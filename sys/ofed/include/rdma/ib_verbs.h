begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2004 Mellanox Technologies Ltd.  All rights reserved.  * Copyright (c) 2004 Infinicon Corporation.  All rights reserved.  * Copyright (c) 2004 Intel Corporation.  All rights reserved.  * Copyright (c) 2004 Topspin Corporation.  All rights reserved.  * Copyright (c) 2004 Voltaire Corporation.  All rights reserved.  * Copyright (c) 2005 Sun Microsystems, Inc. All rights reserved.  * Copyright (c) 2005, 2006, 2007 Cisco Systems.  All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|IB_VERBS_H
argument_list|)
end_if

begin_define
define|#
directive|define
name|IB_VERBS_H
end_define

begin_include
include|#
directive|include
file|<linux/types.h>
end_include

begin_include
include|#
directive|include
file|<linux/device.h>
end_include

begin_include
include|#
directive|include
file|<linux/mm.h>
end_include

begin_include
include|#
directive|include
file|<linux/dma-mapping.h>
end_include

begin_include
include|#
directive|include
file|<linux/kref.h>
end_include

begin_include
include|#
directive|include
file|<linux/list.h>
end_include

begin_include
include|#
directive|include
file|<linux/rwsem.h>
end_include

begin_include
include|#
directive|include
file|<linux/scatterlist.h>
end_include

begin_include
include|#
directive|include
file|<linux/workqueue.h>
end_include

begin_include
include|#
directive|include
file|<linux/socket.h>
end_include

begin_include
include|#
directive|include
file|<linux/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<net/ipv6.h>
end_include

begin_include
include|#
directive|include
file|<net/ip.h>
end_include

begin_include
include|#
directive|include
file|<linux/string.h>
end_include

begin_include
include|#
directive|include
file|<linux/slab.h>
end_include

begin_include
include|#
directive|include
file|<linux/rcupdate.h>
end_include

begin_include
include|#
directive|include
file|<linux/netdevice.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<asm/atomic.h>
end_include

begin_include
include|#
directive|include
file|<asm/uaccess.h>
end_include

begin_struct_decl
struct_decl|struct
name|ifla_vf_info
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|ifla_vf_stats
struct_decl|;
end_struct_decl

begin_decl_stmt
specifier|extern
name|struct
name|workqueue_struct
modifier|*
name|ib_wq
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|workqueue_struct
modifier|*
name|ib_comp_wq
decl_stmt|;
end_decl_stmt

begin_union
union|union
name|ib_gid
block|{
name|u8
name|raw
index|[
literal|16
index|]
decl_stmt|;
struct|struct
block|{
name|__be64
name|subnet_prefix
decl_stmt|;
name|__be64
name|interface_id
decl_stmt|;
block|}
name|global
struct|;
block|}
union|;
end_union

begin_decl_stmt
specifier|extern
name|union
name|ib_gid
name|zgid
decl_stmt|;
end_decl_stmt

begin_enum
enum|enum
name|ib_gid_type
block|{
comment|/* If link layer is Ethernet, this is RoCE V1 */
name|IB_GID_TYPE_IB
init|=
literal|0
block|,
name|IB_GID_TYPE_ROCE
init|=
literal|0
block|,
name|IB_GID_TYPE_ROCE_UDP_ENCAP
init|=
literal|1
block|,
name|IB_GID_TYPE_SIZE
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|ROCE_V2_UDP_DPORT
value|4791
end_define

begin_struct
struct|struct
name|ib_gid_attr
block|{
name|enum
name|ib_gid_type
name|gid_type
decl_stmt|;
name|struct
name|net_device
modifier|*
name|ndev
decl_stmt|;
block|}
struct|;
end_struct

begin_enum
enum|enum
name|rdma_node_type
block|{
comment|/* IB values map to NodeInfo:NodeType. */
name|RDMA_NODE_IB_CA
init|=
literal|1
block|,
name|RDMA_NODE_IB_SWITCH
block|,
name|RDMA_NODE_IB_ROUTER
block|,
name|RDMA_NODE_RNIC
block|,
name|RDMA_NODE_USNIC
block|,
name|RDMA_NODE_USNIC_UDP
block|, }
enum|;
end_enum

begin_enum
enum|enum
block|{
comment|/* set the local administered indication */
name|IB_SA_WELL_KNOWN_GUID
init|=
name|BIT_ULL
argument_list|(
literal|57
argument_list|)
operator||
literal|2
block|, }
enum|;
end_enum

begin_enum
enum|enum
name|rdma_transport_type
block|{
name|RDMA_TRANSPORT_IB
block|,
name|RDMA_TRANSPORT_IWARP
block|,
name|RDMA_TRANSPORT_USNIC
block|,
name|RDMA_TRANSPORT_USNIC_UDP
block|}
enum|;
end_enum

begin_enum
enum|enum
name|rdma_protocol_type
block|{
name|RDMA_PROTOCOL_IB
block|,
name|RDMA_PROTOCOL_IBOE
block|,
name|RDMA_PROTOCOL_IWARP
block|,
name|RDMA_PROTOCOL_USNIC_UDP
block|}
enum|;
end_enum

begin_function_decl
name|__attribute_const__
name|enum
name|rdma_transport_type
name|rdma_node_get_transport
parameter_list|(
name|enum
name|rdma_node_type
name|node_type
parameter_list|)
function_decl|;
end_function_decl

begin_enum
enum|enum
name|rdma_network_type
block|{
name|RDMA_NETWORK_IB
block|,
name|RDMA_NETWORK_ROCE_V1
init|=
name|RDMA_NETWORK_IB
block|,
name|RDMA_NETWORK_IPV4
block|,
name|RDMA_NETWORK_IPV6
block|}
enum|;
end_enum

begin_function
specifier|static
specifier|inline
name|enum
name|ib_gid_type
name|ib_network_to_gid_type
parameter_list|(
name|enum
name|rdma_network_type
name|network_type
parameter_list|)
block|{
if|if
condition|(
name|network_type
operator|==
name|RDMA_NETWORK_IPV4
operator|||
name|network_type
operator|==
name|RDMA_NETWORK_IPV6
condition|)
return|return
name|IB_GID_TYPE_ROCE_UDP_ENCAP
return|;
comment|/* IB_GID_TYPE_IB same as RDMA_NETWORK_ROCE_V1 */
return|return
name|IB_GID_TYPE_IB
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|enum
name|rdma_network_type
name|ib_gid_to_network_type
parameter_list|(
name|enum
name|ib_gid_type
name|gid_type
parameter_list|,
name|union
name|ib_gid
modifier|*
name|gid
parameter_list|)
block|{
if|if
condition|(
name|gid_type
operator|==
name|IB_GID_TYPE_IB
condition|)
return|return
name|RDMA_NETWORK_IB
return|;
if|if
condition|(
name|ipv6_addr_v4mapped
argument_list|(
operator|(
expr|struct
name|in6_addr
operator|*
operator|)
name|gid
argument_list|)
condition|)
return|return
name|RDMA_NETWORK_IPV4
return|;
else|else
return|return
name|RDMA_NETWORK_IPV6
return|;
block|}
end_function

begin_enum
enum|enum
name|rdma_link_layer
block|{
name|IB_LINK_LAYER_UNSPECIFIED
block|,
name|IB_LINK_LAYER_INFINIBAND
block|,
name|IB_LINK_LAYER_ETHERNET
block|, }
enum|;
end_enum

begin_enum
enum|enum
name|ib_device_cap_flags
block|{
name|IB_DEVICE_RESIZE_MAX_WR
init|=
operator|(
literal|1
operator|<<
literal|0
operator|)
block|,
name|IB_DEVICE_BAD_PKEY_CNTR
init|=
operator|(
literal|1
operator|<<
literal|1
operator|)
block|,
name|IB_DEVICE_BAD_QKEY_CNTR
init|=
operator|(
literal|1
operator|<<
literal|2
operator|)
block|,
name|IB_DEVICE_RAW_MULTI
init|=
operator|(
literal|1
operator|<<
literal|3
operator|)
block|,
name|IB_DEVICE_AUTO_PATH_MIG
init|=
operator|(
literal|1
operator|<<
literal|4
operator|)
block|,
name|IB_DEVICE_CHANGE_PHY_PORT
init|=
operator|(
literal|1
operator|<<
literal|5
operator|)
block|,
name|IB_DEVICE_UD_AV_PORT_ENFORCE
init|=
operator|(
literal|1
operator|<<
literal|6
operator|)
block|,
name|IB_DEVICE_CURR_QP_STATE_MOD
init|=
operator|(
literal|1
operator|<<
literal|7
operator|)
block|,
name|IB_DEVICE_SHUTDOWN_PORT
init|=
operator|(
literal|1
operator|<<
literal|8
operator|)
block|,
name|IB_DEVICE_INIT_TYPE
init|=
operator|(
literal|1
operator|<<
literal|9
operator|)
block|,
name|IB_DEVICE_PORT_ACTIVE_EVENT
init|=
operator|(
literal|1
operator|<<
literal|10
operator|)
block|,
name|IB_DEVICE_SYS_IMAGE_GUID
init|=
operator|(
literal|1
operator|<<
literal|11
operator|)
block|,
name|IB_DEVICE_RC_RNR_NAK_GEN
init|=
operator|(
literal|1
operator|<<
literal|12
operator|)
block|,
name|IB_DEVICE_SRQ_RESIZE
init|=
operator|(
literal|1
operator|<<
literal|13
operator|)
block|,
name|IB_DEVICE_N_NOTIFY_CQ
init|=
operator|(
literal|1
operator|<<
literal|14
operator|)
block|,
comment|/* 	 * This device supports a per-device lkey or stag that can be 	 * used without performing a memory registration for the local 	 * memory.  Note that ULPs should never check this flag, but 	 * instead of use the local_dma_lkey flag in the ib_pd structure, 	 * which will always contain a usable lkey. 	 */
name|IB_DEVICE_LOCAL_DMA_LKEY
init|=
operator|(
literal|1
operator|<<
literal|15
operator|)
block|,
name|IB_DEVICE_RESERVED
comment|/* old SEND_W_INV */
init|=
operator|(
literal|1
operator|<<
literal|16
operator|)
block|,
name|IB_DEVICE_MEM_WINDOW
init|=
operator|(
literal|1
operator|<<
literal|17
operator|)
block|,
comment|/* 	 * Devices should set IB_DEVICE_UD_IP_SUM if they support 	 * insertion of UDP and TCP checksum on outgoing UD IPoIB 	 * messages and can verify the validity of checksum for 	 * incoming messages.  Setting this flag implies that the 	 * IPoIB driver may set NETIF_F_IP_CSUM for datagram mode. 	 */
name|IB_DEVICE_UD_IP_CSUM
init|=
operator|(
literal|1
operator|<<
literal|18
operator|)
block|,
name|IB_DEVICE_UD_TSO
init|=
operator|(
literal|1
operator|<<
literal|19
operator|)
block|,
name|IB_DEVICE_XRC
init|=
operator|(
literal|1
operator|<<
literal|20
operator|)
block|,
comment|/* 	 * This device supports the IB "base memory management extension", 	 * which includes support for fast registrations (IB_WR_REG_MR, 	 * IB_WR_LOCAL_INV and IB_WR_SEND_WITH_INV verbs).  This flag should 	 * also be set by any iWarp device which must support FRs to comply 	 * to the iWarp verbs spec.  iWarp devices also support the 	 * IB_WR_RDMA_READ_WITH_INV verb for RDMA READs that invalidate the 	 * stag. 	 */
name|IB_DEVICE_MEM_MGT_EXTENSIONS
init|=
operator|(
literal|1
operator|<<
literal|21
operator|)
block|,
name|IB_DEVICE_BLOCK_MULTICAST_LOOPBACK
init|=
operator|(
literal|1
operator|<<
literal|22
operator|)
block|,
name|IB_DEVICE_MEM_WINDOW_TYPE_2A
init|=
operator|(
literal|1
operator|<<
literal|23
operator|)
block|,
name|IB_DEVICE_MEM_WINDOW_TYPE_2B
init|=
operator|(
literal|1
operator|<<
literal|24
operator|)
block|,
name|IB_DEVICE_RC_IP_CSUM
init|=
operator|(
literal|1
operator|<<
literal|25
operator|)
block|,
name|IB_DEVICE_RAW_IP_CSUM
init|=
operator|(
literal|1
operator|<<
literal|26
operator|)
block|,
comment|/* 	 * Devices should set IB_DEVICE_CROSS_CHANNEL if they 	 * support execution of WQEs that involve synchronization 	 * of I/O operations with single completion queue managed 	 * by hardware. 	 */
name|IB_DEVICE_CROSS_CHANNEL
init|=
operator|(
literal|1
operator|<<
literal|27
operator|)
block|,
name|IB_DEVICE_MANAGED_FLOW_STEERING
init|=
operator|(
literal|1
operator|<<
literal|29
operator|)
block|,
name|IB_DEVICE_SIGNATURE_HANDOVER
init|=
operator|(
literal|1
operator|<<
literal|30
operator|)
block|,
name|IB_DEVICE_ON_DEMAND_PAGING
init|=
operator|(
literal|1ULL
operator|<<
literal|31
operator|)
block|,
name|IB_DEVICE_SG_GAPS_REG
init|=
operator|(
literal|1ULL
operator|<<
literal|32
operator|)
block|,
name|IB_DEVICE_VIRTUAL_FUNCTION
init|=
operator|(
literal|1ULL
operator|<<
literal|33
operator|)
block|,
name|IB_DEVICE_RAW_SCATTER_FCS
init|=
operator|(
literal|1ULL
operator|<<
literal|34
operator|)
block|, }
enum|;
end_enum

begin_enum
enum|enum
name|ib_signature_prot_cap
block|{
name|IB_PROT_T10DIF_TYPE_1
init|=
literal|1
block|,
name|IB_PROT_T10DIF_TYPE_2
init|=
literal|1
operator|<<
literal|1
block|,
name|IB_PROT_T10DIF_TYPE_3
init|=
literal|1
operator|<<
literal|2
block|, }
enum|;
end_enum

begin_enum
enum|enum
name|ib_signature_guard_cap
block|{
name|IB_GUARD_T10DIF_CRC
init|=
literal|1
block|,
name|IB_GUARD_T10DIF_CSUM
init|=
literal|1
operator|<<
literal|1
block|, }
enum|;
end_enum

begin_enum
enum|enum
name|ib_atomic_cap
block|{
name|IB_ATOMIC_NONE
block|,
name|IB_ATOMIC_HCA
block|,
name|IB_ATOMIC_GLOB
block|}
enum|;
end_enum

begin_enum
enum|enum
name|ib_odp_general_cap_bits
block|{
name|IB_ODP_SUPPORT
init|=
literal|1
operator|<<
literal|0
block|, }
enum|;
end_enum

begin_enum
enum|enum
name|ib_odp_transport_cap_bits
block|{
name|IB_ODP_SUPPORT_SEND
init|=
literal|1
operator|<<
literal|0
block|,
name|IB_ODP_SUPPORT_RECV
init|=
literal|1
operator|<<
literal|1
block|,
name|IB_ODP_SUPPORT_WRITE
init|=
literal|1
operator|<<
literal|2
block|,
name|IB_ODP_SUPPORT_READ
init|=
literal|1
operator|<<
literal|3
block|,
name|IB_ODP_SUPPORT_ATOMIC
init|=
literal|1
operator|<<
literal|4
block|, }
enum|;
end_enum

begin_struct
struct|struct
name|ib_odp_caps
block|{
name|uint64_t
name|general_caps
decl_stmt|;
struct|struct
block|{
name|uint32_t
name|rc_odp_caps
decl_stmt|;
name|uint32_t
name|uc_odp_caps
decl_stmt|;
name|uint32_t
name|ud_odp_caps
decl_stmt|;
block|}
name|per_transport_caps
struct|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ib_rss_caps
block|{
comment|/* Corresponding bit will be set if qp type from 	 * 'enum ib_qp_type' is supported, e.g. 	 * supported_qpts |= 1<< IB_QPT_UD 	 */
name|u32
name|supported_qpts
decl_stmt|;
name|u32
name|max_rwq_indirection_tables
decl_stmt|;
name|u32
name|max_rwq_indirection_table_size
decl_stmt|;
block|}
struct|;
end_struct

begin_enum
enum|enum
name|ib_cq_creation_flags
block|{
name|IB_CQ_FLAGS_TIMESTAMP_COMPLETION
init|=
literal|1
operator|<<
literal|0
block|,
name|IB_CQ_FLAGS_IGNORE_OVERRUN
init|=
literal|1
operator|<<
literal|1
block|, }
enum|;
end_enum

begin_struct
struct|struct
name|ib_cq_init_attr
block|{
name|unsigned
name|int
name|cqe
decl_stmt|;
name|int
name|comp_vector
decl_stmt|;
name|u32
name|flags
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ib_device_attr
block|{
name|u64
name|fw_ver
decl_stmt|;
name|__be64
name|sys_image_guid
decl_stmt|;
name|u64
name|max_mr_size
decl_stmt|;
name|u64
name|page_size_cap
decl_stmt|;
name|u32
name|vendor_id
decl_stmt|;
name|u32
name|vendor_part_id
decl_stmt|;
name|u32
name|hw_ver
decl_stmt|;
name|int
name|max_qp
decl_stmt|;
name|int
name|max_qp_wr
decl_stmt|;
name|u64
name|device_cap_flags
decl_stmt|;
name|int
name|max_sge
decl_stmt|;
name|int
name|max_sge_rd
decl_stmt|;
name|int
name|max_cq
decl_stmt|;
name|int
name|max_cqe
decl_stmt|;
name|int
name|max_mr
decl_stmt|;
name|int
name|max_pd
decl_stmt|;
name|int
name|max_qp_rd_atom
decl_stmt|;
name|int
name|max_ee_rd_atom
decl_stmt|;
name|int
name|max_res_rd_atom
decl_stmt|;
name|int
name|max_qp_init_rd_atom
decl_stmt|;
name|int
name|max_ee_init_rd_atom
decl_stmt|;
name|enum
name|ib_atomic_cap
name|atomic_cap
decl_stmt|;
name|enum
name|ib_atomic_cap
name|masked_atomic_cap
decl_stmt|;
name|int
name|max_ee
decl_stmt|;
name|int
name|max_rdd
decl_stmt|;
name|int
name|max_mw
decl_stmt|;
name|int
name|max_raw_ipv6_qp
decl_stmt|;
name|int
name|max_raw_ethy_qp
decl_stmt|;
name|int
name|max_mcast_grp
decl_stmt|;
name|int
name|max_mcast_qp_attach
decl_stmt|;
name|int
name|max_total_mcast_qp_attach
decl_stmt|;
name|int
name|max_ah
decl_stmt|;
name|int
name|max_fmr
decl_stmt|;
name|int
name|max_map_per_fmr
decl_stmt|;
name|int
name|max_srq
decl_stmt|;
name|int
name|max_srq_wr
decl_stmt|;
name|int
name|max_srq_sge
decl_stmt|;
name|unsigned
name|int
name|max_fast_reg_page_list_len
decl_stmt|;
name|u16
name|max_pkeys
decl_stmt|;
name|u8
name|local_ca_ack_delay
decl_stmt|;
name|int
name|sig_prot_cap
decl_stmt|;
name|int
name|sig_guard_cap
decl_stmt|;
name|struct
name|ib_odp_caps
name|odp_caps
decl_stmt|;
name|uint64_t
name|timestamp_mask
decl_stmt|;
name|uint64_t
name|hca_core_clock
decl_stmt|;
comment|/* in KHZ */
name|struct
name|ib_rss_caps
name|rss_caps
decl_stmt|;
name|u32
name|max_wq_type_rq
decl_stmt|;
block|}
struct|;
end_struct

begin_enum
enum|enum
name|ib_mtu
block|{
name|IB_MTU_256
init|=
literal|1
block|,
name|IB_MTU_512
init|=
literal|2
block|,
name|IB_MTU_1024
init|=
literal|3
block|,
name|IB_MTU_2048
init|=
literal|4
block|,
name|IB_MTU_4096
init|=
literal|5
block|}
enum|;
end_enum

begin_function
specifier|static
specifier|inline
name|int
name|ib_mtu_enum_to_int
parameter_list|(
name|enum
name|ib_mtu
name|mtu
parameter_list|)
block|{
switch|switch
condition|(
name|mtu
condition|)
block|{
case|case
name|IB_MTU_256
case|:
return|return
literal|256
return|;
case|case
name|IB_MTU_512
case|:
return|return
literal|512
return|;
case|case
name|IB_MTU_1024
case|:
return|return
literal|1024
return|;
case|case
name|IB_MTU_2048
case|:
return|return
literal|2048
return|;
case|case
name|IB_MTU_4096
case|:
return|return
literal|4096
return|;
default|default:
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_enum
enum|enum
name|ib_port_state
block|{
name|IB_PORT_NOP
init|=
literal|0
block|,
name|IB_PORT_DOWN
init|=
literal|1
block|,
name|IB_PORT_INIT
init|=
literal|2
block|,
name|IB_PORT_ARMED
init|=
literal|3
block|,
name|IB_PORT_ACTIVE
init|=
literal|4
block|,
name|IB_PORT_ACTIVE_DEFER
init|=
literal|5
block|,
name|IB_PORT_DUMMY
init|=
operator|-
literal|1
block|,
comment|/* force enum signed */
block|}
enum|;
end_enum

begin_enum
enum|enum
name|ib_port_cap_flags
block|{
name|IB_PORT_SM
init|=
literal|1
operator|<<
literal|1
block|,
name|IB_PORT_NOTICE_SUP
init|=
literal|1
operator|<<
literal|2
block|,
name|IB_PORT_TRAP_SUP
init|=
literal|1
operator|<<
literal|3
block|,
name|IB_PORT_OPT_IPD_SUP
init|=
literal|1
operator|<<
literal|4
block|,
name|IB_PORT_AUTO_MIGR_SUP
init|=
literal|1
operator|<<
literal|5
block|,
name|IB_PORT_SL_MAP_SUP
init|=
literal|1
operator|<<
literal|6
block|,
name|IB_PORT_MKEY_NVRAM
init|=
literal|1
operator|<<
literal|7
block|,
name|IB_PORT_PKEY_NVRAM
init|=
literal|1
operator|<<
literal|8
block|,
name|IB_PORT_LED_INFO_SUP
init|=
literal|1
operator|<<
literal|9
block|,
name|IB_PORT_SM_DISABLED
init|=
literal|1
operator|<<
literal|10
block|,
name|IB_PORT_SYS_IMAGE_GUID_SUP
init|=
literal|1
operator|<<
literal|11
block|,
name|IB_PORT_PKEY_SW_EXT_PORT_TRAP_SUP
init|=
literal|1
operator|<<
literal|12
block|,
name|IB_PORT_EXTENDED_SPEEDS_SUP
init|=
literal|1
operator|<<
literal|14
block|,
name|IB_PORT_CM_SUP
init|=
literal|1
operator|<<
literal|16
block|,
name|IB_PORT_SNMP_TUNNEL_SUP
init|=
literal|1
operator|<<
literal|17
block|,
name|IB_PORT_REINIT_SUP
init|=
literal|1
operator|<<
literal|18
block|,
name|IB_PORT_DEVICE_MGMT_SUP
init|=
literal|1
operator|<<
literal|19
block|,
name|IB_PORT_VENDOR_CLASS_SUP
init|=
literal|1
operator|<<
literal|20
block|,
name|IB_PORT_DR_NOTICE_SUP
init|=
literal|1
operator|<<
literal|21
block|,
name|IB_PORT_CAP_MASK_NOTICE_SUP
init|=
literal|1
operator|<<
literal|22
block|,
name|IB_PORT_BOOT_MGMT_SUP
init|=
literal|1
operator|<<
literal|23
block|,
name|IB_PORT_LINK_LATENCY_SUP
init|=
literal|1
operator|<<
literal|24
block|,
name|IB_PORT_CLIENT_REG_SUP
init|=
literal|1
operator|<<
literal|25
block|,
name|IB_PORT_IP_BASED_GIDS
init|=
literal|1
operator|<<
literal|26
block|, }
enum|;
end_enum

begin_enum
enum|enum
name|ib_port_width
block|{
name|IB_WIDTH_1X
init|=
literal|1
block|,
name|IB_WIDTH_4X
init|=
literal|2
block|,
name|IB_WIDTH_8X
init|=
literal|4
block|,
name|IB_WIDTH_12X
init|=
literal|8
block|}
enum|;
end_enum

begin_function
specifier|static
specifier|inline
name|int
name|ib_width_enum_to_int
parameter_list|(
name|enum
name|ib_port_width
name|width
parameter_list|)
block|{
switch|switch
condition|(
name|width
condition|)
block|{
case|case
name|IB_WIDTH_1X
case|:
return|return
literal|1
return|;
case|case
name|IB_WIDTH_4X
case|:
return|return
literal|4
return|;
case|case
name|IB_WIDTH_8X
case|:
return|return
literal|8
return|;
case|case
name|IB_WIDTH_12X
case|:
return|return
literal|12
return|;
default|default:
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_enum
enum|enum
name|ib_port_speed
block|{
name|IB_SPEED_SDR
init|=
literal|1
block|,
name|IB_SPEED_DDR
init|=
literal|2
block|,
name|IB_SPEED_QDR
init|=
literal|4
block|,
name|IB_SPEED_FDR10
init|=
literal|8
block|,
name|IB_SPEED_FDR
init|=
literal|16
block|,
name|IB_SPEED_EDR
init|=
literal|32
block|}
enum|;
end_enum

begin_comment
comment|/**  * struct rdma_hw_stats  * @timestamp - Used by the core code to track when the last update was  * @lifespan - Used by the core code to determine how old the counters  *   should be before being updated again.  Stored in jiffies, defaults  *   to 10 milliseconds, drivers can override the default be specifying  *   their own value during their allocation routine.  * @name - Array of pointers to static names used for the counters in  *   directory.  * @num_counters - How many hardware counters there are.  If name is  *   shorter than this number, a kernel oops will result.  Driver authors  *   are encouraged to leave BUILD_BUG_ON(ARRAY_SIZE(@name)< num_counters)  *   in their code to prevent this.  * @value - Array of u64 counters that are accessed by the sysfs code and  *   filled in by the drivers get_stats routine  */
end_comment

begin_struct
struct|struct
name|rdma_hw_stats
block|{
name|unsigned
name|long
name|timestamp
decl_stmt|;
name|unsigned
name|long
name|lifespan
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|names
decl_stmt|;
name|int
name|num_counters
decl_stmt|;
name|u64
name|value
index|[]
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|RDMA_HW_STATS_DEFAULT_LIFESPAN
value|10
end_define

begin_comment
comment|/**  * rdma_alloc_hw_stats_struct - Helper function to allocate dynamic struct  *   for drivers.  * @names - Array of static const char *  * @num_counters - How many elements in array  * @lifespan - How many milliseconds between updates  */
end_comment

begin_function
specifier|static
specifier|inline
name|struct
name|rdma_hw_stats
modifier|*
name|rdma_alloc_hw_stats_struct
parameter_list|(
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|names
parameter_list|,
name|int
name|num_counters
parameter_list|,
name|unsigned
name|long
name|lifespan
parameter_list|)
block|{
name|struct
name|rdma_hw_stats
modifier|*
name|stats
decl_stmt|;
name|stats
operator|=
name|kzalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|stats
argument_list|)
operator|+
name|num_counters
operator|*
sizeof|sizeof
argument_list|(
name|u64
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stats
condition|)
return|return
name|NULL
return|;
name|stats
operator|->
name|names
operator|=
name|names
expr_stmt|;
name|stats
operator|->
name|num_counters
operator|=
name|num_counters
expr_stmt|;
name|stats
operator|->
name|lifespan
operator|=
name|msecs_to_jiffies
argument_list|(
name|lifespan
argument_list|)
expr_stmt|;
return|return
name|stats
return|;
block|}
end_function

begin_comment
comment|/* Define bits for the various functionality this port needs to be supported by  * the core.  */
end_comment

begin_comment
comment|/* Management                           0x00000FFF */
end_comment

begin_define
define|#
directive|define
name|RDMA_CORE_CAP_IB_MAD
value|0x00000001
end_define

begin_define
define|#
directive|define
name|RDMA_CORE_CAP_IB_SMI
value|0x00000002
end_define

begin_define
define|#
directive|define
name|RDMA_CORE_CAP_IB_CM
value|0x00000004
end_define

begin_define
define|#
directive|define
name|RDMA_CORE_CAP_IW_CM
value|0x00000008
end_define

begin_define
define|#
directive|define
name|RDMA_CORE_CAP_IB_SA
value|0x00000010
end_define

begin_define
define|#
directive|define
name|RDMA_CORE_CAP_OPA_MAD
value|0x00000020
end_define

begin_comment
comment|/* Address format                       0x000FF000 */
end_comment

begin_define
define|#
directive|define
name|RDMA_CORE_CAP_AF_IB
value|0x00001000
end_define

begin_define
define|#
directive|define
name|RDMA_CORE_CAP_ETH_AH
value|0x00002000
end_define

begin_comment
comment|/* Protocol                             0xFFF00000 */
end_comment

begin_define
define|#
directive|define
name|RDMA_CORE_CAP_PROT_IB
value|0x00100000
end_define

begin_define
define|#
directive|define
name|RDMA_CORE_CAP_PROT_ROCE
value|0x00200000
end_define

begin_define
define|#
directive|define
name|RDMA_CORE_CAP_PROT_IWARP
value|0x00400000
end_define

begin_define
define|#
directive|define
name|RDMA_CORE_CAP_PROT_ROCE_UDP_ENCAP
value|0x00800000
end_define

begin_define
define|#
directive|define
name|RDMA_CORE_PORT_IBA_IB
value|(RDMA_CORE_CAP_PROT_IB  \ 					| RDMA_CORE_CAP_IB_MAD \ 					| RDMA_CORE_CAP_IB_SMI \ 					| RDMA_CORE_CAP_IB_CM  \ 					| RDMA_CORE_CAP_IB_SA  \ 					| RDMA_CORE_CAP_AF_IB)
end_define

begin_define
define|#
directive|define
name|RDMA_CORE_PORT_IBA_ROCE
value|(RDMA_CORE_CAP_PROT_ROCE \ 					| RDMA_CORE_CAP_IB_MAD  \ 					| RDMA_CORE_CAP_IB_CM   \ 					| RDMA_CORE_CAP_AF_IB   \ 					| RDMA_CORE_CAP_ETH_AH)
end_define

begin_define
define|#
directive|define
name|RDMA_CORE_PORT_IBA_ROCE_UDP_ENCAP
define|\
value|(RDMA_CORE_CAP_PROT_ROCE_UDP_ENCAP \ 					| RDMA_CORE_CAP_IB_MAD  \ 					| RDMA_CORE_CAP_IB_CM   \ 					| RDMA_CORE_CAP_AF_IB   \ 					| RDMA_CORE_CAP_ETH_AH)
end_define

begin_define
define|#
directive|define
name|RDMA_CORE_PORT_IWARP
value|(RDMA_CORE_CAP_PROT_IWARP \ 					| RDMA_CORE_CAP_IW_CM)
end_define

begin_define
define|#
directive|define
name|RDMA_CORE_PORT_INTEL_OPA
value|(RDMA_CORE_PORT_IBA_IB  \ 					| RDMA_CORE_CAP_OPA_MAD)
end_define

begin_struct
struct|struct
name|ib_port_attr
block|{
name|u64
name|subnet_prefix
decl_stmt|;
name|enum
name|ib_port_state
name|state
decl_stmt|;
name|enum
name|ib_mtu
name|max_mtu
decl_stmt|;
name|enum
name|ib_mtu
name|active_mtu
decl_stmt|;
name|int
name|gid_tbl_len
decl_stmt|;
name|u32
name|port_cap_flags
decl_stmt|;
name|u32
name|max_msg_sz
decl_stmt|;
name|u32
name|bad_pkey_cntr
decl_stmt|;
name|u32
name|qkey_viol_cntr
decl_stmt|;
name|u16
name|pkey_tbl_len
decl_stmt|;
name|u16
name|lid
decl_stmt|;
name|u16
name|sm_lid
decl_stmt|;
name|u8
name|lmc
decl_stmt|;
name|u8
name|max_vl_num
decl_stmt|;
name|u8
name|sm_sl
decl_stmt|;
name|u8
name|subnet_timeout
decl_stmt|;
name|u8
name|init_type_reply
decl_stmt|;
name|u8
name|active_width
decl_stmt|;
name|u8
name|active_speed
decl_stmt|;
name|u8
name|phys_state
decl_stmt|;
name|bool
name|grh_required
decl_stmt|;
block|}
struct|;
end_struct

begin_enum
enum|enum
name|ib_device_modify_flags
block|{
name|IB_DEVICE_MODIFY_SYS_IMAGE_GUID
init|=
literal|1
operator|<<
literal|0
block|,
name|IB_DEVICE_MODIFY_NODE_DESC
init|=
literal|1
operator|<<
literal|1
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|IB_DEVICE_NODE_DESC_MAX
value|64
end_define

begin_struct
struct|struct
name|ib_device_modify
block|{
name|u64
name|sys_image_guid
decl_stmt|;
name|char
name|node_desc
index|[
name|IB_DEVICE_NODE_DESC_MAX
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_enum
enum|enum
name|ib_port_modify_flags
block|{
name|IB_PORT_SHUTDOWN
init|=
literal|1
block|,
name|IB_PORT_INIT_TYPE
init|=
operator|(
literal|1
operator|<<
literal|2
operator|)
block|,
name|IB_PORT_RESET_QKEY_CNTR
init|=
operator|(
literal|1
operator|<<
literal|3
operator|)
block|}
enum|;
end_enum

begin_struct
struct|struct
name|ib_port_modify
block|{
name|u32
name|set_port_cap_mask
decl_stmt|;
name|u32
name|clr_port_cap_mask
decl_stmt|;
name|u8
name|init_type
decl_stmt|;
block|}
struct|;
end_struct

begin_enum
enum|enum
name|ib_event_type
block|{
name|IB_EVENT_CQ_ERR
block|,
name|IB_EVENT_QP_FATAL
block|,
name|IB_EVENT_QP_REQ_ERR
block|,
name|IB_EVENT_QP_ACCESS_ERR
block|,
name|IB_EVENT_COMM_EST
block|,
name|IB_EVENT_SQ_DRAINED
block|,
name|IB_EVENT_PATH_MIG
block|,
name|IB_EVENT_PATH_MIG_ERR
block|,
name|IB_EVENT_DEVICE_FATAL
block|,
name|IB_EVENT_PORT_ACTIVE
block|,
name|IB_EVENT_PORT_ERR
block|,
name|IB_EVENT_LID_CHANGE
block|,
name|IB_EVENT_PKEY_CHANGE
block|,
name|IB_EVENT_SM_CHANGE
block|,
name|IB_EVENT_SRQ_ERR
block|,
name|IB_EVENT_SRQ_LIMIT_REACHED
block|,
name|IB_EVENT_QP_LAST_WQE_REACHED
block|,
name|IB_EVENT_CLIENT_REREGISTER
block|,
name|IB_EVENT_GID_CHANGE
block|,
name|IB_EVENT_WQ_FATAL
block|, }
enum|;
end_enum

begin_function_decl
specifier|const
name|char
modifier|*
name|__attribute_const__
name|ib_event_msg
parameter_list|(
name|enum
name|ib_event_type
name|event
parameter_list|)
function_decl|;
end_function_decl

begin_struct
struct|struct
name|ib_event
block|{
name|struct
name|ib_device
modifier|*
name|device
decl_stmt|;
union|union
block|{
name|struct
name|ib_cq
modifier|*
name|cq
decl_stmt|;
name|struct
name|ib_qp
modifier|*
name|qp
decl_stmt|;
name|struct
name|ib_srq
modifier|*
name|srq
decl_stmt|;
name|struct
name|ib_wq
modifier|*
name|wq
decl_stmt|;
name|u8
name|port_num
decl_stmt|;
block|}
name|element
union|;
name|enum
name|ib_event_type
name|event
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ib_event_handler
block|{
name|struct
name|ib_device
modifier|*
name|device
decl_stmt|;
name|void
function_decl|(
modifier|*
name|handler
function_decl|)
parameter_list|(
name|struct
name|ib_event_handler
modifier|*
parameter_list|,
name|struct
name|ib_event
modifier|*
parameter_list|)
function_decl|;
name|struct
name|list_head
name|list
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|INIT_IB_EVENT_HANDLER
parameter_list|(
name|_ptr
parameter_list|,
name|_device
parameter_list|,
name|_handler
parameter_list|)
define|\
value|do {							\ 		(_ptr)->device  = _device;			\ 		(_ptr)->handler = _handler;			\ 		INIT_LIST_HEAD(&(_ptr)->list);			\ 	} while (0)
end_define

begin_struct
struct|struct
name|ib_global_route
block|{
name|union
name|ib_gid
name|dgid
decl_stmt|;
name|u32
name|flow_label
decl_stmt|;
name|u8
name|sgid_index
decl_stmt|;
name|u8
name|hop_limit
decl_stmt|;
name|u8
name|traffic_class
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ib_grh
block|{
name|__be32
name|version_tclass_flow
decl_stmt|;
name|__be16
name|paylen
decl_stmt|;
name|u8
name|next_hdr
decl_stmt|;
name|u8
name|hop_limit
decl_stmt|;
name|union
name|ib_gid
name|sgid
decl_stmt|;
name|union
name|ib_gid
name|dgid
decl_stmt|;
block|}
struct|;
end_struct

begin_union
union|union
name|rdma_network_hdr
block|{
name|struct
name|ib_grh
name|ibgrh
decl_stmt|;
struct|struct
block|{
comment|/* The IB spec states that if it's IPv4, the header 		 * is located in the last 20 bytes of the header. 		 */
name|u8
name|reserved
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|ip
name|roce4grh
decl_stmt|;
block|}
struct|;
block|}
union|;
end_union

begin_enum
enum|enum
block|{
name|IB_MULTICAST_QPN
init|=
literal|0xffffff
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|IB_LID_PERMISSIVE
value|cpu_to_be16(0xFFFF)
end_define

begin_define
define|#
directive|define
name|IB_MULTICAST_LID_BASE
value|cpu_to_be16(0xC000)
end_define

begin_enum
enum|enum
name|ib_ah_flags
block|{
name|IB_AH_GRH
init|=
literal|1
block|}
enum|;
end_enum

begin_enum
enum|enum
name|ib_rate
block|{
name|IB_RATE_PORT_CURRENT
init|=
literal|0
block|,
name|IB_RATE_2_5_GBPS
init|=
literal|2
block|,
name|IB_RATE_5_GBPS
init|=
literal|5
block|,
name|IB_RATE_10_GBPS
init|=
literal|3
block|,
name|IB_RATE_20_GBPS
init|=
literal|6
block|,
name|IB_RATE_30_GBPS
init|=
literal|4
block|,
name|IB_RATE_40_GBPS
init|=
literal|7
block|,
name|IB_RATE_60_GBPS
init|=
literal|8
block|,
name|IB_RATE_80_GBPS
init|=
literal|9
block|,
name|IB_RATE_120_GBPS
init|=
literal|10
block|,
name|IB_RATE_14_GBPS
init|=
literal|11
block|,
name|IB_RATE_56_GBPS
init|=
literal|12
block|,
name|IB_RATE_112_GBPS
init|=
literal|13
block|,
name|IB_RATE_168_GBPS
init|=
literal|14
block|,
name|IB_RATE_25_GBPS
init|=
literal|15
block|,
name|IB_RATE_100_GBPS
init|=
literal|16
block|,
name|IB_RATE_200_GBPS
init|=
literal|17
block|,
name|IB_RATE_300_GBPS
init|=
literal|18
block|}
enum|;
end_enum

begin_comment
comment|/**  * ib_rate_to_mult - Convert the IB rate enum to a multiple of the  * base rate of 2.5 Gbit/sec.  For example, IB_RATE_5_GBPS will be  * converted to 2, since 5 Gbit/sec is 2 * 2.5 Gbit/sec.  * @rate: rate to convert.  */
end_comment

begin_function_decl
name|__attribute_const__
name|int
name|ib_rate_to_mult
parameter_list|(
name|enum
name|ib_rate
name|rate
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * ib_rate_to_mbps - Convert the IB rate enum to Mbps.  * For example, IB_RATE_2_5_GBPS will be converted to 2500.  * @rate: rate to convert.  */
end_comment

begin_function_decl
name|__attribute_const__
name|int
name|ib_rate_to_mbps
parameter_list|(
name|enum
name|ib_rate
name|rate
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * enum ib_mr_type - memory region type  * @IB_MR_TYPE_MEM_REG:       memory region that is used for  *                            normal registration  * @IB_MR_TYPE_SIGNATURE:     memory region that is used for  *                            signature operations (data-integrity  *                            capable regions)  * @IB_MR_TYPE_SG_GAPS:       memory region that is capable to  *                            register any arbitrary sg lists (without  *                            the normal mr constraints - see  *                            ib_map_mr_sg)  */
end_comment

begin_enum
enum|enum
name|ib_mr_type
block|{
name|IB_MR_TYPE_MEM_REG
block|,
name|IB_MR_TYPE_SIGNATURE
block|,
name|IB_MR_TYPE_SG_GAPS
block|, }
enum|;
end_enum

begin_comment
comment|/**  * Signature types  * IB_SIG_TYPE_NONE: Unprotected.  * IB_SIG_TYPE_T10_DIF: Type T10-DIF  */
end_comment

begin_enum
enum|enum
name|ib_signature_type
block|{
name|IB_SIG_TYPE_NONE
block|,
name|IB_SIG_TYPE_T10_DIF
block|, }
enum|;
end_enum

begin_comment
comment|/**  * Signature T10-DIF block-guard types  * IB_T10DIF_CRC: Corresponds to T10-PI mandated CRC checksum rules.  * IB_T10DIF_CSUM: Corresponds to IP checksum rules.  */
end_comment

begin_enum
enum|enum
name|ib_t10_dif_bg_type
block|{
name|IB_T10DIF_CRC
block|,
name|IB_T10DIF_CSUM
block|}
enum|;
end_enum

begin_comment
comment|/**  * struct ib_t10_dif_domain - Parameters specific for T10-DIF  *     domain.  * @bg_type: T10-DIF block guard type (CRC|CSUM)  * @pi_interval: protection information interval.  * @bg: seed of guard computation.  * @app_tag: application tag of guard block  * @ref_tag: initial guard block reference tag.  * @ref_remap: Indicate wethear the reftag increments each block  * @app_escape: Indicate to skip block check if apptag=0xffff  * @ref_escape: Indicate to skip block check if reftag=0xffffffff  * @apptag_check_mask: check bitmask of application tag.  */
end_comment

begin_struct
struct|struct
name|ib_t10_dif_domain
block|{
name|enum
name|ib_t10_dif_bg_type
name|bg_type
decl_stmt|;
name|u16
name|pi_interval
decl_stmt|;
name|u16
name|bg
decl_stmt|;
name|u16
name|app_tag
decl_stmt|;
name|u32
name|ref_tag
decl_stmt|;
name|bool
name|ref_remap
decl_stmt|;
name|bool
name|app_escape
decl_stmt|;
name|bool
name|ref_escape
decl_stmt|;
name|u16
name|apptag_check_mask
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/**  * struct ib_sig_domain - Parameters for signature domain  * @sig_type: specific signauture type  * @sig: union of all signature domain attributes that may  *     be used to set domain layout.  */
end_comment

begin_struct
struct|struct
name|ib_sig_domain
block|{
name|enum
name|ib_signature_type
name|sig_type
decl_stmt|;
union|union
block|{
name|struct
name|ib_t10_dif_domain
name|dif
decl_stmt|;
block|}
name|sig
union|;
block|}
struct|;
end_struct

begin_comment
comment|/**  * struct ib_sig_attrs - Parameters for signature handover operation  * @check_mask: bitmask for signature byte check (8 bytes)  * @mem: memory domain layout desciptor.  * @wire: wire domain layout desciptor.  */
end_comment

begin_struct
struct|struct
name|ib_sig_attrs
block|{
name|u8
name|check_mask
decl_stmt|;
name|struct
name|ib_sig_domain
name|mem
decl_stmt|;
name|struct
name|ib_sig_domain
name|wire
decl_stmt|;
block|}
struct|;
end_struct

begin_enum
enum|enum
name|ib_sig_err_type
block|{
name|IB_SIG_BAD_GUARD
block|,
name|IB_SIG_BAD_REFTAG
block|,
name|IB_SIG_BAD_APPTAG
block|, }
enum|;
end_enum

begin_comment
comment|/**  * struct ib_sig_err - signature error descriptor  */
end_comment

begin_struct
struct|struct
name|ib_sig_err
block|{
name|enum
name|ib_sig_err_type
name|err_type
decl_stmt|;
name|u32
name|expected
decl_stmt|;
name|u32
name|actual
decl_stmt|;
name|u64
name|sig_err_offset
decl_stmt|;
name|u32
name|key
decl_stmt|;
block|}
struct|;
end_struct

begin_enum
enum|enum
name|ib_mr_status_check
block|{
name|IB_MR_CHECK_SIG_STATUS
init|=
literal|1
block|, }
enum|;
end_enum

begin_comment
comment|/**  * struct ib_mr_status - Memory region status container  *  * @fail_status: Bitmask of MR checks status. For each  *     failed check a corresponding status bit is set.  * @sig_err: Additional info for IB_MR_CEHCK_SIG_STATUS  *     failure.  */
end_comment

begin_struct
struct|struct
name|ib_mr_status
block|{
name|u32
name|fail_status
decl_stmt|;
name|struct
name|ib_sig_err
name|sig_err
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/**  * mult_to_ib_rate - Convert a multiple of 2.5 Gbit/sec to an IB rate  * enum.  * @mult: multiple to convert.  */
end_comment

begin_function_decl
name|__attribute_const__
name|enum
name|ib_rate
name|mult_to_ib_rate
parameter_list|(
name|int
name|mult
parameter_list|)
function_decl|;
end_function_decl

begin_struct
struct|struct
name|ib_ah_attr
block|{
name|struct
name|ib_global_route
name|grh
decl_stmt|;
name|u16
name|dlid
decl_stmt|;
name|u8
name|sl
decl_stmt|;
name|u8
name|src_path_bits
decl_stmt|;
name|u8
name|static_rate
decl_stmt|;
name|u8
name|ah_flags
decl_stmt|;
name|u8
name|port_num
decl_stmt|;
name|u8
name|dmac
index|[
name|ETH_ALEN
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_enum
enum|enum
name|ib_wc_status
block|{
name|IB_WC_SUCCESS
block|,
name|IB_WC_LOC_LEN_ERR
block|,
name|IB_WC_LOC_QP_OP_ERR
block|,
name|IB_WC_LOC_EEC_OP_ERR
block|,
name|IB_WC_LOC_PROT_ERR
block|,
name|IB_WC_WR_FLUSH_ERR
block|,
name|IB_WC_MW_BIND_ERR
block|,
name|IB_WC_BAD_RESP_ERR
block|,
name|IB_WC_LOC_ACCESS_ERR
block|,
name|IB_WC_REM_INV_REQ_ERR
block|,
name|IB_WC_REM_ACCESS_ERR
block|,
name|IB_WC_REM_OP_ERR
block|,
name|IB_WC_RETRY_EXC_ERR
block|,
name|IB_WC_RNR_RETRY_EXC_ERR
block|,
name|IB_WC_LOC_RDD_VIOL_ERR
block|,
name|IB_WC_REM_INV_RD_REQ_ERR
block|,
name|IB_WC_REM_ABORT_ERR
block|,
name|IB_WC_INV_EECN_ERR
block|,
name|IB_WC_INV_EEC_STATE_ERR
block|,
name|IB_WC_FATAL_ERR
block|,
name|IB_WC_RESP_TIMEOUT_ERR
block|,
name|IB_WC_GENERAL_ERR
block|}
enum|;
end_enum

begin_function_decl
specifier|const
name|char
modifier|*
name|__attribute_const__
name|ib_wc_status_msg
parameter_list|(
name|enum
name|ib_wc_status
name|status
parameter_list|)
function_decl|;
end_function_decl

begin_enum
enum|enum
name|ib_wc_opcode
block|{
name|IB_WC_SEND
block|,
name|IB_WC_RDMA_WRITE
block|,
name|IB_WC_RDMA_READ
block|,
name|IB_WC_COMP_SWAP
block|,
name|IB_WC_FETCH_ADD
block|,
name|IB_WC_LSO
block|,
name|IB_WC_LOCAL_INV
block|,
name|IB_WC_REG_MR
block|,
name|IB_WC_MASKED_COMP_SWAP
block|,
name|IB_WC_MASKED_FETCH_ADD
block|,
comment|/*  * Set value of IB_WC_RECV so consumers can test if a completion is a  * receive by testing (opcode& IB_WC_RECV).  */
name|IB_WC_RECV
init|=
literal|1
operator|<<
literal|7
block|,
name|IB_WC_RECV_RDMA_WITH_IMM
block|,
name|IB_WC_DUMMY
init|=
operator|-
literal|1
block|,
comment|/* force enum signed */
block|}
enum|;
end_enum

begin_enum
enum|enum
name|ib_wc_flags
block|{
name|IB_WC_GRH
init|=
literal|1
block|,
name|IB_WC_WITH_IMM
init|=
operator|(
literal|1
operator|<<
literal|1
operator|)
block|,
name|IB_WC_WITH_INVALIDATE
init|=
operator|(
literal|1
operator|<<
literal|2
operator|)
block|,
name|IB_WC_IP_CSUM_OK
init|=
operator|(
literal|1
operator|<<
literal|3
operator|)
block|,
name|IB_WC_WITH_SMAC
init|=
operator|(
literal|1
operator|<<
literal|4
operator|)
block|,
name|IB_WC_WITH_VLAN
init|=
operator|(
literal|1
operator|<<
literal|5
operator|)
block|,
name|IB_WC_WITH_NETWORK_HDR_TYPE
init|=
operator|(
literal|1
operator|<<
literal|6
operator|)
block|, }
enum|;
end_enum

begin_struct
struct|struct
name|ib_wc
block|{
union|union
block|{
name|u64
name|wr_id
decl_stmt|;
name|struct
name|ib_cqe
modifier|*
name|wr_cqe
decl_stmt|;
block|}
union|;
name|enum
name|ib_wc_status
name|status
decl_stmt|;
name|enum
name|ib_wc_opcode
name|opcode
decl_stmt|;
name|u32
name|vendor_err
decl_stmt|;
name|u32
name|byte_len
decl_stmt|;
name|struct
name|ib_qp
modifier|*
name|qp
decl_stmt|;
union|union
block|{
name|__be32
name|imm_data
decl_stmt|;
name|u32
name|invalidate_rkey
decl_stmt|;
block|}
name|ex
union|;
name|u32
name|src_qp
decl_stmt|;
name|int
name|wc_flags
decl_stmt|;
name|u16
name|pkey_index
decl_stmt|;
name|u16
name|slid
decl_stmt|;
name|u8
name|sl
decl_stmt|;
name|u8
name|dlid_path_bits
decl_stmt|;
name|u8
name|port_num
decl_stmt|;
comment|/* valid only for DR SMPs on switches */
name|u8
name|smac
index|[
name|ETH_ALEN
index|]
decl_stmt|;
name|u16
name|vlan_id
decl_stmt|;
name|u8
name|network_hdr_type
decl_stmt|;
block|}
struct|;
end_struct

begin_enum
enum|enum
name|ib_cq_notify_flags
block|{
name|IB_CQ_SOLICITED
init|=
literal|1
operator|<<
literal|0
block|,
name|IB_CQ_NEXT_COMP
init|=
literal|1
operator|<<
literal|1
block|,
name|IB_CQ_SOLICITED_MASK
init|=
name|IB_CQ_SOLICITED
operator||
name|IB_CQ_NEXT_COMP
block|,
name|IB_CQ_REPORT_MISSED_EVENTS
init|=
literal|1
operator|<<
literal|2
block|, }
enum|;
end_enum

begin_enum
enum|enum
name|ib_srq_type
block|{
name|IB_SRQT_BASIC
block|,
name|IB_SRQT_XRC
block|}
enum|;
end_enum

begin_enum
enum|enum
name|ib_srq_attr_mask
block|{
name|IB_SRQ_MAX_WR
init|=
literal|1
operator|<<
literal|0
block|,
name|IB_SRQ_LIMIT
init|=
literal|1
operator|<<
literal|1
block|, }
enum|;
end_enum

begin_struct
struct|struct
name|ib_srq_attr
block|{
name|u32
name|max_wr
decl_stmt|;
name|u32
name|max_sge
decl_stmt|;
name|u32
name|srq_limit
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ib_srq_init_attr
block|{
name|void
function_decl|(
modifier|*
name|event_handler
function_decl|)
parameter_list|(
name|struct
name|ib_event
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
name|void
modifier|*
name|srq_context
decl_stmt|;
name|struct
name|ib_srq_attr
name|attr
decl_stmt|;
name|enum
name|ib_srq_type
name|srq_type
decl_stmt|;
union|union
block|{
struct|struct
block|{
name|struct
name|ib_xrcd
modifier|*
name|xrcd
decl_stmt|;
name|struct
name|ib_cq
modifier|*
name|cq
decl_stmt|;
block|}
name|xrc
struct|;
block|}
name|ext
union|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ib_qp_cap
block|{
name|u32
name|max_send_wr
decl_stmt|;
name|u32
name|max_recv_wr
decl_stmt|;
name|u32
name|max_send_sge
decl_stmt|;
name|u32
name|max_recv_sge
decl_stmt|;
name|u32
name|max_inline_data
decl_stmt|;
comment|/* 	 * Maximum number of rdma_rw_ctx structures in flight at a time. 	 * ib_create_qp() will calculate the right amount of neededed WRs 	 * and MRs based on this. 	 */
name|u32
name|max_rdma_ctxs
decl_stmt|;
block|}
struct|;
end_struct

begin_enum
enum|enum
name|ib_sig_type
block|{
name|IB_SIGNAL_ALL_WR
block|,
name|IB_SIGNAL_REQ_WR
block|}
enum|;
end_enum

begin_enum
enum|enum
name|ib_qp_type
block|{
comment|/* 	 * IB_QPT_SMI and IB_QPT_GSI have to be the first two entries 	 * here (and in that order) since the MAD layer uses them as 	 * indices into a 2-entry table. 	 */
name|IB_QPT_SMI
block|,
name|IB_QPT_GSI
block|,
name|IB_QPT_RC
block|,
name|IB_QPT_UC
block|,
name|IB_QPT_UD
block|,
name|IB_QPT_RAW_IPV6
block|,
name|IB_QPT_RAW_ETHERTYPE
block|,
name|IB_QPT_RAW_PACKET
init|=
literal|8
block|,
name|IB_QPT_XRC_INI
init|=
literal|9
block|,
name|IB_QPT_XRC_TGT
block|,
name|IB_QPT_MAX
block|,
comment|/* Reserve a range for qp types internal to the low level driver. 	 * These qp types will not be visible at the IB core layer, so the 	 * IB_QPT_MAX usages should not be affected in the core layer 	 */
name|IB_QPT_RESERVED1
init|=
literal|0x1000
block|,
name|IB_QPT_RESERVED2
block|,
name|IB_QPT_RESERVED3
block|,
name|IB_QPT_RESERVED4
block|,
name|IB_QPT_RESERVED5
block|,
name|IB_QPT_RESERVED6
block|,
name|IB_QPT_RESERVED7
block|,
name|IB_QPT_RESERVED8
block|,
name|IB_QPT_RESERVED9
block|,
name|IB_QPT_RESERVED10
block|, }
enum|;
end_enum

begin_enum
enum|enum
name|ib_qp_create_flags
block|{
name|IB_QP_CREATE_IPOIB_UD_LSO
init|=
literal|1
operator|<<
literal|0
block|,
name|IB_QP_CREATE_BLOCK_MULTICAST_LOOPBACK
init|=
literal|1
operator|<<
literal|1
block|,
name|IB_QP_CREATE_CROSS_CHANNEL
init|=
literal|1
operator|<<
literal|2
block|,
name|IB_QP_CREATE_MANAGED_SEND
init|=
literal|1
operator|<<
literal|3
block|,
name|IB_QP_CREATE_MANAGED_RECV
init|=
literal|1
operator|<<
literal|4
block|,
name|IB_QP_CREATE_NETIF_QP
init|=
literal|1
operator|<<
literal|5
block|,
name|IB_QP_CREATE_SIGNATURE_EN
init|=
literal|1
operator|<<
literal|6
block|,
name|IB_QP_CREATE_USE_GFP_NOIO
init|=
literal|1
operator|<<
literal|7
block|,
name|IB_QP_CREATE_SCATTER_FCS
init|=
literal|1
operator|<<
literal|8
block|,
comment|/* reserve bits 26-31 for low level drivers' internal use */
name|IB_QP_CREATE_RESERVED_START
init|=
literal|1
operator|<<
literal|26
block|,
name|IB_QP_CREATE_RESERVED_END
init|=
literal|1
operator|<<
literal|31
block|, }
enum|;
end_enum

begin_comment
comment|/*  * Note: users may not call ib_close_qp or ib_destroy_qp from the event_handler  * callback to destroy the passed in QP.  */
end_comment

begin_struct
struct|struct
name|ib_qp_init_attr
block|{
name|void
function_decl|(
modifier|*
name|event_handler
function_decl|)
parameter_list|(
name|struct
name|ib_event
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
name|void
modifier|*
name|qp_context
decl_stmt|;
name|struct
name|ib_cq
modifier|*
name|send_cq
decl_stmt|;
name|struct
name|ib_cq
modifier|*
name|recv_cq
decl_stmt|;
name|struct
name|ib_srq
modifier|*
name|srq
decl_stmt|;
name|struct
name|ib_xrcd
modifier|*
name|xrcd
decl_stmt|;
comment|/* XRC TGT QPs only */
name|struct
name|ib_qp_cap
name|cap
decl_stmt|;
name|enum
name|ib_sig_type
name|sq_sig_type
decl_stmt|;
name|enum
name|ib_qp_type
name|qp_type
decl_stmt|;
name|enum
name|ib_qp_create_flags
name|create_flags
decl_stmt|;
comment|/* 	 * Only needed for special QP types, or when using the RW API. 	 */
name|u8
name|port_num
decl_stmt|;
name|struct
name|ib_rwq_ind_table
modifier|*
name|rwq_ind_tbl
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ib_qp_open_attr
block|{
name|void
function_decl|(
modifier|*
name|event_handler
function_decl|)
parameter_list|(
name|struct
name|ib_event
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
name|void
modifier|*
name|qp_context
decl_stmt|;
name|u32
name|qp_num
decl_stmt|;
name|enum
name|ib_qp_type
name|qp_type
decl_stmt|;
block|}
struct|;
end_struct

begin_enum
enum|enum
name|ib_rnr_timeout
block|{
name|IB_RNR_TIMER_655_36
init|=
literal|0
block|,
name|IB_RNR_TIMER_000_01
init|=
literal|1
block|,
name|IB_RNR_TIMER_000_02
init|=
literal|2
block|,
name|IB_RNR_TIMER_000_03
init|=
literal|3
block|,
name|IB_RNR_TIMER_000_04
init|=
literal|4
block|,
name|IB_RNR_TIMER_000_06
init|=
literal|5
block|,
name|IB_RNR_TIMER_000_08
init|=
literal|6
block|,
name|IB_RNR_TIMER_000_12
init|=
literal|7
block|,
name|IB_RNR_TIMER_000_16
init|=
literal|8
block|,
name|IB_RNR_TIMER_000_24
init|=
literal|9
block|,
name|IB_RNR_TIMER_000_32
init|=
literal|10
block|,
name|IB_RNR_TIMER_000_48
init|=
literal|11
block|,
name|IB_RNR_TIMER_000_64
init|=
literal|12
block|,
name|IB_RNR_TIMER_000_96
init|=
literal|13
block|,
name|IB_RNR_TIMER_001_28
init|=
literal|14
block|,
name|IB_RNR_TIMER_001_92
init|=
literal|15
block|,
name|IB_RNR_TIMER_002_56
init|=
literal|16
block|,
name|IB_RNR_TIMER_003_84
init|=
literal|17
block|,
name|IB_RNR_TIMER_005_12
init|=
literal|18
block|,
name|IB_RNR_TIMER_007_68
init|=
literal|19
block|,
name|IB_RNR_TIMER_010_24
init|=
literal|20
block|,
name|IB_RNR_TIMER_015_36
init|=
literal|21
block|,
name|IB_RNR_TIMER_020_48
init|=
literal|22
block|,
name|IB_RNR_TIMER_030_72
init|=
literal|23
block|,
name|IB_RNR_TIMER_040_96
init|=
literal|24
block|,
name|IB_RNR_TIMER_061_44
init|=
literal|25
block|,
name|IB_RNR_TIMER_081_92
init|=
literal|26
block|,
name|IB_RNR_TIMER_122_88
init|=
literal|27
block|,
name|IB_RNR_TIMER_163_84
init|=
literal|28
block|,
name|IB_RNR_TIMER_245_76
init|=
literal|29
block|,
name|IB_RNR_TIMER_327_68
init|=
literal|30
block|,
name|IB_RNR_TIMER_491_52
init|=
literal|31
block|}
enum|;
end_enum

begin_enum
enum|enum
name|ib_qp_attr_mask
block|{
name|IB_QP_STATE
init|=
literal|1
block|,
name|IB_QP_CUR_STATE
init|=
operator|(
literal|1
operator|<<
literal|1
operator|)
block|,
name|IB_QP_EN_SQD_ASYNC_NOTIFY
init|=
operator|(
literal|1
operator|<<
literal|2
operator|)
block|,
name|IB_QP_ACCESS_FLAGS
init|=
operator|(
literal|1
operator|<<
literal|3
operator|)
block|,
name|IB_QP_PKEY_INDEX
init|=
operator|(
literal|1
operator|<<
literal|4
operator|)
block|,
name|IB_QP_PORT
init|=
operator|(
literal|1
operator|<<
literal|5
operator|)
block|,
name|IB_QP_QKEY
init|=
operator|(
literal|1
operator|<<
literal|6
operator|)
block|,
name|IB_QP_AV
init|=
operator|(
literal|1
operator|<<
literal|7
operator|)
block|,
name|IB_QP_PATH_MTU
init|=
operator|(
literal|1
operator|<<
literal|8
operator|)
block|,
name|IB_QP_TIMEOUT
init|=
operator|(
literal|1
operator|<<
literal|9
operator|)
block|,
name|IB_QP_RETRY_CNT
init|=
operator|(
literal|1
operator|<<
literal|10
operator|)
block|,
name|IB_QP_RNR_RETRY
init|=
operator|(
literal|1
operator|<<
literal|11
operator|)
block|,
name|IB_QP_RQ_PSN
init|=
operator|(
literal|1
operator|<<
literal|12
operator|)
block|,
name|IB_QP_MAX_QP_RD_ATOMIC
init|=
operator|(
literal|1
operator|<<
literal|13
operator|)
block|,
name|IB_QP_ALT_PATH
init|=
operator|(
literal|1
operator|<<
literal|14
operator|)
block|,
name|IB_QP_MIN_RNR_TIMER
init|=
operator|(
literal|1
operator|<<
literal|15
operator|)
block|,
name|IB_QP_SQ_PSN
init|=
operator|(
literal|1
operator|<<
literal|16
operator|)
block|,
name|IB_QP_MAX_DEST_RD_ATOMIC
init|=
operator|(
literal|1
operator|<<
literal|17
operator|)
block|,
name|IB_QP_PATH_MIG_STATE
init|=
operator|(
literal|1
operator|<<
literal|18
operator|)
block|,
name|IB_QP_CAP
init|=
operator|(
literal|1
operator|<<
literal|19
operator|)
block|,
name|IB_QP_DEST_QPN
init|=
operator|(
literal|1
operator|<<
literal|20
operator|)
block|,
name|IB_QP_RESERVED1
init|=
operator|(
literal|1
operator|<<
literal|21
operator|)
block|,
name|IB_QP_RESERVED2
init|=
operator|(
literal|1
operator|<<
literal|22
operator|)
block|,
name|IB_QP_RESERVED3
init|=
operator|(
literal|1
operator|<<
literal|23
operator|)
block|,
name|IB_QP_RESERVED4
init|=
operator|(
literal|1
operator|<<
literal|24
operator|)
block|, }
enum|;
end_enum

begin_enum
enum|enum
name|ib_qp_state
block|{
name|IB_QPS_RESET
block|,
name|IB_QPS_INIT
block|,
name|IB_QPS_RTR
block|,
name|IB_QPS_RTS
block|,
name|IB_QPS_SQD
block|,
name|IB_QPS_SQE
block|,
name|IB_QPS_ERR
block|,
name|IB_QPS_DUMMY
init|=
operator|-
literal|1
block|,
comment|/* force enum signed */
block|}
enum|;
end_enum

begin_enum
enum|enum
name|ib_mig_state
block|{
name|IB_MIG_MIGRATED
block|,
name|IB_MIG_REARM
block|,
name|IB_MIG_ARMED
block|}
enum|;
end_enum

begin_enum
enum|enum
name|ib_mw_type
block|{
name|IB_MW_TYPE_1
init|=
literal|1
block|,
name|IB_MW_TYPE_2
init|=
literal|2
block|}
enum|;
end_enum

begin_struct
struct|struct
name|ib_qp_attr
block|{
name|enum
name|ib_qp_state
name|qp_state
decl_stmt|;
name|enum
name|ib_qp_state
name|cur_qp_state
decl_stmt|;
name|enum
name|ib_mtu
name|path_mtu
decl_stmt|;
name|enum
name|ib_mig_state
name|path_mig_state
decl_stmt|;
name|u32
name|qkey
decl_stmt|;
name|u32
name|rq_psn
decl_stmt|;
name|u32
name|sq_psn
decl_stmt|;
name|u32
name|dest_qp_num
decl_stmt|;
name|int
name|qp_access_flags
decl_stmt|;
name|struct
name|ib_qp_cap
name|cap
decl_stmt|;
name|struct
name|ib_ah_attr
name|ah_attr
decl_stmt|;
name|struct
name|ib_ah_attr
name|alt_ah_attr
decl_stmt|;
name|u16
name|pkey_index
decl_stmt|;
name|u16
name|alt_pkey_index
decl_stmt|;
name|u8
name|en_sqd_async_notify
decl_stmt|;
name|u8
name|sq_draining
decl_stmt|;
name|u8
name|max_rd_atomic
decl_stmt|;
name|u8
name|max_dest_rd_atomic
decl_stmt|;
name|u8
name|min_rnr_timer
decl_stmt|;
name|u8
name|port_num
decl_stmt|;
name|u8
name|timeout
decl_stmt|;
name|u8
name|retry_cnt
decl_stmt|;
name|u8
name|rnr_retry
decl_stmt|;
name|u8
name|alt_port_num
decl_stmt|;
name|u8
name|alt_timeout
decl_stmt|;
block|}
struct|;
end_struct

begin_enum
enum|enum
name|ib_wr_opcode
block|{
name|IB_WR_RDMA_WRITE
block|,
name|IB_WR_RDMA_WRITE_WITH_IMM
block|,
name|IB_WR_SEND
block|,
name|IB_WR_SEND_WITH_IMM
block|,
name|IB_WR_RDMA_READ
block|,
name|IB_WR_ATOMIC_CMP_AND_SWP
block|,
name|IB_WR_ATOMIC_FETCH_AND_ADD
block|,
name|IB_WR_LSO
block|,
name|IB_WR_SEND_WITH_INV
block|,
name|IB_WR_RDMA_READ_WITH_INV
block|,
name|IB_WR_LOCAL_INV
block|,
name|IB_WR_REG_MR
block|,
name|IB_WR_MASKED_ATOMIC_CMP_AND_SWP
block|,
name|IB_WR_MASKED_ATOMIC_FETCH_AND_ADD
block|,
name|IB_WR_REG_SIG_MR
block|,
comment|/* reserve values for low level drivers' internal use. 	 * These values will not be used at all in the ib core layer. 	 */
name|IB_WR_RESERVED1
init|=
literal|0xf0
block|,
name|IB_WR_RESERVED2
block|,
name|IB_WR_RESERVED3
block|,
name|IB_WR_RESERVED4
block|,
name|IB_WR_RESERVED5
block|,
name|IB_WR_RESERVED6
block|,
name|IB_WR_RESERVED7
block|,
name|IB_WR_RESERVED8
block|,
name|IB_WR_RESERVED9
block|,
name|IB_WR_RESERVED10
block|,
name|IB_WR_DUMMY
init|=
operator|-
literal|1
block|,
comment|/* force enum signed */
block|}
enum|;
end_enum

begin_enum
enum|enum
name|ib_send_flags
block|{
name|IB_SEND_FENCE
init|=
literal|1
block|,
name|IB_SEND_SIGNALED
init|=
operator|(
literal|1
operator|<<
literal|1
operator|)
block|,
name|IB_SEND_SOLICITED
init|=
operator|(
literal|1
operator|<<
literal|2
operator|)
block|,
name|IB_SEND_INLINE
init|=
operator|(
literal|1
operator|<<
literal|3
operator|)
block|,
name|IB_SEND_IP_CSUM
init|=
operator|(
literal|1
operator|<<
literal|4
operator|)
block|,
comment|/* reserve bits 26-31 for low level drivers' internal use */
name|IB_SEND_RESERVED_START
init|=
operator|(
literal|1
operator|<<
literal|26
operator|)
block|,
name|IB_SEND_RESERVED_END
init|=
operator|(
literal|1
operator|<<
literal|31
operator|)
block|, }
enum|;
end_enum

begin_struct
struct|struct
name|ib_sge
block|{
name|u64
name|addr
decl_stmt|;
name|u32
name|length
decl_stmt|;
name|u32
name|lkey
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ib_cqe
block|{
name|void
function_decl|(
modifier|*
name|done
function_decl|)
parameter_list|(
name|struct
name|ib_cq
modifier|*
name|cq
parameter_list|,
name|struct
name|ib_wc
modifier|*
name|wc
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ib_send_wr
block|{
name|struct
name|ib_send_wr
modifier|*
name|next
decl_stmt|;
union|union
block|{
name|u64
name|wr_id
decl_stmt|;
name|struct
name|ib_cqe
modifier|*
name|wr_cqe
decl_stmt|;
block|}
union|;
name|struct
name|ib_sge
modifier|*
name|sg_list
decl_stmt|;
name|int
name|num_sge
decl_stmt|;
name|enum
name|ib_wr_opcode
name|opcode
decl_stmt|;
name|int
name|send_flags
decl_stmt|;
union|union
block|{
name|__be32
name|imm_data
decl_stmt|;
name|u32
name|invalidate_rkey
decl_stmt|;
block|}
name|ex
union|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ib_rdma_wr
block|{
name|struct
name|ib_send_wr
name|wr
decl_stmt|;
name|u64
name|remote_addr
decl_stmt|;
name|u32
name|rkey
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
specifier|inline
name|struct
name|ib_rdma_wr
modifier|*
name|rdma_wr
parameter_list|(
name|struct
name|ib_send_wr
modifier|*
name|wr
parameter_list|)
block|{
return|return
name|container_of
argument_list|(
name|wr
argument_list|,
expr|struct
name|ib_rdma_wr
argument_list|,
name|wr
argument_list|)
return|;
block|}
end_function

begin_struct
struct|struct
name|ib_atomic_wr
block|{
name|struct
name|ib_send_wr
name|wr
decl_stmt|;
name|u64
name|remote_addr
decl_stmt|;
name|u64
name|compare_add
decl_stmt|;
name|u64
name|swap
decl_stmt|;
name|u64
name|compare_add_mask
decl_stmt|;
name|u64
name|swap_mask
decl_stmt|;
name|u32
name|rkey
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
specifier|inline
name|struct
name|ib_atomic_wr
modifier|*
name|atomic_wr
parameter_list|(
name|struct
name|ib_send_wr
modifier|*
name|wr
parameter_list|)
block|{
return|return
name|container_of
argument_list|(
name|wr
argument_list|,
expr|struct
name|ib_atomic_wr
argument_list|,
name|wr
argument_list|)
return|;
block|}
end_function

begin_struct
struct|struct
name|ib_ud_wr
block|{
name|struct
name|ib_send_wr
name|wr
decl_stmt|;
name|struct
name|ib_ah
modifier|*
name|ah
decl_stmt|;
name|void
modifier|*
name|header
decl_stmt|;
name|int
name|hlen
decl_stmt|;
name|int
name|mss
decl_stmt|;
name|u32
name|remote_qpn
decl_stmt|;
name|u32
name|remote_qkey
decl_stmt|;
name|u16
name|pkey_index
decl_stmt|;
comment|/* valid for GSI only */
name|u8
name|port_num
decl_stmt|;
comment|/* valid for DR SMPs on switch only */
block|}
struct|;
end_struct

begin_function
specifier|static
specifier|inline
name|struct
name|ib_ud_wr
modifier|*
name|ud_wr
parameter_list|(
name|struct
name|ib_send_wr
modifier|*
name|wr
parameter_list|)
block|{
return|return
name|container_of
argument_list|(
name|wr
argument_list|,
expr|struct
name|ib_ud_wr
argument_list|,
name|wr
argument_list|)
return|;
block|}
end_function

begin_struct
struct|struct
name|ib_reg_wr
block|{
name|struct
name|ib_send_wr
name|wr
decl_stmt|;
name|struct
name|ib_mr
modifier|*
name|mr
decl_stmt|;
name|u32
name|key
decl_stmt|;
name|int
name|access
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
specifier|inline
name|struct
name|ib_reg_wr
modifier|*
name|reg_wr
parameter_list|(
name|struct
name|ib_send_wr
modifier|*
name|wr
parameter_list|)
block|{
return|return
name|container_of
argument_list|(
name|wr
argument_list|,
expr|struct
name|ib_reg_wr
argument_list|,
name|wr
argument_list|)
return|;
block|}
end_function

begin_struct
struct|struct
name|ib_sig_handover_wr
block|{
name|struct
name|ib_send_wr
name|wr
decl_stmt|;
name|struct
name|ib_sig_attrs
modifier|*
name|sig_attrs
decl_stmt|;
name|struct
name|ib_mr
modifier|*
name|sig_mr
decl_stmt|;
name|int
name|access_flags
decl_stmt|;
name|struct
name|ib_sge
modifier|*
name|prot
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
specifier|inline
name|struct
name|ib_sig_handover_wr
modifier|*
name|sig_handover_wr
parameter_list|(
name|struct
name|ib_send_wr
modifier|*
name|wr
parameter_list|)
block|{
return|return
name|container_of
argument_list|(
name|wr
argument_list|,
expr|struct
name|ib_sig_handover_wr
argument_list|,
name|wr
argument_list|)
return|;
block|}
end_function

begin_struct
struct|struct
name|ib_recv_wr
block|{
name|struct
name|ib_recv_wr
modifier|*
name|next
decl_stmt|;
union|union
block|{
name|u64
name|wr_id
decl_stmt|;
name|struct
name|ib_cqe
modifier|*
name|wr_cqe
decl_stmt|;
block|}
union|;
name|struct
name|ib_sge
modifier|*
name|sg_list
decl_stmt|;
name|int
name|num_sge
decl_stmt|;
block|}
struct|;
end_struct

begin_enum
enum|enum
name|ib_access_flags
block|{
name|IB_ACCESS_LOCAL_WRITE
init|=
literal|1
block|,
name|IB_ACCESS_REMOTE_WRITE
init|=
operator|(
literal|1
operator|<<
literal|1
operator|)
block|,
name|IB_ACCESS_REMOTE_READ
init|=
operator|(
literal|1
operator|<<
literal|2
operator|)
block|,
name|IB_ACCESS_REMOTE_ATOMIC
init|=
operator|(
literal|1
operator|<<
literal|3
operator|)
block|,
name|IB_ACCESS_MW_BIND
init|=
operator|(
literal|1
operator|<<
literal|4
operator|)
block|,
name|IB_ZERO_BASED
init|=
operator|(
literal|1
operator|<<
literal|5
operator|)
block|,
name|IB_ACCESS_ON_DEMAND
init|=
operator|(
literal|1
operator|<<
literal|6
operator|)
block|, }
enum|;
end_enum

begin_comment
comment|/*  * XXX: these are apparently used for ->rereg_user_mr, no idea why they  * are hidden here instead of a uapi header!  */
end_comment

begin_enum
enum|enum
name|ib_mr_rereg_flags
block|{
name|IB_MR_REREG_TRANS
init|=
literal|1
block|,
name|IB_MR_REREG_PD
init|=
operator|(
literal|1
operator|<<
literal|1
operator|)
block|,
name|IB_MR_REREG_ACCESS
init|=
operator|(
literal|1
operator|<<
literal|2
operator|)
block|,
name|IB_MR_REREG_SUPPORTED
init|=
operator|(
operator|(
name|IB_MR_REREG_ACCESS
operator|<<
literal|1
operator|)
operator|-
literal|1
operator|)
block|}
enum|;
end_enum

begin_struct
struct|struct
name|ib_fmr_attr
block|{
name|int
name|max_pages
decl_stmt|;
name|int
name|max_maps
decl_stmt|;
name|u8
name|page_shift
decl_stmt|;
block|}
struct|;
end_struct

begin_struct_decl
struct_decl|struct
name|ib_umem
struct_decl|;
end_struct_decl

begin_struct
struct|struct
name|ib_ucontext
block|{
name|struct
name|ib_device
modifier|*
name|device
decl_stmt|;
name|struct
name|list_head
name|pd_list
decl_stmt|;
name|struct
name|list_head
name|mr_list
decl_stmt|;
name|struct
name|list_head
name|mw_list
decl_stmt|;
name|struct
name|list_head
name|cq_list
decl_stmt|;
name|struct
name|list_head
name|qp_list
decl_stmt|;
name|struct
name|list_head
name|srq_list
decl_stmt|;
name|struct
name|list_head
name|ah_list
decl_stmt|;
name|struct
name|list_head
name|xrcd_list
decl_stmt|;
name|struct
name|list_head
name|rule_list
decl_stmt|;
name|struct
name|list_head
name|wq_list
decl_stmt|;
name|struct
name|list_head
name|rwq_ind_tbl_list
decl_stmt|;
name|int
name|closing
decl_stmt|;
name|pid_t
name|tgid
decl_stmt|;
ifdef|#
directive|ifdef
name|CONFIG_INFINIBAND_ON_DEMAND_PAGING
name|struct
name|rb_root
name|umem_tree
decl_stmt|;
comment|/* 	 * Protects .umem_rbroot and tree, as well as odp_mrs_count and 	 * mmu notifiers registration. 	 */
name|struct
name|rw_semaphore
name|umem_rwsem
decl_stmt|;
name|void
function_decl|(
modifier|*
name|invalidate_range
function_decl|)
parameter_list|(
name|struct
name|ib_umem
modifier|*
name|umem
parameter_list|,
name|unsigned
name|long
name|start
parameter_list|,
name|unsigned
name|long
name|end
parameter_list|)
function_decl|;
name|struct
name|mmu_notifier
name|mn
decl_stmt|;
name|atomic_t
name|notifier_count
decl_stmt|;
comment|/* A list of umems that don't have private mmu notifier counters yet. */
name|struct
name|list_head
name|no_private_counters
decl_stmt|;
name|int
name|odp_mrs_count
decl_stmt|;
endif|#
directive|endif
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ib_uobject
block|{
name|u64
name|user_handle
decl_stmt|;
comment|/* handle given to us by userspace */
name|struct
name|ib_ucontext
modifier|*
name|context
decl_stmt|;
comment|/* associated user context */
name|void
modifier|*
name|object
decl_stmt|;
comment|/* containing object */
name|struct
name|list_head
name|list
decl_stmt|;
comment|/* link to context's list */
name|int
name|id
decl_stmt|;
comment|/* index into kernel idr */
name|struct
name|kref
name|ref
decl_stmt|;
name|struct
name|rw_semaphore
name|mutex
decl_stmt|;
comment|/* protects .live */
name|struct
name|rcu_head
name|rcu
decl_stmt|;
comment|/* kfree_rcu() overhead */
name|int
name|live
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ib_udata
block|{
specifier|const
name|void
name|__user
modifier|*
name|inbuf
decl_stmt|;
name|void
name|__user
modifier|*
name|outbuf
decl_stmt|;
name|size_t
name|inlen
decl_stmt|;
name|size_t
name|outlen
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ib_pd
block|{
name|u32
name|local_dma_lkey
decl_stmt|;
name|u32
name|flags
decl_stmt|;
name|struct
name|ib_device
modifier|*
name|device
decl_stmt|;
name|struct
name|ib_uobject
modifier|*
name|uobject
decl_stmt|;
name|atomic_t
name|usecnt
decl_stmt|;
comment|/* count all resources */
name|u32
name|unsafe_global_rkey
decl_stmt|;
comment|/* 	 * Implementation details of the RDMA core, don't use in drivers: 	 */
name|struct
name|ib_mr
modifier|*
name|__internal_mr
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ib_xrcd
block|{
name|struct
name|ib_device
modifier|*
name|device
decl_stmt|;
name|atomic_t
name|usecnt
decl_stmt|;
comment|/* count all exposed resources */
name|struct
name|inode
modifier|*
name|inode
decl_stmt|;
name|struct
name|mutex
name|tgt_qp_mutex
decl_stmt|;
name|struct
name|list_head
name|tgt_qp_list
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ib_ah
block|{
name|struct
name|ib_device
modifier|*
name|device
decl_stmt|;
name|struct
name|ib_pd
modifier|*
name|pd
decl_stmt|;
name|struct
name|ib_uobject
modifier|*
name|uobject
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|void
function_decl|(
modifier|*
name|ib_comp_handler
function_decl|)
parameter_list|(
name|struct
name|ib_cq
modifier|*
name|cq
parameter_list|,
name|void
modifier|*
name|cq_context
parameter_list|)
function_decl|;
end_typedef

begin_enum
enum|enum
name|ib_poll_context
block|{
name|IB_POLL_DIRECT
block|,
comment|/* caller context, no hw completions */
name|IB_POLL_SOFTIRQ
block|,
comment|/* poll from softirq context */
name|IB_POLL_WORKQUEUE
block|,
comment|/* poll from workqueue */
block|}
enum|;
end_enum

begin_struct
struct|struct
name|ib_cq
block|{
name|struct
name|ib_device
modifier|*
name|device
decl_stmt|;
name|struct
name|ib_uobject
modifier|*
name|uobject
decl_stmt|;
name|ib_comp_handler
name|comp_handler
decl_stmt|;
name|void
function_decl|(
modifier|*
name|event_handler
function_decl|)
parameter_list|(
name|struct
name|ib_event
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
name|void
modifier|*
name|cq_context
decl_stmt|;
name|int
name|cqe
decl_stmt|;
name|atomic_t
name|usecnt
decl_stmt|;
comment|/* count number of work queues */
name|enum
name|ib_poll_context
name|poll_ctx
decl_stmt|;
name|struct
name|work_struct
name|work
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ib_srq
block|{
name|struct
name|ib_device
modifier|*
name|device
decl_stmt|;
name|struct
name|ib_pd
modifier|*
name|pd
decl_stmt|;
name|struct
name|ib_uobject
modifier|*
name|uobject
decl_stmt|;
name|void
function_decl|(
modifier|*
name|event_handler
function_decl|)
parameter_list|(
name|struct
name|ib_event
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
name|void
modifier|*
name|srq_context
decl_stmt|;
name|enum
name|ib_srq_type
name|srq_type
decl_stmt|;
name|atomic_t
name|usecnt
decl_stmt|;
union|union
block|{
struct|struct
block|{
name|struct
name|ib_xrcd
modifier|*
name|xrcd
decl_stmt|;
name|struct
name|ib_cq
modifier|*
name|cq
decl_stmt|;
name|u32
name|srq_num
decl_stmt|;
block|}
name|xrc
struct|;
block|}
name|ext
union|;
block|}
struct|;
end_struct

begin_enum
enum|enum
name|ib_wq_type
block|{
name|IB_WQT_RQ
block|}
enum|;
end_enum

begin_enum
enum|enum
name|ib_wq_state
block|{
name|IB_WQS_RESET
block|,
name|IB_WQS_RDY
block|,
name|IB_WQS_ERR
block|}
enum|;
end_enum

begin_struct
struct|struct
name|ib_wq
block|{
name|struct
name|ib_device
modifier|*
name|device
decl_stmt|;
name|struct
name|ib_uobject
modifier|*
name|uobject
decl_stmt|;
name|void
modifier|*
name|wq_context
decl_stmt|;
name|void
function_decl|(
modifier|*
name|event_handler
function_decl|)
parameter_list|(
name|struct
name|ib_event
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
name|struct
name|ib_pd
modifier|*
name|pd
decl_stmt|;
name|struct
name|ib_cq
modifier|*
name|cq
decl_stmt|;
name|u32
name|wq_num
decl_stmt|;
name|enum
name|ib_wq_state
name|state
decl_stmt|;
name|enum
name|ib_wq_type
name|wq_type
decl_stmt|;
name|atomic_t
name|usecnt
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ib_wq_init_attr
block|{
name|void
modifier|*
name|wq_context
decl_stmt|;
name|enum
name|ib_wq_type
name|wq_type
decl_stmt|;
name|u32
name|max_wr
decl_stmt|;
name|u32
name|max_sge
decl_stmt|;
name|struct
name|ib_cq
modifier|*
name|cq
decl_stmt|;
name|void
function_decl|(
modifier|*
name|event_handler
function_decl|)
parameter_list|(
name|struct
name|ib_event
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_enum
enum|enum
name|ib_wq_attr_mask
block|{
name|IB_WQ_STATE
init|=
literal|1
operator|<<
literal|0
block|,
name|IB_WQ_CUR_STATE
init|=
literal|1
operator|<<
literal|1
block|, }
enum|;
end_enum

begin_struct
struct|struct
name|ib_wq_attr
block|{
name|enum
name|ib_wq_state
name|wq_state
decl_stmt|;
name|enum
name|ib_wq_state
name|curr_wq_state
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ib_rwq_ind_table
block|{
name|struct
name|ib_device
modifier|*
name|device
decl_stmt|;
name|struct
name|ib_uobject
modifier|*
name|uobject
decl_stmt|;
name|atomic_t
name|usecnt
decl_stmt|;
name|u32
name|ind_tbl_num
decl_stmt|;
name|u32
name|log_ind_tbl_size
decl_stmt|;
name|struct
name|ib_wq
modifier|*
modifier|*
name|ind_tbl
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ib_rwq_ind_table_init_attr
block|{
name|u32
name|log_ind_tbl_size
decl_stmt|;
comment|/* Each entry is a pointer to Receive Work Queue */
name|struct
name|ib_wq
modifier|*
modifier|*
name|ind_tbl
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * @max_write_sge: Maximum SGE elements per RDMA WRITE request.  * @max_read_sge:  Maximum SGE elements per RDMA READ request.  */
end_comment

begin_struct
struct|struct
name|ib_qp
block|{
name|struct
name|ib_device
modifier|*
name|device
decl_stmt|;
name|struct
name|ib_pd
modifier|*
name|pd
decl_stmt|;
name|struct
name|ib_cq
modifier|*
name|send_cq
decl_stmt|;
name|struct
name|ib_cq
modifier|*
name|recv_cq
decl_stmt|;
name|spinlock_t
name|mr_lock
decl_stmt|;
name|struct
name|ib_srq
modifier|*
name|srq
decl_stmt|;
name|struct
name|ib_xrcd
modifier|*
name|xrcd
decl_stmt|;
comment|/* XRC TGT QPs only */
name|struct
name|list_head
name|xrcd_list
decl_stmt|;
comment|/* count times opened, mcast attaches, flow attaches */
name|atomic_t
name|usecnt
decl_stmt|;
name|struct
name|list_head
name|open_list
decl_stmt|;
name|struct
name|ib_qp
modifier|*
name|real_qp
decl_stmt|;
name|struct
name|ib_uobject
modifier|*
name|uobject
decl_stmt|;
name|void
function_decl|(
modifier|*
name|event_handler
function_decl|)
parameter_list|(
name|struct
name|ib_event
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
name|void
modifier|*
name|qp_context
decl_stmt|;
name|u32
name|qp_num
decl_stmt|;
name|u32
name|max_write_sge
decl_stmt|;
name|u32
name|max_read_sge
decl_stmt|;
name|enum
name|ib_qp_type
name|qp_type
decl_stmt|;
name|struct
name|ib_rwq_ind_table
modifier|*
name|rwq_ind_tbl
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ib_mr
block|{
name|struct
name|ib_device
modifier|*
name|device
decl_stmt|;
name|struct
name|ib_pd
modifier|*
name|pd
decl_stmt|;
name|u32
name|lkey
decl_stmt|;
name|u32
name|rkey
decl_stmt|;
name|u64
name|iova
decl_stmt|;
name|u32
name|length
decl_stmt|;
name|unsigned
name|int
name|page_size
decl_stmt|;
name|bool
name|need_inval
decl_stmt|;
union|union
block|{
name|struct
name|ib_uobject
modifier|*
name|uobject
decl_stmt|;
comment|/* user */
name|struct
name|list_head
name|qp_entry
decl_stmt|;
comment|/* FR */
block|}
union|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ib_mw
block|{
name|struct
name|ib_device
modifier|*
name|device
decl_stmt|;
name|struct
name|ib_pd
modifier|*
name|pd
decl_stmt|;
name|struct
name|ib_uobject
modifier|*
name|uobject
decl_stmt|;
name|u32
name|rkey
decl_stmt|;
name|enum
name|ib_mw_type
name|type
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ib_fmr
block|{
name|struct
name|ib_device
modifier|*
name|device
decl_stmt|;
name|struct
name|ib_pd
modifier|*
name|pd
decl_stmt|;
name|struct
name|list_head
name|list
decl_stmt|;
name|u32
name|lkey
decl_stmt|;
name|u32
name|rkey
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Supported steering options */
end_comment

begin_enum
enum|enum
name|ib_flow_attr_type
block|{
comment|/* steering according to rule specifications */
name|IB_FLOW_ATTR_NORMAL
init|=
literal|0x0
block|,
comment|/* default unicast and multicast rule - 	 * receive all Eth traffic which isn't steered to any QP 	 */
name|IB_FLOW_ATTR_ALL_DEFAULT
init|=
literal|0x1
block|,
comment|/* default multicast rule - 	 * receive all Eth multicast traffic which isn't steered to any QP 	 */
name|IB_FLOW_ATTR_MC_DEFAULT
init|=
literal|0x2
block|,
comment|/* sniffer rule - receive all port traffic */
name|IB_FLOW_ATTR_SNIFFER
init|=
literal|0x3
block|}
enum|;
end_enum

begin_comment
comment|/* Supported steering header types */
end_comment

begin_enum
enum|enum
name|ib_flow_spec_type
block|{
comment|/* L2 headers*/
name|IB_FLOW_SPEC_ETH
init|=
literal|0x20
block|,
name|IB_FLOW_SPEC_IB
init|=
literal|0x22
block|,
comment|/* L3 header*/
name|IB_FLOW_SPEC_IPV4
init|=
literal|0x30
block|,
name|IB_FLOW_SPEC_IPV6
init|=
literal|0x31
block|,
comment|/* L4 headers*/
name|IB_FLOW_SPEC_TCP
init|=
literal|0x40
block|,
name|IB_FLOW_SPEC_UDP
init|=
literal|0x41
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|IB_FLOW_SPEC_LAYER_MASK
value|0xF0
end_define

begin_define
define|#
directive|define
name|IB_FLOW_SPEC_SUPPORT_LAYERS
value|4
end_define

begin_comment
comment|/* Flow steering rule priority is set according to it's domain.  * Lower domain value means higher priority.  */
end_comment

begin_enum
enum|enum
name|ib_flow_domain
block|{
name|IB_FLOW_DOMAIN_USER
block|,
name|IB_FLOW_DOMAIN_ETHTOOL
block|,
name|IB_FLOW_DOMAIN_RFS
block|,
name|IB_FLOW_DOMAIN_NIC
block|,
name|IB_FLOW_DOMAIN_NUM
comment|/* Must be last */
block|}
enum|;
end_enum

begin_enum
enum|enum
name|ib_flow_flags
block|{
name|IB_FLOW_ATTR_FLAGS_DONT_TRAP
init|=
literal|1UL
operator|<<
literal|1
block|,
comment|/* Continue match, no steal */
name|IB_FLOW_ATTR_FLAGS_RESERVED
init|=
literal|1UL
operator|<<
literal|2
comment|/* Must be last */
block|}
enum|;
end_enum

begin_struct
struct|struct
name|ib_flow_eth_filter
block|{
name|u8
name|dst_mac
index|[
literal|6
index|]
decl_stmt|;
name|u8
name|src_mac
index|[
literal|6
index|]
decl_stmt|;
name|__be16
name|ether_type
decl_stmt|;
name|__be16
name|vlan_tag
decl_stmt|;
comment|/* Must be last */
name|u8
name|real_sz
index|[
literal|0
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ib_flow_spec_eth
block|{
name|enum
name|ib_flow_spec_type
name|type
decl_stmt|;
name|u16
name|size
decl_stmt|;
name|struct
name|ib_flow_eth_filter
name|val
decl_stmt|;
name|struct
name|ib_flow_eth_filter
name|mask
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ib_flow_ib_filter
block|{
name|__be16
name|dlid
decl_stmt|;
name|__u8
name|sl
decl_stmt|;
comment|/* Must be last */
name|u8
name|real_sz
index|[
literal|0
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ib_flow_spec_ib
block|{
name|enum
name|ib_flow_spec_type
name|type
decl_stmt|;
name|u16
name|size
decl_stmt|;
name|struct
name|ib_flow_ib_filter
name|val
decl_stmt|;
name|struct
name|ib_flow_ib_filter
name|mask
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* IPv4 header flags */
end_comment

begin_enum
enum|enum
name|ib_ipv4_flags
block|{
name|IB_IPV4_DONT_FRAG
init|=
literal|0x2
block|,
comment|/* Don't enable packet fragmentation */
name|IB_IPV4_MORE_FRAG
init|=
literal|0X4
comment|/* For All fragmented packets except the 				    last have this flag set */
block|}
enum|;
end_enum

begin_struct
struct|struct
name|ib_flow_ipv4_filter
block|{
name|__be32
name|src_ip
decl_stmt|;
name|__be32
name|dst_ip
decl_stmt|;
name|u8
name|proto
decl_stmt|;
name|u8
name|tos
decl_stmt|;
name|u8
name|ttl
decl_stmt|;
name|u8
name|flags
decl_stmt|;
comment|/* Must be last */
name|u8
name|real_sz
index|[
literal|0
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ib_flow_spec_ipv4
block|{
name|enum
name|ib_flow_spec_type
name|type
decl_stmt|;
name|u16
name|size
decl_stmt|;
name|struct
name|ib_flow_ipv4_filter
name|val
decl_stmt|;
name|struct
name|ib_flow_ipv4_filter
name|mask
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ib_flow_ipv6_filter
block|{
name|u8
name|src_ip
index|[
literal|16
index|]
decl_stmt|;
name|u8
name|dst_ip
index|[
literal|16
index|]
decl_stmt|;
name|__be32
name|flow_label
decl_stmt|;
name|u8
name|next_hdr
decl_stmt|;
name|u8
name|traffic_class
decl_stmt|;
name|u8
name|hop_limit
decl_stmt|;
comment|/* Must be last */
name|u8
name|real_sz
index|[
literal|0
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ib_flow_spec_ipv6
block|{
name|enum
name|ib_flow_spec_type
name|type
decl_stmt|;
name|u16
name|size
decl_stmt|;
name|struct
name|ib_flow_ipv6_filter
name|val
decl_stmt|;
name|struct
name|ib_flow_ipv6_filter
name|mask
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ib_flow_tcp_udp_filter
block|{
name|__be16
name|dst_port
decl_stmt|;
name|__be16
name|src_port
decl_stmt|;
comment|/* Must be last */
name|u8
name|real_sz
index|[
literal|0
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ib_flow_spec_tcp_udp
block|{
name|enum
name|ib_flow_spec_type
name|type
decl_stmt|;
name|u16
name|size
decl_stmt|;
name|struct
name|ib_flow_tcp_udp_filter
name|val
decl_stmt|;
name|struct
name|ib_flow_tcp_udp_filter
name|mask
decl_stmt|;
block|}
struct|;
end_struct

begin_union
union|union
name|ib_flow_spec
block|{
struct|struct
block|{
name|enum
name|ib_flow_spec_type
name|type
decl_stmt|;
name|u16
name|size
decl_stmt|;
block|}
struct|;
name|struct
name|ib_flow_spec_eth
name|eth
decl_stmt|;
name|struct
name|ib_flow_spec_ib
name|ib
decl_stmt|;
name|struct
name|ib_flow_spec_ipv4
name|ipv4
decl_stmt|;
name|struct
name|ib_flow_spec_tcp_udp
name|tcp_udp
decl_stmt|;
name|struct
name|ib_flow_spec_ipv6
name|ipv6
decl_stmt|;
block|}
union|;
end_union

begin_struct
struct|struct
name|ib_flow_attr
block|{
name|enum
name|ib_flow_attr_type
name|type
decl_stmt|;
name|u16
name|size
decl_stmt|;
name|u16
name|priority
decl_stmt|;
name|u32
name|flags
decl_stmt|;
name|u8
name|num_of_specs
decl_stmt|;
name|u8
name|port
decl_stmt|;
comment|/* Following are the optional layers according to user request 	 * struct ib_flow_spec_xxx 	 * struct ib_flow_spec_yyy 	 */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ib_flow
block|{
name|struct
name|ib_qp
modifier|*
name|qp
decl_stmt|;
name|struct
name|ib_uobject
modifier|*
name|uobject
decl_stmt|;
block|}
struct|;
end_struct

begin_struct_decl
struct_decl|struct
name|ib_mad_hdr
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|ib_grh
struct_decl|;
end_struct_decl

begin_enum
enum|enum
name|ib_process_mad_flags
block|{
name|IB_MAD_IGNORE_MKEY
init|=
literal|1
block|,
name|IB_MAD_IGNORE_BKEY
init|=
literal|2
block|,
name|IB_MAD_IGNORE_ALL
init|=
name|IB_MAD_IGNORE_MKEY
operator||
name|IB_MAD_IGNORE_BKEY
block|}
enum|;
end_enum

begin_enum
enum|enum
name|ib_mad_result
block|{
name|IB_MAD_RESULT_FAILURE
init|=
literal|0
block|,
comment|/* (!SUCCESS is the important flag) */
name|IB_MAD_RESULT_SUCCESS
init|=
literal|1
operator|<<
literal|0
block|,
comment|/* MAD was successfully processed   */
name|IB_MAD_RESULT_REPLY
init|=
literal|1
operator|<<
literal|1
block|,
comment|/* Reply packet needs to be sent    */
name|IB_MAD_RESULT_CONSUMED
init|=
literal|1
operator|<<
literal|2
comment|/* Packet consumed: stop processing */
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|IB_DEVICE_NAME_MAX
value|64
end_define

begin_struct
struct|struct
name|ib_cache
block|{
name|rwlock_t
name|lock
decl_stmt|;
name|struct
name|ib_event_handler
name|event_handler
decl_stmt|;
name|struct
name|ib_pkey_cache
modifier|*
modifier|*
name|pkey_cache
decl_stmt|;
name|struct
name|ib_gid_table
modifier|*
modifier|*
name|gid_cache
decl_stmt|;
name|u8
modifier|*
name|lmc_cache
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ib_dma_mapping_ops
block|{
name|int
function_decl|(
modifier|*
name|mapping_error
function_decl|)
parameter_list|(
name|struct
name|ib_device
modifier|*
name|dev
parameter_list|,
name|u64
name|dma_addr
parameter_list|)
function_decl|;
name|u64
function_decl|(
modifier|*
name|map_single
function_decl|)
parameter_list|(
name|struct
name|ib_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|enum
name|dma_data_direction
name|direction
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|unmap_single
function_decl|)
parameter_list|(
name|struct
name|ib_device
modifier|*
name|dev
parameter_list|,
name|u64
name|addr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|enum
name|dma_data_direction
name|direction
parameter_list|)
function_decl|;
name|u64
function_decl|(
modifier|*
name|map_page
function_decl|)
parameter_list|(
name|struct
name|ib_device
modifier|*
name|dev
parameter_list|,
name|struct
name|page
modifier|*
name|page
parameter_list|,
name|unsigned
name|long
name|offset
parameter_list|,
name|size_t
name|size
parameter_list|,
name|enum
name|dma_data_direction
name|direction
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|unmap_page
function_decl|)
parameter_list|(
name|struct
name|ib_device
modifier|*
name|dev
parameter_list|,
name|u64
name|addr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|enum
name|dma_data_direction
name|direction
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|map_sg
function_decl|)
parameter_list|(
name|struct
name|ib_device
modifier|*
name|dev
parameter_list|,
name|struct
name|scatterlist
modifier|*
name|sg
parameter_list|,
name|int
name|nents
parameter_list|,
name|enum
name|dma_data_direction
name|direction
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|unmap_sg
function_decl|)
parameter_list|(
name|struct
name|ib_device
modifier|*
name|dev
parameter_list|,
name|struct
name|scatterlist
modifier|*
name|sg
parameter_list|,
name|int
name|nents
parameter_list|,
name|enum
name|dma_data_direction
name|direction
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|map_sg_attrs
function_decl|)
parameter_list|(
name|struct
name|ib_device
modifier|*
name|dev
parameter_list|,
name|struct
name|scatterlist
modifier|*
name|sg
parameter_list|,
name|int
name|nents
parameter_list|,
name|enum
name|dma_data_direction
name|direction
parameter_list|,
name|struct
name|dma_attrs
modifier|*
name|attrs
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|unmap_sg_attrs
function_decl|)
parameter_list|(
name|struct
name|ib_device
modifier|*
name|dev
parameter_list|,
name|struct
name|scatterlist
modifier|*
name|sg
parameter_list|,
name|int
name|nents
parameter_list|,
name|enum
name|dma_data_direction
name|direction
parameter_list|,
name|struct
name|dma_attrs
modifier|*
name|attrs
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|sync_single_for_cpu
function_decl|)
parameter_list|(
name|struct
name|ib_device
modifier|*
name|dev
parameter_list|,
name|u64
name|dma_handle
parameter_list|,
name|size_t
name|size
parameter_list|,
name|enum
name|dma_data_direction
name|dir
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|sync_single_for_device
function_decl|)
parameter_list|(
name|struct
name|ib_device
modifier|*
name|dev
parameter_list|,
name|u64
name|dma_handle
parameter_list|,
name|size_t
name|size
parameter_list|,
name|enum
name|dma_data_direction
name|dir
parameter_list|)
function_decl|;
name|void
modifier|*
function_decl|(
modifier|*
name|alloc_coherent
function_decl|)
parameter_list|(
name|struct
name|ib_device
modifier|*
name|dev
parameter_list|,
name|size_t
name|size
parameter_list|,
name|u64
modifier|*
name|dma_handle
parameter_list|,
name|gfp_t
name|flag
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|free_coherent
function_decl|)
parameter_list|(
name|struct
name|ib_device
modifier|*
name|dev
parameter_list|,
name|size_t
name|size
parameter_list|,
name|void
modifier|*
name|cpu_addr
parameter_list|,
name|u64
name|dma_handle
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_struct_decl
struct_decl|struct
name|iw_cm_verbs
struct_decl|;
end_struct_decl

begin_struct
struct|struct
name|ib_port_immutable
block|{
name|int
name|pkey_tbl_len
decl_stmt|;
name|int
name|gid_tbl_len
decl_stmt|;
name|u32
name|core_cap_flags
decl_stmt|;
name|u32
name|max_mad_size
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ib_device
block|{
name|struct
name|device
modifier|*
name|dma_device
decl_stmt|;
name|char
name|name
index|[
name|IB_DEVICE_NAME_MAX
index|]
decl_stmt|;
name|struct
name|list_head
name|event_handler_list
decl_stmt|;
name|spinlock_t
name|event_handler_lock
decl_stmt|;
name|spinlock_t
name|client_data_lock
decl_stmt|;
name|struct
name|list_head
name|core_list
decl_stmt|;
comment|/* Access to the client_data_list is protected by the client_data_lock 	 * spinlock and the lists_rwsem read-write semaphore */
name|struct
name|list_head
name|client_data_list
decl_stmt|;
name|struct
name|ib_cache
name|cache
decl_stmt|;
comment|/** 	 * port_immutable is indexed by port number 	 */
name|struct
name|ib_port_immutable
modifier|*
name|port_immutable
decl_stmt|;
name|int
name|num_comp_vectors
decl_stmt|;
name|struct
name|iw_cm_verbs
modifier|*
name|iwcm
decl_stmt|;
comment|/** 	 * alloc_hw_stats - Allocate a struct rdma_hw_stats and fill in the 	 *   driver initialized data.  The struct is kfree()'ed by the sysfs 	 *   core when the device is removed.  A lifespan of -1 in the return 	 *   struct tells the core to set a default lifespan. 	 */
name|struct
name|rdma_hw_stats
modifier|*
function_decl|(
modifier|*
name|alloc_hw_stats
function_decl|)
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|u8
name|port_num
parameter_list|)
function_decl|;
comment|/** 	 * get_hw_stats - Fill in the counter value(s) in the stats struct. 	 * @index - The index in the value array we wish to have updated, or 	 *   num_counters if we want all stats updated 	 * Return codes - 	 *< 0 - Error, no counters updated 	 *   index - Updated the single counter pointed to by index 	 *   num_counters - Updated all counters (will reset the timestamp 	 *     and prevent further calls for lifespan milliseconds) 	 * Drivers are allowed to update all counters in leiu of just the 	 *   one given in index at their option 	 */
name|int
function_decl|(
modifier|*
name|get_hw_stats
function_decl|)
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|struct
name|rdma_hw_stats
modifier|*
name|stats
parameter_list|,
name|u8
name|port
parameter_list|,
name|int
name|index
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|query_device
function_decl|)
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|struct
name|ib_device_attr
modifier|*
name|device_attr
parameter_list|,
name|struct
name|ib_udata
modifier|*
name|udata
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|query_port
function_decl|)
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|u8
name|port_num
parameter_list|,
name|struct
name|ib_port_attr
modifier|*
name|port_attr
parameter_list|)
function_decl|;
name|enum
name|rdma_link_layer
function_decl|(
modifier|*
name|get_link_layer
function_decl|)
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|u8
name|port_num
parameter_list|)
function_decl|;
comment|/* When calling get_netdev, the HW vendor's driver should return the 	 * net device of device @device at port @port_num or NULL if such 	 * a net device doesn't exist. The vendor driver should call dev_hold 	 * on this net device. The HW vendor's device driver must guarantee 	 * that this function returns NULL before the net device reaches 	 * NETDEV_UNREGISTER_FINAL state. 	 */
name|struct
name|net_device
modifier|*
function_decl|(
modifier|*
name|get_netdev
function_decl|)
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|u8
name|port_num
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|query_gid
function_decl|)
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|u8
name|port_num
parameter_list|,
name|int
name|index
parameter_list|,
name|union
name|ib_gid
modifier|*
name|gid
parameter_list|)
function_decl|;
comment|/* When calling add_gid, the HW vendor's driver should 	 * add the gid of device @device at gid index @index of 	 * port @port_num to be @gid. Meta-info of that gid (for example, 	 * the network device related to this gid is available 	 * at @attr. @context allows the HW vendor driver to store extra 	 * information together with a GID entry. The HW vendor may allocate 	 * memory to contain this information and store it in @context when a 	 * new GID entry is written to. Params are consistent until the next 	 * call of add_gid or delete_gid. The function should return 0 on 	 * success or error otherwise. The function could be called 	 * concurrently for different ports. This function is only called 	 * when roce_gid_table is used. 	 */
name|int
function_decl|(
modifier|*
name|add_gid
function_decl|)
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|u8
name|port_num
parameter_list|,
name|unsigned
name|int
name|index
parameter_list|,
specifier|const
name|union
name|ib_gid
modifier|*
name|gid
parameter_list|,
specifier|const
name|struct
name|ib_gid_attr
modifier|*
name|attr
parameter_list|,
name|void
modifier|*
modifier|*
name|context
parameter_list|)
function_decl|;
comment|/* When calling del_gid, the HW vendor's driver should delete the 	 * gid of device @device at gid index @index of port @port_num. 	 * Upon the deletion of a GID entry, the HW vendor must free any 	 * allocated memory. The caller will clear @context afterwards. 	 * This function is only called when roce_gid_table is used. 	 */
name|int
function_decl|(
modifier|*
name|del_gid
function_decl|)
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|u8
name|port_num
parameter_list|,
name|unsigned
name|int
name|index
parameter_list|,
name|void
modifier|*
modifier|*
name|context
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|query_pkey
function_decl|)
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|u8
name|port_num
parameter_list|,
name|u16
name|index
parameter_list|,
name|u16
modifier|*
name|pkey
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|modify_device
function_decl|)
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|int
name|device_modify_mask
parameter_list|,
name|struct
name|ib_device_modify
modifier|*
name|device_modify
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|modify_port
function_decl|)
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|u8
name|port_num
parameter_list|,
name|int
name|port_modify_mask
parameter_list|,
name|struct
name|ib_port_modify
modifier|*
name|port_modify
parameter_list|)
function_decl|;
name|struct
name|ib_ucontext
modifier|*
function_decl|(
modifier|*
name|alloc_ucontext
function_decl|)
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|struct
name|ib_udata
modifier|*
name|udata
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|dealloc_ucontext
function_decl|)
parameter_list|(
name|struct
name|ib_ucontext
modifier|*
name|context
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|mmap
function_decl|)
parameter_list|(
name|struct
name|ib_ucontext
modifier|*
name|context
parameter_list|,
name|struct
name|vm_area_struct
modifier|*
name|vma
parameter_list|)
function_decl|;
name|struct
name|ib_pd
modifier|*
function_decl|(
modifier|*
name|alloc_pd
function_decl|)
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|struct
name|ib_ucontext
modifier|*
name|context
parameter_list|,
name|struct
name|ib_udata
modifier|*
name|udata
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|dealloc_pd
function_decl|)
parameter_list|(
name|struct
name|ib_pd
modifier|*
name|pd
parameter_list|)
function_decl|;
name|struct
name|ib_ah
modifier|*
function_decl|(
modifier|*
name|create_ah
function_decl|)
parameter_list|(
name|struct
name|ib_pd
modifier|*
name|pd
parameter_list|,
name|struct
name|ib_ah_attr
modifier|*
name|ah_attr
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|modify_ah
function_decl|)
parameter_list|(
name|struct
name|ib_ah
modifier|*
name|ah
parameter_list|,
name|struct
name|ib_ah_attr
modifier|*
name|ah_attr
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|query_ah
function_decl|)
parameter_list|(
name|struct
name|ib_ah
modifier|*
name|ah
parameter_list|,
name|struct
name|ib_ah_attr
modifier|*
name|ah_attr
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|destroy_ah
function_decl|)
parameter_list|(
name|struct
name|ib_ah
modifier|*
name|ah
parameter_list|)
function_decl|;
name|struct
name|ib_srq
modifier|*
function_decl|(
modifier|*
name|create_srq
function_decl|)
parameter_list|(
name|struct
name|ib_pd
modifier|*
name|pd
parameter_list|,
name|struct
name|ib_srq_init_attr
modifier|*
name|srq_init_attr
parameter_list|,
name|struct
name|ib_udata
modifier|*
name|udata
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|modify_srq
function_decl|)
parameter_list|(
name|struct
name|ib_srq
modifier|*
name|srq
parameter_list|,
name|struct
name|ib_srq_attr
modifier|*
name|srq_attr
parameter_list|,
name|enum
name|ib_srq_attr_mask
name|srq_attr_mask
parameter_list|,
name|struct
name|ib_udata
modifier|*
name|udata
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|query_srq
function_decl|)
parameter_list|(
name|struct
name|ib_srq
modifier|*
name|srq
parameter_list|,
name|struct
name|ib_srq_attr
modifier|*
name|srq_attr
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|destroy_srq
function_decl|)
parameter_list|(
name|struct
name|ib_srq
modifier|*
name|srq
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|post_srq_recv
function_decl|)
parameter_list|(
name|struct
name|ib_srq
modifier|*
name|srq
parameter_list|,
name|struct
name|ib_recv_wr
modifier|*
name|recv_wr
parameter_list|,
name|struct
name|ib_recv_wr
modifier|*
modifier|*
name|bad_recv_wr
parameter_list|)
function_decl|;
name|struct
name|ib_qp
modifier|*
function_decl|(
modifier|*
name|create_qp
function_decl|)
parameter_list|(
name|struct
name|ib_pd
modifier|*
name|pd
parameter_list|,
name|struct
name|ib_qp_init_attr
modifier|*
name|qp_init_attr
parameter_list|,
name|struct
name|ib_udata
modifier|*
name|udata
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|modify_qp
function_decl|)
parameter_list|(
name|struct
name|ib_qp
modifier|*
name|qp
parameter_list|,
name|struct
name|ib_qp_attr
modifier|*
name|qp_attr
parameter_list|,
name|int
name|qp_attr_mask
parameter_list|,
name|struct
name|ib_udata
modifier|*
name|udata
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|query_qp
function_decl|)
parameter_list|(
name|struct
name|ib_qp
modifier|*
name|qp
parameter_list|,
name|struct
name|ib_qp_attr
modifier|*
name|qp_attr
parameter_list|,
name|int
name|qp_attr_mask
parameter_list|,
name|struct
name|ib_qp_init_attr
modifier|*
name|qp_init_attr
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|destroy_qp
function_decl|)
parameter_list|(
name|struct
name|ib_qp
modifier|*
name|qp
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|post_send
function_decl|)
parameter_list|(
name|struct
name|ib_qp
modifier|*
name|qp
parameter_list|,
name|struct
name|ib_send_wr
modifier|*
name|send_wr
parameter_list|,
name|struct
name|ib_send_wr
modifier|*
modifier|*
name|bad_send_wr
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|post_recv
function_decl|)
parameter_list|(
name|struct
name|ib_qp
modifier|*
name|qp
parameter_list|,
name|struct
name|ib_recv_wr
modifier|*
name|recv_wr
parameter_list|,
name|struct
name|ib_recv_wr
modifier|*
modifier|*
name|bad_recv_wr
parameter_list|)
function_decl|;
name|struct
name|ib_cq
modifier|*
function_decl|(
modifier|*
name|create_cq
function_decl|)
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
specifier|const
name|struct
name|ib_cq_init_attr
modifier|*
name|attr
parameter_list|,
name|struct
name|ib_ucontext
modifier|*
name|context
parameter_list|,
name|struct
name|ib_udata
modifier|*
name|udata
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|modify_cq
function_decl|)
parameter_list|(
name|struct
name|ib_cq
modifier|*
name|cq
parameter_list|,
name|u16
name|cq_count
parameter_list|,
name|u16
name|cq_period
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|destroy_cq
function_decl|)
parameter_list|(
name|struct
name|ib_cq
modifier|*
name|cq
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|resize_cq
function_decl|)
parameter_list|(
name|struct
name|ib_cq
modifier|*
name|cq
parameter_list|,
name|int
name|cqe
parameter_list|,
name|struct
name|ib_udata
modifier|*
name|udata
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|poll_cq
function_decl|)
parameter_list|(
name|struct
name|ib_cq
modifier|*
name|cq
parameter_list|,
name|int
name|num_entries
parameter_list|,
name|struct
name|ib_wc
modifier|*
name|wc
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|peek_cq
function_decl|)
parameter_list|(
name|struct
name|ib_cq
modifier|*
name|cq
parameter_list|,
name|int
name|wc_cnt
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|req_notify_cq
function_decl|)
parameter_list|(
name|struct
name|ib_cq
modifier|*
name|cq
parameter_list|,
name|enum
name|ib_cq_notify_flags
name|flags
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|req_ncomp_notif
function_decl|)
parameter_list|(
name|struct
name|ib_cq
modifier|*
name|cq
parameter_list|,
name|int
name|wc_cnt
parameter_list|)
function_decl|;
name|struct
name|ib_mr
modifier|*
function_decl|(
modifier|*
name|get_dma_mr
function_decl|)
parameter_list|(
name|struct
name|ib_pd
modifier|*
name|pd
parameter_list|,
name|int
name|mr_access_flags
parameter_list|)
function_decl|;
name|struct
name|ib_mr
modifier|*
function_decl|(
modifier|*
name|reg_user_mr
function_decl|)
parameter_list|(
name|struct
name|ib_pd
modifier|*
name|pd
parameter_list|,
name|u64
name|start
parameter_list|,
name|u64
name|length
parameter_list|,
name|u64
name|virt_addr
parameter_list|,
name|int
name|mr_access_flags
parameter_list|,
name|struct
name|ib_udata
modifier|*
name|udata
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|rereg_user_mr
function_decl|)
parameter_list|(
name|struct
name|ib_mr
modifier|*
name|mr
parameter_list|,
name|int
name|flags
parameter_list|,
name|u64
name|start
parameter_list|,
name|u64
name|length
parameter_list|,
name|u64
name|virt_addr
parameter_list|,
name|int
name|mr_access_flags
parameter_list|,
name|struct
name|ib_pd
modifier|*
name|pd
parameter_list|,
name|struct
name|ib_udata
modifier|*
name|udata
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|dereg_mr
function_decl|)
parameter_list|(
name|struct
name|ib_mr
modifier|*
name|mr
parameter_list|)
function_decl|;
name|struct
name|ib_mr
modifier|*
function_decl|(
modifier|*
name|alloc_mr
function_decl|)
parameter_list|(
name|struct
name|ib_pd
modifier|*
name|pd
parameter_list|,
name|enum
name|ib_mr_type
name|mr_type
parameter_list|,
name|u32
name|max_num_sg
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|map_mr_sg
function_decl|)
parameter_list|(
name|struct
name|ib_mr
modifier|*
name|mr
parameter_list|,
name|struct
name|scatterlist
modifier|*
name|sg
parameter_list|,
name|int
name|sg_nents
parameter_list|,
name|unsigned
name|int
modifier|*
name|sg_offset
parameter_list|)
function_decl|;
name|struct
name|ib_mw
modifier|*
function_decl|(
modifier|*
name|alloc_mw
function_decl|)
parameter_list|(
name|struct
name|ib_pd
modifier|*
name|pd
parameter_list|,
name|enum
name|ib_mw_type
name|type
parameter_list|,
name|struct
name|ib_udata
modifier|*
name|udata
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|dealloc_mw
function_decl|)
parameter_list|(
name|struct
name|ib_mw
modifier|*
name|mw
parameter_list|)
function_decl|;
name|struct
name|ib_fmr
modifier|*
function_decl|(
modifier|*
name|alloc_fmr
function_decl|)
parameter_list|(
name|struct
name|ib_pd
modifier|*
name|pd
parameter_list|,
name|int
name|mr_access_flags
parameter_list|,
name|struct
name|ib_fmr_attr
modifier|*
name|fmr_attr
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|map_phys_fmr
function_decl|)
parameter_list|(
name|struct
name|ib_fmr
modifier|*
name|fmr
parameter_list|,
name|u64
modifier|*
name|page_list
parameter_list|,
name|int
name|list_len
parameter_list|,
name|u64
name|iova
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|unmap_fmr
function_decl|)
parameter_list|(
name|struct
name|list_head
modifier|*
name|fmr_list
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|dealloc_fmr
function_decl|)
parameter_list|(
name|struct
name|ib_fmr
modifier|*
name|fmr
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|attach_mcast
function_decl|)
parameter_list|(
name|struct
name|ib_qp
modifier|*
name|qp
parameter_list|,
name|union
name|ib_gid
modifier|*
name|gid
parameter_list|,
name|u16
name|lid
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|detach_mcast
function_decl|)
parameter_list|(
name|struct
name|ib_qp
modifier|*
name|qp
parameter_list|,
name|union
name|ib_gid
modifier|*
name|gid
parameter_list|,
name|u16
name|lid
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|process_mad
function_decl|)
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|int
name|process_mad_flags
parameter_list|,
name|u8
name|port_num
parameter_list|,
specifier|const
name|struct
name|ib_wc
modifier|*
name|in_wc
parameter_list|,
specifier|const
name|struct
name|ib_grh
modifier|*
name|in_grh
parameter_list|,
specifier|const
name|struct
name|ib_mad_hdr
modifier|*
name|in_mad
parameter_list|,
name|size_t
name|in_mad_size
parameter_list|,
name|struct
name|ib_mad_hdr
modifier|*
name|out_mad
parameter_list|,
name|size_t
modifier|*
name|out_mad_size
parameter_list|,
name|u16
modifier|*
name|out_mad_pkey_index
parameter_list|)
function_decl|;
name|struct
name|ib_xrcd
modifier|*
function_decl|(
modifier|*
name|alloc_xrcd
function_decl|)
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|struct
name|ib_ucontext
modifier|*
name|ucontext
parameter_list|,
name|struct
name|ib_udata
modifier|*
name|udata
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|dealloc_xrcd
function_decl|)
parameter_list|(
name|struct
name|ib_xrcd
modifier|*
name|xrcd
parameter_list|)
function_decl|;
name|struct
name|ib_flow
modifier|*
function_decl|(
modifier|*
name|create_flow
function_decl|)
parameter_list|(
name|struct
name|ib_qp
modifier|*
name|qp
parameter_list|,
name|struct
name|ib_flow_attr
modifier|*
name|flow_attr
parameter_list|,
name|int
name|domain
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|destroy_flow
function_decl|)
parameter_list|(
name|struct
name|ib_flow
modifier|*
name|flow_id
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|check_mr_status
function_decl|)
parameter_list|(
name|struct
name|ib_mr
modifier|*
name|mr
parameter_list|,
name|u32
name|check_mask
parameter_list|,
name|struct
name|ib_mr_status
modifier|*
name|mr_status
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|disassociate_ucontext
function_decl|)
parameter_list|(
name|struct
name|ib_ucontext
modifier|*
name|ibcontext
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|drain_rq
function_decl|)
parameter_list|(
name|struct
name|ib_qp
modifier|*
name|qp
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|drain_sq
function_decl|)
parameter_list|(
name|struct
name|ib_qp
modifier|*
name|qp
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|set_vf_link_state
function_decl|)
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|int
name|vf
parameter_list|,
name|u8
name|port
parameter_list|,
name|int
name|state
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|get_vf_config
function_decl|)
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|int
name|vf
parameter_list|,
name|u8
name|port
parameter_list|,
name|struct
name|ifla_vf_info
modifier|*
name|ivf
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|get_vf_stats
function_decl|)
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|int
name|vf
parameter_list|,
name|u8
name|port
parameter_list|,
name|struct
name|ifla_vf_stats
modifier|*
name|stats
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|set_vf_guid
function_decl|)
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|int
name|vf
parameter_list|,
name|u8
name|port
parameter_list|,
name|u64
name|guid
parameter_list|,
name|int
name|type
parameter_list|)
function_decl|;
name|struct
name|ib_wq
modifier|*
function_decl|(
modifier|*
name|create_wq
function_decl|)
parameter_list|(
name|struct
name|ib_pd
modifier|*
name|pd
parameter_list|,
name|struct
name|ib_wq_init_attr
modifier|*
name|init_attr
parameter_list|,
name|struct
name|ib_udata
modifier|*
name|udata
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|destroy_wq
function_decl|)
parameter_list|(
name|struct
name|ib_wq
modifier|*
name|wq
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|modify_wq
function_decl|)
parameter_list|(
name|struct
name|ib_wq
modifier|*
name|wq
parameter_list|,
name|struct
name|ib_wq_attr
modifier|*
name|attr
parameter_list|,
name|u32
name|wq_attr_mask
parameter_list|,
name|struct
name|ib_udata
modifier|*
name|udata
parameter_list|)
function_decl|;
name|struct
name|ib_rwq_ind_table
modifier|*
function_decl|(
modifier|*
name|create_rwq_ind_table
function_decl|)
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|struct
name|ib_rwq_ind_table_init_attr
modifier|*
name|init_attr
parameter_list|,
name|struct
name|ib_udata
modifier|*
name|udata
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|destroy_rwq_ind_table
function_decl|)
parameter_list|(
name|struct
name|ib_rwq_ind_table
modifier|*
name|wq_ind_table
parameter_list|)
function_decl|;
name|struct
name|ib_dma_mapping_ops
modifier|*
name|dma_ops
decl_stmt|;
name|struct
name|module
modifier|*
name|owner
decl_stmt|;
name|struct
name|device
name|dev
decl_stmt|;
name|struct
name|kobject
modifier|*
name|ports_parent
decl_stmt|;
name|struct
name|list_head
name|port_list
decl_stmt|;
enum|enum
block|{
name|IB_DEV_UNINITIALIZED
block|,
name|IB_DEV_REGISTERED
block|,
name|IB_DEV_UNREGISTERED
block|}
name|reg_state
enum|;
name|int
name|uverbs_abi_ver
decl_stmt|;
name|u64
name|uverbs_cmd_mask
decl_stmt|;
name|u64
name|uverbs_ex_cmd_mask
decl_stmt|;
name|char
name|node_desc
index|[
name|IB_DEVICE_NODE_DESC_MAX
index|]
decl_stmt|;
name|__be64
name|node_guid
decl_stmt|;
name|u32
name|local_dma_lkey
decl_stmt|;
name|u16
name|is_switch
range|:
literal|1
decl_stmt|;
name|u8
name|node_type
decl_stmt|;
name|u8
name|phys_port_cnt
decl_stmt|;
name|struct
name|ib_device_attr
name|attrs
decl_stmt|;
name|struct
name|attribute_group
modifier|*
name|hw_stats_ag
decl_stmt|;
name|struct
name|rdma_hw_stats
modifier|*
name|hw_stats
decl_stmt|;
comment|/** 	 * The following mandatory functions are used only at device 	 * registration.  Keep functions such as these at the end of this 	 * structure to avoid cache line misses when accessing struct ib_device 	 * in fast paths. 	 */
name|int
function_decl|(
modifier|*
name|get_port_immutable
function_decl|)
parameter_list|(
name|struct
name|ib_device
modifier|*
parameter_list|,
name|u8
parameter_list|,
name|struct
name|ib_port_immutable
modifier|*
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|get_dev_fw_str
function_decl|)
parameter_list|(
name|struct
name|ib_device
modifier|*
parameter_list|,
name|char
modifier|*
name|str
parameter_list|,
name|size_t
name|str_len
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ib_client
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|void
function_decl|(
modifier|*
name|add
function_decl|)
parameter_list|(
name|struct
name|ib_device
modifier|*
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|remove
function_decl|)
parameter_list|(
name|struct
name|ib_device
modifier|*
parameter_list|,
name|void
modifier|*
name|client_data
parameter_list|)
function_decl|;
comment|/* Returns the net_dev belonging to this ib_client and matching the 	 * given parameters. 	 * @dev:	 An RDMA device that the net_dev use for communication. 	 * @port:	 A physical port number on the RDMA device. 	 * @pkey:	 P_Key that the net_dev uses if applicable. 	 * @gid:	 A GID that the net_dev uses to communicate. 	 * @addr:	 An IP address the net_dev is configured with. 	 * @client_data: The device's client data set by ib_set_client_data(). 	 * 	 * An ib_client that implements a net_dev on top of RDMA devices 	 * (such as IP over IB) should implement this callback, allowing the 	 * rdma_cm module to find the right net_dev for a given request. 	 * 	 * The caller is responsible for calling dev_put on the returned 	 * netdev. */
name|struct
name|net_device
modifier|*
function_decl|(
modifier|*
name|get_net_dev_by_params
function_decl|)
parameter_list|(
name|struct
name|ib_device
modifier|*
name|dev
parameter_list|,
name|u8
name|port
parameter_list|,
name|u16
name|pkey
parameter_list|,
specifier|const
name|union
name|ib_gid
modifier|*
name|gid
parameter_list|,
specifier|const
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|void
modifier|*
name|client_data
parameter_list|)
function_decl|;
name|struct
name|list_head
name|list
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
name|struct
name|ib_device
modifier|*
name|ib_alloc_device
parameter_list|(
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ib_dealloc_device
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ib_get_device_fw_str
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|char
modifier|*
name|str
parameter_list|,
name|size_t
name|str_len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ib_register_device
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|int
function_decl|(
modifier|*
name|port_callback
function_decl|)
parameter_list|(
name|struct
name|ib_device
modifier|*
parameter_list|,
name|u8
parameter_list|,
name|struct
name|kobject
modifier|*
parameter_list|)
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ib_unregister_device
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ib_register_client
parameter_list|(
name|struct
name|ib_client
modifier|*
name|client
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ib_unregister_client
parameter_list|(
name|struct
name|ib_client
modifier|*
name|client
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
modifier|*
name|ib_get_client_data
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|struct
name|ib_client
modifier|*
name|client
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ib_set_client_data
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|struct
name|ib_client
modifier|*
name|client
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
specifier|inline
name|int
name|ib_copy_from_udata
parameter_list|(
name|void
modifier|*
name|dest
parameter_list|,
name|struct
name|ib_udata
modifier|*
name|udata
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
return|return
name|copy_from_user
argument_list|(
name|dest
argument_list|,
name|udata
operator|->
name|inbuf
argument_list|,
name|len
argument_list|)
condition|?
operator|-
name|EFAULT
else|:
literal|0
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|ib_copy_to_udata
parameter_list|(
name|struct
name|ib_udata
modifier|*
name|udata
parameter_list|,
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
return|return
name|copy_to_user
argument_list|(
name|udata
operator|->
name|outbuf
argument_list|,
name|src
argument_list|,
name|len
argument_list|)
condition|?
operator|-
name|EFAULT
else|:
literal|0
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|bool
name|ib_is_udata_cleared
parameter_list|(
name|struct
name|ib_udata
modifier|*
name|udata
parameter_list|,
name|size_t
name|offset
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
specifier|const
name|void
name|__user
modifier|*
name|p
init|=
operator|(
specifier|const
name|char
name|__user
operator|*
operator|)
name|udata
operator|->
name|inbuf
operator|+
name|offset
decl_stmt|;
name|bool
name|ret
decl_stmt|;
name|u8
modifier|*
name|buf
decl_stmt|;
if|if
condition|(
name|len
operator|>
name|USHRT_MAX
condition|)
return|return
name|false
return|;
name|buf
operator|=
name|memdup_user
argument_list|(
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|buf
argument_list|)
condition|)
return|return
name|false
return|;
name|ret
operator|=
operator|!
name|memchr_inv
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * ib_modify_qp_is_ok - Check that the supplied attribute mask  * contains all required attributes and no attributes not allowed for  * the given QP state transition.  * @cur_state: Current QP state  * @next_state: Next QP state  * @type: QP type  * @mask: Mask of supplied QP attributes  * @ll : link layer of port  *  * This function is a helper function that a low-level driver's  * modify_qp method can use to validate the consumer's input.  It  * checks that cur_state and next_state are valid QP states, that a  * transition from cur_state to next_state is allowed by the IB spec,  * and that the attribute mask supplied is allowed for the transition.  */
end_comment

begin_function_decl
name|int
name|ib_modify_qp_is_ok
parameter_list|(
name|enum
name|ib_qp_state
name|cur_state
parameter_list|,
name|enum
name|ib_qp_state
name|next_state
parameter_list|,
name|enum
name|ib_qp_type
name|type
parameter_list|,
name|enum
name|ib_qp_attr_mask
name|mask
parameter_list|,
name|enum
name|rdma_link_layer
name|ll
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ib_register_event_handler
parameter_list|(
name|struct
name|ib_event_handler
modifier|*
name|event_handler
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ib_unregister_event_handler
parameter_list|(
name|struct
name|ib_event_handler
modifier|*
name|event_handler
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ib_dispatch_event
parameter_list|(
name|struct
name|ib_event
modifier|*
name|event
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ib_query_port
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|u8
name|port_num
parameter_list|,
name|struct
name|ib_port_attr
modifier|*
name|port_attr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|enum
name|rdma_link_layer
name|rdma_port_get_link_layer
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|u8
name|port_num
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * rdma_cap_ib_switch - Check if the device is IB switch  * @device: Device to check  *  * Device driver is responsible for setting is_switch bit on  * in ib_device structure at init time.  *  * Return: true if the device is IB switch.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|rdma_cap_ib_switch
parameter_list|(
specifier|const
name|struct
name|ib_device
modifier|*
name|device
parameter_list|)
block|{
return|return
name|device
operator|->
name|is_switch
return|;
block|}
end_function

begin_comment
comment|/**  * rdma_start_port - Return the first valid port number for the device  * specified  *  * @device: Device to be checked  *  * Return start port number  */
end_comment

begin_function
specifier|static
specifier|inline
name|u8
name|rdma_start_port
parameter_list|(
specifier|const
name|struct
name|ib_device
modifier|*
name|device
parameter_list|)
block|{
return|return
name|rdma_cap_ib_switch
argument_list|(
name|device
argument_list|)
condition|?
literal|0
else|:
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * rdma_end_port - Return the last valid port number for the device  * specified  *  * @device: Device to be checked  *  * Return last port number  */
end_comment

begin_function
specifier|static
specifier|inline
name|u8
name|rdma_end_port
parameter_list|(
specifier|const
name|struct
name|ib_device
modifier|*
name|device
parameter_list|)
block|{
return|return
name|rdma_cap_ib_switch
argument_list|(
name|device
argument_list|)
condition|?
literal|0
else|:
name|device
operator|->
name|phys_port_cnt
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|bool
name|rdma_protocol_ib
parameter_list|(
specifier|const
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|u8
name|port_num
parameter_list|)
block|{
return|return
name|device
operator|->
name|port_immutable
index|[
name|port_num
index|]
operator|.
name|core_cap_flags
operator|&
name|RDMA_CORE_CAP_PROT_IB
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|bool
name|rdma_protocol_roce
parameter_list|(
specifier|const
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|u8
name|port_num
parameter_list|)
block|{
return|return
name|device
operator|->
name|port_immutable
index|[
name|port_num
index|]
operator|.
name|core_cap_flags
operator|&
operator|(
name|RDMA_CORE_CAP_PROT_ROCE
operator||
name|RDMA_CORE_CAP_PROT_ROCE_UDP_ENCAP
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|bool
name|rdma_protocol_roce_udp_encap
parameter_list|(
specifier|const
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|u8
name|port_num
parameter_list|)
block|{
return|return
name|device
operator|->
name|port_immutable
index|[
name|port_num
index|]
operator|.
name|core_cap_flags
operator|&
name|RDMA_CORE_CAP_PROT_ROCE_UDP_ENCAP
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|bool
name|rdma_protocol_roce_eth_encap
parameter_list|(
specifier|const
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|u8
name|port_num
parameter_list|)
block|{
return|return
name|device
operator|->
name|port_immutable
index|[
name|port_num
index|]
operator|.
name|core_cap_flags
operator|&
name|RDMA_CORE_CAP_PROT_ROCE
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|bool
name|rdma_protocol_iwarp
parameter_list|(
specifier|const
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|u8
name|port_num
parameter_list|)
block|{
return|return
name|device
operator|->
name|port_immutable
index|[
name|port_num
index|]
operator|.
name|core_cap_flags
operator|&
name|RDMA_CORE_CAP_PROT_IWARP
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|bool
name|rdma_ib_or_roce
parameter_list|(
specifier|const
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|u8
name|port_num
parameter_list|)
block|{
return|return
name|rdma_protocol_ib
argument_list|(
name|device
argument_list|,
name|port_num
argument_list|)
operator|||
name|rdma_protocol_roce
argument_list|(
name|device
argument_list|,
name|port_num
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * rdma_cap_ib_mad - Check if the port of a device supports Infiniband  * Management Datagrams.  * @device: Device to check  * @port_num: Port number to check  *  * Management Datagrams (MAD) are a required part of the InfiniBand  * specification and are supported on all InfiniBand devices.  A slightly  * extended version are also supported on OPA interfaces.  *  * Return: true if the port supports sending/receiving of MAD packets.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|rdma_cap_ib_mad
parameter_list|(
specifier|const
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|u8
name|port_num
parameter_list|)
block|{
return|return
name|device
operator|->
name|port_immutable
index|[
name|port_num
index|]
operator|.
name|core_cap_flags
operator|&
name|RDMA_CORE_CAP_IB_MAD
return|;
block|}
end_function

begin_comment
comment|/**  * rdma_cap_opa_mad - Check if the port of device provides support for OPA  * Management Datagrams.  * @device: Device to check  * @port_num: Port number to check  *  * Intel OmniPath devices extend and/or replace the InfiniBand Management  * datagrams with their own versions.  These OPA MADs share many but not all of  * the characteristics of InfiniBand MADs.  *  * OPA MADs differ in the following ways:  *  *    1) MADs are variable size up to 2K  *       IBTA defined MADs remain fixed at 256 bytes  *    2) OPA SMPs must carry valid PKeys  *    3) OPA SMP packets are a different format  *  * Return: true if the port supports OPA MAD packet formats.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|rdma_cap_opa_mad
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|u8
name|port_num
parameter_list|)
block|{
return|return
operator|(
name|device
operator|->
name|port_immutable
index|[
name|port_num
index|]
operator|.
name|core_cap_flags
operator|&
name|RDMA_CORE_CAP_OPA_MAD
operator|)
operator|==
name|RDMA_CORE_CAP_OPA_MAD
return|;
block|}
end_function

begin_comment
comment|/**  * rdma_cap_ib_smi - Check if the port of a device provides an Infiniband  * Subnet Management Agent (SMA) on the Subnet Management Interface (SMI).  * @device: Device to check  * @port_num: Port number to check  *  * Each InfiniBand node is required to provide a Subnet Management Agent  * that the subnet manager can access.  Prior to the fabric being fully  * configured by the subnet manager, the SMA is accessed via a well known  * interface called the Subnet Management Interface (SMI).  This interface  * uses directed route packets to communicate with the SM to get around the  * chicken and egg problem of the SM needing to know what's on the fabric  * in order to configure the fabric, and needing to configure the fabric in  * order to send packets to the devices on the fabric.  These directed  * route packets do not need the fabric fully configured in order to reach  * their destination.  The SMI is the only method allowed to send  * directed route packets on an InfiniBand fabric.  *  * Return: true if the port provides an SMI.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|rdma_cap_ib_smi
parameter_list|(
specifier|const
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|u8
name|port_num
parameter_list|)
block|{
return|return
name|device
operator|->
name|port_immutable
index|[
name|port_num
index|]
operator|.
name|core_cap_flags
operator|&
name|RDMA_CORE_CAP_IB_SMI
return|;
block|}
end_function

begin_comment
comment|/**  * rdma_cap_ib_cm - Check if the port of device has the capability Infiniband  * Communication Manager.  * @device: Device to check  * @port_num: Port number to check  *  * The InfiniBand Communication Manager is one of many pre-defined General  * Service Agents (GSA) that are accessed via the General Service  * Interface (GSI).  It's role is to facilitate establishment of connections  * between nodes as well as other management related tasks for established  * connections.  *  * Return: true if the port supports an IB CM (this does not guarantee that  * a CM is actually running however).  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|rdma_cap_ib_cm
parameter_list|(
specifier|const
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|u8
name|port_num
parameter_list|)
block|{
return|return
name|device
operator|->
name|port_immutable
index|[
name|port_num
index|]
operator|.
name|core_cap_flags
operator|&
name|RDMA_CORE_CAP_IB_CM
return|;
block|}
end_function

begin_comment
comment|/**  * rdma_cap_iw_cm - Check if the port of device has the capability IWARP  * Communication Manager.  * @device: Device to check  * @port_num: Port number to check  *  * Similar to above, but specific to iWARP connections which have a different  * managment protocol than InfiniBand.  *  * Return: true if the port supports an iWARP CM (this does not guarantee that  * a CM is actually running however).  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|rdma_cap_iw_cm
parameter_list|(
specifier|const
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|u8
name|port_num
parameter_list|)
block|{
return|return
name|device
operator|->
name|port_immutable
index|[
name|port_num
index|]
operator|.
name|core_cap_flags
operator|&
name|RDMA_CORE_CAP_IW_CM
return|;
block|}
end_function

begin_comment
comment|/**  * rdma_cap_ib_sa - Check if the port of device has the capability Infiniband  * Subnet Administration.  * @device: Device to check  * @port_num: Port number to check  *  * An InfiniBand Subnet Administration (SA) service is a pre-defined General  * Service Agent (GSA) provided by the Subnet Manager (SM).  On InfiniBand  * fabrics, devices should resolve routes to other hosts by contacting the  * SA to query the proper route.  *  * Return: true if the port should act as a client to the fabric Subnet  * Administration interface.  This does not imply that the SA service is  * running locally.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|rdma_cap_ib_sa
parameter_list|(
specifier|const
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|u8
name|port_num
parameter_list|)
block|{
return|return
name|device
operator|->
name|port_immutable
index|[
name|port_num
index|]
operator|.
name|core_cap_flags
operator|&
name|RDMA_CORE_CAP_IB_SA
return|;
block|}
end_function

begin_comment
comment|/**  * rdma_cap_ib_mcast - Check if the port of device has the capability Infiniband  * Multicast.  * @device: Device to check  * @port_num: Port number to check  *  * InfiniBand multicast registration is more complex than normal IPv4 or  * IPv6 multicast registration.  Each Host Channel Adapter must register  * with the Subnet Manager when it wishes to join a multicast group.  It  * should do so only once regardless of how many queue pairs it subscribes  * to this group.  And it should leave the group only after all queue pairs  * attached to the group have been detached.  *  * Return: true if the port must undertake the additional adminstrative  * overhead of registering/unregistering with the SM and tracking of the  * total number of queue pairs attached to the multicast group.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|rdma_cap_ib_mcast
parameter_list|(
specifier|const
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|u8
name|port_num
parameter_list|)
block|{
return|return
name|rdma_cap_ib_sa
argument_list|(
name|device
argument_list|,
name|port_num
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * rdma_cap_af_ib - Check if the port of device has the capability  * Native Infiniband Address.  * @device: Device to check  * @port_num: Port number to check  *  * InfiniBand addressing uses a port's GUID + Subnet Prefix to make a default  * GID.  RoCE uses a different mechanism, but still generates a GID via  * a prescribed mechanism and port specific data.  *  * Return: true if the port uses a GID address to identify devices on the  * network.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|rdma_cap_af_ib
parameter_list|(
specifier|const
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|u8
name|port_num
parameter_list|)
block|{
return|return
name|device
operator|->
name|port_immutable
index|[
name|port_num
index|]
operator|.
name|core_cap_flags
operator|&
name|RDMA_CORE_CAP_AF_IB
return|;
block|}
end_function

begin_comment
comment|/**  * rdma_cap_eth_ah - Check if the port of device has the capability  * Ethernet Address Handle.  * @device: Device to check  * @port_num: Port number to check  *  * RoCE is InfiniBand over Ethernet, and it uses a well defined technique  * to fabricate GIDs over Ethernet/IP specific addresses native to the  * port.  Normally, packet headers are generated by the sending host  * adapter, but when sending connectionless datagrams, we must manually  * inject the proper headers for the fabric we are communicating over.  *  * Return: true if we are running as a RoCE port and must force the  * addition of a Global Route Header built from our Ethernet Address  * Handle into our header list for connectionless packets.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|rdma_cap_eth_ah
parameter_list|(
specifier|const
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|u8
name|port_num
parameter_list|)
block|{
return|return
name|device
operator|->
name|port_immutable
index|[
name|port_num
index|]
operator|.
name|core_cap_flags
operator|&
name|RDMA_CORE_CAP_ETH_AH
return|;
block|}
end_function

begin_comment
comment|/**  * rdma_max_mad_size - Return the max MAD size required by this RDMA Port.  *  * @device: Device  * @port_num: Port number  *  * This MAD size includes the MAD headers and MAD payload.  No other headers  * are included.  *  * Return the max MAD size required by the Port.  Will return 0 if the port  * does not support MADs  */
end_comment

begin_function
specifier|static
specifier|inline
name|size_t
name|rdma_max_mad_size
parameter_list|(
specifier|const
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|u8
name|port_num
parameter_list|)
block|{
return|return
name|device
operator|->
name|port_immutable
index|[
name|port_num
index|]
operator|.
name|max_mad_size
return|;
block|}
end_function

begin_comment
comment|/**  * rdma_cap_roce_gid_table - Check if the port of device uses roce_gid_table  * @device: Device to check  * @port_num: Port number to check  *  * RoCE GID table mechanism manages the various GIDs for a device.  *  * NOTE: if allocating the port's GID table has failed, this call will still  * return true, but any RoCE GID table API will fail.  *  * Return: true if the port uses RoCE GID table mechanism in order to manage  * its GIDs.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|rdma_cap_roce_gid_table
parameter_list|(
specifier|const
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|u8
name|port_num
parameter_list|)
block|{
return|return
name|rdma_protocol_roce
argument_list|(
name|device
argument_list|,
name|port_num
argument_list|)
operator|&&
name|device
operator|->
name|add_gid
operator|&&
name|device
operator|->
name|del_gid
return|;
block|}
end_function

begin_comment
comment|/*  * Check if the device supports READ W/ INVALIDATE.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|rdma_cap_read_inv
parameter_list|(
name|struct
name|ib_device
modifier|*
name|dev
parameter_list|,
name|u32
name|port_num
parameter_list|)
block|{
comment|/* 	 * iWarp drivers must support READ W/ INVALIDATE.  No other protocol 	 * has support for it yet. 	 */
return|return
name|rdma_protocol_iwarp
argument_list|(
name|dev
argument_list|,
name|port_num
argument_list|)
return|;
block|}
end_function

begin_function_decl
name|int
name|ib_query_gid
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|u8
name|port_num
parameter_list|,
name|int
name|index
parameter_list|,
name|union
name|ib_gid
modifier|*
name|gid
parameter_list|,
name|struct
name|ib_gid_attr
modifier|*
name|attr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ib_set_vf_link_state
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|int
name|vf
parameter_list|,
name|u8
name|port
parameter_list|,
name|int
name|state
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ib_get_vf_config
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|int
name|vf
parameter_list|,
name|u8
name|port
parameter_list|,
name|struct
name|ifla_vf_info
modifier|*
name|info
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ib_get_vf_stats
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|int
name|vf
parameter_list|,
name|u8
name|port
parameter_list|,
name|struct
name|ifla_vf_stats
modifier|*
name|stats
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ib_set_vf_guid
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|int
name|vf
parameter_list|,
name|u8
name|port
parameter_list|,
name|u64
name|guid
parameter_list|,
name|int
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ib_query_pkey
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|u8
name|port_num
parameter_list|,
name|u16
name|index
parameter_list|,
name|u16
modifier|*
name|pkey
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ib_modify_device
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|int
name|device_modify_mask
parameter_list|,
name|struct
name|ib_device_modify
modifier|*
name|device_modify
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ib_modify_port
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|u8
name|port_num
parameter_list|,
name|int
name|port_modify_mask
parameter_list|,
name|struct
name|ib_port_modify
modifier|*
name|port_modify
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ib_find_gid
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|union
name|ib_gid
modifier|*
name|gid
parameter_list|,
name|enum
name|ib_gid_type
name|gid_type
parameter_list|,
name|struct
name|net_device
modifier|*
name|ndev
parameter_list|,
name|u8
modifier|*
name|port_num
parameter_list|,
name|u16
modifier|*
name|index
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ib_find_pkey
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|u8
name|port_num
parameter_list|,
name|u16
name|pkey
parameter_list|,
name|u16
modifier|*
name|index
parameter_list|)
function_decl|;
end_function_decl

begin_enum
enum|enum
name|ib_pd_flags
block|{
comment|/* 	 * Create a memory registration for all memory in the system and place 	 * the rkey for it into pd->unsafe_global_rkey.  This can be used by 	 * ULPs to avoid the overhead of dynamic MRs. 	 * 	 * This flag is generally considered unsafe and must only be used in 	 * extremly trusted environments.  Every use of it will log a warning 	 * in the kernel log. 	 */
name|IB_PD_UNSAFE_GLOBAL_RKEY
init|=
literal|0x01
block|, }
enum|;
end_enum

begin_function_decl
name|struct
name|ib_pd
modifier|*
name|__ib_alloc_pd
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|,
specifier|const
name|char
modifier|*
name|caller
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|ib_alloc_pd
parameter_list|(
name|device
parameter_list|,
name|flags
parameter_list|)
define|\
value|__ib_alloc_pd((device), (flags), __func__)
end_define

begin_function_decl
name|void
name|ib_dealloc_pd
parameter_list|(
name|struct
name|ib_pd
modifier|*
name|pd
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * ib_create_ah - Creates an address handle for the given address vector.  * @pd: The protection domain associated with the address handle.  * @ah_attr: The attributes of the address vector.  *  * The address handle is used to reference a local or global destination  * in all UD QP post sends.  */
end_comment

begin_function_decl
name|struct
name|ib_ah
modifier|*
name|ib_create_ah
parameter_list|(
name|struct
name|ib_pd
modifier|*
name|pd
parameter_list|,
name|struct
name|ib_ah_attr
modifier|*
name|ah_attr
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * ib_init_ah_from_wc - Initializes address handle attributes from a  *   work completion.  * @device: Device on which the received message arrived.  * @port_num: Port on which the received message arrived.  * @wc: Work completion associated with the received message.  * @grh: References the received global route header.  This parameter is  *   ignored unless the work completion indicates that the GRH is valid.  * @ah_attr: Returned attributes that can be used when creating an address  *   handle for replying to the message.  */
end_comment

begin_function_decl
name|int
name|ib_init_ah_from_wc
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|u8
name|port_num
parameter_list|,
specifier|const
name|struct
name|ib_wc
modifier|*
name|wc
parameter_list|,
specifier|const
name|struct
name|ib_grh
modifier|*
name|grh
parameter_list|,
name|struct
name|ib_ah_attr
modifier|*
name|ah_attr
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * ib_create_ah_from_wc - Creates an address handle associated with the  *   sender of the specified work completion.  * @pd: The protection domain associated with the address handle.  * @wc: Work completion information associated with a received message.  * @grh: References the received global route header.  This parameter is  *   ignored unless the work completion indicates that the GRH is valid.  * @port_num: The outbound port number to associate with the address.  *  * The address handle is used to reference a local or global destination  * in all UD QP post sends.  */
end_comment

begin_function_decl
name|struct
name|ib_ah
modifier|*
name|ib_create_ah_from_wc
parameter_list|(
name|struct
name|ib_pd
modifier|*
name|pd
parameter_list|,
specifier|const
name|struct
name|ib_wc
modifier|*
name|wc
parameter_list|,
specifier|const
name|struct
name|ib_grh
modifier|*
name|grh
parameter_list|,
name|u8
name|port_num
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * ib_modify_ah - Modifies the address vector associated with an address  *   handle.  * @ah: The address handle to modify.  * @ah_attr: The new address vector attributes to associate with the  *   address handle.  */
end_comment

begin_function_decl
name|int
name|ib_modify_ah
parameter_list|(
name|struct
name|ib_ah
modifier|*
name|ah
parameter_list|,
name|struct
name|ib_ah_attr
modifier|*
name|ah_attr
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * ib_query_ah - Queries the address vector associated with an address  *   handle.  * @ah: The address handle to query.  * @ah_attr: The address vector attributes associated with the address  *   handle.  */
end_comment

begin_function_decl
name|int
name|ib_query_ah
parameter_list|(
name|struct
name|ib_ah
modifier|*
name|ah
parameter_list|,
name|struct
name|ib_ah_attr
modifier|*
name|ah_attr
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * ib_destroy_ah - Destroys an address handle.  * @ah: The address handle to destroy.  */
end_comment

begin_function_decl
name|int
name|ib_destroy_ah
parameter_list|(
name|struct
name|ib_ah
modifier|*
name|ah
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * ib_create_srq - Creates a SRQ associated with the specified protection  *   domain.  * @pd: The protection domain associated with the SRQ.  * @srq_init_attr: A list of initial attributes required to create the  *   SRQ.  If SRQ creation succeeds, then the attributes are updated to  *   the actual capabilities of the created SRQ.  *  * srq_attr->max_wr and srq_attr->max_sge are read the determine the  * requested size of the SRQ, and set to the actual values allocated  * on return.  If ib_create_srq() succeeds, then max_wr and max_sge  * will always be at least as large as the requested values.  */
end_comment

begin_function_decl
name|struct
name|ib_srq
modifier|*
name|ib_create_srq
parameter_list|(
name|struct
name|ib_pd
modifier|*
name|pd
parameter_list|,
name|struct
name|ib_srq_init_attr
modifier|*
name|srq_init_attr
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * ib_modify_srq - Modifies the attributes for the specified SRQ.  * @srq: The SRQ to modify.  * @srq_attr: On input, specifies the SRQ attributes to modify.  On output,  *   the current values of selected SRQ attributes are returned.  * @srq_attr_mask: A bit-mask used to specify which attributes of the SRQ  *   are being modified.  *  * The mask may contain IB_SRQ_MAX_WR to resize the SRQ and/or  * IB_SRQ_LIMIT to set the SRQ's limit and request notification when  * the number of receives queued drops below the limit.  */
end_comment

begin_function_decl
name|int
name|ib_modify_srq
parameter_list|(
name|struct
name|ib_srq
modifier|*
name|srq
parameter_list|,
name|struct
name|ib_srq_attr
modifier|*
name|srq_attr
parameter_list|,
name|enum
name|ib_srq_attr_mask
name|srq_attr_mask
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * ib_query_srq - Returns the attribute list and current values for the  *   specified SRQ.  * @srq: The SRQ to query.  * @srq_attr: The attributes of the specified SRQ.  */
end_comment

begin_function_decl
name|int
name|ib_query_srq
parameter_list|(
name|struct
name|ib_srq
modifier|*
name|srq
parameter_list|,
name|struct
name|ib_srq_attr
modifier|*
name|srq_attr
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * ib_destroy_srq - Destroys the specified SRQ.  * @srq: The SRQ to destroy.  */
end_comment

begin_function_decl
name|int
name|ib_destroy_srq
parameter_list|(
name|struct
name|ib_srq
modifier|*
name|srq
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * ib_post_srq_recv - Posts a list of work requests to the specified SRQ.  * @srq: The SRQ to post the work request on.  * @recv_wr: A list of work requests to post on the receive queue.  * @bad_recv_wr: On an immediate failure, this parameter will reference  *   the work request that failed to be posted on the QP.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|ib_post_srq_recv
parameter_list|(
name|struct
name|ib_srq
modifier|*
name|srq
parameter_list|,
name|struct
name|ib_recv_wr
modifier|*
name|recv_wr
parameter_list|,
name|struct
name|ib_recv_wr
modifier|*
modifier|*
name|bad_recv_wr
parameter_list|)
block|{
return|return
name|srq
operator|->
name|device
operator|->
name|post_srq_recv
argument_list|(
name|srq
argument_list|,
name|recv_wr
argument_list|,
name|bad_recv_wr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * ib_create_qp - Creates a QP associated with the specified protection  *   domain.  * @pd: The protection domain associated with the QP.  * @qp_init_attr: A list of initial attributes required to create the  *   QP.  If QP creation succeeds, then the attributes are updated to  *   the actual capabilities of the created QP.  */
end_comment

begin_function_decl
name|struct
name|ib_qp
modifier|*
name|ib_create_qp
parameter_list|(
name|struct
name|ib_pd
modifier|*
name|pd
parameter_list|,
name|struct
name|ib_qp_init_attr
modifier|*
name|qp_init_attr
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * ib_modify_qp - Modifies the attributes for the specified QP and then  *   transitions the QP to the given state.  * @qp: The QP to modify.  * @qp_attr: On input, specifies the QP attributes to modify.  On output,  *   the current values of selected QP attributes are returned.  * @qp_attr_mask: A bit-mask used to specify which attributes of the QP  *   are being modified.  */
end_comment

begin_function_decl
name|int
name|ib_modify_qp
parameter_list|(
name|struct
name|ib_qp
modifier|*
name|qp
parameter_list|,
name|struct
name|ib_qp_attr
modifier|*
name|qp_attr
parameter_list|,
name|int
name|qp_attr_mask
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * ib_query_qp - Returns the attribute list and current values for the  *   specified QP.  * @qp: The QP to query.  * @qp_attr: The attributes of the specified QP.  * @qp_attr_mask: A bit-mask used to select specific attributes to query.  * @qp_init_attr: Additional attributes of the selected QP.  *  * The qp_attr_mask may be used to limit the query to gathering only the  * selected attributes.  */
end_comment

begin_function_decl
name|int
name|ib_query_qp
parameter_list|(
name|struct
name|ib_qp
modifier|*
name|qp
parameter_list|,
name|struct
name|ib_qp_attr
modifier|*
name|qp_attr
parameter_list|,
name|int
name|qp_attr_mask
parameter_list|,
name|struct
name|ib_qp_init_attr
modifier|*
name|qp_init_attr
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * ib_destroy_qp - Destroys the specified QP.  * @qp: The QP to destroy.  */
end_comment

begin_function_decl
name|int
name|ib_destroy_qp
parameter_list|(
name|struct
name|ib_qp
modifier|*
name|qp
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * ib_open_qp - Obtain a reference to an existing sharable QP.  * @xrcd - XRC domain  * @qp_open_attr: Attributes identifying the QP to open.  *  * Returns a reference to a sharable QP.  */
end_comment

begin_function_decl
name|struct
name|ib_qp
modifier|*
name|ib_open_qp
parameter_list|(
name|struct
name|ib_xrcd
modifier|*
name|xrcd
parameter_list|,
name|struct
name|ib_qp_open_attr
modifier|*
name|qp_open_attr
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * ib_close_qp - Release an external reference to a QP.  * @qp: The QP handle to release  *  * The opened QP handle is released by the caller.  The underlying  * shared QP is not destroyed until all internal references are released.  */
end_comment

begin_function_decl
name|int
name|ib_close_qp
parameter_list|(
name|struct
name|ib_qp
modifier|*
name|qp
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * ib_post_send - Posts a list of work requests to the send queue of  *   the specified QP.  * @qp: The QP to post the work request on.  * @send_wr: A list of work requests to post on the send queue.  * @bad_send_wr: On an immediate failure, this parameter will reference  *   the work request that failed to be posted on the QP.  *  * While IBA Vol. 1 section 11.4.1.1 specifies that if an immediate  * error is returned, the QP state shall not be affected,  * ib_post_send() will return an immediate error after queueing any  * earlier work requests in the list.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|ib_post_send
parameter_list|(
name|struct
name|ib_qp
modifier|*
name|qp
parameter_list|,
name|struct
name|ib_send_wr
modifier|*
name|send_wr
parameter_list|,
name|struct
name|ib_send_wr
modifier|*
modifier|*
name|bad_send_wr
parameter_list|)
block|{
return|return
name|qp
operator|->
name|device
operator|->
name|post_send
argument_list|(
name|qp
argument_list|,
name|send_wr
argument_list|,
name|bad_send_wr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * ib_post_recv - Posts a list of work requests to the receive queue of  *   the specified QP.  * @qp: The QP to post the work request on.  * @recv_wr: A list of work requests to post on the receive queue.  * @bad_recv_wr: On an immediate failure, this parameter will reference  *   the work request that failed to be posted on the QP.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|ib_post_recv
parameter_list|(
name|struct
name|ib_qp
modifier|*
name|qp
parameter_list|,
name|struct
name|ib_recv_wr
modifier|*
name|recv_wr
parameter_list|,
name|struct
name|ib_recv_wr
modifier|*
modifier|*
name|bad_recv_wr
parameter_list|)
block|{
return|return
name|qp
operator|->
name|device
operator|->
name|post_recv
argument_list|(
name|qp
argument_list|,
name|recv_wr
argument_list|,
name|bad_recv_wr
argument_list|)
return|;
block|}
end_function

begin_function_decl
name|struct
name|ib_cq
modifier|*
name|ib_alloc_cq
parameter_list|(
name|struct
name|ib_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|private
parameter_list|,
name|int
name|nr_cqe
parameter_list|,
name|int
name|comp_vector
parameter_list|,
name|enum
name|ib_poll_context
name|poll_ctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ib_free_cq
parameter_list|(
name|struct
name|ib_cq
modifier|*
name|cq
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * ib_create_cq - Creates a CQ on the specified device.  * @device: The device on which to create the CQ.  * @comp_handler: A user-specified callback that is invoked when a  *   completion event occurs on the CQ.  * @event_handler: A user-specified callback that is invoked when an  *   asynchronous event not associated with a completion occurs on the CQ.  * @cq_context: Context associated with the CQ returned to the user via  *   the associated completion and event handlers.  * @cq_attr: The attributes the CQ should be created upon.  *  * Users can examine the cq structure to determine the actual CQ size.  */
end_comment

begin_function_decl
name|struct
name|ib_cq
modifier|*
name|ib_create_cq
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|ib_comp_handler
name|comp_handler
parameter_list|,
name|void
function_decl|(
modifier|*
name|event_handler
function_decl|)
parameter_list|(
name|struct
name|ib_event
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|cq_context
parameter_list|,
specifier|const
name|struct
name|ib_cq_init_attr
modifier|*
name|cq_attr
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * ib_resize_cq - Modifies the capacity of the CQ.  * @cq: The CQ to resize.  * @cqe: The minimum size of the CQ.  *  * Users can examine the cq structure to determine the actual CQ size.  */
end_comment

begin_function_decl
name|int
name|ib_resize_cq
parameter_list|(
name|struct
name|ib_cq
modifier|*
name|cq
parameter_list|,
name|int
name|cqe
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * ib_modify_cq - Modifies moderation params of the CQ  * @cq: The CQ to modify.  * @cq_count: number of CQEs that will trigger an event  * @cq_period: max period of time in usec before triggering an event  *  */
end_comment

begin_function_decl
name|int
name|ib_modify_cq
parameter_list|(
name|struct
name|ib_cq
modifier|*
name|cq
parameter_list|,
name|u16
name|cq_count
parameter_list|,
name|u16
name|cq_period
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * ib_destroy_cq - Destroys the specified CQ.  * @cq: The CQ to destroy.  */
end_comment

begin_function_decl
name|int
name|ib_destroy_cq
parameter_list|(
name|struct
name|ib_cq
modifier|*
name|cq
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * ib_poll_cq - poll a CQ for completion(s)  * @cq:the CQ being polled  * @num_entries:maximum number of completions to return  * @wc:array of at least @num_entries&struct ib_wc where completions  *   will be returned  *  * Poll a CQ for (possibly multiple) completions.  If the return value  * is< 0, an error occurred.  If the return value is>= 0, it is the  * number of completions returned.  If the return value is  * non-negative and< num_entries, then the CQ was emptied.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|ib_poll_cq
parameter_list|(
name|struct
name|ib_cq
modifier|*
name|cq
parameter_list|,
name|int
name|num_entries
parameter_list|,
name|struct
name|ib_wc
modifier|*
name|wc
parameter_list|)
block|{
return|return
name|cq
operator|->
name|device
operator|->
name|poll_cq
argument_list|(
name|cq
argument_list|,
name|num_entries
argument_list|,
name|wc
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * ib_peek_cq - Returns the number of unreaped completions currently  *   on the specified CQ.  * @cq: The CQ to peek.  * @wc_cnt: A minimum number of unreaped completions to check for.  *  * If the number of unreaped completions is greater than or equal to wc_cnt,  * this function returns wc_cnt, otherwise, it returns the actual number of  * unreaped completions.  */
end_comment

begin_function_decl
name|int
name|ib_peek_cq
parameter_list|(
name|struct
name|ib_cq
modifier|*
name|cq
parameter_list|,
name|int
name|wc_cnt
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * ib_req_notify_cq - Request completion notification on a CQ.  * @cq: The CQ to generate an event for.  * @flags:  *   Must contain exactly one of %IB_CQ_SOLICITED or %IB_CQ_NEXT_COMP  *   to request an event on the next solicited event or next work  *   completion at any type, respectively. %IB_CQ_REPORT_MISSED_EVENTS  *   may also be |ed in to request a hint about missed events, as  *   described below.  *  * Return Value:  *< 0 means an error occurred while requesting notification  *   == 0 means notification was requested successfully, and if  *        IB_CQ_REPORT_MISSED_EVENTS was passed in, then no events  *        were missed and it is safe to wait for another event.  In  *        this case is it guaranteed that any work completions added  *        to the CQ since the last CQ poll will trigger a completion  *        notification event.  *> 0 is only returned if IB_CQ_REPORT_MISSED_EVENTS was passed  *        in.  It means that the consumer must poll the CQ again to  *        make sure it is empty to avoid missing an event because of a  *        race between requesting notification and an entry being  *        added to the CQ.  This return value means it is possible  *        (but not guaranteed) that a work completion has been added  *        to the CQ since the last poll without triggering a  *        completion notification event.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|ib_req_notify_cq
parameter_list|(
name|struct
name|ib_cq
modifier|*
name|cq
parameter_list|,
name|enum
name|ib_cq_notify_flags
name|flags
parameter_list|)
block|{
return|return
name|cq
operator|->
name|device
operator|->
name|req_notify_cq
argument_list|(
name|cq
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * ib_req_ncomp_notif - Request completion notification when there are  *   at least the specified number of unreaped completions on the CQ.  * @cq: The CQ to generate an event for.  * @wc_cnt: The number of unreaped completions that should be on the  *   CQ before an event is generated.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|ib_req_ncomp_notif
parameter_list|(
name|struct
name|ib_cq
modifier|*
name|cq
parameter_list|,
name|int
name|wc_cnt
parameter_list|)
block|{
return|return
name|cq
operator|->
name|device
operator|->
name|req_ncomp_notif
condition|?
name|cq
operator|->
name|device
operator|->
name|req_ncomp_notif
argument_list|(
name|cq
argument_list|,
name|wc_cnt
argument_list|)
else|:
operator|-
name|ENOSYS
return|;
block|}
end_function

begin_comment
comment|/**  * ib_dma_mapping_error - check a DMA addr for error  * @dev: The device for which the dma_addr was created  * @dma_addr: The DMA address to check  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|ib_dma_mapping_error
parameter_list|(
name|struct
name|ib_device
modifier|*
name|dev
parameter_list|,
name|u64
name|dma_addr
parameter_list|)
block|{
if|if
condition|(
name|dev
operator|->
name|dma_ops
condition|)
return|return
name|dev
operator|->
name|dma_ops
operator|->
name|mapping_error
argument_list|(
name|dev
argument_list|,
name|dma_addr
argument_list|)
return|;
return|return
name|dma_mapping_error
argument_list|(
name|dev
operator|->
name|dma_device
argument_list|,
name|dma_addr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * ib_dma_map_single - Map a kernel virtual address to DMA address  * @dev: The device for which the dma_addr is to be created  * @cpu_addr: The kernel virtual address  * @size: The size of the region in bytes  * @direction: The direction of the DMA  */
end_comment

begin_function
specifier|static
specifier|inline
name|u64
name|ib_dma_map_single
parameter_list|(
name|struct
name|ib_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|cpu_addr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|enum
name|dma_data_direction
name|direction
parameter_list|)
block|{
if|if
condition|(
name|dev
operator|->
name|dma_ops
condition|)
return|return
name|dev
operator|->
name|dma_ops
operator|->
name|map_single
argument_list|(
name|dev
argument_list|,
name|cpu_addr
argument_list|,
name|size
argument_list|,
name|direction
argument_list|)
return|;
return|return
name|dma_map_single
argument_list|(
name|dev
operator|->
name|dma_device
argument_list|,
name|cpu_addr
argument_list|,
name|size
argument_list|,
name|direction
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * ib_dma_unmap_single - Destroy a mapping created by ib_dma_map_single()  * @dev: The device for which the DMA address was created  * @addr: The DMA address  * @size: The size of the region in bytes  * @direction: The direction of the DMA  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|ib_dma_unmap_single
parameter_list|(
name|struct
name|ib_device
modifier|*
name|dev
parameter_list|,
name|u64
name|addr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|enum
name|dma_data_direction
name|direction
parameter_list|)
block|{
if|if
condition|(
name|dev
operator|->
name|dma_ops
condition|)
name|dev
operator|->
name|dma_ops
operator|->
name|unmap_single
argument_list|(
name|dev
argument_list|,
name|addr
argument_list|,
name|size
argument_list|,
name|direction
argument_list|)
expr_stmt|;
else|else
name|dma_unmap_single
argument_list|(
name|dev
operator|->
name|dma_device
argument_list|,
name|addr
argument_list|,
name|size
argument_list|,
name|direction
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|u64
name|ib_dma_map_single_attrs
parameter_list|(
name|struct
name|ib_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|cpu_addr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|enum
name|dma_data_direction
name|direction
parameter_list|,
name|struct
name|dma_attrs
modifier|*
name|dma_attrs
parameter_list|)
block|{
return|return
name|dma_map_single_attrs
argument_list|(
name|dev
operator|->
name|dma_device
argument_list|,
name|cpu_addr
argument_list|,
name|size
argument_list|,
name|direction
argument_list|,
name|dma_attrs
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|ib_dma_unmap_single_attrs
parameter_list|(
name|struct
name|ib_device
modifier|*
name|dev
parameter_list|,
name|u64
name|addr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|enum
name|dma_data_direction
name|direction
parameter_list|,
name|struct
name|dma_attrs
modifier|*
name|dma_attrs
parameter_list|)
block|{
return|return
name|dma_unmap_single_attrs
argument_list|(
name|dev
operator|->
name|dma_device
argument_list|,
name|addr
argument_list|,
name|size
argument_list|,
name|direction
argument_list|,
name|dma_attrs
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * ib_dma_map_page - Map a physical page to DMA address  * @dev: The device for which the dma_addr is to be created  * @page: The page to be mapped  * @offset: The offset within the page  * @size: The size of the region in bytes  * @direction: The direction of the DMA  */
end_comment

begin_function
specifier|static
specifier|inline
name|u64
name|ib_dma_map_page
parameter_list|(
name|struct
name|ib_device
modifier|*
name|dev
parameter_list|,
name|struct
name|page
modifier|*
name|page
parameter_list|,
name|unsigned
name|long
name|offset
parameter_list|,
name|size_t
name|size
parameter_list|,
name|enum
name|dma_data_direction
name|direction
parameter_list|)
block|{
if|if
condition|(
name|dev
operator|->
name|dma_ops
condition|)
return|return
name|dev
operator|->
name|dma_ops
operator|->
name|map_page
argument_list|(
name|dev
argument_list|,
name|page
argument_list|,
name|offset
argument_list|,
name|size
argument_list|,
name|direction
argument_list|)
return|;
return|return
name|dma_map_page
argument_list|(
name|dev
operator|->
name|dma_device
argument_list|,
name|page
argument_list|,
name|offset
argument_list|,
name|size
argument_list|,
name|direction
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * ib_dma_unmap_page - Destroy a mapping created by ib_dma_map_page()  * @dev: The device for which the DMA address was created  * @addr: The DMA address  * @size: The size of the region in bytes  * @direction: The direction of the DMA  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|ib_dma_unmap_page
parameter_list|(
name|struct
name|ib_device
modifier|*
name|dev
parameter_list|,
name|u64
name|addr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|enum
name|dma_data_direction
name|direction
parameter_list|)
block|{
if|if
condition|(
name|dev
operator|->
name|dma_ops
condition|)
name|dev
operator|->
name|dma_ops
operator|->
name|unmap_page
argument_list|(
name|dev
argument_list|,
name|addr
argument_list|,
name|size
argument_list|,
name|direction
argument_list|)
expr_stmt|;
else|else
name|dma_unmap_page
argument_list|(
name|dev
operator|->
name|dma_device
argument_list|,
name|addr
argument_list|,
name|size
argument_list|,
name|direction
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ib_dma_map_sg - Map a scatter/gather list to DMA addresses  * @dev: The device for which the DMA addresses are to be created  * @sg: The array of scatter/gather entries  * @nents: The number of scatter/gather entries  * @direction: The direction of the DMA  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|ib_dma_map_sg
parameter_list|(
name|struct
name|ib_device
modifier|*
name|dev
parameter_list|,
name|struct
name|scatterlist
modifier|*
name|sg
parameter_list|,
name|int
name|nents
parameter_list|,
name|enum
name|dma_data_direction
name|direction
parameter_list|)
block|{
if|if
condition|(
name|dev
operator|->
name|dma_ops
condition|)
return|return
name|dev
operator|->
name|dma_ops
operator|->
name|map_sg
argument_list|(
name|dev
argument_list|,
name|sg
argument_list|,
name|nents
argument_list|,
name|direction
argument_list|)
return|;
return|return
name|dma_map_sg
argument_list|(
name|dev
operator|->
name|dma_device
argument_list|,
name|sg
argument_list|,
name|nents
argument_list|,
name|direction
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * ib_dma_unmap_sg - Unmap a scatter/gather list of DMA addresses  * @dev: The device for which the DMA addresses were created  * @sg: The array of scatter/gather entries  * @nents: The number of scatter/gather entries  * @direction: The direction of the DMA  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|ib_dma_unmap_sg
parameter_list|(
name|struct
name|ib_device
modifier|*
name|dev
parameter_list|,
name|struct
name|scatterlist
modifier|*
name|sg
parameter_list|,
name|int
name|nents
parameter_list|,
name|enum
name|dma_data_direction
name|direction
parameter_list|)
block|{
if|if
condition|(
name|dev
operator|->
name|dma_ops
condition|)
name|dev
operator|->
name|dma_ops
operator|->
name|unmap_sg
argument_list|(
name|dev
argument_list|,
name|sg
argument_list|,
name|nents
argument_list|,
name|direction
argument_list|)
expr_stmt|;
else|else
name|dma_unmap_sg
argument_list|(
name|dev
operator|->
name|dma_device
argument_list|,
name|sg
argument_list|,
name|nents
argument_list|,
name|direction
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|ib_dma_map_sg_attrs
parameter_list|(
name|struct
name|ib_device
modifier|*
name|dev
parameter_list|,
name|struct
name|scatterlist
modifier|*
name|sg
parameter_list|,
name|int
name|nents
parameter_list|,
name|enum
name|dma_data_direction
name|direction
parameter_list|,
name|struct
name|dma_attrs
modifier|*
name|dma_attrs
parameter_list|)
block|{
if|if
condition|(
name|dev
operator|->
name|dma_ops
condition|)
return|return
name|dev
operator|->
name|dma_ops
operator|->
name|map_sg_attrs
argument_list|(
name|dev
argument_list|,
name|sg
argument_list|,
name|nents
argument_list|,
name|direction
argument_list|,
name|dma_attrs
argument_list|)
return|;
else|else
return|return
name|dma_map_sg_attrs
argument_list|(
name|dev
operator|->
name|dma_device
argument_list|,
name|sg
argument_list|,
name|nents
argument_list|,
name|direction
argument_list|,
name|dma_attrs
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|ib_dma_unmap_sg_attrs
parameter_list|(
name|struct
name|ib_device
modifier|*
name|dev
parameter_list|,
name|struct
name|scatterlist
modifier|*
name|sg
parameter_list|,
name|int
name|nents
parameter_list|,
name|enum
name|dma_data_direction
name|direction
parameter_list|,
name|struct
name|dma_attrs
modifier|*
name|dma_attrs
parameter_list|)
block|{
if|if
condition|(
name|dev
operator|->
name|dma_ops
condition|)
return|return
name|dev
operator|->
name|dma_ops
operator|->
name|unmap_sg_attrs
argument_list|(
name|dev
argument_list|,
name|sg
argument_list|,
name|nents
argument_list|,
name|direction
argument_list|,
name|dma_attrs
argument_list|)
return|;
else|else
name|dma_unmap_sg_attrs
argument_list|(
name|dev
operator|->
name|dma_device
argument_list|,
name|sg
argument_list|,
name|nents
argument_list|,
name|direction
argument_list|,
name|dma_attrs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ib_sg_dma_address - Return the DMA address from a scatter/gather entry  * @dev: The device for which the DMA addresses were created  * @sg: The scatter/gather entry  *  * Note: this function is obsolete. To do: change all occurrences of  * ib_sg_dma_address() into sg_dma_address().  */
end_comment

begin_function
specifier|static
specifier|inline
name|u64
name|ib_sg_dma_address
parameter_list|(
name|struct
name|ib_device
modifier|*
name|dev
parameter_list|,
name|struct
name|scatterlist
modifier|*
name|sg
parameter_list|)
block|{
return|return
name|sg_dma_address
argument_list|(
name|sg
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * ib_sg_dma_len - Return the DMA length from a scatter/gather entry  * @dev: The device for which the DMA addresses were created  * @sg: The scatter/gather entry  *  * Note: this function is obsolete. To do: change all occurrences of  * ib_sg_dma_len() into sg_dma_len().  */
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|int
name|ib_sg_dma_len
parameter_list|(
name|struct
name|ib_device
modifier|*
name|dev
parameter_list|,
name|struct
name|scatterlist
modifier|*
name|sg
parameter_list|)
block|{
return|return
name|sg_dma_len
argument_list|(
name|sg
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * ib_dma_sync_single_for_cpu - Prepare DMA region to be accessed by CPU  * @dev: The device for which the DMA address was created  * @addr: The DMA address  * @size: The size of the region in bytes  * @dir: The direction of the DMA  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|ib_dma_sync_single_for_cpu
parameter_list|(
name|struct
name|ib_device
modifier|*
name|dev
parameter_list|,
name|u64
name|addr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|enum
name|dma_data_direction
name|dir
parameter_list|)
block|{
if|if
condition|(
name|dev
operator|->
name|dma_ops
condition|)
name|dev
operator|->
name|dma_ops
operator|->
name|sync_single_for_cpu
argument_list|(
name|dev
argument_list|,
name|addr
argument_list|,
name|size
argument_list|,
name|dir
argument_list|)
expr_stmt|;
else|else
name|dma_sync_single_for_cpu
argument_list|(
name|dev
operator|->
name|dma_device
argument_list|,
name|addr
argument_list|,
name|size
argument_list|,
name|dir
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ib_dma_sync_single_for_device - Prepare DMA region to be accessed by device  * @dev: The device for which the DMA address was created  * @addr: The DMA address  * @size: The size of the region in bytes  * @dir: The direction of the DMA  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|ib_dma_sync_single_for_device
parameter_list|(
name|struct
name|ib_device
modifier|*
name|dev
parameter_list|,
name|u64
name|addr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|enum
name|dma_data_direction
name|dir
parameter_list|)
block|{
if|if
condition|(
name|dev
operator|->
name|dma_ops
condition|)
name|dev
operator|->
name|dma_ops
operator|->
name|sync_single_for_device
argument_list|(
name|dev
argument_list|,
name|addr
argument_list|,
name|size
argument_list|,
name|dir
argument_list|)
expr_stmt|;
else|else
name|dma_sync_single_for_device
argument_list|(
name|dev
operator|->
name|dma_device
argument_list|,
name|addr
argument_list|,
name|size
argument_list|,
name|dir
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ib_dma_alloc_coherent - Allocate memory and map it for DMA  * @dev: The device for which the DMA address is requested  * @size: The size of the region to allocate in bytes  * @dma_handle: A pointer for returning the DMA address of the region  * @flag: memory allocator flags  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
modifier|*
name|ib_dma_alloc_coherent
parameter_list|(
name|struct
name|ib_device
modifier|*
name|dev
parameter_list|,
name|size_t
name|size
parameter_list|,
name|u64
modifier|*
name|dma_handle
parameter_list|,
name|gfp_t
name|flag
parameter_list|)
block|{
if|if
condition|(
name|dev
operator|->
name|dma_ops
condition|)
return|return
name|dev
operator|->
name|dma_ops
operator|->
name|alloc_coherent
argument_list|(
name|dev
argument_list|,
name|size
argument_list|,
name|dma_handle
argument_list|,
name|flag
argument_list|)
return|;
else|else
block|{
name|dma_addr_t
name|handle
decl_stmt|;
name|void
modifier|*
name|ret
decl_stmt|;
name|ret
operator|=
name|dma_alloc_coherent
argument_list|(
name|dev
operator|->
name|dma_device
argument_list|,
name|size
argument_list|,
operator|&
name|handle
argument_list|,
name|flag
argument_list|)
expr_stmt|;
operator|*
name|dma_handle
operator|=
name|handle
expr_stmt|;
return|return
name|ret
return|;
block|}
block|}
end_function

begin_comment
comment|/**  * ib_dma_free_coherent - Free memory allocated by ib_dma_alloc_coherent()  * @dev: The device for which the DMA addresses were allocated  * @size: The size of the region  * @cpu_addr: the address returned by ib_dma_alloc_coherent()  * @dma_handle: the DMA address returned by ib_dma_alloc_coherent()  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|ib_dma_free_coherent
parameter_list|(
name|struct
name|ib_device
modifier|*
name|dev
parameter_list|,
name|size_t
name|size
parameter_list|,
name|void
modifier|*
name|cpu_addr
parameter_list|,
name|u64
name|dma_handle
parameter_list|)
block|{
if|if
condition|(
name|dev
operator|->
name|dma_ops
condition|)
name|dev
operator|->
name|dma_ops
operator|->
name|free_coherent
argument_list|(
name|dev
argument_list|,
name|size
argument_list|,
name|cpu_addr
argument_list|,
name|dma_handle
argument_list|)
expr_stmt|;
else|else
name|dma_free_coherent
argument_list|(
name|dev
operator|->
name|dma_device
argument_list|,
name|size
argument_list|,
name|cpu_addr
argument_list|,
name|dma_handle
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ib_dereg_mr - Deregisters a memory region and removes it from the  *   HCA translation table.  * @mr: The memory region to deregister.  *  * This function can fail, if the memory region has memory windows bound to it.  */
end_comment

begin_function_decl
name|int
name|ib_dereg_mr
parameter_list|(
name|struct
name|ib_mr
modifier|*
name|mr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|ib_mr
modifier|*
name|ib_alloc_mr
parameter_list|(
name|struct
name|ib_pd
modifier|*
name|pd
parameter_list|,
name|enum
name|ib_mr_type
name|mr_type
parameter_list|,
name|u32
name|max_num_sg
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * ib_update_fast_reg_key - updates the key portion of the fast_reg MR  *   R_Key and L_Key.  * @mr - struct ib_mr pointer to be updated.  * @newkey - new key to be used.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|ib_update_fast_reg_key
parameter_list|(
name|struct
name|ib_mr
modifier|*
name|mr
parameter_list|,
name|u8
name|newkey
parameter_list|)
block|{
name|mr
operator|->
name|lkey
operator|=
operator|(
name|mr
operator|->
name|lkey
operator|&
literal|0xffffff00
operator|)
operator||
name|newkey
expr_stmt|;
name|mr
operator|->
name|rkey
operator|=
operator|(
name|mr
operator|->
name|rkey
operator|&
literal|0xffffff00
operator|)
operator||
name|newkey
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ib_inc_rkey - increments the key portion of the given rkey. Can be used  * for calculating a new rkey for type 2 memory windows.  * @rkey - the rkey to increment.  */
end_comment

begin_function
specifier|static
specifier|inline
name|u32
name|ib_inc_rkey
parameter_list|(
name|u32
name|rkey
parameter_list|)
block|{
specifier|const
name|u32
name|mask
init|=
literal|0x000000ff
decl_stmt|;
return|return
operator|(
operator|(
name|rkey
operator|+
literal|1
operator|)
operator|&
name|mask
operator|)
operator||
operator|(
name|rkey
operator|&
operator|~
name|mask
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * ib_alloc_fmr - Allocates a unmapped fast memory region.  * @pd: The protection domain associated with the unmapped region.  * @mr_access_flags: Specifies the memory access rights.  * @fmr_attr: Attributes of the unmapped region.  *  * A fast memory region must be mapped before it can be used as part of  * a work request.  */
end_comment

begin_function_decl
name|struct
name|ib_fmr
modifier|*
name|ib_alloc_fmr
parameter_list|(
name|struct
name|ib_pd
modifier|*
name|pd
parameter_list|,
name|int
name|mr_access_flags
parameter_list|,
name|struct
name|ib_fmr_attr
modifier|*
name|fmr_attr
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * ib_map_phys_fmr - Maps a list of physical pages to a fast memory region.  * @fmr: The fast memory region to associate with the pages.  * @page_list: An array of physical pages to map to the fast memory region.  * @list_len: The number of pages in page_list.  * @iova: The I/O virtual address to use with the mapped region.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|ib_map_phys_fmr
parameter_list|(
name|struct
name|ib_fmr
modifier|*
name|fmr
parameter_list|,
name|u64
modifier|*
name|page_list
parameter_list|,
name|int
name|list_len
parameter_list|,
name|u64
name|iova
parameter_list|)
block|{
return|return
name|fmr
operator|->
name|device
operator|->
name|map_phys_fmr
argument_list|(
name|fmr
argument_list|,
name|page_list
argument_list|,
name|list_len
argument_list|,
name|iova
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * ib_unmap_fmr - Removes the mapping from a list of fast memory regions.  * @fmr_list: A linked list of fast memory regions to unmap.  */
end_comment

begin_function_decl
name|int
name|ib_unmap_fmr
parameter_list|(
name|struct
name|list_head
modifier|*
name|fmr_list
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * ib_dealloc_fmr - Deallocates a fast memory region.  * @fmr: The fast memory region to deallocate.  */
end_comment

begin_function_decl
name|int
name|ib_dealloc_fmr
parameter_list|(
name|struct
name|ib_fmr
modifier|*
name|fmr
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * ib_attach_mcast - Attaches the specified QP to a multicast group.  * @qp: QP to attach to the multicast group.  The QP must be type  *   IB_QPT_UD.  * @gid: Multicast group GID.  * @lid: Multicast group LID in host byte order.  *  * In order to send and receive multicast packets, subnet  * administration must have created the multicast group and configured  * the fabric appropriately.  The port associated with the specified  * QP must also be a member of the multicast group.  */
end_comment

begin_function_decl
name|int
name|ib_attach_mcast
parameter_list|(
name|struct
name|ib_qp
modifier|*
name|qp
parameter_list|,
name|union
name|ib_gid
modifier|*
name|gid
parameter_list|,
name|u16
name|lid
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * ib_detach_mcast - Detaches the specified QP from a multicast group.  * @qp: QP to detach from the multicast group.  * @gid: Multicast group GID.  * @lid: Multicast group LID in host byte order.  */
end_comment

begin_function_decl
name|int
name|ib_detach_mcast
parameter_list|(
name|struct
name|ib_qp
modifier|*
name|qp
parameter_list|,
name|union
name|ib_gid
modifier|*
name|gid
parameter_list|,
name|u16
name|lid
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * ib_alloc_xrcd - Allocates an XRC domain.  * @device: The device on which to allocate the XRC domain.  */
end_comment

begin_function_decl
name|struct
name|ib_xrcd
modifier|*
name|ib_alloc_xrcd
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * ib_dealloc_xrcd - Deallocates an XRC domain.  * @xrcd: The XRC domain to deallocate.  */
end_comment

begin_function_decl
name|int
name|ib_dealloc_xrcd
parameter_list|(
name|struct
name|ib_xrcd
modifier|*
name|xrcd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|ib_flow
modifier|*
name|ib_create_flow
parameter_list|(
name|struct
name|ib_qp
modifier|*
name|qp
parameter_list|,
name|struct
name|ib_flow_attr
modifier|*
name|flow_attr
parameter_list|,
name|int
name|domain
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ib_destroy_flow
parameter_list|(
name|struct
name|ib_flow
modifier|*
name|flow_id
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
specifier|inline
name|int
name|ib_check_mr_access
parameter_list|(
name|int
name|flags
parameter_list|)
block|{
comment|/* 	 * Local write permission is required if remote write or 	 * remote atomic permission is also requested. 	 */
if|if
condition|(
name|flags
operator|&
operator|(
name|IB_ACCESS_REMOTE_ATOMIC
operator||
name|IB_ACCESS_REMOTE_WRITE
operator|)
operator|&&
operator|!
operator|(
name|flags
operator|&
name|IB_ACCESS_LOCAL_WRITE
operator|)
condition|)
return|return
operator|-
name|EINVAL
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * ib_check_mr_status: lightweight check of MR status.  *     This routine may provide status checks on a selected  *     ib_mr. first use is for signature status check.  *  * @mr: A memory region.  * @check_mask: Bitmask of which checks to perform from  *     ib_mr_status_check enumeration.  * @mr_status: The container of relevant status checks.  *     failed checks will be indicated in the status bitmask  *     and the relevant info shall be in the error item.  */
end_comment

begin_function_decl
name|int
name|ib_check_mr_status
parameter_list|(
name|struct
name|ib_mr
modifier|*
name|mr
parameter_list|,
name|u32
name|check_mask
parameter_list|,
name|struct
name|ib_mr_status
modifier|*
name|mr_status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|net_device
modifier|*
name|ib_get_net_dev_by_params
parameter_list|(
name|struct
name|ib_device
modifier|*
name|dev
parameter_list|,
name|u8
name|port
parameter_list|,
name|u16
name|pkey
parameter_list|,
specifier|const
name|union
name|ib_gid
modifier|*
name|gid
parameter_list|,
specifier|const
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|ib_wq
modifier|*
name|ib_create_wq
parameter_list|(
name|struct
name|ib_pd
modifier|*
name|pd
parameter_list|,
name|struct
name|ib_wq_init_attr
modifier|*
name|init_attr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ib_destroy_wq
parameter_list|(
name|struct
name|ib_wq
modifier|*
name|wq
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ib_modify_wq
parameter_list|(
name|struct
name|ib_wq
modifier|*
name|wq
parameter_list|,
name|struct
name|ib_wq_attr
modifier|*
name|attr
parameter_list|,
name|u32
name|wq_attr_mask
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|ib_rwq_ind_table
modifier|*
name|ib_create_rwq_ind_table
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|struct
name|ib_rwq_ind_table_init_attr
modifier|*
name|wq_ind_table_init_attr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ib_destroy_rwq_ind_table
parameter_list|(
name|struct
name|ib_rwq_ind_table
modifier|*
name|wq_ind_table
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ib_map_mr_sg
parameter_list|(
name|struct
name|ib_mr
modifier|*
name|mr
parameter_list|,
name|struct
name|scatterlist
modifier|*
name|sg
parameter_list|,
name|int
name|sg_nents
parameter_list|,
name|unsigned
name|int
modifier|*
name|sg_offset
parameter_list|,
name|unsigned
name|int
name|page_size
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
specifier|inline
name|int
name|ib_map_mr_sg_zbva
parameter_list|(
name|struct
name|ib_mr
modifier|*
name|mr
parameter_list|,
name|struct
name|scatterlist
modifier|*
name|sg
parameter_list|,
name|int
name|sg_nents
parameter_list|,
name|unsigned
name|int
modifier|*
name|sg_offset
parameter_list|,
name|unsigned
name|int
name|page_size
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
name|n
operator|=
name|ib_map_mr_sg
argument_list|(
name|mr
argument_list|,
name|sg
argument_list|,
name|sg_nents
argument_list|,
name|sg_offset
argument_list|,
name|page_size
argument_list|)
expr_stmt|;
name|mr
operator|->
name|iova
operator|=
literal|0
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_function_decl
name|int
name|ib_sg_to_pages
parameter_list|(
name|struct
name|ib_mr
modifier|*
name|mr
parameter_list|,
name|struct
name|scatterlist
modifier|*
name|sgl
parameter_list|,
name|int
name|sg_nents
parameter_list|,
name|unsigned
name|int
modifier|*
name|sg_offset
parameter_list|,
name|int
function_decl|(
modifier|*
name|set_page
function_decl|)
parameter_list|(
name|struct
name|ib_mr
modifier|*
parameter_list|,
name|u64
parameter_list|)
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ib_drain_rq
parameter_list|(
name|struct
name|ib_qp
modifier|*
name|qp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ib_drain_sq
parameter_list|(
name|struct
name|ib_qp
modifier|*
name|qp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ib_drain_qp
parameter_list|(
name|struct
name|ib_qp
modifier|*
name|qp
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IB_VERBS_H */
end_comment

end_unit

