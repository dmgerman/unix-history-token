begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2004 Mellanox Technologies Ltd.  All rights reserved.  * Copyright (c) 2004 Infinicon Corporation.  All rights reserved.  * Copyright (c) 2004 Intel Corporation.  All rights reserved.  * Copyright (c) 2004 Topspin Corporation.  All rights reserved.  * Copyright (c) 2004 Voltaire Corporation.  All rights reserved.  * Copyright (c) 2005 Sun Microsystems, Inc. All rights reserved.  * Copyright (c) 2005, 2006, 2007 Cisco Systems.  All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|IB_VERBS_H
argument_list|)
end_if

begin_define
define|#
directive|define
name|IB_VERBS_H
end_define

begin_include
include|#
directive|include
file|<linux/types.h>
end_include

begin_include
include|#
directive|include
file|<linux/device.h>
end_include

begin_include
include|#
directive|include
file|<linux/mm.h>
end_include

begin_include
include|#
directive|include
file|<linux/dma-mapping.h>
end_include

begin_include
include|#
directive|include
file|<linux/kref.h>
end_include

begin_include
include|#
directive|include
file|<linux/list.h>
end_include

begin_include
include|#
directive|include
file|<linux/rwsem.h>
end_include

begin_include
include|#
directive|include
file|<linux/scatterlist.h>
end_include

begin_include
include|#
directive|include
file|<linux/workqueue.h>
end_include

begin_include
include|#
directive|include
file|<linux/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<linux/mutex.h>
end_include

begin_include
include|#
directive|include
file|<asm/uaccess.h>
end_include

begin_decl_stmt
specifier|extern
name|struct
name|workqueue_struct
modifier|*
name|ib_wq
decl_stmt|;
end_decl_stmt

begin_union
union|union
name|ib_gid
block|{
name|u8
name|raw
index|[
literal|16
index|]
decl_stmt|;
struct|struct
block|{
name|__be64
name|subnet_prefix
decl_stmt|;
name|__be64
name|interface_id
decl_stmt|;
block|}
name|global
struct|;
block|}
union|;
end_union

begin_enum
enum|enum
name|rdma_node_type
block|{
comment|/* IB values map to NodeInfo:NodeType. */
name|RDMA_NODE_IB_CA
init|=
literal|1
block|,
name|RDMA_NODE_IB_SWITCH
block|,
name|RDMA_NODE_IB_ROUTER
block|,
name|RDMA_NODE_RNIC
block|,
name|RDMA_NODE_MIC
block|}
enum|;
end_enum

begin_enum
enum|enum
name|rdma_transport_type
block|{
name|RDMA_TRANSPORT_IB
block|,
name|RDMA_TRANSPORT_IWARP
block|,
name|RDMA_TRANSPORT_SCIF
block|}
enum|;
end_enum

begin_decl_stmt
name|enum
name|rdma_transport_type
name|rdma_node_get_transport
argument_list|(
expr|enum
name|rdma_node_type
name|node_type
argument_list|)
name|__attribute_const__
decl_stmt|;
end_decl_stmt

begin_enum
enum|enum
name|rdma_link_layer
block|{
name|IB_LINK_LAYER_UNSPECIFIED
block|,
name|IB_LINK_LAYER_INFINIBAND
block|,
name|IB_LINK_LAYER_ETHERNET
block|,
name|IB_LINK_LAYER_SCIF
block|}
enum|;
end_enum

begin_enum
enum|enum
name|ib_device_cap_flags
block|{
name|IB_DEVICE_RESIZE_MAX_WR
init|=
literal|1
block|,
name|IB_DEVICE_BAD_PKEY_CNTR
init|=
operator|(
literal|1
operator|<<
literal|1
operator|)
block|,
name|IB_DEVICE_BAD_QKEY_CNTR
init|=
operator|(
literal|1
operator|<<
literal|2
operator|)
block|,
name|IB_DEVICE_RAW_MULTI
init|=
operator|(
literal|1
operator|<<
literal|3
operator|)
block|,
name|IB_DEVICE_AUTO_PATH_MIG
init|=
operator|(
literal|1
operator|<<
literal|4
operator|)
block|,
name|IB_DEVICE_CHANGE_PHY_PORT
init|=
operator|(
literal|1
operator|<<
literal|5
operator|)
block|,
name|IB_DEVICE_UD_AV_PORT_ENFORCE
init|=
operator|(
literal|1
operator|<<
literal|6
operator|)
block|,
name|IB_DEVICE_CURR_QP_STATE_MOD
init|=
operator|(
literal|1
operator|<<
literal|7
operator|)
block|,
name|IB_DEVICE_SHUTDOWN_PORT
init|=
operator|(
literal|1
operator|<<
literal|8
operator|)
block|,
name|IB_DEVICE_INIT_TYPE
init|=
operator|(
literal|1
operator|<<
literal|9
operator|)
block|,
name|IB_DEVICE_PORT_ACTIVE_EVENT
init|=
operator|(
literal|1
operator|<<
literal|10
operator|)
block|,
name|IB_DEVICE_SYS_IMAGE_GUID
init|=
operator|(
literal|1
operator|<<
literal|11
operator|)
block|,
name|IB_DEVICE_RC_RNR_NAK_GEN
init|=
operator|(
literal|1
operator|<<
literal|12
operator|)
block|,
name|IB_DEVICE_SRQ_RESIZE
init|=
operator|(
literal|1
operator|<<
literal|13
operator|)
block|,
name|IB_DEVICE_N_NOTIFY_CQ
init|=
operator|(
literal|1
operator|<<
literal|14
operator|)
block|,
name|IB_DEVICE_LOCAL_DMA_LKEY
init|=
operator|(
literal|1
operator|<<
literal|15
operator|)
block|,
name|IB_DEVICE_RESERVED
init|=
operator|(
literal|1
operator|<<
literal|16
operator|)
block|,
comment|/* old SEND_W_INV */
name|IB_DEVICE_MEM_WINDOW
init|=
operator|(
literal|1
operator|<<
literal|17
operator|)
block|,
comment|/* 	 * Devices should set IB_DEVICE_UD_IP_SUM if they support 	 * insertion of UDP and TCP checksum on outgoing UD IPoIB 	 * messages and can verify the validity of checksum for 	 * incoming messages.  Setting this flag implies that the 	 * IPoIB driver may set NETIF_F_IP_CSUM for datagram mode. 	 */
name|IB_DEVICE_UD_IP_CSUM
init|=
operator|(
literal|1
operator|<<
literal|18
operator|)
block|,
name|IB_DEVICE_UD_TSO
init|=
operator|(
literal|1
operator|<<
literal|19
operator|)
block|,
name|IB_DEVICE_XRC
init|=
operator|(
literal|1
operator|<<
literal|20
operator|)
block|,
name|IB_DEVICE_MEM_MGT_EXTENSIONS
init|=
operator|(
literal|1
operator|<<
literal|21
operator|)
block|,
name|IB_DEVICE_BLOCK_MULTICAST_LOOPBACK
init|=
operator|(
literal|1
operator|<<
literal|22
operator|)
block|,
name|IB_DEVICE_MR_ALLOCATE
init|=
operator|(
literal|1
operator|<<
literal|23
operator|)
block|,
name|IB_DEVICE_SHARED_MR
init|=
operator|(
literal|1
operator|<<
literal|24
operator|)
block|,
name|IB_DEVICE_QPG
init|=
operator|(
literal|1
operator|<<
literal|25
operator|)
block|,
name|IB_DEVICE_UD_RSS
init|=
operator|(
literal|1
operator|<<
literal|26
operator|)
block|,
name|IB_DEVICE_UD_TSS
init|=
operator|(
literal|1
operator|<<
literal|27
operator|)
block|,
name|IB_DEVICE_CROSS_CHANNEL
init|=
operator|(
literal|1
operator|<<
literal|28
operator|)
block|,
name|IB_DEVICE_MANAGED_FLOW_STEERING
init|=
operator|(
literal|1
operator|<<
literal|29
operator|)
block|,
comment|/* 	 * Devices can set either IB_DEVICE_MEM_WINDOW_TYPE_2A or 	 * IB_DEVICE_MEM_WINDOW_TYPE_2B if it supports type 2A or type 2B 	 * memory windows. It can set neither to indicate it doesn't support 	 * type 2 windows at all. 	 */
name|IB_DEVICE_MEM_WINDOW_TYPE_2A
init|=
operator|(
literal|1
operator|<<
literal|30
operator|)
block|,
name|IB_DEVICE_MEM_WINDOW_TYPE_2B
init|=
operator|(
literal|1
operator|<<
literal|31
operator|)
block|,
name|IB_DEVICE_SIGNATURE_HANDOVER
init|=
operator|(
literal|1LL
operator|<<
literal|32
operator|)
block|}
enum|;
end_enum

begin_enum
enum|enum
name|ib_signature_prot_cap
block|{
name|IB_PROT_T10DIF_TYPE_1
init|=
literal|1
block|,
name|IB_PROT_T10DIF_TYPE_2
init|=
literal|1
operator|<<
literal|1
block|,
name|IB_PROT_T10DIF_TYPE_3
init|=
literal|1
operator|<<
literal|2
block|, }
enum|;
end_enum

begin_enum
enum|enum
name|ib_signature_guard_cap
block|{
name|IB_GUARD_T10DIF_CRC
init|=
literal|1
block|,
name|IB_GUARD_T10DIF_CSUM
init|=
literal|1
operator|<<
literal|1
block|, }
enum|;
end_enum

begin_enum
enum|enum
name|ib_atomic_cap
block|{
name|IB_ATOMIC_NONE
block|,
name|IB_ATOMIC_HCA
block|,
name|IB_ATOMIC_GLOB
block|}
enum|;
end_enum

begin_enum
enum|enum
name|ib_cq_create_flags
block|{
name|IB_CQ_CREATE_CROSS_CHANNEL
init|=
literal|1
operator|<<
literal|0
block|,
name|IB_CQ_TIMESTAMP
init|=
literal|1
operator|<<
literal|1
block|,
name|IB_CQ_TIMESTAMP_TO_SYS_TIME
init|=
literal|1
operator|<<
literal|2
block|}
enum|;
end_enum

begin_struct
struct|struct
name|ib_device_attr
block|{
name|u64
name|fw_ver
decl_stmt|;
name|__be64
name|sys_image_guid
decl_stmt|;
name|u64
name|max_mr_size
decl_stmt|;
name|u64
name|page_size_cap
decl_stmt|;
name|u32
name|vendor_id
decl_stmt|;
name|u32
name|vendor_part_id
decl_stmt|;
name|u32
name|hw_ver
decl_stmt|;
name|int
name|max_qp
decl_stmt|;
name|int
name|max_qp_wr
decl_stmt|;
name|u64
name|device_cap_flags
decl_stmt|;
name|int
name|max_sge
decl_stmt|;
name|int
name|max_sge_rd
decl_stmt|;
name|int
name|max_cq
decl_stmt|;
name|int
name|max_cqe
decl_stmt|;
name|int
name|max_mr
decl_stmt|;
name|int
name|max_pd
decl_stmt|;
name|int
name|max_qp_rd_atom
decl_stmt|;
name|int
name|max_ee_rd_atom
decl_stmt|;
name|int
name|max_res_rd_atom
decl_stmt|;
name|int
name|max_qp_init_rd_atom
decl_stmt|;
name|int
name|max_ee_init_rd_atom
decl_stmt|;
name|enum
name|ib_atomic_cap
name|atomic_cap
decl_stmt|;
name|enum
name|ib_atomic_cap
name|masked_atomic_cap
decl_stmt|;
name|int
name|max_ee
decl_stmt|;
name|int
name|max_rdd
decl_stmt|;
name|int
name|max_mw
decl_stmt|;
name|int
name|max_raw_ipv6_qp
decl_stmt|;
name|int
name|max_raw_ethy_qp
decl_stmt|;
name|int
name|max_mcast_grp
decl_stmt|;
name|int
name|max_mcast_qp_attach
decl_stmt|;
name|int
name|max_total_mcast_qp_attach
decl_stmt|;
name|int
name|max_ah
decl_stmt|;
name|int
name|max_fmr
decl_stmt|;
name|int
name|max_map_per_fmr
decl_stmt|;
name|int
name|max_srq
decl_stmt|;
name|int
name|max_srq_wr
decl_stmt|;
name|int
name|max_srq_sge
decl_stmt|;
name|unsigned
name|int
name|max_fast_reg_page_list_len
decl_stmt|;
name|int
name|max_rss_tbl_sz
decl_stmt|;
name|u16
name|max_pkeys
decl_stmt|;
name|u8
name|local_ca_ack_delay
decl_stmt|;
name|int
name|comp_mask
decl_stmt|;
name|uint64_t
name|timestamp_mask
decl_stmt|;
name|uint64_t
name|hca_core_clock
decl_stmt|;
name|unsigned
name|int
name|sig_prot_cap
decl_stmt|;
name|unsigned
name|int
name|sig_guard_cap
decl_stmt|;
block|}
struct|;
end_struct

begin_enum
enum|enum
name|ib_device_attr_comp_mask
block|{
name|IB_DEVICE_ATTR_WITH_TIMESTAMP_MASK
init|=
literal|1ULL
operator|<<
literal|1
block|,
name|IB_DEVICE_ATTR_WITH_HCA_CORE_CLOCK
init|=
literal|1ULL
operator|<<
literal|2
block|}
enum|;
end_enum

begin_enum
enum|enum
name|ib_mtu
block|{
name|IB_MTU_256
init|=
literal|1
block|,
name|IB_MTU_512
init|=
literal|2
block|,
name|IB_MTU_1024
init|=
literal|3
block|,
name|IB_MTU_2048
init|=
literal|4
block|,
name|IB_MTU_4096
init|=
literal|5
block|}
enum|;
end_enum

begin_function
specifier|static
specifier|inline
name|int
name|ib_mtu_enum_to_int
parameter_list|(
name|enum
name|ib_mtu
name|mtu
parameter_list|)
block|{
switch|switch
condition|(
name|mtu
condition|)
block|{
case|case
name|IB_MTU_256
case|:
return|return
literal|256
return|;
case|case
name|IB_MTU_512
case|:
return|return
literal|512
return|;
case|case
name|IB_MTU_1024
case|:
return|return
literal|1024
return|;
case|case
name|IB_MTU_2048
case|:
return|return
literal|2048
return|;
case|case
name|IB_MTU_4096
case|:
return|return
literal|4096
return|;
default|default:
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_enum
enum|enum
name|ib_port_state
block|{
name|IB_PORT_NOP
init|=
literal|0
block|,
name|IB_PORT_DOWN
init|=
literal|1
block|,
name|IB_PORT_INIT
init|=
literal|2
block|,
name|IB_PORT_ARMED
init|=
literal|3
block|,
name|IB_PORT_ACTIVE
init|=
literal|4
block|,
name|IB_PORT_ACTIVE_DEFER
init|=
literal|5
block|,
name|IB_PORT_DUMMY
init|=
operator|-
literal|1
comment|/* force enum signed */
block|}
enum|;
end_enum

begin_enum
enum|enum
name|ib_port_cap_flags
block|{
name|IB_PORT_SM
init|=
literal|1
operator|<<
literal|1
block|,
name|IB_PORT_NOTICE_SUP
init|=
literal|1
operator|<<
literal|2
block|,
name|IB_PORT_TRAP_SUP
init|=
literal|1
operator|<<
literal|3
block|,
name|IB_PORT_OPT_IPD_SUP
init|=
literal|1
operator|<<
literal|4
block|,
name|IB_PORT_AUTO_MIGR_SUP
init|=
literal|1
operator|<<
literal|5
block|,
name|IB_PORT_SL_MAP_SUP
init|=
literal|1
operator|<<
literal|6
block|,
name|IB_PORT_MKEY_NVRAM
init|=
literal|1
operator|<<
literal|7
block|,
name|IB_PORT_PKEY_NVRAM
init|=
literal|1
operator|<<
literal|8
block|,
name|IB_PORT_LED_INFO_SUP
init|=
literal|1
operator|<<
literal|9
block|,
name|IB_PORT_SM_DISABLED
init|=
literal|1
operator|<<
literal|10
block|,
name|IB_PORT_SYS_IMAGE_GUID_SUP
init|=
literal|1
operator|<<
literal|11
block|,
name|IB_PORT_PKEY_SW_EXT_PORT_TRAP_SUP
init|=
literal|1
operator|<<
literal|12
block|,
name|IB_PORT_EXTENDED_SPEEDS_SUP
init|=
literal|1
operator|<<
literal|14
block|,
name|IB_PORT_CM_SUP
init|=
literal|1
operator|<<
literal|16
block|,
name|IB_PORT_SNMP_TUNNEL_SUP
init|=
literal|1
operator|<<
literal|17
block|,
name|IB_PORT_REINIT_SUP
init|=
literal|1
operator|<<
literal|18
block|,
name|IB_PORT_DEVICE_MGMT_SUP
init|=
literal|1
operator|<<
literal|19
block|,
name|IB_PORT_VENDOR_CLASS_SUP
init|=
literal|1
operator|<<
literal|20
block|,
name|IB_PORT_DR_NOTICE_SUP
init|=
literal|1
operator|<<
literal|21
block|,
name|IB_PORT_CAP_MASK_NOTICE_SUP
init|=
literal|1
operator|<<
literal|22
block|,
name|IB_PORT_BOOT_MGMT_SUP
init|=
literal|1
operator|<<
literal|23
block|,
name|IB_PORT_LINK_LATENCY_SUP
init|=
literal|1
operator|<<
literal|24
block|,
name|IB_PORT_CLIENT_REG_SUP
init|=
literal|1
operator|<<
literal|25
block|}
enum|;
end_enum

begin_enum
enum|enum
name|ib_port_width
block|{
name|IB_WIDTH_1X
init|=
literal|1
block|,
name|IB_WIDTH_4X
init|=
literal|2
block|,
name|IB_WIDTH_8X
init|=
literal|4
block|,
name|IB_WIDTH_12X
init|=
literal|8
block|}
enum|;
end_enum

begin_function
specifier|static
specifier|inline
name|int
name|ib_width_enum_to_int
parameter_list|(
name|enum
name|ib_port_width
name|width
parameter_list|)
block|{
switch|switch
condition|(
name|width
condition|)
block|{
case|case
name|IB_WIDTH_1X
case|:
return|return
literal|1
return|;
case|case
name|IB_WIDTH_4X
case|:
return|return
literal|4
return|;
case|case
name|IB_WIDTH_8X
case|:
return|return
literal|8
return|;
case|case
name|IB_WIDTH_12X
case|:
return|return
literal|12
return|;
default|default:
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_enum
enum|enum
name|ib_port_speed
block|{
name|IB_SPEED_SDR
init|=
literal|1
block|,
name|IB_SPEED_DDR
init|=
literal|2
block|,
name|IB_SPEED_QDR
init|=
literal|4
block|,
name|IB_SPEED_FDR10
init|=
literal|8
block|,
name|IB_SPEED_FDR
init|=
literal|16
block|,
name|IB_SPEED_EDR
init|=
literal|32
block|}
enum|;
end_enum

begin_struct
struct|struct
name|ib_protocol_stats
block|{
comment|/* TBD... */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|iw_protocol_stats
block|{
name|u64
name|ipInReceives
decl_stmt|;
name|u64
name|ipInHdrErrors
decl_stmt|;
name|u64
name|ipInTooBigErrors
decl_stmt|;
name|u64
name|ipInNoRoutes
decl_stmt|;
name|u64
name|ipInAddrErrors
decl_stmt|;
name|u64
name|ipInUnknownProtos
decl_stmt|;
name|u64
name|ipInTruncatedPkts
decl_stmt|;
name|u64
name|ipInDiscards
decl_stmt|;
name|u64
name|ipInDelivers
decl_stmt|;
name|u64
name|ipOutForwDatagrams
decl_stmt|;
name|u64
name|ipOutRequests
decl_stmt|;
name|u64
name|ipOutDiscards
decl_stmt|;
name|u64
name|ipOutNoRoutes
decl_stmt|;
name|u64
name|ipReasmTimeout
decl_stmt|;
name|u64
name|ipReasmReqds
decl_stmt|;
name|u64
name|ipReasmOKs
decl_stmt|;
name|u64
name|ipReasmFails
decl_stmt|;
name|u64
name|ipFragOKs
decl_stmt|;
name|u64
name|ipFragFails
decl_stmt|;
name|u64
name|ipFragCreates
decl_stmt|;
name|u64
name|ipInMcastPkts
decl_stmt|;
name|u64
name|ipOutMcastPkts
decl_stmt|;
name|u64
name|ipInBcastPkts
decl_stmt|;
name|u64
name|ipOutBcastPkts
decl_stmt|;
name|u64
name|tcpRtoAlgorithm
decl_stmt|;
name|u64
name|tcpRtoMin
decl_stmt|;
name|u64
name|tcpRtoMax
decl_stmt|;
name|u64
name|tcpMaxConn
decl_stmt|;
name|u64
name|tcpActiveOpens
decl_stmt|;
name|u64
name|tcpPassiveOpens
decl_stmt|;
name|u64
name|tcpAttemptFails
decl_stmt|;
name|u64
name|tcpEstabResets
decl_stmt|;
name|u64
name|tcpCurrEstab
decl_stmt|;
name|u64
name|tcpInSegs
decl_stmt|;
name|u64
name|tcpOutSegs
decl_stmt|;
name|u64
name|tcpRetransSegs
decl_stmt|;
name|u64
name|tcpInErrs
decl_stmt|;
name|u64
name|tcpOutRsts
decl_stmt|;
block|}
struct|;
end_struct

begin_union
union|union
name|rdma_protocol_stats
block|{
name|struct
name|ib_protocol_stats
name|ib
decl_stmt|;
name|struct
name|iw_protocol_stats
name|iw
decl_stmt|;
block|}
union|;
end_union

begin_comment
comment|/* Define bits for the various functionality this port needs to be supported by  * the core.  */
end_comment

begin_comment
comment|/* Management                           0x00000FFF */
end_comment

begin_define
define|#
directive|define
name|RDMA_CORE_CAP_IB_MAD
value|0x00000001
end_define

begin_define
define|#
directive|define
name|RDMA_CORE_CAP_IB_SMI
value|0x00000002
end_define

begin_define
define|#
directive|define
name|RDMA_CORE_CAP_IB_CM
value|0x00000004
end_define

begin_define
define|#
directive|define
name|RDMA_CORE_CAP_IW_CM
value|0x00000008
end_define

begin_define
define|#
directive|define
name|RDMA_CORE_CAP_IB_SA
value|0x00000010
end_define

begin_define
define|#
directive|define
name|RDMA_CORE_CAP_OPA_MAD
value|0x00000020
end_define

begin_comment
comment|/* Address format                       0x000FF000 */
end_comment

begin_define
define|#
directive|define
name|RDMA_CORE_CAP_AF_IB
value|0x00001000
end_define

begin_define
define|#
directive|define
name|RDMA_CORE_CAP_ETH_AH
value|0x00002000
end_define

begin_define
define|#
directive|define
name|RDMA_CORE_CAP_OPA_AH
value|0x00004000
end_define

begin_comment
comment|/* Protocol                             0xFFF00000 */
end_comment

begin_define
define|#
directive|define
name|RDMA_CORE_CAP_PROT_IB
value|0x00100000
end_define

begin_define
define|#
directive|define
name|RDMA_CORE_CAP_PROT_ROCE
value|0x00200000
end_define

begin_define
define|#
directive|define
name|RDMA_CORE_CAP_PROT_IWARP
value|0x00400000
end_define

begin_define
define|#
directive|define
name|RDMA_CORE_CAP_PROT_ROCE_UDP_ENCAP
value|0x00800000
end_define

begin_define
define|#
directive|define
name|RDMA_CORE_CAP_PROT_RAW_PACKET
value|0x01000000
end_define

begin_define
define|#
directive|define
name|RDMA_CORE_CAP_PROT_USNIC
value|0x02000000
end_define

begin_define
define|#
directive|define
name|RDMA_CORE_PORT_IBA_IB
value|(RDMA_CORE_CAP_PROT_IB  \ 					| RDMA_CORE_CAP_IB_MAD \ 					| RDMA_CORE_CAP_IB_SMI \ 					| RDMA_CORE_CAP_IB_CM  \ 					| RDMA_CORE_CAP_IB_SA  \ 					| RDMA_CORE_CAP_AF_IB)
end_define

begin_define
define|#
directive|define
name|RDMA_CORE_PORT_IBA_ROCE
value|(RDMA_CORE_CAP_PROT_ROCE \ 					| RDMA_CORE_CAP_IB_MAD  \ 					| RDMA_CORE_CAP_IB_CM   \ 					| RDMA_CORE_CAP_AF_IB   \ 					| RDMA_CORE_CAP_ETH_AH)
end_define

begin_define
define|#
directive|define
name|RDMA_CORE_PORT_IBA_ROCE_UDP_ENCAP
define|\
value|(RDMA_CORE_CAP_PROT_ROCE_UDP_ENCAP \ 					| RDMA_CORE_CAP_IB_MAD  \ 					| RDMA_CORE_CAP_IB_CM   \ 					| RDMA_CORE_CAP_AF_IB   \ 					| RDMA_CORE_CAP_ETH_AH)
end_define

begin_define
define|#
directive|define
name|RDMA_CORE_PORT_IWARP
value|(RDMA_CORE_CAP_PROT_IWARP \ 					| RDMA_CORE_CAP_IW_CM)
end_define

begin_define
define|#
directive|define
name|RDMA_CORE_PORT_INTEL_OPA
value|(RDMA_CORE_PORT_IBA_IB  \ 					| RDMA_CORE_CAP_OPA_MAD)
end_define

begin_define
define|#
directive|define
name|RDMA_CORE_PORT_RAW_PACKET
value|(RDMA_CORE_CAP_PROT_RAW_PACKET)
end_define

begin_define
define|#
directive|define
name|RDMA_CORE_PORT_USNIC
value|(RDMA_CORE_CAP_PROT_USNIC)
end_define

begin_struct
struct|struct
name|ib_port_attr
block|{
name|enum
name|ib_port_state
name|state
decl_stmt|;
name|enum
name|ib_mtu
name|max_mtu
decl_stmt|;
name|enum
name|ib_mtu
name|active_mtu
decl_stmt|;
name|int
name|gid_tbl_len
decl_stmt|;
name|u32
name|port_cap_flags
decl_stmt|;
name|u32
name|max_msg_sz
decl_stmt|;
name|u32
name|bad_pkey_cntr
decl_stmt|;
name|u32
name|qkey_viol_cntr
decl_stmt|;
name|u16
name|pkey_tbl_len
decl_stmt|;
name|u16
name|lid
decl_stmt|;
name|u16
name|sm_lid
decl_stmt|;
name|u8
name|lmc
decl_stmt|;
name|u8
name|max_vl_num
decl_stmt|;
name|u8
name|sm_sl
decl_stmt|;
name|u8
name|subnet_timeout
decl_stmt|;
name|u8
name|init_type_reply
decl_stmt|;
name|u8
name|active_width
decl_stmt|;
name|u8
name|active_speed
decl_stmt|;
name|u8
name|phys_state
decl_stmt|;
block|}
struct|;
end_struct

begin_enum
enum|enum
name|ib_device_modify_flags
block|{
name|IB_DEVICE_MODIFY_SYS_IMAGE_GUID
init|=
literal|1
operator|<<
literal|0
block|,
name|IB_DEVICE_MODIFY_NODE_DESC
init|=
literal|1
operator|<<
literal|1
block|}
enum|;
end_enum

begin_struct
struct|struct
name|ib_device_modify
block|{
name|u64
name|sys_image_guid
decl_stmt|;
name|char
name|node_desc
index|[
literal|64
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_enum
enum|enum
name|ib_port_modify_flags
block|{
name|IB_PORT_SHUTDOWN
init|=
literal|1
block|,
name|IB_PORT_INIT_TYPE
init|=
operator|(
literal|1
operator|<<
literal|2
operator|)
block|,
name|IB_PORT_RESET_QKEY_CNTR
init|=
operator|(
literal|1
operator|<<
literal|3
operator|)
block|}
enum|;
end_enum

begin_struct
struct|struct
name|ib_port_modify
block|{
name|u32
name|set_port_cap_mask
decl_stmt|;
name|u32
name|clr_port_cap_mask
decl_stmt|;
name|u8
name|init_type
decl_stmt|;
block|}
struct|;
end_struct

begin_enum
enum|enum
name|ib_event_type
block|{
name|IB_EVENT_CQ_ERR
block|,
name|IB_EVENT_QP_FATAL
block|,
name|IB_EVENT_QP_REQ_ERR
block|,
name|IB_EVENT_QP_ACCESS_ERR
block|,
name|IB_EVENT_COMM_EST
block|,
name|IB_EVENT_SQ_DRAINED
block|,
name|IB_EVENT_PATH_MIG
block|,
name|IB_EVENT_PATH_MIG_ERR
block|,
name|IB_EVENT_DEVICE_FATAL
block|,
name|IB_EVENT_PORT_ACTIVE
block|,
name|IB_EVENT_PORT_ERR
block|,
name|IB_EVENT_LID_CHANGE
block|,
name|IB_EVENT_PKEY_CHANGE
block|,
name|IB_EVENT_SM_CHANGE
block|,
name|IB_EVENT_SRQ_ERR
block|,
name|IB_EVENT_SRQ_LIMIT_REACHED
block|,
name|IB_EVENT_QP_LAST_WQE_REACHED
block|,
name|IB_EVENT_CLIENT_REREGISTER
block|,
name|IB_EVENT_GID_CHANGE
block|, }
enum|;
end_enum

begin_struct
struct|struct
name|ib_event
block|{
name|struct
name|ib_device
modifier|*
name|device
decl_stmt|;
union|union
block|{
name|struct
name|ib_cq
modifier|*
name|cq
decl_stmt|;
name|struct
name|ib_qp
modifier|*
name|qp
decl_stmt|;
name|struct
name|ib_srq
modifier|*
name|srq
decl_stmt|;
name|u8
name|port_num
decl_stmt|;
block|}
name|element
union|;
name|enum
name|ib_event_type
name|event
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ib_event_handler
block|{
name|struct
name|ib_device
modifier|*
name|device
decl_stmt|;
name|void
function_decl|(
modifier|*
name|handler
function_decl|)
parameter_list|(
name|struct
name|ib_event_handler
modifier|*
parameter_list|,
name|struct
name|ib_event
modifier|*
parameter_list|)
function_decl|;
name|struct
name|list_head
name|list
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|INIT_IB_EVENT_HANDLER
parameter_list|(
name|_ptr
parameter_list|,
name|_device
parameter_list|,
name|_handler
parameter_list|)
define|\
value|do {							\ 		(_ptr)->device  = _device;			\ 		(_ptr)->handler = _handler;			\ 		INIT_LIST_HEAD(&(_ptr)->list);			\ 	} while (0)
end_define

begin_struct
struct|struct
name|ib_global_route
block|{
name|union
name|ib_gid
name|dgid
decl_stmt|;
name|u32
name|flow_label
decl_stmt|;
name|u8
name|sgid_index
decl_stmt|;
name|u8
name|hop_limit
decl_stmt|;
name|u8
name|traffic_class
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ib_grh
block|{
name|__be32
name|version_tclass_flow
decl_stmt|;
name|__be16
name|paylen
decl_stmt|;
name|u8
name|next_hdr
decl_stmt|;
name|u8
name|hop_limit
decl_stmt|;
name|union
name|ib_gid
name|sgid
decl_stmt|;
name|union
name|ib_gid
name|dgid
decl_stmt|;
block|}
struct|;
end_struct

begin_enum
enum|enum
block|{
name|IB_MULTICAST_QPN
init|=
literal|0xffffff
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|IB_LID_PERMISSIVE
value|cpu_to_be16(0xFFFF)
end_define

begin_enum
enum|enum
name|ib_ah_flags
block|{
name|IB_AH_GRH
init|=
literal|1
block|}
enum|;
end_enum

begin_enum
enum|enum
name|ib_rate
block|{
name|IB_RATE_PORT_CURRENT
init|=
literal|0
block|,
name|IB_RATE_2_5_GBPS
init|=
literal|2
block|,
name|IB_RATE_5_GBPS
init|=
literal|5
block|,
name|IB_RATE_10_GBPS
init|=
literal|3
block|,
name|IB_RATE_20_GBPS
init|=
literal|6
block|,
name|IB_RATE_30_GBPS
init|=
literal|4
block|,
name|IB_RATE_40_GBPS
init|=
literal|7
block|,
name|IB_RATE_60_GBPS
init|=
literal|8
block|,
name|IB_RATE_80_GBPS
init|=
literal|9
block|,
name|IB_RATE_120_GBPS
init|=
literal|10
block|,
name|IB_RATE_14_GBPS
init|=
literal|11
block|,
name|IB_RATE_56_GBPS
init|=
literal|12
block|,
name|IB_RATE_112_GBPS
init|=
literal|13
block|,
name|IB_RATE_168_GBPS
init|=
literal|14
block|,
name|IB_RATE_25_GBPS
init|=
literal|15
block|,
name|IB_RATE_100_GBPS
init|=
literal|16
block|,
name|IB_RATE_200_GBPS
init|=
literal|17
block|,
name|IB_RATE_300_GBPS
init|=
literal|18
block|}
enum|;
end_enum

begin_enum
enum|enum
name|ib_mr_create_flags
block|{
name|IB_MR_SIGNATURE_EN
init|=
literal|1
block|, }
enum|;
end_enum

begin_comment
comment|/**  * ib_mr_init_attr - Memory region init attributes passed to routine  *     ib_create_mr.  * @max_reg_descriptors: max number of registration descriptors that  *     may be used with registration work requests.  * @flags: MR creation flags bit mask.  */
end_comment

begin_struct
struct|struct
name|ib_mr_init_attr
block|{
name|int
name|max_reg_descriptors
decl_stmt|;
name|u32
name|flags
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/**  * ib_rate_to_mult - Convert the IB rate enum to a multiple of the  * base rate of 2.5 Gbit/sec.  For example, IB_RATE_5_GBPS will be  * converted to 2, since 5 Gbit/sec is 2 * 2.5 Gbit/sec.  * @rate: rate to convert.  */
end_comment

begin_decl_stmt
name|int
name|ib_rate_to_mult
argument_list|(
expr|enum
name|ib_rate
name|rate
argument_list|)
name|__attribute_const__
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**  * ib_rate_to_mbps - Convert the IB rate enum to Mbps.  * For example, IB_RATE_2_5_GBPS will be converted to 2500.  * @rate: rate to convert.  */
end_comment

begin_decl_stmt
name|int
name|ib_rate_to_mbps
argument_list|(
expr|enum
name|ib_rate
name|rate
argument_list|)
name|__attribute_const__
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|ib_cq_init_attr
block|{
name|int
name|cqe
decl_stmt|;
name|int
name|comp_vector
decl_stmt|;
name|u32
name|flags
decl_stmt|;
block|}
struct|;
end_struct

begin_enum
enum|enum
name|ib_signature_type
block|{
name|IB_SIG_TYPE_T10_DIF
block|, }
enum|;
end_enum

begin_comment
comment|/**  * T10-DIF Signature types  * T10-DIF types are defined by SCSI  * specifications.  */
end_comment

begin_enum
enum|enum
name|ib_t10_dif_type
block|{
name|IB_T10DIF_NONE
block|,
name|IB_T10DIF_TYPE1
block|,
name|IB_T10DIF_TYPE2
block|,
name|IB_T10DIF_TYPE3
block|}
enum|;
end_enum

begin_comment
comment|/**  * Signature T10-DIF block-guard types  * IB_T10DIF_CRC: Corresponds to T10-PI mandated CRC checksum rules.  * IB_T10DIF_CSUM: Corresponds to IP checksum rules.  */
end_comment

begin_enum
enum|enum
name|ib_t10_dif_bg_type
block|{
name|IB_T10DIF_CRC
block|,
name|IB_T10DIF_CSUM
block|}
enum|;
end_enum

begin_comment
comment|/**  * struct ib_t10_dif_domain - Parameters specific for T10-DIF  *     domain.  * @type: T10-DIF type (0|1|2|3)  * @bg_type: T10-DIF block guard type (CRC|CSUM)  * @pi_interval: protection information interval.  * @bg: seed of guard computation.  * @app_tag: application tag of guard block  * @ref_tag: initial guard block reference tag.  * @type3_inc_reftag: T10-DIF type 3 does not state  *     about the reference tag, it is the user  *     choice to increment it or not.  */
end_comment

begin_struct
struct|struct
name|ib_t10_dif_domain
block|{
name|enum
name|ib_t10_dif_type
name|type
decl_stmt|;
name|enum
name|ib_t10_dif_bg_type
name|bg_type
decl_stmt|;
name|u32
name|pi_interval
decl_stmt|;
name|u16
name|bg
decl_stmt|;
name|u16
name|app_tag
decl_stmt|;
name|u32
name|ref_tag
decl_stmt|;
name|bool
name|type3_inc_reftag
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/**  * struct ib_sig_domain - Parameters for signature domain  * @sig_type: specific signauture type  * @sig: union of all signature domain attributes that may  *     be used to set domain layout.  */
end_comment

begin_struct
struct|struct
name|ib_sig_domain
block|{
name|enum
name|ib_signature_type
name|sig_type
decl_stmt|;
union|union
block|{
name|struct
name|ib_t10_dif_domain
name|dif
decl_stmt|;
block|}
name|sig
union|;
block|}
struct|;
end_struct

begin_comment
comment|/**  * struct ib_sig_attrs - Parameters for signature handover operation  * @check_mask: bitmask for signature byte check (8 bytes)  * @mem: memory domain layout desciptor.  * @wire: wire domain layout desciptor.  */
end_comment

begin_struct
struct|struct
name|ib_sig_attrs
block|{
name|u8
name|check_mask
decl_stmt|;
name|struct
name|ib_sig_domain
name|mem
decl_stmt|;
name|struct
name|ib_sig_domain
name|wire
decl_stmt|;
block|}
struct|;
end_struct

begin_enum
enum|enum
name|ib_sig_err_type
block|{
name|IB_SIG_BAD_GUARD
block|,
name|IB_SIG_BAD_REFTAG
block|,
name|IB_SIG_BAD_APPTAG
block|, }
enum|;
end_enum

begin_comment
comment|/**  * struct ib_sig_err - signature error descriptor  */
end_comment

begin_struct
struct|struct
name|ib_sig_err
block|{
name|enum
name|ib_sig_err_type
name|err_type
decl_stmt|;
name|u32
name|expected
decl_stmt|;
name|u32
name|actual
decl_stmt|;
name|u64
name|sig_err_offset
decl_stmt|;
name|u32
name|key
decl_stmt|;
block|}
struct|;
end_struct

begin_enum
enum|enum
name|ib_mr_status_check
block|{
name|IB_MR_CHECK_SIG_STATUS
init|=
literal|1
block|, }
enum|;
end_enum

begin_comment
comment|/**  * struct ib_mr_status - Memory region status container  *  * @fail_status: Bitmask of MR checks status. For each  *     failed check a corresponding status bit is set.  * @sig_err: Additional info for IB_MR_CEHCK_SIG_STATUS  *     failure.  */
end_comment

begin_struct
struct|struct
name|ib_mr_status
block|{
name|u32
name|fail_status
decl_stmt|;
name|struct
name|ib_sig_err
name|sig_err
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/**  * mult_to_ib_rate - Convert a multiple of 2.5 Gbit/sec to an IB rate  * enum.  * @mult: multiple to convert.  */
end_comment

begin_decl_stmt
name|enum
name|ib_rate
name|mult_to_ib_rate
argument_list|(
name|int
name|mult
argument_list|)
name|__attribute_const__
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|ib_ah_attr
block|{
name|struct
name|ib_global_route
name|grh
decl_stmt|;
name|u16
name|dlid
decl_stmt|;
name|u8
name|sl
decl_stmt|;
name|u8
name|src_path_bits
decl_stmt|;
name|u8
name|static_rate
decl_stmt|;
name|u8
name|ah_flags
decl_stmt|;
name|u8
name|port_num
decl_stmt|;
name|u8
name|dmac
index|[
literal|6
index|]
decl_stmt|;
name|u16
name|vlan_id
decl_stmt|;
block|}
struct|;
end_struct

begin_enum
enum|enum
name|ib_wc_status
block|{
name|IB_WC_SUCCESS
block|,
name|IB_WC_LOC_LEN_ERR
block|,
name|IB_WC_LOC_QP_OP_ERR
block|,
name|IB_WC_LOC_EEC_OP_ERR
block|,
name|IB_WC_LOC_PROT_ERR
block|,
name|IB_WC_WR_FLUSH_ERR
block|,
name|IB_WC_MW_BIND_ERR
block|,
name|IB_WC_BAD_RESP_ERR
block|,
name|IB_WC_LOC_ACCESS_ERR
block|,
name|IB_WC_REM_INV_REQ_ERR
block|,
name|IB_WC_REM_ACCESS_ERR
block|,
name|IB_WC_REM_OP_ERR
block|,
name|IB_WC_RETRY_EXC_ERR
block|,
name|IB_WC_RNR_RETRY_EXC_ERR
block|,
name|IB_WC_LOC_RDD_VIOL_ERR
block|,
name|IB_WC_REM_INV_RD_REQ_ERR
block|,
name|IB_WC_REM_ABORT_ERR
block|,
name|IB_WC_INV_EECN_ERR
block|,
name|IB_WC_INV_EEC_STATE_ERR
block|,
name|IB_WC_FATAL_ERR
block|,
name|IB_WC_RESP_TIMEOUT_ERR
block|,
name|IB_WC_GENERAL_ERR
block|}
enum|;
end_enum

begin_enum
enum|enum
name|ib_wc_opcode
block|{
name|IB_WC_SEND
block|,
name|IB_WC_RDMA_WRITE
block|,
name|IB_WC_RDMA_READ
block|,
name|IB_WC_COMP_SWAP
block|,
name|IB_WC_FETCH_ADD
block|,
name|IB_WC_BIND_MW
block|,
name|IB_WC_LSO
block|,
name|IB_WC_LOCAL_INV
block|,
name|IB_WC_FAST_REG_MR
block|,
name|IB_WC_MASKED_COMP_SWAP
block|,
name|IB_WC_MASKED_FETCH_ADD
block|,
comment|/*  * Set value of IB_WC_RECV so consumers can test if a completion is a  * receive by testing (opcode& IB_WC_RECV).  */
name|IB_WC_RECV
init|=
literal|1
operator|<<
literal|7
block|,
name|IB_WC_RECV_RDMA_WITH_IMM
block|}
enum|;
end_enum

begin_enum
enum|enum
name|ib_wc_flags
block|{
name|IB_WC_GRH
init|=
literal|1
block|,
name|IB_WC_WITH_IMM
init|=
operator|(
literal|1
operator|<<
literal|1
operator|)
block|,
name|IB_WC_WITH_INVALIDATE
init|=
operator|(
literal|1
operator|<<
literal|2
operator|)
block|,
name|IB_WC_IP_CSUM_OK
init|=
operator|(
literal|1
operator|<<
literal|3
operator|)
block|,
name|IB_WC_WITH_SL
init|=
operator|(
literal|1
operator|<<
literal|4
operator|)
block|,
name|IB_WC_WITH_SLID
init|=
operator|(
literal|1
operator|<<
literal|5
operator|)
block|,
name|IB_WC_WITH_TIMESTAMP
init|=
operator|(
literal|1
operator|<<
literal|6
operator|)
block|,
name|IB_WC_WITH_SMAC
init|=
operator|(
literal|1
operator|<<
literal|7
operator|)
block|,
name|IB_WC_WITH_VLAN
init|=
operator|(
literal|1
operator|<<
literal|8
operator|)
block|, }
enum|;
end_enum

begin_struct
struct|struct
name|ib_wc
block|{
name|u64
name|wr_id
decl_stmt|;
name|enum
name|ib_wc_status
name|status
decl_stmt|;
name|enum
name|ib_wc_opcode
name|opcode
decl_stmt|;
name|u32
name|vendor_err
decl_stmt|;
name|u32
name|byte_len
decl_stmt|;
name|struct
name|ib_qp
modifier|*
name|qp
decl_stmt|;
union|union
block|{
name|__be32
name|imm_data
decl_stmt|;
name|u32
name|invalidate_rkey
decl_stmt|;
block|}
name|ex
union|;
name|u32
name|src_qp
decl_stmt|;
name|int
name|wc_flags
decl_stmt|;
name|u16
name|pkey_index
decl_stmt|;
name|u16
name|slid
decl_stmt|;
name|u8
name|sl
decl_stmt|;
name|u8
name|dlid_path_bits
decl_stmt|;
name|u8
name|port_num
decl_stmt|;
comment|/* valid only for DR SMPs on switches */
name|int
name|csum_ok
decl_stmt|;
struct|struct
block|{
name|uint64_t
name|timestamp
decl_stmt|;
comment|/* timestamp = 0 indicates error*/
block|}
name|ts
struct|;
name|u8
name|smac
index|[
literal|6
index|]
decl_stmt|;
name|u16
name|vlan_id
decl_stmt|;
block|}
struct|;
end_struct

begin_enum
enum|enum
name|ib_cq_notify_flags
block|{
name|IB_CQ_SOLICITED
init|=
literal|1
operator|<<
literal|0
block|,
name|IB_CQ_NEXT_COMP
init|=
literal|1
operator|<<
literal|1
block|,
name|IB_CQ_SOLICITED_MASK
init|=
name|IB_CQ_SOLICITED
operator||
name|IB_CQ_NEXT_COMP
block|,
name|IB_CQ_REPORT_MISSED_EVENTS
init|=
literal|1
operator|<<
literal|2
block|, }
enum|;
end_enum

begin_enum
enum|enum
name|ib_srq_type
block|{
name|IB_SRQT_BASIC
block|,
name|IB_SRQT_XRC
block|}
enum|;
end_enum

begin_enum
enum|enum
name|ib_srq_attr_mask
block|{
name|IB_SRQ_MAX_WR
init|=
literal|1
operator|<<
literal|0
block|,
name|IB_SRQ_LIMIT
init|=
literal|1
operator|<<
literal|1
block|, }
enum|;
end_enum

begin_struct
struct|struct
name|ib_srq_attr
block|{
name|u32
name|max_wr
decl_stmt|;
name|u32
name|max_sge
decl_stmt|;
name|u32
name|srq_limit
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ib_srq_init_attr
block|{
name|void
function_decl|(
modifier|*
name|event_handler
function_decl|)
parameter_list|(
name|struct
name|ib_event
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
name|void
modifier|*
name|srq_context
decl_stmt|;
name|struct
name|ib_srq_attr
name|attr
decl_stmt|;
name|enum
name|ib_srq_type
name|srq_type
decl_stmt|;
union|union
block|{
struct|struct
block|{
name|struct
name|ib_xrcd
modifier|*
name|xrcd
decl_stmt|;
name|struct
name|ib_cq
modifier|*
name|cq
decl_stmt|;
block|}
name|xrc
struct|;
block|}
name|ext
union|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ib_qp_cap
block|{
name|u32
name|max_send_wr
decl_stmt|;
name|u32
name|max_recv_wr
decl_stmt|;
name|u32
name|max_send_sge
decl_stmt|;
name|u32
name|max_recv_sge
decl_stmt|;
name|u32
name|max_inline_data
decl_stmt|;
name|u32
name|qpg_tss_mask_sz
decl_stmt|;
block|}
struct|;
end_struct

begin_enum
enum|enum
name|ib_sig_type
block|{
name|IB_SIGNAL_ALL_WR
block|,
name|IB_SIGNAL_REQ_WR
block|}
enum|;
end_enum

begin_enum
enum|enum
name|ib_qp_type
block|{
comment|/* 	 * IB_QPT_SMI and IB_QPT_GSI have to be the first two entries 	 * here (and in that order) since the MAD layer uses them as 	 * indices into a 2-entry table. 	 */
name|IB_QPT_SMI
block|,
name|IB_QPT_GSI
block|,
name|IB_QPT_RC
block|,
name|IB_QPT_UC
block|,
name|IB_QPT_UD
block|,
name|IB_QPT_RAW_IPV6
block|,
name|IB_QPT_RAW_ETHERTYPE
block|,
name|IB_QPT_RAW_PACKET
init|=
literal|8
block|,
name|IB_QPT_XRC_INI
init|=
literal|9
block|,
name|IB_QPT_XRC_TGT
block|,
name|IB_QPT_DC_INI
block|,
name|IB_QPT_MAX
block|,
comment|/* Reserve a range for qp types internal to the low level driver. 	 * These qp types will not be visible at the IB core layer, so the 	 * IB_QPT_MAX usages should not be affected in the core layer 	 */
name|IB_QPT_RESERVED1
init|=
literal|0x1000
block|,
name|IB_QPT_RESERVED2
block|,
name|IB_QPT_RESERVED3
block|,
name|IB_QPT_RESERVED4
block|,
name|IB_QPT_RESERVED5
block|,
name|IB_QPT_RESERVED6
block|,
name|IB_QPT_RESERVED7
block|,
name|IB_QPT_RESERVED8
block|,
name|IB_QPT_RESERVED9
block|,
name|IB_QPT_RESERVED10
block|, }
enum|;
end_enum

begin_enum
enum|enum
name|ib_qp_create_flags
block|{
name|IB_QP_CREATE_IPOIB_UD_LSO
init|=
literal|1
operator|<<
literal|0
block|,
name|IB_QP_CREATE_BLOCK_MULTICAST_LOOPBACK
init|=
literal|1
operator|<<
literal|1
block|,
name|IB_QP_CREATE_CROSS_CHANNEL
init|=
literal|1
operator|<<
literal|2
block|,
name|IB_QP_CREATE_MANAGED_SEND
init|=
literal|1
operator|<<
literal|3
block|,
name|IB_QP_CREATE_MANAGED_RECV
init|=
literal|1
operator|<<
literal|4
block|,
name|IB_QP_CREATE_NETIF_QP
init|=
literal|1
operator|<<
literal|5
block|,
name|IB_QP_CREATE_SIGNATURE_EN
init|=
literal|1
operator|<<
literal|6
block|,
comment|/* reserve bits 26-31 for low level drivers' internal use */
name|IB_QP_CREATE_RESERVED_START
init|=
literal|1
operator|<<
literal|26
block|,
name|IB_QP_CREATE_RESERVED_END
init|=
literal|1
operator|<<
literal|31
block|, }
enum|;
end_enum

begin_enum
enum|enum
name|ib_qpg_type
block|{
name|IB_QPG_NONE
init|=
literal|0
block|,
name|IB_QPG_PARENT
init|=
operator|(
literal|1
operator|<<
literal|0
operator|)
block|,
name|IB_QPG_CHILD_RX
init|=
operator|(
literal|1
operator|<<
literal|1
operator|)
block|,
name|IB_QPG_CHILD_TX
init|=
operator|(
literal|1
operator|<<
literal|2
operator|)
block|}
enum|;
end_enum

begin_struct
struct|struct
name|ib_qpg_init_attrib
block|{
name|u32
name|tss_child_count
decl_stmt|;
name|u32
name|rss_child_count
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ib_qp_init_attr
block|{
name|void
function_decl|(
modifier|*
name|event_handler
function_decl|)
parameter_list|(
name|struct
name|ib_event
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
name|void
modifier|*
name|qp_context
decl_stmt|;
name|struct
name|ib_cq
modifier|*
name|send_cq
decl_stmt|;
name|struct
name|ib_cq
modifier|*
name|recv_cq
decl_stmt|;
name|struct
name|ib_srq
modifier|*
name|srq
decl_stmt|;
name|struct
name|ib_xrcd
modifier|*
name|xrcd
decl_stmt|;
comment|/* XRC TGT QPs only */
name|struct
name|ib_qp_cap
name|cap
decl_stmt|;
union|union
block|{
name|struct
name|ib_qp
modifier|*
name|qpg_parent
decl_stmt|;
comment|/* see qpg_type */
name|struct
name|ib_qpg_init_attrib
name|parent_attrib
decl_stmt|;
block|}
union|;
name|enum
name|ib_sig_type
name|sq_sig_type
decl_stmt|;
name|enum
name|ib_qp_type
name|qp_type
decl_stmt|;
name|enum
name|ib_qp_create_flags
name|create_flags
decl_stmt|;
name|enum
name|ib_qpg_type
name|qpg_type
decl_stmt|;
name|u8
name|port_num
decl_stmt|;
comment|/* special QP types only */
block|}
struct|;
end_struct

begin_enum
enum|enum
block|{
name|IB_DCT_CREATE_FLAG_RCV_INLINE
init|=
literal|1
operator|<<
literal|0
block|,
name|IB_DCT_CREATE_FLAGS_MASK
init|=
name|IB_DCT_CREATE_FLAG_RCV_INLINE
block|, }
enum|;
end_enum

begin_struct
struct|struct
name|ib_dct_init_attr
block|{
name|struct
name|ib_pd
modifier|*
name|pd
decl_stmt|;
name|struct
name|ib_cq
modifier|*
name|cq
decl_stmt|;
name|struct
name|ib_srq
modifier|*
name|srq
decl_stmt|;
name|u64
name|dc_key
decl_stmt|;
name|u8
name|port
decl_stmt|;
name|u32
name|access_flags
decl_stmt|;
name|u8
name|min_rnr_timer
decl_stmt|;
name|u8
name|tclass
decl_stmt|;
name|u32
name|flow_label
decl_stmt|;
name|enum
name|ib_mtu
name|mtu
decl_stmt|;
name|u8
name|pkey_index
decl_stmt|;
name|u8
name|gid_index
decl_stmt|;
name|u8
name|hop_limit
decl_stmt|;
name|u32
name|create_flags
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ib_dct_attr
block|{
name|u64
name|dc_key
decl_stmt|;
name|u8
name|port
decl_stmt|;
name|u32
name|access_flags
decl_stmt|;
name|u8
name|min_rnr_timer
decl_stmt|;
name|u8
name|tclass
decl_stmt|;
name|u32
name|flow_label
decl_stmt|;
name|enum
name|ib_mtu
name|mtu
decl_stmt|;
name|u8
name|pkey_index
decl_stmt|;
name|u8
name|gid_index
decl_stmt|;
name|u8
name|hop_limit
decl_stmt|;
name|u32
name|key_violations
decl_stmt|;
name|u8
name|state
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ib_qp_open_attr
block|{
name|void
function_decl|(
modifier|*
name|event_handler
function_decl|)
parameter_list|(
name|struct
name|ib_event
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
name|void
modifier|*
name|qp_context
decl_stmt|;
name|u32
name|qp_num
decl_stmt|;
name|enum
name|ib_qp_type
name|qp_type
decl_stmt|;
block|}
struct|;
end_struct

begin_enum
enum|enum
name|ib_rnr_timeout
block|{
name|IB_RNR_TIMER_655_36
init|=
literal|0
block|,
name|IB_RNR_TIMER_000_01
init|=
literal|1
block|,
name|IB_RNR_TIMER_000_02
init|=
literal|2
block|,
name|IB_RNR_TIMER_000_03
init|=
literal|3
block|,
name|IB_RNR_TIMER_000_04
init|=
literal|4
block|,
name|IB_RNR_TIMER_000_06
init|=
literal|5
block|,
name|IB_RNR_TIMER_000_08
init|=
literal|6
block|,
name|IB_RNR_TIMER_000_12
init|=
literal|7
block|,
name|IB_RNR_TIMER_000_16
init|=
literal|8
block|,
name|IB_RNR_TIMER_000_24
init|=
literal|9
block|,
name|IB_RNR_TIMER_000_32
init|=
literal|10
block|,
name|IB_RNR_TIMER_000_48
init|=
literal|11
block|,
name|IB_RNR_TIMER_000_64
init|=
literal|12
block|,
name|IB_RNR_TIMER_000_96
init|=
literal|13
block|,
name|IB_RNR_TIMER_001_28
init|=
literal|14
block|,
name|IB_RNR_TIMER_001_92
init|=
literal|15
block|,
name|IB_RNR_TIMER_002_56
init|=
literal|16
block|,
name|IB_RNR_TIMER_003_84
init|=
literal|17
block|,
name|IB_RNR_TIMER_005_12
init|=
literal|18
block|,
name|IB_RNR_TIMER_007_68
init|=
literal|19
block|,
name|IB_RNR_TIMER_010_24
init|=
literal|20
block|,
name|IB_RNR_TIMER_015_36
init|=
literal|21
block|,
name|IB_RNR_TIMER_020_48
init|=
literal|22
block|,
name|IB_RNR_TIMER_030_72
init|=
literal|23
block|,
name|IB_RNR_TIMER_040_96
init|=
literal|24
block|,
name|IB_RNR_TIMER_061_44
init|=
literal|25
block|,
name|IB_RNR_TIMER_081_92
init|=
literal|26
block|,
name|IB_RNR_TIMER_122_88
init|=
literal|27
block|,
name|IB_RNR_TIMER_163_84
init|=
literal|28
block|,
name|IB_RNR_TIMER_245_76
init|=
literal|29
block|,
name|IB_RNR_TIMER_327_68
init|=
literal|30
block|,
name|IB_RNR_TIMER_491_52
init|=
literal|31
block|}
enum|;
end_enum

begin_enum
enum|enum
name|ib_qp_attr_mask
block|{
name|IB_QP_STATE
init|=
literal|1
block|,
name|IB_QP_CUR_STATE
init|=
operator|(
literal|1
operator|<<
literal|1
operator|)
block|,
name|IB_QP_EN_SQD_ASYNC_NOTIFY
init|=
operator|(
literal|1
operator|<<
literal|2
operator|)
block|,
name|IB_QP_ACCESS_FLAGS
init|=
operator|(
literal|1
operator|<<
literal|3
operator|)
block|,
name|IB_QP_PKEY_INDEX
init|=
operator|(
literal|1
operator|<<
literal|4
operator|)
block|,
name|IB_QP_PORT
init|=
operator|(
literal|1
operator|<<
literal|5
operator|)
block|,
name|IB_QP_QKEY
init|=
operator|(
literal|1
operator|<<
literal|6
operator|)
block|,
name|IB_QP_AV
init|=
operator|(
literal|1
operator|<<
literal|7
operator|)
block|,
name|IB_QP_PATH_MTU
init|=
operator|(
literal|1
operator|<<
literal|8
operator|)
block|,
name|IB_QP_TIMEOUT
init|=
operator|(
literal|1
operator|<<
literal|9
operator|)
block|,
name|IB_QP_RETRY_CNT
init|=
operator|(
literal|1
operator|<<
literal|10
operator|)
block|,
name|IB_QP_RNR_RETRY
init|=
operator|(
literal|1
operator|<<
literal|11
operator|)
block|,
name|IB_QP_RQ_PSN
init|=
operator|(
literal|1
operator|<<
literal|12
operator|)
block|,
name|IB_QP_MAX_QP_RD_ATOMIC
init|=
operator|(
literal|1
operator|<<
literal|13
operator|)
block|,
name|IB_QP_ALT_PATH
init|=
operator|(
literal|1
operator|<<
literal|14
operator|)
block|,
name|IB_QP_MIN_RNR_TIMER
init|=
operator|(
literal|1
operator|<<
literal|15
operator|)
block|,
name|IB_QP_SQ_PSN
init|=
operator|(
literal|1
operator|<<
literal|16
operator|)
block|,
name|IB_QP_MAX_DEST_RD_ATOMIC
init|=
operator|(
literal|1
operator|<<
literal|17
operator|)
block|,
name|IB_QP_PATH_MIG_STATE
init|=
operator|(
literal|1
operator|<<
literal|18
operator|)
block|,
name|IB_QP_CAP
init|=
operator|(
literal|1
operator|<<
literal|19
operator|)
block|,
name|IB_QP_DEST_QPN
init|=
operator|(
literal|1
operator|<<
literal|20
operator|)
block|,
name|IB_QP_GROUP_RSS
init|=
operator|(
literal|1
operator|<<
literal|21
operator|)
block|,
name|IB_QP_DC_KEY
init|=
operator|(
literal|1
operator|<<
literal|22
operator|)
block|,
name|IB_QP_SMAC
init|=
operator|(
literal|1
operator|<<
literal|23
operator|)
block|,
name|IB_QP_ALT_SMAC
init|=
operator|(
literal|1
operator|<<
literal|24
operator|)
block|,
name|IB_QP_VID
init|=
operator|(
literal|1
operator|<<
literal|25
operator|)
block|,
name|IB_QP_ALT_VID
init|=
operator|(
literal|1
operator|<<
literal|26
operator|)
block|}
enum|;
end_enum

begin_enum
enum|enum
name|ib_qp_state
block|{
name|IB_QPS_RESET
block|,
name|IB_QPS_INIT
block|,
name|IB_QPS_RTR
block|,
name|IB_QPS_RTS
block|,
name|IB_QPS_SQD
block|,
name|IB_QPS_SQE
block|,
name|IB_QPS_ERR
block|,
name|IB_QPS_DUMMY
init|=
operator|-
literal|1
comment|/* force enum signed */
block|}
enum|;
end_enum

begin_enum
enum|enum
name|ib_mig_state
block|{
name|IB_MIG_MIGRATED
block|,
name|IB_MIG_REARM
block|,
name|IB_MIG_ARMED
block|}
enum|;
end_enum

begin_enum
enum|enum
name|ib_mw_type
block|{
name|IB_MW_TYPE_1
init|=
literal|1
block|,
name|IB_MW_TYPE_2
init|=
literal|2
block|}
enum|;
end_enum

begin_struct
struct|struct
name|ib_qp_attr
block|{
name|enum
name|ib_qp_state
name|qp_state
decl_stmt|;
name|enum
name|ib_qp_state
name|cur_qp_state
decl_stmt|;
name|enum
name|ib_mtu
name|path_mtu
decl_stmt|;
name|enum
name|ib_mig_state
name|path_mig_state
decl_stmt|;
name|u32
name|qkey
decl_stmt|;
name|u32
name|rq_psn
decl_stmt|;
name|u32
name|sq_psn
decl_stmt|;
name|u32
name|dest_qp_num
decl_stmt|;
name|int
name|qp_access_flags
decl_stmt|;
name|struct
name|ib_qp_cap
name|cap
decl_stmt|;
name|struct
name|ib_ah_attr
name|ah_attr
decl_stmt|;
name|struct
name|ib_ah_attr
name|alt_ah_attr
decl_stmt|;
name|u16
name|pkey_index
decl_stmt|;
name|u16
name|alt_pkey_index
decl_stmt|;
name|u8
name|en_sqd_async_notify
decl_stmt|;
name|u8
name|sq_draining
decl_stmt|;
name|u8
name|max_rd_atomic
decl_stmt|;
name|u8
name|max_dest_rd_atomic
decl_stmt|;
name|u8
name|min_rnr_timer
decl_stmt|;
name|u8
name|port_num
decl_stmt|;
name|u8
name|timeout
decl_stmt|;
name|u8
name|retry_cnt
decl_stmt|;
name|u8
name|rnr_retry
decl_stmt|;
name|u8
name|alt_port_num
decl_stmt|;
name|u8
name|alt_timeout
decl_stmt|;
name|u8
name|smac
index|[
name|ETH_ALEN
index|]
decl_stmt|;
name|u8
name|alt_smac
index|[
name|ETH_ALEN
index|]
decl_stmt|;
name|u16
name|vlan_id
decl_stmt|;
name|u16
name|alt_vlan_id
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ib_qp_attr_ex
block|{
name|enum
name|ib_qp_state
name|qp_state
decl_stmt|;
name|enum
name|ib_qp_state
name|cur_qp_state
decl_stmt|;
name|enum
name|ib_mtu
name|path_mtu
decl_stmt|;
name|enum
name|ib_mig_state
name|path_mig_state
decl_stmt|;
name|u32
name|qkey
decl_stmt|;
name|u32
name|rq_psn
decl_stmt|;
name|u32
name|sq_psn
decl_stmt|;
name|u32
name|dest_qp_num
decl_stmt|;
name|int
name|qp_access_flags
decl_stmt|;
name|struct
name|ib_qp_cap
name|cap
decl_stmt|;
name|struct
name|ib_ah_attr
name|ah_attr
decl_stmt|;
name|struct
name|ib_ah_attr
name|alt_ah_attr
decl_stmt|;
name|u16
name|pkey_index
decl_stmt|;
name|u16
name|alt_pkey_index
decl_stmt|;
name|u8
name|en_sqd_async_notify
decl_stmt|;
name|u8
name|sq_draining
decl_stmt|;
name|u8
name|max_rd_atomic
decl_stmt|;
name|u8
name|max_dest_rd_atomic
decl_stmt|;
name|u8
name|min_rnr_timer
decl_stmt|;
name|u8
name|port_num
decl_stmt|;
name|u8
name|timeout
decl_stmt|;
name|u8
name|retry_cnt
decl_stmt|;
name|u8
name|rnr_retry
decl_stmt|;
name|u8
name|alt_port_num
decl_stmt|;
name|u8
name|alt_timeout
decl_stmt|;
name|u64
name|dct_key
decl_stmt|;
block|}
struct|;
end_struct

begin_enum
enum|enum
name|ib_wr_opcode
block|{
name|IB_WR_RDMA_WRITE
block|,
name|IB_WR_RDMA_WRITE_WITH_IMM
block|,
name|IB_WR_SEND
block|,
name|IB_WR_SEND_WITH_IMM
block|,
name|IB_WR_RDMA_READ
block|,
name|IB_WR_ATOMIC_CMP_AND_SWP
block|,
name|IB_WR_ATOMIC_FETCH_AND_ADD
block|,
name|IB_WR_LSO
block|,
name|IB_WR_SEND_WITH_INV
block|,
name|IB_WR_RDMA_READ_WITH_INV
block|,
name|IB_WR_LOCAL_INV
block|,
name|IB_WR_FAST_REG_MR
block|,
name|IB_WR_MASKED_ATOMIC_CMP_AND_SWP
block|,
name|IB_WR_MASKED_ATOMIC_FETCH_AND_ADD
block|,
name|IB_WR_BIND_MW
block|,
name|IB_WR_REG_SIG_MR
block|,
comment|/* reserve values for low level drivers' internal use. 	 * These values will not be used at all in the ib core layer. 	 */
name|IB_WR_RESERVED1
init|=
literal|0xf0
block|,
name|IB_WR_RESERVED2
block|,
name|IB_WR_RESERVED3
block|,
name|IB_WR_RESERVED4
block|,
name|IB_WR_RESERVED5
block|,
name|IB_WR_RESERVED6
block|,
name|IB_WR_RESERVED7
block|,
name|IB_WR_RESERVED8
block|,
name|IB_WR_RESERVED9
block|,
name|IB_WR_RESERVED10
block|,
name|IB_WR_DUMMY
init|=
operator|-
literal|1
block|,
comment|/* force enum type signed */
block|}
enum|;
end_enum

begin_enum
enum|enum
name|ib_send_flags
block|{
name|IB_SEND_FENCE
init|=
literal|1
block|,
name|IB_SEND_SIGNALED
init|=
operator|(
literal|1
operator|<<
literal|1
operator|)
block|,
name|IB_SEND_SOLICITED
init|=
operator|(
literal|1
operator|<<
literal|2
operator|)
block|,
name|IB_SEND_INLINE
init|=
operator|(
literal|1
operator|<<
literal|3
operator|)
block|,
name|IB_SEND_IP_CSUM
init|=
operator|(
literal|1
operator|<<
literal|4
operator|)
block|,
comment|/* reserve bits 26-31 for low level drivers' internal use */
name|IB_SEND_RESERVED_START
init|=
operator|(
literal|1
operator|<<
literal|26
operator|)
block|,
name|IB_SEND_RESERVED_END
init|=
operator|(
literal|1
operator|<<
literal|31
operator|)
block|,
name|IB_SEND_UMR_UNREG
init|=
operator|(
literal|1
operator|<<
literal|5
operator|)
block|}
enum|;
end_enum

begin_struct
struct|struct
name|ib_sge
block|{
name|u64
name|addr
decl_stmt|;
name|u32
name|length
decl_stmt|;
name|u32
name|lkey
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ib_fast_reg_page_list
block|{
name|struct
name|ib_device
modifier|*
name|device
decl_stmt|;
name|u64
modifier|*
name|page_list
decl_stmt|;
name|unsigned
name|int
name|max_page_list_len
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/**  * struct ib_mw_bind_info - Parameters for a memory window bind operation.  * @mr: A memory region to bind the memory window to.  * @addr: The address where the memory window should begin.  * @length: The length of the memory window, in bytes.  * @mw_access_flags: Access flags from enum ib_access_flags for the window.  *  * This struct contains the shared parameters for type 1 and type 2  * memory window bind operations.  */
end_comment

begin_struct
struct|struct
name|ib_mw_bind_info
block|{
name|struct
name|ib_mr
modifier|*
name|mr
decl_stmt|;
name|u64
name|addr
decl_stmt|;
name|u64
name|length
decl_stmt|;
name|int
name|mw_access_flags
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ib_send_wr
block|{
name|struct
name|ib_send_wr
modifier|*
name|next
decl_stmt|;
name|u64
name|wr_id
decl_stmt|;
name|struct
name|ib_sge
modifier|*
name|sg_list
decl_stmt|;
name|int
name|num_sge
decl_stmt|;
name|enum
name|ib_wr_opcode
name|opcode
decl_stmt|;
name|int
name|send_flags
decl_stmt|;
union|union
block|{
name|__be32
name|imm_data
decl_stmt|;
name|u32
name|invalidate_rkey
decl_stmt|;
block|}
name|ex
union|;
union|union
block|{
struct|struct
block|{
name|u64
name|remote_addr
decl_stmt|;
name|u32
name|rkey
decl_stmt|;
block|}
name|rdma
struct|;
struct|struct
block|{
name|u64
name|remote_addr
decl_stmt|;
name|u64
name|compare_add
decl_stmt|;
name|u64
name|swap
decl_stmt|;
name|u64
name|compare_add_mask
decl_stmt|;
name|u64
name|swap_mask
decl_stmt|;
name|u32
name|rkey
decl_stmt|;
block|}
name|atomic
struct|;
struct|struct
block|{
name|struct
name|ib_ah
modifier|*
name|ah
decl_stmt|;
name|void
modifier|*
name|header
decl_stmt|;
name|int
name|hlen
decl_stmt|;
name|int
name|mss
decl_stmt|;
name|u32
name|remote_qpn
decl_stmt|;
name|u32
name|remote_qkey
decl_stmt|;
name|u16
name|pkey_index
decl_stmt|;
comment|/* valid for GSI only */
name|u8
name|port_num
decl_stmt|;
comment|/* valid for DR SMPs on switch only */
block|}
name|ud
struct|;
struct|struct
block|{
name|u64
name|iova_start
decl_stmt|;
name|struct
name|ib_fast_reg_page_list
modifier|*
name|page_list
decl_stmt|;
name|unsigned
name|int
name|page_shift
decl_stmt|;
name|unsigned
name|int
name|page_list_len
decl_stmt|;
name|u32
name|length
decl_stmt|;
name|int
name|access_flags
decl_stmt|;
name|u32
name|rkey
decl_stmt|;
block|}
name|fast_reg
struct|;
struct|struct
block|{
name|int
name|npages
decl_stmt|;
name|int
name|access_flags
decl_stmt|;
name|u32
name|mkey
decl_stmt|;
name|struct
name|ib_pd
modifier|*
name|pd
decl_stmt|;
name|u64
name|virt_addr
decl_stmt|;
name|u64
name|length
decl_stmt|;
name|int
name|page_shift
decl_stmt|;
block|}
name|umr
struct|;
struct|struct
block|{
name|struct
name|ib_mw
modifier|*
name|mw
decl_stmt|;
comment|/* The new rkey for the memory window. */
name|u32
name|rkey
decl_stmt|;
name|struct
name|ib_mw_bind_info
name|bind_info
decl_stmt|;
block|}
name|bind_mw
struct|;
struct|struct
block|{
name|struct
name|ib_sig_attrs
modifier|*
name|sig_attrs
decl_stmt|;
name|struct
name|ib_mr
modifier|*
name|sig_mr
decl_stmt|;
name|int
name|access_flags
decl_stmt|;
name|struct
name|ib_sge
modifier|*
name|prot
decl_stmt|;
block|}
name|sig_handover
struct|;
block|}
name|wr
union|;
name|u32
name|xrc_remote_srq_num
decl_stmt|;
comment|/* XRC TGT QPs only */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ib_recv_wr
block|{
name|struct
name|ib_recv_wr
modifier|*
name|next
decl_stmt|;
name|u64
name|wr_id
decl_stmt|;
name|struct
name|ib_sge
modifier|*
name|sg_list
decl_stmt|;
name|int
name|num_sge
decl_stmt|;
block|}
struct|;
end_struct

begin_enum
enum|enum
name|ib_access_flags
block|{
name|IB_ACCESS_LOCAL_WRITE
init|=
literal|1
block|,
name|IB_ACCESS_REMOTE_WRITE
init|=
operator|(
literal|1
operator|<<
literal|1
operator|)
block|,
name|IB_ACCESS_REMOTE_READ
init|=
operator|(
literal|1
operator|<<
literal|2
operator|)
block|,
name|IB_ACCESS_REMOTE_ATOMIC
init|=
operator|(
literal|1
operator|<<
literal|3
operator|)
block|,
name|IB_ACCESS_MW_BIND
init|=
operator|(
literal|1
operator|<<
literal|4
operator|)
block|,
name|IB_ACCESS_ALLOCATE_MR
init|=
operator|(
literal|1
operator|<<
literal|5
operator|)
block|,
name|IB_ZERO_BASED
init|=
operator|(
literal|1
operator|<<
literal|13
operator|)
block|}
enum|;
end_enum

begin_struct
struct|struct
name|ib_phys_buf
block|{
name|u64
name|addr
decl_stmt|;
name|u64
name|size
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ib_mr_attr
block|{
name|struct
name|ib_pd
modifier|*
name|pd
decl_stmt|;
name|u64
name|device_virt_addr
decl_stmt|;
name|u64
name|size
decl_stmt|;
name|int
name|mr_access_flags
decl_stmt|;
name|u32
name|lkey
decl_stmt|;
name|u32
name|rkey
decl_stmt|;
block|}
struct|;
end_struct

begin_enum
enum|enum
name|ib_mr_rereg_flags
block|{
name|IB_MR_REREG_TRANS
init|=
literal|1
block|,
name|IB_MR_REREG_PD
init|=
operator|(
literal|1
operator|<<
literal|1
operator|)
block|,
name|IB_MR_REREG_ACCESS
init|=
operator|(
literal|1
operator|<<
literal|2
operator|)
block|}
enum|;
end_enum

begin_comment
comment|/**  * struct ib_mw_bind - Parameters for a type 1 memory window bind operation.  * @wr_id:      Work request id.  * @send_flags: Flags from ib_send_flags enum.  * @bind_info:  More parameters of the bind operation.  */
end_comment

begin_struct
struct|struct
name|ib_mw_bind
block|{
name|u64
name|wr_id
decl_stmt|;
name|int
name|send_flags
decl_stmt|;
name|struct
name|ib_mw_bind_info
name|bind_info
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ib_fmr_attr
block|{
name|int
name|max_pages
decl_stmt|;
name|int
name|max_maps
decl_stmt|;
name|u8
name|page_shift
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ib_ucontext
block|{
name|struct
name|ib_device
modifier|*
name|device
decl_stmt|;
name|struct
name|list_head
name|pd_list
decl_stmt|;
name|struct
name|list_head
name|mr_list
decl_stmt|;
name|struct
name|list_head
name|mw_list
decl_stmt|;
name|struct
name|list_head
name|cq_list
decl_stmt|;
name|struct
name|list_head
name|qp_list
decl_stmt|;
name|struct
name|list_head
name|srq_list
decl_stmt|;
name|struct
name|list_head
name|ah_list
decl_stmt|;
name|struct
name|list_head
name|xrcd_list
decl_stmt|;
name|struct
name|list_head
name|rule_list
decl_stmt|;
name|struct
name|list_head
name|dct_list
decl_stmt|;
name|int
name|closing
decl_stmt|;
name|void
modifier|*
name|peer_mem_private_data
decl_stmt|;
name|char
modifier|*
name|peer_mem_name
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ib_uobject
block|{
name|u64
name|user_handle
decl_stmt|;
comment|/* handle given to us by userspace */
name|struct
name|ib_ucontext
modifier|*
name|context
decl_stmt|;
comment|/* associated user context */
name|void
modifier|*
name|object
decl_stmt|;
comment|/* containing object */
name|struct
name|list_head
name|list
decl_stmt|;
comment|/* link to context's list */
name|int
name|id
decl_stmt|;
comment|/* index into kernel idr */
name|struct
name|kref
name|ref
decl_stmt|;
name|struct
name|rw_semaphore
name|mutex
decl_stmt|;
comment|/* protects .live */
name|int
name|live
decl_stmt|;
block|}
struct|;
end_struct

begin_struct_decl
struct_decl|struct
name|ib_udata
struct_decl|;
end_struct_decl

begin_struct
struct|struct
name|ib_udata_ops
block|{
name|int
function_decl|(
modifier|*
name|copy_from
function_decl|)
parameter_list|(
name|void
modifier|*
name|dest
parameter_list|,
name|struct
name|ib_udata
modifier|*
name|udata
parameter_list|,
name|size_t
name|len
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|copy_to
function_decl|)
parameter_list|(
name|struct
name|ib_udata
modifier|*
name|udata
parameter_list|,
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|len
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ib_udata
block|{
name|struct
name|ib_udata_ops
modifier|*
name|ops
decl_stmt|;
name|void
name|__user
modifier|*
name|inbuf
decl_stmt|;
name|void
name|__user
modifier|*
name|outbuf
decl_stmt|;
name|size_t
name|inlen
decl_stmt|;
name|size_t
name|outlen
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ib_pd
block|{
name|struct
name|ib_device
modifier|*
name|device
decl_stmt|;
name|struct
name|ib_uobject
modifier|*
name|uobject
decl_stmt|;
name|atomic_t
name|usecnt
decl_stmt|;
comment|/* count all resources */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ib_xrcd
block|{
name|struct
name|ib_device
modifier|*
name|device
decl_stmt|;
name|atomic_t
name|usecnt
decl_stmt|;
comment|/* count all exposed resources */
name|struct
name|inode
modifier|*
name|inode
decl_stmt|;
name|struct
name|mutex
name|tgt_qp_mutex
decl_stmt|;
name|struct
name|list_head
name|tgt_qp_list
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ib_ah
block|{
name|struct
name|ib_device
modifier|*
name|device
decl_stmt|;
name|struct
name|ib_pd
modifier|*
name|pd
decl_stmt|;
name|struct
name|ib_uobject
modifier|*
name|uobject
decl_stmt|;
block|}
struct|;
end_struct

begin_enum
enum|enum
name|ib_cq_attr_mask
block|{
name|IB_CQ_MODERATION
init|=
operator|(
literal|1
operator|<<
literal|0
operator|)
block|,
name|IB_CQ_CAP_FLAGS
init|=
operator|(
literal|1
operator|<<
literal|1
operator|)
block|}
enum|;
end_enum

begin_enum
enum|enum
name|ib_cq_cap_flags
block|{
name|IB_CQ_IGNORE_OVERRUN
init|=
operator|(
literal|1
operator|<<
literal|0
operator|)
block|}
enum|;
end_enum

begin_struct
struct|struct
name|ib_cq_attr
block|{
struct|struct
block|{
name|u16
name|cq_count
decl_stmt|;
name|u16
name|cq_period
decl_stmt|;
block|}
name|moderation
struct|;
name|u32
name|cq_cap_flags
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|void
function_decl|(
modifier|*
name|ib_comp_handler
function_decl|)
parameter_list|(
name|struct
name|ib_cq
modifier|*
name|cq
parameter_list|,
name|void
modifier|*
name|cq_context
parameter_list|)
function_decl|;
end_typedef

begin_struct
struct|struct
name|ib_cq
block|{
name|struct
name|ib_device
modifier|*
name|device
decl_stmt|;
name|struct
name|ib_uobject
modifier|*
name|uobject
decl_stmt|;
name|ib_comp_handler
name|comp_handler
decl_stmt|;
name|void
function_decl|(
modifier|*
name|event_handler
function_decl|)
parameter_list|(
name|struct
name|ib_event
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
name|void
modifier|*
name|cq_context
decl_stmt|;
name|int
name|cqe
decl_stmt|;
name|atomic_t
name|usecnt
decl_stmt|;
comment|/* count number of work queues */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ib_srq
block|{
name|struct
name|ib_device
modifier|*
name|device
decl_stmt|;
name|struct
name|ib_pd
modifier|*
name|pd
decl_stmt|;
name|struct
name|ib_uobject
modifier|*
name|uobject
decl_stmt|;
name|void
function_decl|(
modifier|*
name|event_handler
function_decl|)
parameter_list|(
name|struct
name|ib_event
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
name|void
modifier|*
name|srq_context
decl_stmt|;
name|enum
name|ib_srq_type
name|srq_type
decl_stmt|;
name|atomic_t
name|usecnt
decl_stmt|;
union|union
block|{
struct|struct
block|{
name|struct
name|ib_xrcd
modifier|*
name|xrcd
decl_stmt|;
name|struct
name|ib_cq
modifier|*
name|cq
decl_stmt|;
name|u32
name|srq_num
decl_stmt|;
block|}
name|xrc
struct|;
block|}
name|ext
union|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ib_qp
block|{
name|struct
name|ib_device
modifier|*
name|device
decl_stmt|;
name|struct
name|ib_pd
modifier|*
name|pd
decl_stmt|;
name|struct
name|ib_cq
modifier|*
name|send_cq
decl_stmt|;
name|struct
name|ib_cq
modifier|*
name|recv_cq
decl_stmt|;
name|struct
name|ib_srq
modifier|*
name|srq
decl_stmt|;
name|struct
name|ib_xrcd
modifier|*
name|xrcd
decl_stmt|;
comment|/* XRC TGT QPs only */
name|struct
name|list_head
name|xrcd_list
decl_stmt|;
comment|/* count times opened, mcast attaches, flow attaches */
name|atomic_t
name|usecnt
decl_stmt|;
name|struct
name|list_head
name|open_list
decl_stmt|;
name|struct
name|ib_qp
modifier|*
name|real_qp
decl_stmt|;
name|struct
name|ib_uobject
modifier|*
name|uobject
decl_stmt|;
name|void
function_decl|(
modifier|*
name|event_handler
function_decl|)
parameter_list|(
name|struct
name|ib_event
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
name|void
modifier|*
name|qp_context
decl_stmt|;
name|u32
name|qp_num
decl_stmt|;
name|enum
name|ib_qp_type
name|qp_type
decl_stmt|;
name|enum
name|ib_qpg_type
name|qpg_type
decl_stmt|;
name|u8
name|port_num
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ib_dct
block|{
name|struct
name|ib_device
modifier|*
name|device
decl_stmt|;
name|struct
name|ib_uobject
modifier|*
name|uobject
decl_stmt|;
name|struct
name|ib_pd
modifier|*
name|pd
decl_stmt|;
name|struct
name|ib_cq
modifier|*
name|cq
decl_stmt|;
name|struct
name|ib_srq
modifier|*
name|srq
decl_stmt|;
name|u32
name|dct_num
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ib_mr
block|{
name|struct
name|ib_device
modifier|*
name|device
decl_stmt|;
name|struct
name|ib_pd
modifier|*
name|pd
decl_stmt|;
name|struct
name|ib_uobject
modifier|*
name|uobject
decl_stmt|;
name|u32
name|lkey
decl_stmt|;
name|u32
name|rkey
decl_stmt|;
name|atomic_t
name|usecnt
decl_stmt|;
comment|/* count number of MWs */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ib_mw
block|{
name|struct
name|ib_device
modifier|*
name|device
decl_stmt|;
name|struct
name|ib_pd
modifier|*
name|pd
decl_stmt|;
name|struct
name|ib_uobject
modifier|*
name|uobject
decl_stmt|;
name|u32
name|rkey
decl_stmt|;
name|enum
name|ib_mw_type
name|type
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ib_fmr
block|{
name|struct
name|ib_device
modifier|*
name|device
decl_stmt|;
name|struct
name|ib_pd
modifier|*
name|pd
decl_stmt|;
name|struct
name|list_head
name|list
decl_stmt|;
name|u32
name|lkey
decl_stmt|;
name|u32
name|rkey
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Supported steering options */
end_comment

begin_enum
enum|enum
name|ib_flow_attr_type
block|{
comment|/* steering according to rule specifications */
name|IB_FLOW_ATTR_NORMAL
init|=
literal|0x0
block|,
comment|/* default unicast and multicast rule - 	 * receive all Eth traffic which isn't steered to any QP 	 */
name|IB_FLOW_ATTR_ALL_DEFAULT
init|=
literal|0x1
block|,
comment|/* default multicast rule - 	 * receive all Eth multicast traffic which isn't steered to any QP 	 */
name|IB_FLOW_ATTR_MC_DEFAULT
init|=
literal|0x2
block|,
comment|/* sniffer rule - receive all port traffic */
name|IB_FLOW_ATTR_SNIFFER
init|=
literal|0x3
block|}
enum|;
end_enum

begin_comment
comment|/* Supported steering header types */
end_comment

begin_enum
enum|enum
name|ib_flow_spec_type
block|{
comment|/* L2 headers*/
name|IB_FLOW_SPEC_ETH
init|=
literal|0x20
block|,
name|IB_FLOW_SPEC_IB
init|=
literal|0x21
block|,
comment|/* L3 header*/
name|IB_FLOW_SPEC_IPV4
init|=
literal|0x30
block|,
comment|/* L4 headers*/
name|IB_FLOW_SPEC_TCP
init|=
literal|0x40
block|,
name|IB_FLOW_SPEC_UDP
init|=
literal|0x41
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|IB_FLOW_SPEC_SUPPORT_LAYERS
value|4
end_define

begin_comment
comment|/* Flow steering rule priority is set according to it's domain.  * Lower domain value means higher priority.  */
end_comment

begin_enum
enum|enum
name|ib_flow_domain
block|{
name|IB_FLOW_DOMAIN_USER
block|,
name|IB_FLOW_DOMAIN_ETHTOOL
block|,
name|IB_FLOW_DOMAIN_RFS
block|,
name|IB_FLOW_DOMAIN_NIC
block|,
name|IB_FLOW_DOMAIN_NUM
comment|/* Must be last */
block|}
enum|;
end_enum

begin_enum
enum|enum
name|ib_flow_flags
block|{
name|IB_FLOW_ATTR_FLAGS_ALLOW_LOOP_BACK
init|=
literal|1
block|}
enum|;
end_enum

begin_struct
struct|struct
name|ib_flow_eth_filter
block|{
name|u8
name|dst_mac
index|[
literal|6
index|]
decl_stmt|;
name|u8
name|src_mac
index|[
literal|6
index|]
decl_stmt|;
name|__be16
name|ether_type
decl_stmt|;
name|__be16
name|vlan_tag
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ib_flow_spec_eth
block|{
name|enum
name|ib_flow_spec_type
name|type
decl_stmt|;
name|u16
name|size
decl_stmt|;
name|struct
name|ib_flow_eth_filter
name|val
decl_stmt|;
name|struct
name|ib_flow_eth_filter
name|mask
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ib_flow_ib_filter
block|{
name|__be32
name|l3_type_qpn
decl_stmt|;
name|u8
name|dst_gid
index|[
literal|16
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ib_flow_spec_ib
block|{
name|enum
name|ib_flow_spec_type
name|type
decl_stmt|;
name|u16
name|size
decl_stmt|;
name|struct
name|ib_flow_ib_filter
name|val
decl_stmt|;
name|struct
name|ib_flow_ib_filter
name|mask
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ib_flow_ipv4_filter
block|{
name|__be32
name|src_ip
decl_stmt|;
name|__be32
name|dst_ip
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ib_flow_spec_ipv4
block|{
name|enum
name|ib_flow_spec_type
name|type
decl_stmt|;
name|u16
name|size
decl_stmt|;
name|struct
name|ib_flow_ipv4_filter
name|val
decl_stmt|;
name|struct
name|ib_flow_ipv4_filter
name|mask
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ib_flow_tcp_udp_filter
block|{
name|__be16
name|dst_port
decl_stmt|;
name|__be16
name|src_port
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ib_flow_spec_tcp_udp
block|{
name|enum
name|ib_flow_spec_type
name|type
decl_stmt|;
name|u16
name|size
decl_stmt|;
name|struct
name|ib_flow_tcp_udp_filter
name|val
decl_stmt|;
name|struct
name|ib_flow_tcp_udp_filter
name|mask
decl_stmt|;
block|}
struct|;
end_struct

begin_union
union|union
name|ib_flow_spec
block|{
struct|struct
block|{
name|enum
name|ib_flow_spec_type
name|type
decl_stmt|;
name|u16
name|size
decl_stmt|;
block|}
struct|;
name|struct
name|ib_flow_spec_ib
name|ib
decl_stmt|;
name|struct
name|ib_flow_spec_eth
name|eth
decl_stmt|;
name|struct
name|ib_flow_spec_ipv4
name|ipv4
decl_stmt|;
name|struct
name|ib_flow_spec_tcp_udp
name|tcp_udp
decl_stmt|;
block|}
union|;
end_union

begin_struct
struct|struct
name|ib_flow_attr
block|{
name|enum
name|ib_flow_attr_type
name|type
decl_stmt|;
name|u16
name|size
decl_stmt|;
name|u16
name|priority
decl_stmt|;
name|u8
name|num_of_specs
decl_stmt|;
name|u8
name|port
decl_stmt|;
name|u32
name|flags
decl_stmt|;
comment|/* Following are the optional layers according to user request 	 * struct ib_flow_spec_xxx 	 * struct ib_flow_spec_yyy 	 */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ib_flow
block|{
name|struct
name|ib_qp
modifier|*
name|qp
decl_stmt|;
name|struct
name|ib_uobject
modifier|*
name|uobject
decl_stmt|;
block|}
struct|;
end_struct

begin_struct_decl
struct_decl|struct
name|ib_mad
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|ib_grh
struct_decl|;
end_struct_decl

begin_enum
enum|enum
name|ib_process_mad_flags
block|{
name|IB_MAD_IGNORE_MKEY
init|=
literal|1
block|,
name|IB_MAD_IGNORE_BKEY
init|=
literal|2
block|,
name|IB_MAD_IGNORE_ALL
init|=
name|IB_MAD_IGNORE_MKEY
operator||
name|IB_MAD_IGNORE_BKEY
block|}
enum|;
end_enum

begin_enum
enum|enum
name|ib_mad_result
block|{
name|IB_MAD_RESULT_FAILURE
init|=
literal|0
block|,
comment|/* (!SUCCESS is the important flag) */
name|IB_MAD_RESULT_SUCCESS
init|=
literal|1
operator|<<
literal|0
block|,
comment|/* MAD was successfully processed   */
name|IB_MAD_RESULT_REPLY
init|=
literal|1
operator|<<
literal|1
block|,
comment|/* Reply packet needs to be sent    */
name|IB_MAD_RESULT_CONSUMED
init|=
literal|1
operator|<<
literal|2
comment|/* Packet consumed: stop processing */
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|IB_DEVICE_NAME_MAX
value|64
end_define

begin_struct
struct|struct
name|ib_cache
block|{
name|rwlock_t
name|lock
decl_stmt|;
name|struct
name|ib_event_handler
name|event_handler
decl_stmt|;
name|struct
name|ib_pkey_cache
modifier|*
modifier|*
name|pkey_cache
decl_stmt|;
name|struct
name|ib_gid_cache
modifier|*
modifier|*
name|gid_cache
decl_stmt|;
name|u8
modifier|*
name|lmc_cache
decl_stmt|;
block|}
struct|;
end_struct

begin_enum
enum|enum
name|verbs_values_mask
block|{
name|IBV_VALUES_HW_CLOCK
init|=
literal|1
operator|<<
literal|0
block|}
enum|;
end_enum

begin_struct
struct|struct
name|ib_device_values
block|{
name|int
name|values_mask
decl_stmt|;
name|uint64_t
name|hwclock
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ib_dma_mapping_ops
block|{
name|int
function_decl|(
modifier|*
name|mapping_error
function_decl|)
parameter_list|(
name|struct
name|ib_device
modifier|*
name|dev
parameter_list|,
name|u64
name|dma_addr
parameter_list|)
function_decl|;
name|u64
function_decl|(
modifier|*
name|map_single
function_decl|)
parameter_list|(
name|struct
name|ib_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|enum
name|dma_data_direction
name|direction
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|unmap_single
function_decl|)
parameter_list|(
name|struct
name|ib_device
modifier|*
name|dev
parameter_list|,
name|u64
name|addr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|enum
name|dma_data_direction
name|direction
parameter_list|)
function_decl|;
name|u64
function_decl|(
modifier|*
name|map_page
function_decl|)
parameter_list|(
name|struct
name|ib_device
modifier|*
name|dev
parameter_list|,
name|struct
name|page
modifier|*
name|page
parameter_list|,
name|unsigned
name|long
name|offset
parameter_list|,
name|size_t
name|size
parameter_list|,
name|enum
name|dma_data_direction
name|direction
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|unmap_page
function_decl|)
parameter_list|(
name|struct
name|ib_device
modifier|*
name|dev
parameter_list|,
name|u64
name|addr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|enum
name|dma_data_direction
name|direction
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|map_sg
function_decl|)
parameter_list|(
name|struct
name|ib_device
modifier|*
name|dev
parameter_list|,
name|struct
name|scatterlist
modifier|*
name|sg
parameter_list|,
name|int
name|nents
parameter_list|,
name|enum
name|dma_data_direction
name|direction
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|unmap_sg
function_decl|)
parameter_list|(
name|struct
name|ib_device
modifier|*
name|dev
parameter_list|,
name|struct
name|scatterlist
modifier|*
name|sg
parameter_list|,
name|int
name|nents
parameter_list|,
name|enum
name|dma_data_direction
name|direction
parameter_list|)
function_decl|;
name|u64
function_decl|(
modifier|*
name|dma_address
function_decl|)
parameter_list|(
name|struct
name|ib_device
modifier|*
name|dev
parameter_list|,
name|struct
name|scatterlist
modifier|*
name|sg
parameter_list|)
function_decl|;
name|unsigned
name|int
function_decl|(
modifier|*
name|dma_len
function_decl|)
parameter_list|(
name|struct
name|ib_device
modifier|*
name|dev
parameter_list|,
name|struct
name|scatterlist
modifier|*
name|sg
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|sync_single_for_cpu
function_decl|)
parameter_list|(
name|struct
name|ib_device
modifier|*
name|dev
parameter_list|,
name|u64
name|dma_handle
parameter_list|,
name|size_t
name|size
parameter_list|,
name|enum
name|dma_data_direction
name|dir
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|sync_single_for_device
function_decl|)
parameter_list|(
name|struct
name|ib_device
modifier|*
name|dev
parameter_list|,
name|u64
name|dma_handle
parameter_list|,
name|size_t
name|size
parameter_list|,
name|enum
name|dma_data_direction
name|dir
parameter_list|)
function_decl|;
name|void
modifier|*
function_decl|(
modifier|*
name|alloc_coherent
function_decl|)
parameter_list|(
name|struct
name|ib_device
modifier|*
name|dev
parameter_list|,
name|size_t
name|size
parameter_list|,
name|u64
modifier|*
name|dma_handle
parameter_list|,
name|gfp_t
name|flag
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|free_coherent
function_decl|)
parameter_list|(
name|struct
name|ib_device
modifier|*
name|dev
parameter_list|,
name|size_t
name|size
parameter_list|,
name|void
modifier|*
name|cpu_addr
parameter_list|,
name|u64
name|dma_handle
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_struct_decl
struct_decl|struct
name|iw_cm_verbs
struct_decl|;
end_struct_decl

begin_struct
struct|struct
name|ib_port_immutable
block|{
name|int
name|pkey_tbl_len
decl_stmt|;
name|int
name|gid_tbl_len
decl_stmt|;
name|u32
name|core_cap_flags
decl_stmt|;
name|u32
name|max_mad_size
decl_stmt|;
block|}
struct|;
end_struct

begin_struct_decl
struct_decl|struct
name|ib_exp_device_attr
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|ib_exp_qp_init_attr
struct_decl|;
end_struct_decl

begin_struct
struct|struct
name|ib_device
block|{
name|struct
name|device
modifier|*
name|dma_device
decl_stmt|;
name|char
name|name
index|[
name|IB_DEVICE_NAME_MAX
index|]
decl_stmt|;
name|struct
name|list_head
name|event_handler_list
decl_stmt|;
name|spinlock_t
name|event_handler_lock
decl_stmt|;
name|spinlock_t
name|client_data_lock
decl_stmt|;
name|struct
name|list_head
name|core_list
decl_stmt|;
name|struct
name|list_head
name|client_data_list
decl_stmt|;
name|struct
name|ib_cache
name|cache
decl_stmt|;
comment|/** 	 * port_immutable is indexed by port number 	 */
name|struct
name|ib_port_immutable
modifier|*
name|port_immutable
decl_stmt|;
name|int
name|num_comp_vectors
decl_stmt|;
name|struct
name|iw_cm_verbs
modifier|*
name|iwcm
decl_stmt|;
name|int
function_decl|(
modifier|*
name|get_protocol_stats
function_decl|)
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|union
name|rdma_protocol_stats
modifier|*
name|stats
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|query_device
function_decl|)
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|struct
name|ib_device_attr
modifier|*
name|device_attr
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|query_port
function_decl|)
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|u8
name|port_num
parameter_list|,
name|struct
name|ib_port_attr
modifier|*
name|port_attr
parameter_list|)
function_decl|;
name|enum
name|rdma_link_layer
function_decl|(
modifier|*
name|get_link_layer
function_decl|)
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|u8
name|port_num
parameter_list|)
function_decl|;
comment|/* When calling get_netdev, the HW vendor's driver should return the 	 * net device of device @device at port @port_num. The function 	 * is called in rtnl_lock. The HW vendor's device driver must guarantee 	 * to return NULL before the net device has reached 	 * NETDEV_UNREGISTER_FINAL state. 	 */
name|struct
name|net_device
modifier|*
function_decl|(
modifier|*
name|get_netdev
function_decl|)
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|u8
name|port_num
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|query_gid
function_decl|)
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|u8
name|port_num
parameter_list|,
name|int
name|index
parameter_list|,
name|union
name|ib_gid
modifier|*
name|gid
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|query_pkey
function_decl|)
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|u8
name|port_num
parameter_list|,
name|u16
name|index
parameter_list|,
name|u16
modifier|*
name|pkey
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|modify_device
function_decl|)
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|int
name|device_modify_mask
parameter_list|,
name|struct
name|ib_device_modify
modifier|*
name|device_modify
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|modify_port
function_decl|)
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|u8
name|port_num
parameter_list|,
name|int
name|port_modify_mask
parameter_list|,
name|struct
name|ib_port_modify
modifier|*
name|port_modify
parameter_list|)
function_decl|;
name|struct
name|ib_ucontext
modifier|*
function_decl|(
modifier|*
name|alloc_ucontext
function_decl|)
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|struct
name|ib_udata
modifier|*
name|udata
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|dealloc_ucontext
function_decl|)
parameter_list|(
name|struct
name|ib_ucontext
modifier|*
name|context
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|mmap
function_decl|)
parameter_list|(
name|struct
name|ib_ucontext
modifier|*
name|context
parameter_list|,
name|struct
name|vm_area_struct
modifier|*
name|vma
parameter_list|)
function_decl|;
name|struct
name|ib_pd
modifier|*
function_decl|(
modifier|*
name|alloc_pd
function_decl|)
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|struct
name|ib_ucontext
modifier|*
name|context
parameter_list|,
name|struct
name|ib_udata
modifier|*
name|udata
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|dealloc_pd
function_decl|)
parameter_list|(
name|struct
name|ib_pd
modifier|*
name|pd
parameter_list|)
function_decl|;
name|struct
name|ib_ah
modifier|*
function_decl|(
modifier|*
name|create_ah
function_decl|)
parameter_list|(
name|struct
name|ib_pd
modifier|*
name|pd
parameter_list|,
name|struct
name|ib_ah_attr
modifier|*
name|ah_attr
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|modify_ah
function_decl|)
parameter_list|(
name|struct
name|ib_ah
modifier|*
name|ah
parameter_list|,
name|struct
name|ib_ah_attr
modifier|*
name|ah_attr
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|query_ah
function_decl|)
parameter_list|(
name|struct
name|ib_ah
modifier|*
name|ah
parameter_list|,
name|struct
name|ib_ah_attr
modifier|*
name|ah_attr
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|destroy_ah
function_decl|)
parameter_list|(
name|struct
name|ib_ah
modifier|*
name|ah
parameter_list|)
function_decl|;
name|struct
name|ib_srq
modifier|*
function_decl|(
modifier|*
name|create_srq
function_decl|)
parameter_list|(
name|struct
name|ib_pd
modifier|*
name|pd
parameter_list|,
name|struct
name|ib_srq_init_attr
modifier|*
name|srq_init_attr
parameter_list|,
name|struct
name|ib_udata
modifier|*
name|udata
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|modify_srq
function_decl|)
parameter_list|(
name|struct
name|ib_srq
modifier|*
name|srq
parameter_list|,
name|struct
name|ib_srq_attr
modifier|*
name|srq_attr
parameter_list|,
name|enum
name|ib_srq_attr_mask
name|srq_attr_mask
parameter_list|,
name|struct
name|ib_udata
modifier|*
name|udata
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|query_srq
function_decl|)
parameter_list|(
name|struct
name|ib_srq
modifier|*
name|srq
parameter_list|,
name|struct
name|ib_srq_attr
modifier|*
name|srq_attr
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|destroy_srq
function_decl|)
parameter_list|(
name|struct
name|ib_srq
modifier|*
name|srq
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|post_srq_recv
function_decl|)
parameter_list|(
name|struct
name|ib_srq
modifier|*
name|srq
parameter_list|,
name|struct
name|ib_recv_wr
modifier|*
name|recv_wr
parameter_list|,
name|struct
name|ib_recv_wr
modifier|*
modifier|*
name|bad_recv_wr
parameter_list|)
function_decl|;
name|struct
name|ib_qp
modifier|*
function_decl|(
modifier|*
name|create_qp
function_decl|)
parameter_list|(
name|struct
name|ib_pd
modifier|*
name|pd
parameter_list|,
name|struct
name|ib_qp_init_attr
modifier|*
name|qp_init_attr
parameter_list|,
name|struct
name|ib_udata
modifier|*
name|udata
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|modify_qp
function_decl|)
parameter_list|(
name|struct
name|ib_qp
modifier|*
name|qp
parameter_list|,
name|struct
name|ib_qp_attr
modifier|*
name|qp_attr
parameter_list|,
name|int
name|qp_attr_mask
parameter_list|,
name|struct
name|ib_udata
modifier|*
name|udata
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|query_qp
function_decl|)
parameter_list|(
name|struct
name|ib_qp
modifier|*
name|qp
parameter_list|,
name|struct
name|ib_qp_attr
modifier|*
name|qp_attr
parameter_list|,
name|int
name|qp_attr_mask
parameter_list|,
name|struct
name|ib_qp_init_attr
modifier|*
name|qp_init_attr
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|destroy_qp
function_decl|)
parameter_list|(
name|struct
name|ib_qp
modifier|*
name|qp
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|post_send
function_decl|)
parameter_list|(
name|struct
name|ib_qp
modifier|*
name|qp
parameter_list|,
name|struct
name|ib_send_wr
modifier|*
name|send_wr
parameter_list|,
name|struct
name|ib_send_wr
modifier|*
modifier|*
name|bad_send_wr
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|post_recv
function_decl|)
parameter_list|(
name|struct
name|ib_qp
modifier|*
name|qp
parameter_list|,
name|struct
name|ib_recv_wr
modifier|*
name|recv_wr
parameter_list|,
name|struct
name|ib_recv_wr
modifier|*
modifier|*
name|bad_recv_wr
parameter_list|)
function_decl|;
name|struct
name|ib_cq
modifier|*
function_decl|(
modifier|*
name|create_cq
function_decl|)
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|struct
name|ib_cq_init_attr
modifier|*
name|attr
parameter_list|,
name|struct
name|ib_ucontext
modifier|*
name|context
parameter_list|,
name|struct
name|ib_udata
modifier|*
name|udata
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|modify_cq
function_decl|)
parameter_list|(
name|struct
name|ib_cq
modifier|*
name|cq
parameter_list|,
name|struct
name|ib_cq_attr
modifier|*
name|cq_attr
parameter_list|,
name|int
name|cq_attr_mask
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|destroy_cq
function_decl|)
parameter_list|(
name|struct
name|ib_cq
modifier|*
name|cq
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|resize_cq
function_decl|)
parameter_list|(
name|struct
name|ib_cq
modifier|*
name|cq
parameter_list|,
name|int
name|cqe
parameter_list|,
name|struct
name|ib_udata
modifier|*
name|udata
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|poll_cq
function_decl|)
parameter_list|(
name|struct
name|ib_cq
modifier|*
name|cq
parameter_list|,
name|int
name|num_entries
parameter_list|,
name|struct
name|ib_wc
modifier|*
name|wc
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|peek_cq
function_decl|)
parameter_list|(
name|struct
name|ib_cq
modifier|*
name|cq
parameter_list|,
name|int
name|wc_cnt
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|req_notify_cq
function_decl|)
parameter_list|(
name|struct
name|ib_cq
modifier|*
name|cq
parameter_list|,
name|enum
name|ib_cq_notify_flags
name|flags
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|req_ncomp_notif
function_decl|)
parameter_list|(
name|struct
name|ib_cq
modifier|*
name|cq
parameter_list|,
name|int
name|wc_cnt
parameter_list|)
function_decl|;
name|struct
name|ib_mr
modifier|*
function_decl|(
modifier|*
name|get_dma_mr
function_decl|)
parameter_list|(
name|struct
name|ib_pd
modifier|*
name|pd
parameter_list|,
name|int
name|mr_access_flags
parameter_list|)
function_decl|;
name|struct
name|ib_mr
modifier|*
function_decl|(
modifier|*
name|reg_phys_mr
function_decl|)
parameter_list|(
name|struct
name|ib_pd
modifier|*
name|pd
parameter_list|,
name|struct
name|ib_phys_buf
modifier|*
name|phys_buf_array
parameter_list|,
name|int
name|num_phys_buf
parameter_list|,
name|int
name|mr_access_flags
parameter_list|,
name|u64
modifier|*
name|iova_start
parameter_list|)
function_decl|;
name|struct
name|ib_mr
modifier|*
function_decl|(
modifier|*
name|reg_user_mr
function_decl|)
parameter_list|(
name|struct
name|ib_pd
modifier|*
name|pd
parameter_list|,
name|u64
name|start
parameter_list|,
name|u64
name|length
parameter_list|,
name|u64
name|virt_addr
parameter_list|,
name|int
name|mr_access_flags
parameter_list|,
name|struct
name|ib_udata
modifier|*
name|udata
parameter_list|,
name|int
name|mr_id
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|query_mr
function_decl|)
parameter_list|(
name|struct
name|ib_mr
modifier|*
name|mr
parameter_list|,
name|struct
name|ib_mr_attr
modifier|*
name|mr_attr
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|dereg_mr
function_decl|)
parameter_list|(
name|struct
name|ib_mr
modifier|*
name|mr
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|destroy_mr
function_decl|)
parameter_list|(
name|struct
name|ib_mr
modifier|*
name|mr
parameter_list|)
function_decl|;
name|struct
name|ib_mr
modifier|*
function_decl|(
modifier|*
name|create_mr
function_decl|)
parameter_list|(
name|struct
name|ib_pd
modifier|*
name|pd
parameter_list|,
name|struct
name|ib_mr_init_attr
modifier|*
name|mr_init_attr
parameter_list|)
function_decl|;
name|struct
name|ib_mr
modifier|*
function_decl|(
modifier|*
name|alloc_fast_reg_mr
function_decl|)
parameter_list|(
name|struct
name|ib_pd
modifier|*
name|pd
parameter_list|,
name|int
name|max_page_list_len
parameter_list|)
function_decl|;
name|struct
name|ib_fast_reg_page_list
modifier|*
function_decl|(
modifier|*
name|alloc_fast_reg_page_list
function_decl|)
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|int
name|page_list_len
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|free_fast_reg_page_list
function_decl|)
parameter_list|(
name|struct
name|ib_fast_reg_page_list
modifier|*
name|page_list
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|rereg_phys_mr
function_decl|)
parameter_list|(
name|struct
name|ib_mr
modifier|*
name|mr
parameter_list|,
name|int
name|mr_rereg_mask
parameter_list|,
name|struct
name|ib_pd
modifier|*
name|pd
parameter_list|,
name|struct
name|ib_phys_buf
modifier|*
name|phys_buf_array
parameter_list|,
name|int
name|num_phys_buf
parameter_list|,
name|int
name|mr_access_flags
parameter_list|,
name|u64
modifier|*
name|iova_start
parameter_list|)
function_decl|;
name|struct
name|ib_mw
modifier|*
function_decl|(
modifier|*
name|alloc_mw
function_decl|)
parameter_list|(
name|struct
name|ib_pd
modifier|*
name|pd
parameter_list|,
name|enum
name|ib_mw_type
name|type
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|bind_mw
function_decl|)
parameter_list|(
name|struct
name|ib_qp
modifier|*
name|qp
parameter_list|,
name|struct
name|ib_mw
modifier|*
name|mw
parameter_list|,
name|struct
name|ib_mw_bind
modifier|*
name|mw_bind
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|dealloc_mw
function_decl|)
parameter_list|(
name|struct
name|ib_mw
modifier|*
name|mw
parameter_list|)
function_decl|;
name|struct
name|ib_fmr
modifier|*
function_decl|(
modifier|*
name|alloc_fmr
function_decl|)
parameter_list|(
name|struct
name|ib_pd
modifier|*
name|pd
parameter_list|,
name|int
name|mr_access_flags
parameter_list|,
name|struct
name|ib_fmr_attr
modifier|*
name|fmr_attr
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|map_phys_fmr
function_decl|)
parameter_list|(
name|struct
name|ib_fmr
modifier|*
name|fmr
parameter_list|,
name|u64
modifier|*
name|page_list
parameter_list|,
name|int
name|list_len
parameter_list|,
name|u64
name|iova
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|unmap_fmr
function_decl|)
parameter_list|(
name|struct
name|list_head
modifier|*
name|fmr_list
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|dealloc_fmr
function_decl|)
parameter_list|(
name|struct
name|ib_fmr
modifier|*
name|fmr
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|attach_mcast
function_decl|)
parameter_list|(
name|struct
name|ib_qp
modifier|*
name|qp
parameter_list|,
name|union
name|ib_gid
modifier|*
name|gid
parameter_list|,
name|u16
name|lid
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|detach_mcast
function_decl|)
parameter_list|(
name|struct
name|ib_qp
modifier|*
name|qp
parameter_list|,
name|union
name|ib_gid
modifier|*
name|gid
parameter_list|,
name|u16
name|lid
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|process_mad
function_decl|)
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|int
name|process_mad_flags
parameter_list|,
name|u8
name|port_num
parameter_list|,
name|struct
name|ib_wc
modifier|*
name|in_wc
parameter_list|,
name|struct
name|ib_grh
modifier|*
name|in_grh
parameter_list|,
name|struct
name|ib_mad
modifier|*
name|in_mad
parameter_list|,
name|struct
name|ib_mad
modifier|*
name|out_mad
parameter_list|)
function_decl|;
name|struct
name|ib_xrcd
modifier|*
function_decl|(
modifier|*
name|alloc_xrcd
function_decl|)
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|struct
name|ib_ucontext
modifier|*
name|ucontext
parameter_list|,
name|struct
name|ib_udata
modifier|*
name|udata
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|dealloc_xrcd
function_decl|)
parameter_list|(
name|struct
name|ib_xrcd
modifier|*
name|xrcd
parameter_list|)
function_decl|;
name|struct
name|ib_flow
modifier|*
function_decl|(
modifier|*
name|create_flow
function_decl|)
parameter_list|(
name|struct
name|ib_qp
modifier|*
name|qp
parameter_list|,
name|struct
name|ib_flow_attr
modifier|*
name|flow_attr
parameter_list|,
name|int
name|domain
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|destroy_flow
function_decl|)
parameter_list|(
name|struct
name|ib_flow
modifier|*
name|flow_id
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|check_mr_status
function_decl|)
parameter_list|(
name|struct
name|ib_mr
modifier|*
name|mr
parameter_list|,
name|u32
name|check_mask
parameter_list|,
name|struct
name|ib_mr_status
modifier|*
name|mr_status
parameter_list|)
function_decl|;
name|unsigned
name|long
function_decl|(
modifier|*
name|get_unmapped_area
function_decl|)
parameter_list|(
name|struct
name|file
modifier|*
name|file
parameter_list|,
name|unsigned
name|long
name|addr
parameter_list|,
name|unsigned
name|long
name|len
parameter_list|,
name|unsigned
name|long
name|pgoff
parameter_list|,
name|unsigned
name|long
name|flags
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|ioctl
function_decl|)
parameter_list|(
name|struct
name|ib_ucontext
modifier|*
name|context
parameter_list|,
name|unsigned
name|int
name|cmd
parameter_list|,
name|unsigned
name|long
name|arg
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|query_values
function_decl|)
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|int
name|q_values
parameter_list|,
name|struct
name|ib_device_values
modifier|*
name|values
parameter_list|)
function_decl|;
name|struct
name|ib_dma_mapping_ops
modifier|*
name|dma_ops
decl_stmt|;
name|struct
name|module
modifier|*
name|owner
decl_stmt|;
name|struct
name|device
name|dev
decl_stmt|;
name|struct
name|kobject
modifier|*
name|ports_parent
decl_stmt|;
name|struct
name|list_head
name|port_list
decl_stmt|;
enum|enum
block|{
name|IB_DEV_UNINITIALIZED
block|,
name|IB_DEV_REGISTERED
block|,
name|IB_DEV_UNREGISTERED
block|}
name|reg_state
enum|;
name|int
name|uverbs_abi_ver
decl_stmt|;
name|u64
name|uverbs_cmd_mask
decl_stmt|;
name|u64
name|uverbs_ex_cmd_mask
decl_stmt|;
name|char
name|node_desc
index|[
literal|64
index|]
decl_stmt|;
name|__be64
name|node_guid
decl_stmt|;
name|u32
name|local_dma_lkey
decl_stmt|;
name|u8
name|node_type
decl_stmt|;
name|u8
name|phys_port_cnt
decl_stmt|;
name|int
name|cmd_perf
decl_stmt|;
name|u64
name|cmd_avg
decl_stmt|;
name|u32
name|cmd_n
decl_stmt|;
name|spinlock_t
name|cmd_perf_lock
decl_stmt|;
comment|/** 	 * The following mandatory functions are used only at device 	 * registration.  Keep functions such as these at the end of this 	 * structure to avoid cache line misses when accessing struct ib_device 	 * in fast paths. 	 */
name|int
function_decl|(
modifier|*
name|get_port_immutable
function_decl|)
parameter_list|(
name|struct
name|ib_device
modifier|*
parameter_list|,
name|u8
parameter_list|,
name|struct
name|ib_port_immutable
modifier|*
parameter_list|)
function_decl|;
comment|/* 	 * Experimental data and functions 	 */
name|int
function_decl|(
modifier|*
name|exp_query_device
function_decl|)
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|struct
name|ib_exp_device_attr
modifier|*
name|device_attr
parameter_list|)
function_decl|;
name|struct
name|ib_qp
modifier|*
function_decl|(
modifier|*
name|exp_create_qp
function_decl|)
parameter_list|(
name|struct
name|ib_pd
modifier|*
name|pd
parameter_list|,
name|struct
name|ib_exp_qp_init_attr
modifier|*
name|qp_init_attr
parameter_list|,
name|struct
name|ib_udata
modifier|*
name|udata
parameter_list|)
function_decl|;
name|struct
name|ib_dct
modifier|*
function_decl|(
modifier|*
name|exp_create_dct
function_decl|)
parameter_list|(
name|struct
name|ib_pd
modifier|*
name|pd
parameter_list|,
name|struct
name|ib_dct_init_attr
modifier|*
name|attr
parameter_list|,
name|struct
name|ib_udata
modifier|*
name|udata
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|exp_destroy_dct
function_decl|)
parameter_list|(
name|struct
name|ib_dct
modifier|*
name|dct
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|exp_query_dct
function_decl|)
parameter_list|(
name|struct
name|ib_dct
modifier|*
name|dct
parameter_list|,
name|struct
name|ib_dct_attr
modifier|*
name|attr
parameter_list|)
function_decl|;
name|u64
name|uverbs_exp_cmd_mask
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ib_client
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|void
function_decl|(
modifier|*
name|add
function_decl|)
parameter_list|(
name|struct
name|ib_device
modifier|*
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|remove
function_decl|)
parameter_list|(
name|struct
name|ib_device
modifier|*
parameter_list|)
function_decl|;
name|struct
name|list_head
name|list
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
name|struct
name|ib_device
modifier|*
name|ib_alloc_device
parameter_list|(
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ib_dealloc_device
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ib_register_device
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|int
function_decl|(
modifier|*
name|port_callback
function_decl|)
parameter_list|(
name|struct
name|ib_device
modifier|*
parameter_list|,
name|u8
parameter_list|,
name|struct
name|kobject
modifier|*
parameter_list|)
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ib_unregister_device
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ib_register_client
parameter_list|(
name|struct
name|ib_client
modifier|*
name|client
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ib_unregister_client
parameter_list|(
name|struct
name|ib_client
modifier|*
name|client
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
modifier|*
name|ib_get_client_data
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|struct
name|ib_client
modifier|*
name|client
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ib_set_client_data
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|struct
name|ib_client
modifier|*
name|client
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
specifier|inline
name|int
name|ib_copy_from_udata
parameter_list|(
name|void
modifier|*
name|dest
parameter_list|,
name|struct
name|ib_udata
modifier|*
name|udata
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
return|return
name|udata
operator|->
name|ops
operator|->
name|copy_from
argument_list|(
name|dest
argument_list|,
name|udata
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|ib_copy_to_udata
parameter_list|(
name|struct
name|ib_udata
modifier|*
name|udata
parameter_list|,
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
return|return
name|udata
operator|->
name|ops
operator|->
name|copy_to
argument_list|(
name|udata
argument_list|,
name|src
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * ib_modify_qp_is_ok - Check that the supplied attribute mask  * contains all required attributes and no attributes not allowed for  * the given QP state transition.  * @cur_state: Current QP state  * @next_state: Next QP state  * @type: QP type  * @mask: Mask of supplied QP attributes  * @ll : link layer of port  *  * This function is a helper function that a low-level driver's  * modify_qp method can use to validate the consumer's input.  It  * checks that cur_state and next_state are valid QP states, that a  * transition from cur_state to next_state is allowed by the IB spec,  * and that the attribute mask supplied is allowed for the transition.  */
end_comment

begin_function_decl
name|int
name|ib_modify_qp_is_ok
parameter_list|(
name|enum
name|ib_qp_state
name|cur_state
parameter_list|,
name|enum
name|ib_qp_state
name|next_state
parameter_list|,
name|enum
name|ib_qp_type
name|type
parameter_list|,
name|enum
name|ib_qp_attr_mask
name|mask
parameter_list|,
name|enum
name|rdma_link_layer
name|ll
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ib_register_event_handler
parameter_list|(
name|struct
name|ib_event_handler
modifier|*
name|event_handler
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ib_unregister_event_handler
parameter_list|(
name|struct
name|ib_event_handler
modifier|*
name|event_handler
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ib_dispatch_event
parameter_list|(
name|struct
name|ib_event
modifier|*
name|event
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ib_query_device
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|struct
name|ib_device_attr
modifier|*
name|device_attr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ib_query_port
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|u8
name|port_num
parameter_list|,
name|struct
name|ib_port_attr
modifier|*
name|port_attr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|enum
name|rdma_link_layer
name|rdma_port_get_link_layer
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|u8
name|port_num
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
specifier|inline
name|bool
name|rdma_protocol_ib
parameter_list|(
specifier|const
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|u8
name|port_num
parameter_list|)
block|{
return|return
name|device
operator|->
name|port_immutable
index|[
name|port_num
index|]
operator|.
name|core_cap_flags
operator|&
name|RDMA_CORE_CAP_PROT_IB
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|bool
name|rdma_protocol_roce
parameter_list|(
specifier|const
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|u8
name|port_num
parameter_list|)
block|{
return|return
name|device
operator|->
name|port_immutable
index|[
name|port_num
index|]
operator|.
name|core_cap_flags
operator|&
operator|(
name|RDMA_CORE_CAP_PROT_ROCE
operator||
name|RDMA_CORE_CAP_PROT_ROCE_UDP_ENCAP
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|bool
name|rdma_protocol_roce_udp_encap
parameter_list|(
specifier|const
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|u8
name|port_num
parameter_list|)
block|{
return|return
name|device
operator|->
name|port_immutable
index|[
name|port_num
index|]
operator|.
name|core_cap_flags
operator|&
name|RDMA_CORE_CAP_PROT_ROCE_UDP_ENCAP
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|bool
name|rdma_protocol_roce_eth_encap
parameter_list|(
specifier|const
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|u8
name|port_num
parameter_list|)
block|{
return|return
name|device
operator|->
name|port_immutable
index|[
name|port_num
index|]
operator|.
name|core_cap_flags
operator|&
name|RDMA_CORE_CAP_PROT_ROCE
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|bool
name|rdma_protocol_iwarp
parameter_list|(
specifier|const
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|u8
name|port_num
parameter_list|)
block|{
return|return
name|device
operator|->
name|port_immutable
index|[
name|port_num
index|]
operator|.
name|core_cap_flags
operator|&
name|RDMA_CORE_CAP_PROT_IWARP
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|bool
name|rdma_ib_or_roce
parameter_list|(
specifier|const
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|u8
name|port_num
parameter_list|)
block|{
return|return
name|rdma_protocol_ib
argument_list|(
name|device
argument_list|,
name|port_num
argument_list|)
operator|||
name|rdma_protocol_roce
argument_list|(
name|device
argument_list|,
name|port_num
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * rdma_cap_ib_mad - Check if the port of a device supports Infiniband  * Management Datagrams.  * @device: Device to check  * @port_num: Port number to check  *  * Management Datagrams (MAD) are a required part of the InfiniBand  * specification and are supported on all InfiniBand devices.  A slightly  * extended version are also supported on OPA interfaces.  *  * Return: true if the port supports sending/receiving of MAD packets.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|rdma_cap_ib_mad
parameter_list|(
specifier|const
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|u8
name|port_num
parameter_list|)
block|{
return|return
name|device
operator|->
name|port_immutable
index|[
name|port_num
index|]
operator|.
name|core_cap_flags
operator|&
name|RDMA_CORE_CAP_IB_MAD
return|;
block|}
end_function

begin_comment
comment|/**  * rdma_cap_opa_mad - Check if the port of device provides support for OPA  * Management Datagrams.  * @device: Device to check  * @port_num: Port number to check  *  * Intel OmniPath devices extend and/or replace the InfiniBand Management  * datagrams with their own versions.  These OPA MADs share many but not all of  * the characteristics of InfiniBand MADs.  *  * OPA MADs differ in the following ways:  *  *    1) MADs are variable size up to 2K  *       IBTA defined MADs remain fixed at 256 bytes  *    2) OPA SMPs must carry valid PKeys  *    3) OPA SMP packets are a different format  *  * Return: true if the port supports OPA MAD packet formats.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|rdma_cap_opa_mad
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|u8
name|port_num
parameter_list|)
block|{
return|return
operator|(
name|device
operator|->
name|port_immutable
index|[
name|port_num
index|]
operator|.
name|core_cap_flags
operator|&
name|RDMA_CORE_CAP_OPA_MAD
operator|)
operator|==
name|RDMA_CORE_CAP_OPA_MAD
return|;
block|}
end_function

begin_comment
comment|/**  * rdma_cap_ib_smi - Check if the port of a device provides an Infiniband  * Subnet Management Agent (SMA) on the Subnet Management Interface (SMI).  * @device: Device to check  * @port_num: Port number to check  *  * Each InfiniBand node is required to provide a Subnet Management Agent  * that the subnet manager can access.  Prior to the fabric being fully  * configured by the subnet manager, the SMA is accessed via a well known  * interface called the Subnet Management Interface (SMI).  This interface  * uses directed route packets to communicate with the SM to get around the  * chicken and egg problem of the SM needing to know what's on the fabric  * in order to configure the fabric, and needing to configure the fabric in  * order to send packets to the devices on the fabric.  These directed  * route packets do not need the fabric fully configured in order to reach  * their destination.  The SMI is the only method allowed to send  * directed route packets on an InfiniBand fabric.  *  * Return: true if the port provides an SMI.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|rdma_cap_ib_smi
parameter_list|(
specifier|const
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|u8
name|port_num
parameter_list|)
block|{
return|return
name|device
operator|->
name|port_immutable
index|[
name|port_num
index|]
operator|.
name|core_cap_flags
operator|&
name|RDMA_CORE_CAP_IB_SMI
return|;
block|}
end_function

begin_comment
comment|/**  * rdma_cap_ib_cm - Check if the port of device has the capability Infiniband  * Communication Manager.  * @device: Device to check  * @port_num: Port number to check  *  * The InfiniBand Communication Manager is one of many pre-defined General  * Service Agents (GSA) that are accessed via the General Service  * Interface (GSI).  It's role is to facilitate establishment of connections  * between nodes as well as other management related tasks for established  * connections.  *  * Return: true if the port supports an IB CM (this does not guarantee that  * a CM is actually running however).  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|rdma_cap_ib_cm
parameter_list|(
specifier|const
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|u8
name|port_num
parameter_list|)
block|{
return|return
name|device
operator|->
name|port_immutable
index|[
name|port_num
index|]
operator|.
name|core_cap_flags
operator|&
name|RDMA_CORE_CAP_IB_CM
return|;
block|}
end_function

begin_comment
comment|/**  * rdma_cap_iw_cm - Check if the port of device has the capability IWARP  * Communication Manager.  * @device: Device to check  * @port_num: Port number to check  *  * Similar to above, but specific to iWARP connections which have a different  * managment protocol than InfiniBand.  *  * Return: true if the port supports an iWARP CM (this does not guarantee that  * a CM is actually running however).  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|rdma_cap_iw_cm
parameter_list|(
specifier|const
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|u8
name|port_num
parameter_list|)
block|{
return|return
name|device
operator|->
name|port_immutable
index|[
name|port_num
index|]
operator|.
name|core_cap_flags
operator|&
name|RDMA_CORE_CAP_IW_CM
return|;
block|}
end_function

begin_comment
comment|/**  * rdma_cap_ib_sa - Check if the port of device has the capability Infiniband  * Subnet Administration.  * @device: Device to check  * @port_num: Port number to check  *  * An InfiniBand Subnet Administration (SA) service is a pre-defined General  * Service Agent (GSA) provided by the Subnet Manager (SM).  On InfiniBand  * fabrics, devices should resolve routes to other hosts by contacting the  * SA to query the proper route.  *  * Return: true if the port should act as a client to the fabric Subnet  * Administration interface.  This does not imply that the SA service is  * running locally.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|rdma_cap_ib_sa
parameter_list|(
specifier|const
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|u8
name|port_num
parameter_list|)
block|{
return|return
name|device
operator|->
name|port_immutable
index|[
name|port_num
index|]
operator|.
name|core_cap_flags
operator|&
name|RDMA_CORE_CAP_IB_SA
return|;
block|}
end_function

begin_comment
comment|/**  * rdma_cap_ib_mcast - Check if the port of device has the capability Infiniband  * Multicast.  * @device: Device to check  * @port_num: Port number to check  *  * InfiniBand multicast registration is more complex than normal IPv4 or  * IPv6 multicast registration.  Each Host Channel Adapter must register  * with the Subnet Manager when it wishes to join a multicast group.  It  * should do so only once regardless of how many queue pairs it subscribes  * to this group.  And it should leave the group only after all queue pairs  * attached to the group have been detached.  *  * Return: true if the port must undertake the additional adminstrative  * overhead of registering/unregistering with the SM and tracking of the  * total number of queue pairs attached to the multicast group.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|rdma_cap_ib_mcast
parameter_list|(
specifier|const
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|u8
name|port_num
parameter_list|)
block|{
return|return
name|rdma_cap_ib_sa
argument_list|(
name|device
argument_list|,
name|port_num
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * rdma_cap_af_ib - Check if the port of device has the capability  * Native Infiniband Address.  * @device: Device to check  * @port_num: Port number to check  *  * InfiniBand addressing uses a port's GUID + Subnet Prefix to make a default  * GID.  RoCE uses a different mechanism, but still generates a GID via  * a prescribed mechanism and port specific data.  *  * Return: true if the port uses a GID address to identify devices on the  * network.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|rdma_cap_af_ib
parameter_list|(
specifier|const
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|u8
name|port_num
parameter_list|)
block|{
return|return
name|device
operator|->
name|port_immutable
index|[
name|port_num
index|]
operator|.
name|core_cap_flags
operator|&
name|RDMA_CORE_CAP_AF_IB
return|;
block|}
end_function

begin_comment
comment|/**  * rdma_cap_eth_ah - Check if the port of device has the capability  * Ethernet Address Handle.  * @device: Device to check  * @port_num: Port number to check  *  * RoCE is InfiniBand over Ethernet, and it uses a well defined technique  * to fabricate GIDs over Ethernet/IP specific addresses native to the  * port.  Normally, packet headers are generated by the sending host  * adapter, but when sending connectionless datagrams, we must manually  * inject the proper headers for the fabric we are communicating over.  *  * Return: true if we are running as a RoCE port and must force the  * addition of a Global Route Header built from our Ethernet Address  * Handle into our header list for connectionless packets.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|rdma_cap_eth_ah
parameter_list|(
specifier|const
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|u8
name|port_num
parameter_list|)
block|{
return|return
name|device
operator|->
name|port_immutable
index|[
name|port_num
index|]
operator|.
name|core_cap_flags
operator|&
name|RDMA_CORE_CAP_ETH_AH
return|;
block|}
end_function

begin_comment
comment|/**  * rdma_max_mad_size - Return the max MAD size required by this RDMA Port.  *  * @device: Device  * @port_num: Port number  *  * This MAD size includes the MAD headers and MAD payload.  No other headers  * are included.  *  * Return the max MAD size required by the Port.  Will return 0 if the port  * does not support MADs  */
end_comment

begin_function
specifier|static
specifier|inline
name|size_t
name|rdma_max_mad_size
parameter_list|(
specifier|const
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|u8
name|port_num
parameter_list|)
block|{
return|return
name|device
operator|->
name|port_immutable
index|[
name|port_num
index|]
operator|.
name|max_mad_size
return|;
block|}
end_function

begin_comment
comment|/*  * Check if the device supports READ W/ INVALIDATE.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|rdma_cap_read_inv
parameter_list|(
name|struct
name|ib_device
modifier|*
name|dev
parameter_list|,
name|u32
name|port_num
parameter_list|)
block|{
comment|/* 	 * iWarp drivers must support READ W/ INVALIDATE.  No other protocol 	 * has support for it yet. 	 */
return|return
name|rdma_protocol_iwarp
argument_list|(
name|dev
argument_list|,
name|port_num
argument_list|)
return|;
block|}
end_function

begin_function_decl
name|int
name|ib_query_gid
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|u8
name|port_num
parameter_list|,
name|int
name|index
parameter_list|,
name|union
name|ib_gid
modifier|*
name|gid
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ib_query_pkey
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|u8
name|port_num
parameter_list|,
name|u16
name|index
parameter_list|,
name|u16
modifier|*
name|pkey
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ib_modify_device
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|int
name|device_modify_mask
parameter_list|,
name|struct
name|ib_device_modify
modifier|*
name|device_modify
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ib_modify_port
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|u8
name|port_num
parameter_list|,
name|int
name|port_modify_mask
parameter_list|,
name|struct
name|ib_port_modify
modifier|*
name|port_modify
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ib_find_gid
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|union
name|ib_gid
modifier|*
name|gid
parameter_list|,
name|u8
modifier|*
name|port_num
parameter_list|,
name|u16
modifier|*
name|index
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ib_find_pkey
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|u8
name|port_num
parameter_list|,
name|u16
name|pkey
parameter_list|,
name|u16
modifier|*
name|index
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * ib_alloc_pd - Allocates an unused protection domain.  * @device: The device on which to allocate the protection domain.  *  * A protection domain object provides an association between QPs, shared  * receive queues, address handles, memory regions, and memory windows.  */
end_comment

begin_function_decl
name|struct
name|ib_pd
modifier|*
name|ib_alloc_pd
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * ib_dealloc_pd - Deallocates a protection domain.  * @pd: The protection domain to deallocate.  */
end_comment

begin_function_decl
name|int
name|ib_dealloc_pd
parameter_list|(
name|struct
name|ib_pd
modifier|*
name|pd
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * ib_create_ah - Creates an address handle for the given address vector.  * @pd: The protection domain associated with the address handle.  * @ah_attr: The attributes of the address vector.  *  * The address handle is used to reference a local or global destination  * in all UD QP post sends.  */
end_comment

begin_function_decl
name|struct
name|ib_ah
modifier|*
name|ib_create_ah
parameter_list|(
name|struct
name|ib_pd
modifier|*
name|pd
parameter_list|,
name|struct
name|ib_ah_attr
modifier|*
name|ah_attr
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * ib_init_ah_from_wc - Initializes address handle attributes from a  *   work completion.  * @device: Device on which the received message arrived.  * @port_num: Port on which the received message arrived.  * @wc: Work completion associated with the received message.  * @grh: References the received global route header.  This parameter is  *   ignored unless the work completion indicates that the GRH is valid.  * @ah_attr: Returned attributes that can be used when creating an address  *   handle for replying to the message.  */
end_comment

begin_function_decl
name|int
name|ib_init_ah_from_wc
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|u8
name|port_num
parameter_list|,
name|struct
name|ib_wc
modifier|*
name|wc
parameter_list|,
name|struct
name|ib_grh
modifier|*
name|grh
parameter_list|,
name|struct
name|ib_ah_attr
modifier|*
name|ah_attr
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * ib_create_ah_from_wc - Creates an address handle associated with the  *   sender of the specified work completion.  * @pd: The protection domain associated with the address handle.  * @wc: Work completion information associated with a received message.  * @grh: References the received global route header.  This parameter is  *   ignored unless the work completion indicates that the GRH is valid.  * @port_num: The outbound port number to associate with the address.  *  * The address handle is used to reference a local or global destination  * in all UD QP post sends.  */
end_comment

begin_function_decl
name|struct
name|ib_ah
modifier|*
name|ib_create_ah_from_wc
parameter_list|(
name|struct
name|ib_pd
modifier|*
name|pd
parameter_list|,
name|struct
name|ib_wc
modifier|*
name|wc
parameter_list|,
name|struct
name|ib_grh
modifier|*
name|grh
parameter_list|,
name|u8
name|port_num
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * ib_modify_ah - Modifies the address vector associated with an address  *   handle.  * @ah: The address handle to modify.  * @ah_attr: The new address vector attributes to associate with the  *   address handle.  */
end_comment

begin_function_decl
name|int
name|ib_modify_ah
parameter_list|(
name|struct
name|ib_ah
modifier|*
name|ah
parameter_list|,
name|struct
name|ib_ah_attr
modifier|*
name|ah_attr
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * ib_query_ah - Queries the address vector associated with an address  *   handle.  * @ah: The address handle to query.  * @ah_attr: The address vector attributes associated with the address  *   handle.  */
end_comment

begin_function_decl
name|int
name|ib_query_ah
parameter_list|(
name|struct
name|ib_ah
modifier|*
name|ah
parameter_list|,
name|struct
name|ib_ah_attr
modifier|*
name|ah_attr
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * ib_destroy_ah - Destroys an address handle.  * @ah: The address handle to destroy.  */
end_comment

begin_function_decl
name|int
name|ib_destroy_ah
parameter_list|(
name|struct
name|ib_ah
modifier|*
name|ah
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * ib_create_srq - Creates a SRQ associated with the specified protection  *   domain.  * @pd: The protection domain associated with the SRQ.  * @srq_init_attr: A list of initial attributes required to create the  *   SRQ.  If SRQ creation succeeds, then the attributes are updated to  *   the actual capabilities of the created SRQ.  *  * srq_attr->max_wr and srq_attr->max_sge are read the determine the  * requested size of the SRQ, and set to the actual values allocated  * on return.  If ib_create_srq() succeeds, then max_wr and max_sge  * will always be at least as large as the requested values.  */
end_comment

begin_function_decl
name|struct
name|ib_srq
modifier|*
name|ib_create_srq
parameter_list|(
name|struct
name|ib_pd
modifier|*
name|pd
parameter_list|,
name|struct
name|ib_srq_init_attr
modifier|*
name|srq_init_attr
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * ib_modify_srq - Modifies the attributes for the specified SRQ.  * @srq: The SRQ to modify.  * @srq_attr: On input, specifies the SRQ attributes to modify.  On output,  *   the current values of selected SRQ attributes are returned.  * @srq_attr_mask: A bit-mask used to specify which attributes of the SRQ  *   are being modified.  *  * The mask may contain IB_SRQ_MAX_WR to resize the SRQ and/or  * IB_SRQ_LIMIT to set the SRQ's limit and request notification when  * the number of receives queued drops below the limit.  */
end_comment

begin_function_decl
name|int
name|ib_modify_srq
parameter_list|(
name|struct
name|ib_srq
modifier|*
name|srq
parameter_list|,
name|struct
name|ib_srq_attr
modifier|*
name|srq_attr
parameter_list|,
name|enum
name|ib_srq_attr_mask
name|srq_attr_mask
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * ib_query_srq - Returns the attribute list and current values for the  *   specified SRQ.  * @srq: The SRQ to query.  * @srq_attr: The attributes of the specified SRQ.  */
end_comment

begin_function_decl
name|int
name|ib_query_srq
parameter_list|(
name|struct
name|ib_srq
modifier|*
name|srq
parameter_list|,
name|struct
name|ib_srq_attr
modifier|*
name|srq_attr
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * ib_destroy_srq - Destroys the specified SRQ.  * @srq: The SRQ to destroy.  */
end_comment

begin_function_decl
name|int
name|ib_destroy_srq
parameter_list|(
name|struct
name|ib_srq
modifier|*
name|srq
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * ib_post_srq_recv - Posts a list of work requests to the specified SRQ.  * @srq: The SRQ to post the work request on.  * @recv_wr: A list of work requests to post on the receive queue.  * @bad_recv_wr: On an immediate failure, this parameter will reference  *   the work request that failed to be posted on the QP.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|ib_post_srq_recv
parameter_list|(
name|struct
name|ib_srq
modifier|*
name|srq
parameter_list|,
name|struct
name|ib_recv_wr
modifier|*
name|recv_wr
parameter_list|,
name|struct
name|ib_recv_wr
modifier|*
modifier|*
name|bad_recv_wr
parameter_list|)
block|{
return|return
name|srq
operator|->
name|device
operator|->
name|post_srq_recv
argument_list|(
name|srq
argument_list|,
name|recv_wr
argument_list|,
name|bad_recv_wr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * ib_create_qp - Creates a QP associated with the specified protection  *   domain.  * @pd: The protection domain associated with the QP.  * @qp_init_attr: A list of initial attributes required to create the  *   QP.  If QP creation succeeds, then the attributes are updated to  *   the actual capabilities of the created QP.  */
end_comment

begin_function_decl
name|struct
name|ib_qp
modifier|*
name|ib_create_qp
parameter_list|(
name|struct
name|ib_pd
modifier|*
name|pd
parameter_list|,
name|struct
name|ib_qp_init_attr
modifier|*
name|qp_init_attr
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * ib_modify_qp - Modifies the attributes for the specified QP and then  *   transitions the QP to the given state.  * @qp: The QP to modify.  * @qp_attr: On input, specifies the QP attributes to modify.  On output,  *   the current values of selected QP attributes are returned.  * @qp_attr_mask: A bit-mask used to specify which attributes of the QP  *   are being modified.  */
end_comment

begin_function_decl
name|int
name|ib_modify_qp
parameter_list|(
name|struct
name|ib_qp
modifier|*
name|qp
parameter_list|,
name|struct
name|ib_qp_attr
modifier|*
name|qp_attr
parameter_list|,
name|int
name|qp_attr_mask
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * ib_query_qp - Returns the attribute list and current values for the  *   specified QP.  * @qp: The QP to query.  * @qp_attr: The attributes of the specified QP.  * @qp_attr_mask: A bit-mask used to select specific attributes to query.  * @qp_init_attr: Additional attributes of the selected QP.  *  * The qp_attr_mask may be used to limit the query to gathering only the  * selected attributes.  */
end_comment

begin_function_decl
name|int
name|ib_query_qp
parameter_list|(
name|struct
name|ib_qp
modifier|*
name|qp
parameter_list|,
name|struct
name|ib_qp_attr
modifier|*
name|qp_attr
parameter_list|,
name|int
name|qp_attr_mask
parameter_list|,
name|struct
name|ib_qp_init_attr
modifier|*
name|qp_init_attr
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * ib_destroy_qp - Destroys the specified QP.  * @qp: The QP to destroy.  */
end_comment

begin_function_decl
name|int
name|ib_destroy_qp
parameter_list|(
name|struct
name|ib_qp
modifier|*
name|qp
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * ib_open_qp - Obtain a reference to an existing sharable QP.  * @xrcd - XRC domain  * @qp_open_attr: Attributes identifying the QP to open.  *  * Returns a reference to a sharable QP.  */
end_comment

begin_function_decl
name|struct
name|ib_qp
modifier|*
name|ib_open_qp
parameter_list|(
name|struct
name|ib_xrcd
modifier|*
name|xrcd
parameter_list|,
name|struct
name|ib_qp_open_attr
modifier|*
name|qp_open_attr
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * ib_close_qp - Release an external reference to a QP.  * @qp: The QP handle to release  *  * The opened QP handle is released by the caller.  The underlying  * shared QP is not destroyed until all internal references are released.  */
end_comment

begin_function_decl
name|int
name|ib_close_qp
parameter_list|(
name|struct
name|ib_qp
modifier|*
name|qp
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * ib_post_send - Posts a list of work requests to the send queue of  *   the specified QP.  * @qp: The QP to post the work request on.  * @send_wr: A list of work requests to post on the send queue.  * @bad_send_wr: On an immediate failure, this parameter will reference  *   the work request that failed to be posted on the QP.  *  * While IBA Vol. 1 section 11.4.1.1 specifies that if an immediate  * error is returned, the QP state shall not be affected,  * ib_post_send() will return an immediate error after queueing any  * earlier work requests in the list.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|ib_post_send
parameter_list|(
name|struct
name|ib_qp
modifier|*
name|qp
parameter_list|,
name|struct
name|ib_send_wr
modifier|*
name|send_wr
parameter_list|,
name|struct
name|ib_send_wr
modifier|*
modifier|*
name|bad_send_wr
parameter_list|)
block|{
return|return
name|qp
operator|->
name|device
operator|->
name|post_send
argument_list|(
name|qp
argument_list|,
name|send_wr
argument_list|,
name|bad_send_wr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * ib_post_recv - Posts a list of work requests to the receive queue of  *   the specified QP.  * @qp: The QP to post the work request on.  * @recv_wr: A list of work requests to post on the receive queue.  * @bad_recv_wr: On an immediate failure, this parameter will reference  *   the work request that failed to be posted on the QP.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|ib_post_recv
parameter_list|(
name|struct
name|ib_qp
modifier|*
name|qp
parameter_list|,
name|struct
name|ib_recv_wr
modifier|*
name|recv_wr
parameter_list|,
name|struct
name|ib_recv_wr
modifier|*
modifier|*
name|bad_recv_wr
parameter_list|)
block|{
return|return
name|qp
operator|->
name|device
operator|->
name|post_recv
argument_list|(
name|qp
argument_list|,
name|recv_wr
argument_list|,
name|bad_recv_wr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * ib_create_cq - Creates a CQ on the specified device.  * @device: The device on which to create the CQ.  * @comp_handler: A user-specified callback that is invoked when a  *   completion event occurs on the CQ.  * @event_handler: A user-specified callback that is invoked when an  *   asynchronous event not associated with a completion occurs on the CQ.  * @cq_context: Context associated with the CQ returned to the user via  *   the associated completion and event handlers.  * @cqe: The minimum size of the CQ.  * @comp_vector - Completion vector used to signal completion events.  *     Must be>= 0 and< context->num_comp_vectors.  *  * Users can examine the cq structure to determine the actual CQ size.  */
end_comment

begin_function_decl
name|struct
name|ib_cq
modifier|*
name|ib_create_cq
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|ib_comp_handler
name|comp_handler
parameter_list|,
name|void
function_decl|(
modifier|*
name|event_handler
function_decl|)
parameter_list|(
name|struct
name|ib_event
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|cq_context
parameter_list|,
name|int
name|cqe
parameter_list|,
name|int
name|comp_vector
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * ib_resize_cq - Modifies the capacity of the CQ.  * @cq: The CQ to resize.  * @cqe: The minimum size of the CQ.  *  * Users can examine the cq structure to determine the actual CQ size.  */
end_comment

begin_function_decl
name|int
name|ib_resize_cq
parameter_list|(
name|struct
name|ib_cq
modifier|*
name|cq
parameter_list|,
name|int
name|cqe
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * ib_modify_cq - Modifies the attributes for the specified CQ and then  *   transitions the CQ to the given state.  * @cq: The CQ to modify.  * @cq_attr: specifies the CQ attributes to modify.  * @cq_attr_mask: A bit-mask used to specify which attributes of the CQ  *   are being modified.  */
end_comment

begin_function_decl
name|int
name|ib_modify_cq
parameter_list|(
name|struct
name|ib_cq
modifier|*
name|cq
parameter_list|,
name|struct
name|ib_cq_attr
modifier|*
name|cq_attr
parameter_list|,
name|int
name|cq_attr_mask
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * ib_destroy_cq - Destroys the specified CQ.  * @cq: The CQ to destroy.  */
end_comment

begin_function_decl
name|int
name|ib_destroy_cq
parameter_list|(
name|struct
name|ib_cq
modifier|*
name|cq
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * ib_poll_cq - poll a CQ for completion(s)  * @cq:the CQ being polled  * @num_entries:maximum number of completions to return  * @wc:array of at least @num_entries&struct ib_wc where completions  *   will be returned  *  * Poll a CQ for (possibly multiple) completions.  If the return value  * is< 0, an error occurred.  If the return value is>= 0, it is the  * number of completions returned.  If the return value is  * non-negative and< num_entries, then the CQ was emptied.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|ib_poll_cq
parameter_list|(
name|struct
name|ib_cq
modifier|*
name|cq
parameter_list|,
name|int
name|num_entries
parameter_list|,
name|struct
name|ib_wc
modifier|*
name|wc
parameter_list|)
block|{
return|return
name|cq
operator|->
name|device
operator|->
name|poll_cq
argument_list|(
name|cq
argument_list|,
name|num_entries
argument_list|,
name|wc
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * ib_peek_cq - Returns the number of unreaped completions currently  *   on the specified CQ.  * @cq: The CQ to peek.  * @wc_cnt: A minimum number of unreaped completions to check for.  *  * If the number of unreaped completions is greater than or equal to wc_cnt,  * this function returns wc_cnt, otherwise, it returns the actual number of  * unreaped completions.  */
end_comment

begin_function_decl
name|int
name|ib_peek_cq
parameter_list|(
name|struct
name|ib_cq
modifier|*
name|cq
parameter_list|,
name|int
name|wc_cnt
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * ib_req_notify_cq - Request completion notification on a CQ.  * @cq: The CQ to generate an event for.  * @flags:  *   Must contain exactly one of %IB_CQ_SOLICITED or %IB_CQ_NEXT_COMP  *   to request an event on the next solicited event or next work  *   completion at any type, respectively. %IB_CQ_REPORT_MISSED_EVENTS  *   may also be |ed in to request a hint about missed events, as  *   described below.  *  * Return Value:  *< 0 means an error occurred while requesting notification  *   == 0 means notification was requested successfully, and if  *        IB_CQ_REPORT_MISSED_EVENTS was passed in, then no events  *        were missed and it is safe to wait for another event.  In  *        this case is it guaranteed that any work completions added  *        to the CQ since the last CQ poll will trigger a completion  *        notification event.  *> 0 is only returned if IB_CQ_REPORT_MISSED_EVENTS was passed  *        in.  It means that the consumer must poll the CQ again to  *        make sure it is empty to avoid missing an event because of a  *        race between requesting notification and an entry being  *        added to the CQ.  This return value means it is possible  *        (but not guaranteed) that a work completion has been added  *        to the CQ since the last poll without triggering a  *        completion notification event.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|ib_req_notify_cq
parameter_list|(
name|struct
name|ib_cq
modifier|*
name|cq
parameter_list|,
name|enum
name|ib_cq_notify_flags
name|flags
parameter_list|)
block|{
return|return
name|cq
operator|->
name|device
operator|->
name|req_notify_cq
argument_list|(
name|cq
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * ib_req_ncomp_notif - Request completion notification when there are  *   at least the specified number of unreaped completions on the CQ.  * @cq: The CQ to generate an event for.  * @wc_cnt: The number of unreaped completions that should be on the  *   CQ before an event is generated.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|ib_req_ncomp_notif
parameter_list|(
name|struct
name|ib_cq
modifier|*
name|cq
parameter_list|,
name|int
name|wc_cnt
parameter_list|)
block|{
return|return
name|cq
operator|->
name|device
operator|->
name|req_ncomp_notif
condition|?
name|cq
operator|->
name|device
operator|->
name|req_ncomp_notif
argument_list|(
name|cq
argument_list|,
name|wc_cnt
argument_list|)
else|:
operator|-
name|ENOSYS
return|;
block|}
end_function

begin_comment
comment|/**  * ib_get_dma_mr - Returns a memory region for system memory that is  *   usable for DMA.  * @pd: The protection domain associated with the memory region.  * @mr_access_flags: Specifies the memory access rights.  *  * Note that the ib_dma_*() functions defined below must be used  * to create/destroy addresses used with the Lkey or Rkey returned  * by ib_get_dma_mr().  */
end_comment

begin_function_decl
name|struct
name|ib_mr
modifier|*
name|ib_get_dma_mr
parameter_list|(
name|struct
name|ib_pd
modifier|*
name|pd
parameter_list|,
name|int
name|mr_access_flags
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * ib_dma_mapping_error - check a DMA addr for error  * @dev: The device for which the dma_addr was created  * @dma_addr: The DMA address to check  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|ib_dma_mapping_error
parameter_list|(
name|struct
name|ib_device
modifier|*
name|dev
parameter_list|,
name|u64
name|dma_addr
parameter_list|)
block|{
if|if
condition|(
name|dev
operator|->
name|dma_ops
condition|)
return|return
name|dev
operator|->
name|dma_ops
operator|->
name|mapping_error
argument_list|(
name|dev
argument_list|,
name|dma_addr
argument_list|)
return|;
return|return
name|dma_mapping_error
argument_list|(
name|dev
operator|->
name|dma_device
argument_list|,
name|dma_addr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * ib_dma_map_single - Map a kernel virtual address to DMA address  * @dev: The device for which the dma_addr is to be created  * @cpu_addr: The kernel virtual address  * @size: The size of the region in bytes  * @direction: The direction of the DMA  */
end_comment

begin_function
specifier|static
specifier|inline
name|u64
name|ib_dma_map_single
parameter_list|(
name|struct
name|ib_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|cpu_addr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|enum
name|dma_data_direction
name|direction
parameter_list|)
block|{
if|if
condition|(
name|dev
operator|->
name|dma_ops
condition|)
return|return
name|dev
operator|->
name|dma_ops
operator|->
name|map_single
argument_list|(
name|dev
argument_list|,
name|cpu_addr
argument_list|,
name|size
argument_list|,
name|direction
argument_list|)
return|;
return|return
name|dma_map_single
argument_list|(
name|dev
operator|->
name|dma_device
argument_list|,
name|cpu_addr
argument_list|,
name|size
argument_list|,
name|direction
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * ib_dma_unmap_single - Destroy a mapping created by ib_dma_map_single()  * @dev: The device for which the DMA address was created  * @addr: The DMA address  * @size: The size of the region in bytes  * @direction: The direction of the DMA  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|ib_dma_unmap_single
parameter_list|(
name|struct
name|ib_device
modifier|*
name|dev
parameter_list|,
name|u64
name|addr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|enum
name|dma_data_direction
name|direction
parameter_list|)
block|{
if|if
condition|(
name|dev
operator|->
name|dma_ops
condition|)
name|dev
operator|->
name|dma_ops
operator|->
name|unmap_single
argument_list|(
name|dev
argument_list|,
name|addr
argument_list|,
name|size
argument_list|,
name|direction
argument_list|)
expr_stmt|;
else|else
name|dma_unmap_single
argument_list|(
name|dev
operator|->
name|dma_device
argument_list|,
name|addr
argument_list|,
name|size
argument_list|,
name|direction
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|u64
name|ib_dma_map_single_attrs
parameter_list|(
name|struct
name|ib_device
modifier|*
name|dev
parameter_list|,
name|void
modifier|*
name|cpu_addr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|enum
name|dma_data_direction
name|direction
parameter_list|,
name|struct
name|dma_attrs
modifier|*
name|attrs
parameter_list|)
block|{
return|return
name|dma_map_single_attrs
argument_list|(
name|dev
operator|->
name|dma_device
argument_list|,
name|cpu_addr
argument_list|,
name|size
argument_list|,
name|direction
argument_list|,
name|attrs
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|ib_dma_unmap_single_attrs
parameter_list|(
name|struct
name|ib_device
modifier|*
name|dev
parameter_list|,
name|u64
name|addr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|enum
name|dma_data_direction
name|direction
parameter_list|,
name|struct
name|dma_attrs
modifier|*
name|attrs
parameter_list|)
block|{
return|return
name|dma_unmap_single_attrs
argument_list|(
name|dev
operator|->
name|dma_device
argument_list|,
name|addr
argument_list|,
name|size
argument_list|,
name|direction
argument_list|,
name|attrs
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * ib_dma_map_page - Map a physical page to DMA address  * @dev: The device for which the dma_addr is to be created  * @page: The page to be mapped  * @offset: The offset within the page  * @size: The size of the region in bytes  * @direction: The direction of the DMA  */
end_comment

begin_function
specifier|static
specifier|inline
name|u64
name|ib_dma_map_page
parameter_list|(
name|struct
name|ib_device
modifier|*
name|dev
parameter_list|,
name|struct
name|page
modifier|*
name|page
parameter_list|,
name|unsigned
name|long
name|offset
parameter_list|,
name|size_t
name|size
parameter_list|,
name|enum
name|dma_data_direction
name|direction
parameter_list|)
block|{
if|if
condition|(
name|dev
operator|->
name|dma_ops
condition|)
return|return
name|dev
operator|->
name|dma_ops
operator|->
name|map_page
argument_list|(
name|dev
argument_list|,
name|page
argument_list|,
name|offset
argument_list|,
name|size
argument_list|,
name|direction
argument_list|)
return|;
return|return
name|dma_map_page
argument_list|(
name|dev
operator|->
name|dma_device
argument_list|,
name|page
argument_list|,
name|offset
argument_list|,
name|size
argument_list|,
name|direction
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * ib_dma_unmap_page - Destroy a mapping created by ib_dma_map_page()  * @dev: The device for which the DMA address was created  * @addr: The DMA address  * @size: The size of the region in bytes  * @direction: The direction of the DMA  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|ib_dma_unmap_page
parameter_list|(
name|struct
name|ib_device
modifier|*
name|dev
parameter_list|,
name|u64
name|addr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|enum
name|dma_data_direction
name|direction
parameter_list|)
block|{
if|if
condition|(
name|dev
operator|->
name|dma_ops
condition|)
name|dev
operator|->
name|dma_ops
operator|->
name|unmap_page
argument_list|(
name|dev
argument_list|,
name|addr
argument_list|,
name|size
argument_list|,
name|direction
argument_list|)
expr_stmt|;
else|else
name|dma_unmap_page
argument_list|(
name|dev
operator|->
name|dma_device
argument_list|,
name|addr
argument_list|,
name|size
argument_list|,
name|direction
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ib_dma_map_sg - Map a scatter/gather list to DMA addresses  * @dev: The device for which the DMA addresses are to be created  * @sg: The array of scatter/gather entries  * @nents: The number of scatter/gather entries  * @direction: The direction of the DMA  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|ib_dma_map_sg
parameter_list|(
name|struct
name|ib_device
modifier|*
name|dev
parameter_list|,
name|struct
name|scatterlist
modifier|*
name|sg
parameter_list|,
name|int
name|nents
parameter_list|,
name|enum
name|dma_data_direction
name|direction
parameter_list|)
block|{
if|if
condition|(
name|dev
operator|->
name|dma_ops
condition|)
return|return
name|dev
operator|->
name|dma_ops
operator|->
name|map_sg
argument_list|(
name|dev
argument_list|,
name|sg
argument_list|,
name|nents
argument_list|,
name|direction
argument_list|)
return|;
return|return
name|dma_map_sg
argument_list|(
name|dev
operator|->
name|dma_device
argument_list|,
name|sg
argument_list|,
name|nents
argument_list|,
name|direction
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * ib_dma_unmap_sg - Unmap a scatter/gather list of DMA addresses  * @dev: The device for which the DMA addresses were created  * @sg: The array of scatter/gather entries  * @nents: The number of scatter/gather entries  * @direction: The direction of the DMA  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|ib_dma_unmap_sg
parameter_list|(
name|struct
name|ib_device
modifier|*
name|dev
parameter_list|,
name|struct
name|scatterlist
modifier|*
name|sg
parameter_list|,
name|int
name|nents
parameter_list|,
name|enum
name|dma_data_direction
name|direction
parameter_list|)
block|{
if|if
condition|(
name|dev
operator|->
name|dma_ops
condition|)
name|dev
operator|->
name|dma_ops
operator|->
name|unmap_sg
argument_list|(
name|dev
argument_list|,
name|sg
argument_list|,
name|nents
argument_list|,
name|direction
argument_list|)
expr_stmt|;
else|else
name|dma_unmap_sg
argument_list|(
name|dev
operator|->
name|dma_device
argument_list|,
name|sg
argument_list|,
name|nents
argument_list|,
name|direction
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|ib_dma_map_sg_attrs
parameter_list|(
name|struct
name|ib_device
modifier|*
name|dev
parameter_list|,
name|struct
name|scatterlist
modifier|*
name|sg
parameter_list|,
name|int
name|nents
parameter_list|,
name|enum
name|dma_data_direction
name|direction
parameter_list|,
name|struct
name|dma_attrs
modifier|*
name|attrs
parameter_list|)
block|{
return|return
name|dma_map_sg_attrs
argument_list|(
name|dev
operator|->
name|dma_device
argument_list|,
name|sg
argument_list|,
name|nents
argument_list|,
name|direction
argument_list|,
name|attrs
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|ib_dma_unmap_sg_attrs
parameter_list|(
name|struct
name|ib_device
modifier|*
name|dev
parameter_list|,
name|struct
name|scatterlist
modifier|*
name|sg
parameter_list|,
name|int
name|nents
parameter_list|,
name|enum
name|dma_data_direction
name|direction
parameter_list|,
name|struct
name|dma_attrs
modifier|*
name|attrs
parameter_list|)
block|{
name|dma_unmap_sg_attrs
argument_list|(
name|dev
operator|->
name|dma_device
argument_list|,
name|sg
argument_list|,
name|nents
argument_list|,
name|direction
argument_list|,
name|attrs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ib_sg_dma_address - Return the DMA address from a scatter/gather entry  * @dev: The device for which the DMA addresses were created  * @sg: The scatter/gather entry  */
end_comment

begin_function
specifier|static
specifier|inline
name|u64
name|ib_sg_dma_address
parameter_list|(
name|struct
name|ib_device
modifier|*
name|dev
parameter_list|,
name|struct
name|scatterlist
modifier|*
name|sg
parameter_list|)
block|{
if|if
condition|(
name|dev
operator|->
name|dma_ops
condition|)
return|return
name|dev
operator|->
name|dma_ops
operator|->
name|dma_address
argument_list|(
name|dev
argument_list|,
name|sg
argument_list|)
return|;
return|return
name|sg_dma_address
argument_list|(
name|sg
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * ib_sg_dma_len - Return the DMA length from a scatter/gather entry  * @dev: The device for which the DMA addresses were created  * @sg: The scatter/gather entry  */
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|int
name|ib_sg_dma_len
parameter_list|(
name|struct
name|ib_device
modifier|*
name|dev
parameter_list|,
name|struct
name|scatterlist
modifier|*
name|sg
parameter_list|)
block|{
if|if
condition|(
name|dev
operator|->
name|dma_ops
condition|)
return|return
name|dev
operator|->
name|dma_ops
operator|->
name|dma_len
argument_list|(
name|dev
argument_list|,
name|sg
argument_list|)
return|;
return|return
name|sg_dma_len
argument_list|(
name|sg
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * ib_dma_sync_single_for_cpu - Prepare DMA region to be accessed by CPU  * @dev: The device for which the DMA address was created  * @addr: The DMA address  * @size: The size of the region in bytes  * @dir: The direction of the DMA  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|ib_dma_sync_single_for_cpu
parameter_list|(
name|struct
name|ib_device
modifier|*
name|dev
parameter_list|,
name|u64
name|addr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|enum
name|dma_data_direction
name|dir
parameter_list|)
block|{
if|if
condition|(
name|dev
operator|->
name|dma_ops
condition|)
name|dev
operator|->
name|dma_ops
operator|->
name|sync_single_for_cpu
argument_list|(
name|dev
argument_list|,
name|addr
argument_list|,
name|size
argument_list|,
name|dir
argument_list|)
expr_stmt|;
else|else
name|dma_sync_single_for_cpu
argument_list|(
name|dev
operator|->
name|dma_device
argument_list|,
name|addr
argument_list|,
name|size
argument_list|,
name|dir
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ib_dma_sync_single_for_device - Prepare DMA region to be accessed by device  * @dev: The device for which the DMA address was created  * @addr: The DMA address  * @size: The size of the region in bytes  * @dir: The direction of the DMA  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|ib_dma_sync_single_for_device
parameter_list|(
name|struct
name|ib_device
modifier|*
name|dev
parameter_list|,
name|u64
name|addr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|enum
name|dma_data_direction
name|dir
parameter_list|)
block|{
if|if
condition|(
name|dev
operator|->
name|dma_ops
condition|)
name|dev
operator|->
name|dma_ops
operator|->
name|sync_single_for_device
argument_list|(
name|dev
argument_list|,
name|addr
argument_list|,
name|size
argument_list|,
name|dir
argument_list|)
expr_stmt|;
else|else
name|dma_sync_single_for_device
argument_list|(
name|dev
operator|->
name|dma_device
argument_list|,
name|addr
argument_list|,
name|size
argument_list|,
name|dir
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ib_dma_alloc_coherent - Allocate memory and map it for DMA  * @dev: The device for which the DMA address is requested  * @size: The size of the region to allocate in bytes  * @dma_handle: A pointer for returning the DMA address of the region  * @flag: memory allocator flags  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
modifier|*
name|ib_dma_alloc_coherent
parameter_list|(
name|struct
name|ib_device
modifier|*
name|dev
parameter_list|,
name|size_t
name|size
parameter_list|,
name|u64
modifier|*
name|dma_handle
parameter_list|,
name|gfp_t
name|flag
parameter_list|)
block|{
if|if
condition|(
name|dev
operator|->
name|dma_ops
condition|)
return|return
name|dev
operator|->
name|dma_ops
operator|->
name|alloc_coherent
argument_list|(
name|dev
argument_list|,
name|size
argument_list|,
name|dma_handle
argument_list|,
name|flag
argument_list|)
return|;
else|else
block|{
name|dma_addr_t
name|handle
decl_stmt|;
name|void
modifier|*
name|ret
decl_stmt|;
name|ret
operator|=
name|dma_alloc_coherent
argument_list|(
name|dev
operator|->
name|dma_device
argument_list|,
name|size
argument_list|,
operator|&
name|handle
argument_list|,
name|flag
argument_list|)
expr_stmt|;
operator|*
name|dma_handle
operator|=
name|handle
expr_stmt|;
return|return
name|ret
return|;
block|}
block|}
end_function

begin_comment
comment|/**  * ib_dma_free_coherent - Free memory allocated by ib_dma_alloc_coherent()  * @dev: The device for which the DMA addresses were allocated  * @size: The size of the region  * @cpu_addr: the address returned by ib_dma_alloc_coherent()  * @dma_handle: the DMA address returned by ib_dma_alloc_coherent()  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|ib_dma_free_coherent
parameter_list|(
name|struct
name|ib_device
modifier|*
name|dev
parameter_list|,
name|size_t
name|size
parameter_list|,
name|void
modifier|*
name|cpu_addr
parameter_list|,
name|u64
name|dma_handle
parameter_list|)
block|{
if|if
condition|(
name|dev
operator|->
name|dma_ops
condition|)
name|dev
operator|->
name|dma_ops
operator|->
name|free_coherent
argument_list|(
name|dev
argument_list|,
name|size
argument_list|,
name|cpu_addr
argument_list|,
name|dma_handle
argument_list|)
expr_stmt|;
else|else
name|dma_free_coherent
argument_list|(
name|dev
operator|->
name|dma_device
argument_list|,
name|size
argument_list|,
name|cpu_addr
argument_list|,
name|dma_handle
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ib_reg_phys_mr - Prepares a virtually addressed memory region for use  *   by an HCA.  * @pd: The protection domain associated assigned to the registered region.  * @phys_buf_array: Specifies a list of physical buffers to use in the  *   memory region.  * @num_phys_buf: Specifies the size of the phys_buf_array.  * @mr_access_flags: Specifies the memory access rights.  * @iova_start: The offset of the region's starting I/O virtual address.  */
end_comment

begin_function_decl
name|struct
name|ib_mr
modifier|*
name|ib_reg_phys_mr
parameter_list|(
name|struct
name|ib_pd
modifier|*
name|pd
parameter_list|,
name|struct
name|ib_phys_buf
modifier|*
name|phys_buf_array
parameter_list|,
name|int
name|num_phys_buf
parameter_list|,
name|int
name|mr_access_flags
parameter_list|,
name|u64
modifier|*
name|iova_start
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * ib_rereg_phys_mr - Modifies the attributes of an existing memory region.  *   Conceptually, this call performs the functions deregister memory region  *   followed by register physical memory region.  Where possible,  *   resources are reused instead of deallocated and reallocated.  * @mr: The memory region to modify.  * @mr_rereg_mask: A bit-mask used to indicate which of the following  *   properties of the memory region are being modified.  * @pd: If %IB_MR_REREG_PD is set in mr_rereg_mask, this field specifies  *   the new protection domain to associated with the memory region,  *   otherwise, this parameter is ignored.  * @phys_buf_array: If %IB_MR_REREG_TRANS is set in mr_rereg_mask, this  *   field specifies a list of physical buffers to use in the new  *   translation, otherwise, this parameter is ignored.  * @num_phys_buf: If %IB_MR_REREG_TRANS is set in mr_rereg_mask, this  *   field specifies the size of the phys_buf_array, otherwise, this  *   parameter is ignored.  * @mr_access_flags: If %IB_MR_REREG_ACCESS is set in mr_rereg_mask, this  *   field specifies the new memory access rights, otherwise, this  *   parameter is ignored.  * @iova_start: The offset of the region's starting I/O virtual address.  */
end_comment

begin_function_decl
name|int
name|ib_rereg_phys_mr
parameter_list|(
name|struct
name|ib_mr
modifier|*
name|mr
parameter_list|,
name|int
name|mr_rereg_mask
parameter_list|,
name|struct
name|ib_pd
modifier|*
name|pd
parameter_list|,
name|struct
name|ib_phys_buf
modifier|*
name|phys_buf_array
parameter_list|,
name|int
name|num_phys_buf
parameter_list|,
name|int
name|mr_access_flags
parameter_list|,
name|u64
modifier|*
name|iova_start
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * ib_query_mr - Retrieves information about a specific memory region.  * @mr: The memory region to retrieve information about.  * @mr_attr: The attributes of the specified memory region.  */
end_comment

begin_function_decl
name|int
name|ib_query_mr
parameter_list|(
name|struct
name|ib_mr
modifier|*
name|mr
parameter_list|,
name|struct
name|ib_mr_attr
modifier|*
name|mr_attr
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * ib_dereg_mr - Deregisters a memory region and removes it from the  *   HCA translation table.  * @mr: The memory region to deregister.  *  * This function can fail, if the memory region has memory windows bound to it.  */
end_comment

begin_function_decl
name|int
name|ib_dereg_mr
parameter_list|(
name|struct
name|ib_mr
modifier|*
name|mr
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * ib_create_mr - Allocates a memory region that may be used for  *     signature handover operations.  * @pd: The protection domain associated with the region.  * @mr_init_attr: memory region init attributes.  */
end_comment

begin_function_decl
name|struct
name|ib_mr
modifier|*
name|ib_create_mr
parameter_list|(
name|struct
name|ib_pd
modifier|*
name|pd
parameter_list|,
name|struct
name|ib_mr_init_attr
modifier|*
name|mr_init_attr
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * ib_destroy_mr - Destroys a memory region that was created using  *     ib_create_mr and removes it from HW translation tables.  * @mr: The memory region to destroy.  *  * This function can fail, if the memory region has memory windows bound to it.  */
end_comment

begin_function_decl
name|int
name|ib_destroy_mr
parameter_list|(
name|struct
name|ib_mr
modifier|*
name|mr
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * ib_alloc_fast_reg_mr - Allocates memory region usable with the  *   IB_WR_FAST_REG_MR send work request.  * @pd: The protection domain associated with the region.  * @max_page_list_len: requested max physical buffer list length to be  *   used with fast register work requests for this MR.  */
end_comment

begin_function_decl
name|struct
name|ib_mr
modifier|*
name|ib_alloc_fast_reg_mr
parameter_list|(
name|struct
name|ib_pd
modifier|*
name|pd
parameter_list|,
name|int
name|max_page_list_len
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * ib_alloc_fast_reg_page_list - Allocates a page list array  * @device - ib device pointer.  * @page_list_len - size of the page list array to be allocated.  *  * This allocates and returns a struct ib_fast_reg_page_list * and a  * page_list array that is at least page_list_len in size.  The actual  * size is returned in max_page_list_len.  The caller is responsible  * for initializing the contents of the page_list array before posting  * a send work request with the IB_WC_FAST_REG_MR opcode.  *  * The page_list array entries must be translated using one of the  * ib_dma_*() functions just like the addresses passed to  * ib_map_phys_fmr().  Once the ib_post_send() is issued, the struct  * ib_fast_reg_page_list must not be modified by the caller until the  * IB_WC_FAST_REG_MR work request completes.  */
end_comment

begin_function_decl
name|struct
name|ib_fast_reg_page_list
modifier|*
name|ib_alloc_fast_reg_page_list
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|int
name|page_list_len
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * ib_free_fast_reg_page_list - Deallocates a previously allocated  *   page list array.  * @page_list - struct ib_fast_reg_page_list pointer to be deallocated.  */
end_comment

begin_function_decl
name|void
name|ib_free_fast_reg_page_list
parameter_list|(
name|struct
name|ib_fast_reg_page_list
modifier|*
name|page_list
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * ib_update_fast_reg_key - updates the key portion of the fast_reg MR  *   R_Key and L_Key.  * @mr - struct ib_mr pointer to be updated.  * @newkey - new key to be used.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|ib_update_fast_reg_key
parameter_list|(
name|struct
name|ib_mr
modifier|*
name|mr
parameter_list|,
name|u8
name|newkey
parameter_list|)
block|{
name|mr
operator|->
name|lkey
operator|=
operator|(
name|mr
operator|->
name|lkey
operator|&
literal|0xffffff00
operator|)
operator||
name|newkey
expr_stmt|;
name|mr
operator|->
name|rkey
operator|=
operator|(
name|mr
operator|->
name|rkey
operator|&
literal|0xffffff00
operator|)
operator||
name|newkey
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ib_inc_rkey - increments the key portion of the given rkey. Can be used  * for calculating a new rkey for type 2 memory windows.  * @rkey - the rkey to increment.  */
end_comment

begin_function
specifier|static
specifier|inline
name|u32
name|ib_inc_rkey
parameter_list|(
name|u32
name|rkey
parameter_list|)
block|{
specifier|const
name|u32
name|mask
init|=
literal|0x000000ff
decl_stmt|;
return|return
operator|(
operator|(
name|rkey
operator|+
literal|1
operator|)
operator|&
name|mask
operator|)
operator||
operator|(
name|rkey
operator|&
operator|~
name|mask
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * ib_alloc_mw - Allocates a memory window.  * @pd: The protection domain associated with the memory window.  * @type: The type of the memory window (1 or 2).  */
end_comment

begin_function_decl
name|struct
name|ib_mw
modifier|*
name|ib_alloc_mw
parameter_list|(
name|struct
name|ib_pd
modifier|*
name|pd
parameter_list|,
name|enum
name|ib_mw_type
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * ib_bind_mw - Posts a work request to the send queue of the specified  *   QP, which binds the memory window to the given address range and  *   remote access attributes.  * @qp: QP to post the bind work request on.  * @mw: The memory window to bind.  * @mw_bind: Specifies information about the memory window, including  *   its address range, remote access rights, and associated memory region.  *  * If there is no immediate error, the function will update the rkey member  * of the mw parameter to its new value. The bind operation can still fail  * asynchronously.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|ib_bind_mw
parameter_list|(
name|struct
name|ib_qp
modifier|*
name|qp
parameter_list|,
name|struct
name|ib_mw
modifier|*
name|mw
parameter_list|,
name|struct
name|ib_mw_bind
modifier|*
name|mw_bind
parameter_list|)
block|{
comment|/* XXX reference counting in corresponding MR? */
return|return
name|mw
operator|->
name|device
operator|->
name|bind_mw
condition|?
name|mw
operator|->
name|device
operator|->
name|bind_mw
argument_list|(
name|qp
argument_list|,
name|mw
argument_list|,
name|mw_bind
argument_list|)
else|:
operator|-
name|ENOSYS
return|;
block|}
end_function

begin_comment
comment|/**  * ib_dealloc_mw - Deallocates a memory window.  * @mw: The memory window to deallocate.  */
end_comment

begin_function_decl
name|int
name|ib_dealloc_mw
parameter_list|(
name|struct
name|ib_mw
modifier|*
name|mw
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * ib_alloc_fmr - Allocates a unmapped fast memory region.  * @pd: The protection domain associated with the unmapped region.  * @mr_access_flags: Specifies the memory access rights.  * @fmr_attr: Attributes of the unmapped region.  *  * A fast memory region must be mapped before it can be used as part of  * a work request.  */
end_comment

begin_function_decl
name|struct
name|ib_fmr
modifier|*
name|ib_alloc_fmr
parameter_list|(
name|struct
name|ib_pd
modifier|*
name|pd
parameter_list|,
name|int
name|mr_access_flags
parameter_list|,
name|struct
name|ib_fmr_attr
modifier|*
name|fmr_attr
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * ib_map_phys_fmr - Maps a list of physical pages to a fast memory region.  * @fmr: The fast memory region to associate with the pages.  * @page_list: An array of physical pages to map to the fast memory region.  * @list_len: The number of pages in page_list.  * @iova: The I/O virtual address to use with the mapped region.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|ib_map_phys_fmr
parameter_list|(
name|struct
name|ib_fmr
modifier|*
name|fmr
parameter_list|,
name|u64
modifier|*
name|page_list
parameter_list|,
name|int
name|list_len
parameter_list|,
name|u64
name|iova
parameter_list|)
block|{
return|return
name|fmr
operator|->
name|device
operator|->
name|map_phys_fmr
argument_list|(
name|fmr
argument_list|,
name|page_list
argument_list|,
name|list_len
argument_list|,
name|iova
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * ib_unmap_fmr - Removes the mapping from a list of fast memory regions.  * @fmr_list: A linked list of fast memory regions to unmap.  */
end_comment

begin_function_decl
name|int
name|ib_unmap_fmr
parameter_list|(
name|struct
name|list_head
modifier|*
name|fmr_list
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * ib_dealloc_fmr - Deallocates a fast memory region.  * @fmr: The fast memory region to deallocate.  */
end_comment

begin_function_decl
name|int
name|ib_dealloc_fmr
parameter_list|(
name|struct
name|ib_fmr
modifier|*
name|fmr
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * ib_attach_mcast - Attaches the specified QP to a multicast group.  * @qp: QP to attach to the multicast group.  The QP must be type  *   IB_QPT_UD.  * @gid: Multicast group GID.  * @lid: Multicast group LID in host byte order.  *  * In order to send and receive multicast packets, subnet  * administration must have created the multicast group and configured  * the fabric appropriately.  The port associated with the specified  * QP must also be a member of the multicast group.  */
end_comment

begin_function_decl
name|int
name|ib_attach_mcast
parameter_list|(
name|struct
name|ib_qp
modifier|*
name|qp
parameter_list|,
name|union
name|ib_gid
modifier|*
name|gid
parameter_list|,
name|u16
name|lid
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * ib_detach_mcast - Detaches the specified QP from a multicast group.  * @qp: QP to detach from the multicast group.  * @gid: Multicast group GID.  * @lid: Multicast group LID in host byte order.  */
end_comment

begin_function_decl
name|int
name|ib_detach_mcast
parameter_list|(
name|struct
name|ib_qp
modifier|*
name|qp
parameter_list|,
name|union
name|ib_gid
modifier|*
name|gid
parameter_list|,
name|u16
name|lid
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * ib_alloc_xrcd - Allocates an XRC domain.  * @device: The device on which to allocate the XRC domain.  */
end_comment

begin_function_decl
name|struct
name|ib_xrcd
modifier|*
name|ib_alloc_xrcd
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * ib_dealloc_xrcd - Deallocates an XRC domain.  * @xrcd: The XRC domain to deallocate.  */
end_comment

begin_function_decl
name|int
name|ib_dealloc_xrcd
parameter_list|(
name|struct
name|ib_xrcd
modifier|*
name|xrcd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|ib_flow
modifier|*
name|ib_create_flow
parameter_list|(
name|struct
name|ib_qp
modifier|*
name|qp
parameter_list|,
name|struct
name|ib_flow_attr
modifier|*
name|flow_attr
parameter_list|,
name|int
name|domain
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ib_destroy_flow
parameter_list|(
name|struct
name|ib_flow
modifier|*
name|flow_id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|ib_dct
modifier|*
name|ib_create_dct
parameter_list|(
name|struct
name|ib_pd
modifier|*
name|pd
parameter_list|,
name|struct
name|ib_dct_init_attr
modifier|*
name|attr
parameter_list|,
name|struct
name|ib_udata
modifier|*
name|udata
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ib_destroy_dct
parameter_list|(
name|struct
name|ib_dct
modifier|*
name|dct
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ib_query_dct
parameter_list|(
name|struct
name|ib_dct
modifier|*
name|dct
parameter_list|,
name|struct
name|ib_dct_attr
modifier|*
name|attr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ib_query_values
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|int
name|q_values
parameter_list|,
name|struct
name|ib_device_values
modifier|*
name|values
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
specifier|inline
name|void
name|ib_active_speed_enum_to_rate
parameter_list|(
name|u8
name|active_speed
parameter_list|,
name|int
modifier|*
name|rate
parameter_list|,
name|char
modifier|*
modifier|*
name|speed
parameter_list|)
block|{
switch|switch
condition|(
name|active_speed
condition|)
block|{
case|case
name|IB_SPEED_DDR
case|:
operator|*
name|speed
operator|=
literal|" DDR"
expr_stmt|;
operator|*
name|rate
operator|=
literal|50
expr_stmt|;
break|break;
case|case
name|IB_SPEED_QDR
case|:
operator|*
name|speed
operator|=
literal|" QDR"
expr_stmt|;
operator|*
name|rate
operator|=
literal|100
expr_stmt|;
break|break;
case|case
name|IB_SPEED_FDR10
case|:
operator|*
name|speed
operator|=
literal|" FDR10"
expr_stmt|;
operator|*
name|rate
operator|=
literal|100
expr_stmt|;
break|break;
case|case
name|IB_SPEED_FDR
case|:
operator|*
name|speed
operator|=
literal|" FDR"
expr_stmt|;
operator|*
name|rate
operator|=
literal|140
expr_stmt|;
break|break;
case|case
name|IB_SPEED_EDR
case|:
operator|*
name|speed
operator|=
literal|" EDR"
expr_stmt|;
operator|*
name|rate
operator|=
literal|250
expr_stmt|;
break|break;
case|case
name|IB_SPEED_SDR
case|:
default|default:
comment|/* default to SDR for invalid rates */
operator|*
name|rate
operator|=
literal|25
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|ib_check_mr_access
parameter_list|(
name|int
name|flags
parameter_list|)
block|{
comment|/* 	 * Local write permission is required if remote write or 	 * remote atomic permission is also requested. 	 */
if|if
condition|(
name|flags
operator|&
operator|(
name|IB_ACCESS_REMOTE_ATOMIC
operator||
name|IB_ACCESS_REMOTE_WRITE
operator|)
operator|&&
operator|!
operator|(
name|flags
operator|&
name|IB_ACCESS_LOCAL_WRITE
operator|)
condition|)
return|return
operator|-
name|EINVAL
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * ib_check_mr_status: lightweight check of MR status.  *     This routine may provide status checks on a selected  *     ib_mr. first use is for signature status check.  *  * @mr: A memory region.  * @check_mask: Bitmask of which checks to perform from  *     ib_mr_status_check enumeration.  * @mr_status: The container of relevant status checks.  *     failed checks will be indicated in the status bitmask  *     and the relevant info shall be in the error item.  */
end_comment

begin_function_decl
name|int
name|ib_check_mr_status
parameter_list|(
name|struct
name|ib_mr
modifier|*
name|mr
parameter_list|,
name|u32
name|check_mask
parameter_list|,
name|struct
name|ib_mr_status
modifier|*
name|mr_status
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IB_VERBS_H */
end_comment

end_unit

