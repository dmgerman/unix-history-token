begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * misc.c  *  * This is a collection of several routines from gzip-1.0.3  * adapted for Linux.  *  * Ported to 386bsd by Serge Vakulenko  */
end_comment

begin_include
include|#
directive|include
file|"gzip.h"
end_include

begin_decl_stmt
name|unsigned
name|outcnt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|insize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|inptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
specifier|const
name|char
name|input_data
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
specifier|const
name|int
name|input_len
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|input_ptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|method
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|output_data
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ulong
name|output_ptr
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|makecrc
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|putstr
parameter_list|(
name|char
modifier|*
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
modifier|*
name|memcpy
parameter_list|(
name|void
modifier|*
name|to
parameter_list|,
specifier|const
name|void
modifier|*
name|from
parameter_list|,
name|unsigned
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|memcmp
parameter_list|(
specifier|const
name|void
modifier|*
name|arg1
parameter_list|,
specifier|const
name|void
modifier|*
name|arg2
parameter_list|,
name|unsigned
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|ulong
name|crc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* shift register contents */
end_comment

begin_decl_stmt
name|ulong
name|crc_32_tab
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* crc table, defined below */
end_comment

begin_comment
comment|/*  * Run a set of bytes through the crc shift register.  If s is a NULL  * pointer, then initialize the crc shift register contents instead.  * Return the current crc in either case.  */
end_comment

begin_function
name|void
name|updcrc
parameter_list|(
name|s
parameter_list|,
name|n
parameter_list|)
name|uchar
modifier|*
name|s
decl_stmt|;
comment|/* pointer to bytes to pump through */
name|unsigned
name|n
decl_stmt|;
comment|/* number of bytes in s[] */
block|{
while|while
condition|(
name|n
operator|--
condition|)
name|crc
operator|=
name|crc_32_tab
index|[
operator|(
name|uchar
operator|)
name|crc
operator|^
operator|(
operator|*
name|s
operator|++
operator|)
index|]
operator|^
operator|(
name|crc
operator|>>
literal|8
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Clear input and output buffers  */
end_comment

begin_function
name|void
name|clear_bufs
parameter_list|()
block|{
name|outcnt
operator|=
literal|0
expr_stmt|;
name|insize
operator|=
name|inptr
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Fill the input buffer. This is called only when the buffer is empty  * and at least one byte is really needed.  */
end_comment

begin_function
name|void
name|fill_inbuf
parameter_list|()
block|{
name|int
name|len
decl_stmt|,
name|i
decl_stmt|;
comment|/* Read as much as possible */
name|insize
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|len
operator|=
name|INBUFSIZ
operator|-
name|insize
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|input_len
operator|-
name|input_ptr
operator|+
literal|1
condition|)
name|len
operator|=
name|input_len
operator|-
name|input_ptr
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
break|break;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|inbuf
index|[
name|insize
operator|+
name|i
index|]
operator|=
name|input_data
index|[
name|input_ptr
operator|+
name|i
index|]
expr_stmt|;
name|insize
operator|+=
name|len
expr_stmt|;
name|input_ptr
operator|+=
name|len
expr_stmt|;
block|}
do|while
condition|(
name|insize
operator|<
name|INBUFSIZ
condition|)
do|;
if|if
condition|(
name|insize
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"unable to fill buffer"
argument_list|)
expr_stmt|;
name|inptr
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Write the output window window[0..outcnt-1] and update crc and bytes_out.  * (Used for the decompressed data only.)  */
end_comment

begin_function
name|void
name|flush_window
parameter_list|()
block|{
if|if
condition|(
name|outcnt
operator|==
literal|0
condition|)
return|return;
name|updcrc
argument_list|(
name|window
argument_list|,
name|outcnt
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|output_data
index|[
name|output_ptr
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|window
argument_list|,
name|outcnt
argument_list|)
expr_stmt|;
name|output_ptr
operator|+=
name|outcnt
expr_stmt|;
name|outcnt
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Code to compute the CRC-32 table. Borrowed from  * gzip-1.0.3/makecrc.c.  * Not copyrighted 1990 Mark Adler  */
end_comment

begin_function
name|void
name|makecrc
parameter_list|(
name|void
parameter_list|)
block|{
name|ulong
name|c
decl_stmt|;
comment|/* crc shift register */
name|ulong
name|e
decl_stmt|;
comment|/* polynomial exclusive-or pattern */
name|int
name|i
decl_stmt|;
comment|/* counter for all possible eight bit values */
name|int
name|k
decl_stmt|;
comment|/* byte being shifted into crc apparatus */
comment|/* terms of polynomial defining this crc (except x^32): */
specifier|static
specifier|const
name|uchar
name|poly
index|[]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|4
block|,
literal|5
block|,
literal|7
block|,
literal|8
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|16
block|,
literal|22
block|,
literal|23
block|,
literal|26
block|, }
decl_stmt|;
comment|/* Make exclusive-or pattern from polynomial */
name|e
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|poly
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|poly
argument_list|)
condition|;
name|i
operator|++
control|)
name|e
operator||=
literal|1L
operator|<<
operator|(
literal|31
operator|-
name|poly
index|[
name|i
index|]
operator|)
expr_stmt|;
name|crc_32_tab
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|k
operator|=
name|i
operator||
literal|256
init|;
name|k
operator|!=
literal|1
condition|;
name|k
operator|>>=
literal|1
control|)
block|{
name|c
operator|=
name|c
operator|&
literal|1
condition|?
operator|(
name|c
operator|>>
literal|1
operator|)
operator|^
name|e
else|:
name|c
operator|>>
literal|1
expr_stmt|;
if|if
condition|(
name|k
operator|&
literal|1
condition|)
name|c
operator|^=
name|e
expr_stmt|;
block|}
name|crc_32_tab
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Check the magic number of the input file and update ofname if an  * original name was given and to_stdout is not set.  * Set inptr to the offset of the next byte to be processed.  */
end_comment

begin_function
specifier|static
name|void
name|get_method
parameter_list|()
block|{
name|uchar
name|flags
decl_stmt|;
name|char
name|magic
index|[
literal|2
index|]
decl_stmt|;
comment|/* magic header */
name|magic
index|[
literal|0
index|]
operator|=
name|get_byte
argument_list|()
expr_stmt|;
name|magic
index|[
literal|1
index|]
operator|=
name|get_byte
argument_list|()
expr_stmt|;
name|method
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* unknown yet */
name|extended
operator|=
name|pkzip
operator|=
literal|0
expr_stmt|;
comment|/* assume multiple members in gzip file except for record oriented I/O */
if|if
condition|(
name|memcmp
argument_list|(
name|magic
argument_list|,
name|GZIP_MAGIC
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
operator|||
name|memcmp
argument_list|(
name|magic
argument_list|,
name|OLD_GZIP_MAGIC
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|method
operator|=
name|get_byte
argument_list|()
expr_stmt|;
name|flags
operator|=
name|get_byte
argument_list|()
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|ENCRYPTED
condition|)
name|error
argument_list|(
literal|"Input is encrypted"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|CONTINUATION
condition|)
name|error
argument_list|(
literal|"Multi part input"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|RESERVED
condition|)
name|error
argument_list|(
literal|"Input has invalid flags"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|get_byte
argument_list|()
expr_stmt|;
comment|/* Get timestamp */
operator|(
name|void
operator|)
name|get_byte
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|get_byte
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|get_byte
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|get_byte
argument_list|()
expr_stmt|;
comment|/* Ignore extra flags for the moment */
operator|(
name|void
operator|)
name|get_byte
argument_list|()
expr_stmt|;
comment|/* Ignore OS type for the moment */
if|if
condition|(
name|flags
operator|&
name|EXTRA_FIELD
condition|)
block|{
name|unsigned
name|len
init|=
name|get_byte
argument_list|()
decl_stmt|;
name|len
operator||=
name|get_byte
argument_list|()
operator|<<
literal|8
expr_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
operator|(
name|void
operator|)
name|get_byte
argument_list|()
expr_stmt|;
block|}
comment|/* Discard file comment if any */
if|if
condition|(
name|flags
operator|&
name|COMMENT
condition|)
while|while
condition|(
name|get_byte
argument_list|()
condition|)
continue|continue;
block|}
elseif|else
if|if
condition|(
name|memcmp
argument_list|(
name|magic
argument_list|,
name|PKZIP_MAGIC
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
operator|&&
name|inptr
operator|==
literal|2
operator|&&
name|memcmp
argument_list|(
name|inbuf
argument_list|,
name|PKZIP_MAGIC
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * To simplify the code, we support a zip file when alone only. 		 * We are thus guaranteed that the entire local header fits in inbuf. 		 */
name|inptr
operator|=
literal|0
expr_stmt|;
name|check_zipfile
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|memcmp
argument_list|(
name|magic
argument_list|,
name|PACK_MAGIC
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"packed input"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|memcmp
argument_list|(
name|magic
argument_list|,
name|LZW_MAGIC
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"compressed input"
argument_list|)
expr_stmt|;
if|if
condition|(
name|method
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"Corrupted input"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|decompress_kernel
parameter_list|(
name|void
modifier|*
name|dest
parameter_list|)
block|{
name|output_data
operator|=
name|dest
expr_stmt|;
name|output_ptr
operator|=
literal|0
expr_stmt|;
name|input_ptr
operator|=
literal|0
expr_stmt|;
name|clear_bufs
argument_list|()
expr_stmt|;
name|makecrc
argument_list|()
expr_stmt|;
name|get_method
argument_list|()
expr_stmt|;
name|unzip
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

