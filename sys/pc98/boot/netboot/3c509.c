begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/************************************************************************** NETBOOT -  BOOTP/TFTP Bootstrap Program  Author: Martin Renters.   Date: Mar 22 1995   This code is based heavily on David Greenman's if_ed.c driver and   Andres Vega Garcia's if_ep.c driver.   Copyright (C) 1993-1994, David Greenman, Martin Renters.  Copyright (C) 1993-1995, Andres Vega Garcia.  Copyright (C) 1995, Serge Babkin.   This software may be used, modified, copied, distributed, and sold, in   both source and binary form provided that the above copyright and these   terms are retained. Under no circumstances are the authors responsible for   the proper functioning of this software, nor do the authors assume any   responsibility for damages incurred with its use.  3c509 support added by Serge Babkin (babkin@hq.icb.chel.su)  $FreeBSD$  ***************************************************************************/
end_comment

begin_comment
comment|/* #define EDEBUG */
end_comment

begin_include
include|#
directive|include
file|"netboot.h"
end_include

begin_include
include|#
directive|include
file|"3c509.h"
end_include

begin_decl_stmt
name|short
name|aui
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|bnc
init|=
literal|0
decl_stmt|,
name|utp
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for 3C509 */
end_comment

begin_decl_stmt
name|unsigned
name|short
name|eth_nic_base
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|short
name|eth_asic_base
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|short
name|eth_base
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
name|eth_tx_start
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
name|eth_laar
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
name|eth_flags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
name|eth_vendor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
name|eth_memsize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
modifier|*
name|eth_bmem
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
modifier|*
name|eth_rmem
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
modifier|*
name|eth_node_addr
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|send_ID_sequence
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|get_eeprom_data
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|get_e
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|/************************************************************************** The following two variables are used externally ***************************************************************************/
end_comment

begin_decl_stmt
name|char
name|packet
index|[
name|ETHER_MAX_LEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|packetlen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*********************** Name of driver *********************************/
end_comment

begin_decl_stmt
name|char
name|eth_driver
index|[]
init|=
literal|"ep0"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/************************************************************************** ETH_PROBE - Look for an adapter ***************************************************************************/
end_comment

begin_macro
name|eth_probe
argument_list|()
end_macro

begin_block
block|{
comment|/* common variables */
name|int
name|i
decl_stmt|;
comment|/* variables for 3C509 */
name|int
name|data
decl_stmt|,
name|j
decl_stmt|,
name|io_base
decl_stmt|,
name|id_port
init|=
name|EP_ID_PORT
decl_stmt|;
name|int
name|nisa
init|=
literal|0
decl_stmt|,
name|neisa
init|=
literal|0
decl_stmt|;
name|u_short
name|k
decl_stmt|;
name|int
name|ep_current_tag
init|=
name|EP_LAST_TAG
operator|+
literal|1
decl_stmt|;
name|short
modifier|*
name|p
decl_stmt|;
name|eth_vendor
operator|=
name|VENDOR_NONE
expr_stmt|;
comment|/********************************************************* 			Search for 3Com 509 card 	***********************************************************/
comment|/* Look for the EISA boards, leave them activated */
comment|/* search for the first card, ignore all others */
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
literal|16
operator|&&
name|eth_vendor
operator|==
name|VENDOR_NONE
condition|;
name|j
operator|++
control|)
block|{
name|io_base
operator|=
operator|(
name|j
operator|*
name|EP_EISA_START
operator|)
operator||
name|EP_EISA_W0
expr_stmt|;
if|if
condition|(
name|inw
argument_list|(
name|io_base
operator|+
name|EP_W0_MFG_ID
argument_list|)
operator|!=
name|MFG_ID
condition|)
continue|continue;
comment|/* we must found 0x1f if the board is EISA configurated */
if|if
condition|(
operator|(
name|inw
argument_list|(
name|io_base
operator|+
name|EP_W0_ADDRESS_CFG
argument_list|)
operator|&
literal|0x1f
operator|)
operator|!=
literal|0x1f
condition|)
continue|continue;
comment|/* Reset and Enable the card */
name|outb
argument_list|(
name|io_base
operator|+
name|EP_W0_CONFIG_CTRL
argument_list|,
name|W0_P4_CMD_RESET_ADAPTER
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* we must wait at least 1 ms */
name|outb
argument_list|(
name|io_base
operator|+
name|EP_W0_CONFIG_CTRL
argument_list|,
name|W0_P4_CMD_ENABLE_ADAPTER
argument_list|)
expr_stmt|;
comment|/* 			 * Once activated, all the registers are mapped in the range 			 * x000 - x00F, where x is the slot number. 			 */
name|eth_base
operator|=
name|j
operator|*
name|EP_EISA_START
expr_stmt|;
name|eth_vendor
operator|=
name|VENDOR_3C509
expr_stmt|;
block|}
name|ep_current_tag
operator|--
expr_stmt|;
comment|/* Look for the ISA boards. Init and leave them actived */
comment|/* search for the first card, ignore all others */
name|outb
argument_list|(
name|id_port
argument_list|,
literal|0xc0
argument_list|)
expr_stmt|;
comment|/* Global reset */
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|EP_MAX_BOARDS
operator|&&
name|eth_vendor
operator|==
name|VENDOR_NONE
condition|;
name|i
operator|++
control|)
block|{
name|outb
argument_list|(
name|id_port
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|id_port
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_ID_sequence
argument_list|(
name|id_port
argument_list|)
expr_stmt|;
name|data
operator|=
name|get_eeprom_data
argument_list|(
name|id_port
argument_list|,
name|EEPROM_MFG_ID
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|!=
name|MFG_ID
condition|)
break|break;
comment|/* resolve contention using the Ethernet address */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|3
condition|;
name|j
operator|++
control|)
name|data
operator|=
name|get_eeprom_data
argument_list|(
name|id_port
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|eth_base
operator|=
operator|(
name|get_eeprom_data
argument_list|(
name|id_port
argument_list|,
name|EEPROM_ADDR_CFG
argument_list|)
operator|&
literal|0x1f
operator|)
operator|*
literal|0x10
operator|+
literal|0x200
expr_stmt|;
name|outb
argument_list|(
name|id_port
argument_list|,
name|ep_current_tag
argument_list|)
expr_stmt|;
comment|/* tags board */
name|outb
argument_list|(
name|id_port
argument_list|,
name|ACTIVATE_ADAPTER_TO_CONFIG
argument_list|)
expr_stmt|;
name|eth_vendor
operator|=
name|VENDOR_3C509
expr_stmt|;
name|ep_current_tag
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|eth_vendor
operator|!=
name|VENDOR_3C509
condition|)
goto|goto
name|no3c509
goto|;
comment|/* 	* The iobase was found and MFG_ID was 0x6d50. PROD_ID should be 	* 0x9[0-f]50 	*/
name|GO_WINDOW
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|k
operator|=
name|get_e
argument_list|(
name|EEPROM_PROD_ID
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|k
operator|&
literal|0xf0ff
operator|)
operator|!=
operator|(
name|PROD_ID
operator|&
literal|0xf0ff
operator|)
condition|)
goto|goto
name|no3c509
goto|;
if|if
condition|(
name|eth_base
operator|>=
name|EP_EISA_START
condition|)
block|{
name|printf
argument_list|(
literal|"3C5x9 board on EISA at 0x%x - "
argument_list|,
name|eth_base
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"3C5x9 board on ISA at 0x%x - "
argument_list|,
name|eth_base
argument_list|)
expr_stmt|;
block|}
comment|/* test for presence of connectors */
name|i
operator|=
name|inw
argument_list|(
name|IS_BASE
operator|+
name|EP_W0_CONFIG_CTRL
argument_list|)
expr_stmt|;
name|j
operator|=
name|inw
argument_list|(
name|IS_BASE
operator|+
name|EP_W0_ADDRESS_CFG
argument_list|)
operator|>>
literal|14
expr_stmt|;
switch|switch
condition|(
name|j
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
name|i
operator|&
name|IS_UTP
condition|)
block|{
name|printf
argument_list|(
literal|"10baseT\r\n"
argument_list|)
expr_stmt|;
name|utp
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"10baseT not present\r\n"
argument_list|)
expr_stmt|;
name|eth_vendor
operator|=
name|VENDOR_NONE
expr_stmt|;
goto|goto
name|no3c509
goto|;
block|}
break|break;
case|case
literal|1
case|:
if|if
condition|(
name|i
operator|&
name|IS_AUI
condition|)
name|printf
argument_list|(
literal|"10base5\r\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"10base5 not present\r\n"
argument_list|)
expr_stmt|;
name|eth_vendor
operator|=
name|VENDOR_NONE
expr_stmt|;
goto|goto
name|no3c509
goto|;
block|}
break|break;
case|case
literal|3
case|:
if|if
condition|(
name|i
operator|&
name|IS_BNC
condition|)
block|{
name|printf
argument_list|(
literal|"10base2\r\n"
argument_list|)
expr_stmt|;
name|bnc
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"10base2 not present\r\n"
argument_list|)
expr_stmt|;
name|eth_vendor
operator|=
name|VENDOR_NONE
expr_stmt|;
goto|goto
name|no3c509
goto|;
block|}
break|break;
default|default:
name|printf
argument_list|(
literal|"unknown connector\r\n"
argument_list|)
expr_stmt|;
name|eth_vendor
operator|=
name|VENDOR_NONE
expr_stmt|;
goto|goto
name|no3c509
goto|;
block|}
comment|/* 	* Read the station address from the eeprom 	*/
name|p
operator|=
operator|(
name|u_short
operator|*
operator|)
name|arptable
index|[
name|ARP_CLIENT
index|]
operator|.
name|node
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|GO_WINDOW
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|p
index|[
name|i
index|]
operator|=
name|htons
argument_list|(
name|get_e
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|GO_WINDOW
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_W2_ADDR_0
operator|+
operator|(
name|i
operator|*
literal|2
operator|)
argument_list|,
name|ntohs
argument_list|(
name|p
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"Ethernet address: "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"%b:"
argument_list|,
name|arptable
index|[
name|ARP_CLIENT
index|]
operator|.
name|node
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%b\n"
argument_list|,
name|arptable
index|[
name|ARP_CLIENT
index|]
operator|.
name|node
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|eth_node_addr
operator|=
name|arptable
index|[
name|ARP_CLIENT
index|]
operator|.
name|node
expr_stmt|;
name|eth_reset
argument_list|()
expr_stmt|;
return|return
name|eth_vendor
return|;
name|no3c509
label|:
name|eth_vendor
operator|=
name|VENDOR_NONE
expr_stmt|;
return|return
name|VENDOR_NONE
return|;
block|}
end_block

begin_comment
comment|/************************************************************************** ETH_RESET - Reset adapter ***************************************************************************/
end_comment

begin_macro
name|eth_reset
argument_list|()
end_macro

begin_block
block|{
name|int
name|s
decl_stmt|,
name|i
decl_stmt|;
comment|/*********************************************************** 			Reset 3Com 509 card 	*************************************************************/
if|if
condition|(
name|eth_vendor
operator|!=
name|VENDOR_3C509
condition|)
goto|goto
name|no3c509
goto|;
comment|/* stop card */
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|RX_DISABLE
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|RX_DISCARD_TOP_PACK
argument_list|)
expr_stmt|;
while|while
condition|(
name|inw
argument_list|(
name|BASE
operator|+
name|EP_STATUS
argument_list|)
operator|&
name|S_COMMAND_IN_PROGRESS
condition|)
empty_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|TX_DISABLE
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|STOP_TRANSCEIVER
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|RX_RESET
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|TX_RESET
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|C_INTR_LATCH
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|SET_RD_0_MASK
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|SET_INTR_MASK
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|SET_RX_FILTER
argument_list|)
expr_stmt|;
comment|/* 	/* initialize card 	*/
while|while
condition|(
name|inw
argument_list|(
name|BASE
operator|+
name|EP_STATUS
argument_list|)
operator|&
name|S_COMMAND_IN_PROGRESS
condition|)
empty_stmt|;
name|GO_WINDOW
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Disable the card */
name|outw
argument_list|(
name|BASE
operator|+
name|EP_W0_CONFIG_CTRL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Configure IRQ to none */
name|outw
argument_list|(
name|BASE
operator|+
name|EP_W0_RESOURCE_CFG
argument_list|,
name|SET_IRQ
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Enable the card */
name|outw
argument_list|(
name|BASE
operator|+
name|EP_W0_CONFIG_CTRL
argument_list|,
name|ENABLE_DRQ_IRQ
argument_list|)
expr_stmt|;
name|GO_WINDOW
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* Reload the ether_addr. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
name|outb
argument_list|(
name|BASE
operator|+
name|EP_W2_ADDR_0
operator|+
name|i
argument_list|,
name|arptable
index|[
name|ARP_CLIENT
index|]
operator|.
name|node
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|RX_RESET
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|TX_RESET
argument_list|)
expr_stmt|;
comment|/* Window 1 is operating window */
name|GO_WINDOW
argument_list|(
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|31
condition|;
name|i
operator|++
control|)
name|inb
argument_list|(
name|BASE
operator|+
name|EP_W1_TX_STATUS
argument_list|)
expr_stmt|;
comment|/* get rid of stray intr's */
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|ACK_INTR
operator||
literal|0xff
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|SET_RD_0_MASK
operator||
name|S_5_INTS
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|SET_INTR_MASK
operator||
name|S_5_INTS
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|SET_RX_FILTER
operator||
name|FIL_INDIVIDUAL
operator||
name|FIL_BRDCST
argument_list|)
expr_stmt|;
comment|/* configure BNC */
if|if
condition|(
name|bnc
condition|)
block|{
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|START_TRANSCEIVER
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
comment|/* configure UTP */
if|if
condition|(
name|utp
condition|)
block|{
name|GO_WINDOW
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_W4_MEDIA_TYPE
argument_list|,
name|ENABLE_UTP
argument_list|)
expr_stmt|;
name|GO_WINDOW
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* start tranciever and receiver */
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|RX_ENABLE
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|TX_ENABLE
argument_list|)
expr_stmt|;
comment|/* set early threshold for minimal packet length */
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|SET_RX_EARLY_THRESH
operator||
literal|64
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|SET_TX_START_THRESH
operator||
literal|16
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
name|no3c509
label|:
block|}
end_block

begin_comment
comment|/************************************************************************** ETH_TRANSMIT - Transmit a frame ***************************************************************************/
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|padmap
index|[]
init|=
block|{
literal|0
block|,
literal|3
block|,
literal|2
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|eth_transmit
argument_list|(
argument|d
argument_list|,
argument|t
argument_list|,
argument|s
argument_list|,
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|d
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Destination */
end_comment

begin_decl_stmt
name|unsigned
name|short
name|t
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Type */
end_comment

begin_decl_stmt
name|unsigned
name|short
name|s
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size */
end_comment

begin_decl_stmt
name|char
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Packet */
end_comment

begin_block
block|{
specifier|register
name|u_int
name|len
decl_stmt|;
name|int
name|pad
decl_stmt|;
name|int
name|status
decl_stmt|;
name|unsigned
name|char
name|c
decl_stmt|;
if|if
condition|(
name|eth_vendor
operator|!=
name|VENDOR_3C509
condition|)
goto|goto
name|no3c509
goto|;
ifdef|#
directive|ifdef
name|EDEBUG
name|printf
argument_list|(
literal|"{l=%d,t=%x}"
argument_list|,
name|s
operator|+
literal|14
argument_list|,
name|t
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* swap bytes of type */
name|t
operator|=
operator|(
operator|(
name|t
operator|&
literal|0xFF
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|t
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
operator|)
expr_stmt|;
name|len
operator|=
name|s
operator|+
literal|14
expr_stmt|;
comment|/* actual length of packet */
name|pad
operator|=
name|padmap
index|[
name|len
operator|&
literal|3
index|]
expr_stmt|;
comment|/* 	* The 3c509 automatically pads short packets to minimum ethernet length, 	* but we drop packets that are too large. Perhaps we should truncate 	* them instead? 	*/
if|if
condition|(
name|len
operator|+
name|pad
operator|>
name|ETHER_MAX_LEN
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|/* drop acknowledgements */
while|while
condition|(
operator|(
name|status
operator|=
name|inb
argument_list|(
name|BASE
operator|+
name|EP_W1_TX_STATUS
argument_list|)
operator|)
operator|&
name|TXS_COMPLETE
condition|)
block|{
if|if
condition|(
name|status
operator|&
operator|(
name|TXS_UNDERRUN
operator||
name|TXS_MAX_COLLISION
operator||
name|TXS_STATUS_OVERFLOW
operator|)
condition|)
block|{
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|TX_RESET
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|TX_ENABLE
argument_list|)
expr_stmt|;
block|}
name|outb
argument_list|(
name|BASE
operator|+
name|EP_W1_TX_STATUS
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|inw
argument_list|(
name|BASE
operator|+
name|EP_W1_FREE_TX
argument_list|)
operator|<
name|len
operator|+
name|pad
operator|+
literal|4
condition|)
block|{
comment|/* no room in FIFO */
block|}
name|outw
argument_list|(
name|BASE
operator|+
name|EP_W1_TX_PIO_WR_1
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_W1_TX_PIO_WR_1
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
comment|/* Second dword meaningless */
comment|/* write packet */
name|outsw
argument_list|(
name|BASE
operator|+
name|EP_W1_TX_PIO_WR_1
argument_list|,
name|d
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|outsw
argument_list|(
name|BASE
operator|+
name|EP_W1_TX_PIO_WR_1
argument_list|,
name|eth_node_addr
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_W1_TX_PIO_WR_1
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|outsw
argument_list|(
name|BASE
operator|+
name|EP_W1_TX_PIO_WR_1
argument_list|,
name|p
argument_list|,
name|s
operator|/
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|&
literal|1
condition|)
name|outb
argument_list|(
name|BASE
operator|+
name|EP_W1_TX_PIO_WR_1
argument_list|,
operator|*
operator|(
name|p
operator|+
name|s
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|pad
operator|--
condition|)
name|outb
argument_list|(
name|BASE
operator|+
name|EP_W1_TX_PIO_WR_1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Padding */
comment|/* timeout after sending */
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|no3c509
label|:
block|}
end_block

begin_comment
comment|/************************************************************************** ETH_POLL - Wait for a frame ***************************************************************************/
end_comment

begin_macro
name|eth_poll
argument_list|()
end_macro

begin_block
block|{
comment|/* common variables */
name|unsigned
name|short
name|type
init|=
literal|0
decl_stmt|;
name|unsigned
name|short
name|len
decl_stmt|;
comment|/* variables for 3C509 */
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|int
name|lenthisone
decl_stmt|;
name|short
name|rx_fifo2
decl_stmt|,
name|status
decl_stmt|,
name|cst
decl_stmt|;
specifier|register
name|short
name|rx_fifo
decl_stmt|;
if|if
condition|(
name|eth_vendor
operator|!=
name|VENDOR_3C509
condition|)
goto|goto
name|no3c509
goto|;
name|cst
operator|=
name|inw
argument_list|(
name|BASE
operator|+
name|EP_STATUS
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EDEBUG
if|if
condition|(
name|cst
operator|&
literal|0x1FFF
condition|)
name|printf
argument_list|(
literal|"-%x-"
argument_list|,
name|cst
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|cst
operator|&
operator|(
name|S_RX_COMPLETE
operator||
name|S_RX_EARLY
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* acknowledge  everything */
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|ACK_INTR
operator||
operator|(
name|cst
operator|&
name|S_5_INTS
operator|)
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|C_INTR_LATCH
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|status
operator|=
name|inw
argument_list|(
name|BASE
operator|+
name|EP_W1_RX_STATUS
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EDEBUG
name|printf
argument_list|(
literal|"*%x*"
argument_list|,
name|status
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|status
operator|&
name|ERR_RX
condition|)
block|{
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|RX_DISCARD_TOP_PACK
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|rx_fifo
operator|=
name|status
operator|&
name|RX_BYTES_MASK
expr_stmt|;
if|if
condition|(
name|rx_fifo
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* read packet */
ifdef|#
directive|ifdef
name|EDEBUG
name|printf
argument_list|(
literal|"[l=%d"
argument_list|,
name|rx_fifo
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|insw
argument_list|(
name|BASE
operator|+
name|EP_W1_RX_PIO_RD_1
argument_list|,
name|packet
argument_list|,
name|rx_fifo
operator|/
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|rx_fifo
operator|&
literal|1
condition|)
name|packet
index|[
name|rx_fifo
operator|-
literal|1
index|]
operator|=
name|inb
argument_list|(
name|BASE
operator|+
name|EP_W1_RX_PIO_RD_1
argument_list|)
expr_stmt|;
name|packetlen
operator|=
name|rx_fifo
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|status
operator|=
name|inw
argument_list|(
name|BASE
operator|+
name|EP_W1_RX_STATUS
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EDEBUG
name|printf
argument_list|(
literal|"*%x*"
argument_list|,
name|status
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rx_fifo
operator|=
name|status
operator|&
name|RX_BYTES_MASK
expr_stmt|;
if|if
condition|(
name|rx_fifo
operator|>
literal|0
condition|)
block|{
name|insw
argument_list|(
name|BASE
operator|+
name|EP_W1_RX_PIO_RD_1
argument_list|,
name|packet
operator|+
name|packetlen
argument_list|,
name|rx_fifo
operator|/
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|rx_fifo
operator|&
literal|1
condition|)
name|packet
index|[
name|packetlen
operator|+
name|rx_fifo
operator|-
literal|1
index|]
operator|=
name|inb
argument_list|(
name|BASE
operator|+
name|EP_W1_RX_PIO_RD_1
argument_list|)
expr_stmt|;
name|packetlen
operator|+=
name|rx_fifo
expr_stmt|;
ifdef|#
directive|ifdef
name|EDEBUG
name|printf
argument_list|(
literal|"+%d"
argument_list|,
name|rx_fifo
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
operator|(
name|status
operator|&
name|RX_INCOMPLETE
operator|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|EDEBUG
name|printf
argument_list|(
literal|"=%d"
argument_list|,
name|packetlen
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
comment|/* acknowledge reception of packet */
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|RX_DISCARD_TOP_PACK
argument_list|)
expr_stmt|;
while|while
condition|(
name|inw
argument_list|(
name|BASE
operator|+
name|EP_STATUS
argument_list|)
operator|&
name|S_COMMAND_IN_PROGRESS
condition|)
empty_stmt|;
name|type
operator|=
operator|(
name|packet
index|[
literal|12
index|]
operator|<<
literal|8
operator|)
operator||
name|packet
index|[
literal|13
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|EDEBUG
if|if
condition|(
name|packet
index|[
literal|0
index|]
operator|+
name|packet
index|[
literal|1
index|]
operator|+
name|packet
index|[
literal|2
index|]
operator|+
name|packet
index|[
literal|3
index|]
operator|+
name|packet
index|[
literal|4
index|]
operator|+
name|packet
index|[
literal|5
index|]
operator|==
literal|0xFF
operator|*
literal|6
condition|)
name|printf
argument_list|(
literal|",t=0x%x,b]"
argument_list|,
name|type
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|",t=0x%x]"
argument_list|,
name|type
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|type
operator|==
name|ARP
condition|)
block|{
name|struct
name|arprequest
modifier|*
name|arpreq
decl_stmt|;
name|unsigned
name|long
name|reqip
decl_stmt|;
name|arpreq
operator|=
operator|(
expr|struct
name|arprequest
operator|*
operator|)
operator|&
name|packet
index|[
name|ETHER_HDR_LEN
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|EDEBUG
name|printf
argument_list|(
literal|"(ARP %I->%I)"
argument_list|,
name|ntohl
argument_list|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arpreq
operator|->
name|sipaddr
argument_list|)
argument_list|,
name|ntohl
argument_list|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arpreq
operator|->
name|tipaddr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|convert_ipaddr
argument_list|(
operator|&
name|reqip
argument_list|,
name|arpreq
operator|->
name|tipaddr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ntohs
argument_list|(
name|arpreq
operator|->
name|opcode
argument_list|)
operator|==
name|ARP_REQUEST
operator|)
operator|&&
operator|(
name|reqip
operator|==
name|arptable
index|[
name|ARP_CLIENT
index|]
operator|.
name|ipaddr
operator|)
condition|)
block|{
name|arpreq
operator|->
name|opcode
operator|=
name|htons
argument_list|(
name|ARP_REPLY
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|arpreq
operator|->
name|sipaddr
argument_list|,
name|arpreq
operator|->
name|tipaddr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|arpreq
operator|->
name|shwaddr
argument_list|,
name|arpreq
operator|->
name|thwaddr
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|arptable
index|[
name|ARP_CLIENT
index|]
operator|.
name|node
argument_list|,
name|arpreq
operator|->
name|shwaddr
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|convert_ipaddr
argument_list|(
name|arpreq
operator|->
name|sipaddr
argument_list|,
operator|&
name|reqip
argument_list|)
expr_stmt|;
name|eth_transmit
argument_list|(
name|arpreq
operator|->
name|thwaddr
argument_list|,
name|ARP
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|arprequest
argument_list|)
argument_list|,
name|arpreq
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|IP
condition|)
block|{
name|struct
name|iphdr
modifier|*
name|iph
decl_stmt|;
name|iph
operator|=
operator|(
expr|struct
name|iphdr
operator|*
operator|)
operator|&
name|packet
index|[
name|ETHER_HDR_LEN
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|EDEBUG
name|printf
argument_list|(
literal|"(IP %I-%d->%I)"
argument_list|,
name|ntohl
argument_list|(
operator|*
operator|(
name|int
operator|*
operator|)
name|iph
operator|->
name|src
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|iph
operator|->
name|protocol
argument_list|)
argument_list|,
name|ntohl
argument_list|(
operator|*
operator|(
name|int
operator|*
operator|)
name|iph
operator|->
name|dest
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
literal|1
return|;
name|no3c509
label|:
block|}
end_block

begin_comment
comment|/************************************************************************* 	3Com 509 - specific routines **************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|eeprom_rdy
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|is_eeprom_busy
argument_list|(
name|IS_BASE
argument_list|)
operator|&&
name|i
operator|<
name|MAX_EEPROMBUSY
condition|;
name|i
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|i
operator|>=
name|MAX_EEPROMBUSY
condition|)
block|{
name|printf
argument_list|(
literal|"3c509: eeprom failed to come ready.\r\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * get_e: gets a 16 bits word from the EEPROM. we must have set the window  * before  */
end_comment

begin_function
specifier|static
name|int
name|get_e
parameter_list|(
name|offset
parameter_list|)
name|int
name|offset
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|eeprom_rdy
argument_list|()
condition|)
return|return
operator|(
literal|0xffff
operator|)
return|;
name|outw
argument_list|(
name|IS_BASE
operator|+
name|EP_W0_EEPROM_COMMAND
argument_list|,
name|EEPROM_CMD_RD
operator||
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eeprom_rdy
argument_list|()
condition|)
return|return
operator|(
literal|0xffff
operator|)
return|;
return|return
operator|(
name|inw
argument_list|(
name|IS_BASE
operator|+
name|EP_W0_EEPROM_DATA
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|send_ID_sequence
parameter_list|(
name|port
parameter_list|)
name|int
name|port
decl_stmt|;
block|{
name|int
name|cx
decl_stmt|,
name|al
decl_stmt|;
for|for
control|(
name|al
operator|=
literal|0xff
operator|,
name|cx
operator|=
literal|0
init|;
name|cx
operator|<
literal|255
condition|;
name|cx
operator|++
control|)
block|{
name|outb
argument_list|(
name|port
argument_list|,
name|al
argument_list|)
expr_stmt|;
name|al
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|al
operator|&
literal|0x100
condition|)
name|al
operator|^=
literal|0xcf
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * We get eeprom data from the id_port given an offset into the eeprom.  * Basically; after the ID_sequence is sent to all of the cards; they enter  * the ID_CMD state where they will accept command requests. 0x80-0xbf loads  * the eeprom data.  We then read the port 16 times and with every read; the  * cards check for contention (ie: if one card writes a 0 bit and another  * writes a 1 bit then the host sees a 0. At the end of the cycle; each card  * compares the data on the bus; if there is a difference then that card goes  * into ID_WAIT state again). In the meantime; one bit of data is returned in  * the AX register which is conveniently returned to us by inb().  Hence; we  * read 16 times getting one bit of data with each read.  */
end_comment

begin_function
specifier|static
name|int
name|get_eeprom_data
parameter_list|(
name|id_port
parameter_list|,
name|offset
parameter_list|)
name|int
name|id_port
decl_stmt|;
name|int
name|offset
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|data
init|=
literal|0
decl_stmt|;
name|outb
argument_list|(
name|id_port
argument_list|,
literal|0x80
operator|+
name|offset
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
name|data
operator|=
operator|(
name|data
operator|<<
literal|1
operator|)
operator||
operator|(
name|inw
argument_list|(
name|id_port
argument_list|)
operator|&
literal|1
operator|)
expr_stmt|;
return|return
operator|(
name|data
operator|)
return|;
block|}
end_function

begin_comment
comment|/* a surrogate */
end_comment

begin_macro
name|DELAY
argument_list|(
argument|val
argument_list|)
end_macro

begin_block
block|{
name|int
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|val
condition|;
name|c
operator|+=
literal|20
control|)
block|{
name|twiddle
argument_list|()
expr_stmt|;
block|}
block|}
end_block

end_unit

