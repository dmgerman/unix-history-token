begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * TODO:  * [1] integrate into current if_ed.c  * [2] parse tuples to find out where to map the shared memory buffer,  *     and what to write into the configuration register  * [3] move pcic-specific code into a separate module.  *  * Device driver for IBM PCMCIA Credit Card Adapter for Ethernet,  * if_ze.c  *  * Based on the Device driver for National Semiconductor DS8390 ethernet  * adapters by David Greenman.  Modifications for PCMCIA by Keith Moore.  * Adapted for FreeBSD 1.1.5 by Jordan Hubbard.  *  * Currently supports only the IBM Credit Card Adapter for Ethernet, but  * could probably work with other PCMCIA cards also, if it were modified  * to get the locations of the PCMCIA configuration option register (COR)  * by parsing the configuration tuples, rather than by hard-coding in  * the value expected by IBM's card.  *  * Sources for data on the PCMCIA/IBM CCAE specific portions of the driver:  *  * [1] _Local Area Network Credit Card Adapters Technical Reference_,  *     IBM Corp., SC30-3585-00, part # 33G9243.  * [2] "pre-alpha" PCMCIA support code for Linux by Barry Jaspan.  * [3] Intel 82536SL PC Card Interface Controller Data Sheet, Intel  *     Order Number 290423-002  * [4] National Semiconductor DP83902A ST-NIC (tm) Serial Network  *     Interface Controller for Twisted Pair data sheet.  *  *  * Copyright (C) 1993, David Greenman. This software may be used, modified,  *   copied, distributed, and sold, in both source and binary form provided  *   that the above copyright and these terms are retained. Under no  *   circumstances is the author responsible for the proper functioning  *   of this software, nor does the author assume any responsibility  *   for damages incurred with its use.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|PC98
end_ifdef

begin_include
include|#
directive|include
file|<pc98/pc98/pc98_device.h>
end_include

begin_include
include|#
directive|include
file|<pc98/pc98/pcic.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/pcic.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * map a portion of the card's memory space into system memory  * space.  *  * slot = # of the slot the card is plugged into  * window = which pcic memory map registers to use (0..4)  * sys_addr = base system PHYSICAL memory address where we want it.  must  *	      be on an appropriate boundary (lower 12 bits are zero).  * card_addr = the base address of the card's memory to correspond  *             to sys_addr  * length = length of the segment to map (may be rounded up as necessary)  * type = which card memory space to map (attribute or shared)  * width = 1 for byte-wide mapping; 2 for word (16-bit) mapping.  */
end_comment

begin_function
name|void
name|pcic_map_memory
parameter_list|(
name|int
name|slot
parameter_list|,
name|int
name|window
parameter_list|,
name|unsigned
name|long
name|sys_addr
parameter_list|,
name|unsigned
name|long
name|card_addr
parameter_list|,
name|unsigned
name|long
name|length
parameter_list|,
name|enum
name|memtype
name|type
parameter_list|,
name|int
name|width
parameter_list|)
block|{
name|unsigned
name|short
name|offset
decl_stmt|;
name|unsigned
name|short
name|mem_start_addr
decl_stmt|;
name|unsigned
name|short
name|mem_stop_addr
decl_stmt|;
name|sys_addr
operator|>>=
literal|12
expr_stmt|;
name|card_addr
operator|>>=
literal|12
expr_stmt|;
name|length
operator|>>=
literal|12
expr_stmt|;
comment|/*      * compute an offset for the chip such that      * (sys_addr + offset) = card_addr      * but the arithmetic is done modulo 2^14      */
name|offset
operator|=
operator|(
name|card_addr
operator|-
name|sys_addr
operator|)
operator|&
literal|0x3FFF
expr_stmt|;
comment|/*      * now OR in the bit for "attribute memory" if necessary      */
if|if
condition|(
name|type
operator|==
name|ATTRIBUTE
condition|)
block|{
name|offset
operator||=
operator|(
name|PCIC_REG
operator|<<
literal|8
operator|)
expr_stmt|;
comment|/* REG == "region active" pin on card */
block|}
comment|/*      * okay, set up the chip memory mapping registers, and turn      * on the enable bit for this window.      * if we are doing 16-bit wide accesses (width == 2),      * turn on the appropriate bit.      *      * XXX for now, we set all of the wait state bits to zero.      * Not really sure how they should be set.      */
name|mem_start_addr
operator|=
name|sys_addr
operator|&
literal|0xFFF
expr_stmt|;
if|if
condition|(
name|width
operator|==
literal|2
condition|)
name|mem_start_addr
operator||=
operator|(
name|PCIC_DATA16
operator|<<
literal|8
operator|)
expr_stmt|;
name|mem_stop_addr
operator|=
operator|(
name|sys_addr
operator|+
name|length
operator|)
operator|&
literal|0xFFF
expr_stmt|;
name|pcic_putw
argument_list|(
name|slot
argument_list|,
name|MEM_START_ADDR
argument_list|(
name|window
argument_list|)
argument_list|,
name|mem_start_addr
argument_list|)
expr_stmt|;
name|pcic_putw
argument_list|(
name|slot
argument_list|,
name|MEM_STOP_ADDR
argument_list|(
name|window
argument_list|)
argument_list|,
name|mem_stop_addr
argument_list|)
expr_stmt|;
name|pcic_putw
argument_list|(
name|slot
argument_list|,
name|MEM_OFFSET
argument_list|(
name|window
argument_list|)
argument_list|,
name|offset
argument_list|)
expr_stmt|;
comment|/*      * Assert the bit (PCIC_MEMCS16) that says to decode all of      * the address lines.      */
name|pcic_putb
argument_list|(
name|slot
argument_list|,
name|PCIC_ADDRWINE
argument_list|,
name|pcic_getb
argument_list|(
name|slot
argument_list|,
name|PCIC_ADDRWINE
argument_list|)
operator||
name|MEM_ENABLE_BIT
argument_list|(
name|window
argument_list|)
operator||
name|PCIC_MEMCS16
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pcic_unmap_memory
parameter_list|(
name|int
name|slot
parameter_list|,
name|int
name|window
parameter_list|)
block|{
comment|/*      * seems like we need to turn off the enable bit first, after which      * we can clear the registers out just to be sure.      */
name|pcic_putb
argument_list|(
name|slot
argument_list|,
name|PCIC_ADDRWINE
argument_list|,
name|pcic_getb
argument_list|(
name|slot
argument_list|,
name|PCIC_ADDRWINE
argument_list|)
operator|&
operator|~
name|MEM_ENABLE_BIT
argument_list|(
name|window
argument_list|)
argument_list|)
expr_stmt|;
name|pcic_putw
argument_list|(
name|slot
argument_list|,
name|MEM_START_ADDR
argument_list|(
name|window
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pcic_putw
argument_list|(
name|slot
argument_list|,
name|MEM_STOP_ADDR
argument_list|(
name|window
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pcic_putw
argument_list|(
name|slot
argument_list|,
name|MEM_OFFSET
argument_list|(
name|window
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * map a range of addresses into system i/o space  * (no translation of i/o addresses is possible)  *  * 'width' is:  * + 0 to tell the PCIC to generate the ISA IOCS16* signal from  *   the PCMCIA IOIS16* signal.  * + 1 to select 8-bit width  * + 2 to select 16-bit width  */
end_comment

begin_function
name|void
name|pcic_map_io
parameter_list|(
name|int
name|slot
parameter_list|,
name|int
name|window
parameter_list|,
name|unsigned
name|short
name|base
parameter_list|,
name|unsigned
name|short
name|length
parameter_list|,
name|unsigned
name|short
name|width
parameter_list|)
block|{
name|unsigned
name|char
name|x
decl_stmt|;
name|pcic_putw
argument_list|(
name|slot
argument_list|,
name|IO_START_ADDR
argument_list|(
name|window
argument_list|)
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|pcic_putw
argument_list|(
name|slot
argument_list|,
name|IO_STOP_ADDR
argument_list|(
name|window
argument_list|)
argument_list|,
name|base
operator|+
name|length
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/*      * select the bits that determine whether      * an i/o operation is 8 or 16 bits wide      */
name|x
operator|=
name|pcic_getb
argument_list|(
name|slot
argument_list|,
name|PCIC_IOCTL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|width
condition|)
block|{
case|case
literal|0
case|:
comment|/* PCMCIA card decides */
if|if
condition|(
name|window
condition|)
name|x
operator|=
operator|(
name|x
operator|&
literal|0xf0
operator|)
operator||
name|PCIC_IO1_CS16
expr_stmt|;
else|else
name|x
operator|=
operator|(
name|x
operator|&
literal|0x0f
operator|)
operator||
name|PCIC_IO0_CS16
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* 8 bits wide */
break|break;
case|case
literal|2
case|:
comment|/* 16 bits wide */
if|if
condition|(
name|window
condition|)
name|x
operator|=
operator|(
name|x
operator|&
literal|0xf0
operator|)
operator||
name|PCIC_IO1_16BIT
expr_stmt|;
else|else
name|x
operator|=
operator|(
name|x
operator|&
literal|0x0f
operator|)
operator||
name|PCIC_IO0_16BIT
expr_stmt|;
break|break;
block|}
name|pcic_putb
argument_list|(
name|slot
argument_list|,
name|PCIC_IOCTL
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|pcic_putb
argument_list|(
name|slot
argument_list|,
name|PCIC_ADDRWINE
argument_list|,
name|pcic_getb
argument_list|(
name|slot
argument_list|,
name|PCIC_ADDRWINE
argument_list|)
operator||
name|IO_ENABLE_BIT
argument_list|(
name|window
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TEST
end_ifdef

begin_function
name|void
name|pcic_unmap_io
parameter_list|(
name|int
name|slot
parameter_list|,
name|int
name|window
parameter_list|)
block|{
name|pcic_putb
argument_list|(
name|slot
argument_list|,
name|PCIC_ADDRWINE
argument_list|,
name|pcic_getb
argument_list|(
name|slot
argument_list|,
name|PCIC_ADDRWINE
argument_list|)
operator|&
operator|~
name|IO_ENABLE_BIT
argument_list|(
name|window
argument_list|)
argument_list|)
expr_stmt|;
name|pcic_putw
argument_list|(
name|slot
argument_list|,
name|IO_START_ADDR
argument_list|(
name|window
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pcic_putw
argument_list|(
name|slot
argument_list|,
name|IO_STOP_ADDR
argument_list|(
name|window
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TEST */
end_comment

begin_comment
comment|/*  * tell the PCIC which irq we want to use.  only the following are legal:  * 3, 4, 5, 7, 9, 10, 11, 12, 14, 15  *  * NB: 'irq' is an interrupt NUMBER, not a MASK as in struct isa_device.  */
end_comment

begin_function
name|void
name|pcic_map_irq
parameter_list|(
name|int
name|slot
parameter_list|,
name|int
name|irq
parameter_list|)
block|{
if|if
condition|(
name|irq
operator|<
literal|3
operator|||
name|irq
operator|==
literal|6
operator|||
name|irq
operator|==
literal|8
operator|||
name|irq
operator|==
literal|13
operator|||
name|irq
operator|>
literal|15
condition|)
block|{
name|printf
argument_list|(
literal|"zp: pcic_map_irq (slot %d): illegal irq %d\n"
argument_list|,
name|slot
argument_list|,
name|irq
argument_list|)
expr_stmt|;
return|return;
block|}
name|pcic_putb
argument_list|(
name|slot
argument_list|,
name|PCIC_INT_GEN
argument_list|,
name|pcic_getb
argument_list|(
name|slot
argument_list|,
name|PCIC_INT_GEN
argument_list|)
operator||
operator|(
name|irq
operator|&
literal|0x0F
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pcic_power_on
parameter_list|(
name|int
name|slot
parameter_list|)
block|{
name|pcic_putb
argument_list|(
name|slot
argument_list|,
name|PCIC_STATUS
argument_list|,
name|pcic_getb
argument_list|(
name|slot
argument_list|,
name|PCIC_STATUS
argument_list|)
operator||
name|PCIC_POW
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100000
argument_list|)
expr_stmt|;
name|pcic_putb
argument_list|(
name|slot
argument_list|,
name|PCIC_POWER
argument_list|,
name|pcic_getb
argument_list|(
name|slot
argument_list|,
name|PCIC_POWER
argument_list|)
operator||
name|PCIC_DISRST
operator||
name|PCIC_PCPWRE
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100000
argument_list|)
expr_stmt|;
name|pcic_putb
argument_list|(
name|slot
argument_list|,
name|PCIC_POWER
argument_list|,
name|pcic_getb
argument_list|(
name|slot
argument_list|,
name|PCIC_POWER
argument_list|)
operator||
name|PCIC_OUTENA
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pcic_power_off
parameter_list|(
name|int
name|slot
parameter_list|)
block|{
name|pcic_putb
argument_list|(
name|slot
argument_list|,
name|PCIC_POWER
argument_list|,
name|pcic_getb
argument_list|(
name|slot
argument_list|,
name|PCIC_POWER
argument_list|)
operator|&
operator|~
operator|(
name|PCIC_OUTENA
operator||
name|PCIC_PCPWRE
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pcic_reset
parameter_list|(
name|int
name|slot
parameter_list|)
block|{
comment|/* assert RESET (by clearing a bit!), wait a bit, and de-assert it */
name|pcic_putb
argument_list|(
name|slot
argument_list|,
name|PCIC_INT_GEN
argument_list|,
name|pcic_getb
argument_list|(
name|slot
argument_list|,
name|PCIC_INT_GEN
argument_list|)
operator|&
operator|~
name|PCIC_CARDRESET
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100000
argument_list|)
expr_stmt|;
name|pcic_putb
argument_list|(
name|slot
argument_list|,
name|PCIC_INT_GEN
argument_list|,
name|pcic_getb
argument_list|(
name|slot
argument_list|,
name|PCIC_INT_GEN
argument_list|)
operator||
name|PCIC_CARDRESET
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

