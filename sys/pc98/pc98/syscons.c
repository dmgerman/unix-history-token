begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992-1995 S
comment|en Schmidt  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer  *    in this position and unchanged.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software withough specific prior written permission  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  *  $Id: syscons.c,v 1.74 1998/01/24 02:54:40 eivind Exp $  */
end_comment

begin_include
include|#
directive|include
file|"sc.h"
end_include

begin_include
include|#
directive|include
file|"apm.h"
end_include

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_include
include|#
directive|include
file|"opt_devfs.h"
end_include

begin_include
include|#
directive|include
file|"opt_syscons.h"
end_include

begin_if
if|#
directive|if
name|NSC
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEVFS
end_ifdef

begin_include
include|#
directive|include
file|<sys/devfsext.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<machine/cons.h>
end_include

begin_include
include|#
directive|include
file|<machine/console.h>
end_include

begin_include
include|#
directive|include
file|<machine/mouse.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/psl.h>
end_include

begin_include
include|#
directive|include
file|<machine/frame.h>
end_include

begin_include
include|#
directive|include
file|<machine/pc/display.h>
end_include

begin_include
include|#
directive|include
file|<machine/apm_bios.h>
end_include

begin_include
include|#
directive|include
file|<machine/random.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|PC98
end_ifdef

begin_define
define|#
directive|define
name|KANJI
end_define

begin_include
include|#
directive|include
file|<pc98/pc98/pc98.h>
end_include

begin_include
include|#
directive|include
file|<pc98/pc98/pc98_machdep.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/timerreg.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/kbdtables.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/kbdio.h>
end_include

begin_include
include|#
directive|include
file|<pc98/pc98/syscons.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<i386/isa/isa.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/timerreg.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/kbdtables.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/kbdio.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/syscons.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PC98 */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|PC98
argument_list|)
operator|&&
name|defined
argument_list|(
name|LINE30
argument_list|)
end_if

begin_include
include|#
directive|include
file|<pc98/pc98/30line.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAXCONS
argument_list|)
end_if

begin_define
define|#
directive|define
name|MAXCONS
value|16
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SC_MAX_HISTORY_SIZE
argument_list|)
end_if

begin_define
define|#
directive|define
name|SC_MAX_HISTORY_SIZE
value|(1000 * MAXCONS)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SC_HISTORY_SIZE
argument_list|)
end_if

begin_define
define|#
directive|define
name|SC_HISTORY_SIZE
value|(ROW * 4)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|(
name|SC_HISTORY_SIZE
operator|*
name|MAXCONS
operator|)
operator|>
name|SC_MAX_HISTORY_SIZE
end_if

begin_undef
undef|#
directive|undef
name|SC_MAX_HISTORY_SIZE
end_undef

begin_define
define|#
directive|define
name|SC_MAX_HISTORY_SIZE
value|(SC_HISTORY_SIZE * MAXCONS)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|COLD
value|0
end_define

begin_define
define|#
directive|define
name|WARM
value|1
end_define

begin_define
define|#
directive|define
name|MODE_MAP_SIZE
value|(M_VGA_CG320 + 1)
end_define

begin_define
define|#
directive|define
name|MODE_PARAM_SIZE
value|64
end_define

begin_comment
comment|/* for backward compatibility */
end_comment

begin_define
define|#
directive|define
name|OLD_CONS_MOUSECTL
value|_IOWR('c', 10, old_mouse_info_t)
end_define

begin_typedef
typedef|typedef
struct|struct
name|old_mouse_data
block|{
name|int
name|x
decl_stmt|;
name|int
name|y
decl_stmt|;
name|int
name|buttons
decl_stmt|;
block|}
name|old_mouse_data_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|old_mouse_info
block|{
name|int
name|operation
decl_stmt|;
union|union
block|{
name|struct
name|old_mouse_data
name|data
decl_stmt|;
name|struct
name|mouse_mode
name|mode
decl_stmt|;
block|}
name|u
union|;
block|}
name|old_mouse_info_t
typedef|;
end_typedef

begin_comment
comment|/* XXX use sc_bcopy where video memory is concerned */
end_comment

begin_define
define|#
directive|define
name|sc_bcopy
value|generic_bcopy
end_define

begin_function_decl
specifier|extern
name|void
name|generic_bcopy
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|default_attr
name|user_default
init|=
block|{
operator|(
name|FG_LIGHTGREY
operator||
name|BG_BLACK
operator|)
operator|<<
literal|8
block|,
operator|(
name|FG_BLACK
operator||
name|BG_LIGHTGREY
operator|)
operator|<<
literal|8
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|PC98
end_ifdef

begin_decl_stmt
specifier|static
name|default_attr
name|kernel_default
init|=
block|{
operator|(
name|FG_LIGHTGREY
operator||
name|BG_BLACK
operator|)
operator|<<
literal|8
block|,
operator|(
name|FG_BLACK
operator||
name|BG_LIGHTGREY
operator|)
operator|<<
literal|8
block|}
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|default_attr
name|kernel_default
init|=
block|{
operator|(
name|FG_WHITE
operator||
name|BG_BLACK
operator|)
operator|<<
literal|8
block|,
operator|(
name|FG_BLACK
operator||
name|BG_LIGHTGREY
operator|)
operator|<<
literal|8
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PC98 */
end_comment

begin_decl_stmt
specifier|static
name|scr_stat
name|main_console
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|scr_stat
modifier|*
name|console
index|[
name|MAXCONS
index|]
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEVFS
end_ifdef

begin_decl_stmt
specifier|static
name|void
modifier|*
name|sc_devfs_token
index|[
name|MAXCONS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
modifier|*
name|sc_mouse_devfs_token
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
modifier|*
name|sc_console_devfs_token
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|scr_stat
modifier|*
name|cur_console
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|scr_stat
modifier|*
name|new_scp
decl_stmt|,
modifier|*
name|old_scp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|term_stat
name|kernel_console
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|default_attr
modifier|*
name|current_default
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|flags
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sc_port
init|=
name|IO_KBD
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|KBDC
name|sc_kbdc
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|init_done
init|=
name|COLD
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_short
name|sc_buffer
index|[
name|ROW
operator|*
name|COL
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|switch_in_progress
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|write_in_progress
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|blink_in_progress
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|blinkrate
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|PC98
end_ifndef

begin_decl_stmt
name|u_int
name|crtc_addr
init|=
name|MONO_BASE
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
name|crtc_type
init|=
name|KD_MONO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|crtc_vga
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|shfts
init|=
literal|0
decl_stmt|,
name|ctls
init|=
literal|0
decl_stmt|,
name|alts
init|=
literal|0
decl_stmt|,
name|agrs
init|=
literal|0
decl_stmt|,
name|metas
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|accents
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|PC98
end_ifdef

begin_decl_stmt
specifier|static
name|u_char
name|nlkcnt
init|=
literal|0
decl_stmt|,
name|slkcnt
init|=
literal|0
decl_stmt|,
name|alkcnt
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|u_char
name|nlkcnt
init|=
literal|0
decl_stmt|,
name|clkcnt
init|=
literal|0
decl_stmt|,
name|slkcnt
init|=
literal|0
decl_stmt|,
name|alkcnt
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|u_int
name|n_fkey_tab
init|=
sizeof|sizeof
argument_list|(
name|fkey_tab
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|fkey_tab
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|delayed_next_scr
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|scrn_blank_time
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* screen saver timeout value */
end_comment

begin_decl_stmt
name|int
name|scrn_blanked
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* screen saver active flag */
end_comment

begin_decl_stmt
specifier|static
name|long
name|scrn_time_stamp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
name|scr_map
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
name|scr_rmap
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|video_mode_ptr
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fonts_loaded
init|=
literal|0
ifdef|#
directive|ifdef
name|STD8X16FONT
operator||
name|FONT_16
endif|#
directive|endif
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|font_8
index|[
literal|256
operator|*
literal|8
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|font_14
index|[
literal|256
operator|*
literal|14
index|]
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|STD8X16FONT
end_ifdef

begin_decl_stmt
specifier|extern
endif|#
directive|endif
name|unsigned
name|char
name|font_16
index|[
literal|256
operator|*
literal|16
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|palette
index|[
literal|256
operator|*
literal|3
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|mode_map
index|[
name|MODE_MAP_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|vgaregs
index|[
name|MODE_PARAM_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|vgaregs2
index|[
name|MODE_PARAM_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rows_offset
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|cut_buffer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mouse_level
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* sysmouse protocol level */
end_comment

begin_decl_stmt
specifier|static
name|mousestatus_t
name|mouse_status
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_short
name|mouse_and_mask
index|[
literal|16
index|]
init|=
block|{
literal|0xc000
block|,
literal|0xe000
block|,
literal|0xf000
block|,
literal|0xf800
block|,
literal|0xfc00
block|,
literal|0xfe00
block|,
literal|0xff00
block|,
literal|0xff80
block|,
literal|0xfe00
block|,
literal|0x1e00
block|,
literal|0x1f00
block|,
literal|0x0f00
block|,
literal|0x0f00
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_short
name|mouse_or_mask
index|[
literal|16
index|]
init|=
block|{
literal|0x0000
block|,
literal|0x4000
block|,
literal|0x6000
block|,
literal|0x7000
block|,
literal|0x7800
block|,
literal|0x7c00
block|,
literal|0x7e00
block|,
literal|0x6800
block|,
literal|0x0c00
block|,
literal|0x0c00
block|,
literal|0x0600
block|,
literal|0x0600
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|extra_history_size
init|=
name|SC_MAX_HISTORY_SIZE
operator|-
name|SC_HISTORY_SIZE
operator|*
name|MAXCONS
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|none_saver
parameter_list|(
name|int
name|blank
parameter_list|)
block|{ }
end_function

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
name|current_saver
function_decl|)
parameter_list|(
name|int
name|blank
parameter_list|)
init|=
name|none_saver
function_decl|;
end_function_decl

begin_function_decl
name|int
function_decl|(
modifier|*
name|sc_user_ioctl
function_decl|)
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
init|=
name|NULL
function_decl|;
end_function_decl

begin_comment
comment|/* OS specific stuff */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|not_yet_done
end_ifdef

begin_define
define|#
directive|define
name|VIRTUAL_TTY
parameter_list|(
name|x
parameter_list|)
value|(sccons[x] = ttymalloc(sccons[x]))
end_define

begin_decl_stmt
name|struct
name|CONSOLE_TTY
argument_list|(
name|sccons
index|[
name|MAXCONS
index|]
operator|=
name|ttymalloc
argument_list|(
name|sccons
index|[
name|MAXCONS
index|]
argument_list|)
argument_list|)
decl|struct
name|MOUSE_TTY
argument_list|(
name|sccons
index|[
name|MAXCONS
operator|+
literal|1
index|]
operator|=
name|ttymalloc
argument_list|(
name|sccons
index|[
name|MAXCONS
operator|+
literal|1
index|]
argument_list|)
argument_list|)
decl|struct
name|tty
modifier|*
name|sccons
index|[
name|MAXCONS
operator|+
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|VIRTUAL_TTY
parameter_list|(
name|x
parameter_list|)
value|&sccons[x]
end_define

begin_define
define|#
directive|define
name|CONSOLE_TTY
value|&sccons[MAXCONS]
end_define

begin_define
define|#
directive|define
name|MOUSE_TTY
value|&sccons[MAXCONS+1]
end_define

begin_decl_stmt
specifier|static
name|struct
name|tty
name|sccons
index|[
name|MAXCONS
operator|+
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|SC_MOUSE
value|128
end_define

begin_define
define|#
directive|define
name|SC_CONSOLE
value|255
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|PC98
end_ifdef

begin_decl_stmt
specifier|static
name|u_char
name|default_kanji
init|=
name|UJIS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_short
modifier|*
name|Crtat
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_short
modifier|*
name|Atrat
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|MONO_BUF
value|pa_to_va(0xB0000)
end_define

begin_define
define|#
directive|define
name|CGA_BUF
value|pa_to_va(0xB8000)
end_define

begin_decl_stmt
name|u_short
modifier|*
name|Crtat
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|int
name|nsccons
init|=
name|MAXCONS
operator|+
literal|2
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|WRAPHIST
parameter_list|(
name|scp
parameter_list|,
name|pointer
parameter_list|,
name|offset
parameter_list|)
define|\
value|((scp->history) + ((((pointer) - (scp->history)) + (scp->history_size)\     + (offset)) % (scp->history_size)))
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|PC98
end_ifdef

begin_define
define|#
directive|define
name|WRAPHIST_A
parameter_list|(
name|scp
parameter_list|,
name|pointer
parameter_list|,
name|offset
parameter_list|)
define|\
value|((scp->his_atr) + ((((pointer) - (scp->his_atr)) + (scp->history_size)\     + (offset)) % (scp->history_size)))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ISSIGVALID
parameter_list|(
name|sig
parameter_list|)
value|((sig)> 0&& (sig)< NSIG)
end_define

begin_comment
comment|/* this should really be in `rtc.h' */
end_comment

begin_define
define|#
directive|define
name|RTC_EQUIPMENT
value|0x14
end_define

begin_comment
comment|/* prototypes */
end_comment

begin_function_decl
specifier|static
name|int
name|scattach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|scparam
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|struct
name|termios
modifier|*
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|scprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|scvidprobe
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sckbdprobe
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|scstart
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|scmousestart
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|scinit
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|map_mode_table
parameter_list|(
name|char
modifier|*
name|map
index|[]
parameter_list|,
name|char
modifier|*
name|table
parameter_list|,
name|int
name|max
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_char
name|map_mode_num
parameter_list|(
name|u_char
name|mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|get_mode_param
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|u_char
name|mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int
name|scgetc
parameter_list|(
name|u_int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|SCGETC_CN
value|1
end_define

begin_define
define|#
directive|define
name|SCGETC_NONBLOCK
value|2
end_define

begin_function_decl
specifier|static
name|scr_stat
modifier|*
name|get_scr_stat
parameter_list|(
name|dev_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|scr_stat
modifier|*
name|alloc_scp
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_scp
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_scr_num
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|timeout_t
name|scrn_timer
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|stop_scrn_saver
parameter_list|(
name|void
function_decl|(
modifier|*
name|saver
function_decl|)
parameter_list|(
name|int
parameter_list|)
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|clear_screen
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|switch_scr
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|u_int
name|next_scr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|exchange_scr
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|move_crsr
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|scan_esc
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|u_char
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|draw_cursor_image
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|remove_cursor_image
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ansi_put
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_char
modifier|*
name|get_fstr
parameter_list|(
name|u_int
name|c
parameter_list|,
name|u_int
modifier|*
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|history_to_screen
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|history_up_line
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|history_down_line
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mask2attr
parameter_list|(
name|struct
name|term_stat
modifier|*
name|term
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_keyboard
parameter_list|(
name|int
name|command
parameter_list|,
name|int
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|update_leds
parameter_list|(
name|int
name|which
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_vgaregs
parameter_list|(
name|char
modifier|*
name|modetable
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|read_vgaregs
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|COMP_IDENTICAL
value|0
end_define

begin_define
define|#
directive|define
name|COMP_SIMILAR
value|1
end_define

begin_define
define|#
directive|define
name|COMP_DIFFERENT
value|2
end_define

begin_function_decl
specifier|static
name|int
name|comp_vgaregs
parameter_list|(
name|u_char
modifier|*
name|buf1
parameter_list|,
name|u_char
modifier|*
name|buf2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_vgaregs
parameter_list|(
name|u_char
modifier|*
name|buf
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|PARAM_BUFSIZE
value|6
end_define

begin_function_decl
specifier|static
name|void
name|set_font_mode
parameter_list|(
name|u_char
modifier|*
name|buf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_normal_mode
parameter_list|(
name|u_char
modifier|*
name|buf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_destructive_cursor
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_mouse_pos
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|skip_spc_right
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|u_short
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|skip_spc_left
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|u_short
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mouse_cut
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mouse_cut_start
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mouse_cut_end
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mouse_cut_word
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mouse_cut_line
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mouse_cut_extend
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mouse_paste
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|draw_mouse_image
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|remove_mouse_image
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|draw_cutmarking
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|remove_cutmarking
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|save_palette
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_bell
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|int
name|pitch
parameter_list|,
name|int
name|duration
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|timeout_t
name|blink_screen
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SC_SPLASH_SCREEN
end_ifdef

begin_function_decl
specifier|static
name|void
name|toggle_splash_screen
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|isa_driver
name|scdriver
init|=
block|{
name|scprobe
block|,
name|scattach
block|,
literal|"sc"
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_open_t
name|scopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|scclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_read_t
name|scread
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_write_t
name|scwrite
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|scioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_devtotty_t
name|scdevtotty
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_mmap_t
name|scmmap
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CDEV_MAJOR
value|12
end_define

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|scdevsw
init|=
block|{
name|scopen
block|,
name|scclose
block|,
name|scread
block|,
name|scwrite
block|,
name|scioctl
block|,
name|nullstop
block|,
name|noreset
block|,
name|scdevtotty
block|,
name|ttpoll
block|,
name|scmmap
block|,
name|nostrategy
block|,
literal|"sc"
block|,
name|NULL
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|PC98
end_ifdef

begin_decl_stmt
specifier|static
name|u_char
name|ibmpc_to_pc98
index|[
literal|16
index|]
init|=
block|{
literal|0x01
block|,
literal|0x21
block|,
literal|0x81
block|,
literal|0xa1
block|,
literal|0x41
block|,
literal|0x61
block|,
literal|0xc1
block|,
literal|0xe1
block|,
literal|0x09
block|,
literal|0x29
block|,
literal|0x89
block|,
literal|0xa9
block|,
literal|0x49
block|,
literal|0x69
block|,
literal|0xc9
block|,
literal|0xe9
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|ibmpc_to_pc98rev
index|[
literal|16
index|]
init|=
block|{
literal|0x05
block|,
literal|0x25
block|,
literal|0x85
block|,
literal|0xa5
block|,
literal|0x45
block|,
literal|0x65
block|,
literal|0xc5
block|,
literal|0xe5
block|,
literal|0x0d
block|,
literal|0x2d
block|,
literal|0x8d
block|,
literal|0xad
block|,
literal|0x4d
block|,
literal|0x6d
block|,
literal|0xcd
block|,
literal|0xed
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|unsigned
name|int
name|at2pc98
parameter_list|(
name|unsigned
name|int
name|attr
parameter_list|)
block|{
name|unsigned
name|char
name|fg_at
decl_stmt|,
name|bg_at
decl_stmt|;
name|unsigned
name|int
name|at
decl_stmt|;
name|fg_at
operator|=
operator|(
operator|(
name|attr
operator|>>
literal|8
operator|)
operator|&
literal|0x0F
operator|)
expr_stmt|;
name|bg_at
operator|=
operator|(
operator|(
name|attr
operator|>>
literal|8
operator|)
operator|&
literal|0xF0
operator|)
expr_stmt|;
if|if
condition|(
name|bg_at
condition|)
block|{
if|if
condition|(
name|bg_at
operator|&
literal|0x80
condition|)
block|{
if|if
condition|(
name|bg_at
operator|&
literal|0x70
condition|)
block|{
comment|/* reverse& blink */
name|at
operator|=
name|ibmpc_to_pc98rev
index|[
name|bg_at
operator|>>
literal|4
index|]
operator||
literal|0x02
expr_stmt|;
block|}
else|else
block|{
comment|/* normal& blink */
name|at
operator|=
name|ibmpc_to_pc98
index|[
name|fg_at
index|]
operator||
literal|0x02
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* reverse */
name|at
operator|=
name|ibmpc_to_pc98rev
index|[
name|bg_at
operator|>>
literal|4
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* normal */
name|at
operator|=
name|ibmpc_to_pc98
index|[
name|fg_at
index|]
expr_stmt|;
block|}
name|at
operator||=
operator|(
operator|(
name|fg_at
operator||
name|bg_at
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
return|return
operator|(
name|at
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * These functions need to be before calls to them so they can be inlined.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|draw_cursor_image
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
name|u_short
name|cursor_image
decl_stmt|,
modifier|*
name|ptr
decl_stmt|;
name|u_short
name|prev_image
decl_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|int
name|pos
init|=
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
decl_stmt|;
while|while
condition|(
operator|(
name|inb
argument_list|(
name|TEXT_GDC
operator|+
literal|0
argument_list|)
operator|&
literal|0x04
operator|)
operator|==
literal|0
condition|)
block|{}
name|outb
argument_list|(
name|TEXT_GDC
operator|+
literal|2
argument_list|,
literal|0x49
argument_list|)
expr_stmt|;
comment|/* CSRW */
name|outb
argument_list|(
name|TEXT_GDC
operator|+
literal|0
argument_list|,
name|pos
operator|&
literal|0xff
argument_list|)
expr_stmt|;
comment|/* EADl */
name|outb
argument_list|(
name|TEXT_GDC
operator|+
literal|0
argument_list|,
name|pos
operator|>>
literal|8
argument_list|)
expr_stmt|;
comment|/* EADh */
else|#
directive|else
name|ptr
operator|=
name|Crtat
operator|+
operator|(
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
operator|)
expr_stmt|;
comment|/* do we have a destructive cursor ? */
if|if
condition|(
name|flags
operator|&
name|CHAR_CURSOR
condition|)
block|{
name|prev_image
operator|=
name|scp
operator|->
name|cursor_saveunder
expr_stmt|;
name|cursor_image
operator|=
operator|*
name|ptr
operator|&
literal|0x00ff
expr_stmt|;
if|if
condition|(
name|cursor_image
operator|==
name|DEAD_CHAR
condition|)
name|cursor_image
operator|=
name|prev_image
operator|&
literal|0x00ff
expr_stmt|;
name|cursor_image
operator||=
operator|*
operator|(
name|scp
operator|->
name|cursor_pos
operator|)
operator|&
literal|0xff00
expr_stmt|;
name|scp
operator|->
name|cursor_saveunder
operator|=
name|cursor_image
expr_stmt|;
comment|/* update the cursor bitmap if the char under the cursor has changed */
if|if
condition|(
name|prev_image
operator|!=
name|cursor_image
condition|)
name|set_destructive_cursor
argument_list|(
name|scp
argument_list|)
expr_stmt|;
comment|/* modify cursor_image */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|BLINK_CURSOR
operator|)
operator|||
operator|(
operator|(
name|flags
operator|&
name|BLINK_CURSOR
operator|)
operator|&&
operator|(
name|blinkrate
operator|&
literal|4
operator|)
operator|)
condition|)
block|{
comment|/*  	     * When the mouse pointer is at the same position as the cursor, 	     * the cursor bitmap needs to be updated even if the char under  	     * the cursor hasn't changed, because the mouse pionter may  	     * have moved by a few dots within the cursor cel. 	     */
if|if
condition|(
operator|(
name|prev_image
operator|==
name|cursor_image
operator|)
operator|&&
operator|(
name|cursor_image
operator|!=
operator|*
operator|(
name|scp
operator|->
name|cursor_pos
operator|)
operator|)
condition|)
name|set_destructive_cursor
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|cursor_image
operator|&=
literal|0xff00
expr_stmt|;
name|cursor_image
operator||=
name|DEAD_CHAR
expr_stmt|;
block|}
block|}
else|else
block|{
name|cursor_image
operator|=
operator|(
operator|*
operator|(
name|ptr
operator|)
operator|&
literal|0x00ff
operator|)
operator||
operator|*
operator|(
name|scp
operator|->
name|cursor_pos
operator|)
operator|&
literal|0xff00
expr_stmt|;
name|scp
operator|->
name|cursor_saveunder
operator|=
name|cursor_image
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|BLINK_CURSOR
operator|)
operator|||
operator|(
operator|(
name|flags
operator|&
name|BLINK_CURSOR
operator|)
operator|&&
operator|(
name|blinkrate
operator|&
literal|4
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|cursor_image
operator|&
literal|0x7000
operator|)
operator|==
literal|0x7000
condition|)
block|{
name|cursor_image
operator|&=
literal|0x8fff
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|cursor_image
operator|&
literal|0x0700
operator|)
condition|)
name|cursor_image
operator||=
literal|0x0700
expr_stmt|;
block|}
else|else
block|{
name|cursor_image
operator||=
literal|0x7000
expr_stmt|;
if|if
condition|(
operator|(
name|cursor_image
operator|&
literal|0x0700
operator|)
operator|==
literal|0x0700
condition|)
name|cursor_image
operator|&=
literal|0xf0ff
expr_stmt|;
block|}
block|}
block|}
operator|*
name|ptr
operator|=
name|cursor_image
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|remove_cursor_image
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|PC98
comment|/*     u_short cursor_image, *ptr;      ptr = Crtat + (scp->cursor_oldpos - scp->scr_buf);  	cursor_image = scp->cursor_saveunder;     *ptr = cursor_image; SOS */
operator|*
operator|(
name|Crtat
operator|+
operator|(
name|scp
operator|->
name|cursor_oldpos
operator|-
name|scp
operator|->
name|scr_buf
operator|)
operator|)
operator|=
name|scp
operator|->
name|cursor_saveunder
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|move_crsr
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
block|{
if|if
condition|(
name|x
operator|<
literal|0
condition|)
name|x
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|y
operator|<
literal|0
condition|)
name|y
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|x
operator|>=
name|scp
operator|->
name|xsize
condition|)
name|x
operator|=
name|scp
operator|->
name|xsize
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|y
operator|>=
name|scp
operator|->
name|ysize
condition|)
name|y
operator|=
name|scp
operator|->
name|ysize
operator|-
literal|1
expr_stmt|;
name|scp
operator|->
name|xpos
operator|=
name|x
expr_stmt|;
name|scp
operator|->
name|ypos
operator|=
name|y
expr_stmt|;
name|scp
operator|->
name|cursor_pos
operator|=
name|scp
operator|->
name|scr_buf
operator|+
name|scp
operator|->
name|ypos
operator|*
name|scp
operator|->
name|xsize
operator|+
name|scp
operator|->
name|xpos
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|scp
operator|->
name|cursor_atr
operator|=
name|scp
operator|->
name|atr_buf
operator|+
name|scp
operator|->
name|ypos
operator|*
name|scp
operator|->
name|xsize
operator|+
name|scp
operator|->
name|xpos
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|int
name|scprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
block|{
if|if
condition|(
operator|!
name|scvidprobe
argument_list|(
name|dev
operator|->
name|id_unit
argument_list|,
name|dev
operator|->
name|id_flags
argument_list|)
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"sc%d: no video adapter is found.\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sc_port
operator|=
name|dev
operator|->
name|id_iobase
expr_stmt|;
if|if
condition|(
name|sckbdprobe
argument_list|(
name|dev
operator|->
name|id_unit
argument_list|,
name|dev
operator|->
name|id_flags
argument_list|)
condition|)
return|return
operator|(
name|IO_KBDSIZE
operator|)
return|;
else|else
return|return
operator|(
operator|(
name|dev
operator|->
name|id_flags
operator|&
name|DETECT_KBD
operator|)
condition|?
literal|0
else|:
name|IO_KBDSIZE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* probe video adapters, return TRUE if found */
end_comment

begin_function
specifier|static
name|int
name|scvidprobe
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
comment|/*       * XXX don't try to `printf' anything here, the console may not have       * been configured yet.       */
name|u_short
specifier|volatile
modifier|*
name|cp
decl_stmt|;
name|u_short
name|was
decl_stmt|;
name|u_long
name|pa
decl_stmt|;
name|u_long
name|segoff
decl_stmt|;
comment|/* do this test only once */
if|if
condition|(
name|init_done
operator|!=
name|COLD
condition|)
return|return
operator|(
name|Crtat
operator|!=
literal|0
operator|)
return|;
comment|/*      * Finish defaulting crtc variables for a mono screen.  Crtat is a      * bogus common variable so that it can be shared with pcvt, so it      * can't be statically initialized.  XXX.      */
ifdef|#
directive|ifdef
name|PC98
name|Crtat
operator|=
operator|(
name|u_short
operator|*
operator|)
name|TEXT_VRAM
expr_stmt|;
name|Atrat
operator|=
operator|(
name|u_short
operator|*
operator|)
name|TEXT_VRAM
operator|+
name|ATTR_OFFSET
expr_stmt|;
name|crtc_type
operator|=
name|KD_PC98
expr_stmt|;
else|#
directive|else
name|Crtat
operator|=
operator|(
name|u_short
operator|*
operator|)
name|MONO_BUF
expr_stmt|;
name|crtc_type
operator|=
name|KD_MONO
expr_stmt|;
comment|/* If CGA memory seems to work, switch to color.  */
name|cp
operator|=
operator|(
name|u_short
operator|*
operator|)
name|CGA_BUF
expr_stmt|;
name|was
operator|=
operator|*
name|cp
expr_stmt|;
operator|*
name|cp
operator|=
operator|(
name|u_short
operator|)
literal|0xA55A
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|0xA55A
condition|)
block|{
name|Crtat
operator|=
operator|(
name|u_short
operator|*
operator|)
name|CGA_BUF
expr_stmt|;
name|crtc_addr
operator|=
name|COLOR_BASE
expr_stmt|;
name|crtc_type
operator|=
name|KD_CGA
expr_stmt|;
block|}
else|else
block|{
name|cp
operator|=
name|Crtat
expr_stmt|;
name|was
operator|=
operator|*
name|cp
expr_stmt|;
operator|*
name|cp
operator|=
operator|(
name|u_short
operator|)
literal|0xA55A
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|!=
literal|0xA55A
condition|)
block|{
comment|/* no screen at all, bail out */
name|Crtat
operator|=
literal|0
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
operator|*
name|cp
operator|=
name|was
expr_stmt|;
comment|/*       * Check rtc and BIOS date area.      * XXX: don't use BIOSDATA_EQUIPMENT, it is not a dead copy      * of RTC_EQUIPMENT. The bit 4 and 5 of the ETC_EQUIPMENT are      * zeros for EGA and VGA. However, the EGA/VGA BIOS will set       * these bits in BIOSDATA_EQUIPMENT according to the monitor      * type detected.      */
switch|switch
condition|(
operator|(
name|rtcin
argument_list|(
name|RTC_EQUIPMENT
argument_list|)
operator|>>
literal|4
operator|)
operator|&
literal|3
condition|)
block|{
comment|/* bit 4 and 5 */
case|case
literal|0
case|:
comment|/* EGA/VGA, or nothing */
name|crtc_type
operator|=
name|KD_EGA
expr_stmt|;
comment|/* the color adapter may be in the 40x25 mode... XXX */
break|break;
case|case
literal|1
case|:
comment|/* CGA 40x25 */
comment|/* switch to the 80x25 mode? XXX */
comment|/* FALL THROUGH */
case|case
literal|2
case|:
comment|/* CGA 80x25 */
comment|/* `crtc_type' has already been set... */
comment|/* crtc_type = KD_CGA; */
break|break;
case|case
literal|3
case|:
comment|/* MDA */
comment|/* `crtc_type' has already been set... */
comment|/* crtc_type = KD_MONO; */
break|break;
block|}
comment|/* is this a VGA or higher ? */
name|outb
argument_list|(
name|crtc_addr
argument_list|,
literal|7
argument_list|)
expr_stmt|;
if|if
condition|(
name|inb
argument_list|(
name|crtc_addr
argument_list|)
operator|==
literal|7
condition|)
block|{
name|crtc_type
operator|=
name|KD_VGA
expr_stmt|;
name|crtc_vga
operator|=
name|TRUE
expr_stmt|;
name|read_vgaregs
argument_list|(
name|vgaregs
argument_list|)
expr_stmt|;
comment|/* Get the BIOS video mode pointer */
name|segoff
operator|=
operator|*
operator|(
name|u_long
operator|*
operator|)
name|pa_to_va
argument_list|(
literal|0x4a8
argument_list|)
expr_stmt|;
name|pa
operator|=
operator|(
operator|(
operator|(
name|segoff
operator|&
literal|0xffff0000
operator|)
operator|>>
literal|12
operator|)
operator|+
operator|(
name|segoff
operator|&
literal|0xffff
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|ISMAPPED
argument_list|(
name|pa
argument_list|,
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
argument_list|)
condition|)
block|{
name|segoff
operator|=
operator|*
operator|(
name|u_long
operator|*
operator|)
name|pa_to_va
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|pa
operator|=
operator|(
operator|(
operator|(
name|segoff
operator|&
literal|0xffff0000
operator|)
operator|>>
literal|12
operator|)
operator|+
operator|(
name|segoff
operator|&
literal|0xffff
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|ISMAPPED
argument_list|(
name|pa
argument_list|,
name|MODE_PARAM_SIZE
argument_list|)
condition|)
name|video_mode_ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|pa_to_va
argument_list|(
name|pa
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* PC98 */
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* probe the keyboard, return TRUE if found */
end_comment

begin_function
specifier|static
name|int
name|sckbdprobe
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|codeset
decl_stmt|;
name|int
name|c
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|m
decl_stmt|;
name|sc_kbdc
operator|=
name|kbdc_open
argument_list|(
name|sc_port
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|PC98
if|if
condition|(
operator|!
name|kbdc_lock
argument_list|(
name|sc_kbdc
argument_list|,
name|TRUE
argument_list|)
condition|)
block|{
comment|/* driver error? */
name|printf
argument_list|(
literal|"sc%d: unable to lock the controller.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|flags
operator|&
name|DETECT_KBD
operator|)
condition|?
name|FALSE
else|:
name|TRUE
operator|)
return|;
block|}
comment|/* discard anything left after UserConfig */
name|empty_both_buffers
argument_list|(
name|sc_kbdc
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* save the current keyboard controller command byte */
name|m
operator|=
name|kbdc_get_device_mask
argument_list|(
name|sc_kbdc
argument_list|)
operator|&
operator|~
name|KBD_KBD_CONTROL_BITS
expr_stmt|;
name|c
operator|=
name|get_controller_command_byte
argument_list|(
name|sc_kbdc
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* CONTROLLER ERROR */
name|printf
argument_list|(
literal|"sc%d: unable to get the current command byte value.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"sc%d: the current keyboard controller command byte %04x\n"
argument_list|,
name|unit
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* override the keyboard lock switch */
block|c |= KBD_OVERRIDE_KBD_LOCK;
endif|#
directive|endif
comment|/*       * The keyboard may have been screwed up by the boot block.      * We may just be able to recover from error by testing the controller      * and the keyboard port. The controller command byte needs to be saved      * before this recovery operation, as some controllers seem to set       * the command byte to particular values.      */
name|test_controller
argument_list|(
name|sc_kbdc
argument_list|)
expr_stmt|;
name|test_kbd_port
argument_list|(
name|sc_kbdc
argument_list|)
expr_stmt|;
comment|/* enable the keyboard port, but disable the keyboard intr. */
if|if
condition|(
operator|!
name|set_controller_command_byte
argument_list|(
name|sc_kbdc
argument_list|,
name|KBD_KBD_CONTROL_BITS
argument_list|,
name|KBD_ENABLE_KBD_PORT
operator||
name|KBD_DISABLE_KBD_INT
argument_list|)
condition|)
block|{
comment|/* CONTROLLER ERROR  	 * there is very little we can do... 	 */
name|printf
argument_list|(
literal|"sc%d: unable to set the command byte.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/*        * Check if we have an XT keyboard before we attempt to reset it.        * The procedure assumes that the keyboard and the controller have        * been set up properly by BIOS and have not been messed up        * during the boot process.       */
name|codeset
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|XT_KEYBD
condition|)
comment|/* the user says there is a XT keyboard */
name|codeset
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|DETECT_XT_KEYBOARD
elseif|else
if|if
condition|(
operator|(
name|c
operator|&
name|KBD_TRANSLATION
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* SET_SCANCODE_SET is not always supported; ignore error */
if|if
condition|(
name|send_kbd_command_and_data
argument_list|(
name|sc_kbdc
argument_list|,
name|KBDC_SET_SCANCODE_SET
argument_list|,
literal|0
argument_list|)
operator|==
name|KBD_ACK
condition|)
name|codeset
operator|=
name|read_kbd_data
argument_list|(
name|sc_kbdc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"sc%d: keyboard scancode set %d\n"
argument_list|,
name|unit
argument_list|,
name|codeset
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DETECT_XT_KEYBOARD */
if|if
condition|(
name|flags
operator|&
name|KBD_NORESET
condition|)
block|{
name|write_kbd_command
argument_list|(
name|sc_kbdc
argument_list|,
name|KBDC_ECHO
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_kbd_data
argument_list|(
name|sc_kbdc
argument_list|)
operator|!=
name|KBD_ECHO
condition|)
block|{
name|empty_both_buffers
argument_list|(
name|sc_kbdc
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|test_controller
argument_list|(
name|sc_kbdc
argument_list|)
expr_stmt|;
name|test_kbd_port
argument_list|(
name|sc_kbdc
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"sc%d: failed to get response from the keyboard.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
else|else
block|{
comment|/* reset keyboard hardware */
if|if
condition|(
operator|!
name|reset_kbd
argument_list|(
name|sc_kbdc
argument_list|)
condition|)
block|{
comment|/* KEYBOARD ERROR              * Keyboard reset may fail either because the keyboard doen't              * exist, or because the keyboard doesn't pass the self-test,              * or the keyboard controller on the motherboard and the keyboard              * somehow fail to shake hands. It is just possible, particularly              * in the last case, that the keyoard controller may be left               * in a hung state. test_controller() and test_kbd_port() appear              * to bring the keyboard controller back (I don't know why and              * how, though.)              */
name|empty_both_buffers
argument_list|(
name|sc_kbdc
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|test_controller
argument_list|(
name|sc_kbdc
argument_list|)
expr_stmt|;
name|test_kbd_port
argument_list|(
name|sc_kbdc
argument_list|)
expr_stmt|;
comment|/* We could disable the keyboard port and interrupt... but,               * the keyboard may still exist (see above).               */
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"sc%d: failed to reset the keyboard.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
comment|/*      * Allow us to set the XT_KEYBD flag in UserConfig so that keyboards      * such as those on the IBM ThinkPad laptop computers can be used      * with the standard console driver.      */
if|if
condition|(
name|codeset
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|send_kbd_command_and_data
argument_list|(
name|sc_kbdc
argument_list|,
name|KBDC_SET_SCANCODE_SET
argument_list|,
name|codeset
argument_list|)
operator|==
name|KBD_ACK
condition|)
block|{
comment|/* XT kbd doesn't need scan code translation */
name|c
operator|&=
operator|~
name|KBD_TRANSLATION
expr_stmt|;
block|}
else|else
block|{
comment|/* KEYBOARD ERROR  	     * The XT kbd isn't usable unless the proper scan code set 	     * is selected.  	     */
name|printf
argument_list|(
literal|"sc%d: unable to set the XT keyboard mode.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
comment|/* enable the keyboard port and intr. */
if|if
condition|(
operator|!
name|set_controller_command_byte
argument_list|(
name|sc_kbdc
argument_list|,
name|KBD_KBD_CONTROL_BITS
operator||
name|KBD_TRANSLATION
operator||
name|KBD_OVERRIDE_KBD_LOCK
argument_list|,
operator|(
name|c
operator|&
operator|(
name|KBD_TRANSLATION
operator||
name|KBD_OVERRIDE_KBD_LOCK
operator|)
operator|)
operator||
name|KBD_ENABLE_KBD_PORT
operator||
name|KBD_ENABLE_KBD_INT
argument_list|)
condition|)
block|{
comment|/* CONTROLLER ERROR  	 * This is serious; we are left with the disabled keyboard intr.  	 */
name|printf
argument_list|(
literal|"sc%d: unable to enable the keyboard port and intr.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|kbdc_set_device_mask
argument_list|(
name|sc_kbdc
argument_list|,
name|m
operator||
name|KBD_KBD_CONTROL_BITS
argument_list|)
operator|,
name|kbdc_lock
argument_list|(
name|sc_kbdc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !PC98 */
return|return
name|TRUE
return|;
ifndef|#
directive|ifndef
name|PC98
name|fail
label|:
if|if
condition|(
name|c
operator|!=
operator|-
literal|1
condition|)
comment|/* try to restore the command byte as before, if possible */
name|set_controller_command_byte
argument_list|(
name|sc_kbdc
argument_list|,
literal|0xff
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|kbdc_set_device_mask
argument_list|(
name|sc_kbdc
argument_list|,
operator|(
name|flags
operator|&
name|DETECT_KBD
operator|)
condition|?
name|m
else|:
name|m
operator||
name|KBD_KBD_CONTROL_BITS
argument_list|)
expr_stmt|;
name|kbdc_lock
argument_list|(
name|sc_kbdc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
endif|#
directive|endif
comment|/* !PC98 */
block|}
end_function

begin_if
if|#
directive|if
name|NAPM
operator|>
literal|0
end_if

begin_function
specifier|static
name|int
name|scresume
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
name|shfts
operator|=
name|ctls
operator|=
name|alts
operator|=
name|agrs
operator|=
name|metas
operator|=
name|accents
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|scattach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
block|{
name|scr_stat
modifier|*
name|scp
decl_stmt|;
name|dev_t
name|cdev
init|=
name|makedev
argument_list|(
name|CDEV_MAJOR
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
ifdef|#
directive|ifdef
name|DEVFS
name|int
name|vc
decl_stmt|;
endif|#
directive|endif
name|scinit
argument_list|()
expr_stmt|;
name|flags
operator|=
name|dev
operator|->
name|id_flags
expr_stmt|;
if|if
condition|(
operator|!
name|crtc_vga
condition|)
name|flags
operator|&=
operator|~
name|CHAR_CURSOR
expr_stmt|;
name|scp
operator|=
name|console
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|crtc_vga
condition|)
block|{
name|cut_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
block|}
name|scp
operator|->
name|scr_buf
operator|=
operator|(
name|u_short
operator|*
operator|)
name|malloc
argument_list|(
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|scp
operator|->
name|atr_buf
operator|=
operator|(
name|u_short
operator|*
operator|)
name|malloc
argument_list|(
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* copy temporary buffer to final buffer */
name|bcopy
argument_list|(
name|sc_buffer
argument_list|,
name|scp
operator|->
name|scr_buf
argument_list|,
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|bcopy
argument_list|(
name|Atrat
argument_list|,
name|scp
operator|->
name|atr_buf
argument_list|,
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|scp
operator|->
name|cursor_pos
operator|=
name|scp
operator|->
name|cursor_oldpos
operator|=
name|scp
operator|->
name|scr_buf
operator|+
name|scp
operator|->
name|xpos
operator|+
name|scp
operator|->
name|ypos
operator|*
name|scp
operator|->
name|xsize
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|scp
operator|->
name|cursor_atr
operator|=
name|scp
operator|->
name|atr_buf
operator|+
name|scp
operator|->
name|xpos
operator|+
name|scp
operator|->
name|ypos
operator|*
name|scp
operator|->
name|xsize
expr_stmt|;
endif|#
directive|endif
name|scp
operator|->
name|mouse_pos
operator|=
name|scp
operator|->
name|mouse_oldpos
operator|=
name|scp
operator|->
name|scr_buf
operator|+
operator|(
operator|(
name|scp
operator|->
name|mouse_ypos
operator|/
name|scp
operator|->
name|font_size
operator|)
operator|*
name|scp
operator|->
name|xsize
operator|+
name|scp
operator|->
name|mouse_xpos
operator|/
literal|8
operator|)
expr_stmt|;
comment|/* initialize history buffer& pointers */
name|scp
operator|->
name|history_head
operator|=
name|scp
operator|->
name|history_pos
operator|=
operator|(
name|u_short
operator|*
operator|)
name|malloc
argument_list|(
name|scp
operator|->
name|history_size
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|history_head
operator|!=
name|NULL
condition|)
name|bzero
argument_list|(
name|scp
operator|->
name|history_head
argument_list|,
name|scp
operator|->
name|history_size
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|scp
operator|->
name|history
operator|=
name|scp
operator|->
name|history_head
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|scp
operator|->
name|his_atr_head
operator|=
name|scp
operator|->
name|his_atr_pos
operator|=
operator|(
name|u_short
operator|*
operator|)
name|malloc
argument_list|(
name|scp
operator|->
name|history_size
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|his_atr_head
operator|!=
name|NULL
condition|)
name|bzero
argument_list|(
name|scp
operator|->
name|his_atr_head
argument_list|,
name|scp
operator|->
name|history_size
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|scp
operator|->
name|his_atr
operator|=
name|scp
operator|->
name|his_atr_pos
expr_stmt|;
endif|#
directive|endif
comment|/* initialize cursor stuff */
if|if
condition|(
operator|!
operator|(
name|scp
operator|->
name|status
operator|&
name|UNKNOWN_MODE
operator|)
condition|)
name|draw_cursor_image
argument_list|(
name|scp
argument_list|)
expr_stmt|;
comment|/* get screen update going */
name|scrn_timer
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|update_leds
argument_list|(
name|scp
operator|->
name|status
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|PC98
if|if
condition|(
operator|(
name|crtc_type
operator|==
name|KD_VGA
operator|)
operator|&&
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"sc%d: BIOS video mode:%d\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|,
operator|*
operator|(
name|u_char
operator|*
operator|)
name|pa_to_va
argument_list|(
literal|0x449
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sc%d: VGA registers upon power-up\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
name|dump_vgaregs
argument_list|(
name|vgaregs
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sc%d: video mode:%d\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|,
name|scp
operator|->
name|mode
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sc%d: VGA registers in BIOS for mode:%d\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|,
name|scp
operator|->
name|mode
argument_list|)
expr_stmt|;
name|dump_vgaregs
argument_list|(
name|vgaregs2
argument_list|)
expr_stmt|;
name|p
operator|=
name|get_mode_param
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"sc%d: VGA registers to be used for mode:%d\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|,
name|scp
operator|->
name|mode
argument_list|)
expr_stmt|;
name|dump_vgaregs
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"sc%d: rows_offset:%d\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|,
name|rows_offset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|crtc_type
operator|==
name|KD_VGA
operator|)
operator|&&
operator|(
name|video_mode_ptr
operator|==
name|NULL
operator|)
condition|)
name|printf
argument_list|(
literal|"sc%d: WARNING: video mode switching is only partially supported\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"sc%d: "
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|crtc_type
condition|)
block|{
ifdef|#
directive|ifdef
name|PC98
case|case
name|KD_PC98
case|:
name|printf
argument_list|(
literal|"<text mode>"
argument_list|)
expr_stmt|;
break|break;
else|#
directive|else
case|case
name|KD_VGA
case|:
if|if
condition|(
name|crtc_addr
operator|==
name|MONO_BASE
condition|)
name|printf
argument_list|(
literal|"VGA mono"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"VGA color"
argument_list|)
expr_stmt|;
break|break;
case|case
name|KD_EGA
case|:
if|if
condition|(
name|crtc_addr
operator|==
name|MONO_BASE
condition|)
name|printf
argument_list|(
literal|"EGA mono"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"EGA color"
argument_list|)
expr_stmt|;
break|break;
case|case
name|KD_CGA
case|:
name|printf
argument_list|(
literal|"CGA"
argument_list|)
expr_stmt|;
break|break;
case|case
name|KD_MONO
case|:
case|case
name|KD_HERCULES
case|:
default|default:
name|printf
argument_list|(
literal|"MDA/hercules"
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* PC98 */
block|}
name|printf
argument_list|(
literal|"<%d virtual consoles, flags=0x%x>\n"
argument_list|,
name|MAXCONS
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|#
directive|if
name|NAPM
operator|>
literal|0
name|scp
operator|->
name|r_hook
operator|.
name|ah_fun
operator|=
name|scresume
expr_stmt|;
name|scp
operator|->
name|r_hook
operator|.
name|ah_arg
operator|=
name|NULL
expr_stmt|;
name|scp
operator|->
name|r_hook
operator|.
name|ah_name
operator|=
literal|"system keyboard"
expr_stmt|;
name|scp
operator|->
name|r_hook
operator|.
name|ah_order
operator|=
name|APM_MID_ORDER
expr_stmt|;
name|apm_hook_establish
argument_list|(
name|APM_HOOK_RESUME
argument_list|,
operator|&
name|scp
operator|->
name|r_hook
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cdevsw_add
argument_list|(
operator|&
name|cdev
argument_list|,
operator|&
name|scdevsw
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVFS
for|for
control|(
name|vc
operator|=
literal|0
init|;
name|vc
operator|<
name|MAXCONS
condition|;
name|vc
operator|++
control|)
name|sc_devfs_token
index|[
name|vc
index|]
operator|=
name|devfs_add_devswf
argument_list|(
operator|&
name|scdevsw
argument_list|,
name|vc
argument_list|,
name|DV_CHR
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0600
argument_list|,
literal|"ttyv%n"
argument_list|,
name|vc
argument_list|)
expr_stmt|;
name|sc_mouse_devfs_token
operator|=
name|devfs_add_devswf
argument_list|(
operator|&
name|scdevsw
argument_list|,
name|SC_MOUSE
argument_list|,
name|DV_CHR
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0600
argument_list|,
literal|"sysmouse"
argument_list|)
expr_stmt|;
name|sc_console_devfs_token
operator|=
name|devfs_add_devswf
argument_list|(
operator|&
name|scdevsw
argument_list|,
name|SC_CONSOLE
argument_list|,
name|DV_CHR
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0600
argument_list|,
literal|"consolectl"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_function
name|struct
name|tty
modifier|*
name|scdevtotty
parameter_list|(
name|dev_t
name|dev
parameter_list|)
block|{
name|int
name|unit
init|=
name|minor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|init_done
operator|==
name|COLD
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|unit
operator|==
name|SC_CONSOLE
condition|)
return|return
name|CONSOLE_TTY
return|;
if|if
condition|(
name|unit
operator|==
name|SC_MOUSE
condition|)
return|return
name|MOUSE_TTY
return|;
if|if
condition|(
name|unit
operator|>=
name|MAXCONS
operator|||
name|unit
operator|<
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
name|VIRTUAL_TTY
argument_list|(
name|unit
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|scopen
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|tty
modifier|*
name|tp
init|=
name|scdevtotty
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|tp
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|tp
operator|->
name|t_oproc
operator|=
operator|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|==
name|SC_MOUSE
operator|)
condition|?
name|scmousestart
else|:
name|scstart
expr_stmt|;
name|tp
operator|->
name|t_param
operator|=
name|scparam
expr_stmt|;
name|tp
operator|->
name|t_dev
operator|=
name|dev
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
condition|)
block|{
name|ttychars
argument_list|(
name|tp
argument_list|)
expr_stmt|;
comment|/* Use the current setting of the<-- key as default VERASE. */
comment|/* If the Delete key is preferable, an stty is necessary     */
name|tp
operator|->
name|t_cc
index|[
name|VERASE
index|]
operator|=
name|key_map
operator|.
name|key
index|[
literal|0x0e
index|]
operator|.
name|map
index|[
literal|0
index|]
expr_stmt|;
name|tp
operator|->
name|t_iflag
operator|=
name|TTYDEF_IFLAG
expr_stmt|;
name|tp
operator|->
name|t_oflag
operator|=
name|TTYDEF_OFLAG
expr_stmt|;
name|tp
operator|->
name|t_cflag
operator|=
name|TTYDEF_CFLAG
expr_stmt|;
name|tp
operator|->
name|t_lflag
operator|=
name|TTYDEF_LFLAG
expr_stmt|;
name|tp
operator|->
name|t_ispeed
operator|=
name|tp
operator|->
name|t_ospeed
operator|=
name|TTYDEF_SPEED
expr_stmt|;
name|scparam
argument_list|(
name|tp
argument_list|,
operator|&
name|tp
operator|->
name|t_termios
argument_list|)
expr_stmt|;
name|ttsetwater
argument_list|(
name|tp
argument_list|)
expr_stmt|;
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_modem
operator|)
operator|(
name|tp
operator|,
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|==
name|SC_MOUSE
condition|)
name|mouse_level
operator|=
literal|0
expr_stmt|;
comment|/* XXX */
block|}
elseif|else
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_XCLUDE
operator|&&
name|p
operator|->
name|p_ucred
operator|->
name|cr_uid
operator|!=
literal|0
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
if|if
condition|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|<
name|MAXCONS
operator|&&
operator|!
name|console
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
condition|)
block|{
name|console
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
operator|=
name|alloc_scp
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|<
name|MAXCONS
operator|&&
operator|!
name|tp
operator|->
name|t_winsize
operator|.
name|ws_col
operator|&&
operator|!
name|tp
operator|->
name|t_winsize
operator|.
name|ws_row
condition|)
block|{
name|tp
operator|->
name|t_winsize
operator|.
name|ws_col
operator|=
name|console
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
operator|->
name|xsize
expr_stmt|;
name|tp
operator|->
name|t_winsize
operator|.
name|ws_row
operator|=
name|console
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
operator|->
name|ysize
expr_stmt|;
block|}
return|return
operator|(
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_open
operator|)
operator|(
name|dev
operator|,
name|tp
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|scclose
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|tty
modifier|*
name|tp
init|=
name|scdevtotty
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|scr_stat
modifier|*
name|scp
decl_stmt|;
if|if
condition|(
operator|!
name|tp
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|<
name|MAXCONS
condition|)
block|{
name|scp
operator|=
name|get_scr_stat
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|status
operator|&
name|SWITCH_WAIT_ACQ
condition|)
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|scp
operator|->
name|smode
argument_list|)
expr_stmt|;
if|#
directive|if
name|not_yet_done
if|if
condition|(
name|scp
operator|==
operator|&
name|main_console
condition|)
block|{
name|scp
operator|->
name|pid
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|proc
operator|=
name|NULL
expr_stmt|;
name|scp
operator|->
name|smode
operator|.
name|mode
operator|=
name|VT_AUTO
expr_stmt|;
block|}
else|else
block|{
name|free
argument_list|(
name|scp
operator|->
name|scr_buf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|free
argument_list|(
name|scp
operator|->
name|atr_buf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|his_atr
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|scp
operator|->
name|his_atr
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|scp
operator|->
name|history
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|scp
operator|->
name|history
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|history_size
operator|/
name|scp
operator|->
name|xsize
operator|>
name|imax
argument_list|(
name|SC_HISTORY_SIZE
argument_list|,
name|scp
operator|->
name|ysize
argument_list|)
condition|)
name|extra_history_size
operator|+=
name|scp
operator|->
name|history_size
operator|/
name|scp
operator|->
name|xsize
operator|-
name|imax
argument_list|(
name|SC_HISTORY_SIZE
argument_list|,
name|scp
operator|->
name|ysize
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|scp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|console
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
operator|=
name|NULL
expr_stmt|;
block|}
else|#
directive|else
name|scp
operator|->
name|pid
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|proc
operator|=
name|NULL
expr_stmt|;
name|scp
operator|->
name|smode
operator|.
name|mode
operator|=
name|VT_AUTO
expr_stmt|;
endif|#
directive|endif
block|}
name|spltty
argument_list|()
expr_stmt|;
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_close
operator|)
operator|(
name|tp
operator|,
name|flag
operator|)
expr_stmt|;
name|ttyclose
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|spl0
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|scread
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|struct
name|tty
modifier|*
name|tp
init|=
name|scdevtotty
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|tp
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
return|return
operator|(
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_read
operator|)
operator|(
name|tp
operator|,
name|uio
operator|,
name|flag
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|scwrite
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|struct
name|tty
modifier|*
name|tp
init|=
name|scdevtotty
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|tp
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
return|return
operator|(
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_write
operator|)
operator|(
name|tp
operator|,
name|uio
operator|,
name|flag
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|scintr
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
specifier|static
name|struct
name|tty
modifier|*
name|cur_tty
decl_stmt|;
name|int
name|c
decl_stmt|,
name|len
decl_stmt|;
name|u_char
modifier|*
name|cp
decl_stmt|;
comment|/* make screensaver happy */
name|scrn_time_stamp
operator|=
name|mono_time
operator|.
name|tv_sec
expr_stmt|;
comment|/*       * Loop while there is still input to get from the keyboard.      * I don't think this is nessesary, and it doesn't fix      * the Xaccel-2.1 keyboard hang, but it can't hurt.		XXX      */
while|while
condition|(
operator|(
name|c
operator|=
name|scgetc
argument_list|(
name|SCGETC_NONBLOCK
argument_list|)
operator|)
operator|!=
name|NOKEY
condition|)
block|{
name|cur_tty
operator|=
name|VIRTUAL_TTY
argument_list|(
name|get_scr_num
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|cur_tty
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
condition|)
if|if
condition|(
operator|!
operator|(
operator|(
name|cur_tty
operator|=
name|CONSOLE_TTY
operator|)
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
condition|)
continue|continue;
switch|switch
condition|(
name|c
operator|&
literal|0xff00
condition|)
block|{
case|case
literal|0x0000
case|:
comment|/* normal key */
operator|(
operator|*
name|linesw
index|[
name|cur_tty
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
name|c
operator|&
literal|0xFF
operator|,
name|cur_tty
operator|)
expr_stmt|;
break|break;
case|case
name|FKEY
case|:
comment|/* function key, return string */
if|if
condition|(
name|cp
operator|=
name|get_fstr
argument_list|(
operator|(
name|u_int
operator|)
name|c
argument_list|,
operator|(
name|u_int
operator|*
operator|)
operator|&
name|len
argument_list|)
condition|)
block|{
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
operator|(
operator|*
name|linesw
index|[
name|cur_tty
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
operator|*
name|cp
operator|++
operator|&
literal|0xFF
operator|,
name|cur_tty
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|MKEY
case|:
comment|/* meta is active, prepend ESC */
operator|(
operator|*
name|linesw
index|[
name|cur_tty
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
literal|0x1b
operator|,
name|cur_tty
operator|)
expr_stmt|;
operator|(
operator|*
name|linesw
index|[
name|cur_tty
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
name|c
operator|&
literal|0xFF
operator|,
name|cur_tty
operator|)
expr_stmt|;
break|break;
case|case
name|BKEY
case|:
comment|/* backtab fixed sequence (esc [ Z) */
operator|(
operator|*
name|linesw
index|[
name|cur_tty
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
literal|0x1b
operator|,
name|cur_tty
operator|)
expr_stmt|;
operator|(
operator|*
name|linesw
index|[
name|cur_tty
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
literal|'['
operator|,
name|cur_tty
operator|)
expr_stmt|;
operator|(
operator|*
name|linesw
index|[
name|cur_tty
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
literal|'Z'
operator|,
name|cur_tty
operator|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|cur_console
operator|->
name|status
operator|&
name|MOUSE_ENABLED
condition|)
block|{
name|cur_console
operator|->
name|status
operator|&=
operator|~
name|MOUSE_VISIBLE
expr_stmt|;
name|remove_mouse_image
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|scparam
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|struct
name|termios
modifier|*
name|t
parameter_list|)
block|{
name|tp
operator|->
name|t_ispeed
operator|=
name|t
operator|->
name|c_ispeed
expr_stmt|;
name|tp
operator|->
name|t_ospeed
operator|=
name|t
operator|->
name|c_ospeed
expr_stmt|;
name|tp
operator|->
name|t_cflag
operator|=
name|t
operator|->
name|c_cflag
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|scioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|scr_stat
modifier|*
name|scp
decl_stmt|;
name|u_short
modifier|*
name|usp
decl_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|u_short
modifier|*
name|atr_usp
decl_stmt|;
endif|#
directive|endif
name|char
modifier|*
name|mp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|tp
operator|=
name|scdevtotty
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tp
condition|)
return|return
name|ENXIO
return|;
name|scp
operator|=
name|get_scr_stat
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
expr_stmt|;
comment|/* If there is a user_ioctl function call that first */
if|if
condition|(
name|sc_user_ioctl
condition|)
block|{
if|if
condition|(
name|error
operator|=
call|(
modifier|*
name|sc_user_ioctl
call|)
argument_list|(
name|dev
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|flag
argument_list|,
name|p
argument_list|)
condition|)
return|return
name|error
return|;
block|}
switch|switch
condition|(
name|cmd
condition|)
block|{
comment|/* process console hardware related ioctl's */
case|case
name|GIO_ATTR
case|:
comment|/* get current attributes */
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
operator|(
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
expr_stmt|;
return|return
literal|0
return|;
case|case
name|GIO_COLOR
case|:
comment|/* is this a color console ? */
ifdef|#
directive|ifdef
name|PC98
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
literal|0
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|crtc_addr
operator|==
name|COLOR_BASE
condition|)
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
literal|1
expr_stmt|;
else|else
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
case|case
name|CONS_CURRENT
case|:
comment|/* get current adapter type */
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|crtc_type
expr_stmt|;
return|return
literal|0
return|;
case|case
name|CONS_GET
case|:
comment|/* get current video mode */
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|scp
operator|->
name|mode
expr_stmt|;
return|return
literal|0
return|;
case|case
name|CONS_BLANKTIME
case|:
comment|/* set screen saver timeout (0 = no saver) */
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|<
literal|0
condition|)
return|return
name|EINVAL
return|;
name|scrn_blank_time
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
if|if
condition|(
name|scrn_blank_time
operator|==
literal|0
condition|)
name|scrn_time_stamp
operator|=
name|mono_time
operator|.
name|tv_sec
expr_stmt|;
return|return
literal|0
return|;
case|case
name|CONS_CURSORTYPE
case|:
comment|/* set cursor type blink/noblink */
if|if
condition|(
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|)
operator|&
literal|0x01
condition|)
name|flags
operator||=
name|BLINK_CURSOR
expr_stmt|;
else|else
name|flags
operator|&=
operator|~
name|BLINK_CURSOR
expr_stmt|;
if|if
condition|(
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|)
operator|&
literal|0x02
condition|)
block|{
if|if
condition|(
operator|!
name|crtc_vga
condition|)
return|return
name|ENXIO
return|;
name|flags
operator||=
name|CHAR_CURSOR
expr_stmt|;
block|}
else|else
name|flags
operator|&=
operator|~
name|CHAR_CURSOR
expr_stmt|;
comment|/*  	 * The cursor shape is global property; all virtual consoles 	 * are affected. Update the cursor in the current console... 	 */
if|if
condition|(
operator|!
operator|(
name|cur_console
operator|->
name|status
operator|&
name|UNKNOWN_MODE
operator|)
condition|)
block|{
name|remove_cursor_image
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|CHAR_CURSOR
condition|)
name|set_destructive_cursor
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
name|draw_cursor_image
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
case|case
name|CONS_BELLTYPE
case|:
comment|/* set bell type sound/visual */
if|if
condition|(
operator|*
name|data
condition|)
name|flags
operator||=
name|VISUAL_BELL
expr_stmt|;
else|else
name|flags
operator|&=
operator|~
name|VISUAL_BELL
expr_stmt|;
return|return
literal|0
return|;
case|case
name|CONS_HISTORY
case|:
comment|/* set history size */
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|>
literal|0
condition|)
block|{
name|int
name|lines
decl_stmt|;
comment|/* buffer size to allocate */
name|int
name|lines0
decl_stmt|;
comment|/* current buffer size */
name|lines
operator|=
name|imax
argument_list|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|,
name|scp
operator|->
name|ysize
argument_list|)
expr_stmt|;
name|lines0
operator|=
operator|(
name|scp
operator|->
name|history
operator|!=
name|NULL
operator|)
condition|?
name|scp
operator|->
name|history_size
operator|/
name|scp
operator|->
name|xsize
else|:
name|scp
operator|->
name|ysize
expr_stmt|;
comment|/* 	     * syscons unconditionally allocates buffers upto SC_HISTORY_SIZE 	     * lines or scp->ysize lines, whichever is larger. A value  	     * greater than that is allowed, subject to extra_history_size. 	     */
if|if
condition|(
name|lines
operator|>
name|imax
argument_list|(
name|lines0
argument_list|,
name|SC_HISTORY_SIZE
argument_list|)
operator|+
name|extra_history_size
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|cur_console
operator|->
name|status
operator|&
name|BUFFER_SAVED
condition|)
return|return
name|EBUSY
return|;
name|usp
operator|=
name|scp
operator|->
name|history
expr_stmt|;
name|scp
operator|->
name|history
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|usp
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|usp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|atr_usp
operator|=
name|scp
operator|->
name|his_atr
expr_stmt|;
name|scp
operator|->
name|his_atr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|atr_usp
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|atr_usp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|scp
operator|->
name|history_size
operator|=
name|lines
operator|*
name|scp
operator|->
name|xsize
expr_stmt|;
comment|/* 	     * extra_history_size +=  	     *    (lines0> imax(SC_HISTORY_SIZE, scp->ysize)) ?  	     *     lines0 - imax(SC_HISTORY_SIZE, scp->ysize)) : 0; 	     * extra_history_size -=  	     *    (lines> imax(SC_HISTORY_SIZE, scp->ysize)) ?  	     *	   lines - imax(SC_HISTORY_SIZE, scp->ysize)) : 0; 	     * lines0>= ysize&& lines>= ysize... Hey, the above can be  	     * reduced to the following... 	     */
name|extra_history_size
operator|+=
name|imax
argument_list|(
name|lines0
argument_list|,
name|SC_HISTORY_SIZE
argument_list|)
operator|-
name|imax
argument_list|(
name|lines
argument_list|,
name|SC_HISTORY_SIZE
argument_list|)
expr_stmt|;
name|usp
operator|=
operator|(
name|u_short
operator|*
operator|)
name|malloc
argument_list|(
name|scp
operator|->
name|history_size
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|usp
argument_list|,
name|scp
operator|->
name|history_size
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|scp
operator|->
name|history_head
operator|=
name|scp
operator|->
name|history_pos
operator|=
name|usp
expr_stmt|;
name|scp
operator|->
name|history
operator|=
name|usp
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|atr_usp
operator|=
operator|(
name|u_short
operator|*
operator|)
name|malloc
argument_list|(
name|scp
operator|->
name|history_size
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|atr_usp
argument_list|,
name|scp
operator|->
name|history_size
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|scp
operator|->
name|his_atr_head
operator|=
name|scp
operator|->
name|his_atr_pos
operator|=
name|atr_usp
expr_stmt|;
name|scp
operator|->
name|his_atr
operator|=
name|atr_usp
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
else|else
return|return
name|EINVAL
return|;
case|case
name|CONS_MOUSECTL
case|:
comment|/* control mouse arrow */
case|case
name|OLD_CONS_MOUSECTL
case|:
block|{
comment|/* MOUSE_BUTTON?DOWN -> MOUSE_MSC_BUTTON?UP */
specifier|static
name|butmap
index|[
literal|8
index|]
operator|=
block|{
name|MOUSE_MSC_BUTTON1UP
operator||
name|MOUSE_MSC_BUTTON2UP
operator||
name|MOUSE_MSC_BUTTON3UP
block|,
name|MOUSE_MSC_BUTTON2UP
operator||
name|MOUSE_MSC_BUTTON3UP
block|,
name|MOUSE_MSC_BUTTON1UP
operator||
name|MOUSE_MSC_BUTTON3UP
block|,
name|MOUSE_MSC_BUTTON3UP
block|,
name|MOUSE_MSC_BUTTON1UP
operator||
name|MOUSE_MSC_BUTTON2UP
block|,
name|MOUSE_MSC_BUTTON2UP
block|,
name|MOUSE_MSC_BUTTON1UP
block|,
literal|0
block|, 	}
expr_stmt|;
name|mouse_info_t
modifier|*
name|mouse
init|=
operator|(
name|mouse_info_t
operator|*
operator|)
name|data
decl_stmt|;
name|mouse_info_t
name|buf
decl_stmt|;
if|if
condition|(
operator|!
name|crtc_vga
condition|)
return|return
name|ENODEV
return|;
if|if
condition|(
name|cmd
operator|==
name|OLD_CONS_MOUSECTL
condition|)
block|{
specifier|static
name|unsigned
name|char
name|swapb
index|[]
init|=
block|{
literal|0
block|,
literal|4
block|,
literal|2
block|,
literal|6
block|,
literal|1
block|,
literal|5
block|,
literal|3
block|,
literal|7
block|}
decl_stmt|;
name|old_mouse_info_t
modifier|*
name|old_mouse
init|=
operator|(
name|old_mouse_info_t
operator|*
operator|)
name|data
decl_stmt|;
name|mouse
operator|=
operator|&
name|buf
expr_stmt|;
name|mouse
operator|->
name|operation
operator|=
name|old_mouse
operator|->
name|operation
expr_stmt|;
switch|switch
condition|(
name|mouse
operator|->
name|operation
condition|)
block|{
case|case
name|MOUSE_MODE
case|:
name|mouse
operator|->
name|u
operator|.
name|mode
operator|=
name|old_mouse
operator|->
name|u
operator|.
name|mode
expr_stmt|;
break|break;
case|case
name|MOUSE_SHOW
case|:
case|case
name|MOUSE_HIDE
case|:
break|break;
case|case
name|MOUSE_MOVEABS
case|:
case|case
name|MOUSE_MOVEREL
case|:
case|case
name|MOUSE_ACTION
case|:
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|x
operator|=
name|old_mouse
operator|->
name|u
operator|.
name|data
operator|.
name|x
expr_stmt|;
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|y
operator|=
name|old_mouse
operator|->
name|u
operator|.
name|data
operator|.
name|y
expr_stmt|;
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|z
operator|=
literal|0
expr_stmt|;
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|buttons
operator|=
name|swapb
index|[
name|old_mouse
operator|->
name|u
operator|.
name|data
operator|.
name|buttons
operator|&
literal|0x7
index|]
expr_stmt|;
break|break;
case|case
name|MOUSE_GETINFO
case|:
name|old_mouse
operator|->
name|u
operator|.
name|data
operator|.
name|x
operator|=
name|scp
operator|->
name|mouse_xpos
expr_stmt|;
name|old_mouse
operator|->
name|u
operator|.
name|data
operator|.
name|y
operator|=
name|scp
operator|->
name|mouse_ypos
expr_stmt|;
name|old_mouse
operator|->
name|u
operator|.
name|data
operator|.
name|buttons
operator|=
name|swapb
index|[
name|scp
operator|->
name|mouse_buttons
operator|&
literal|0x7
index|]
expr_stmt|;
break|break;
default|default:
return|return
name|EINVAL
return|;
block|}
block|}
switch|switch
condition|(
name|mouse
operator|->
name|operation
condition|)
block|{
case|case
name|MOUSE_MODE
case|:
if|if
condition|(
name|ISSIGVALID
argument_list|(
name|mouse
operator|->
name|u
operator|.
name|mode
operator|.
name|signal
argument_list|)
condition|)
block|{
name|scp
operator|->
name|mouse_signal
operator|=
name|mouse
operator|->
name|u
operator|.
name|mode
operator|.
name|signal
expr_stmt|;
name|scp
operator|->
name|mouse_proc
operator|=
name|p
expr_stmt|;
name|scp
operator|->
name|mouse_pid
operator|=
name|p
operator|->
name|p_pid
expr_stmt|;
block|}
else|else
block|{
name|scp
operator|->
name|mouse_signal
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|mouse_proc
operator|=
name|NULL
expr_stmt|;
name|scp
operator|->
name|mouse_pid
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|MOUSE_SHOW
case|:
if|if
condition|(
operator|!
operator|(
name|scp
operator|->
name|status
operator|&
name|MOUSE_ENABLED
operator|)
condition|)
block|{
name|scp
operator|->
name|status
operator||=
operator|(
name|MOUSE_ENABLED
operator||
name|MOUSE_VISIBLE
operator|)
expr_stmt|;
name|scp
operator|->
name|mouse_oldpos
operator|=
name|scp
operator|->
name|mouse_pos
expr_stmt|;
name|mark_all
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
else|else
return|return
name|EINVAL
return|;
break|break;
case|case
name|MOUSE_HIDE
case|:
if|if
condition|(
name|scp
operator|->
name|status
operator|&
name|MOUSE_ENABLED
condition|)
block|{
name|scp
operator|->
name|status
operator|&=
operator|~
operator|(
name|MOUSE_ENABLED
operator||
name|MOUSE_VISIBLE
operator|)
expr_stmt|;
name|mark_all
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
else|else
return|return
name|EINVAL
return|;
break|break;
case|case
name|MOUSE_MOVEABS
case|:
name|scp
operator|->
name|mouse_xpos
operator|=
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|x
expr_stmt|;
name|scp
operator|->
name|mouse_ypos
operator|=
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|y
expr_stmt|;
name|set_mouse_pos
argument_list|(
name|scp
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOUSE_MOVEREL
case|:
name|scp
operator|->
name|mouse_xpos
operator|+=
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|x
expr_stmt|;
name|scp
operator|->
name|mouse_ypos
operator|+=
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|y
expr_stmt|;
name|set_mouse_pos
argument_list|(
name|scp
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOUSE_GETINFO
case|:
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|x
operator|=
name|scp
operator|->
name|mouse_xpos
expr_stmt|;
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|y
operator|=
name|scp
operator|->
name|mouse_ypos
expr_stmt|;
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|z
operator|=
literal|0
expr_stmt|;
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|buttons
operator|=
name|scp
operator|->
name|mouse_buttons
expr_stmt|;
break|break;
case|case
name|MOUSE_ACTION
case|:
case|case
name|MOUSE_MOTION_EVENT
case|:
comment|/* this should maybe only be settable from /dev/consolectl SOS */
comment|/* send out mouse event on /dev/sysmouse */
name|mouse_status
operator|.
name|dx
operator|+=
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|x
expr_stmt|;
name|mouse_status
operator|.
name|dy
operator|+=
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|y
expr_stmt|;
name|mouse_status
operator|.
name|dz
operator|+=
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|z
expr_stmt|;
if|if
condition|(
name|mouse
operator|->
name|operation
operator|==
name|MOUSE_ACTION
condition|)
name|mouse_status
operator|.
name|button
operator|=
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|buttons
expr_stmt|;
name|mouse_status
operator|.
name|flags
operator||=
operator|(
operator|(
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|x
operator|||
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|y
operator|||
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|z
operator|)
condition|?
name|MOUSE_POSCHANGED
else|:
literal|0
operator|)
operator||
operator|(
name|mouse_status
operator|.
name|obutton
operator|^
name|mouse_status
operator|.
name|button
operator|)
expr_stmt|;
if|if
condition|(
name|cur_console
operator|->
name|status
operator|&
name|MOUSE_ENABLED
condition|)
name|cur_console
operator|->
name|status
operator||=
name|MOUSE_VISIBLE
expr_stmt|;
if|if
condition|(
operator|(
name|MOUSE_TTY
operator|)
operator|->
name|t_state
operator|&
name|TS_ISOPEN
condition|)
block|{
name|u_char
name|buf
index|[
name|MOUSE_SYS_PACKETSIZE
index|]
decl_stmt|;
name|int
name|j
decl_stmt|;
comment|/* the first five bytes are compatible with MouseSystems' */
name|buf
index|[
literal|0
index|]
operator|=
name|MOUSE_MSC_SYNC
operator||
name|butmap
index|[
name|mouse_status
operator|.
name|button
operator|&
name|MOUSE_STDBUTTONS
index|]
expr_stmt|;
name|j
operator|=
name|imax
argument_list|(
name|imin
argument_list|(
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|x
argument_list|,
literal|255
argument_list|)
argument_list|,
operator|-
literal|256
argument_list|)
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|j
operator|>>
literal|1
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
name|j
operator|-
name|buf
index|[
literal|1
index|]
expr_stmt|;
name|j
operator|=
operator|-
name|imax
argument_list|(
name|imin
argument_list|(
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|y
argument_list|,
literal|255
argument_list|)
argument_list|,
operator|-
literal|256
argument_list|)
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|j
operator|>>
literal|1
expr_stmt|;
name|buf
index|[
literal|4
index|]
operator|=
name|j
operator|-
name|buf
index|[
literal|2
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MOUSE_MSC_PACKETSIZE
condition|;
name|j
operator|++
control|)
operator|(
operator|*
name|linesw
index|[
operator|(
name|MOUSE_TTY
operator|)
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
name|buf
index|[
name|j
index|]
operator|,
name|MOUSE_TTY
operator|)
expr_stmt|;
if|if
condition|(
name|mouse_level
operator|>=
literal|1
condition|)
block|{
comment|/* extended part */
name|j
operator|=
name|imax
argument_list|(
name|imin
argument_list|(
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|z
argument_list|,
literal|127
argument_list|)
argument_list|,
operator|-
literal|128
argument_list|)
expr_stmt|;
name|buf
index|[
literal|5
index|]
operator|=
operator|(
name|j
operator|>>
literal|1
operator|)
operator|&
literal|0x7f
expr_stmt|;
name|buf
index|[
literal|6
index|]
operator|=
operator|(
name|j
operator|-
operator|(
name|j
operator|>>
literal|1
operator|)
operator|)
operator|&
literal|0x7f
expr_stmt|;
comment|/* buttons 4-10 */
name|buf
index|[
literal|7
index|]
operator|=
operator|(
operator|~
name|mouse_status
operator|.
name|button
operator|>>
literal|3
operator|)
operator|&
literal|0x7f
expr_stmt|;
for|for
control|(
name|j
operator|=
name|MOUSE_MSC_PACKETSIZE
init|;
name|j
operator|<
name|MOUSE_SYS_PACKETSIZE
condition|;
name|j
operator|++
control|)
operator|(
operator|*
name|linesw
index|[
operator|(
name|MOUSE_TTY
operator|)
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
name|buf
index|[
name|j
index|]
operator|,
name|MOUSE_TTY
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cur_console
operator|->
name|mouse_signal
condition|)
block|{
name|cur_console
operator|->
name|mouse_buttons
operator|=
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|buttons
expr_stmt|;
comment|/* has controlling process died? */
if|if
condition|(
name|cur_console
operator|->
name|mouse_proc
operator|&&
operator|(
name|cur_console
operator|->
name|mouse_proc
operator|!=
name|pfind
argument_list|(
name|cur_console
operator|->
name|mouse_pid
argument_list|)
operator|)
condition|)
block|{
name|cur_console
operator|->
name|mouse_signal
operator|=
literal|0
expr_stmt|;
name|cur_console
operator|->
name|mouse_proc
operator|=
name|NULL
expr_stmt|;
name|cur_console
operator|->
name|mouse_pid
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|psignal
argument_list|(
name|cur_console
operator|->
name|mouse_proc
argument_list|,
name|cur_console
operator|->
name|mouse_signal
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mouse
operator|->
name|operation
operator|==
name|MOUSE_ACTION
condition|)
block|{
comment|/* process button presses */
if|if
condition|(
operator|(
name|cur_console
operator|->
name|mouse_buttons
operator|^
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|buttons
operator|)
operator|&&
operator|!
operator|(
name|cur_console
operator|->
name|status
operator|&
name|UNKNOWN_MODE
operator|)
condition|)
block|{
name|cur_console
operator|->
name|mouse_buttons
operator|=
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|buttons
expr_stmt|;
if|if
condition|(
name|cur_console
operator|->
name|mouse_buttons
operator|&
name|MOUSE_BUTTON1DOWN
condition|)
name|mouse_cut_start
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
else|else
name|mouse_cut_end
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_console
operator|->
name|mouse_buttons
operator|&
name|MOUSE_BUTTON2DOWN
operator|||
name|cur_console
operator|->
name|mouse_buttons
operator|&
name|MOUSE_BUTTON3DOWN
condition|)
name|mouse_paste
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|x
operator|!=
literal|0
operator|||
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|y
operator|!=
literal|0
condition|)
block|{
name|cur_console
operator|->
name|mouse_xpos
operator|+=
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|x
expr_stmt|;
name|cur_console
operator|->
name|mouse_ypos
operator|+=
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|y
expr_stmt|;
name|set_mouse_pos
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MOUSE_BUTTON_EVENT
case|:
if|if
condition|(
operator|(
name|mouse
operator|->
name|u
operator|.
name|event
operator|.
name|id
operator|&
name|MOUSE_BUTTONS
operator|)
operator|==
literal|0
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|mouse
operator|->
name|u
operator|.
name|event
operator|.
name|value
operator|<
literal|0
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|mouse
operator|->
name|u
operator|.
name|event
operator|.
name|value
operator|>
literal|0
condition|)
block|{
name|cur_console
operator|->
name|mouse_buttons
operator||=
name|mouse
operator|->
name|u
operator|.
name|event
operator|.
name|id
expr_stmt|;
name|mouse_status
operator|.
name|button
operator||=
name|mouse
operator|->
name|u
operator|.
name|event
operator|.
name|id
expr_stmt|;
block|}
else|else
block|{
name|cur_console
operator|->
name|mouse_buttons
operator|&=
operator|~
name|mouse
operator|->
name|u
operator|.
name|event
operator|.
name|id
expr_stmt|;
name|mouse_status
operator|.
name|button
operator|&=
operator|~
name|mouse
operator|->
name|u
operator|.
name|event
operator|.
name|id
expr_stmt|;
block|}
name|mouse_status
operator|.
name|flags
operator||=
operator|(
operator|(
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|x
operator|||
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|y
operator|||
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|z
operator|)
condition|?
name|MOUSE_POSCHANGED
else|:
literal|0
operator|)
operator||
operator|(
name|mouse_status
operator|.
name|obutton
operator|^
name|mouse_status
operator|.
name|button
operator|)
expr_stmt|;
if|if
condition|(
name|cur_console
operator|->
name|status
operator|&
name|MOUSE_ENABLED
condition|)
name|cur_console
operator|->
name|status
operator||=
name|MOUSE_VISIBLE
expr_stmt|;
if|if
condition|(
operator|(
name|MOUSE_TTY
operator|)
operator|->
name|t_state
operator|&
name|TS_ISOPEN
condition|)
block|{
name|u_char
name|buf
index|[
literal|8
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|MOUSE_MSC_SYNC
operator||
name|butmap
index|[
name|mouse_status
operator|.
name|button
operator|&
name|MOUSE_STDBUTTONS
index|]
expr_stmt|;
name|buf
index|[
literal|7
index|]
operator|=
operator|(
operator|~
name|mouse_status
operator|.
name|button
operator|>>
literal|3
operator|)
operator|&
literal|0x7f
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|buf
index|[
literal|2
index|]
operator|=
name|buf
index|[
literal|3
index|]
operator|=
name|buf
index|[
literal|4
index|]
operator|=
name|buf
index|[
literal|5
index|]
operator|=
name|buf
index|[
literal|6
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
operator|(
name|mouse_level
operator|>=
literal|1
operator|)
condition|?
name|MOUSE_SYS_PACKETSIZE
else|:
name|MOUSE_MSC_PACKETSIZE
operator|)
condition|;
name|i
operator|++
control|)
operator|(
operator|*
name|linesw
index|[
operator|(
name|MOUSE_TTY
operator|)
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
name|buf
index|[
name|i
index|]
operator|,
name|MOUSE_TTY
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|cur_console
operator|->
name|mouse_signal
condition|)
block|{
if|if
condition|(
name|cur_console
operator|->
name|mouse_proc
operator|&&
operator|(
name|cur_console
operator|->
name|mouse_proc
operator|!=
name|pfind
argument_list|(
name|cur_console
operator|->
name|mouse_pid
argument_list|)
operator|)
condition|)
block|{
name|cur_console
operator|->
name|mouse_signal
operator|=
literal|0
expr_stmt|;
name|cur_console
operator|->
name|mouse_proc
operator|=
name|NULL
expr_stmt|;
name|cur_console
operator|->
name|mouse_pid
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|psignal
argument_list|(
name|cur_console
operator|->
name|mouse_proc
argument_list|,
name|cur_console
operator|->
name|mouse_signal
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cur_console
operator|->
name|status
operator|&
name|UNKNOWN_MODE
condition|)
break|break;
switch|switch
condition|(
name|mouse
operator|->
name|u
operator|.
name|event
operator|.
name|id
condition|)
block|{
case|case
name|MOUSE_BUTTON1DOWN
case|:
switch|switch
condition|(
name|mouse
operator|->
name|u
operator|.
name|event
operator|.
name|value
operator|%
literal|4
condition|)
block|{
case|case
literal|0
case|:
comment|/* up */
name|mouse_cut_end
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|mouse_cut_start
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|mouse_cut_word
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|mouse_cut_line
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|MOUSE_BUTTON2DOWN
case|:
switch|switch
condition|(
name|mouse
operator|->
name|u
operator|.
name|event
operator|.
name|value
condition|)
block|{
case|case
literal|0
case|:
comment|/* up */
break|break;
default|default:
name|mouse_paste
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|MOUSE_BUTTON3DOWN
case|:
switch|switch
condition|(
name|mouse
operator|->
name|u
operator|.
name|event
operator|.
name|value
condition|)
block|{
case|case
literal|0
case|:
comment|/* up */
if|if
condition|(
operator|!
operator|(
name|cur_console
operator|->
name|mouse_buttons
operator|&
name|MOUSE_BUTTON1DOWN
operator|)
condition|)
name|mouse_cut_end
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
break|break;
default|default:
name|mouse_cut_extend
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
block|}
break|break;
default|default:
return|return
name|EINVAL
return|;
block|}
comment|/* make screensaver happy */
name|scrn_time_stamp
operator|=
name|mono_time
operator|.
name|tv_sec
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* MOUSE_XXX: /dev/sysmouse ioctls */
case|case
name|MOUSE_GETHWINFO
case|:
comment|/* get device information */
block|{
name|mousehw_t
modifier|*
name|hw
init|=
operator|(
name|mousehw_t
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|tp
operator|!=
name|MOUSE_TTY
condition|)
return|return
name|ENOTTY
return|;
name|hw
operator|->
name|buttons
operator|=
literal|10
expr_stmt|;
comment|/* XXX unknown */
name|hw
operator|->
name|iftype
operator|=
name|MOUSE_IF_SYSMOUSE
expr_stmt|;
name|hw
operator|->
name|type
operator|=
name|MOUSE_MOUSE
expr_stmt|;
name|hw
operator|->
name|model
operator|=
name|MOUSE_MODEL_GENERIC
expr_stmt|;
name|hw
operator|->
name|hwid
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
case|case
name|MOUSE_GETMODE
case|:
comment|/* get protocol/mode */
block|{
name|mousemode_t
modifier|*
name|mode
init|=
operator|(
name|mousemode_t
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|tp
operator|!=
name|MOUSE_TTY
condition|)
return|return
name|ENOTTY
return|;
name|mode
operator|->
name|level
operator|=
name|mouse_level
expr_stmt|;
switch|switch
condition|(
name|mode
operator|->
name|level
condition|)
block|{
case|case
literal|0
case|:
comment|/* at this level, sysmouse emulates MouseSystems protocol */
name|mode
operator|->
name|protocol
operator|=
name|MOUSE_PROTO_MSC
expr_stmt|;
name|mode
operator|->
name|rate
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* unknown */
name|mode
operator|->
name|resolution
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* unknown */
name|mode
operator|->
name|accelfactor
operator|=
literal|0
expr_stmt|;
comment|/* disabled */
name|mode
operator|->
name|packetsize
operator|=
name|MOUSE_MSC_PACKETSIZE
expr_stmt|;
name|mode
operator|->
name|syncmask
index|[
literal|0
index|]
operator|=
name|MOUSE_MSC_SYNCMASK
expr_stmt|;
name|mode
operator|->
name|syncmask
index|[
literal|1
index|]
operator|=
name|MOUSE_MSC_SYNC
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* at this level, sysmouse uses its own protocol */
name|mode
operator|->
name|protocol
operator|=
name|MOUSE_PROTO_SYSMOUSE
expr_stmt|;
name|mode
operator|->
name|rate
operator|=
operator|-
literal|1
expr_stmt|;
name|mode
operator|->
name|resolution
operator|=
operator|-
literal|1
expr_stmt|;
name|mode
operator|->
name|accelfactor
operator|=
literal|0
expr_stmt|;
name|mode
operator|->
name|packetsize
operator|=
name|MOUSE_SYS_PACKETSIZE
expr_stmt|;
name|mode
operator|->
name|syncmask
index|[
literal|0
index|]
operator|=
name|MOUSE_SYS_SYNCMASK
expr_stmt|;
name|mode
operator|->
name|syncmask
index|[
literal|1
index|]
operator|=
name|MOUSE_SYS_SYNC
expr_stmt|;
break|break;
block|}
return|return
literal|0
return|;
block|}
case|case
name|MOUSE_SETMODE
case|:
comment|/* set protocol/mode */
block|{
name|mousemode_t
modifier|*
name|mode
init|=
operator|(
name|mousemode_t
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|tp
operator|!=
name|MOUSE_TTY
condition|)
return|return
name|ENOTTY
return|;
if|if
condition|(
operator|(
name|mode
operator|->
name|level
operator|<
literal|0
operator|)
operator|||
operator|(
name|mode
operator|->
name|level
operator|>
literal|1
operator|)
condition|)
return|return
name|EINVAL
return|;
name|mouse_level
operator|=
name|mode
operator|->
name|level
expr_stmt|;
return|return
literal|0
return|;
block|}
case|case
name|MOUSE_GETLEVEL
case|:
comment|/* get operation level */
if|if
condition|(
name|tp
operator|!=
name|MOUSE_TTY
condition|)
return|return
name|ENOTTY
return|;
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|mouse_level
expr_stmt|;
return|return
literal|0
return|;
case|case
name|MOUSE_SETLEVEL
case|:
comment|/* set operation level */
if|if
condition|(
name|tp
operator|!=
name|MOUSE_TTY
condition|)
return|return
name|ENOTTY
return|;
if|if
condition|(
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|<
literal|0
operator|)
operator|||
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|>
literal|1
operator|)
condition|)
return|return
name|EINVAL
return|;
name|mouse_level
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
return|return
literal|0
return|;
case|case
name|MOUSE_GETSTATUS
case|:
comment|/* get accumulated mouse events */
if|if
condition|(
name|tp
operator|!=
name|MOUSE_TTY
condition|)
return|return
name|ENOTTY
return|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
operator|*
operator|(
name|mousestatus_t
operator|*
operator|)
name|data
operator|=
name|mouse_status
expr_stmt|;
name|mouse_status
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|mouse_status
operator|.
name|obutton
operator|=
name|mouse_status
operator|.
name|button
expr_stmt|;
name|mouse_status
operator|.
name|dx
operator|=
literal|0
expr_stmt|;
name|mouse_status
operator|.
name|dy
operator|=
literal|0
expr_stmt|;
name|mouse_status
operator|.
name|dz
operator|=
literal|0
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
if|#
directive|if
name|notyet
case|case
name|MOUSE_GETVARS
case|:
comment|/* get internal mouse variables */
case|case
name|MOUSE_SETVARS
case|:
comment|/* set internal mouse variables */
if|if
condition|(
name|tp
operator|!=
name|MOUSE_TTY
condition|)
return|return
name|ENOTTY
return|;
return|return
name|ENODEV
return|;
endif|#
directive|endif
case|case
name|MOUSE_READSTATE
case|:
comment|/* read status from the device */
case|case
name|MOUSE_READDATA
case|:
comment|/* read data from the device */
if|if
condition|(
name|tp
operator|!=
name|MOUSE_TTY
condition|)
return|return
name|ENOTTY
return|;
return|return
name|ENODEV
return|;
case|case
name|CONS_GETINFO
case|:
comment|/* get current (virtual) console info */
block|{
name|vid_info_t
modifier|*
name|ptr
init|=
operator|(
name|vid_info_t
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|ptr
operator|->
name|size
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|vid_info
argument_list|)
condition|)
block|{
name|ptr
operator|->
name|m_num
operator|=
name|get_scr_num
argument_list|()
expr_stmt|;
name|ptr
operator|->
name|mv_col
operator|=
name|scp
operator|->
name|xpos
expr_stmt|;
name|ptr
operator|->
name|mv_row
operator|=
name|scp
operator|->
name|ypos
expr_stmt|;
name|ptr
operator|->
name|mv_csz
operator|=
name|scp
operator|->
name|xsize
expr_stmt|;
name|ptr
operator|->
name|mv_rsz
operator|=
name|scp
operator|->
name|ysize
expr_stmt|;
name|ptr
operator|->
name|mv_norm
operator|.
name|fore
operator|=
operator|(
name|scp
operator|->
name|term
operator|.
name|std_color
operator|&
literal|0x0f00
operator|)
operator|>>
literal|8
expr_stmt|;
name|ptr
operator|->
name|mv_norm
operator|.
name|back
operator|=
operator|(
name|scp
operator|->
name|term
operator|.
name|std_color
operator|&
literal|0xf000
operator|)
operator|>>
literal|12
expr_stmt|;
name|ptr
operator|->
name|mv_rev
operator|.
name|fore
operator|=
operator|(
name|scp
operator|->
name|term
operator|.
name|rev_color
operator|&
literal|0x0f00
operator|)
operator|>>
literal|8
expr_stmt|;
name|ptr
operator|->
name|mv_rev
operator|.
name|back
operator|=
operator|(
name|scp
operator|->
name|term
operator|.
name|rev_color
operator|&
literal|0xf000
operator|)
operator|>>
literal|12
expr_stmt|;
name|ptr
operator|->
name|mv_grfc
operator|.
name|fore
operator|=
literal|0
expr_stmt|;
comment|/* not supported */
name|ptr
operator|->
name|mv_grfc
operator|.
name|back
operator|=
literal|0
expr_stmt|;
comment|/* not supported */
name|ptr
operator|->
name|mv_ovscan
operator|=
name|scp
operator|->
name|border
expr_stmt|;
name|ptr
operator|->
name|mk_keylock
operator|=
name|scp
operator|->
name|status
operator|&
name|LOCK_KEY_MASK
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|EINVAL
return|;
block|}
case|case
name|CONS_GETVERS
case|:
comment|/* get version number */
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
literal|0x200
expr_stmt|;
comment|/* version 2.0 */
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|PC98
case|case
name|SW_PC98_80x25
case|:
case|case
name|SW_PC98_80x30
case|:
comment|/* PC98 TEXT MODES */
if|if
condition|(
operator|!
name|crtc_vga
condition|)
return|return
name|ENXIO
return|;
name|scp
operator|->
name|xsize
operator|=
literal|80
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|history
operator|!=
name|NULL
condition|)
name|i
operator|=
name|imax
argument_list|(
name|scp
operator|->
name|history_size
operator|/
name|scp
operator|->
name|xsize
operator|-
name|imax
argument_list|(
name|SC_HISTORY_SIZE
argument_list|,
name|scp
operator|->
name|ysize
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|i
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|cmd
operator|&
literal|0xff
condition|)
block|{
case|case
name|M_PC98_80x25
case|:
name|scp
operator|->
name|ysize
operator|=
literal|25
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|LINE30
case|case
name|M_PC98_80x30
case|:
name|scp
operator|->
name|ysize
operator|=
name|LINE30_ROW
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
return|return
name|EINVAL
return|;
block|}
else|#
directive|else
comment|/* IBM-PC */
comment|/* VGA TEXT MODES */
case|case
name|SW_VGA_C40x25
case|:
case|case
name|SW_VGA_C80x25
case|:
case|case
name|SW_VGA_M80x25
case|:
case|case
name|SW_VGA_C80x30
case|:
case|case
name|SW_VGA_M80x30
case|:
case|case
name|SW_VGA_C80x50
case|:
case|case
name|SW_VGA_M80x50
case|:
case|case
name|SW_VGA_C80x60
case|:
case|case
name|SW_VGA_M80x60
case|:
case|case
name|SW_B40x25
case|:
case|case
name|SW_C40x25
case|:
case|case
name|SW_B80x25
case|:
case|case
name|SW_C80x25
case|:
case|case
name|SW_ENH_B40x25
case|:
case|case
name|SW_ENH_C40x25
case|:
case|case
name|SW_ENH_B80x25
case|:
case|case
name|SW_ENH_C80x25
case|:
case|case
name|SW_ENH_B80x43
case|:
case|case
name|SW_ENH_C80x43
case|:
case|case
name|SW_EGAMONO80x25
case|:
if|if
condition|(
operator|!
name|crtc_vga
condition|)
return|return
name|ENODEV
return|;
name|mp
operator|=
name|get_mode_param
argument_list|(
name|scp
argument_list|,
name|cmd
operator|&
literal|0xff
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|==
name|NULL
condition|)
return|return
name|ENODEV
return|;
if|if
condition|(
name|scp
operator|->
name|history
operator|!=
name|NULL
condition|)
name|i
operator|=
name|imax
argument_list|(
name|scp
operator|->
name|history_size
operator|/
name|scp
operator|->
name|xsize
operator|-
name|imax
argument_list|(
name|SC_HISTORY_SIZE
argument_list|,
name|scp
operator|->
name|ysize
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|i
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|cmd
operator|&
literal|0xff
condition|)
block|{
case|case
name|M_VGA_C80x60
case|:
case|case
name|M_VGA_M80x60
case|:
if|if
condition|(
operator|!
operator|(
name|fonts_loaded
operator|&
name|FONT_8
operator|)
condition|)
return|return
name|EINVAL
return|;
name|scp
operator|->
name|xsize
operator|=
literal|80
expr_stmt|;
name|scp
operator|->
name|ysize
operator|=
literal|60
expr_stmt|;
break|break;
case|case
name|M_VGA_C80x50
case|:
case|case
name|M_VGA_M80x50
case|:
if|if
condition|(
operator|!
operator|(
name|fonts_loaded
operator|&
name|FONT_8
operator|)
condition|)
return|return
name|EINVAL
return|;
name|scp
operator|->
name|xsize
operator|=
literal|80
expr_stmt|;
name|scp
operator|->
name|ysize
operator|=
literal|50
expr_stmt|;
break|break;
case|case
name|M_ENH_B80x43
case|:
case|case
name|M_ENH_C80x43
case|:
if|if
condition|(
operator|!
operator|(
name|fonts_loaded
operator|&
name|FONT_8
operator|)
condition|)
return|return
name|EINVAL
return|;
name|scp
operator|->
name|xsize
operator|=
literal|80
expr_stmt|;
name|scp
operator|->
name|ysize
operator|=
literal|43
expr_stmt|;
break|break;
case|case
name|M_VGA_C80x30
case|:
case|case
name|M_VGA_M80x30
case|:
name|scp
operator|->
name|xsize
operator|=
literal|80
expr_stmt|;
name|scp
operator|->
name|ysize
operator|=
literal|30
expr_stmt|;
break|break;
case|case
name|M_ENH_C40x25
case|:
case|case
name|M_ENH_B40x25
case|:
case|case
name|M_ENH_C80x25
case|:
case|case
name|M_ENH_B80x25
case|:
case|case
name|M_EGAMONO80x25
case|:
if|if
condition|(
operator|!
operator|(
name|fonts_loaded
operator|&
name|FONT_14
operator|)
condition|)
return|return
name|EINVAL
return|;
comment|/* FALL THROUGH */
default|default:
if|if
condition|(
operator|(
name|cmd
operator|&
literal|0xff
operator|)
operator|>
name|M_VGA_CG320
condition|)
return|return
name|EINVAL
return|;
name|scp
operator|->
name|xsize
operator|=
name|mp
index|[
literal|0
index|]
expr_stmt|;
name|scp
operator|->
name|ysize
operator|=
name|mp
index|[
literal|1
index|]
operator|+
name|rows_offset
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
name|scp
operator|->
name|mode
operator|=
name|cmd
operator|&
literal|0xff
expr_stmt|;
name|free
argument_list|(
name|scp
operator|->
name|scr_buf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|scp
operator|->
name|scr_buf
operator|=
operator|(
name|u_short
operator|*
operator|)
name|malloc
argument_list|(
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|scp
operator|->
name|cursor_pos
operator|=
name|scp
operator|->
name|cursor_oldpos
operator|=
name|scp
operator|->
name|scr_buf
operator|+
name|scp
operator|->
name|xpos
operator|+
name|scp
operator|->
name|ypos
operator|*
name|scp
operator|->
name|xsize
expr_stmt|;
name|scp
operator|->
name|mouse_pos
operator|=
name|scp
operator|->
name|mouse_oldpos
operator|=
name|scp
operator|->
name|scr_buf
operator|+
operator|(
operator|(
name|scp
operator|->
name|mouse_ypos
operator|/
name|scp
operator|->
name|font_size
operator|)
operator|*
name|scp
operator|->
name|xsize
operator|+
name|scp
operator|->
name|mouse_xpos
operator|/
literal|8
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|free
argument_list|(
name|scp
operator|->
name|atr_buf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|scp
operator|->
name|atr_buf
operator|=
operator|(
name|u_short
operator|*
operator|)
name|malloc
argument_list|(
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|scp
operator|->
name|cursor_atr
operator|=
name|scp
operator|->
name|atr_buf
operator|+
name|scp
operator|->
name|xpos
operator|+
name|scp
operator|->
name|ypos
operator|*
name|scp
operator|->
name|xsize
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
name|cut_buffer
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|cut_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|cut_buffer
index|[
literal|0
index|]
operator|=
literal|0x00
expr_stmt|;
name|usp
operator|=
name|scp
operator|->
name|history
expr_stmt|;
name|scp
operator|->
name|history
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|usp
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|usp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|extra_history_size
operator|+=
name|i
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PC98
name|atr_usp
operator|=
name|scp
operator|->
name|his_atr
expr_stmt|;
name|scp
operator|->
name|his_atr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|atr_usp
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|atr_usp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|scp
operator|->
name|history_size
operator|=
name|imax
argument_list|(
name|SC_HISTORY_SIZE
argument_list|,
name|scp
operator|->
name|ysize
argument_list|)
operator|*
name|scp
operator|->
name|xsize
expr_stmt|;
name|usp
operator|=
operator|(
name|u_short
operator|*
operator|)
name|malloc
argument_list|(
name|scp
operator|->
name|history_size
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|usp
operator|!=
name|NULL
condition|)
name|bzero
argument_list|(
name|usp
argument_list|,
name|scp
operator|->
name|history_size
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|scp
operator|->
name|history_head
operator|=
name|scp
operator|->
name|history_pos
operator|=
name|usp
expr_stmt|;
name|scp
operator|->
name|history
operator|=
name|usp
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|atr_usp
operator|=
operator|(
name|u_short
operator|*
operator|)
name|malloc
argument_list|(
name|scp
operator|->
name|history_size
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|atr_usp
operator|!=
name|NULL
condition|)
name|bzero
argument_list|(
name|atr_usp
argument_list|,
name|scp
operator|->
name|history_size
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|scp
operator|->
name|his_atr_head
operator|=
name|scp
operator|->
name|his_atr_pos
operator|=
name|atr_usp
expr_stmt|;
name|scp
operator|->
name|his_atr
operator|=
name|atr_usp
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|scp
operator|==
name|cur_console
condition|)
name|set_mode
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|scp
operator|->
name|status
operator|&=
operator|~
name|UNKNOWN_MODE
expr_stmt|;
name|clear_screen
argument_list|(
name|scp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_winsize
operator|.
name|ws_col
operator|!=
name|scp
operator|->
name|xsize
operator|||
name|tp
operator|->
name|t_winsize
operator|.
name|ws_row
operator|!=
name|scp
operator|->
name|ysize
condition|)
block|{
name|tp
operator|->
name|t_winsize
operator|.
name|ws_col
operator|=
name|scp
operator|->
name|xsize
expr_stmt|;
name|tp
operator|->
name|t_winsize
operator|.
name|ws_row
operator|=
name|scp
operator|->
name|ysize
expr_stmt|;
name|pgsignal
argument_list|(
name|tp
operator|->
name|t_pgrp
argument_list|,
name|SIGWINCH
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
ifndef|#
directive|ifndef
name|PC98
comment|/* GRAPHICS MODES */
case|case
name|SW_BG320
case|:
case|case
name|SW_BG640
case|:
case|case
name|SW_CG320
case|:
case|case
name|SW_CG320_D
case|:
case|case
name|SW_CG640_E
case|:
case|case
name|SW_CG640x350
case|:
case|case
name|SW_ENH_CG640
case|:
case|case
name|SW_BG640x480
case|:
case|case
name|SW_CG640x480
case|:
case|case
name|SW_VGA_CG320
case|:
if|if
condition|(
operator|!
name|crtc_vga
condition|)
return|return
name|ENODEV
return|;
name|mp
operator|=
name|get_mode_param
argument_list|(
name|scp
argument_list|,
name|cmd
operator|&
literal|0xff
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|==
name|NULL
condition|)
return|return
name|ENODEV
return|;
name|scp
operator|->
name|mode
operator|=
name|cmd
operator|&
literal|0xFF
expr_stmt|;
name|scp
operator|->
name|xpixel
operator|=
name|mp
index|[
literal|0
index|]
operator|*
literal|8
expr_stmt|;
name|scp
operator|->
name|ypixel
operator|=
operator|(
name|mp
index|[
literal|1
index|]
operator|+
name|rows_offset
operator|)
operator|*
name|mp
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|scp
operator|==
name|cur_console
condition|)
name|set_mode
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|scp
operator|->
name|status
operator||=
name|UNKNOWN_MODE
expr_stmt|;
comment|/* graphics mode */
comment|/* clear_graphics();*/
if|if
condition|(
name|tp
operator|->
name|t_winsize
operator|.
name|ws_xpixel
operator|!=
name|scp
operator|->
name|xpixel
operator|||
name|tp
operator|->
name|t_winsize
operator|.
name|ws_ypixel
operator|!=
name|scp
operator|->
name|ypixel
condition|)
block|{
name|tp
operator|->
name|t_winsize
operator|.
name|ws_xpixel
operator|=
name|scp
operator|->
name|xpixel
expr_stmt|;
name|tp
operator|->
name|t_winsize
operator|.
name|ws_ypixel
operator|=
name|scp
operator|->
name|ypixel
expr_stmt|;
name|pgsignal
argument_list|(
name|tp
operator|->
name|t_pgrp
argument_list|,
name|SIGWINCH
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
case|case
name|SW_VGA_MODEX
case|:
if|if
condition|(
operator|!
name|crtc_vga
condition|)
return|return
name|ENODEV
return|;
name|mp
operator|=
name|get_mode_param
argument_list|(
name|scp
argument_list|,
name|cmd
operator|&
literal|0xff
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|==
name|NULL
condition|)
return|return
name|ENODEV
return|;
name|scp
operator|->
name|mode
operator|=
name|cmd
operator|&
literal|0xFF
expr_stmt|;
if|if
condition|(
name|scp
operator|==
name|cur_console
condition|)
name|set_mode
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|scp
operator|->
name|status
operator||=
name|UNKNOWN_MODE
expr_stmt|;
comment|/* graphics mode */
comment|/* clear_graphics();*/
name|scp
operator|->
name|xpixel
operator|=
literal|320
expr_stmt|;
name|scp
operator|->
name|ypixel
operator|=
literal|240
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_winsize
operator|.
name|ws_xpixel
operator|!=
name|scp
operator|->
name|xpixel
operator|||
name|tp
operator|->
name|t_winsize
operator|.
name|ws_ypixel
operator|!=
name|scp
operator|->
name|ypixel
condition|)
block|{
name|tp
operator|->
name|t_winsize
operator|.
name|ws_xpixel
operator|=
name|scp
operator|->
name|xpixel
expr_stmt|;
name|tp
operator|->
name|t_winsize
operator|.
name|ws_ypixel
operator|=
name|scp
operator|->
name|ypixel
expr_stmt|;
name|pgsignal
argument_list|(
name|tp
operator|->
name|t_pgrp
argument_list|,
name|SIGWINCH
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* PC98 */
case|case
name|VT_SETMODE
case|:
comment|/* set screen switcher mode */
block|{
name|struct
name|vt_mode
modifier|*
name|mode
decl_stmt|;
name|mode
operator|=
operator|(
expr|struct
name|vt_mode
operator|*
operator|)
name|data
expr_stmt|;
if|if
condition|(
name|ISSIGVALID
argument_list|(
name|mode
operator|->
name|relsig
argument_list|)
operator|&&
name|ISSIGVALID
argument_list|(
name|mode
operator|->
name|acqsig
argument_list|)
operator|&&
name|ISSIGVALID
argument_list|(
name|mode
operator|->
name|frsig
argument_list|)
condition|)
block|{
name|bcopy
argument_list|(
name|data
argument_list|,
operator|&
name|scp
operator|->
name|smode
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vt_mode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|smode
operator|.
name|mode
operator|==
name|VT_PROCESS
condition|)
block|{
name|scp
operator|->
name|proc
operator|=
name|p
expr_stmt|;
name|scp
operator|->
name|pid
operator|=
name|scp
operator|->
name|proc
operator|->
name|p_pid
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
else|else
return|return
name|EINVAL
return|;
block|}
case|case
name|VT_GETMODE
case|:
comment|/* get screen switcher mode */
name|bcopy
argument_list|(
operator|&
name|scp
operator|->
name|smode
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vt_mode
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|VT_RELDISP
case|:
comment|/* screen switcher ioctl */
switch|switch
condition|(
operator|*
name|data
condition|)
block|{
case|case
name|VT_FALSE
case|:
comment|/* user refuses to release screen, abort */
if|if
condition|(
name|scp
operator|==
name|old_scp
operator|&&
operator|(
name|scp
operator|->
name|status
operator|&
name|SWITCH_WAIT_REL
operator|)
condition|)
block|{
name|old_scp
operator|->
name|status
operator|&=
operator|~
name|SWITCH_WAIT_REL
expr_stmt|;
name|switch_in_progress
operator|=
name|FALSE
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|EINVAL
return|;
case|case
name|VT_TRUE
case|:
comment|/* user has released screen, go on */
if|if
condition|(
name|scp
operator|==
name|old_scp
operator|&&
operator|(
name|scp
operator|->
name|status
operator|&
name|SWITCH_WAIT_REL
operator|)
condition|)
block|{
name|scp
operator|->
name|status
operator|&=
operator|~
name|SWITCH_WAIT_REL
expr_stmt|;
name|exchange_scr
argument_list|()
expr_stmt|;
if|if
condition|(
name|new_scp
operator|->
name|smode
operator|.
name|mode
operator|==
name|VT_PROCESS
condition|)
block|{
name|new_scp
operator|->
name|status
operator||=
name|SWITCH_WAIT_ACQ
expr_stmt|;
name|psignal
argument_list|(
name|new_scp
operator|->
name|proc
argument_list|,
name|new_scp
operator|->
name|smode
operator|.
name|acqsig
argument_list|)
expr_stmt|;
block|}
else|else
name|switch_in_progress
operator|=
name|FALSE
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|EINVAL
return|;
case|case
name|VT_ACKACQ
case|:
comment|/* acquire acknowledged, switch completed */
if|if
condition|(
name|scp
operator|==
name|new_scp
operator|&&
operator|(
name|scp
operator|->
name|status
operator|&
name|SWITCH_WAIT_ACQ
operator|)
condition|)
block|{
name|scp
operator|->
name|status
operator|&=
operator|~
name|SWITCH_WAIT_ACQ
expr_stmt|;
name|switch_in_progress
operator|=
name|FALSE
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|EINVAL
return|;
default|default:
return|return
name|EINVAL
return|;
block|}
comment|/* NOT REACHED */
case|case
name|VT_OPENQRY
case|:
comment|/* return free virtual console */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXCONS
condition|;
name|i
operator|++
control|)
block|{
name|tp
operator|=
name|VIRTUAL_TTY
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
condition|)
block|{
operator|*
name|data
operator|=
name|i
operator|+
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
name|EINVAL
return|;
case|case
name|VT_ACTIVATE
case|:
comment|/* switch to screen *data */
return|return
name|switch_scr
argument_list|(
name|scp
argument_list|,
operator|(
operator|*
name|data
operator|)
operator|-
literal|1
argument_list|)
return|;
case|case
name|VT_WAITACTIVE
case|:
comment|/* wait for switch to occur */
if|if
condition|(
operator|*
name|data
operator|>
name|MAXCONS
operator|||
operator|*
name|data
operator|<
literal|0
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|==
operator|(
operator|*
name|data
operator|)
operator|-
literal|1
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|*
name|data
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|scp
operator|==
name|cur_console
condition|)
return|return
literal|0
return|;
block|}
else|else
name|scp
operator|=
name|console
index|[
operator|(
operator|*
name|data
operator|)
operator|-
literal|1
index|]
expr_stmt|;
while|while
condition|(
operator|(
name|error
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|scp
operator|->
name|smode
argument_list|,
name|PZERO
operator||
name|PCATCH
argument_list|,
literal|"waitvt"
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|ERESTART
condition|)
empty_stmt|;
return|return
name|error
return|;
case|case
name|VT_GETACTIVE
case|:
operator|*
name|data
operator|=
name|get_scr_num
argument_list|()
operator|+
literal|1
expr_stmt|;
return|return
literal|0
return|;
case|case
name|KDENABIO
case|:
comment|/* allow io operations */
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
if|if
condition|(
name|securelevel
operator|>
literal|0
condition|)
return|return
name|EPERM
return|;
name|p
operator|->
name|p_md
operator|.
name|md_regs
operator|->
name|tf_eflags
operator||=
name|PSL_IOPL
expr_stmt|;
return|return
literal|0
return|;
case|case
name|KDDISABIO
case|:
comment|/* disallow io operations (default) */
name|p
operator|->
name|p_md
operator|.
name|md_regs
operator|->
name|tf_eflags
operator|&=
operator|~
name|PSL_IOPL
expr_stmt|;
return|return
literal|0
return|;
case|case
name|KDSETMODE
case|:
comment|/* set current mode of this (virtual) console */
switch|switch
condition|(
operator|*
name|data
condition|)
block|{
case|case
name|KD_TEXT
case|:
comment|/* switch to TEXT (known) mode */
ifndef|#
directive|ifndef
name|PC98
comment|/* restore fonts& palette ! */
if|if
condition|(
name|crtc_vga
condition|)
block|{
if|if
condition|(
name|fonts_loaded
operator|&
name|FONT_8
condition|)
name|copy_font
argument_list|(
name|LOAD
argument_list|,
name|FONT_8
argument_list|,
name|font_8
argument_list|)
expr_stmt|;
if|if
condition|(
name|fonts_loaded
operator|&
name|FONT_14
condition|)
name|copy_font
argument_list|(
name|LOAD
argument_list|,
name|FONT_14
argument_list|,
name|font_14
argument_list|)
expr_stmt|;
if|if
condition|(
name|fonts_loaded
operator|&
name|FONT_16
condition|)
name|copy_font
argument_list|(
name|LOAD
argument_list|,
name|FONT_16
argument_list|,
name|font_16
argument_list|)
expr_stmt|;
name|load_palette
argument_list|(
name|palette
argument_list|)
expr_stmt|;
block|}
comment|/* move hardware cursor out of the way */
name|outb
argument_list|(
name|crtc_addr
argument_list|,
literal|14
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|crtc_addr
operator|+
literal|1
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|crtc_addr
argument_list|,
literal|15
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|crtc_addr
operator|+
literal|1
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* FALL THROUGH */
endif|#
directive|endif
case|case
name|KD_TEXT1
case|:
comment|/* switch to TEXT (known) mode */
comment|/* no restore fonts& palette */
ifdef|#
directive|ifdef
name|PC98
name|scp
operator|->
name|status
operator|&=
operator|~
name|UNKNOWN_MODE
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|crtc_vga
condition|)
endif|#
directive|endif
name|set_mode
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|scp
operator|->
name|status
operator|&=
operator|~
name|UNKNOWN_MODE
expr_stmt|;
name|clear_screen
argument_list|(
name|scp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|KD_GRAPHICS
case|:
comment|/* switch to GRAPHICS (unknown) mode */
name|scp
operator|->
name|status
operator||=
name|UNKNOWN_MODE
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|set_mode
argument_list|(
name|scp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
default|default:
return|return
name|EINVAL
return|;
block|}
comment|/* NOT REACHED */
case|case
name|KDGETMODE
case|:
comment|/* get current mode of this (virtual) console */
operator|*
name|data
operator|=
operator|(
name|scp
operator|->
name|status
operator|&
name|UNKNOWN_MODE
operator|)
condition|?
name|KD_GRAPHICS
else|:
name|KD_TEXT
expr_stmt|;
return|return
literal|0
return|;
case|case
name|KDSBORDER
case|:
comment|/* set border color of this (virtual) console */
name|scp
operator|->
name|border
operator|=
operator|*
name|data
expr_stmt|;
if|if
condition|(
name|scp
operator|==
name|cur_console
condition|)
name|set_border
argument_list|(
name|scp
operator|->
name|border
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|KDSKBSTATE
case|:
comment|/* set keyboard state (locks) */
if|if
condition|(
operator|*
name|data
operator|>=
literal|0
operator|&&
operator|*
name|data
operator|<=
name|LOCK_KEY_MASK
condition|)
block|{
name|scp
operator|->
name|status
operator|&=
operator|~
name|LOCK_KEY_MASK
expr_stmt|;
name|scp
operator|->
name|status
operator||=
operator|*
name|data
expr_stmt|;
if|if
condition|(
name|scp
operator|==
name|cur_console
condition|)
name|update_leds
argument_list|(
name|scp
operator|->
name|status
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|EINVAL
return|;
case|case
name|KDGKBSTATE
case|:
comment|/* get keyboard state (locks) */
operator|*
name|data
operator|=
name|scp
operator|->
name|status
operator|&
name|LOCK_KEY_MASK
expr_stmt|;
return|return
literal|0
return|;
case|case
name|KDSETRAD
case|:
comment|/* set keyboard repeat& delay rates */
ifndef|#
directive|ifndef
name|PC98
if|if
condition|(
operator|*
name|data
operator|&
literal|0x80
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|sc_kbdc
operator|!=
name|NULL
condition|)
name|set_keyboard
argument_list|(
name|KBDC_SET_TYPEMATIC
argument_list|,
operator|*
name|data
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
case|case
name|KDSKBMODE
case|:
comment|/* set keyboard mode */
switch|switch
condition|(
operator|*
name|data
condition|)
block|{
case|case
name|K_RAW
case|:
comment|/* switch to RAW scancode mode */
name|scp
operator|->
name|status
operator|&=
operator|~
name|KBD_CODE_MODE
expr_stmt|;
name|scp
operator|->
name|status
operator||=
name|KBD_RAW_MODE
expr_stmt|;
return|return
literal|0
return|;
case|case
name|K_CODE
case|:
comment|/* switch to CODE mode */
name|scp
operator|->
name|status
operator|&=
operator|~
name|KBD_RAW_MODE
expr_stmt|;
name|scp
operator|->
name|status
operator||=
name|KBD_CODE_MODE
expr_stmt|;
return|return
literal|0
return|;
case|case
name|K_XLATE
case|:
comment|/* switch to XLT ascii mode */
if|if
condition|(
name|scp
operator|==
name|cur_console
operator|&&
name|scp
operator|->
name|status
operator|&
name|KBD_RAW_MODE
condition|)
name|shfts
operator|=
name|ctls
operator|=
name|alts
operator|=
name|agrs
operator|=
name|metas
operator|=
name|accents
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|status
operator|&=
operator|~
operator|(
name|KBD_RAW_MODE
operator||
name|KBD_CODE_MODE
operator|)
expr_stmt|;
return|return
literal|0
return|;
default|default:
return|return
name|EINVAL
return|;
block|}
comment|/* NOT REACHED */
case|case
name|KDGKBMODE
case|:
comment|/* get keyboard mode */
operator|*
name|data
operator|=
operator|(
name|scp
operator|->
name|status
operator|&
name|KBD_RAW_MODE
operator|)
condition|?
name|K_RAW
else|:
operator|(
operator|(
name|scp
operator|->
name|status
operator|&
name|KBD_CODE_MODE
operator|)
condition|?
name|K_CODE
else|:
name|K_XLATE
operator|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|KDMKTONE
case|:
comment|/* sound the bell */
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
condition|)
name|do_bell
argument_list|(
name|scp
argument_list|,
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|)
operator|&
literal|0xffff
argument_list|,
operator|(
operator|(
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|)
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
operator|*
name|hz
operator|/
literal|1000
argument_list|)
expr_stmt|;
else|else
name|do_bell
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|bell_pitch
argument_list|,
name|scp
operator|->
name|bell_duration
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|KIOCSOUND
case|:
comment|/* make tone (*data) hz */
if|if
condition|(
name|scp
operator|==
name|cur_console
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
condition|)
block|{
name|int
name|pitch
init|=
name|timer_freq
operator|/
operator|*
operator|(
name|int
operator|*
operator|)
name|data
decl_stmt|;
ifdef|#
directive|ifdef
name|PC98
comment|/* enable counter 1 */
name|outb
argument_list|(
literal|0x35
argument_list|,
name|inb
argument_list|(
literal|0x35
argument_list|)
operator|&
literal|0xf7
argument_list|)
expr_stmt|;
comment|/* set command for counter 1, 2 byte write */
if|if
condition|(
name|acquire_timer1
argument_list|(
name|TIMER_16BIT
operator||
name|TIMER_SQWAVE
argument_list|)
condition|)
block|{
return|return
name|EBUSY
return|;
block|}
comment|/* set pitch */
name|outb
argument_list|(
name|TIMER_CNTR1
argument_list|,
name|pitch
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TIMER_CNTR1
argument_list|,
operator|(
name|pitch
operator|>>
literal|8
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* set command for counter 2, 2 byte write */
if|if
condition|(
name|acquire_timer2
argument_list|(
name|TIMER_16BIT
operator||
name|TIMER_SQWAVE
argument_list|)
condition|)
return|return
name|EBUSY
return|;
comment|/* set pitch */
name|outb
argument_list|(
name|TIMER_CNTR2
argument_list|,
name|pitch
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TIMER_CNTR2
argument_list|,
operator|(
name|pitch
operator|>>
literal|8
operator|)
argument_list|)
expr_stmt|;
comment|/* enable counter 2 output to speaker */
name|outb
argument_list|(
name|IO_PPI
argument_list|,
name|inb
argument_list|(
name|IO_PPI
argument_list|)
operator||
literal|3
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|PC98
comment|/* disable counter 1 */
name|outb
argument_list|(
literal|0x35
argument_list|,
name|inb
argument_list|(
literal|0x35
argument_list|)
operator||
literal|0x08
argument_list|)
expr_stmt|;
name|release_timer1
argument_list|()
expr_stmt|;
else|#
directive|else
comment|/* disable counter 2 output to speaker */
name|outb
argument_list|(
name|IO_PPI
argument_list|,
name|inb
argument_list|(
name|IO_PPI
argument_list|)
operator|&
literal|0xFC
argument_list|)
expr_stmt|;
name|release_timer2
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
block|}
return|return
literal|0
return|;
case|case
name|KDGKBTYPE
case|:
comment|/* get keyboard type */
operator|*
name|data
operator|=
literal|0
expr_stmt|;
comment|/* type not known (yet) */
return|return
literal|0
return|;
case|case
name|KDSETLED
case|:
comment|/* set keyboard LED status */
if|if
condition|(
operator|*
name|data
operator|>=
literal|0
operator|&&
operator|*
name|data
operator|<=
name|LED_MASK
condition|)
block|{
name|scp
operator|->
name|status
operator|&=
operator|~
name|LED_MASK
expr_stmt|;
name|scp
operator|->
name|status
operator||=
operator|*
name|data
expr_stmt|;
if|if
condition|(
name|scp
operator|==
name|cur_console
condition|)
name|update_leds
argument_list|(
name|scp
operator|->
name|status
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|EINVAL
return|;
case|case
name|KDGETLED
case|:
comment|/* get keyboard LED status */
operator|*
name|data
operator|=
name|scp
operator|->
name|status
operator|&
name|LED_MASK
expr_stmt|;
return|return
literal|0
return|;
case|case
name|GETFKEY
case|:
comment|/* get functionkey string */
if|if
condition|(
operator|*
operator|(
name|u_short
operator|*
operator|)
name|data
operator|<
name|n_fkey_tab
condition|)
block|{
name|fkeyarg_t
modifier|*
name|ptr
init|=
operator|(
name|fkeyarg_t
operator|*
operator|)
name|data
decl_stmt|;
name|bcopy
argument_list|(
operator|&
name|fkey_tab
index|[
name|ptr
operator|->
name|keynum
index|]
operator|.
name|str
argument_list|,
name|ptr
operator|->
name|keydef
argument_list|,
name|fkey_tab
index|[
name|ptr
operator|->
name|keynum
index|]
operator|.
name|len
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|flen
operator|=
name|fkey_tab
index|[
name|ptr
operator|->
name|keynum
index|]
operator|.
name|len
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
return|return
name|EINVAL
return|;
case|case
name|SETFKEY
case|:
comment|/* set functionkey string */
if|if
condition|(
operator|*
operator|(
name|u_short
operator|*
operator|)
name|data
operator|<
name|n_fkey_tab
condition|)
block|{
name|fkeyarg_t
modifier|*
name|ptr
init|=
operator|(
name|fkeyarg_t
operator|*
operator|)
name|data
decl_stmt|;
name|bcopy
argument_list|(
name|ptr
operator|->
name|keydef
argument_list|,
operator|&
name|fkey_tab
index|[
name|ptr
operator|->
name|keynum
index|]
operator|.
name|str
argument_list|,
name|min
argument_list|(
name|ptr
operator|->
name|flen
argument_list|,
name|MAXFK
argument_list|)
argument_list|)
expr_stmt|;
name|fkey_tab
index|[
name|ptr
operator|->
name|keynum
index|]
operator|.
name|len
operator|=
name|min
argument_list|(
name|ptr
operator|->
name|flen
argument_list|,
name|MAXFK
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
return|return
name|EINVAL
return|;
case|case
name|GIO_SCRNMAP
case|:
comment|/* get output translation table */
name|bcopy
argument_list|(
operator|&
name|scr_map
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|scr_map
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|PIO_SCRNMAP
case|:
comment|/* set output translation table */
name|bcopy
argument_list|(
name|data
argument_list|,
operator|&
name|scr_map
argument_list|,
sizeof|sizeof
argument_list|(
name|scr_map
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|scr_map
argument_list|)
condition|;
name|i
operator|++
control|)
name|scr_rmap
index|[
name|scr_map
index|[
name|i
index|]
index|]
operator|=
name|i
expr_stmt|;
return|return
literal|0
return|;
case|case
name|GIO_KEYMAP
case|:
comment|/* get keyboard translation table */
name|bcopy
argument_list|(
operator|&
name|key_map
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|key_map
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|PIO_KEYMAP
case|:
comment|/* set keyboard translation table */
name|accents
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|accent_map
argument_list|,
sizeof|sizeof
argument_list|(
name|accent_map
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|data
argument_list|,
operator|&
name|key_map
argument_list|,
sizeof|sizeof
argument_list|(
name|key_map
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|GIO_DEADKEYMAP
case|:
comment|/* get accent key translation table */
name|bcopy
argument_list|(
operator|&
name|accent_map
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|accent_map
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|PIO_DEADKEYMAP
case|:
comment|/* set accent key translation table */
name|accents
operator|=
literal|0
expr_stmt|;
name|bcopy
argument_list|(
name|data
argument_list|,
operator|&
name|accent_map
argument_list|,
sizeof|sizeof
argument_list|(
name|accent_map
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|PC98
case|case
name|PIO_FONT8x8
case|:
comment|/* set 8x8 dot font */
case|case
name|GIO_FONT8x8
case|:
comment|/* get 8x8 dot font */
case|case
name|PIO_FONT8x14
case|:
comment|/* set 8x14 dot font */
case|case
name|GIO_FONT8x14
case|:
comment|/* get 8x14 dot font */
case|case
name|PIO_FONT8x16
case|:
comment|/* set 8x16 dot font */
case|case
name|GIO_FONT8x16
case|:
comment|/* get 8x16 dot font */
return|return
name|ENXIO
return|;
else|#
directive|else
case|case
name|PIO_FONT8x8
case|:
comment|/* set 8x8 dot font */
if|if
condition|(
operator|!
name|crtc_vga
condition|)
return|return
name|ENXIO
return|;
name|bcopy
argument_list|(
name|data
argument_list|,
name|font_8
argument_list|,
literal|8
operator|*
literal|256
argument_list|)
expr_stmt|;
name|fonts_loaded
operator||=
name|FONT_8
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|cur_console
operator|->
name|status
operator|&
name|UNKNOWN_MODE
operator|)
condition|)
block|{
name|copy_font
argument_list|(
name|LOAD
argument_list|,
name|FONT_8
argument_list|,
name|font_8
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|CHAR_CURSOR
condition|)
name|set_destructive_cursor
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
case|case
name|GIO_FONT8x8
case|:
comment|/* get 8x8 dot font */
if|if
condition|(
operator|!
name|crtc_vga
condition|)
return|return
name|ENXIO
return|;
if|if
condition|(
name|fonts_loaded
operator|&
name|FONT_8
condition|)
block|{
name|bcopy
argument_list|(
name|font_8
argument_list|,
name|data
argument_list|,
literal|8
operator|*
literal|256
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
return|return
name|ENXIO
return|;
case|case
name|PIO_FONT8x14
case|:
comment|/* set 8x14 dot font */
if|if
condition|(
operator|!
name|crtc_vga
condition|)
return|return
name|ENXIO
return|;
name|bcopy
argument_list|(
name|data
argument_list|,
name|font_14
argument_list|,
literal|14
operator|*
literal|256
argument_list|)
expr_stmt|;
name|fonts_loaded
operator||=
name|FONT_14
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|cur_console
operator|->
name|status
operator|&
name|UNKNOWN_MODE
operator|)
condition|)
block|{
name|copy_font
argument_list|(
name|LOAD
argument_list|,
name|FONT_14
argument_list|,
name|font_14
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|CHAR_CURSOR
condition|)
name|set_destructive_cursor
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
case|case
name|GIO_FONT8x14
case|:
comment|/* get 8x14 dot font */
if|if
condition|(
operator|!
name|crtc_vga
condition|)
return|return
name|ENXIO
return|;
if|if
condition|(
name|fonts_loaded
operator|&
name|FONT_14
condition|)
block|{
name|bcopy
argument_list|(
name|font_14
argument_list|,
name|data
argument_list|,
literal|14
operator|*
literal|256
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
return|return
name|ENXIO
return|;
case|case
name|PIO_FONT8x16
case|:
comment|/* set 8x16 dot font */
if|if
condition|(
operator|!
name|crtc_vga
condition|)
return|return
name|ENXIO
return|;
name|bcopy
argument_list|(
name|data
argument_list|,
name|font_16
argument_list|,
literal|16
operator|*
literal|256
argument_list|)
expr_stmt|;
name|fonts_loaded
operator||=
name|FONT_16
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|cur_console
operator|->
name|status
operator|&
name|UNKNOWN_MODE
operator|)
condition|)
block|{
name|copy_font
argument_list|(
name|LOAD
argument_list|,
name|FONT_16
argument_list|,
name|font_16
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|CHAR_CURSOR
condition|)
name|set_destructive_cursor
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
case|case
name|GIO_FONT8x16
case|:
comment|/* get 8x16 dot font */
if|if
condition|(
operator|!
name|crtc_vga
condition|)
return|return
name|ENXIO
return|;
if|if
condition|(
name|fonts_loaded
operator|&
name|FONT_16
condition|)
block|{
name|bcopy
argument_list|(
name|font_16
argument_list|,
name|data
argument_list|,
literal|16
operator|*
literal|256
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
return|return
name|ENXIO
return|;
endif|#
directive|endif
comment|/* PC98 */
ifdef|#
directive|ifdef
name|PC98
case|case
name|ADJUST_CLOCK
case|:
comment|/* /dev/rtc for 98note resume */
name|inittodr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
endif|#
directive|endif
default|default:
break|break;
block|}
name|error
operator|=
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_ioctl
operator|)
operator|(
name|tp
operator|,
name|cmd
operator|,
name|data
operator|,
name|flag
operator|,
name|p
operator|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ENOIOCTL
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|ttioctl
argument_list|(
name|tp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|flag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ENOIOCTL
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
name|ENOTTY
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|scstart
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|clist
modifier|*
name|rbp
decl_stmt|;
name|int
name|s
decl_stmt|,
name|len
decl_stmt|;
name|u_char
name|buf
index|[
name|PCBURST
index|]
decl_stmt|;
name|scr_stat
modifier|*
name|scp
init|=
name|get_scr_stat
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|scp
operator|->
name|status
operator|&
name|SLKED
operator|||
name|blink_in_progress
condition|)
return|return;
comment|/* XXX who repeats the call when the above flags are cleared? */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
operator|(
name|TS_TIMEOUT
operator||
name|TS_BUSY
operator||
name|TS_TTSTOP
operator|)
operator|)
condition|)
block|{
name|tp
operator|->
name|t_state
operator||=
name|TS_BUSY
expr_stmt|;
name|rbp
operator|=
operator|&
name|tp
operator|->
name|t_outq
expr_stmt|;
while|while
condition|(
name|rbp
operator|->
name|c_cc
condition|)
block|{
name|len
operator|=
name|q_to_b
argument_list|(
name|rbp
argument_list|,
name|buf
argument_list|,
name|PCBURST
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ansi_put
argument_list|(
name|scp
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
block|}
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_BUSY
expr_stmt|;
name|ttwwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|scmousestart
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|clist
modifier|*
name|rbp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|u_char
name|buf
index|[
name|PCBURST
index|]
decl_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
operator|(
name|TS_TIMEOUT
operator||
name|TS_BUSY
operator||
name|TS_TTSTOP
operator|)
operator|)
condition|)
block|{
name|tp
operator|->
name|t_state
operator||=
name|TS_BUSY
expr_stmt|;
name|rbp
operator|=
operator|&
name|tp
operator|->
name|t_outq
expr_stmt|;
while|while
condition|(
name|rbp
operator|->
name|c_cc
condition|)
block|{
name|q_to_b
argument_list|(
name|rbp
argument_list|,
name|buf
argument_list|,
name|PCBURST
argument_list|)
expr_stmt|;
block|}
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_BUSY
expr_stmt|;
name|ttwwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sccnprobe
parameter_list|(
name|struct
name|consdev
modifier|*
name|cp
parameter_list|)
block|{
name|struct
name|isa_device
modifier|*
name|dvp
decl_stmt|;
comment|/*      * Take control if we are the highest priority enabled display device.      */
name|dvp
operator|=
name|find_display
argument_list|()
expr_stmt|;
if|if
condition|(
name|dvp
operator|==
name|NULL
operator|||
name|dvp
operator|->
name|id_driver
operator|!=
operator|&
name|scdriver
condition|)
block|{
name|cp
operator|->
name|cn_pri
operator|=
name|CN_DEAD
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|scvidprobe
argument_list|(
name|dvp
operator|->
name|id_unit
argument_list|,
name|dvp
operator|->
name|id_flags
argument_list|)
condition|)
block|{
name|cp
operator|->
name|cn_pri
operator|=
name|CN_DEAD
expr_stmt|;
return|return;
block|}
comment|/* initialize required fields */
name|cp
operator|->
name|cn_dev
operator|=
name|makedev
argument_list|(
name|CDEV_MAJOR
argument_list|,
name|SC_CONSOLE
argument_list|)
expr_stmt|;
name|cp
operator|->
name|cn_pri
operator|=
name|CN_INTERNAL
expr_stmt|;
name|sc_kbdc
operator|=
name|kbdc_open
argument_list|(
name|sc_port
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sccninit
parameter_list|(
name|struct
name|consdev
modifier|*
name|cp
parameter_list|)
block|{
name|scinit
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sccnputc
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|c
parameter_list|)
block|{
name|u_char
name|buf
index|[
literal|1
index|]
decl_stmt|;
name|int
name|s
decl_stmt|;
name|scr_stat
modifier|*
name|scp
init|=
name|console
index|[
literal|0
index|]
decl_stmt|;
name|term_stat
name|save
init|=
name|scp
operator|->
name|term
decl_stmt|;
name|scp
operator|->
name|term
operator|=
name|kernel_console
expr_stmt|;
name|current_default
operator|=
operator|&
name|kernel_default
expr_stmt|;
if|if
condition|(
name|scp
operator|==
name|cur_console
operator|&&
operator|!
operator|(
name|scp
operator|->
name|status
operator|&
name|UNKNOWN_MODE
operator|)
condition|)
name|remove_cursor_image
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|ansi_put
argument_list|(
name|scp
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|kernel_console
operator|=
name|scp
operator|->
name|term
expr_stmt|;
name|current_default
operator|=
operator|&
name|user_default
expr_stmt|;
name|scp
operator|->
name|term
operator|=
name|save
expr_stmt|;
name|s
operator|=
name|splclock
argument_list|()
expr_stmt|;
if|if
condition|(
name|scp
operator|==
name|cur_console
operator|&&
operator|!
operator|(
name|scp
operator|->
name|status
operator|&
name|UNKNOWN_MODE
operator|)
condition|)
block|{
if|if
condition|(
comment|/* timer not running&& */
operator|(
name|scp
operator|->
name|start
operator|<=
name|scp
operator|->
name|end
operator|)
condition|)
block|{
name|sc_bcopy
argument_list|(
name|scp
operator|->
name|scr_buf
operator|+
name|scp
operator|->
name|start
argument_list|,
name|Crtat
operator|+
name|scp
operator|->
name|start
argument_list|,
operator|(
literal|1
operator|+
name|scp
operator|->
name|end
operator|-
name|scp
operator|->
name|start
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|sc_bcopy
argument_list|(
name|scp
operator|->
name|atr_buf
operator|+
name|scp
operator|->
name|start
argument_list|,
name|Atrat
operator|+
name|scp
operator|->
name|start
argument_list|,
operator|(
literal|1
operator|+
name|scp
operator|->
name|end
operator|-
name|scp
operator|->
name|start
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|scp
operator|->
name|start
operator|=
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
expr_stmt|;
name|scp
operator|->
name|end
operator|=
literal|0
expr_stmt|;
block|}
name|scp
operator|->
name|cursor_oldpos
operator|=
name|scp
operator|->
name|cursor_pos
expr_stmt|;
name|draw_cursor_image
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|sccngetc
parameter_list|(
name|dev_t
name|dev
parameter_list|)
block|{
name|int
name|s
init|=
name|spltty
argument_list|()
decl_stmt|;
comment|/* block scintr and scrn_timer while we poll */
name|int
name|c
decl_stmt|;
comment|/*       * Stop the screen saver if necessary.      * What if we have been running in the screen saver code... XXX      */
if|if
condition|(
name|scrn_blanked
operator|>
literal|0
condition|)
name|stop_scrn_saver
argument_list|(
name|current_saver
argument_list|)
expr_stmt|;
name|c
operator|=
name|scgetc
argument_list|(
name|SCGETC_CN
argument_list|)
expr_stmt|;
comment|/* make sure the screen saver won't be activated soon */
name|scrn_time_stamp
operator|=
name|mono_time
operator|.
name|tv_sec
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sccncheckc
parameter_list|(
name|dev_t
name|dev
parameter_list|)
block|{
name|int
name|c
decl_stmt|,
name|s
decl_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|scrn_blanked
operator|>
literal|0
condition|)
name|stop_scrn_saver
argument_list|(
name|current_saver
argument_list|)
expr_stmt|;
name|c
operator|=
name|scgetc
argument_list|(
name|SCGETC_CN
operator||
name|SCGETC_NONBLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|NOKEY
condition|)
name|scrn_time_stamp
operator|=
name|mono_time
operator|.
name|tv_sec
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|c
operator|==
name|NOKEY
condition|?
operator|-
literal|1
else|:
name|c
operator|)
return|;
comment|/* c == -1 can't happen */
block|}
end_function

begin_function
specifier|static
name|scr_stat
modifier|*
name|get_scr_stat
parameter_list|(
name|dev_t
name|dev
parameter_list|)
block|{
name|int
name|unit
init|=
name|minor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|unit
operator|==
name|SC_CONSOLE
condition|)
return|return
name|console
index|[
literal|0
index|]
return|;
if|if
condition|(
name|unit
operator|>=
name|MAXCONS
operator|||
name|unit
operator|<
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
name|console
index|[
name|unit
index|]
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_scr_num
parameter_list|()
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|i
operator|<
name|MAXCONS
operator|)
operator|&&
operator|(
name|cur_console
operator|!=
name|console
index|[
name|i
index|]
operator|)
condition|)
name|i
operator|++
expr_stmt|;
return|return
name|i
operator|<
name|MAXCONS
condition|?
name|i
else|:
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|scrn_timer
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|scr_stat
modifier|*
name|scp
init|=
name|cur_console
decl_stmt|;
name|int
name|s
init|=
name|spltty
argument_list|()
decl_stmt|;
comment|/*       * With release 2.1 of the Xaccel server, the keyboard is left      * hanging pretty often. Apparently an interrupt from the      * keyboard is lost, and I don't know why (yet).      * This ugly hack calls scintr if input is ready for the keyboard      * and conveniently hides the problem.			XXX      */
comment|/* Try removing anything stuck in the keyboard controller; whether      * it's a keyboard scan code or mouse data. `scintr()' doesn't      * read the mouse data directly, but `kbdio' routines will, as a      * side effect.      */
if|if
condition|(
name|kbdc_lock
argument_list|(
name|sc_kbdc
argument_list|,
name|TRUE
argument_list|)
condition|)
block|{
comment|/* 	 * We have seen the lock flag is not set. Let's reset the flag early; 	 * otherwise `update_led()' failes which may want the lock  	 * during `scintr()'. 	 */
name|kbdc_lock
argument_list|(
name|sc_kbdc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|kbdc_data_ready
argument_list|(
name|sc_kbdc
argument_list|)
condition|)
name|scintr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* should we just return ? */
if|if
condition|(
operator|(
name|scp
operator|->
name|status
operator|&
name|UNKNOWN_MODE
operator|)
operator|||
name|blink_in_progress
operator|||
name|switch_in_progress
condition|)
block|{
name|timeout
argument_list|(
name|scrn_timer
argument_list|,
name|NULL
argument_list|,
name|hz
operator|/
literal|10
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* should we stop the screen saver? */
if|if
condition|(
name|mono_time
operator|.
name|tv_sec
operator|<=
name|scrn_time_stamp
operator|+
name|scrn_blank_time
condition|)
if|if
condition|(
name|scrn_blanked
operator|>
literal|0
condition|)
name|stop_scrn_saver
argument_list|(
name|current_saver
argument_list|)
expr_stmt|;
if|if
condition|(
name|scrn_blanked
operator|<=
literal|0
condition|)
block|{
comment|/* update screen image */
if|if
condition|(
name|scp
operator|->
name|start
operator|<=
name|scp
operator|->
name|end
condition|)
block|{
name|sc_bcopy
argument_list|(
name|scp
operator|->
name|scr_buf
operator|+
name|scp
operator|->
name|start
argument_list|,
name|Crtat
operator|+
name|scp
operator|->
name|start
argument_list|,
operator|(
literal|1
operator|+
name|scp
operator|->
name|end
operator|-
name|scp
operator|->
name|start
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|sc_bcopy
argument_list|(
name|scp
operator|->
name|atr_buf
operator|+
name|scp
operator|->
name|start
argument_list|,
name|Atrat
operator|+
name|scp
operator|->
name|start
argument_list|,
operator|(
literal|1
operator|+
name|scp
operator|->
name|end
operator|-
name|scp
operator|->
name|start
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* update "pseudo" mouse pointer image */
if|if
condition|(
operator|(
name|scp
operator|->
name|status
operator|&
name|MOUSE_VISIBLE
operator|)
operator|&&
name|crtc_vga
condition|)
block|{
comment|/* did mouse move since last time ? */
if|if
condition|(
name|scp
operator|->
name|status
operator|&
name|MOUSE_MOVED
condition|)
block|{
comment|/* do we need to remove old mouse pointer image ? */
if|if
condition|(
name|scp
operator|->
name|mouse_cut_start
operator|!=
name|NULL
operator|||
operator|(
name|scp
operator|->
name|mouse_pos
operator|-
name|scp
operator|->
name|scr_buf
operator|)
operator|<=
name|scp
operator|->
name|start
operator|||
operator|(
name|scp
operator|->
name|mouse_pos
operator|+
name|scp
operator|->
name|xsize
operator|+
literal|1
operator|-
name|scp
operator|->
name|scr_buf
operator|)
operator|>=
name|scp
operator|->
name|end
condition|)
block|{
name|remove_mouse_image
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
name|scp
operator|->
name|status
operator|&=
operator|~
name|MOUSE_MOVED
expr_stmt|;
name|draw_mouse_image
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* mouse didn't move, has it been overwritten ? */
if|if
condition|(
operator|(
name|scp
operator|->
name|mouse_pos
operator|+
name|scp
operator|->
name|xsize
operator|+
literal|1
operator|-
name|scp
operator|->
name|scr_buf
operator|)
operator|>=
name|scp
operator|->
name|start
operator|&&
operator|(
name|scp
operator|->
name|mouse_pos
operator|-
name|scp
operator|->
name|scr_buf
operator|)
operator|<=
name|scp
operator|->
name|end
condition|)
block|{
name|draw_mouse_image
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* update cursor image */
if|if
condition|(
name|scp
operator|->
name|status
operator|&
name|CURSOR_ENABLED
condition|)
block|{
comment|/* did cursor move since last time ? */
if|if
condition|(
name|scp
operator|->
name|cursor_pos
operator|!=
name|scp
operator|->
name|cursor_oldpos
condition|)
block|{
comment|/* do we need to remove old cursor image ? */
if|if
condition|(
operator|(
name|scp
operator|->
name|cursor_oldpos
operator|-
name|scp
operator|->
name|scr_buf
operator|)
operator|<
name|scp
operator|->
name|start
operator|||
operator|(
operator|(
name|scp
operator|->
name|cursor_oldpos
operator|-
name|scp
operator|->
name|scr_buf
operator|)
operator|>
name|scp
operator|->
name|end
operator|)
condition|)
block|{
name|remove_cursor_image
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
name|scp
operator|->
name|cursor_oldpos
operator|=
name|scp
operator|->
name|cursor_pos
expr_stmt|;
name|draw_cursor_image
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* cursor didn't move, has it been overwritten ? */
if|if
condition|(
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
operator|>=
name|scp
operator|->
name|start
operator|&&
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
operator|<=
name|scp
operator|->
name|end
condition|)
block|{
name|draw_cursor_image
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* if its a blinking cursor, we may have to update it */
if|if
condition|(
name|flags
operator|&
name|BLINK_CURSOR
condition|)
name|draw_cursor_image
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
block|}
name|blinkrate
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|scp
operator|->
name|mouse_cut_start
operator|!=
name|NULL
condition|)
name|draw_cutmarking
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|scp
operator|->
name|end
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|start
operator|=
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
expr_stmt|;
block|}
comment|/* should we activate the screen saver? */
if|if
condition|(
operator|(
name|scrn_blank_time
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|mono_time
operator|.
name|tv_sec
operator|>
name|scrn_time_stamp
operator|+
name|scrn_blank_time
operator|)
condition|)
call|(
modifier|*
name|current_saver
call|)
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|timeout
argument_list|(
name|scrn_timer
argument_list|,
name|NULL
argument_list|,
name|hz
operator|/
literal|25
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|add_scrn_saver
parameter_list|(
name|void
function_decl|(
modifier|*
name|this_saver
function_decl|)
parameter_list|(
name|int
parameter_list|)
parameter_list|)
block|{
if|if
condition|(
name|current_saver
operator|!=
name|none_saver
condition|)
return|return
name|EBUSY
return|;
name|current_saver
operator|=
name|this_saver
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|remove_scrn_saver
parameter_list|(
name|void
function_decl|(
modifier|*
name|this_saver
function_decl|)
parameter_list|(
name|int
parameter_list|)
parameter_list|)
block|{
if|if
condition|(
name|current_saver
operator|!=
name|this_saver
condition|)
return|return
name|EINVAL
return|;
comment|/*      * In order to prevent `current_saver' from being called by      * the timeout routine `scrn_timer()' while we manipulate       * the saver list, we shall set `current_saver' to `none_saver'       * before stopping the current saver, rather than blocking by `splXX()'.      */
name|current_saver
operator|=
name|none_saver
expr_stmt|;
if|if
condition|(
name|scrn_blanked
operator|>
literal|0
condition|)
name|stop_scrn_saver
argument_list|(
name|this_saver
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|stop_scrn_saver
parameter_list|(
name|void
function_decl|(
modifier|*
name|saver
function_decl|)
parameter_list|(
name|int
parameter_list|)
parameter_list|)
block|{
call|(
modifier|*
name|saver
call|)
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|scrn_time_stamp
operator|=
name|mono_time
operator|.
name|tv_sec
expr_stmt|;
name|mark_all
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|clear_screen
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
name|move_crsr
argument_list|(
name|scp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|scp
operator|->
name|cursor_oldpos
operator|=
name|scp
operator|->
name|cursor_pos
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|fillw
argument_list|(
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|scp
operator|->
name|scr_buf
argument_list|,
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
argument_list|)
expr_stmt|;
name|fillw
argument_list|(
name|at2pc98
argument_list|(
name|scp
operator|->
name|term
operator|.
name|cur_color
argument_list|)
argument_list|,
name|scp
operator|->
name|atr_buf
argument_list|,
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
argument_list|)
expr_stmt|;
else|#
directive|else
name|fillw
argument_list|(
name|scp
operator|->
name|term
operator|.
name|cur_color
operator||
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|scp
operator|->
name|scr_buf
argument_list|,
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mark_all
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|remove_cutmarking
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|switch_scr
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|u_int
name|next_scr
parameter_list|)
block|{
if|if
condition|(
name|switch_in_progress
operator|&&
operator|(
name|cur_console
operator|->
name|proc
operator|!=
name|pfind
argument_list|(
name|cur_console
operator|->
name|pid
argument_list|)
operator|)
condition|)
name|switch_in_progress
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|next_scr
operator|>=
name|MAXCONS
operator|||
name|switch_in_progress
operator|||
operator|(
name|cur_console
operator|->
name|smode
operator|.
name|mode
operator|==
name|VT_AUTO
operator|&&
name|cur_console
operator|->
name|status
operator|&
name|UNKNOWN_MODE
operator|)
condition|)
block|{
name|do_bell
argument_list|(
name|scp
argument_list|,
name|BELL_PITCH
argument_list|,
name|BELL_DURATION
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
comment|/* is the wanted virtual console open ? */
if|if
condition|(
name|next_scr
condition|)
block|{
name|struct
name|tty
modifier|*
name|tp
init|=
name|VIRTUAL_TTY
argument_list|(
name|next_scr
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
condition|)
block|{
name|do_bell
argument_list|(
name|scp
argument_list|,
name|BELL_PITCH
argument_list|,
name|BELL_DURATION
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
block|}
comment|/* delay switch if actively updating screen */
if|if
condition|(
name|write_in_progress
operator|||
name|blink_in_progress
condition|)
block|{
name|delayed_next_scr
operator|=
name|next_scr
operator|+
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
name|switch_in_progress
operator|=
name|TRUE
expr_stmt|;
name|old_scp
operator|=
name|cur_console
expr_stmt|;
name|new_scp
operator|=
name|console
index|[
name|next_scr
index|]
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|new_scp
operator|->
name|smode
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_scp
operator|==
name|old_scp
condition|)
block|{
name|switch_in_progress
operator|=
name|FALSE
expr_stmt|;
name|delayed_next_scr
operator|=
name|FALSE
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* has controlling process died? */
if|if
condition|(
name|old_scp
operator|->
name|proc
operator|&&
operator|(
name|old_scp
operator|->
name|proc
operator|!=
name|pfind
argument_list|(
name|old_scp
operator|->
name|pid
argument_list|)
operator|)
condition|)
name|old_scp
operator|->
name|smode
operator|.
name|mode
operator|=
name|VT_AUTO
expr_stmt|;
if|if
condition|(
name|new_scp
operator|->
name|proc
operator|&&
operator|(
name|new_scp
operator|->
name|proc
operator|!=
name|pfind
argument_list|(
name|new_scp
operator|->
name|pid
argument_list|)
operator|)
condition|)
name|new_scp
operator|->
name|smode
operator|.
name|mode
operator|=
name|VT_AUTO
expr_stmt|;
comment|/* check the modes and switch appropriately */
if|if
condition|(
name|old_scp
operator|->
name|smode
operator|.
name|mode
operator|==
name|VT_PROCESS
condition|)
block|{
name|old_scp
operator|->
name|status
operator||=
name|SWITCH_WAIT_REL
expr_stmt|;
name|psignal
argument_list|(
name|old_scp
operator|->
name|proc
argument_list|,
name|old_scp
operator|->
name|smode
operator|.
name|relsig
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|exchange_scr
argument_list|()
expr_stmt|;
if|if
condition|(
name|new_scp
operator|->
name|smode
operator|.
name|mode
operator|==
name|VT_PROCESS
condition|)
block|{
name|new_scp
operator|->
name|status
operator||=
name|SWITCH_WAIT_ACQ
expr_stmt|;
name|psignal
argument_list|(
name|new_scp
operator|->
name|proc
argument_list|,
name|new_scp
operator|->
name|smode
operator|.
name|acqsig
argument_list|)
expr_stmt|;
block|}
else|else
name|switch_in_progress
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|exchange_scr
parameter_list|(
name|void
parameter_list|)
block|{
name|move_crsr
argument_list|(
name|old_scp
argument_list|,
name|old_scp
operator|->
name|xpos
argument_list|,
name|old_scp
operator|->
name|ypos
argument_list|)
expr_stmt|;
name|cur_console
operator|=
name|new_scp
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
if|if
condition|(
name|old_scp
operator|->
name|mode
operator|!=
name|new_scp
operator|->
name|mode
operator|||
operator|(
name|old_scp
operator|->
name|status
operator|&
name|UNKNOWN_MODE
operator|)
operator|||
operator|(
name|new_scp
operator|->
name|status
operator|&
name|UNKNOWN_MODE
operator|)
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|old_scp
operator|->
name|mode
operator|!=
name|new_scp
operator|->
name|mode
operator|||
operator|(
name|old_scp
operator|->
name|status
operator|&
name|UNKNOWN_MODE
operator|)
condition|)
block|{
if|if
condition|(
name|crtc_vga
condition|)
endif|#
directive|endif
name|set_mode
argument_list|(
name|new_scp
argument_list|)
expr_stmt|;
block|}
name|move_crsr
argument_list|(
name|new_scp
argument_list|,
name|new_scp
operator|->
name|xpos
argument_list|,
name|new_scp
operator|->
name|ypos
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|PC98
if|if
condition|(
operator|!
operator|(
name|new_scp
operator|->
name|status
operator|&
name|UNKNOWN_MODE
operator|)
operator|&&
operator|(
name|flags
operator|&
name|CHAR_CURSOR
operator|)
condition|)
name|set_destructive_cursor
argument_list|(
name|new_scp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|old_scp
operator|->
name|status
operator|&
name|UNKNOWN_MODE
operator|)
operator|&&
name|crtc_vga
condition|)
name|load_palette
argument_list|(
name|palette
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|old_scp
operator|->
name|status
operator|&
name|KBD_RAW_MODE
operator|||
name|new_scp
operator|->
name|status
operator|&
name|KBD_RAW_MODE
operator|||
name|old_scp
operator|->
name|status
operator|&
name|KBD_CODE_MODE
operator|||
name|new_scp
operator|->
name|status
operator|&
name|KBD_CODE_MODE
condition|)
name|shfts
operator|=
name|ctls
operator|=
name|alts
operator|=
name|agrs
operator|=
name|metas
operator|=
name|accents
operator|=
literal|0
expr_stmt|;
name|set_border
argument_list|(
name|new_scp
operator|->
name|border
argument_list|)
expr_stmt|;
name|update_leds
argument_list|(
name|new_scp
operator|->
name|status
argument_list|)
expr_stmt|;
name|delayed_next_scr
operator|=
name|FALSE
expr_stmt|;
name|mark_all
argument_list|(
name|new_scp
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|scan_esc
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|u_char
name|c
parameter_list|)
block|{
specifier|static
name|u_char
name|ansi_col
index|[
literal|16
index|]
init|=
block|{
literal|0
block|,
literal|4
block|,
literal|2
block|,
literal|6
block|,
literal|1
block|,
literal|5
block|,
literal|3
block|,
literal|7
block|,
literal|8
block|,
literal|12
block|,
literal|10
block|,
literal|14
block|,
literal|9
block|,
literal|13
block|,
literal|11
block|,
literal|15
block|}
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|u_short
modifier|*
name|src
decl_stmt|,
modifier|*
name|dst
decl_stmt|,
name|count
decl_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|u_short
modifier|*
name|src_attr
decl_stmt|,
modifier|*
name|dst_attr
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|esc
operator|==
literal|1
condition|)
block|{
comment|/* seen ESC */
ifdef|#
directive|ifdef
name|KANJI
switch|switch
condition|(
name|scp
operator|->
name|kanji_type
condition|)
block|{
case|case
literal|0x80
case|:
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'B'
case|:
case|case
literal|'@'
case|:
name|scp
operator|->
name|kanji_type
operator|=
literal|0x20
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|esc
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|kanji_1st_char
operator|=
literal|0
expr_stmt|;
return|return;
default|default:
name|scp
operator|->
name|kanji_type
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|esc
operator|=
literal|0
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|0x40
case|:
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'J'
case|:
case|case
literal|'B'
case|:
case|case
literal|'H'
case|:
name|scp
operator|->
name|kanji_type
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|esc
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|kanji_1st_char
operator|=
literal|0
expr_stmt|;
return|return;
case|case
literal|'I'
case|:
name|scp
operator|->
name|kanji_type
operator|=
literal|0x10
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|esc
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|kanji_1st_char
operator|=
literal|0
expr_stmt|;
return|return;
default|default:
name|scp
operator|->
name|kanji_type
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|esc
operator|=
literal|0
expr_stmt|;
break|break;
block|}
break|break;
default|default:
break|break;
block|}
endif|#
directive|endif
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'7'
case|:
comment|/* Save cursor position */
name|scp
operator|->
name|saved_xpos
operator|=
name|scp
operator|->
name|xpos
expr_stmt|;
name|scp
operator|->
name|saved_ypos
operator|=
name|scp
operator|->
name|ypos
expr_stmt|;
break|break;
case|case
literal|'8'
case|:
comment|/* Restore saved cursor position */
if|if
condition|(
name|scp
operator|->
name|saved_xpos
operator|>=
literal|0
operator|&&
name|scp
operator|->
name|saved_ypos
operator|>=
literal|0
condition|)
name|move_crsr
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|saved_xpos
argument_list|,
name|scp
operator|->
name|saved_ypos
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'['
case|:
comment|/* Start ESC [ sequence */
name|scp
operator|->
name|term
operator|.
name|esc
operator|=
literal|2
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|last_param
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|scp
operator|->
name|term
operator|.
name|num_param
init|;
name|i
operator|<
name|MAX_ESC_PAR
condition|;
name|i
operator|++
control|)
name|scp
operator|->
name|term
operator|.
name|param
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|num_param
operator|=
literal|0
expr_stmt|;
return|return;
ifdef|#
directive|ifdef
name|KANJI
case|case
literal|'$'
case|:
comment|/* Kanji IN sequence */
name|scp
operator|->
name|kanji_type
operator|=
literal|0x80
expr_stmt|;
return|return;
endif|#
directive|endif
case|case
literal|'M'
case|:
comment|/* Move cursor up 1 line, scroll if at top */
if|if
condition|(
name|scp
operator|->
name|ypos
operator|>
literal|0
condition|)
name|move_crsr
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|xpos
argument_list|,
name|scp
operator|->
name|ypos
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|PC98
name|bcopy
argument_list|(
name|scp
operator|->
name|scr_buf
argument_list|,
name|scp
operator|->
name|scr_buf
operator|+
name|scp
operator|->
name|xsize
argument_list|,
operator|(
name|scp
operator|->
name|ysize
operator|-
literal|1
operator|)
operator|*
name|scp
operator|->
name|xsize
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|scp
operator|->
name|atr_buf
argument_list|,
name|scp
operator|->
name|atr_buf
operator|+
name|scp
operator|->
name|xsize
argument_list|,
operator|(
name|scp
operator|->
name|ysize
operator|-
literal|1
operator|)
operator|*
name|scp
operator|->
name|xsize
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|fillw
argument_list|(
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|scp
operator|->
name|scr_buf
argument_list|,
name|scp
operator|->
name|xsize
argument_list|)
expr_stmt|;
name|fillw
argument_list|(
name|at2pc98
argument_list|(
name|scp
operator|->
name|term
operator|.
name|cur_color
argument_list|)
argument_list|,
name|scp
operator|->
name|atr_buf
argument_list|,
name|scp
operator|->
name|xsize
argument_list|)
expr_stmt|;
else|#
directive|else
name|bcopy
argument_list|(
name|scp
operator|->
name|scr_buf
argument_list|,
name|scp
operator|->
name|scr_buf
operator|+
name|scp
operator|->
name|xsize
argument_list|,
operator|(
name|scp
operator|->
name|ysize
operator|-
literal|1
operator|)
operator|*
name|scp
operator|->
name|xsize
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|fillw
argument_list|(
name|scp
operator|->
name|term
operator|.
name|cur_color
operator||
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|scp
operator|->
name|scr_buf
argument_list|,
name|scp
operator|->
name|xsize
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mark_all
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
break|break;
if|#
directive|if
name|notyet
case|case
literal|'Q'
case|:
name|scp
operator|->
name|term
operator|.
name|esc
operator|=
literal|4
expr_stmt|;
return|return;
endif|#
directive|endif
case|case
literal|'c'
case|:
comment|/* Clear screen& home */
name|clear_screen
argument_list|(
name|scp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'('
case|:
comment|/* iso-2022: designate 94 character set to G0 */
ifdef|#
directive|ifdef
name|KANJI
name|scp
operator|->
name|kanji_type
operator|=
literal|0x40
expr_stmt|;
else|#
directive|else
name|scp
operator|->
name|term
operator|.
name|esc
operator|=
literal|5
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|esc
operator|==
literal|2
condition|)
block|{
comment|/* seen ESC [ */
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
block|{
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|num_param
operator|<
name|MAX_ESC_PAR
condition|)
block|{
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|last_param
operator|!=
name|scp
operator|->
name|term
operator|.
name|num_param
condition|)
block|{
name|scp
operator|->
name|term
operator|.
name|last_param
operator|=
name|scp
operator|->
name|term
operator|.
name|num_param
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|param
index|[
name|scp
operator|->
name|term
operator|.
name|num_param
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|scp
operator|->
name|term
operator|.
name|param
index|[
name|scp
operator|->
name|term
operator|.
name|num_param
index|]
operator|*=
literal|10
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|param
index|[
name|scp
operator|->
name|term
operator|.
name|num_param
index|]
operator|+=
name|c
operator|-
literal|'0'
expr_stmt|;
return|return;
block|}
block|}
name|scp
operator|->
name|term
operator|.
name|num_param
operator|=
name|scp
operator|->
name|term
operator|.
name|last_param
operator|+
literal|1
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|';'
case|:
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|num_param
operator|<
name|MAX_ESC_PAR
condition|)
return|return;
break|break;
case|case
literal|'='
case|:
name|scp
operator|->
name|term
operator|.
name|esc
operator|=
literal|3
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|last_param
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|scp
operator|->
name|term
operator|.
name|num_param
init|;
name|i
operator|<
name|MAX_ESC_PAR
condition|;
name|i
operator|++
control|)
name|scp
operator|->
name|term
operator|.
name|param
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|num_param
operator|=
literal|0
expr_stmt|;
return|return;
case|case
literal|'A'
case|:
comment|/* up n rows */
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
name|n
operator|=
literal|1
expr_stmt|;
name|move_crsr
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|xpos
argument_list|,
name|scp
operator|->
name|ypos
operator|-
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
comment|/* down n rows */
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
name|n
operator|=
literal|1
expr_stmt|;
name|move_crsr
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|xpos
argument_list|,
name|scp
operator|->
name|ypos
operator|+
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
comment|/* right n columns */
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
name|n
operator|=
literal|1
expr_stmt|;
name|move_crsr
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|xpos
operator|+
name|n
argument_list|,
name|scp
operator|->
name|ypos
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
comment|/* left n columns */
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
name|n
operator|=
literal|1
expr_stmt|;
name|move_crsr
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|xpos
operator|-
name|n
argument_list|,
name|scp
operator|->
name|ypos
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
comment|/* cursor to start of line n lines down */
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
name|n
operator|=
literal|1
expr_stmt|;
name|move_crsr
argument_list|(
name|scp
argument_list|,
literal|0
argument_list|,
name|scp
operator|->
name|ypos
operator|+
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
comment|/* cursor to start of line n lines up */
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
name|n
operator|=
literal|1
expr_stmt|;
name|move_crsr
argument_list|(
name|scp
argument_list|,
literal|0
argument_list|,
name|scp
operator|->
name|ypos
operator|-
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* Cursor move */
case|case
literal|'H'
case|:
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|num_param
operator|==
literal|0
condition|)
name|move_crsr
argument_list|(
name|scp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|num_param
operator|==
literal|2
condition|)
name|move_crsr
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|1
index|]
operator|-
literal|1
argument_list|,
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'J'
case|:
comment|/* Clear all or part of display */
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|num_param
operator|==
literal|0
condition|)
name|n
operator|=
literal|0
expr_stmt|;
else|else
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
switch|switch
condition|(
name|n
condition|)
block|{
case|case
literal|0
case|:
comment|/* clear form cursor to end of display */
ifdef|#
directive|ifdef
name|PC98
name|fillw
argument_list|(
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|scp
operator|->
name|cursor_pos
argument_list|,
name|scp
operator|->
name|scr_buf
operator|+
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
operator|-
name|scp
operator|->
name|cursor_pos
argument_list|)
expr_stmt|;
name|fillw
argument_list|(
name|at2pc98
argument_list|(
name|scp
operator|->
name|term
operator|.
name|cur_color
argument_list|)
argument_list|,
name|scp
operator|->
name|cursor_atr
argument_list|,
name|scp
operator|->
name|atr_buf
operator|+
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
operator|-
name|scp
operator|->
name|cursor_atr
argument_list|)
expr_stmt|;
else|#
directive|else
name|fillw
argument_list|(
name|scp
operator|->
name|term
operator|.
name|cur_color
operator||
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|scp
operator|->
name|cursor_pos
argument_list|,
name|scp
operator|->
name|scr_buf
operator|+
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
operator|-
name|scp
operator|->
name|cursor_pos
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_atr
operator|-
name|scp
operator|->
name|atr_buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
argument_list|)
expr_stmt|;
name|remove_cutmarking
argument_list|(
name|scp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* clear from beginning of display to cursor */
ifdef|#
directive|ifdef
name|PC98
name|fillw
argument_list|(
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|scp
operator|->
name|scr_buf
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
name|fillw
argument_list|(
name|at2pc98
argument_list|(
name|scp
operator|->
name|term
operator|.
name|cur_color
argument_list|)
argument_list|,
name|scp
operator|->
name|atr_buf
argument_list|,
name|scp
operator|->
name|cursor_atr
operator|-
name|scp
operator|->
name|atr_buf
argument_list|)
expr_stmt|;
else|#
directive|else
name|fillw
argument_list|(
name|scp
operator|->
name|term
operator|.
name|cur_color
operator||
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|scp
operator|->
name|scr_buf
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mark_for_update
argument_list|(
name|scp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_atr
operator|-
name|scp
operator|->
name|atr_buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|remove_cutmarking
argument_list|(
name|scp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* clear entire display */
ifdef|#
directive|ifdef
name|PC98
name|fillw
argument_list|(
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|scp
operator|->
name|scr_buf
argument_list|,
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
argument_list|)
expr_stmt|;
name|fillw
argument_list|(
name|at2pc98
argument_list|(
name|scp
operator|->
name|term
operator|.
name|cur_color
argument_list|)
argument_list|,
name|scp
operator|->
name|atr_buf
argument_list|,
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
argument_list|)
expr_stmt|;
else|#
directive|else
name|fillw
argument_list|(
name|scp
operator|->
name|term
operator|.
name|cur_color
operator||
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|scp
operator|->
name|scr_buf
argument_list|,
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mark_all
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|remove_cutmarking
argument_list|(
name|scp
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'K'
case|:
comment|/* Clear all or part of line */
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|num_param
operator|==
literal|0
condition|)
name|n
operator|=
literal|0
expr_stmt|;
else|else
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
switch|switch
condition|(
name|n
condition|)
block|{
case|case
literal|0
case|:
comment|/* clear form cursor to end of line */
ifdef|#
directive|ifdef
name|PC98
name|fillw
argument_list|(
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|scp
operator|->
name|cursor_pos
argument_list|,
name|scp
operator|->
name|xsize
operator|-
name|scp
operator|->
name|xpos
argument_list|)
expr_stmt|;
name|fillw
argument_list|(
name|at2pc98
argument_list|(
name|scp
operator|->
name|term
operator|.
name|cur_color
argument_list|)
argument_list|,
name|scp
operator|->
name|cursor_atr
argument_list|,
name|scp
operator|->
name|xsize
operator|-
name|scp
operator|->
name|xpos
argument_list|)
expr_stmt|;
else|#
directive|else
name|fillw
argument_list|(
name|scp
operator|->
name|term
operator|.
name|cur_color
operator||
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|scp
operator|->
name|cursor_pos
argument_list|,
name|scp
operator|->
name|xsize
operator|-
name|scp
operator|->
name|xpos
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_atr
operator|-
name|scp
operator|->
name|atr_buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
operator|+
name|scp
operator|->
name|xsize
operator|-
name|scp
operator|->
name|xpos
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_atr
operator|-
name|scp
operator|->
name|atr_buf
operator|+
name|scp
operator|->
name|xsize
operator|-
name|scp
operator|->
name|xpos
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|1
case|:
comment|/* clear from beginning of line to cursor */
ifdef|#
directive|ifdef
name|PC98
name|fillw
argument_list|(
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|xpos
argument_list|,
name|scp
operator|->
name|xpos
operator|+
literal|1
argument_list|)
expr_stmt|;
name|fillw
argument_list|(
name|at2pc98
argument_list|(
name|scp
operator|->
name|term
operator|.
name|cur_color
argument_list|)
argument_list|,
name|scp
operator|->
name|cursor_atr
operator|-
name|scp
operator|->
name|xpos
argument_list|,
name|scp
operator|->
name|xpos
operator|+
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|fillw
argument_list|(
name|scp
operator|->
name|term
operator|.
name|cur_color
operator||
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|xpos
argument_list|,
name|scp
operator|->
name|xpos
operator|+
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|ypos
operator|*
name|scp
operator|->
name|xsize
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_atr
operator|-
name|scp
operator|->
name|atr_buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|2
case|:
comment|/* clear entire line */
ifdef|#
directive|ifdef
name|PC98
name|fillw
argument_list|(
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|xpos
argument_list|,
name|scp
operator|->
name|xsize
argument_list|)
expr_stmt|;
name|fillw
argument_list|(
name|at2pc98
argument_list|(
name|scp
operator|->
name|term
operator|.
name|cur_color
argument_list|)
argument_list|,
name|scp
operator|->
name|cursor_atr
operator|-
name|scp
operator|->
name|xpos
argument_list|,
name|scp
operator|->
name|xsize
argument_list|)
expr_stmt|;
else|#
directive|else
name|fillw
argument_list|(
name|scp
operator|->
name|term
operator|.
name|cur_color
operator||
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|xpos
argument_list|,
name|scp
operator|->
name|xsize
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|ypos
operator|*
name|scp
operator|->
name|xsize
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
operator|(
name|scp
operator|->
name|ypos
operator|+
literal|1
operator|)
operator|*
name|scp
operator|->
name|xsize
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'L'
case|:
comment|/* Insert n lines */
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
name|n
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|scp
operator|->
name|ysize
operator|-
name|scp
operator|->
name|ypos
condition|)
name|n
operator|=
name|scp
operator|->
name|ysize
operator|-
name|scp
operator|->
name|ypos
expr_stmt|;
name|src
operator|=
name|scp
operator|->
name|scr_buf
operator|+
name|scp
operator|->
name|ypos
operator|*
name|scp
operator|->
name|xsize
expr_stmt|;
name|dst
operator|=
name|src
operator|+
name|n
operator|*
name|scp
operator|->
name|xsize
expr_stmt|;
name|count
operator|=
name|scp
operator|->
name|ysize
operator|-
operator|(
name|scp
operator|->
name|ypos
operator|+
name|n
operator|)
expr_stmt|;
name|bcopy
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|count
operator|*
name|scp
operator|->
name|xsize
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|src_attr
operator|=
name|scp
operator|->
name|atr_buf
operator|+
name|scp
operator|->
name|ypos
operator|*
name|scp
operator|->
name|xsize
expr_stmt|;
name|dst_attr
operator|=
name|src_attr
operator|+
name|n
operator|*
name|scp
operator|->
name|xsize
expr_stmt|;
name|bcopy
argument_list|(
name|src_attr
argument_list|,
name|dst_attr
argument_list|,
name|count
operator|*
name|scp
operator|->
name|xsize
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|fillw
argument_list|(
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|src
argument_list|,
name|n
operator|*
name|scp
operator|->
name|xsize
argument_list|)
expr_stmt|;
name|fillw
argument_list|(
name|at2pc98
argument_list|(
name|scp
operator|->
name|term
operator|.
name|cur_color
argument_list|)
argument_list|,
name|src_attr
argument_list|,
name|n
operator|*
name|scp
operator|->
name|xsize
argument_list|)
expr_stmt|;
else|#
directive|else
name|fillw
argument_list|(
name|scp
operator|->
name|term
operator|.
name|cur_color
operator||
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|src
argument_list|,
name|n
operator|*
name|scp
operator|->
name|xsize
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|ypos
operator|*
name|scp
operator|->
name|xsize
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
comment|/* Delete n lines */
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
name|n
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|scp
operator|->
name|ysize
operator|-
name|scp
operator|->
name|ypos
condition|)
name|n
operator|=
name|scp
operator|->
name|ysize
operator|-
name|scp
operator|->
name|ypos
expr_stmt|;
name|dst
operator|=
name|scp
operator|->
name|scr_buf
operator|+
name|scp
operator|->
name|ypos
operator|*
name|scp
operator|->
name|xsize
expr_stmt|;
name|src
operator|=
name|dst
operator|+
name|n
operator|*
name|scp
operator|->
name|xsize
expr_stmt|;
name|count
operator|=
name|scp
operator|->
name|ysize
operator|-
operator|(
name|scp
operator|->
name|ypos
operator|+
name|n
operator|)
expr_stmt|;
name|bcopy
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|count
operator|*
name|scp
operator|->
name|xsize
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|src
operator|=
name|dst
operator|+
name|count
operator|*
name|scp
operator|->
name|xsize
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|dst_attr
operator|=
name|scp
operator|->
name|atr_buf
operator|+
name|scp
operator|->
name|ypos
operator|*
name|scp
operator|->
name|xsize
expr_stmt|;
name|src_attr
operator|=
name|dst_attr
operator|+
name|n
operator|*
name|scp
operator|->
name|xsize
expr_stmt|;
name|bcopy
argument_list|(
name|src_attr
argument_list|,
name|dst_attr
argument_list|,
name|count
operator|*
name|scp
operator|->
name|xsize
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|src_attr
operator|=
name|dst_attr
operator|+
name|count
operator|*
name|scp
operator|->
name|xsize
expr_stmt|;
name|fillw
argument_list|(
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|src
argument_list|,
name|n
operator|*
name|scp
operator|->
name|xsize
argument_list|)
expr_stmt|;
name|fillw
argument_list|(
name|at2pc98
argument_list|(
name|scp
operator|->
name|term
operator|.
name|cur_color
argument_list|)
argument_list|,
name|src_attr
argument_list|,
name|n
operator|*
name|scp
operator|->
name|xsize
argument_list|)
expr_stmt|;
else|#
directive|else
name|fillw
argument_list|(
name|scp
operator|->
name|term
operator|.
name|cur_color
operator||
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|src
argument_list|,
name|n
operator|*
name|scp
operator|->
name|xsize
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|ypos
operator|*
name|scp
operator|->
name|xsize
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
comment|/* Delete n chars */
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
name|n
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|scp
operator|->
name|xsize
operator|-
name|scp
operator|->
name|xpos
condition|)
name|n
operator|=
name|scp
operator|->
name|xsize
operator|-
name|scp
operator|->
name|xpos
expr_stmt|;
name|dst
operator|=
name|scp
operator|->
name|cursor_pos
expr_stmt|;
name|src
operator|=
name|dst
operator|+
name|n
expr_stmt|;
name|count
operator|=
name|scp
operator|->
name|xsize
operator|-
operator|(
name|scp
operator|->
name|xpos
operator|+
name|n
operator|)
expr_stmt|;
name|bcopy
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|src
operator|=
name|dst
operator|+
name|count
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|dst_attr
operator|=
name|scp
operator|->
name|cursor_atr
expr_stmt|;
name|src_attr
operator|=
name|dst_attr
operator|+
name|n
expr_stmt|;
name|bcopy
argument_list|(
name|src_attr
argument_list|,
name|dst_attr
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|src_attr
operator|=
name|dst_attr
operator|+
name|count
expr_stmt|;
name|fillw
argument_list|(
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|src
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|fillw
argument_list|(
name|at2pc98
argument_list|(
name|scp
operator|->
name|term
operator|.
name|cur_color
argument_list|)
argument_list|,
name|src_attr
argument_list|,
name|n
argument_list|)
expr_stmt|;
else|#
directive|else
name|fillw
argument_list|(
name|scp
operator|->
name|term
operator|.
name|cur_color
operator||
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|src
argument_list|,
name|n
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_atr
operator|-
name|scp
operator|->
name|atr_buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
operator|+
name|n
operator|+
name|count
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_atr
operator|-
name|scp
operator|->
name|atr_buf
operator|+
name|n
operator|+
name|count
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'@'
case|:
comment|/* Insert n chars */
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
name|n
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|scp
operator|->
name|xsize
operator|-
name|scp
operator|->
name|xpos
condition|)
name|n
operator|=
name|scp
operator|->
name|xsize
operator|-
name|scp
operator|->
name|xpos
expr_stmt|;
name|src
operator|=
name|scp
operator|->
name|cursor_pos
expr_stmt|;
name|dst
operator|=
name|src
operator|+
name|n
expr_stmt|;
name|count
operator|=
name|scp
operator|->
name|xsize
operator|-
operator|(
name|scp
operator|->
name|xpos
operator|+
name|n
operator|)
expr_stmt|;
name|bcopy
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|src_attr
operator|=
name|scp
operator|->
name|cursor_atr
expr_stmt|;
name|dst_attr
operator|=
name|src_attr
operator|+
name|n
expr_stmt|;
name|bcopy
argument_list|(
name|src_attr
argument_list|,
name|dst_attr
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|fillw
argument_list|(
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|src
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|fillw
argument_list|(
name|at2pc98
argument_list|(
name|scp
operator|->
name|term
operator|.
name|cur_color
argument_list|)
argument_list|,
name|src_attr
argument_list|,
name|n
argument_list|)
expr_stmt|;
else|#
directive|else
name|fillw
argument_list|(
name|scp
operator|->
name|term
operator|.
name|cur_color
operator||
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|src
argument_list|,
name|n
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_atr
operator|-
name|scp
operator|->
name|atr_buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
operator|+
name|n
operator|+
name|count
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_atr
operator|-
name|scp
operator|->
name|atr_buf
operator|+
name|n
operator|+
name|count
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'S'
case|:
comment|/* scroll up n lines */
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
name|n
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|scp
operator|->
name|ysize
condition|)
name|n
operator|=
name|scp
operator|->
name|ysize
expr_stmt|;
name|bcopy
argument_list|(
name|scp
operator|->
name|scr_buf
operator|+
operator|(
name|scp
operator|->
name|xsize
operator|*
name|n
operator|)
argument_list|,
name|scp
operator|->
name|scr_buf
argument_list|,
name|scp
operator|->
name|xsize
operator|*
operator|(
name|scp
operator|->
name|ysize
operator|-
name|n
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|bcopy
argument_list|(
name|scp
operator|->
name|atr_buf
operator|+
operator|(
name|scp
operator|->
name|xsize
operator|*
name|n
operator|)
argument_list|,
name|scp
operator|->
name|atr_buf
argument_list|,
name|scp
operator|->
name|xsize
operator|*
operator|(
name|scp
operator|->
name|ysize
operator|-
name|n
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|fillw
argument_list|(
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|scp
operator|->
name|scr_buf
operator|+
name|scp
operator|->
name|xsize
operator|*
operator|(
name|scp
operator|->
name|ysize
operator|-
name|n
operator|)
argument_list|,
name|scp
operator|->
name|xsize
operator|*
name|n
argument_list|)
expr_stmt|;
name|fillw
argument_list|(
name|at2pc98
argument_list|(
name|scp
operator|->
name|term
operator|.
name|cur_color
argument_list|)
argument_list|,
name|scp
operator|->
name|atr_buf
operator|+
name|scp
operator|->
name|xsize
operator|*
operator|(
name|scp
operator|->
name|ysize
operator|-
name|n
operator|)
argument_list|,
name|scp
operator|->
name|xsize
operator|*
name|n
argument_list|)
expr_stmt|;
else|#
directive|else
name|fillw
argument_list|(
name|scp
operator|->
name|term
operator|.
name|cur_color
operator||
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|scp
operator|->
name|scr_buf
operator|+
name|scp
operator|->
name|xsize
operator|*
operator|(
name|scp
operator|->
name|ysize
operator|-
name|n
operator|)
argument_list|,
name|scp
operator|->
name|xsize
operator|*
name|n
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mark_all
argument_list|(
name|scp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
comment|/* scroll down n lines */
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
name|n
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|scp
operator|->
name|ysize
condition|)
name|n
operator|=
name|scp
operator|->
name|ysize
expr_stmt|;
name|bcopy
argument_list|(
name|scp
operator|->
name|scr_buf
argument_list|,
name|scp
operator|->
name|scr_buf
operator|+
operator|(
name|scp
operator|->
name|xsize
operator|*
name|n
operator|)
argument_list|,
name|scp
operator|->
name|xsize
operator|*
operator|(
name|scp
operator|->
name|ysize
operator|-
name|n
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|bcopy
argument_list|(
name|scp
operator|->
name|atr_buf
argument_list|,
name|scp
operator|->
name|atr_buf
operator|+
operator|(
name|scp
operator|->
name|xsize
operator|*
name|n
operator|)
argument_list|,
name|scp
operator|->
name|xsize
operator|*
operator|(
name|scp
operator|->
name|ysize
operator|-
name|n
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|fillw
argument_list|(
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|scp
operator|->
name|scr_buf
argument_list|,
name|scp
operator|->
name|xsize
operator|*
name|n
argument_list|)
expr_stmt|;
name|fillw
argument_list|(
name|at2pc98
argument_list|(
name|scp
operator|->
name|term
operator|.
name|cur_color
argument_list|)
argument_list|,
name|scp
operator|->
name|atr_buf
argument_list|,
name|scp
operator|->
name|xsize
operator|*
name|n
argument_list|)
expr_stmt|;
else|#
directive|else
name|fillw
argument_list|(
name|scp
operator|->
name|term
operator|.
name|cur_color
operator||
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|scp
operator|->
name|scr_buf
argument_list|,
name|scp
operator|->
name|xsize
operator|*
name|n
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mark_all
argument_list|(
name|scp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
comment|/* erase n characters in line */
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
name|n
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|scp
operator|->
name|xsize
operator|-
name|scp
operator|->
name|xpos
condition|)
name|n
operator|=
name|scp
operator|->
name|xsize
operator|-
name|scp
operator|->
name|xpos
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|fillw
argument_list|(
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|scp
operator|->
name|cursor_pos
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|fillw
argument_list|(
name|at2pc98
argument_list|(
name|scp
operator|->
name|term
operator|.
name|cur_color
argument_list|)
argument_list|,
name|scp
operator|->
name|cursor_atr
argument_list|,
name|n
argument_list|)
expr_stmt|;
else|#
directive|else
name|fillw
argument_list|(
name|scp
operator|->
name|term
operator|.
name|cur_color
operator||
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|scp
operator|->
name|cursor_pos
argument_list|,
name|n
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_atr
operator|-
name|scp
operator|->
name|atr_buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
operator|+
name|n
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_atr
operator|-
name|scp
operator|->
name|atr_buf
operator|+
name|n
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'Z'
case|:
comment|/* move n tabs backwards */
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
name|n
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|scp
operator|->
name|xpos
operator|&
literal|0xf8
operator|)
operator|==
name|scp
operator|->
name|xpos
condition|)
name|i
operator|-=
literal|8
operator|*
name|n
expr_stmt|;
else|else
name|i
operator|-=
literal|8
operator|*
operator|(
name|n
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|i
operator|=
literal|0
expr_stmt|;
name|move_crsr
argument_list|(
name|scp
argument_list|,
name|i
argument_list|,
name|scp
operator|->
name|ypos
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'`'
case|:
comment|/* move cursor to column n */
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
name|n
operator|=
literal|1
expr_stmt|;
name|move_crsr
argument_list|(
name|scp
argument_list|,
name|n
operator|-
literal|1
argument_list|,
name|scp
operator|->
name|ypos
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
comment|/* move cursor n columns to the right */
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
name|n
operator|=
literal|1
expr_stmt|;
name|move_crsr
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|xpos
operator|+
name|n
argument_list|,
name|scp
operator|->
name|ypos
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* move cursor to row n */
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
name|n
operator|=
literal|1
expr_stmt|;
name|move_crsr
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|xpos
argument_list|,
name|n
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
comment|/* move cursor n rows down */
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
name|n
operator|=
literal|1
expr_stmt|;
name|move_crsr
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|xpos
argument_list|,
name|scp
operator|->
name|ypos
operator|+
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
comment|/* change attribute */
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|num_param
operator|==
literal|0
condition|)
block|{
name|scp
operator|->
name|term
operator|.
name|attr_mask
operator|=
name|NORMAL_ATTR
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|scp
operator|->
name|term
operator|.
name|cur_color
operator|=
name|scp
operator|->
name|term
operator|.
name|std_color
expr_stmt|;
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|scp
operator|->
name|term
operator|.
name|num_param
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
name|i
index|]
condition|)
block|{
case|case
literal|0
case|:
comment|/* back to normal */
name|scp
operator|->
name|term
operator|.
name|attr_mask
operator|=
name|NORMAL_ATTR
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|scp
operator|->
name|term
operator|.
name|cur_color
operator|=
name|scp
operator|->
name|term
operator|.
name|std_color
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* bold */
name|scp
operator|->
name|term
operator|.
name|attr_mask
operator||=
name|BOLD_ATTR
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|mask2attr
argument_list|(
operator|&
name|scp
operator|->
name|term
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
comment|/* underline */
name|scp
operator|->
name|term
operator|.
name|attr_mask
operator||=
name|UNDERLINE_ATTR
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|mask2attr
argument_list|(
operator|&
name|scp
operator|->
name|term
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
comment|/* blink */
name|scp
operator|->
name|term
operator|.
name|attr_mask
operator||=
name|BLINK_ATTR
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|mask2attr
argument_list|(
operator|&
name|scp
operator|->
name|term
argument_list|)
expr_stmt|;
break|break;
case|case
literal|7
case|:
comment|/* reverse video */
name|scp
operator|->
name|term
operator|.
name|attr_mask
operator||=
name|REVERSE_ATTR
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|mask2attr
argument_list|(
operator|&
name|scp
operator|->
name|term
argument_list|)
expr_stmt|;
break|break;
case|case
literal|30
case|:
case|case
literal|31
case|:
comment|/* set fg color */
case|case
literal|32
case|:
case|case
literal|33
case|:
case|case
literal|34
case|:
case|case
literal|35
case|:
case|case
literal|36
case|:
case|case
literal|37
case|:
name|scp
operator|->
name|term
operator|.
name|attr_mask
operator||=
name|FOREGROUND_CHANGED
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_color
operator|=
operator|(
name|scp
operator|->
name|term
operator|.
name|cur_color
operator|&
literal|0xF000
operator|)
operator||
operator|(
name|ansi_col
index|[
operator|(
name|n
operator|-
literal|30
operator|)
operator|&
literal|7
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|mask2attr
argument_list|(
operator|&
name|scp
operator|->
name|term
argument_list|)
expr_stmt|;
break|break;
case|case
literal|40
case|:
case|case
literal|41
case|:
comment|/* set bg color */
case|case
literal|42
case|:
case|case
literal|43
case|:
case|case
literal|44
case|:
case|case
literal|45
case|:
case|case
literal|46
case|:
case|case
literal|47
case|:
name|scp
operator|->
name|term
operator|.
name|attr_mask
operator||=
name|BACKGROUND_CHANGED
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_color
operator|=
operator|(
name|scp
operator|->
name|term
operator|.
name|cur_color
operator|&
literal|0x0F00
operator|)
operator||
operator|(
name|ansi_col
index|[
operator|(
name|n
operator|-
literal|40
operator|)
operator|&
literal|7
index|]
operator|<<
literal|12
operator|)
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|mask2attr
argument_list|(
operator|&
name|scp
operator|->
name|term
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
literal|'s'
case|:
comment|/* Save cursor position */
name|scp
operator|->
name|saved_xpos
operator|=
name|scp
operator|->
name|xpos
expr_stmt|;
name|scp
operator|->
name|saved_ypos
operator|=
name|scp
operator|->
name|ypos
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
comment|/* Restore saved cursor position */
if|if
condition|(
name|scp
operator|->
name|saved_xpos
operator|>=
literal|0
operator|&&
name|scp
operator|->
name|saved_ypos
operator|>=
literal|0
condition|)
name|move_crsr
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|saved_xpos
argument_list|,
name|scp
operator|->
name|saved_ypos
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|num_param
operator|==
literal|0
condition|)
name|n
operator|=
literal|0
expr_stmt|;
else|else
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
switch|switch
condition|(
name|n
condition|)
block|{
case|case
literal|0
case|:
comment|/* reset attributes */
name|scp
operator|->
name|term
operator|.
name|attr_mask
operator|=
name|NORMAL_ATTR
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|scp
operator|->
name|term
operator|.
name|cur_color
operator|=
name|scp
operator|->
name|term
operator|.
name|std_color
operator|=
name|current_default
operator|->
name|std_color
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|rev_color
operator|=
name|current_default
operator|->
name|rev_color
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* set ansi background */
name|scp
operator|->
name|term
operator|.
name|attr_mask
operator|&=
operator|~
name|BACKGROUND_CHANGED
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_color
operator|=
name|scp
operator|->
name|term
operator|.
name|std_color
operator|=
operator|(
name|scp
operator|->
name|term
operator|.
name|std_color
operator|&
literal|0x0F00
operator|)
operator||
operator|(
name|ansi_col
index|[
operator|(
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|1
index|]
operator|)
operator|&
literal|0x0F
index|]
operator|<<
literal|12
operator|)
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|mask2attr
argument_list|(
operator|&
name|scp
operator|->
name|term
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* set ansi foreground */
name|scp
operator|->
name|term
operator|.
name|attr_mask
operator|&=
operator|~
name|FOREGROUND_CHANGED
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_color
operator|=
name|scp
operator|->
name|term
operator|.
name|std_color
operator|=
operator|(
name|scp
operator|->
name|term
operator|.
name|std_color
operator|&
literal|0xF000
operator|)
operator||
operator|(
name|ansi_col
index|[
operator|(
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|1
index|]
operator|)
operator|&
literal|0x0F
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|mask2attr
argument_list|(
operator|&
name|scp
operator|->
name|term
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* set ansi attribute directly */
name|scp
operator|->
name|term
operator|.
name|attr_mask
operator|&=
operator|~
operator|(
name|FOREGROUND_CHANGED
operator||
name|BACKGROUND_CHANGED
operator|)
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_color
operator|=
name|scp
operator|->
name|term
operator|.
name|std_color
operator|=
operator|(
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|1
index|]
operator|&
literal|0xFF
operator|)
operator|<<
literal|8
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|mask2attr
argument_list|(
operator|&
name|scp
operator|->
name|term
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
comment|/* set ansi reverse video background */
name|scp
operator|->
name|term
operator|.
name|rev_color
operator|=
operator|(
name|scp
operator|->
name|term
operator|.
name|rev_color
operator|&
literal|0x0F00
operator|)
operator||
operator|(
name|ansi_col
index|[
operator|(
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|1
index|]
operator|)
operator|&
literal|0x0F
index|]
operator|<<
literal|12
operator|)
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|mask2attr
argument_list|(
operator|&
name|scp
operator|->
name|term
argument_list|)
expr_stmt|;
break|break;
case|case
literal|6
case|:
comment|/* set ansi reverse video foreground */
name|scp
operator|->
name|term
operator|.
name|rev_color
operator|=
operator|(
name|scp
operator|->
name|term
operator|.
name|rev_color
operator|&
literal|0xF000
operator|)
operator||
operator|(
name|ansi_col
index|[
operator|(
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|1
index|]
operator|)
operator|&
literal|0x0F
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|mask2attr
argument_list|(
operator|&
name|scp
operator|->
name|term
argument_list|)
expr_stmt|;
break|break;
case|case
literal|7
case|:
comment|/* set ansi reverse video directly */
name|scp
operator|->
name|term
operator|.
name|rev_color
operator|=
operator|(
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|1
index|]
operator|&
literal|0xFF
operator|)
operator|<<
literal|8
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|mask2attr
argument_list|(
operator|&
name|scp
operator|->
name|term
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'z'
case|:
comment|/* switch to (virtual) console n */
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|num_param
operator|==
literal|1
condition|)
name|switch_scr
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|esc
operator|==
literal|3
condition|)
block|{
comment|/* seen ESC [0-9]+ = */
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
block|{
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|num_param
operator|<
name|MAX_ESC_PAR
condition|)
block|{
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|last_param
operator|!=
name|scp
operator|->
name|term
operator|.
name|num_param
condition|)
block|{
name|scp
operator|->
name|term
operator|.
name|last_param
operator|=
name|scp
operator|->
name|term
operator|.
name|num_param
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|param
index|[
name|scp
operator|->
name|term
operator|.
name|num_param
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|scp
operator|->
name|term
operator|.
name|param
index|[
name|scp
operator|->
name|term
operator|.
name|num_param
index|]
operator|*=
literal|10
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|param
index|[
name|scp
operator|->
name|term
operator|.
name|num_param
index|]
operator|+=
name|c
operator|-
literal|'0'
expr_stmt|;
return|return;
block|}
block|}
name|scp
operator|->
name|term
operator|.
name|num_param
operator|=
name|scp
operator|->
name|term
operator|.
name|last_param
operator|+
literal|1
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|';'
case|:
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|num_param
operator|<
name|MAX_ESC_PAR
condition|)
return|return;
break|break;
case|case
literal|'A'
case|:
comment|/* set display border color */
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|num_param
operator|==
literal|1
condition|)
block|{
name|scp
operator|->
name|border
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|scp
operator|==
name|cur_console
condition|)
name|set_border
argument_list|(
name|scp
operator|->
name|border
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'B'
case|:
comment|/* set bell pitch and duration */
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|num_param
operator|==
literal|2
condition|)
block|{
name|scp
operator|->
name|bell_pitch
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
name|scp
operator|->
name|bell_duration
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|1
index|]
operator|*
literal|10
expr_stmt|;
block|}
break|break;
case|case
literal|'C'
case|:
comment|/* set cursor type& shape */
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|num_param
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
operator|&
literal|0x01
condition|)
name|flags
operator||=
name|BLINK_CURSOR
expr_stmt|;
else|else
name|flags
operator|&=
operator|~
name|BLINK_CURSOR
expr_stmt|;
if|if
condition|(
operator|(
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
operator|&
literal|0x02
operator|)
operator|&&
name|crtc_vga
condition|)
name|flags
operator||=
name|CHAR_CURSOR
expr_stmt|;
else|else
name|flags
operator|&=
operator|~
name|CHAR_CURSOR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|num_param
operator|==
literal|2
condition|)
block|{
name|scp
operator|->
name|cursor_start
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
operator|&
literal|0x1F
expr_stmt|;
name|scp
operator|->
name|cursor_end
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|1
index|]
operator|&
literal|0x1F
expr_stmt|;
block|}
comment|/*  	     * The cursor shape is global property; all virtual consoles 	     * are affected. Update the cursor in the current console... 	     */
if|if
condition|(
operator|!
operator|(
name|cur_console
operator|->
name|status
operator|&
name|UNKNOWN_MODE
operator|)
condition|)
block|{
name|remove_cursor_image
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
if|if
condition|(
name|crtc_vga
operator|&&
operator|(
name|flags
operator|&
name|CHAR_CURSOR
operator|)
condition|)
name|set_destructive_cursor
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
name|draw_cursor_image
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'F'
case|:
comment|/* set ansi foreground */
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|num_param
operator|==
literal|1
condition|)
block|{
name|scp
operator|->
name|term
operator|.
name|attr_mask
operator|&=
operator|~
name|FOREGROUND_CHANGED
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_color
operator|=
name|scp
operator|->
name|term
operator|.
name|std_color
operator|=
operator|(
name|scp
operator|->
name|term
operator|.
name|std_color
operator|&
literal|0xF000
operator|)
operator||
operator|(
operator|(
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
operator|&
literal|0x0F
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|mask2attr
argument_list|(
operator|&
name|scp
operator|->
name|term
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'G'
case|:
comment|/* set ansi background */
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|num_param
operator|==
literal|1
condition|)
block|{
name|scp
operator|->
name|term
operator|.
name|attr_mask
operator|&=
operator|~
name|BACKGROUND_CHANGED
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_color
operator|=
name|scp
operator|->
name|term
operator|.
name|std_color
operator|=
operator|(
name|scp
operator|->
name|term
operator|.
name|std_color
operator|&
literal|0x0F00
operator|)
operator||
operator|(
operator|(
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
operator|&
literal|0x0F
operator|)
operator|<<
literal|12
operator|)
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|mask2attr
argument_list|(
operator|&
name|scp
operator|->
name|term
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'H'
case|:
comment|/* set ansi reverse video foreground */
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|num_param
operator|==
literal|1
condition|)
block|{
name|scp
operator|->
name|term
operator|.
name|rev_color
operator|=
operator|(
name|scp
operator|->
name|term
operator|.
name|rev_color
operator|&
literal|0xF000
operator|)
operator||
operator|(
operator|(
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
operator|&
literal|0x0F
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|mask2attr
argument_list|(
operator|&
name|scp
operator|->
name|term
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'I'
case|:
comment|/* set ansi reverse video background */
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|num_param
operator|==
literal|1
condition|)
block|{
name|scp
operator|->
name|term
operator|.
name|rev_color
operator|=
operator|(
name|scp
operator|->
name|term
operator|.
name|rev_color
operator|&
literal|0x0F00
operator|)
operator||
operator|(
operator|(
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
operator|&
literal|0x0F
operator|)
operator|<<
literal|12
operator|)
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|mask2attr
argument_list|(
operator|&
name|scp
operator|->
name|term
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
if|#
directive|if
name|notyet
elseif|else
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|esc
operator|==
literal|4
condition|)
block|{
comment|/* seen ESC Q */
comment|/* to be filled */
block|}
endif|#
directive|endif
elseif|else
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|esc
operator|==
literal|5
condition|)
block|{
comment|/* seen ESC ( */
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'B'
case|:
comment|/* iso-2022: desginate ASCII into G0 */
break|break;
comment|/* other items to be filled */
default|default:
break|break;
block|}
block|}
name|scp
operator|->
name|term
operator|.
name|esc
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|KANJI
specifier|static
name|u_char
name|iskanji1
parameter_list|(
name|u_char
name|mode
parameter_list|,
name|u_char
name|c
parameter_list|)
block|{
if|if
condition|(
operator|(
name|mode
operator|==
literal|0x20
operator|)
operator|&&
operator|(
name|c
operator|>=
literal|0x21
operator|)
operator|&&
operator|(
name|c
operator|<=
literal|0x7e
operator|)
condition|)
block|{
comment|/* JIS */
return|return
literal|0x20
return|;
block|}
if|if
condition|(
operator|(
name|mode
operator|==
literal|0x10
operator|)
operator|&&
operator|(
name|c
operator|>=
literal|0x21
operator|)
operator|&&
operator|(
name|c
operator|<=
literal|0x5f
operator|)
condition|)
block|{
comment|/* JIS HANKAKU */
return|return
literal|0x10
return|;
block|}
if|if
condition|(
operator|(
name|c
operator|>=
literal|0x81
operator|)
operator|&&
operator|(
name|c
operator|<=
literal|0x9f
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|0x8e
operator|)
condition|)
block|{
comment|/* SJIS */
name|default_kanji
operator|=
name|SJIS
expr_stmt|;
return|return
literal|2
return|;
block|}
if|if
condition|(
operator|(
name|c
operator|>=
literal|0xa1
operator|)
operator|&&
operator|(
name|c
operator|<=
literal|0xdf
operator|)
operator|&&
operator|(
name|default_kanji
operator|==
name|SJIS
operator|)
condition|)
block|{
comment|/* Sjis HANKAKU */
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|(
name|c
operator|>=
literal|0xa1
operator|)
operator|&&
operator|(
name|c
operator|<=
literal|0xdf
operator|)
operator|&&
operator|(
name|default_kanji
operator|==
name|UJIS
operator|)
condition|)
block|{
comment|/* UJIS */
return|return
literal|4
return|;
block|}
if|if
condition|(
operator|(
name|c
operator|>=
literal|0xf0
operator|)
operator|&&
operator|(
name|c
operator|<=
literal|0xfe
operator|)
condition|)
block|{
comment|/* UJIS */
name|default_kanji
operator|=
name|UJIS
expr_stmt|;
return|return
literal|4
return|;
block|}
if|if
condition|(
operator|(
name|c
operator|>=
literal|0xe0
operator|)
operator|&&
operator|(
name|c
operator|<=
literal|0xef
operator|)
condition|)
block|{
comment|/* SJIS or UJIS */
return|return
literal|6
return|;
block|}
if|if
condition|(
name|c
operator|==
literal|0x8e
condition|)
block|{
comment|/* SJIS or UJIS HANKAKU */
return|return
literal|3
return|;
block|}
return|return
literal|0
return|;
block|}
specifier|static
name|u_char
name|iskanji2
parameter_list|(
name|u_char
name|mode
parameter_list|,
name|u_char
name|c
parameter_list|)
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
literal|0x20
case|:
if|if
condition|(
operator|(
name|c
operator|>=
literal|0x21
operator|)
operator|&&
operator|(
name|c
operator|<=
literal|0x7e
operator|)
condition|)
block|{
comment|/* JIS */
return|return
literal|0x20
return|;
block|}
break|break;
case|case
literal|2
case|:
if|if
condition|(
operator|(
name|c
operator|>=
literal|0x40
operator|)
operator|&&
operator|(
name|c
operator|<=
literal|0xfc
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|0x7f
operator|)
condition|)
block|{
comment|/* SJIS */
return|return
literal|2
return|;
block|}
break|break;
case|case
literal|4
case|:
if|if
condition|(
operator|(
name|c
operator|>=
literal|0xa1
operator|)
operator|&&
operator|(
name|c
operator|<=
literal|0xfe
operator|)
condition|)
block|{
comment|/* UJIS */
return|return
literal|4
return|;
block|}
break|break;
case|case
literal|3
case|:
if|if
condition|(
operator|(
name|c
operator|>=
literal|0xa1
operator|)
operator|&&
operator|(
name|c
operator|<=
literal|0xdf
operator|)
operator|&&
operator|(
name|default_kanji
operator|==
name|UJIS
operator|)
condition|)
block|{
comment|/* UJIS HANKAKU */
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|(
name|c
operator|>=
literal|0x40
operator|)
operator|&&
operator|(
name|c
operator|<=
literal|0xfc
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|0x7f
operator|)
condition|)
block|{
comment|/* SJIS */
name|default_kanji
operator|=
name|SJIS
expr_stmt|;
return|return
literal|2
return|;
block|}
break|break;
case|case
literal|6
case|:
if|if
condition|(
operator|(
name|c
operator|>=
literal|0x40
operator|)
operator|&&
operator|(
name|c
operator|<=
literal|0xa0
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|0x7f
operator|)
condition|)
block|{
comment|/* SJIS */
name|default_kanji
operator|=
name|SJIS
expr_stmt|;
return|return
literal|2
return|;
block|}
if|if
condition|(
operator|(
name|c
operator|==
literal|0xfd
operator|)
operator|||
operator|(
name|c
operator|==
literal|0xfe
operator|)
condition|)
block|{
comment|/* UJIS */
name|default_kanji
operator|=
name|UJIS
expr_stmt|;
return|return
literal|4
return|;
block|}
if|if
condition|(
operator|(
name|c
operator|>=
literal|0xa1
operator|)
operator|&&
operator|(
name|c
operator|<=
literal|0xfc
operator|)
condition|)
block|{
if|if
condition|(
name|default_kanji
operator|==
name|SJIS
condition|)
return|return
literal|2
return|;
if|if
condition|(
name|default_kanji
operator|==
name|UJIS
condition|)
return|return
literal|4
return|;
block|}
break|break;
block|}
return|return
literal|0
return|;
block|}
comment|/*  * JIS X0208-83 keisen conversion table  */
specifier|static
name|u_short
name|keiConv
index|[
literal|32
index|]
init|=
block|{
literal|0x240c
block|,
literal|0x260c
block|,
literal|0x300c
block|,
literal|0x340c
block|,
literal|0x3c0c
block|,
literal|0x380c
block|,
literal|0x400c
block|,
literal|0x500c
block|,
literal|0x480c
block|,
literal|0x580c
block|,
literal|0x600c
block|,
literal|0x250c
block|,
literal|0x270c
block|,
literal|0x330c
block|,
literal|0x370c
block|,
literal|0x3f0c
block|,
literal|0x3b0c
block|,
literal|0x470c
block|,
literal|0x570c
block|,
literal|0x4f0c
block|,
literal|0x5f0c
block|,
literal|0x6f0c
block|,
literal|0x440c
block|,
literal|0x530c
block|,
literal|0x4c0c
block|,
literal|0x5b0c
block|,
literal|0x630c
block|,
literal|0x410c
block|,
literal|0x540c
block|,
literal|0x490c
block|,
literal|0x5c0c
block|,
literal|0x660c
block|}
decl_stmt|;
specifier|static
name|u_short
name|kanji_convert
parameter_list|(
name|u_char
name|mode
parameter_list|,
name|u_char
name|h
parameter_list|,
name|u_char
name|l
parameter_list|)
block|{
name|u_short
name|tmp
decl_stmt|,
name|high
decl_stmt|,
name|low
decl_stmt|,
name|c
decl_stmt|;
name|high
operator|=
operator|(
name|u_short
operator|)
name|h
expr_stmt|;
name|low
operator|=
operator|(
name|u_short
operator|)
name|l
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
literal|2
case|:
comment|/* SHIFT JIS */
if|if
condition|(
name|low
operator|>=
literal|0xe0
condition|)
block|{
name|low
operator|-=
literal|0x40
expr_stmt|;
block|}
name|low
operator|=
operator|(
name|low
operator|-
literal|0x81
operator|)
operator|*
literal|2
operator|+
literal|0x21
expr_stmt|;
if|if
condition|(
name|high
operator|>
literal|0x7f
condition|)
block|{
name|high
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|high
operator|>
literal|0x9d
condition|)
block|{
name|low
operator|++
expr_stmt|;
name|high
operator|-=
literal|0x9e
operator|-
literal|0x21
expr_stmt|;
block|}
else|else
block|{
name|high
operator|-=
literal|0x40
operator|-
literal|0x21
expr_stmt|;
block|}
name|high
operator|&=
literal|0x7F
expr_stmt|;
name|low
operator|&=
literal|0x7F
expr_stmt|;
name|tmp
operator|=
operator|(
operator|(
name|high
operator|<<
literal|8
operator|)
operator||
name|low
operator|)
operator|-
literal|0x20
expr_stmt|;
break|break;
case|case
literal|0x20
case|:
comment|/* JIS */
case|case
literal|4
case|:
comment|/* HANKAKU? */
name|high
operator|&=
literal|0x7F
expr_stmt|;
name|low
operator|&=
literal|0x7F
expr_stmt|;
name|tmp
operator|=
operator|(
operator|(
name|high
operator|<<
literal|8
operator|)
operator||
name|low
operator|)
operator|-
literal|0x20
expr_stmt|;
break|break;
default|default:
name|tmp
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* keisen */
name|c
operator|=
operator|(
operator|(
name|tmp
operator|&
literal|0xff
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
name|tmp
operator|>>
literal|8
operator|)
expr_stmt|;
if|if
condition|(
literal|0x0821
operator|<=
name|c
operator|&&
name|c
operator|<=
literal|0x0840
condition|)
name|tmp
operator|=
name|keiConv
index|[
name|c
operator|-
literal|0x0821
index|]
expr_stmt|;
return|return
operator|(
name|tmp
operator|)
return|;
block|}
endif|#
directive|endif
specifier|static
name|void
name|ansi_put
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|u_char
modifier|*
name|ptr
init|=
name|buf
decl_stmt|;
ifdef|#
directive|ifdef
name|KANJI
name|u_short
name|i
decl_stmt|,
name|kanji_code
decl_stmt|;
endif|#
directive|endif
comment|/* make screensaver happy */
if|if
condition|(
name|scp
operator|==
name|cur_console
condition|)
name|scrn_time_stamp
operator|=
name|mono_time
operator|.
name|tv_sec
expr_stmt|;
name|write_in_progress
operator|++
expr_stmt|;
name|outloop
label|:
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|esc
condition|)
block|{
name|scan_esc
argument_list|(
name|scp
argument_list|,
operator|*
name|ptr
operator|++
argument_list|)
expr_stmt|;
name|len
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|PRINTABLE
argument_list|(
operator|*
name|ptr
argument_list|)
condition|)
block|{
comment|/* Print only printables */
name|int
name|cnt
init|=
name|len
operator|<=
operator|(
name|scp
operator|->
name|xsize
operator|-
name|scp
operator|->
name|xpos
operator|)
condition|?
name|len
else|:
operator|(
name|scp
operator|->
name|xsize
operator|-
name|scp
operator|->
name|xpos
operator|)
decl_stmt|;
name|u_short
name|cur_attr
init|=
name|scp
operator|->
name|term
operator|.
name|cur_attr
decl_stmt|;
name|u_short
modifier|*
name|cursor_pos
init|=
name|scp
operator|->
name|cursor_pos
decl_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|u_char
name|c
init|=
operator|*
name|ptr
decl_stmt|;
name|u_short
modifier|*
name|cursor_atr
init|=
name|scp
operator|->
name|cursor_atr
decl_stmt|;
ifdef|#
directive|ifdef
name|KANJI
if|if
condition|(
name|scp
operator|->
name|kanji_1st_char
operator|==
literal|0
condition|)
block|{
name|scp
operator|->
name|kanji_type
operator|=
name|iskanji1
argument_list|(
name|scp
operator|->
name|kanji_type
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|kanji_type
operator|&
literal|0xee
condition|)
block|{
comment|/* not Ascii& not HANKAKU */
name|scp
operator|->
name|kanji_1st_char
operator|=
name|c
expr_stmt|;
name|ptr
operator|++
expr_stmt|;
name|len
operator|--
expr_stmt|;
goto|goto
name|kanji_end
goto|;
block|}
else|else
block|{
name|scp
operator|->
name|kanji_1st_char
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|scp
operator|->
name|kanji_type
operator|=
name|iskanji2
argument_list|(
name|scp
operator|->
name|kanji_type
argument_list|,
name|c
argument_list|)
operator|)
operator|&
literal|0xee
condition|)
block|{
comment|/* print kanji on TEXT VRAM */
name|kanji_code
operator|=
name|kanji_convert
argument_list|(
name|scp
operator|->
name|kanji_type
argument_list|,
name|c
argument_list|,
name|scp
operator|->
name|kanji_1st_char
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|cursor_pos
operator|=
operator|(
name|kanji_code
operator||
operator|(
name|i
operator|*
literal|0x80
operator|)
operator|)
expr_stmt|;
operator|*
name|cursor_atr
operator|=
operator|(
name|at2pc98
argument_list|(
name|cur_attr
argument_list|)
operator|)
expr_stmt|;
name|cursor_pos
operator|++
expr_stmt|;
name|cursor_atr
operator|++
expr_stmt|;
if|if
condition|(
operator|++
name|scp
operator|->
name|xpos
operator|>=
name|scp
operator|->
name|xsize
condition|)
block|{
name|scp
operator|->
name|xpos
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|ypos
operator|++
expr_stmt|;
block|}
block|}
name|scp
operator|->
name|kanji_type
operator|&=
literal|0xF0
expr_stmt|;
name|scp
operator|->
name|kanji_1st_char
operator|=
literal|0
expr_stmt|;
name|ptr
operator|++
expr_stmt|;
name|len
operator|--
expr_stmt|;
goto|goto
name|kanji_end
goto|;
block|}
else|else
block|{
name|scp
operator|->
name|kanji_1st_char
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|scp
operator|->
name|kanji_type
operator|&
literal|0x11
operator|)
condition|)
name|c
operator||=
literal|0x80
expr_stmt|;
name|scp
operator|->
name|kanji_type
operator|&=
literal|0xf0
expr_stmt|;
endif|#
directive|endif
comment|/* KANJI */
operator|*
name|cursor_pos
operator|++
operator|=
operator|(
name|scr_map
index|[
name|c
index|]
operator|)
expr_stmt|;
operator|*
name|cursor_atr
operator|++
operator|=
name|at2pc98
argument_list|(
name|cur_attr
argument_list|)
expr_stmt|;
name|ptr
operator|++
expr_stmt|;
else|#
directive|else
do|do
block|{
comment|/* 	     * gcc-2.6.3 generates poor (un)sign extension code.  Casting the 	     * pointers in the following to volatile should have no effect, 	     * but in fact speeds up this inner loop from 26 to 18 cycles 	     * (+ cache misses) on i486's. 	     */
define|#
directive|define
name|UCVP
parameter_list|(
name|ucp
parameter_list|)
value|((u_char volatile *)(ucp))
operator|*
name|cursor_pos
operator|++
operator|=
name|UCVP
argument_list|(
name|scr_map
argument_list|)
index|[
operator|*
name|UCVP
argument_list|(
name|ptr
argument_list|)
index|]
operator||
name|cur_attr
expr_stmt|;
name|ptr
operator|++
expr_stmt|;
name|cnt
operator|--
expr_stmt|;
block|}
do|while
condition|(
name|cnt
operator|&&
name|PRINTABLE
argument_list|(
operator|*
name|ptr
argument_list|)
condition|)
do|;
endif|#
directive|endif
comment|/* PC98 */
name|len
operator|-=
operator|(
name|cursor_pos
operator|-
name|scp
operator|->
name|cursor_pos
operator|)
expr_stmt|;
name|scp
operator|->
name|xpos
operator|+=
operator|(
name|cursor_pos
operator|-
name|scp
operator|->
name|cursor_pos
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KANJI
name|kanji_end
label|:
endif|#
directive|endif
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_atr
operator|-
name|scp
operator|->
name|atr_buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|cursor_atr
operator|-
name|scp
operator|->
name|atr_buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|scp
operator|->
name|cursor_pos
operator|=
name|cursor_pos
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|scp
operator|->
name|cursor_atr
operator|=
name|cursor_atr
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|scp
operator|->
name|xpos
operator|>=
name|scp
operator|->
name|xsize
condition|)
block|{
name|scp
operator|->
name|xpos
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|ypos
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
switch|switch
condition|(
operator|*
name|ptr
condition|)
block|{
case|case
literal|0x07
case|:
name|do_bell
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|bell_pitch
argument_list|,
name|scp
operator|->
name|bell_duration
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x08
case|:
comment|/* non-destructive backspace */
if|if
condition|(
name|scp
operator|->
name|cursor_pos
operator|>
name|scp
operator|->
name|scr_buf
condition|)
block|{
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_atr
operator|-
name|scp
operator|->
name|atr_buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|scp
operator|->
name|cursor_pos
operator|--
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|scp
operator|->
name|cursor_atr
operator|--
expr_stmt|;
endif|#
directive|endif
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_atr
operator|-
name|scp
operator|->
name|atr_buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|scp
operator|->
name|xpos
operator|>
literal|0
condition|)
name|scp
operator|->
name|xpos
operator|--
expr_stmt|;
else|else
block|{
name|scp
operator|->
name|xpos
operator|+=
name|scp
operator|->
name|xsize
operator|-
literal|1
expr_stmt|;
name|scp
operator|->
name|ypos
operator|--
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|0x09
case|:
comment|/* non-destructive tab */
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_atr
operator|-
name|scp
operator|->
name|atr_buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|scp
operator|->
name|cursor_pos
operator|+=
operator|(
literal|8
operator|-
name|scp
operator|->
name|xpos
operator|%
literal|8u
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|scp
operator|->
name|cursor_atr
operator|+=
operator|(
literal|8
operator|-
name|scp
operator|->
name|xpos
operator|%
literal|8u
operator|)
expr_stmt|;
endif|#
directive|endif
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_atr
operator|-
name|scp
operator|->
name|atr_buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|scp
operator|->
name|xpos
operator|+=
operator|(
literal|8
operator|-
name|scp
operator|->
name|xpos
operator|%
literal|8u
operator|)
operator|)
operator|>=
name|scp
operator|->
name|xsize
condition|)
block|{
name|scp
operator|->
name|xpos
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|ypos
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|0x0a
case|:
comment|/* newline, same pos */
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_atr
operator|-
name|scp
operator|->
name|atr_buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|scp
operator|->
name|cursor_pos
operator|+=
name|scp
operator|->
name|xsize
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|scp
operator|->
name|cursor_atr
operator|+=
name|scp
operator|->
name|xsize
expr_stmt|;
endif|#
directive|endif
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_atr
operator|-
name|scp
operator|->
name|atr_buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|scp
operator|->
name|ypos
operator|++
expr_stmt|;
break|break;
case|case
literal|0x0c
case|:
comment|/* form feed, clears screen */
name|clear_screen
argument_list|(
name|scp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x0d
case|:
comment|/* return, return to pos 0 */
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_atr
operator|-
name|scp
operator|->
name|atr_buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|scp
operator|->
name|cursor_pos
operator|-=
name|scp
operator|->
name|xpos
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|scp
operator|->
name|cursor_atr
operator|-=
name|scp
operator|->
name|xpos
expr_stmt|;
endif|#
directive|endif
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_atr
operator|-
name|scp
operator|->
name|atr_buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|scp
operator|->
name|xpos
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|0x1b
case|:
comment|/* start escape sequence */
name|scp
operator|->
name|term
operator|.
name|esc
operator|=
literal|1
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|num_param
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|ptr
operator|++
expr_stmt|;
name|len
operator|--
expr_stmt|;
block|}
comment|/* do we have to scroll ?? */
if|if
condition|(
name|scp
operator|->
name|cursor_pos
operator|>=
name|scp
operator|->
name|scr_buf
operator|+
name|scp
operator|->
name|ysize
operator|*
name|scp
operator|->
name|xsize
condition|)
block|{
name|remove_cutmarking
argument_list|(
name|scp
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|history
condition|)
block|{
name|bcopy
argument_list|(
name|scp
operator|->
name|scr_buf
argument_list|,
name|scp
operator|->
name|history_head
argument_list|,
name|scp
operator|->
name|xsize
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|scp
operator|->
name|history_head
operator|+=
name|scp
operator|->
name|xsize
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|bcopy
argument_list|(
name|scp
operator|->
name|atr_buf
argument_list|,
name|scp
operator|->
name|his_atr_head
argument_list|,
name|scp
operator|->
name|xsize
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|scp
operator|->
name|his_atr_head
operator|+=
name|scp
operator|->
name|xsize
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|scp
operator|->
name|history_head
operator|+
name|scp
operator|->
name|xsize
operator|>
name|scp
operator|->
name|history
operator|+
name|scp
operator|->
name|history_size
condition|)
ifdef|#
directive|ifdef
name|PC98
block|{
endif|#
directive|endif
name|scp
operator|->
name|history_head
operator|=
name|scp
operator|->
name|history
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|scp
operator|->
name|his_atr_head
operator|=
name|scp
operator|->
name|his_atr
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|bcopy
argument_list|(
name|scp
operator|->
name|scr_buf
operator|+
name|scp
operator|->
name|xsize
argument_list|,
name|scp
operator|->
name|scr_buf
argument_list|,
name|scp
operator|->
name|xsize
operator|*
operator|(
name|scp
operator|->
name|ysize
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|bcopy
argument_list|(
name|scp
operator|->
name|atr_buf
operator|+
name|scp
operator|->
name|xsize
argument_list|,
name|scp
operator|->
name|atr_buf
argument_list|,
name|scp
operator|->
name|xsize
operator|*
operator|(
name|scp
operator|->
name|ysize
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|fillw
argument_list|(
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|scp
operator|->
name|scr_buf
operator|+
name|scp
operator|->
name|xsize
operator|*
operator|(
name|scp
operator|->
name|ysize
operator|-
literal|1
operator|)
argument_list|,
name|scp
operator|->
name|xsize
argument_list|)
expr_stmt|;
name|fillw
argument_list|(
name|at2pc98
argument_list|(
name|scp
operator|->
name|term
operator|.
name|cur_color
argument_list|)
argument_list|,
name|scp
operator|->
name|atr_buf
operator|+
name|scp
operator|->
name|xsize
operator|*
operator|(
name|scp
operator|->
name|ysize
operator|-
literal|1
operator|)
argument_list|,
name|scp
operator|->
name|xsize
argument_list|)
expr_stmt|;
else|#
directive|else
name|fillw
argument_list|(
name|scp
operator|->
name|term
operator|.
name|cur_color
operator||
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|scp
operator|->
name|scr_buf
operator|+
name|scp
operator|->
name|xsize
operator|*
operator|(
name|scp
operator|->
name|ysize
operator|-
literal|1
operator|)
argument_list|,
name|scp
operator|->
name|xsize
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|scp
operator|->
name|cursor_pos
operator|-=
name|scp
operator|->
name|xsize
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|scp
operator|->
name|cursor_atr
operator|-=
name|scp
operator|->
name|xsize
expr_stmt|;
endif|#
directive|endif
name|scp
operator|->
name|ypos
operator|--
expr_stmt|;
name|mark_all
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|len
condition|)
goto|goto
name|outloop
goto|;
name|write_in_progress
operator|--
expr_stmt|;
if|if
condition|(
name|delayed_next_scr
condition|)
name|switch_scr
argument_list|(
name|scp
argument_list|,
name|delayed_next_scr
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|scinit
parameter_list|(
name|void
parameter_list|)
block|{
name|u_int
name|hw_cursor
decl_stmt|;
name|u_int
name|i
decl_stmt|;
if|if
condition|(
name|init_done
operator|!=
name|COLD
condition|)
return|return;
name|init_done
operator|=
name|WARM
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
ifdef|#
directive|ifdef
name|AUTO_CLOCK
if|if
condition|(
name|pc98_machine_type
operator|&
name|M_8M
condition|)
block|{
name|BELL_PITCH
operator|=
literal|1339
expr_stmt|;
block|}
else|else
block|{
name|BELL_PITCH
operator|=
literal|1678
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* AUTO_CLOCK */
name|outb
argument_list|(
literal|0x62
argument_list|,
literal|0xd
argument_list|)
expr_stmt|;
name|outb
argument_list|(
literal|0xA2
argument_list|,
literal|0xd
argument_list|)
expr_stmt|;
comment|/* Extract cursor location */
while|while
condition|(
operator|(
name|inb
argument_list|(
name|TEXT_GDC
operator|+
literal|0
argument_list|)
operator|&
literal|0x04
operator|)
operator|==
literal|0
condition|)
block|{}
comment|/* GDC wait */
name|outb
argument_list|(
name|TEXT_GDC
operator|+
literal|2
argument_list|,
literal|0xe0
argument_list|)
expr_stmt|;
comment|/* CSRR */
while|while
condition|(
operator|(
name|inb
argument_list|(
name|TEXT_GDC
operator|+
literal|0
argument_list|)
operator|&
literal|0x1
operator|)
operator|==
literal|0
condition|)
block|{}
comment|/* GDC wait */
name|hw_cursor
operator|=
name|inb
argument_list|(
name|TEXT_GDC
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* EADl */
name|hw_cursor
operator||=
operator|(
name|inb
argument_list|(
name|TEXT_GDC
operator|+
literal|2
argument_list|)
operator|<<
literal|8
operator|)
expr_stmt|;
comment|/* EADh */
name|inb
argument_list|(
name|TEXT_GDC
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* dummy */
name|inb
argument_list|(
name|TEXT_GDC
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* dummy */
name|inb
argument_list|(
name|TEXT_GDC
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* dummy */
if|if
condition|(
name|hw_cursor
operator|>=
name|ROW
operator|*
name|COL
condition|)
block|{
name|hw_cursor
operator|=
literal|0
expr_stmt|;
block|}
name|crtc_vga
operator|=
name|TRUE
expr_stmt|;
else|#
directive|else
comment|/* IBM-PC */
comment|/*      * Ensure a zero start address.  This is mainly to recover after      * switching from pcvt using userconfig().  The registers are w/o      * for old hardware so it's too hard to relocate the active screen      * memory.      */
name|outb
argument_list|(
name|crtc_addr
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|crtc_addr
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|crtc_addr
argument_list|,
literal|13
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|crtc_addr
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* extract cursor location */
name|outb
argument_list|(
name|crtc_addr
argument_list|,
literal|14
argument_list|)
expr_stmt|;
name|hw_cursor
operator|=
name|inb
argument_list|(
name|crtc_addr
operator|+
literal|1
argument_list|)
operator|<<
literal|8
expr_stmt|;
name|outb
argument_list|(
name|crtc_addr
argument_list|,
literal|15
argument_list|)
expr_stmt|;
name|hw_cursor
operator||=
name|inb
argument_list|(
name|crtc_addr
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/*      * Validate cursor location.  It may be off the screen.  Then we must      * not use it for the initial buffer offset.      */
if|if
condition|(
name|hw_cursor
operator|>=
name|ROW
operator|*
name|COL
condition|)
name|hw_cursor
operator|=
operator|(
name|ROW
operator|-
literal|1
operator|)
operator|*
name|COL
expr_stmt|;
comment|/* move hardware cursor out of the way */
name|outb
argument_list|(
name|crtc_addr
argument_list|,
literal|14
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|crtc_addr
operator|+
literal|1
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|crtc_addr
argument_list|,
literal|15
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|crtc_addr
operator|+
literal|1
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PC98 */
comment|/* set up the first console */
name|current_default
operator|=
operator|&
name|user_default
expr_stmt|;
name|console
index|[
literal|0
index|]
operator|=
operator|&
name|main_console
expr_stmt|;
name|init_scp
argument_list|(
name|console
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|cur_console
operator|=
name|console
index|[
literal|0
index|]
expr_stmt|;
ifndef|#
directive|ifndef
name|PC98
comment|/* discard the video mode table if we are not familiar with it... */
if|if
condition|(
name|video_mode_ptr
condition|)
block|{
name|bzero
argument_list|(
name|mode_map
argument_list|,
sizeof|sizeof
argument_list|(
name|mode_map
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|video_mode_ptr
operator|+
name|MODE_PARAM_SIZE
operator|*
name|console
index|[
literal|0
index|]
operator|->
name|mode
argument_list|,
name|vgaregs2
argument_list|,
sizeof|sizeof
argument_list|(
name|vgaregs2
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|comp_vgaregs
argument_list|(
name|vgaregs
argument_list|,
name|video_mode_ptr
operator|+
name|MODE_PARAM_SIZE
operator|*
name|console
index|[
literal|0
index|]
operator|->
name|mode
argument_list|)
condition|)
block|{
case|case
name|COMP_IDENTICAL
case|:
name|map_mode_table
argument_list|(
name|mode_map
argument_list|,
name|video_mode_ptr
argument_list|,
name|M_VGA_CG320
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/*               * This is a kludge for Toshiba DynaBook SS433 whose BIOS video              * mode table entry has the actual # of rows at the offset 1;  	     * BIOSes from other manufacturers store the # of rows - 1 there.  	     * XXX              */
name|rows_offset
operator|=
name|vgaregs
index|[
literal|1
index|]
operator|+
literal|1
operator|-
name|video_mode_ptr
index|[
name|MODE_PARAM_SIZE
operator|*
name|console
index|[
literal|0
index|]
operator|->
name|mode
operator|+
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|COMP_SIMILAR
case|:
name|map_mode_table
argument_list|(
name|mode_map
argument_list|,
name|video_mode_ptr
argument_list|,
name|M_VGA_CG320
operator|+
literal|1
argument_list|)
expr_stmt|;
name|mode_map
index|[
name|console
index|[
literal|0
index|]
operator|->
name|mode
index|]
operator|=
name|vgaregs
expr_stmt|;
name|rows_offset
operator|=
name|vgaregs
index|[
literal|1
index|]
operator|+
literal|1
operator|-
name|video_mode_ptr
index|[
name|MODE_PARAM_SIZE
operator|*
name|console
index|[
literal|0
index|]
operator|->
name|mode
operator|+
literal|1
index|]
expr_stmt|;
name|vgaregs
index|[
literal|1
index|]
operator|-=
name|rows_offset
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|COMP_DIFFERENT
case|:
default|default:
name|video_mode_ptr
operator|=
name|NULL
expr_stmt|;
name|mode_map
index|[
name|console
index|[
literal|0
index|]
operator|->
name|mode
index|]
operator|=
name|vgaregs
expr_stmt|;
name|rows_offset
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
endif|#
directive|endif
comment|/* copy screen to temporary buffer */
name|sc_bcopy
argument_list|(
name|Crtat
argument_list|,
name|sc_buffer
argument_list|,
name|console
index|[
literal|0
index|]
operator|->
name|xsize
operator|*
name|console
index|[
literal|0
index|]
operator|->
name|ysize
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|console
index|[
literal|0
index|]
operator|->
name|scr_buf
operator|=
name|console
index|[
literal|0
index|]
operator|->
name|mouse_pos
operator|=
name|sc_buffer
expr_stmt|;
name|console
index|[
literal|0
index|]
operator|->
name|cursor_pos
operator|=
name|console
index|[
literal|0
index|]
operator|->
name|cursor_oldpos
operator|=
name|sc_buffer
operator|+
name|hw_cursor
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|console
index|[
literal|0
index|]
operator|->
name|atr_buf
operator|=
name|Atrat
expr_stmt|;
name|console
index|[
literal|0
index|]
operator|->
name|cursor_atr
operator|=
name|Atrat
operator|+
name|hw_cursor
expr_stmt|;
else|#
directive|else
name|console
index|[
literal|0
index|]
operator|->
name|cursor_saveunder
operator|=
operator|*
name|console
index|[
literal|0
index|]
operator|->
name|cursor_pos
expr_stmt|;
endif|#
directive|endif
name|console
index|[
literal|0
index|]
operator|->
name|xpos
operator|=
name|hw_cursor
operator|%
name|COL
expr_stmt|;
name|console
index|[
literal|0
index|]
operator|->
name|ypos
operator|=
name|hw_cursor
operator|/
name|COL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|MAXCONS
condition|;
name|i
operator|++
control|)
name|console
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|kernel_console
operator|.
name|esc
operator|=
literal|0
expr_stmt|;
name|kernel_console
operator|.
name|attr_mask
operator|=
name|NORMAL_ATTR
expr_stmt|;
name|kernel_console
operator|.
name|cur_attr
operator|=
name|kernel_console
operator|.
name|cur_color
operator|=
name|kernel_console
operator|.
name|std_color
operator|=
name|kernel_default
operator|.
name|std_color
expr_stmt|;
name|kernel_console
operator|.
name|rev_color
operator|=
name|kernel_default
operator|.
name|rev_color
expr_stmt|;
comment|/* initialize mapscrn arrays to a one to one map */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|scr_map
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|scr_map
index|[
name|i
index|]
operator|=
name|scr_rmap
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PC98
name|scr_map
index|[
literal|0x5c
index|]
operator|=
operator|(
name|u_char
operator|)
literal|0xfc
expr_stmt|;
comment|/* for backslash */
endif|#
directive|endif
block|}
specifier|static
name|void
name|map_mode_table
parameter_list|(
name|char
modifier|*
name|map
index|[]
parameter_list|,
name|char
modifier|*
name|table
parameter_list|,
name|int
name|max
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max
condition|;
operator|++
name|i
control|)
name|map
index|[
name|i
index|]
operator|=
name|table
operator|+
name|i
operator|*
name|MODE_PARAM_SIZE
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|MODE_MAP_SIZE
condition|;
operator|++
name|i
control|)
name|map
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
specifier|static
name|u_char
name|map_mode_num
parameter_list|(
name|u_char
name|mode
parameter_list|)
block|{
specifier|static
struct|struct
block|{
name|u_char
name|from
decl_stmt|;
name|u_char
name|to
decl_stmt|;
block|}
name|mode_map
index|[]
init|=
block|{
block|{
name|M_ENH_B80x43
block|,
name|M_ENH_B80x25
block|}
block|,
block|{
name|M_ENH_C80x43
block|,
name|M_ENH_C80x25
block|}
block|,
block|{
name|M_VGA_M80x30
block|,
name|M_VGA_M80x25
block|}
block|,
block|{
name|M_VGA_C80x30
block|,
name|M_VGA_C80x25
block|}
block|,
block|{
name|M_VGA_M80x50
block|,
name|M_VGA_M80x25
block|}
block|,
block|{
name|M_VGA_C80x50
block|,
name|M_VGA_C80x25
block|}
block|,
block|{
name|M_VGA_M80x60
block|,
name|M_VGA_M80x25
block|}
block|,
block|{
name|M_VGA_C80x60
block|,
name|M_VGA_C80x25
block|}
block|,
block|{
name|M_VGA_MODEX
block|,
name|M_VGA_CG320
block|}
block|,     }
struct|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|mode_map
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|mode_map
index|[
literal|0
index|]
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|mode_map
index|[
name|i
index|]
operator|.
name|from
operator|==
name|mode
condition|)
return|return
name|mode_map
index|[
name|i
index|]
operator|.
name|to
return|;
block|}
return|return
name|mode
return|;
block|}
specifier|static
name|char
modifier|*
name|get_mode_param
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|u_char
name|mode
parameter_list|)
block|{
if|if
condition|(
name|mode
operator|>=
name|MODE_MAP_SIZE
condition|)
name|mode
operator|=
name|map_mode_num
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|<
name|MODE_MAP_SIZE
condition|)
return|return
name|mode_map
index|[
name|mode
index|]
return|;
else|else
return|return
name|NULL
return|;
block|}
specifier|static
name|scr_stat
modifier|*
name|alloc_scp
parameter_list|()
block|{
name|scr_stat
modifier|*
name|scp
decl_stmt|;
name|scp
operator|=
operator|(
name|scr_stat
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|scr_stat
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|init_scp
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|scp
operator|->
name|scr_buf
operator|=
name|scp
operator|->
name|cursor_pos
operator|=
name|scp
operator|->
name|cursor_oldpos
operator|=
operator|(
name|u_short
operator|*
operator|)
name|malloc
argument_list|(
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|scp
operator|->
name|mouse_pos
operator|=
name|scp
operator|->
name|mouse_oldpos
operator|=
name|scp
operator|->
name|scr_buf
operator|+
operator|(
operator|(
name|scp
operator|->
name|mouse_ypos
operator|/
name|scp
operator|->
name|font_size
operator|)
operator|*
name|scp
operator|->
name|xsize
operator|+
name|scp
operator|->
name|mouse_xpos
operator|/
literal|8
operator|)
expr_stmt|;
name|scp
operator|->
name|history_head
operator|=
name|scp
operator|->
name|history_pos
operator|=
operator|(
name|u_short
operator|*
operator|)
name|malloc
argument_list|(
name|scp
operator|->
name|history_size
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|scp
operator|->
name|history_head
argument_list|,
name|scp
operator|->
name|history_size
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|scp
operator|->
name|history
operator|=
name|scp
operator|->
name|history_head
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|scp
operator|->
name|atr_buf
operator|=
name|scp
operator|->
name|cursor_atr
operator|=
name|scp
operator|->
name|atr_buf
operator|=
operator|(
name|u_short
operator|*
operator|)
name|malloc
argument_list|(
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|scp
operator|->
name|his_atr_head
operator|=
name|scp
operator|->
name|his_atr_pos
operator|=
operator|(
name|u_short
operator|*
operator|)
name|malloc
argument_list|(
name|scp
operator|->
name|history_size
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|scp
operator|->
name|his_atr_head
argument_list|,
name|scp
operator|->
name|history_size
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|scp
operator|->
name|his_atr
operator|=
name|scp
operator|->
name|his_atr_head
expr_stmt|;
endif|#
directive|endif
comment|/* SOS #ifndef PC98     if (crtc_vga&& video_mode_ptr) #endif 	set_mode(scp); */
name|clear_screen
argument_list|(
name|scp
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|PC98
name|scp
operator|->
name|cursor_saveunder
operator|=
operator|*
name|scp
operator|->
name|cursor_pos
expr_stmt|;
endif|#
directive|endif
return|return
name|scp
return|;
block|}
specifier|static
name|void
name|init_scp
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|PC98
name|scp
operator|->
name|mode
operator|=
name|M_PC98_80x25
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|crtc_vga
condition|)
if|if
condition|(
name|crtc_addr
operator|==
name|MONO_BASE
condition|)
name|scp
operator|->
name|mode
operator|=
name|M_VGA_M80x25
expr_stmt|;
else|else
name|scp
operator|->
name|mode
operator|=
name|M_VGA_C80x25
expr_stmt|;
elseif|else
if|if
condition|(
name|crtc_addr
operator|==
name|MONO_BASE
condition|)
name|scp
operator|->
name|mode
operator|=
name|M_B80x25
expr_stmt|;
else|else
name|scp
operator|->
name|mode
operator|=
name|M_C80x25
expr_stmt|;
name|scp
operator|->
name|initial_mode
operator|=
name|scp
operator|->
name|mode
expr_stmt|;
endif|#
directive|endif
name|scp
operator|->
name|font_size
operator|=
literal|16
expr_stmt|;
name|scp
operator|->
name|xsize
operator|=
name|COL
expr_stmt|;
name|scp
operator|->
name|ysize
operator|=
name|ROW
expr_stmt|;
name|scp
operator|->
name|xpos
operator|=
name|scp
operator|->
name|ypos
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|saved_xpos
operator|=
name|scp
operator|->
name|saved_ypos
operator|=
operator|-
literal|1
expr_stmt|;
name|scp
operator|->
name|start
operator|=
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
expr_stmt|;
name|scp
operator|->
name|end
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|esc
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|attr_mask
operator|=
name|NORMAL_ATTR
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|scp
operator|->
name|term
operator|.
name|cur_color
operator|=
name|scp
operator|->
name|term
operator|.
name|std_color
operator|=
name|current_default
operator|->
name|std_color
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|rev_color
operator|=
name|current_default
operator|->
name|rev_color
expr_stmt|;
name|scp
operator|->
name|border
operator|=
name|BG_BLACK
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|scp
operator|->
name|cursor_start
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|cursor_end
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|scp
operator|->
name|cursor_start
operator|=
operator|*
operator|(
name|char
operator|*
operator|)
name|pa_to_va
argument_list|(
literal|0x461
argument_list|)
expr_stmt|;
name|scp
operator|->
name|cursor_end
operator|=
operator|*
operator|(
name|char
operator|*
operator|)
name|pa_to_va
argument_list|(
literal|0x460
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|scp
operator|->
name|mouse_xpos
operator|=
name|scp
operator|->
name|xsize
operator|*
literal|8
operator|/
literal|2
expr_stmt|;
name|scp
operator|->
name|mouse_ypos
operator|=
name|scp
operator|->
name|ysize
operator|*
name|scp
operator|->
name|font_size
operator|/
literal|2
expr_stmt|;
name|scp
operator|->
name|mouse_cut_start
operator|=
name|scp
operator|->
name|mouse_cut_end
operator|=
name|NULL
expr_stmt|;
name|scp
operator|->
name|mouse_signal
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|mouse_pid
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|mouse_proc
operator|=
name|NULL
expr_stmt|;
name|scp
operator|->
name|bell_pitch
operator|=
name|BELL_PITCH
expr_stmt|;
name|scp
operator|->
name|bell_duration
operator|=
name|BELL_DURATION
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|scp
operator|->
name|status
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|status
operator||=
name|CURSOR_ENABLED
expr_stmt|;
else|#
directive|else
name|scp
operator|->
name|status
operator|=
operator|(
operator|*
operator|(
name|char
operator|*
operator|)
name|pa_to_va
argument_list|(
literal|0x417
argument_list|)
operator|&
literal|0x20
operator|)
condition|?
name|NLKED
else|:
literal|0
expr_stmt|;
name|scp
operator|->
name|status
operator||=
name|CURSOR_ENABLED
expr_stmt|;
endif|#
directive|endif
name|scp
operator|->
name|pid
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|proc
operator|=
name|NULL
expr_stmt|;
name|scp
operator|->
name|smode
operator|.
name|mode
operator|=
name|VT_AUTO
expr_stmt|;
name|scp
operator|->
name|history_head
operator|=
name|scp
operator|->
name|history_pos
operator|=
name|scp
operator|->
name|history
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|scp
operator|->
name|his_atr_head
operator|=
name|scp
operator|->
name|his_atr_pos
operator|=
name|scp
operator|->
name|his_atr
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
name|scp
operator|->
name|history_size
operator|=
name|imax
argument_list|(
name|SC_HISTORY_SIZE
argument_list|,
name|scp
operator|->
name|ysize
argument_list|)
operator|*
name|scp
operator|->
name|xsize
expr_stmt|;
ifdef|#
directive|ifdef
name|KANJI
name|scp
operator|->
name|kanji_1st_char
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|kanji_type
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
specifier|static
name|u_char
modifier|*
name|get_fstr
parameter_list|(
name|u_int
name|c
parameter_list|,
name|u_int
modifier|*
name|len
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|c
operator|&
name|FKEY
operator|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|i
operator|=
operator|(
name|c
operator|&
literal|0xFF
operator|)
operator|-
name|F_FN
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|n_fkey_tab
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
operator|*
name|len
operator|=
name|fkey_tab
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
return|return
operator|(
name|fkey_tab
index|[
name|i
index|]
operator|.
name|str
operator|)
return|;
block|}
specifier|static
name|void
name|history_to_screen
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|scp
operator|->
name|ysize
condition|;
name|i
operator|++
control|)
ifdef|#
directive|ifdef
name|PC98
block|{
endif|#
directive|endif
name|bcopy
argument_list|(
name|scp
operator|->
name|history
operator|+
operator|(
operator|(
operator|(
name|scp
operator|->
name|history_pos
operator|-
name|scp
operator|->
name|history
operator|)
operator|+
name|scp
operator|->
name|history_size
operator|-
operator|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|*
name|scp
operator|->
name|xsize
operator|)
operator|)
operator|%
name|scp
operator|->
name|history_size
operator|)
argument_list|,
name|scp
operator|->
name|scr_buf
operator|+
operator|(
name|scp
operator|->
name|xsize
operator|*
operator|(
name|scp
operator|->
name|ysize
operator|-
literal|1
operator|-
name|i
operator|)
operator|)
argument_list|,
name|scp
operator|->
name|xsize
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|bcopy
argument_list|(
name|scp
operator|->
name|his_atr
operator|+
operator|(
operator|(
operator|(
name|scp
operator|->
name|his_atr_pos
operator|-
name|scp
operator|->
name|his_atr
operator|)
operator|+
name|scp
operator|->
name|history_size
operator|-
operator|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|*
name|scp
operator|->
name|xsize
operator|)
operator|)
operator|%
name|scp
operator|->
name|history_size
operator|)
argument_list|,
name|scp
operator|->
name|atr_buf
operator|+
operator|(
name|scp
operator|->
name|xsize
operator|*
operator|(
name|scp
operator|->
name|ysize
operator|-
literal|1
operator|-
name|i
operator|)
operator|)
argument_list|,
name|scp
operator|->
name|xsize
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|mark_all
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
specifier|static
name|int
name|history_up_line
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
if|if
condition|(
name|WRAPHIST
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|history_pos
argument_list|,
operator|-
operator|(
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
operator|)
argument_list|)
operator|!=
name|scp
operator|->
name|history_head
condition|)
block|{
name|scp
operator|->
name|history_pos
operator|=
name|WRAPHIST
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|history_pos
argument_list|,
operator|-
name|scp
operator|->
name|xsize
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|scp
operator|->
name|his_atr_pos
operator|=
name|WRAPHIST_A
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|his_atr_pos
argument_list|,
operator|-
name|scp
operator|->
name|xsize
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|history_to_screen
argument_list|(
name|scp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
return|return
operator|-
literal|1
return|;
block|}
specifier|static
name|int
name|history_down_line
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
if|if
condition|(
name|scp
operator|->
name|history_pos
operator|!=
name|scp
operator|->
name|history_head
condition|)
block|{
name|scp
operator|->
name|history_pos
operator|=
name|WRAPHIST
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|history_pos
argument_list|,
name|scp
operator|->
name|xsize
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|scp
operator|->
name|his_atr_pos
operator|=
name|WRAPHIST_A
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|his_atr_pos
argument_list|,
name|scp
operator|->
name|xsize
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|history_to_screen
argument_list|(
name|scp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
return|return
operator|-
literal|1
return|;
block|}
comment|/*  * scgetc(flags) - get character from keyboard.  * If flags& SCGETC_CN, then avoid harmful side effects.  * If flags& SCGETC_NONBLOCK, then wait until a key is pressed, else  * return NOKEY if there is nothing there.  */
specifier|static
name|u_int
name|scgetc
parameter_list|(
name|u_int
name|flags
parameter_list|)
block|{
name|struct
name|key_t
modifier|*
name|key
decl_stmt|;
name|u_char
name|scancode
decl_stmt|,
name|keycode
decl_stmt|;
name|u_int
name|state
decl_stmt|,
name|action
decl_stmt|;
name|int
name|c
decl_stmt|;
specifier|static
name|u_char
name|esc_flag
init|=
literal|0
decl_stmt|,
name|compose
init|=
literal|0
decl_stmt|;
specifier|static
name|u_int
name|chr
init|=
literal|0
decl_stmt|;
name|next_code
label|:
comment|/* first see if there is something in the keyboard port */
if|if
condition|(
name|flags
operator|&
name|SCGETC_NONBLOCK
condition|)
block|{
name|c
operator|=
name|read_kbd_data_no_wait
argument_list|(
name|sc_kbdc
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|NOKEY
operator|)
return|;
block|}
else|else
block|{
do|do
block|{
name|c
operator|=
name|read_kbd_data
argument_list|(
name|sc_kbdc
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|==
operator|-
literal|1
condition|)
do|;
block|}
name|scancode
operator|=
operator|(
name|u_char
operator|)
name|c
expr_stmt|;
comment|/* do the /dev/random device a favour */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCGETC_CN
operator|)
condition|)
name|add_keyboard_randomness
argument_list|(
name|scancode
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_console
operator|->
name|status
operator|&
name|KBD_RAW_MODE
condition|)
return|return
name|scancode
return|;
name|keycode
operator|=
name|scancode
operator|&
literal|0x7F
expr_stmt|;
switch|switch
condition|(
name|esc_flag
condition|)
block|{
case|case
literal|0x00
case|:
comment|/* normal scancode */
switch|switch
condition|(
name|scancode
condition|)
block|{
case|case
literal|0xB8
case|:
comment|/* left alt (compose key) */
if|if
condition|(
name|compose
condition|)
block|{
name|compose
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|chr
operator|>
literal|255
condition|)
block|{
name|do_bell
argument_list|(
name|cur_console
argument_list|,
name|BELL_PITCH
argument_list|,
name|BELL_DURATION
argument_list|)
expr_stmt|;
name|chr
operator|=
literal|0
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|0x38
case|:
if|if
condition|(
operator|!
name|compose
condition|)
block|{
name|compose
operator|=
literal|1
expr_stmt|;
name|chr
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
literal|0xE0
case|:
case|case
literal|0xE1
case|:
name|esc_flag
operator|=
name|scancode
expr_stmt|;
goto|goto
name|next_code
goto|;
block|}
break|break;
case|case
literal|0xE0
case|:
comment|/* 0xE0 prefix */
name|esc_flag
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|keycode
condition|)
block|{
case|case
literal|0x1C
case|:
comment|/* right enter key */
name|keycode
operator|=
literal|0x59
expr_stmt|;
break|break;
case|case
literal|0x1D
case|:
comment|/* right ctrl key */
name|keycode
operator|=
literal|0x5A
expr_stmt|;
break|break;
case|case
literal|0x35
case|:
comment|/* keypad divide key */
name|keycode
operator|=
literal|0x5B
expr_stmt|;
break|break;
case|case
literal|0x37
case|:
comment|/* print scrn key */
name|keycode
operator|=
literal|0x5C
expr_stmt|;
break|break;
case|case
literal|0x38
case|:
comment|/* right alt key (alt gr) */
name|keycode
operator|=
literal|0x5D
expr_stmt|;
break|break;
case|case
literal|0x47
case|:
comment|/* grey home key */
name|keycode
operator|=
literal|0x5E
expr_stmt|;
break|break;
case|case
literal|0x48
case|:
comment|/* grey up arrow key */
name|keycode
operator|=
literal|0x5F
expr_stmt|;
break|break;
case|case
literal|0x49
case|:
comment|/* grey page up key */
name|keycode
operator|=
literal|0x60
expr_stmt|;
break|break;
case|case
literal|0x4B
case|:
comment|/* grey left arrow key */
name|keycode
operator|=
literal|0x61
expr_stmt|;
break|break;
case|case
literal|0x4D
case|:
comment|/* grey right arrow key */
name|keycode
operator|=
literal|0x62
expr_stmt|;
break|break;
case|case
literal|0x4F
case|:
comment|/* grey end key */
name|keycode
operator|=
literal|0x63
expr_stmt|;
break|break;
case|case
literal|0x50
case|:
comment|/* grey down arrow key */
name|keycode
operator|=
literal|0x64
expr_stmt|;
break|break;
case|case
literal|0x51
case|:
comment|/* grey page down key */
name|keycode
operator|=
literal|0x65
expr_stmt|;
break|break;
case|case
literal|0x52
case|:
comment|/* grey insert key */
name|keycode
operator|=
literal|0x66
expr_stmt|;
break|break;
case|case
literal|0x53
case|:
comment|/* grey delete key */
name|keycode
operator|=
literal|0x67
expr_stmt|;
break|break;
comment|/* the following 3 are only used on the MS "Natural" keyboard */
case|case
literal|0x5b
case|:
comment|/* left Window key */
name|keycode
operator|=
literal|0x69
expr_stmt|;
break|break;
case|case
literal|0x5c
case|:
comment|/* right Window key */
name|keycode
operator|=
literal|0x6a
expr_stmt|;
break|break;
case|case
literal|0x5d
case|:
comment|/* menu key */
name|keycode
operator|=
literal|0x6b
expr_stmt|;
break|break;
default|default:
comment|/* ignore everything else */
goto|goto
name|next_code
goto|;
block|}
break|break;
case|case
literal|0xE1
case|:
comment|/* 0xE1 prefix */
name|esc_flag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|keycode
operator|==
literal|0x1D
condition|)
name|esc_flag
operator|=
literal|0x1D
expr_stmt|;
goto|goto
name|next_code
goto|;
comment|/* NOT REACHED */
case|case
literal|0x1D
case|:
comment|/* pause / break */
name|esc_flag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|keycode
operator|!=
literal|0x45
condition|)
goto|goto
name|next_code
goto|;
name|keycode
operator|=
literal|0x68
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cur_console
operator|->
name|status
operator|&
name|KBD_CODE_MODE
condition|)
return|return
operator|(
name|keycode
operator||
operator|(
name|scancode
operator|&
literal|0x80
operator|)
operator|)
return|;
comment|/* if scroll-lock pressed allow history browsing */
if|if
condition|(
name|cur_console
operator|->
name|history
operator|&&
name|cur_console
operator|->
name|status
operator|&
name|SLKED
condition|)
block|{
name|int
name|i
decl_stmt|;
name|cur_console
operator|->
name|status
operator|&=
operator|~
name|CURSOR_ENABLED
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|cur_console
operator|->
name|status
operator|&
name|BUFFER_SAVED
operator|)
condition|)
block|{
name|cur_console
operator|->
name|status
operator||=
name|BUFFER_SAVED
expr_stmt|;
name|cur_console
operator|->
name|history_save
operator|=
name|cur_console
operator|->
name|history_head
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|cur_console
operator|->
name|his_atr_save
operator|=
name|cur_console
operator|->
name|his_atr_head
expr_stmt|;
endif|#
directive|endif
comment|/* copy screen into top of history buffer */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cur_console
operator|->
name|ysize
condition|;
name|i
operator|++
control|)
block|{
name|bcopy
argument_list|(
name|cur_console
operator|->
name|scr_buf
operator|+
operator|(
name|cur_console
operator|->
name|xsize
operator|*
name|i
operator|)
argument_list|,
name|cur_console
operator|->
name|history_head
argument_list|,
name|cur_console
operator|->
name|xsize
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|cur_console
operator|->
name|history_head
operator|+=
name|cur_console
operator|->
name|xsize
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|bcopy
argument_list|(
name|cur_console
operator|->
name|atr_buf
operator|+
operator|(
name|cur_console
operator|->
name|xsize
operator|*
name|i
operator|)
argument_list|,
name|cur_console
operator|->
name|his_atr_head
argument_list|,
name|cur_console
operator|->
name|xsize
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|cur_console
operator|->
name|his_atr_head
operator|+=
name|cur_console
operator|->
name|xsize
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|cur_console
operator|->
name|history_head
operator|+
name|cur_console
operator|->
name|xsize
operator|>
name|cur_console
operator|->
name|history
operator|+
name|cur_console
operator|->
name|history_size
condition|)
ifdef|#
directive|ifdef
name|PC98
block|{
endif|#
directive|endif
name|cur_console
operator|->
name|history_head
operator|=
name|cur_console
operator|->
name|history
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|cur_console
operator|->
name|his_atr_head
operator|=
name|cur_console
operator|->
name|his_atr
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|cur_console
operator|->
name|history_pos
operator|=
name|cur_console
operator|->
name|history_head
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|cur_console
operator|->
name|his_atr_pos
operator|=
name|cur_console
operator|->
name|his_atr_head
expr_stmt|;
endif|#
directive|endif
name|history_to_screen
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|scancode
condition|)
block|{
ifdef|#
directive|ifdef
name|PC98
case|case
literal|0x3E
case|:
comment|/* home key */
else|#
directive|else
case|case
literal|0x47
case|:
comment|/* home key */
endif|#
directive|endif
name|cur_console
operator|->
name|history_pos
operator|=
name|cur_console
operator|->
name|history_head
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|cur_console
operator|->
name|his_atr_pos
operator|=
name|cur_console
operator|->
name|his_atr_head
expr_stmt|;
endif|#
directive|endif
name|history_to_screen
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
goto|goto
name|next_code
goto|;
ifdef|#
directive|ifdef
name|PC98
case|case
literal|0x3F
case|:
comment|/* help key */
else|#
directive|else
case|case
literal|0x4F
case|:
comment|/* end key */
endif|#
directive|endif
name|cur_console
operator|->
name|history_pos
operator|=
name|WRAPHIST
argument_list|(
name|cur_console
argument_list|,
name|cur_console
operator|->
name|history_head
argument_list|,
name|cur_console
operator|->
name|xsize
operator|*
name|cur_console
operator|->
name|ysize
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|cur_console
operator|->
name|his_atr_pos
operator|=
name|WRAPHIST_A
argument_list|(
name|cur_console
argument_list|,
name|cur_console
operator|->
name|his_atr_head
argument_list|,
name|cur_console
operator|->
name|xsize
operator|*
name|cur_console
operator|->
name|ysize
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|history_to_screen
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
goto|goto
name|next_code
goto|;
ifdef|#
directive|ifdef
name|PC98
case|case
literal|0x3A
case|:
comment|/* up arrow key */
else|#
directive|else
case|case
literal|0x48
case|:
comment|/* up arrow key */
endif|#
directive|endif
if|if
condition|(
name|history_up_line
argument_list|(
name|cur_console
argument_list|)
condition|)
name|do_bell
argument_list|(
name|cur_console
argument_list|,
name|BELL_PITCH
argument_list|,
name|BELL_DURATION
argument_list|)
expr_stmt|;
goto|goto
name|next_code
goto|;
ifdef|#
directive|ifdef
name|PC98
case|case
literal|0x3D
case|:
comment|/* down arrow key */
else|#
directive|else
case|case
literal|0x50
case|:
comment|/* down arrow key */
endif|#
directive|endif
if|if
condition|(
name|history_down_line
argument_list|(
name|cur_console
argument_list|)
condition|)
name|do_bell
argument_list|(
name|cur_console
argument_list|,
name|BELL_PITCH
argument_list|,
name|BELL_DURATION
argument_list|)
expr_stmt|;
goto|goto
name|next_code
goto|;
ifdef|#
directive|ifdef
name|PC98
case|case
literal|0x36
case|:
comment|/* roll up key */
else|#
directive|else
case|case
literal|0x49
case|:
comment|/* page up key */
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cur_console
operator|->
name|ysize
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|history_up_line
argument_list|(
name|cur_console
argument_list|)
condition|)
block|{
name|do_bell
argument_list|(
name|cur_console
argument_list|,
name|BELL_PITCH
argument_list|,
name|BELL_DURATION
argument_list|)
expr_stmt|;
break|break;
block|}
goto|goto
name|next_code
goto|;
ifdef|#
directive|ifdef
name|PC98
case|case
literal|0x37
case|:
comment|/* roll down key */
else|#
directive|else
case|case
literal|0x51
case|:
comment|/* page down key */
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cur_console
operator|->
name|ysize
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|history_down_line
argument_list|(
name|cur_console
argument_list|)
condition|)
block|{
name|do_bell
argument_list|(
name|cur_console
argument_list|,
name|BELL_PITCH
argument_list|,
name|BELL_DURATION
argument_list|)
expr_stmt|;
break|break;
block|}
goto|goto
name|next_code
goto|;
block|}
block|}
if|if
condition|(
name|compose
condition|)
block|{
switch|switch
condition|(
name|scancode
condition|)
block|{
comment|/* key pressed process it */
case|case
literal|0x47
case|:
case|case
literal|0x48
case|:
case|case
literal|0x49
case|:
comment|/* keypad 7,8,9 */
name|chr
operator|=
operator|(
name|scancode
operator|-
literal|0x40
operator|)
operator|+
name|chr
operator|*
literal|10
expr_stmt|;
goto|goto
name|next_code
goto|;
case|case
literal|0x4B
case|:
case|case
literal|0x4C
case|:
case|case
literal|0x4D
case|:
comment|/* keypad 4,5,6 */
name|chr
operator|=
operator|(
name|scancode
operator|-
literal|0x47
operator|)
operator|+
name|chr
operator|*
literal|10
expr_stmt|;
goto|goto
name|next_code
goto|;
case|case
literal|0x4F
case|:
case|case
literal|0x50
case|:
case|case
literal|0x51
case|:
comment|/* keypad 1,2,3 */
name|chr
operator|=
operator|(
name|scancode
operator|-
literal|0x4E
operator|)
operator|+
name|chr
operator|*
literal|10
expr_stmt|;
goto|goto
name|next_code
goto|;
case|case
literal|0x52
case|:
comment|/* keypad 0 */
name|chr
operator|*=
literal|10
expr_stmt|;
goto|goto
name|next_code
goto|;
comment|/* key release, no interest here */
case|case
literal|0xC7
case|:
case|case
literal|0xC8
case|:
case|case
literal|0xC9
case|:
comment|/* keypad 7,8,9 */
case|case
literal|0xCB
case|:
case|case
literal|0xCC
case|:
case|case
literal|0xCD
case|:
comment|/* keypad 4,5,6 */
case|case
literal|0xCF
case|:
case|case
literal|0xD0
case|:
case|case
literal|0xD1
case|:
comment|/* keypad 1,2,3 */
case|case
literal|0xD2
case|:
comment|/* keypad 0 */
goto|goto
name|next_code
goto|;
case|case
literal|0x38
case|:
comment|/* left alt key */
break|break;
default|default:
if|if
condition|(
name|chr
condition|)
block|{
name|compose
operator|=
name|chr
operator|=
literal|0
expr_stmt|;
name|do_bell
argument_list|(
name|cur_console
argument_list|,
name|BELL_PITCH
argument_list|,
name|BELL_DURATION
argument_list|)
expr_stmt|;
goto|goto
name|next_code
goto|;
block|}
break|break;
block|}
block|}
name|state
operator|=
operator|(
name|shfts
condition|?
literal|1
else|:
literal|0
operator|)
operator||
operator|(
literal|2
operator|*
operator|(
name|ctls
condition|?
literal|1
else|:
literal|0
operator|)
operator|)
operator||
operator|(
literal|4
operator|*
operator|(
name|alts
condition|?
literal|1
else|:
literal|0
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|agrs
operator|&&
operator|(
name|cur_console
operator|->
name|status
operator|&
name|ALKED
operator|)
operator|)
operator|||
operator|(
name|agrs
operator|&&
operator|!
operator|(
name|cur_console
operator|->
name|status
operator|&
name|ALKED
operator|)
operator|)
condition|)
name|keycode
operator|+=
name|ALTGR_OFFSET
expr_stmt|;
name|key
operator|=
operator|&
name|key_map
operator|.
name|key
index|[
name|keycode
index|]
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|key
operator|->
name|flgs
operator|&
name|FLAG_LOCK_C
operator|)
operator|&&
operator|(
name|cur_console
operator|->
name|status
operator|&
name|CLKED
operator|)
operator|)
operator|||
operator|(
operator|(
name|key
operator|->
name|flgs
operator|&
name|FLAG_LOCK_N
operator|)
operator|&&
operator|(
name|cur_console
operator|->
name|status
operator|&
name|NLKED
operator|)
operator|)
condition|)
name|state
operator|^=
literal|1
expr_stmt|;
comment|/* Check for make/break */
name|action
operator|=
name|key
operator|->
name|map
index|[
name|state
index|]
expr_stmt|;
if|if
condition|(
name|scancode
operator|&
literal|0x80
condition|)
block|{
comment|/* key released */
if|if
condition|(
name|key
operator|->
name|spcl
operator|&
operator|(
literal|0x80
operator|>>
name|state
operator|)
condition|)
block|{
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|LSH
case|:
name|shfts
operator|&=
operator|~
literal|1
expr_stmt|;
break|break;
case|case
name|RSH
case|:
name|shfts
operator|&=
operator|~
literal|2
expr_stmt|;
break|break;
case|case
name|LCTR
case|:
name|ctls
operator|&=
operator|~
literal|1
expr_stmt|;
break|break;
case|case
name|RCTR
case|:
name|ctls
operator|&=
operator|~
literal|2
expr_stmt|;
break|break;
case|case
name|LALT
case|:
name|alts
operator|&=
operator|~
literal|1
expr_stmt|;
break|break;
case|case
name|RALT
case|:
name|alts
operator|&=
operator|~
literal|2
expr_stmt|;
break|break;
case|case
name|NLK
case|:
name|nlkcnt
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|CLK
case|:
ifdef|#
directive|ifdef
name|PC98
name|cur_console
operator|->
name|status
operator|&=
operator|~
name|CLKED
expr_stmt|;
name|update_leds
argument_list|(
name|cur_console
operator|->
name|status
argument_list|)
expr_stmt|;
else|#
directive|else
name|clkcnt
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|SLK
case|:
name|slkcnt
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ASH
case|:
name|agrs
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ALK
case|:
name|alkcnt
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|META
case|:
name|metas
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|chr
operator|&&
operator|!
name|compose
condition|)
block|{
name|action
operator|=
name|chr
expr_stmt|;
name|chr
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|action
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* key pressed */
if|if
condition|(
name|key
operator|->
name|spcl
operator|&
operator|(
literal|0x80
operator|>>
name|state
operator|)
condition|)
block|{
switch|switch
condition|(
name|action
condition|)
block|{
comment|/* LOCKING KEYS */
case|case
name|NLK
case|:
ifdef|#
directive|ifdef
name|SC_SPLASH_SCREEN
name|toggle_splash_screen
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
comment|/* SOS XXX */
endif|#
directive|endif
if|if
condition|(
operator|!
name|nlkcnt
condition|)
block|{
name|nlkcnt
operator|++
expr_stmt|;
if|if
condition|(
name|cur_console
operator|->
name|status
operator|&
name|NLKED
condition|)
name|cur_console
operator|->
name|status
operator|&=
operator|~
name|NLKED
expr_stmt|;
else|else
name|cur_console
operator|->
name|status
operator||=
name|NLKED
expr_stmt|;
name|update_leds
argument_list|(
name|cur_console
operator|->
name|status
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CLK
case|:
ifdef|#
directive|ifdef
name|PC98
name|cur_console
operator|->
name|status
operator||=
name|CLKED
expr_stmt|;
name|update_leds
argument_list|(
name|cur_console
operator|->
name|status
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|!
name|clkcnt
condition|)
block|{
name|clkcnt
operator|++
expr_stmt|;
if|if
condition|(
name|cur_console
operator|->
name|status
operator|&
name|CLKED
condition|)
name|cur_console
operator|->
name|status
operator|&=
operator|~
name|CLKED
expr_stmt|;
else|else
name|cur_console
operator|->
name|status
operator||=
name|CLKED
expr_stmt|;
name|update_leds
argument_list|(
name|cur_console
operator|->
name|status
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
case|case
name|SLK
case|:
if|if
condition|(
operator|!
name|slkcnt
condition|)
block|{
name|slkcnt
operator|++
expr_stmt|;
if|if
condition|(
name|cur_console
operator|->
name|status
operator|&
name|SLKED
condition|)
block|{
name|cur_console
operator|->
name|status
operator|&=
operator|~
name|SLKED
expr_stmt|;
if|if
condition|(
name|cur_console
operator|->
name|status
operator|&
name|BUFFER_SAVED
condition|)
block|{
name|int
name|i
decl_stmt|;
name|u_short
modifier|*
name|ptr
init|=
name|cur_console
operator|->
name|history_save
decl_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|u_short
modifier|*
name|ptr_a
init|=
name|cur_console
operator|->
name|his_atr_save
decl_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cur_console
operator|->
name|ysize
condition|;
name|i
operator|++
control|)
block|{
name|bcopy
argument_list|(
name|ptr
argument_list|,
name|cur_console
operator|->
name|scr_buf
operator|+
operator|(
name|cur_console
operator|->
name|xsize
operator|*
name|i
operator|)
argument_list|,
name|cur_console
operator|->
name|xsize
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|ptr
operator|+=
name|cur_console
operator|->
name|xsize
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|bcopy
argument_list|(
name|ptr_a
argument_list|,
name|cur_console
operator|->
name|atr_buf
operator|+
operator|(
name|cur_console
operator|->
name|xsize
operator|*
name|i
operator|)
argument_list|,
name|cur_console
operator|->
name|xsize
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|ptr_a
operator|+=
name|cur_console
operator|->
name|xsize
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ptr
operator|+
name|cur_console
operator|->
name|xsize
operator|>
name|cur_console
operator|->
name|history
operator|+
name|cur_console
operator|->
name|history_size
condition|)
ifdef|#
directive|ifdef
name|PC98
block|{
endif|#
directive|endif
name|ptr
operator|=
name|cur_console
operator|->
name|history
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|ptr_a
operator|=
name|cur_console
operator|->
name|his_atr
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|cur_console
operator|->
name|status
operator|&=
operator|~
name|BUFFER_SAVED
expr_stmt|;
name|cur_console
operator|->
name|history_head
operator|=
name|cur_console
operator|->
name|history_save
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|cur_console
operator|->
name|his_atr_head
operator|=
name|cur_console
operator|->
name|his_atr_save
expr_stmt|;
endif|#
directive|endif
name|cur_console
operator|->
name|status
operator||=
name|CURSOR_ENABLED
expr_stmt|;
name|mark_all
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
block|}
name|scstart
argument_list|(
name|VIRTUAL_TTY
argument_list|(
name|get_scr_num
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|cur_console
operator|->
name|status
operator||=
name|SLKED
expr_stmt|;
name|update_leds
argument_list|(
name|cur_console
operator|->
name|status
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ALK
case|:
if|if
condition|(
operator|!
name|alkcnt
condition|)
block|{
name|alkcnt
operator|++
expr_stmt|;
if|if
condition|(
name|cur_console
operator|->
name|status
operator|&
name|ALKED
condition|)
name|cur_console
operator|->
name|status
operator|&=
operator|~
name|ALKED
expr_stmt|;
else|else
name|cur_console
operator|->
name|status
operator||=
name|ALKED
expr_stmt|;
name|update_leds
argument_list|(
name|cur_console
operator|->
name|status
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* NON-LOCKING KEYS */
case|case
name|NOP
case|:
break|break;
case|case
name|SPSC
case|:
ifdef|#
directive|ifdef
name|SC_SPLASH_SCREEN
name|accents
operator|=
literal|0
expr_stmt|;
name|toggle_splash_screen
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|RBT
case|:
name|accents
operator|=
literal|0
expr_stmt|;
name|shutdown_nice
argument_list|()
expr_stmt|;
break|break;
case|case
name|SUSP
case|:
if|#
directive|if
name|NAPM
operator|>
literal|0
name|accents
operator|=
literal|0
expr_stmt|;
name|apm_suspend
argument_list|()
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|DBG
case|:
ifdef|#
directive|ifdef
name|DDB
comment|/* try to switch to console 0 */
name|accents
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cur_console
operator|->
name|smode
operator|.
name|mode
operator|==
name|VT_AUTO
operator|&&
name|console
index|[
literal|0
index|]
operator|->
name|smode
operator|.
name|mode
operator|==
name|VT_AUTO
condition|)
name|switch_scr
argument_list|(
name|cur_console
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Debugger
argument_list|(
literal|"manual escape to debugger"
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"No debugger in kernel\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|LSH
case|:
name|shfts
operator||=
literal|1
expr_stmt|;
break|break;
case|case
name|RSH
case|:
name|shfts
operator||=
literal|2
expr_stmt|;
break|break;
case|case
name|LCTR
case|:
name|ctls
operator||=
literal|1
expr_stmt|;
break|break;
case|case
name|RCTR
case|:
name|ctls
operator||=
literal|2
expr_stmt|;
break|break;
case|case
name|LALT
case|:
name|alts
operator||=
literal|1
expr_stmt|;
break|break;
case|case
name|RALT
case|:
name|alts
operator||=
literal|2
expr_stmt|;
break|break;
case|case
name|ASH
case|:
name|agrs
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|META
case|:
name|metas
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|NEXT
case|:
block|{
name|int
name|next
decl_stmt|,
name|this
init|=
name|get_scr_num
argument_list|()
decl_stmt|;
name|accents
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|next
operator|=
name|this
operator|+
literal|1
init|;
name|next
operator|!=
name|this
condition|;
name|next
operator|=
operator|(
name|next
operator|+
literal|1
operator|)
operator|%
name|MAXCONS
control|)
block|{
name|struct
name|tty
modifier|*
name|tp
init|=
name|VIRTUAL_TTY
argument_list|(
name|next
argument_list|)
decl_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
condition|)
block|{
name|switch_scr
argument_list|(
name|cur_console
argument_list|,
name|next
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
break|break;
case|case
name|BTAB
case|:
name|accents
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|BKEY
operator|)
return|;
default|default:
if|if
condition|(
name|action
operator|>=
name|F_ACC
operator|&&
name|action
operator|<=
name|L_ACC
condition|)
block|{
comment|/* turn it into an index */
name|action
operator|-=
name|F_ACC
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|action
operator|>
name|accent_map
operator|.
name|n_accs
operator|)
operator|||
operator|(
name|accent_map
operator|.
name|acc
index|[
name|action
operator|-
literal|1
index|]
operator|.
name|accchar
operator|==
literal|0
operator|)
condition|)
block|{
comment|/*  			 * The index is out of range or pointing to an  			 * empty entry. 			 */
name|accents
operator|=
literal|0
expr_stmt|;
name|do_bell
argument_list|(
name|cur_console
argument_list|,
name|BELL_PITCH
argument_list|,
name|BELL_DURATION
argument_list|)
expr_stmt|;
block|}
comment|/*  		     * If the same accent key has been hit twice, 		     * produce the accent char itself. 		     */
if|if
condition|(
name|action
operator|==
name|accents
condition|)
block|{
name|action
operator|=
name|accent_map
operator|.
name|acc
index|[
name|accents
operator|-
literal|1
index|]
operator|.
name|accchar
expr_stmt|;
name|accents
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|metas
condition|)
name|action
operator||=
name|MKEY
expr_stmt|;
return|return
operator|(
name|action
operator|)
return|;
block|}
comment|/* remember the index and wait for the next key stroke */
name|accents
operator|=
name|action
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|accents
operator|>
literal|0
condition|)
block|{
name|accents
operator|=
literal|0
expr_stmt|;
name|do_bell
argument_list|(
name|cur_console
argument_list|,
name|BELL_PITCH
argument_list|,
name|BELL_DURATION
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|action
operator|>=
name|F_SCR
operator|&&
name|action
operator|<=
name|L_SCR
condition|)
block|{
name|switch_scr
argument_list|(
name|cur_console
argument_list|,
name|action
operator|-
name|F_SCR
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|action
operator|>=
name|F_FN
operator|&&
name|action
operator|<=
name|L_FN
condition|)
name|action
operator||=
name|FKEY
expr_stmt|;
return|return
operator|(
name|action
operator|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|accents
condition|)
block|{
name|struct
name|acc_t
modifier|*
name|acc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|acc
operator|=
operator|&
name|accent_map
operator|.
name|acc
index|[
name|accents
operator|-
literal|1
index|]
expr_stmt|;
name|accents
operator|=
literal|0
expr_stmt|;
comment|/*  		 * If the accent key is followed by the space key, 		 * produce the accent char itself. 		 */
if|if
condition|(
name|action
operator|==
literal|' '
condition|)
block|{
name|action
operator|=
name|acc
operator|->
name|accchar
expr_stmt|;
if|if
condition|(
name|metas
condition|)
name|action
operator||=
name|MKEY
expr_stmt|;
return|return
operator|(
name|action
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_ACCENTCHARS
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|acc
operator|->
name|map
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|0
condition|)
comment|/* end of the map entry */
break|break;
if|if
condition|(
name|acc
operator|->
name|map
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
name|action
condition|)
block|{
name|action
operator|=
name|acc
operator|->
name|map
index|[
name|i
index|]
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|metas
condition|)
name|action
operator||=
name|MKEY
expr_stmt|;
return|return
operator|(
name|action
operator|)
return|;
block|}
block|}
name|do_bell
argument_list|(
name|cur_console
argument_list|,
name|BELL_PITCH
argument_list|,
name|BELL_DURATION
argument_list|)
expr_stmt|;
goto|goto
name|next_code
goto|;
block|}
if|if
condition|(
name|metas
condition|)
name|action
operator||=
name|MKEY
expr_stmt|;
return|return
operator|(
name|action
operator|)
return|;
block|}
block|}
goto|goto
name|next_code
goto|;
block|}
ifdef|#
directive|ifdef
name|SC_SPLASH_SCREEN
specifier|static
name|void
name|toggle_splash_screen
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
specifier|static
name|int
name|toggle
init|=
literal|0
decl_stmt|;
specifier|static
name|u_char
name|save_mode
decl_stmt|;
name|int
name|s
init|=
name|splhigh
argument_list|()
decl_stmt|;
if|if
condition|(
name|toggle
condition|)
block|{
name|scp
operator|->
name|mode
operator|=
name|save_mode
expr_stmt|;
name|scp
operator|->
name|status
operator|&=
operator|~
name|UNKNOWN_MODE
expr_stmt|;
name|set_mode
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|toggle
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|save_mode
operator|=
name|scp
operator|->
name|mode
expr_stmt|;
name|scp
operator|->
name|mode
operator|=
name|M_VGA_CG320
expr_stmt|;
name|scp
operator|->
name|status
operator||=
name|UNKNOWN_MODE
expr_stmt|;
name|set_mode
argument_list|(
name|scp
argument_list|)
expr_stmt|;
comment|/* load image */
name|toggle
operator|=
literal|1
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|int
name|scmmap
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|nprot
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|PC98
if|if
condition|(
name|offset
operator|>
literal|0x48000
operator|-
name|PAGE_SIZE
condition|)
else|#
directive|else
if|if
condition|(
name|offset
operator|>
literal|0x20000
operator|-
name|PAGE_SIZE
condition|)
endif|#
directive|endif
return|return
operator|-
literal|1
return|;
return|return
name|i386_btop
argument_list|(
operator|(
name|VIDEOMEM
operator|+
name|offset
operator|)
argument_list|)
return|;
block|}
comment|/*  * Calculate hardware attributes word using logical attributes mask and  * hardware colors  */
specifier|static
name|int
name|mask2attr
parameter_list|(
name|struct
name|term_stat
modifier|*
name|term
parameter_list|)
block|{
name|int
name|attr
decl_stmt|,
name|mask
init|=
name|term
operator|->
name|attr_mask
decl_stmt|;
if|if
condition|(
name|mask
operator|&
name|REVERSE_ATTR
condition|)
block|{
name|attr
operator|=
operator|(
operator|(
name|mask
operator|&
name|FOREGROUND_CHANGED
operator|)
condition|?
operator|(
operator|(
name|term
operator|->
name|cur_color
operator|&
literal|0xF000
operator|)
operator|>>
literal|4
operator|)
else|:
operator|(
name|term
operator|->
name|rev_color
operator|&
literal|0x0F00
operator|)
operator|)
operator||
operator|(
operator|(
name|mask
operator|&
name|BACKGROUND_CHANGED
operator|)
condition|?
operator|(
operator|(
name|term
operator|->
name|cur_color
operator|&
literal|0x0F00
operator|)
operator|<<
literal|4
operator|)
else|:
operator|(
name|term
operator|->
name|rev_color
operator|&
literal|0xF000
operator|)
operator|)
expr_stmt|;
block|}
else|else
name|attr
operator|=
name|term
operator|->
name|cur_color
expr_stmt|;
comment|/* XXX: underline mapping for Hercules adapter can be better */
if|if
condition|(
name|mask
operator|&
operator|(
name|BOLD_ATTR
operator||
name|UNDERLINE_ATTR
operator|)
condition|)
name|attr
operator|^=
literal|0x0800
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|BLINK_ATTR
condition|)
name|attr
operator|^=
literal|0x8000
expr_stmt|;
return|return
name|attr
return|;
block|}
specifier|static
name|void
name|set_keyboard
parameter_list|(
name|int
name|command
parameter_list|,
name|int
name|data
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|PC98
name|int
name|s
decl_stmt|;
if|if
condition|(
name|sc_kbdc
operator|==
name|NULL
condition|)
return|return;
comment|/* prevent the timeout routine from polling the keyboard */
if|if
condition|(
operator|!
name|kbdc_lock
argument_list|(
name|sc_kbdc
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return;
comment|/* disable the keyboard and mouse interrupt */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|#
directive|if
literal|0
block|c = get_controller_command_byte(sc_kbdc);     if ((c == -1)  	|| !set_controller_command_byte(sc_kbdc,              kbdc_get_device_mask(sc_kbdc),             KBD_DISABLE_KBD_PORT | KBD_DISABLE_KBD_INT                 | KBD_DISABLE_AUX_PORT | KBD_DISABLE_AUX_INT)) {
comment|/* CONTROLLER ERROR */
block|kbdc_lock(sc_kbdc, FALSE); 	splx(s); 	return;     }
comment|/*       * Now that the keyboard controller is told not to generate       * the keyboard and mouse interrupts, call `splx()' to allow       * the other tty interrupts. The clock interrupt may also occur,       * but the timeout routine (`scrn_timer()') will be blocked       * by the lock flag set via `kbdc_lock()'      */
block|splx(s);
endif|#
directive|endif
if|if
condition|(
name|send_kbd_command_and_data
argument_list|(
name|sc_kbdc
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
operator|!=
name|KBD_ACK
condition|)
name|send_kbd_command
argument_list|(
name|sc_kbdc
argument_list|,
name|KBDC_ENABLE_KBD
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* restore the interrupts */
block|if (!set_controller_command_byte(sc_kbdc,             kbdc_get_device_mask(sc_kbdc), 	    c& (KBD_KBD_CONTROL_BITS | KBD_AUX_CONTROL_BITS))) {
comment|/* CONTROLLER ERROR */
block|}
else|#
directive|else
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|kbdc_lock
argument_list|(
name|sc_kbdc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
specifier|static
name|void
name|update_leds
parameter_list|(
name|int
name|which
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|PC98
name|int
name|s
decl_stmt|;
specifier|static
name|u_char
name|xlate_leds
index|[
literal|8
index|]
init|=
block|{
literal|0
block|,
literal|4
block|,
literal|2
block|,
literal|6
block|,
literal|1
block|,
literal|5
block|,
literal|3
block|,
literal|7
block|}
decl_stmt|;
comment|/* replace CAPS led with ALTGR led for ALTGR keyboards */
if|if
condition|(
name|key_map
operator|.
name|n_keys
operator|>
name|ALTGR_OFFSET
condition|)
block|{
if|if
condition|(
name|which
operator|&
name|ALKED
condition|)
name|which
operator||=
name|CLKED
expr_stmt|;
else|else
name|which
operator|&=
operator|~
name|CLKED
expr_stmt|;
block|}
name|set_keyboard
argument_list|(
name|KBDC_SET_LEDS
argument_list|,
name|xlate_leds
index|[
name|which
operator|&
name|LED_MASK
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|void
name|set_mode
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
name|char
name|special_modetable
index|[
name|MODE_PARAM_SIZE
index|]
decl_stmt|;
name|char
modifier|*
name|mp
decl_stmt|;
if|if
condition|(
name|scp
operator|!=
name|cur_console
condition|)
return|return;
comment|/*       * even if mode switching is disabled, we can change back      * to the initial mode or the custom mode based on the initial      * mode if we have saved register values upon start-up.      */
name|mp
operator|=
name|get_mode_param
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|==
name|NULL
condition|)
return|return;
name|bcopy
argument_list|(
name|mp
argument_list|,
operator|&
name|special_modetable
argument_list|,
sizeof|sizeof
argument_list|(
name|special_modetable
argument_list|)
argument_list|)
expr_stmt|;
comment|/* setup video hardware for the given mode */
ifdef|#
directive|ifdef
name|PC98
ifdef|#
directive|ifdef
name|LINE30
switch|switch
condition|(
name|scp
operator|->
name|mode
condition|)
block|{
case|case
name|M_PC98_80x25
case|:
comment|/* VGA TEXT MODES */
name|initialize_gdc
argument_list|(
name|T25_G400
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_PC98_80x30
case|:
name|initialize_gdc
argument_list|(
name|T30_G400
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
endif|#
directive|endif
if|if
condition|(
name|scp
operator|->
name|status
operator|&
name|UNKNOWN_MODE
condition|)
block|{
while|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
literal|0x60
argument_list|)
operator|&
literal|0x20
operator|)
condition|)
block|{}
comment|/* V-SYNC wait */
name|outb
argument_list|(
literal|0x62
argument_list|,
literal|0xc
argument_list|)
expr_stmt|;
comment|/* text off */
name|outb
argument_list|(
literal|0xA2
argument_list|,
literal|0xd
argument_list|)
expr_stmt|;
comment|/* graphics on */
block|}
else|else
block|{
while|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
literal|0x60
argument_list|)
operator|&
literal|0x20
operator|)
condition|)
block|{}
comment|/* V-SYNC wait */
name|outb
argument_list|(
literal|0x62
argument_list|,
literal|0xd
argument_list|)
expr_stmt|;
comment|/* text on */
name|outb
argument_list|(
literal|0xA2
argument_list|,
literal|0xc
argument_list|)
expr_stmt|;
comment|/* graphics off */
block|}
else|#
directive|else
comment|/* IBM-PC */
switch|switch
condition|(
name|scp
operator|->
name|mode
condition|)
block|{
case|case
name|M_VGA_C80x60
case|:
case|case
name|M_VGA_M80x60
case|:
name|special_modetable
index|[
literal|2
index|]
operator|=
literal|0x08
expr_stmt|;
name|special_modetable
index|[
literal|19
index|]
operator|=
literal|0x47
expr_stmt|;
goto|goto
name|special_480l
goto|;
case|case
name|M_VGA_C80x30
case|:
case|case
name|M_VGA_M80x30
case|:
name|special_modetable
index|[
literal|19
index|]
operator|=
literal|0x4f
expr_stmt|;
name|special_480l
label|:
name|special_modetable
index|[
literal|9
index|]
operator||=
literal|0xc0
expr_stmt|;
name|special_modetable
index|[
literal|16
index|]
operator|=
literal|0x08
expr_stmt|;
name|special_modetable
index|[
literal|17
index|]
operator|=
literal|0x3e
expr_stmt|;
name|special_modetable
index|[
literal|26
index|]
operator|=
literal|0xea
expr_stmt|;
name|special_modetable
index|[
literal|28
index|]
operator|=
literal|0xdf
expr_stmt|;
name|special_modetable
index|[
literal|31
index|]
operator|=
literal|0xe7
expr_stmt|;
name|special_modetable
index|[
literal|32
index|]
operator|=
literal|0x04
expr_stmt|;
goto|goto
name|setup_mode
goto|;
case|case
name|M_ENH_C80x43
case|:
case|case
name|M_ENH_B80x43
case|:
name|special_modetable
index|[
literal|28
index|]
operator|=
literal|87
expr_stmt|;
goto|goto
name|special_80x50
goto|;
case|case
name|M_VGA_C80x50
case|:
case|case
name|M_VGA_M80x50
case|:
name|special_80x50
label|:
name|special_modetable
index|[
literal|2
index|]
operator|=
literal|8
expr_stmt|;
name|special_modetable
index|[
literal|19
index|]
operator|=
literal|7
expr_stmt|;
goto|goto
name|setup_mode
goto|;
case|case
name|M_VGA_C40x25
case|:
case|case
name|M_VGA_C80x25
case|:
case|case
name|M_VGA_M80x25
case|:
case|case
name|M_B40x25
case|:
case|case
name|M_C40x25
case|:
case|case
name|M_B80x25
case|:
case|case
name|M_C80x25
case|:
case|case
name|M_ENH_B40x25
case|:
case|case
name|M_ENH_C40x25
case|:
case|case
name|M_ENH_B80x25
case|:
case|case
name|M_ENH_C80x25
case|:
case|case
name|M_EGAMONO80x25
case|:
name|setup_mode
label|:
name|set_vgaregs
argument_list|(
name|special_modetable
argument_list|)
expr_stmt|;
name|scp
operator|->
name|font_size
operator|=
name|special_modetable
index|[
literal|2
index|]
expr_stmt|;
comment|/* set font type (size) */
if|if
condition|(
name|scp
operator|->
name|font_size
operator|<
literal|14
condition|)
block|{
if|if
condition|(
name|fonts_loaded
operator|&
name|FONT_8
condition|)
name|copy_font
argument_list|(
name|LOAD
argument_list|,
name|FONT_8
argument_list|,
name|font_8
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
literal|0x0A
argument_list|)
expr_stmt|;
comment|/* font 2 */
block|}
elseif|else
if|if
condition|(
name|scp
operator|->
name|font_size
operator|>=
literal|16
condition|)
block|{
if|if
condition|(
name|fonts_loaded
operator|&
name|FONT_16
condition|)
name|copy_font
argument_list|(
name|LOAD
argument_list|,
name|FONT_16
argument_list|,
name|font_16
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* font 0 */
block|}
else|else
block|{
if|if
condition|(
name|fonts_loaded
operator|&
name|FONT_14
condition|)
name|copy_font
argument_list|(
name|LOAD
argument_list|,
name|FONT_14
argument_list|,
name|font_14
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
literal|0x05
argument_list|)
expr_stmt|;
comment|/* font 1 */
block|}
if|if
condition|(
name|flags
operator|&
name|CHAR_CURSOR
condition|)
name|set_destructive_cursor
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|mark_all
argument_list|(
name|scp
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_VGA_MODEX
case|:
comment|/* "unchain" the VGA mode */
name|special_modetable
index|[
literal|5
operator|-
literal|1
operator|+
literal|0x04
index|]
operator|&=
literal|0xf7
expr_stmt|;
name|special_modetable
index|[
literal|5
operator|-
literal|1
operator|+
literal|0x04
index|]
operator||=
literal|0x04
expr_stmt|;
comment|/* turn off doubleword mode */
name|special_modetable
index|[
literal|10
operator|+
literal|0x14
index|]
operator|&=
literal|0xbf
expr_stmt|;
comment|/* turn off word adressing */
name|special_modetable
index|[
literal|10
operator|+
literal|0x17
index|]
operator||=
literal|0x40
expr_stmt|;
comment|/* set logical screen width */
name|special_modetable
index|[
literal|10
operator|+
literal|0x13
index|]
operator|=
literal|80
expr_stmt|;
comment|/* set 240 lines */
name|special_modetable
index|[
literal|10
operator|+
literal|0x11
index|]
operator|=
literal|0x2c
expr_stmt|;
name|special_modetable
index|[
literal|10
operator|+
literal|0x06
index|]
operator|=
literal|0x0d
expr_stmt|;
name|special_modetable
index|[
literal|10
operator|+
literal|0x07
index|]
operator|=
literal|0x3e
expr_stmt|;
name|special_modetable
index|[
literal|10
operator|+
literal|0x10
index|]
operator|=
literal|0xea
expr_stmt|;
name|special_modetable
index|[
literal|10
operator|+
literal|0x11
index|]
operator|=
literal|0xac
expr_stmt|;
name|special_modetable
index|[
literal|10
operator|+
literal|0x12
index|]
operator|=
literal|0xdf
expr_stmt|;
name|special_modetable
index|[
literal|10
operator|+
literal|0x15
index|]
operator|=
literal|0xe7
expr_stmt|;
name|special_modetable
index|[
literal|10
operator|+
literal|0x16
index|]
operator|=
literal|0x06
expr_stmt|;
comment|/* set vertical sync polarity to reflect aspect ratio */
name|special_modetable
index|[
literal|9
index|]
operator|=
literal|0xe3
expr_stmt|;
goto|goto
name|setup_grmode
goto|;
case|case
name|M_BG320
case|:
case|case
name|M_CG320
case|:
case|case
name|M_BG640
case|:
case|case
name|M_CG320_D
case|:
case|case
name|M_CG640_E
case|:
case|case
name|M_CG640x350
case|:
case|case
name|M_ENH_CG640
case|:
case|case
name|M_BG640x480
case|:
case|case
name|M_CG640x480
case|:
case|case
name|M_VGA_CG320
case|:
name|setup_grmode
label|:
name|set_vgaregs
argument_list|(
name|special_modetable
argument_list|)
expr_stmt|;
name|scp
operator|->
name|font_size
operator|=
name|FONT_NONE
expr_stmt|;
break|break;
default|default:
comment|/* call user defined function XXX */
break|break;
block|}
endif|#
directive|endif
comment|/* PC98 */
comment|/* set border color for this (virtual) console */
name|set_border
argument_list|(
name|scp
operator|->
name|border
argument_list|)
expr_stmt|;
return|return;
block|}
name|void
name|set_border
parameter_list|(
name|u_char
name|color
parameter_list|)
block|{
switch|switch
condition|(
name|crtc_type
condition|)
block|{
ifdef|#
directive|ifdef
name|PC98
case|case
name|KD_PC98
case|:
name|outb
argument_list|(
literal|0x6c
argument_list|,
name|color
operator|<<
literal|4
argument_list|)
expr_stmt|;
break|break;
else|#
directive|else
case|case
name|KD_EGA
case|:
case|case
name|KD_VGA
case|:
name|inb
argument_list|(
name|crtc_addr
operator|+
literal|6
argument_list|)
expr_stmt|;
comment|/* reset flip-flop */
name|outb
argument_list|(
name|ATC
argument_list|,
literal|0x31
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ATC
argument_list|,
name|color
argument_list|)
expr_stmt|;
break|break;
case|case
name|KD_CGA
case|:
name|outb
argument_list|(
name|crtc_addr
operator|+
literal|5
argument_list|,
name|color
operator|&
literal|0x0f
argument_list|)
expr_stmt|;
comment|/* color select register */
break|break;
case|case
name|KD_MONO
case|:
case|case
name|KD_HERCULES
case|:
endif|#
directive|endif
default|default:
break|break;
block|}
block|}
ifndef|#
directive|ifndef
name|PC98
specifier|static
name|void
name|set_vgaregs
parameter_list|(
name|char
modifier|*
name|modetable
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|s
init|=
name|splhigh
argument_list|()
decl_stmt|;
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
comment|/* stop sequencer */
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x07
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* unlock registers */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
comment|/* program sequencer */
name|outb
argument_list|(
name|TSIDX
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
name|modetable
index|[
name|i
operator|+
literal|5
index|]
argument_list|)
expr_stmt|;
block|}
name|outb
argument_list|(
name|MISC
argument_list|,
name|modetable
index|[
literal|9
index|]
argument_list|)
expr_stmt|;
comment|/* set dot-clock */
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
comment|/* start sequencer */
name|outb
argument_list|(
name|crtc_addr
argument_list|,
literal|0x11
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|crtc_addr
operator|+
literal|1
argument_list|,
name|inb
argument_list|(
name|crtc_addr
operator|+
literal|1
argument_list|)
operator|&
literal|0x7F
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|25
condition|;
name|i
operator|++
control|)
block|{
comment|/* program crtc */
name|outb
argument_list|(
name|crtc_addr
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|14
operator|||
name|i
operator|==
literal|15
condition|)
comment|/* no hardware cursor */
name|outb
argument_list|(
name|crtc_addr
operator|+
literal|1
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
else|else
name|outb
argument_list|(
name|crtc_addr
operator|+
literal|1
argument_list|,
name|modetable
index|[
name|i
operator|+
literal|10
index|]
argument_list|)
expr_stmt|;
block|}
name|inb
argument_list|(
name|crtc_addr
operator|+
literal|6
argument_list|)
expr_stmt|;
comment|/* reset flip-flop */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|20
condition|;
name|i
operator|++
control|)
block|{
comment|/* program attribute ctrl */
name|outb
argument_list|(
name|ATC
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ATC
argument_list|,
name|modetable
index|[
name|i
operator|+
literal|35
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|9
condition|;
name|i
operator|++
control|)
block|{
comment|/* program graph data ctrl */
name|outb
argument_list|(
name|GDCIDX
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GDCREG
argument_list|,
name|modetable
index|[
name|i
operator|+
literal|55
index|]
argument_list|)
expr_stmt|;
block|}
name|inb
argument_list|(
name|crtc_addr
operator|+
literal|6
argument_list|)
expr_stmt|;
comment|/* reset flip-flop */
name|outb
argument_list|(
name|ATC
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
comment|/* enable palette */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|read_vgaregs
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|s
decl_stmt|;
name|bzero
argument_list|(
name|buf
argument_list|,
name|MODE_PARAM_SIZE
argument_list|)
expr_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
comment|/* stop sequencer */
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x07
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* unlock registers */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|5
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|outb
argument_list|(
name|TSIDX
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|buf
index|[
name|j
operator|++
index|]
operator|=
name|inb
argument_list|(
name|TSREG
argument_list|)
expr_stmt|;
block|}
name|buf
index|[
literal|9
index|]
operator|=
name|inb
argument_list|(
name|MISC
operator|+
literal|10
argument_list|)
expr_stmt|;
comment|/* dot-clock */
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
comment|/* start sequencer */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|10
init|;
name|i
operator|<
literal|25
condition|;
name|i
operator|++
control|)
block|{
comment|/* crtc */
name|outb
argument_list|(
name|crtc_addr
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|buf
index|[
name|j
operator|++
index|]
operator|=
name|inb
argument_list|(
name|crtc_addr
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|35
init|;
name|i
operator|<
literal|20
condition|;
name|i
operator|++
control|)
block|{
comment|/* attribute ctrl */
name|inb
argument_list|(
name|crtc_addr
operator|+
literal|6
argument_list|)
expr_stmt|;
comment|/* reset flip-flop */
name|outb
argument_list|(
name|ATC
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|buf
index|[
name|j
operator|++
index|]
operator|=
name|inb
argument_list|(
name|ATC
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|55
init|;
name|i
operator|<
literal|9
condition|;
name|i
operator|++
control|)
block|{
comment|/* graph data ctrl */
name|outb
argument_list|(
name|GDCIDX
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|buf
index|[
name|j
operator|++
index|]
operator|=
name|inb
argument_list|(
name|GDCREG
argument_list|)
expr_stmt|;
block|}
name|inb
argument_list|(
name|crtc_addr
operator|+
literal|6
argument_list|)
expr_stmt|;
comment|/* reset flip-flop */
name|outb
argument_list|(
name|ATC
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
comment|/* enable palette */
name|buf
index|[
literal|0
index|]
operator|=
operator|*
operator|(
name|char
operator|*
operator|)
name|pa_to_va
argument_list|(
literal|0x44a
argument_list|)
expr_stmt|;
comment|/* COLS */
name|buf
index|[
literal|1
index|]
operator|=
operator|*
operator|(
name|char
operator|*
operator|)
name|pa_to_va
argument_list|(
literal|0x484
argument_list|)
expr_stmt|;
comment|/* ROWS */
name|buf
index|[
literal|2
index|]
operator|=
operator|*
operator|(
name|char
operator|*
operator|)
name|pa_to_va
argument_list|(
literal|0x485
argument_list|)
expr_stmt|;
comment|/* POINTS */
name|buf
index|[
literal|3
index|]
operator|=
operator|*
operator|(
name|char
operator|*
operator|)
name|pa_to_va
argument_list|(
literal|0x44c
argument_list|)
expr_stmt|;
name|buf
index|[
literal|4
index|]
operator|=
operator|*
operator|(
name|char
operator|*
operator|)
name|pa_to_va
argument_list|(
literal|0x44d
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
specifier|static
name|int
name|comp_vgaregs
parameter_list|(
name|u_char
modifier|*
name|buf1
parameter_list|,
name|u_char
modifier|*
name|buf2
parameter_list|)
block|{
specifier|static
struct|struct
block|{
name|u_char
name|mask
decl_stmt|;
block|}
name|params
index|[
name|MODE_PARAM_SIZE
index|]
init|=
block|{
literal|0xff
block|,
literal|0x00
block|,
literal|0xff
block|,
comment|/* COLS, ROWS, POINTS */
literal|0xff
block|,
literal|0xff
block|,
comment|/* page length */
literal|0xfe
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|/* sequencer registers */
literal|0xf3
block|,
comment|/* misc register */
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0x7f
block|,
literal|0xff
block|,
comment|/* CRTC */
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0x7f
block|,
literal|0xff
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0xff
block|,
literal|0x7f
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0x7f
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xef
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|/* attribute controller registers */
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xf0
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|/* GDC register */
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,      }
struct|;
name|int
name|identical
init|=
name|TRUE
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|params
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|params
index|[
literal|0
index|]
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|params
index|[
name|i
index|]
operator|.
name|mask
operator|==
literal|0
condition|)
comment|/* don't care */
continue|continue;
if|if
condition|(
operator|(
name|buf1
index|[
name|i
index|]
operator|&
name|params
index|[
name|i
index|]
operator|.
name|mask
operator|)
operator|!=
operator|(
name|buf2
index|[
name|i
index|]
operator|&
name|params
index|[
name|i
index|]
operator|.
name|mask
operator|)
condition|)
return|return
name|COMP_DIFFERENT
return|;
if|if
condition|(
name|buf1
index|[
name|i
index|]
operator|!=
name|buf2
index|[
name|i
index|]
condition|)
name|identical
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
operator|(
name|identical
operator|)
condition|?
name|COMP_IDENTICAL
else|:
name|COMP_SIMILAR
return|;
if|#
directive|if
literal|0
block|for(i = 0; i< 20; ++i) { 	if (*buf1++ != *buf2++) 	    return COMP_DIFFERENT;     }     buf1 += 2;
comment|/* skip the cursor shape */
block|buf2 += 2;     for(i = 22; i< 24; ++i) { 	if (*buf1++ != *buf2++) 	    return COMP_DIFFERENT;     }     buf1 += 2;
comment|/* skip the cursor position */
block|buf2 += 2;     for(i = 26; i< MODE_PARAM_SIZE; ++i) { 	if (*buf1++ != *buf2++) 	    return COMP_DIFFERENT;     }     return COMP_IDENTICAL;
endif|#
directive|endif
block|}
specifier|static
name|void
name|dump_vgaregs
parameter_list|(
name|u_char
modifier|*
name|buf
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MODE_PARAM_SIZE
condition|;
control|)
block|{
name|printf
argument_list|(
literal|"%02x "
argument_list|,
name|buf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|++
name|i
operator|%
literal|16
operator|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
specifier|static
name|void
name|set_font_mode
parameter_list|(
name|u_char
modifier|*
name|buf
parameter_list|)
block|{
name|int
name|s
init|=
name|splhigh
argument_list|()
decl_stmt|;
comment|/* save register values */
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|inb
argument_list|(
name|TSREG
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|inb
argument_list|(
name|TSREG
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GDCIDX
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|inb
argument_list|(
name|GDCREG
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GDCIDX
argument_list|,
literal|0x05
argument_list|)
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
name|inb
argument_list|(
name|GDCREG
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GDCIDX
argument_list|,
literal|0x06
argument_list|)
expr_stmt|;
name|buf
index|[
literal|4
index|]
operator|=
name|inb
argument_list|(
name|GDCREG
argument_list|)
expr_stmt|;
name|inb
argument_list|(
name|crtc_addr
operator|+
literal|6
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ATC
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
name|buf
index|[
literal|5
index|]
operator|=
name|inb
argument_list|(
name|ATC
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* setup vga for loading fonts (graphics plane mode) */
name|inb
argument_list|(
name|crtc_addr
operator|+
literal|6
argument_list|)
expr_stmt|;
comment|/* reset flip-flop */
name|outb
argument_list|(
name|ATC
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ATC
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
name|inb
argument_list|(
name|crtc_addr
operator|+
literal|6
argument_list|)
expr_stmt|;
comment|/* reset flip-flop */
name|outb
argument_list|(
name|ATC
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
comment|/* enable palette */
if|#
directive|if
name|SLOW_VGA
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
literal|0x06
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GDCIDX
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GDCREG
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GDCIDX
argument_list|,
literal|0x05
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GDCREG
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GDCIDX
argument_list|,
literal|0x06
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GDCREG
argument_list|,
literal|0x05
argument_list|)
expr_stmt|;
else|#
directive|else
name|outw
argument_list|(
name|TSIDX
argument_list|,
literal|0x0402
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|TSIDX
argument_list|,
literal|0x0604
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|GDCIDX
argument_list|,
literal|0x0204
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|GDCIDX
argument_list|,
literal|0x0005
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|GDCIDX
argument_list|,
literal|0x0506
argument_list|)
expr_stmt|;
comment|/* addr = a0000, 64kb */
endif|#
directive|endif
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|set_normal_mode
parameter_list|(
name|u_char
modifier|*
name|buf
parameter_list|)
block|{
name|char
modifier|*
name|modetable
decl_stmt|;
name|int
name|s
init|=
name|splhigh
argument_list|()
decl_stmt|;
comment|/* setup vga for normal operation mode again */
name|inb
argument_list|(
name|crtc_addr
operator|+
literal|6
argument_list|)
expr_stmt|;
comment|/* reset flip-flop */
name|outb
argument_list|(
name|ATC
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ATC
argument_list|,
name|buf
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|inb
argument_list|(
name|crtc_addr
operator|+
literal|6
argument_list|)
expr_stmt|;
comment|/* reset flip-flop */
name|outb
argument_list|(
name|ATC
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
comment|/* enable palette */
if|#
directive|if
name|SLOW_VGA
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
name|buf
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
name|buf
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GDCIDX
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GDCREG
argument_list|,
name|buf
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GDCIDX
argument_list|,
literal|0x05
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GDCREG
argument_list|,
name|buf
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|crtc_addr
operator|==
name|MONO_BASE
condition|)
block|{
name|outb
argument_list|(
name|GDCIDX
argument_list|,
literal|0x06
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GDCREG
argument_list|,
operator|(
name|buf
index|[
literal|4
index|]
operator|&
literal|0x03
operator|)
operator||
literal|0x08
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outb
argument_list|(
name|GDCIDX
argument_list|,
literal|0x06
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GDCREG
argument_list|,
operator|(
name|buf
index|[
literal|4
index|]
operator|&
literal|0x03
operator|)
operator||
literal|0x0c
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|outw
argument_list|(
name|TSIDX
argument_list|,
literal|0x0002
operator||
operator|(
name|buf
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|TSIDX
argument_list|,
literal|0x0004
operator||
operator|(
name|buf
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|GDCIDX
argument_list|,
literal|0x0004
operator||
operator|(
name|buf
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|GDCIDX
argument_list|,
literal|0x0005
operator||
operator|(
name|buf
index|[
literal|3
index|]
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|crtc_addr
operator|==
name|MONO_BASE
condition|)
name|outw
argument_list|(
name|GDCIDX
argument_list|,
literal|0x0006
operator||
operator|(
operator|(
operator|(
name|buf
index|[
literal|4
index|]
operator|&
literal|0x03
operator|)
operator||
literal|0x08
operator|)
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
else|else
name|outw
argument_list|(
name|GDCIDX
argument_list|,
literal|0x0006
operator||
operator|(
operator|(
operator|(
name|buf
index|[
literal|4
index|]
operator|&
literal|0x03
operator|)
operator||
literal|0x0c
operator|)
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|void
name|copy_font
parameter_list|(
name|int
name|operation
parameter_list|,
name|int
name|font_type
parameter_list|,
name|char
modifier|*
name|font_image
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|PC98
name|int
name|ch
decl_stmt|,
name|line
decl_stmt|,
name|segment
decl_stmt|,
name|fontsize
decl_stmt|;
name|u_char
name|buf
index|[
name|PARAM_BUFSIZE
index|]
decl_stmt|;
name|u_char
name|val
decl_stmt|;
switch|switch
condition|(
name|font_type
condition|)
block|{
default|default:
case|case
name|FONT_8
case|:
name|segment
operator|=
literal|0x8000
expr_stmt|;
name|fontsize
operator|=
literal|8
expr_stmt|;
break|break;
case|case
name|FONT_14
case|:
name|segment
operator|=
literal|0x4000
expr_stmt|;
name|fontsize
operator|=
literal|14
expr_stmt|;
break|break;
case|case
name|FONT_16
case|:
name|segment
operator|=
literal|0x0000
expr_stmt|;
name|fontsize
operator|=
literal|16
expr_stmt|;
break|break;
block|}
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
name|val
operator|=
name|inb
argument_list|(
name|TSREG
argument_list|)
expr_stmt|;
comment|/* disable screen */
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
name|val
operator||
literal|0x20
argument_list|)
expr_stmt|;
name|set_font_mode
argument_list|(
name|buf
argument_list|)
expr_stmt|;
for|for
control|(
name|ch
operator|=
literal|0
init|;
name|ch
operator|<
literal|256
condition|;
name|ch
operator|++
control|)
for|for
control|(
name|line
operator|=
literal|0
init|;
name|line
operator|<
name|fontsize
condition|;
name|line
operator|++
control|)
if|if
condition|(
name|operation
condition|)
operator|*
operator|(
name|char
operator|*
operator|)
name|pa_to_va
argument_list|(
name|VIDEOMEM
operator|+
operator|(
name|segment
operator|)
operator|+
operator|(
name|ch
operator|*
literal|32
operator|)
operator|+
name|line
argument_list|)
operator|=
name|font_image
index|[
operator|(
name|ch
operator|*
name|fontsize
operator|)
operator|+
name|line
index|]
expr_stmt|;
else|else
name|font_image
index|[
operator|(
name|ch
operator|*
name|fontsize
operator|)
operator|+
name|line
index|]
operator|=
operator|*
operator|(
name|char
operator|*
operator|)
name|pa_to_va
argument_list|(
name|VIDEOMEM
operator|+
operator|(
name|segment
operator|)
operator|+
operator|(
name|ch
operator|*
literal|32
operator|)
operator|+
name|line
argument_list|)
expr_stmt|;
name|set_normal_mode
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
name|val
operator|&
literal|0xDF
argument_list|)
expr_stmt|;
comment|/* enable screen */
endif|#
directive|endif
block|}
specifier|static
name|void
name|set_destructive_cursor
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|PC98
name|u_char
name|buf
index|[
name|PARAM_BUFSIZE
index|]
decl_stmt|;
name|u_char
name|cursor
index|[
literal|32
index|]
decl_stmt|;
name|caddr_t
name|address
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|font_buffer
decl_stmt|;
if|if
condition|(
name|scp
operator|->
name|font_size
operator|<
literal|14
condition|)
block|{
name|font_buffer
operator|=
name|font_8
expr_stmt|;
name|address
operator|=
operator|(
name|caddr_t
operator|)
name|VIDEOMEM
operator|+
literal|0x8000
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scp
operator|->
name|font_size
operator|>=
literal|16
condition|)
block|{
name|font_buffer
operator|=
name|font_16
expr_stmt|;
name|address
operator|=
operator|(
name|caddr_t
operator|)
name|VIDEOMEM
expr_stmt|;
block|}
else|else
block|{
name|font_buffer
operator|=
name|font_14
expr_stmt|;
name|address
operator|=
operator|(
name|caddr_t
operator|)
name|VIDEOMEM
operator|+
literal|0x4000
expr_stmt|;
block|}
if|if
condition|(
name|scp
operator|->
name|status
operator|&
name|MOUSE_VISIBLE
condition|)
block|{
if|if
condition|(
operator|(
name|scp
operator|->
name|cursor_saveunder
operator|&
literal|0xff
operator|)
operator|==
literal|0xd0
condition|)
name|bcopy
argument_list|(
operator|&
name|scp
operator|->
name|mouse_cursor
index|[
literal|0
index|]
argument_list|,
name|cursor
argument_list|,
name|scp
operator|->
name|font_size
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|scp
operator|->
name|cursor_saveunder
operator|&
literal|0xff
operator|)
operator|==
literal|0xd1
condition|)
name|bcopy
argument_list|(
operator|&
name|scp
operator|->
name|mouse_cursor
index|[
literal|32
index|]
argument_list|,
name|cursor
argument_list|,
name|scp
operator|->
name|font_size
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|scp
operator|->
name|cursor_saveunder
operator|&
literal|0xff
operator|)
operator|==
literal|0xd2
condition|)
name|bcopy
argument_list|(
operator|&
name|scp
operator|->
name|mouse_cursor
index|[
literal|64
index|]
argument_list|,
name|cursor
argument_list|,
name|scp
operator|->
name|font_size
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|scp
operator|->
name|cursor_saveunder
operator|&
literal|0xff
operator|)
operator|==
literal|0xd3
condition|)
name|bcopy
argument_list|(
operator|&
name|scp
operator|->
name|mouse_cursor
index|[
literal|96
index|]
argument_list|,
name|cursor
argument_list|,
name|scp
operator|->
name|font_size
argument_list|)
expr_stmt|;
else|else
name|bcopy
argument_list|(
name|font_buffer
operator|+
operator|(
operator|(
name|scp
operator|->
name|cursor_saveunder
operator|&
literal|0xff
operator|)
operator|*
name|scp
operator|->
name|font_size
operator|)
argument_list|,
name|cursor
argument_list|,
name|scp
operator|->
name|font_size
argument_list|)
expr_stmt|;
block|}
else|else
name|bcopy
argument_list|(
name|font_buffer
operator|+
operator|(
operator|(
name|scp
operator|->
name|cursor_saveunder
operator|&
literal|0xff
operator|)
operator|*
name|scp
operator|->
name|font_size
operator|)
argument_list|,
name|cursor
argument_list|,
name|scp
operator|->
name|font_size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|i
operator|>=
name|scp
operator|->
name|cursor_start
operator|&&
name|i
operator|<=
name|scp
operator|->
name|cursor_end
operator|)
operator|||
operator|(
name|scp
operator|->
name|cursor_start
operator|>=
name|scp
operator|->
name|font_size
operator|&&
name|i
operator|==
name|scp
operator|->
name|font_size
operator|-
literal|1
operator|)
condition|)
name|cursor
index|[
name|i
index|]
operator||=
literal|0xff
expr_stmt|;
if|#
directive|if
literal|1
while|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|crtc_addr
operator|+
literal|6
argument_list|)
operator|&
literal|0x08
operator|)
condition|)
comment|/* wait for vertical retrace */
empty_stmt|;
endif|#
directive|endif
name|set_font_mode
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|sc_bcopy
argument_list|(
name|cursor
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pa_to_va
argument_list|(
name|address
argument_list|)
operator|+
name|DEAD_CHAR
operator|*
literal|32
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|set_normal_mode
argument_list|(
name|buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
specifier|static
name|void
name|set_mouse_pos
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
specifier|static
name|int
name|last_xpos
init|=
operator|-
literal|1
decl_stmt|,
name|last_ypos
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|scp
operator|->
name|mouse_xpos
operator|<
literal|0
condition|)
name|scp
operator|->
name|mouse_xpos
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|mouse_ypos
operator|<
literal|0
condition|)
name|scp
operator|->
name|mouse_ypos
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|status
operator|&
name|UNKNOWN_MODE
condition|)
block|{
if|if
condition|(
name|scp
operator|->
name|mouse_xpos
operator|>
name|scp
operator|->
name|xpixel
operator|-
literal|1
condition|)
name|scp
operator|->
name|mouse_xpos
operator|=
name|scp
operator|->
name|xpixel
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|mouse_ypos
operator|>
name|scp
operator|->
name|ypixel
operator|-
literal|1
condition|)
name|scp
operator|->
name|mouse_ypos
operator|=
name|scp
operator|->
name|ypixel
operator|-
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|scp
operator|->
name|mouse_xpos
operator|>
operator|(
name|scp
operator|->
name|xsize
operator|*
literal|8
operator|)
operator|-
literal|1
condition|)
name|scp
operator|->
name|mouse_xpos
operator|=
operator|(
name|scp
operator|->
name|xsize
operator|*
literal|8
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|mouse_ypos
operator|>
operator|(
name|scp
operator|->
name|ysize
operator|*
name|scp
operator|->
name|font_size
operator|)
operator|-
literal|1
condition|)
name|scp
operator|->
name|mouse_ypos
operator|=
operator|(
name|scp
operator|->
name|ysize
operator|*
name|scp
operator|->
name|font_size
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|mouse_xpos
operator|!=
name|last_xpos
operator|||
name|scp
operator|->
name|mouse_ypos
operator|!=
name|last_ypos
condition|)
block|{
name|scp
operator|->
name|status
operator||=
name|MOUSE_MOVED
expr_stmt|;
name|scp
operator|->
name|mouse_pos
operator|=
name|scp
operator|->
name|scr_buf
operator|+
operator|(
operator|(
name|scp
operator|->
name|mouse_ypos
operator|/
name|scp
operator|->
name|font_size
operator|)
operator|*
name|scp
operator|->
name|xsize
operator|+
name|scp
operator|->
name|mouse_xpos
operator|/
literal|8
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|scp
operator|->
name|status
operator|&
name|MOUSE_VISIBLE
operator|)
operator|&&
operator|(
name|scp
operator|->
name|status
operator|&
name|MOUSE_CUTTING
operator|)
condition|)
name|mouse_cut
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
block|}
define|#
directive|define
name|isspace
parameter_list|(
name|c
parameter_list|)
value|(((c)& 0xff) == ' ')
specifier|static
name|int
name|skip_spc_right
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|u_short
modifier|*
name|p
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
operator|(
name|p
operator|-
name|scp
operator|->
name|scr_buf
operator|)
operator|%
name|scp
operator|->
name|xsize
init|;
name|i
operator|<
name|scp
operator|->
name|xsize
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
break|break;
operator|++
name|p
expr_stmt|;
block|}
return|return
name|i
return|;
block|}
specifier|static
name|int
name|skip_spc_left
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|u_short
modifier|*
name|p
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
operator|(
name|p
operator|--
operator|-
name|scp
operator|->
name|scr_buf
operator|)
operator|%
name|scp
operator|->
name|xsize
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
break|break;
operator|--
name|p
expr_stmt|;
block|}
return|return
name|i
return|;
block|}
specifier|static
name|void
name|mouse_cut
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
name|u_short
modifier|*
name|end
decl_stmt|;
name|u_short
modifier|*
name|p
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|j
init|=
literal|0
decl_stmt|;
name|scp
operator|->
name|mouse_cut_end
operator|=
operator|(
name|scp
operator|->
name|mouse_pos
operator|>=
name|scp
operator|->
name|mouse_cut_start
operator|)
condition|?
name|scp
operator|->
name|mouse_pos
operator|+
literal|1
else|:
name|scp
operator|->
name|mouse_pos
expr_stmt|;
name|end
operator|=
operator|(
name|scp
operator|->
name|mouse_cut_start
operator|>
name|scp
operator|->
name|mouse_cut_end
operator|)
condition|?
name|scp
operator|->
name|mouse_cut_start
else|:
name|scp
operator|->
name|mouse_cut_end
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|(
name|scp
operator|->
name|mouse_cut_start
operator|>
name|scp
operator|->
name|mouse_cut_end
operator|)
condition|?
name|scp
operator|->
name|mouse_cut_end
else|:
name|scp
operator|->
name|mouse_cut_start
init|;
name|p
operator|<
name|end
condition|;
operator|++
name|p
control|)
block|{
name|cut_buffer
index|[
name|i
index|]
operator|=
operator|*
name|p
operator|&
literal|0xff
expr_stmt|;
comment|/* remember the position of the last non-space char */
if|if
condition|(
operator|!
name|isspace
argument_list|(
name|cut_buffer
index|[
name|i
operator|++
index|]
argument_list|)
condition|)
name|j
operator|=
name|i
expr_stmt|;
comment|/* trim trailing blank when crossing lines */
if|if
condition|(
operator|(
operator|(
name|p
operator|-
name|scp
operator|->
name|scr_buf
operator|)
operator|%
name|scp
operator|->
name|xsize
operator|)
operator|==
operator|(
name|scp
operator|->
name|xsize
operator|-
literal|1
operator|)
condition|)
block|{
name|cut_buffer
index|[
name|j
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
name|i
operator|=
name|j
expr_stmt|;
block|}
block|}
name|cut_buffer
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* scan towards the end of the last line */
operator|--
name|p
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|(
name|p
operator|-
name|scp
operator|->
name|scr_buf
operator|)
operator|%
name|scp
operator|->
name|xsize
init|;
name|i
operator|<
name|scp
operator|->
name|xsize
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
break|break;
operator|++
name|p
expr_stmt|;
block|}
comment|/* if there is nothing but blank chars, trim them, but mark towards eol */
if|if
condition|(
name|i
operator|>=
name|scp
operator|->
name|xsize
condition|)
block|{
if|if
condition|(
name|scp
operator|->
name|mouse_cut_start
operator|>
name|scp
operator|->
name|mouse_cut_end
condition|)
name|scp
operator|->
name|mouse_cut_start
operator|=
name|p
expr_stmt|;
else|else
name|scp
operator|->
name|mouse_cut_end
operator|=
name|p
expr_stmt|;
name|cut_buffer
index|[
name|j
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
name|cut_buffer
index|[
name|j
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|mouse_cut_start
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|mouse_cut_end
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|mouse_cut_start
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|scp
operator|->
name|status
operator|&
name|MOUSE_VISIBLE
condition|)
block|{
if|if
condition|(
name|scp
operator|->
name|mouse_pos
operator|==
name|scp
operator|->
name|mouse_cut_start
operator|&&
name|scp
operator|->
name|mouse_cut_start
operator|==
name|scp
operator|->
name|mouse_cut_end
operator|-
literal|1
condition|)
block|{
name|cut_buffer
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|remove_cutmarking
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|skip_spc_right
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|mouse_pos
argument_list|)
operator|>=
name|scp
operator|->
name|xsize
condition|)
block|{
comment|/* if the pointer is on trailing blank chars, mark towards eol */
name|i
operator|=
name|skip_spc_left
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|mouse_pos
argument_list|)
operator|+
literal|1
expr_stmt|;
name|scp
operator|->
name|mouse_cut_start
operator|=
name|scp
operator|->
name|scr_buf
operator|+
operator|(
operator|(
name|scp
operator|->
name|mouse_pos
operator|-
name|scp
operator|->
name|scr_buf
operator|)
operator|/
name|scp
operator|->
name|xsize
operator|)
operator|*
name|scp
operator|->
name|xsize
operator|+
name|i
expr_stmt|;
name|scp
operator|->
name|mouse_cut_end
operator|=
name|scp
operator|->
name|scr_buf
operator|+
operator|(
operator|(
name|scp
operator|->
name|mouse_pos
operator|-
name|scp
operator|->
name|scr_buf
operator|)
operator|/
name|scp
operator|->
name|xsize
operator|+
literal|1
operator|)
operator|*
name|scp
operator|->
name|xsize
expr_stmt|;
name|cut_buffer
index|[
literal|0
index|]
operator|=
literal|'\n'
expr_stmt|;
name|cut_buffer
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|scp
operator|->
name|status
operator||=
name|MOUSE_CUTTING
expr_stmt|;
block|}
else|else
block|{
name|scp
operator|->
name|mouse_cut_start
operator|=
name|scp
operator|->
name|mouse_pos
expr_stmt|;
name|scp
operator|->
name|mouse_cut_end
operator|=
name|scp
operator|->
name|mouse_cut_start
operator|+
literal|1
expr_stmt|;
name|cut_buffer
index|[
literal|0
index|]
operator|=
operator|*
name|scp
operator|->
name|mouse_cut_start
operator|&
literal|0xff
expr_stmt|;
name|cut_buffer
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|scp
operator|->
name|status
operator||=
name|MOUSE_CUTTING
expr_stmt|;
block|}
name|mark_all
argument_list|(
name|scp
argument_list|)
expr_stmt|;
comment|/* delete all other screens cut markings */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXCONS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|console
index|[
name|i
index|]
operator|==
name|NULL
operator|||
name|console
index|[
name|i
index|]
operator|==
name|scp
condition|)
continue|continue;
name|remove_cutmarking
argument_list|(
name|console
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|static
name|void
name|mouse_cut_end
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
if|if
condition|(
name|scp
operator|->
name|status
operator|&
name|MOUSE_VISIBLE
condition|)
block|{
name|scp
operator|->
name|status
operator|&=
operator|~
name|MOUSE_CUTTING
expr_stmt|;
block|}
block|}
specifier|static
name|void
name|mouse_cut_word
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
name|u_short
modifier|*
name|p
decl_stmt|;
name|u_short
modifier|*
name|sol
decl_stmt|;
name|u_short
modifier|*
name|eol
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/*      * Because we don't have locale information in the kernel,      * we only distinguish space char and non-space chars.  Punctuation      * chars, symbols and other regular chars are all treated alike.      */
if|if
condition|(
name|scp
operator|->
name|status
operator|&
name|MOUSE_VISIBLE
condition|)
block|{
name|sol
operator|=
name|scp
operator|->
name|scr_buf
operator|+
operator|(
operator|(
name|scp
operator|->
name|mouse_pos
operator|-
name|scp
operator|->
name|scr_buf
operator|)
operator|/
name|scp
operator|->
name|xsize
operator|)
operator|*
name|scp
operator|->
name|xsize
expr_stmt|;
name|eol
operator|=
name|sol
operator|+
name|scp
operator|->
name|xsize
expr_stmt|;
if|if
condition|(
name|isspace
argument_list|(
operator|*
name|scp
operator|->
name|mouse_pos
argument_list|)
condition|)
block|{
for|for
control|(
name|p
operator|=
name|scp
operator|->
name|mouse_pos
init|;
name|p
operator|>=
name|sol
condition|;
operator|--
name|p
control|)
if|if
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
break|break;
name|scp
operator|->
name|mouse_cut_start
operator|=
operator|++
name|p
expr_stmt|;
for|for
control|(
name|p
operator|=
name|scp
operator|->
name|mouse_pos
init|;
name|p
operator|<
name|eol
condition|;
operator|++
name|p
control|)
if|if
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
break|break;
name|scp
operator|->
name|mouse_cut_end
operator|=
name|p
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|p
operator|=
name|scp
operator|->
name|mouse_pos
init|;
name|p
operator|>=
name|sol
condition|;
operator|--
name|p
control|)
if|if
condition|(
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
break|break;
name|scp
operator|->
name|mouse_cut_start
operator|=
operator|++
name|p
expr_stmt|;
for|for
control|(
name|p
operator|=
name|scp
operator|->
name|mouse_pos
init|;
name|p
operator|<
name|eol
condition|;
operator|++
name|p
control|)
if|if
condition|(
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
break|break;
name|scp
operator|->
name|mouse_cut_end
operator|=
name|p
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|p
operator|=
name|scp
operator|->
name|mouse_cut_start
init|;
name|p
operator|<
name|scp
operator|->
name|mouse_cut_end
condition|;
operator|++
name|p
control|)
name|cut_buffer
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|p
operator|&
literal|0xff
expr_stmt|;
name|cut_buffer
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|scp
operator|->
name|status
operator||=
name|MOUSE_CUTTING
expr_stmt|;
block|}
block|}
specifier|static
name|void
name|mouse_cut_line
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
name|u_short
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|scp
operator|->
name|status
operator|&
name|MOUSE_VISIBLE
condition|)
block|{
name|scp
operator|->
name|mouse_cut_start
operator|=
name|scp
operator|->
name|scr_buf
operator|+
operator|(
operator|(
name|scp
operator|->
name|mouse_pos
operator|-
name|scp
operator|->
name|scr_buf
operator|)
operator|/
name|scp
operator|->
name|xsize
operator|)
operator|*
name|scp
operator|->
name|xsize
expr_stmt|;
name|scp
operator|->
name|mouse_cut_end
operator|=
name|scp
operator|->
name|mouse_cut_start
operator|+
name|scp
operator|->
name|xsize
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|p
operator|=
name|scp
operator|->
name|mouse_cut_start
init|;
name|p
operator|<
name|scp
operator|->
name|mouse_cut_end
condition|;
operator|++
name|p
control|)
name|cut_buffer
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|p
operator|&
literal|0xff
expr_stmt|;
name|cut_buffer
index|[
name|i
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
name|cut_buffer
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|scp
operator|->
name|status
operator||=
name|MOUSE_CUTTING
expr_stmt|;
block|}
block|}
specifier|static
name|void
name|mouse_cut_extend
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
if|if
condition|(
operator|(
name|scp
operator|->
name|status
operator|&
name|MOUSE_VISIBLE
operator|)
operator|&&
operator|!
operator|(
name|scp
operator|->
name|status
operator|&
name|MOUSE_CUTTING
operator|)
operator|&&
operator|(
name|scp
operator|->
name|mouse_cut_start
operator|!=
name|NULL
operator|)
condition|)
block|{
name|mouse_cut
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|scp
operator|->
name|status
operator||=
name|MOUSE_CUTTING
expr_stmt|;
block|}
block|}
specifier|static
name|void
name|mouse_paste
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
if|if
condition|(
name|scp
operator|->
name|status
operator|&
name|MOUSE_VISIBLE
condition|)
block|{
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|u_char
modifier|*
name|ptr
init|=
name|cut_buffer
decl_stmt|;
name|tp
operator|=
name|VIRTUAL_TTY
argument_list|(
name|get_scr_num
argument_list|()
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|ptr
condition|)
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
name|scr_rmap
index|[
operator|*
name|ptr
operator|++
index|]
operator|,
name|tp
operator|)
expr_stmt|;
block|}
block|}
specifier|static
name|void
name|draw_mouse_image
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|PC98
operator|*
operator|(
name|Atrat
operator|+
operator|(
name|scp
operator|->
name|mouse_pos
operator|-
name|scp
operator|->
name|scr_buf
operator|)
operator|)
operator|^=
literal|0x4
expr_stmt|;
comment|/* reverse bit */
else|#
directive|else
name|caddr_t
name|address
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|font_buffer
decl_stmt|;
name|u_char
name|buf
index|[
name|PARAM_BUFSIZE
index|]
decl_stmt|;
name|u_short
name|buffer
index|[
literal|32
index|]
decl_stmt|;
name|u_short
name|xoffset
decl_stmt|,
name|yoffset
decl_stmt|;
name|u_short
modifier|*
name|crt_pos
init|=
name|Crtat
operator|+
operator|(
name|scp
operator|->
name|mouse_pos
operator|-
name|scp
operator|->
name|scr_buf
operator|)
decl_stmt|;
name|int
name|font_size
init|=
name|scp
operator|->
name|font_size
decl_stmt|;
if|if
condition|(
name|font_size
operator|<
literal|14
condition|)
block|{
name|font_buffer
operator|=
name|font_8
expr_stmt|;
name|address
operator|=
operator|(
name|caddr_t
operator|)
name|VIDEOMEM
operator|+
literal|0x8000
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|font_size
operator|>=
literal|16
condition|)
block|{
name|font_buffer
operator|=
name|font_16
expr_stmt|;
name|address
operator|=
operator|(
name|caddr_t
operator|)
name|VIDEOMEM
expr_stmt|;
block|}
else|else
block|{
name|font_buffer
operator|=
name|font_14
expr_stmt|;
name|address
operator|=
operator|(
name|caddr_t
operator|)
name|VIDEOMEM
operator|+
literal|0x4000
expr_stmt|;
block|}
name|xoffset
operator|=
name|scp
operator|->
name|mouse_xpos
operator|%
literal|8
expr_stmt|;
name|yoffset
operator|=
name|scp
operator|->
name|mouse_ypos
operator|%
name|font_size
expr_stmt|;
comment|/* prepare mousepointer char's bitmaps */
name|bcopy
argument_list|(
name|font_buffer
operator|+
operator|(
operator|(
operator|*
operator|(
name|scp
operator|->
name|mouse_pos
operator|)
operator|&
literal|0xff
operator|)
operator|*
name|font_size
operator|)
argument_list|,
operator|&
name|scp
operator|->
name|mouse_cursor
index|[
literal|0
index|]
argument_list|,
name|font_size
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|font_buffer
operator|+
operator|(
operator|(
operator|*
operator|(
name|scp
operator|->
name|mouse_pos
operator|+
literal|1
operator|)
operator|&
literal|0xff
operator|)
operator|*
name|font_size
operator|)
argument_list|,
operator|&
name|scp
operator|->
name|mouse_cursor
index|[
literal|32
index|]
argument_list|,
name|font_size
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|font_buffer
operator|+
operator|(
operator|(
operator|*
operator|(
name|scp
operator|->
name|mouse_pos
operator|+
name|scp
operator|->
name|xsize
operator|)
operator|&
literal|0xff
operator|)
operator|*
name|font_size
operator|)
argument_list|,
operator|&
name|scp
operator|->
name|mouse_cursor
index|[
literal|64
index|]
argument_list|,
name|font_size
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|font_buffer
operator|+
operator|(
operator|(
operator|*
operator|(
name|scp
operator|->
name|mouse_pos
operator|+
name|scp
operator|->
name|xsize
operator|+
literal|1
operator|)
operator|&
literal|0xff
operator|)
operator|*
name|font_size
operator|)
argument_list|,
operator|&
name|scp
operator|->
name|mouse_cursor
index|[
literal|96
index|]
argument_list|,
name|font_size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|font_size
condition|;
name|i
operator|++
control|)
block|{
name|buffer
index|[
name|i
index|]
operator|=
name|scp
operator|->
name|mouse_cursor
index|[
name|i
index|]
operator|<<
literal|8
operator||
name|scp
operator|->
name|mouse_cursor
index|[
name|i
operator|+
literal|32
index|]
expr_stmt|;
name|buffer
index|[
name|i
operator|+
name|font_size
index|]
operator|=
name|scp
operator|->
name|mouse_cursor
index|[
name|i
operator|+
literal|64
index|]
operator|<<
literal|8
operator||
name|scp
operator|->
name|mouse_cursor
index|[
name|i
operator|+
literal|96
index|]
expr_stmt|;
block|}
comment|/* now and-or in the mousepointer image */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|buffer
index|[
name|i
operator|+
name|yoffset
index|]
operator|=
operator|(
name|buffer
index|[
name|i
operator|+
name|yoffset
index|]
operator|&
operator|~
operator|(
name|mouse_and_mask
index|[
name|i
index|]
operator|>>
name|xoffset
operator|)
operator|)
operator||
operator|(
name|mouse_or_mask
index|[
name|i
index|]
operator|>>
name|xoffset
operator|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|font_size
condition|;
name|i
operator|++
control|)
block|{
name|scp
operator|->
name|mouse_cursor
index|[
name|i
index|]
operator|=
operator|(
name|buffer
index|[
name|i
index|]
operator|&
literal|0xff00
operator|)
operator|>>
literal|8
expr_stmt|;
name|scp
operator|->
name|mouse_cursor
index|[
name|i
operator|+
literal|32
index|]
operator|=
name|buffer
index|[
name|i
index|]
operator|&
literal|0xff
expr_stmt|;
name|scp
operator|->
name|mouse_cursor
index|[
name|i
operator|+
literal|64
index|]
operator|=
operator|(
name|buffer
index|[
name|i
operator|+
name|font_size
index|]
operator|&
literal|0xff00
operator|)
operator|>>
literal|8
expr_stmt|;
name|scp
operator|->
name|mouse_cursor
index|[
name|i
operator|+
literal|96
index|]
operator|=
name|buffer
index|[
name|i
operator|+
name|font_size
index|]
operator|&
literal|0xff
expr_stmt|;
block|}
endif|#
directive|endif
name|scp
operator|->
name|mouse_oldpos
operator|=
name|scp
operator|->
name|mouse_pos
expr_stmt|;
ifndef|#
directive|ifndef
name|PC98
if|#
directive|if
literal|1
comment|/* wait for vertical retrace to avoid jitter on some videocards */
while|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|crtc_addr
operator|+
literal|6
argument_list|)
operator|&
literal|0x08
operator|)
condition|)
comment|/* idle */
empty_stmt|;
endif|#
directive|endif
name|set_font_mode
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|sc_bcopy
argument_list|(
name|scp
operator|->
name|mouse_cursor
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pa_to_va
argument_list|(
name|address
argument_list|)
operator|+
literal|0xd0
operator|*
literal|32
argument_list|,
literal|128
argument_list|)
expr_stmt|;
name|set_normal_mode
argument_list|(
name|buf
argument_list|)
expr_stmt|;
operator|*
operator|(
name|crt_pos
operator|)
operator|=
operator|(
operator|*
operator|(
name|scp
operator|->
name|mouse_pos
operator|)
operator|&
literal|0xff00
operator|)
operator||
literal|0xd0
expr_stmt|;
operator|*
operator|(
name|crt_pos
operator|+
name|scp
operator|->
name|xsize
operator|)
operator|=
operator|(
operator|*
operator|(
name|scp
operator|->
name|mouse_pos
operator|+
name|scp
operator|->
name|xsize
operator|)
operator|&
literal|0xff00
operator|)
operator||
literal|0xd2
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|mouse_xpos
operator|<
operator|(
name|scp
operator|->
name|xsize
operator|-
literal|1
operator|)
operator|*
literal|8
condition|)
block|{
operator|*
operator|(
name|crt_pos
operator|+
literal|1
operator|)
operator|=
operator|(
operator|*
operator|(
name|scp
operator|->
name|mouse_pos
operator|+
literal|1
operator|)
operator|&
literal|0xff00
operator|)
operator||
literal|0xd1
expr_stmt|;
operator|*
operator|(
name|crt_pos
operator|+
name|scp
operator|->
name|xsize
operator|+
literal|1
operator|)
operator|=
operator|(
operator|*
operator|(
name|scp
operator|->
name|mouse_pos
operator|+
name|scp
operator|->
name|xsize
operator|+
literal|1
operator|)
operator|&
literal|0xff00
operator|)
operator||
literal|0xd3
expr_stmt|;
block|}
endif|#
directive|endif
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|mouse_oldpos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|PC98
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|mouse_oldpos
operator|+
name|scp
operator|->
name|xsize
operator|+
literal|1
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
specifier|static
name|void
name|remove_mouse_image
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|PC98
name|u_short
modifier|*
name|crt_pos
init|=
name|Atrat
operator|+
operator|(
name|scp
operator|->
name|mouse_oldpos
operator|-
name|scp
operator|->
name|scr_buf
operator|)
decl_stmt|;
else|#
directive|else
name|u_short
modifier|*
name|crt_pos
init|=
name|Crtat
operator|+
operator|(
name|scp
operator|->
name|mouse_oldpos
operator|-
name|scp
operator|->
name|scr_buf
operator|)
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PC98
operator|*
operator|(
name|crt_pos
operator|)
operator|=
operator|*
operator|(
name|scp
operator|->
name|atr_buf
operator|+
operator|(
name|scp
operator|->
name|mouse_oldpos
operator|-
name|scp
operator|->
name|scr_buf
operator|)
operator|)
expr_stmt|;
else|#
directive|else
operator|*
operator|(
name|crt_pos
operator|)
operator|=
operator|*
operator|(
name|scp
operator|->
name|mouse_oldpos
operator|)
expr_stmt|;
operator|*
operator|(
name|crt_pos
operator|+
literal|1
operator|)
operator|=
operator|*
operator|(
name|scp
operator|->
name|mouse_oldpos
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
operator|(
name|crt_pos
operator|+
name|scp
operator|->
name|xsize
operator|)
operator|=
operator|*
operator|(
name|scp
operator|->
name|mouse_oldpos
operator|+
name|scp
operator|->
name|xsize
operator|)
expr_stmt|;
operator|*
operator|(
name|crt_pos
operator|+
name|scp
operator|->
name|xsize
operator|+
literal|1
operator|)
operator|=
operator|*
operator|(
name|scp
operator|->
name|mouse_oldpos
operator|+
name|scp
operator|->
name|xsize
operator|+
literal|1
operator|)
expr_stmt|;
endif|#
directive|endif
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|mouse_oldpos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|PC98
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|mouse_oldpos
operator|+
name|scp
operator|->
name|xsize
operator|+
literal|1
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
specifier|static
name|void
name|draw_cutmarking
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
name|u_short
modifier|*
name|ptr
decl_stmt|;
name|u_short
name|och
decl_stmt|,
name|nch
decl_stmt|;
for|for
control|(
name|ptr
operator|=
name|scp
operator|->
name|scr_buf
init|;
name|ptr
operator|<=
operator|(
name|scp
operator|->
name|scr_buf
operator|+
operator|(
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
operator|)
operator|)
condition|;
name|ptr
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|PC98
name|nch
operator|=
name|och
operator|=
operator|*
operator|(
name|Atrat
operator|+
operator|(
name|ptr
operator|-
name|scp
operator|->
name|scr_buf
operator|)
operator|)
expr_stmt|;
else|#
directive|else
name|nch
operator|=
name|och
operator|=
operator|*
operator|(
name|Crtat
operator|+
operator|(
name|ptr
operator|-
name|scp
operator|->
name|scr_buf
operator|)
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* are we outside the selected area ? */
if|if
condition|(
name|ptr
operator|<
operator|(
name|scp
operator|->
name|mouse_cut_start
operator|>
name|scp
operator|->
name|mouse_cut_end
condition|?
name|scp
operator|->
name|mouse_cut_end
else|:
name|scp
operator|->
name|mouse_cut_start
operator|)
operator|||
name|ptr
operator|>=
operator|(
name|scp
operator|->
name|mouse_cut_start
operator|>
name|scp
operator|->
name|mouse_cut_end
condition|?
name|scp
operator|->
name|mouse_cut_start
else|:
name|scp
operator|->
name|mouse_cut_end
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|PC98
if|if
condition|(
name|ptr
operator|!=
name|scp
operator|->
name|mouse_pos
condition|)
name|nch
operator|=
operator|*
operator|(
name|scp
operator|->
name|atr_buf
operator|+
operator|(
name|ptr
operator|-
name|scp
operator|->
name|scr_buf
operator|)
operator|)
expr_stmt|;
else|else
name|nch
operator|=
operator|*
operator|(
name|scp
operator|->
name|atr_buf
operator|+
operator|(
name|ptr
operator|-
name|scp
operator|->
name|scr_buf
operator|)
operator|)
operator|^
literal|0x4
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|ptr
operator|!=
name|scp
operator|->
name|cursor_pos
condition|)
name|nch
operator|=
operator|(
name|och
operator|&
literal|0xff
operator|)
operator||
operator|(
operator|*
name|ptr
operator|&
literal|0xff00
operator|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|PC98
if|if
condition|(
name|ptr
operator|!=
name|scp
operator|->
name|mouse_pos
condition|)
name|nch
operator|=
operator|*
operator|(
name|scp
operator|->
name|atr_buf
operator|+
operator|(
name|ptr
operator|-
name|scp
operator|->
name|scr_buf
operator|)
operator|)
operator|^
literal|0x4
expr_stmt|;
comment|/* reverse bit */
else|#
directive|else
comment|/* are we clear of the cursor image ? */
if|if
condition|(
name|ptr
operator|!=
name|scp
operator|->
name|cursor_pos
condition|)
name|nch
operator|=
operator|(
name|och
operator|&
literal|0x88ff
operator|)
operator||
operator|(
operator|*
name|ptr
operator|&
literal|0x7000
operator|)
operator|>>
literal|4
operator||
operator|(
operator|*
name|ptr
operator|&
literal|0x0700
operator|)
operator|<<
literal|4
expr_stmt|;
else|else
block|{
if|if
condition|(
name|flags
operator|&
name|CHAR_CURSOR
condition|)
name|nch
operator|=
operator|(
name|och
operator|&
literal|0x88ff
operator|)
operator||
operator|(
operator|*
name|ptr
operator|&
literal|0x7000
operator|)
operator|>>
literal|4
operator||
operator|(
operator|*
name|ptr
operator|&
literal|0x0700
operator|)
operator|<<
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|BLINK_CURSOR
operator|)
condition|)
name|nch
operator|=
operator|(
name|och
operator|&
literal|0xff
operator|)
operator||
operator|(
operator|*
name|ptr
operator|&
literal|0xff00
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
if|if
condition|(
name|nch
operator|!=
name|och
condition|)
ifdef|#
directive|ifdef
name|PC98
operator|*
operator|(
name|Atrat
operator|+
operator|(
name|ptr
operator|-
name|scp
operator|->
name|scr_buf
operator|)
operator|)
operator|=
name|nch
expr_stmt|;
else|#
directive|else
operator|*
operator|(
name|Crtat
operator|+
operator|(
name|ptr
operator|-
name|scp
operator|->
name|scr_buf
operator|)
operator|)
operator|=
name|nch
expr_stmt|;
endif|#
directive|endif
block|}
block|}
specifier|static
name|void
name|remove_cutmarking
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
name|scp
operator|->
name|mouse_cut_start
operator|=
name|scp
operator|->
name|mouse_cut_end
operator|=
name|NULL
expr_stmt|;
name|scp
operator|->
name|status
operator|&=
operator|~
name|MOUSE_CUTTING
expr_stmt|;
name|mark_all
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|save_palette
parameter_list|(
name|void
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|PC98
name|int
name|i
decl_stmt|;
name|outb
argument_list|(
name|PALRADR
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0x00
init|;
name|i
operator|<
literal|0x300
condition|;
name|i
operator|++
control|)
name|palette
index|[
name|i
index|]
operator|=
name|inb
argument_list|(
name|PALDATA
argument_list|)
expr_stmt|;
name|inb
argument_list|(
name|crtc_addr
operator|+
literal|6
argument_list|)
expr_stmt|;
comment|/* reset flip/flop */
endif|#
directive|endif
block|}
name|void
name|load_palette
parameter_list|(
name|char
modifier|*
name|palette
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|PC98
name|int
name|i
decl_stmt|;
name|outb
argument_list|(
name|PIXMASK
argument_list|,
literal|0xFF
argument_list|)
expr_stmt|;
comment|/* no pixelmask */
name|outb
argument_list|(
name|PALWADR
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0x00
init|;
name|i
operator|<
literal|0x300
condition|;
name|i
operator|++
control|)
name|outb
argument_list|(
name|PALDATA
argument_list|,
name|palette
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|inb
argument_list|(
name|crtc_addr
operator|+
literal|6
argument_list|)
expr_stmt|;
comment|/* reset flip/flop */
name|outb
argument_list|(
name|ATC
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
comment|/* enable palette */
endif|#
directive|endif
block|}
specifier|static
name|void
name|do_bell
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|int
name|pitch
parameter_list|,
name|int
name|duration
parameter_list|)
block|{
if|if
condition|(
name|flags
operator|&
name|VISUAL_BELL
condition|)
block|{
if|if
condition|(
name|blink_in_progress
condition|)
return|return;
name|blink_in_progress
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|scp
operator|!=
name|cur_console
condition|)
name|blink_in_progress
operator|+=
literal|2
expr_stmt|;
name|blink_screen
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|scp
operator|!=
name|cur_console
condition|)
name|pitch
operator|*=
literal|2
expr_stmt|;
name|sysbeep
argument_list|(
name|pitch
argument_list|,
name|duration
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|PC98
comment|/* Save font and palette if VGA */
if|if
condition|(
name|crtc_vga
condition|)
block|{
if|if
condition|(
name|fonts_loaded
operator|&
name|FONT_16
condition|)
block|{
name|copy_font
argument_list|(
name|LOAD
argument_list|,
name|FONT_16
argument_list|,
name|font_16
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|copy_font
argument_list|(
name|SAVE
argument_list|,
name|FONT_16
argument_list|,
name|font_16
argument_list|)
expr_stmt|;
name|fonts_loaded
operator|=
name|FONT_16
expr_stmt|;
block|}
name|save_palette
argument_list|()
expr_stmt|;
name|set_destructive_cursor
argument_list|(
name|console
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SC_SPLASH_SCREEN
comment|/*       * Now put up a graphics image, and maybe cycle a      * couble of palette entries for simple animation.      */
name|toggle_splash_screen
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
specifier|static
name|void
name|blink_screen
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|scr_stat
modifier|*
name|scp
init|=
name|arg
decl_stmt|;
if|if
condition|(
operator|(
name|scp
operator|->
name|status
operator|&
name|UNKNOWN_MODE
operator|)
operator|||
operator|(
name|blink_in_progress
operator|<=
literal|1
operator|)
condition|)
block|{
name|blink_in_progress
operator|=
name|FALSE
expr_stmt|;
name|mark_all
argument_list|(
name|scp
argument_list|)
expr_stmt|;
if|if
condition|(
name|delayed_next_scr
condition|)
name|switch_scr
argument_list|(
name|scp
argument_list|,
name|delayed_next_scr
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|PC98
if|if
condition|(
name|blink_in_progress
operator|&
literal|1
condition|)
block|{
name|fillw
argument_list|(
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|Crtat
argument_list|,
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
argument_list|)
expr_stmt|;
name|fillw
argument_list|(
name|at2pc98
argument_list|(
name|kernel_default
operator|.
name|std_color
argument_list|)
argument_list|,
name|Atrat
argument_list|,
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fillw
argument_list|(
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|Crtat
argument_list|,
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
argument_list|)
expr_stmt|;
name|fillw
argument_list|(
name|at2pc98
argument_list|(
name|kernel_default
operator|.
name|rev_color
argument_list|)
argument_list|,
name|Atrat
argument_list|,
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|blink_in_progress
operator|&
literal|1
condition|)
name|fillw
argument_list|(
name|kernel_default
operator|.
name|std_color
operator||
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|Crtat
argument_list|,
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
argument_list|)
expr_stmt|;
else|else
name|fillw
argument_list|(
name|kernel_default
operator|.
name|rev_color
operator||
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|Crtat
argument_list|,
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|blink_in_progress
operator|--
expr_stmt|;
name|timeout
argument_list|(
name|blink_screen
argument_list|,
name|scp
argument_list|,
name|hz
operator|/
literal|10
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|SC_SPLASH_SCREEN
specifier|static
name|void
name|toggle_splash_screen
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
specifier|static
name|int
name|toggle
init|=
literal|0
decl_stmt|;
specifier|static
name|u_char
name|save_mode
decl_stmt|;
name|int
name|s
decl_stmt|;
ifndef|#
directive|ifndef
name|PC98
if|if
condition|(
name|video_mode_ptr
operator|==
name|NULL
condition|)
return|return;
endif|#
directive|endif
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
if|if
condition|(
name|toggle
condition|)
block|{
name|scp
operator|->
name|mode
operator|=
name|save_mode
expr_stmt|;
name|scp
operator|->
name|status
operator|&=
operator|~
name|UNKNOWN_MODE
expr_stmt|;
name|set_mode
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|load_palette
argument_list|(
name|palette
argument_list|)
expr_stmt|;
name|toggle
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|save_mode
operator|=
name|scp
operator|->
name|mode
expr_stmt|;
name|scp
operator|->
name|mode
operator|=
name|M_VGA_CG320
expr_stmt|;
name|scp
operator|->
name|status
operator||=
name|UNKNOWN_MODE
expr_stmt|;
name|set_mode
argument_list|(
name|scp
argument_list|)
expr_stmt|;
comment|/* load image */
name|toggle
operator|=
literal|1
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PC98
argument_list|)
operator|&&
name|defined
argument_list|(
name|LINE30
argument_list|)
comment|/* 30line */
specifier|static
name|void
name|master_gdc_cmd
parameter_list|(
name|unsigned
name|int
name|cmd
parameter_list|)
block|{
while|while
condition|(
operator|(
name|inb
argument_list|(
literal|0x60
argument_list|)
operator|&
literal|2
operator|)
operator|!=
literal|0
condition|)
empty_stmt|;
name|outb
argument_list|(
literal|0x62
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|master_gdc_prm
parameter_list|(
name|unsigned
name|int
name|pmtr
parameter_list|)
block|{
while|while
condition|(
operator|(
name|inb
argument_list|(
literal|0x60
argument_list|)
operator|&
literal|2
operator|)
operator|!=
literal|0
condition|)
empty_stmt|;
name|outb
argument_list|(
literal|0x60
argument_list|,
name|pmtr
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|master_gdc_word_prm
parameter_list|(
name|unsigned
name|int
name|wpmtr
parameter_list|)
block|{
name|master_gdc_prm
argument_list|(
name|wpmtr
operator|&
literal|0x00ff
argument_list|)
expr_stmt|;
name|master_gdc_prm
argument_list|(
operator|(
name|wpmtr
operator|>>
literal|8
operator|)
operator|&
literal|0x00ff
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|master_gdc_fifo_empty
parameter_list|(
name|void
parameter_list|)
block|{
while|while
condition|(
operator|(
name|inb
argument_list|(
literal|0x60
argument_list|)
operator|&
literal|4
operator|)
operator|==
literal|0
condition|)
empty_stmt|;
block|}
specifier|static
name|void
name|master_gdc_wait_vsync
parameter_list|(
name|void
parameter_list|)
block|{
while|while
condition|(
operator|(
name|inb
argument_list|(
literal|0x60
argument_list|)
operator|&
literal|0x20
operator|)
operator|!=
literal|0
condition|)
empty_stmt|;
while|while
condition|(
operator|(
name|inb
argument_list|(
literal|0x60
argument_list|)
operator|&
literal|0x20
operator|)
operator|==
literal|0
condition|)
empty_stmt|;
block|}
specifier|static
name|void
name|gdc_cmd
parameter_list|(
name|unsigned
name|int
name|cmd
parameter_list|)
block|{
while|while
condition|(
operator|(
name|inb
argument_list|(
literal|0xa0
argument_list|)
operator|&
literal|2
operator|)
operator|!=
literal|0
condition|)
empty_stmt|;
name|outb
argument_list|(
literal|0xa2
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|gdc_prm
parameter_list|(
name|unsigned
name|int
name|pmtr
parameter_list|)
block|{
while|while
condition|(
operator|(
name|inb
argument_list|(
literal|0xa0
argument_list|)
operator|&
literal|2
operator|)
operator|!=
literal|0
condition|)
empty_stmt|;
name|outb
argument_list|(
literal|0xa0
argument_list|,
name|pmtr
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|gdc_word_prm
parameter_list|(
name|unsigned
name|int
name|wpmtr
parameter_list|)
block|{
name|gdc_prm
argument_list|(
name|wpmtr
operator|&
literal|0x00ff
argument_list|)
expr_stmt|;
name|gdc_prm
argument_list|(
operator|(
name|wpmtr
operator|>>
literal|8
operator|)
operator|&
literal|0x00ff
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|gdc_fifo_empty
parameter_list|(
name|void
parameter_list|)
block|{
while|while
condition|(
operator|(
name|inb
argument_list|(
literal|0xa0
argument_list|)
operator|&
literal|0x04
operator|)
operator|==
literal|0
condition|)
empty_stmt|;
block|}
specifier|static
name|void
name|gdc_wait_vsync
parameter_list|(
name|void
parameter_list|)
block|{
while|while
condition|(
operator|(
name|inb
argument_list|(
literal|0xa0
argument_list|)
operator|&
literal|0x20
operator|)
operator|!=
literal|0
condition|)
empty_stmt|;
while|while
condition|(
operator|(
name|inb
argument_list|(
literal|0xa0
argument_list|)
operator|&
literal|0x20
operator|)
operator|==
literal|0
condition|)
empty_stmt|;
block|}
specifier|static
name|int
name|check_gdc_clock
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|(
name|inb
argument_list|(
literal|0x31
argument_list|)
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
block|{
return|return
name|_5MHZ
return|;
block|}
else|else
block|{
return|return
name|_2_5MHZ
return|;
block|}
block|}
specifier|static
name|void
name|initialize_gdc
parameter_list|(
name|unsigned
name|int
name|mode
parameter_list|)
block|{
comment|/* start 30line initialize */
name|int
name|m_mode
decl_stmt|,
name|s_mode
decl_stmt|,
name|gdc_clock
decl_stmt|;
name|gdc_clock
operator|=
name|check_gdc_clock
argument_list|()
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|T25_G400
condition|)
block|{
name|m_mode
operator|=
name|_25L
expr_stmt|;
block|}
else|else
block|{
name|m_mode
operator|=
name|_30L
expr_stmt|;
block|}
name|s_mode
operator|=
literal|2
operator|*
name|mode
operator|+
name|gdc_clock
expr_stmt|;
name|gdc_INFO
operator|=
name|m_mode
expr_stmt|;
name|master_gdc_cmd
argument_list|(
name|_GDC_RESET
argument_list|)
expr_stmt|;
name|master_gdc_cmd
argument_list|(
name|_GDC_MASTER
argument_list|)
expr_stmt|;
name|gdc_cmd
argument_list|(
name|_GDC_RESET
argument_list|)
expr_stmt|;
name|gdc_cmd
argument_list|(
name|_GDC_SLAVE
argument_list|)
expr_stmt|;
comment|/* GDC Master */
name|master_gdc_cmd
argument_list|(
name|_GDC_SYNC
argument_list|)
expr_stmt|;
name|master_gdc_prm
argument_list|(
literal|0x00
argument_list|)
expr_stmt|;
comment|/* flush less */
comment|/* text& graph */
name|master_gdc_prm
argument_list|(
name|master_param
index|[
name|m_mode
index|]
index|[
name|GDC_CR
index|]
argument_list|)
expr_stmt|;
name|master_gdc_word_prm
argument_list|(
operator|(
operator|(
name|master_param
index|[
name|m_mode
index|]
index|[
name|GDC_HFP
index|]
operator|<<
literal|10
operator|)
operator|+
operator|(
name|master_param
index|[
name|m_mode
index|]
index|[
name|GDC_VS
index|]
operator|<<
literal|5
operator|)
operator|+
name|master_param
index|[
name|m_mode
index|]
index|[
name|GDC_HS
index|]
operator|)
argument_list|)
expr_stmt|;
name|master_gdc_prm
argument_list|(
name|master_param
index|[
name|m_mode
index|]
index|[
name|GDC_HBP
index|]
argument_list|)
expr_stmt|;
name|master_gdc_prm
argument_list|(
name|master_param
index|[
name|m_mode
index|]
index|[
name|GDC_VFP
index|]
argument_list|)
expr_stmt|;
name|master_gdc_word_prm
argument_list|(
operator|(
operator|(
name|master_param
index|[
name|m_mode
index|]
index|[
name|GDC_VBP
index|]
operator|<<
literal|10
operator|)
operator|+
operator|(
name|master_param
index|[
name|m_mode
index|]
index|[
name|GDC_LF
index|]
operator|)
operator|)
argument_list|)
expr_stmt|;
name|master_gdc_fifo_empty
argument_list|()
expr_stmt|;
name|master_gdc_cmd
argument_list|(
name|_GDC_PITCH
argument_list|)
expr_stmt|;
name|master_gdc_prm
argument_list|(
name|MasterPCH
argument_list|)
expr_stmt|;
name|master_gdc_fifo_empty
argument_list|()
expr_stmt|;
comment|/* GDC slave */
name|gdc_cmd
argument_list|(
name|_GDC_SYNC
argument_list|)
expr_stmt|;
name|gdc_prm
argument_list|(
literal|0x06
argument_list|)
expr_stmt|;
name|gdc_prm
argument_list|(
name|slave_param
index|[
name|s_mode
index|]
index|[
name|GDC_CR
index|]
argument_list|)
expr_stmt|;
name|gdc_word_prm
argument_list|(
operator|(
name|slave_param
index|[
name|s_mode
index|]
index|[
name|GDC_HFP
index|]
operator|<<
literal|10
operator|)
operator|+
operator|(
name|slave_param
index|[
name|s_mode
index|]
index|[
name|GDC_VS
index|]
operator|<<
literal|5
operator|)
operator|+
operator|(
name|slave_param
index|[
name|s_mode
index|]
index|[
name|GDC_HS
index|]
operator|)
argument_list|)
expr_stmt|;
name|gdc_prm
argument_list|(
name|slave_param
index|[
name|s_mode
index|]
index|[
name|GDC_HBP
index|]
argument_list|)
expr_stmt|;
name|gdc_prm
argument_list|(
name|slave_param
index|[
name|s_mode
index|]
index|[
name|GDC_VFP
index|]
argument_list|)
expr_stmt|;
name|gdc_word_prm
argument_list|(
operator|(
name|slave_param
index|[
name|s_mode
index|]
index|[
name|GDC_VBP
index|]
operator|<<
literal|10
operator|)
operator|+
operator|(
name|slave_param
index|[
name|s_mode
index|]
index|[
name|GDC_LF
index|]
operator|)
argument_list|)
expr_stmt|;
name|gdc_fifo_empty
argument_list|()
expr_stmt|;
name|gdc_cmd
argument_list|(
name|_GDC_PITCH
argument_list|)
expr_stmt|;
name|gdc_prm
argument_list|(
name|SlavePCH
index|[
name|gdc_clock
index|]
argument_list|)
expr_stmt|;
name|gdc_fifo_empty
argument_list|()
expr_stmt|;
comment|/* set Master GDC scroll param */
name|master_gdc_wait_vsync
argument_list|()
expr_stmt|;
name|master_gdc_wait_vsync
argument_list|()
expr_stmt|;
name|master_gdc_wait_vsync
argument_list|()
expr_stmt|;
name|master_gdc_cmd
argument_list|(
name|_GDC_SCROLL
argument_list|)
expr_stmt|;
name|master_gdc_word_prm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|master_gdc_word_prm
argument_list|(
operator|(
name|master_param
index|[
name|m_mode
index|]
index|[
name|GDC_LF
index|]
operator|<<
literal|4
operator|)
operator||
literal|0x0000
argument_list|)
expr_stmt|;
name|master_gdc_fifo_empty
argument_list|()
expr_stmt|;
comment|/* set Slave GDC scroll param */
name|gdc_wait_vsync
argument_list|()
expr_stmt|;
name|gdc_cmd
argument_list|(
name|_GDC_SCROLL
argument_list|)
expr_stmt|;
name|gdc_word_prm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|gdc_clock
operator|==
name|_5MHZ
condition|)
block|{
name|gdc_word_prm
argument_list|(
operator|(
name|SlaveScrlLF
index|[
name|mode
index|]
operator|<<
literal|4
operator|)
operator||
literal|0x4000
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gdc_word_prm
argument_list|(
name|SlaveScrlLF
index|[
name|mode
index|]
operator|<<
literal|4
argument_list|)
expr_stmt|;
block|}
name|gdc_fifo_empty
argument_list|()
expr_stmt|;
name|gdc_word_prm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|gdc_clock
operator|==
name|_5MHZ
condition|)
block|{
name|gdc_word_prm
argument_list|(
operator|(
name|SlaveScrlLF
index|[
name|mode
index|]
operator|<<
literal|4
operator|)
operator||
literal|0x4000
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gdc_word_prm
argument_list|(
name|SlaveScrlLF
index|[
name|mode
index|]
operator|<<
literal|4
argument_list|)
expr_stmt|;
block|}
name|gdc_fifo_empty
argument_list|()
expr_stmt|;
comment|/* sync start */
name|gdc_cmd
argument_list|(
name|_GDC_STOP
argument_list|)
expr_stmt|;
name|gdc_wait_vsync
argument_list|()
expr_stmt|;
name|gdc_wait_vsync
argument_list|()
expr_stmt|;
name|gdc_wait_vsync
argument_list|()
expr_stmt|;
name|master_gdc_cmd
argument_list|(
name|_GDC_START
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* 30 line */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NSC */
end_comment

end_unit

