begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * sound/opl3.c  *  * A low level driver for Yamaha YM3812 and OPL-3 -chips  *  * Copyright by Hannu Savolainen 1993  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met: 1. Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer. 2.  * Redistributions in binary form must reproduce the above copyright notice,  * this list of conditions and the following disclaimer in the documentation  * and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_comment
comment|/*  * Major improvements to the FM handling 30AUG92 by Rob Hooft,  */
end_comment

begin_comment
comment|/*  * hooft@chem.ruu.nl  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PC98
end_ifdef

begin_include
include|#
directive|include
file|<pc98/pc98/sound/sound_config.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<i386/isa/sound/sound_config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CONFIGURE_SOUNDCARD
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|EXCLUDE_YM3812
argument_list|)
end_if

begin_include
include|#
directive|include
file|<i386/isa/sound/opl3.h>
end_include

begin_define
define|#
directive|define
name|MAX_VOICE
value|18
end_define

begin_define
define|#
directive|define
name|OFFS_4OP
value|11
end_define

begin_comment
comment|/* 				   * * * Definitions for the operators OP3 and 				   * * OP4 * * begin here   */
end_comment

begin_decl_stmt
specifier|static
name|int
name|opl3_enabled
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|opl4_enabled
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|PC98
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|left_address
init|=
literal|0x28d2
decl_stmt|,
name|right_address
init|=
literal|0x28d2
decl_stmt|,
name|both_address
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|int
name|left_address
init|=
literal|0x388
decl_stmt|,
name|right_address
init|=
literal|0x388
decl_stmt|,
name|both_address
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|nr_voices
init|=
literal|9
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|logical_voices
index|[
name|MAX_VOICE
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|,
literal|17
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|voice_info
block|{
name|unsigned
name|char
name|keyon_byte
decl_stmt|;
name|long
name|bender
decl_stmt|;
name|long
name|bender_range
decl_stmt|;
name|unsigned
name|long
name|orig_freq
decl_stmt|;
name|unsigned
name|long
name|current_freq
decl_stmt|;
name|int
name|mode
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|voice_info
name|voices
index|[
name|MAX_VOICE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|voice_alloc_info
modifier|*
name|voice_alloc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|channel_info
modifier|*
name|chn_info
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|sbi_instrument
modifier|*
name|instrmap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|sbi_instrument
modifier|*
name|active_instrument
index|[
name|MAX_VOICE
index|]
init|=
block|{
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|synth_info
name|fm_info
init|=
block|{
literal|"OPL-2"
block|,
literal|0
block|,
name|SYNTH_TYPE_FM
block|,
name|FM_TYPE_ADLIB
block|,
literal|0
block|,
literal|9
block|,
literal|0
block|,
name|SBFM_MAXINSTR
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|already_initialized
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|opl3_ok
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|opl3_busy
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fm_model
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   				 * *  * * 0=no fm, 1=mono, 2=SB Pro 1, 3=SB 				 * Pro 2 * *    */
end_comment

begin_function_decl
specifier|static
name|int
name|store_instr
parameter_list|(
name|int
name|instr_no
parameter_list|,
name|struct
name|sbi_instrument
modifier|*
name|instr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|freq_to_fnum
parameter_list|(
name|int
name|freq
parameter_list|,
name|int
modifier|*
name|block
parameter_list|,
name|int
modifier|*
name|fnum
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|opl3_command
parameter_list|(
name|int
name|io_addr
parameter_list|,
name|unsigned
name|int
name|addr
parameter_list|,
name|unsigned
name|int
name|val
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|opl3_kill_note
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|note
parameter_list|,
name|int
name|velocity
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|connection_mask
init|=
literal|0x00
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|enable_opl3_mode
parameter_list|(
name|int
name|left
parameter_list|,
name|int
name|right
parameter_list|,
name|int
name|both
parameter_list|)
block|{
if|if
condition|(
name|opl3_enabled
condition|)
return|return;
name|opl3_enabled
operator|=
literal|1
expr_stmt|;
name|left_address
operator|=
name|left
expr_stmt|;
name|right_address
operator|=
name|right
expr_stmt|;
name|both_address
operator|=
name|both
expr_stmt|;
name|fm_info
operator|.
name|capabilities
operator|=
name|SYNTH_CAP_OPL3
expr_stmt|;
name|fm_info
operator|.
name|synth_subtype
operator|=
name|FM_TYPE_OPL3
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|enter_4op_mode
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|static
name|int
name|voices_4op
index|[
name|MAX_VOICE
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|15
block|,
literal|16
block|,
literal|17
block|}
decl_stmt|;
name|connection_mask
operator|=
literal|0x3f
expr_stmt|;
comment|/* Connect all possible 4 OP voices */
name|opl3_command
argument_list|(
name|right_address
argument_list|,
name|CONNECTION_SELECT_REGISTER
argument_list|,
literal|0x3f
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
name|physical_voices
index|[
name|i
index|]
operator|.
name|voice_mode
operator|=
literal|4
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|3
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
name|physical_voices
index|[
name|i
index|]
operator|.
name|voice_mode
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|9
init|;
name|i
operator|<
literal|12
condition|;
name|i
operator|++
control|)
name|physical_voices
index|[
name|i
index|]
operator|.
name|voice_mode
operator|=
literal|4
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|12
init|;
name|i
operator|<
literal|15
condition|;
name|i
operator|++
control|)
name|physical_voices
index|[
name|i
index|]
operator|.
name|voice_mode
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|12
condition|;
name|i
operator|++
control|)
name|logical_voices
index|[
name|i
index|]
operator|=
name|voices_4op
index|[
name|i
index|]
expr_stmt|;
name|voice_alloc
operator|->
name|max_voice
operator|=
name|nr_voices
operator|=
literal|12
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|opl3_ioctl
parameter_list|(
name|int
name|dev
parameter_list|,
name|unsigned
name|int
name|cmd
parameter_list|,
name|unsigned
name|int
name|arg
parameter_list|)
block|{
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SNDCTL_FM_LOAD_INSTR
case|:
block|{
name|struct
name|sbi_instrument
name|ins
decl_stmt|;
name|IOCTL_FROM_USER
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ins
argument_list|,
operator|(
name|char
operator|*
operator|)
name|arg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ins
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ins
operator|.
name|channel
operator|<
literal|0
operator|||
name|ins
operator|.
name|channel
operator|>=
name|SBFM_MAXINSTR
condition|)
block|{
name|printk
argument_list|(
literal|"FM Error: Invalid instrument number %d\n"
argument_list|,
name|ins
operator|.
name|channel
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|pmgr_inform
argument_list|(
name|dev
argument_list|,
name|PM_E_PATCH_LOADED
argument_list|,
name|ins
operator|.
name|channel
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|store_instr
argument_list|(
name|ins
operator|.
name|channel
argument_list|,
operator|&
name|ins
argument_list|)
return|;
block|}
break|break;
case|case
name|SNDCTL_SYNTH_INFO
case|:
name|fm_info
operator|.
name|nr_voices
operator|=
operator|(
name|nr_voices
operator|==
literal|12
operator|)
condition|?
literal|6
else|:
name|nr_voices
expr_stmt|;
name|IOCTL_TO_USER
argument_list|(
operator|(
name|char
operator|*
operator|)
name|arg
argument_list|,
literal|0
argument_list|,
operator|&
name|fm_info
argument_list|,
sizeof|sizeof
argument_list|(
name|fm_info
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
break|break;
case|case
name|SNDCTL_SYNTH_MEMAVL
case|:
return|return
literal|0x7fffffff
return|;
break|break;
case|case
name|SNDCTL_FM_4OP_ENABLE
case|:
if|if
condition|(
name|opl3_enabled
condition|)
name|enter_4op_mode
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
break|break;
default|default:
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
block|}
end_function

begin_function
name|int
name|opl3_detect
parameter_list|(
name|int
name|ioaddr
parameter_list|)
block|{
comment|/*    * This function returns 1 if the FM chicp is present at the given I/O port    * The detection algorithm plays with the timer built in the FM chip and    * looks for a change in the status register.    *    * Note! The timers of the FM chip are not connected to AdLib (and compatible)    * boards.    *    * Note2! The chip is initialized if detected.    */
name|unsigned
name|char
name|stat1
decl_stmt|,
name|stat2
decl_stmt|,
name|signature
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|already_initialized
condition|)
block|{
return|return
literal|0
return|;
comment|/* 				 * Do avoid duplicate initializations 				 */
block|}
if|if
condition|(
name|opl3_enabled
condition|)
name|ioaddr
operator|=
name|left_address
expr_stmt|;
comment|/* Reset timers 1 and 2 */
name|opl3_command
argument_list|(
name|ioaddr
argument_list|,
name|TIMER_CONTROL_REGISTER
argument_list|,
name|TIMER1_MASK
operator||
name|TIMER2_MASK
argument_list|)
expr_stmt|;
comment|/* Reset the IRQ of the FM chip */
name|opl3_command
argument_list|(
name|ioaddr
argument_list|,
name|TIMER_CONTROL_REGISTER
argument_list|,
name|IRQ_RESET
argument_list|)
expr_stmt|;
name|signature
operator|=
name|stat1
operator|=
name|INB
argument_list|(
name|ioaddr
argument_list|)
expr_stmt|;
comment|/* Status register */
if|if
condition|(
operator|(
name|stat1
operator|&
literal|0xE0
operator|)
operator|!=
literal|0x00
condition|)
block|{
return|return
literal|0
return|;
comment|/* 				 * Should be 0x00 				 */
block|}
name|opl3_command
argument_list|(
name|ioaddr
argument_list|,
name|TIMER1_REGISTER
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* Set timer1 to 0xff */
name|opl3_command
argument_list|(
name|ioaddr
argument_list|,
name|TIMER_CONTROL_REGISTER
argument_list|,
name|TIMER2_MASK
operator||
name|TIMER1_START
argument_list|)
expr_stmt|;
comment|/* 						 * Unmask and start timer 1 						 */
comment|/*    * Now we have to delay at least 80 usec    */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|50
condition|;
name|i
operator|++
control|)
name|tenmicrosec
argument_list|()
expr_stmt|;
name|stat2
operator|=
name|INB
argument_list|(
name|ioaddr
argument_list|)
expr_stmt|;
comment|/* 				 * Read status after timers have expired 				 */
comment|/*    * Stop the timers    */
comment|/* Reset timers 1 and 2 */
name|opl3_command
argument_list|(
name|ioaddr
argument_list|,
name|TIMER_CONTROL_REGISTER
argument_list|,
name|TIMER1_MASK
operator||
name|TIMER2_MASK
argument_list|)
expr_stmt|;
comment|/* Reset the IRQ of the FM chip */
name|opl3_command
argument_list|(
name|ioaddr
argument_list|,
name|TIMER_CONTROL_REGISTER
argument_list|,
name|IRQ_RESET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stat2
operator|&
literal|0xE0
operator|)
operator|!=
literal|0xc0
condition|)
block|{
return|return
literal|0
return|;
comment|/* 				 * There is no YM3812 				 */
block|}
comment|/*    * There is a FM chicp in this address. Detect the type (OPL2 to OPL4)    */
if|if
condition|(
name|signature
operator|==
literal|0x06
condition|)
comment|/* OPL2 */
block|{
name|opl3_enabled
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|signature
operator|==
literal|0x00
condition|)
comment|/* OPL3 or OPL4 */
block|{
name|unsigned
name|char
name|tmp
decl_stmt|;
if|if
condition|(
operator|!
name|opl3_enabled
condition|)
comment|/* Was not already enabled */
block|{
name|left_address
operator|=
name|ioaddr
expr_stmt|;
name|right_address
operator|=
name|ioaddr
operator|+
literal|2
expr_stmt|;
name|opl3_enabled
operator|=
literal|1
expr_stmt|;
block|}
comment|/*        * Detect availability of OPL4 (_experimental_). Works propably        * only after a cold boot. In addition the OPL4 port        * of the chip may not be connected to the PC bus at all.        */
name|opl3_command
argument_list|(
name|right_address
argument_list|,
name|OPL3_MODE_REGISTER
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|opl3_command
argument_list|(
name|right_address
argument_list|,
name|OPL3_MODE_REGISTER
argument_list|,
name|OPL3_ENABLE
operator||
name|OPL4_ENABLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tmp
operator|=
name|INB
argument_list|(
name|ioaddr
argument_list|)
operator|)
operator|==
literal|0x02
condition|)
comment|/* Have a OPL4 */
block|{
name|opl4_enabled
operator|=
literal|1
expr_stmt|;
block|}
name|opl3_command
argument_list|(
name|right_address
argument_list|,
name|OPL3_MODE_REGISTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|9
condition|;
name|i
operator|++
control|)
name|opl3_command
argument_list|(
name|ioaddr
argument_list|,
name|KEYON_BLOCK
operator|+
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 						 * Note off 						 */
name|opl3_command
argument_list|(
name|ioaddr
argument_list|,
name|TEST_REGISTER
argument_list|,
name|ENABLE_WAVE_SELECT
argument_list|)
expr_stmt|;
name|opl3_command
argument_list|(
name|ioaddr
argument_list|,
name|PERCUSSION_REGISTER
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* 							 * Melodic mode. 							 */
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|opl3_kill_note
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|note
parameter_list|,
name|int
name|velocity
parameter_list|)
block|{
name|struct
name|physical_voice_info
modifier|*
name|map
decl_stmt|;
if|if
condition|(
name|voice
operator|<
literal|0
operator|||
name|voice
operator|>=
name|nr_voices
condition|)
return|return
literal|0
return|;
name|voice_alloc
operator|->
name|map
index|[
name|voice
index|]
operator|=
literal|0
expr_stmt|;
name|map
operator|=
operator|&
name|physical_voices
index|[
name|logical_voices
index|[
name|voice
index|]
index|]
expr_stmt|;
name|DEB
argument_list|(
name|printk
argument_list|(
literal|"Kill note %d\n"
argument_list|,
name|voice
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|->
name|voice_mode
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|opl3_command
argument_list|(
name|map
operator|->
name|ioaddr
argument_list|,
name|KEYON_BLOCK
operator|+
name|map
operator|->
name|voice_num
argument_list|,
name|voices
index|[
name|voice
index|]
operator|.
name|keyon_byte
operator|&
operator|~
literal|0x20
argument_list|)
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|keyon_byte
operator|=
literal|0
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|bender
operator|=
literal|0
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|bender_range
operator|=
literal|200
expr_stmt|;
comment|/* 					 * 200 cents = 2 semitones 					 */
name|voices
index|[
name|voice
index|]
operator|.
name|orig_freq
operator|=
literal|0
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|current_freq
operator|=
literal|0
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|mode
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_define
define|#
directive|define
name|HIHAT
value|0
end_define

begin_define
define|#
directive|define
name|CYMBAL
value|1
end_define

begin_define
define|#
directive|define
name|TOMTOM
value|2
end_define

begin_define
define|#
directive|define
name|SNARE
value|3
end_define

begin_define
define|#
directive|define
name|BDRUM
value|4
end_define

begin_define
define|#
directive|define
name|UNDEFINED
value|TOMTOM
end_define

begin_define
define|#
directive|define
name|DEFAULT
value|TOMTOM
end_define

begin_function
specifier|static
name|int
name|store_instr
parameter_list|(
name|int
name|instr_no
parameter_list|,
name|struct
name|sbi_instrument
modifier|*
name|instr
parameter_list|)
block|{
if|if
condition|(
name|instr
operator|->
name|key
operator|!=
name|FM_PATCH
operator|&&
operator|(
name|instr
operator|->
name|key
operator|!=
name|OPL3_PATCH
operator|||
operator|!
name|opl3_enabled
operator|)
condition|)
name|printk
argument_list|(
literal|"FM warning: Invalid patch format field (key) 0x%x\n"
argument_list|,
name|instr
operator|->
name|key
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|instrmap
index|[
name|instr_no
index|]
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|instr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|instr
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|opl3_set_instr
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|instr_no
parameter_list|)
block|{
if|if
condition|(
name|voice
operator|<
literal|0
operator|||
name|voice
operator|>=
name|nr_voices
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|instr_no
operator|<
literal|0
operator|||
name|instr_no
operator|>=
name|SBFM_MAXINSTR
condition|)
return|return
literal|0
return|;
name|active_instrument
index|[
name|voice
index|]
operator|=
operator|&
name|instrmap
index|[
name|instr_no
index|]
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * The next table looks magical, but it certainly is not. Its values have  * been calculated as table[i]=8*log(i/64)/log(2) with an obvious exception  * for i=0. This log-table converts a linear volume-scaling (0..127) to a  * logarithmic scaling as present in the FM-synthesizer chips. so :    Volume  * 64 =  0 db = relative volume  0 and:    Volume 32 = -6 db = relative  * volume -8 it was implemented as a table because it is only 128 bytes and  * it saves a lot of log() calculations. (RH)  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|fm_volume_table
index|[
literal|128
index|]
init|=
block|{
operator|-
literal|64
block|,
operator|-
literal|48
block|,
operator|-
literal|40
block|,
operator|-
literal|35
block|,
operator|-
literal|32
block|,
operator|-
literal|29
block|,
operator|-
literal|27
block|,
operator|-
literal|26
block|,
comment|/* 						 * 0 -   7 						 */
operator|-
literal|24
block|,
operator|-
literal|23
block|,
operator|-
literal|21
block|,
operator|-
literal|20
block|,
operator|-
literal|19
block|,
operator|-
literal|18
block|,
operator|-
literal|18
block|,
operator|-
literal|17
block|,
comment|/* 						 * 8 -  15 						 */
operator|-
literal|16
block|,
operator|-
literal|15
block|,
operator|-
literal|15
block|,
operator|-
literal|14
block|,
operator|-
literal|13
block|,
operator|-
literal|13
block|,
operator|-
literal|12
block|,
operator|-
literal|12
block|,
comment|/* 						 * 16 -  23 						 */
operator|-
literal|11
block|,
operator|-
literal|11
block|,
operator|-
literal|10
block|,
operator|-
literal|10
block|,
operator|-
literal|10
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|8
block|,
comment|/* 					 * 24 -  31 					 */
operator|-
literal|8
block|,
operator|-
literal|8
block|,
operator|-
literal|7
block|,
operator|-
literal|7
block|,
operator|-
literal|7
block|,
operator|-
literal|6
block|,
operator|-
literal|6
block|,
operator|-
literal|6
block|,
comment|/* 					   * 32 -  39 					 */
operator|-
literal|5
block|,
operator|-
literal|5
block|,
operator|-
literal|5
block|,
operator|-
literal|5
block|,
operator|-
literal|4
block|,
operator|-
literal|4
block|,
operator|-
literal|4
block|,
operator|-
literal|4
block|,
comment|/* 					   * 40 -  47 					 */
operator|-
literal|3
block|,
operator|-
literal|3
block|,
operator|-
literal|3
block|,
operator|-
literal|3
block|,
operator|-
literal|2
block|,
operator|-
literal|2
block|,
operator|-
literal|2
block|,
operator|-
literal|2
block|,
comment|/* 					   * 48 -  55 					 */
operator|-
literal|2
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 				 * 56 -  63 				 */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* 				 * 64 -  71 				 */
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
comment|/* 				 * 72 -  79 				 */
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
comment|/* 				 * 80 -  87 				 */
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|5
block|,
comment|/* 				 * 88 -  95 				 */
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
comment|/* 				 * 96 - 103 				 */
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
comment|/* 				 * 104 - 111 				 */
literal|6
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
comment|/* 				 * 112 - 119 				 */
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   				 * *  * * 120 - 127   */
end_comment

begin_function
specifier|static
name|void
name|calc_vol
parameter_list|(
name|unsigned
name|char
modifier|*
name|regbyte
parameter_list|,
name|int
name|volume
parameter_list|)
block|{
name|int
name|level
init|=
operator|(
operator|~
operator|*
name|regbyte
operator|&
literal|0x3f
operator|)
decl_stmt|;
if|if
condition|(
name|level
condition|)
name|level
operator|+=
name|fm_volume_table
index|[
name|volume
index|]
expr_stmt|;
if|if
condition|(
name|level
operator|>
literal|0x3f
condition|)
name|level
operator|=
literal|0x3f
expr_stmt|;
if|if
condition|(
name|level
operator|<
literal|0
condition|)
name|level
operator|=
literal|0
expr_stmt|;
operator|*
name|regbyte
operator|=
operator|(
operator|*
name|regbyte
operator|&
literal|0xc0
operator|)
operator||
operator|(
operator|~
name|level
operator|&
literal|0x3f
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_voice_volume
parameter_list|(
name|int
name|voice
parameter_list|,
name|int
name|volume
parameter_list|)
block|{
name|unsigned
name|char
name|vol1
decl_stmt|,
name|vol2
decl_stmt|,
name|vol3
decl_stmt|,
name|vol4
decl_stmt|;
name|struct
name|sbi_instrument
modifier|*
name|instr
decl_stmt|;
name|struct
name|physical_voice_info
modifier|*
name|map
decl_stmt|;
if|if
condition|(
name|voice
operator|<
literal|0
operator|||
name|voice
operator|>=
name|nr_voices
condition|)
return|return;
name|map
operator|=
operator|&
name|physical_voices
index|[
name|logical_voices
index|[
name|voice
index|]
index|]
expr_stmt|;
name|instr
operator|=
name|active_instrument
index|[
name|voice
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|instr
condition|)
name|instr
operator|=
operator|&
name|instrmap
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|instr
operator|->
name|channel
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|voices
index|[
name|voice
index|]
operator|.
name|mode
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|voices
index|[
name|voice
index|]
operator|.
name|mode
operator|==
literal|2
condition|)
block|{
comment|/* 				 * 2 OP voice 				 */
name|vol1
operator|=
name|instr
operator|->
name|operators
index|[
literal|2
index|]
expr_stmt|;
name|vol2
operator|=
name|instr
operator|->
name|operators
index|[
literal|3
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|instr
operator|->
name|operators
index|[
literal|10
index|]
operator|&
literal|0x01
operator|)
condition|)
block|{
comment|/* 				 * Additive synthesis 				 */
name|calc_vol
argument_list|(
operator|&
name|vol1
argument_list|,
name|volume
argument_list|)
expr_stmt|;
name|calc_vol
argument_list|(
operator|&
name|vol2
argument_list|,
name|volume
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * FM synthesis 				 */
name|calc_vol
argument_list|(
operator|&
name|vol2
argument_list|,
name|volume
argument_list|)
expr_stmt|;
block|}
name|opl3_command
argument_list|(
name|map
operator|->
name|ioaddr
argument_list|,
name|KSL_LEVEL
operator|+
name|map
operator|->
name|op
index|[
literal|0
index|]
argument_list|,
name|vol1
argument_list|)
expr_stmt|;
comment|/* 									   * Modulator 									   * volume 									 */
name|opl3_command
argument_list|(
name|map
operator|->
name|ioaddr
argument_list|,
name|KSL_LEVEL
operator|+
name|map
operator|->
name|op
index|[
literal|1
index|]
argument_list|,
name|vol2
argument_list|)
expr_stmt|;
comment|/* 									   * Carrier 									   * volume 									 */
block|}
else|else
block|{
comment|/* 				 * 4 OP voice 				 */
name|int
name|connection
decl_stmt|;
name|vol1
operator|=
name|instr
operator|->
name|operators
index|[
literal|2
index|]
expr_stmt|;
name|vol2
operator|=
name|instr
operator|->
name|operators
index|[
literal|3
index|]
expr_stmt|;
name|vol3
operator|=
name|instr
operator|->
name|operators
index|[
name|OFFS_4OP
operator|+
literal|2
index|]
expr_stmt|;
name|vol4
operator|=
name|instr
operator|->
name|operators
index|[
name|OFFS_4OP
operator|+
literal|3
index|]
expr_stmt|;
comment|/*        * The connection method for 4 OP voices is defined by the rightmost        * bits at the offsets 10 and 10+OFFS_4OP        */
name|connection
operator|=
operator|(
operator|(
name|instr
operator|->
name|operators
index|[
literal|10
index|]
operator|&
literal|0x01
operator|)
operator|<<
literal|1
operator|)
operator||
operator|(
name|instr
operator|->
name|operators
index|[
literal|10
operator|+
name|OFFS_4OP
index|]
operator|&
literal|0x01
operator|)
expr_stmt|;
switch|switch
condition|(
name|connection
condition|)
block|{
case|case
literal|0
case|:
name|calc_vol
argument_list|(
operator|&
name|vol4
argument_list|,
name|volume
argument_list|)
expr_stmt|;
comment|/* 					 * Just the OP 4 is carrier 					 */
break|break;
case|case
literal|1
case|:
name|calc_vol
argument_list|(
operator|&
name|vol2
argument_list|,
name|volume
argument_list|)
expr_stmt|;
name|calc_vol
argument_list|(
operator|&
name|vol4
argument_list|,
name|volume
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|calc_vol
argument_list|(
operator|&
name|vol1
argument_list|,
name|volume
argument_list|)
expr_stmt|;
name|calc_vol
argument_list|(
operator|&
name|vol4
argument_list|,
name|volume
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|calc_vol
argument_list|(
operator|&
name|vol1
argument_list|,
name|volume
argument_list|)
expr_stmt|;
name|calc_vol
argument_list|(
operator|&
name|vol3
argument_list|,
name|volume
argument_list|)
expr_stmt|;
name|calc_vol
argument_list|(
operator|&
name|vol4
argument_list|,
name|volume
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* 				 * Why ?? 				 */
empty_stmt|;
block|}
name|opl3_command
argument_list|(
name|map
operator|->
name|ioaddr
argument_list|,
name|KSL_LEVEL
operator|+
name|map
operator|->
name|op
index|[
literal|0
index|]
argument_list|,
name|vol1
argument_list|)
expr_stmt|;
name|opl3_command
argument_list|(
name|map
operator|->
name|ioaddr
argument_list|,
name|KSL_LEVEL
operator|+
name|map
operator|->
name|op
index|[
literal|1
index|]
argument_list|,
name|vol2
argument_list|)
expr_stmt|;
name|opl3_command
argument_list|(
name|map
operator|->
name|ioaddr
argument_list|,
name|KSL_LEVEL
operator|+
name|map
operator|->
name|op
index|[
literal|2
index|]
argument_list|,
name|vol3
argument_list|)
expr_stmt|;
name|opl3_command
argument_list|(
name|map
operator|->
name|ioaddr
argument_list|,
name|KSL_LEVEL
operator|+
name|map
operator|->
name|op
index|[
literal|3
index|]
argument_list|,
name|vol4
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|opl3_start_note
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|note
parameter_list|,
name|int
name|volume
parameter_list|)
block|{
name|unsigned
name|char
name|data
decl_stmt|,
name|fpc
decl_stmt|;
name|int
name|block
decl_stmt|,
name|fnum
decl_stmt|,
name|freq
decl_stmt|,
name|voice_mode
decl_stmt|;
name|struct
name|sbi_instrument
modifier|*
name|instr
decl_stmt|;
name|struct
name|physical_voice_info
modifier|*
name|map
decl_stmt|;
if|if
condition|(
name|voice
operator|<
literal|0
operator|||
name|voice
operator|>=
name|nr_voices
condition|)
return|return
literal|0
return|;
name|map
operator|=
operator|&
name|physical_voices
index|[
name|logical_voices
index|[
name|voice
index|]
index|]
expr_stmt|;
if|if
condition|(
name|map
operator|->
name|voice_mode
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|note
operator|==
literal|255
condition|)
comment|/* 				 * Just change the volume 				 */
block|{
name|set_voice_volume
argument_list|(
name|voice
argument_list|,
name|volume
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/*    * Kill previous note before playing    */
name|opl3_command
argument_list|(
name|map
operator|->
name|ioaddr
argument_list|,
name|KSL_LEVEL
operator|+
name|map
operator|->
name|op
index|[
literal|1
index|]
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* 								 * Carrier 								 * volume to 								 * min 								 */
name|opl3_command
argument_list|(
name|map
operator|->
name|ioaddr
argument_list|,
name|KSL_LEVEL
operator|+
name|map
operator|->
name|op
index|[
literal|0
index|]
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* 								 * Modulator 								 * volume to 								 */
if|if
condition|(
name|map
operator|->
name|voice_mode
operator|==
literal|4
condition|)
block|{
name|opl3_command
argument_list|(
name|map
operator|->
name|ioaddr
argument_list|,
name|KSL_LEVEL
operator|+
name|map
operator|->
name|op
index|[
literal|2
index|]
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|opl3_command
argument_list|(
name|map
operator|->
name|ioaddr
argument_list|,
name|KSL_LEVEL
operator|+
name|map
operator|->
name|op
index|[
literal|3
index|]
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
block|}
name|opl3_command
argument_list|(
name|map
operator|->
name|ioaddr
argument_list|,
name|KEYON_BLOCK
operator|+
name|map
operator|->
name|voice_num
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* 									 * Note 									 * off 									 */
name|instr
operator|=
name|active_instrument
index|[
name|voice
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|instr
condition|)
name|instr
operator|=
operator|&
name|instrmap
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|instr
operator|->
name|channel
operator|<
literal|0
condition|)
block|{
name|printk
argument_list|(
literal|"OPL3: Initializing voice %d with undefined instrument\n"
argument_list|,
name|voice
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|map
operator|->
name|voice_mode
operator|==
literal|2
operator|&&
name|instr
operator|->
name|key
operator|==
name|OPL3_PATCH
condition|)
return|return
literal|0
return|;
comment|/* 				 * Cannot play 				 */
name|voice_mode
operator|=
name|map
operator|->
name|voice_mode
expr_stmt|;
if|if
condition|(
name|voice_mode
operator|==
literal|4
condition|)
block|{
name|int
name|voice_shift
decl_stmt|;
name|voice_shift
operator|=
operator|(
name|map
operator|->
name|ioaddr
operator|==
name|left_address
operator|)
condition|?
literal|0
else|:
literal|3
expr_stmt|;
name|voice_shift
operator|+=
name|map
operator|->
name|voice_num
expr_stmt|;
if|if
condition|(
name|instr
operator|->
name|key
operator|!=
name|OPL3_PATCH
condition|)
comment|/* 					 * Just 2 OP patch 					 */
block|{
name|voice_mode
operator|=
literal|2
expr_stmt|;
name|connection_mask
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|voice_shift
operator|)
expr_stmt|;
block|}
else|else
block|{
name|connection_mask
operator||=
operator|(
literal|1
operator|<<
name|voice_shift
operator|)
expr_stmt|;
block|}
name|opl3_command
argument_list|(
name|right_address
argument_list|,
name|CONNECTION_SELECT_REGISTER
argument_list|,
name|connection_mask
argument_list|)
expr_stmt|;
block|}
comment|/*    * Set Sound Characteristics    */
name|opl3_command
argument_list|(
name|map
operator|->
name|ioaddr
argument_list|,
name|AM_VIB
operator|+
name|map
operator|->
name|op
index|[
literal|0
index|]
argument_list|,
name|instr
operator|->
name|operators
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|opl3_command
argument_list|(
name|map
operator|->
name|ioaddr
argument_list|,
name|AM_VIB
operator|+
name|map
operator|->
name|op
index|[
literal|1
index|]
argument_list|,
name|instr
operator|->
name|operators
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/*    * Set Attack/Decay    */
name|opl3_command
argument_list|(
name|map
operator|->
name|ioaddr
argument_list|,
name|ATTACK_DECAY
operator|+
name|map
operator|->
name|op
index|[
literal|0
index|]
argument_list|,
name|instr
operator|->
name|operators
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|opl3_command
argument_list|(
name|map
operator|->
name|ioaddr
argument_list|,
name|ATTACK_DECAY
operator|+
name|map
operator|->
name|op
index|[
literal|1
index|]
argument_list|,
name|instr
operator|->
name|operators
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
comment|/*    * Set Sustain/Release    */
name|opl3_command
argument_list|(
name|map
operator|->
name|ioaddr
argument_list|,
name|SUSTAIN_RELEASE
operator|+
name|map
operator|->
name|op
index|[
literal|0
index|]
argument_list|,
name|instr
operator|->
name|operators
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
name|opl3_command
argument_list|(
name|map
operator|->
name|ioaddr
argument_list|,
name|SUSTAIN_RELEASE
operator|+
name|map
operator|->
name|op
index|[
literal|1
index|]
argument_list|,
name|instr
operator|->
name|operators
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
comment|/*    * Set Wave Select    */
name|opl3_command
argument_list|(
name|map
operator|->
name|ioaddr
argument_list|,
name|WAVE_SELECT
operator|+
name|map
operator|->
name|op
index|[
literal|0
index|]
argument_list|,
name|instr
operator|->
name|operators
index|[
literal|8
index|]
argument_list|)
expr_stmt|;
name|opl3_command
argument_list|(
name|map
operator|->
name|ioaddr
argument_list|,
name|WAVE_SELECT
operator|+
name|map
operator|->
name|op
index|[
literal|1
index|]
argument_list|,
name|instr
operator|->
name|operators
index|[
literal|9
index|]
argument_list|)
expr_stmt|;
comment|/*    * Set Feedback/Connection    */
name|fpc
operator|=
name|instr
operator|->
name|operators
index|[
literal|10
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|fpc
operator|&
literal|0x30
operator|)
condition|)
name|fpc
operator||=
literal|0x30
expr_stmt|;
comment|/* 				 * Ensure that at least one chn is enabled 				 */
name|opl3_command
argument_list|(
name|map
operator|->
name|ioaddr
argument_list|,
name|FEEDBACK_CONNECTION
operator|+
name|map
operator|->
name|voice_num
argument_list|,
name|fpc
argument_list|)
expr_stmt|;
comment|/*    * If the voice is a 4 OP one, initialize the operators 3 and 4 also    */
if|if
condition|(
name|voice_mode
operator|==
literal|4
condition|)
block|{
comment|/*        * Set Sound Characteristics        */
name|opl3_command
argument_list|(
name|map
operator|->
name|ioaddr
argument_list|,
name|AM_VIB
operator|+
name|map
operator|->
name|op
index|[
literal|2
index|]
argument_list|,
name|instr
operator|->
name|operators
index|[
name|OFFS_4OP
operator|+
literal|0
index|]
argument_list|)
expr_stmt|;
name|opl3_command
argument_list|(
name|map
operator|->
name|ioaddr
argument_list|,
name|AM_VIB
operator|+
name|map
operator|->
name|op
index|[
literal|3
index|]
argument_list|,
name|instr
operator|->
name|operators
index|[
name|OFFS_4OP
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/*        * Set Attack/Decay        */
name|opl3_command
argument_list|(
name|map
operator|->
name|ioaddr
argument_list|,
name|ATTACK_DECAY
operator|+
name|map
operator|->
name|op
index|[
literal|2
index|]
argument_list|,
name|instr
operator|->
name|operators
index|[
name|OFFS_4OP
operator|+
literal|4
index|]
argument_list|)
expr_stmt|;
name|opl3_command
argument_list|(
name|map
operator|->
name|ioaddr
argument_list|,
name|ATTACK_DECAY
operator|+
name|map
operator|->
name|op
index|[
literal|3
index|]
argument_list|,
name|instr
operator|->
name|operators
index|[
name|OFFS_4OP
operator|+
literal|5
index|]
argument_list|)
expr_stmt|;
comment|/*        * Set Sustain/Release        */
name|opl3_command
argument_list|(
name|map
operator|->
name|ioaddr
argument_list|,
name|SUSTAIN_RELEASE
operator|+
name|map
operator|->
name|op
index|[
literal|2
index|]
argument_list|,
name|instr
operator|->
name|operators
index|[
name|OFFS_4OP
operator|+
literal|6
index|]
argument_list|)
expr_stmt|;
name|opl3_command
argument_list|(
name|map
operator|->
name|ioaddr
argument_list|,
name|SUSTAIN_RELEASE
operator|+
name|map
operator|->
name|op
index|[
literal|3
index|]
argument_list|,
name|instr
operator|->
name|operators
index|[
name|OFFS_4OP
operator|+
literal|7
index|]
argument_list|)
expr_stmt|;
comment|/*        * Set Wave Select        */
name|opl3_command
argument_list|(
name|map
operator|->
name|ioaddr
argument_list|,
name|WAVE_SELECT
operator|+
name|map
operator|->
name|op
index|[
literal|2
index|]
argument_list|,
name|instr
operator|->
name|operators
index|[
name|OFFS_4OP
operator|+
literal|8
index|]
argument_list|)
expr_stmt|;
name|opl3_command
argument_list|(
name|map
operator|->
name|ioaddr
argument_list|,
name|WAVE_SELECT
operator|+
name|map
operator|->
name|op
index|[
literal|3
index|]
argument_list|,
name|instr
operator|->
name|operators
index|[
name|OFFS_4OP
operator|+
literal|9
index|]
argument_list|)
expr_stmt|;
comment|/*        * Set Feedback/Connection        */
name|fpc
operator|=
name|instr
operator|->
name|operators
index|[
name|OFFS_4OP
operator|+
literal|10
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|fpc
operator|&
literal|0x30
operator|)
condition|)
name|fpc
operator||=
literal|0x30
expr_stmt|;
comment|/* 				 * Ensure that at least one chn is enabled 				 */
name|opl3_command
argument_list|(
name|map
operator|->
name|ioaddr
argument_list|,
name|FEEDBACK_CONNECTION
operator|+
name|map
operator|->
name|voice_num
operator|+
literal|3
argument_list|,
name|fpc
argument_list|)
expr_stmt|;
block|}
name|voices
index|[
name|voice
index|]
operator|.
name|mode
operator|=
name|voice_mode
expr_stmt|;
name|set_voice_volume
argument_list|(
name|voice
argument_list|,
name|volume
argument_list|)
expr_stmt|;
name|freq
operator|=
name|voices
index|[
name|voice
index|]
operator|.
name|orig_freq
operator|=
name|note_to_freq
argument_list|(
name|note
argument_list|)
operator|/
literal|1000
expr_stmt|;
comment|/*    * Since the pitch bender may have been set before playing the note, we    * have to calculate the bending now.    */
name|freq
operator|=
name|compute_finetune
argument_list|(
name|voices
index|[
name|voice
index|]
operator|.
name|orig_freq
argument_list|,
name|voices
index|[
name|voice
index|]
operator|.
name|bender
argument_list|,
name|voices
index|[
name|voice
index|]
operator|.
name|bender_range
argument_list|)
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|current_freq
operator|=
name|freq
expr_stmt|;
name|freq_to_fnum
argument_list|(
name|freq
argument_list|,
operator|&
name|block
argument_list|,
operator|&
name|fnum
argument_list|)
expr_stmt|;
comment|/*    * Play note    */
name|data
operator|=
name|fnum
operator|&
literal|0xff
expr_stmt|;
comment|/* 				 * Least significant bits of fnumber 				 */
name|opl3_command
argument_list|(
name|map
operator|->
name|ioaddr
argument_list|,
name|FNUM_LOW
operator|+
name|map
operator|->
name|voice_num
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|data
operator|=
literal|0x20
operator||
operator|(
operator|(
name|block
operator|&
literal|0x7
operator|)
operator|<<
literal|2
operator|)
operator||
operator|(
operator|(
name|fnum
operator|>>
literal|8
operator|)
operator|&
literal|0x3
operator|)
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|keyon_byte
operator|=
name|data
expr_stmt|;
name|opl3_command
argument_list|(
name|map
operator|->
name|ioaddr
argument_list|,
name|KEYON_BLOCK
operator|+
name|map
operator|->
name|voice_num
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|voice_mode
operator|==
literal|4
condition|)
name|opl3_command
argument_list|(
name|map
operator|->
name|ioaddr
argument_list|,
name|KEYON_BLOCK
operator|+
name|map
operator|->
name|voice_num
operator|+
literal|3
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|freq_to_fnum
parameter_list|(
name|int
name|freq
parameter_list|,
name|int
modifier|*
name|block
parameter_list|,
name|int
modifier|*
name|fnum
parameter_list|)
block|{
name|int
name|f
decl_stmt|,
name|octave
decl_stmt|;
comment|/*    * Converts the note frequency to block and fnum values for the FM chip    */
comment|/*    * First try to compute the block -value (octave) where the note belongs    */
name|f
operator|=
name|freq
expr_stmt|;
name|octave
operator|=
literal|5
expr_stmt|;
if|if
condition|(
name|f
operator|==
literal|0
condition|)
name|octave
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|f
operator|<
literal|261
condition|)
block|{
while|while
condition|(
name|f
operator|<
literal|261
condition|)
block|{
name|octave
operator|--
expr_stmt|;
name|f
operator|<<=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|f
operator|>
literal|493
condition|)
block|{
while|while
condition|(
name|f
operator|>
literal|493
condition|)
block|{
name|octave
operator|++
expr_stmt|;
name|f
operator|>>=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|octave
operator|>
literal|7
condition|)
name|octave
operator|=
literal|7
expr_stmt|;
operator|*
name|fnum
operator|=
name|freq
operator|*
operator|(
literal|1
operator|<<
operator|(
literal|20
operator|-
name|octave
operator|)
operator|)
operator|/
literal|49716
expr_stmt|;
operator|*
name|block
operator|=
name|octave
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|opl3_command
parameter_list|(
name|int
name|io_addr
parameter_list|,
name|unsigned
name|int
name|addr
parameter_list|,
name|unsigned
name|int
name|val
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/*    * The original 2-OP synth requires a quite long delay after writing to a    * register. The OPL-3 survives with just two INBs    */
name|OUTB
argument_list|(
call|(
name|unsigned
name|char
call|)
argument_list|(
name|addr
operator|&
literal|0xff
argument_list|)
argument_list|,
name|io_addr
argument_list|)
expr_stmt|;
comment|/* 							 * Select register 							 * 							 */
if|if
condition|(
operator|!
name|opl3_enabled
condition|)
name|tenmicrosec
argument_list|()
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
name|INB
argument_list|(
name|io_addr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|OUTB
argument_list|(
call|(
name|unsigned
name|char
call|)
argument_list|(
name|val
operator|&
literal|0xff
argument_list|)
argument_list|,
name|io_addr
operator|+
literal|0x100
argument_list|)
expr_stmt|;
else|#
directive|else
name|OUTB
argument_list|(
call|(
name|unsigned
name|char
call|)
argument_list|(
name|val
operator|&
literal|0xff
argument_list|)
argument_list|,
name|io_addr
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* 							 * Write to register 							 * 							 */
endif|#
directive|endif
if|if
condition|(
operator|!
name|opl3_enabled
condition|)
block|{
name|tenmicrosec
argument_list|()
expr_stmt|;
name|tenmicrosec
argument_list|()
expr_stmt|;
name|tenmicrosec
argument_list|()
expr_stmt|;
block|}
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
name|INB
argument_list|(
name|io_addr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|opl3_reset
parameter_list|(
name|int
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nr_voices
condition|;
name|i
operator|++
control|)
block|{
name|opl3_command
argument_list|(
name|physical_voices
index|[
name|logical_voices
index|[
name|i
index|]
index|]
operator|.
name|ioaddr
argument_list|,
name|KSL_LEVEL
operator|+
name|physical_voices
index|[
name|logical_voices
index|[
name|i
index|]
index|]
operator|.
name|op
index|[
literal|0
index|]
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|opl3_command
argument_list|(
name|physical_voices
index|[
name|logical_voices
index|[
name|i
index|]
index|]
operator|.
name|ioaddr
argument_list|,
name|KSL_LEVEL
operator|+
name|physical_voices
index|[
name|logical_voices
index|[
name|i
index|]
index|]
operator|.
name|op
index|[
literal|1
index|]
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
if|if
condition|(
name|physical_voices
index|[
name|logical_voices
index|[
name|i
index|]
index|]
operator|.
name|voice_mode
operator|==
literal|4
condition|)
block|{
name|opl3_command
argument_list|(
name|physical_voices
index|[
name|logical_voices
index|[
name|i
index|]
index|]
operator|.
name|ioaddr
argument_list|,
name|KSL_LEVEL
operator|+
name|physical_voices
index|[
name|logical_voices
index|[
name|i
index|]
index|]
operator|.
name|op
index|[
literal|2
index|]
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|opl3_command
argument_list|(
name|physical_voices
index|[
name|logical_voices
index|[
name|i
index|]
index|]
operator|.
name|ioaddr
argument_list|,
name|KSL_LEVEL
operator|+
name|physical_voices
index|[
name|logical_voices
index|[
name|i
index|]
index|]
operator|.
name|op
index|[
literal|3
index|]
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
block|}
name|opl3_kill_note
argument_list|(
name|dev
argument_list|,
name|i
argument_list|,
literal|0
argument_list|,
literal|64
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|opl3_enabled
condition|)
block|{
name|voice_alloc
operator|->
name|max_voice
operator|=
name|nr_voices
operator|=
literal|18
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|18
condition|;
name|i
operator|++
control|)
name|logical_voices
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|18
condition|;
name|i
operator|++
control|)
name|physical_voices
index|[
name|i
index|]
operator|.
name|voice_mode
operator|=
literal|2
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|opl3_open
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|opl3_ok
condition|)
return|return
name|RET_ERROR
argument_list|(
name|ENXIO
argument_list|)
return|;
if|if
condition|(
name|opl3_busy
condition|)
return|return
name|RET_ERROR
argument_list|(
name|EBUSY
argument_list|)
return|;
name|opl3_busy
operator|=
literal|1
expr_stmt|;
name|voice_alloc
operator|->
name|max_voice
operator|=
name|nr_voices
operator|=
name|opl3_enabled
condition|?
literal|18
else|:
literal|9
expr_stmt|;
name|voice_alloc
operator|->
name|timestamp
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|18
condition|;
name|i
operator|++
control|)
block|{
name|voice_alloc
operator|->
name|map
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|voice_alloc
operator|->
name|alloc_times
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|connection_mask
operator|=
literal|0x00
expr_stmt|;
comment|/* 				 * Just 2 OP voices 				 */
if|if
condition|(
name|opl3_enabled
condition|)
name|opl3_command
argument_list|(
name|right_address
argument_list|,
name|CONNECTION_SELECT_REGISTER
argument_list|,
name|connection_mask
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|opl3_close
parameter_list|(
name|int
name|dev
parameter_list|)
block|{
name|opl3_busy
operator|=
literal|0
expr_stmt|;
name|voice_alloc
operator|->
name|max_voice
operator|=
name|nr_voices
operator|=
name|opl3_enabled
condition|?
literal|18
else|:
literal|9
expr_stmt|;
name|fm_info
operator|.
name|nr_drums
operator|=
literal|0
expr_stmt|;
name|fm_info
operator|.
name|perc_mode
operator|=
literal|0
expr_stmt|;
name|opl3_reset
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|opl3_hw_control
parameter_list|(
name|int
name|dev
parameter_list|,
name|unsigned
name|char
modifier|*
name|event
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|int
name|opl3_load_patch
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|format
parameter_list|,
name|snd_rw_buf
modifier|*
name|addr
parameter_list|,
name|int
name|offs
parameter_list|,
name|int
name|count
parameter_list|,
name|int
name|pmgr_flag
parameter_list|)
block|{
name|struct
name|sbi_instrument
name|ins
decl_stmt|;
if|if
condition|(
name|count
operator|<
sizeof|sizeof
argument_list|(
name|ins
argument_list|)
condition|)
block|{
name|printk
argument_list|(
literal|"FM Error: Patch record too short\n"
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|COPY_FROM_USER
argument_list|(
operator|&
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ins
operator|)
index|[
name|offs
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|addr
argument_list|,
name|offs
argument_list|,
sizeof|sizeof
argument_list|(
name|ins
argument_list|)
operator|-
name|offs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ins
operator|.
name|channel
operator|<
literal|0
operator|||
name|ins
operator|.
name|channel
operator|>=
name|SBFM_MAXINSTR
condition|)
block|{
name|printk
argument_list|(
literal|"FM Error: Invalid instrument number %d\n"
argument_list|,
name|ins
operator|.
name|channel
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|ins
operator|.
name|key
operator|=
name|format
expr_stmt|;
return|return
name|store_instr
argument_list|(
name|ins
operator|.
name|channel
argument_list|,
operator|&
name|ins
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|opl3_panning
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|pressure
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|void
name|opl3_volume_method
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|mode
parameter_list|)
block|{ }
end_function

begin_define
define|#
directive|define
name|SET_VIBRATO
parameter_list|(
name|cell
parameter_list|)
value|{ \       tmp = instr->operators[(cell-1)+(((cell-1)/2)*OFFS_4OP)]; \       if (pressure> 110) \ 	tmp |= 0x40;
comment|/* Vibrato on */
value|\       opl3_command (map->ioaddr, AM_VIB + map->op[cell-1], tmp);}
end_define

begin_function
specifier|static
name|void
name|opl3_aftertouch
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|pressure
parameter_list|)
block|{
name|int
name|tmp
decl_stmt|;
name|struct
name|sbi_instrument
modifier|*
name|instr
decl_stmt|;
name|struct
name|physical_voice_info
modifier|*
name|map
decl_stmt|;
if|if
condition|(
name|voice
operator|<
literal|0
operator|||
name|voice
operator|>=
name|nr_voices
condition|)
return|return;
name|map
operator|=
operator|&
name|physical_voices
index|[
name|logical_voices
index|[
name|voice
index|]
index|]
expr_stmt|;
name|DEB
argument_list|(
name|printk
argument_list|(
literal|"Aftertouch %d\n"
argument_list|,
name|voice
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|->
name|voice_mode
operator|==
literal|0
condition|)
return|return;
comment|/*    * Adjust the amount of vibrato depending the pressure    */
name|instr
operator|=
name|active_instrument
index|[
name|voice
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|instr
condition|)
name|instr
operator|=
operator|&
name|instrmap
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|voices
index|[
name|voice
index|]
operator|.
name|mode
operator|==
literal|4
condition|)
block|{
name|int
name|connection
init|=
operator|(
operator|(
name|instr
operator|->
name|operators
index|[
literal|10
index|]
operator|&
literal|0x01
operator|)
operator|<<
literal|1
operator|)
operator||
operator|(
name|instr
operator|->
name|operators
index|[
literal|10
operator|+
name|OFFS_4OP
index|]
operator|&
literal|0x01
operator|)
decl_stmt|;
switch|switch
condition|(
name|connection
condition|)
block|{
case|case
literal|0
case|:
name|SET_VIBRATO
argument_list|(
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|SET_VIBRATO
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|SET_VIBRATO
argument_list|(
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|SET_VIBRATO
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|SET_VIBRATO
argument_list|(
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|SET_VIBRATO
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|SET_VIBRATO
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|SET_VIBRATO
argument_list|(
literal|4
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/*        * Not implemented yet        */
block|}
else|else
block|{
name|SET_VIBRATO
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|instr
operator|->
name|operators
index|[
literal|10
index|]
operator|&
literal|0x01
operator|)
condition|)
comment|/* 						 * Additive synthesis 						 */
name|SET_VIBRATO
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_undef
undef|#
directive|undef
name|SET_VIBRATO
end_undef

begin_function
specifier|static
name|void
name|bend_pitch
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|value
parameter_list|)
block|{
name|unsigned
name|char
name|data
decl_stmt|;
name|int
name|block
decl_stmt|,
name|fnum
decl_stmt|,
name|freq
decl_stmt|;
name|struct
name|physical_voice_info
modifier|*
name|map
decl_stmt|;
name|map
operator|=
operator|&
name|physical_voices
index|[
name|logical_voices
index|[
name|voice
index|]
index|]
expr_stmt|;
if|if
condition|(
name|map
operator|->
name|voice_mode
operator|==
literal|0
condition|)
return|return;
name|voices
index|[
name|voice
index|]
operator|.
name|bender
operator|=
name|value
expr_stmt|;
if|if
condition|(
operator|!
name|value
condition|)
return|return;
if|if
condition|(
operator|!
operator|(
name|voices
index|[
name|voice
index|]
operator|.
name|keyon_byte
operator|&
literal|0x20
operator|)
condition|)
return|return;
comment|/* 				 * Not keyed on 				 */
name|freq
operator|=
name|compute_finetune
argument_list|(
name|voices
index|[
name|voice
index|]
operator|.
name|orig_freq
argument_list|,
name|voices
index|[
name|voice
index|]
operator|.
name|bender
argument_list|,
name|voices
index|[
name|voice
index|]
operator|.
name|bender_range
argument_list|)
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|current_freq
operator|=
name|freq
expr_stmt|;
name|freq_to_fnum
argument_list|(
name|freq
argument_list|,
operator|&
name|block
argument_list|,
operator|&
name|fnum
argument_list|)
expr_stmt|;
name|data
operator|=
name|fnum
operator|&
literal|0xff
expr_stmt|;
comment|/* 				 * Least significant bits of fnumber 				 */
name|opl3_command
argument_list|(
name|map
operator|->
name|ioaddr
argument_list|,
name|FNUM_LOW
operator|+
name|map
operator|->
name|voice_num
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|data
operator|=
literal|0x20
operator||
operator|(
operator|(
name|block
operator|&
literal|0x7
operator|)
operator|<<
literal|2
operator|)
operator||
operator|(
operator|(
name|fnum
operator|>>
literal|8
operator|)
operator|&
literal|0x3
operator|)
expr_stmt|;
comment|/* 								 * * 								 * KEYON|OCTAVE|MS 								 * 								 * * bits * * 								 * of * f-num 								 * 								 */
name|voices
index|[
name|voice
index|]
operator|.
name|keyon_byte
operator|=
name|data
expr_stmt|;
name|opl3_command
argument_list|(
name|map
operator|->
name|ioaddr
argument_list|,
name|KEYON_BLOCK
operator|+
name|map
operator|->
name|voice_num
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|opl3_controller
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|ctrl_num
parameter_list|,
name|int
name|value
parameter_list|)
block|{
if|if
condition|(
name|voice
operator|<
literal|0
operator|||
name|voice
operator|>=
name|nr_voices
condition|)
return|return;
switch|switch
condition|(
name|ctrl_num
condition|)
block|{
case|case
name|CTRL_PITCH_BENDER
case|:
name|bend_pitch
argument_list|(
name|dev
argument_list|,
name|voice
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTRL_PITCH_BENDER_RANGE
case|:
name|voices
index|[
name|voice
index|]
operator|.
name|bender_range
operator|=
name|value
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|opl3_patchmgr
parameter_list|(
name|int
name|dev
parameter_list|,
name|struct
name|patmgr_info
modifier|*
name|rec
parameter_list|)
block|{
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|opl3_bender
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|value
parameter_list|)
block|{
if|if
condition|(
name|voice
operator|<
literal|0
operator|||
name|voice
operator|>=
name|nr_voices
condition|)
return|return;
name|bend_pitch
argument_list|(
name|dev
argument_list|,
name|voice
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|opl3_alloc_voice
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|chn
parameter_list|,
name|int
name|note
parameter_list|,
name|struct
name|voice_alloc_info
modifier|*
name|alloc
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|p
decl_stmt|,
name|best
decl_stmt|,
name|first
decl_stmt|,
name|avail_voices
decl_stmt|,
name|best_time
init|=
literal|0x7fffffff
decl_stmt|;
name|struct
name|sbi_instrument
modifier|*
name|instr
decl_stmt|;
name|int
name|is4op
decl_stmt|;
name|int
name|instr_no
decl_stmt|;
if|if
condition|(
name|chn
operator|<
literal|0
operator|||
name|chn
operator|>
literal|15
condition|)
name|instr_no
operator|=
literal|0
expr_stmt|;
else|else
name|instr_no
operator|=
name|chn_info
index|[
name|chn
index|]
operator|.
name|pgm_num
expr_stmt|;
name|instr
operator|=
operator|&
name|instrmap
index|[
name|instr_no
index|]
expr_stmt|;
if|if
condition|(
name|instr
operator|->
name|channel
operator|<
literal|0
operator|||
comment|/* Instrument not loaded */
name|nr_voices
operator|!=
literal|12
condition|)
comment|/* Not in 4 OP mode */
name|is4op
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|nr_voices
operator|==
literal|12
condition|)
comment|/* 4 OP mode */
name|is4op
operator|=
operator|(
name|instr
operator|->
name|key
operator|==
name|OPL3_PATCH
operator|)
expr_stmt|;
else|else
name|is4op
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|is4op
condition|)
block|{
name|first
operator|=
name|p
operator|=
literal|0
expr_stmt|;
name|avail_voices
operator|=
literal|6
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|nr_voices
operator|==
literal|12
condition|)
comment|/* 4 OP mode. Use the '2 OP only' voices first */
name|first
operator|=
name|p
operator|=
literal|6
expr_stmt|;
else|else
name|first
operator|=
name|p
operator|=
literal|0
expr_stmt|;
name|avail_voices
operator|=
name|nr_voices
expr_stmt|;
block|}
comment|/*      *    Now try to find a free voice    */
name|best
operator|=
name|first
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|avail_voices
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|alloc
operator|->
name|map
index|[
name|p
index|]
operator|==
literal|0
condition|)
block|{
return|return
name|p
return|;
block|}
if|if
condition|(
name|alloc
operator|->
name|alloc_times
index|[
name|p
index|]
operator|<
name|best_time
condition|)
comment|/* Find oldest playing note */
block|{
name|best_time
operator|=
name|alloc
operator|->
name|alloc_times
index|[
name|p
index|]
expr_stmt|;
name|best
operator|=
name|p
expr_stmt|;
block|}
name|p
operator|=
operator|(
name|p
operator|+
literal|1
operator|)
operator|%
name|avail_voices
expr_stmt|;
block|}
comment|/*      *    Insert some kind of priority mechanism here.    */
if|if
condition|(
name|best
operator|<
literal|0
condition|)
name|best
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|best
operator|>
name|nr_voices
condition|)
name|best
operator|-=
name|nr_voices
expr_stmt|;
return|return
name|best
return|;
comment|/* All voices in use. Select the first one. */
block|}
end_function

begin_function
specifier|static
name|void
name|opl3_setup_voice
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|chn
parameter_list|)
block|{
name|struct
name|channel_info
modifier|*
name|info
init|=
operator|&
name|synth_devs
index|[
name|dev
index|]
operator|->
name|chn_info
index|[
name|chn
index|]
decl_stmt|;
name|opl3_set_instr
argument_list|(
name|dev
argument_list|,
name|voice
argument_list|,
name|info
operator|->
name|pgm_num
argument_list|)
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|bender
operator|=
name|info
operator|->
name|bender_value
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|synth_operations
name|opl3_operations
init|=
block|{
operator|&
name|fm_info
block|,
literal|0
block|,
name|SYNTH_TYPE_FM
block|,
name|FM_TYPE_ADLIB
block|,
name|opl3_open
block|,
name|opl3_close
block|,
name|opl3_ioctl
block|,
name|opl3_kill_note
block|,
name|opl3_start_note
block|,
name|opl3_set_instr
block|,
name|opl3_reset
block|,
name|opl3_hw_control
block|,
name|opl3_load_patch
block|,
name|opl3_aftertouch
block|,
name|opl3_controller
block|,
name|opl3_panning
block|,
name|opl3_volume_method
block|,
name|opl3_patchmgr
block|,
name|opl3_bender
block|,
name|opl3_alloc_voice
block|,
name|opl3_setup_voice
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|long
name|opl3_init
parameter_list|(
name|long
name|mem_start
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|PERMANENT_MALLOC
argument_list|(
expr|struct
name|sbi_instrument
operator|*
argument_list|,
name|instrmap
argument_list|,
name|SBFM_MAXINSTR
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|instrmap
argument_list|)
argument_list|,
name|mem_start
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_synths
operator|>=
name|MAX_SYNTH_DEV
condition|)
name|printk
argument_list|(
literal|"OPL3 Error: Too many synthesizers\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|synth_devs
index|[
name|num_synths
operator|++
index|]
operator|=
operator|&
name|opl3_operations
expr_stmt|;
name|voice_alloc
operator|=
operator|&
name|opl3_operations
operator|.
name|alloc
expr_stmt|;
name|chn_info
operator|=
operator|&
name|opl3_operations
operator|.
name|chn_info
index|[
literal|0
index|]
expr_stmt|;
block|}
name|fm_model
operator|=
literal|0
expr_stmt|;
name|opl3_ok
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|opl3_enabled
condition|)
block|{
if|if
condition|(
name|opl4_enabled
condition|)
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|printk
argument_list|(
literal|"opl0:<Yamaha OPL4/OPL3 FM>"
argument_list|)
expr_stmt|;
else|else
name|printk
argument_list|(
literal|"opl0:<Yamaha OPL-3 FM>"
argument_list|)
expr_stmt|;
else|#
directive|else
name|printk
argument_list|(
literal|"<Yamaha OPL4/OPL3 FM>"
argument_list|)
expr_stmt|;
else|else
name|printk
argument_list|(
literal|"<Yamaha OPL-3 FM>"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fm_model
operator|=
literal|2
expr_stmt|;
name|voice_alloc
operator|->
name|max_voice
operator|=
name|nr_voices
operator|=
literal|18
expr_stmt|;
name|fm_info
operator|.
name|nr_drums
operator|=
literal|0
expr_stmt|;
name|fm_info
operator|.
name|capabilities
operator||=
name|SYNTH_CAP_OPL3
expr_stmt|;
name|strcpy
argument_list|(
name|fm_info
operator|.
name|name
argument_list|,
literal|"Yamaha OPL-3"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|18
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|physical_voices
index|[
name|i
index|]
operator|.
name|ioaddr
operator|==
name|USE_LEFT
condition|)
name|physical_voices
index|[
name|i
index|]
operator|.
name|ioaddr
operator|=
name|left_address
expr_stmt|;
else|else
name|physical_voices
index|[
name|i
index|]
operator|.
name|ioaddr
operator|=
name|right_address
expr_stmt|;
name|opl3_command
argument_list|(
name|right_address
argument_list|,
name|OPL3_MODE_REGISTER
argument_list|,
name|OPL3_ENABLE
argument_list|)
expr_stmt|;
comment|/* 									 * Enable 									 * OPL-3 									 * mode 									 */
name|opl3_command
argument_list|(
name|right_address
argument_list|,
name|CONNECTION_SELECT_REGISTER
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* 									 * Select 									 * all 									 * 2-OP 									 * * 									 * voices 									 */
block|}
else|else
block|{
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|printk
argument_list|(
literal|"opl0:<Yamaha 2-OP FM>"
argument_list|)
expr_stmt|;
else|#
directive|else
name|printk
argument_list|(
literal|"<Yamaha 2-OP FM>"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fm_model
operator|=
literal|1
expr_stmt|;
name|voice_alloc
operator|->
name|max_voice
operator|=
name|nr_voices
operator|=
literal|9
expr_stmt|;
name|fm_info
operator|.
name|nr_drums
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|18
condition|;
name|i
operator|++
control|)
name|physical_voices
index|[
name|i
index|]
operator|.
name|ioaddr
operator|=
name|left_address
expr_stmt|;
block|}
empty_stmt|;
name|already_initialized
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SBFM_MAXINSTR
condition|;
name|i
operator|++
control|)
name|instrmap
index|[
name|i
index|]
operator|.
name|channel
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|mem_start
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

