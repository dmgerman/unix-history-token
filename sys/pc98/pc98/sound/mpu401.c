begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * sound/mpu401.c  *  * The low level driver for Roland MPU-401 compatible Midi cards.  *  * Copyright by Hannu Savolainen 1993  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met: 1. Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer. 2.  * Redistributions in binary form must reproduce the above copyright notice,  * this list of conditions and the following disclaimer in the documentation  * and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * Modified:  *  Riccardo Facchetti  24 Mar 1995  *  - Added the Audio Excel DSP 16 initialization routine.  */
end_comment

begin_define
define|#
directive|define
name|USE_SEQ_MACROS
end_define

begin_define
define|#
directive|define
name|USE_SIMPLE_MACROS
end_define

begin_include
include|#
directive|include
file|<i386/isa/sound/sound_config.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|CONFIGURE_SOUNDCARD
end_ifdef

begin_if
if|#
directive|if
operator|(
operator|!
name|defined
argument_list|(
name|EXCLUDE_MPU401
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|EXCLUDE_MPU_EMU
argument_list|)
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|EXCLUDE_MIDI
argument_list|)
end_if

begin_include
include|#
directive|include
file|<i386/isa/sound/coproc.h>
end_include

begin_decl_stmt
specifier|static
name|int
name|init_sequence
index|[
literal|20
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* NOTE! pos 0 = len, start pos 1. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|timer_mode
init|=
name|TMR_INTERNAL
decl_stmt|,
name|timer_caps
init|=
name|TMR_INTERNAL
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|mpu_config
block|{
name|int
name|base
decl_stmt|;
comment|/* 				 * I/O base 				 */
name|int
name|irq
decl_stmt|;
name|int
name|opened
decl_stmt|;
comment|/* 				 * Open mode 				 */
name|int
name|devno
decl_stmt|;
name|int
name|synthno
decl_stmt|;
name|int
name|uart_mode
decl_stmt|;
name|int
name|initialized
decl_stmt|;
name|int
name|mode
decl_stmt|;
define|#
directive|define
name|MODE_MIDI
value|1
define|#
directive|define
name|MODE_SYNTH
value|2
name|unsigned
name|char
name|version
decl_stmt|,
name|revision
decl_stmt|;
name|unsigned
name|int
name|capabilities
decl_stmt|;
define|#
directive|define
name|MPU_CAP_INTLG
value|0x10000000
define|#
directive|define
name|MPU_CAP_SYNC
value|0x00000010
define|#
directive|define
name|MPU_CAP_FSK
value|0x00000020
define|#
directive|define
name|MPU_CAP_CLS
value|0x00000040
define|#
directive|define
name|MPU_CAP_SMPTE
value|0x00000080
define|#
directive|define
name|MPU_CAP_2PORT
value|0x00000001
name|int
name|timer_flag
decl_stmt|;
define|#
directive|define
name|MBUF_MAX
value|10
define|#
directive|define
name|BUFTEST
parameter_list|(
name|dc
parameter_list|)
value|if (dc->m_ptr>= MBUF_MAX || dc->m_ptr< 0) \ 	{printk("MPU: Invalid buffer pointer %d/%d, s=%d\n", dc->m_ptr, dc->m_left, dc->m_state);dc->m_ptr--;}
name|int
name|m_busy
decl_stmt|;
name|unsigned
name|char
name|m_buf
index|[
name|MBUF_MAX
index|]
decl_stmt|;
name|int
name|m_ptr
decl_stmt|;
name|int
name|m_state
decl_stmt|;
name|int
name|m_left
decl_stmt|;
name|unsigned
name|char
name|last_status
decl_stmt|;
name|void
function_decl|(
modifier|*
name|inputintr
function_decl|)
parameter_list|(
name|int
name|dev
parameter_list|,
name|unsigned
name|char
name|data
parameter_list|)
function_decl|;
name|int
name|shared_irq
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|DATAPORT
parameter_list|(
name|base
parameter_list|)
value|(base)
end_define

begin_define
define|#
directive|define
name|COMDPORT
parameter_list|(
name|base
parameter_list|)
value|(base+1)
end_define

begin_define
define|#
directive|define
name|STATPORT
parameter_list|(
name|base
parameter_list|)
value|(base+1)
end_define

begin_define
define|#
directive|define
name|mpu401_status
parameter_list|(
name|base
parameter_list|)
value|INB(STATPORT(base))
end_define

begin_define
define|#
directive|define
name|input_avail
parameter_list|(
name|base
parameter_list|)
value|(!(mpu401_status(base)&INPUT_AVAIL))
end_define

begin_define
define|#
directive|define
name|output_ready
parameter_list|(
name|base
parameter_list|)
value|(!(mpu401_status(base)&OUTPUT_READY))
end_define

begin_define
define|#
directive|define
name|write_command
parameter_list|(
name|base
parameter_list|,
name|cmd
parameter_list|)
value|OUTB(cmd, COMDPORT(base))
end_define

begin_define
define|#
directive|define
name|read_data
parameter_list|(
name|base
parameter_list|)
value|INB(DATAPORT(base))
end_define

begin_define
define|#
directive|define
name|write_data
parameter_list|(
name|base
parameter_list|,
name|byte
parameter_list|)
value|OUTB(byte, DATAPORT(base))
end_define

begin_define
define|#
directive|define
name|OUTPUT_READY
value|0x40
end_define

begin_define
define|#
directive|define
name|INPUT_AVAIL
value|0x80
end_define

begin_define
define|#
directive|define
name|MPU_ACK
value|0xF7
end_define

begin_define
define|#
directive|define
name|MPU_RESET
value|0xFF
end_define

begin_define
define|#
directive|define
name|UART_MODE_ON
value|0x3F
end_define

begin_decl_stmt
specifier|static
name|struct
name|mpu_config
name|dev_conf
index|[
name|MAX_MIDI_DEV
index|]
init|=
block|{
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|n_mpu_devs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|irq2dev
index|[
literal|16
index|]
init|=
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|reset_mpu401
parameter_list|(
name|struct
name|mpu_config
modifier|*
name|devc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_uart_mode
parameter_list|(
name|int
name|dev
parameter_list|,
name|struct
name|mpu_config
modifier|*
name|devc
parameter_list|,
name|int
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mpu_timer_init
parameter_list|(
name|int
name|midi_dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mpu_timer_interrupt
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|timer_ext_event
parameter_list|(
name|struct
name|mpu_config
modifier|*
name|devc
parameter_list|,
name|int
name|event
parameter_list|,
name|int
name|parm
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|synth_info
name|mpu_synth_info_proto
init|=
block|{
literal|"MPU-401 MIDI interface"
block|,
literal|0
block|,
name|SYNTH_TYPE_MIDI
block|,
literal|0
block|,
literal|0
block|,
literal|128
block|,
literal|0
block|,
literal|128
block|,
name|SYNTH_CAP_INPUT
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|synth_info
name|mpu_synth_info
index|[
name|MAX_MIDI_DEV
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * States for the input scanner  */
end_comment

begin_define
define|#
directive|define
name|ST_INIT
value|0
end_define

begin_comment
comment|/* Ready for timing byte or msg */
end_comment

begin_define
define|#
directive|define
name|ST_TIMED
value|1
end_define

begin_comment
comment|/* Leading timing byte rcvd */
end_comment

begin_define
define|#
directive|define
name|ST_DATABYTE
value|2
end_define

begin_comment
comment|/* Waiting for (nr_left) data bytes */
end_comment

begin_define
define|#
directive|define
name|ST_SYSMSG
value|100
end_define

begin_comment
comment|/* System message (sysx etc). */
end_comment

begin_define
define|#
directive|define
name|ST_SYSEX
value|101
end_define

begin_comment
comment|/* System exclusive msg */
end_comment

begin_define
define|#
directive|define
name|ST_MTC
value|102
end_define

begin_comment
comment|/* Midi Time Code (MTC) qframe msg */
end_comment

begin_define
define|#
directive|define
name|ST_SONGSEL
value|103
end_define

begin_comment
comment|/* Song select */
end_comment

begin_define
define|#
directive|define
name|ST_SONGPOS
value|104
end_define

begin_comment
comment|/* Song position pointer */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|len_tab
index|[]
init|=
comment|/* # of data bytes following a status 					 */
block|{
literal|2
block|,
comment|/* 8x */
literal|2
block|,
comment|/* 9x */
literal|2
block|,
comment|/* Ax */
literal|2
block|,
comment|/* Bx */
literal|1
block|,
comment|/* Cx */
literal|1
block|,
comment|/* Dx */
literal|2
block|,
comment|/* Ex */
literal|0
comment|/* Fx */
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|STORE
parameter_list|(
name|cmd
parameter_list|)
define|\
value|{ \   int len; \   unsigned char obuf[8]; \   cmd; \   seq_input_event(obuf, len); \ }
end_define

begin_define
define|#
directive|define
name|_seqbuf
value|obuf
end_define

begin_define
define|#
directive|define
name|_seqbufptr
value|0
end_define

begin_define
define|#
directive|define
name|_SEQ_ADVBUF
parameter_list|(
name|x
parameter_list|)
value|len=x
end_define

begin_function
specifier|static
name|int
name|mpu_input_scanner
parameter_list|(
name|struct
name|mpu_config
modifier|*
name|devc
parameter_list|,
name|unsigned
name|char
name|midic
parameter_list|)
block|{
switch|switch
condition|(
name|devc
operator|->
name|m_state
condition|)
block|{
case|case
name|ST_INIT
case|:
switch|switch
condition|(
name|midic
condition|)
block|{
case|case
literal|0xf8
case|:
comment|/* Timer overflow */
break|break;
case|case
literal|0xfc
case|:
name|printk
argument_list|(
literal|"<all end>"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xfd
case|:
if|if
condition|(
name|devc
operator|->
name|timer_flag
condition|)
name|mpu_timer_interrupt
argument_list|()
expr_stmt|;
break|break;
case|case
literal|0xfe
case|:
return|return
name|MPU_ACK
return|;
break|break;
case|case
literal|0xf0
case|:
case|case
literal|0xf1
case|:
case|case
literal|0xf2
case|:
case|case
literal|0xf3
case|:
case|case
literal|0xf4
case|:
case|case
literal|0xf5
case|:
case|case
literal|0xf6
case|:
case|case
literal|0xf7
case|:
name|printk
argument_list|(
literal|"<Trk data rq #%d>"
argument_list|,
name|midic
operator|&
literal|0x0f
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xf9
case|:
name|printk
argument_list|(
literal|"<conductor rq>"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xff
case|:
name|devc
operator|->
name|m_state
operator|=
name|ST_SYSMSG
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|midic
operator|<=
literal|0xef
condition|)
block|{
comment|/* printk("mpu time: %d ", midic); */
name|devc
operator|->
name|m_state
operator|=
name|ST_TIMED
expr_stmt|;
block|}
else|else
name|printk
argument_list|(
literal|"<MPU: Unknown event %02x> "
argument_list|,
name|midic
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ST_TIMED
case|:
block|{
name|int
name|msg
init|=
operator|(
name|midic
operator|&
literal|0xf0
operator|)
operator|>>
literal|4
decl_stmt|;
name|devc
operator|->
name|m_state
operator|=
name|ST_DATABYTE
expr_stmt|;
if|if
condition|(
name|msg
operator|<
literal|8
condition|)
comment|/* Data byte */
block|{
comment|/* printk("midi msg (running status) "); */
name|msg
operator|=
operator|(
name|devc
operator|->
name|last_status
operator|&
literal|0xf0
operator|)
operator|>>
literal|4
expr_stmt|;
name|msg
operator|-=
literal|8
expr_stmt|;
name|devc
operator|->
name|m_left
operator|=
name|len_tab
index|[
name|msg
index|]
operator|-
literal|1
expr_stmt|;
name|devc
operator|->
name|m_ptr
operator|=
literal|2
expr_stmt|;
name|devc
operator|->
name|m_buf
index|[
literal|0
index|]
operator|=
name|devc
operator|->
name|last_status
expr_stmt|;
name|devc
operator|->
name|m_buf
index|[
literal|1
index|]
operator|=
name|midic
expr_stmt|;
if|if
condition|(
name|devc
operator|->
name|m_left
operator|<=
literal|0
condition|)
block|{
name|devc
operator|->
name|m_state
operator|=
name|ST_INIT
expr_stmt|;
name|do_midi_msg
argument_list|(
name|devc
operator|->
name|synthno
argument_list|,
name|devc
operator|->
name|m_buf
argument_list|,
name|devc
operator|->
name|m_ptr
argument_list|)
expr_stmt|;
name|devc
operator|->
name|m_ptr
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|msg
operator|==
literal|0xf
condition|)
comment|/* MPU MARK */
block|{
name|devc
operator|->
name|m_state
operator|=
name|ST_INIT
expr_stmt|;
switch|switch
condition|(
name|midic
condition|)
block|{
case|case
literal|0xf8
case|:
comment|/* printk("NOP "); */
break|break;
case|case
literal|0xf9
case|:
comment|/* printk("meas end "); */
break|break;
case|case
literal|0xfc
case|:
comment|/* printk("data end "); */
break|break;
default|default:
name|printk
argument_list|(
literal|"Unknown MPU mark %02x\n"
argument_list|,
name|midic
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|devc
operator|->
name|last_status
operator|=
name|midic
expr_stmt|;
comment|/* printk ("midi msg "); */
name|msg
operator|-=
literal|8
expr_stmt|;
name|devc
operator|->
name|m_left
operator|=
name|len_tab
index|[
name|msg
index|]
expr_stmt|;
name|devc
operator|->
name|m_ptr
operator|=
literal|1
expr_stmt|;
name|devc
operator|->
name|m_buf
index|[
literal|0
index|]
operator|=
name|midic
expr_stmt|;
if|if
condition|(
name|devc
operator|->
name|m_left
operator|<=
literal|0
condition|)
block|{
name|devc
operator|->
name|m_state
operator|=
name|ST_INIT
expr_stmt|;
name|do_midi_msg
argument_list|(
name|devc
operator|->
name|synthno
argument_list|,
name|devc
operator|->
name|m_buf
argument_list|,
name|devc
operator|->
name|m_ptr
argument_list|)
expr_stmt|;
name|devc
operator|->
name|m_ptr
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|ST_SYSMSG
case|:
switch|switch
condition|(
name|midic
condition|)
block|{
case|case
literal|0xf0
case|:
name|printk
argument_list|(
literal|"<SYX>"
argument_list|)
expr_stmt|;
name|devc
operator|->
name|m_state
operator|=
name|ST_SYSEX
expr_stmt|;
break|break;
case|case
literal|0xf1
case|:
name|devc
operator|->
name|m_state
operator|=
name|ST_MTC
expr_stmt|;
break|break;
case|case
literal|0xf2
case|:
name|devc
operator|->
name|m_state
operator|=
name|ST_SONGPOS
expr_stmt|;
name|devc
operator|->
name|m_ptr
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|0xf3
case|:
name|devc
operator|->
name|m_state
operator|=
name|ST_SONGSEL
expr_stmt|;
break|break;
case|case
literal|0xf6
case|:
comment|/* printk("tune_request\n"); */
name|devc
operator|->
name|m_state
operator|=
name|ST_INIT
expr_stmt|;
comment|/* 	     *    Real time messages 	   */
case|case
literal|0xf8
case|:
comment|/* midi clock */
name|devc
operator|->
name|m_state
operator|=
name|ST_INIT
expr_stmt|;
name|timer_ext_event
argument_list|(
name|devc
argument_list|,
name|TMR_CLOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xfA
case|:
name|devc
operator|->
name|m_state
operator|=
name|ST_INIT
expr_stmt|;
name|timer_ext_event
argument_list|(
name|devc
argument_list|,
name|TMR_START
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xFB
case|:
name|devc
operator|->
name|m_state
operator|=
name|ST_INIT
expr_stmt|;
name|timer_ext_event
argument_list|(
name|devc
argument_list|,
name|TMR_CONTINUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xFC
case|:
name|devc
operator|->
name|m_state
operator|=
name|ST_INIT
expr_stmt|;
name|timer_ext_event
argument_list|(
name|devc
argument_list|,
name|TMR_STOP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xFE
case|:
comment|/* active sensing */
name|devc
operator|->
name|m_state
operator|=
name|ST_INIT
expr_stmt|;
break|break;
case|case
literal|0xff
case|:
comment|/* printk("midi hard reset"); */
name|devc
operator|->
name|m_state
operator|=
name|ST_INIT
expr_stmt|;
break|break;
default|default:
name|printk
argument_list|(
literal|"unknown MIDI sysmsg %0x\n"
argument_list|,
name|midic
argument_list|)
expr_stmt|;
name|devc
operator|->
name|m_state
operator|=
name|ST_INIT
expr_stmt|;
block|}
break|break;
case|case
name|ST_MTC
case|:
name|devc
operator|->
name|m_state
operator|=
name|ST_INIT
expr_stmt|;
name|printk
argument_list|(
literal|"MTC frame %x02\n"
argument_list|,
name|midic
argument_list|)
expr_stmt|;
break|break;
case|case
name|ST_SYSEX
case|:
if|if
condition|(
name|midic
operator|==
literal|0xf7
condition|)
block|{
name|printk
argument_list|(
literal|"<EOX>"
argument_list|)
expr_stmt|;
name|devc
operator|->
name|m_state
operator|=
name|ST_INIT
expr_stmt|;
block|}
else|else
name|printk
argument_list|(
literal|"%02x "
argument_list|,
name|midic
argument_list|)
expr_stmt|;
break|break;
case|case
name|ST_SONGPOS
case|:
name|BUFTEST
argument_list|(
name|devc
argument_list|)
expr_stmt|;
name|devc
operator|->
name|m_buf
index|[
name|devc
operator|->
name|m_ptr
operator|++
index|]
operator|=
name|midic
expr_stmt|;
if|if
condition|(
name|devc
operator|->
name|m_ptr
operator|==
literal|2
condition|)
block|{
name|devc
operator|->
name|m_state
operator|=
name|ST_INIT
expr_stmt|;
name|devc
operator|->
name|m_ptr
operator|=
literal|0
expr_stmt|;
name|timer_ext_event
argument_list|(
name|devc
argument_list|,
name|TMR_SPP
argument_list|,
operator|(
operator|(
name|devc
operator|->
name|m_buf
index|[
literal|1
index|]
operator|&
literal|0x7f
operator|)
operator|<<
literal|7
operator|)
operator||
operator|(
name|devc
operator|->
name|m_buf
index|[
literal|0
index|]
operator|&
literal|0x7f
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ST_DATABYTE
case|:
name|BUFTEST
argument_list|(
name|devc
argument_list|)
expr_stmt|;
name|devc
operator|->
name|m_buf
index|[
name|devc
operator|->
name|m_ptr
operator|++
index|]
operator|=
name|midic
expr_stmt|;
if|if
condition|(
operator|(
operator|--
name|devc
operator|->
name|m_left
operator|)
operator|<=
literal|0
condition|)
block|{
name|devc
operator|->
name|m_state
operator|=
name|ST_INIT
expr_stmt|;
name|do_midi_msg
argument_list|(
name|devc
operator|->
name|synthno
argument_list|,
name|devc
operator|->
name|m_buf
argument_list|,
name|devc
operator|->
name|m_ptr
argument_list|)
expr_stmt|;
name|devc
operator|->
name|m_ptr
operator|=
literal|0
expr_stmt|;
block|}
break|break;
default|default:
name|printk
argument_list|(
literal|"Bad state %d "
argument_list|,
name|devc
operator|->
name|m_state
argument_list|)
expr_stmt|;
name|devc
operator|->
name|m_state
operator|=
name|ST_INIT
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mpu401_input_loop
parameter_list|(
name|struct
name|mpu_config
modifier|*
name|devc
parameter_list|)
block|{
name|unsigned
name|long
name|flags
decl_stmt|;
name|int
name|busy
decl_stmt|;
name|int
name|n
decl_stmt|;
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|busy
operator|=
name|devc
operator|->
name|m_busy
expr_stmt|;
name|devc
operator|->
name|m_busy
operator|=
literal|1
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|busy
condition|)
comment|/* Already inside the scanner */
return|return;
name|n
operator|=
literal|50
expr_stmt|;
while|while
condition|(
name|input_avail
argument_list|(
name|devc
operator|->
name|base
argument_list|)
operator|&&
name|n
operator|--
operator|>
literal|0
condition|)
block|{
name|unsigned
name|char
name|c
init|=
name|read_data
argument_list|(
name|devc
operator|->
name|base
argument_list|)
decl_stmt|;
if|if
condition|(
name|devc
operator|->
name|mode
operator|==
name|MODE_SYNTH
condition|)
block|{
name|mpu_input_scanner
argument_list|(
name|devc
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|devc
operator|->
name|opened
operator|&
name|OPEN_READ
operator|&&
name|devc
operator|->
name|inputintr
operator|!=
name|NULL
condition|)
name|devc
operator|->
name|inputintr
argument_list|(
name|devc
operator|->
name|devno
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
name|devc
operator|->
name|m_busy
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|void
name|mpuintr
argument_list|(
name|INT_HANDLER_PARMS
argument_list|(
name|irq
argument_list|,
name|dummy
argument_list|)
argument_list|)
block|{
name|struct
name|mpu_config
modifier|*
name|devc
decl_stmt|;
name|int
name|dev
decl_stmt|;
ifdef|#
directive|ifdef
name|linux
name|sti
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|irq
operator|<
literal|1
operator|||
name|irq
operator|>
literal|15
condition|)
block|{
name|printk
argument_list|(
literal|"MPU-401: Interrupt #%d?\n"
argument_list|,
name|irq
argument_list|)
expr_stmt|;
return|return;
block|}
name|dev
operator|=
name|irq2dev
index|[
name|irq
index|]
expr_stmt|;
if|if
condition|(
name|dev
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* printk ("MPU-401: Interrupt #%d?\n", irq); */
return|return;
block|}
name|devc
operator|=
operator|&
name|dev_conf
index|[
name|dev
index|]
expr_stmt|;
if|if
condition|(
name|input_avail
argument_list|(
name|devc
operator|->
name|base
argument_list|)
condition|)
if|if
condition|(
name|devc
operator|->
name|base
operator|!=
literal|0
operator|&&
operator|(
name|devc
operator|->
name|opened
operator|&
name|OPEN_READ
operator|||
name|devc
operator|->
name|mode
operator|==
name|MODE_SYNTH
operator|)
condition|)
name|mpu401_input_loop
argument_list|(
name|devc
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Dummy read (just to acknowledge the interrupt) */
name|read_data
argument_list|(
name|devc
operator|->
name|base
argument_list|)
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_function
specifier|static
name|int
name|mpu401_open
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|mode
parameter_list|,
name|void
function_decl|(
modifier|*
name|input
function_decl|)
parameter_list|(
name|int
name|dev
parameter_list|,
name|unsigned
name|char
name|data
parameter_list|)
parameter_list|,
name|void
function_decl|(
modifier|*
name|output
function_decl|)
parameter_list|(
name|int
name|dev
parameter_list|)
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|struct
name|mpu_config
modifier|*
name|devc
decl_stmt|;
if|if
condition|(
name|dev
operator|<
literal|0
operator|||
name|dev
operator|>=
name|num_midis
condition|)
return|return
name|RET_ERROR
argument_list|(
name|ENXIO
argument_list|)
return|;
name|devc
operator|=
operator|&
name|dev_conf
index|[
name|dev
index|]
expr_stmt|;
if|if
condition|(
name|devc
operator|->
name|opened
condition|)
block|{
name|printk
argument_list|(
literal|"MPU-401: Midi busy\n"
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|EBUSY
argument_list|)
return|;
block|}
comment|/*      *  Verify that the device is really running.      *  Some devices (such as Ensoniq SoundScape don't      *  work before the on board processor (OBP) is initialized      *  by downloadin it's microcode.    */
if|if
condition|(
operator|!
name|devc
operator|->
name|initialized
condition|)
block|{
if|if
condition|(
name|mpu401_status
argument_list|(
name|devc
operator|->
name|base
argument_list|)
operator|==
literal|0xff
condition|)
comment|/* Bus float */
block|{
name|printk
argument_list|(
literal|"MPU-401: Device not initialized properly\n"
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
block|}
name|reset_mpu401
argument_list|(
name|devc
argument_list|)
expr_stmt|;
block|}
name|irq2dev
index|[
name|devc
operator|->
name|irq
index|]
operator|=
name|dev
expr_stmt|;
if|if
condition|(
name|devc
operator|->
name|shared_irq
operator|==
literal|0
condition|)
if|if
condition|(
operator|(
name|err
operator|=
name|snd_set_irq_handler
argument_list|(
name|devc
operator|->
name|irq
argument_list|,
name|mpuintr
argument_list|,
name|midi_devs
index|[
name|dev
index|]
operator|->
name|info
operator|.
name|name
argument_list|)
operator|<
literal|0
operator|)
condition|)
block|{
return|return
name|err
return|;
block|}
if|if
condition|(
name|midi_devs
index|[
name|dev
index|]
operator|->
name|coproc
condition|)
if|if
condition|(
operator|(
name|err
operator|=
name|midi_devs
index|[
name|dev
index|]
operator|->
name|coproc
operator|->
name|open
argument_list|(
name|midi_devs
index|[
name|dev
index|]
operator|->
name|coproc
operator|->
name|devc
argument_list|,
name|COPR_MIDI
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|devc
operator|->
name|shared_irq
operator|==
literal|0
condition|)
name|snd_release_irq
argument_list|(
name|devc
operator|->
name|irq
argument_list|)
expr_stmt|;
name|printk
argument_list|(
literal|"MPU-401: Can't access coprocessor device\n"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|set_uart_mode
argument_list|(
name|dev
argument_list|,
name|devc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|devc
operator|->
name|mode
operator|=
name|MODE_MIDI
expr_stmt|;
name|devc
operator|->
name|synthno
operator|=
literal|0
expr_stmt|;
name|mpu401_input_loop
argument_list|(
name|devc
argument_list|)
expr_stmt|;
name|devc
operator|->
name|inputintr
operator|=
name|input
expr_stmt|;
name|devc
operator|->
name|opened
operator|=
name|mode
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mpu401_close
parameter_list|(
name|int
name|dev
parameter_list|)
block|{
name|struct
name|mpu_config
modifier|*
name|devc
decl_stmt|;
name|devc
operator|=
operator|&
name|dev_conf
index|[
name|dev
index|]
expr_stmt|;
if|if
condition|(
name|devc
operator|->
name|uart_mode
condition|)
name|reset_mpu401
argument_list|(
name|devc
argument_list|)
expr_stmt|;
comment|/* 				 * This disables the UART mode 				 */
name|devc
operator|->
name|mode
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|devc
operator|->
name|shared_irq
operator|==
literal|0
condition|)
name|snd_release_irq
argument_list|(
name|devc
operator|->
name|irq
argument_list|)
expr_stmt|;
name|devc
operator|->
name|inputintr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|midi_devs
index|[
name|dev
index|]
operator|->
name|coproc
condition|)
name|midi_devs
index|[
name|dev
index|]
operator|->
name|coproc
operator|->
name|close
argument_list|(
name|midi_devs
index|[
name|dev
index|]
operator|->
name|coproc
operator|->
name|devc
argument_list|,
name|COPR_MIDI
argument_list|)
expr_stmt|;
name|devc
operator|->
name|opened
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mpu401_out
parameter_list|(
name|int
name|dev
parameter_list|,
name|unsigned
name|char
name|midi_byte
parameter_list|)
block|{
name|int
name|timeout
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|struct
name|mpu_config
modifier|*
name|devc
decl_stmt|;
name|devc
operator|=
operator|&
name|dev_conf
index|[
name|dev
index|]
expr_stmt|;
if|#
directive|if
literal|0
comment|/*    * Test for input since pending input seems to block the output.    */
block|if (input_avail (devc->base))     {       mpu401_input_loop (devc);     }
endif|#
directive|endif
comment|/*    * Sometimes it takes about 13000 loops before the output becomes ready    * (After reset). Normally it takes just about 10 loops.    */
for|for
control|(
name|timeout
operator|=
literal|3000
init|;
name|timeout
operator|>
literal|0
operator|&&
operator|!
name|output_ready
argument_list|(
name|devc
operator|->
name|base
argument_list|)
condition|;
name|timeout
operator|--
control|)
empty_stmt|;
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|output_ready
argument_list|(
name|devc
operator|->
name|base
argument_list|)
condition|)
block|{
name|printk
argument_list|(
literal|"MPU-401: Send data timeout\n"
argument_list|)
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|write_data
argument_list|(
name|devc
operator|->
name|base
argument_list|,
name|midi_byte
argument_list|)
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mpu401_command
parameter_list|(
name|int
name|dev
parameter_list|,
name|mpu_command_rec
modifier|*
name|cmd
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|timeout
decl_stmt|,
name|ok
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|struct
name|mpu_config
modifier|*
name|devc
decl_stmt|;
name|devc
operator|=
operator|&
name|dev_conf
index|[
name|dev
index|]
expr_stmt|;
if|if
condition|(
name|devc
operator|->
name|uart_mode
condition|)
comment|/* 				 * Not possible in UART mode 				 */
block|{
name|printk
argument_list|(
literal|"MPU-401 commands not possible in the UART mode\n"
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
comment|/*    * Test for input since pending input seems to block the output.    */
if|if
condition|(
name|input_avail
argument_list|(
name|devc
operator|->
name|base
argument_list|)
condition|)
name|mpu401_input_loop
argument_list|(
name|devc
argument_list|)
expr_stmt|;
comment|/*    * Sometimes it takes about 30000 loops before the output becomes ready    * (After reset). Normally it takes just about 10 loops.    */
name|timeout
operator|=
literal|30000
expr_stmt|;
name|retry
label|:
if|if
condition|(
name|timeout
operator|--
operator|<=
literal|0
condition|)
block|{
name|printk
argument_list|(
literal|"MPU-401: Command (0x%x) timeout\n"
argument_list|,
operator|(
name|int
operator|)
name|cmd
operator|->
name|cmd
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
block|}
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|output_ready
argument_list|(
name|devc
operator|->
name|base
argument_list|)
condition|)
block|{
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|write_command
argument_list|(
name|devc
operator|->
name|base
argument_list|,
name|cmd
operator|->
name|cmd
argument_list|)
expr_stmt|;
name|ok
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|timeout
operator|=
literal|50000
init|;
name|timeout
operator|>
literal|0
operator|&&
operator|!
name|ok
condition|;
name|timeout
operator|--
control|)
if|if
condition|(
name|input_avail
argument_list|(
name|devc
operator|->
name|base
argument_list|)
condition|)
block|{
if|if
condition|(
name|mpu_input_scanner
argument_list|(
name|devc
argument_list|,
name|read_data
argument_list|(
name|devc
operator|->
name|base
argument_list|)
argument_list|)
operator|==
name|MPU_ACK
condition|)
name|ok
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
comment|/*       printk ("MPU: No ACK to command (0x%x)\n", (int) cmd->cmd); */
return|return
name|RET_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
block|}
if|if
condition|(
name|cmd
operator|->
name|nr_args
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cmd
operator|->
name|nr_args
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|timeout
operator|=
literal|3000
init|;
name|timeout
operator|>
literal|0
operator|&&
operator|!
name|output_ready
argument_list|(
name|devc
operator|->
name|base
argument_list|)
condition|;
name|timeout
operator|--
control|)
empty_stmt|;
if|if
condition|(
operator|!
name|mpu401_out
argument_list|(
name|dev
argument_list|,
name|cmd
operator|->
name|data
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|printk
argument_list|(
literal|"MPU: Command (0x%x), parm send failed.\n"
argument_list|,
operator|(
name|int
operator|)
name|cmd
operator|->
name|cmd
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
block|}
block|}
name|ret
operator|=
literal|0
expr_stmt|;
name|cmd
operator|->
name|data
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|nr_returns
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cmd
operator|->
name|nr_returns
condition|;
name|i
operator|++
control|)
block|{
name|ok
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|timeout
operator|=
literal|5000
init|;
name|timeout
operator|>
literal|0
operator|&&
operator|!
name|ok
condition|;
name|timeout
operator|--
control|)
if|if
condition|(
name|input_avail
argument_list|(
name|devc
operator|->
name|base
argument_list|)
condition|)
block|{
name|cmd
operator|->
name|data
index|[
name|i
index|]
operator|=
name|read_data
argument_list|(
name|devc
operator|->
name|base
argument_list|)
expr_stmt|;
name|ok
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
comment|/* printk ("MPU: No response(%d) to command (0x%x)\n", i, (int) cmd->cmd); */
return|return
name|RET_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
block|}
block|}
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|exec_cmd
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|cmd
parameter_list|,
name|int
name|data
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
specifier|static
name|mpu_command_rec
name|rec
decl_stmt|;
name|rec
operator|.
name|cmd
operator|=
name|cmd
operator|&
literal|0xff
expr_stmt|;
name|rec
operator|.
name|nr_args
operator|=
operator|(
operator|(
name|cmd
operator|&
literal|0xf0
operator|)
operator|==
literal|0xE0
operator|)
expr_stmt|;
name|rec
operator|.
name|nr_returns
operator|=
operator|(
operator|(
name|cmd
operator|&
literal|0xf0
operator|)
operator|==
literal|0xA0
operator|)
expr_stmt|;
name|rec
operator|.
name|data
index|[
literal|0
index|]
operator|=
name|data
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|mpu401_command
argument_list|(
name|dev
argument_list|,
operator|&
name|rec
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|ret
return|;
return|return
operator|(
name|unsigned
name|char
operator|)
name|rec
operator|.
name|data
index|[
literal|0
index|]
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mpu401_prefix_cmd
parameter_list|(
name|int
name|dev
parameter_list|,
name|unsigned
name|char
name|status
parameter_list|)
block|{
name|struct
name|mpu_config
modifier|*
name|devc
init|=
operator|&
name|dev_conf
index|[
name|dev
index|]
decl_stmt|;
if|if
condition|(
name|devc
operator|->
name|uart_mode
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|status
operator|<
literal|0xf0
condition|)
block|{
if|if
condition|(
name|exec_cmd
argument_list|(
name|dev
argument_list|,
literal|0xD0
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
switch|switch
condition|(
name|status
condition|)
block|{
case|case
literal|0xF0
case|:
if|if
condition|(
name|exec_cmd
argument_list|(
name|dev
argument_list|,
literal|0xDF
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mpu401_start_read
parameter_list|(
name|int
name|dev
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mpu401_end_read
parameter_list|(
name|int
name|dev
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mpu401_ioctl
parameter_list|(
name|int
name|dev
parameter_list|,
name|unsigned
name|cmd
parameter_list|,
name|unsigned
name|arg
parameter_list|)
block|{
name|struct
name|mpu_config
modifier|*
name|devc
decl_stmt|;
name|devc
operator|=
operator|&
name|dev_conf
index|[
name|dev
index|]
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
literal|1
case|:
name|IOCTL_FROM_USER
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|init_sequence
argument_list|,
operator|(
name|char
operator|*
operator|)
name|arg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|init_sequence
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
break|break;
case|case
name|SNDCTL_MIDI_MPUMODE
case|:
if|if
condition|(
name|devc
operator|->
name|version
operator|==
literal|0
condition|)
block|{
name|printk
argument_list|(
literal|"MPU-401: Intelligent mode not supported by the HW\n"
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|set_uart_mode
argument_list|(
name|dev
argument_list|,
name|devc
argument_list|,
operator|!
name|IOCTL_IN
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
break|break;
case|case
name|SNDCTL_MIDI_MPUCMD
case|:
block|{
name|int
name|ret
decl_stmt|;
name|mpu_command_rec
name|rec
decl_stmt|;
name|IOCTL_FROM_USER
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|rec
argument_list|,
operator|(
name|char
operator|*
operator|)
name|arg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|rec
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|mpu401_command
argument_list|(
name|dev
argument_list|,
operator|&
name|rec
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|ret
return|;
name|IOCTL_TO_USER
argument_list|(
operator|(
name|char
operator|*
operator|)
name|arg
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|rec
argument_list|,
sizeof|sizeof
argument_list|(
name|rec
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
default|default:
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mpu401_kick
parameter_list|(
name|int
name|dev
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|int
name|mpu401_buffer_status
parameter_list|(
name|int
name|dev
parameter_list|)
block|{
return|return
literal|0
return|;
comment|/* 				 * No data in buffers 				 */
block|}
end_function

begin_function
specifier|static
name|int
name|mpu_synth_ioctl
parameter_list|(
name|int
name|dev
parameter_list|,
name|unsigned
name|int
name|cmd
parameter_list|,
name|unsigned
name|int
name|arg
parameter_list|)
block|{
name|int
name|midi_dev
decl_stmt|;
name|struct
name|mpu_config
modifier|*
name|devc
decl_stmt|;
name|midi_dev
operator|=
name|synth_devs
index|[
name|dev
index|]
operator|->
name|midi_dev
expr_stmt|;
if|if
condition|(
name|midi_dev
operator|<
literal|0
operator|||
name|midi_dev
operator|>
name|num_midis
condition|)
return|return
name|RET_ERROR
argument_list|(
name|ENXIO
argument_list|)
return|;
name|devc
operator|=
operator|&
name|dev_conf
index|[
name|midi_dev
index|]
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SNDCTL_SYNTH_INFO
case|:
name|IOCTL_TO_USER
argument_list|(
operator|(
name|char
operator|*
operator|)
name|arg
argument_list|,
literal|0
argument_list|,
operator|&
name|mpu_synth_info
index|[
name|midi_dev
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|synth_info
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
break|break;
case|case
name|SNDCTL_SYNTH_MEMAVL
case|:
return|return
literal|0x7fffffff
return|;
break|break;
default|default:
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|mpu_synth_open
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|int
name|midi_dev
decl_stmt|,
name|err
decl_stmt|;
name|struct
name|mpu_config
modifier|*
name|devc
decl_stmt|;
name|midi_dev
operator|=
name|synth_devs
index|[
name|dev
index|]
operator|->
name|midi_dev
expr_stmt|;
if|if
condition|(
name|midi_dev
operator|<
literal|0
operator|||
name|midi_dev
operator|>
name|num_midis
condition|)
block|{
return|return
name|RET_ERROR
argument_list|(
name|ENXIO
argument_list|)
return|;
block|}
name|devc
operator|=
operator|&
name|dev_conf
index|[
name|midi_dev
index|]
expr_stmt|;
comment|/*      *  Verify that the device is really running.      *  Some devices (such as Ensoniq SoundScape don't      *  work before the on board processor (OBP) is initialized      *  by downloadin it's microcode.    */
if|if
condition|(
operator|!
name|devc
operator|->
name|initialized
condition|)
block|{
if|if
condition|(
name|mpu401_status
argument_list|(
name|devc
operator|->
name|base
argument_list|)
operator|==
literal|0xff
condition|)
comment|/* Bus float */
block|{
name|printk
argument_list|(
literal|"MPU-401: Device not initialized properly\n"
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
block|}
name|reset_mpu401
argument_list|(
name|devc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|devc
operator|->
name|opened
condition|)
block|{
name|printk
argument_list|(
literal|"MPU-401: Midi busy\n"
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|EBUSY
argument_list|)
return|;
block|}
name|devc
operator|->
name|mode
operator|=
name|MODE_SYNTH
expr_stmt|;
name|devc
operator|->
name|synthno
operator|=
name|dev
expr_stmt|;
name|devc
operator|->
name|inputintr
operator|=
name|NULL
expr_stmt|;
name|irq2dev
index|[
name|devc
operator|->
name|irq
index|]
operator|=
name|midi_dev
expr_stmt|;
if|if
condition|(
name|devc
operator|->
name|shared_irq
operator|==
literal|0
condition|)
if|if
condition|(
operator|(
name|err
operator|=
name|snd_set_irq_handler
argument_list|(
name|devc
operator|->
name|irq
argument_list|,
name|mpuintr
argument_list|,
name|midi_devs
index|[
name|midi_dev
index|]
operator|->
name|info
operator|.
name|name
argument_list|)
operator|<
literal|0
operator|)
condition|)
block|{
return|return
name|err
return|;
block|}
if|if
condition|(
name|midi_devs
index|[
name|midi_dev
index|]
operator|->
name|coproc
condition|)
if|if
condition|(
operator|(
name|err
operator|=
name|midi_devs
index|[
name|midi_dev
index|]
operator|->
name|coproc
operator|->
name|open
argument_list|(
name|midi_devs
index|[
name|midi_dev
index|]
operator|->
name|coproc
operator|->
name|devc
argument_list|,
name|COPR_MIDI
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|devc
operator|->
name|shared_irq
operator|==
literal|0
condition|)
name|snd_release_irq
argument_list|(
name|devc
operator|->
name|irq
argument_list|)
expr_stmt|;
name|printk
argument_list|(
literal|"MPU-401: Can't access coprocessor device\n"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|devc
operator|->
name|opened
operator|=
name|mode
expr_stmt|;
name|reset_mpu401
argument_list|(
name|devc
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|OPEN_READ
condition|)
block|{
name|exec_cmd
argument_list|(
name|midi_dev
argument_list|,
literal|0x8B
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Enable data in stop mode */
name|exec_cmd
argument_list|(
name|midi_dev
argument_list|,
literal|0x34
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Return timing bytes in stop mode */
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mpu_synth_close
parameter_list|(
name|int
name|dev
parameter_list|)
block|{
name|int
name|midi_dev
decl_stmt|;
name|struct
name|mpu_config
modifier|*
name|devc
decl_stmt|;
name|midi_dev
operator|=
name|synth_devs
index|[
name|dev
index|]
operator|->
name|midi_dev
expr_stmt|;
name|devc
operator|=
operator|&
name|dev_conf
index|[
name|midi_dev
index|]
expr_stmt|;
name|exec_cmd
argument_list|(
name|midi_dev
argument_list|,
literal|0x15
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Stop recording, playback and MIDI */
name|exec_cmd
argument_list|(
name|midi_dev
argument_list|,
literal|0x8a
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Disable data in stopped mode */
if|if
condition|(
name|devc
operator|->
name|shared_irq
operator|==
literal|0
condition|)
name|snd_release_irq
argument_list|(
name|devc
operator|->
name|irq
argument_list|)
expr_stmt|;
name|devc
operator|->
name|inputintr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|midi_devs
index|[
name|midi_dev
index|]
operator|->
name|coproc
condition|)
name|midi_devs
index|[
name|midi_dev
index|]
operator|->
name|coproc
operator|->
name|close
argument_list|(
name|midi_devs
index|[
name|midi_dev
index|]
operator|->
name|coproc
operator|->
name|devc
argument_list|,
name|COPR_MIDI
argument_list|)
expr_stmt|;
name|devc
operator|->
name|opened
operator|=
literal|0
expr_stmt|;
name|devc
operator|->
name|mode
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|MIDI_SYNTH_NAME
value|"MPU-401 UART Midi"
end_define

begin_define
define|#
directive|define
name|MIDI_SYNTH_CAPS
value|SYNTH_CAP_INPUT
end_define

begin_include
include|#
directive|include
file|<i386/isa/sound/midi_synth.h>
end_include

begin_decl_stmt
specifier|static
name|struct
name|synth_operations
name|mpu401_synth_proto
init|=
block|{
name|NULL
block|,
literal|0
block|,
name|SYNTH_TYPE_MIDI
block|,
literal|0
block|,
name|mpu_synth_open
block|,
name|mpu_synth_close
block|,
name|mpu_synth_ioctl
block|,
name|midi_synth_kill_note
block|,
name|midi_synth_start_note
block|,
name|midi_synth_set_instr
block|,
name|midi_synth_reset
block|,
name|midi_synth_hw_control
block|,
name|midi_synth_load_patch
block|,
name|midi_synth_aftertouch
block|,
name|midi_synth_controller
block|,
name|midi_synth_panning
block|,
name|NULL
block|,
name|midi_synth_patchmgr
block|,
name|midi_synth_bender
block|,
name|NULL
block|,
comment|/* alloc */
name|midi_synth_setup_voice
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|synth_operations
name|mpu401_synth_operations
index|[
name|MAX_MIDI_DEV
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|midi_operations
name|mpu401_midi_proto
init|=
block|{
block|{
literal|"MPU-401 Midi"
block|,
literal|0
block|,
name|MIDI_CAP_MPU401
block|,
name|SNDCARD_MPU401
block|}
block|,
name|NULL
block|,
block|{
literal|0
block|}
block|,
name|mpu401_open
block|,
name|mpu401_close
block|,
name|mpu401_ioctl
block|,
name|mpu401_out
block|,
name|mpu401_start_read
block|,
name|mpu401_end_read
block|,
name|mpu401_kick
block|,
name|NULL
block|,
name|mpu401_buffer_status
block|,
name|mpu401_prefix_cmd
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|midi_operations
name|mpu401_midi_operations
index|[
name|MAX_MIDI_DEV
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|mpu401_chk_version
parameter_list|(
name|struct
name|mpu_config
modifier|*
name|devc
parameter_list|)
block|{
name|int
name|tmp
decl_stmt|;
name|devc
operator|->
name|version
operator|=
name|devc
operator|->
name|revision
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|tmp
operator|=
name|exec_cmd
argument_list|(
name|num_midis
argument_list|,
literal|0xAC
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
operator|(
name|tmp
operator|&
literal|0xf0
operator|)
operator|>
literal|0x20
condition|)
comment|/* Why it's larger than 2.x ??? */
return|return;
name|devc
operator|->
name|version
operator|=
name|tmp
expr_stmt|;
if|if
condition|(
operator|(
name|tmp
operator|=
name|exec_cmd
argument_list|(
name|num_midis
argument_list|,
literal|0xAD
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|devc
operator|->
name|version
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|devc
operator|->
name|revision
operator|=
name|tmp
expr_stmt|;
block|}
end_function

begin_function
name|long
name|attach_mpu401
parameter_list|(
name|long
name|mem_start
parameter_list|,
name|struct
name|address_info
modifier|*
name|hw_config
parameter_list|)
block|{
name|unsigned
name|long
name|flags
decl_stmt|;
name|char
name|revision_char
decl_stmt|;
name|struct
name|mpu_config
modifier|*
name|devc
decl_stmt|;
if|if
condition|(
name|num_midis
operator|>=
name|MAX_MIDI_DEV
condition|)
block|{
name|printk
argument_list|(
literal|"MPU-401: Too many midi devices detected\n"
argument_list|)
expr_stmt|;
return|return
name|mem_start
return|;
block|}
name|devc
operator|=
operator|&
name|dev_conf
index|[
name|num_midis
index|]
expr_stmt|;
name|devc
operator|->
name|base
operator|=
name|hw_config
operator|->
name|io_base
expr_stmt|;
name|devc
operator|->
name|irq
operator|=
name|hw_config
operator|->
name|irq
expr_stmt|;
name|devc
operator|->
name|opened
operator|=
literal|0
expr_stmt|;
name|devc
operator|->
name|uart_mode
operator|=
literal|0
expr_stmt|;
name|devc
operator|->
name|initialized
operator|=
literal|0
expr_stmt|;
name|devc
operator|->
name|version
operator|=
literal|0
expr_stmt|;
name|devc
operator|->
name|revision
operator|=
literal|0
expr_stmt|;
name|devc
operator|->
name|capabilities
operator|=
literal|0
expr_stmt|;
name|devc
operator|->
name|timer_flag
operator|=
literal|0
expr_stmt|;
name|devc
operator|->
name|m_busy
operator|=
literal|0
expr_stmt|;
name|devc
operator|->
name|m_state
operator|=
name|ST_INIT
expr_stmt|;
name|devc
operator|->
name|shared_irq
operator|=
name|hw_config
operator|->
name|always_detect
expr_stmt|;
if|if
condition|(
operator|!
name|hw_config
operator|->
name|always_detect
condition|)
block|{
comment|/* Verify the hardware again */
if|if
condition|(
operator|!
name|reset_mpu401
argument_list|(
name|devc
argument_list|)
condition|)
return|return
name|mem_start
return|;
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|mpu401_chk_version
argument_list|(
name|devc
argument_list|)
expr_stmt|;
if|if
condition|(
name|devc
operator|->
name|version
operator|==
literal|0
condition|)
name|mpu401_chk_version
argument_list|(
name|devc
argument_list|)
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|devc
operator|->
name|version
operator|==
literal|0
condition|)
block|{
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|mpu401_synth_operations
index|[
name|num_midis
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|std_midi_synth
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|synth_operations
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|devc
operator|->
name|capabilities
operator||=
name|MPU_CAP_INTLG
expr_stmt|;
comment|/* Supports intelligent mode */
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|mpu401_synth_operations
index|[
name|num_midis
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|mpu401_synth_proto
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|synth_operations
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|mpu401_midi_operations
index|[
name|num_midis
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|mpu401_midi_proto
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|midi_operations
argument_list|)
argument_list|)
expr_stmt|;
name|mpu401_midi_operations
index|[
name|num_midis
index|]
operator|.
name|converter
operator|=
operator|&
name|mpu401_synth_operations
index|[
name|num_midis
index|]
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|mpu_synth_info
index|[
name|num_midis
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|mpu_synth_info_proto
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|synth_info
argument_list|)
argument_list|)
expr_stmt|;
name|n_mpu_devs
operator|++
expr_stmt|;
if|if
condition|(
name|devc
operator|->
name|version
operator|==
literal|0x20
operator|&&
name|devc
operator|->
name|revision
operator|>=
literal|0x07
condition|)
comment|/* MusicQuest interface */
block|{
name|int
name|ports
init|=
operator|(
name|devc
operator|->
name|revision
operator|&
literal|0x08
operator|)
condition|?
literal|32
else|:
literal|16
decl_stmt|;
name|devc
operator|->
name|capabilities
operator||=
name|MPU_CAP_SYNC
operator||
name|MPU_CAP_SMPTE
operator||
name|MPU_CAP_CLS
operator||
name|MPU_CAP_2PORT
expr_stmt|;
name|revision_char
operator|=
operator|(
name|devc
operator|->
name|revision
operator|==
literal|0x7f
operator|)
condition|?
literal|'M'
else|:
literal|' '
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|printk
argument_list|(
literal|"mpu0:<MQX-%d%c MIDI Interface>"
argument_list|,
else|#
directive|else
argument|printk (
literal|"<MQX-%d%c MIDI Interface>"
argument|,
endif|#
directive|endif
argument|ports, 	      revision_char);       sprintf (mpu_synth_info[num_midis].name,
literal|"MQX-%d%c MIDI Interface #%d"
argument|, 	       ports, 	       revision_char, 	       n_mpu_devs);     }   else     {        revision_char = devc->revision ? devc->revision +
literal|'@'
argument|:
literal|' '
argument|;       if (devc->revision> (
literal|'Z'
argument|-
literal|'@'
argument|)) 	revision_char =
literal|'+'
argument|;        devc->capabilities |= MPU_CAP_SYNC | MPU_CAP_FSK;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
argument|printk (
literal|"mpu0:<MPU-401 MIDI Interface %d.%d%c>"
argument|,
else|#
directive|else
argument|printk (
literal|"<MPU-401 MIDI Interface %d.%d%c>"
argument|,
endif|#
directive|endif
argument|(devc->version&
literal|0xf0
argument|)>>
literal|4
argument|, 	      devc->version&
literal|0x0f
argument|, 	      revision_char);       sprintf (mpu_synth_info[num_midis].name,
literal|"MPU-401 %d.%d%c Midi interface #%d"
argument|, 	       (devc->version&
literal|0xf0
argument|)>>
literal|4
argument|, 	       devc->version&
literal|0x0f
argument|, 	       revision_char, 	       n_mpu_devs);     }    strcpy (mpu401_midi_operations[num_midis].info.name, 	  mpu_synth_info[num_midis].name);    mpu401_synth_operations[num_midis].midi_dev = devc->devno = num_midis;   mpu401_synth_operations[devc->devno].info =&mpu_synth_info[devc->devno];    if (devc->capabilities& MPU_CAP_INTLG)
comment|/* Has timer */
argument|mpu_timer_init (num_midis);    irq2dev[devc->irq] = num_midis;   midi_devs[num_midis++] =&mpu401_midi_operations[devc->devno];   return mem_start; }  static int reset_mpu401 (struct mpu_config *devc) {   unsigned long   flags;   int             ok, timeout, n;   int             timeout_limit;
comment|/*    * Send the RESET command. Try again if no success at the first time.    * (If the device is in the UART mode, it will not ack the reset cmd).    */
argument|ok =
literal|0
argument|;    timeout_limit = devc->initialized ?
literal|30000
argument|:
literal|100000
argument|;   devc->initialized =
literal|1
argument|;    for (n =
literal|0
argument|; n<
literal|2
argument|&& !ok; n++)     {       for (timeout = timeout_limit; timeout>
literal|0
argument|&& !ok; timeout--) 	ok = output_ready (devc->base);        write_command (devc->base, MPU_RESET);
comment|/* 						 * Send MPU-401 RESET Command 						 */
comment|/*        * Wait at least 25 msec. This method is not accurate so let's make the        * loop bit longer. Cannot sleep since this is called during boot.        */
argument|for (timeout = timeout_limit *
literal|2
argument|; timeout>
literal|0
argument|&& !ok; timeout--) 	{ 	  DISABLE_INTR (flags); 	  if (input_avail (devc->base)) 	    if (read_data (devc->base) == MPU_ACK) 	      ok =
literal|1
argument|; 	  RESTORE_INTR (flags); 	}      }    devc->m_state = ST_INIT;   devc->m_ptr =
literal|0
argument|;   devc->m_left =
literal|0
argument|;   devc->last_status =
literal|0
argument|;   devc->uart_mode =
literal|0
argument|;    return ok; }  static void set_uart_mode (int dev, struct mpu_config *devc, int arg) {    if (!arg&& devc->version ==
literal|0
argument|)     {       return;     }    if ((devc->uart_mode ==
literal|0
argument|) == (arg ==
literal|0
argument|))     {       return;
comment|/* Already set */
argument|}    reset_mpu401 (devc);
comment|/* This exits the uart mode */
argument|if (arg)     {       if (exec_cmd (dev, UART_MODE_ON,
literal|0
argument|)<
literal|0
argument|) 	{ 	  printk (
literal|"MPU%d: Can't enter UART mode\n"
argument|, devc->devno); 	  devc->uart_mode =
literal|0
argument|; 	  return; 	}     }   devc->uart_mode = arg;  }  int probe_mpu401 (struct address_info *hw_config) {   int             ok =
literal|0
argument|;   struct mpu_config tmp_devc;    tmp_devc.base = hw_config->io_base;   tmp_devc.irq = hw_config->irq;   tmp_devc.initialized =
literal|0
argument|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|EXCLUDE_AEDSP16
argument_list|)
operator|&&
name|defined
argument_list|(
name|AEDSP16_MPU401
argument_list|)
comment|/*      * Initialize Audio Excel DSP 16 to MPU-401, before any operation.    */
argument|InitAEDSP16_MPU401 (hw_config);
endif|#
directive|endif
argument|if (hw_config->always_detect)     return
literal|1
argument|;    if (INB (hw_config->io_base +
literal|1
argument|) ==
literal|0xff
argument|)     return
literal|0
argument|;
comment|/* Just bus float? */
argument|ok = reset_mpu401 (&tmp_devc);    return ok; }
comment|/*****************************************************  *      Timer stuff  ****************************************************/
if|#
directive|if
operator|!
name|defined
argument_list|(
name|EXCLUDE_SEQUENCER
argument_list|)
argument|static volatile int timer_initialized =
literal|0
argument|, timer_open =
literal|0
argument|, tmr_running =
literal|0
argument|; static volatile int curr_tempo, curr_timebase, hw_timebase; static int      max_timebase =
literal|8
argument|;
comment|/* 8*24=192 ppqn */
argument|static volatile unsigned long next_event_time; static volatile unsigned long curr_ticks, curr_clocks; static unsigned long prev_event_time; static int      metronome_mode;  static unsigned long clocks2ticks (unsigned long clocks) {
comment|/*      * The MPU-401 supports just a limited set of possible timebase values.      * Since the applications require more choices, the driver has to      * program the HW to do it's best and to convert between the HW and      * actual timebases.    */
argument|return ((clocks * curr_timebase) + (hw_timebase /
literal|2
argument|)) / hw_timebase; }  static void set_timebase (int midi_dev, int val) {   int             hw_val;    if (val<
literal|48
argument|)     val =
literal|48
argument|;   if (val>
literal|1000
argument|)     val =
literal|1000
argument|;    hw_val = val;   hw_val = (hw_val +
literal|23
argument|) /
literal|24
argument|;   if (hw_val> max_timebase)     hw_val = max_timebase;    if (exec_cmd (midi_dev,
literal|0xC0
argument|| (hw_val&
literal|0x0f
argument|),
literal|0
argument|)<
literal|0
argument|)     {       printk (
literal|"MPU: Can't set HW timebase to %d\n"
argument|, hw_val *
literal|24
argument|);       return;     }   hw_timebase = hw_val *
literal|24
argument|;   curr_timebase = val;  }  static void tmr_reset (void) {   unsigned long   flags;    DISABLE_INTR (flags);   next_event_time =
literal|0xffffffff
argument|;   prev_event_time =
literal|0
argument|;   curr_ticks = curr_clocks =
literal|0
argument|;   RESTORE_INTR (flags); }  static void set_timer_mode (int midi_dev) {   if (timer_mode& TMR_MODE_CLS)     exec_cmd (midi_dev,
literal|0x3c
argument|,
literal|0
argument|);
comment|/* Use CLS sync */
argument|else if (timer_mode& TMR_MODE_SMPTE)     exec_cmd (midi_dev,
literal|0x3d
argument|,
literal|0
argument|);
comment|/* Use SMPTE sync */
argument|if (timer_mode& TMR_INTERNAL)     {       exec_cmd (midi_dev,
literal|0x80
argument|,
literal|0
argument|);
comment|/* Use MIDI sync */
argument|}   else     {       if (timer_mode& (TMR_MODE_MIDI | TMR_MODE_CLS)) 	{ 	  exec_cmd (midi_dev,
literal|0x82
argument|,
literal|0
argument|);
comment|/* Use MIDI sync */
argument|exec_cmd (midi_dev,
literal|0x91
argument|,
literal|0
argument|);
comment|/* Enable ext MIDI ctrl */
argument|}       else if (timer_mode& TMR_MODE_FSK) 	exec_cmd (midi_dev,
literal|0x81
argument|,
literal|0
argument|);
comment|/* Use FSK sync */
argument|} }  static void stop_metronome (int midi_dev) {   exec_cmd (midi_dev,
literal|0x84
argument|,
literal|0
argument|);
comment|/* Disable metronome */
argument|}  static void setup_metronome (int midi_dev) {   int             numerator, denominator;   int             clks_per_click, num_32nds_per_beat;   int             beats_per_measure;    numerator = ((unsigned) metronome_mode>>
literal|24
argument|)&
literal|0xff
argument|;   denominator = ((unsigned) metronome_mode>>
literal|16
argument|)&
literal|0xff
argument|;   clks_per_click = ((unsigned) metronome_mode>>
literal|8
argument|)&
literal|0xff
argument|;   num_32nds_per_beat = (unsigned) metronome_mode&
literal|0xff
argument|;   beats_per_measure = (numerator *
literal|4
argument|)>> denominator;    if (!metronome_mode)     exec_cmd (midi_dev,
literal|0x84
argument|,
literal|0
argument|);
comment|/* Disable metronome */
argument|else     {       exec_cmd (midi_dev,
literal|0xE4
argument|, clks_per_click);       exec_cmd (midi_dev,
literal|0xE6
argument|, beats_per_measure);       exec_cmd (midi_dev,
literal|0x83
argument|,
literal|0
argument|);
comment|/* Enable metronome without accents */
argument|} }  static int start_timer (int midi_dev) {   tmr_reset ();   set_timer_mode (midi_dev);    if (tmr_running)     return TIMER_NOT_ARMED;
comment|/* Already running */
argument|if (timer_mode& TMR_INTERNAL)     {       exec_cmd (midi_dev,
literal|0x02
argument|,
literal|0
argument|);
comment|/* Send MIDI start */
argument|tmr_running =
literal|1
argument|;       return TIMER_NOT_ARMED;     }   else     {       exec_cmd (midi_dev,
literal|0x35
argument|,
literal|0
argument|);
comment|/* Enable mode messages to PC */
argument|exec_cmd (midi_dev,
literal|0x38
argument|,
literal|0
argument|);
comment|/* Enable sys common messages to PC */
argument|exec_cmd (midi_dev,
literal|0x39
argument|,
literal|0
argument|);
comment|/* Enable real time messages to PC */
argument|exec_cmd (midi_dev,
literal|0x97
argument|,
literal|0
argument|);
comment|/* Enable system exclusive messages to PC */
argument|}    return TIMER_ARMED; }  static int mpu_timer_open (int dev, int mode) {   int             midi_dev = sound_timer_devs[dev]->devlink;    if (timer_open)     return RET_ERROR (EBUSY);    tmr_reset ();   curr_tempo =
literal|50
argument|;   exec_cmd (midi_dev,
literal|0xE0
argument|,
literal|50
argument|);   curr_timebase = hw_timebase =
literal|120
argument|;   set_timebase (midi_dev,
literal|120
argument|);   timer_open =
literal|1
argument|;   metronome_mode =
literal|0
argument|;   set_timer_mode (midi_dev);    exec_cmd (midi_dev,
literal|0xe7
argument|,
literal|0x04
argument|);
comment|/* Send all clocks to host */
argument|exec_cmd (midi_dev,
literal|0x95
argument|,
literal|0
argument|);
comment|/* Enable clock to host */
argument|return
literal|0
argument|; }  static void mpu_timer_close (int dev) {   int             midi_dev = sound_timer_devs[dev]->devlink;    timer_open = tmr_running =
literal|0
argument|;   exec_cmd (midi_dev,
literal|0x15
argument|,
literal|0
argument|);
comment|/* Stop all */
argument|exec_cmd (midi_dev,
literal|0x94
argument|,
literal|0
argument|);
comment|/* Disable clock to host */
argument|exec_cmd (midi_dev,
literal|0x8c
argument|,
literal|0
argument|);
comment|/* Disable measure end messages to host */
argument|stop_metronome (midi_dev); }  static int mpu_timer_event (int dev, unsigned char *event) {   unsigned char   command = event[
literal|1
argument|];   unsigned long   parm = *(unsigned int *)&event[
literal|4
argument|];   int             midi_dev = sound_timer_devs[dev]->devlink;    switch (command)     {     case TMR_WAIT_REL:       parm += prev_event_time;     case TMR_WAIT_ABS:       if (parm>
literal|0
argument|) 	{ 	  long            time;  	  if (parm<= curr_ticks)
comment|/* It's the time */
argument|return TIMER_NOT_ARMED;  	  time = parm; 	  next_event_time = prev_event_time = time;  	  return TIMER_ARMED; 	}       break;      case TMR_START:       if (tmr_running) 	break;       return start_timer (midi_dev);       break;      case TMR_STOP:       exec_cmd (midi_dev,
literal|0x01
argument|,
literal|0
argument|);
comment|/* Send MIDI stop */
argument|stop_metronome (midi_dev);       tmr_running =
literal|0
argument|;       break;      case TMR_CONTINUE:       if (tmr_running) 	break;       exec_cmd (midi_dev,
literal|0x03
argument|,
literal|0
argument|);
comment|/* Send MIDI continue */
argument|setup_metronome (midi_dev);       tmr_running =
literal|1
argument|;       break;      case TMR_TEMPO:       if (parm) 	{ 	  if (parm<
literal|8
argument|) 	    parm =
literal|8
argument|; 	  if (parm>
literal|250
argument|) 	    parm =
literal|250
argument|;  	  if (exec_cmd (midi_dev,
literal|0xE0
argument|, parm)<
literal|0
argument|) 	    printk (
literal|"MPU: Can't set tempo to %d\n"
argument|, (int) parm); 	  curr_tempo = parm; 	}       break;      case TMR_ECHO:       seq_copy_to_input (event,
literal|8
argument|);       break;      case TMR_TIMESIG:       if (metronome_mode)
comment|/* Metronome enabled */
argument|{ 	  metronome_mode = parm; 	  setup_metronome (midi_dev); 	}       break;      default:;     }    return TIMER_NOT_ARMED; }  static unsigned long mpu_timer_get_time (int dev) {   if (!timer_open)     return
literal|0
argument|;    return curr_ticks; }  static int mpu_timer_ioctl (int dev, 		 unsigned int command, unsigned int arg) {   int             midi_dev = sound_timer_devs[dev]->devlink;    switch (command)     {     case SNDCTL_TMR_SOURCE:       { 	int             parm = IOCTL_IN (arg)& timer_caps;  	if (parm !=
literal|0
argument|) 	  { 	    timer_mode = parm;  	    if (timer_mode& TMR_MODE_CLS) 	      exec_cmd (midi_dev,
literal|0x3c
argument|,
literal|0
argument|);
comment|/* Use CLS sync */
argument|else if (timer_mode& TMR_MODE_SMPTE) 	      exec_cmd (midi_dev,
literal|0x3d
argument|,
literal|0
argument|);
comment|/* Use SMPTE sync */
argument|}  	return IOCTL_OUT (arg, timer_mode);       }       break;      case SNDCTL_TMR_START:       start_timer (midi_dev);       return
literal|0
argument|;       break;      case SNDCTL_TMR_STOP:       tmr_running =
literal|0
argument|;       exec_cmd (midi_dev,
literal|0x01
argument|,
literal|0
argument|);
comment|/* Send MIDI stop */
argument|stop_metronome (midi_dev);       return
literal|0
argument|;       break;      case SNDCTL_TMR_CONTINUE:       if (tmr_running) 	return
literal|0
argument|;       tmr_running =
literal|1
argument|;       exec_cmd (midi_dev,
literal|0x03
argument|,
literal|0
argument|);
comment|/* Send MIDI continue */
argument|return
literal|0
argument|;       break;      case SNDCTL_TMR_TIMEBASE:       { 	int             val = IOCTL_IN (arg);  	if (val) 	  set_timebase (midi_dev, val);  	return IOCTL_OUT (arg, curr_timebase);       }       break;      case SNDCTL_TMR_TEMPO:       { 	int             val = IOCTL_IN (arg); 	int             ret;  	if (val) 	  { 	    if (val<
literal|8
argument|) 	      val =
literal|8
argument|; 	    if (val>
literal|250
argument|) 	      val =
literal|250
argument|; 	    if ((ret = exec_cmd (midi_dev,
literal|0xE0
argument|, val))<
literal|0
argument|) 	      { 		printk (
literal|"MPU: Can't set tempo to %d\n"
argument|, (int) val); 		return ret; 	      }  	    curr_tempo = val; 	  }  	return IOCTL_OUT (arg, curr_tempo);       }       break;      case SNDCTL_SEQ_CTRLRATE:       if (IOCTL_IN (arg) !=
literal|0
argument|)
comment|/* Can't change */
argument|return RET_ERROR (EINVAL);        return IOCTL_OUT (arg, ((curr_tempo * curr_timebase) +
literal|30
argument|) /
literal|60
argument|);       break;      case SNDCTL_TMR_METRONOME:       metronome_mode = IOCTL_IN (arg);       setup_metronome (midi_dev);       return
literal|0
argument|;       break;      default:     }    return RET_ERROR (EINVAL); }  static void mpu_timer_arm (int dev, long time) {   if (time<
literal|0
argument|)     time = curr_ticks +
literal|1
argument|;   else if (time<= curr_ticks)
comment|/* It's the time */
argument|return;    next_event_time = prev_event_time = time;    return; }  static struct sound_timer_operations mpu_timer = {   {
literal|"MPU-401 Timer"
argument|,
literal|0
argument|},
literal|10
argument|,
comment|/* Priority */
literal|0
argument|,
comment|/* Local device link */
argument|mpu_timer_open,   mpu_timer_close,   mpu_timer_event,   mpu_timer_get_time,   mpu_timer_ioctl,   mpu_timer_arm };  static void mpu_timer_interrupt (void) {    if (!timer_open)     return;    if (!tmr_running)     return;    curr_clocks++;   curr_ticks = clocks2ticks (curr_clocks);    if (curr_ticks>= next_event_time)     {       next_event_time =
literal|0xffffffff
argument|;       sequencer_timer ();     } }  static void timer_ext_event (struct mpu_config *devc, int event, int parm) {   int             midi_dev = devc->devno;    if (!devc->timer_flag)     return;    switch (event)     {     case TMR_CLOCK:       printk (
literal|"<MIDI clk>"
argument|);       break;      case TMR_START:       printk (
literal|"Ext MIDI start\n"
argument|);       if (!tmr_running) 	if (timer_mode& TMR_EXTERNAL) 	  { 	    tmr_running =
literal|1
argument|; 	    setup_metronome (midi_dev); 	    next_event_time =
literal|0
argument|; 	    STORE (SEQ_START_TIMER ()); 	  }       break;      case TMR_STOP:       printk (
literal|"Ext MIDI stop\n"
argument|);       if (timer_mode& TMR_EXTERNAL) 	{ 	  tmr_running =
literal|0
argument|; 	  stop_metronome (midi_dev); 	  STORE (SEQ_STOP_TIMER ()); 	}       break;      case TMR_CONTINUE:       printk (
literal|"Ext MIDI continue\n"
argument|);       if (timer_mode& TMR_EXTERNAL) 	{ 	  tmr_running =
literal|1
argument|; 	  setup_metronome (midi_dev); 	  STORE (SEQ_CONTINUE_TIMER ()); 	}       break;      case TMR_SPP:       printk (
literal|"Songpos: %d\n"
argument|, parm);       if (timer_mode& TMR_EXTERNAL) 	{ 	  STORE (SEQ_SONGPOS (parm)); 	}       break;     } }  static void mpu_timer_init (int midi_dev) {   struct mpu_config *devc;   int             n;    devc =&dev_conf[midi_dev];    if (timer_initialized)     return;
comment|/* There is already a similar timer */
argument|timer_initialized =
literal|1
argument|;    mpu_timer.devlink = midi_dev;   dev_conf[midi_dev].timer_flag =
literal|1
argument|;
if|#
directive|if
literal|1
argument|if (num_sound_timers>= MAX_TIMER_DEV)     n =
literal|0
argument|;
comment|/* Overwrite the system timer */
argument|else     n = num_sound_timers++;
else|#
directive|else
argument|n =
literal|0
argument|;
endif|#
directive|endif
argument|sound_timer_devs[n] =&mpu_timer;    if (devc->version<
literal|0x20
argument|)
comment|/* Original MPU-401 */
argument|timer_caps = TMR_INTERNAL | TMR_EXTERNAL | TMR_MODE_FSK | TMR_MODE_MIDI;   else     {
comment|/*          * The version number 2.0 is used (at least) by the          * MusicQuest cards and the Roland Super-MPU.          *          * MusicQuest has given a special meaning to the bits of the          * revision number. The Super-MPU returns 0.        */
argument|if (devc->revision) 	timer_caps |= TMR_EXTERNAL | TMR_MODE_MIDI;        if (devc->revision&
literal|0x02
argument|) 	timer_caps |= TMR_MODE_CLS;
if|#
directive|if
literal|0
argument|if (devc->revision& 0x04) 	timer_caps |= TMR_MODE_SMPTE;
endif|#
directive|endif
argument|if (devc->revision&
literal|0x40
argument|) 	max_timebase =
literal|10
argument|;
comment|/* Has the 216 and 240 ppqn modes */
argument|}    timer_mode = (TMR_INTERNAL | TMR_MODE_MIDI)& timer_caps;  }
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

end_unit

