begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1991 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * William Jolitz.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	from: @(#)isa.c	7.2 (Berkeley) 5/13/91  *	$Id: pc98.c,v 1.10.2.8 1997/10/13 08:58:48 kato Exp $  */
end_comment

begin_comment
comment|/*  * code to manage AT bus  *  * 92/08/18  Frank P. MacLachlan (fpm@crash.cts.com):  * Fixed uninitialized variable problem and added code to deal  * with DMA page boundaries in isa_dmarangecheck().  Fixed word  * mode DMA count compution and reorganized DMA setup code in  * isa_dmastart()  */
end_comment

begin_comment
comment|/*  * modified for PC9801 by A.Kojima F.Ukai M.Ishii   *			Kyoto University Microcomputer Club (KMC)  */
end_comment

begin_include
include|#
directive|include
file|"opt_auto_eoi.h"
end_include

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/segments.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|PC98
end_ifdef

begin_include
include|#
directive|include
file|<machine/cpufunc.h>
end_include

begin_include
include|#
directive|include
file|<pc98/pc98/pc98.h>
end_include

begin_include
include|#
directive|include
file|<pc98/pc98/pc98_machdep.h>
end_include

begin_include
include|#
directive|include
file|<pc98/pc98/epsonio.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<i386/isa/isa.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<i386/isa/icu.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/ic/i8237.h>
end_include

begin_include
include|#
directive|include
file|"vector.h"
end_include

begin_comment
comment|/* **  Register definitions for DMA controller 1 (channels 0..3): */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PC98
end_ifdef

begin_define
define|#
directive|define
name|DMA1_CHN
parameter_list|(
name|c
parameter_list|)
value|(IO_DMA + (chan<<2))
end_define

begin_comment
comment|/* addr reg for channel c */
end_comment

begin_define
define|#
directive|define
name|DMA1_SMSK
value|(IO_DMA + 0x14)
end_define

begin_comment
comment|/* single mask register */
end_comment

begin_define
define|#
directive|define
name|DMA1_MODE
value|(IO_DMA + 0x16)
end_define

begin_comment
comment|/* mode register */
end_comment

begin_define
define|#
directive|define
name|DMA1_FFC
value|(IO_DMA + 0x18)
end_define

begin_comment
comment|/* clear first/last FF */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DMA1_CHN
parameter_list|(
name|c
parameter_list|)
value|(IO_DMA1 + 1*(2*(c)))
end_define

begin_comment
comment|/* addr reg for channel c */
end_comment

begin_define
define|#
directive|define
name|DMA1_SMSK
value|(IO_DMA1 + 1*10)
end_define

begin_comment
comment|/* single mask register */
end_comment

begin_define
define|#
directive|define
name|DMA1_MODE
value|(IO_DMA1 + 1*11)
end_define

begin_comment
comment|/* mode register */
end_comment

begin_define
define|#
directive|define
name|DMA1_FFC
value|(IO_DMA1 + 1*12)
end_define

begin_comment
comment|/* clear first/last FF */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* **  Register definitions for DMA controller 2 (channels 4..7): */
end_comment

begin_define
define|#
directive|define
name|DMA2_CHN
parameter_list|(
name|c
parameter_list|)
value|(IO_DMA2 + 2*(2*(c)))
end_define

begin_comment
comment|/* addr reg for channel c */
end_comment

begin_define
define|#
directive|define
name|DMA2_SMSK
value|(IO_DMA2 + 2*10)
end_define

begin_comment
comment|/* single mask register */
end_comment

begin_define
define|#
directive|define
name|DMA2_MODE
value|(IO_DMA2 + 2*11)
end_define

begin_comment
comment|/* mode register */
end_comment

begin_define
define|#
directive|define
name|DMA2_FFC
value|(IO_DMA2 + 2*12)
end_define

begin_comment
comment|/* clear first/last FF */
end_comment

begin_decl_stmt
name|u_long
modifier|*
name|intr_countp
index|[
name|ICU_LEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|inthand2_t
modifier|*
name|intr_handler
index|[
name|ICU_LEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int
name|intr_mask
index|[
name|ICU_LEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int
modifier|*
name|intr_mptr
index|[
name|ICU_LEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|intr_unit
index|[
name|ICU_LEN
index|]
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_decl_stmt
name|unsigned
name|int
name|ddb_inb
name|__P
argument_list|(
operator|(
name|unsigned
name|int
name|addr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|ddb_outb
name|__P
argument_list|(
operator|(
name|unsigned
name|int
name|addr
operator|,
name|unsigned
name|char
name|dt
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|inthand_t
modifier|*
name|fastintr
index|[
name|ICU_LEN
index|]
init|=
block|{
operator|&
name|IDTVEC
argument_list|(
name|fastintr0
argument_list|)
block|,
operator|&
name|IDTVEC
argument_list|(
name|fastintr1
argument_list|)
block|,
operator|&
name|IDTVEC
argument_list|(
name|fastintr2
argument_list|)
block|,
operator|&
name|IDTVEC
argument_list|(
name|fastintr3
argument_list|)
block|,
operator|&
name|IDTVEC
argument_list|(
name|fastintr4
argument_list|)
block|,
operator|&
name|IDTVEC
argument_list|(
name|fastintr5
argument_list|)
block|,
operator|&
name|IDTVEC
argument_list|(
name|fastintr6
argument_list|)
block|,
operator|&
name|IDTVEC
argument_list|(
name|fastintr7
argument_list|)
block|,
operator|&
name|IDTVEC
argument_list|(
name|fastintr8
argument_list|)
block|,
operator|&
name|IDTVEC
argument_list|(
name|fastintr9
argument_list|)
block|,
operator|&
name|IDTVEC
argument_list|(
name|fastintr10
argument_list|)
block|,
operator|&
name|IDTVEC
argument_list|(
name|fastintr11
argument_list|)
block|,
operator|&
name|IDTVEC
argument_list|(
name|fastintr12
argument_list|)
block|,
operator|&
name|IDTVEC
argument_list|(
name|fastintr13
argument_list|)
block|,
operator|&
name|IDTVEC
argument_list|(
name|fastintr14
argument_list|)
block|,
operator|&
name|IDTVEC
argument_list|(
argument|fastintr15
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|inthand_t
modifier|*
name|slowintr
index|[
name|ICU_LEN
index|]
init|=
block|{
operator|&
name|IDTVEC
argument_list|(
name|intr0
argument_list|)
block|,
operator|&
name|IDTVEC
argument_list|(
name|intr1
argument_list|)
block|,
operator|&
name|IDTVEC
argument_list|(
name|intr2
argument_list|)
block|,
operator|&
name|IDTVEC
argument_list|(
name|intr3
argument_list|)
block|,
operator|&
name|IDTVEC
argument_list|(
name|intr4
argument_list|)
block|,
operator|&
name|IDTVEC
argument_list|(
name|intr5
argument_list|)
block|,
operator|&
name|IDTVEC
argument_list|(
name|intr6
argument_list|)
block|,
operator|&
name|IDTVEC
argument_list|(
name|intr7
argument_list|)
block|,
operator|&
name|IDTVEC
argument_list|(
name|intr8
argument_list|)
block|,
operator|&
name|IDTVEC
argument_list|(
name|intr9
argument_list|)
block|,
operator|&
name|IDTVEC
argument_list|(
name|intr10
argument_list|)
block|,
operator|&
name|IDTVEC
argument_list|(
name|intr11
argument_list|)
block|,
operator|&
name|IDTVEC
argument_list|(
name|intr12
argument_list|)
block|,
operator|&
name|IDTVEC
argument_list|(
name|intr13
argument_list|)
block|,
operator|&
name|IDTVEC
argument_list|(
name|intr14
argument_list|)
block|,
operator|&
name|IDTVEC
argument_list|(
argument|intr15
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|config_isadev
name|__P
argument_list|(
operator|(
expr|struct
name|isa_device
operator|*
name|isdp
operator|,
name|u_int
operator|*
name|mp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|config_isadev_c
name|__P
argument_list|(
operator|(
expr|struct
name|isa_device
operator|*
name|isdp
operator|,
name|u_int
operator|*
name|mp
operator|,
name|int
name|reconfig
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|conflict
name|__P
argument_list|(
operator|(
expr|struct
name|isa_device
operator|*
name|dvp
operator|,
expr|struct
name|isa_device
operator|*
name|tmpdvp
operator|,
name|int
name|item
operator|,
name|char
specifier|const
operator|*
name|whatnot
operator|,
name|char
specifier|const
operator|*
name|reason
operator|,
name|char
specifier|const
operator|*
name|format
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|haveseen
name|__P
argument_list|(
operator|(
expr|struct
name|isa_device
operator|*
name|dvp
operator|,
expr|struct
name|isa_device
operator|*
name|tmpdvp
operator|,
name|u_int
name|checkbits
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|isa_dmarangecheck
name|__P
argument_list|(
operator|(
name|caddr_t
name|va
operator|,
name|u_int
name|length
operator|,
name|int
name|chan
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|inthand2_t
name|isa_strayintr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|register_imask
name|__P
argument_list|(
operator|(
expr|struct
name|isa_device
operator|*
name|dvp
operator|,
name|u_int
name|mask
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * print a conflict message  */
end_comment

begin_function
specifier|static
name|void
name|conflict
parameter_list|(
name|dvp
parameter_list|,
name|tmpdvp
parameter_list|,
name|item
parameter_list|,
name|whatnot
parameter_list|,
name|reason
parameter_list|,
name|format
parameter_list|)
name|struct
name|isa_device
modifier|*
name|dvp
decl_stmt|;
name|struct
name|isa_device
modifier|*
name|tmpdvp
decl_stmt|;
name|int
name|item
decl_stmt|;
name|char
specifier|const
modifier|*
name|whatnot
decl_stmt|;
name|char
specifier|const
modifier|*
name|reason
decl_stmt|;
name|char
specifier|const
modifier|*
name|format
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"%s%d not %sed due to %s conflict with %s%d at "
argument_list|,
name|dvp
operator|->
name|id_driver
operator|->
name|name
argument_list|,
name|dvp
operator|->
name|id_unit
argument_list|,
name|whatnot
argument_list|,
name|reason
argument_list|,
name|tmpdvp
operator|->
name|id_driver
operator|->
name|name
argument_list|,
name|tmpdvp
operator|->
name|id_unit
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|format
argument_list|,
name|item
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Check to see if things are already in use, like IRQ's, I/O addresses  * and Memory addresses.  */
end_comment

begin_function
specifier|static
name|int
name|haveseen
parameter_list|(
name|dvp
parameter_list|,
name|tmpdvp
parameter_list|,
name|checkbits
parameter_list|)
name|struct
name|isa_device
modifier|*
name|dvp
decl_stmt|;
name|struct
name|isa_device
modifier|*
name|tmpdvp
decl_stmt|;
name|u_int
name|checkbits
decl_stmt|;
block|{
comment|/* 	 * Only check against devices that have already been found and are not 	 * unilaterally allowed to conflict anyway. 	 */
if|if
condition|(
name|tmpdvp
operator|->
name|id_alive
operator|&&
operator|!
name|dvp
operator|->
name|id_conflicts
condition|)
block|{
name|char
specifier|const
modifier|*
name|whatnot
decl_stmt|;
name|whatnot
operator|=
name|checkbits
operator|&
name|CC_ATTACH
condition|?
literal|"attach"
else|:
literal|"prob"
expr_stmt|;
comment|/* 		 * Check for I/O address conflict.  We can only check the 		 * starting address of the device against the range of the 		 * device that has already been probed since we do not 		 * know how many I/O addresses this device uses. 		 */
if|if
condition|(
name|checkbits
operator|&
name|CC_IOADDR
operator|&&
name|tmpdvp
operator|->
name|id_alive
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|dvp
operator|->
name|id_iobase
operator|>=
name|tmpdvp
operator|->
name|id_iobase
operator|)
operator|&&
operator|(
name|dvp
operator|->
name|id_iobase
operator|<=
operator|(
name|tmpdvp
operator|->
name|id_iobase
operator|+
name|tmpdvp
operator|->
name|id_alive
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
name|conflict
argument_list|(
name|dvp
argument_list|,
name|tmpdvp
argument_list|,
name|dvp
operator|->
name|id_iobase
argument_list|,
name|whatnot
argument_list|,
literal|"I/O address"
argument_list|,
literal|"0x%x"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
comment|/* 		 * Check for Memory address conflict.  We can check for 		 * range overlap, but it will not catch all cases since the 		 * driver may adjust the msize paramater during probe, for 		 * now we just check that the starting address does not 		 * fall within any allocated region. 		 * XXX could add a second check after the probe for overlap, 		 * since at that time we would know the full range. 		 * XXX KERNBASE is a hack, we should have vaddr in the table! 		 */
if|if
condition|(
name|checkbits
operator|&
name|CC_MEMADDR
operator|&&
name|tmpdvp
operator|->
name|id_maddr
condition|)
block|{
if|if
condition|(
operator|(
name|KERNBASE
operator|+
name|dvp
operator|->
name|id_maddr
operator|>=
name|tmpdvp
operator|->
name|id_maddr
operator|)
operator|&&
operator|(
name|KERNBASE
operator|+
name|dvp
operator|->
name|id_maddr
operator|<=
operator|(
name|tmpdvp
operator|->
name|id_maddr
operator|+
name|tmpdvp
operator|->
name|id_msize
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
name|conflict
argument_list|(
name|dvp
argument_list|,
name|tmpdvp
argument_list|,
operator|(
name|int
operator|)
name|dvp
operator|->
name|id_maddr
argument_list|,
name|whatnot
argument_list|,
literal|"maddr"
argument_list|,
literal|"0x%x"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
comment|/* 		 * Check for IRQ conflicts. 		 */
if|if
condition|(
name|checkbits
operator|&
name|CC_IRQ
operator|&&
name|tmpdvp
operator|->
name|id_irq
condition|)
block|{
if|if
condition|(
name|tmpdvp
operator|->
name|id_irq
operator|==
name|dvp
operator|->
name|id_irq
condition|)
block|{
name|conflict
argument_list|(
name|dvp
argument_list|,
name|tmpdvp
argument_list|,
name|ffs
argument_list|(
name|dvp
operator|->
name|id_irq
argument_list|)
operator|-
literal|1
argument_list|,
name|whatnot
argument_list|,
literal|"irq"
argument_list|,
literal|"%d"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
comment|/* 		 * Check for DRQ conflicts. 		 */
if|if
condition|(
name|checkbits
operator|&
name|CC_DRQ
operator|&&
name|tmpdvp
operator|->
name|id_drq
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|tmpdvp
operator|->
name|id_drq
operator|==
name|dvp
operator|->
name|id_drq
condition|)
block|{
name|conflict
argument_list|(
name|dvp
argument_list|,
name|tmpdvp
argument_list|,
name|dvp
operator|->
name|id_drq
argument_list|,
name|whatnot
argument_list|,
literal|"drq"
argument_list|,
literal|"%d"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Search through all the isa_devtab_* tables looking for anything that  * conflicts with the current device.  */
end_comment

begin_function
name|int
name|haveseen_isadev
parameter_list|(
name|dvp
parameter_list|,
name|checkbits
parameter_list|)
name|struct
name|isa_device
modifier|*
name|dvp
decl_stmt|;
name|u_int
name|checkbits
decl_stmt|;
block|{
name|struct
name|isa_device
modifier|*
name|tmpdvp
decl_stmt|;
name|int
name|status
init|=
literal|0
decl_stmt|;
for|for
control|(
name|tmpdvp
operator|=
name|isa_devtab_tty
init|;
name|tmpdvp
operator|->
name|id_driver
condition|;
name|tmpdvp
operator|++
control|)
block|{
name|status
operator||=
name|haveseen
argument_list|(
name|dvp
argument_list|,
name|tmpdvp
argument_list|,
name|checkbits
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|status
return|;
block|}
for|for
control|(
name|tmpdvp
operator|=
name|isa_devtab_bio
init|;
name|tmpdvp
operator|->
name|id_driver
condition|;
name|tmpdvp
operator|++
control|)
block|{
name|status
operator||=
name|haveseen
argument_list|(
name|dvp
argument_list|,
name|tmpdvp
argument_list|,
name|checkbits
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|status
return|;
block|}
for|for
control|(
name|tmpdvp
operator|=
name|isa_devtab_net
init|;
name|tmpdvp
operator|->
name|id_driver
condition|;
name|tmpdvp
operator|++
control|)
block|{
name|status
operator||=
name|haveseen
argument_list|(
name|dvp
argument_list|,
name|tmpdvp
argument_list|,
name|checkbits
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|status
return|;
block|}
for|for
control|(
name|tmpdvp
operator|=
name|isa_devtab_null
init|;
name|tmpdvp
operator|->
name|id_driver
condition|;
name|tmpdvp
operator|++
control|)
block|{
name|status
operator||=
name|haveseen
argument_list|(
name|dvp
argument_list|,
name|tmpdvp
argument_list|,
name|checkbits
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|status
return|;
block|}
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Configure all ISA devices  */
end_comment

begin_function
name|void
name|isa_configure
parameter_list|()
block|{
name|struct
name|isa_device
modifier|*
name|dvp
decl_stmt|;
name|splhigh
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"Probing for devices on the ISA bus:\n"
argument_list|)
expr_stmt|;
comment|/* First probe all the sensitive probes */
for|for
control|(
name|dvp
operator|=
name|isa_devtab_tty
init|;
name|dvp
operator|->
name|id_driver
condition|;
name|dvp
operator|++
control|)
if|if
condition|(
name|dvp
operator|->
name|id_driver
operator|->
name|sensitive_hw
condition|)
name|config_isadev
argument_list|(
name|dvp
argument_list|,
operator|&
name|tty_imask
argument_list|)
expr_stmt|;
for|for
control|(
name|dvp
operator|=
name|isa_devtab_bio
init|;
name|dvp
operator|->
name|id_driver
condition|;
name|dvp
operator|++
control|)
if|if
condition|(
name|dvp
operator|->
name|id_driver
operator|->
name|sensitive_hw
condition|)
name|config_isadev
argument_list|(
name|dvp
argument_list|,
operator|&
name|bio_imask
argument_list|)
expr_stmt|;
for|for
control|(
name|dvp
operator|=
name|isa_devtab_net
init|;
name|dvp
operator|->
name|id_driver
condition|;
name|dvp
operator|++
control|)
if|if
condition|(
name|dvp
operator|->
name|id_driver
operator|->
name|sensitive_hw
condition|)
name|config_isadev
argument_list|(
name|dvp
argument_list|,
operator|&
name|net_imask
argument_list|)
expr_stmt|;
for|for
control|(
name|dvp
operator|=
name|isa_devtab_null
init|;
name|dvp
operator|->
name|id_driver
condition|;
name|dvp
operator|++
control|)
if|if
condition|(
name|dvp
operator|->
name|id_driver
operator|->
name|sensitive_hw
condition|)
name|config_isadev
argument_list|(
name|dvp
argument_list|,
operator|(
name|u_int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* Then all the bad ones */
for|for
control|(
name|dvp
operator|=
name|isa_devtab_tty
init|;
name|dvp
operator|->
name|id_driver
condition|;
name|dvp
operator|++
control|)
if|if
condition|(
operator|!
name|dvp
operator|->
name|id_driver
operator|->
name|sensitive_hw
condition|)
name|config_isadev
argument_list|(
name|dvp
argument_list|,
operator|&
name|tty_imask
argument_list|)
expr_stmt|;
for|for
control|(
name|dvp
operator|=
name|isa_devtab_bio
init|;
name|dvp
operator|->
name|id_driver
condition|;
name|dvp
operator|++
control|)
if|if
condition|(
operator|!
name|dvp
operator|->
name|id_driver
operator|->
name|sensitive_hw
condition|)
name|config_isadev
argument_list|(
name|dvp
argument_list|,
operator|&
name|bio_imask
argument_list|)
expr_stmt|;
for|for
control|(
name|dvp
operator|=
name|isa_devtab_net
init|;
name|dvp
operator|->
name|id_driver
condition|;
name|dvp
operator|++
control|)
if|if
condition|(
operator|!
name|dvp
operator|->
name|id_driver
operator|->
name|sensitive_hw
condition|)
name|config_isadev
argument_list|(
name|dvp
argument_list|,
operator|&
name|net_imask
argument_list|)
expr_stmt|;
for|for
control|(
name|dvp
operator|=
name|isa_devtab_null
init|;
name|dvp
operator|->
name|id_driver
condition|;
name|dvp
operator|++
control|)
if|if
condition|(
operator|!
name|dvp
operator|->
name|id_driver
operator|->
name|sensitive_hw
condition|)
name|config_isadev
argument_list|(
name|dvp
argument_list|,
operator|(
name|u_int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|bio_imask
operator||=
name|SWI_CLOCK_MASK
expr_stmt|;
name|net_imask
operator||=
name|SWI_NET_MASK
expr_stmt|;
name|tty_imask
operator||=
name|SWI_TTY_MASK
expr_stmt|;
comment|/*  * XXX we should really add the tty device to net_imask when the line is  * switched to SLIPDISC, and then remove it when it is switched away from  * SLIPDISC.  No need to block out ALL ttys during a splimp when only one  * of them is running slip.  *  * XXX actually, blocking all ttys during a splimp doesn't matter so much  * with sio because the serial interrupt layer doesn't use tty_imask.  Only  * non-serial ttys suffer.  It's more stupid that ALL 'net's are blocked  * during spltty.  */
include|#
directive|include
file|"sl.h"
if|#
directive|if
name|NSL
operator|>
literal|0
name|net_imask
operator||=
name|tty_imask
expr_stmt|;
name|tty_imask
operator|=
name|net_imask
expr_stmt|;
endif|#
directive|endif
comment|/* bio_imask |= tty_imask ;  can some tty devices use buffers? */
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"imasks: bio %x, tty %x, net %x\n"
argument_list|,
name|bio_imask
argument_list|,
name|tty_imask
argument_list|,
name|net_imask
argument_list|)
expr_stmt|;
comment|/* 	 * Finish initializing intr_mask[].  Note that the partly 	 * constructed masks aren't actually used since we're at splhigh. 	 * For fully dynamic initialization, register_intr() and 	 * unregister_intr() will have to adjust the masks for _all_ 	 * interrupts and for tty_imask, etc. 	 */
for|for
control|(
name|dvp
operator|=
name|isa_devtab_tty
init|;
name|dvp
operator|->
name|id_driver
condition|;
name|dvp
operator|++
control|)
name|register_imask
argument_list|(
name|dvp
argument_list|,
name|tty_imask
argument_list|)
expr_stmt|;
for|for
control|(
name|dvp
operator|=
name|isa_devtab_bio
init|;
name|dvp
operator|->
name|id_driver
condition|;
name|dvp
operator|++
control|)
name|register_imask
argument_list|(
name|dvp
argument_list|,
name|bio_imask
argument_list|)
expr_stmt|;
for|for
control|(
name|dvp
operator|=
name|isa_devtab_net
init|;
name|dvp
operator|->
name|id_driver
condition|;
name|dvp
operator|++
control|)
name|register_imask
argument_list|(
name|dvp
argument_list|,
name|net_imask
argument_list|)
expr_stmt|;
for|for
control|(
name|dvp
operator|=
name|isa_devtab_null
init|;
name|dvp
operator|->
name|id_driver
condition|;
name|dvp
operator|++
control|)
name|register_imask
argument_list|(
name|dvp
argument_list|,
name|SWI_CLOCK_MASK
argument_list|)
expr_stmt|;
name|spl0
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Configure an ISA device.  */
end_comment

begin_function
specifier|static
name|void
name|config_isadev
parameter_list|(
name|isdp
parameter_list|,
name|mp
parameter_list|)
name|struct
name|isa_device
modifier|*
name|isdp
decl_stmt|;
name|u_int
modifier|*
name|mp
decl_stmt|;
block|{
name|config_isadev_c
argument_list|(
name|isdp
argument_list|,
name|mp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|reconfig_isadev
parameter_list|(
name|isdp
parameter_list|,
name|mp
parameter_list|)
name|struct
name|isa_device
modifier|*
name|isdp
decl_stmt|;
name|u_int
modifier|*
name|mp
decl_stmt|;
block|{
name|config_isadev_c
argument_list|(
name|isdp
argument_list|,
name|mp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|config_isadev_c
parameter_list|(
name|isdp
parameter_list|,
name|mp
parameter_list|,
name|reconfig
parameter_list|)
name|struct
name|isa_device
modifier|*
name|isdp
decl_stmt|;
name|u_int
modifier|*
name|mp
decl_stmt|;
name|int
name|reconfig
decl_stmt|;
block|{
name|u_int
name|checkbits
decl_stmt|;
name|int
name|id_alive
decl_stmt|;
name|int
name|last_alive
decl_stmt|;
name|struct
name|isa_driver
modifier|*
name|dp
init|=
name|isdp
operator|->
name|id_driver
decl_stmt|;
if|if
condition|(
operator|!
name|isdp
operator|->
name|id_enabled
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"%s%d: disabled, not probed.\n"
argument_list|,
name|dp
operator|->
name|name
argument_list|,
name|isdp
operator|->
name|id_unit
argument_list|)
expr_stmt|;
return|return;
block|}
name|checkbits
operator|=
name|CC_DRQ
operator||
name|CC_IOADDR
operator||
name|CC_MEMADDR
expr_stmt|;
if|if
condition|(
operator|!
name|reconfig
operator|&&
name|haveseen_isadev
argument_list|(
name|isdp
argument_list|,
name|checkbits
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|reconfig
operator|&&
name|isdp
operator|->
name|id_maddr
condition|)
block|{
name|isdp
operator|->
name|id_maddr
operator|-=
name|ISA_HOLE_START
expr_stmt|;
name|isdp
operator|->
name|id_maddr
operator|+=
name|atdevbase
expr_stmt|;
block|}
if|if
condition|(
name|reconfig
condition|)
block|{
name|last_alive
operator|=
name|isdp
operator|->
name|id_alive
expr_stmt|;
name|isdp
operator|->
name|id_reconfig
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|last_alive
operator|=
literal|0
expr_stmt|;
name|isdp
operator|->
name|id_reconfig
operator|=
literal|0
expr_stmt|;
block|}
name|id_alive
operator|=
call|(
modifier|*
name|dp
operator|->
name|probe
call|)
argument_list|(
name|isdp
argument_list|)
expr_stmt|;
if|if
condition|(
name|id_alive
condition|)
block|{
comment|/* 		 * Only print the I/O address range if id_alive != -1 		 * Right now this is a temporary fix just for the new 		 * NPX code so that if it finds a 486 that can use trap 		 * 16 it will not report I/O addresses. 		 * Rod Grimes 04/26/94 		 */
if|if
condition|(
operator|!
name|isdp
operator|->
name|id_reconfig
condition|)
block|{
name|printf
argument_list|(
literal|"%s%d"
argument_list|,
name|dp
operator|->
name|name
argument_list|,
name|isdp
operator|->
name|id_unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|id_alive
operator|!=
operator|-
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|" at 0x%x"
argument_list|,
name|isdp
operator|->
name|id_iobase
argument_list|)
expr_stmt|;
if|if
condition|(
name|isdp
operator|->
name|id_iobase
operator|+
name|id_alive
operator|-
literal|1
operator|!=
name|isdp
operator|->
name|id_iobase
condition|)
block|{
name|printf
argument_list|(
literal|"-0x%x"
argument_list|,
name|isdp
operator|->
name|id_iobase
operator|+
name|id_alive
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|isdp
operator|->
name|id_irq
condition|)
name|printf
argument_list|(
literal|" irq %d"
argument_list|,
name|ffs
argument_list|(
name|isdp
operator|->
name|id_irq
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|isdp
operator|->
name|id_drq
operator|!=
operator|-
literal|1
condition|)
name|printf
argument_list|(
literal|" drq %d"
argument_list|,
name|isdp
operator|->
name|id_drq
argument_list|)
expr_stmt|;
if|if
condition|(
name|isdp
operator|->
name|id_maddr
condition|)
name|printf
argument_list|(
literal|" maddr 0x%lx"
argument_list|,
name|kvtop
argument_list|(
name|isdp
operator|->
name|id_maddr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|isdp
operator|->
name|id_msize
condition|)
name|printf
argument_list|(
literal|" msize %d"
argument_list|,
name|isdp
operator|->
name|id_msize
argument_list|)
expr_stmt|;
if|if
condition|(
name|isdp
operator|->
name|id_flags
condition|)
name|printf
argument_list|(
literal|" flags 0x%x"
argument_list|,
name|isdp
operator|->
name|id_flags
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|printf
argument_list|(
literal|" on isa"
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|isdp
operator|->
name|id_iobase
operator|&&
operator|!
operator|(
name|isdp
operator|->
name|id_iobase
operator|&
literal|0xf300
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|" on motherboard"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isdp
operator|->
name|id_iobase
operator|>=
literal|0x1000
operator|&&
operator|!
operator|(
name|isdp
operator|->
name|id_iobase
operator|&
literal|0x300
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|" on eisa slot %d"
argument_list|,
name|isdp
operator|->
name|id_iobase
operator|>>
literal|12
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|" on isa"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* 			 * Check for conflicts again.  The driver may have 			 * changed *dvp.  We should weaken the early check 			 * since the driver may have been able to change 			 * *dvp to avoid conflicts if given a chance.  We 			 * already skip the early check for IRQs and force 			 * a check for IRQs in the next group of checks. 			 */
name|checkbits
operator||=
name|CC_IRQ
expr_stmt|;
if|if
condition|(
name|haveseen_isadev
argument_list|(
name|isdp
argument_list|,
name|checkbits
argument_list|)
condition|)
return|return;
name|isdp
operator|->
name|id_alive
operator|=
name|id_alive
expr_stmt|;
block|}
call|(
modifier|*
name|dp
operator|->
name|attach
call|)
argument_list|(
name|isdp
argument_list|)
expr_stmt|;
if|if
condition|(
name|isdp
operator|->
name|id_irq
condition|)
block|{
if|if
condition|(
name|mp
condition|)
name|INTRMASK
argument_list|(
operator|*
name|mp
argument_list|,
name|isdp
operator|->
name|id_irq
argument_list|)
expr_stmt|;
name|register_intr
argument_list|(
name|ffs
argument_list|(
name|isdp
operator|->
name|id_irq
argument_list|)
operator|-
literal|1
argument_list|,
name|isdp
operator|->
name|id_id
argument_list|,
name|isdp
operator|->
name|id_ri_flags
argument_list|,
name|isdp
operator|->
name|id_intr
argument_list|,
name|mp
argument_list|,
name|isdp
operator|->
name|id_unit
argument_list|)
expr_stmt|;
name|INTREN
argument_list|(
name|isdp
operator|->
name|id_irq
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|isdp
operator|->
name|id_reconfig
condition|)
block|{
call|(
modifier|*
name|dp
operator|->
name|attach
call|)
argument_list|(
name|isdp
argument_list|)
expr_stmt|;
comment|/* reconfiguration attach */
block|}
if|if
condition|(
operator|!
name|last_alive
condition|)
block|{
if|if
condition|(
operator|!
name|isdp
operator|->
name|id_reconfig
condition|)
block|{
name|printf
argument_list|(
literal|"%s%d not found"
argument_list|,
name|dp
operator|->
name|name
argument_list|,
name|isdp
operator|->
name|id_unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|isdp
operator|->
name|id_iobase
condition|)
block|{
name|printf
argument_list|(
literal|" at 0x%x"
argument_list|,
name|isdp
operator|->
name|id_iobase
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* This code has not been tested.... */
if|if
condition|(
name|isdp
operator|->
name|id_irq
condition|)
block|{
name|INTRDIS
argument_list|(
name|isdp
operator|->
name|id_irq
argument_list|)
expr_stmt|;
name|unregister_intr
argument_list|(
name|ffs
argument_list|(
name|isdp
operator|->
name|id_irq
argument_list|)
operator|-
literal|1
argument_list|,
name|isdp
operator|->
name|id_intr
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
condition|)
name|INTRUNMASK
argument_list|(
operator|*
name|mp
argument_list|,
name|isdp
operator|->
name|id_irq
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Fill in default interrupt table (in case of spuruious interrupt  * during configuration of kernel, setup interrupt control unit  */
end_comment

begin_function
name|void
name|isa_defaultirq
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
comment|/* icu vectors */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ICU_LEN
condition|;
name|i
operator|++
control|)
name|unregister_intr
argument_list|(
name|i
argument_list|,
operator|(
name|inthand2_t
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* initialize 8259's */
ifdef|#
directive|ifdef
name|PC98
name|outb
argument_list|(
name|IO_ICU1
argument_list|,
literal|0x11
argument_list|)
expr_stmt|;
comment|/* reset; program device, four bytes */
name|outb
argument_list|(
name|IO_ICU1
operator|+
literal|2
argument_list|,
name|NRSVIDT
argument_list|)
expr_stmt|;
comment|/* starting at this vector index */
name|outb
argument_list|(
name|IO_ICU1
operator|+
literal|2
argument_list|,
literal|1
operator|<<
literal|7
argument_list|)
expr_stmt|;
comment|/* slave on line 7 */
ifdef|#
directive|ifdef
name|AUTO_EOI_1
name|outb
argument_list|(
name|IO_ICU1
operator|+
literal|2
argument_list|,
literal|0x1f
argument_list|)
expr_stmt|;
comment|/* (master) auto EOI, 8086 mode */
else|#
directive|else
name|outb
argument_list|(
name|IO_ICU1
operator|+
literal|2
argument_list|,
literal|0x1d
argument_list|)
expr_stmt|;
comment|/* (master) 8086 mode */
endif|#
directive|endif
name|outb
argument_list|(
name|IO_ICU1
operator|+
literal|2
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* leave interrupts masked */
name|outb
argument_list|(
name|IO_ICU1
argument_list|,
literal|0x0a
argument_list|)
expr_stmt|;
comment|/* default to IRR on read */
name|outb
argument_list|(
name|IO_ICU2
argument_list|,
literal|0x11
argument_list|)
expr_stmt|;
comment|/* reset; program device, four bytes */
name|outb
argument_list|(
name|IO_ICU2
operator|+
literal|2
argument_list|,
name|NRSVIDT
operator|+
literal|8
argument_list|)
expr_stmt|;
comment|/* staring at this vector index */
name|outb
argument_list|(
name|IO_ICU2
operator|+
literal|2
argument_list|,
literal|7
argument_list|)
expr_stmt|;
comment|/* my slave id is 7 */
name|outb
argument_list|(
name|IO_ICU2
operator|+
literal|2
argument_list|,
literal|9
argument_list|)
expr_stmt|;
comment|/* 8086 mode */
name|outb
argument_list|(
name|IO_ICU2
operator|+
literal|2
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* leave interrupts masked */
name|outb
argument_list|(
name|IO_ICU2
argument_list|,
literal|0x0a
argument_list|)
expr_stmt|;
comment|/* default to IRR on read */
else|#
directive|else
name|outb
argument_list|(
name|IO_ICU1
argument_list|,
literal|0x11
argument_list|)
expr_stmt|;
comment|/* reset; program device, four bytes */
name|outb
argument_list|(
name|IO_ICU1
operator|+
literal|1
argument_list|,
name|NRSVIDT
argument_list|)
expr_stmt|;
comment|/* starting at this vector index */
name|outb
argument_list|(
name|IO_ICU1
operator|+
literal|1
argument_list|,
literal|1
operator|<<
literal|2
argument_list|)
expr_stmt|;
comment|/* slave on line 2 */
ifdef|#
directive|ifdef
name|AUTO_EOI_1
name|outb
argument_list|(
name|IO_ICU1
operator|+
literal|1
argument_list|,
literal|2
operator||
literal|1
argument_list|)
expr_stmt|;
comment|/* auto EOI, 8086 mode */
else|#
directive|else
name|outb
argument_list|(
name|IO_ICU1
operator|+
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 8086 mode */
endif|#
directive|endif
name|outb
argument_list|(
name|IO_ICU1
operator|+
literal|1
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* leave interrupts masked */
name|outb
argument_list|(
name|IO_ICU1
argument_list|,
literal|0x0a
argument_list|)
expr_stmt|;
comment|/* default to IRR on read */
name|outb
argument_list|(
name|IO_ICU1
argument_list|,
literal|0xc0
operator||
operator|(
literal|3
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
comment|/* pri order 3-7, 0-2 (com2 first) */
name|outb
argument_list|(
name|IO_ICU2
argument_list|,
literal|0x11
argument_list|)
expr_stmt|;
comment|/* reset; program device, four bytes */
name|outb
argument_list|(
name|IO_ICU2
operator|+
literal|1
argument_list|,
name|NRSVIDT
operator|+
literal|8
argument_list|)
expr_stmt|;
comment|/* staring at this vector index */
name|outb
argument_list|(
name|IO_ICU2
operator|+
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* my slave id is 2 */
ifdef|#
directive|ifdef
name|AUTO_EOI_2
name|outb
argument_list|(
name|IO_ICU2
operator|+
literal|1
argument_list|,
literal|2
operator||
literal|1
argument_list|)
expr_stmt|;
comment|/* auto EOI, 8086 mode */
else|#
directive|else
name|outb
argument_list|(
name|IO_ICU2
operator|+
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 8086 mode */
endif|#
directive|endif
name|outb
argument_list|(
name|IO_ICU2
operator|+
literal|1
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* leave interrupts masked */
name|outb
argument_list|(
name|IO_ICU2
argument_list|,
literal|0x0a
argument_list|)
expr_stmt|;
comment|/* default to IRR on read */
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|PC98
end_ifdef

begin_decl_stmt
specifier|static
name|caddr_t
name|dma_bouncebuf
index|[
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|dma_bouncebufsize
index|[
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|caddr_t
name|dma_bouncebuf
index|[
literal|8
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|dma_bouncebufsize
index|[
literal|8
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|u_int8_t
name|dma_bounced
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int8_t
name|dma_busy
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used in isa_dmastart() */
end_comment

begin_decl_stmt
specifier|static
name|u_int8_t
name|dma_inuse
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* User for acquire/release */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PC98
end_ifdef

begin_define
define|#
directive|define
name|VALID_DMA_MASK
value|(3)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|VALID_DMA_MASK
value|(7)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* high byte of address is stored in this port for i-th dma channel */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PC98
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|dmapageport
index|[
literal|4
index|]
init|=
block|{
literal|0x27
block|,
literal|0x21
block|,
literal|0x23
block|,
literal|0x25
block|}
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* IBM-PC */
end_comment

begin_decl_stmt
specifier|static
name|int
name|dmapageport
index|[
literal|8
index|]
init|=
block|{
literal|0x87
block|,
literal|0x83
block|,
literal|0x81
block|,
literal|0x82
block|,
literal|0x8f
block|,
literal|0x8b
block|,
literal|0x89
block|,
literal|0x8a
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Setup a DMA channel's bounce buffer.  */
end_comment

begin_function
name|void
name|isa_dmainit
parameter_list|(
name|chan
parameter_list|,
name|bouncebufsize
parameter_list|)
name|int
name|chan
decl_stmt|;
name|u_int
name|bouncebufsize
decl_stmt|;
block|{
name|void
modifier|*
name|buf
decl_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|chan
operator|&
operator|~
name|VALID_DMA_MASK
condition|)
name|panic
argument_list|(
literal|"isa_dmainit: channel out of range"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dma_bouncebuf
index|[
name|chan
index|]
operator|!=
name|NULL
condition|)
name|panic
argument_list|(
literal|"isa_dmainit: impossible request"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dma_bouncebufsize
index|[
name|chan
index|]
operator|=
name|bouncebufsize
expr_stmt|;
comment|/* Try malloc() first.  It works better if it works. */
name|buf
operator|=
name|malloc
argument_list|(
name|bouncebufsize
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|isa_dmarangecheck
argument_list|(
name|buf
argument_list|,
name|bouncebufsize
argument_list|,
name|chan
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dma_bouncebuf
index|[
name|chan
index|]
operator|=
name|buf
expr_stmt|;
return|return;
block|}
name|free
argument_list|(
name|buf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
name|buf
operator|=
name|contigmalloc
argument_list|(
name|bouncebufsize
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|,
literal|0ul
argument_list|,
literal|0xfffffful
argument_list|,
literal|1ul
argument_list|,
name|chan
operator|&
literal|4
condition|?
literal|0x20000ul
else|:
literal|0x10000ul
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|"isa_dmainit(%d, %d) failed\n"
argument_list|,
name|chan
argument_list|,
name|bouncebufsize
argument_list|)
expr_stmt|;
else|else
name|dma_bouncebuf
index|[
name|chan
index|]
operator|=
name|buf
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Register a DMA channel's usage.  Usually called from a device driver  * in open() or during it's initialization.  */
end_comment

begin_function
name|int
name|isa_dma_acquire
parameter_list|(
name|chan
parameter_list|)
name|int
name|chan
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|chan
operator|&
operator|~
name|VALID_DMA_MASK
condition|)
name|panic
argument_list|(
literal|"isa_dma_acquire: channel out of range"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|dma_inuse
operator|&
operator|(
literal|1
operator|<<
name|chan
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"isa_dma_acquire: channel %d already in use\n"
argument_list|,
name|chan
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|dma_inuse
operator||=
operator|(
literal|1
operator|<<
name|chan
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Unregister a DMA channel's usage.  Usually called from a device driver  * during close() or during it's shutdown.  */
end_comment

begin_function
name|void
name|isa_dma_release
parameter_list|(
name|chan
parameter_list|)
name|int
name|chan
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|chan
operator|&
operator|~
name|VALID_DMA_MASK
condition|)
name|panic
argument_list|(
literal|"isa_dma_release: channel out of range"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dma_inuse
operator|&
operator|(
literal|1
operator|<<
name|chan
operator|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"isa_dma_release: channel %d not in use\n"
argument_list|,
name|chan
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|dma_busy
operator|&
operator|(
literal|1
operator|<<
name|chan
operator|)
condition|)
block|{
name|dma_busy
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|chan
operator|)
expr_stmt|;
comment|/*  		 * XXX We should also do "dma_bounced&= (1<< chan);" 		 * because we are acting on behalf of isa_dmadone() which 		 * was not called to end the last DMA operation.  This does 		 * not matter now, but it may in the future. 		 */
block|}
name|dma_inuse
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|chan
operator|)
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|PC98
end_ifndef

begin_comment
comment|/*  * isa_dmacascade(): program 8237 DMA controller channel to accept  * external dma control by a board.  */
end_comment

begin_function
name|void
name|isa_dmacascade
parameter_list|(
name|chan
parameter_list|)
name|int
name|chan
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|chan
operator|&
operator|~
name|VALID_DMA_MASK
condition|)
name|panic
argument_list|(
literal|"isa_dmacascade: channel out of range"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* set dma channel mode, and set dma channel mode */
if|if
condition|(
operator|(
name|chan
operator|&
literal|4
operator|)
operator|==
literal|0
condition|)
block|{
name|outb
argument_list|(
name|DMA1_MODE
argument_list|,
name|DMA37MD_CASCADE
operator||
name|chan
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|DMA1_SMSK
argument_list|,
name|chan
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outb
argument_list|(
name|DMA2_MODE
argument_list|,
name|DMA37MD_CASCADE
operator||
operator|(
name|chan
operator|&
literal|3
operator|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|DMA2_SMSK
argument_list|,
name|chan
operator|&
literal|3
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * isa_dmastart(): program 8237 DMA controller channel, avoid page alignment  * problems by using a bounce buffer.  */
end_comment

begin_function
name|void
name|isa_dmastart
parameter_list|(
name|int
name|flags
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|u_int
name|nbytes
parameter_list|,
name|int
name|chan
parameter_list|)
block|{
name|vm_offset_t
name|phys
decl_stmt|;
name|int
name|waport
decl_stmt|;
name|caddr_t
name|newaddr
decl_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|chan
operator|&
operator|~
name|VALID_DMA_MASK
condition|)
name|panic
argument_list|(
literal|"isa_dmastart: channel out of range"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|chan
operator|<
literal|4
operator|&&
name|nbytes
operator|>
operator|(
literal|1
operator|<<
literal|16
operator|)
operator|)
operator|||
operator|(
name|chan
operator|>=
literal|4
operator|&&
operator|(
name|nbytes
operator|>
operator|(
literal|1
operator|<<
literal|17
operator|)
operator|||
operator|(
name|u_int
operator|)
name|addr
operator|&
literal|1
operator|)
operator|)
condition|)
name|panic
argument_list|(
literal|"isa_dmastart: impossible request"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dma_inuse
operator|&
operator|(
literal|1
operator|<<
name|chan
operator|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"isa_dmastart: channel %d not acquired\n"
argument_list|,
name|chan
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|dma_busy
operator|&
operator|(
literal|1
operator|<<
name|chan
operator|)
condition|)
name|printf
argument_list|(
literal|"isa_dmastart: channel %d busy\n"
argument_list|,
name|chan
argument_list|)
expr_stmt|;
name|dma_busy
operator||=
operator|(
literal|1
operator|<<
name|chan
operator|)
expr_stmt|;
if|if
condition|(
name|isa_dmarangecheck
argument_list|(
name|addr
argument_list|,
name|nbytes
argument_list|,
name|chan
argument_list|)
condition|)
block|{
if|if
condition|(
name|dma_bouncebuf
index|[
name|chan
index|]
operator|==
name|NULL
operator|||
name|dma_bouncebufsize
index|[
name|chan
index|]
operator|<
name|nbytes
condition|)
name|panic
argument_list|(
literal|"isa_dmastart: bad bounce buffer"
argument_list|)
expr_stmt|;
name|dma_bounced
operator||=
operator|(
literal|1
operator|<<
name|chan
operator|)
expr_stmt|;
name|newaddr
operator|=
name|dma_bouncebuf
index|[
name|chan
index|]
expr_stmt|;
comment|/* copy bounce buffer on write */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|B_READ
operator|)
condition|)
name|bcopy
argument_list|(
name|addr
argument_list|,
name|newaddr
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
name|addr
operator|=
name|newaddr
expr_stmt|;
block|}
comment|/* translate to physical */
name|phys
operator|=
name|pmap_extract
argument_list|(
name|pmap_kernel
argument_list|()
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_pre_dma_flush
condition|)
name|wbinvd
argument_list|()
expr_stmt|;
comment|/* wbinvd (WB cache flush) */
ifndef|#
directive|ifndef
name|PC98
if|if
condition|(
operator|(
name|chan
operator|&
literal|4
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Program one of DMA channels 0..3.  These are 		 * byte mode channels. 		 */
endif|#
directive|endif
comment|/* set dma channel mode, and reset address ff */
comment|/* If B_RAW flag is set, then use autoinitialise mode */
if|if
condition|(
name|flags
operator|&
name|B_RAW
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|B_READ
condition|)
name|outb
argument_list|(
name|DMA1_MODE
argument_list|,
name|DMA37MD_AUTO
operator||
name|DMA37MD_WRITE
operator||
name|chan
argument_list|)
expr_stmt|;
else|else
name|outb
argument_list|(
name|DMA1_MODE
argument_list|,
name|DMA37MD_AUTO
operator||
name|DMA37MD_READ
operator||
name|chan
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|B_READ
condition|)
name|outb
argument_list|(
name|DMA1_MODE
argument_list|,
name|DMA37MD_SINGLE
operator||
name|DMA37MD_WRITE
operator||
name|chan
argument_list|)
expr_stmt|;
else|else
name|outb
argument_list|(
name|DMA1_MODE
argument_list|,
name|DMA37MD_SINGLE
operator||
name|DMA37MD_READ
operator||
name|chan
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|DMA1_FFC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* send start address */
name|waport
operator|=
name|DMA1_CHN
argument_list|(
name|chan
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|waport
argument_list|,
name|phys
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|waport
argument_list|,
name|phys
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|dmapageport
index|[
name|chan
index|]
argument_list|,
name|phys
operator|>>
literal|16
argument_list|)
expr_stmt|;
comment|/* send count */
name|outb
argument_list|(
name|waport
operator|+
literal|2
argument_list|,
operator|--
name|nbytes
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|waport
operator|+
literal|2
argument_list|,
name|nbytes
operator|>>
literal|8
argument_list|)
expr_stmt|;
comment|/* unmask channel */
name|outb
argument_list|(
name|DMA1_SMSK
argument_list|,
name|chan
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|PC98
block|}
else|else
block|{
comment|/* 		 * Program one of DMA channels 4..7.  These are 		 * word mode channels. 		 */
comment|/* set dma channel mode, and reset address ff */
comment|/* If B_RAW flag is set, then use autoinitialise mode */
if|if
condition|(
name|flags
operator|&
name|B_RAW
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|B_READ
condition|)
name|outb
argument_list|(
name|DMA2_MODE
argument_list|,
name|DMA37MD_AUTO
operator||
name|DMA37MD_WRITE
operator||
operator|(
name|chan
operator|&
literal|3
operator|)
argument_list|)
expr_stmt|;
else|else
name|outb
argument_list|(
name|DMA2_MODE
argument_list|,
name|DMA37MD_AUTO
operator||
name|DMA37MD_READ
operator||
operator|(
name|chan
operator|&
literal|3
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|B_READ
condition|)
name|outb
argument_list|(
name|DMA2_MODE
argument_list|,
name|DMA37MD_SINGLE
operator||
name|DMA37MD_WRITE
operator||
operator|(
name|chan
operator|&
literal|3
operator|)
argument_list|)
expr_stmt|;
else|else
name|outb
argument_list|(
name|DMA2_MODE
argument_list|,
name|DMA37MD_SINGLE
operator||
name|DMA37MD_READ
operator||
operator|(
name|chan
operator|&
literal|3
operator|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|DMA2_FFC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* send start address */
name|waport
operator|=
name|DMA2_CHN
argument_list|(
name|chan
operator|-
literal|4
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|waport
argument_list|,
name|phys
operator|>>
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|waport
argument_list|,
name|phys
operator|>>
literal|9
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|dmapageport
index|[
name|chan
index|]
argument_list|,
name|phys
operator|>>
literal|16
argument_list|)
expr_stmt|;
comment|/* send count */
name|nbytes
operator|>>=
literal|1
expr_stmt|;
name|outb
argument_list|(
name|waport
operator|+
literal|2
argument_list|,
operator|--
name|nbytes
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|waport
operator|+
literal|2
argument_list|,
name|nbytes
operator|>>
literal|8
argument_list|)
expr_stmt|;
comment|/* unmask channel */
name|outb
argument_list|(
name|DMA2_SMSK
argument_list|,
name|chan
operator|&
literal|3
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|isa_dmadone
parameter_list|(
name|int
name|flags
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|nbytes
parameter_list|,
name|int
name|chan
parameter_list|)
block|{
if|if
condition|(
name|flags
operator|&
name|B_READ
condition|)
block|{
comment|/* cache flush only after reading 92/12/9 by A.Kojima */
if|if
condition|(
name|need_post_dma_flush
condition|)
name|invd
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|chan
operator|&
operator|~
name|VALID_DMA_MASK
condition|)
name|panic
argument_list|(
literal|"isa_dmadone: channel out of range"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dma_inuse
operator|&
operator|(
literal|1
operator|<<
name|chan
operator|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"isa_dmadone: channel %d not acquired\n"
argument_list|,
name|chan
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/* 	 * XXX This should be checked, but drivers like ad1848 only call 	 * isa_dmastart() once because they use Auto DMA mode.  If we 	 * leave this in, drivers that do this will print this continuously. 	 */
block|if (dma_busy& (1<< chan) == 0) 		printf("isa_dmadone: channel %d not busy\n", chan);
endif|#
directive|endif
if|if
condition|(
name|dma_bounced
operator|&
operator|(
literal|1
operator|<<
name|chan
operator|)
condition|)
block|{
comment|/* copy bounce buffer on read */
if|if
condition|(
name|flags
operator|&
name|B_READ
condition|)
name|bcopy
argument_list|(
name|dma_bouncebuf
index|[
name|chan
index|]
argument_list|,
name|addr
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
name|dma_bounced
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|chan
operator|)
expr_stmt|;
block|}
name|dma_busy
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|chan
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Check for problems with the address range of a DMA transfer  * (non-contiguous physical pages, outside of bus address space,  * crossing DMA page boundaries).  * Return true if special handling needed.  */
end_comment

begin_function
specifier|static
name|int
name|isa_dmarangecheck
parameter_list|(
name|caddr_t
name|va
parameter_list|,
name|u_int
name|length
parameter_list|,
name|int
name|chan
parameter_list|)
block|{
name|vm_offset_t
name|phys
decl_stmt|,
name|priorpage
init|=
literal|0
decl_stmt|,
name|endva
decl_stmt|;
name|u_int
name|dma_pgmsk
init|=
operator|(
name|chan
operator|&
literal|4
operator|)
condition|?
operator|~
operator|(
literal|128
operator|*
literal|1024
operator|-
literal|1
operator|)
else|:
operator|~
operator|(
literal|64
operator|*
literal|1024
operator|-
literal|1
operator|)
decl_stmt|;
name|endva
operator|=
operator|(
name|vm_offset_t
operator|)
name|round_page
argument_list|(
name|va
operator|+
name|length
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|va
operator|<
operator|(
name|caddr_t
operator|)
name|endva
condition|;
name|va
operator|+=
name|PAGE_SIZE
control|)
block|{
name|phys
operator|=
name|trunc_page
argument_list|(
name|pmap_extract
argument_list|(
name|pmap_kernel
argument_list|()
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|va
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EPSON_BOUNCEDMA
define|#
directive|define
name|ISARAM_END
value|0xf00000
else|#
directive|else
define|#
directive|define
name|ISARAM_END
value|RAM_END
endif|#
directive|endif
if|if
condition|(
name|phys
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"isa_dmacheck: no physical page present"
argument_list|)
expr_stmt|;
if|if
condition|(
name|phys
operator|>=
name|ISARAM_END
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|priorpage
condition|)
block|{
if|if
condition|(
name|priorpage
operator|+
name|PAGE_SIZE
operator|!=
name|phys
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* check if crossing a DMA page boundary */
if|if
condition|(
operator|(
operator|(
name|u_int
operator|)
name|priorpage
operator|^
operator|(
name|u_int
operator|)
name|phys
operator|)
operator|&
name|dma_pgmsk
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|priorpage
operator|=
name|phys
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|PC98
end_ifdef

begin_define
define|#
directive|define
name|NMI_PARITY
value|0x04
end_define

begin_define
define|#
directive|define
name|NMI_EPARITY
value|0x02
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NMI_PARITY
value|(1<< 7)
end_define

begin_define
define|#
directive|define
name|NMI_IOCHAN
value|(1<< 6)
end_define

begin_define
define|#
directive|define
name|ENMI_WATCHDOG
value|(1<< 7)
end_define

begin_define
define|#
directive|define
name|ENMI_BUSTIMER
value|(1<< 6)
end_define

begin_define
define|#
directive|define
name|ENMI_IOSTATUS
value|(1<< 5)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Handle a NMI, possibly a machine check.  * return true to panic system, false to ignore.  */
end_comment

begin_function
name|int
name|isa_nmi
parameter_list|(
name|cd
parameter_list|)
name|int
name|cd
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|PC98
name|int
name|port
init|=
name|inb
argument_list|(
literal|0x33
argument_list|)
decl_stmt|;
if|if
condition|(
name|epson_machine_id
operator|==
literal|0x20
condition|)
name|epson_outb
argument_list|(
literal|0xc16
argument_list|,
name|epson_inb
argument_list|(
literal|0xc16
argument_list|)
operator||
literal|0x1
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
operator|&
name|NMI_PARITY
condition|)
block|{
name|panic
argument_list|(
literal|"BASE RAM parity error, likely hardware failure."
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|port
operator|&
name|NMI_EPARITY
condition|)
block|{
name|panic
argument_list|(
literal|"EXTENDED RAM parity error, likely hardware failure."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"\nNMI Resume ??\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|#
directive|else
comment|/* IBM-PC */
name|int
name|isa_port
init|=
name|inb
argument_list|(
literal|0x61
argument_list|)
decl_stmt|;
name|int
name|eisa_port
init|=
name|inb
argument_list|(
literal|0x461
argument_list|)
decl_stmt|;
if|if
condition|(
name|isa_port
operator|&
name|NMI_PARITY
condition|)
name|panic
argument_list|(
literal|"RAM parity error, likely hardware failure."
argument_list|)
expr_stmt|;
if|if
condition|(
name|isa_port
operator|&
name|NMI_IOCHAN
condition|)
name|panic
argument_list|(
literal|"I/O channel check, likely hardware failure."
argument_list|)
expr_stmt|;
comment|/* 	 * On a real EISA machine, this will never happen.  However it can 	 * happen on ISA machines which implement XT style floating point 	 * error handling (very rare).  Save them from a meaningless panic. 	 */
if|if
condition|(
name|eisa_port
operator|==
literal|0xff
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|eisa_port
operator|&
name|ENMI_WATCHDOG
condition|)
name|panic
argument_list|(
literal|"EISA watchdog timer expired, likely hardware failure."
argument_list|)
expr_stmt|;
if|if
condition|(
name|eisa_port
operator|&
name|ENMI_BUSTIMER
condition|)
name|panic
argument_list|(
literal|"EISA bus timeout, likely hardware failure."
argument_list|)
expr_stmt|;
if|if
condition|(
name|eisa_port
operator|&
name|ENMI_IOSTATUS
condition|)
name|panic
argument_list|(
literal|"EISA I/O port status error."
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nNMI ISA %x, EISA %x\n"
argument_list|,
name|isa_port
argument_list|,
name|eisa_port
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Caught a stray interrupt, notify  */
end_comment

begin_function
specifier|static
name|void
name|isa_strayintr
parameter_list|(
name|d
parameter_list|)
name|int
name|d
decl_stmt|;
block|{
comment|/* DON'T BOTHER FOR NOW! */
comment|/* for some reason, we get bursts of intr #7, even if not enabled! */
comment|/* 	 * Well the reason you got bursts of intr #7 is because someone 	 * raised an interrupt line and dropped it before the 8259 could 	 * prioritize it.  This is documented in the intel data book.  This 	 * means you have BAD hardware!  I have changed this so that only 	 * the first 5 get logged, then it quits logging them, and puts 	 * out a special message. rgrimes 3/25/1993 	 */
comment|/* 	 * XXX TODO print a different message for #7 if it is for a 	 * glitch.  Glitches can be distinguished from real #7's by 	 * testing that the in-service bit is _not_ set.  The test 	 * must be done before sending an EOI so it can't be done if 	 * we are using AUTO_EOI_1. 	 */
if|if
condition|(
name|intrcnt
index|[
name|NR_DEVICES
operator|+
name|d
index|]
operator|<=
literal|5
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"stray irq %d\n"
argument_list|,
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|intrcnt
index|[
name|NR_DEVICES
operator|+
name|d
index|]
operator|==
literal|5
condition|)
name|log
argument_list|(
name|LOG_CRIT
argument_list|,
literal|"too many stray irq %d's; not logging any more\n"
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Find the highest priority enabled display device.  Since we can't  * distinguish display devices from ttys, depend on display devices  * being sensitive and before sensitive non-display devices (if any)  * in isa_devtab_tty.  *  * XXX we should add capability flags IAMDISPLAY and ISUPPORTCONSOLES.  */
end_comment

begin_function
name|struct
name|isa_device
modifier|*
name|find_display
parameter_list|()
block|{
name|struct
name|isa_device
modifier|*
name|dvp
decl_stmt|;
for|for
control|(
name|dvp
operator|=
name|isa_devtab_tty
init|;
name|dvp
operator|->
name|id_driver
operator|!=
name|NULL
condition|;
name|dvp
operator|++
control|)
if|if
condition|(
name|dvp
operator|->
name|id_driver
operator|->
name|sensitive_hw
operator|&&
name|dvp
operator|->
name|id_enabled
condition|)
return|return
operator|(
name|dvp
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * find an ISA device in a given isa_devtab_* table, given  * the table to search, the expected id_driver entry, and the unit number.  *  * this function is defined in isa_device.h, and this location is debatable;  * i put it there because it's useless w/o, and directly operates on  * the other stuff in that file.  *  */
end_comment

begin_function
name|struct
name|isa_device
modifier|*
name|find_isadev
parameter_list|(
name|table
parameter_list|,
name|driverp
parameter_list|,
name|unit
parameter_list|)
name|struct
name|isa_device
modifier|*
name|table
decl_stmt|;
name|struct
name|isa_driver
modifier|*
name|driverp
decl_stmt|;
name|int
name|unit
decl_stmt|;
block|{
if|if
condition|(
name|driverp
operator|==
name|NULL
condition|)
comment|/* sanity check */
return|return
name|NULL
return|;
while|while
condition|(
operator|(
name|table
operator|->
name|id_driver
operator|!=
name|driverp
operator|)
operator|||
operator|(
name|table
operator|->
name|id_unit
operator|!=
name|unit
operator|)
condition|)
block|{
if|if
condition|(
name|table
operator|->
name|id_driver
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
name|table
operator|++
expr_stmt|;
block|}
return|return
name|table
return|;
block|}
end_function

begin_comment
comment|/*  * Return nonzero if a (masked) irq is pending for a given device.  */
end_comment

begin_function
name|int
name|isa_irq_pending
parameter_list|(
name|dvp
parameter_list|)
name|struct
name|isa_device
modifier|*
name|dvp
decl_stmt|;
block|{
name|unsigned
name|id_irq
decl_stmt|;
name|id_irq
operator|=
name|dvp
operator|->
name|id_irq
expr_stmt|;
if|if
condition|(
name|id_irq
operator|&
literal|0xff
condition|)
return|return
operator|(
name|inb
argument_list|(
name|IO_ICU1
argument_list|)
operator|&
name|id_irq
operator|)
return|;
return|return
operator|(
name|inb
argument_list|(
name|IO_ICU2
argument_list|)
operator|&
operator|(
name|id_irq
operator|>>
literal|8
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|update_intr_masks
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|intr
decl_stmt|,
name|n
init|=
literal|0
decl_stmt|;
name|u_int
name|mask
decl_stmt|,
modifier|*
name|maskptr
decl_stmt|;
for|for
control|(
name|intr
operator|=
literal|0
init|;
name|intr
operator|<
name|ICU_LEN
condition|;
name|intr
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|PC98
if|if
condition|(
name|intr
operator|==
literal|7
condition|)
continue|continue;
else|#
directive|else
if|if
condition|(
name|intr
operator|==
literal|2
condition|)
continue|continue;
endif|#
directive|endif
name|maskptr
operator|=
name|intr_mptr
index|[
name|intr
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|maskptr
condition|)
continue|continue;
operator|*
name|maskptr
operator||=
literal|1
operator|<<
name|intr
expr_stmt|;
name|mask
operator|=
operator|*
name|maskptr
expr_stmt|;
if|if
condition|(
name|mask
operator|!=
name|intr_mask
index|[
name|intr
index|]
condition|)
block|{
if|#
directive|if
literal|0
block|printf ("intr_mask[%2d] old=%08x new=%08x ptr=%p.\n", 				intr, intr_mask[intr], mask, maskptr);
endif|#
directive|endif
name|intr_mask
index|[
name|intr
index|]
operator|=
name|mask
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
block|}
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_function
name|int
name|register_intr
parameter_list|(
name|intr
parameter_list|,
name|device_id
parameter_list|,
name|flags
parameter_list|,
name|handler
parameter_list|,
name|maskptr
parameter_list|,
name|unit
parameter_list|)
name|int
name|intr
decl_stmt|;
name|int
name|device_id
decl_stmt|;
name|u_int
name|flags
decl_stmt|;
name|inthand2_t
modifier|*
name|handler
decl_stmt|;
name|u_int
modifier|*
name|maskptr
decl_stmt|;
name|int
name|unit
decl_stmt|;
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|u_long
name|ef
decl_stmt|;
name|int
name|id
decl_stmt|;
name|u_int
name|mask
init|=
operator|(
name|maskptr
condition|?
operator|*
name|maskptr
else|:
literal|0
operator|)
decl_stmt|;
ifdef|#
directive|ifdef
name|PC98
if|if
condition|(
operator|(
name|u_int
operator|)
name|intr
operator|>=
name|ICU_LEN
operator|||
name|intr
operator|==
literal|7
else|#
directive|else
if|if
condition|(
operator|(
name|u_int
operator|)
name|intr
operator|>=
name|ICU_LEN
operator|||
name|intr
operator|==
literal|2
endif|#
directive|endif
operator|||
operator|(
name|u_int
operator|)
name|device_id
operator|>=
name|NR_DEVICES
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|intr_handler
index|[
name|intr
index|]
operator|!=
name|isa_strayintr
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|ef
operator|=
name|read_eflags
argument_list|()
expr_stmt|;
name|disable_intr
argument_list|()
expr_stmt|;
name|intr_countp
index|[
name|intr
index|]
operator|=
operator|&
name|intrcnt
index|[
name|device_id
index|]
expr_stmt|;
name|intr_handler
index|[
name|intr
index|]
operator|=
name|handler
expr_stmt|;
name|intr_mptr
index|[
name|intr
index|]
operator|=
name|maskptr
expr_stmt|;
name|intr_mask
index|[
name|intr
index|]
operator|=
name|mask
operator||
operator|(
literal|1
operator|<<
name|intr
operator|)
expr_stmt|;
name|intr_unit
index|[
name|intr
index|]
operator|=
name|unit
expr_stmt|;
name|setidt
argument_list|(
name|ICU_OFFSET
operator|+
name|intr
argument_list|,
name|flags
operator|&
name|RI_FAST
condition|?
name|fastintr
index|[
name|intr
index|]
else|:
name|slowintr
index|[
name|intr
index|]
argument_list|,
name|SDT_SYS386IGT
argument_list|,
name|SEL_KPL
argument_list|,
name|GSEL
argument_list|(
name|GCODE_SEL
argument_list|,
name|SEL_KPL
argument_list|)
argument_list|)
expr_stmt|;
name|write_eflags
argument_list|(
name|ef
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|intrnames
operator|,
name|id
operator|=
literal|0
init|;
name|id
operator|<=
name|device_id
condition|;
name|id
operator|++
control|)
while|while
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|'\0'
condition|)
empty_stmt|;
if|if
condition|(
name|cp
operator|>
name|eintrnames
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|intr
operator|<
literal|10
condition|)
block|{
name|cp
index|[
operator|-
literal|3
index|]
operator|=
name|intr
operator|+
literal|'0'
expr_stmt|;
name|cp
index|[
operator|-
literal|2
index|]
operator|=
literal|' '
expr_stmt|;
block|}
else|else
block|{
name|cp
index|[
operator|-
literal|3
index|]
operator|=
literal|'1'
expr_stmt|;
name|cp
index|[
operator|-
literal|2
index|]
operator|=
name|intr
operator|-
literal|10
operator|+
literal|'0'
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|register_imask
parameter_list|(
name|dvp
parameter_list|,
name|mask
parameter_list|)
name|struct
name|isa_device
modifier|*
name|dvp
decl_stmt|;
name|u_int
name|mask
decl_stmt|;
block|{
if|if
condition|(
name|dvp
operator|->
name|id_alive
operator|&&
name|dvp
operator|->
name|id_irq
condition|)
block|{
name|int
name|intr
decl_stmt|;
name|intr
operator|=
name|ffs
argument_list|(
name|dvp
operator|->
name|id_irq
argument_list|)
operator|-
literal|1
expr_stmt|;
name|intr_mask
index|[
name|intr
index|]
operator|=
name|mask
operator||
operator|(
literal|1
operator|<<
name|intr
operator|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|update_intr_masks
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|int
name|unregister_intr
parameter_list|(
name|intr
parameter_list|,
name|handler
parameter_list|)
name|int
name|intr
decl_stmt|;
name|inthand2_t
modifier|*
name|handler
decl_stmt|;
block|{
name|u_long
name|ef
decl_stmt|;
if|if
condition|(
operator|(
name|u_int
operator|)
name|intr
operator|>=
name|ICU_LEN
operator|||
name|handler
operator|!=
name|intr_handler
index|[
name|intr
index|]
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ef
operator|=
name|read_eflags
argument_list|()
expr_stmt|;
name|disable_intr
argument_list|()
expr_stmt|;
name|intr_countp
index|[
name|intr
index|]
operator|=
operator|&
name|intrcnt
index|[
name|NR_DEVICES
operator|+
name|intr
index|]
expr_stmt|;
name|intr_handler
index|[
name|intr
index|]
operator|=
name|isa_strayintr
expr_stmt|;
name|intr_mptr
index|[
name|intr
index|]
operator|=
name|NULL
expr_stmt|;
name|intr_mask
index|[
name|intr
index|]
operator|=
name|HWI_MASK
operator||
name|SWI_MASK
expr_stmt|;
name|intr_unit
index|[
name|intr
index|]
operator|=
name|intr
expr_stmt|;
name|setidt
argument_list|(
name|ICU_OFFSET
operator|+
name|intr
argument_list|,
name|slowintr
index|[
name|intr
index|]
argument_list|,
name|SDT_SYS386IGT
argument_list|,
name|SEL_KPL
argument_list|,
name|GSEL
argument_list|(
name|GCODE_SEL
argument_list|,
name|SEL_KPL
argument_list|)
argument_list|)
expr_stmt|;
name|write_eflags
argument_list|(
name|ef
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_function
name|unsigned
name|int
name|ddb_inb
parameter_list|(
name|unsigned
name|int
name|addr
parameter_list|)
block|{
return|return
name|inb
argument_list|(
name|addr
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|ddb_outb
parameter_list|(
name|unsigned
name|int
name|addr
parameter_list|,
name|unsigned
name|char
name|dt
parameter_list|)
block|{
name|outb
argument_list|(
name|addr
argument_list|,
name|dt
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

