begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Julian SCSI driver for PC-9801 based on aha1542.c  *  * Copyright (c) by Yoshio Kimura  * 05/14/1994  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|"sbic.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<pc98/pc98/pc98.h>
end_include

begin_include
include|#
directive|include
file|<pc98/pc98/pc98_device.h>
end_include

begin_include
include|#
directive|include
file|<pc98/pc98/icu.h>
end_include

begin_include
include|#
directive|include
file|<pc98/pc98/ic/i8237.h>
end_include

begin_include
include|#
directive|include
file|<pc98/pc98/scsireg.h>
end_include

begin_include
include|#
directive|include
file|<scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<scsi/scsiconf.h>
end_include

begin_include
include|#
directive|include
file|<sys/devconf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_comment
comment|/************************** board definitions *******************************/
end_comment

begin_comment
comment|/*  * I/O Port Interface  */
end_comment

begin_define
define|#
directive|define
name|SBIC_BASE
value|sbic->sbic_base
end_define

begin_define
define|#
directive|define
name|SBIC_AUX_REG
value|(SBIC_BASE + 0)
end_define

begin_comment
comment|/* auxiliary status(R) */
end_comment

begin_define
define|#
directive|define
name|SBIC_ADR_REG
value|(SBIC_BASE + 0)
end_define

begin_comment
comment|/* address(W) */
end_comment

begin_define
define|#
directive|define
name|SBIC_CTL_REG
value|(SBIC_BASE + 2)
end_define

begin_comment
comment|/* control(R/W) */
end_comment

begin_define
define|#
directive|define
name|SBIC_STA_REG
value|(SBIC_BASE + 4)
end_define

begin_comment
comment|/* status(R/W) */
end_comment

begin_comment
comment|/*  * Register Access Interface  */
end_comment

begin_define
define|#
directive|define
name|SBIC_asr
parameter_list|(
name|val
parameter_list|)
value|(val) = inb(SBIC_AUX_REG)
end_define

begin_define
define|#
directive|define
name|GET_SBIC_REG
parameter_list|(
name|regno
parameter_list|,
name|val
parameter_list|)
value|{ \ 		outb(SBIC_ADR_REG, (regno)); \ 		(val) = inb(SBIC_CTL_REG); \ 	}
end_define

begin_define
define|#
directive|define
name|SET_SBIC_REG
parameter_list|(
name|regno
parameter_list|,
name|val
parameter_list|)
value|{ \ 		outb(SBIC_ADR_REG, (regno)); \ 		outb(SBIC_CTL_REG, (val)); \ 	}
end_define

begin_define
define|#
directive|define
name|SET_SCSI_CMD
parameter_list|(
name|cmd
parameter_list|,
name|cmdlen
parameter_list|)
value|{ \ 		int n; \ 		u_char *cmds = (u_char *)(cmd); \ 		SET_SBIC_REG(SBIC_cdbsize, (cmdlen)); \ 		for (n = 0; n< (cmdlen); n++) { \ 			SET_SBIC_REG(SBIC_cdb1 + n, cmds[n]); \ 		} \ 	}
end_define

begin_define
define|#
directive|define
name|SET_XFER_LEN
parameter_list|(
name|val
parameter_list|)
value|{ \ 		SET_SBIC_REG(SBIC_count_hi, ((val)& 0xff0000)>> 16); \ 		SET_SBIC_REG(SBIC_count_med, ((val)& 0x00ff00)>> 8); \ 		SET_SBIC_REG(SBIC_count_lo, (val)& 0x0000ff); \ 	}
end_define

begin_define
define|#
directive|define
name|SBIC_ENABLE_INT
parameter_list|()
value|{ \ 		int tmp; \ 		GET_SBIC_REG(SBIC_bank, tmp); \ 		SET_SBIC_REG(SBIC_bank, tmp | 0x04); \ 	}
end_define

begin_define
define|#
directive|define
name|SBIC_DISABLE_INT
parameter_list|()
value|{ \ 		int tmp; \ 		GET_SBIC_REG(SBIC_bank, tmp); \ 		SET_SBIC_REG(SBIC_bank, tmp& 0xfb); \ 	}
end_define

begin_define
define|#
directive|define
name|SBIC_DMA_ENABLE
parameter_list|()
value|outb(SBIC_STA_REG, 1)
end_define

begin_define
define|#
directive|define
name|INT3
value|0
end_define

begin_define
define|#
directive|define
name|INT5
value|1
end_define

begin_define
define|#
directive|define
name|INT6
value|2
end_define

begin_define
define|#
directive|define
name|INT9
value|3
end_define

begin_define
define|#
directive|define
name|INT12
value|4
end_define

begin_define
define|#
directive|define
name|INT13
value|5
end_define

begin_define
define|#
directive|define
name|SBIC_NSEG
value|17
end_define

begin_define
define|#
directive|define
name|SBIC_ID
value|7
end_define

begin_define
define|#
directive|define
name|MAXSIMUL
value|8
end_define

begin_define
define|#
directive|define
name|SBIC_RESET_TIMEOUT
value|2000
end_define

begin_comment
comment|/* time to wait for reset */
end_comment

begin_decl_stmt
specifier|extern
name|short
name|dmapageport
index|[]
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|sbic_ccb
block|{
name|u_char
name|target
decl_stmt|;
name|u_char
name|lun
decl_stmt|;
name|u_char
name|status
decl_stmt|;
name|u_char
name|message
decl_stmt|;
name|int
name|datalen
decl_stmt|;
name|int
name|sense_addr
decl_stmt|;
name|int
name|sense_len
decl_stmt|;
name|u_char
name|scsi_cmdlen
decl_stmt|;
name|struct
name|scsi_generic
name|scsi_cmd
decl_stmt|;
name|struct
name|scsi_xfer
modifier|*
name|xfer
decl_stmt|;
struct|struct
name|scat_gather
block|{
name|int
name|seg_addr
decl_stmt|;
name|int
name|seg_len
decl_stmt|;
block|}
name|scat_gath
index|[
name|SBIC_NSEG
index|]
struct|;
name|int
name|seg
decl_stmt|;
name|int
name|use_seg
decl_stmt|;
name|int
name|xs_flags
decl_stmt|;
name|int
name|flags
decl_stmt|;
define|#
directive|define
name|CCB_FREE
value|0x00
define|#
directive|define
name|CCB_ACTIVE
value|0x01
define|#
directive|define
name|CCB_ABORT
value|0x40
define|#
directive|define
name|CCB_SENSE
value|0x80
define|#
directive|define
name|CCB_BOUNCE
value|0x100
block|}
struct|;
end_struct

begin_struct
struct|struct
name|sbic_config
block|{
name|u_char
name|chan
decl_stmt|;
name|u_char
name|intr
decl_stmt|;
name|u_char
name|scsi_dev
range|:
literal|3
decl_stmt|;
name|u_char
label|:
literal|5
expr_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*********************************** end of board definitions***************/
end_comment

begin_define
define|#
directive|define
name|KVTOPHYS
parameter_list|(
name|x
parameter_list|)
value|vtophys(x)
end_define

begin_define
define|#
directive|define
name|SBIC_DMA_PAGES
value|SBIC_NSEG
end_define

begin_define
define|#
directive|define
name|PAGESIZ
value|4096
end_define

begin_define
define|#
directive|define
name|ALLWAYS_BOUNCE
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|ALLWAYS_BOUNCE
end_ifdef

begin_decl_stmt
specifier|static
name|vm_offset_t
name|sbic_bounce
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SBICDEBUG
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|sbic_debug
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|sbic_data
block|{
name|short
name|sbic_base
decl_stmt|;
comment|/* base port for each board */
name|struct
name|sbic_ccb
name|sbic_ccb
index|[
name|MAXSIMUL
index|]
decl_stmt|;
name|int
name|top
decl_stmt|;
comment|/* ccb queue top */
name|int
name|bottom
decl_stmt|;
comment|/* ccb queue end */
name|int
name|active
decl_stmt|;
comment|/* number of active ccb */
name|int
name|free
decl_stmt|;
comment|/* number of free ccb */
name|int
name|unit
decl_stmt|;
name|int
name|sbic_int
decl_stmt|;
comment|/* our irq level */
name|int
name|sbic_dma
decl_stmt|;
comment|/* our DMA req channel */
name|int
name|sbic_scsi_dev
decl_stmt|;
comment|/* our scsi bus address */
name|struct
name|scsi_link
name|sc_link
decl_stmt|;
comment|/* prototype for subdevs */
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|sbic_data
modifier|*
name|sbicdata
index|[
name|NSBIC
index|]
decl_stmt|;
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|static
name|struct
name|sbic_ccb
modifier|*
name|sbic_get_ccb
parameter_list|(
name|struct
name|sbic_data
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sbicprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sbic_done
parameter_list|(
name|struct
name|sbic_data
modifier|*
parameter_list|,
name|struct
name|sbic_ccb
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sbicattach
parameter_list|(
name|struct
name|isa_device
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|sbic_scsi_cmd
parameter_list|(
name|struct
name|scsi_xfer
modifier|*
name|xs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int32_t
name|sbic_adapter_info
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sbicminphys
parameter_list|(
name|struct
name|buf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sbic_free_ccb
parameter_list|(
name|struct
name|sbic_data
modifier|*
parameter_list|,
name|struct
name|sbic_ccb
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sbic_init
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xfer_addr_check
parameter_list|(
name|int
parameter_list|,
name|struct
name|sbic_ccb
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sbic_poll
parameter_list|(
name|struct
name|sbic_data
modifier|*
parameter_list|,
name|struct
name|sbic_ccb
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|start_scsi
parameter_list|(
name|struct
name|sbic_data
modifier|*
parameter_list|,
name|struct
name|sbic_ccb
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dataphase
parameter_list|(
name|struct
name|sbic_data
modifier|*
parameter_list|,
name|struct
name|sbic_ccb
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sbic_request_sense
parameter_list|(
name|struct
name|sbic_data
modifier|*
parameter_list|,
name|struct
name|sbic_ccb
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sbic_dmastart
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|unsigned
parameter_list|,
name|unsigned
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sbic_dmadone
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|unsigned
parameter_list|,
name|unsigned
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|scsi_adapter
name|sbic_switch
init|=
block|{
name|sbic_scsi_cmd
block|,
name|sbicminphys
block|,
literal|0
block|,
literal|0
block|,
name|sbic_adapter_info
block|,
literal|"sbic"
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the below structure is so we have a default dev struct for out link struct */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|scsi_device
name|sbic_dev
init|=
block|{
name|NULL
block|,
comment|/* Use default error handler */
name|NULL
block|,
comment|/* have a queue, served by this */
name|NULL
block|,
comment|/* have no async handler */
name|NULL
block|,
comment|/* Use default 'done' routine */
literal|"sbic"
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|isa_driver
name|sbicdriver
init|=
block|{
name|sbicprobe
block|,
name|sbicattach
block|,
literal|"sbic"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|kern_devconf
name|kdc_sbic
index|[
name|NSBIC
index|]
init|=
block|{
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* filled in by dev_attach */
literal|"sbic"
block|,
literal|0
block|,
block|{
name|MDDT_PC98
block|,
literal|0
block|,
literal|"bio"
block|}
block|,
name|pc98_generic_externalize
block|,
literal|0
block|,
literal|0
block|,
name|PC98_EXTERNALLEN
block|,
operator|&
name|kdc_nec0
block|,
comment|/* parent */
literal|0
block|,
comment|/* parentdata */
name|DC_UNCONFIGURED
block|,
comment|/* always start out here in probe */
literal|"55 compatible SCSI board host adapter"
block|,
name|DC_CLS_MISC
comment|/* host adapters aren't special */
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|inline
name|void
name|sbic_registerdev
parameter_list|(
name|struct
name|isa_device
modifier|*
name|id
parameter_list|)
block|{
if|if
condition|(
name|id
operator|->
name|id_unit
condition|)
name|kdc_sbic
index|[
name|id
operator|->
name|id_unit
index|]
operator|=
name|kdc_sbic
index|[
literal|0
index|]
expr_stmt|;
name|kdc_sbic
index|[
name|id
operator|->
name|id_unit
index|]
operator|.
name|kdc_unit
operator|=
name|id
operator|->
name|id_unit
expr_stmt|;
name|kdc_sbic
index|[
name|id
operator|->
name|id_unit
index|]
operator|.
name|kdc_parentdata
operator|=
name|id
expr_stmt|;
name|dev_attach
argument_list|(
operator|&
name|kdc_sbic
index|[
name|id
operator|->
name|id_unit
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|sbicunit
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Check if the device can be found at the port given  * and if so, set it up ready for further work  * as an argument, takes the pc98_device structure from  * autoconf.c  */
end_comment

begin_function
specifier|static
name|int
name|sbicprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|unit
init|=
name|sbicunit
decl_stmt|;
name|struct
name|sbic_data
modifier|*
name|sbic
decl_stmt|;
comment|/* 	 * find unit and check we have that many defined 	 */
if|if
condition|(
name|unit
operator|>=
name|NSBIC
condition|)
block|{
name|printf
argument_list|(
literal|"sbic: unit number (%d) to high\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|dev
operator|->
name|id_unit
operator|=
name|unit
expr_stmt|;
comment|/* 	 * a quick safety check so we can be sleazy later 	 */
if|if
condition|(
sizeof|sizeof
argument_list|(
expr|struct
name|sbic_data
argument_list|)
operator|>
name|PAGESIZ
condition|)
block|{
name|printf
argument_list|(
literal|"sbic struct> pagesize\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Allocate a storage area for us 	 */
if|if
condition|(
name|sbicdata
index|[
name|unit
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"sbic%d: memory already allocated\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sbic
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sbic_data
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sbic
condition|)
block|{
name|printf
argument_list|(
literal|"sbic%d: cannot malloc!\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|bzero
argument_list|(
name|sbic
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sbic_data
argument_list|)
argument_list|)
expr_stmt|;
name|sbicdata
index|[
name|unit
index|]
operator|=
name|sbic
expr_stmt|;
name|sbic
operator|->
name|sbic_base
operator|=
name|dev
operator|->
name|id_iobase
expr_stmt|;
ifdef|#
directive|ifdef
name|ALLWAYS_BOUNCE
comment|/* 	 * allocate bounce buffer for sense data 	 */
ifdef|#
directive|ifdef
name|EPSON_BOUNCEDMA
define|#
directive|define
name|PC98_RAMEND
value|0xf00000
else|#
directive|else
define|#
directive|define
name|PC98_RAMEND
value|RAM_END
endif|#
directive|endif
comment|/* try malloc() first. */
name|sbic_bounce
operator|=
operator|(
name|vm_offset_t
operator|)
name|malloc
argument_list|(
name|PAGE_SIZE
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sbic_bounce
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|vtophys
argument_list|(
name|sbic_bounce
argument_list|)
operator|>=
name|PC98_RAMEND
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|sbic_bounce
operator|=
operator|(
name|vm_offset_t
operator|)
name|contigmalloc
argument_list|(
name|PAGE_SIZE
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|,
literal|0ul
argument_list|,
name|PC98_RAMEND
argument_list|,
literal|1ul
argument_list|,
literal|0x10000ul
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sbic_bounce
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"Can't allocate bounce buffer."
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|DEV_LKM
name|sbic_registerdev
argument_list|(
name|dev
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Try initialize a unit at this location 	 * sets up dma, loads sbic_init[unit] 	 */
if|if
condition|(
name|sbic_init
argument_list|(
name|unit
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|sbicdata
index|[
name|unit
index|]
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|sbic
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * If it's there, put in it's interrupt vectors 	 */
name|dev
operator|->
name|id_irq
operator|=
operator|(
literal|1
operator|<<
name|sbic
operator|->
name|sbic_int
operator|)
expr_stmt|;
name|dev
operator|->
name|id_drq
operator|=
name|sbic
operator|->
name|sbic_dma
expr_stmt|;
name|sbicunit
operator|++
expr_stmt|;
return|return
operator|(
literal|5
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Attach all the sub-devices we can find.  */
end_comment

begin_function
specifier|static
name|int
name|sbicattach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|unit
init|=
name|dev
operator|->
name|id_unit
decl_stmt|;
name|struct
name|sbic_data
modifier|*
name|sbic
init|=
name|sbicdata
index|[
name|unit
index|]
decl_stmt|;
name|struct
name|scsibus_data
modifier|*
name|scbus
decl_stmt|;
comment|/* 	 * fill in the prototype scsi_link 	 */
name|sbic
operator|->
name|sc_link
operator|.
name|adapter_unit
operator|=
name|unit
expr_stmt|;
name|sbic
operator|->
name|sc_link
operator|.
name|adapter_targ
operator|=
name|sbic
operator|->
name|sbic_scsi_dev
expr_stmt|;
name|sbic
operator|->
name|sc_link
operator|.
name|adapter_softc
operator|=
name|sbic
expr_stmt|;
name|sbic
operator|->
name|sc_link
operator|.
name|adapter
operator|=
operator|&
name|sbic_switch
expr_stmt|;
name|sbic
operator|->
name|sc_link
operator|.
name|device
operator|=
operator|&
name|sbic_dev
expr_stmt|;
name|sbic
operator|->
name|sc_link
operator|.
name|flags
operator|=
name|SDEV_BOUNCE
expr_stmt|;
comment|/* 	 * Prepare the scsibus_data area for the upperlevel 	 * scsi code. 	 */
name|scbus
operator|=
name|scsi_alloc_bus
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|scbus
condition|)
return|return
literal|0
return|;
name|scbus
operator|->
name|adapter_link
operator|=
operator|&
name|sbic
operator|->
name|sc_link
expr_stmt|;
comment|/* 	 * ask the adapter what subunits are present 	 */
name|kdc_sbic
index|[
name|unit
index|]
operator|.
name|kdc_state
operator|=
name|DC_BUSY
expr_stmt|;
comment|/* host adapters are always busy */
name|scsi_attachdevs
argument_list|(
name|scbus
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Return some information to the caller about  * the adapter and it's capabilities  */
end_comment

begin_function
specifier|static
name|u_int32_t
name|sbic_adapter_info
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 1 outstanding request at a time per device */
block|}
end_function

begin_comment
comment|/*  * Catch an interrupt from the adapter  */
end_comment

begin_function
name|void
name|sbicintr
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|struct
name|sbic_ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|sbic_data
modifier|*
name|sbic
init|=
name|sbicdata
index|[
name|unit
index|]
decl_stmt|;
name|u_char
name|asr
decl_stmt|,
name|host_stat
decl_stmt|,
name|cmd_phase
decl_stmt|;
name|u_char
modifier|*
name|cmd
decl_stmt|;
name|int
name|i
decl_stmt|,
name|seg
decl_stmt|,
name|phys
decl_stmt|;
ifdef|#
directive|ifdef
name|SBICDEBUG
name|printf
argument_list|(
literal|"sbicintr"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SBICDEBUG */
name|SBIC_asr
argument_list|(
name|asr
argument_list|)
expr_stmt|;
comment|/* drop spurious interrupts */
if|if
condition|(
operator|!
operator|(
name|asr
operator|&
name|SBIC_ASR_INT
operator|)
condition|)
return|return;
name|GET_SBIC_REG
argument_list|(
name|SBIC_csr
argument_list|,
name|host_stat
argument_list|)
expr_stmt|;
name|GET_SBIC_REG
argument_list|(
name|SBIC_cmd_phase
argument_list|,
name|cmd_phase
argument_list|)
expr_stmt|;
name|ccb
operator|=
operator|&
name|sbic
operator|->
name|sbic_ccb
index|[
name|sbic
operator|->
name|top
index|]
expr_stmt|;
name|seg
operator|=
name|ccb
operator|->
name|seg
expr_stmt|;
switch|switch
condition|(
name|host_stat
condition|)
block|{
case|case
name|SBIC_CSR_XFERRED
operator||
name|SBIC_MCI_DATA_OUT
case|:
comment|/* data phase start */
case|case
name|SBIC_CSR_MIS_1
operator||
name|SBIC_MCI_DATA_OUT
case|:
comment|/* data phase continue */
case|case
name|SBIC_CSR_XFERRED
operator||
name|SBIC_MCI_DATA_IN
case|:
case|case
name|SBIC_CSR_MIS_1
operator||
name|SBIC_MCI_DATA_IN
case|:
name|dataphase
argument_list|(
name|sbic
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
return|return;
case|case
name|SBIC_CSR_MIS_1
operator||
name|SBIC_MCI_STATUS
case|:
comment|/* status phase start */
case|case
name|SBIC_CSR_XFERRED
operator||
name|SBIC_MCI_STATUS
case|:
comment|/* status phase start */
name|SET_XFER_LEN
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|SET_SBIC_REG
argument_list|(
name|SBIC_cmd_phase
argument_list|,
literal|0x46
argument_list|)
expr_stmt|;
name|SET_SBIC_REG
argument_list|(
name|SBIC_cmd
argument_list|,
name|SBIC_CMD_SEL_XFER
argument_list|)
expr_stmt|;
return|return;
case|case
name|SBIC_CSR_S_XFERRED
case|:
name|phys
operator|=
name|KVTOPHYS
argument_list|(
name|ccb
operator|->
name|sense_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|flags
operator|&
name|CCB_SENSE
condition|)
block|{
name|sbic_dmadone
argument_list|(
name|B_READ
argument_list|,
name|phys
argument_list|,
name|ccb
operator|->
name|sense_len
argument_list|,
name|sbic
operator|->
name|sbic_dma
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|ccb
operator|->
name|datalen
operator|)
operator|&&
operator|(
name|ccb
operator|->
name|xs_flags
operator|&
name|SCSI_DATA_IN
operator|)
condition|)
block|{
name|sbic_dmadone
argument_list|(
name|B_READ
argument_list|,
name|ccb
operator|->
name|scat_gath
index|[
name|seg
operator|-
literal|1
index|]
operator|.
name|seg_addr
argument_list|,
name|ccb
operator|->
name|scat_gath
index|[
name|seg
operator|-
literal|1
index|]
operator|.
name|seg_len
argument_list|,
name|sbic
operator|->
name|sbic_dma
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|datalen
operator|)
operator|&&
operator|(
name|ccb
operator|->
name|xs_flags
operator|&
name|SCSI_DATA_OUT
operator|)
condition|)
block|{
name|sbic_dmadone
argument_list|(
name|B_WRITE
argument_list|,
name|ccb
operator|->
name|scat_gath
index|[
name|seg
operator|-
literal|1
index|]
operator|.
name|seg_addr
argument_list|,
name|ccb
operator|->
name|scat_gath
index|[
name|seg
operator|-
literal|1
index|]
operator|.
name|seg_len
argument_list|,
name|sbic
operator|->
name|sbic_dma
argument_list|)
expr_stmt|;
block|}
block|}
name|GET_SBIC_REG
argument_list|(
name|SBIC_tlun
argument_list|,
name|ccb
operator|->
name|status
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|status
operator|&=
literal|0x1f
expr_stmt|;
switch|switch
condition|(
name|ccb
operator|->
name|status
condition|)
block|{
case|case
name|SCSI_CHECK
case|:
name|ccb
operator|->
name|flags
operator||=
name|CCB_SENSE
expr_stmt|;
name|ccb
operator|->
name|xfer
operator|->
name|error
operator|=
name|XS_SENSE
expr_stmt|;
name|sbic_request_sense
argument_list|(
name|sbic
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
return|return;
case|case
name|SCSI_BUSY
case|:
name|ccb
operator|->
name|xfer
operator|->
name|error
operator|=
name|XS_BUSY
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|sbic_done
argument_list|(
name|sbic
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
break|break;
case|case
name|SBIC_CSR_SEL_TIMEO
case|:
comment|/* selection timeout */
name|ccb
operator|->
name|xfer
operator|->
name|error
operator|=
name|XS_TIMEOUT
expr_stmt|;
name|sbic_done
argument_list|(
name|sbic
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"sbic%d:%d:%d -- "
argument_list|,
name|unit
argument_list|,
name|ccb
operator|->
name|target
argument_list|,
name|ccb
operator|->
name|lun
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"host: %x interrupt occured\n"
argument_list|,
name|host_stat
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"Unsupported interrupts. check intr code\n"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * A ccb is put onto the free list.  */
end_comment

begin_function
specifier|static
name|void
name|sbic_free_ccb
parameter_list|(
name|struct
name|sbic_data
modifier|*
name|sbic
parameter_list|,
name|struct
name|sbic_ccb
modifier|*
name|ccb
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|unsigned
name|opri
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|)
name|opri
operator|=
name|splbio
argument_list|()
expr_stmt|;
if|if
condition|(
name|ccb
operator|=
operator|&
name|sbic
operator|->
name|sbic_ccb
index|[
name|sbic
operator|->
name|top
index|]
condition|)
name|sbic
operator|->
name|top
operator|=
operator|++
name|sbic
operator|->
name|top
operator|%
name|MAXSIMUL
expr_stmt|;
else|else
name|sbic
operator|->
name|bottom
operator|=
operator|(
operator|--
name|sbic
operator|->
name|bottom
operator|+
name|MAXSIMUL
operator|)
operator|%
name|MAXSIMUL
expr_stmt|;
name|sbic
operator|->
name|active
operator|--
expr_stmt|;
name|sbic
operator|->
name|free
operator|++
expr_stmt|;
name|ccb
operator|->
name|flags
operator|=
name|CCB_FREE
expr_stmt|;
if|if
condition|(
name|sbic
operator|->
name|free
condition|)
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|sbic
operator|->
name|free
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|)
name|splx
argument_list|(
name|opri
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get a free ccb  */
end_comment

begin_function
specifier|static
name|struct
name|sbic_ccb
modifier|*
name|sbic_get_ccb
parameter_list|(
name|struct
name|sbic_data
modifier|*
name|sbic
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|unsigned
name|opri
init|=
literal|0
decl_stmt|;
name|struct
name|sbic_ccb
modifier|*
name|rc
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|)
name|opri
operator|=
name|splbio
argument_list|()
expr_stmt|;
comment|/* 	 * If we can and have to, sleep waiting for one to come free 	 */
while|while
condition|(
operator|(
operator|!
name|sbic
operator|->
name|free
operator|)
operator|&&
operator|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOSLEEP
operator|)
operator|)
condition|)
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|sbic
operator|->
name|free
argument_list|,
name|PRIBIO
argument_list|,
literal|"sbicccb"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sbic
operator|->
name|free
condition|)
block|{
name|rc
operator|=
operator|&
name|sbic
operator|->
name|sbic_ccb
index|[
name|sbic
operator|->
name|bottom
index|]
expr_stmt|;
name|sbic
operator|->
name|free
operator|--
expr_stmt|;
name|sbic
operator|->
name|active
operator|++
expr_stmt|;
name|sbic
operator|->
name|bottom
operator|=
operator|++
name|sbic
operator|->
name|bottom
operator|%
name|MAXSIMUL
expr_stmt|;
name|rc
operator|->
name|flags
operator|=
name|CCB_ACTIVE
expr_stmt|;
block|}
else|else
name|rc
operator|=
operator|(
expr|struct
name|sbic_ccb
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|)
name|splx
argument_list|(
name|opri
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * We have a ccb which has been processed by the  * adapter, now we lock to see how the operation  * went. Wake up the owner if waiting  */
end_comment

begin_function
specifier|static
name|void
name|sbic_done
parameter_list|(
name|struct
name|sbic_data
modifier|*
name|sbic
parameter_list|,
name|struct
name|sbic_ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|scsi_xfer
modifier|*
name|xs
init|=
name|ccb
operator|->
name|xfer
decl_stmt|;
name|unsigned
name|opri
decl_stmt|;
name|SC_DEBUG
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB2
argument_list|,
operator|(
literal|"sbic_done\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|xs
operator|->
name|flags
operator|&
name|INUSE
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"sbic%d: exiting but not in use!\n"
argument_list|,
name|sbic
operator|->
name|unit
argument_list|)
expr_stmt|;
name|Debugger
argument_list|(
literal|"sbic55"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|!
name|xs
operator|->
name|error
operator|)
operator|||
operator|(
name|xs
operator|->
name|flags
operator|&
name|SCSI_ERR_OK
operator|)
condition|)
name|xs
operator|->
name|resid
operator|=
literal|0
expr_stmt|;
name|xs
operator|->
name|flags
operator||=
name|ITSDONE
expr_stmt|;
ifdef|#
directive|ifdef
name|ALLWAYS_BOUNCE
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ccb
operator|->
name|sense_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|xs
operator|->
name|sense
argument_list|,
name|ccb
operator|->
name|sense_len
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|ccb
operator|->
name|flags
operator|&
name|CCB_BOUNCE
condition|)
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ccb
operator|->
name|sense_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|xs
operator|->
name|sense
argument_list|,
name|ccb
operator|->
name|sense_len
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sbic_free_ccb
argument_list|(
name|sbic
argument_list|,
name|ccb
argument_list|,
name|xs
operator|->
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|sbic
operator|->
name|active
condition|)
block|{
name|opri
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|SBIC_ENABLE_INT
argument_list|()
expr_stmt|;
name|start_scsi
argument_list|(
name|sbic
argument_list|,
operator|&
name|sbic
operator|->
name|sbic_ccb
index|[
name|sbic
operator|->
name|top
index|]
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|opri
argument_list|)
expr_stmt|;
block|}
name|scsi_done
argument_list|(
name|xs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Start the board, ready for normal operation  */
end_comment

begin_function
specifier|static
name|int
name|sbic_init
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|struct
name|sbic_data
modifier|*
name|sbic
init|=
name|sbicdata
index|[
name|unit
index|]
decl_stmt|;
name|struct
name|sbic_config
name|conf
decl_stmt|;
name|int
name|i
decl_stmt|,
name|asr
decl_stmt|,
name|csr
decl_stmt|,
name|tmp
decl_stmt|;
name|SBIC_asr
argument_list|(
name|asr
argument_list|)
expr_stmt|;
comment|/* dummy read */
name|GET_SBIC_REG
argument_list|(
name|SBIC_csr
argument_list|,
name|csr
argument_list|)
expr_stmt|;
name|SBIC_DISABLE_INT
argument_list|()
expr_stmt|;
name|SET_SBIC_REG
argument_list|(
name|SBIC_myid
argument_list|,
name|SBIC_ID_FS_16_20
operator||
name|SBIC_ID
argument_list|)
expr_stmt|;
name|SET_SBIC_REG
argument_list|(
name|SBIC_cmd
argument_list|,
name|SBIC_CMD_RESET
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|SBIC_RESET_TIMEOUT
init|;
name|i
condition|;
name|i
operator|--
control|)
block|{
name|SBIC_asr
argument_list|(
name|asr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|asr
operator|!=
literal|0xff
operator|)
operator|&&
operator|(
name|asr
operator|&
name|SBIC_ASR_INT
operator|)
condition|)
block|{
name|GET_SBIC_REG
argument_list|(
name|SBIC_csr
argument_list|,
name|csr
argument_list|)
expr_stmt|;
if|if
condition|(
name|csr
operator|==
name|SBIC_CSR_RESET
condition|)
break|break;
block|}
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* calibrated in msec */
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|SBICDEBUG
if|if
condition|(
name|sbic_debug
condition|)
name|printf
argument_list|(
literal|"sbic_init: No answer from sbic board\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|conf
operator|.
name|chan
operator|=
operator|(
name|inb
argument_list|(
name|SBIC_STA_REG
argument_list|)
operator|&
literal|0x03
operator|)
expr_stmt|;
name|GET_SBIC_REG
argument_list|(
name|SBIC_int
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|conf
operator|.
name|intr
operator|=
operator|(
name|tmp
operator|>>
literal|3
operator|)
operator|&
literal|0x07
expr_stmt|;
name|conf
operator|.
name|scsi_dev
operator|=
name|tmp
operator|&
literal|0x07
expr_stmt|;
name|sbic
operator|->
name|sbic_dma
operator|=
name|conf
operator|.
name|chan
expr_stmt|;
name|sbic
operator|->
name|sbic_scsi_dev
operator|=
name|conf
operator|.
name|scsi_dev
expr_stmt|;
switch|switch
condition|(
name|conf
operator|.
name|intr
condition|)
block|{
case|case
name|INT3
case|:
name|sbic
operator|->
name|sbic_int
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|INT5
case|:
name|sbic
operator|->
name|sbic_int
operator|=
literal|5
expr_stmt|;
break|break;
case|case
name|INT6
case|:
name|sbic
operator|->
name|sbic_int
operator|=
literal|6
expr_stmt|;
break|break;
case|case
name|INT9
case|:
name|sbic
operator|->
name|sbic_int
operator|=
literal|9
expr_stmt|;
break|break;
case|case
name|INT12
case|:
name|sbic
operator|->
name|sbic_int
operator|=
literal|12
expr_stmt|;
break|break;
case|case
name|INT13
case|:
name|sbic
operator|->
name|sbic_int
operator|=
literal|13
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"illegal int jumpter setting\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|SET_SBIC_REG
argument_list|(
name|SBIC_rselid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
name|SET_SBIC_REG
argument_list|(
name|SBIC_timeo
argument_list|,
literal|0x80
argument_list|)
expr_stmt|;
else|#
directive|else
name|SET_SBIC_REG
argument_list|(
name|SBIC_timeo
argument_list|,
literal|0xa0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SET_SBIC_REG
argument_list|(
name|SBIC_control
argument_list|,
name|SBIC_CTL_EDI
argument_list|)
expr_stmt|;
name|SET_SBIC_REG
argument_list|(
name|SBIC_syn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SBIC_ENABLE_INT
argument_list|()
expr_stmt|;
comment|/* 	 * ccb queue initialize 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXSIMUL
condition|;
name|i
operator|++
control|)
block|{
name|sbic
operator|->
name|sbic_ccb
index|[
name|i
index|]
operator|.
name|flags
operator|=
name|CCB_FREE
expr_stmt|;
block|}
name|sbic
operator|->
name|top
operator|=
name|sbic
operator|->
name|bottom
operator|=
name|sbic
operator|->
name|active
operator|=
literal|0
expr_stmt|;
name|sbic
operator|->
name|free
operator|=
name|MAXSIMUL
expr_stmt|;
comment|/* 	 * Note that wa are going and return (to probe) 	 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sbicminphys
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
comment|/*	sbic seems to explode with 17 segs (64k may require 17 segs) */
if|if
condition|(
name|bp
operator|->
name|b_bcount
operator|>
operator|(
operator|(
name|SBIC_NSEG
operator|-
literal|1
operator|)
operator|*
name|PAGESIZ
operator|)
condition|)
name|bp
operator|->
name|b_bcount
operator|=
operator|(
operator|(
name|SBIC_NSEG
operator|-
literal|1
operator|)
operator|*
name|PAGESIZ
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * start a scsi operation given the command and  * the data address. Also needs the unit, target  * and lu  */
end_comment

begin_function
specifier|static
name|int32_t
name|sbic_scsi_cmd
parameter_list|(
name|struct
name|scsi_xfer
modifier|*
name|xs
parameter_list|)
block|{
name|struct
name|scsi_link
modifier|*
name|sc_link
init|=
name|xs
operator|->
name|sc_link
decl_stmt|;
name|int
name|unit
init|=
name|sc_link
operator|->
name|adapter_unit
decl_stmt|;
name|struct
name|sbic_data
modifier|*
name|sbic
init|=
name|sc_link
operator|->
name|adapter_softc
decl_stmt|;
name|struct
name|sbic_ccb
modifier|*
name|ccb
decl_stmt|;
name|int
name|s
decl_stmt|,
name|i
decl_stmt|,
name|retval
decl_stmt|,
name|flags
decl_stmt|;
name|SC_DEBUG
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB2
argument_list|,
operator|(
literal|"sbic_scsi_cmd\n"
operator|)
argument_list|)
expr_stmt|;
name|flags
operator|=
name|xs
operator|->
name|flags
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ccb
operator|=
name|sbic_get_ccb
argument_list|(
name|sbic
argument_list|,
name|flags
argument_list|)
operator|)
condition|)
block|{
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
return|return
operator|(
name|TRY_AGAIN_LATER
operator|)
return|;
block|}
name|ccb
operator|->
name|xfer
operator|=
name|xs
expr_stmt|;
name|ccb
operator|->
name|target
operator|=
name|xs
operator|->
name|sc_link
operator|->
name|target
expr_stmt|;
name|ccb
operator|->
name|lun
operator|=
name|xs
operator|->
name|sc_link
operator|->
name|lun
expr_stmt|;
name|ccb
operator|->
name|xs_flags
operator|=
name|xs
operator|->
name|flags
expr_stmt|;
name|ccb
operator|->
name|scsi_cmdlen
operator|=
name|xs
operator|->
name|cmdlen
expr_stmt|;
name|ccb
operator|->
name|datalen
operator|=
name|xs
operator|->
name|datalen
expr_stmt|;
name|ccb
operator|->
name|sense_len
operator|=
sizeof|sizeof
argument_list|(
name|xs
operator|->
name|sense
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ALLWAYS_BOUNCE
name|ccb
operator|->
name|sense_addr
operator|=
call|(
name|int
call|)
argument_list|(
name|sbic_bounce
argument_list|)
expr_stmt|;
else|#
directive|else
name|ccb
operator|->
name|sense_addr
operator|=
operator|(
name|int
operator|)
operator|&
name|xs
operator|->
name|sense
expr_stmt|;
endif|#
directive|endif
name|ccb
operator|->
name|seg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|retval
operator|=
name|xfer_addr_check
argument_list|(
name|unit
argument_list|,
name|ccb
argument_list|)
condition|)
block|{
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
name|sbic_free_ccb
argument_list|(
name|sbic
argument_list|,
name|ccb
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_RESET
operator|)
condition|)
block|{
name|bcopy
argument_list|(
name|xs
operator|->
name|cmd
argument_list|,
operator|&
name|ccb
operator|->
name|scsi_cmd
argument_list|,
name|ccb
operator|->
name|scsi_cmdlen
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|scsi_cmd
operator|.
name|bytes
index|[
literal|0
index|]
operator||=
operator|(
operator|(
name|ccb
operator|->
name|lun
operator|<<
literal|5
operator|)
operator|&
literal|0xe0
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|)
block|{
if|if
condition|(
name|sbic
operator|->
name|active
operator|==
literal|1
condition|)
block|{
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|SBIC_ENABLE_INT
argument_list|()
expr_stmt|;
name|start_scsi
argument_list|(
name|sbic
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|SC_DEBUG
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB3
argument_list|,
operator|(
literal|"sent\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|SUCCESSFULLY_QUEUED
operator|)
return|;
block|}
name|SBIC_DISABLE_INT
argument_list|()
expr_stmt|;
name|start_scsi
argument_list|(
name|sbic
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
name|SC_DEBUG
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB3
argument_list|,
operator|(
literal|"cmd sent, waiting\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|sbic_poll
argument_list|(
name|sbic
argument_list|,
name|ccb
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sbic_poll
parameter_list|(
name|struct
name|sbic_data
modifier|*
name|sbic
parameter_list|,
name|struct
name|sbic_ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|int
name|count
decl_stmt|,
name|asr
decl_stmt|,
name|done
init|=
literal|0
decl_stmt|;
name|count
operator|=
name|ccb
operator|->
name|xfer
operator|->
name|timeout
operator|*
literal|1000
expr_stmt|;
while|while
condition|(
name|count
condition|)
block|{
name|SBIC_asr
argument_list|(
name|asr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|asr
operator|!=
literal|0xff
operator|)
operator|&&
operator|(
name|asr
operator|&
name|SBIC_ASR_INT
operator|)
condition|)
block|{
name|sbicintr
argument_list|(
name|sbic
operator|->
name|unit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ccb
operator|->
name|xfer
operator|->
name|flags
operator|&
name|ITSDONE
condition|)
block|{
break|break;
block|}
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|count
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|count
condition|)
name|panic
argument_list|(
literal|"sbic scsi timeout!!"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|xfer
operator|->
name|error
condition|)
return|return
operator|(
name|HAD_ERROR
operator|)
return|;
return|return
operator|(
name|COMPLETE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xfer_addr_check
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|sbic_ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|struct
name|iovec
modifier|*
name|iovp
decl_stmt|;
name|struct
name|scat_gather
modifier|*
name|sg
decl_stmt|;
name|struct
name|scsi_xfer
modifier|*
name|xs
decl_stmt|;
name|int
name|thiskv
decl_stmt|,
name|thisphys
decl_stmt|,
name|nextphys
decl_stmt|;
name|int
name|bytes_this_page
decl_stmt|,
name|bytes_this_seg
decl_stmt|;
name|int
name|datalen
decl_stmt|,
name|flags
decl_stmt|;
name|xs
operator|=
name|ccb
operator|->
name|xfer
expr_stmt|;
name|flags
operator|=
name|ccb
operator|->
name|xs_flags
expr_stmt|;
if|if
condition|(
operator|(
name|xs
operator|->
name|datalen
operator|)
operator|&&
operator|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_RESET
operator|)
operator|)
condition|)
block|{
name|sg
operator|=
name|ccb
operator|->
name|scat_gath
expr_stmt|;
name|ccb
operator|->
name|use_seg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SCSI_DATA_UIO
condition|)
block|{
name|iovp
operator|=
operator|(
operator|(
expr|struct
name|uio
operator|*
operator|)
name|xs
operator|->
name|data
operator|)
operator|->
name|uio_iov
expr_stmt|;
name|datalen
operator|=
operator|(
operator|(
expr|struct
name|uio
operator|*
operator|)
name|xs
operator|->
name|data
operator|)
operator|->
name|uio_iovcnt
expr_stmt|;
while|while
condition|(
operator|(
name|datalen
operator|)
operator|&&
operator|(
name|ccb
operator|->
name|use_seg
operator|<
name|SBIC_NSEG
operator|)
condition|)
block|{
name|sg
operator|->
name|seg_addr
operator|=
name|KVTOPHYS
argument_list|(
operator|(
name|int
operator|)
name|iovp
operator|->
name|iov_base
argument_list|)
expr_stmt|;
name|sg
operator|->
name|seg_len
operator|=
name|iovp
operator|->
name|iov_len
expr_stmt|;
name|SC_DEBUGN
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB4
argument_list|,
operator|(
literal|"UIO(0x%x@0x%x)"
operator|,
name|iovp
operator|->
name|iov_len
operator|,
name|iovp
operator|->
name|iov_base
operator|)
argument_list|)
expr_stmt|;
name|sg
operator|++
expr_stmt|;
name|iovp
operator|++
expr_stmt|;
name|ccb
operator|->
name|use_seg
operator|++
expr_stmt|;
name|datalen
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 			 * Set up scatter gather block 			 */
name|SC_DEBUG
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB4
argument_list|,
operator|(
literal|"%d @0x%x:- "
operator|,
name|xs
operator|->
name|datalen
operator|,
name|xs
operator|->
name|data
operator|)
argument_list|)
expr_stmt|;
name|datalen
operator|=
name|xs
operator|->
name|datalen
expr_stmt|;
name|thiskv
operator|=
operator|(
name|int
operator|)
name|xs
operator|->
name|data
expr_stmt|;
name|thisphys
operator|=
name|KVTOPHYS
argument_list|(
name|thiskv
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|datalen
operator|)
operator|&&
operator|(
name|ccb
operator|->
name|use_seg
operator|<
name|SBIC_NSEG
operator|)
condition|)
block|{
name|bytes_this_seg
operator|=
literal|0
expr_stmt|;
name|sg
operator|->
name|seg_addr
operator|=
name|thisphys
expr_stmt|;
name|SC_DEBUGN
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB4
argument_list|,
operator|(
literal|"0x%x"
operator|,
name|thisphys
operator|)
argument_list|)
expr_stmt|;
name|nextphys
operator|=
name|thisphys
expr_stmt|;
while|while
condition|(
operator|(
name|datalen
operator|)
operator|&&
operator|(
name|thisphys
operator|==
name|nextphys
operator|)
condition|)
block|{
if|if
condition|(
name|thisphys
operator|>
literal|0xFFFFFF
condition|)
block|{
name|printf
argument_list|(
literal|"sbic%d: DMA beyond"
literal|" end of PC98\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
return|return
operator|(
name|HAD_ERROR
operator|)
return|;
block|}
name|nextphys
operator|=
operator|(
name|thisphys
operator|&
operator|(
operator|~
operator|(
name|PAGESIZ
operator|-
literal|1
operator|)
operator|)
operator|)
operator|+
name|PAGESIZ
expr_stmt|;
name|bytes_this_page
operator|=
name|nextphys
operator|-
name|thisphys
expr_stmt|;
name|bytes_this_page
operator|=
name|min
argument_list|(
name|bytes_this_page
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
name|bytes_this_seg
operator|+=
name|bytes_this_page
expr_stmt|;
name|datalen
operator|-=
name|bytes_this_page
expr_stmt|;
name|thiskv
operator|=
operator|(
name|thiskv
operator|&
operator|(
operator|~
operator|(
name|PAGESIZ
operator|-
literal|1
operator|)
operator|)
operator|)
operator|+
name|PAGESIZ
expr_stmt|;
if|if
condition|(
name|datalen
condition|)
name|thisphys
operator|=
name|KVTOPHYS
argument_list|(
name|thiskv
argument_list|)
expr_stmt|;
block|}
name|SC_DEBUGN
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB4
argument_list|,
operator|(
literal|"(0x%x)"
operator|,
name|bytes_this_seg
operator|)
argument_list|)
expr_stmt|;
name|sg
operator|->
name|seg_len
operator|=
name|bytes_this_seg
expr_stmt|;
name|sg
operator|++
expr_stmt|;
name|ccb
operator|->
name|use_seg
operator|++
expr_stmt|;
block|}
block|}
name|SC_DEBUGN
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB4
argument_list|,
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|datalen
condition|)
block|{
name|printf
argument_list|(
literal|"sbic%d: sbic_scsi_cmd, more than %d DMA segs\n"
argument_list|,
name|unit
argument_list|,
name|SBIC_NSEG
argument_list|)
expr_stmt|;
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
return|return
operator|(
name|HAD_ERROR
operator|)
return|;
block|}
block|}
else|else
block|{
name|ccb
operator|->
name|scat_gath
index|[
literal|0
index|]
operator|.
name|seg_len
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|start_scsi
parameter_list|(
name|struct
name|sbic_data
modifier|*
name|sbic
parameter_list|,
name|struct
name|sbic_ccb
modifier|*
name|ccb
parameter_list|)
block|{
if|if
condition|(
name|ccb
operator|->
name|xs_flags
operator|&
name|SCSI_RESET
condition|)
block|{
name|SET_SBIC_REG
argument_list|(
name|SBIC_cmd
argument_list|,
name|SBIC_CMD_RESET
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|datalen
operator|)
operator|&&
operator|(
name|ccb
operator|->
name|xs_flags
operator|&
name|SCSI_DATA_IN
operator|)
condition|)
name|sbic_dmastart
argument_list|(
name|B_READ
argument_list|,
name|ccb
operator|->
name|scat_gath
index|[
literal|0
index|]
operator|.
name|seg_addr
argument_list|,
name|ccb
operator|->
name|scat_gath
index|[
literal|0
index|]
operator|.
name|seg_len
argument_list|,
name|sbic
operator|->
name|sbic_dma
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|datalen
operator|)
operator|&&
operator|(
name|ccb
operator|->
name|xs_flags
operator|&
name|SCSI_DATA_OUT
operator|)
condition|)
name|sbic_dmastart
argument_list|(
name|B_WRITE
argument_list|,
name|ccb
operator|->
name|scat_gath
index|[
literal|0
index|]
operator|.
name|seg_addr
argument_list|,
name|ccb
operator|->
name|scat_gath
index|[
literal|0
index|]
operator|.
name|seg_len
argument_list|,
name|sbic
operator|->
name|sbic_dma
argument_list|)
expr_stmt|;
name|SET_SCSI_CMD
argument_list|(
operator|&
name|ccb
operator|->
name|scsi_cmd
argument_list|,
name|ccb
operator|->
name|scsi_cmdlen
argument_list|)
expr_stmt|;
name|SET_XFER_LEN
argument_list|(
name|ccb
operator|->
name|scat_gath
index|[
literal|0
index|]
operator|.
name|seg_len
argument_list|)
expr_stmt|;
name|SET_SBIC_REG
argument_list|(
name|SBIC_selid
argument_list|,
name|ccb
operator|->
name|target
argument_list|)
expr_stmt|;
name|SET_SBIC_REG
argument_list|(
name|SBIC_tlun
argument_list|,
name|ccb
operator|->
name|lun
argument_list|)
expr_stmt|;
name|SBIC_DMA_ENABLE
argument_list|()
expr_stmt|;
name|SET_SBIC_REG
argument_list|(
name|SBIC_control
argument_list|,
name|SBIC_CTL_DMA
operator||
name|SBIC_CTL_EDI
argument_list|)
expr_stmt|;
name|SET_SBIC_REG
argument_list|(
name|SBIC_cmd
argument_list|,
name|SBIC_CMD_SEL_XFER
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|seg
operator|++
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|dataphase
parameter_list|(
name|struct
name|sbic_data
modifier|*
name|sbic
parameter_list|,
name|struct
name|sbic_ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|int
name|seg
init|=
name|ccb
operator|->
name|seg
decl_stmt|,
name|tmp
decl_stmt|;
if|if
condition|(
operator|(
name|ccb
operator|->
name|datalen
operator|)
operator|&&
operator|(
name|ccb
operator|->
name|xs_flags
operator|&
name|SCSI_DATA_IN
operator|)
condition|)
block|{
name|sbic_dmadone
argument_list|(
name|B_READ
argument_list|,
name|ccb
operator|->
name|scat_gath
index|[
name|seg
operator|-
literal|1
index|]
operator|.
name|seg_addr
argument_list|,
name|ccb
operator|->
name|scat_gath
index|[
name|seg
operator|-
literal|1
index|]
operator|.
name|seg_len
argument_list|,
name|sbic
operator|->
name|sbic_dma
argument_list|)
expr_stmt|;
name|sbic_dmastart
argument_list|(
name|B_READ
argument_list|,
name|ccb
operator|->
name|scat_gath
index|[
name|seg
index|]
operator|.
name|seg_addr
argument_list|,
name|ccb
operator|->
name|scat_gath
index|[
name|seg
index|]
operator|.
name|seg_len
argument_list|,
name|sbic
operator|->
name|sbic_dma
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|datalen
operator|)
operator|&&
operator|(
name|ccb
operator|->
name|xs_flags
operator|&
name|SCSI_DATA_OUT
operator|)
condition|)
block|{
name|sbic_dmadone
argument_list|(
name|B_WRITE
argument_list|,
name|ccb
operator|->
name|scat_gath
index|[
name|seg
operator|-
literal|1
index|]
operator|.
name|seg_addr
argument_list|,
name|ccb
operator|->
name|scat_gath
index|[
name|seg
operator|-
literal|1
index|]
operator|.
name|seg_len
argument_list|,
name|sbic
operator|->
name|sbic_dma
argument_list|)
expr_stmt|;
name|sbic_dmastart
argument_list|(
name|B_WRITE
argument_list|,
name|ccb
operator|->
name|scat_gath
index|[
name|seg
index|]
operator|.
name|seg_addr
argument_list|,
name|ccb
operator|->
name|scat_gath
index|[
name|seg
index|]
operator|.
name|seg_len
argument_list|,
name|sbic
operator|->
name|sbic_dma
argument_list|)
expr_stmt|;
block|}
name|SBIC_DMA_ENABLE
argument_list|()
expr_stmt|;
name|SET_SBIC_REG
argument_list|(
name|SBIC_control
argument_list|,
name|SBIC_CTL_DMA
operator||
name|SBIC_CTL_EDI
argument_list|)
expr_stmt|;
name|SET_XFER_LEN
argument_list|(
name|ccb
operator|->
name|scat_gath
index|[
name|seg
index|]
operator|.
name|seg_len
argument_list|)
expr_stmt|;
name|SET_SBIC_REG
argument_list|(
name|SBIC_cmd
argument_list|,
name|SBIC_CMD_XFER_INFO
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|seg
operator|++
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|sbic_request_sense
parameter_list|(
name|struct
name|sbic_data
modifier|*
name|sbic
parameter_list|,
name|struct
name|sbic_ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|int
name|phys
decl_stmt|,
name|len
decl_stmt|;
name|unsigned
name|chan
decl_stmt|;
name|u_char
name|cmd
index|[
literal|6
index|]
init|=
block|{
literal|3
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|cmd
index|[
literal|1
index|]
operator||=
operator|(
operator|(
name|ccb
operator|->
name|lun
operator|<<
literal|5
operator|)
operator|&
literal|0xe0
operator|)
expr_stmt|;
name|chan
operator|=
name|sbic
operator|->
name|sbic_dma
expr_stmt|;
name|len
operator|=
name|ccb
operator|->
name|sense_len
expr_stmt|;
ifndef|#
directive|ifndef
name|ALLWAYS_BOUNCE
if|if
condition|(
name|pc98_dmarangecheck
argument_list|(
operator|(
name|caddr_t
operator|)
name|ccb
operator|->
name|sense_addr
argument_list|,
name|len
argument_list|)
condition|)
block|{
name|ccb
operator|->
name|sense_addr
operator|=
call|(
name|int
call|)
argument_list|(
name|sbic_bounce
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|flags
operator||=
name|CCB_BOUNCE
expr_stmt|;
block|}
endif|#
directive|endif
name|phys
operator|=
name|KVTOPHYS
argument_list|(
name|ccb
operator|->
name|sense_addr
argument_list|)
expr_stmt|;
name|sbic_dmastart
argument_list|(
name|B_READ
argument_list|,
name|phys
argument_list|,
name|len
argument_list|,
name|chan
argument_list|)
expr_stmt|;
name|SET_SCSI_CMD
argument_list|(
name|cmd
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|SET_XFER_LEN
argument_list|(
name|ccb
operator|->
name|sense_len
argument_list|)
expr_stmt|;
name|SET_SBIC_REG
argument_list|(
name|SBIC_selid
argument_list|,
name|ccb
operator|->
name|target
argument_list|)
expr_stmt|;
name|SET_SBIC_REG
argument_list|(
name|SBIC_tlun
argument_list|,
name|ccb
operator|->
name|lun
argument_list|)
expr_stmt|;
name|SBIC_DMA_ENABLE
argument_list|()
expr_stmt|;
name|SET_SBIC_REG
argument_list|(
name|SBIC_control
argument_list|,
name|SBIC_CTL_DMA
operator||
name|SBIC_CTL_EDI
argument_list|)
expr_stmt|;
name|SET_SBIC_REG
argument_list|(
name|SBIC_cmd
argument_list|,
name|SBIC_CMD_SEL_XFER
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|sbic_dmastart
parameter_list|(
name|int
name|flags
parameter_list|,
name|int
name|phys
parameter_list|,
name|unsigned
name|nbytes
parameter_list|,
name|unsigned
name|chan
parameter_list|)
block|{
name|int
name|modeport
decl_stmt|,
name|waport
decl_stmt|,
name|mskport
decl_stmt|;
name|caddr_t
name|newaddr
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
name|chan
operator|>
literal|3
operator|||
name|nbytes
operator|>
operator|(
literal|1
operator|<<
literal|16
operator|)
condition|)
name|panic
argument_list|(
literal|"sbic_dmastart: impossible request"
argument_list|)
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
comment|/* mask on */
ifdef|#
directive|ifdef
name|CYRIX_5X86
asm|asm("wbinvd");
comment|/* wbinvd (WB cache flush) */
endif|#
directive|endif
comment|/* mask channel */
name|mskport
operator|=
name|IO_DMA
operator|+
literal|0x14
expr_stmt|;
comment|/* 0x15 */
name|outb
argument_list|(
name|mskport
argument_list|,
name|chan
operator|&
literal|3
operator||
literal|0x04
argument_list|)
expr_stmt|;
comment|/* set dma channel mode, and reset address ff */
name|modeport
operator|=
name|IO_DMA
operator|+
literal|0x16
expr_stmt|;
comment|/* 0x17 */
if|if
condition|(
name|flags
operator|&
name|B_READ
condition|)
block|{
name|outb
argument_list|(
name|modeport
argument_list|,
name|DMA37MD_SINGLE
operator||
name|DMA37MD_WRITE
operator||
operator|(
name|chan
operator|&
literal|3
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outb
argument_list|(
name|modeport
argument_list|,
name|DMA37MD_SINGLE
operator||
name|DMA37MD_READ
operator||
operator|(
name|chan
operator|&
literal|3
operator|)
argument_list|)
expr_stmt|;
block|}
name|outb
argument_list|(
name|modeport
operator|+
literal|1
operator|*
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 0x19 (clear byte pointer) */
comment|/* send start address */
name|waport
operator|=
name|IO_DMA
operator|+
operator|(
name|chan
operator|<<
literal|2
operator|)
expr_stmt|;
comment|/* 0x1, 0x5, 0x9, 0xd */
name|outb
argument_list|(
name|waport
argument_list|,
name|phys
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|waport
argument_list|,
name|phys
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|dmapageport
index|[
name|chan
index|]
argument_list|,
name|phys
operator|>>
literal|16
argument_list|)
expr_stmt|;
comment|/* send count */
name|outb
argument_list|(
name|waport
operator|+
literal|2
argument_list|,
operator|--
name|nbytes
argument_list|)
expr_stmt|;
comment|/* 0x3, 0x7, 0xb, 0xf */
name|outb
argument_list|(
name|waport
operator|+
literal|2
argument_list|,
name|nbytes
operator|>>
literal|8
argument_list|)
expr_stmt|;
comment|/* unmask channel */
name|mskport
operator|=
name|IO_DMA
operator|+
literal|0x14
expr_stmt|;
comment|/* 0x15 */
name|outb
argument_list|(
name|mskport
argument_list|,
name|chan
operator|&
literal|3
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* mask off */
block|}
end_function

begin_function
specifier|static
name|void
name|sbic_dmadone
parameter_list|(
name|int
name|flags
parameter_list|,
name|int
name|addr
parameter_list|,
name|unsigned
name|nbytes
parameter_list|,
name|unsigned
name|chan
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|CYRIX_486DLC
argument_list|)
operator|||
name|defined
argument_list|(
name|IBM_486SLC
argument_list|)
if|if
condition|(
name|flags
operator|&
name|B_READ
condition|)
block|{
comment|/* cache flush only after reading 92/12/9 by A.Kojima */
asm|asm("	.byte 0x0f,0x08");
comment|/* invd (cache flush) */
block|}
endif|#
directive|endif
block|}
end_function

end_unit

