begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1990 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Don Ahn.  *  * Copyright (c) 1993, 1994 by  *  jc@irbs.UUCP (John Capo)  *  vak@zebub.msk.su (Serge Vakulenko)  *  ache@astral.msk.su (Andrew A. Chernov)  *  * Copyright (c) 1993, 1994, 1995 by  *  joerg_wunsch@uriah.sax.de (Joerg Wunsch)  *  dufault@hda.com (Peter Dufault)  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	from:	@(#)fd.c	7.4 (Berkeley) 5/25/91  *	$Id: fd.c,v 1.3 1996/07/30 18:55:58 asami Exp $  *  */
end_comment

begin_include
include|#
directive|include
file|"ft.h"
end_include

begin_if
if|#
directive|if
name|NFT
operator|<
literal|1
end_if

begin_undef
undef|#
directive|undef
name|NFDC
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"fd.h"
end_include

begin_if
if|#
directive|if
name|NFDC
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<machine/ioctl_fd.h>
end_include

begin_include
include|#
directive|include
file|<sys/disklabel.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/devconf.h>
end_include

begin_include
include|#
directive|include
file|<sys/dkstat.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|PC98
end_ifdef

begin_include
include|#
directive|include
file|<pc98/pc98/pc98.h>
end_include

begin_include
include|#
directive|include
file|<pc98/pc98/pc98_device.h>
end_include

begin_include
include|#
directive|include
file|<pc98/pc98/fdreg.h>
end_include

begin_include
include|#
directive|include
file|<pc98/pc98/fdc.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<i386/isa/isa.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/fdreg.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/fdc.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/rtc.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<machine/stdarg.h>
end_include

begin_if
if|#
directive|if
name|NFT
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<sys/ftape.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|PC98
end_ifdef

begin_include
include|#
directive|include
file|<pc98/pc98/ftreg.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<i386/isa/ftreg.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DEVFS
end_ifdef

begin_include
include|#
directive|include
file|<sys/devfsext.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|fd_goaway
parameter_list|(
name|struct
name|kern_devconf
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fdc_goaway
parameter_list|(
name|struct
name|kern_devconf
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fd_externalize
parameter_list|(
name|struct
name|kern_devconf
modifier|*
parameter_list|,
name|struct
name|sysctl_req
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Templates for the kern_devconf structures used when we attach.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|kern_devconf
name|kdc_fd
index|[
name|NFD
index|]
init|=
block|{
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* filled in by kern_devconf.c */
literal|"fd"
block|,
literal|0
block|,
block|{
name|MDDT_DISK
block|,
literal|0
block|}
block|,
name|fd_externalize
block|,
literal|0
block|,
name|fd_goaway
block|,
name|DISK_EXTERNALLEN
block|,
literal|0
block|,
comment|/* parent */
literal|0
block|,
comment|/* parentdata */
name|DC_UNCONFIGURED
block|,
comment|/* state */
literal|"floppy disk"
block|,
name|DC_CLS_DISK
comment|/* class */
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|kern_devconf
name|kdc_fdc
index|[
name|NFDC
index|]
init|=
block|{
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* filled in by kern_devconf.c */
ifdef|#
directive|ifdef
name|PC98
literal|"fdc"
block|,
literal|0
block|,
block|{
name|MDDT_PC98
block|,
literal|0
block|,
literal|"bio"
block|}
block|,
name|pc98_generic_externalize
block|,
literal|0
block|,
name|fdc_goaway
block|,
name|PC98_EXTERNALLEN
block|,
else|#
directive|else
literal|"fdc"
block|,
literal|0
block|,
block|{
name|MDDT_ISA
block|,
literal|0
block|,
literal|"bio"
block|}
block|,
name|isa_generic_externalize
block|,
literal|0
block|,
name|fdc_goaway
block|,
name|ISA_EXTERNALLEN
block|,
endif|#
directive|endif
literal|0
block|,
comment|/* parent */
literal|0
block|,
comment|/* parentdata */
name|DC_UNCONFIGURED
block|,
comment|/* state */
literal|"floppy disk/tape controller"
block|,
name|DC_CLS_MISC
comment|/* class */
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|inline
name|void
name|fd_registerdev
parameter_list|(
name|int
name|ctlr
parameter_list|,
name|int
name|unit
parameter_list|)
block|{
if|if
condition|(
name|unit
operator|!=
literal|0
condition|)
name|kdc_fd
index|[
name|unit
index|]
operator|=
name|kdc_fd
index|[
literal|0
index|]
expr_stmt|;
name|kdc_fd
index|[
name|unit
index|]
operator|.
name|kdc_unit
operator|=
name|unit
expr_stmt|;
name|kdc_fd
index|[
name|unit
index|]
operator|.
name|kdc_parent
operator|=
operator|&
name|kdc_fdc
index|[
name|ctlr
index|]
expr_stmt|;
name|kdc_fd
index|[
name|unit
index|]
operator|.
name|kdc_parentdata
operator|=
literal|0
expr_stmt|;
name|dev_attach
argument_list|(
operator|&
name|kdc_fd
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|fdc_registerdev
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dvp
parameter_list|)
block|{
name|int
name|unit
init|=
name|dvp
operator|->
name|id_unit
decl_stmt|;
if|if
condition|(
name|unit
operator|!=
literal|0
condition|)
name|kdc_fdc
index|[
name|unit
index|]
operator|=
name|kdc_fdc
index|[
literal|0
index|]
expr_stmt|;
name|kdc_fdc
index|[
name|unit
index|]
operator|.
name|kdc_unit
operator|=
name|unit
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|kdc_fdc
index|[
name|unit
index|]
operator|.
name|kdc_parent
operator|=
operator|&
name|kdc_nec0
expr_stmt|;
else|#
directive|else
name|kdc_fdc
index|[
name|unit
index|]
operator|.
name|kdc_parent
operator|=
operator|&
name|kdc_isa0
expr_stmt|;
endif|#
directive|endif
name|kdc_fdc
index|[
name|unit
index|]
operator|.
name|kdc_parentdata
operator|=
name|dvp
expr_stmt|;
name|dev_attach
argument_list|(
operator|&
name|kdc_fdc
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|fdc_goaway
parameter_list|(
name|struct
name|kern_devconf
modifier|*
name|kdc
parameter_list|,
name|int
name|force
parameter_list|)
block|{
if|if
condition|(
name|force
condition|)
block|{
name|dev_detach
argument_list|(
name|kdc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
return|return
name|EBUSY
return|;
comment|/* XXX fix */
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|fd_goaway
parameter_list|(
name|struct
name|kern_devconf
modifier|*
name|kdc
parameter_list|,
name|int
name|force
parameter_list|)
block|{
name|dev_detach
argument_list|(
name|kdc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_define
define|#
directive|define
name|b_cylin
value|b_resid
end_define

begin_comment
comment|/* XXX now spelled b_cylinder elsewhere */
end_comment

begin_comment
comment|/* misuse a flag to identify format operation */
end_comment

begin_define
define|#
directive|define
name|B_FORMAT
value|B_XXX
end_define

begin_comment
comment|/*  * this biotab field doubles as a field for the physical unit number  * on the controller  */
end_comment

begin_define
define|#
directive|define
name|id_physid
value|id_scsiid
end_define

begin_comment
comment|/* error returns for fd_cmd() */
end_comment

begin_define
define|#
directive|define
name|FD_FAILED
value|-1
end_define

begin_define
define|#
directive|define
name|FD_NOT_VALID
value|-2
end_define

begin_define
define|#
directive|define
name|FDC_ERRMAX
value|100
end_define

begin_comment
comment|/* do not log more */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PC98
end_ifdef

begin_define
define|#
directive|define
name|NUMTYPES
value|5
end_define

begin_define
define|#
directive|define
name|NUMDENS
value|NUMTYPES
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NUMTYPES
value|14
end_define

begin_define
define|#
directive|define
name|NUMDENS
value|(NUMTYPES - 6)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* These defines (-1) must match index for fd_types */
end_comment

begin_define
define|#
directive|define
name|F_TAPE_TYPE
value|0x020
end_define

begin_comment
comment|/* bit for fd_types to indicate tape */
end_comment

begin_define
define|#
directive|define
name|NO_TYPE
value|0
end_define

begin_comment
comment|/* must match NO_TYPE in ft.c */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PC98
end_ifdef

begin_define
define|#
directive|define
name|FDT_NONE
value|0
end_define

begin_comment
comment|/* none present */
end_comment

begin_define
define|#
directive|define
name|FDT_12M
value|1
end_define

begin_comment
comment|/* 1M/640K FDD */
end_comment

begin_define
define|#
directive|define
name|FDT_144M
value|2
end_define

begin_comment
comment|/* 1.44M/1M/640K FDD */
end_comment

begin_define
define|#
directive|define
name|FD_1200
value|1
end_define

begin_define
define|#
directive|define
name|FD_1232
value|2
end_define

begin_define
define|#
directive|define
name|FD_720
value|3
end_define

begin_define
define|#
directive|define
name|FD_640
value|4
end_define

begin_define
define|#
directive|define
name|FD_1440
value|5
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|FD_1720
value|1
end_define

begin_define
define|#
directive|define
name|FD_1480
value|2
end_define

begin_define
define|#
directive|define
name|FD_1440
value|3
end_define

begin_define
define|#
directive|define
name|FD_1200
value|4
end_define

begin_define
define|#
directive|define
name|FD_820
value|5
end_define

begin_define
define|#
directive|define
name|FD_800
value|6
end_define

begin_define
define|#
directive|define
name|FD_720
value|7
end_define

begin_define
define|#
directive|define
name|FD_360
value|8
end_define

begin_define
define|#
directive|define
name|FD_1480in5_25
value|9
end_define

begin_define
define|#
directive|define
name|FD_1440in5_25
value|10
end_define

begin_define
define|#
directive|define
name|FD_820in5_25
value|11
end_define

begin_define
define|#
directive|define
name|FD_800in5_25
value|12
end_define

begin_define
define|#
directive|define
name|FD_720in5_25
value|13
end_define

begin_define
define|#
directive|define
name|FD_360in5_25
value|14
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|fd_type
name|fd_types
index|[
name|NUMTYPES
index|]
init|=
block|{
ifdef|#
directive|ifdef
name|PC98
block|{
literal|15
block|,
literal|2
block|,
literal|0xFF
block|,
literal|0x1B
block|,
literal|80
block|,
literal|2400
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0x54
block|,
literal|1
block|}
block|,
comment|/* 1.2 meg HD floppy    */
block|{
literal|8
block|,
literal|3
block|,
literal|0xFF
block|,
literal|0x35
block|,
literal|77
block|,
literal|1232
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0x74
block|,
literal|1
block|}
block|,
comment|/* 1.2 meg HD floppy 1024/sec  */
block|{
literal|9
block|,
literal|2
block|,
literal|0xFF
block|,
literal|0x20
block|,
literal|80
block|,
literal|1440
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|0x50
block|,
literal|1
block|}
block|,
comment|/* 720k floppy in 1.2meg drive */
block|{
literal|8
block|,
literal|2
block|,
literal|0xFF
block|,
literal|0x2A
block|,
literal|80
block|,
literal|1280
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|0x50
block|,
literal|1
block|}
block|,
comment|/* 640k floppy in 1.2meg drive */
block|{
literal|18
block|,
literal|2
block|,
literal|0xFF
block|,
literal|0x1B
block|,
literal|80
block|,
literal|2880
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|0x54
block|,
literal|1
block|}
block|,
comment|/* 1.44 meg HD 3.5in floppy */
else|#
directive|else
block|{
literal|21
block|,
literal|2
block|,
literal|0xFF
block|,
literal|0x04
block|,
literal|82
block|,
literal|3444
block|,
literal|1
block|,
name|FDC_500KBPS
block|,
literal|2
block|,
literal|0x0C
block|,
literal|2
block|}
block|,
comment|/* 1.72M in HD 3.5in */
block|{
literal|18
block|,
literal|2
block|,
literal|0xFF
block|,
literal|0x1B
block|,
literal|82
block|,
literal|2952
block|,
literal|1
block|,
name|FDC_500KBPS
block|,
literal|2
block|,
literal|0x6C
block|,
literal|1
block|}
block|,
comment|/* 1.48M in HD 3.5in */
block|{
literal|18
block|,
literal|2
block|,
literal|0xFF
block|,
literal|0x1B
block|,
literal|80
block|,
literal|2880
block|,
literal|1
block|,
name|FDC_500KBPS
block|,
literal|2
block|,
literal|0x6C
block|,
literal|1
block|}
block|,
comment|/* 1.44M in HD 3.5in */
block|{
literal|15
block|,
literal|2
block|,
literal|0xFF
block|,
literal|0x1B
block|,
literal|80
block|,
literal|2400
block|,
literal|1
block|,
name|FDC_500KBPS
block|,
literal|2
block|,
literal|0x54
block|,
literal|1
block|}
block|,
comment|/*  1.2M in HD 5.25/3.5 */
block|{
literal|10
block|,
literal|2
block|,
literal|0xFF
block|,
literal|0x10
block|,
literal|82
block|,
literal|1640
block|,
literal|1
block|,
name|FDC_250KBPS
block|,
literal|2
block|,
literal|0x2E
block|,
literal|1
block|}
block|,
comment|/*  820K in HD 3.5in */
block|{
literal|10
block|,
literal|2
block|,
literal|0xFF
block|,
literal|0x10
block|,
literal|80
block|,
literal|1600
block|,
literal|1
block|,
name|FDC_250KBPS
block|,
literal|2
block|,
literal|0x2E
block|,
literal|1
block|}
block|,
comment|/*  800K in HD 3.5in */
block|{
literal|9
block|,
literal|2
block|,
literal|0xFF
block|,
literal|0x20
block|,
literal|80
block|,
literal|1440
block|,
literal|1
block|,
name|FDC_250KBPS
block|,
literal|2
block|,
literal|0x50
block|,
literal|1
block|}
block|,
comment|/*  720K in HD 3.5in */
block|{
literal|9
block|,
literal|2
block|,
literal|0xFF
block|,
literal|0x2A
block|,
literal|40
block|,
literal|720
block|,
literal|1
block|,
name|FDC_250KBPS
block|,
literal|2
block|,
literal|0x50
block|,
literal|1
block|}
block|,
comment|/*  360K in DD 5.25in */
block|{
literal|18
block|,
literal|2
block|,
literal|0xFF
block|,
literal|0x02
block|,
literal|82
block|,
literal|2952
block|,
literal|1
block|,
name|FDC_500KBPS
block|,
literal|2
block|,
literal|0x02
block|,
literal|2
block|}
block|,
comment|/* 1.48M in HD 5.25in */
block|{
literal|18
block|,
literal|2
block|,
literal|0xFF
block|,
literal|0x02
block|,
literal|80
block|,
literal|2880
block|,
literal|1
block|,
name|FDC_500KBPS
block|,
literal|2
block|,
literal|0x02
block|,
literal|2
block|}
block|,
comment|/* 1.44M in HD 5.25in */
block|{
literal|10
block|,
literal|2
block|,
literal|0xFF
block|,
literal|0x10
block|,
literal|82
block|,
literal|1640
block|,
literal|1
block|,
name|FDC_300KBPS
block|,
literal|2
block|,
literal|0x2E
block|,
literal|1
block|}
block|,
comment|/*  820K in HD 5.25in */
block|{
literal|10
block|,
literal|2
block|,
literal|0xFF
block|,
literal|0x10
block|,
literal|80
block|,
literal|1600
block|,
literal|1
block|,
name|FDC_300KBPS
block|,
literal|2
block|,
literal|0x2E
block|,
literal|1
block|}
block|,
comment|/*  800K in HD 5.25in */
block|{
literal|9
block|,
literal|2
block|,
literal|0xFF
block|,
literal|0x20
block|,
literal|80
block|,
literal|1440
block|,
literal|1
block|,
name|FDC_300KBPS
block|,
literal|2
block|,
literal|0x50
block|,
literal|1
block|}
block|,
comment|/*  720K in HD 5.25in */
block|{
literal|9
block|,
literal|2
block|,
literal|0xFF
block|,
literal|0x23
block|,
literal|40
block|,
literal|720
block|,
literal|2
block|,
name|FDC_300KBPS
block|,
literal|2
block|,
literal|0x50
block|,
literal|1
block|}
block|,
comment|/*  360K in HD 5.25in */
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|PC98
end_ifdef

begin_define
define|#
directive|define
name|DRVS_PER_CTLR
value|4
end_define

begin_comment
comment|/* 4 floppies */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DRVS_PER_CTLR
value|2
end_define

begin_comment
comment|/* 2 floppies */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/***********************************************************************\ * Per controller structure.						* \***********************************************************************/
end_comment

begin_decl_stmt
name|struct
name|fdc_data
name|fdc_data
index|[
name|NFDC
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/***********************************************************************\ * Per drive structure.							* * N per controller  (DRVS_PER_CTLR)					* \***********************************************************************/
end_comment

begin_struct
specifier|static
struct|struct
name|fd_data
block|{
name|struct
name|fdc_data
modifier|*
name|fdc
decl_stmt|;
comment|/* pointer to controller structure */
name|int
name|fdsu
decl_stmt|;
comment|/* this units number on this controller */
name|int
name|type
decl_stmt|;
comment|/* Drive type (FD_1440...) */
name|struct
name|fd_type
modifier|*
name|ft
decl_stmt|;
comment|/* pointer to the type descriptor */
name|int
name|flags
decl_stmt|;
define|#
directive|define
name|FD_OPEN
value|0x01
comment|/* it's open		*/
define|#
directive|define
name|FD_ACTIVE
value|0x02
comment|/* it's active		*/
define|#
directive|define
name|FD_MOTOR
value|0x04
comment|/* motor should be on	*/
define|#
directive|define
name|FD_MOTOR_WAIT
value|0x08
comment|/* motor coming up	*/
name|int
name|skip
decl_stmt|;
name|int
name|hddrv
decl_stmt|;
define|#
directive|define
name|FD_NO_TRACK
value|-2
name|int
name|track
decl_stmt|;
comment|/* where we think the head is */
name|int
name|options
decl_stmt|;
comment|/* user configurable options, see ioctl_fd.h */
name|int
name|dkunit
decl_stmt|;
comment|/* disk stats unit number */
ifdef|#
directive|ifdef
name|DEVFS
name|void
modifier|*
name|bdevs
index|[
literal|1
operator|+
name|NUMDENS
operator|+
name|MAXPARTITIONS
index|]
decl_stmt|;
name|void
modifier|*
name|cdevs
index|[
literal|1
operator|+
name|NUMDENS
operator|+
name|MAXPARTITIONS
index|]
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PC98
name|int
name|pc98_trans
decl_stmt|;
endif|#
directive|endif
block|}
name|fd_data
index|[
name|NFD
index|]
struct|;
end_struct

begin_ifdef
ifdef|#
directive|ifdef
name|EPSON_NRDISK
end_ifdef

begin_typedef
typedef|typedef
name|unsigned
name|int
name|nrd_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|P_NRD_ADDRH
value|0xc24
end_define

begin_define
define|#
directive|define
name|P_NRD_ADDRM
value|0xc22
end_define

begin_define
define|#
directive|define
name|P_NRD_ADDRL
value|0xc20
end_define

begin_define
define|#
directive|define
name|P_NRD_CHECK
value|0xc20
end_define

begin_define
define|#
directive|define
name|P_NRD_DATA
value|0xc26
end_define

begin_define
define|#
directive|define
name|P_NRD_LED
value|0xc36
end_define

begin_define
define|#
directive|define
name|B_NRD_CHK
value|0x80
end_define

begin_define
define|#
directive|define
name|B_NRD_LED
value|0x40
end_define

begin_define
define|#
directive|define
name|A_NRD_INFO
value|0x2
end_define

begin_define
define|#
directive|define
name|A_NRD_BASE
value|0x400
end_define

begin_define
define|#
directive|define
name|NRD_STATUS
value|0x0
end_define

begin_define
define|#
directive|define
name|NRD_ST0_HD
value|0x04
end_define

begin_decl_stmt
specifier|static
name|fdu_t
name|nrdu
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nrdsec
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|nrd_t
name|nrdblkn
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|nrd_t
name|nrdaddr
init|=
literal|0x0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|nrd_check_ready
parameter_list|()
value|({		\ 	(epson_inb(P_NRD_CHECK)& B_NRD_CHK) ? 0 : 1;	\ 	})
end_define

begin_define
define|#
directive|define
name|nrd_LED_on
parameter_list|()
value|epson_outb(P_NRD_LED, B_NRD_LED)
end_define

begin_define
define|#
directive|define
name|nrd_LED_off
parameter_list|()
value|epson_outb(P_NRD_LED, ~B_NRD_LED)
end_define

begin_define
define|#
directive|define
name|nrd_trac
parameter_list|()
value|((int)(nrd_info(nrdaddr)& 0xff))
end_define

begin_define
define|#
directive|define
name|nrd_head
parameter_list|()
value|((int)((nrd_info(nrdaddr)>> 8)& 0xff))
end_define

begin_define
define|#
directive|define
name|nrd_sec
parameter_list|()
value|((int)(nrd_info(nrdaddr + 2)& 0xff))
end_define

begin_define
define|#
directive|define
name|nrd_secsize
parameter_list|()
value|((int)((nrd_info(A_NRD_INFO)>> 8)& 0xff))
end_define

begin_define
define|#
directive|define
name|nrd_addrset
parameter_list|(
name|p
parameter_list|)
value|nrd_addr((nrd_t)((nrd_t)p+A_NRD_BASE))
end_define

begin_function
specifier|static
specifier|inline
name|void
name|nrd_addr
parameter_list|(
name|addr
parameter_list|)
name|nrd_t
name|addr
decl_stmt|;
block|{
name|epson_outb
argument_list|(
name|P_NRD_ADDRH
argument_list|,
call|(
name|u_char
call|)
argument_list|(
operator|(
name|addr
operator|>>
literal|16
operator|)
operator|&
literal|0x1f
argument_list|)
argument_list|)
expr_stmt|;
name|epson_outb
argument_list|(
name|P_NRD_ADDRM
argument_list|,
call|(
name|u_char
call|)
argument_list|(
operator|(
name|addr
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
name|epson_outb
argument_list|(
name|P_NRD_ADDRL
argument_list|,
call|(
name|u_char
call|)
argument_list|(
name|addr
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|u_short
name|nrd_info
parameter_list|(
name|addr
parameter_list|)
name|nrd_t
name|addr
decl_stmt|;
block|{
name|u_short
name|tmp
decl_stmt|;
name|nrd_addr
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|outb
argument_list|(
literal|0x43f
argument_list|,
literal|0x42
argument_list|)
expr_stmt|;
name|tmp
operator|=
operator|(
name|short
operator|)
name|inw
argument_list|(
name|P_NRD_DATA
argument_list|)
expr_stmt|;
name|outb
argument_list|(
literal|0x43f
argument_list|,
literal|0x40
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|u_short
operator|)
name|tmp
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EPSON_NRDISK */
end_comment

begin_comment
comment|/***********************************************************************\ * Throughout this file the following conventions will be used:		* * fd is a pointer to the fd_data struct for the drive in question	* * fdc is a pointer to the fdc_data struct for the controller		* * fdu is the floppy drive unit number					* * fdcu is the floppy controller unit number				* * fdsu is the floppy drive unit number on that controller. (sub-unit)	* \***********************************************************************/
end_comment

begin_if
if|#
directive|if
name|NFT
operator|>
literal|0
end_if

begin_function_decl
name|int
name|ftopen
parameter_list|(
name|dev_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ftintr
parameter_list|(
name|ftu_t
name|ftu
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ftclose
parameter_list|(
name|dev_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ftstrategy
parameter_list|(
name|struct
name|buf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ftioctl
parameter_list|(
name|dev_t
parameter_list|,
name|int
parameter_list|,
name|caddr_t
parameter_list|,
name|int
parameter_list|,
name|struct
name|proc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ftdump
parameter_list|(
name|dev_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ftsize
parameter_list|(
name|dev_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ftattach
parameter_list|(
name|struct
name|isa_device
modifier|*
parameter_list|,
name|struct
name|isa_device
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* autoconfig functions */
end_comment

begin_function_decl
specifier|static
name|int
name|fdprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fdattach
parameter_list|(
name|struct
name|isa_device
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* needed for ft driver, thus exported */
end_comment

begin_function_decl
name|int
name|in_fdc
parameter_list|(
name|fdcu_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|out_fdc
parameter_list|(
name|fdcu_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* internal functions */
end_comment

begin_function_decl
specifier|static
name|void
name|set_motor
parameter_list|(
name|fdcu_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|TURNON
value|1
end_define

begin_define
define|#
directive|define
name|TURNOFF
value|0
end_define

begin_decl_stmt
specifier|static
name|timeout_t
name|fd_turnoff
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|timeout_t
name|fd_motor_on
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|fd_turnon
parameter_list|(
name|fdu_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fdc_reset
parameter_list|(
name|fdc_p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fd_in
parameter_list|(
name|fdcu_t
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fdstart
parameter_list|(
name|fdcu_t
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|timeout_t
name|fd_timeout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|timeout_t
name|fd_pseudointr
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|fdstate
parameter_list|(
name|fdcu_t
parameter_list|,
name|fdc_p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|retrier
parameter_list|(
name|fdcu_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fdformat
parameter_list|(
name|dev_t
parameter_list|,
name|struct
name|fd_formb
modifier|*
parameter_list|,
name|struct
name|proc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|DEVIDLE
value|0
end_define

begin_define
define|#
directive|define
name|FINDWORK
value|1
end_define

begin_define
define|#
directive|define
name|DOSEEK
value|2
end_define

begin_define
define|#
directive|define
name|SEEKCOMPLETE
value|3
end_define

begin_define
define|#
directive|define
name|IOCOMPLETE
value|4
end_define

begin_define
define|#
directive|define
name|RECALCOMPLETE
value|5
end_define

begin_define
define|#
directive|define
name|STARTRECAL
value|6
end_define

begin_define
define|#
directive|define
name|RESETCTLR
value|7
end_define

begin_define
define|#
directive|define
name|SEEKWAIT
value|8
end_define

begin_define
define|#
directive|define
name|RECALWAIT
value|9
end_define

begin_define
define|#
directive|define
name|MOTORWAIT
value|10
end_define

begin_define
define|#
directive|define
name|IOTIMEDOUT
value|11
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
specifier|const
name|fdstates
index|[]
init|=
block|{
literal|"DEVIDLE"
block|,
literal|"FINDWORK"
block|,
literal|"DOSEEK"
block|,
literal|"SEEKCOMPLETE"
block|,
literal|"IOCOMPLETE"
block|,
literal|"RECALCOMPLETE"
block|,
literal|"STARTRECAL"
block|,
literal|"RESETCTLR"
block|,
literal|"SEEKWAIT"
block|,
literal|"RECALWAIT"
block|,
literal|"MOTORWAIT"
block|,
literal|"IOTIMEDOUT"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* CAUTION: fd_debug causes huge amounts of logging output */
end_comment

begin_decl_stmt
specifier|static
name|int
specifier|volatile
name|fd_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|TRACE0
parameter_list|(
name|arg
parameter_list|)
value|if(fd_debug) printf(arg)
end_define

begin_define
define|#
directive|define
name|TRACE1
parameter_list|(
name|arg1
parameter_list|,
name|arg2
parameter_list|)
value|if(fd_debug) printf(arg1, arg2)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* DEBUG */
end_comment

begin_define
define|#
directive|define
name|TRACE0
parameter_list|(
name|arg
parameter_list|)
end_define

begin_define
define|#
directive|define
name|TRACE1
parameter_list|(
name|arg1
parameter_list|,
name|arg2
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_comment
comment|/* autoconfig structure */
end_comment

begin_decl_stmt
name|struct
name|isa_driver
name|fdcdriver
init|=
block|{
name|fdprobe
block|,
name|fdattach
block|,
literal|"fdc"
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_open_t
name|Fdopen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* NOTE, not fdopen */
end_comment

begin_decl_stmt
specifier|static
name|d_close_t
name|fdclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|fdioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_strategy_t
name|fdstrategy
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CDEV_MAJOR
value|9
end_define

begin_define
define|#
directive|define
name|BDEV_MAJOR
value|2
end_define

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|fd_cdevsw
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bdevsw
name|fd_bdevsw
init|=
block|{
name|Fdopen
block|,
name|fdclose
block|,
name|fdstrategy
block|,
name|fdioctl
block|,
comment|/*2*/
name|nodump
block|,
name|nopsize
block|,
literal|0
block|,
literal|"fd"
block|,
operator|&
name|fd_cdevsw
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|isa_device
modifier|*
name|fdcdevs
index|[
name|NFDC
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Provide hw.devconf information.  */
end_comment

begin_function
specifier|static
name|int
name|fd_externalize
parameter_list|(
name|struct
name|kern_devconf
modifier|*
name|kdc
parameter_list|,
name|struct
name|sysctl_req
modifier|*
name|req
parameter_list|)
block|{
return|return
name|disk_externalize
argument_list|(
name|fd_data
index|[
name|kdc
operator|->
name|kdc_unit
index|]
operator|.
name|fdsu
argument_list|,
name|req
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fdc_err
parameter_list|(
name|fdcu_t
name|fdcu
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|fdc_data
index|[
name|fdcu
index|]
operator|.
name|fdc_errs
operator|++
expr_stmt|;
if|if
condition|(
name|s
condition|)
block|{
if|if
condition|(
name|fdc_data
index|[
name|fdcu
index|]
operator|.
name|fdc_errs
operator|<
name|FDC_ERRMAX
condition|)
name|printf
argument_list|(
literal|"fdc%d: %s"
argument_list|,
name|fdcu
argument_list|,
name|s
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fdc_data
index|[
name|fdcu
index|]
operator|.
name|fdc_errs
operator|==
name|FDC_ERRMAX
condition|)
name|printf
argument_list|(
literal|"fdc%d: too many errors, not logging any more\n"
argument_list|,
name|fdcu
argument_list|)
expr_stmt|;
block|}
return|return
name|FD_FAILED
return|;
block|}
end_function

begin_comment
comment|/*  * fd_cmd: Send a command to the chip.  Takes a varargs with this structure:  * Unit number,  * # of output bytes, output bytes as ints ...,  * # of input bytes, input bytes as ints ...  */
end_comment

begin_function
specifier|static
name|int
name|fd_cmd
parameter_list|(
name|fdcu_t
name|fdcu
parameter_list|,
name|int
name|n_out
parameter_list|,
modifier|...
parameter_list|)
block|{
name|u_char
name|cmd
decl_stmt|;
name|int
name|n_in
decl_stmt|;
name|int
name|n
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|n_out
argument_list|)
expr_stmt|;
name|cmd
operator|=
call|(
name|u_char
call|)
argument_list|(
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|n_out
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|n_out
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|char
name|msg
index|[
literal|50
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"cmd %x failed at out byte %d of %d\n"
argument_list|,
name|cmd
argument_list|,
name|n
operator|+
literal|1
argument_list|,
name|n_out
argument_list|)
expr_stmt|;
return|return
name|fdc_err
argument_list|(
name|fdcu
argument_list|,
name|msg
argument_list|)
return|;
block|}
block|}
name|n_in
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|n_in
condition|;
name|n
operator|++
control|)
block|{
name|int
modifier|*
name|ptr
init|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|fd_in
argument_list|(
name|fdcu
argument_list|,
name|ptr
argument_list|)
operator|<
literal|0
condition|)
block|{
name|char
name|msg
index|[
literal|50
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"cmd %02x failed at in byte %d of %d\n"
argument_list|,
name|cmd
argument_list|,
name|n
operator|+
literal|1
argument_list|,
name|n_in
argument_list|)
expr_stmt|;
return|return
name|fdc_err
argument_list|(
name|fdcu
argument_list|,
name|msg
argument_list|)
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fd_sense_drive_status
parameter_list|(
name|fdc_p
name|fdc
parameter_list|,
name|int
modifier|*
name|st3p
parameter_list|)
block|{
name|int
name|st3
decl_stmt|;
if|if
condition|(
name|fd_cmd
argument_list|(
name|fdc
operator|->
name|fdcu
argument_list|,
literal|2
argument_list|,
name|NE7CMD_SENSED
argument_list|,
name|fdc
operator|->
name|fdu
argument_list|,
literal|1
argument_list|,
operator|&
name|st3
argument_list|)
condition|)
block|{
return|return
name|fdc_err
argument_list|(
name|fdc
operator|->
name|fdcu
argument_list|,
literal|"Sense Drive Status failed\n"
argument_list|)
return|;
block|}
if|if
condition|(
name|st3p
condition|)
operator|*
name|st3p
operator|=
name|st3
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fd_sense_int
parameter_list|(
name|fdc_p
name|fdc
parameter_list|,
name|int
modifier|*
name|st0p
parameter_list|,
name|int
modifier|*
name|cylp
parameter_list|)
block|{
name|int
name|st0
decl_stmt|,
name|cyl
decl_stmt|;
ifdef|#
directive|ifdef
name|EPSON_NRDISK
if|if
condition|(
name|fdc
operator|->
name|fdu
operator|==
name|nrdu
condition|)
block|{
if|if
condition|(
name|fdc
operator|->
name|fd
operator|->
name|track
operator|>=
literal|0
condition|)
name|nrdaddr
operator|=
operator|(
name|fdc
operator|->
name|fd
operator|->
name|track
operator|+
literal|1
operator|)
operator|*
literal|8
expr_stmt|;
else|else
name|nrdaddr
operator|=
literal|0x0
expr_stmt|;
operator|*
name|st0p
operator|=
name|nrd_head
argument_list|()
condition|?
name|NRD_ST0_HD
else|:
name|NRD_STATUS
expr_stmt|;
operator|*
name|cylp
operator|=
name|nrd_trac
argument_list|()
expr_stmt|;
block|}
else|else
block|{
endif|#
directive|endif
comment|/* EPSON_NRDISK */
name|int
name|ret
init|=
name|fd_cmd
argument_list|(
name|fdc
operator|->
name|fdcu
argument_list|,
literal|1
argument_list|,
name|NE7CMD_SENSEI
argument_list|,
literal|1
argument_list|,
operator|&
name|st0
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
operator|(
name|void
operator|)
name|fdc_err
argument_list|(
name|fdc
operator|->
name|fdcu
argument_list|,
literal|"sense intr err reading stat reg 0\n"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
if|if
condition|(
name|st0p
condition|)
operator|*
name|st0p
operator|=
name|st0
expr_stmt|;
if|if
condition|(
operator|(
name|st0
operator|&
name|NE7_ST0_IC
operator|)
operator|==
name|NE7_ST0_IC_IV
condition|)
block|{
comment|/* 		 * There doesn't seem to have been an interrupt. 		 */
return|return
name|FD_NOT_VALID
return|;
block|}
if|if
condition|(
name|fd_in
argument_list|(
name|fdc
operator|->
name|fdcu
argument_list|,
operator|&
name|cyl
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
name|fdc_err
argument_list|(
name|fdc
operator|->
name|fdcu
argument_list|,
literal|"can't get cyl num\n"
argument_list|)
return|;
block|}
if|if
condition|(
name|cylp
condition|)
operator|*
name|cylp
operator|=
name|cyl
expr_stmt|;
ifdef|#
directive|ifdef
name|EPSON_NRDISK
block|}
endif|#
directive|endif
comment|/* EPSON_NRDISK */
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fd_read_status
parameter_list|(
name|fdc_p
name|fdc
parameter_list|,
name|int
name|fdsu
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|ret
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * XXX types are poorly chosen.  Only bytes can by read 		 * from the hardware, but fdc_status wants u_longs and 		 * fd_in() gives ints. 		 */
name|int
name|status
decl_stmt|;
ifdef|#
directive|ifdef
name|EPSON_NRDISK
if|if
condition|(
name|fdc
operator|->
name|fdu
operator|==
name|nrdu
condition|)
block|{
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|0
case|:
name|fdc
operator|->
name|status
index|[
name|i
index|]
operator|=
name|nrd_head
argument_list|()
condition|?
name|NRD_ST0_HD
else|:
name|NRD_STATUS
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|fdc
operator|->
name|status
index|[
name|i
index|]
operator|=
name|NRD_STATUS
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|fdc
operator|->
name|status
index|[
name|i
index|]
operator|=
name|NRD_STATUS
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|fdc
operator|->
name|status
index|[
name|i
index|]
operator|=
name|nrd_trac
argument_list|()
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|fdc
operator|->
name|status
index|[
name|i
index|]
operator|=
name|nrd_head
argument_list|()
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|fdc
operator|->
name|status
index|[
name|i
index|]
operator|=
name|nrdsec
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|fdc
operator|->
name|status
index|[
name|i
index|]
operator|=
name|nrd_secsize
argument_list|()
expr_stmt|;
break|break;
block|}
name|ret
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
endif|#
directive|endif
comment|/* EPSON_NRDISK */
name|ret
operator|=
name|fd_in
argument_list|(
name|fdc
operator|->
name|fdcu
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
name|fdc
operator|->
name|status
index|[
name|i
index|]
operator|=
name|status
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
break|break;
ifdef|#
directive|ifdef
name|EPSON_NRDISK
block|}
endif|#
directive|endif
comment|/* EPSON_NRDISK */
block|}
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
name|fdc
operator|->
name|flags
operator||=
name|FDC_STAT_VALID
expr_stmt|;
else|else
name|fdc
operator|->
name|flags
operator|&=
operator|~
name|FDC_STAT_VALID
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/****************************************************************************/
end_comment

begin_comment
comment|/*                      autoconfiguration stuff                             */
end_comment

begin_comment
comment|/****************************************************************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PC98
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|pc98_trans
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 0 : HD , 1 : DD , 2 : 1.44 */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pc98_trans_prev
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|set_density
parameter_list|(
name|fdcu_t
parameter_list|,
name|fdu_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pc98_fd_check_ready
parameter_list|(
name|fdu_t
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|set_density
parameter_list|(
name|fdcu
parameter_list|,
name|fdu
parameter_list|)
name|fdcu_t
name|fdcu
decl_stmt|;
name|fdu_t
name|fdu
decl_stmt|;
block|{
comment|/* always motor on */
name|outb
argument_list|(
name|IO_FDPORT
argument_list|,
operator|(
name|pc98_trans
operator|!=
literal|1
condition|?
name|FDP_FDDEXC
else|:
literal|0
operator|)
operator||
name|FDP_PORTEXC
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|fdc_data
index|[
name|fdcu
index|]
operator|.
name|baseport
operator|+
name|FDOUT
argument_list|,
name|FDO_RST
operator||
name|FDO_DMAE
argument_list|)
expr_stmt|;
comment|/* in the case of note W, always inhibit 100ms timer */
block|}
end_function

begin_function
specifier|static
name|int
name|pc98_fd_check_ready
parameter_list|(
name|fdu
parameter_list|)
name|fdu_t
name|fdu
decl_stmt|;
block|{
name|fd_p
name|fd
init|=
name|fd_data
operator|+
name|fdu
decl_stmt|;
name|fdcu_t
name|fdcu
init|=
name|fd
operator|->
name|fdc
operator|->
name|fdcu
decl_stmt|;
name|int
name|retry
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|EPSON_NRDISK
if|if
condition|(
name|fdu
operator|==
name|nrdu
condition|)
block|{
if|if
condition|(
name|nrd_check_ready
argument_list|()
condition|)
return|return
literal|0
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
endif|#
directive|endif
while|while
condition|(
name|retry
operator|++
operator|<
literal|30000
condition|)
block|{
name|set_motor
argument_list|(
name|fdcu
argument_list|,
name|fd
operator|->
name|fdsu
argument_list|,
name|TURNON
argument_list|)
expr_stmt|;
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
name|NE7CMD_SENSED
argument_list|)
expr_stmt|;
comment|/* Sense Drive Status */
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
name|fdu
argument_list|)
expr_stmt|;
comment|/* Drive number */
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|in_fdc
argument_list|(
name|fdcu
argument_list|)
operator|&
name|NE7_ST3_RD
operator|)
condition|)
block|{
name|outb
argument_list|(
name|fdc_data
index|[
name|fdcu
index|]
operator|.
name|baseport
operator|+
name|FDOUT
argument_list|,
name|FDO_DMAE
operator||
name|FDO_MTON
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * probe for existance of controller  */
end_comment

begin_function
specifier|static
name|int
name|fdprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
block|{
name|fdcu_t
name|fdcu
init|=
name|dev
operator|->
name|id_unit
decl_stmt|;
if|if
condition|(
name|fdc_data
index|[
name|fdcu
index|]
operator|.
name|flags
operator|&
name|FDC_ATTACHED
condition|)
block|{
name|printf
argument_list|(
literal|"fdc%d: unit used multiple times\n"
argument_list|,
name|fdcu
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|fdcdevs
index|[
name|fdcu
index|]
operator|=
name|dev
expr_stmt|;
name|fdc_data
index|[
name|fdcu
index|]
operator|.
name|baseport
operator|=
name|dev
operator|->
name|id_iobase
expr_stmt|;
ifndef|#
directive|ifndef
name|DEV_LKM
name|fdc_registerdev
argument_list|(
name|dev
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|PC98
comment|/* First - lets reset the floppy controller */
name|outb
argument_list|(
name|dev
operator|->
name|id_iobase
operator|+
name|FDOUT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|dev
operator|->
name|id_iobase
operator|+
name|FDOUT
argument_list|,
name|FDO_FRST
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* see if it can handle a command */
ifdef|#
directive|ifdef
name|PC98
if|if
condition|(
name|fd_cmd
argument_list|(
name|fdcu
argument_list|,
literal|3
argument_list|,
name|NE7CMD_SPECIFY
argument_list|,
name|NE7_SPEC_1
argument_list|(
literal|4
argument_list|,
literal|240
argument_list|)
argument_list|,
name|NE7_SPEC_2
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
else|#
directive|else
if|if
condition|(
name|fd_cmd
argument_list|(
name|fdcu
argument_list|,
literal|3
argument_list|,
name|NE7CMD_SPECIFY
argument_list|,
name|NE7_SPEC_1
argument_list|(
literal|3
argument_list|,
literal|240
argument_list|)
argument_list|,
name|NE7_SPEC_2
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
endif|#
directive|endif
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|kdc_fdc
index|[
name|fdcu
index|]
operator|.
name|kdc_state
operator|=
name|DC_IDLE
expr_stmt|;
return|return
operator|(
name|IO_FDCSIZE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * wire controller into system, look for floppy units  */
end_comment

begin_function
specifier|static
name|int
name|fdattach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
block|{
name|unsigned
name|fdt
decl_stmt|;
name|fdu_t
name|fdu
decl_stmt|;
name|fdcu_t
name|fdcu
init|=
name|dev
operator|->
name|id_unit
decl_stmt|;
name|fdc_p
name|fdc
init|=
name|fdc_data
operator|+
name|fdcu
decl_stmt|;
name|fd_p
name|fd
decl_stmt|;
name|int
name|fdsu
decl_stmt|,
name|st0
decl_stmt|,
name|st3
decl_stmt|,
name|i
decl_stmt|;
if|#
directive|if
name|NFT
operator|>
literal|0
name|int
name|unithasfd
decl_stmt|;
endif|#
directive|endif
name|struct
name|isa_device
modifier|*
name|fdup
decl_stmt|;
name|int
name|ic_type
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|DEVFS
name|int
name|mynor
decl_stmt|;
name|int
name|typemynor
decl_stmt|;
name|int
name|typesize
decl_stmt|;
endif|#
directive|endif
name|fdc
operator|->
name|fdcu
operator|=
name|fdcu
expr_stmt|;
name|fdc
operator|->
name|flags
operator||=
name|FDC_ATTACHED
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|fdc
operator|->
name|dmachan
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|fdc
operator|->
name|dmachan
operator|!=
name|dev
operator|->
name|id_drq
condition|)
block|{
name|dev
operator|->
name|id_drq
operator|=
name|fdc
operator|->
name|dmachan
expr_stmt|;
name|printf
argument_list|(
literal|" [dma is changed to #%d]"
argument_list|,
name|fdc
operator|->
name|dmachan
argument_list|)
expr_stmt|;
block|}
comment|/* Acquire the DMA channel forever, The driver will do the rest */
name|pc98_dma_acquire
argument_list|(
name|fdc
operator|->
name|dmachan
argument_list|)
expr_stmt|;
name|pc98_dmainit
argument_list|(
name|fdc
operator|->
name|dmachan
argument_list|,
literal|128
operator|<<
literal|3
comment|/* XXX max secsize */
argument_list|)
expr_stmt|;
name|fdc
operator|->
name|state
operator|=
name|DEVIDLE
expr_stmt|;
name|fdc_reset
argument_list|(
name|fdc
argument_list|)
expr_stmt|;
else|#
directive|else
name|fdc
operator|->
name|dmachan
operator|=
name|dev
operator|->
name|id_drq
expr_stmt|;
comment|/* Acquire the DMA channel forever, The driver will do the rest */
name|isa_dma_acquire
argument_list|(
name|fdc
operator|->
name|dmachan
argument_list|)
expr_stmt|;
name|isa_dmainit
argument_list|(
name|fdc
operator|->
name|dmachan
argument_list|,
literal|128
operator|<<
literal|3
comment|/* XXX max secsize */
argument_list|)
expr_stmt|;
name|fdc
operator|->
name|state
operator|=
name|DEVIDLE
expr_stmt|;
comment|/* reset controller, turn motor off, clear fdout mirror reg */
name|outb
argument_list|(
name|fdc
operator|->
name|baseport
operator|+
name|FDOUT
argument_list|,
operator|(
operator|(
name|fdc
operator|->
name|fdout
operator|=
literal|0
operator|)
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|TAILQ_INIT
argument_list|(
operator|&
name|fdc
operator|->
name|head
argument_list|)
expr_stmt|;
comment|/* check for each floppy drive */
ifdef|#
directive|ifdef
name|PC98
for|for
control|(
name|fdup
operator|=
name|pc98_biotab_fdc
init|;
name|fdup
operator|->
name|id_driver
operator|!=
literal|0
condition|;
name|fdup
operator|++
control|)
block|{
else|#
directive|else
for|for
control|(
name|fdup
operator|=
name|isa_biotab_fdc
init|;
name|fdup
operator|->
name|id_driver
operator|!=
literal|0
condition|;
name|fdup
operator|++
control|)
block|{
endif|#
directive|endif
if|if
condition|(
name|fdup
operator|->
name|id_iobase
operator|!=
name|dev
operator|->
name|id_iobase
condition|)
continue|continue;
name|fdu
operator|=
name|fdup
operator|->
name|id_unit
expr_stmt|;
name|fd
operator|=
operator|&
name|fd_data
index|[
name|fdu
index|]
expr_stmt|;
if|if
condition|(
name|fdu
operator|>=
operator|(
name|NFD
operator|+
name|NFT
operator|)
condition|)
continue|continue;
name|fdsu
operator|=
name|fdup
operator|->
name|id_physid
expr_stmt|;
comment|/* look up what bios thinks we have */
switch|switch
condition|(
name|fdu
condition|)
block|{
ifdef|#
directive|ifdef
name|PC98
case|case
literal|0
case|:
case|case
literal|1
case|:
case|case
literal|2
case|:
case|case
literal|3
case|:
if|if
condition|(
operator|(
name|PC98_SYSTEM_PARAMETER
argument_list|(
literal|0x5ae
argument_list|)
operator|>>
name|fdu
operator|)
operator|&
literal|0x01
condition|)
name|fdt
operator|=
name|FDT_144M
expr_stmt|;
ifdef|#
directive|ifdef
name|EPSON_NRDISK
elseif|else
if|if
condition|(
operator|(
name|PC98_SYSTEM_PARAMETER
argument_list|(
literal|0x55c
argument_list|)
operator|>>
name|fdu
operator|)
operator|&
literal|0x01
condition|)
block|{
name|fdt
operator|=
name|FDT_12M
expr_stmt|;
switch|switch
condition|(
name|epson_machine_id
condition|)
block|{
case|case
literal|0x20
case|:
case|case
literal|0x27
case|:
if|if
condition|(
operator|(
name|PC98_SYSTEM_PARAMETER
argument_list|(
literal|0x488
argument_list|)
operator|>>
name|fdu
operator|)
operator|&
literal|0x01
condition|)
block|{
if|if
condition|(
name|nrd_check_ready
argument_list|()
condition|)
block|{
name|nrd_LED_on
argument_list|()
expr_stmt|;
name|nrdu
operator|=
name|fdu
expr_stmt|;
block|}
else|else
name|fdt
operator|=
name|FDT_NONE
expr_stmt|;
block|}
block|}
block|}
else|#
directive|else
comment|/* !EPSON_NRDISK */
elseif|else
if|if
condition|(
operator|(
name|PC98_SYSTEM_PARAMETER
argument_list|(
literal|0x55c
argument_list|)
operator|>>
name|fdu
operator|)
operator|&
literal|0x01
condition|)
block|{
name|fdt
operator|=
name|FDT_12M
expr_stmt|;
switch|switch
condition|(
name|epson_machine_id
condition|)
block|{
case|case
literal|0x20
case|:
case|case
literal|0x27
case|:
if|if
condition|(
operator|(
name|PC98_SYSTEM_PARAMETER
argument_list|(
literal|0x488
argument_list|)
operator|>>
name|fdu
operator|)
operator|&
literal|0x01
condition|)
name|fdt
operator|=
name|FDT_NONE
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* EPSON_NRDISK */
else|else
name|fdt
operator|=
name|FDT_NONE
expr_stmt|;
break|break;
default|default:
name|fdt
operator|=
name|FDT_NONE
expr_stmt|;
break|break;
else|#
directive|else
case|case
literal|0
case|:
name|fdt
operator|=
operator|(
name|rtcin
argument_list|(
name|RTC_FDISKETTE
argument_list|)
operator|&
literal|0xf0
operator|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|fdt
operator|=
operator|(
operator|(
name|rtcin
argument_list|(
name|RTC_FDISKETTE
argument_list|)
operator|<<
literal|4
operator|)
operator|&
literal|0xf0
operator|)
expr_stmt|;
break|break;
default|default:
name|fdt
operator|=
name|RTCFDT_NONE
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
comment|/* is there a unit? */
ifdef|#
directive|ifdef
name|PC98
if|if
condition|(
operator|(
name|fdt
operator|==
name|FDT_NONE
operator|)
else|#
directive|else
if|if
condition|(
operator|(
name|fdt
operator|==
name|RTCFDT_NONE
operator|)
endif|#
directive|endif
if|#
directive|if
name|NFT
operator|>
literal|0
operator|||
operator|(
name|fdsu
operator|>=
name|DRVS_PER_CTLR
operator|)
condition|)
block|{
else|#
directive|else
block|)
block|{
ifdef|#
directive|ifdef
name|PC98
name|fd
operator|->
name|fdc
operator|=
name|fdc
expr_stmt|;
endif|#
directive|endif
name|fd
operator|->
name|type
operator|=
name|NO_TYPE
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|NFT
operator|>
literal|0
comment|/* If BIOS says no floppy, or> 2nd device */
comment|/* Probe for and attach a floppy tape.     */
comment|/* Tell FT if there was already a disk     */
comment|/* with this unit number found.            */
name|unithasfd
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fdu
operator|<
name|NFD
operator|&&
name|fd
operator|->
name|type
operator|!=
name|NO_TYPE
condition|)
name|unithasfd
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ftattach
argument_list|(
name|dev
argument_list|,
name|fdup
argument_list|,
name|unithasfd
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|fdsu
operator|<
name|DRVS_PER_CTLR
condition|)
name|fd
operator|->
name|type
operator|=
name|NO_TYPE
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
ifdef|#
directive|ifdef
name|PC98
name|kdc_fdc
index|[
name|fdcu
index|]
operator|.
name|kdc_description
operator|=
literal|"NEC 765 floppy disk/tape controller"
expr_stmt|;
else|#
directive|else
comment|/* select it */
name|set_motor
argument_list|(
name|fdcu
argument_list|,
name|fdsu
argument_list|,
name|TURNON
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000000
argument_list|)
expr_stmt|;
comment|/* 1 sec */
if|if
condition|(
name|ic_type
operator|==
literal|0
operator|&&
name|fd_cmd
argument_list|(
name|fdcu
argument_list|,
literal|1
argument_list|,
name|NE7CMD_VERSION
argument_list|,
literal|1
argument_list|,
operator|&
name|ic_type
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"fdc%d: "
argument_list|,
name|fdcu
argument_list|)
expr_stmt|;
name|ic_type
operator|=
operator|(
name|u_char
operator|)
name|ic_type
expr_stmt|;
switch|switch
condition|(
name|ic_type
condition|)
block|{
case|case
literal|0x80
case|:
name|printf
argument_list|(
literal|"NEC 765\n"
argument_list|)
expr_stmt|;
name|fdc
operator|->
name|fdct
operator|=
name|FDC_NE765
expr_stmt|;
name|kdc_fdc
index|[
name|fdcu
index|]
operator|.
name|kdc_description
operator|=
literal|"NEC 765 floppy disk/tape controller"
expr_stmt|;
break|break;
case|case
literal|0x81
case|:
name|printf
argument_list|(
literal|"Intel 82077\n"
argument_list|)
expr_stmt|;
name|fdc
operator|->
name|fdct
operator|=
name|FDC_I82077
expr_stmt|;
name|kdc_fdc
index|[
name|fdcu
index|]
operator|.
name|kdc_description
operator|=
literal|"Intel 82077 floppy disk/tape controller"
expr_stmt|;
break|break;
case|case
literal|0x90
case|:
name|printf
argument_list|(
literal|"NEC 72065B\n"
argument_list|)
expr_stmt|;
name|fdc
operator|->
name|fdct
operator|=
name|FDC_NE72065
expr_stmt|;
name|kdc_fdc
index|[
name|fdcu
index|]
operator|.
name|kdc_description
operator|=
literal|"NEC 72065B floppy disk/tape controller"
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"unknown IC type %02x\n"
argument_list|,
name|ic_type
argument_list|)
expr_stmt|;
name|fdc
operator|->
name|fdct
operator|=
name|FDC_UNKNOWN
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|fd_cmd
argument_list|(
name|fdcu
argument_list|,
literal|2
argument_list|,
name|NE7CMD_SENSED
argument_list|,
name|fdsu
argument_list|,
literal|1
argument_list|,
operator|&
name|st3
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|st3
operator|&
name|NE7_ST3_T0
operator|)
condition|)
block|{
comment|/* if at track 0, first seek inwards */
comment|/* seek some steps: */
operator|(
name|void
operator|)
name|fd_cmd
argument_list|(
name|fdcu
argument_list|,
literal|3
argument_list|,
name|NE7CMD_SEEK
argument_list|,
name|fdsu
argument_list|,
literal|10
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|300000
argument_list|)
expr_stmt|;
comment|/* ...wait a moment... */
operator|(
name|void
operator|)
name|fd_sense_int
argument_list|(
name|fdc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* make ctrlr happy */
block|}
comment|/* If we're at track 0 first seek inwards. */
if|if
condition|(
operator|(
name|fd_sense_drive_status
argument_list|(
name|fdc
argument_list|,
operator|&
name|st3
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|st3
operator|&
name|NE7_ST3_T0
operator|)
condition|)
block|{
comment|/* Seek some steps... */
if|if
condition|(
name|fd_cmd
argument_list|(
name|fdcu
argument_list|,
literal|3
argument_list|,
name|NE7CMD_SEEK
argument_list|,
name|fdsu
argument_list|,
literal|10
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* ...wait a moment... */
name|DELAY
argument_list|(
literal|300000
argument_list|)
expr_stmt|;
comment|/* make ctrlr happy: */
operator|(
name|void
operator|)
name|fd_sense_int
argument_list|(
name|fdc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
comment|/* 			 * we must recalibrate twice, just in case the 			 * heads have been beyond cylinder 76, since most 			 * FDCs still barf when attempting to recalibrate 			 * more than 77 steps 			 */
comment|/* go back to 0: */
if|if
condition|(
name|fd_cmd
argument_list|(
name|fdcu
argument_list|,
literal|2
argument_list|,
name|NE7CMD_RECAL
argument_list|,
name|fdsu
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* a second being enough for full stroke seek*/
name|DELAY
argument_list|(
name|i
operator|==
literal|0
condition|?
literal|1000000
else|:
literal|300000
argument_list|)
expr_stmt|;
comment|/* anything responding? */
if|if
condition|(
name|fd_sense_int
argument_list|(
name|fdc
argument_list|,
operator|&
name|st0
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|st0
operator|&
name|NE7_ST0_EC
operator|)
operator|==
literal|0
condition|)
break|break;
comment|/* already probed succesfully */
block|}
block|}
name|set_motor
argument_list|(
name|fdcu
argument_list|,
name|fdsu
argument_list|,
name|TURNOFF
argument_list|)
expr_stmt|;
if|if
condition|(
name|st0
operator|&
name|NE7_ST0_EC
condition|)
comment|/* no track 0 -> no drive present */
continue|continue;
endif|#
directive|endif
name|fd
operator|->
name|track
operator|=
name|FD_NO_TRACK
expr_stmt|;
name|fd
operator|->
name|fdc
operator|=
name|fdc
expr_stmt|;
name|fd
operator|->
name|fdsu
operator|=
name|fdsu
expr_stmt|;
name|fd
operator|->
name|options
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"fd%d: "
argument_list|,
name|fdu
argument_list|)
expr_stmt|;
name|fd_registerdev
argument_list|(
name|fdcu
argument_list|,
name|fdu
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|fdt
condition|)
block|{
ifdef|#
directive|ifdef
name|PC98
case|case
name|FDT_12M
case|:
ifdef|#
directive|ifdef
name|EPSON_NRDISK
if|if
condition|(
name|fdu
operator|==
name|nrdu
condition|)
block|{
name|printf
argument_list|(
literal|"EPSON RAM DRIVE\n"
argument_list|)
expr_stmt|;
name|nrd_LED_off
argument_list|()
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"1M/640M FDD\n"
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !EPSON_NRDISK */
name|printf
argument_list|(
literal|"1M/640K FDD\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* EPSON_NRDISK */
name|fd
operator|->
name|type
operator|=
name|FD_1200
expr_stmt|;
name|fd
operator|->
name|pc98_trans
operator|=
literal|0
expr_stmt|;
name|kdc_fd
index|[
name|fdu
index|]
operator|.
name|kdc_description
operator|=
literal|"1M/640K floppy disk drive"
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVFS
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"rfd%d.1200"
argument_list|,
name|fdu
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEVFS */
break|break;
case|case
name|FDT_144M
case|:
name|printf
argument_list|(
literal|"1.44M FDD\n"
argument_list|)
expr_stmt|;
name|fd
operator|->
name|type
operator|=
name|FD_1200
expr_stmt|;
name|fd
operator|->
name|pc98_trans
operator|=
literal|0
expr_stmt|;
name|outb
argument_list|(
literal|0x4be
argument_list|,
operator|(
name|fdu
operator|<<
literal|5
operator|)
operator||
literal|0x10
argument_list|)
expr_stmt|;
name|kdc_fd
index|[
name|fdu
index|]
operator|.
name|kdc_description
operator|=
literal|"1.44MB (1440K) 3.5in floppy disk drive"
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVFS
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"rfd%d.1440"
argument_list|,
name|fdu
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEVFS */
break|break;
else|#
directive|else
case|case
name|RTCFDT_12M
case|:
name|printf
argument_list|(
literal|"1.2MB 5.25in\n"
argument_list|)
expr_stmt|;
name|fd
operator|->
name|type
operator|=
name|FD_1200
expr_stmt|;
name|kdc_fd
index|[
name|fdu
index|]
operator|.
name|kdc_description
operator|=
literal|"1.2MB (1200K) 5.25in floppy disk drive"
expr_stmt|;
break|break;
case|case
name|RTCFDT_144M
case|:
name|printf
argument_list|(
literal|"1.44MB 3.5in\n"
argument_list|)
expr_stmt|;
name|fd
operator|->
name|type
operator|=
name|FD_1440
expr_stmt|;
name|kdc_fd
index|[
name|fdu
index|]
operator|.
name|kdc_description
operator|=
literal|"1.44MB (1440K) 3.5in floppy disk drive"
expr_stmt|;
break|break;
case|case
name|RTCFDT_288M
case|:
case|case
name|RTCFDT_288M_1
case|:
name|printf
argument_list|(
literal|"2.88MB 3.5in - 1.44MB mode\n"
argument_list|)
expr_stmt|;
name|fd
operator|->
name|type
operator|=
name|FD_1440
expr_stmt|;
name|kdc_fd
index|[
name|fdu
index|]
operator|.
name|kdc_description
operator|=
literal|"2.88MB (2880K) 3.5in floppy disk drive in 1.44 mode"
expr_stmt|;
break|break;
case|case
name|RTCFDT_360K
case|:
name|printf
argument_list|(
literal|"360KB 5.25in\n"
argument_list|)
expr_stmt|;
name|fd
operator|->
name|type
operator|=
name|FD_360
expr_stmt|;
name|kdc_fd
index|[
name|fdu
index|]
operator|.
name|kdc_description
operator|=
literal|"360KB 5.25in floppy disk drive"
expr_stmt|;
break|break;
case|case
name|RTCFDT_720K
case|:
name|printf
argument_list|(
literal|"720KB 3.5in\n"
argument_list|)
expr_stmt|;
name|fd
operator|->
name|type
operator|=
name|FD_720
expr_stmt|;
name|kdc_fd
index|[
name|fdu
index|]
operator|.
name|kdc_description
operator|=
literal|"720KB 3.5in floppy disk drive"
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|printf
argument_list|(
literal|"unknown\n"
argument_list|)
expr_stmt|;
name|fd
operator|->
name|type
operator|=
name|NO_TYPE
expr_stmt|;
name|dev_detach
argument_list|(
operator|&
name|kdc_fd
index|[
name|fdu
index|]
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|kdc_fd
index|[
name|fdu
index|]
operator|.
name|kdc_state
operator|=
name|DC_IDLE
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVFS
name|mynor
operator|=
name|fdu
operator|<<
literal|6
expr_stmt|;
name|fd
operator|->
name|bdevs
index|[
literal|0
index|]
operator|=
name|devfs_add_devswf
argument_list|(
operator|&
name|fd_bdevsw
argument_list|,
name|mynor
argument_list|,
name|DV_BLK
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
literal|0640
argument_list|,
literal|"fd%d"
argument_list|,
name|fdu
argument_list|)
expr_stmt|;
name|fd
operator|->
name|cdevs
index|[
literal|0
index|]
operator|=
name|devfs_add_devswf
argument_list|(
operator|&
name|fd_cdevsw
argument_list|,
name|mynor
argument_list|,
name|DV_CHR
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
literal|0640
argument_list|,
literal|"rfd%d"
argument_list|,
name|fdu
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|1
operator|+
name|NUMDENS
condition|;
name|i
operator|++
control|)
block|{
comment|/* 			 * XXX this and the lookup in Fdopen() should be 			 * data driven. 			 */
switch|switch
condition|(
name|fd
operator|->
name|type
condition|)
block|{
case|case
name|FD_360
case|:
if|if
condition|(
name|i
operator|!=
name|FD_360
condition|)
continue|continue;
break|break;
case|case
name|FD_720
case|:
if|if
condition|(
name|i
operator|!=
name|FD_720
operator|&&
name|i
operator|!=
name|FD_800
operator|&&
name|i
operator|!=
name|FD_820
condition|)
continue|continue;
break|break;
case|case
name|FD_1200
case|:
if|if
condition|(
name|i
operator|!=
name|FD_360
operator|&&
name|i
operator|!=
name|FD_720
operator|&&
name|i
operator|!=
name|FD_800
operator|&&
name|i
operator|!=
name|FD_820
operator|&&
name|i
operator|!=
name|FD_1200
operator|&&
name|i
operator|!=
name|FD_1440
operator|&&
name|i
operator|!=
name|FD_1480
condition|)
continue|continue;
break|break;
case|case
name|FD_1440
case|:
if|if
condition|(
name|i
operator|!=
name|FD_720
operator|&&
name|i
operator|!=
name|FD_800
operator|&&
name|i
operator|!=
name|FD_820
operator|&&
name|i
operator|!=
name|FD_1200
operator|&&
name|i
operator|!=
name|FD_1440
operator|&&
name|i
operator|!=
name|FD_1480
operator|&&
name|i
operator|!=
name|FD_1720
condition|)
continue|continue;
break|break;
block|}
name|typemynor
operator|=
name|mynor
operator||
name|i
expr_stmt|;
name|typesize
operator|=
name|fd_types
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|size
operator|/
literal|2
expr_stmt|;
comment|/* 			 * XXX all these conversions give bloated code and 			 * confusing names. 			 */
if|if
condition|(
name|typesize
operator|==
literal|1476
condition|)
name|typesize
operator|=
literal|1480
expr_stmt|;
if|if
condition|(
name|typesize
operator|==
literal|1722
condition|)
name|typesize
operator|=
literal|1720
expr_stmt|;
name|fd
operator|->
name|bdevs
index|[
name|i
index|]
operator|=
name|devfs_add_devswf
argument_list|(
operator|&
name|fd_bdevsw
argument_list|,
name|typemynor
argument_list|,
name|DV_BLK
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
literal|0640
argument_list|,
literal|"fd%d.%d"
argument_list|,
name|fdu
argument_list|,
name|typesize
argument_list|)
expr_stmt|;
name|fd
operator|->
name|cdevs
index|[
name|i
index|]
operator|=
name|devfs_add_devswf
argument_list|(
operator|&
name|fd_cdevsw
argument_list|,
name|typemynor
argument_list|,
name|DV_CHR
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
literal|0640
argument_list|,
literal|"rfd%d.%d"
argument_list|,
name|fdu
argument_list|,
name|typesize
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXPARTITIONS
condition|;
name|i
operator|++
control|)
block|{
name|fd
operator|->
name|bdevs
index|[
literal|1
operator|+
name|NUMDENS
operator|+
name|i
index|]
operator|=
name|devfs_link
argument_list|(
name|fd
operator|->
name|bdevs
index|[
literal|0
index|]
argument_list|,
literal|"fd%d%c"
argument_list|,
name|fdu
argument_list|,
literal|'a'
operator|+
name|i
argument_list|)
expr_stmt|;
name|fd
operator|->
name|cdevs
index|[
literal|1
operator|+
name|NUMDENS
operator|+
name|i
index|]
operator|=
name|devfs_link
argument_list|(
name|fd
operator|->
name|cdevs
index|[
literal|0
index|]
argument_list|,
literal|"rfd%d%c"
argument_list|,
name|fdu
argument_list|,
literal|'a'
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DEVFS */
if|if
condition|(
name|dk_ndrive
operator|<
name|DK_NDRIVE
condition|)
block|{
name|sprintf
argument_list|(
name|dk_names
index|[
name|dk_ndrive
index|]
argument_list|,
literal|"fd%d"
argument_list|,
name|fdu
argument_list|)
expr_stmt|;
name|fd
operator|->
name|dkunit
operator|=
name|dk_ndrive
operator|++
expr_stmt|;
comment|/* 			 * XXX assume rate is FDC_500KBPS. 			 */
name|dk_wpms
index|[
name|dk_ndrive
index|]
operator|=
literal|500000
operator|/
literal|8
operator|/
literal|2
expr_stmt|;
block|}
else|else
block|{
name|fd
operator|->
name|dkunit
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/****************************************************************************/
comment|/*                            motor control stuff                           */
comment|/*		remember to not deselect the drive we're working on         */
comment|/****************************************************************************/
specifier|static
name|void
name|set_motor
parameter_list|(
name|fdcu_t
name|fdcu
parameter_list|,
name|int
name|fdsu
parameter_list|,
name|int
name|turnon
parameter_list|)
block|{
name|int
name|fdout
init|=
name|fdc_data
index|[
name|fdcu
index|]
operator|.
name|fdout
decl_stmt|;
name|int
name|needspecify
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|outb
argument_list|(
name|IO_FDPORT
argument_list|,
operator|(
name|pc98_trans
operator|!=
literal|1
condition|?
name|FDP_FDDEXC
else|:
literal|0
operator|)
operator||
name|FDP_PORTEXC
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|fdout
operator|=
name|FDO_DMAE
operator||
name|FDO_MTON
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|turnon
condition|)
block|{
name|fdout
operator|&=
operator|~
name|FDO_FDSEL
expr_stmt|;
name|fdout
operator||=
operator|(
name|FDO_MOEN0
operator|<<
name|fdsu
operator|)
operator|+
name|fdsu
expr_stmt|;
block|}
else|else
name|fdout
operator|&=
operator|~
operator|(
name|FDO_MOEN0
operator|<<
name|fdsu
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|turnon
operator|&&
operator|(
name|fdout
operator|&
operator|(
name|FDO_MOEN0
operator|+
name|FDO_MOEN1
operator|+
name|FDO_MOEN2
operator|+
name|FDO_MOEN3
operator|)
operator|)
operator|==
literal|0
condition|)
comment|/* gonna turn off the last drive, put FDC to bed */
name|fdout
operator|&=
operator|~
operator|(
name|FDO_FRST
operator||
name|FDO_FDMAEN
operator|)
expr_stmt|;
else|else
block|{
comment|/* make sure controller is selected and specified */
if|if
condition|(
operator|(
name|fdout
operator|&
operator|(
name|FDO_FRST
operator||
name|FDO_FDMAEN
operator|)
operator|)
operator|==
literal|0
condition|)
name|needspecify
operator|=
literal|1
expr_stmt|;
name|fdout
operator||=
operator|(
name|FDO_FRST
operator||
name|FDO_FDMAEN
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
name|outb
argument_list|(
name|fdc_data
index|[
name|fdcu
index|]
operator|.
name|baseport
operator|+
name|FDOUT
argument_list|,
name|fdout
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|fdc_data
index|[
name|fdcu
index|]
operator|.
name|fdout
operator|=
name|fdout
expr_stmt|;
ifndef|#
directive|ifndef
name|PC98
name|kdc_fdc
index|[
name|fdcu
index|]
operator|.
name|kdc_state
operator|=
operator|(
name|fdout
operator|&
name|FDO_FRST
operator|)
condition|?
name|DC_BUSY
else|:
name|DC_IDLE
expr_stmt|;
endif|#
directive|endif
name|TRACE1
argument_list|(
literal|"[0x%x->FDOUT]"
argument_list|,
name|fdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|needspecify
condition|)
block|{
comment|/* 		 * XXX 		 * special case: since we have just woken up the FDC 		 * from its sleep, we silently assume the command will 		 * be accepted, and do not test for a timeout 		 */
ifdef|#
directive|ifdef
name|PC98
operator|(
name|void
operator|)
name|fd_cmd
argument_list|(
name|fdcu
argument_list|,
literal|3
argument_list|,
name|NE7CMD_SPECIFY
argument_list|,
name|NE7_SPEC_1
argument_list|(
literal|4
argument_list|,
literal|240
argument_list|)
argument_list|,
name|NE7_SPEC_2
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|fd_cmd
argument_list|(
name|fdcu
argument_list|,
literal|3
argument_list|,
name|NE7CMD_SPECIFY
argument_list|,
name|NE7_SPEC_1
argument_list|(
literal|3
argument_list|,
literal|240
argument_list|)
argument_list|,
name|NE7_SPEC_2
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
specifier|static
name|void
name|fd_turnoff
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|)
block|{
name|fdu_t
name|fdu
init|=
operator|(
name|fdu_t
operator|)
name|arg1
decl_stmt|;
name|int
name|s
decl_stmt|;
name|fd_p
name|fd
init|=
name|fd_data
operator|+
name|fdu
decl_stmt|;
name|TRACE1
argument_list|(
literal|"[fd%d: turnoff]"
argument_list|,
name|fdu
argument_list|)
expr_stmt|;
comment|/* 	 * Don't turn off the motor yet if the drive is active. 	 * XXX shouldn't even schedule turnoff until drive is inactive 	 * and nothing is queued on it. 	 */
if|if
condition|(
name|fd
operator|->
name|fdc
operator|->
name|state
operator|!=
name|DEVIDLE
operator|&&
name|fd
operator|->
name|fdc
operator|->
name|fdu
operator|==
name|fdu
condition|)
block|{
name|timeout
argument_list|(
name|fd_turnoff
argument_list|,
name|arg1
argument_list|,
literal|4
operator|*
name|hz
argument_list|)
expr_stmt|;
return|return;
block|}
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|fd
operator|->
name|flags
operator|&=
operator|~
name|FD_MOTOR
expr_stmt|;
name|set_motor
argument_list|(
name|fd
operator|->
name|fdc
operator|->
name|fdcu
argument_list|,
name|fd
operator|->
name|fdsu
argument_list|,
name|TURNOFF
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|fd_motor_on
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|)
block|{
name|fdu_t
name|fdu
init|=
operator|(
name|fdu_t
operator|)
name|arg1
decl_stmt|;
name|int
name|s
decl_stmt|;
name|fd_p
name|fd
init|=
name|fd_data
operator|+
name|fdu
decl_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|fd
operator|->
name|flags
operator|&=
operator|~
name|FD_MOTOR_WAIT
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|->
name|fdc
operator|->
name|fd
operator|==
name|fd
operator|)
operator|&&
operator|(
name|fd
operator|->
name|fdc
operator|->
name|state
operator|==
name|MOTORWAIT
operator|)
condition|)
block|{
name|fdintr
argument_list|(
name|fd
operator|->
name|fdc
operator|->
name|fdcu
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|fd_turnon
parameter_list|(
name|fdu_t
name|fdu
parameter_list|)
block|{
name|fd_p
name|fd
init|=
name|fd_data
operator|+
name|fdu
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|fd
operator|->
name|flags
operator|&
name|FD_MOTOR
operator|)
condition|)
block|{
name|fd
operator|->
name|flags
operator||=
operator|(
name|FD_MOTOR
operator|+
name|FD_MOTOR_WAIT
operator|)
expr_stmt|;
name|set_motor
argument_list|(
name|fd
operator|->
name|fdc
operator|->
name|fdcu
argument_list|,
name|fd
operator|->
name|fdsu
argument_list|,
name|TURNON
argument_list|)
expr_stmt|;
name|timeout
argument_list|(
name|fd_motor_on
argument_list|,
operator|(
name|caddr_t
operator|)
name|fdu
argument_list|,
name|hz
argument_list|)
expr_stmt|;
comment|/* in 1 sec its ok */
block|}
block|}
specifier|static
name|void
name|fdc_reset
parameter_list|(
name|fdc_p
name|fdc
parameter_list|)
block|{
name|fdcu_t
name|fdcu
init|=
name|fdc
operator|->
name|fdcu
decl_stmt|;
comment|/* Try a reset, keep motor on */
ifdef|#
directive|ifdef
name|PC98
name|set_density
argument_list|(
name|fdcu
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pc98_machine_type
operator|&
name|M_EPSON_PC98
condition|)
name|outb
argument_list|(
name|fdc
operator|->
name|baseport
operator|+
name|FDOUT
argument_list|,
literal|0xe8
argument_list|)
expr_stmt|;
else|else
name|outb
argument_list|(
name|fdc
operator|->
name|baseport
operator|+
name|FDOUT
argument_list|,
literal|0xd8
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|fdc
operator|->
name|baseport
operator|+
name|FDOUT
argument_list|,
literal|0x18
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
else|#
directive|else
name|outb
argument_list|(
name|fdc
operator|->
name|baseport
operator|+
name|FDOUT
argument_list|,
name|fdc
operator|->
name|fdout
operator|&
operator|~
operator|(
name|FDO_FRST
operator||
name|FDO_FDMAEN
operator|)
argument_list|)
expr_stmt|;
name|TRACE1
argument_list|(
literal|"[0x%x->FDOUT]"
argument_list|,
name|fdc
operator|->
name|fdout
operator|&
operator|~
operator|(
name|FDO_FRST
operator||
name|FDO_FDMAEN
operator|)
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* enable FDC, but defer interrupts a moment */
name|outb
argument_list|(
name|fdc
operator|->
name|baseport
operator|+
name|FDOUT
argument_list|,
name|fdc
operator|->
name|fdout
operator|&
operator|~
name|FDO_FDMAEN
argument_list|)
expr_stmt|;
name|TRACE1
argument_list|(
literal|"[0x%x->FDOUT]"
argument_list|,
name|fdc
operator|->
name|fdout
operator|&
operator|~
name|FDO_FDMAEN
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|fdc
operator|->
name|baseport
operator|+
name|FDOUT
argument_list|,
name|fdc
operator|->
name|fdout
argument_list|)
expr_stmt|;
name|TRACE1
argument_list|(
literal|"[0x%x->FDOUT]"
argument_list|,
name|fdc
operator|->
name|fdout
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* XXX after a reset, silently believe the FDC will accept commands */
ifdef|#
directive|ifdef
name|PC98
operator|(
name|void
operator|)
name|fd_cmd
argument_list|(
name|fdcu
argument_list|,
literal|3
argument_list|,
name|NE7CMD_SPECIFY
argument_list|,
name|NE7_SPEC_1
argument_list|(
literal|4
argument_list|,
literal|240
argument_list|)
argument_list|,
name|NE7_SPEC_2
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|fd_cmd
argument_list|(
name|fdcu
argument_list|,
literal|3
argument_list|,
name|NE7CMD_SPECIFY
argument_list|,
name|NE7_SPEC_1
argument_list|(
literal|3
argument_list|,
literal|240
argument_list|)
argument_list|,
name|NE7_SPEC_2
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/****************************************************************************/
comment|/*                             fdc in/out                                   */
comment|/****************************************************************************/
name|int
name|in_fdc
parameter_list|(
name|fdcu_t
name|fdcu
parameter_list|)
block|{
name|int
name|baseport
init|=
name|fdc_data
index|[
name|fdcu
index|]
operator|.
name|baseport
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
init|=
literal|1000000
decl_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|inb
argument_list|(
name|baseport
operator|+
name|FDSTS
argument_list|)
operator|&
operator|(
name|NE7_DIO
operator||
name|NE7_RQM
operator|)
operator|)
operator|!=
operator|(
name|NE7_DIO
operator||
name|NE7_RQM
operator|)
operator|&&
name|j
operator|--
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|==
name|NE7_RQM
condition|)
return|return
name|fdc_err
argument_list|(
name|fdcu
argument_list|,
literal|"ready for output in input\n"
argument_list|)
return|;
block|}
if|if
condition|(
name|j
operator|<=
literal|0
condition|)
return|return
name|fdc_err
argument_list|(
name|fdcu
argument_list|,
name|bootverbose
condition|?
literal|"input ready timeout\n"
else|:
literal|0
argument_list|)
return|;
ifdef|#
directive|ifdef
name|DEBUG
name|i
operator|=
name|inb
argument_list|(
name|baseport
operator|+
name|FDDATA
argument_list|)
expr_stmt|;
name|TRACE1
argument_list|(
literal|"[FDDATA->0x%x]"
argument_list|,
operator|(
name|unsigned
name|char
operator|)
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
else|#
directive|else
return|return
name|inb
argument_list|(
name|baseport
operator|+
name|FDDATA
argument_list|)
return|;
endif|#
directive|endif
block|}
comment|/*  * fd_in: Like in_fdc, but allows you to see if it worked.  */
specifier|static
name|int
name|fd_in
parameter_list|(
name|fdcu_t
name|fdcu
parameter_list|,
name|int
modifier|*
name|ptr
parameter_list|)
block|{
name|int
name|baseport
init|=
name|fdc_data
index|[
name|fdcu
index|]
operator|.
name|baseport
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
init|=
literal|1000000
decl_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|inb
argument_list|(
name|baseport
operator|+
name|FDSTS
argument_list|)
operator|&
operator|(
name|NE7_DIO
operator||
name|NE7_RQM
operator|)
operator|)
operator|!=
operator|(
name|NE7_DIO
operator||
name|NE7_RQM
operator|)
operator|&&
name|j
operator|--
operator|>
literal|0
condition|)
block|{
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|NE7_RQM
condition|)
return|return
name|fdc_err
argument_list|(
name|fdcu
argument_list|,
literal|"ready for output in input\n"
argument_list|)
return|;
block|}
if|if
condition|(
name|j
operator|<=
literal|0
condition|)
return|return
name|fdc_err
argument_list|(
name|fdcu
argument_list|,
name|bootverbose
condition|?
literal|"input ready timeout\n"
else|:
literal|0
argument_list|)
return|;
ifdef|#
directive|ifdef
name|DEBUG
name|i
operator|=
name|inb
argument_list|(
name|baseport
operator|+
name|FDDATA
argument_list|)
expr_stmt|;
name|TRACE1
argument_list|(
literal|"[FDDATA->0x%x]"
argument_list|,
operator|(
name|unsigned
name|char
operator|)
name|i
argument_list|)
expr_stmt|;
operator|*
name|ptr
operator|=
name|i
expr_stmt|;
return|return
literal|0
return|;
else|#
directive|else
name|i
operator|=
name|inb
argument_list|(
name|baseport
operator|+
name|FDDATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
condition|)
operator|*
name|ptr
operator|=
name|i
expr_stmt|;
return|return
literal|0
return|;
endif|#
directive|endif
block|}
name|int
name|out_fdc
parameter_list|(
name|fdcu_t
name|fdcu
parameter_list|,
name|int
name|x
parameter_list|)
block|{
name|int
name|baseport
init|=
name|fdc_data
index|[
name|fdcu
index|]
operator|.
name|baseport
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Check that the direction bit is set */
name|i
operator|=
literal|1000000
expr_stmt|;
while|while
condition|(
operator|(
name|inb
argument_list|(
name|baseport
operator|+
name|FDSTS
argument_list|)
operator|&
name|NE7_DIO
operator|)
operator|&&
name|i
operator|--
operator|>
literal|0
condition|)
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
return|return
name|fdc_err
argument_list|(
name|fdcu
argument_list|,
literal|"direction bit not set\n"
argument_list|)
return|;
comment|/* Check that the floppy controller is ready for a command */
name|i
operator|=
literal|1000000
expr_stmt|;
while|while
condition|(
operator|(
name|inb
argument_list|(
name|baseport
operator|+
name|FDSTS
argument_list|)
operator|&
name|NE7_RQM
operator|)
operator|==
literal|0
operator|&&
name|i
operator|--
operator|>
literal|0
condition|)
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
return|return
name|fdc_err
argument_list|(
name|fdcu
argument_list|,
name|bootverbose
condition|?
literal|"output ready timeout\n"
else|:
literal|0
argument_list|)
return|;
comment|/* Send the command and return */
name|outb
argument_list|(
name|baseport
operator|+
name|FDDATA
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|TRACE1
argument_list|(
literal|"[0x%x->FDDATA]"
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/****************************************************************************/
comment|/*                           fdopen/fdclose                                 */
comment|/****************************************************************************/
name|int
name|Fdopen
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|fdu_t
name|fdu
init|=
name|FDUNIT
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|type
init|=
name|FDTYPE
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
decl_stmt|;
name|fdc_p
name|fdc
decl_stmt|;
if|#
directive|if
name|NFT
operator|>
literal|0
comment|/* check for a tape open */
if|if
condition|(
name|type
operator|&
name|F_TAPE_TYPE
condition|)
return|return
operator|(
name|ftopen
argument_list|(
name|dev
argument_list|,
name|flags
argument_list|)
operator|)
return|;
endif|#
directive|endif
comment|/* check bounds */
if|if
condition|(
name|fdu
operator|>=
name|NFD
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|fdc
operator|=
name|fd_data
index|[
name|fdu
index|]
operator|.
name|fdc
expr_stmt|;
if|if
condition|(
operator|(
name|fdc
operator|==
name|NULL
operator|)
operator|||
operator|(
name|fd_data
index|[
name|fdu
index|]
operator|.
name|type
operator|==
name|NO_TYPE
operator|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|type
operator|>
name|NUMDENS
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
ifdef|#
directive|ifdef
name|PC98
if|if
condition|(
name|pc98_fd_check_ready
argument_list|(
name|fdu
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
endif|#
directive|endif
if|if
condition|(
name|type
operator|==
literal|0
condition|)
name|type
operator|=
name|fd_data
index|[
name|fdu
index|]
operator|.
name|type
expr_stmt|;
ifndef|#
directive|ifndef
name|PC98
else|else
block|{
if|if
condition|(
name|type
operator|!=
name|fd_data
index|[
name|fdu
index|]
operator|.
name|type
condition|)
block|{
switch|switch
condition|(
name|fd_data
index|[
name|fdu
index|]
operator|.
name|type
condition|)
block|{
case|case
name|FD_360
case|:
return|return
operator|(
name|ENXIO
operator|)
return|;
case|case
name|FD_720
case|:
if|if
condition|(
name|type
operator|!=
name|FD_820
operator|&&
name|type
operator|!=
name|FD_800
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
break|break;
case|case
name|FD_1200
case|:
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|FD_1480
case|:
name|type
operator|=
name|FD_1480in5_25
expr_stmt|;
break|break;
case|case
name|FD_1440
case|:
name|type
operator|=
name|FD_1440in5_25
expr_stmt|;
break|break;
case|case
name|FD_820
case|:
name|type
operator|=
name|FD_820in5_25
expr_stmt|;
break|break;
case|case
name|FD_800
case|:
name|type
operator|=
name|FD_800in5_25
expr_stmt|;
break|break;
case|case
name|FD_720
case|:
name|type
operator|=
name|FD_720in5_25
expr_stmt|;
break|break;
case|case
name|FD_360
case|:
name|type
operator|=
name|FD_360in5_25
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
break|break;
case|case
name|FD_1440
case|:
if|if
condition|(
name|type
operator|!=
name|FD_1720
operator|&&
name|type
operator|!=
name|FD_1480
operator|&&
name|type
operator|!=
name|FD_1200
operator|&&
name|type
operator|!=
name|FD_820
operator|&&
name|type
operator|!=
name|FD_800
operator|&&
name|type
operator|!=
name|FD_720
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
break|break;
block|}
block|}
block|}
endif|#
directive|endif
name|fd_data
index|[
name|fdu
index|]
operator|.
name|ft
operator|=
name|fd_types
operator|+
name|type
operator|-
literal|1
expr_stmt|;
name|fd_data
index|[
name|fdu
index|]
operator|.
name|flags
operator||=
name|FD_OPEN
expr_stmt|;
name|kdc_fd
index|[
name|fdu
index|]
operator|.
name|kdc_state
operator|=
name|DC_BUSY
expr_stmt|;
return|return
literal|0
return|;
block|}
name|int
name|fdclose
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|fdu_t
name|fdu
init|=
name|FDUNIT
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
decl_stmt|;
if|#
directive|if
name|NFT
operator|>
literal|0
name|int
name|type
init|=
name|FDTYPE
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|&
name|F_TAPE_TYPE
condition|)
return|return
name|ftclose
argument_list|(
name|dev
argument_list|,
name|flags
argument_list|)
return|;
endif|#
directive|endif
name|fd_data
index|[
name|fdu
index|]
operator|.
name|flags
operator|&=
operator|~
name|FD_OPEN
expr_stmt|;
name|fd_data
index|[
name|fdu
index|]
operator|.
name|options
operator|&=
operator|~
name|FDOPT_NORETRY
expr_stmt|;
name|kdc_fd
index|[
name|fdu
index|]
operator|.
name|kdc_state
operator|=
name|DC_IDLE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/****************************************************************************/
comment|/*                               fdstrategy                                 */
comment|/****************************************************************************/
name|void
name|fdstrategy
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|long
name|nblocks
decl_stmt|,
name|blknum
decl_stmt|;
name|int
name|s
decl_stmt|;
name|fdcu_t
name|fdcu
decl_stmt|;
name|fdu_t
name|fdu
decl_stmt|;
name|fdc_p
name|fdc
decl_stmt|;
name|fd_p
name|fd
decl_stmt|;
name|size_t
name|fdblk
decl_stmt|;
name|fdu
operator|=
name|FDUNIT
argument_list|(
name|minor
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
argument_list|)
expr_stmt|;
name|fd
operator|=
operator|&
name|fd_data
index|[
name|fdu
index|]
expr_stmt|;
name|fdc
operator|=
name|fd
operator|->
name|fdc
expr_stmt|;
name|fdcu
operator|=
name|fdc
operator|->
name|fdcu
expr_stmt|;
if|#
directive|if
name|NFT
operator|>
literal|0
if|if
condition|(
name|FDTYPE
argument_list|(
name|minor
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
argument_list|)
operator|&
name|F_TAPE_TYPE
condition|)
block|{
comment|/* ft tapes do not (yet) support strategy i/o */
name|bp
operator|->
name|b_error
operator|=
name|ENODEV
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* check for controller already busy with tape */
if|if
condition|(
name|fdc
operator|->
name|flags
operator|&
name|FDC_TAPE_BUSY
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|EBUSY
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
endif|#
directive|endif
name|fdblk
operator|=
literal|128
operator|<<
operator|(
name|fd
operator|->
name|ft
operator|->
name|secsize
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_FORMAT
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|fdu
operator|>=
name|NFD
operator|)
operator|||
operator|(
name|bp
operator|->
name|b_blkno
operator|<
literal|0
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"fd%d: fdstrat: bad request blkno = %lu, bcount = %ld\n"
argument_list|,
name|fdu
argument_list|,
operator|(
name|u_long
operator|)
name|bp
operator|->
name|b_blkno
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|EINVAL
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
operator|(
name|bp
operator|->
name|b_bcount
operator|%
name|fdblk
operator|)
operator|!=
literal|0
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|EINVAL
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
comment|/* 	 * Set up block calculations. 	 */
name|blknum
operator|=
operator|(
name|unsigned
name|long
operator|)
name|bp
operator|->
name|b_blkno
operator|*
name|DEV_BSIZE
operator|/
name|fdblk
expr_stmt|;
name|nblocks
operator|=
name|fd
operator|->
name|ft
operator|->
name|size
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
define|#
directive|define
name|B_XXX2
value|0x8000000
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_XXX2
condition|)
block|{
name|blknum
operator|*=
literal|2
expr_stmt|;
name|bp
operator|->
name|b_blkno
operator|*=
literal|2
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_XXX2
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|blknum
operator|+
operator|(
name|bp
operator|->
name|b_bcount
operator|/
name|fdblk
operator|)
operator|>
name|nblocks
condition|)
block|{
if|if
condition|(
name|blknum
operator|==
name|nblocks
condition|)
block|{
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
block|}
else|else
block|{
name|bp
operator|->
name|b_error
operator|=
name|ENOSPC
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
block|}
goto|goto
name|bad
goto|;
block|}
name|bp
operator|->
name|b_cylin
operator|=
name|blknum
operator|/
operator|(
name|fd
operator|->
name|ft
operator|->
name|sectrac
operator|*
name|fd
operator|->
name|ft
operator|->
name|heads
operator|)
expr_stmt|;
name|bp
operator|->
name|b_pblkno
operator|=
name|bp
operator|->
name|b_blkno
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|tqdisksort
argument_list|(
operator|&
name|fdc
operator|->
name|head
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|untimeout
argument_list|(
name|fd_turnoff
argument_list|,
operator|(
name|caddr_t
operator|)
name|fdu
argument_list|)
expr_stmt|;
comment|/* a good idea */
name|fdstart
argument_list|(
name|fdcu
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
name|bad
label|:
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
comment|/***************************************************************\ *				fdstart				* * We have just queued something.. if the controller is not busy	* * then simulate the case where it has just finished a command	* * So that it (the interrupt routine) looks on the queue for more* * work to do and picks up what we just added.			* * If the controller is already busy, we need do nothing, as it	* * will pick up our work when the present work completes		* \***************************************************************/
specifier|static
name|void
name|fdstart
parameter_list|(
name|fdcu_t
name|fdcu
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
if|if
condition|(
name|fdc_data
index|[
name|fdcu
index|]
operator|.
name|state
operator|==
name|DEVIDLE
condition|)
block|{
name|fdintr
argument_list|(
name|fdcu
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|fd_timeout
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|)
block|{
name|fdcu_t
name|fdcu
init|=
operator|(
name|fdcu_t
operator|)
name|arg1
decl_stmt|;
name|fdu_t
name|fdu
init|=
name|fdc_data
index|[
name|fdcu
index|]
operator|.
name|fdu
decl_stmt|;
name|int
name|baseport
init|=
name|fdc_data
index|[
name|fdcu
index|]
operator|.
name|baseport
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|bp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|fdc_data
index|[
name|fdcu
index|]
operator|.
name|head
argument_list|)
expr_stmt|;
comment|/* 	 * Due to IBM's brain-dead design, the FDC has a faked ready 	 * signal, hardwired to ready == true. Thus, any command 	 * issued if there's no diskette in the drive will _never_ 	 * complete, and must be aborted by resetting the FDC. 	 * Many thanks, Big Blue! 	 */
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|TRACE1
argument_list|(
literal|"fd%d[fd_timeout()]"
argument_list|,
name|fdu
argument_list|)
expr_stmt|;
comment|/* See if the controller is still busy (patiently awaiting data) */
if|if
condition|(
operator|(
operator|(
name|inb
argument_list|(
name|baseport
operator|+
name|FDSTS
argument_list|)
operator|)
operator|&
operator|(
name|NE7_CB
operator||
name|NE7_RQM
operator|)
operator|)
operator|==
name|NE7_CB
condition|)
block|{
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|TRACE1
argument_list|(
literal|"[FDSTS->0x%x]"
argument_list|,
name|inb
argument_list|(
name|baseport
operator|+
name|FDSTS
argument_list|)
argument_list|)
expr_stmt|;
comment|/* yup, it is; kill it now */
name|fdc_reset
argument_list|(
operator|&
name|fdc_data
index|[
name|fdcu
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"fd%d: Operation timeout\n"
argument_list|,
name|fdu
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bp
condition|)
block|{
name|retrier
argument_list|(
name|fdcu
argument_list|)
expr_stmt|;
name|fdc_data
index|[
name|fdcu
index|]
operator|.
name|status
index|[
literal|0
index|]
operator|=
name|NE7_ST0_IC_RC
expr_stmt|;
name|fdc_data
index|[
name|fdcu
index|]
operator|.
name|state
operator|=
name|IOTIMEDOUT
expr_stmt|;
if|if
condition|(
name|fdc_data
index|[
name|fdcu
index|]
operator|.
name|retry
operator|<
literal|6
condition|)
name|fdc_data
index|[
name|fdcu
index|]
operator|.
name|retry
operator|=
literal|6
expr_stmt|;
block|}
else|else
block|{
name|fdc_data
index|[
name|fdcu
index|]
operator|.
name|fd
operator|=
operator|(
name|fd_p
operator|)
literal|0
expr_stmt|;
name|fdc_data
index|[
name|fdcu
index|]
operator|.
name|fdu
operator|=
operator|-
literal|1
expr_stmt|;
name|fdc_data
index|[
name|fdcu
index|]
operator|.
name|state
operator|=
name|DEVIDLE
expr_stmt|;
block|}
name|fdintr
argument_list|(
name|fdcu
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
comment|/* just ensure it has the right spl */
specifier|static
name|void
name|fd_pseudointr
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|)
block|{
name|fdcu_t
name|fdcu
init|=
operator|(
name|fdcu_t
operator|)
name|arg1
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|fdintr
argument_list|(
name|fdcu
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
comment|/***********************************************************************\ *                                 fdintr				* * keep calling the state machine until it returns a 0			* * ALWAYS called at SPLBIO 						* \***********************************************************************/
name|void
name|fdintr
parameter_list|(
name|fdcu_t
name|fdcu
parameter_list|)
block|{
name|fdc_p
name|fdc
init|=
name|fdc_data
operator|+
name|fdcu
decl_stmt|;
if|#
directive|if
name|NFT
operator|>
literal|0
name|fdu_t
name|fdu
init|=
name|fdc
operator|->
name|fdu
decl_stmt|;
if|if
condition|(
name|fdc
operator|->
name|flags
operator|&
name|FDC_TAPE_BUSY
condition|)
operator|(
name|ftintr
argument_list|(
name|fdu
argument_list|)
operator|)
expr_stmt|;
else|else
endif|#
directive|endif
while|while
condition|(
name|fdstate
argument_list|(
name|fdcu
argument_list|,
name|fdc
argument_list|)
condition|)
empty_stmt|;
block|}
comment|/***********************************************************************\ * The controller state machine.						* * if it returns a non zero value, it should be called again immediatly	* \***********************************************************************/
specifier|static
name|int
name|fdstate
parameter_list|(
name|fdcu_t
name|fdcu
parameter_list|,
name|fdc_p
name|fdc
parameter_list|)
block|{
name|int
name|read
decl_stmt|,
name|format
decl_stmt|,
name|head
decl_stmt|,
name|sec
init|=
literal|0
decl_stmt|,
name|sectrac
decl_stmt|,
name|st0
decl_stmt|,
name|cyl
decl_stmt|,
name|st3
decl_stmt|;
name|unsigned
name|long
name|blknum
decl_stmt|;
name|fdu_t
name|fdu
init|=
name|fdc
operator|->
name|fdu
decl_stmt|;
name|fd_p
name|fd
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|fd_formb
modifier|*
name|finfo
init|=
name|NULL
decl_stmt|;
name|size_t
name|fdblk
decl_stmt|;
name|bp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|fdc
operator|->
name|head
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bp
condition|)
block|{
comment|/***********************************************\ 		* nothing left for this controller to do	* 		* Force into the IDLE state,			* 		\***********************************************/
name|fdc
operator|->
name|state
operator|=
name|DEVIDLE
expr_stmt|;
if|if
condition|(
name|fdc
operator|->
name|fd
condition|)
block|{
name|printf
argument_list|(
literal|"fd%d: unexpected valid fd pointer\n"
argument_list|,
name|fdc
operator|->
name|fdu
argument_list|)
expr_stmt|;
name|fdc
operator|->
name|fd
operator|=
operator|(
name|fd_p
operator|)
literal|0
expr_stmt|;
name|fdc
operator|->
name|fdu
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|TRACE1
argument_list|(
literal|"[fdc%d IDLE]"
argument_list|,
name|fdcu
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|fdu
operator|=
name|FDUNIT
argument_list|(
name|minor
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
argument_list|)
expr_stmt|;
name|fd
operator|=
name|fd_data
operator|+
name|fdu
expr_stmt|;
name|fdblk
operator|=
literal|128
operator|<<
name|fd
operator|->
name|ft
operator|->
name|secsize
expr_stmt|;
if|if
condition|(
name|fdc
operator|->
name|fd
operator|&&
operator|(
name|fd
operator|!=
name|fdc
operator|->
name|fd
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"fd%d: confused fd pointers\n"
argument_list|,
name|fdu
argument_list|)
expr_stmt|;
block|}
name|read
operator|=
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
expr_stmt|;
name|format
operator|=
name|bp
operator|->
name|b_flags
operator|&
name|B_FORMAT
expr_stmt|;
if|if
condition|(
name|format
condition|)
name|finfo
operator|=
operator|(
expr|struct
name|fd_formb
operator|*
operator|)
name|bp
operator|->
name|b_un
operator|.
name|b_addr
expr_stmt|;
name|TRACE1
argument_list|(
literal|"fd%d"
argument_list|,
name|fdu
argument_list|)
expr_stmt|;
name|TRACE1
argument_list|(
literal|"[%s]"
argument_list|,
name|fdstates
index|[
name|fdc
operator|->
name|state
index|]
argument_list|)
expr_stmt|;
name|TRACE1
argument_list|(
literal|"(0x%x)"
argument_list|,
name|fd
operator|->
name|flags
argument_list|)
expr_stmt|;
name|untimeout
argument_list|(
name|fd_turnoff
argument_list|,
operator|(
name|caddr_t
operator|)
name|fdu
argument_list|)
expr_stmt|;
name|timeout
argument_list|(
name|fd_turnoff
argument_list|,
operator|(
name|caddr_t
operator|)
name|fdu
argument_list|,
literal|4
operator|*
name|hz
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|fdc
operator|->
name|state
condition|)
block|{
case|case
name|DEVIDLE
case|:
case|case
name|FINDWORK
case|:
comment|/* we have found new work */
name|fdc
operator|->
name|retry
operator|=
literal|0
expr_stmt|;
name|fd
operator|->
name|skip
operator|=
literal|0
expr_stmt|;
name|fdc
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
name|fdc
operator|->
name|fdu
operator|=
name|fdu
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|pc98_trans
operator|=
name|fd
operator|->
name|ft
operator|->
name|trans
expr_stmt|;
if|if
condition|(
name|pc98_trans_prev
operator|!=
name|pc98_trans
condition|)
block|{
name|int
name|i
decl_stmt|;
name|set_density
argument_list|(
name|fdcu
argument_list|,
name|fdu
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|outb
argument_list|(
literal|0x5f
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
literal|0x5f
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|pc98_trans_prev
operator|=
name|pc98_trans
expr_stmt|;
block|}
if|if
condition|(
name|pc98_trans
operator|!=
name|fd
operator|->
name|pc98_trans
condition|)
block|{
if|if
condition|(
name|pc98_trans
operator|!=
literal|1
operator|&&
operator|(
name|PC98_SYSTEM_PARAMETER
argument_list|(
literal|0x5ae
argument_list|)
operator|>>
name|fdu
operator|)
operator|&
literal|0x01
condition|)
block|{
name|outb
argument_list|(
literal|0x4be
argument_list|,
operator|(
name|fdu
operator|<<
literal|5
operator|)
operator||
literal|0x10
operator||
operator|(
name|pc98_trans
operator|>>
literal|1
operator|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
literal|0x5f
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
literal|0x5f
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|fd
operator|->
name|pc98_trans
operator|=
name|pc98_trans
expr_stmt|;
block|}
else|#
directive|else
name|outb
argument_list|(
name|fdc
operator|->
name|baseport
operator|+
name|FDCTL
argument_list|,
name|fd
operator|->
name|ft
operator|->
name|trans
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|TRACE1
argument_list|(
literal|"[0x%x->FDCTL]"
argument_list|,
name|fd
operator|->
name|ft
operator|->
name|trans
argument_list|)
expr_stmt|;
comment|/*******************************************************\ 		* If the next drive has a motor startup pending, then	* 		* it will start up in it's own good time		* 		\*******************************************************/
if|if
condition|(
name|fd
operator|->
name|flags
operator|&
name|FD_MOTOR_WAIT
condition|)
block|{
name|fdc
operator|->
name|state
operator|=
name|MOTORWAIT
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* come back later */
block|}
comment|/*******************************************************\ 		* Maybe if it's not starting, it SHOULD be starting	* 		\*******************************************************/
ifdef|#
directive|ifdef
name|EPSON_NRDISK
if|if
condition|(
name|fdu
operator|!=
name|nrdu
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|fd
operator|->
name|flags
operator|&
name|FD_MOTOR
operator|)
condition|)
block|{
name|fdc
operator|->
name|state
operator|=
name|MOTORWAIT
expr_stmt|;
name|fd_turnon
argument_list|(
name|fdu
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
comment|/* at least make sure we are selected */
block|{
name|set_motor
argument_list|(
name|fdcu
argument_list|,
name|fd
operator|->
name|fdsu
argument_list|,
name|TURNON
argument_list|)
expr_stmt|;
block|}
block|}
else|#
directive|else
comment|/* !EPSON_NRDISK */
if|if
condition|(
operator|!
operator|(
name|fd
operator|->
name|flags
operator|&
name|FD_MOTOR
operator|)
condition|)
block|{
name|fdc
operator|->
name|state
operator|=
name|MOTORWAIT
expr_stmt|;
name|fd_turnon
argument_list|(
name|fdu
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
comment|/* at least make sure we are selected */
block|{
name|set_motor
argument_list|(
name|fdcu
argument_list|,
name|fd
operator|->
name|fdsu
argument_list|,
name|TURNON
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|fdc
operator|->
name|state
operator|=
name|DOSEEK
expr_stmt|;
break|break;
case|case
name|DOSEEK
case|:
if|if
condition|(
name|bp
operator|->
name|b_cylin
operator|==
name|fd
operator|->
name|track
condition|)
block|{
name|fdc
operator|->
name|state
operator|=
name|SEEKCOMPLETE
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|PC98
name|pc98_fd_check_ready
argument_list|(
name|fdu
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|fd_cmd
argument_list|(
name|fdcu
argument_list|,
literal|3
argument_list|,
name|NE7CMD_SEEK
argument_list|,
name|fd
operator|->
name|fdsu
argument_list|,
name|bp
operator|->
name|b_cylin
operator|*
name|fd
operator|->
name|ft
operator|->
name|steptrac
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* 			 * seek command not accepted, looks like 			 * the FDC went off to the Saints... 			 */
name|fdc
operator|->
name|retry
operator|=
literal|6
expr_stmt|;
comment|/* try a reset */
return|return
operator|(
name|retrier
argument_list|(
name|fdcu
argument_list|)
operator|)
return|;
block|}
name|fd
operator|->
name|track
operator|=
name|FD_NO_TRACK
expr_stmt|;
name|fdc
operator|->
name|state
operator|=
name|SEEKWAIT
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* will return later */
case|case
name|SEEKWAIT
case|:
comment|/* allow heads to settle */
name|timeout
argument_list|(
name|fd_pseudointr
argument_list|,
operator|(
name|caddr_t
operator|)
name|fdcu
argument_list|,
name|hz
operator|/
literal|16
argument_list|)
expr_stmt|;
name|fdc
operator|->
name|state
operator|=
name|SEEKCOMPLETE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* will return later */
case|case
name|SEEKCOMPLETE
case|:
comment|/* SEEK DONE, START DMA */
comment|/* Make sure seek really happened*/
if|if
condition|(
name|fd
operator|->
name|track
operator|==
name|FD_NO_TRACK
condition|)
block|{
name|int
name|descyl
init|=
name|bp
operator|->
name|b_cylin
operator|*
name|fd
operator|->
name|ft
operator|->
name|steptrac
decl_stmt|;
do|do
block|{
comment|/* 				 * This might be a "ready changed" interrupt, 				 * which cannot really happen since the 				 * RDY pin is hardwired to + 5 volts.  This 				 * generally indicates a "bouncing" intr 				 * line, so do one of the following: 				 * 				 * When running on an enhanced FDC that is 				 * known to not go stuck after responding 				 * with INVALID, fetch all interrupt states 				 * until seeing either an INVALID or a 				 * real interrupt condition. 				 * 				 * When running on a dumb old NE765, give 				 * up immediately.  The controller will 				 * provide up to four dummy RC interrupt 				 * conditions right after reset (for the 				 * corresponding four drives), so this is 				 * our only chance to get notice that it 				 * was not the FDC that caused the interrupt. 				 */
if|if
condition|(
name|fd_sense_int
argument_list|(
name|fdc
argument_list|,
operator|&
name|st0
argument_list|,
operator|&
name|cyl
argument_list|)
operator|==
name|FD_NOT_VALID
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|fdc
operator|->
name|fdct
operator|==
name|FDC_NE765
operator|&&
operator|(
name|st0
operator|&
name|NE7_ST0_IC
operator|)
operator|==
name|NE7_ST0_IC_RC
condition|)
return|return
literal|0
return|;
comment|/* hope for a real intr */
block|}
do|while
condition|(
operator|(
name|st0
operator|&
name|NE7_ST0_IC
operator|)
operator|==
name|NE7_ST0_IC_RC
condition|)
do|;
if|if
condition|(
literal|0
operator|==
name|descyl
condition|)
block|{
name|int
name|failed
init|=
literal|0
decl_stmt|;
comment|/* 				 * seek to cyl 0 requested; make sure we are 				 * really there 				 */
if|if
condition|(
name|fd_sense_drive_status
argument_list|(
name|fdc
argument_list|,
operator|&
name|st3
argument_list|)
condition|)
name|failed
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|EPSON_NRDISK
if|if
condition|(
name|fdu
operator|==
name|nrdu
condition|)
name|st3
operator|=
name|NE7_ST3_T0
expr_stmt|;
endif|#
directive|endif
comment|/* EPSON_NRDISK */
if|if
condition|(
operator|(
name|st3
operator|&
name|NE7_ST3_T0
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"fd%d: Seek to cyl 0, but not really there (ST3 = %b)\n"
argument_list|,
name|fdu
argument_list|,
name|st3
argument_list|,
name|NE7_ST3BITS
argument_list|)
expr_stmt|;
name|failed
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|failed
condition|)
block|{
if|if
condition|(
name|fdc
operator|->
name|retry
operator|<
literal|3
condition|)
name|fdc
operator|->
name|retry
operator|=
literal|3
expr_stmt|;
return|return
operator|(
name|retrier
argument_list|(
name|fdcu
argument_list|)
operator|)
return|;
block|}
block|}
ifdef|#
directive|ifdef
name|EPSON_NRDISK
if|if
condition|(
name|fdu
operator|==
name|nrdu
condition|)
name|cyl
operator|=
name|descyl
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|cyl
operator|!=
name|descyl
condition|)
block|{
name|printf
argument_list|(
literal|"fd%d: Seek to cyl %d failed; am at cyl %d (ST0 = 0x%x)\n"
argument_list|,
name|fdu
argument_list|,
name|descyl
argument_list|,
name|cyl
argument_list|,
name|st0
argument_list|)
expr_stmt|;
return|return
operator|(
name|retrier
argument_list|(
name|fdcu
argument_list|)
operator|)
return|;
block|}
block|}
name|fd
operator|->
name|track
operator|=
name|bp
operator|->
name|b_cylin
expr_stmt|;
if|if
condition|(
name|format
condition|)
name|fd
operator|->
name|skip
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|finfo
operator|->
name|fd_formb_cylno
argument_list|(
literal|0
argument_list|)
operator|)
operator|-
operator|(
name|char
operator|*
operator|)
name|finfo
expr_stmt|;
ifdef|#
directive|ifdef
name|EPSON_NRDISK
if|if
condition|(
name|fdu
operator|!=
name|nrdu
condition|)
block|{
endif|#
directive|endif
comment|/* EPSON_NRDISK */
ifdef|#
directive|ifdef
name|PC98
name|pc98_dmastart
argument_list|(
argument|bp->b_flags
argument_list|,
argument|bp->b_un.b_addr+fd->skip
argument_list|,
else|#
directive|else
argument|isa_dmastart(bp->b_flags, bp->b_un.b_addr+fd->skip,
endif|#
directive|endif
argument|format ? bp->b_bcount : fdblk, fdc->dmachan); 		blknum = (unsigned long)bp->b_blkno*DEV_BSIZE/fdblk 			+ fd->skip/fdblk; 		sectrac = fd->ft->sectrac; 		sec = blknum %  (sectrac * fd->ft->heads); 		head = sec / sectrac; 		sec = sec % sectrac +
literal|1
argument|; 		fd->hddrv = ((head&
literal|1
argument|)<<
literal|2
argument|)+fdu; 		if(format || !read) 		{
comment|/* make sure the drive is writable */
argument|if(fd_sense_drive_status(fdc,&st3) !=
literal|0
argument|) 			{
comment|/* stuck controller? */
argument|fdc->retry =
literal|6
argument|;
comment|/* reset the beast */
argument|return(retrier(fdcu)); 			} 			if(st3& NE7_ST3_WP) 			{
comment|/* 				 * XXX YES! this is ugly. 				 * in order to force the current operation 				 * to fail, we will have to fake an FDC 				 * error - all error handling is done 				 * by the retrier() 				 */
argument|fdc->status[
literal|0
argument|] = NE7_ST0_IC_AT; 				fdc->status[
literal|1
argument|] = NE7_ST1_NW; 				fdc->status[
literal|2
argument|] =
literal|0
argument|; 				fdc->status[
literal|3
argument|] = fd->track; 				fdc->status[
literal|4
argument|] = head; 				fdc->status[
literal|5
argument|] = sec; 				fdc->retry =
literal|8
argument|;
comment|/* break out immediately */
argument|fdc->state = IOTIMEDOUT;
comment|/* not really... */
argument|return (
literal|1
argument|); 			} 		}  		if(format) 		{
comment|/* formatting */
argument|if(fd_cmd(fdcu,
literal|6
argument|, 				  NE7CMD_FORMAT, 				  head<<
literal|2
argument|| fdu, 				  finfo->fd_formb_secshift, 				  finfo->fd_formb_nsecs, 				  finfo->fd_formb_gaplen, 				  finfo->fd_formb_fillbyte,
literal|0
argument|)) 			{
comment|/* controller fell over */
argument|fdc->retry =
literal|6
argument|; 				return(retrier(fdcu)); 			} 		} 		else 		{ 			if (fd_cmd(fdcu,
literal|9
argument|, 				   (read ? NE7CMD_READ : NE7CMD_WRITE), 				   head<<
literal|2
argument|| fdu,
comment|/* head& unit */
argument|fd->track,
comment|/* track */
argument|head, 				   sec,
comment|/* sector + 1 */
argument|fd->ft->secsize,
comment|/* sector size */
argument|sectrac,
comment|/* sectors/track */
argument|fd->ft->gap,
comment|/* gap size */
argument|fd->ft->datalen,
comment|/* data length */
literal|0
argument|)) 			{
comment|/* the beast is sleeping again */
argument|fdc->retry =
literal|6
argument|; 				return(retrier(fdcu)); 			} 		} 		fdc->state = IOCOMPLETE; 		timeout(fd_timeout, (caddr_t)fdcu, hz); 		return(
literal|0
argument|);
comment|/* will return later */
ifdef|#
directive|ifdef
name|EPSON_NRDISK
argument|} 		else { 			nrdblkn = (nrd_t)((unsigned long)bp->b_blkno*DEV_BSIZE/fdblk 				+ fd->skip/fdblk); 			nrd_LED_on(); 			nrd_addrset(fdblk * nrdblkn); 			while (!nrd_check_ready()) DELAY(
literal|1
argument|); 			if (read) epson_insw(P_NRD_DATA, 					bp->b_un.b_addr + fd->skip, 					fdblk / sizeof(short)); 			else epson_outsw(P_NRD_DATA, 				bp->b_un.b_addr + fd->skip, 				(format ? bp->b_bcount : fdblk) 					/ sizeof(short));  			blknum = (unsigned long)bp->b_blkno*DEV_BSIZE/fdblk 				+ fd->skip/fdblk; 			sectrac = fd->ft->sectrac; 			sec = blknum %  (sectrac * fd->ft->heads); 			head = sec / sectrac; 			sec = sec % sectrac +
literal|1
argument|; 			fd->hddrv = ((head&
literal|1
argument|)<<
literal|2
argument|)+fdu;  			if (nrdsec++>= nrd_sec())  				nrdaddr = (nrd_t)(fd->track *
literal|8
argument|+ head *
literal|4
argument|); 			nrdsec = sec; 			fdc->state = IOCOMPLETE; 		}
endif|#
directive|endif
argument|case IOCOMPLETE:
comment|/* IO DONE, post-analyze */
ifdef|#
directive|ifdef
name|EPSON_NRDISK
argument|if (fdu != nrdu) untimeout(fd_timeout, (caddr_t)fdcu);
else|#
directive|else
argument|untimeout(fd_timeout, (caddr_t)fdcu);
endif|#
directive|endif
argument|if (fd_read_status(fdc, fd->fdsu)) 		{ 			if (fdc->retry<
literal|6
argument|) 				fdc->retry =
literal|6
argument|;
comment|/* force a reset */
argument|return retrier(fdcu);   		}  		fdc->state = IOTIMEDOUT;
comment|/* FALLTHROUGH */
argument|case IOTIMEDOUT:
ifdef|#
directive|ifdef
name|EPSON_NRDISK
argument|if (fdu != nrdu) {
endif|#
directive|endif
comment|/* EPSON_NRDISK */
ifdef|#
directive|ifdef
name|PC98
argument|pc98_dmadone(bp->b_flags, bp->b_un.b_addr+fd->skip,
else|#
directive|else
argument|isa_dmadone(bp->b_flags, bp->b_un.b_addr+fd->skip,
endif|#
directive|endif
argument|format ? bp->b_bcount : fdblk, fdc->dmachan);
ifdef|#
directive|ifdef
name|EPSON_NRDISK
argument|} 		else nrd_LED_off();
endif|#
directive|endif
comment|/* EPSON_NRDISK */
argument|if (fdc->status[
literal|0
argument|]& NE7_ST0_IC) 		{                         if ((fdc->status[
literal|0
argument|]& NE7_ST0_IC) == NE7_ST0_IC_AT&& fdc->status[
literal|1
argument|]& NE7_ST1_OR) {
comment|/* 				 * DMA overrun. Someone hogged the bus 				 * and didn't release it in time for the 				 * next FDC transfer. 				 * Just restart it, don't increment retry 				 * count. (vak)                                  */
argument|fdc->state = SEEKCOMPLETE;                                 return (
literal|1
argument|);                         } 			else if((fdc->status[
literal|0
argument|]& NE7_ST0_IC) == NE7_ST0_IC_IV&& fdc->retry<
literal|6
argument|) 				fdc->retry =
literal|6
argument|;
comment|/* force a reset */
argument|else if((fdc->status[
literal|0
argument|]& NE7_ST0_IC) == NE7_ST0_IC_AT&& fdc->status[
literal|2
argument|]& NE7_ST2_WC&& fdc->retry<
literal|3
argument|) 				fdc->retry =
literal|3
argument|;
comment|/* force recalibrate */
argument|return(retrier(fdcu)); 		}
comment|/* All OK */
argument|fd->skip += fdblk; 		if (!format&& fd->skip< bp->b_bcount) 		{
comment|/* set up next transfer */
argument|blknum = (unsigned long)bp->b_blkno*DEV_BSIZE/fdblk 				+ fd->skip/fdblk;
ifdef|#
directive|ifdef
name|EPSON_NRDISK
argument|nrdblkn = (unsigned long)bp->b_blkno*DEV_BSIZE/fdblk 				+ fd->skip/fdblk;
endif|#
directive|endif
argument|bp->b_cylin = 				(blknum / (fd->ft->sectrac * fd->ft->heads)); 			fdc->state = DOSEEK; 		} 		else 		{
comment|/* ALL DONE */
argument|fd->skip =
literal|0
argument|; 			bp->b_resid =
literal|0
argument|; 			TAILQ_REMOVE(&fdc->head, bp, b_act); 			biodone(bp); 			fdc->fd = (fd_p)
literal|0
argument|; 			fdc->fdu = -
literal|1
argument|; 			fdc->state = FINDWORK; 		} 		return(
literal|1
argument|); 	case RESETCTLR: 		fdc_reset(fdc); 		fdc->retry++; 		fdc->state = STARTRECAL; 		break; 	case STARTRECAL:
comment|/* XXX clear the fdc results from the last reset, if any. */
argument|{ 			int i; 			for (i =
literal|0
argument|; i<
literal|4
argument|; i++) 				(void)fd_sense_int(fdc,&st0,&cyl); 		}
ifdef|#
directive|ifdef
name|PC98
argument|pc98_fd_check_ready(fdu);
endif|#
directive|endif
argument|if(fd_cmd(fdcu,
literal|2
argument|, NE7CMD_RECAL, fdu,
literal|0
argument|))
comment|/* Recalibrate Function */
argument|{
comment|/* arrgl */
argument|fdc->retry =
literal|6
argument|; 			return(retrier(fdcu)); 		} 		fdc->state = RECALWAIT; 		return(
literal|0
argument|);
comment|/* will return later */
argument|case RECALWAIT:
comment|/* allow heads to settle */
argument|timeout(fd_pseudointr, (caddr_t)fdcu, hz /
literal|8
argument|); 		fdc->state = RECALCOMPLETE; 		return(
literal|0
argument|);
comment|/* will return later */
argument|case RECALCOMPLETE: 		do {
comment|/* 			 * See SEEKCOMPLETE for a comment on this: 			 */
argument|if (fd_sense_int(fdc,&st0,&cyl) == FD_NOT_VALID) 				return
literal|0
argument|; 			if(fdc->fdct == FDC_NE765&& (st0& NE7_ST0_IC) == NE7_ST0_IC_RC) 				return
literal|0
argument|;
comment|/* hope for a real intr */
argument|} while ((st0& NE7_ST0_IC) == NE7_ST0_IC_RC);
ifdef|#
directive|ifdef
name|EPSON_NRDISK
argument|if (fdu == nrdu) { 			st0 = NE7_ST0_IC_NT; 			cyl =
literal|0
argument|; 		}
endif|#
directive|endif
argument|if ((st0& NE7_ST0_IC) != NE7_ST0_IC_NT || cyl !=
literal|0
argument|) 		{ 			if(fdc->retry>
literal|3
argument|)
comment|/* 				 * a recalibrate from beyond cylinder 77 				 * will "fail" due to the FDC limitations; 				 * since people used to complain much about 				 * the failure message, try not logging 				 * this one if it seems to be the first 				 * time in a line 				 */
argument|printf(
literal|"fd%d: recal failed ST0 %b cyl %d\n"
argument|, 				       fdu, st0, NE7_ST0BITS, cyl); 			if(fdc->retry<
literal|3
argument|) fdc->retry =
literal|3
argument|; 			return(retrier(fdcu)); 		} 		fd->track =
literal|0
argument|;
comment|/* Seek (probably) necessary */
argument|fdc->state = DOSEEK; 		return(
literal|1
argument|);
comment|/* will return immediatly */
argument|case MOTORWAIT: 		if(fd->flags& FD_MOTOR_WAIT) 		{ 			return(
literal|0
argument|);
comment|/* time's not up yet */
argument|}
comment|/* 		 * since the controller was off, it has lost its 		 * idea about the current track it were; thus, 		 * recalibrate the bastard 		 */
argument|fdc->state = STARTRECAL; 		return(
literal|1
argument|);
comment|/* will return immediatly */
argument|default: 		printf(
literal|"fdc%d: Unexpected FD int->"
argument|, fdcu); 		if (fd_read_status(fdc, fd->fdsu) ==
literal|0
argument|) 			printf(
literal|"FDC status :%lx %lx %lx %lx %lx %lx %lx   "
argument|, 			       fdc->status[
literal|0
argument|], 			       fdc->status[
literal|1
argument|], 			       fdc->status[
literal|2
argument|], 			       fdc->status[
literal|3
argument|], 			       fdc->status[
literal|4
argument|], 			       fdc->status[
literal|5
argument|], 			       fdc->status[
literal|6
argument|] ); 		else 			printf(
literal|"No status available   "
argument|); 		if (fd_sense_int(fdc,&st0,&cyl) !=
literal|0
argument|) 		{ 			printf(
literal|"[controller is dead now]\n"
argument|); 			return(
literal|0
argument|); 		} 		printf(
literal|"ST0 = %x, PCN = %x\n"
argument|, st0, cyl); 		return(
literal|0
argument|); 	}
comment|/*XXX confusing: some branches return immediately, others end up here*/
argument|return(
literal|1
argument|);
comment|/* Come back immediatly to new state */
argument|}  static int retrier(fdcu) 	fdcu_t fdcu; { 	fdc_p fdc = fdc_data + fdcu; 	register struct buf *bp;  	bp = TAILQ_FIRST(&fdc->head);  	if(fd_data[FDUNIT(minor(bp->b_dev))].options& FDOPT_NORETRY) 		goto fail; 	switch(fdc->retry) 	{ 	case
literal|0
argument|: case
literal|1
argument|: case
literal|2
argument|: 		fdc->state = SEEKCOMPLETE; 		break; 	case
literal|3
argument|: case
literal|4
argument|: case
literal|5
argument|: 		fdc->state = STARTRECAL; 		break; 	case
literal|6
argument|: 		fdc->state = RESETCTLR; 		break; 	case
literal|7
argument|: 		break; 	default: 	fail: 		{ 			dev_t sav_b_dev = bp->b_dev;
comment|/* Trick diskerr */
argument|bp->b_dev = makedev(major(bp->b_dev), 					    (FDUNIT(minor(bp->b_dev))<<
literal|3
argument|)|RAW_PART); 			diskerr(bp,
literal|"fd"
argument|,
literal|"hard error"
argument|, LOG_PRINTF, 				fdc->fd->skip / DEV_BSIZE, 				(struct disklabel *)NULL); 			bp->b_dev = sav_b_dev; 			if (fdc->flags& FDC_STAT_VALID) 			{ 				printf(
literal|" (ST0 %b ST1 %b ST2 %b cyl %ld hd %ld sec %ld)\n"
argument|, 				       fdc->status[
literal|0
argument|], NE7_ST0BITS, 				       fdc->status[
literal|1
argument|], NE7_ST1BITS, 				       fdc->status[
literal|2
argument|], NE7_ST2BITS, 				       fdc->status[
literal|3
argument|], fdc->status[
literal|4
argument|], 				       fdc->status[
literal|5
argument|]); 			} 			else 				printf(
literal|" (No status)\n"
argument|); 		} 		bp->b_flags |= B_ERROR; 		bp->b_error = EIO; 		bp->b_resid = bp->b_bcount - fdc->fd->skip; 		TAILQ_REMOVE(&fdc->head, bp, b_act); 		fdc->fd->skip =
literal|0
argument|; 		biodone(bp); 		fdc->state = FINDWORK; 		fdc->fd = (fd_p)
literal|0
argument|; 		fdc->fdu = -
literal|1
argument|;
comment|/* XXX abort current command, if any.  */
argument|return(
literal|1
argument|); 	} 	fdc->retry++; 	return(
literal|1
argument|); }  static int fdformat(dev, finfo, p) 	dev_t dev; 	struct fd_formb *finfo; 	struct proc *p; {  	fdu_t	fdu;  	fd_p	fd;  	struct buf *bp; 	int rv =
literal|0
argument|, s; 	size_t fdblk;   	fdu = FDUNIT(minor(dev)); 	fd =&fd_data[fdu]; 	fdblk =
literal|128
argument|<< fd->ft->secsize;
comment|/* set up a buffer header for fdstrategy() */
argument|bp = (struct buf *)malloc(sizeof(struct buf), M_TEMP, M_NOWAIT); 	if(bp ==
literal|0
argument|) 		return ENOBUFS;
comment|/* 	 * keep the process from being swapped 	 */
argument|p->p_flag |= P_PHYSIO; 	bzero((void *)bp, sizeof(struct buf)); 	bp->b_flags = B_BUSY | B_PHYS | B_FORMAT; 	bp->b_proc = p; 	bp->b_dev = dev;
comment|/* 	 * calculate a fake blkno, so fdstrategy() would initiate a 	 * seek to the requested cylinder 	 */
argument|bp->b_blkno = (finfo->cyl * (fd->ft->sectrac * fd->ft->heads) 		+ finfo->head * fd->ft->sectrac) * fdblk / DEV_BSIZE;  	bp->b_bcount = sizeof(struct fd_idfield_data) * finfo->fd_formb_nsecs; 	bp->b_un.b_addr = (caddr_t)finfo;
comment|/* now do the format */
argument|fdstrategy(bp);
comment|/* ...and wait for it to complete */
argument|s = splbio(); 	while(!(bp->b_flags& B_DONE)) 	{ 		rv = tsleep((caddr_t)bp, PRIBIO,
literal|"fdform"
argument|,
literal|20
argument|* hz); 		if(rv == EWOULDBLOCK) 			break; 	} 	splx(s);  	if(rv == EWOULDBLOCK) {
comment|/* timed out */
argument|rv = EIO; 		biodone(bp); 	} 	if(bp->b_flags& B_ERROR) 		rv = bp->b_error;
comment|/* 	 * allow the process to be swapped 	 */
argument|p->p_flag&= ~P_PHYSIO; 	free(bp, M_TEMP); 	return rv; }
comment|/*  * TODO: don't allocate buffer on stack.  */
argument|int fdioctl(dev, cmd, addr, flag, p) 	dev_t dev; 	int cmd; 	caddr_t addr; 	int flag; 	struct proc *p; {  	fdu_t	fdu = FDUNIT(minor(dev));  	fd_p	fd =&fd_data[fdu]; 	size_t fdblk;  	struct fd_type *fdt; 	struct disklabel *dl; 	char buffer[DEV_BSIZE]; 	int error =
literal|0
argument|;
if|#
directive|if
name|NFT
operator|>
literal|0
argument|int type = FDTYPE(minor(dev));
comment|/* check for a tape ioctl */
argument|if (type& F_TAPE_TYPE) 		return ftioctl(dev, cmd, addr, flag, p);
endif|#
directive|endif
argument|fdblk =
literal|128
argument|<< fd->ft->secsize;
ifdef|#
directive|ifdef
name|PC98
argument|pc98_fd_check_ready(fdu);
endif|#
directive|endif
argument|switch (cmd) 	{ 	case DIOCGDINFO: 		bzero(buffer, sizeof (buffer)); 		dl = (struct disklabel *)buffer; 		dl->d_secsize = fdblk; 		fdt = fd_data[FDUNIT(minor(dev))].ft; 		dl->d_secpercyl = fdt->size / fdt->tracks; 		dl->d_type = DTYPE_FLOPPY;  		if (readdisklabel(dkmodpart(dev, RAW_PART), fdstrategy, dl) 		    == NULL) 			error =
literal|0
argument|; 		else 			error = EINVAL;  		*(struct disklabel *)addr = *dl; 		break;  	case DIOCSDINFO: 		if ((flag& FWRITE) ==
literal|0
argument|) 			error = EBADF; 		break;  	case DIOCWLABEL: 		if ((flag& FWRITE) ==
literal|0
argument|) 			error = EBADF; 		break;  	case DIOCWDINFO: 		if ((flag& FWRITE) ==
literal|0
argument|) 		{ 			error = EBADF; 			break; 		}  		dl = (struct disklabel *)addr;  		if ((error = setdisklabel((struct disklabel *)buffer, dl, 					  (u_long)
literal|0
argument|)) !=
literal|0
argument|) 			break;  		error = writedisklabel(dev, fdstrategy, 				       (struct disklabel *)buffer); 		break;  	case FD_FORM: 		if((flag& FWRITE) ==
literal|0
argument|) 			error = EBADF;
comment|/* must be opened for writing */
argument|else if(((struct fd_formb *)addr)->format_version != 			FD_FORMAT_VERSION) 			error = EINVAL;
comment|/* wrong version of formatting prog */
argument|else 			error = fdformat(dev, (struct fd_formb *)addr, p); 		break;  	case FD_GTYPE:
comment|/* get drive type */
argument|*(struct fd_type *)addr = *fd_data[FDUNIT(minor(dev))].ft; 		break;  	case FD_STYPE:
comment|/* set drive type */
comment|/* this is considered harmful; only allow for superuser */
argument|if(suser(p->p_ucred,&p->p_acflag) !=
literal|0
argument|) 			return EPERM; 		*fd_data[FDUNIT(minor(dev))].ft = *(struct fd_type *)addr; 		break;  	case FD_GOPTS:
comment|/* get drive options */
argument|*(int *)addr = fd_data[FDUNIT(minor(dev))].options; 		break;  	case FD_SOPTS:
comment|/* set drive options */
argument|fd_data[FDUNIT(minor(dev))].options = *(int *)addr; 		break;  	default: 		error = ENOTTY; 		break; 	} 	return (error); }   static fd_devsw_installed =
literal|0
argument|;  static void 	fd_drvinit(void *notused ) {  	if( ! fd_devsw_installed ) { 		bdevsw_add_generic(BDEV_MAJOR,CDEV_MAJOR,&fd_bdevsw); 		fd_devsw_installed =
literal|1
argument|; 	} }  SYSINIT(fddev,SI_SUB_DRIVERS,SI_ORDER_MIDDLE+CDEV_MAJOR,fd_drvinit,NULL)
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Hello emacs, these are the  * Local Variables:  *  c-indent-level:               8  *  c-continued-statement-offset: 8  *  c-continued-brace-offset:     0  *  c-brace-offset:              -8  *  c-brace-imaginary-offset:     0  *  c-argdecl-indent:             8  *  c-label-offset:              -8  *  c++-hanging-braces:           1  *  c++-access-specifier-offset: -8  *  c++-empty-arglist-indent:     8  *  c++-friend-offset:            0  * End:  */
end_comment

end_unit

