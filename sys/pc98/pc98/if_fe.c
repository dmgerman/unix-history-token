begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * All Rights Reserved, Copyright (C) Fujitsu Limited 1995  *  * This software may be used, modified, copied, distributed, and sold, in  * both source and binary form provided that the above copyright, these  * terms and the following disclaimer are retained.  The name of the author  * and/or the contributor may not be used to endorse or promote products  * derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND THE CONTRIBUTOR ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR THE CONTRIBUTOR BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION.  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * $Id: if_fe.c,v 1.23 1997/07/21 13:11:04 kato Exp $  *  * Device driver for Fujitsu MB86960A/MB86965A based Ethernet cards.  * To be used with FreeBSD 2.x  * Contributed by M. Sekiguchi.<seki@sysrap.cs.fujitsu.co.jp>  *  * This version is intended to be a generic template for various  * MB86960A/MB86965A based Ethernet cards.  It currently supports  * Fujitsu FMV-180 series for ISA and Allied-Telesis AT1700/RE2000  * series for ISA, as well as Fujitsu MBH10302 PC card.  * There are some currently-  * unused hooks embedded, which are primarily intended to support  * other types of Ethernet cards, but the author is not sure whether  * they are useful.  *  * This version also includes some alignments for  * RE1000/RE1000+/ME1500 support.  It is incomplete, however, since the  * cards are not for AT-compatibles.  (They are for PC98 bus -- a  * proprietary bus architecture available only in Japan.)  Further  * work for PC98 version will be available as a part of FreeBSD(98)  * project.  *  * This software is a derivative work of if_ed.c version 1.56 by David  * Greenman available as a part of FreeBSD 2.0 RELEASE source distribution.  *  * The following lines are retained from the original if_ed.c:  *  * Copyright (C) 1993, David Greenman. This software may be used, modified,  *   copied, distributed, and sold, in both source and binary form provided  *   that the above copyright and these terms are retained. Under no  *   circumstances is the author responsible for the proper functioning  *   of this software, nor does the author assume any responsibility  *   for damages incurred with its use.  */
end_comment

begin_comment
comment|/*  * Modified for Allied-Telesis RE1000 series.  */
end_comment

begin_comment
comment|/*  * TODO:  *  o   To support MBH10304 PC card.  It is another MB8696x based  *      PCMCIA Ethernet card by Fujitsu, which is not compatible with  *      MBH10302.  *  o   To merge FreeBSD(98) efforts into a single source file.  *  o   To support ISA PnP auto configuration for FMV-183/184.  *  o   To reconsider mbuf usage.  *  o   To reconsider transmission buffer usage, including  *      transmission buffer size (currently 4KB x 2) and pros-and-  *      cons of multiple frame transmission.  *  o   To test IPX codes.  */
end_comment

begin_include
include|#
directive|include
file|"fe.h"
end_include

begin_include
include|#
directive|include
file|"bpfilter.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IPX code is not tested.  FIXME.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|IPX
end_ifdef

begin_include
include|#
directive|include
file|<netipx/ipx.h>
end_include

begin_include
include|#
directive|include
file|<netipx/ipx_if.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* To be used with IPv6 package of INRIA.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_comment
comment|/* IPv6 added by shin 96.2.6 */
end_comment

begin_include
include|#
directive|include
file|<netinet/if_ether6.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* XNS code is not tested.  FIXME.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NS
end_ifdef

begin_include
include|#
directive|include
file|<netns/ns.h>
end_include

begin_include
include|#
directive|include
file|<netns/ns_if.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/icu.h>
end_include

begin_comment
comment|/* PCCARD suport */
end_comment

begin_include
include|#
directive|include
file|"card.h"
end_include

begin_if
if|#
directive|if
name|NCARD
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_include
include|#
directive|include
file|<pccard/card.h>
end_include

begin_include
include|#
directive|include
file|<pccard/slot.h>
end_include

begin_include
include|#
directive|include
file|<pccard/driver.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<i386/isa/ic/mb86960.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/if_fereg.h>
end_include

begin_comment
comment|/*  * This version of fe is an ISA device driver.  * Override the following macro to adapt it to another bus.  * (E.g., PC98.)  */
end_comment

begin_define
define|#
directive|define
name|DEVICE
value|struct isa_device
end_define

begin_comment
comment|/*  * Default settings for fe driver specific options.  * They can be set in config file by "options" statements.  */
end_comment

begin_comment
comment|/*  * Debug control.  * 0: No debug at all.  All debug specific codes are stripped off.  * 1: Silent.  No debug messages are logged except emergent ones.  * 2: Brief.  Lair events and/or important information are logged.  * 3: Detailed.  Logs all information which *may* be useful for debugging.  * 4: Trace.  All actions in the driver is logged.  Super verbose.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|FE_DEBUG
end_ifndef

begin_define
define|#
directive|define
name|FE_DEBUG
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Transmit just one packet per a "send" command to 86960.  * This option is intended for performance test.  An EXPERIMENTAL option.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|FE_SINGLE_TRANSMISSION
end_ifndef

begin_define
define|#
directive|define
name|FE_SINGLE_TRANSMISSION
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Device configuration flags.  */
end_comment

begin_comment
comment|/* DLCR6 settings.  */
end_comment

begin_define
define|#
directive|define
name|FE_FLAGS_DLCR6_VALUE
value|0x007F
end_define

begin_comment
comment|/* Force DLCR6 override.  */
end_comment

begin_define
define|#
directive|define
name|FE_FLAGS_OVERRIDE_DLCR6
value|0x0080
end_define

begin_comment
comment|/* Shouldn't these be defined somewhere else such as isa_device.h?  */
end_comment

begin_define
define|#
directive|define
name|NO_IOADDR
value|(-1)
end_define

begin_define
define|#
directive|define
name|NO_IRQ
value|0
end_define

begin_comment
comment|/*  * Data type for a multicast address filter on 8696x.  */
end_comment

begin_struct
struct|struct
name|fe_filter
block|{
name|u_char
name|data
index|[
name|FE_FILTER_LEN
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Special filter values.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|fe_filter
specifier|const
name|fe_filter_nothing
init|=
block|{
name|FE_FILTER_NOTHING
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|fe_filter
specifier|const
name|fe_filter_all
init|=
block|{
name|FE_FILTER_ALL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* How many registers does an fe-supported adapter have at maximum?  */
end_comment

begin_define
define|#
directive|define
name|MAXREGISTERS
value|32
end_define

begin_comment
comment|/*  * fe_softc: per line info and status  */
end_comment

begin_struct
specifier|static
struct|struct
name|fe_softc
block|{
comment|/* Used by "common" codes.  */
name|struct
name|arpcom
name|arpcom
decl_stmt|;
comment|/* Ethernet common */
comment|/* Used by config codes.  */
comment|/* Set by probe() and not modified in later phases.  */
name|char
modifier|*
name|typestr
decl_stmt|;
comment|/* printable name of the interface.  */
name|u_short
name|iobase
decl_stmt|;
comment|/* base I/O address of the adapter.  */
name|u_short
name|ioaddr
index|[
name|MAXREGISTERS
index|]
decl_stmt|;
comment|/* I/O addresses of register.  */
name|u_short
name|txb_size
decl_stmt|;
comment|/* size of TX buffer, in bytes  */
name|u_char
name|proto_dlcr4
decl_stmt|;
comment|/* DLCR4 prototype.  */
name|u_char
name|proto_dlcr5
decl_stmt|;
comment|/* DLCR5 prototype.  */
name|u_char
name|proto_dlcr6
decl_stmt|;
comment|/* DLCR6 prototype.  */
name|u_char
name|proto_dlcr7
decl_stmt|;
comment|/* DLCR7 prototype.  */
name|u_char
name|proto_bmpr13
decl_stmt|;
comment|/* BMPR13 prototype.  */
name|u_char
name|proto_bmpr14
decl_stmt|;
comment|/* BMPR14 prototype.  */
comment|/* Vendor specific hooks.  */
name|void
function_decl|(
modifier|*
name|init
function_decl|)
parameter_list|(
name|struct
name|fe_softc
modifier|*
parameter_list|)
function_decl|;
comment|/* Just before fe_init().  */
name|void
function_decl|(
modifier|*
name|stop
function_decl|)
parameter_list|(
name|struct
name|fe_softc
modifier|*
parameter_list|)
function_decl|;
comment|/* Just after fe_stop().  */
comment|/* Transmission buffer management.  */
name|u_short
name|txb_free
decl_stmt|;
comment|/* free bytes in TX buffer  */
name|u_char
name|txb_count
decl_stmt|;
comment|/* number of packets in TX buffer  */
name|u_char
name|txb_sched
decl_stmt|;
comment|/* number of scheduled packets  */
comment|/* Excessive collision counter (see fe_tint() for details.  */
name|u_char
name|tx_excolls
decl_stmt|;
comment|/* # of excessive collisions.  */
comment|/* Multicast address filter management.  */
name|u_char
name|filter_change
decl_stmt|;
comment|/* MARs must be changed ASAP. */
name|struct
name|fe_filter
name|filter
decl_stmt|;
comment|/* new filter value.  */
block|}
name|fe_softc
index|[
name|NFE
index|]
struct|;
end_struct

begin_define
define|#
directive|define
name|sc_if
value|arpcom.ac_if
end_define

begin_define
define|#
directive|define
name|sc_unit
value|arpcom.ac_if.if_unit
end_define

begin_define
define|#
directive|define
name|sc_enaddr
value|arpcom.ac_enaddr
end_define

begin_comment
comment|/* Standard driver entry points.  These can be static.  */
end_comment

begin_function_decl
specifier|static
name|int
name|fe_probe
parameter_list|(
name|struct
name|isa_device
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fe_attach
parameter_list|(
name|struct
name|isa_device
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fe_init
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fe_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|int
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fe_start
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fe_reset
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fe_watchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Local functions.  Order of declaration is confused.  FIXME.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PC98
end_ifdef

begin_function_decl
specifier|static
name|int
name|fe_probe_re1000
parameter_list|(
name|DEVICE
modifier|*
parameter_list|,
name|struct
name|fe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fe_probe_re1000p
parameter_list|(
name|DEVICE
modifier|*
parameter_list|,
name|struct
name|fe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fe_probe_cnet9ne
parameter_list|(
name|DEVICE
modifier|*
parameter_list|,
name|struct
name|fe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fe_probe_cnet98p2
parameter_list|(
name|DEVICE
modifier|*
parameter_list|,
name|struct
name|fe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|static
name|int
name|fe_probe_fmv
parameter_list|(
name|DEVICE
modifier|*
parameter_list|,
name|struct
name|fe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fe_probe_ati
parameter_list|(
name|DEVICE
modifier|*
parameter_list|,
name|struct
name|fe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fe_init_ati
parameter_list|(
name|struct
name|fe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PC98 */
end_comment

begin_function_decl
specifier|static
name|int
name|fe_probe_gwy
parameter_list|(
name|DEVICE
modifier|*
parameter_list|,
name|struct
name|fe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|NCARD
operator|>
literal|0
end_if

begin_function_decl
specifier|static
name|int
name|fe_probe_mbh
parameter_list|(
name|DEVICE
modifier|*
parameter_list|,
name|struct
name|fe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fe_init_mbh
parameter_list|(
name|struct
name|fe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fe_probe_tdk
parameter_list|(
name|DEVICE
modifier|*
parameter_list|,
name|struct
name|fe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|fe_get_packet
parameter_list|(
name|struct
name|fe_softc
modifier|*
parameter_list|,
name|u_short
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fe_stop
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fe_tint
parameter_list|(
name|struct
name|fe_softc
modifier|*
parameter_list|,
name|u_char
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fe_rint
parameter_list|(
name|struct
name|fe_softc
modifier|*
parameter_list|,
name|u_char
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fe_xmit
parameter_list|(
name|struct
name|fe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fe_emptybuffer
parameter_list|(
name|struct
name|fe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fe_write_mbufs
parameter_list|(
name|struct
name|fe_softc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|fe_filter
name|fe_mcaf
parameter_list|(
name|struct
name|fe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fe_hash
parameter_list|(
name|u_char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fe_setmode
parameter_list|(
name|struct
name|fe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fe_loadmar
parameter_list|(
name|struct
name|fe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|FE_DEBUG
operator|>=
literal|1
end_if

begin_function_decl
specifier|static
name|void
name|fe_dump
parameter_list|(
name|int
parameter_list|,
name|struct
name|fe_softc
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Driver struct used in the config code.  This must be public (external.)  */
end_comment

begin_decl_stmt
name|struct
name|isa_driver
name|fedriver
init|=
block|{
name|fe_probe
block|,
name|fe_attach
block|,
literal|"fe"
block|,
literal|1
comment|/* It's safe to mark as "sensitive"  */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Fe driver specific constants which relate to 86960/86965.  */
end_comment

begin_comment
comment|/* Interrupt masks  */
end_comment

begin_define
define|#
directive|define
name|FE_TMASK
value|( FE_D2_COLL16 | FE_D2_TXDONE )
end_define

begin_define
define|#
directive|define
name|FE_RMASK
value|( FE_D3_OVRFLO | FE_D3_CRCERR \ 		 | FE_D3_ALGERR | FE_D3_SRTPKT | FE_D3_PKTRDY )
end_define

begin_comment
comment|/* Maximum number of iterations for a receive interrupt.  */
end_comment

begin_define
define|#
directive|define
name|FE_MAX_RECV_COUNT
value|( ( 65536 - 2048 * 2 ) / 64 )
end_define

begin_comment
comment|/* 	 * Maximum size of SRAM is 65536, 	 * minimum size of transmission buffer in fe is 2x2KB, 	 * and minimum amount of received packet including headers 	 * added by the chip is 64 bytes. 	 * Hence FE_MAX_RECV_COUNT is the upper limit for number 	 * of packets in the receive buffer. 	 */
end_comment

begin_comment
comment|/*  * Routines to access contiguous I/O ports.  */
end_comment

begin_function
specifier|static
name|void
name|inblk
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|,
name|int
name|offs
parameter_list|,
name|u_char
modifier|*
name|mem
parameter_list|,
name|int
name|len
parameter_list|)
block|{
while|while
condition|(
operator|--
name|len
operator|>=
literal|0
condition|)
block|{
operator|*
name|mem
operator|++
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|offs
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|outblk
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|,
name|int
name|offs
parameter_list|,
name|u_char
specifier|const
modifier|*
name|mem
parameter_list|,
name|int
name|len
parameter_list|)
block|{
while|while
condition|(
operator|--
name|len
operator|>=
literal|0
condition|)
block|{
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|offs
operator|++
index|]
argument_list|,
operator|*
name|mem
operator|++
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* PCCARD Support */
end_comment

begin_if
if|#
directive|if
name|NCARD
operator|>
literal|0
end_if

begin_comment
comment|/*  *      PC-Card (PCMCIA) specific code.  */
end_comment

begin_function_decl
specifier|static
name|int
name|feinit
parameter_list|(
name|struct
name|pccard_devinfo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* init device */
end_comment

begin_function_decl
specifier|static
name|void
name|feunload
parameter_list|(
name|struct
name|pccard_devinfo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Disable driver */
end_comment

begin_function_decl
specifier|static
name|int
name|fe_card_intr
parameter_list|(
name|struct
name|pccard_devinfo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Interrupt handler */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|pccard_device
name|fe_info
init|=
block|{
literal|"fe"
block|,
name|feinit
block|,
name|feunload
block|,
name|fe_card_intr
block|,
literal|0
block|,
comment|/* Attributes - presently unused */
operator|&
name|net_imask
comment|/* Interrupt mask for device */
comment|/* XXX - Should this also include net_imask? */
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DATA_SET
argument_list|(
name|pccarddrv_set
argument_list|,
name|fe_info
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  *	Initialize the device - called from Slot manager.  */
end_comment

begin_function
specifier|static
name|int
name|feinit
parameter_list|(
name|struct
name|pccard_devinfo
modifier|*
name|devi
parameter_list|)
block|{
name|struct
name|fe_softc
modifier|*
name|sc
decl_stmt|;
comment|/* validate unit number. */
if|if
condition|(
name|devi
operator|->
name|isahd
operator|.
name|id_unit
operator|>=
name|NFE
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
comment|/* 	 * Probe the device. If a value is returned, 	 * the device was found at the location. 	 */
if|#
directive|if
name|FE_DEBUG
operator|>=
literal|2
name|printf
argument_list|(
literal|"Start Probe\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Initialize "minimum" parts of our softc.  */
name|sc
operator|=
operator|&
name|fe_softc
index|[
name|devi
operator|->
name|isahd
operator|.
name|id_unit
index|]
expr_stmt|;
name|sc
operator|->
name|sc_unit
operator|=
name|devi
operator|->
name|isahd
operator|.
name|id_unit
expr_stmt|;
name|sc
operator|->
name|iobase
operator|=
name|devi
operator|->
name|isahd
operator|.
name|id_iobase
expr_stmt|;
comment|/* Use Ethernet address got from CIS, if one is available.  */
if|if
condition|(
operator|(
name|devi
operator|->
name|misc
index|[
literal|0
index|]
operator|&
literal|0x03
operator|)
operator|==
literal|0x00
operator|&&
operator|(
name|devi
operator|->
name|misc
index|[
literal|0
index|]
operator||
name|devi
operator|->
name|misc
index|[
literal|1
index|]
operator||
name|devi
operator|->
name|misc
index|[
literal|2
index|]
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Yes, it looks like a valid Ether address.  */
name|bcopy
argument_list|(
name|devi
operator|->
name|misc
argument_list|,
name|sc
operator|->
name|sc_enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Indicate we have no Ether address in CIS.  */
name|bzero
argument_list|(
name|sc
operator|->
name|sc_enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
block|}
comment|/* Probe supported PC card models.  */
if|if
condition|(
name|fe_probe_tdk
argument_list|(
operator|&
name|devi
operator|->
name|isahd
argument_list|,
name|sc
argument_list|)
operator|==
literal|0
operator|&&
name|fe_probe_mbh
argument_list|(
operator|&
name|devi
operator|->
name|isahd
argument_list|,
name|sc
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|#
directive|if
name|FE_DEBUG
operator|>=
literal|2
name|printf
argument_list|(
literal|"Start attach\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|fe_attach
argument_list|(
operator|&
name|devi
operator|->
name|isahd
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	feunload - unload the driver and clear the table.  *	XXX TODO:  *	This is usually called when the card is ejected, but  *	can be caused by a modunload of a controller driver.  *	The idea is to reset the driver's view of the device  *	and ensure that any driver entry points such as  *	read and write do not hang.  */
end_comment

begin_function
specifier|static
name|void
name|feunload
parameter_list|(
name|struct
name|pccard_devinfo
modifier|*
name|devi
parameter_list|)
block|{
name|struct
name|fe_softc
modifier|*
name|sc
init|=
operator|&
name|fe_softc
index|[
name|devi
operator|->
name|isahd
operator|.
name|id_unit
index|]
decl_stmt|;
name|printf
argument_list|(
literal|"fe%d: unload\n"
argument_list|,
name|devi
operator|->
name|isahd
operator|.
name|id_unit
argument_list|)
expr_stmt|;
name|fe_stop
argument_list|(
name|devi
operator|->
name|isahd
operator|.
name|id_unit
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	fe_card_intr - Shared interrupt called from  *	 front end of PC-Card handler.  */
end_comment

begin_function
specifier|static
name|int
name|fe_card_intr
parameter_list|(
name|struct
name|pccard_devinfo
modifier|*
name|devi
parameter_list|)
block|{
name|feintr
argument_list|(
name|devi
operator|->
name|isahd
operator|.
name|id_unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NCARD> 0 */
end_comment

begin_comment
comment|/*  * Hardware probe routines.  */
end_comment

begin_comment
comment|/* How and where to probe; to support automatic I/O address detection.  */
end_comment

begin_struct
struct|struct
name|fe_probe_list
block|{
name|int
function_decl|(
modifier|*
name|probe
function_decl|)
parameter_list|(
name|DEVICE
modifier|*
parameter_list|,
name|struct
name|fe_softc
modifier|*
parameter_list|)
function_decl|;
name|u_short
specifier|const
modifier|*
name|addresses
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Lists of possible addresses.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PC98
end_ifdef

begin_decl_stmt
specifier|static
name|u_short
specifier|const
name|fe_re1000_addr
index|[]
init|=
block|{
literal|0x0D0
block|,
literal|0x0D2
block|,
literal|0x0D4
block|,
literal|0x0D6
block|,
literal|0x0D8
block|,
literal|0x0DA
block|,
literal|0x0DC
block|,
literal|0x0DE
block|,
literal|0x1D0
block|,
literal|0x1D2
block|,
literal|0x1D4
block|,
literal|0x1D6
block|,
literal|0x1D8
block|,
literal|0x1DA
block|,
literal|0x1DC
block|,
literal|0x1DE
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_short
specifier|const
name|fe_re1000p_addr
index|[]
init|=
block|{
literal|0x0D0
block|,
literal|0x0D2
block|,
literal|0x0D4
block|,
literal|0x0D8
block|,
literal|0x1D4
block|,
literal|0x1D6
block|,
literal|0x1D8
block|,
literal|0x1DA
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_short
specifier|const
name|fe_cnet9ne_addr
index|[]
init|=
block|{
literal|0x73D0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_short
specifier|const
name|fe_cnet98p2_addr
index|[]
init|=
block|{
literal|0x03D0
block|,
literal|0x13D0
block|,
literal|0x23D0
block|,
literal|0x33D0
block|,
literal|0x43D0
block|,
literal|0x53D0
block|,
literal|0x63D0
block|,
literal|0x73D0
block|,
literal|0x83D0
block|,
literal|0x93D0
block|,
literal|0xA3D0
block|,
literal|0xB3D0
block|,
literal|0xC3D0
block|,
literal|0xD3D0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|u_short
specifier|const
name|fe_fmv_addr
index|[]
init|=
block|{
literal|0x220
block|,
literal|0x240
block|,
literal|0x260
block|,
literal|0x280
block|,
literal|0x2A0
block|,
literal|0x2C0
block|,
literal|0x300
block|,
literal|0x340
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_short
specifier|const
name|fe_ati_addr
index|[]
init|=
block|{
literal|0x240
block|,
literal|0x260
block|,
literal|0x280
block|,
literal|0x2A0
block|,
literal|0x300
block|,
literal|0x320
block|,
literal|0x340
block|,
literal|0x380
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|fe_probe_list
specifier|const
name|fe_probe_list
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|PC98
block|{
name|fe_probe_re1000
block|,
name|fe_re1000_addr
block|}
block|,
block|{
name|fe_probe_re1000p
block|,
name|fe_re1000p_addr
block|}
block|,
comment|/* XXX: We must probe C-NET(98)P2 after C-NET(9N)E. */
block|{
name|fe_probe_cnet9ne
block|,
name|fe_cnet9ne_addr
block|}
block|,
block|{
name|fe_probe_cnet98p2
block|,
name|fe_cnet98p2_addr
block|}
block|,
else|#
directive|else
block|{
name|fe_probe_fmv
block|,
name|fe_fmv_addr
block|}
block|,
block|{
name|fe_probe_ati
block|,
name|fe_ati_addr
block|}
block|,
endif|#
directive|endif
block|{
name|fe_probe_gwy
block|,
name|NULL
block|}
block|,
comment|/* GWYs cannot be auto detected.  */
block|{
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Determine if the device is present  *  *   on entry:  * 	a pointer to an isa_device struct  *   on exit:  *	zero if device not found  *	or number of i/o addresses used (if found)  */
end_comment

begin_function
specifier|static
name|int
name|fe_probe
parameter_list|(
name|DEVICE
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|fe_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|u
decl_stmt|;
name|int
name|nports
decl_stmt|;
name|struct
name|fe_probe_list
specifier|const
modifier|*
name|list
decl_stmt|;
name|u_short
specifier|const
modifier|*
name|addr
decl_stmt|;
name|u_short
name|single
index|[
literal|2
index|]
decl_stmt|;
comment|/* Initialize "minimum" parts of our softc.  */
name|sc
operator|=
operator|&
name|fe_softc
index|[
name|dev
operator|->
name|id_unit
index|]
expr_stmt|;
name|sc
operator|->
name|sc_unit
operator|=
name|dev
operator|->
name|id_unit
expr_stmt|;
comment|/* TODO: Should be in each probe routines */
name|sc
operator|->
name|proto_bmpr14
operator|=
literal|0
expr_stmt|;
comment|/* Probe each possibility, one at a time.  */
for|for
control|(
name|list
operator|=
name|fe_probe_list
init|;
name|list
operator|->
name|probe
operator|!=
name|NULL
condition|;
name|list
operator|++
control|)
block|{
if|if
condition|(
name|dev
operator|->
name|id_iobase
operator|!=
name|NO_IOADDR
condition|)
block|{
comment|/* Probe one specific address.  */
name|single
index|[
literal|0
index|]
operator|=
name|dev
operator|->
name|id_iobase
expr_stmt|;
name|single
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|addr
operator|=
name|single
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|list
operator|->
name|addresses
operator|!=
name|NULL
condition|)
block|{
comment|/* Auto detect.  */
name|addr
operator|=
name|list
operator|->
name|addresses
expr_stmt|;
block|}
else|else
block|{
comment|/* We need a list of addresses to do auto detect.  */
continue|continue;
block|}
comment|/* Probe all possible addresses for the board.  */
while|while
condition|(
operator|*
name|addr
operator|!=
literal|0
condition|)
block|{
comment|/* See if the address is already in use.  */
for|for
control|(
name|u
operator|=
literal|0
init|;
name|u
operator|<
name|NFE
condition|;
name|u
operator|++
control|)
block|{
if|if
condition|(
name|fe_softc
index|[
name|u
index|]
operator|.
name|iobase
operator|==
operator|*
name|addr
condition|)
break|break;
block|}
if|#
directive|if
name|FE_DEBUG
operator|>=
literal|3
if|if
condition|(
name|u
operator|==
name|NFE
condition|)
block|{
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"fe%d: probing %d at 0x%x\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|list
operator|-
name|fe_probe_list
argument_list|,
operator|*
name|addr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|u
operator|==
name|sc
operator|->
name|sc_unit
condition|)
block|{
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"fe%d: re-probing %d at 0x%x?\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|list
operator|-
name|fe_probe_list
argument_list|,
operator|*
name|addr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"fe%d: skipping %d at 0x%x\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|list
operator|-
name|fe_probe_list
argument_list|,
operator|*
name|addr
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Probe the address if it is free.  */
if|if
condition|(
name|u
operator|==
name|NFE
operator|||
name|u
operator|==
name|sc
operator|->
name|sc_unit
condition|)
block|{
comment|/* Probe an address.  */
name|sc
operator|->
name|iobase
operator|=
operator|*
name|addr
expr_stmt|;
name|nports
operator|=
name|list
operator|->
name|probe
argument_list|(
name|dev
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|nports
operator|>
literal|0
condition|)
block|{
comment|/* Found.  */
name|dev
operator|->
name|id_iobase
operator|=
operator|*
name|addr
expr_stmt|;
return|return
operator|(
name|nports
operator|)
return|;
block|}
name|sc
operator|->
name|iobase
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Try next.  */
name|addr
operator|++
expr_stmt|;
block|}
block|}
comment|/* Probe failed.  */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check for specific bits in specific registers have specific values.  */
end_comment

begin_struct
struct|struct
name|fe_simple_probe_struct
block|{
name|u_char
name|port
decl_stmt|;
comment|/* Offset from the base I/O address.  */
name|u_char
name|mask
decl_stmt|;
comment|/* Bits to be checked.  */
name|u_char
name|bits
decl_stmt|;
comment|/* Values to be compared against.  */
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|fe_simple_probe
parameter_list|(
name|struct
name|fe_softc
specifier|const
modifier|*
name|sc
parameter_list|,
name|struct
name|fe_simple_probe_struct
specifier|const
modifier|*
name|sp
parameter_list|)
block|{
name|struct
name|fe_simple_probe_struct
specifier|const
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|sp
init|;
name|p
operator|->
name|mask
operator|!=
literal|0
condition|;
name|p
operator|++
control|)
block|{
if|#
directive|if
name|FE_DEBUG
operator|>=
literal|2
name|printf
argument_list|(
literal|"Probe Port:%x,Value:%x,Mask:%x.Bits:%x\n"
argument_list|,
name|p
operator|->
name|port
argument_list|,
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|p
operator|->
name|port
index|]
argument_list|)
argument_list|,
name|p
operator|->
name|mask
argument_list|,
name|p
operator|->
name|bits
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|p
operator|->
name|port
index|]
argument_list|)
operator|&
name|p
operator|->
name|mask
operator|)
operator|!=
name|p
operator|->
name|bits
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Routines to read all bytes from the config EEPROM through MB86965A.  * I'm not sure what exactly I'm doing here...  I was told just to follow  * the steps, and it worked.  Could someone tell me why the following  * code works?  (Or, why all similar codes I tried previously doesn't  * work.)  FIXME.  */
end_comment

begin_function
specifier|static
name|void
name|fe_strobe_eeprom
parameter_list|(
name|u_short
name|bmpr16
parameter_list|)
block|{
comment|/* 	 * We must guarantee 800ns (or more) interval to access slow 	 * EEPROMs.  The following redundant code provides enough 	 * delay with ISA timing.  (Even if the bus clock is "tuned.") 	 * Some modification will be needed on faster busses. 	 */
name|outb
argument_list|(
name|bmpr16
argument_list|,
name|FE_B16_SELECT
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|bmpr16
argument_list|,
name|FE_B16_SELECT
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|bmpr16
argument_list|,
name|FE_B16_SELECT
operator||
name|FE_B16_CLOCK
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|bmpr16
argument_list|,
name|FE_B16_SELECT
operator||
name|FE_B16_CLOCK
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|bmpr16
argument_list|,
name|FE_B16_SELECT
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|bmpr16
argument_list|,
name|FE_B16_SELECT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fe_read_eeprom
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|,
name|u_char
modifier|*
name|data
parameter_list|)
block|{
name|u_short
name|bmpr16
init|=
name|sc
operator|->
name|ioaddr
index|[
name|FE_BMPR16
index|]
decl_stmt|;
name|u_short
name|bmpr17
init|=
name|sc
operator|->
name|ioaddr
index|[
name|FE_BMPR17
index|]
decl_stmt|;
name|u_char
name|n
decl_stmt|,
name|val
decl_stmt|,
name|bit
decl_stmt|;
comment|/* Read bytes from EEPROM; two bytes per an iteration.  */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|FE_EEPROM_SIZE
operator|/
literal|2
condition|;
name|n
operator|++
control|)
block|{
comment|/* Reset the EEPROM interface.  */
name|outb
argument_list|(
name|bmpr16
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|bmpr17
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* Start EEPROM access.  */
name|outb
argument_list|(
name|bmpr16
argument_list|,
name|FE_B16_SELECT
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|bmpr17
argument_list|,
name|FE_B17_DATA
argument_list|)
expr_stmt|;
name|fe_strobe_eeprom
argument_list|(
name|bmpr16
argument_list|)
expr_stmt|;
comment|/* Pass the iteration count to the chip.  */
name|val
operator|=
literal|0x80
operator||
name|n
expr_stmt|;
for|for
control|(
name|bit
operator|=
literal|0x80
init|;
name|bit
operator|!=
literal|0x00
condition|;
name|bit
operator|>>=
literal|1
control|)
block|{
name|outb
argument_list|(
name|bmpr17
argument_list|,
operator|(
name|val
operator|&
name|bit
operator|)
condition|?
name|FE_B17_DATA
else|:
literal|0
argument_list|)
expr_stmt|;
name|fe_strobe_eeprom
argument_list|(
name|bmpr16
argument_list|)
expr_stmt|;
block|}
name|outb
argument_list|(
name|bmpr17
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* Read a byte.  */
name|val
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|bit
operator|=
literal|0x80
init|;
name|bit
operator|!=
literal|0x00
condition|;
name|bit
operator|>>=
literal|1
control|)
block|{
name|fe_strobe_eeprom
argument_list|(
name|bmpr16
argument_list|)
expr_stmt|;
if|if
condition|(
name|inb
argument_list|(
name|bmpr17
argument_list|)
operator|&
name|FE_B17_DATA
condition|)
block|{
name|val
operator||=
name|bit
expr_stmt|;
block|}
block|}
operator|*
name|data
operator|++
operator|=
name|val
expr_stmt|;
comment|/* Read one more byte.  */
name|val
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|bit
operator|=
literal|0x80
init|;
name|bit
operator|!=
literal|0x00
condition|;
name|bit
operator|>>=
literal|1
control|)
block|{
name|fe_strobe_eeprom
argument_list|(
name|bmpr16
argument_list|)
expr_stmt|;
if|if
condition|(
name|inb
argument_list|(
name|bmpr17
argument_list|)
operator|&
name|FE_B17_DATA
condition|)
block|{
name|val
operator||=
name|bit
expr_stmt|;
block|}
block|}
operator|*
name|data
operator|++
operator|=
name|val
expr_stmt|;
block|}
comment|/* Reset the EEPROM interface, again.  */
name|outb
argument_list|(
name|bmpr16
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|bmpr17
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
if|#
directive|if
name|FE_DEBUG
operator|>=
literal|3
comment|/* Report what we got.  */
name|data
operator|-=
name|FE_EEPROM_SIZE
expr_stmt|;
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"fe%d: EEPROM:"
literal|" %02x%02x%02x%02x %02x%02x%02x%02x -"
literal|" %02x%02x%02x%02x %02x%02x%02x%02x -"
literal|" %02x%02x%02x%02x %02x%02x%02x%02x -"
literal|" %02x%02x%02x%02x %02x%02x%02x%02x\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|data
index|[
literal|0
index|]
argument_list|,
name|data
index|[
literal|1
index|]
argument_list|,
name|data
index|[
literal|2
index|]
argument_list|,
name|data
index|[
literal|3
index|]
argument_list|,
name|data
index|[
literal|4
index|]
argument_list|,
name|data
index|[
literal|5
index|]
argument_list|,
name|data
index|[
literal|6
index|]
argument_list|,
name|data
index|[
literal|7
index|]
argument_list|,
name|data
index|[
literal|8
index|]
argument_list|,
name|data
index|[
literal|9
index|]
argument_list|,
name|data
index|[
literal|10
index|]
argument_list|,
name|data
index|[
literal|11
index|]
argument_list|,
name|data
index|[
literal|12
index|]
argument_list|,
name|data
index|[
literal|13
index|]
argument_list|,
name|data
index|[
literal|14
index|]
argument_list|,
name|data
index|[
literal|15
index|]
argument_list|,
name|data
index|[
literal|16
index|]
argument_list|,
name|data
index|[
literal|17
index|]
argument_list|,
name|data
index|[
literal|18
index|]
argument_list|,
name|data
index|[
literal|19
index|]
argument_list|,
name|data
index|[
literal|20
index|]
argument_list|,
name|data
index|[
literal|21
index|]
argument_list|,
name|data
index|[
literal|22
index|]
argument_list|,
name|data
index|[
literal|23
index|]
argument_list|,
name|data
index|[
literal|24
index|]
argument_list|,
name|data
index|[
literal|25
index|]
argument_list|,
name|data
index|[
literal|26
index|]
argument_list|,
name|data
index|[
literal|27
index|]
argument_list|,
name|data
index|[
literal|28
index|]
argument_list|,
name|data
index|[
literal|29
index|]
argument_list|,
name|data
index|[
literal|30
index|]
argument_list|,
name|data
index|[
literal|31
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Hardware (vendor) specific probe routines.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PC98
end_ifdef

begin_comment
comment|/*  * Probe and initialization for Allied-Telesis RE1000 series.  */
end_comment

begin_function
specifier|static
name|int
name|fe_probe_re1000
parameter_list|(
name|DEVICE
modifier|*
name|isa_dev
parameter_list|,
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|int
name|dlcr6
decl_stmt|,
name|dlcr7
decl_stmt|;
name|u_char
name|c
init|=
literal|0
decl_stmt|;
specifier|static
name|u_short
specifier|const
name|irqmap
index|[
literal|4
index|]
init|=
block|{
name|IRQ3
block|,
name|IRQ5
block|,
name|IRQ6
block|,
name|IRQ12
block|}
decl_stmt|;
if|#
directive|if
name|FE_DEBUG
operator|>=
literal|3
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"fe%d: probe (0x%x) for RE1000\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|sc
operator|->
name|iobase
argument_list|)
expr_stmt|;
name|fe_dump
argument_list|(
name|LOG_INFO
argument_list|,
name|sc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Setup an I/O address mapping table.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXREGISTERS
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|ioaddr
index|[
name|i
index|]
operator|=
name|sc
operator|->
name|iobase
operator|+
operator|(
name|i
operator|/
literal|2
operator|)
operator|*
literal|0x200
operator|+
operator|(
name|i
operator|%
literal|2
operator|)
expr_stmt|;
block|}
comment|/* 	 * RE1000 does not use 86965 EEPROM interface. 	 */
name|c
operator|^=
name|sc
operator|->
name|sc_enaddr
index|[
literal|0
index|]
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_RE1000_MAC0
index|]
argument_list|)
expr_stmt|;
name|c
operator|^=
name|sc
operator|->
name|sc_enaddr
index|[
literal|1
index|]
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_RE1000_MAC1
index|]
argument_list|)
expr_stmt|;
name|c
operator|^=
name|sc
operator|->
name|sc_enaddr
index|[
literal|2
index|]
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_RE1000_MAC2
index|]
argument_list|)
expr_stmt|;
name|c
operator|^=
name|sc
operator|->
name|sc_enaddr
index|[
literal|3
index|]
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_RE1000_MAC3
index|]
argument_list|)
expr_stmt|;
name|c
operator|^=
name|sc
operator|->
name|sc_enaddr
index|[
literal|4
index|]
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_RE1000_MAC4
index|]
argument_list|)
expr_stmt|;
name|c
operator|^=
name|sc
operator|->
name|sc_enaddr
index|[
literal|5
index|]
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_RE1000_MAC5
index|]
argument_list|)
expr_stmt|;
name|c
operator|^=
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_RE1000_MACCHK
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|sc
operator|->
name|sc_enaddr
index|[
literal|0
index|]
operator|!=
literal|0x00
operator|||
name|sc
operator|->
name|sc_enaddr
index|[
literal|1
index|]
operator|!=
literal|0x00
operator|||
name|sc
operator|->
name|sc_enaddr
index|[
literal|2
index|]
operator|!=
literal|0xF4
condition|)
return|return
literal|0
return|;
comment|/* 	 * check interrupt configure 	 */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|4
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|isa_dev
operator|->
name|id_irq
operator|==
name|irqmap
index|[
name|n
index|]
condition|)
break|break;
block|}
if|if
condition|(
name|n
operator|==
literal|4
condition|)
return|return
literal|0
return|;
comment|/* 	 * set irq 	 */
name|c
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_RE1000_IRQCONF
index|]
argument_list|)
expr_stmt|;
name|c
operator|&=
operator|(
operator|~
name|FE_RE1000_IRQCONF_IRQ
operator|)
expr_stmt|;
name|c
operator||=
operator|(
literal|1
operator|<<
operator|(
name|n
operator|+
name|FE_RE1000_IRQCONF_IRQSHIFT
operator|)
operator|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_RE1000_IRQCONF
index|]
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|sc
operator|->
name|typestr
operator|=
literal|"RE1000"
expr_stmt|;
comment|/* 	 * Program the 86965 as follows: 	 *	SRAM: 32KB, 100ns, byte-wide access. 	 *	Transmission buffer: 4KB x 2. 	 *	System bus interface: 16 bits. 	 */
name|sc
operator|->
name|proto_dlcr4
operator|=
name|FE_D4_LBC_DISABLE
operator||
name|FE_D4_CNTRL
expr_stmt|;
comment|/* FIXME */
name|sc
operator|->
name|proto_dlcr5
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|proto_dlcr6
operator|=
name|FE_D6_BUFSIZ_32KB
operator||
name|FE_D6_TXBSIZ_2x4KB
operator||
name|FE_D6_BBW_BYTE
operator||
name|FE_D6_SBW_WORD
operator||
name|FE_D6_SRAM_100ns
expr_stmt|;
name|sc
operator|->
name|proto_dlcr7
operator|=
name|FE_D7_BYTSWP_LH
operator||
name|FE_D7_IDENT_EC
expr_stmt|;
name|sc
operator|->
name|proto_bmpr13
operator|=
name|FE_B13_TPTYPE_UTP
operator||
name|FE_B13_PORT_AUTO
expr_stmt|;
if|#
directive|if
name|FE_DEBUG
operator|>=
literal|3
name|fe_dump
argument_list|(
name|LOG_INFO
argument_list|,
name|sc
argument_list|,
literal|"RE1000 found"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Initialize 86965.  */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR6
index|]
argument_list|,
name|sc
operator|->
name|proto_dlcr6
operator||
name|FE_D6_DLC_DISABLE
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
comment|/* Disable all interrupts.  */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR2
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR3
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|FE_DEBUG
operator|>=
literal|3
name|fe_dump
argument_list|(
name|LOG_INFO
argument_list|,
name|sc
argument_list|,
literal|"end of fe_probe_re1000()"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * That's all.  RE1000 occupies 2*16 I/O addresses, by the way. 	 */
return|return
literal|2
return|;
comment|/* ??? */
block|}
end_function

begin_comment
comment|/*  * Probe and initialization for Allied-Telesis RE1000Plus/ME1500 series.  */
end_comment

begin_function
specifier|static
name|int
name|fe_probe_re1000p
parameter_list|(
name|DEVICE
modifier|*
name|isa_dev
parameter_list|,
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|n
decl_stmt|,
name|signature
decl_stmt|;
name|int
name|dlcr6
decl_stmt|,
name|dlcr7
decl_stmt|;
name|u_char
name|eeprom
index|[
name|FE_EEPROM_SIZE
index|]
decl_stmt|;
specifier|static
name|u_short
specifier|const
name|irqmap
index|[
literal|4
index|]
init|=
block|{
name|IRQ3
block|,
name|IRQ5
block|,
name|IRQ6
block|,
name|IRQ12
block|}
decl_stmt|;
specifier|static
name|struct
name|fe_simple_probe_struct
specifier|const
name|probe_signature1
index|[]
init|=
block|{
block|{
name|FE_DLCR0
block|,
literal|0xBF
block|,
literal|0x00
block|}
block|,
block|{
name|FE_DLCR2
block|,
literal|0xFF
block|,
literal|0x00
block|}
block|,
block|{
name|FE_DLCR4
block|,
literal|0x0F
block|,
literal|0x06
block|}
block|,
block|{
name|FE_DLCR6
block|,
literal|0x0F
block|,
literal|0x06
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
specifier|static
name|struct
name|fe_simple_probe_struct
specifier|const
name|probe_signature2
index|[]
init|=
block|{
block|{
name|FE_DLCR1
block|,
literal|0xFF
block|,
literal|0x00
block|}
block|,
block|{
name|FE_DLCR3
block|,
literal|0xFF
block|,
literal|0x00
block|}
block|,
block|{
name|FE_DLCR5
block|,
literal|0xFF
block|,
literal|0x41
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
specifier|static
name|struct
name|fe_simple_probe_struct
specifier|const
name|probe_table
index|[]
init|=
block|{
block|{
name|FE_DLCR2
block|,
literal|0x71
block|,
literal|0x00
block|}
block|,
block|{
name|FE_DLCR4
block|,
literal|0x08
block|,
literal|0x00
block|}
block|,
block|{
name|FE_DLCR5
block|,
literal|0x80
block|,
literal|0x00
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
specifier|static
name|struct
name|fe_simple_probe_struct
specifier|const
name|vendor_code
index|[]
init|=
block|{
block|{
name|FE_DLCR8
block|,
literal|0xFF
block|,
literal|0x00
block|}
block|,
block|{
name|FE_DLCR9
block|,
literal|0xFF
block|,
literal|0x00
block|}
block|,
block|{
name|FE_DLCR10
block|,
literal|0xFF
block|,
literal|0xF4
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
if|#
directive|if
name|FE_DEBUG
operator|>=
literal|3
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"fe%d: probe (0x%x) for RE1000Plus/ME1500\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|sc
operator|->
name|iobase
argument_list|)
expr_stmt|;
name|fe_dump
argument_list|(
name|LOG_INFO
argument_list|,
name|sc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Setup an I/O address mapping table.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|ioaddr
index|[
name|i
index|]
operator|=
name|sc
operator|->
name|iobase
operator|+
operator|(
name|i
operator|/
literal|2
operator|)
operator|*
literal|0x200
operator|+
operator|(
name|i
operator|%
literal|2
operator|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|16
init|;
name|i
operator|<
name|MAXREGISTERS
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|ioaddr
index|[
name|i
index|]
operator|=
name|sc
operator|->
name|iobase
operator|+
name|i
operator|*
literal|0x200
operator|-
literal|0x1000
expr_stmt|;
block|}
comment|/* First, check the "signature" */
name|signature
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fe_simple_probe
argument_list|(
name|sc
argument_list|,
name|probe_signature1
argument_list|)
condition|)
block|{
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR6
index|]
argument_list|,
operator|(
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR6
index|]
argument_list|)
operator|&
literal|0xCF
operator|)
operator||
literal|0x16
argument_list|)
expr_stmt|;
if|if
condition|(
name|fe_simple_probe
argument_list|(
name|sc
argument_list|,
name|probe_signature2
argument_list|)
condition|)
name|signature
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * If the "signature" not detected, 86965 *might* be previously 	 * initialized. So, check the Ethernet address here. 	 * 	 * Allied-Telesis uses 00 00 F4 ?? ?? ??. 	 */
if|if
condition|(
name|signature
operator|==
literal|0
condition|)
block|{
comment|/* Simple check */
if|if
condition|(
operator|!
name|fe_simple_probe
argument_list|(
name|sc
argument_list|,
name|probe_table
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Disable DLC */
name|dlcr6
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR6
index|]
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR6
index|]
argument_list|,
name|dlcr6
operator||
name|FE_D6_DLC_DISABLE
argument_list|)
expr_stmt|;
comment|/* Select register bank for DLCR */
name|dlcr7
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR7
index|]
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR7
index|]
argument_list|,
name|dlcr7
operator|&
literal|0xF3
operator||
name|FE_D7_RBS_DLCR
argument_list|)
expr_stmt|;
comment|/* Check the Ethernet address */
if|if
condition|(
operator|!
name|fe_simple_probe
argument_list|(
name|sc
argument_list|,
name|vendor_code
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Restore configuration registers */
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR6
index|]
argument_list|,
name|dlcr6
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR7
index|]
argument_list|,
name|dlcr7
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * We are now almost sure we have an 86965 at the given 	 * address.  So, read EEPROM through 86965.  We have to write 	 * into LSI registers to read from EEPROM.  I want to avoid it 	 * at this stage, but I cannot test the presense of the chip 	 * any further without reading EEPROM.  FIXME. 	 */
name|fe_read_eeprom
argument_list|(
name|sc
argument_list|,
name|eeprom
argument_list|)
expr_stmt|;
comment|/* Make sure that config info in EEPROM and 86965 agree.  */
if|if
condition|(
name|eeprom
index|[
name|FE_EEPROM_CONF
index|]
operator|!=
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_BMPR19
index|]
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|/* 	 * Initialize constants in the per-line structure. 	 */
comment|/* Get our station address from EEPROM.  */
name|bcopy
argument_list|(
name|eeprom
operator|+
name|FE_ATI_EEP_ADDR
argument_list|,
name|sc
operator|->
name|sc_enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|sc
operator|->
name|typestr
operator|=
literal|"RE1000Plus/ME1500"
expr_stmt|;
comment|/* 	 * Read IRQ configuration. 	 */
name|n
operator|=
operator|(
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_BMPR19
index|]
argument_list|)
operator|&
name|FE_B19_IRQ
operator|)
operator|>>
name|FE_B19_IRQ_SHIFT
expr_stmt|;
name|isa_dev
operator|->
name|id_irq
operator|=
name|irqmap
index|[
name|n
index|]
expr_stmt|;
comment|/* 	 * Program the 86965 as follows: 	 *	SRAM: 32KB, 100ns, byte-wide access. 	 *	Transmission buffer: 4KB x 2. 	 *	System bus interface: 16 bits. 	 */
name|sc
operator|->
name|proto_dlcr4
operator|=
name|FE_D4_LBC_DISABLE
operator||
name|FE_D4_CNTRL
expr_stmt|;
comment|/* FIXME */
name|sc
operator|->
name|proto_dlcr5
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|proto_dlcr6
operator|=
name|FE_D6_BUFSIZ_32KB
operator||
name|FE_D6_TXBSIZ_2x4KB
operator||
name|FE_D6_BBW_BYTE
operator||
name|FE_D6_SBW_WORD
operator||
name|FE_D6_SRAM_100ns
expr_stmt|;
name|sc
operator|->
name|proto_dlcr7
operator|=
name|FE_D7_BYTSWP_LH
operator||
name|FE_D7_IDENT_EC
expr_stmt|;
name|sc
operator|->
name|proto_bmpr13
operator|=
name|FE_B13_TPTYPE_UTP
operator||
name|FE_B13_PORT_AUTO
expr_stmt|;
if|#
directive|if
name|FE_DEBUG
operator|>=
literal|3
name|fe_dump
argument_list|(
name|LOG_INFO
argument_list|,
name|sc
argument_list|,
literal|"RE1000Plus/ME1500 found"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Initialize 86965.  */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR6
index|]
argument_list|,
name|sc
operator|->
name|proto_dlcr6
operator||
name|FE_D6_DLC_DISABLE
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
comment|/* Disable all interrupts.  */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR2
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR3
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|FE_DEBUG
operator|>=
literal|3
name|fe_dump
argument_list|(
name|LOG_INFO
argument_list|,
name|sc
argument_list|,
literal|"end of fe_probe_re1000p()"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * That's all.  RE1000Plus/ME1500 occupies 2*16 I/O addresses, by the way. 	 */
return|return
literal|2
return|;
comment|/* ??? */
block|}
end_function

begin_comment
comment|/*  * Probe and initialization for Contec C-NET(9N)E series.  */
end_comment

begin_comment
comment|/* TODO: Should be in "if_fereg.h" */
end_comment

begin_define
define|#
directive|define
name|FE_CNET9NE_INTR
value|0x10
end_define

begin_comment
comment|/* Interrupt Mask? */
end_comment

begin_define
define|#
directive|define
name|FE_CNET9NE_MAC0
value|0x11
end_define

begin_comment
comment|/* Station(MAC) address */
end_comment

begin_define
define|#
directive|define
name|FE_CNET9NE_MAC1
value|0x13
end_define

begin_define
define|#
directive|define
name|FE_CNET9NE_MAC2
value|0x15
end_define

begin_define
define|#
directive|define
name|FE_CNET9NE_MAC3
value|0x17
end_define

begin_define
define|#
directive|define
name|FE_CNET9NE_MAC4
value|0x19
end_define

begin_define
define|#
directive|define
name|FE_CNET9NE_MAC5
value|0x1B
end_define

begin_comment
comment|/* TODO: Should be in "ic/mb86960.h" */
end_comment

begin_define
define|#
directive|define
name|FE_D7_ENDEC
value|0xC0
end_define

begin_comment
comment|/* Encoder/Decoder mode(86960 only)	*/
end_comment

begin_define
define|#
directive|define
name|FE_D7_ENDEC_NORMAL_NICE
value|0x00
end_define

begin_comment
comment|/* Normal NICE		*/
end_comment

begin_define
define|#
directive|define
name|FE_D7_ENDEC_NICE_MONITOR
value|0x40
end_define

begin_comment
comment|/* NICE + Monitor	*/
end_comment

begin_define
define|#
directive|define
name|FE_D7_ENDEC_BYPASS
value|0x80
end_define

begin_comment
comment|/* Encoder/Decoder Bypass */
end_comment

begin_define
define|#
directive|define
name|FE_D7_ENDEC_TEST
value|0xC0
end_define

begin_comment
comment|/* Encoder/Decoder Test	*/
end_comment

begin_function
specifier|static
name|int
name|fe_probe_cnet9ne
parameter_list|(
name|DEVICE
modifier|*
name|isa_dev
parameter_list|,
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u_char
name|c
decl_stmt|;
if|#
directive|if
name|FE_DEBUG
operator|>=
literal|3
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"fe%d: probe (0x%x) for C-NET(9N)E\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|sc
operator|->
name|iobase
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Setup an I/O address mapping table.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|ioaddr
index|[
name|i
index|]
operator|=
name|sc
operator|->
name|iobase
operator|+
name|i
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
name|MAXREGISTERS
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|ioaddr
index|[
name|i
index|]
operator|=
name|sc
operator|->
name|iobase
operator|+
literal|0x400
operator|-
literal|16
operator|+
name|i
expr_stmt|;
block|}
if|#
directive|if
name|FE_DEBUG
operator|>=
literal|3
name|fe_dump
argument_list|(
name|LOG_INFO
argument_list|,
name|sc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Get our station address from EEPROM. */
name|sc
operator|->
name|sc_enaddr
index|[
literal|0
index|]
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_CNET9NE_MAC0
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_enaddr
index|[
literal|1
index|]
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_CNET9NE_MAC1
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_enaddr
index|[
literal|2
index|]
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_CNET9NE_MAC2
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_enaddr
index|[
literal|3
index|]
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_CNET9NE_MAC3
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_enaddr
index|[
literal|4
index|]
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_CNET9NE_MAC4
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_enaddr
index|[
literal|5
index|]
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_CNET9NE_MAC5
index|]
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
comment|/* 	 * Check the Ethernet address here. 	 * 	 * Contec uses 00 80 4C ?? ?? ??. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_enaddr
index|[
literal|0
index|]
operator|!=
operator|(
name|u_char
operator|)
literal|0x00
operator|||
name|sc
operator|->
name|sc_enaddr
index|[
literal|1
index|]
operator|!=
operator|(
name|u_char
operator|)
literal|0x80
operator|||
name|sc
operator|->
name|sc_enaddr
index|[
literal|2
index|]
operator|!=
operator|(
name|u_char
operator|)
literal|0x4C
condition|)
block|{
else|#
directive|else
comment|/* 	 * Make sure we got a valid Ethernet address. 	 */
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_enaddr
index|[
literal|0
index|]
operator|&
literal|0x03
operator|)
operator|!=
literal|0x00
comment|/* Multicast or Local address. */
operator|||
operator|(
name|sc
operator|->
name|sc_enaddr
index|[
literal|0
index|]
operator||
name|sc
operator|->
name|sc_enaddr
index|[
literal|1
index|]
operator||
name|sc
operator|->
name|sc_enaddr
index|[
literal|2
index|]
operator|)
operator|==
literal|0x00
condition|)
block|{
endif|#
directive|endif
if|#
directive|if
name|FE_DEBUG
operator|>=
literal|3
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"fe%d: invalid MAC adrs(%x:%x:%x:%x:%x:%x)\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
operator|(
name|u_char
operator|)
name|sc
operator|->
name|sc_enaddr
index|[
literal|0
index|]
argument_list|,
operator|(
name|u_char
operator|)
name|sc
operator|->
name|sc_enaddr
index|[
literal|1
index|]
argument_list|,
operator|(
name|u_char
operator|)
name|sc
operator|->
name|sc_enaddr
index|[
literal|2
index|]
argument_list|,
operator|(
name|u_char
operator|)
name|sc
operator|->
name|sc_enaddr
index|[
literal|3
index|]
argument_list|,
operator|(
name|u_char
operator|)
name|sc
operator|->
name|sc_enaddr
index|[
literal|4
index|]
argument_list|,
operator|(
name|u_char
operator|)
name|sc
operator|->
name|sc_enaddr
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
comment|/* See if C-NET(9N)E is on its address. */
if|if
condition|(
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR6
index|]
argument_list|)
operator|==
operator|(
name|u_char
operator|)
literal|0xff
condition|)
block|{
if|#
directive|if
name|FE_DEBUG
operator|>=
literal|3
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"fe%d: inb(%x) returns 0xff\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR6
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
name|sc
operator|->
name|typestr
operator|=
literal|"C-NET9NE"
expr_stmt|;
comment|/* 	 * Program the 86960 as follows: 	 *	SRAM: 64KB, word-wide access. 	 *	Transmission buffer: 4KB x 2. 	 *	System bus interface: 16 bits. 	 *	Encoder/Decoder mode: Normal NICE. 	 * 	 * 86960 manual says that SRAM access-time can't be configured. 	 * (must be 1) 	 */
name|sc
operator|->
name|proto_dlcr4
operator|=
name|FE_D4_LBC_DISABLE
operator||
name|FE_D4_CNTRL
expr_stmt|;
name|sc
operator|->
name|proto_dlcr5
operator|=
name|FE_D5_RMTRST
expr_stmt|;
comment|/* reserved bit(must be 1) */
name|sc
operator|->
name|proto_dlcr6
operator|=
name|FE_D6_BUFSIZ_64KB
operator||
name|FE_D6_TXBSIZ_2x4KB
operator||
name|FE_D6_BBW_WORD
operator||
name|FE_D6_SBW_WORD
operator||
name|FE_D6_SRAM
expr_stmt|;
ifndef|#
directive|ifndef
name|CNET9NC
name|sc
operator|->
name|proto_dlcr7
operator|=
name|FE_D7_BYTSWP_LH
operator||
name|FE_D7_ENDEC_NORMAL_NICE
expr_stmt|;
else|#
directive|else
name|sc
operator|->
name|proto_dlcr7
operator|=
name|FE_D7_BYTSWP_LH
operator||
name|FE_D7_ENDEC_BYPASS
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|proto_bmpr13
operator|=
name|FE_B13_TPTYPE_UTP
operator||
name|FE_B13_PORT_AUTO
expr_stmt|;
name|sc
operator|->
name|proto_bmpr14
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|stop
operator|=
name|sc
operator|->
name|init
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
name|FE_DEBUG
operator|>=
literal|3
name|fe_dump
argument_list|(
name|LOG_INFO
argument_list|,
name|sc
argument_list|,
literal|"C-NET(9N)E found"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Initialize 86960.  */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR6
index|]
argument_list|,
name|sc
operator|->
name|proto_dlcr6
operator||
name|FE_D6_DLC_DISABLE
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
comment|/* XXX: Is this really necessary?  FIXME. */
name|c
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
operator|(
name|u_char
operator|)
literal|0xff
condition|)
block|{
if|#
directive|if
name|FE_DEBUG
operator|>=
literal|3
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"fe%d: inb(%x) returns 0xff\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
name|c
operator|&
name|FE_D1_PKTRDY
operator|)
operator|==
literal|0
condition|)
block|{
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR1
index|]
argument_list|,
name|FE_D1_PKTRDY
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Disable all interrupts.  */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR2
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR3
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|CNET9NC
comment|/* Enable interrupt?  FIXME. */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_CNET9NE_INTR
index|]
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|FE_DEBUG
operator|>=
literal|3
name|fe_dump
argument_list|(
name|LOG_INFO
argument_list|,
name|sc
argument_list|,
literal|"end of fe_probe_cnet9ne()"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * XXX: The I/O address range is fragmented in the CNET(9N)E. 	 *      "16" is the number of regs at iobase. 	 */
return|return
literal|16
return|;
block|}
comment|/*  * Probe and initialization for Contec C-NET(98)P2 series.  */
comment|/*  * Routines to read all bytes from the config EEPROM through TDK 78Q8377A.  * I'm not sure what exactly I'm doing here...  I was told just to follow  * the steps, and it worked.  Could someone tell me why the following  * code works?  FIXME.  */
specifier|static
name|void
name|fe_strobe_eeprom_tdk
parameter_list|(
name|u_short
name|bmpr12
parameter_list|)
block|{
name|outb
argument_list|(
name|bmpr12
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|bmpr12
argument_list|,
literal|0x12
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|bmpr12
argument_list|,
literal|0x12
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|bmpr12
argument_list|,
literal|0x16
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|bmpr12
argument_list|,
literal|0x12
operator||
literal|0x01
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|bmpr12
argument_list|,
literal|0x16
operator||
literal|0x01
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|bmpr12
argument_list|,
literal|0x12
operator||
literal|0x01
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|bmpr12
argument_list|,
literal|0x16
operator||
literal|0x01
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|bmpr12
argument_list|,
literal|0x12
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|bmpr12
argument_list|,
literal|0x16
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|fe_read_eeprom_tdk
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|,
name|u_char
modifier|*
name|data
parameter_list|)
block|{
name|u_short
name|bmpr12
init|=
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR12
index|]
decl_stmt|;
name|u_char
name|n
decl_stmt|,
name|val
decl_stmt|,
name|bit
decl_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR6
index|]
argument_list|,
name|FE_D6_BBW_WORD
operator||
name|FE_D6_SBW_WORD
operator||
name|FE_D6_DLC_DISABLE
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR7
index|]
argument_list|,
name|FE_D7_BYTSWP_LH
operator||
name|FE_D7_RBS_BMPR
operator||
name|FE_D7_RDYPNS
operator||
name|FE_D7_POWER_UP
argument_list|)
expr_stmt|;
comment|/* Read bytes from EEPROM; two bytes per an iteration.  */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|FE_EEPROM_SIZE
operator|/
literal|2
condition|;
name|n
operator|++
control|)
block|{
comment|/* Start EEPROM access.  */
name|fe_strobe_eeprom_tdk
argument_list|(
name|bmpr12
argument_list|)
expr_stmt|;
comment|/* Pass the iteration count to the chip.  */
for|for
control|(
name|bit
operator|=
literal|0x80
init|;
name|bit
operator|!=
literal|0x00
condition|;
name|bit
operator|>>=
literal|1
control|)
block|{
name|val
operator|=
operator|(
name|n
operator|&
name|bit
operator|)
condition|?
literal|0x01
else|:
literal|0x00
expr_stmt|;
name|outb
argument_list|(
name|bmpr12
argument_list|,
literal|0x12
operator||
name|val
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|bmpr12
argument_list|,
literal|0x16
operator||
name|val
argument_list|)
expr_stmt|;
block|}
comment|/* Read a byte.  */
name|val
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|bit
operator|=
literal|0x80
init|;
name|bit
operator|!=
literal|0x00
condition|;
name|bit
operator|>>=
literal|1
control|)
block|{
name|outb
argument_list|(
name|bmpr12
argument_list|,
literal|0x12
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|bmpr12
argument_list|,
literal|0x16
argument_list|)
expr_stmt|;
if|if
condition|(
name|inb
argument_list|(
name|bmpr12
argument_list|)
operator|&
literal|0x01
condition|)
block|{
name|val
operator||=
name|bit
expr_stmt|;
block|}
block|}
operator|*
name|data
operator|++
operator|=
name|val
expr_stmt|;
comment|/* Read one more byte.  */
name|val
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|bit
operator|=
literal|0x80
init|;
name|bit
operator|!=
literal|0x00
condition|;
name|bit
operator|>>=
literal|1
control|)
block|{
name|outb
argument_list|(
name|bmpr12
argument_list|,
literal|0x12
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|bmpr12
argument_list|,
literal|0x16
argument_list|)
expr_stmt|;
if|if
condition|(
name|inb
argument_list|(
name|bmpr12
argument_list|)
operator|&
literal|0x01
condition|)
block|{
name|val
operator||=
name|bit
expr_stmt|;
block|}
block|}
operator|*
name|data
operator|++
operator|=
name|val
expr_stmt|;
name|outb
argument_list|(
name|bmpr12
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
block|}
comment|/* Reset the EEPROM interface.  */
name|outb
argument_list|(
name|bmpr12
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
if|#
directive|if
name|FE_DEBUG
operator|>=
literal|3
comment|/* Report what we got.  */
name|data
operator|-=
name|FE_EEPROM_SIZE
expr_stmt|;
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"fe%d: EEPROM:"
literal|" %02x%02x%02x%02x %02x%02x%02x%02x -"
literal|" %02x%02x%02x%02x %02x%02x%02x%02x -"
literal|" %02x%02x%02x%02x %02x%02x%02x%02x -"
literal|" %02x%02x%02x%02x %02x%02x%02x%02x\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|data
index|[
literal|0
index|]
argument_list|,
name|data
index|[
literal|1
index|]
argument_list|,
name|data
index|[
literal|2
index|]
argument_list|,
name|data
index|[
literal|3
index|]
argument_list|,
name|data
index|[
literal|4
index|]
argument_list|,
name|data
index|[
literal|5
index|]
argument_list|,
name|data
index|[
literal|6
index|]
argument_list|,
name|data
index|[
literal|7
index|]
argument_list|,
name|data
index|[
literal|8
index|]
argument_list|,
name|data
index|[
literal|9
index|]
argument_list|,
name|data
index|[
literal|10
index|]
argument_list|,
name|data
index|[
literal|11
index|]
argument_list|,
name|data
index|[
literal|12
index|]
argument_list|,
name|data
index|[
literal|13
index|]
argument_list|,
name|data
index|[
literal|14
index|]
argument_list|,
name|data
index|[
literal|15
index|]
argument_list|,
name|data
index|[
literal|16
index|]
argument_list|,
name|data
index|[
literal|17
index|]
argument_list|,
name|data
index|[
literal|18
index|]
argument_list|,
name|data
index|[
literal|19
index|]
argument_list|,
name|data
index|[
literal|20
index|]
argument_list|,
name|data
index|[
literal|21
index|]
argument_list|,
name|data
index|[
literal|22
index|]
argument_list|,
name|data
index|[
literal|23
index|]
argument_list|,
name|data
index|[
literal|24
index|]
argument_list|,
name|data
index|[
literal|25
index|]
argument_list|,
name|data
index|[
literal|26
index|]
argument_list|,
name|data
index|[
literal|27
index|]
argument_list|,
name|data
index|[
literal|28
index|]
argument_list|,
name|data
index|[
literal|29
index|]
argument_list|,
name|data
index|[
literal|30
index|]
argument_list|,
name|data
index|[
literal|31
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* TODO: Should be in "if_fereg.h" */
define|#
directive|define
name|FE_CNET98P2_EEP_IRQ
value|(0x04 * 2 + 1)
comment|/* Irq			*/
define|#
directive|define
name|FE_CNET98P2_EEP_ADDR
value|(0x08 * 2)
comment|/* Station(MAC) address	*/
define|#
directive|define
name|FE_CNET98P2_EEP_DUPLEX
value|(0x0c * 2 + 1)
comment|/* Duplex mode		*/
specifier|static
name|int
name|fe_probe_cnet98p2
parameter_list|(
name|DEVICE
modifier|*
name|isa_dev
parameter_list|,
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u_char
name|duplex
decl_stmt|;
name|u_char
name|eeprom
index|[
name|FE_EEPROM_SIZE
index|]
decl_stmt|;
specifier|static
name|u_short
specifier|const
name|irqmap
index|[]
init|=
comment|/*                        INT0          INT1  INT2	*/
block|{
name|NO_IRQ
block|,
name|NO_IRQ
block|,
name|NO_IRQ
block|,
name|IRQ3
block|,
name|NO_IRQ
block|,
name|IRQ5
block|,
name|IRQ6
block|,
name|NO_IRQ
block|,
name|NO_IRQ
block|,
name|IRQ9
block|,
name|IRQ10
block|,
name|NO_IRQ
block|,
name|IRQ12
block|,
name|IRQ13
block|,
name|NO_IRQ
block|,
name|NO_IRQ
block|}
decl_stmt|;
comment|/*        INT3  INT4           INT5   INT6		*/
if|#
directive|if
name|FE_DEBUG
operator|>=
literal|3
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"fe%d: probe (0x%x) for C-NET(98)P2\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|sc
operator|->
name|iobase
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Setup an I/O address mapping table.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|ioaddr
index|[
name|i
index|]
operator|=
name|sc
operator|->
name|iobase
operator|+
name|i
expr_stmt|;
block|}
comment|/* Full unused slots with a safe address. */
for|for
control|(
init|;
name|i
operator|<
name|MAXREGISTERS
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|ioaddr
index|[
name|i
index|]
operator|=
name|sc
operator|->
name|iobase
expr_stmt|;
block|}
if|#
directive|if
name|FE_DEBUG
operator|>=
literal|3
name|fe_dump
argument_list|(
name|LOG_INFO
argument_list|,
name|sc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* See if C-NET(98)P2 is on its address. */
if|if
condition|(
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR0
index|]
argument_list|)
operator|==
operator|(
name|u_char
operator|)
literal|0xff
condition|)
block|{
if|#
directive|if
name|FE_DEBUG
operator|>=
literal|3
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"fe%d: inb(%x) returns 0xff\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR0
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
if|if
condition|(
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR6
index|]
argument_list|)
operator|==
operator|(
name|u_char
operator|)
literal|0xff
condition|)
block|{
if|#
directive|if
name|FE_DEBUG
operator|>=
literal|3
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"fe%d: inb(%x) returns 0xff\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR6
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
comment|/* 	 * We are now almost sure we have a 78Q8377 at the given 	 * address.  So, read EEPROM through 78Q8377.  We have to write 	 * into LSI registers to read from EEPROM.  FIXME. 	 */
name|fe_read_eeprom_tdk
argument_list|(
name|sc
argument_list|,
name|eeprom
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize constants in the per-line structure. 	 */
comment|/* Get our station address from EEPROM.  */
name|bcopy
argument_list|(
name|eeprom
operator|+
name|FE_CNET98P2_EEP_ADDR
argument_list|,
name|sc
operator|->
name|sc_enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
comment|/* 	 * Check the Ethernet address here. 	 * 	 * Contec uses 00 80 4C ?? ?? ??. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_enaddr
index|[
literal|0
index|]
operator|!=
operator|(
name|u_char
operator|)
literal|0x00
operator|||
name|sc
operator|->
name|sc_enaddr
index|[
literal|1
index|]
operator|!=
operator|(
name|u_char
operator|)
literal|0x80
operator|||
name|sc
operator|->
name|sc_enaddr
index|[
literal|2
index|]
operator|!=
operator|(
name|u_char
operator|)
literal|0x4C
condition|)
block|{
else|#
directive|else
comment|/* 	 * Make sure we got a valid Ethernet address. 	 */
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_enaddr
index|[
literal|0
index|]
operator|&
literal|0x03
operator|)
operator|!=
literal|0x00
comment|/* Multicast or Local address. */
operator|||
operator|(
name|sc
operator|->
name|sc_enaddr
index|[
literal|0
index|]
operator||
name|sc
operator|->
name|sc_enaddr
index|[
literal|1
index|]
operator||
name|sc
operator|->
name|sc_enaddr
index|[
literal|2
index|]
operator|)
operator|==
literal|0x00
condition|)
block|{
endif|#
directive|endif
if|#
directive|if
name|FE_DEBUG
operator|>=
literal|3
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"fe%d: invalid MAC adrs(%x:%x:%x:%x:%x:%x)\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
operator|(
name|u_char
operator|)
name|sc
operator|->
name|sc_enaddr
index|[
literal|0
index|]
argument_list|,
operator|(
name|u_char
operator|)
name|sc
operator|->
name|sc_enaddr
index|[
literal|1
index|]
argument_list|,
operator|(
name|u_char
operator|)
name|sc
operator|->
name|sc_enaddr
index|[
literal|2
index|]
argument_list|,
operator|(
name|u_char
operator|)
name|sc
operator|->
name|sc_enaddr
index|[
literal|3
index|]
argument_list|,
operator|(
name|u_char
operator|)
name|sc
operator|->
name|sc_enaddr
index|[
literal|4
index|]
argument_list|,
operator|(
name|u_char
operator|)
name|sc
operator|->
name|sc_enaddr
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
comment|/* 	 * Get IRQ configuration from EEPROM. 	 */
name|isa_dev
operator|->
name|id_irq
operator|=
name|irqmap
index|[
name|eeprom
index|[
name|FE_CNET98P2_EEP_IRQ
index|]
index|]
expr_stmt|;
if|if
condition|(
name|isa_dev
operator|->
name|id_irq
operator|==
name|NO_IRQ
condition|)
block|{
if|#
directive|if
name|FE_DEBUG
operator|>=
literal|3
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"fe%d: invalid irq configuration(%d)\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|eeprom
index|[
name|FE_CNET98P2_EEP_IRQ
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
comment|/* 	 * Get Duplex-mode configuration from EEPROM. 	 */
name|duplex
operator|=
name|eeprom
index|[
name|FE_CNET98P2_EEP_DUPLEX
index|]
operator|&
name|FE_D4_DSC
expr_stmt|;
name|sc
operator|->
name|typestr
operator|=
operator|(
name|duplex
condition|?
literal|"CNET98P2(Full duplex)"
else|:
literal|"CNET98P2(Half duplex)"
operator|)
expr_stmt|;
comment|/* 	 * Program the 78Q8377 as follows: 	 *      SRAM: 32KB, 100ns, byte-wide access. 	 *      Transmission buffer: 4KB x 2. 	 *      System bus interface: 16 bits. 	 * XXX: Should we add IDENT_NICE or IDENT_EC to DLCR7?  FIXME. 	 */
name|sc
operator|->
name|proto_dlcr4
operator|=
name|FE_D4_LBC_DISABLE
operator||
name|FE_D4_CNTRL
operator||
name|duplex
expr_stmt|;
name|sc
operator|->
name|proto_dlcr5
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|proto_dlcr6
operator|=
name|FE_D6_BUFSIZ_32KB
operator||
name|FE_D6_TXBSIZ_2x4KB
operator||
name|FE_D6_BBW_BYTE
operator||
name|FE_D6_SBW_WORD
operator||
name|FE_D6_SRAM_100ns
expr_stmt|;
name|sc
operator|->
name|proto_dlcr7
operator|=
name|FE_D7_BYTSWP_LH
expr_stmt|;
name|sc
operator|->
name|proto_bmpr13
operator|=
name|FE_B13_TPTYPE_UTP
operator||
name|FE_B13_PORT_AUTO
expr_stmt|;
name|sc
operator|->
name|proto_bmpr14
operator|=
name|FE_B14_FILTER
expr_stmt|;
name|sc
operator|->
name|stop
operator|=
name|sc
operator|->
name|init
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
name|FE_DEBUG
operator|>=
literal|3
name|fe_dump
argument_list|(
name|LOG_INFO
argument_list|,
name|sc
argument_list|,
literal|"C-NET(98)P2 found"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Initialize 78Q8377.  */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR6
index|]
argument_list|,
name|sc
operator|->
name|proto_dlcr6
operator||
name|FE_D6_DLC_DISABLE
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
comment|/* Disable all interrupts.  */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR2
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR3
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|FE_DEBUG
operator|>=
literal|3
name|fe_dump
argument_list|(
name|LOG_INFO
argument_list|,
name|sc
argument_list|,
literal|"end of fe_probe_cnet98p2()"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * That's all.  C-NET(98)P2 occupies 16 I/O addresses, as always. 	 */
return|return
literal|16
return|;
block|}
else|#
directive|else
comment|/*  * Probe and initialization for Fujitsu FMV-180 series boards  */
specifier|static
name|int
name|fe_probe_fmv
parameter_list|(
name|DEVICE
modifier|*
name|dev
parameter_list|,
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
specifier|static
name|u_short
specifier|const
name|baseaddr
index|[
literal|8
index|]
init|=
block|{
literal|0x220
block|,
literal|0x240
block|,
literal|0x260
block|,
literal|0x280
block|,
literal|0x2A0
block|,
literal|0x2C0
block|,
literal|0x300
block|,
literal|0x340
block|}
decl_stmt|;
specifier|static
name|u_short
specifier|const
name|irqmap
index|[
literal|4
index|]
init|=
block|{
name|IRQ3
block|,
name|IRQ7
block|,
name|IRQ10
block|,
name|IRQ15
block|}
decl_stmt|;
specifier|static
name|struct
name|fe_simple_probe_struct
specifier|const
name|probe_table
index|[]
init|=
block|{
block|{
name|FE_DLCR2
block|,
literal|0x70
block|,
literal|0x00
block|}
block|,
block|{
name|FE_DLCR4
block|,
literal|0x08
block|,
literal|0x00
block|}
block|,
comment|/*	{ FE_DLCR5, 0x80, 0x00 },	Doesn't work.  */
block|{
name|FE_FMV0
block|,
literal|0x78
block|,
literal|0x50
block|}
block|,
comment|/* ERRDY+PRRDY */
block|{
name|FE_FMV1
block|,
literal|0xB0
block|,
literal|0x00
block|}
block|,
comment|/* FMV-183/184 has 0x48 bits. */
block|{
name|FE_FMV3
block|,
literal|0x7F
block|,
literal|0x00
block|}
block|,
if|#
directive|if
literal|1
comment|/* 	 * Test *vendor* part of the station address for Fujitsu. 	 * The test will gain reliability of probe process, but 	 * it rejects FMV-180 clone boards manufactured by other vendors. 	 * We have to turn the test off when such cards are made available. 	 */
block|{
name|FE_FMV4
block|,
literal|0xFF
block|,
literal|0x00
block|}
block|,
block|{
name|FE_FMV5
block|,
literal|0xFF
block|,
literal|0x00
block|}
block|,
block|{
name|FE_FMV6
block|,
literal|0xFF
block|,
literal|0x0E
block|}
block|,
else|#
directive|else
comment|/* 	 * We can always verify the *first* 2 bits (in Ethernet 	 * bit order) are "no multicast" and "no local" even for 	 * unknown vendors. 	 */
block|{
name|FE_FMV4
block|,
literal|0x03
block|,
literal|0x00
block|}
block|,
endif|#
directive|endif
block|{
literal|0
block|}
block|}
decl_stmt|;
comment|/* "Hardware revision ID"  */
name|int
name|revision
decl_stmt|;
comment|/* 	 * See if the specified address is possible for FMV-180 series. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|baseaddr
index|[
name|i
index|]
operator|==
name|sc
operator|->
name|iobase
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
literal|8
condition|)
return|return
literal|0
return|;
comment|/* Setup an I/O address mapping table.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXREGISTERS
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|ioaddr
index|[
name|i
index|]
operator|=
name|sc
operator|->
name|iobase
operator|+
name|i
expr_stmt|;
block|}
comment|/* Simple probe.  */
if|if
condition|(
operator|!
name|fe_simple_probe
argument_list|(
name|sc
argument_list|,
name|probe_table
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Check if our I/O address matches config info. on EEPROM.  */
name|n
operator|=
operator|(
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_FMV2
index|]
argument_list|)
operator|&
name|FE_FMV2_IOS
operator|)
operator|>>
name|FE_FMV2_IOS_SHIFT
expr_stmt|;
if|if
condition|(
name|baseaddr
index|[
name|n
index|]
operator|!=
name|sc
operator|->
name|iobase
condition|)
block|{
if|#
directive|if
literal|0
comment|/* May not work on some revisions of the cards... FIXME.  */
block|return 0;
else|#
directive|else
comment|/* Just log the fact and see what happens... FIXME.  */
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"fe%d: strange I/O config?\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Find the "hardware revision."  */
name|revision
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_FMV1
index|]
argument_list|)
operator|&
name|FE_FMV1_REV
expr_stmt|;
comment|/* Determine the card type.  */
name|sc
operator|->
name|typestr
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_FMV0
index|]
argument_list|)
operator|&
name|FE_FMV0_MEDIA
condition|)
block|{
case|case
literal|0
case|:
comment|/* No interface?  This doesn't seem to be an FMV-180...  */
return|return
literal|0
return|;
case|case
name|FE_FMV0_MEDIUM_T
case|:
switch|switch
condition|(
name|revision
condition|)
block|{
case|case
literal|8
case|:
name|sc
operator|->
name|typestr
operator|=
literal|"FMV-183"
expr_stmt|;
break|break;
case|case
literal|12
case|:
name|sc
operator|->
name|typestr
operator|=
literal|"FMV-183 (on-board)"
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FE_FMV0_MEDIUM_T
operator||
name|FE_FMV0_MEDIUM_5
case|:
switch|switch
condition|(
name|revision
condition|)
block|{
case|case
literal|0
case|:
name|sc
operator|->
name|typestr
operator|=
literal|"FMV-181"
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|sc
operator|->
name|typestr
operator|=
literal|"FMV-181A"
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FE_FMV0_MEDIUM_2
case|:
switch|switch
condition|(
name|revision
condition|)
block|{
case|case
literal|8
case|:
name|sc
operator|->
name|typestr
operator|=
literal|"FMV-184 (CSR = 2)"
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FE_FMV0_MEDIUM_5
case|:
switch|switch
condition|(
name|revision
condition|)
block|{
case|case
literal|8
case|:
name|sc
operator|->
name|typestr
operator|=
literal|"FMV-184 (CSR = 1)"
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|FE_FMV0_MEDIUM_2
operator||
name|FE_FMV0_MEDIUM_5
case|:
switch|switch
condition|(
name|revision
condition|)
block|{
case|case
literal|0
case|:
name|sc
operator|->
name|typestr
operator|=
literal|"FMV-182"
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|sc
operator|->
name|typestr
operator|=
literal|"FMV-182A"
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|sc
operator|->
name|typestr
operator|=
literal|"FMV-184 (CSR = 3)"
expr_stmt|;
break|break;
block|}
break|break;
block|}
if|if
condition|(
name|sc
operator|->
name|typestr
operator|==
name|NULL
condition|)
block|{
comment|/* Unknown card type...  Hope the driver works.  */
name|sc
operator|->
name|typestr
operator|=
literal|"unknown FMV-180 version"
expr_stmt|;
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"fe%d: %s: %x-%x-%x-%x\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|sc
operator|->
name|typestr
argument_list|,
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_FMV0
index|]
argument_list|)
argument_list|,
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_FMV1
index|]
argument_list|)
argument_list|,
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_FMV2
index|]
argument_list|)
argument_list|,
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_FMV3
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * An FMV-180 has been proved. 	 * Determine which IRQ to be used. 	 * 	 * In this version, we give a priority to the kernel config file. 	 * If the EEPROM and config don't match, say it to the user for 	 * an attention. 	 */
name|n
operator|=
operator|(
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_FMV2
index|]
argument_list|)
operator|&
name|FE_FMV2_IRS
operator|)
operator|>>
name|FE_FMV2_IRS_SHIFT
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|id_irq
operator|==
name|NO_IRQ
condition|)
block|{
comment|/* Just use the probed value.  */
name|dev
operator|->
name|id_irq
operator|=
name|irqmap
index|[
name|n
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dev
operator|->
name|id_irq
operator|!=
name|irqmap
index|[
name|n
index|]
condition|)
block|{
comment|/* Don't match.  */
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"fe%d: check IRQ in config; it may be incorrect\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Initialize constants in the per-line structure. 	 */
comment|/* Get our station address from EEPROM.  */
name|inblk
argument_list|(
name|sc
argument_list|,
name|FE_FMV4
argument_list|,
name|sc
operator|->
name|sc_enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
comment|/* Make sure we got a valid station address.  */
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_enaddr
index|[
literal|0
index|]
operator|&
literal|0x03
operator|)
operator|!=
literal|0x00
operator|||
operator|(
name|sc
operator|->
name|sc_enaddr
index|[
literal|0
index|]
operator|==
literal|0x00
operator|&&
name|sc
operator|->
name|sc_enaddr
index|[
literal|1
index|]
operator|==
literal|0x00
operator|&&
name|sc
operator|->
name|sc_enaddr
index|[
literal|2
index|]
operator|==
literal|0x00
operator|)
condition|)
return|return
literal|0
return|;
comment|/* 	 * Register values which (may) depend on board design. 	 * 	 * Program the 86960 as follows: 	 *	SRAM: 32KB, 100ns, byte-wide access. 	 *	Transmission buffer: 4KB x 2. 	 *	System bus interface: 16 bits. 	 */
name|sc
operator|->
name|proto_dlcr4
operator|=
name|FE_D4_LBC_DISABLE
operator||
name|FE_D4_CNTRL
expr_stmt|;
name|sc
operator|->
name|proto_dlcr5
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|proto_dlcr6
operator|=
name|FE_D6_BUFSIZ_32KB
operator||
name|FE_D6_TXBSIZ_2x4KB
operator||
name|FE_D6_BBW_BYTE
operator||
name|FE_D6_SBW_WORD
operator||
name|FE_D6_SRAM_100ns
expr_stmt|;
name|sc
operator|->
name|proto_dlcr7
operator|=
name|FE_D7_BYTSWP_LH
operator||
name|FE_D7_IDENT_EC
expr_stmt|;
name|sc
operator|->
name|proto_bmpr13
operator|=
name|FE_B13_TPTYPE_UTP
operator||
name|FE_B13_PORT_AUTO
expr_stmt|;
comment|/* 	 * Minimum initialization of the hardware. 	 * We write into registers; hope I/O ports have no 	 * overlap with other boards. 	 */
comment|/* Initialize ASIC.  */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_FMV3
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_FMV10
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Initialize 86960.  */
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR6
index|]
argument_list|,
name|sc
operator|->
name|proto_dlcr6
operator||
name|FE_D6_DLC_DISABLE
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
comment|/* Disable all interrupts.  */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR2
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR3
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* "Refresh" hardware configuration.  FIXME.  */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_FMV2
index|]
argument_list|,
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_FMV2
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Turn the "master interrupt control" flag of ASIC on.  */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_FMV3
index|]
argument_list|,
name|FE_FMV3_IRQENB
argument_list|)
expr_stmt|;
comment|/* 	 * That's all.  FMV-180 occupies 32 I/O addresses, by the way. 	 */
return|return
literal|32
return|;
block|}
comment|/*  * Probe and initialization for Allied-Telesis AT1700/RE2000 series.  */
specifier|static
name|int
name|fe_probe_ati
parameter_list|(
name|DEVICE
modifier|*
name|dev
parameter_list|,
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|u_char
name|eeprom
index|[
name|FE_EEPROM_SIZE
index|]
decl_stmt|;
name|u_char
name|save16
decl_stmt|,
name|save17
decl_stmt|;
specifier|static
name|u_short
specifier|const
name|baseaddr
index|[
literal|8
index|]
init|=
block|{
literal|0x260
block|,
literal|0x280
block|,
literal|0x2A0
block|,
literal|0x240
block|,
literal|0x340
block|,
literal|0x320
block|,
literal|0x380
block|,
literal|0x300
block|}
decl_stmt|;
specifier|static
name|u_short
specifier|const
name|irqmaps
index|[
literal|4
index|]
index|[
literal|4
index|]
init|=
block|{
block|{
name|IRQ3
block|,
name|IRQ4
block|,
name|IRQ5
block|,
name|IRQ9
block|}
block|,
block|{
name|IRQ10
block|,
name|IRQ11
block|,
name|IRQ12
block|,
name|IRQ15
block|}
block|,
block|{
name|IRQ3
block|,
name|IRQ11
block|,
name|IRQ5
block|,
name|IRQ15
block|}
block|,
block|{
name|IRQ10
block|,
name|IRQ11
block|,
name|IRQ14
block|,
name|IRQ15
block|}
block|, 	}
decl_stmt|;
specifier|static
name|struct
name|fe_simple_probe_struct
specifier|const
name|probe_table
index|[]
init|=
block|{
block|{
name|FE_DLCR2
block|,
literal|0x70
block|,
literal|0x00
block|}
block|,
block|{
name|FE_DLCR4
block|,
literal|0x08
block|,
literal|0x00
block|}
block|,
block|{
name|FE_DLCR5
block|,
literal|0x80
block|,
literal|0x00
block|}
block|,
if|#
directive|if
literal|0
block|{ FE_BMPR16, 0x1B, 0x00 }, 		{ FE_BMPR17, 0x7F, 0x00 },
endif|#
directive|endif
block|{
literal|0
block|}
block|}
decl_stmt|;
comment|/* Assume we have 86965 and no need to restore these.  */
name|save16
operator|=
literal|0
expr_stmt|;
name|save17
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|FE_DEBUG
operator|>=
literal|3
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"fe%d: probe (0x%x) for ATI\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|sc
operator|->
name|iobase
argument_list|)
expr_stmt|;
name|fe_dump
argument_list|(
name|LOG_INFO
argument_list|,
name|sc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * See if the specified address is possible for MB86965A JLI mode. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|baseaddr
index|[
name|i
index|]
operator|==
name|sc
operator|->
name|iobase
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
literal|8
condition|)
goto|goto
name|NOTFOUND
goto|;
comment|/* Setup an I/O address mapping table.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXREGISTERS
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|ioaddr
index|[
name|i
index|]
operator|=
name|sc
operator|->
name|iobase
operator|+
name|i
expr_stmt|;
block|}
comment|/* 	 * We should test if MB86965A is on the base address now. 	 * Unfortunately, it is very hard to probe it reliably, since 	 * we have no way to reset the chip under software control. 	 * On cold boot, we could check the "signature" bit patterns 	 * described in the Fujitsu document.  On warm boot, however, 	 * we can predict almost nothing about register values. 	 */
if|if
condition|(
operator|!
name|fe_simple_probe
argument_list|(
name|sc
argument_list|,
name|probe_table
argument_list|)
condition|)
goto|goto
name|NOTFOUND
goto|;
comment|/* Check if our I/O address matches config info on 86965.  */
name|n
operator|=
operator|(
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_BMPR19
index|]
argument_list|)
operator|&
name|FE_B19_ADDR
operator|)
operator|>>
name|FE_B19_ADDR_SHIFT
expr_stmt|;
if|if
condition|(
name|baseaddr
index|[
name|n
index|]
operator|!=
name|sc
operator|->
name|iobase
condition|)
goto|goto
name|NOTFOUND
goto|;
comment|/* 	 * We are now almost sure we have an AT1700 at the given 	 * address.  So, read EEPROM through 86965.  We have to write 	 * into LSI registers to read from EEPROM.  I want to avoid it 	 * at this stage, but I cannot test the presence of the chip 	 * any further without reading EEPROM.  FIXME. 	 */
name|save16
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_BMPR16
index|]
argument_list|)
expr_stmt|;
name|save17
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_BMPR17
index|]
argument_list|)
expr_stmt|;
name|fe_read_eeprom
argument_list|(
name|sc
argument_list|,
name|eeprom
argument_list|)
expr_stmt|;
comment|/* Make sure the EEPROM is turned off.  */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_BMPR16
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_BMPR17
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Make sure that config info in EEPROM and 86965 agree.  */
if|if
condition|(
name|eeprom
index|[
name|FE_EEPROM_CONF
index|]
operator|!=
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_BMPR19
index|]
argument_list|)
condition|)
block|{
goto|goto
name|NOTFOUND
goto|;
block|}
comment|/* 	 * The following model identification codes are stolen from 	 * from the NetBSD port of the fe driver.  My reviewers 	 * suggested minor revision. 	 */
comment|/* Determine the card type.  */
switch|switch
condition|(
name|eeprom
index|[
name|FE_ATI_EEP_MODEL
index|]
condition|)
block|{
case|case
name|FE_ATI_MODEL_AT1700T
case|:
name|sc
operator|->
name|typestr
operator|=
literal|"AT-1700T/RE2001"
expr_stmt|;
break|break;
case|case
name|FE_ATI_MODEL_AT1700BT
case|:
name|sc
operator|->
name|typestr
operator|=
literal|"AT-1700BT/RE2003"
expr_stmt|;
break|break;
case|case
name|FE_ATI_MODEL_AT1700FT
case|:
name|sc
operator|->
name|typestr
operator|=
literal|"AT-1700FT/RE2009"
expr_stmt|;
break|break;
case|case
name|FE_ATI_MODEL_AT1700AT
case|:
name|sc
operator|->
name|typestr
operator|=
literal|"AT-1700AT/RE2005"
expr_stmt|;
break|break;
default|default:
name|sc
operator|->
name|typestr
operator|=
literal|"unknown AT-1700/RE2000 ?"
expr_stmt|;
break|break;
block|}
comment|/* 	 * Try to determine IRQ settings. 	 * Different models use different ranges of IRQs. 	 */
if|if
condition|(
name|dev
operator|->
name|id_irq
operator|==
name|NO_IRQ
condition|)
block|{
name|n
operator|=
operator|(
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_BMPR19
index|]
argument_list|)
operator|&
name|FE_B19_IRQ
operator|)
operator|>>
name|FE_B19_IRQ_SHIFT
expr_stmt|;
switch|switch
condition|(
name|eeprom
index|[
name|FE_ATI_EEP_REVISION
index|]
operator|&
literal|0xf0
condition|)
block|{
case|case
literal|0x30
case|:
name|dev
operator|->
name|id_irq
operator|=
name|irqmaps
index|[
literal|3
index|]
index|[
name|n
index|]
expr_stmt|;
break|break;
case|case
literal|0x10
case|:
case|case
literal|0x50
case|:
name|dev
operator|->
name|id_irq
operator|=
name|irqmaps
index|[
literal|2
index|]
index|[
name|n
index|]
expr_stmt|;
break|break;
case|case
literal|0x40
case|:
case|case
literal|0x60
case|:
if|if
condition|(
name|eeprom
index|[
name|FE_ATI_EEP_MAGIC
index|]
operator|&
literal|0x04
condition|)
block|{
name|dev
operator|->
name|id_irq
operator|=
name|irqmaps
index|[
literal|1
index|]
index|[
name|n
index|]
expr_stmt|;
block|}
else|else
block|{
name|dev
operator|->
name|id_irq
operator|=
name|irqmaps
index|[
literal|0
index|]
index|[
name|n
index|]
expr_stmt|;
block|}
break|break;
default|default:
name|dev
operator|->
name|id_irq
operator|=
name|irqmaps
index|[
literal|0
index|]
index|[
name|n
index|]
expr_stmt|;
break|break;
block|}
block|}
comment|/* 	 * Initialize constants in the per-line structure. 	 */
comment|/* Get our station address from EEPROM.  */
name|bcopy
argument_list|(
name|eeprom
operator|+
name|FE_ATI_EEP_ADDR
argument_list|,
name|sc
operator|->
name|sc_enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
comment|/* 	 * This test doesn't work well for AT1700 look-alike by 	 * other vendors. 	 */
comment|/* Make sure the vendor part is for Allied-Telesis.  */
if|if
condition|(
name|sc
operator|->
name|sc_enaddr
index|[
literal|0
index|]
operator|!=
literal|0x00
operator|||
name|sc
operator|->
name|sc_enaddr
index|[
literal|1
index|]
operator|!=
literal|0x00
operator|||
name|sc
operator|->
name|sc_enaddr
index|[
literal|2
index|]
operator|!=
literal|0xF4
condition|)
return|return
literal|0
return|;
else|#
directive|else
comment|/* Make sure we got a valid station address.  */
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_enaddr
index|[
literal|0
index|]
operator|&
literal|0x03
operator|)
operator|!=
literal|0x00
operator|||
operator|(
name|sc
operator|->
name|sc_enaddr
index|[
literal|0
index|]
operator|==
literal|0x00
operator|&&
name|sc
operator|->
name|sc_enaddr
index|[
literal|1
index|]
operator|==
literal|0x00
operator|&&
name|sc
operator|->
name|sc_enaddr
index|[
literal|2
index|]
operator|==
literal|0x00
operator|)
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* 	 * Program the 86960 as follows: 	 *	SRAM: 32KB, 100ns, byte-wide access. 	 *	Transmission buffer: 4KB x 2. 	 *	System bus interface: 16 bits. 	 */
name|sc
operator|->
name|proto_dlcr4
operator|=
name|FE_D4_LBC_DISABLE
operator||
name|FE_D4_CNTRL
expr_stmt|;
comment|/* FIXME */
name|sc
operator|->
name|proto_dlcr5
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|proto_dlcr6
operator|=
name|FE_D6_BUFSIZ_32KB
operator||
name|FE_D6_TXBSIZ_2x4KB
operator||
name|FE_D6_BBW_BYTE
operator||
name|FE_D6_SBW_WORD
operator||
name|FE_D6_SRAM_100ns
expr_stmt|;
name|sc
operator|->
name|proto_dlcr7
operator|=
name|FE_D7_BYTSWP_LH
operator||
name|FE_D7_IDENT_EC
expr_stmt|;
if|#
directive|if
literal|0
comment|/* XXXX Should we use this?  FIXME.  */
block|sc->proto_bmpr13 = eeprom[ FE_ATI_EEP_MEDIA ];
else|#
directive|else
name|sc
operator|->
name|proto_bmpr13
operator|=
name|FE_B13_TPTYPE_UTP
operator||
name|FE_B13_PORT_AUTO
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|FE_DEBUG
operator|>=
literal|3
name|fe_dump
argument_list|(
name|LOG_INFO
argument_list|,
name|sc
argument_list|,
literal|"ATI found"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Setup hooks.  This may solves a nasty bug.  FIXME.  */
name|sc
operator|->
name|init
operator|=
name|fe_init_ati
expr_stmt|;
comment|/* Initialize 86965.  */
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR6
index|]
argument_list|,
name|sc
operator|->
name|proto_dlcr6
operator||
name|FE_D6_DLC_DISABLE
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
comment|/* Disable all interrupts.  */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR2
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR3
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|FE_DEBUG
operator|>=
literal|3
name|fe_dump
argument_list|(
name|LOG_INFO
argument_list|,
name|sc
argument_list|,
literal|"end of fe_probe_ati()"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * That's all.  AT1700 occupies 32 I/O addresses, by the way. 	 */
return|return
literal|32
return|;
name|NOTFOUND
label|:
comment|/* 	 * We have no AT1700 at a given address. 	 * Restore BMPR16 and BMPR17 if we have destroyed them, 	 * hoping that the hardware on the address didn't get 	 * bad side effect. 	 */
if|if
condition|(
name|save16
operator|!=
literal|0
operator||
name|save17
operator|!=
literal|0
condition|)
block|{
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_BMPR16
index|]
argument_list|,
name|save16
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_BMPR17
index|]
argument_list|,
name|save17
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* ATI specific initialization routine.  */
specifier|static
name|void
name|fe_init_ati
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* 	 * I've told that the following operation "Resets" the chip. 	 * Hope this solve a bug which hangs up the driver under 	 * heavy load...  FIXME. 	 */
comment|/* Minimal initialization of 86965.  */
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR6
index|]
argument_list|,
name|sc
operator|->
name|proto_dlcr6
operator||
name|FE_D6_DLC_DISABLE
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
comment|/* "Reset" by wrting into an undocument register location.  */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
literal|0x1F
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* How long do we have to wait after the reset?  FIXME.  */
name|DELAY
argument_list|(
literal|300
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* PC98 */
comment|/*  * Probe and initialization for Gateway Communications' old cards.  */
specifier|static
name|int
name|fe_probe_gwy
parameter_list|(
name|DEVICE
modifier|*
name|dev
parameter_list|,
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|type
decl_stmt|;
specifier|static
name|struct
name|fe_simple_probe_struct
name|probe_table
index|[]
init|=
block|{
block|{
name|FE_DLCR2
block|,
literal|0x70
block|,
literal|0x00
block|}
block|,
block|{
name|FE_DLCR4
block|,
literal|0x08
block|,
literal|0x00
block|}
block|,
block|{
name|FE_DLCR7
block|,
literal|0xC0
block|,
literal|0x00
block|}
block|,
comment|/* 		 * Test *vendor* part of the address for Gateway. 		 * This test is essential to identify Gateway's cards. 		 * We shuld define some symbolic names for the 		 * following offsets.  FIXME. 		 */
block|{
literal|0x18
block|,
literal|0xFF
block|,
literal|0x00
block|}
block|,
block|{
literal|0x19
block|,
literal|0xFF
block|,
literal|0x00
block|}
block|,
block|{
literal|0x1A
block|,
literal|0xFF
block|,
literal|0x61
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
comment|/* 	 * We need explicit IRQ and supported address. 	 * I'm not sure which address and IRQ is possible for Gateway 	 * Ethernet family.  The following accepts everything.  FIXME. 	 */
if|if
condition|(
name|dev
operator|->
name|id_irq
operator|==
name|NO_IRQ
operator|||
operator|(
name|sc
operator|->
name|iobase
operator|&
operator|~
literal|0x3E0
operator|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|#
directive|if
name|FE_DEBUG
operator|>=
literal|3
name|fe_dump
argument_list|(
name|LOG_INFO
argument_list|,
name|sc
argument_list|,
literal|"top of probe"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Setup an I/O address mapping table.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXREGISTERS
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|ioaddr
index|[
name|i
index|]
operator|=
name|sc
operator|->
name|iobase
operator|+
name|i
expr_stmt|;
block|}
comment|/* See if the card is on its address.  */
if|if
condition|(
operator|!
name|fe_simple_probe
argument_list|(
name|sc
argument_list|,
name|probe_table
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|/* Determine the card type.  */
name|sc
operator|->
name|typestr
operator|=
literal|"Gateway Ethernet w/ Fujitsu chipset"
expr_stmt|;
comment|/* Get our station address from EEPROM. */
name|inblk
argument_list|(
name|sc
argument_list|,
literal|0x18
argument_list|,
name|sc
operator|->
name|sc_enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
comment|/* 	 * Program the 86960 as follows: 	 *	SRAM: 16KB, 100ns, byte-wide access. 	 *	Transmission buffer: 2KB x 2. 	 *	System bus interface: 16 bits. 	 * Make sure to clear out ID bits in DLCR7 	 * (They actually are Encoder/Decoder control in NICE.) 	 */
name|sc
operator|->
name|proto_dlcr4
operator|=
name|FE_D4_LBC_DISABLE
operator||
name|FE_D4_CNTRL
expr_stmt|;
name|sc
operator|->
name|proto_dlcr5
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|proto_dlcr6
operator|=
name|FE_D6_BUFSIZ_16KB
operator||
name|FE_D6_TXBSIZ_2x2KB
operator||
name|FE_D6_BBW_BYTE
operator||
name|FE_D6_SBW_WORD
operator||
name|FE_D6_SRAM_100ns
expr_stmt|;
name|sc
operator|->
name|proto_dlcr7
operator|=
name|FE_D7_BYTSWP_LH
expr_stmt|;
name|sc
operator|->
name|proto_bmpr13
operator|=
literal|0
expr_stmt|;
comment|/* Minimal initialization of 86960.  */
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR6
index|]
argument_list|,
name|sc
operator|->
name|proto_dlcr6
operator||
name|FE_D6_DLC_DISABLE
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
comment|/* Disable all interrupts.  */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR2
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR3
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* That's all.  The card occupies 32 I/O addresses, as always.  */
return|return
literal|32
return|;
block|}
if|#
directive|if
name|NCARD
operator|>
literal|0
comment|/*  * Probe and initialization for Fujitsu MBH10302 PCMCIA Ethernet interface.  * Note that this is for 10302 only; MBH10304 is handled by fe_probe_tdk().  */
specifier|static
name|int
name|fe_probe_mbh
parameter_list|(
name|DEVICE
modifier|*
name|dev
parameter_list|,
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|type
decl_stmt|;
specifier|static
name|struct
name|fe_simple_probe_struct
name|probe_table
index|[]
init|=
block|{
block|{
name|FE_DLCR0
block|,
literal|0x09
block|,
literal|0x00
block|}
block|,
block|{
name|FE_DLCR2
block|,
literal|0x79
block|,
literal|0x00
block|}
block|,
block|{
name|FE_DLCR4
block|,
literal|0x08
block|,
literal|0x00
block|}
block|,
block|{
name|FE_DLCR6
block|,
literal|0xFF
block|,
literal|0xB6
block|}
block|,
comment|/* 	 * The following location has the first byte of the card's 	 * Ethernet (MAC) address. 	 * We can always verify the *first* 2 bits (in Ethernet 	 * bit order) are "global" and "unicast" for any vendors'. 	 */
block|{
name|FE_MBH10
block|,
literal|0x03
block|,
literal|0x00
block|}
block|,
comment|/* Just a gap?  Seems reliable, anyway.  */
block|{
literal|0x12
block|,
literal|0xFF
block|,
literal|0x00
block|}
block|,
block|{
literal|0x13
block|,
literal|0xFF
block|,
literal|0x00
block|}
block|,
block|{
literal|0x14
block|,
literal|0xFF
block|,
literal|0x00
block|}
block|,
block|{
literal|0x15
block|,
literal|0xFF
block|,
literal|0x00
block|}
block|,
block|{
literal|0x16
block|,
literal|0xFF
block|,
literal|0x00
block|}
block|,
block|{
literal|0x17
block|,
literal|0xFF
block|,
literal|0x00
block|}
block|,
if|#
directive|if
literal|0
block|{ 0x18, 0xFF, 0xFF }, 		{ 0x19, 0xFF, 0xFF },
endif|#
directive|endif
block|{
literal|0
block|}
block|}
decl_stmt|;
comment|/* 	 * We need explicit IRQ and supported address. 	 */
if|if
condition|(
name|dev
operator|->
name|id_irq
operator|==
name|NO_IRQ
operator|||
operator|(
name|sc
operator|->
name|iobase
operator|&
operator|~
literal|0x3E0
operator|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|#
directive|if
name|FE_DEBUG
operator|>=
literal|3
name|fe_dump
argument_list|(
name|LOG_INFO
argument_list|,
name|sc
argument_list|,
literal|"top of probe"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Setup an I/O address mapping table.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXREGISTERS
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|ioaddr
index|[
name|i
index|]
operator|=
name|sc
operator|->
name|iobase
operator|+
name|i
expr_stmt|;
block|}
comment|/* 	 * See if MBH10302 is on its address. 	 * I'm not sure the following probe code works.  FIXME. 	 */
if|if
condition|(
operator|!
name|fe_simple_probe
argument_list|(
name|sc
argument_list|,
name|probe_table
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Determine the card type.  */
name|sc
operator|->
name|typestr
operator|=
literal|"MBH10302 (PCMCIA)"
expr_stmt|;
comment|/* 	 * Initialize constants in the per-line structure. 	 */
comment|/* Get our station address from EEPROM.  */
name|inblk
argument_list|(
name|sc
argument_list|,
name|FE_MBH10
argument_list|,
name|sc
operator|->
name|sc_enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
comment|/* Make sure we got a valid station address.  */
if|if
condition|(
name|sc
operator|->
name|sc_enaddr
index|[
literal|0
index|]
operator|==
literal|0x00
operator|&&
name|sc
operator|->
name|sc_enaddr
index|[
literal|1
index|]
operator|==
literal|0x00
operator|&&
name|sc
operator|->
name|sc_enaddr
index|[
literal|2
index|]
operator|==
literal|0x00
condition|)
return|return
literal|0
return|;
comment|/* 	 * Program the 86960 as follows: 	 *	SRAM: 32KB, 100ns, byte-wide access. 	 *	Transmission buffer: 4KB x 2. 	 *	System bus interface: 16 bits. 	 */
name|sc
operator|->
name|proto_dlcr4
operator|=
name|FE_D4_LBC_DISABLE
operator||
name|FE_D4_CNTRL
expr_stmt|;
name|sc
operator|->
name|proto_dlcr5
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|proto_dlcr6
operator|=
name|FE_D6_BUFSIZ_32KB
operator||
name|FE_D6_TXBSIZ_2x4KB
operator||
name|FE_D6_BBW_BYTE
operator||
name|FE_D6_SBW_WORD
operator||
name|FE_D6_SRAM_100ns
expr_stmt|;
name|sc
operator|->
name|proto_dlcr7
operator|=
name|FE_D7_BYTSWP_LH
operator||
name|FE_D7_IDENT_NICE
expr_stmt|;
name|sc
operator|->
name|proto_bmpr13
operator|=
name|FE_B13_TPTYPE_UTP
operator||
name|FE_B13_PORT_AUTO
expr_stmt|;
comment|/* Setup hooks.  We need a special initialization procedure.  */
name|sc
operator|->
name|init
operator|=
name|fe_init_mbh
expr_stmt|;
comment|/* 	 * Minimum initialization. 	 */
comment|/* Minimal initialization of 86960.  */
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR6
index|]
argument_list|,
name|sc
operator|->
name|proto_dlcr6
operator||
name|FE_D6_DLC_DISABLE
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
comment|/* Disable all interrupts.  */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR2
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR3
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
comment|/* FIXME.  */
comment|/* Initialize system bus interface and encoder/decoder operation.  */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_MBH0
index|]
argument_list|,
name|FE_MBH0_MAGIC
operator||
name|FE_MBH0_INTR_DISABLE
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * That's all.  MBH10302 occupies 32 I/O addresses, by the way. 	 */
return|return
literal|32
return|;
block|}
comment|/* MBH specific initialization routine.  */
specifier|static
name|void
name|fe_init_mbh
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* Minimal initialization of 86960.  */
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR6
index|]
argument_list|,
name|sc
operator|->
name|proto_dlcr6
operator||
name|FE_D6_DLC_DISABLE
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
comment|/* Disable all interrupts.  */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR2
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR3
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Enable master interrupt flag.  */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_MBH0
index|]
argument_list|,
name|FE_MBH0_MAGIC
operator||
name|FE_MBH0_INTR_ENABLE
argument_list|)
expr_stmt|;
block|}
comment|/*  * Probe and initialization for TDK/CONTEC PCMCIA Ethernet interface.  * by MASUI Kenji<masui@cs.titech.ac.jp>  *  * (Contec uses TDK Ethenet chip -- hosokawa)  *  * This version of fe_probe_tdk has been rewrote to handle  * *generic* PC card implementation of Fujitsu MB8696x and compatibles.  * The name _tdk is just for a historical reason.<seki> :-)  */
specifier|static
name|int
name|fe_probe_tdk
parameter_list|(
name|DEVICE
modifier|*
name|dev
parameter_list|,
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|static
name|struct
name|fe_simple_probe_struct
name|probe_table
index|[]
init|=
block|{
block|{
name|FE_DLCR2
block|,
literal|0x70
block|,
literal|0x00
block|}
block|,
block|{
name|FE_DLCR4
block|,
literal|0x08
block|,
literal|0x00
block|}
block|,
comment|/*  { FE_DLCR5, 0x80, 0x00 },       Does not work well.  */
block|{
literal|0
block|}
block|}
decl_stmt|;
comment|/* We need an IRQ.  */
if|if
condition|(
name|dev
operator|->
name|id_irq
operator|==
name|NO_IRQ
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Generic driver needs Ethernet address taken from CIS.  */
if|if
condition|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
index|[
literal|1
index|]
operator|==
literal|0
operator|&&
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
index|[
literal|2
index|]
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|/* Setup an I/O address mapping table; we need only 16 ports.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|ioaddr
index|[
name|i
index|]
operator|=
name|sc
operator|->
name|iobase
operator|+
name|i
expr_stmt|;
block|}
comment|/* Fill unused slots with a safe address.  */
for|for
control|(
name|i
operator|=
literal|16
init|;
name|i
operator|<
name|MAXREGISTERS
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|ioaddr
index|[
name|i
index|]
operator|=
name|sc
operator|->
name|iobase
expr_stmt|;
block|}
comment|/*          * See if C-NET(PC)C is on its address.          */
if|if
condition|(
operator|!
name|fe_simple_probe
argument_list|(
name|sc
argument_list|,
name|probe_table
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Determine the card type.  */
name|sc
operator|->
name|typestr
operator|=
literal|"Generic MB8696x Ethernet (PCMCIA)"
expr_stmt|;
comment|/*          * Initialize constants in the per-line structure.          */
comment|/* The station address *must*be* already in sc_enaddr;            Make sure we got a valid station address.  */
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_enaddr
index|[
literal|0
index|]
operator|&
literal|0x03
operator|)
operator|!=
literal|0x00
operator|||
operator|(
name|sc
operator|->
name|sc_enaddr
index|[
literal|0
index|]
operator|==
literal|0x00
operator|&&
name|sc
operator|->
name|sc_enaddr
index|[
literal|1
index|]
operator|==
literal|0x00
operator|&&
name|sc
operator|->
name|sc_enaddr
index|[
literal|2
index|]
operator|==
literal|0x00
operator|)
condition|)
return|return
literal|0
return|;
comment|/*          * Program the 86965 as follows:          *      SRAM: 32KB, 100ns, byte-wide access.          *      Transmission buffer: 4KB x 2.          *      System bus interface: 16 bits. 	 * XXX: Should we remove IDENT_NICE from DLCR7?  Or, 	 *	even add IDENT_EC instead?  FIXME.          */
name|sc
operator|->
name|proto_dlcr4
operator|=
name|FE_D4_LBC_DISABLE
operator||
name|FE_D4_CNTRL
expr_stmt|;
name|sc
operator|->
name|proto_dlcr5
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|proto_dlcr6
operator|=
name|FE_D6_BUFSIZ_32KB
operator||
name|FE_D6_TXBSIZ_2x4KB
operator||
name|FE_D6_BBW_BYTE
operator||
name|FE_D6_SBW_WORD
operator||
name|FE_D6_SRAM_100ns
expr_stmt|;
name|sc
operator|->
name|proto_dlcr7
operator|=
name|FE_D7_BYTSWP_LH
operator||
name|FE_D7_IDENT_NICE
expr_stmt|;
name|sc
operator|->
name|proto_bmpr13
operator|=
name|FE_B13_TPTYPE_UTP
operator||
name|FE_B13_PORT_AUTO
expr_stmt|;
comment|/* Minimul initialization of 86960.  */
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR6
index|]
argument_list|,
name|sc
operator|->
name|proto_dlcr6
operator||
name|FE_D6_DLC_DISABLE
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
comment|/* Disable all interrupts.  */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR2
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR3
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*          * That's all.  C-NET(PC)C occupies 16 I/O addresses. 	 * 	 * Some PC cards (e.g., TDK and Contec) have 16 I/O addresses, 	 * while some others (e.g., Fujitsu) have 32.  Fortunately, 	 * this generic driver never accesses latter 16 ports in 32 	 * ports cards.  So, we can assume the *generic* PC cards 	 * always have 16 ports. 	 * 	 * Moreover, PC card probe is isolated from ISA probe, and PC 	 * card probe routine doesn't use "# of ports" returned by this 	 * function.  16 v.s. 32 is not important now. 	 */
return|return
literal|16
return|;
block|}
endif|#
directive|endif
comment|/* NCARD> 0 */
comment|/*  * Install interface into kernel networking data structures  */
specifier|static
name|int
name|fe_attach
parameter_list|(
name|DEVICE
modifier|*
name|dev
parameter_list|)
block|{
if|#
directive|if
name|NCARD
operator|>
literal|0
specifier|static
name|int
name|already_ifattach
index|[
name|NFE
index|]
decl_stmt|;
endif|#
directive|endif
name|struct
name|fe_softc
modifier|*
name|sc
init|=
operator|&
name|fe_softc
index|[
name|dev
operator|->
name|id_unit
index|]
decl_stmt|;
comment|/* 	 * Initialize ifnet structure 	 */
name|sc
operator|->
name|sc_if
operator|.
name|if_softc
operator|=
name|sc
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_unit
operator|=
name|sc
operator|->
name|sc_unit
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_name
operator|=
literal|"fe"
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_output
operator|=
name|ether_output
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_start
operator|=
name|fe_start
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_ioctl
operator|=
name|fe_ioctl
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_watchdog
operator|=
name|fe_watchdog
expr_stmt|;
comment|/* 	 * Set default interface flags. 	 */
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
comment|/* 	 * Set maximum size of output queue, if it has not been set. 	 * It is done here as this driver may be started after the 	 * system initialization (i.e., the interface is PCMCIA.) 	 * 	 * I'm not sure this is really necessary, but, even if it is, 	 * it should be done somewhere else, e.g., in if_attach(), 	 * since it must be a common workaround for all network drivers. 	 * FIXME. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_if
operator|.
name|if_snd
operator|.
name|ifq_maxlen
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_if
operator|.
name|if_snd
operator|.
name|ifq_maxlen
operator|=
name|ifqmaxlen
expr_stmt|;
block|}
if|#
directive|if
name|FE_DEBUG
operator|>=
literal|3
name|fe_dump
argument_list|(
name|LOG_INFO
argument_list|,
name|sc
argument_list|,
literal|"attach()"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|FE_SINGLE_TRANSMISSION
comment|/* Override txb config to allocate minimum.  */
name|sc
operator|->
name|proto_dlcr6
operator|&=
operator|~
name|FE_D6_TXBSIZ
name|sc
operator|->
name|proto_dlcr6
operator||=
name|FE_D6_TXBSIZ_2x2KB
expr_stmt|;
endif|#
directive|endif
comment|/* Modify hardware config if it is requested.  */
if|if
condition|(
name|dev
operator|->
name|id_flags
operator|&
name|FE_FLAGS_OVERRIDE_DLCR6
condition|)
block|{
name|sc
operator|->
name|proto_dlcr6
operator|=
name|dev
operator|->
name|id_flags
operator|&
name|FE_FLAGS_DLCR6_VALUE
expr_stmt|;
block|}
comment|/* Find TX buffer size, based on the hardware dependent proto.  */
switch|switch
condition|(
name|sc
operator|->
name|proto_dlcr6
operator|&
name|FE_D6_TXBSIZ
condition|)
block|{
case|case
name|FE_D6_TXBSIZ_2x2KB
case|:
name|sc
operator|->
name|txb_size
operator|=
literal|2048
expr_stmt|;
break|break;
case|case
name|FE_D6_TXBSIZ_2x4KB
case|:
name|sc
operator|->
name|txb_size
operator|=
literal|4096
expr_stmt|;
break|break;
case|case
name|FE_D6_TXBSIZ_2x8KB
case|:
name|sc
operator|->
name|txb_size
operator|=
literal|8192
expr_stmt|;
break|break;
default|default:
comment|/* Oops, we can't work with single buffer configuration.  */
if|#
directive|if
name|FE_DEBUG
operator|>=
literal|2
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"fe%d: strange TXBSIZ config; fixing\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|proto_dlcr6
operator|&=
operator|~
name|FE_D6_TXBSIZ
expr_stmt|;
name|sc
operator|->
name|proto_dlcr6
operator||=
name|FE_D6_TXBSIZ_2x2KB
expr_stmt|;
name|sc
operator|->
name|txb_size
operator|=
literal|2048
expr_stmt|;
break|break;
block|}
comment|/* Attach and stop the interface. */
if|#
directive|if
name|NCARD
operator|>
literal|0
if|if
condition|(
name|already_ifattach
index|[
name|dev
operator|->
name|id_unit
index|]
operator|!=
literal|1
condition|)
block|{
name|if_attach
argument_list|(
operator|&
name|sc
operator|->
name|sc_if
argument_list|)
expr_stmt|;
name|already_ifattach
index|[
name|dev
operator|->
name|id_unit
index|]
operator|=
literal|1
expr_stmt|;
block|}
else|#
directive|else
name|if_attach
argument_list|(
operator|&
name|sc
operator|->
name|sc_if
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fe_stop
argument_list|(
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
comment|/* This changes the state to IDLE.  */
name|ether_ifattach
argument_list|(
operator|&
name|sc
operator|->
name|sc_if
argument_list|)
expr_stmt|;
comment|/* Print additional info when attached.  */
name|printf
argument_list|(
literal|"fe%d: address %6D, type %s\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|sc
operator|->
name|sc_enaddr
argument_list|,
literal|":"
argument_list|,
name|sc
operator|->
name|typestr
argument_list|)
expr_stmt|;
if|#
directive|if
name|FE_DEBUG
operator|>=
literal|3
block|{
name|int
name|buf
decl_stmt|,
name|txb
decl_stmt|,
name|bbw
decl_stmt|,
name|sbw
decl_stmt|,
name|ram
decl_stmt|;
name|buf
operator|=
name|txb
operator|=
name|bbw
operator|=
name|sbw
operator|=
name|ram
operator|=
operator|-
literal|1
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|proto_dlcr6
operator|&
name|FE_D6_BUFSIZ
condition|)
block|{
case|case
name|FE_D6_BUFSIZ_8KB
case|:
name|buf
operator|=
literal|8
expr_stmt|;
break|break;
case|case
name|FE_D6_BUFSIZ_16KB
case|:
name|buf
operator|=
literal|16
expr_stmt|;
break|break;
case|case
name|FE_D6_BUFSIZ_32KB
case|:
name|buf
operator|=
literal|32
expr_stmt|;
break|break;
case|case
name|FE_D6_BUFSIZ_64KB
case|:
name|buf
operator|=
literal|64
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|sc
operator|->
name|proto_dlcr6
operator|&
name|FE_D6_TXBSIZ
condition|)
block|{
case|case
name|FE_D6_TXBSIZ_2x2KB
case|:
name|txb
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|FE_D6_TXBSIZ_2x4KB
case|:
name|txb
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|FE_D6_TXBSIZ_2x8KB
case|:
name|txb
operator|=
literal|8
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|sc
operator|->
name|proto_dlcr6
operator|&
name|FE_D6_BBW
condition|)
block|{
case|case
name|FE_D6_BBW_BYTE
case|:
name|bbw
operator|=
literal|8
expr_stmt|;
break|break;
case|case
name|FE_D6_BBW_WORD
case|:
name|bbw
operator|=
literal|16
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|sc
operator|->
name|proto_dlcr6
operator|&
name|FE_D6_SBW
condition|)
block|{
case|case
name|FE_D6_SBW_BYTE
case|:
name|sbw
operator|=
literal|8
expr_stmt|;
break|break;
case|case
name|FE_D6_SBW_WORD
case|:
name|sbw
operator|=
literal|16
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|sc
operator|->
name|proto_dlcr6
operator|&
name|FE_D6_SRAM
condition|)
block|{
case|case
name|FE_D6_SRAM_100ns
case|:
name|ram
operator|=
literal|100
expr_stmt|;
break|break;
case|case
name|FE_D6_SRAM_150ns
case|:
name|ram
operator|=
literal|150
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|"fe%d: SRAM %dKB %dbit %dns, TXB %dKBx2, %dbit I/O\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|buf
argument_list|,
name|bbw
argument_list|,
name|ram
argument_list|,
name|txb
argument_list|,
name|sbw
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
comment|/* If BPF is in the kernel, call the attach for it.  */
name|bpfattach
argument_list|(
operator|&
name|sc
operator|->
name|sc_if
argument_list|,
name|DLT_EN10MB
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|1
return|;
block|}
comment|/*  * Reset interface.  */
specifier|static
name|void
name|fe_reset
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
comment|/* 	 * Stop interface and re-initialize. 	 */
name|fe_stop
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|fe_init
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
comment|/*  * Stop everything on the interface.  *  * All buffered packets, both transmitting and receiving,  * if any, will be lost by stopping the interface.  */
specifier|static
name|void
name|fe_stop
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|struct
name|fe_softc
modifier|*
name|sc
init|=
operator|&
name|fe_softc
index|[
name|unit
index|]
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|#
directive|if
name|FE_DEBUG
operator|>=
literal|3
name|fe_dump
argument_list|(
name|LOG_INFO
argument_list|,
name|sc
argument_list|,
literal|"stop()"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Disable interrupts.  */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR2
index|]
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR3
index|]
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* Stop interface hardware.  */
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR6
index|]
argument_list|,
name|sc
operator|->
name|proto_dlcr6
operator||
name|FE_D6_DLC_DISABLE
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
comment|/* Clear all interrupt status.  */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR0
index|]
argument_list|,
literal|0xFF
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR1
index|]
argument_list|,
literal|0xFF
argument_list|)
expr_stmt|;
comment|/* Put the chip in stand-by mode.  */
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR7
index|]
argument_list|,
name|sc
operator|->
name|proto_dlcr7
operator||
name|FE_D7_POWER_DOWN
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
comment|/* Reset transmitter variables and interface flags.  */
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&=
operator|~
operator|(
name|IFF_OACTIVE
operator||
name|IFF_RUNNING
operator|)
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_timer
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|txb_free
operator|=
name|sc
operator|->
name|txb_size
expr_stmt|;
name|sc
operator|->
name|txb_count
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|txb_sched
operator|=
literal|0
expr_stmt|;
comment|/* MAR loading can be delayed.  */
name|sc
operator|->
name|filter_change
operator|=
literal|0
expr_stmt|;
comment|/* Update config status also.  */
comment|/* Call a hook.  */
if|if
condition|(
name|sc
operator|->
name|stop
condition|)
name|sc
operator|->
name|stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|#
directive|if
name|FE_DEBUG
operator|>=
literal|3
name|fe_dump
argument_list|(
name|LOG_INFO
argument_list|,
name|sc
argument_list|,
literal|"end of stop()"
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
comment|/*  * Device timeout/watchdog routine. Entered if the device neglects to  * generate an interrupt after a transmit has been started on it.  */
specifier|static
name|void
name|fe_watchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|fe_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|fe_softc
operator|*
operator|)
name|ifp
decl_stmt|;
if|#
directive|if
name|FE_DEBUG
operator|>=
literal|1
comment|/* A "debug" message.  */
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fe%d: transmission timeout (%d+%d)%s\n"
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|,
name|sc
operator|->
name|txb_sched
argument_list|,
name|sc
operator|->
name|txb_count
argument_list|,
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
condition|?
literal|""
else|:
literal|" when down"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_if
operator|.
name|if_opackets
operator|==
literal|0
operator|&&
name|sc
operator|->
name|sc_if
operator|.
name|if_ipackets
operator|==
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"fe%d: wrong IRQ setting in config?\n"
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|FE_DEBUG
operator|>=
literal|3
name|fe_dump
argument_list|(
name|LOG_INFO
argument_list|,
name|sc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Record how many packets are lost by this accident.  */
name|ifp
operator|->
name|if_oerrors
operator|+=
name|sc
operator|->
name|txb_sched
operator|+
name|sc
operator|->
name|txb_count
expr_stmt|;
comment|/* Put the interface into known initial state.  */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
name|fe_reset
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fe_stop
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  * Initialize device.  */
specifier|static
name|void
name|fe_init
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|struct
name|fe_softc
modifier|*
name|sc
init|=
operator|&
name|fe_softc
index|[
name|unit
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|s
decl_stmt|;
if|#
directive|if
name|FE_DEBUG
operator|>=
literal|3
name|fe_dump
argument_list|(
name|LOG_INFO
argument_list|,
name|sc
argument_list|,
literal|"init()"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* We need an address. */
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|sc_if
operator|.
name|if_addrhead
argument_list|)
condition|)
block|{
comment|/* XXX unlikely */
if|#
directive|if
name|FE_DEBUG
operator|>=
literal|1
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fe%d: init() without any address\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
if|#
directive|if
name|FE_DEBUG
operator|>=
literal|1
comment|/* 	 * Make sure we have a valid station address. 	 * The following test is applicable for any Ethernet interfaces. 	 * It can be done in somewhere common to all of them.  FIXME. 	 */
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_enaddr
index|[
literal|0
index|]
operator|&
literal|0x01
operator|)
operator|!=
literal|0
operator|||
operator|(
name|sc
operator|->
name|sc_enaddr
index|[
literal|0
index|]
operator|==
literal|0x00
operator|&&
name|sc
operator|->
name|sc_enaddr
index|[
literal|1
index|]
operator|==
literal|0x00
operator|&&
name|sc
operator|->
name|sc_enaddr
index|[
literal|2
index|]
operator|==
literal|0x00
operator|)
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fe%d: invalid station address (%6D)\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|sc
operator|->
name|sc_enaddr
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* Start initializing 86960.  */
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* Call a hook.  */
if|if
condition|(
name|sc
operator|->
name|init
condition|)
name|sc
operator|->
name|init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|#
directive|if
name|FE_DEBUG
operator|>=
literal|3
name|fe_dump
argument_list|(
name|LOG_INFO
argument_list|,
name|sc
argument_list|,
literal|"after init hook"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Make sure to disable the chip, also. 	 * This may also help re-programming the chip after 	 * hot insertion of PCMCIAs. 	 */
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR6
index|]
argument_list|,
name|sc
operator|->
name|proto_dlcr6
operator||
name|FE_D6_DLC_DISABLE
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
comment|/* Power up the chip and select register bank for DLCRs.  */
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR7
index|]
argument_list|,
name|sc
operator|->
name|proto_dlcr7
operator||
name|FE_D7_RBS_DLCR
operator||
name|FE_D7_POWER_UP
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
comment|/* Feed the station address.  */
name|outblk
argument_list|(
name|sc
argument_list|,
name|FE_DLCR8
argument_list|,
name|sc
operator|->
name|sc_enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
comment|/* Clear multicast address filter to receive nothing.  */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR7
index|]
argument_list|,
name|sc
operator|->
name|proto_dlcr7
operator||
name|FE_D7_RBS_MAR
operator||
name|FE_D7_POWER_UP
argument_list|)
expr_stmt|;
name|outblk
argument_list|(
name|sc
argument_list|,
name|FE_MAR8
argument_list|,
name|fe_filter_nothing
operator|.
name|data
argument_list|,
name|FE_FILTER_LEN
argument_list|)
expr_stmt|;
comment|/* Select the BMPR bank for runtime register access.  */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR7
index|]
argument_list|,
name|sc
operator|->
name|proto_dlcr7
operator||
name|FE_D7_RBS_BMPR
operator||
name|FE_D7_POWER_UP
argument_list|)
expr_stmt|;
comment|/* Initialize registers.  */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR0
index|]
argument_list|,
literal|0xFF
argument_list|)
expr_stmt|;
comment|/* Clear all bits.  */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR1
index|]
argument_list|,
literal|0xFF
argument_list|)
expr_stmt|;
comment|/* ditto.  */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR2
index|]
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR3
index|]
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR4
index|]
argument_list|,
name|sc
operator|->
name|proto_dlcr4
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR5
index|]
argument_list|,
name|sc
operator|->
name|proto_dlcr5
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_BMPR10
index|]
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_BMPR11
index|]
argument_list|,
name|FE_B11_CTRL_SKIP
operator||
name|FE_B11_MODE1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_BMPR12
index|]
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_BMPR13
index|]
argument_list|,
name|sc
operator|->
name|proto_bmpr13
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_BMPR14
index|]
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_BMPR15
index|]
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
if|#
directive|if
name|FE_DEBUG
operator|>=
literal|3
name|fe_dump
argument_list|(
name|LOG_INFO
argument_list|,
name|sc
argument_list|,
literal|"just before enabling DLC"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Enable interrupts.  */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR2
index|]
argument_list|,
name|FE_TMASK
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR3
index|]
argument_list|,
name|FE_RMASK
argument_list|)
expr_stmt|;
comment|/* Enable transmitter and receiver.  */
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR6
index|]
argument_list|,
name|sc
operator|->
name|proto_dlcr6
operator||
name|FE_D6_DLC_ENABLE
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
if|#
directive|if
name|FE_DEBUG
operator|>=
literal|3
name|fe_dump
argument_list|(
name|LOG_INFO
argument_list|,
name|sc
argument_list|,
literal|"just after enabling DLC"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Make sure to empty the receive buffer. 	 * 	 * This may be redundant, but *if* the receive buffer were full 	 * at this point, then the driver would hang.  I have experienced 	 * some strange hang-up just after UP.  I hope the following 	 * code solve the problem. 	 * 	 * I have changed the order of hardware initialization. 	 * I think the receive buffer cannot have any packets at this 	 * point in this version.  The following code *must* be 	 * redundant now.  FIXME. 	 * 	 * I've heard a rumore that on some PC card implementation of 	 * 8696x, the receive buffer can have some data at this point. 	 * The following message helps discovering the fact.  FIXME. 	 */
if|if
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR5
index|]
argument_list|)
operator|&
name|FE_D5_BUFEMP
operator|)
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"fe%d: receive buffer has some data after reset\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
name|fe_emptybuffer
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|FE_DEBUG
operator|>=
literal|3
name|fe_dump
argument_list|(
name|LOG_INFO
argument_list|,
name|sc
argument_list|,
literal|"after ERB loop"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Do we need this here?  Actually, no.  I must be paranoia.  */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR0
index|]
argument_list|,
literal|0xFF
argument_list|)
expr_stmt|;
comment|/* Clear all bits.  */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR1
index|]
argument_list|,
literal|0xFF
argument_list|)
expr_stmt|;
comment|/* ditto.  */
if|#
directive|if
name|FE_DEBUG
operator|>=
literal|3
name|fe_dump
argument_list|(
name|LOG_INFO
argument_list|,
name|sc
argument_list|,
literal|"after FIXME"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Set 'running' flag, because we are now running.   */
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
comment|/* 	 * At this point, the interface is running properly, 	 * except that it receives *no* packets.  we then call 	 * fe_setmode() to tell the chip what packets to be 	 * received, based on the if_flags and multicast group 	 * list.  It completes the initialization process. 	 */
name|fe_setmode
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|#
directive|if
name|FE_DEBUG
operator|>=
literal|3
name|fe_dump
argument_list|(
name|LOG_INFO
argument_list|,
name|sc
argument_list|,
literal|"after setmode"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ...and attempt to start output queued packets.  */
name|fe_start
argument_list|(
operator|&
name|sc
operator|->
name|sc_if
argument_list|)
expr_stmt|;
if|#
directive|if
name|FE_DEBUG
operator|>=
literal|3
name|fe_dump
argument_list|(
name|LOG_INFO
argument_list|,
name|sc
argument_list|,
literal|"init() done"
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
comment|/*  * This routine actually starts the transmission on the interface  */
specifier|static
name|void
name|fe_xmit
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* 	 * Set a timer just in case we never hear from the board again. 	 * We use longer timeout for multiple packet transmission. 	 * I'm not sure this timer value is appropriate.  FIXME. 	 */
name|sc
operator|->
name|sc_if
operator|.
name|if_timer
operator|=
literal|1
operator|+
name|sc
operator|->
name|txb_count
expr_stmt|;
comment|/* Update txb variables.  */
name|sc
operator|->
name|txb_sched
operator|=
name|sc
operator|->
name|txb_count
expr_stmt|;
name|sc
operator|->
name|txb_count
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|txb_free
operator|=
name|sc
operator|->
name|txb_size
expr_stmt|;
name|sc
operator|->
name|tx_excolls
operator|=
literal|0
expr_stmt|;
comment|/* Start transmitter, passing packets in TX buffer.  */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_BMPR10
index|]
argument_list|,
name|sc
operator|->
name|txb_sched
operator||
name|FE_B10_START
argument_list|)
expr_stmt|;
block|}
comment|/*  * Start output on interface.  * We make two assumptions here:  *  1) that the current priority is set to splimp _before_ this code  *     is called *and* is returned to the appropriate priority after  *     return  *  2) that the IFF_OACTIVE flag is checked before this code is called  *     (i.e. that the output part of the interface is idle)  */
name|void
name|fe_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|fe_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
if|#
directive|if
name|FE_DEBUG
operator|>=
literal|1
comment|/* Just a sanity check.  */
if|if
condition|(
operator|(
name|sc
operator|->
name|txb_count
operator|==
literal|0
operator|)
operator|!=
operator|(
name|sc
operator|->
name|txb_free
operator|==
name|sc
operator|->
name|txb_size
operator|)
condition|)
block|{
comment|/* 		 * Txb_count and txb_free co-works to manage the 		 * transmission buffer.  Txb_count keeps track of the 		 * used potion of the buffer, while txb_free does unused 		 * potion.  So, as long as the driver runs properly, 		 * txb_count is zero if and only if txb_free is same 		 * as txb_size (which represents whole buffer.) 		 */
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fe%d: inconsistent txb variables (%d, %d)\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|sc
operator|->
name|txb_count
argument_list|,
name|sc
operator|->
name|txb_free
argument_list|)
expr_stmt|;
comment|/* 		 * So, what should I do, then? 		 * 		 * We now know txb_count and txb_free contradicts.  We 		 * cannot, however, tell which is wrong.  More 		 * over, we cannot peek 86960 transmission buffer or 		 * reset the transmission buffer.  (In fact, we can 		 * reset the entire interface.  I don't want to do it.) 		 * 		 * If txb_count is incorrect, leaving it as-is will cause 		 * sending of garbage after next interrupt.  We have to 		 * avoid it.  Hence, we reset the txb_count here.  If 		 * txb_free was incorrect, resetting txb_count just loose 		 * some packets.  We can live with it. 		 */
name|sc
operator|->
name|txb_count
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|FE_DEBUG
operator|>=
literal|1
comment|/* 	 * First, see if there are buffered packets and an idle 	 * transmitter - should never happen at this point. 	 */
if|if
condition|(
operator|(
name|sc
operator|->
name|txb_count
operator|>
literal|0
operator|)
operator|&&
operator|(
name|sc
operator|->
name|txb_sched
operator|==
literal|0
operator|)
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fe%d: transmitter idle with %d buffered packets\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|sc
operator|->
name|txb_count
argument_list|)
expr_stmt|;
name|fe_xmit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * Stop accepting more transmission packets temporarily, when 	 * a filter change request is delayed.  Updating the MARs on 	 * 86960 flushes the transmission buffer, so it is delayed 	 * until all buffered transmission packets have been sent 	 * out. 	 */
if|if
condition|(
name|sc
operator|->
name|filter_change
condition|)
block|{
comment|/* 		 * Filter change request is delayed only when the DLC is 		 * working.  DLC soon raise an interrupt after finishing 		 * the work. 		 */
goto|goto
name|indicate_active
goto|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * See if there is room to put another packet in the buffer. 		 * We *could* do better job by peeking the send queue to 		 * know the length of the next packet.  Current version just 		 * tests against the worst case (i.e., longest packet).  FIXME. 		 * 		 * When adding the packet-peek feature, don't forget adding a 		 * test on txb_count against QUEUEING_MAX. 		 * There is a little chance the packet count exceeds 		 * the limit.  Assume transmission buffer is 8KB (2x8KB 		 * configuration) and an application sends a bunch of small 		 * (i.e., minimum packet sized) packets rapidly.  An 8KB 		 * buffer can hold 130 blocks of 62 bytes long... 		 */
if|if
condition|(
name|sc
operator|->
name|txb_free
operator|<
name|ETHER_MAX_LEN
operator|-
name|ETHER_CRC_LEN
operator|+
name|FE_DATA_LEN_LEN
condition|)
block|{
comment|/* No room.  */
goto|goto
name|indicate_active
goto|;
block|}
if|#
directive|if
name|FE_SINGLE_TRANSMISSION
if|if
condition|(
name|sc
operator|->
name|txb_count
operator|>
literal|0
condition|)
block|{
comment|/* Just one packet per a transmission buffer.  */
goto|goto
name|indicate_active
goto|;
block|}
endif|#
directive|endif
comment|/* 		 * Get the next mbuf chain for a packet to send. 		 */
name|IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|sc_if
operator|.
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
comment|/* No more packets to send.  */
goto|goto
name|indicate_inactive
goto|;
block|}
comment|/* 		 * Copy the mbuf chain into the transmission buffer. 		 * txb_* variables are updated as necessary. 		 */
name|fe_write_mbufs
argument_list|(
name|sc
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* Start transmitter if it's idle.  */
if|if
condition|(
operator|(
name|sc
operator|->
name|txb_count
operator|>
literal|0
operator|)
operator|&&
operator|(
name|sc
operator|->
name|txb_sched
operator|==
literal|0
operator|)
condition|)
block|{
name|fe_xmit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Tap off here if there is a bpf listener, 		 * and the device is *not* in promiscuous mode. 		 * (86960 receives self-generated packets if  		 * and only if it is in "receive everything" 		 * mode.) 		 */
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
if|if
condition|(
name|sc
operator|->
name|sc_if
operator|.
name|if_bpf
operator|&&
operator|!
operator|(
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
condition|)
block|{
name|bpf_mtap
argument_list|(
operator|&
name|sc
operator|->
name|sc_if
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|indicate_inactive
label|:
comment|/* 	 * We are using the !OACTIVE flag to indicate to 	 * the outside world that we can accept an 	 * additional packet rather than that the 	 * transmitter is _actually_ active.  Indeed, the 	 * transmitter may be active, but if we haven't 	 * filled all the buffers with data then we still 	 * want to accept more. 	 */
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
return|return;
name|indicate_active
label|:
comment|/* 	 * The transmitter is active, and there are no room for 	 * more outgoing packets in the transmission buffer. 	 */
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
return|return;
block|}
comment|/*  * Drop (skip) a packet from receive buffer in 86960 memory.  */
specifier|static
name|void
name|fe_droppacket
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* 	 * 86960 manual says that we have to read 8 bytes from the buffer 	 * before skip the packets and that there must be more than 8 bytes 	 * remaining in the buffer when issue a skip command. 	 * Remember, we have already read 4 bytes before come here. 	 */
if|if
condition|(
name|len
operator|>
literal|12
condition|)
block|{
comment|/* Read 4 more bytes, and skip the rest of the packet.  */
operator|(
name|void
operator|)
name|inw
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_BMPR8
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|inw
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_BMPR8
index|]
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_BMPR14
index|]
argument_list|,
name|sc
operator|->
name|proto_bmpr14
operator||
name|FE_B14_SKIP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We should not come here unless receiving RUNTs.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|+=
literal|2
control|)
block|{
operator|(
name|void
operator|)
name|inw
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_BMPR8
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/*  * Empty receiving buffer.  */
specifier|static
name|void
name|fe_emptybuffer
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u_char
name|saved_dlcr5
decl_stmt|;
if|#
directive|if
name|FE_DEBUG
operator|>=
literal|2
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"fe%d: emptying receive buffer\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Stop receiving packets, temporarily. 	 */
name|saved_dlcr5
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR5
index|]
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR5
index|]
argument_list|,
name|sc
operator|->
name|proto_dlcr5
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1300
argument_list|)
expr_stmt|;
comment|/* 	 * When we come here, the receive buffer management should 	 * have been broken.  So, we cannot use skip operation. 	 * Just discard everything in the buffer. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32768
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR5
index|]
argument_list|)
operator|&
name|FE_D5_BUFEMP
condition|)
break|break;
operator|(
name|void
operator|)
name|inw
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_BMPR8
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Double check. 	 */
if|if
condition|(
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR5
index|]
argument_list|)
operator|&
name|FE_D5_BUFEMP
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fe%d: could not empty receive buffer\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
comment|/* Hmm.  What should I do if this happens?  FIXME.  */
block|}
comment|/* 	 * Restart receiving packets. 	 */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR5
index|]
argument_list|,
name|saved_dlcr5
argument_list|)
expr_stmt|;
block|}
comment|/*  * Transmission interrupt handler  * The control flow of this function looks silly.  FIXME.  */
specifier|static
name|void
name|fe_tint
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|,
name|u_char
name|tstat
parameter_list|)
block|{
name|int
name|left
decl_stmt|;
name|int
name|col
decl_stmt|;
comment|/* 	 * Handle "excessive collision" interrupt. 	 */
if|if
condition|(
name|tstat
operator|&
name|FE_D0_COLL16
condition|)
block|{
comment|/* 		 * Find how many packets (including this collided one) 		 * are left unsent in transmission buffer. 		 */
name|left
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_BMPR10
index|]
argument_list|)
expr_stmt|;
if|#
directive|if
name|FE_DEBUG
operator|>=
literal|2
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"fe%d: excessive collision (%d/%d)\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|left
argument_list|,
name|sc
operator|->
name|txb_sched
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|FE_DEBUG
operator|>=
literal|3
name|fe_dump
argument_list|(
name|LOG_INFO
argument_list|,
name|sc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * Clear the collision flag (in 86960) here 		 * to avoid confusing statistics. 		 */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR0
index|]
argument_list|,
name|FE_D0_COLLID
argument_list|)
expr_stmt|;
comment|/* 		 * Restart transmitter, skipping the 		 * collided packet. 		 * 		 * We *must* skip the packet to keep network running 		 * properly.  Excessive collision error is an 		 * indication of the network overload.  If we 		 * tried sending the same packet after excessive 		 * collision, the network would be filled with 		 * out-of-time packets.  Packets belonging 		 * to reliable transport (such as TCP) are resent 		 * by some upper layer. 		 */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_BMPR11
index|]
argument_list|,
name|FE_B11_CTRL_SKIP
operator||
name|FE_B11_MODE1
argument_list|)
expr_stmt|;
comment|/* Update statistics.  */
name|sc
operator|->
name|tx_excolls
operator|++
expr_stmt|;
block|}
comment|/* 	 * Handle "transmission complete" interrupt. 	 */
if|if
condition|(
name|tstat
operator|&
name|FE_D0_TXDONE
condition|)
block|{
comment|/* 		 * Add in total number of collisions on last 		 * transmission.  We also clear "collision occurred" flag 		 * here. 		 * 		 * 86960 has a design flaw on collision count on multiple 		 * packet transmission.  When we send two or more packets 		 * with one start command (that's what we do when the 		 * transmission queue is crowded), 86960 informs us number 		 * of collisions occurred on the last packet on the 		 * transmission only.  Number of collisions on previous 		 * packets are lost.  I have told that the fact is clearly 		 * stated in the Fujitsu document. 		 * 		 * I considered not to mind it seriously.  Collision 		 * count is not so important, anyway.  Any comments?  FIXME. 		 */
if|if
condition|(
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR0
index|]
argument_list|)
operator|&
name|FE_D0_COLLID
condition|)
block|{
comment|/* Clear collision flag.  */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR0
index|]
argument_list|,
name|FE_D0_COLLID
argument_list|)
expr_stmt|;
comment|/* Extract collision count from 86960.  */
name|col
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR4
index|]
argument_list|)
expr_stmt|;
name|col
operator|=
operator|(
name|col
operator|&
name|FE_D4_COL
operator|)
operator|>>
name|FE_D4_COL_SHIFT
expr_stmt|;
if|if
condition|(
name|col
operator|==
literal|0
condition|)
block|{
comment|/* 				 * Status register indicates collisions, 				 * while the collision count is zero. 				 * This can happen after multiple packet 				 * transmission, indicating that one or more 				 * previous packet(s) had been collided. 				 * 				 * Since the accurate number of collisions 				 * has been lost, we just guess it as 1; 				 * Am I too optimistic?  FIXME. 				 */
name|col
operator|=
literal|1
expr_stmt|;
block|}
name|sc
operator|->
name|sc_if
operator|.
name|if_collisions
operator|+=
name|col
expr_stmt|;
if|#
directive|if
name|FE_DEBUG
operator|>=
literal|3
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"fe%d: %d collision(s) (%d)\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|col
argument_list|,
name|sc
operator|->
name|txb_sched
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 		 * Update transmission statistics. 		 * Be sure to reflect number of excessive collisions. 		 */
name|sc
operator|->
name|sc_if
operator|.
name|if_opackets
operator|+=
name|sc
operator|->
name|txb_sched
operator|-
name|sc
operator|->
name|tx_excolls
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_oerrors
operator|+=
name|sc
operator|->
name|tx_excolls
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_collisions
operator|+=
name|sc
operator|->
name|tx_excolls
operator|*
literal|16
expr_stmt|;
name|sc
operator|->
name|txb_sched
operator|=
literal|0
expr_stmt|;
comment|/* 		 * The transmitter is no more active. 		 * Reset output active flag and watchdog timer. 		 */
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_timer
operator|=
literal|0
expr_stmt|;
comment|/* 		 * If more data is ready to transmit in the buffer, start 		 * transmitting them.  Otherwise keep transmitter idle, 		 * even if more data is queued.  This gives receive 		 * process a slight priority. 		 */
if|if
condition|(
name|sc
operator|->
name|txb_count
operator|>
literal|0
condition|)
name|fe_xmit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  * Ethernet interface receiver interrupt.  */
specifier|static
name|void
name|fe_rint
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|,
name|u_char
name|rstat
parameter_list|)
block|{
name|u_short
name|len
decl_stmt|;
name|u_char
name|status
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Update statistics if this interrupt is caused by an error. 	 */
if|if
condition|(
name|rstat
operator|&
operator|(
name|FE_D1_OVRFLO
operator||
name|FE_D1_CRCERR
operator||
name|FE_D1_ALGERR
operator||
name|FE_D1_SRTPKT
operator|)
condition|)
block|{
if|#
directive|if
name|FE_DEBUG
operator|>=
literal|2
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"fe%d: receive error: %s%s%s%s(%02x)\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|rstat
operator|&
name|FE_D1_OVRFLO
condition|?
literal|"OVR "
else|:
literal|""
argument_list|,
name|rstat
operator|&
name|FE_D1_CRCERR
condition|?
literal|"CRC "
else|:
literal|""
argument_list|,
name|rstat
operator|&
name|FE_D1_ALGERR
condition|?
literal|"ALG "
else|:
literal|""
argument_list|,
name|rstat
operator|&
name|FE_D1_SRTPKT
condition|?
literal|"LEN "
else|:
literal|""
argument_list|,
name|rstat
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|sc_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
block|}
comment|/* 	 * MB86960 has a flag indicating "receive queue empty." 	 * We just loop, checking the flag, to pull out all received 	 * packets. 	 * 	 * We limit the number of iterations to avoid infinite-loop. 	 * The upper bound is set to unrealistic high value. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FE_MAX_RECV_COUNT
operator|*
literal|2
condition|;
name|i
operator|++
control|)
block|{
comment|/* Stop the iteration if 86960 indicates no packets.  */
if|if
condition|(
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR5
index|]
argument_list|)
operator|&
name|FE_D5_BUFEMP
condition|)
break|break;
comment|/* 		 * Extract A receive status byte. 		 * As our 86960 is in 16 bit bus access mode, we have to 		 * use inw() to get the status byte.  The significant 		 * value is returned in lower 8 bits. 		 */
name|status
operator|=
operator|(
name|u_char
operator|)
name|inw
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_BMPR8
index|]
argument_list|)
expr_stmt|;
if|#
directive|if
name|FE_DEBUG
operator|>=
literal|4
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"fe%d: receive status = %04x\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|status
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * Extract the packet length. 		 * It is a sum of a header (14 bytes) and a payload. 		 * CRC has been stripped off by the 86960. 		 */
name|len
operator|=
name|inw
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_BMPR8
index|]
argument_list|)
expr_stmt|;
if|#
directive|if
name|FE_DEBUG
operator|>=
literal|1
comment|/* 		 * If there was an error with the received packet, it 		 * must be an indication of out-of-sync on receive 		 * buffer, because we have programmed the 8696x to 		 * to discard errored packets, even when the interface 		 * is in promiscuous mode.  We have to re-synchronize. 		 */
if|if
condition|(
operator|!
operator|(
name|status
operator|&
name|FE_RPH_GOOD
operator|)
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fe%d: corrupted receive status byte (%02x)\n"
argument_list|,
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_unit
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
name|fe_emptybuffer
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
if|#
directive|if
name|FE_DEBUG
operator|>=
literal|1
comment|/* 		 * MB86960 checks the packet length and drop big packet 		 * before passing it to us.  There are no chance we can 		 * get big packets through it, even if they are actually 		 * sent over a line.  Hence, if the length exceeds 		 * the specified limit, it means some serious failure, 		 * such as out-of-sync on receive buffer management. 		 * 		 * Same for short packets, since we have programmed 		 * 86960 to drop short packets. 		 */
if|if
condition|(
name|len
operator|>
name|ETHER_MAX_LEN
operator|-
name|ETHER_CRC_LEN
operator|||
name|len
operator|<
name|ETHER_MIN_LEN
operator|-
name|ETHER_CRC_LEN
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"fe%d: received a %s packet? (%u bytes)\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|len
operator|<
name|ETHER_MIN_LEN
operator|-
name|ETHER_CRC_LEN
condition|?
literal|"partial"
else|:
literal|"big"
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
name|fe_emptybuffer
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* 		 * Go get a packet. 		 */
if|if
condition|(
name|fe_get_packet
argument_list|(
name|sc
argument_list|,
name|len
argument_list|)
operator|<
literal|0
condition|)
block|{
if|#
directive|if
name|FE_DEBUG
operator|>=
literal|2
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"%s%d: out of mbuf;"
literal|" dropping a packet (%u bytes)\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Skip a packet, updating statistics.  */
name|sc
operator|->
name|sc_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
name|fe_droppacket
argument_list|(
name|sc
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* 			 * Try extracting other packets, although they will 			 * cause out-of-mbuf error again.  This is required 			 * to keep receiver interrupt comming. 			 * (Earlier versions had a bug on this point.) 			 */
continue|continue;
block|}
comment|/* Successfully received a packet.  Update stat.  */
name|sc
operator|->
name|sc_if
operator|.
name|if_ipackets
operator|++
expr_stmt|;
block|}
block|}
comment|/*  * Ethernet interface interrupt processor  */
name|void
name|feintr
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|struct
name|fe_softc
modifier|*
name|sc
init|=
operator|&
name|fe_softc
index|[
name|unit
index|]
decl_stmt|;
name|u_char
name|tstat
decl_stmt|,
name|rstat
decl_stmt|;
comment|/* 	 * Loop until there are no more new interrupt conditions. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
if|#
directive|if
name|FE_DEBUG
operator|>=
literal|4
name|fe_dump
argument_list|(
name|LOG_INFO
argument_list|,
name|sc
argument_list|,
literal|"intr()"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * Get interrupt conditions, masking unneeded flags. 		 */
name|tstat
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR0
index|]
argument_list|)
operator|&
name|FE_TMASK
expr_stmt|;
name|rstat
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR1
index|]
argument_list|)
operator|&
name|FE_RMASK
expr_stmt|;
if|#
directive|if
name|FE_DEBUG
operator|>=
literal|1
comment|/* Test for a "dead-lock" condition.  */
if|if
condition|(
operator|(
name|rstat
operator|&
name|FE_D1_PKTRDY
operator|)
operator|==
literal|0
operator|&&
operator|(
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR5
index|]
argument_list|)
operator|&
name|FE_D5_BUFEMP
operator|)
operator|==
literal|0
operator|&&
operator|(
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR1
index|]
argument_list|)
operator|&
name|FE_D1_PKTRDY
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * PKTRDY is off, while receive buffer is not empty. 			 * We did a double check to avoid a race condition... 			 * So, we should have missed an interrupt. 			 */
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"fe%d: missed a receiver interrupt?\n"
argument_list|,
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_unit
argument_list|)
expr_stmt|;
comment|/* Simulate the missed interrupt condition.  */
name|rstat
operator||=
name|FE_D1_PKTRDY
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Stop processing if there are no interrupts to handle.  */
if|if
condition|(
name|tstat
operator|==
literal|0
operator|&&
name|rstat
operator|==
literal|0
condition|)
break|break;
comment|/* 		 * Reset the conditions we are acknowledging. 		 */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR0
index|]
argument_list|,
name|tstat
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR1
index|]
argument_list|,
name|rstat
argument_list|)
expr_stmt|;
comment|/* 		 * Handle transmitter interrupts. Handle these first because 		 * the receiver will reset the board under some conditions. 		 */
if|if
condition|(
name|tstat
condition|)
block|{
name|fe_tint
argument_list|(
name|sc
argument_list|,
name|tstat
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Handle receiver interrupts 		 */
if|if
condition|(
name|rstat
condition|)
block|{
name|fe_rint
argument_list|(
name|sc
argument_list|,
name|rstat
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Update the multicast address filter if it is 		 * needed and possible.  We do it now, because 		 * we can make sure the transmission buffer is empty, 		 * and there is a good chance that the receive queue 		 * is empty.  It will minimize the possibility of 		 * packet loss. 		 */
if|if
condition|(
name|sc
operator|->
name|filter_change
operator|&&
name|sc
operator|->
name|txb_count
operator|==
literal|0
operator|&&
name|sc
operator|->
name|txb_sched
operator|==
literal|0
condition|)
block|{
name|fe_loadmar
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
block|}
comment|/* 		 * If it looks like the transmitter can take more data, 		 * attempt to start output on the interface. This is done 		 * after handling the receiver interrupt to give the 		 * receive operation priority. 		 * 		 * BTW, I'm not sure in what case the OACTIVE is on at 		 * this point.  Is the following test redundant? 		 * 		 * No.  This routine polls for both transmitter and 		 * receiver interrupts.  86960 can raise a receiver 		 * interrupt when the transmission buffer is full. 		 */
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&
name|IFF_OACTIVE
operator|)
operator|==
literal|0
condition|)
block|{
name|fe_start
argument_list|(
operator|&
name|sc
operator|->
name|sc_if
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/*  * Process an ioctl request. This code needs some work - it looks  * pretty ugly.  */
specifier|static
name|int
name|fe_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|command
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|fe_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|FE_DEBUG
operator|>=
literal|3
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"fe%d: ioctl(%x)\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|command
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
block|{
name|struct
name|ifaddr
modifier|*
name|ifa
init|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|data
decl_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
switch|switch
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|fe_init
argument_list|(
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
comment|/* before arp_ifinit */
name|arp_ifinit
argument_list|(
operator|&
name|sc
operator|->
name|arpcom
argument_list|,
name|ifa
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IPX
comment|/* 			 * XXX - This code is probably wrong 			 */
case|case
name|AF_IPX
case|:
block|{
specifier|register
name|struct
name|ipx_addr
modifier|*
name|ina
init|=
operator|&
operator|(
name|IA_SIPX
argument_list|(
name|ifa
argument_list|)
operator|->
name|sipx_addr
operator|)
decl_stmt|;
if|if
condition|(
name|ipx_nullhost
argument_list|(
operator|*
name|ina
argument_list|)
condition|)
name|ina
operator|->
name|x_host
operator|=
operator|*
operator|(
expr|union
name|ipx_host
operator|*
operator|)
operator|(
name|sc
operator|->
name|sc_enaddr
operator|)
expr_stmt|;
else|else
block|{
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|ina
operator|->
name|x_host
operator|.
name|c_host
argument_list|,
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|sc_enaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_enaddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 				 * Set new address 				 */
name|fe_init
argument_list|(
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
comment|/* IPV6 added by shin 96.2.6 */
name|fe_init
argument_list|(
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
name|ndp6_ifinit
argument_list|(
operator|&
name|sc
operator|->
name|arpcom
argument_list|,
name|ifa
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NS
comment|/* 			 * XXX - This code is probably wrong 			 */
case|case
name|AF_NS
case|:
block|{
specifier|register
name|struct
name|ns_addr
modifier|*
name|ina
init|=
operator|&
operator|(
name|IA_SNS
argument_list|(
name|ifa
argument_list|)
operator|->
name|sns_addr
operator|)
decl_stmt|;
if|if
condition|(
name|ns_nullhost
argument_list|(
operator|*
name|ina
argument_list|)
condition|)
name|ina
operator|->
name|x_host
operator|=
operator|*
operator|(
expr|union
name|ns_host
operator|*
operator|)
operator|(
name|sc
operator|->
name|sc_enaddr
operator|)
expr_stmt|;
else|else
block|{
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|ina
operator|->
name|x_host
operator|.
name|c_host
argument_list|,
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|sc_enaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_enaddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 				 * Set new address 				 */
name|fe_init
argument_list|(
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
default|default:
name|fe_init
argument_list|(
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
block|}
ifdef|#
directive|ifdef
name|SIOCGIFADDR
case|case
name|SIOCGIFADDR
case|:
block|{
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|sa
init|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ifr
operator|->
name|ifr_data
decl_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|sc_enaddr
argument_list|,
operator|(
name|caddr_t
operator|)
name|sa
operator|->
name|sa_data
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIOCGIFPHYSADDR
case|case
name|SIOCGIFPHYSADDR
case|:
block|{
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|sc_enaddr
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ifr
operator|->
name|ifr_data
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|notdef
ifdef|#
directive|ifdef
name|SIOCSIFPHYSADDR
case|case
name|SIOCSIFPHYSADDR
case|:
block|{
comment|/* 		 * Set the physical (Ethernet) address of the interface. 		 * When and by whom is this command used?  FIXME. 		 */
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|ifr
operator|->
name|ifr_data
argument_list|,
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|sc_enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|fe_setlinkaddr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
endif|#
directive|endif
comment|/* notdef */
ifdef|#
directive|ifdef
name|SIOCSIFFLAGS
case|case
name|SIOCSIFFLAGS
case|:
block|{
comment|/* 		 * Switch interface state between "running" and 		 * "stopped", reflecting the UP flag. 		 */
if|if
condition|(
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
name|fe_init
argument_list|(
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|!=
literal|0
condition|)
block|{
name|fe_stop
argument_list|(
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * Promiscuous and/or multicast flags may have changed, 		 * so reprogram the multicast filter and/or receive mode. 		 */
name|fe_setmode
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|#
directive|if
name|FE_DEBUG
operator|>=
literal|1
comment|/* "ifconfig fe0 debug" to print register dump.  */
if|if
condition|(
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
block|{
name|fe_dump
argument_list|(
name|LOG_DEBUG
argument_list|,
name|sc
argument_list|,
literal|"SIOCSIFFLAGS(DEBUG)"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIOCADDMULTI
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
comment|/* 	     * Multicast list has changed; set the hardware filter 	     * accordingly. 	     */
name|fe_setmode
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIOCSIFMTU
case|case
name|SIOCSIFMTU
case|:
block|{
comment|/* 		 * Set the interface MTU. 		 */
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|ifr
operator|->
name|ifr_mtu
operator|>
name|ETHERMTU
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|sc_if
operator|.
name|if_mtu
operator|=
name|ifr
operator|->
name|ifr_mtu
expr_stmt|;
block|}
break|break;
block|}
endif|#
directive|endif
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/*  * Retrieve packet from receive buffer and send to the next level up via  * ether_input(). If there is a BPF listener, give a copy to BPF, too.  * Returns 0 if success, -1 if error (i.e., mbuf allocation failure).  */
specifier|static
name|int
name|fe_get_packet
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|,
name|u_short
name|len
parameter_list|)
block|{
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
comment|/* 	 * NFS wants the data be aligned to the word (4 byte) 	 * boundary.  Ethernet header has 14 bytes.  There is a 	 * 2-byte gap. 	 */
define|#
directive|define
name|NFS_MAGIC_OFFSET
value|2
comment|/* 	 * This function assumes that an Ethernet packet fits in an 	 * mbuf (with a cluster attached when necessary.)  On FreeBSD 	 * 2.0 for x86, which is the primary target of this driver, an 	 * mbuf cluster has 4096 bytes, and we are happy.  On ancient 	 * BSDs, such as vanilla 4.3 for 386, a cluster size was 1024, 	 * however.  If the following #error message were printed upon 	 * compile, you need to rewrite this function. 	 */
if|#
directive|if
operator|(
name|MCLBYTES
operator|<
name|ETHER_MAX_LEN
operator|-
name|ETHER_CRC_LEN
operator|+
name|NFS_MAGIC_OFFSET
operator|)
error|#
directive|error
literal|"Too small MCLBYTES to use fe driver."
endif|#
directive|endif
comment|/* 	 * Our strategy has one more problem.  There is a policy on 	 * mbuf cluster allocation.  It says that we must have at 	 * least MINCLSIZE (208 bytes on FreeBSD 2.0 for x86) to 	 * allocate a cluster.  For a packet of a size between 	 * (MHLEN - 2) to (MINCLSIZE - 2), our code violates the rule... 	 * On the other hand, the current code is short, simple, 	 * and fast, however.  It does no harmful thing, just waists 	 * some memory.  Any comments?  FIXME. 	 */
comment|/* Allocate an mbuf with packet header info.  */
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Attach a cluster if this packet doesn't fit in a normal mbuf.  */
if|if
condition|(
name|len
operator|>
name|MHLEN
operator|-
name|NFS_MAGIC_OFFSET
condition|)
block|{
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|/* Initialize packet header info.  */
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
operator|&
name|sc
operator|->
name|sc_if
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|len
expr_stmt|;
comment|/* Set the length of this packet.  */
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
comment|/* The following silliness is to make NFS happy */
name|m
operator|->
name|m_data
operator|+=
name|NFS_MAGIC_OFFSET
expr_stmt|;
comment|/* Get a packet.  */
name|insw
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_BMPR8
index|]
argument_list|,
name|m
operator|->
name|m_data
argument_list|,
operator|(
name|len
operator|+
literal|1
operator|)
operator|>>
literal|1
argument_list|)
expr_stmt|;
comment|/* Get (actually just point to) the header part.  */
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
define|#
directive|define
name|ETHER_ADDR_IS_MULTICAST
parameter_list|(
name|A
parameter_list|)
value|(*(char *)(A)& 1)
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
comment|/* 	 * Check if there's a BPF listener on this interface. 	 * If it is, hand off the raw packet to bpf. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_if
operator|.
name|if_bpf
condition|)
block|{
name|bpf_mtap
argument_list|(
operator|&
name|sc
operator|->
name|sc_if
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * Make sure this packet is (or may be) directed to us. 	 * That is, the packet is either unicasted to our address, 	 * or broad/multi-casted.  If any other packets are 	 * received, it is an indication of an error -- probably 	 * 86960 is in a wrong operation mode. 	 * Promiscuous mode is an exception.  Under the mode, all 	 * packets on the media must be received.  (We must have 	 * programmed the 86960 so.) 	 */
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
operator|&&
operator|!
name|ETHER_ADDR_IS_MULTICAST
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|)
operator|&&
name|bcmp
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|,
name|sc
operator|->
name|sc_enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * The packet was not for us.  This is normal since 		 * we are now in promiscuous mode.  Just drop the packet. 		 */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|#
directive|if
name|FE_DEBUG
operator|>=
literal|3
if|if
condition|(
operator|!
name|ETHER_ADDR_IS_MULTICAST
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|)
operator|&&
name|bcmp
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|,
name|sc
operator|->
name|sc_enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * This packet was not for us.  We can't be in promiscuous 		 * mode since the case was handled by above test. 		 * We found an error (of this driver.) 		 */
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"fe%d: got an unwanted packet, dst = %6D\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|eh
operator|->
name|ether_dhost
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
comment|/* Strip off the Ethernet header.  */
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
comment|/* Feed the packet to upper layer.  */
name|ether_input
argument_list|(
operator|&
name|sc
operator|->
name|sc_if
argument_list|,
name|eh
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/*  * Write an mbuf chain to the transmission buffer memory using 16 bit PIO.  * Returns number of bytes actually written, including length word.  *  * If an mbuf chain is too long for an Ethernet frame, it is not sent.  * Packets shorter than Ethernet minimum are legal, and we pad them  * before sending out.  An exception is "partial" packets which are  * shorter than mandatory Ethernet header.  */
specifier|static
name|void
name|fe_write_mbufs
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|u_short
name|addr_bmpr8
init|=
name|sc
operator|->
name|ioaddr
index|[
name|FE_BMPR8
index|]
decl_stmt|;
name|u_short
name|length
decl_stmt|,
name|len
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mp
decl_stmt|;
name|u_char
modifier|*
name|data
decl_stmt|;
name|u_short
name|savebyte
decl_stmt|;
comment|/* WARNING: Architecture dependent!  */
define|#
directive|define
name|NO_PENDING_BYTE
value|0xFFFF
specifier|static
name|u_char
name|padding
index|[
name|ETHER_MIN_LEN
operator|-
name|ETHER_CRC_LEN
operator|-
name|ETHER_HDR_LEN
index|]
decl_stmt|;
if|#
directive|if
name|FE_DEBUG
operator|>=
literal|1
comment|/* First, count up the total number of bytes to copy */
name|length
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|mp
operator|=
name|m
init|;
name|mp
operator|!=
name|NULL
condition|;
name|mp
operator|=
name|mp
operator|->
name|m_next
control|)
block|{
name|length
operator|+=
name|mp
operator|->
name|m_len
expr_stmt|;
block|}
else|#
directive|else
comment|/* Just use the length value in the packet header.  */
name|length
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|FE_DEBUG
operator|>=
literal|2
comment|/* Check if this matches the one in the packet header.  */
if|if
condition|(
name|length
operator|!=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"fe%d: packet length mismatch? (%d/%d)\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|length
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|FE_DEBUG
operator|>=
literal|1
comment|/* 	 * Should never send big packets.  If such a packet is passed, 	 * it should be a bug of upper layer.  We just ignore it. 	 * ... Partial (too short) packets, neither. 	 */
if|if
condition|(
name|length
operator|<
name|ETHER_HDR_LEN
operator|||
name|length
operator|>
name|ETHER_MAX_LEN
operator|-
name|ETHER_CRC_LEN
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fe%d: got an out-of-spec packet (%u bytes) to send\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_oerrors
operator|++
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* 	 * Put the length word for this frame. 	 * Does 86960 accept odd length?  -- Yes. 	 * Do we need to pad the length to minimum size by ourselves? 	 * -- Generally yes.  But for (or will be) the last 	 * packet in the transmission buffer, we can skip the 	 * padding process.  It may gain performance slightly.  FIXME. 	 */
name|outw
argument_list|(
name|addr_bmpr8
argument_list|,
name|max
argument_list|(
name|length
argument_list|,
name|ETHER_MIN_LEN
operator|-
name|ETHER_CRC_LEN
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Update buffer status now. 	 * Truncate the length up to an even number, since we use outw(). 	 */
name|length
operator|=
operator|(
name|length
operator|+
literal|1
operator|)
operator|&
operator|~
literal|1
expr_stmt|;
name|sc
operator|->
name|txb_free
operator|-=
name|FE_DATA_LEN_LEN
operator|+
name|max
argument_list|(
name|length
argument_list|,
name|ETHER_MIN_LEN
operator|-
name|ETHER_CRC_LEN
argument_list|)
expr_stmt|;
name|sc
operator|->
name|txb_count
operator|++
expr_stmt|;
comment|/* 	 * Transfer the data from mbuf chain to the transmission buffer. 	 * MB86960 seems to require that data be transferred as words, and 	 * only words.  So that we require some extra code to patch 	 * over odd-length mbufs. 	 */
name|savebyte
operator|=
name|NO_PENDING_BYTE
expr_stmt|;
for|for
control|(
name|mp
operator|=
name|m
init|;
name|mp
operator|!=
literal|0
condition|;
name|mp
operator|=
name|mp
operator|->
name|m_next
control|)
block|{
comment|/* Ignore empty mbuf.  */
name|len
operator|=
name|mp
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
continue|continue;
comment|/* Find the actual data to send.  */
name|data
operator|=
name|mtod
argument_list|(
name|mp
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
comment|/* Finish the last byte.  */
if|if
condition|(
name|savebyte
operator|!=
name|NO_PENDING_BYTE
condition|)
block|{
name|outw
argument_list|(
name|addr_bmpr8
argument_list|,
name|savebyte
operator||
operator|(
operator|*
name|data
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
name|data
operator|++
expr_stmt|;
name|len
operator|--
expr_stmt|;
name|savebyte
operator|=
name|NO_PENDING_BYTE
expr_stmt|;
block|}
comment|/* output contiguous words */
if|if
condition|(
name|len
operator|>
literal|1
condition|)
block|{
name|outsw
argument_list|(
name|addr_bmpr8
argument_list|,
name|data
argument_list|,
name|len
operator|>>
literal|1
argument_list|)
expr_stmt|;
name|data
operator|+=
name|len
operator|&
operator|~
literal|1
expr_stmt|;
name|len
operator|&=
literal|1
expr_stmt|;
block|}
comment|/* Save a remaining byte, if there is one.  */
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|savebyte
operator|=
operator|*
name|data
expr_stmt|;
block|}
block|}
comment|/* Spit the last byte, if the length is odd.  */
if|if
condition|(
name|savebyte
operator|!=
name|NO_PENDING_BYTE
condition|)
block|{
name|outw
argument_list|(
name|addr_bmpr8
argument_list|,
name|savebyte
argument_list|)
expr_stmt|;
block|}
comment|/* Pad to the Ethernet minimum length, if the packet is too short.  */
if|if
condition|(
name|length
operator|<
name|ETHER_MIN_LEN
operator|-
name|ETHER_CRC_LEN
condition|)
block|{
name|outsw
argument_list|(
name|addr_bmpr8
argument_list|,
name|padding
argument_list|,
operator|(
name|ETHER_MIN_LEN
operator|-
name|ETHER_CRC_LEN
operator|-
name|length
operator|)
operator|>>
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  * Compute hash value for an Ethernet address  */
specifier|static
name|int
name|fe_hash
parameter_list|(
name|u_char
modifier|*
name|ep
parameter_list|)
block|{
define|#
directive|define
name|FE_HASH_MAGIC_NUMBER
value|0xEDB88320L
name|u_long
name|hash
init|=
literal|0xFFFFFFFFL
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|u_char
name|b
decl_stmt|;
name|u_long
name|m
decl_stmt|;
for|for
control|(
name|i
operator|=
name|ETHER_ADDR_LEN
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
block|{
name|b
operator|=
operator|*
name|ep
operator|++
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|8
init|;
operator|--
name|j
operator|>=
literal|0
condition|;
control|)
block|{
name|m
operator|=
name|hash
expr_stmt|;
name|hash
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|^
name|b
operator|)
operator|&
literal|1
condition|)
name|hash
operator|^=
name|FE_HASH_MAGIC_NUMBER
expr_stmt|;
name|b
operator|>>=
literal|1
expr_stmt|;
block|}
block|}
return|return
operator|(
call|(
name|int
call|)
argument_list|(
name|hash
operator|>>
literal|26
argument_list|)
operator|)
return|;
block|}
comment|/*  * Compute the multicast address filter from the  * list of multicast addresses we need to listen to.  */
specifier|static
name|struct
name|fe_filter
name|fe_mcaf
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|index
decl_stmt|;
name|struct
name|fe_filter
name|filter
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|filter
operator|=
name|fe_filter_nothing
expr_stmt|;
for|for
control|(
name|ifma
operator|=
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_multiaddrs
operator|.
name|lh_first
init|;
name|ifma
condition|;
name|ifma
operator|=
name|ifma
operator|->
name|ifma_link
operator|.
name|le_next
control|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
name|index
operator|=
name|fe_hash
argument_list|(
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|FE_DEBUG
operator|>=
literal|4
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"fe%d: hash(%6D) == %d\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|enm
operator|->
name|enm_addrlo
argument_list|,
literal|":"
argument_list|,
name|index
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|filter
operator|.
name|data
index|[
name|index
operator|>>
literal|3
index|]
operator||=
literal|1
operator|<<
operator|(
name|index
operator|&
literal|7
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|filter
operator|)
return|;
block|}
comment|/*  * Calculate a new "multicast packet filter" and put the 86960  * receiver in appropriate mode.  */
specifier|static
name|void
name|fe_setmode
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|flags
init|=
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
decl_stmt|;
comment|/* 	 * If the interface is not running, we postpone the update 	 * process for receive modes and multicast address filter 	 * until the interface is restarted.  It reduces some 	 * complicated job on maintaining chip states.  (Earlier versions 	 * of this driver had a bug on that point...) 	 * 	 * To complete the trick, fe_init() calls fe_setmode() after 	 * restarting the interface. 	 */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|IFF_RUNNING
operator|)
condition|)
return|return;
comment|/* 	 * Promiscuous mode is handled separately. 	 */
if|if
condition|(
name|flags
operator|&
name|IFF_PROMISC
condition|)
block|{
comment|/* 		 * Program 86960 to receive all packets on the segment 		 * including those directed to other stations. 		 * Multicast filter stored in MARs are ignored 		 * under this setting, so we don't need to update it. 		 * 		 * Promiscuous mode in FreeBSD 2 is used solely by 		 * BPF, and BPF only listens to valid (no error) packets. 		 * So, we ignore erroneous ones even in this mode. 		 * (Older versions of fe driver mistook the point.) 		 */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR5
index|]
argument_list|,
name|sc
operator|->
name|proto_dlcr5
operator||
name|FE_D5_AFM0
operator||
name|FE_D5_AFM1
argument_list|)
expr_stmt|;
name|sc
operator|->
name|filter_change
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|FE_DEBUG
operator|>=
literal|3
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"fe%d: promiscuous mode\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
comment|/* 	 * Turn the chip to the normal (non-promiscuous) mode. 	 */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR5
index|]
argument_list|,
name|sc
operator|->
name|proto_dlcr5
operator||
name|FE_D5_AFM1
argument_list|)
expr_stmt|;
comment|/* 	 * Find the new multicast filter value. 	 * I'm not sure we have to handle modes other than MULTICAST. 	 * Who sets ALLMULTI?  Who turns MULTICAST off?  FIXME. 	 */
if|if
condition|(
name|flags
operator|&
name|IFF_ALLMULTI
condition|)
block|{
name|sc
operator|->
name|filter
operator|=
name|fe_filter_all
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|IFF_MULTICAST
condition|)
block|{
name|sc
operator|->
name|filter
operator|=
name|fe_mcaf
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|filter
operator|=
name|fe_filter_nothing
expr_stmt|;
block|}
name|sc
operator|->
name|filter_change
operator|=
literal|1
expr_stmt|;
if|#
directive|if
name|FE_DEBUG
operator|>=
literal|3
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"fe%d: address filter: [%8D]\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|sc
operator|->
name|filter
operator|.
name|data
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * We have to update the multicast filter in the 86960, A.S.A.P. 	 * 	 * Note that the DLC (Data Link Control unit, i.e. transmitter 	 * and receiver) must be stopped when feeding the filter, and 	 * DLC trashes all packets in both transmission and receive 	 * buffers when stopped. 	 * 	 * ... Are the above sentences correct?  I have to check the 	 *     manual of the MB86960A.  FIXME. 	 * 	 * To reduce the packet loss, we delay the filter update 	 * process until buffers are empty. 	 */
if|if
condition|(
name|sc
operator|->
name|txb_sched
operator|==
literal|0
operator|&&
name|sc
operator|->
name|txb_count
operator|==
literal|0
operator|&&
operator|!
operator|(
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR1
index|]
argument_list|)
operator|&
name|FE_D1_PKTRDY
operator|)
condition|)
block|{
comment|/* 		 * Buffers are (apparently) empty.  Load 		 * the new filter value into MARs now. 		 */
name|fe_loadmar
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Buffers are not empty.  Mark that we have to update 		 * the MARs.  The new filter will be loaded by feintr() 		 * later. 		 */
if|#
directive|if
name|FE_DEBUG
operator|>=
literal|4
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"fe%d: filter change delayed\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
comment|/*  * Load a new multicast address filter into MARs.  *  * The caller must have splimp'ed before fe_loadmar.  * This function starts the DLC upon return.  So it can be called only  * when the chip is working, i.e., from the driver's point of view, when  * a device is RUNNING.  (I mistook the point in previous versions.)  */
specifier|static
name|void
name|fe_loadmar
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* Stop the DLC (transmitter and receiver).  */
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR6
index|]
argument_list|,
name|sc
operator|->
name|proto_dlcr6
operator||
name|FE_D6_DLC_DISABLE
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
comment|/* Select register bank 1 for MARs.  */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR7
index|]
argument_list|,
name|sc
operator|->
name|proto_dlcr7
operator||
name|FE_D7_RBS_MAR
operator||
name|FE_D7_POWER_UP
argument_list|)
expr_stmt|;
comment|/* Copy filter value into the registers.  */
name|outblk
argument_list|(
name|sc
argument_list|,
name|FE_MAR8
argument_list|,
name|sc
operator|->
name|filter
operator|.
name|data
argument_list|,
name|FE_FILTER_LEN
argument_list|)
expr_stmt|;
comment|/* Restore the bank selection for BMPRs (i.e., runtime registers).  */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR7
index|]
argument_list|,
name|sc
operator|->
name|proto_dlcr7
operator||
name|FE_D7_RBS_BMPR
operator||
name|FE_D7_POWER_UP
argument_list|)
expr_stmt|;
comment|/* Restart the DLC.  */
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR6
index|]
argument_list|,
name|sc
operator|->
name|proto_dlcr6
operator||
name|FE_D6_DLC_ENABLE
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
comment|/* We have just updated the filter.  */
name|sc
operator|->
name|filter_change
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|FE_DEBUG
operator|>=
literal|3
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"fe%d: address filter changed\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|#
directive|if
name|FE_DEBUG
operator|>=
literal|1
specifier|static
name|void
name|fe_dump
parameter_list|(
name|int
name|level
parameter_list|,
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|,
name|char
modifier|*
name|message
parameter_list|)
block|{
name|log
argument_list|(
name|level
argument_list|,
literal|"fe%d: %s,"
literal|" DLCR = %02x %02x %02x %02x %02x %02x %02x %02x,"
literal|" BMPR = xx xx %02x %02x %02x %02x %02x %02x,"
literal|" asic = %02x %02x %02x %02x %02x %02x %02x %02x"
literal|" + %02x %02x %02x %02x %02x %02x %02x %02x\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|message
condition|?
name|message
else|:
literal|"registers"
argument_list|,
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR0
index|]
argument_list|)
argument_list|,
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR1
index|]
argument_list|)
argument_list|,
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR2
index|]
argument_list|)
argument_list|,
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR3
index|]
argument_list|)
argument_list|,
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR4
index|]
argument_list|)
argument_list|,
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR5
index|]
argument_list|)
argument_list|,
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR6
index|]
argument_list|)
argument_list|,
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR7
index|]
argument_list|)
argument_list|,
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_BMPR10
index|]
argument_list|)
argument_list|,
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_BMPR11
index|]
argument_list|)
argument_list|,
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_BMPR12
index|]
argument_list|)
argument_list|,
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_BMPR13
index|]
argument_list|)
argument_list|,
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_BMPR14
index|]
argument_list|)
argument_list|,
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_BMPR15
index|]
argument_list|)
argument_list|,
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
literal|0x10
index|]
argument_list|)
argument_list|,
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
literal|0x11
index|]
argument_list|)
argument_list|,
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
literal|0x12
index|]
argument_list|)
argument_list|,
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
literal|0x13
index|]
argument_list|)
argument_list|,
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
literal|0x14
index|]
argument_list|)
argument_list|,
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
literal|0x15
index|]
argument_list|)
argument_list|,
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
literal|0x16
index|]
argument_list|)
argument_list|,
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
literal|0x17
index|]
argument_list|)
argument_list|,
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
literal|0x18
index|]
argument_list|)
argument_list|,
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
literal|0x19
index|]
argument_list|)
argument_list|,
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
literal|0x1A
index|]
argument_list|)
argument_list|,
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
literal|0x1B
index|]
argument_list|)
argument_list|,
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
literal|0x1C
index|]
argument_list|)
argument_list|,
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
literal|0x1D
index|]
argument_list|)
argument_list|,
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
literal|0x1E
index|]
argument_list|)
argument_list|,
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
literal|0x1F
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

