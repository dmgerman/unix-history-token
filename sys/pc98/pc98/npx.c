begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1990 William Jolitz.  * Copyright (c) 1991 The Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	from: @(#)npx.c	7.2 (Berkeley) 5/12/91  *	$Id: npx.c,v 1.24 1997/07/21 13:13:43 kato Exp $  */
end_comment

begin_include
include|#
directive|include
file|"npx.h"
end_include

begin_if
if|#
directive|if
name|NNPX
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|"opt_cpu.h"
end_include

begin_include
include|#
directive|include
file|"opt_math_emulate.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|NPX_DEBUG
end_ifdef

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<machine/asmacros.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/ipl.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/pcb.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<machine/specialreg.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/icu.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/intr_machdep.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|PC98
end_ifdef

begin_include
include|#
directive|include
file|<pc98/pc98/pc98.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<i386/isa/isa.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * 387 and 287 Numeric Coprocessor Extension (NPX) Driver.  */
end_comment

begin_comment
comment|/* Configuration flags. */
end_comment

begin_define
define|#
directive|define
name|NPX_DISABLE_I586_OPTIMIZED_BCOPY
value|(1<< 0)
end_define

begin_define
define|#
directive|define
name|NPX_DISABLE_I586_OPTIMIZED_BZERO
value|(1<< 1)
end_define

begin_define
define|#
directive|define
name|NPX_DISABLE_I586_OPTIMIZED_COPYIO
value|(1<< 2)
end_define

begin_comment
comment|/* XXX - should be in header file. */
end_comment

begin_extern
extern|extern void (*bcopy_vector
end_extern

begin_expr_stmt
unit|)
name|__P
argument_list|(
operator|(
specifier|const
name|void
operator|*
name|from
operator|,
name|void
operator|*
name|to
operator|,
name|size_t
name|len
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_extern
extern|extern void (*ovbcopy_vector
end_extern

begin_expr_stmt
unit|)
name|__P
argument_list|(
operator|(
specifier|const
name|void
operator|*
name|from
operator|,
name|void
operator|*
name|to
operator|,
name|size_t
name|len
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_extern
extern|extern int (*copyin_vector
end_extern

begin_expr_stmt
unit|)
name|__P
argument_list|(
operator|(
specifier|const
name|void
operator|*
name|udaddr
operator|,
name|void
operator|*
name|kaddr
operator|,
name|size_t
name|len
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_extern
extern|extern int (*copyout_vector
end_extern

begin_expr_stmt
unit|)
name|__P
argument_list|(
operator|(
specifier|const
name|void
operator|*
name|kaddr
operator|,
name|void
operator|*
name|udaddr
operator|,
name|size_t
name|len
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|void
name|i586_bcopy
name|__P
argument_list|(
operator|(
specifier|const
name|void
operator|*
name|from
operator|,
name|void
operator|*
name|to
operator|,
name|size_t
name|len
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|i586_bzero
name|__P
argument_list|(
operator|(
name|void
operator|*
name|buf
operator|,
name|size_t
name|len
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|i586_copyin
name|__P
argument_list|(
operator|(
specifier|const
name|void
operator|*
name|udaddr
operator|,
name|void
operator|*
name|kaddr
operator|,
name|size_t
name|len
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|i586_copyout
name|__P
argument_list|(
operator|(
specifier|const
name|void
operator|*
name|kaddr
operator|,
name|void
operator|*
name|udaddr
operator|,
name|size_t
name|len
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_define
define|#
directive|define
name|fldcw
parameter_list|(
name|addr
parameter_list|)
value|__asm("fldcw %0" : : "m" (*(addr)))
end_define

begin_define
define|#
directive|define
name|fnclex
parameter_list|()
value|__asm("fnclex")
end_define

begin_define
define|#
directive|define
name|fninit
parameter_list|()
value|__asm("fninit")
end_define

begin_define
define|#
directive|define
name|fnop
parameter_list|()
value|__asm("fnop")
end_define

begin_define
define|#
directive|define
name|fnsave
parameter_list|(
name|addr
parameter_list|)
value|__asm("fnsave %0" : "=m" (*(addr)))
end_define

begin_define
define|#
directive|define
name|fnstcw
parameter_list|(
name|addr
parameter_list|)
value|__asm("fnstcw %0" : "=m" (*(addr)))
end_define

begin_define
define|#
directive|define
name|fnstsw
parameter_list|(
name|addr
parameter_list|)
value|__asm("fnstsw %0" : "=m" (*(addr)))
end_define

begin_define
define|#
directive|define
name|fp_divide_by_0
parameter_list|()
value|__asm("fldz; fld1; fdiv %st,%st(1); fnop")
end_define

begin_define
define|#
directive|define
name|frstor
parameter_list|(
name|addr
parameter_list|)
value|__asm("frstor %0" : : "m" (*(addr)))
end_define

begin_define
define|#
directive|define
name|start_emulating
parameter_list|()
value|__asm("smsw %%ax; orb %0,%%al; lmsw %%ax" \ 				      : : "n" (CR0_TS) : "ax")
end_define

begin_define
define|#
directive|define
name|stop_emulating
parameter_list|()
value|__asm("clts")
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not __GNUC__ */
end_comment

begin_decl_stmt
name|void
name|fldcw
name|__P
argument_list|(
operator|(
name|caddr_t
name|addr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|fnclex
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|fninit
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|fnop
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|fnsave
name|__P
argument_list|(
operator|(
name|caddr_t
name|addr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|fnstcw
name|__P
argument_list|(
operator|(
name|caddr_t
name|addr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|fnstsw
name|__P
argument_list|(
operator|(
name|caddr_t
name|addr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|fp_divide_by_0
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|frstor
name|__P
argument_list|(
operator|(
name|caddr_t
name|addr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|start_emulating
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|stop_emulating
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __GNUC__ */
end_comment

begin_typedef
typedef|typedef
name|u_char
name|bool_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|int
name|npxattach
name|__P
argument_list|(
operator|(
expr|struct
name|isa_device
operator|*
name|dvp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|npxprobe
name|__P
argument_list|(
operator|(
expr|struct
name|isa_device
operator|*
name|dvp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|npxprobe1
name|__P
argument_list|(
operator|(
expr|struct
name|isa_device
operator|*
name|dvp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|isa_driver
name|npxdriver
init|=
block|{
name|npxprobe
block|,
name|npxattach
block|,
literal|"npx"
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|hw_float
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX currently just alias for npx_exists */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw
argument_list|,
name|HW_FLOATINGPT
argument_list|,
name|floatingpoint
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|hw_float
argument_list|,
literal|0
argument_list|,
literal|"Floatingpoint instructions executed in hardware"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_int
name|npx0_imask
init|=
name|SWI_CLOCK_MASK
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|SMP
end_ifndef

begin_comment
comment|/* XXX per-cpu on smp */
end_comment

begin_decl_stmt
name|struct
name|proc
modifier|*
name|npxproc
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|bool_t
name|npx_ex16
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool_t
name|npx_exists
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|gate_descriptor
name|npx_idt_probeintr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|npx_intrno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|volatile
name|u_int
name|npx_intrs_while_probing
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool_t
name|npx_irq13
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|volatile
name|u_int
name|npx_traps_while_probing
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|SMP
end_ifndef

begin_comment
comment|/*  * Special interrupt handlers.  Someday intr0-intr15 will be used to count  * interrupts.  We'll still need a special exception 16 handler.  The busy  * latch stuff in probeintr() can be moved to npxprobe().  */
end_comment

begin_decl_stmt
name|inthand_t
name|probeintr
decl_stmt|;
end_decl_stmt

begin_asm
asm|asm (" 	.text 	.p2align 2,0x90 " __XSTRING(CNAME(probeintr)) ": 	ss 	incl	" __XSTRING(CNAME(npx_intrs_while_probing)) " 	pushl	%eax 	movb	$0x20,%al	# EOI (asm in strings loses cpp features) #ifdef PC98 	outb	%al,$0x08	# IO_ICU2 	outb	%al,$0x0	# IO_ICU1 #else 	outb	%al,$0xa0	# IO_ICU2 	outb	%al,$0x20	# IO_ICU1 #endif 	movb	$0,%al #ifdef PC98 	outb	%al,$0xf8	# clear BUSY# latch #else 	outb	%al,$0xf0	# clear BUSY# latch #endif 	popl	%eax 	iret ");
end_asm

begin_decl_stmt
name|inthand_t
name|probetrap
decl_stmt|;
end_decl_stmt

begin_asm
asm|asm (" 	.text 	.p2align 2,0x90 " __XSTRING(CNAME(probetrap)) ": 	ss 	incl	" __XSTRING(CNAME(npx_traps_while_probing)) " 	fnclex 	iret ");
end_asm

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SMP */
end_comment

begin_comment
comment|/*  * Probe routine.  Initialize cr0 to give correct behaviour for [f]wait  * whether the device exists or not (XXX should be elsewhere).  Set flags  * to tell npxattach() what to do.  Modify device struct if npx doesn't  * need to use interrupts.  Return 1 if device exists.  */
end_comment

begin_function
specifier|static
name|int
name|npxprobe
parameter_list|(
name|dvp
parameter_list|)
name|struct
name|isa_device
modifier|*
name|dvp
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|SMP
return|return
name|npxprobe1
argument_list|(
name|dvp
argument_list|)
return|;
else|#
directive|else
comment|/* SMP */
name|int
name|result
decl_stmt|;
name|u_long
name|save_eflags
decl_stmt|;
name|u_char
name|save_icu1_mask
decl_stmt|;
name|u_char
name|save_icu2_mask
decl_stmt|;
name|struct
name|gate_descriptor
name|save_idt_npxintr
decl_stmt|;
name|struct
name|gate_descriptor
name|save_idt_npxtrap
decl_stmt|;
comment|/* 	 * This routine is now just a wrapper for npxprobe1(), to install 	 * special npx interrupt and trap handlers, to enable npx interrupts 	 * and to disable other interrupts.  Someday isa_configure() will 	 * install suitable handlers and run with interrupts enabled so we 	 * won't need to do so much here. 	 */
name|npx_intrno
operator|=
name|NRSVIDT
operator|+
name|ffs
argument_list|(
name|dvp
operator|->
name|id_irq
argument_list|)
operator|-
literal|1
expr_stmt|;
name|save_eflags
operator|=
name|read_eflags
argument_list|()
expr_stmt|;
name|disable_intr
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|save_icu1_mask
operator|=
name|inb
argument_list|(
name|IO_ICU1
operator|+
literal|2
argument_list|)
expr_stmt|;
name|save_icu2_mask
operator|=
name|inb
argument_list|(
name|IO_ICU2
operator|+
literal|2
argument_list|)
expr_stmt|;
else|#
directive|else
name|save_icu1_mask
operator|=
name|inb
argument_list|(
name|IO_ICU1
operator|+
literal|1
argument_list|)
expr_stmt|;
name|save_icu2_mask
operator|=
name|inb
argument_list|(
name|IO_ICU2
operator|+
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|save_idt_npxintr
operator|=
name|idt
index|[
name|npx_intrno
index|]
expr_stmt|;
name|save_idt_npxtrap
operator|=
name|idt
index|[
literal|16
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|outb
argument_list|(
name|IO_ICU1
operator|+
literal|2
argument_list|,
operator|~
operator|(
name|IRQ_SLAVE
operator||
name|dvp
operator|->
name|id_irq
operator|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|IO_ICU2
operator|+
literal|2
argument_list|,
operator|~
operator|(
name|dvp
operator|->
name|id_irq
operator|>>
literal|8
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|outb
argument_list|(
name|IO_ICU1
operator|+
literal|1
argument_list|,
operator|~
operator|(
name|IRQ_SLAVE
operator||
name|dvp
operator|->
name|id_irq
operator|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|IO_ICU2
operator|+
literal|1
argument_list|,
operator|~
operator|(
name|dvp
operator|->
name|id_irq
operator|>>
literal|8
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|setidt
argument_list|(
literal|16
argument_list|,
name|probetrap
argument_list|,
name|SDT_SYS386TGT
argument_list|,
name|SEL_KPL
argument_list|,
name|GSEL
argument_list|(
name|GCODE_SEL
argument_list|,
name|SEL_KPL
argument_list|)
argument_list|)
expr_stmt|;
name|setidt
argument_list|(
name|npx_intrno
argument_list|,
name|probeintr
argument_list|,
name|SDT_SYS386IGT
argument_list|,
name|SEL_KPL
argument_list|,
name|GSEL
argument_list|(
name|GCODE_SEL
argument_list|,
name|SEL_KPL
argument_list|)
argument_list|)
expr_stmt|;
name|npx_idt_probeintr
operator|=
name|idt
index|[
name|npx_intrno
index|]
expr_stmt|;
name|enable_intr
argument_list|()
expr_stmt|;
name|result
operator|=
name|npxprobe1
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|disable_intr
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|outb
argument_list|(
name|IO_ICU1
operator|+
literal|2
argument_list|,
name|save_icu1_mask
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|IO_ICU2
operator|+
literal|2
argument_list|,
name|save_icu2_mask
argument_list|)
expr_stmt|;
else|#
directive|else
name|outb
argument_list|(
name|IO_ICU1
operator|+
literal|1
argument_list|,
name|save_icu1_mask
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|IO_ICU2
operator|+
literal|1
argument_list|,
name|save_icu2_mask
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|idt
index|[
name|npx_intrno
index|]
operator|=
name|save_idt_npxintr
expr_stmt|;
name|idt
index|[
literal|16
index|]
operator|=
name|save_idt_npxtrap
expr_stmt|;
name|write_eflags
argument_list|(
name|save_eflags
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
endif|#
directive|endif
comment|/* SMP */
block|}
end_function

begin_function
specifier|static
name|int
name|npxprobe1
parameter_list|(
name|dvp
parameter_list|)
name|struct
name|isa_device
modifier|*
name|dvp
decl_stmt|;
block|{
name|u_short
name|control
decl_stmt|;
name|u_short
name|status
decl_stmt|;
comment|/* 	 * Partially reset the coprocessor, if any.  Some BIOS's don't reset 	 * it after a warm boot. 	 */
ifdef|#
directive|ifdef
name|PC98
name|outb
argument_list|(
name|IO_NPX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|outb
argument_list|(
literal|0xf1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* full reset on some systems, NOP on others */
name|outb
argument_list|(
literal|0xf0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* clear BUSY# latch */
endif|#
directive|endif
comment|/* 	 * Prepare to trap all ESC (i.e., NPX) instructions and all WAIT 	 * instructions.  We must set the CR0_MP bit and use the CR0_TS 	 * bit to control the trap, because setting the CR0_EM bit does 	 * not cause WAIT instructions to trap.  It's important to trap 	 * WAIT instructions - otherwise the "wait" variants of no-wait 	 * control instructions would degenerate to the "no-wait" variants 	 * after FP context switches but work correctly otherwise.  It's 	 * particularly important to trap WAITs when there is no NPX - 	 * otherwise the "wait" variants would always degenerate. 	 * 	 * Try setting CR0_NE to get correct error reporting on 486DX's. 	 * Setting it should fail or do nothing on lesser processors. 	 */
name|load_cr0
argument_list|(
name|rcr0
argument_list|()
operator||
name|CR0_MP
operator||
name|CR0_NE
argument_list|)
expr_stmt|;
comment|/* 	 * But don't trap while we're probing. 	 */
name|stop_emulating
argument_list|()
expr_stmt|;
comment|/* 	 * Finish resetting the coprocessor, if any.  If there is an error 	 * pending, then we may get a bogus IRQ13, but probeintr() will handle 	 * it OK.  Bogus halts have never been observed, but we enabled 	 * IRQ13 and cleared the BUSY# latch early to handle them anyway. 	 */
name|fninit
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
comment|/* 	 * Exception 16 MUST work for SMP. 	 */
name|npx_irq13
operator|=
literal|0
expr_stmt|;
name|npx_ex16
operator|=
name|hw_float
operator|=
name|npx_exists
operator|=
literal|1
expr_stmt|;
name|dvp
operator|->
name|id_irq
operator|=
literal|0
expr_stmt|;
comment|/* zap the interrupt */
comment|/* 	 * special return value to flag that we do not 	 * actually use any I/O registers 	 */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
else|#
directive|else
comment|/* SMP */
comment|/* 	 * Don't use fwait here because it might hang. 	 * Don't use fnop here because it usually hangs if there is no FPU. 	 */
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* wait for any IRQ13 */
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|npx_intrs_while_probing
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"fninit caused %u bogus npx interrupt(s)\n"
argument_list|,
name|npx_intrs_while_probing
argument_list|)
expr_stmt|;
if|if
condition|(
name|npx_traps_while_probing
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"fninit caused %u bogus npx trap(s)\n"
argument_list|,
name|npx_traps_while_probing
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Check for a status of mostly zero. 	 */
name|status
operator|=
literal|0x5a5a
expr_stmt|;
name|fnstsw
argument_list|(
operator|&
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
literal|0xb8ff
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Good, now check for a proper control word. 		 */
name|control
operator|=
literal|0x5a5a
expr_stmt|;
name|fnstcw
argument_list|(
operator|&
name|control
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|control
operator|&
literal|0x1f3f
operator|)
operator|==
literal|0x033f
condition|)
block|{
name|hw_float
operator|=
name|npx_exists
operator|=
literal|1
expr_stmt|;
comment|/* 			 * We have an npx, now divide by 0 to see if exception 			 * 16 works. 			 */
name|control
operator|&=
operator|~
operator|(
literal|1
operator|<<
literal|2
operator|)
expr_stmt|;
comment|/* enable divide by 0 trap */
name|fldcw
argument_list|(
operator|&
name|control
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FPU_ERROR_BROKEN
comment|/* 			 * FPU error signal doesn't work on some CPU 			 * accelerator board. 			 */
name|npx_ex16
operator|=
literal|1
expr_stmt|;
name|dvp
operator|->
name|id_irq
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
endif|#
directive|endif
name|npx_traps_while_probing
operator|=
name|npx_intrs_while_probing
operator|=
literal|0
expr_stmt|;
name|fp_divide_by_0
argument_list|()
expr_stmt|;
if|if
condition|(
name|npx_traps_while_probing
operator|!=
literal|0
condition|)
block|{
comment|/* 				 * Good, exception 16 works. 				 */
name|npx_ex16
operator|=
literal|1
expr_stmt|;
name|dvp
operator|->
name|id_irq
operator|=
literal|0
expr_stmt|;
comment|/* zap the interrupt */
comment|/* 				 * special return value to flag that we do not 				 * actually use any I/O registers 				 */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|npx_intrs_while_probing
operator|!=
literal|0
condition|)
block|{
comment|/* 				 * Bad, we are stuck with IRQ13. 				 */
name|npx_irq13
operator|=
literal|1
expr_stmt|;
comment|/* 				 * npxattach would be too late to set npx0_imask. 				 */
name|npx0_imask
operator||=
name|dvp
operator|->
name|id_irq
expr_stmt|;
return|return
operator|(
name|IO_NPXSIZE
operator|)
return|;
block|}
comment|/* 			 * Worse, even IRQ13 is broken.  Use emulator. 			 */
block|}
block|}
comment|/* 	 * Probe failed, but we want to get to npxattach to initialize the 	 * emulator and say that it has been installed.  XXX handle devices 	 * that aren't really devices better. 	 */
name|dvp
operator|->
name|id_irq
operator|=
literal|0
expr_stmt|;
comment|/* 	 * special return value to flag that we do not 	 * actually use any I/O registers 	 */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
endif|#
directive|endif
comment|/* SMP */
block|}
end_function

begin_comment
comment|/*  * Attach routine - announce which it is, and wire into system  */
end_comment

begin_function
name|int
name|npxattach
parameter_list|(
name|dvp
parameter_list|)
name|struct
name|isa_device
modifier|*
name|dvp
decl_stmt|;
block|{
comment|/* The caller has printed "irq 13" for the npx_irq13 case. */
if|if
condition|(
operator|!
name|npx_irq13
condition|)
block|{
name|printf
argument_list|(
literal|"npx%d: "
argument_list|,
name|dvp
operator|->
name|id_unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|npx_ex16
condition|)
name|printf
argument_list|(
literal|"INT 16 interface\n"
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|MATH_EMULATE
argument_list|)
operator|||
name|defined
argument_list|(
name|GPL_MATH_EMULATE
argument_list|)
elseif|else
if|if
condition|(
name|npx_exists
condition|)
block|{
name|printf
argument_list|(
literal|"error reporting broken; using 387 emulator\n"
argument_list|)
expr_stmt|;
name|hw_float
operator|=
name|npx_exists
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"387 emulator\n"
argument_list|)
expr_stmt|;
else|#
directive|else
else|else
name|printf
argument_list|(
literal|"no 387 emulator in kernel!\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|npxinit
argument_list|(
name|__INITIAL_NPXCW__
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|I586_CPU
argument_list|)
if|if
condition|(
name|cpu_class
operator|==
name|CPUCLASS_586
operator|&&
name|npx_ex16
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|dvp
operator|->
name|id_flags
operator|&
name|NPX_DISABLE_I586_OPTIMIZED_BCOPY
operator|)
condition|)
block|{
name|bcopy_vector
operator|=
name|i586_bcopy
expr_stmt|;
name|ovbcopy_vector
operator|=
name|i586_bcopy
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|dvp
operator|->
name|id_flags
operator|&
name|NPX_DISABLE_I586_OPTIMIZED_BZERO
operator|)
condition|)
name|bzero
operator|=
name|i586_bzero
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|dvp
operator|->
name|id_flags
operator|&
name|NPX_DISABLE_I586_OPTIMIZED_COPYIO
operator|)
condition|)
block|{
name|copyin_vector
operator|=
name|i586_copyin
expr_stmt|;
name|copyout_vector
operator|=
name|i586_copyout
expr_stmt|;
block|}
block|}
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
comment|/* XXX unused */
block|}
end_function

begin_comment
comment|/*  * Initialize floating point unit.  */
end_comment

begin_function
name|void
name|npxinit
parameter_list|(
name|control
parameter_list|)
name|u_short
name|control
decl_stmt|;
block|{
name|struct
name|save87
name|dummy
decl_stmt|;
if|if
condition|(
operator|!
name|npx_exists
condition|)
return|return;
comment|/* 	 * fninit has the same h/w bugs as fnsave.  Use the detoxified 	 * fnsave to throw away any junk in the fpu.  npxsave() initializes 	 * the fpu and sets npxproc = NULL as important side effects. 	 */
name|npxsave
argument_list|(
operator|&
name|dummy
argument_list|)
expr_stmt|;
name|stop_emulating
argument_list|()
expr_stmt|;
name|fldcw
argument_list|(
operator|&
name|control
argument_list|)
expr_stmt|;
if|if
condition|(
name|curpcb
operator|!=
name|NULL
condition|)
name|fnsave
argument_list|(
operator|&
name|curpcb
operator|->
name|pcb_savefpu
argument_list|)
expr_stmt|;
name|start_emulating
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free coprocessor (if we have it).  */
end_comment

begin_function
name|void
name|npxexit
parameter_list|(
name|p
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
if|if
condition|(
name|p
operator|==
name|npxproc
condition|)
name|npxsave
argument_list|(
operator|&
name|curpcb
operator|->
name|pcb_savefpu
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NPX_DEBUG
if|if
condition|(
name|npx_exists
condition|)
block|{
name|u_int
name|masked_exceptions
decl_stmt|;
name|masked_exceptions
operator|=
name|curpcb
operator|->
name|pcb_savefpu
operator|.
name|sv_env
operator|.
name|en_cw
operator|&
name|curpcb
operator|->
name|pcb_savefpu
operator|.
name|sv_env
operator|.
name|en_sw
operator|&
literal|0x7f
expr_stmt|;
comment|/* 		 * Log exceptions that would have trapped with the old 		 * control word (overflow, divide by 0, and invalid operand). 		 */
if|if
condition|(
name|masked_exceptions
operator|&
literal|0x0d
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"pid %d (%s) exited with masked floating point exceptions 0x%02x\n"
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|p
operator|->
name|p_comm
argument_list|,
name|masked_exceptions
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Preserve the FP status word, clear FP exceptions, then generate a SIGFPE.  *  * Clearing exceptions is necessary mainly to avoid IRQ13 bugs.  We now  * depend on longjmp() restoring a usable state.  Restoring the state  * or examining it might fail if we didn't clear exceptions.  *  * XXX there is no standard way to tell SIGFPE handlers about the error  * state.  The old interface:  *  *	void handler(int sig, int code, struct sigcontext *scp);  *  * is broken because it is non-ANSI and because the FP state is not in  * struct sigcontext.  *  * XXX the FP state is not preserved across signal handlers.  So signal  * handlers cannot afford to do FP unless they preserve the state or  * longjmp() out.  Both preserving the state and longjmp()ing may be  * destroyed by IRQ13 bugs.  Clearing FP exceptions is not an acceptable  * solution for signals other than SIGFPE.  */
end_comment

begin_function
name|void
name|npxintr
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|int
name|code
decl_stmt|;
name|struct
name|intrframe
modifier|*
name|frame
decl_stmt|;
if|if
condition|(
name|npxproc
operator|==
name|NULL
operator|||
operator|!
name|npx_exists
condition|)
block|{
name|printf
argument_list|(
literal|"npxintr: npxproc = %p, curproc = %p, npx_exists = %d\n"
argument_list|,
name|npxproc
argument_list|,
name|curproc
argument_list|,
name|npx_exists
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"npxintr from nowhere"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|npxproc
operator|!=
name|curproc
condition|)
block|{
name|printf
argument_list|(
literal|"npxintr: npxproc = %p, curproc = %p, npx_exists = %d\n"
argument_list|,
name|npxproc
argument_list|,
name|curproc
argument_list|,
name|npx_exists
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"npxintr from non-current process"
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PC98
name|outb
argument_list|(
name|IO_NPX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|outb
argument_list|(
literal|0xf0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fnstsw
argument_list|(
operator|&
name|curpcb
operator|->
name|pcb_savefpu
operator|.
name|sv_ex_sw
argument_list|)
expr_stmt|;
name|fnclex
argument_list|()
expr_stmt|;
name|fnop
argument_list|()
expr_stmt|;
comment|/* 	 * Pass exception to process. 	 */
name|frame
operator|=
operator|(
expr|struct
name|intrframe
operator|*
operator|)
operator|&
name|unit
expr_stmt|;
comment|/* XXX */
if|if
condition|(
operator|(
name|ISPL
argument_list|(
name|frame
operator|->
name|if_cs
argument_list|)
operator|==
name|SEL_UPL
operator|)
operator|||
operator|(
name|frame
operator|->
name|if_eflags
operator|&
name|PSL_VM
operator|)
condition|)
block|{
comment|/* 		 * Interrupt is essentially a trap, so we can afford to call 		 * the SIGFPE handler (if any) as soon as the interrupt 		 * returns. 		 * 		 * XXX little or nothing is gained from this, and plenty is 		 * lost - the interrupt frame has to contain the trap frame 		 * (this is otherwise only necessary for the rescheduling trap 		 * in doreti, and the frame for that could easily be set up 		 * just before it is used). 		 */
name|curproc
operator|->
name|p_md
operator|.
name|md_regs
operator|=
operator|(
expr|struct
name|trapframe
operator|*
operator|)
operator|&
name|frame
operator|->
name|if_es
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
comment|/* 		 * Encode the appropriate code for detailed information on 		 * this exception. 		 */
name|code
operator|=
name|XXX_ENCODE
argument_list|(
name|curpcb
operator|->
name|pcb_savefpu
operator|.
name|sv_ex_sw
argument_list|)
expr_stmt|;
else|#
directive|else
name|code
operator|=
literal|0
expr_stmt|;
comment|/* XXX */
endif|#
directive|endif
name|trapsignal
argument_list|(
name|curproc
argument_list|,
name|SIGFPE
argument_list|,
name|code
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Nested interrupt.  These losers occur when: 		 *	o an IRQ13 is bogusly generated at a bogus time, e.g.: 		 *		o immediately after an fnsave or frstor of an 		 *		  error state. 		 *		o a couple of 386 instructions after 		 *		  "fstpl _memvar" causes a stack overflow. 		 *	  These are especially nasty when combined with a 		 *	  trace trap. 		 *	o an IRQ13 occurs at the same time as another higher- 		 *	  priority interrupt. 		 * 		 * Treat them like a true async interrupt. 		 */
name|psignal
argument_list|(
name|curproc
argument_list|,
name|SIGFPE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Implement device not available (DNA) exception  *  * It would be better to switch FP context here (if curproc != npxproc)  * and not necessarily for every context switch, but it is too hard to  * access foreign pcb's.  */
end_comment

begin_function
name|int
name|npxdna
parameter_list|()
block|{
if|if
condition|(
operator|!
name|npx_exists
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|npxproc
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"npxdna: npxproc = %p, curproc = %p\n"
argument_list|,
name|npxproc
argument_list|,
name|curproc
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"npxdna"
argument_list|)
expr_stmt|;
block|}
name|stop_emulating
argument_list|()
expr_stmt|;
comment|/* 	 * Record new context early in case frstor causes an IRQ13. 	 */
name|npxproc
operator|=
name|curproc
expr_stmt|;
name|curpcb
operator|->
name|pcb_savefpu
operator|.
name|sv_ex_sw
operator|=
literal|0
expr_stmt|;
comment|/* 	 * The following frstor may cause an IRQ13 when the state being 	 * restored has a pending error.  The error will appear to have been 	 * triggered by the current (npx) user instruction even when that 	 * instruction is a no-wait instruction that should not trigger an 	 * error (e.g., fnclex).  On at least one 486 system all of the 	 * no-wait instructions are broken the same as frstor, so our 	 * treatment does not amplify the breakage.  On at least one 	 * 386/Cyrix 387 system, fnclex works correctly while frstor and 	 * fnsave are broken, so our treatment breaks fnclex if it is the 	 * first FPU instruction after a context switch. 	 */
name|frstor
argument_list|(
operator|&
name|curpcb
operator|->
name|pcb_savefpu
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Wrapper for fnsave instruction to handle h/w bugs.  If there is an error  * pending, then fnsave generates a bogus IRQ13 on some systems.  Force  * any IRQ13 to be handled immediately, and then ignore it.  This routine is  * often called at splhigh so it must not use many system services.  In  * particular, it's much easier to install a special handler than to  * guarantee that it's safe to use npxintr() and its supporting code.  */
end_comment

begin_function
name|void
name|npxsave
parameter_list|(
name|addr
parameter_list|)
name|struct
name|save87
modifier|*
name|addr
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|SMP
name|stop_emulating
argument_list|()
expr_stmt|;
name|fnsave
argument_list|(
name|addr
argument_list|)
expr_stmt|;
comment|/* fnop(); */
name|start_emulating
argument_list|()
expr_stmt|;
name|npxproc
operator|=
name|NULL
expr_stmt|;
else|#
directive|else
comment|/* SMP */
name|u_char
name|icu1_mask
decl_stmt|;
name|u_char
name|icu2_mask
decl_stmt|;
name|u_char
name|old_icu1_mask
decl_stmt|;
name|u_char
name|old_icu2_mask
decl_stmt|;
name|struct
name|gate_descriptor
name|save_idt_npxintr
decl_stmt|;
name|disable_intr
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|old_icu1_mask
operator|=
name|inb
argument_list|(
name|IO_ICU1
operator|+
literal|2
argument_list|)
expr_stmt|;
name|old_icu2_mask
operator|=
name|inb
argument_list|(
name|IO_ICU2
operator|+
literal|2
argument_list|)
expr_stmt|;
else|#
directive|else
name|old_icu1_mask
operator|=
name|inb
argument_list|(
name|IO_ICU1
operator|+
literal|1
argument_list|)
expr_stmt|;
name|old_icu2_mask
operator|=
name|inb
argument_list|(
name|IO_ICU2
operator|+
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|save_idt_npxintr
operator|=
name|idt
index|[
name|npx_intrno
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|outb
argument_list|(
name|IO_ICU1
operator|+
literal|2
argument_list|,
name|old_icu1_mask
operator|&
operator|~
operator|(
name|IRQ_SLAVE
operator||
name|npx0_imask
operator|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|IO_ICU2
operator|+
literal|2
argument_list|,
name|old_icu2_mask
operator|&
operator|~
operator|(
name|npx0_imask
operator|>>
literal|8
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|outb
argument_list|(
name|IO_ICU1
operator|+
literal|1
argument_list|,
name|old_icu1_mask
operator|&
operator|~
operator|(
name|IRQ_SLAVE
operator||
name|npx0_imask
operator|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|IO_ICU2
operator|+
literal|1
argument_list|,
name|old_icu2_mask
operator|&
operator|~
operator|(
name|npx0_imask
operator|>>
literal|8
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|idt
index|[
name|npx_intrno
index|]
operator|=
name|npx_idt_probeintr
expr_stmt|;
name|enable_intr
argument_list|()
expr_stmt|;
name|stop_emulating
argument_list|()
expr_stmt|;
name|fnsave
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|fnop
argument_list|()
expr_stmt|;
name|start_emulating
argument_list|()
expr_stmt|;
name|npxproc
operator|=
name|NULL
expr_stmt|;
name|disable_intr
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|icu1_mask
operator|=
name|inb
argument_list|(
name|IO_ICU1
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* masks may have changed */
name|icu2_mask
operator|=
name|inb
argument_list|(
name|IO_ICU2
operator|+
literal|2
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|IO_ICU1
operator|+
literal|2
argument_list|,
operator|(
name|icu1_mask
operator|&
operator|~
name|npx0_imask
operator|)
operator||
operator|(
name|old_icu1_mask
operator|&
name|npx0_imask
operator|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|IO_ICU2
operator|+
literal|2
argument_list|,
operator|(
name|icu2_mask
operator|&
operator|~
operator|(
name|npx0_imask
operator|>>
literal|8
operator|)
operator|)
operator||
operator|(
name|old_icu2_mask
operator|&
operator|(
name|npx0_imask
operator|>>
literal|8
operator|)
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|icu1_mask
operator|=
name|inb
argument_list|(
name|IO_ICU1
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* masks may have changed */
name|icu2_mask
operator|=
name|inb
argument_list|(
name|IO_ICU2
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|IO_ICU1
operator|+
literal|1
argument_list|,
operator|(
name|icu1_mask
operator|&
operator|~
name|npx0_imask
operator|)
operator||
operator|(
name|old_icu1_mask
operator|&
name|npx0_imask
operator|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|IO_ICU2
operator|+
literal|1
argument_list|,
operator|(
name|icu2_mask
operator|&
operator|~
operator|(
name|npx0_imask
operator|>>
literal|8
operator|)
operator|)
operator||
operator|(
name|old_icu2_mask
operator|&
operator|(
name|npx0_imask
operator|>>
literal|8
operator|)
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|idt
index|[
name|npx_intrno
index|]
operator|=
name|save_idt_npxintr
expr_stmt|;
name|enable_intr
argument_list|()
expr_stmt|;
comment|/* back to usual state */
endif|#
directive|endif
comment|/* SMP */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NNPX> 0 */
end_comment

end_unit

