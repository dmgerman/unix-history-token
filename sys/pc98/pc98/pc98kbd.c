begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1999 FreeBSD(98) port team.  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer as  *    the first lines of this file unmodified.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  *	$Id: pc98kbd.c,v 1.2 1999/01/18 14:55:38 kato Exp $  */
end_comment

begin_include
include|#
directive|include
file|"pckbd.h"
end_include

begin_include
include|#
directive|include
file|"opt_kbd.h"
end_include

begin_include
include|#
directive|include
file|"opt_devfs.h"
end_include

begin_if
if|#
directive|if
name|NPCKBD
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<dev/kbd/kbdreg.h>
end_include

begin_include
include|#
directive|include
file|<pc98/pc98/pc98.h>
end_include

begin_include
include|#
directive|include
file|<pc98/pc98/pc98_machdep.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__i386__
end_ifdef

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|DRIVER_NAME
value|"pckbd"
end_define

begin_comment
comment|/* device configuration flags */
end_comment

begin_define
define|#
directive|define
name|KB_CONF_FAIL_IF_NO_KBD
value|(1<< 0)
end_define

begin_comment
comment|/* don't install if no kbd is found */
end_comment

begin_comment
comment|/* some macros */
end_comment

begin_define
define|#
directive|define
name|PC98KBD_UNIT
parameter_list|(
name|dev
parameter_list|)
value|minor(dev)
end_define

begin_define
define|#
directive|define
name|PC98KBD_MKMINOR
parameter_list|(
name|unit
parameter_list|)
value|(unit)
end_define

begin_comment
comment|/* cdev driver declaration */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|pckbd_softc
block|{
name|short
name|flags
decl_stmt|;
define|#
directive|define
name|PC98KBD_ATTACHED
value|(1<< 0)
name|keyboard_t
modifier|*
name|kbd
decl_stmt|;
ifdef|#
directive|ifdef
name|KBD_INSTALL_CDEV
name|genkbd_softc_t
name|gensc
decl_stmt|;
endif|#
directive|endif
block|}
name|pckbd_softc_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|PC98KBD_SOFTC
parameter_list|(
name|unit
parameter_list|)
value|pckbd_softc[(unit)]
end_define

begin_decl_stmt
specifier|static
name|pckbd_softc_t
modifier|*
name|pckbd_softc
index|[
name|NPCKBD
index|]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|pckbdprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pckbdattach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|ointhand2_t
name|pckbd_isa_intr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* driver declaration for isa_devtab_tty[] */
end_comment

begin_decl_stmt
name|struct
name|isa_driver
name|pckbddriver
init|=
block|{
name|pckbdprobe
block|,
name|pckbdattach
block|,
name|DRIVER_NAME
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|pckbd_probe_unit
parameter_list|(
name|int
name|unit
parameter_list|,
name|pckbd_softc_t
modifier|*
name|sc
parameter_list|,
name|int
name|port
parameter_list|,
name|int
name|irq
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pckbd_attach_unit
parameter_list|(
name|int
name|unit
parameter_list|,
name|pckbd_softc_t
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|timeout_t
name|pckbd_timeout
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|KBD_INSTALL_CDEV
end_ifdef

begin_decl_stmt
specifier|static
name|d_open_t
name|pckbdopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|pckbdclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_read_t
name|pckbdread
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|pckbdioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_poll_t
name|pckbdpoll
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|pckbd_cdevsw
init|=
block|{
name|pckbdopen
block|,
name|pckbdclose
block|,
name|pckbdread
block|,
name|nowrite
block|,
name|pckbdioctl
block|,
name|nostop
block|,
name|nullreset
block|,
name|nodevtotty
block|,
name|pckbdpoll
block|,
name|nommap
block|,
name|NULL
block|,
name|DRIVER_NAME
block|,
name|NULL
block|,
operator|-
literal|1
block|, }
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* KBD_INSTALL_CDEV */
end_comment

begin_function
specifier|static
name|int
name|pckbdprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
block|{
name|pckbd_softc_t
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|dev
operator|->
name|id_unit
operator|>=
sizeof|sizeof
argument_list|(
name|pckbd_softc
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|pckbd_softc
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
literal|0
return|;
name|sc
operator|=
name|pckbd_softc
index|[
name|dev
operator|->
name|id_unit
index|]
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
block|{
name|sc
operator|=
name|pckbd_softc
index|[
name|dev
operator|->
name|id_unit
index|]
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|bzero
argument_list|(
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* try to find a keyboard */
name|error
operator|=
name|pckbd_probe_unit
argument_list|(
name|dev
operator|->
name|id_unit
argument_list|,
name|sc
argument_list|,
name|dev
operator|->
name|id_iobase
argument_list|,
name|dev
operator|->
name|id_irq
argument_list|,
name|dev
operator|->
name|id_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
literal|0
return|;
comment|/* declare our interrupt handler */
name|dev
operator|->
name|id_ointr
operator|=
name|pckbd_isa_intr
expr_stmt|;
return|return
name|IO_KBDSIZE
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pckbdattach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
block|{
name|pckbd_softc_t
modifier|*
name|sc
decl_stmt|;
if|if
condition|(
name|dev
operator|->
name|id_unit
operator|>=
sizeof|sizeof
argument_list|(
name|pckbd_softc
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|pckbd_softc
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
literal|0
return|;
name|sc
operator|=
name|pckbd_softc
index|[
name|dev
operator|->
name|id_unit
index|]
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
return|return
operator|(
operator|(
name|pckbd_attach_unit
argument_list|(
name|dev
operator|->
name|id_unit
argument_list|,
name|sc
argument_list|)
operator|)
condition|?
literal|0
else|:
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pckbd_isa_intr
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|keyboard_t
modifier|*
name|kbd
decl_stmt|;
name|kbd
operator|=
name|pckbd_softc
index|[
name|unit
index|]
operator|->
name|kbd
expr_stmt|;
operator|(
operator|*
name|kbdsw
index|[
name|kbd
operator|->
name|kb_index
index|]
operator|->
name|intr
operator|)
operator|(
name|kbd
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pckbd_probe_unit
parameter_list|(
name|int
name|unit
parameter_list|,
name|pckbd_softc_t
modifier|*
name|sc
parameter_list|,
name|int
name|port
parameter_list|,
name|int
name|irq
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|keyboard_switch_t
modifier|*
name|sw
decl_stmt|;
name|int
name|args
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|PC98KBD_ATTACHED
condition|)
return|return
literal|0
return|;
name|sw
operator|=
name|kbd_get_switch
argument_list|(
name|DRIVER_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|sw
operator|==
name|NULL
condition|)
return|return
name|ENXIO
return|;
name|args
index|[
literal|0
index|]
operator|=
name|port
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|irq
expr_stmt|;
return|return
call|(
modifier|*
name|sw
operator|->
name|probe
call|)
argument_list|(
name|unit
argument_list|,
operator|&
name|sc
operator|->
name|kbd
argument_list|,
name|args
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pckbd_attach_unit
parameter_list|(
name|int
name|unit
parameter_list|,
name|pckbd_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|keyboard_switch_t
modifier|*
name|sw
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|PC98KBD_ATTACHED
condition|)
return|return
literal|0
return|;
name|sw
operator|=
name|kbd_get_switch
argument_list|(
name|DRIVER_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|sw
operator|==
name|NULL
condition|)
return|return
name|ENXIO
return|;
comment|/* reset, initialize and enable the device */
name|error
operator|=
call|(
modifier|*
name|sw
operator|->
name|init
call|)
argument_list|(
name|sc
operator|->
name|kbd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|ENXIO
return|;
call|(
modifier|*
name|sw
operator|->
name|enable
call|)
argument_list|(
name|sc
operator|->
name|kbd
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KBD_INSTALL_CDEV
comment|/* attach a virtual keyboard cdev */
name|error
operator|=
name|kbd_attach
argument_list|(
name|makedev
argument_list|(
literal|0
argument_list|,
name|PC98KBD_MKMINOR
argument_list|(
name|unit
argument_list|)
argument_list|)
argument_list|,
name|sc
operator|->
name|kbd
argument_list|,
operator|&
name|pckbd_cdevsw
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
endif|#
directive|endif
comment|/* KBD_INSTALL_CDEV */
comment|/* 	 * This is a kludge to compensate for lost keyboard interrupts. 	 * A similar code used to be in syscons. See below. XXX 	 */
name|pckbd_timeout
argument_list|(
name|sc
operator|->
name|kbd
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
call|(
modifier|*
name|sw
operator|->
name|diag
call|)
argument_list|(
name|sc
operator|->
name|kbd
argument_list|,
name|bootverbose
argument_list|)
expr_stmt|;
name|sc
operator|->
name|flags
operator||=
name|PC98KBD_ATTACHED
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pckbd_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|keyboard_t
modifier|*
name|kbd
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* The following comments are extracted from syscons.c (1.287) */
comment|/*  	 * With release 2.1 of the Xaccel server, the keyboard is left 	 * hanging pretty often. Apparently an interrupt from the 	 * keyboard is lost, and I don't know why (yet). 	 * This ugly hack calls scintr if input is ready for the keyboard 	 * and conveniently hides the problem.			XXX 	 */
comment|/* 	 * Try removing anything stuck in the keyboard controller; whether 	 * it's a keyboard scan code or mouse data. `scintr()' doesn't 	 * read the mouse data directly, but `kbdio' routines will, as a 	 * side effect. 	 */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|kbd
operator|=
operator|(
name|keyboard_t
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|kbdsw
index|[
name|kbd
operator|->
name|kb_index
index|]
operator|->
name|lock
operator|)
operator|(
name|kbd
operator|,
name|TRUE
operator|)
condition|)
block|{
comment|/* 		 * We have seen the lock flag is not set. Let's reset 		 * the flag early, otherwise the LED update routine fails 		 * which may want the lock during the interrupt routine. 		 */
operator|(
operator|*
name|kbdsw
index|[
name|kbd
operator|->
name|kb_index
index|]
operator|->
name|lock
operator|)
operator|(
name|kbd
operator|,
name|FALSE
operator|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|kbdsw
index|[
name|kbd
operator|->
name|kb_index
index|]
operator|->
name|check_char
operator|)
operator|(
name|kbd
operator|)
condition|)
operator|(
operator|*
name|kbdsw
index|[
name|kbd
operator|->
name|kb_index
index|]
operator|->
name|intr
operator|)
operator|(
name|kbd
operator|,
name|NULL
operator|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|timeout
argument_list|(
name|pckbd_timeout
argument_list|,
name|arg
argument_list|,
name|hz
operator|/
literal|10
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* cdev driver functions */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|KBD_INSTALL_CDEV
end_ifdef

begin_function
specifier|static
name|int
name|pckbdopen
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|pckbd_softc_t
modifier|*
name|sc
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|unit
operator|=
name|PC98KBD_UNIT
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unit
operator|>=
name|NPCKBD
operator|)
operator|||
operator|(
operator|(
name|sc
operator|=
name|PC98KBD_SOFTC
argument_list|(
name|unit
argument_list|)
operator|)
operator|==
name|NULL
operator|)
condition|)
return|return
name|ENXIO
return|;
if|if
condition|(
name|mode
operator|&
operator|(
name|FWRITE
operator||
name|O_CREAT
operator||
name|O_APPEND
operator||
name|O_TRUNC
operator|)
condition|)
return|return
name|ENODEV
return|;
comment|/* FIXME: set the initial input mode (K_XLATE?) and lock state? */
return|return
name|genkbdopen
argument_list|(
operator|&
name|sc
operator|->
name|gensc
argument_list|,
name|sc
operator|->
name|kbd
argument_list|,
name|flag
argument_list|,
name|mode
argument_list|,
name|p
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pckbdclose
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|pckbd_softc_t
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|PC98KBD_SOFTC
argument_list|(
name|PC98KBD_UNIT
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|genkbdclose
argument_list|(
operator|&
name|sc
operator|->
name|gensc
argument_list|,
name|sc
operator|->
name|kbd
argument_list|,
name|flag
argument_list|,
name|mode
argument_list|,
name|p
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pckbdread
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|pckbd_softc_t
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|PC98KBD_SOFTC
argument_list|(
name|PC98KBD_UNIT
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|genkbdread
argument_list|(
operator|&
name|sc
operator|->
name|gensc
argument_list|,
name|sc
operator|->
name|kbd
argument_list|,
name|uio
argument_list|,
name|flag
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pckbdioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|pckbd_softc_t
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|PC98KBD_SOFTC
argument_list|(
name|PC98KBD_UNIT
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|genkbdioctl
argument_list|(
operator|&
name|sc
operator|->
name|gensc
argument_list|,
name|sc
operator|->
name|kbd
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|,
name|flag
argument_list|,
name|p
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pckbdpoll
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|event
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|pckbd_softc_t
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|PC98KBD_SOFTC
argument_list|(
name|PC98KBD_UNIT
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|genkbdpoll
argument_list|(
operator|&
name|sc
operator|->
name|gensc
argument_list|,
name|sc
operator|->
name|kbd
argument_list|,
name|event
argument_list|,
name|p
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* KBD_INSTALL_CDEV */
end_comment

begin_comment
comment|/* LOW-LEVEL */
end_comment

begin_include
include|#
directive|include
file|<machine/limits.h>
end_include

begin_include
include|#
directive|include
file|<machine/console.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_define
define|#
directive|define
name|PC98KBD_DEFAULT
value|0
end_define

begin_typedef
typedef|typedef
name|caddr_t
name|KBDC
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|pckbd_state
block|{
name|KBDC
name|kbdc
decl_stmt|;
comment|/* keyboard controller */
name|int
name|ks_mode
decl_stmt|;
comment|/* input mode (K_XLATE,K_RAW,K_CODE) */
name|int
name|ks_flags
decl_stmt|;
comment|/* flags */
define|#
directive|define
name|COMPOSE
value|(1<< 0)
name|int
name|ks_state
decl_stmt|;
comment|/* shift/lock key state */
name|int
name|ks_accents
decl_stmt|;
comment|/* accent key index (> 0) */
name|u_int
name|ks_composed_char
decl_stmt|;
comment|/* composed char code (> 0) */
block|}
name|pckbd_state_t
typedef|;
end_typedef

begin_comment
comment|/* keyboard driver declaration */
end_comment

begin_function_decl
specifier|static
name|int
name|pckbd_configure
parameter_list|(
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|kbd_probe_t
name|pckbd_probe
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kbd_init_t
name|pckbd_init
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kbd_term_t
name|pckbd_term
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kbd_intr_t
name|pckbd_intr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kbd_test_if_t
name|pckbd_test_if
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kbd_enable_t
name|pckbd_enable
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kbd_disable_t
name|pckbd_disable
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kbd_read_t
name|pckbd_read
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kbd_check_t
name|pckbd_check
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kbd_read_char_t
name|pckbd_read_char
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kbd_check_char_t
name|pckbd_check_char
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kbd_ioctl_t
name|pckbd_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kbd_lock_t
name|pckbd_lock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kbd_clear_state_t
name|pckbd_clear_state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kbd_get_state_t
name|pckbd_get_state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kbd_set_state_t
name|pckbd_set_state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|keyboard_switch_t
name|pckbdsw
init|=
block|{
name|pckbd_probe
block|,
name|pckbd_init
block|,
name|pckbd_term
block|,
name|pckbd_intr
block|,
name|pckbd_test_if
block|,
name|pckbd_enable
block|,
name|pckbd_disable
block|,
name|pckbd_read
block|,
name|pckbd_check
block|,
name|pckbd_read_char
block|,
name|pckbd_check_char
block|,
name|pckbd_ioctl
block|,
name|pckbd_lock
block|,
name|pckbd_clear_state
block|,
name|pckbd_get_state
block|,
name|pckbd_set_state
block|,
name|genkbd_get_fkeystr
block|,
name|genkbd_diag
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|KEYBOARD_DRIVER
argument_list|(
name|pckbd
argument_list|,
name|pckbdsw
argument_list|,
name|pckbd_configure
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|kbdc_softc
block|{
name|int
name|port
decl_stmt|;
comment|/* base port address */
name|int
name|lock
decl_stmt|;
comment|/* FIXME: XXX not quite a semaphore... */
block|}
struct|;
end_struct

begin_comment
comment|/* local functions */
end_comment

begin_function_decl
specifier|static
name|int
name|probe_keyboard
parameter_list|(
name|KBDC
name|kbdc
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|init_keyboard
parameter_list|(
name|KBDC
name|kbdc
parameter_list|,
name|int
modifier|*
name|type
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|KBDC
name|kbdc_open
parameter_list|(
name|int
name|port
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|kbdc_lock
parameter_list|(
name|KBDC
name|kbdc
parameter_list|,
name|int
name|lock
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|kbdc_data_ready
parameter_list|(
name|KBDC
name|kbdc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|read_kbd_data
parameter_list|(
name|KBDC
name|kbdc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|read_kbd_data_no_wait
parameter_list|(
name|KBDC
name|kbdc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wait_for_kbd_data
parameter_list|(
name|struct
name|kbdc_softc
modifier|*
name|kbdc
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* local variables */
end_comment

begin_comment
comment|/* the initial key map, accent map and fkey strings */
end_comment

begin_include
include|#
directive|include
file|<dev/kbd/kbdtables.h>
end_include

begin_comment
comment|/* structures for the default keyboard */
end_comment

begin_decl_stmt
specifier|static
name|keyboard_t
name|default_kbd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|pckbd_state_t
name|default_kbd_state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|keymap_t
name|default_keymap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|accentmap_t
name|default_accentmap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|fkeytab_t
name|default_fkeytab
index|[
name|NUM_FKEYS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   * The back door to the keyboard driver!  * This function is called by the console driver, via the kbdio module,  * to tickle keyboard drivers when the low-level console is being initialized.  * Almost nothing in the kernel has been initialied yet.  Try to probe  * keyboards if possible.  * NOTE: because of the way the low-level conole is initialized, this routine  * may be called more than once!!  */
end_comment

begin_function
specifier|static
name|int
name|pckbd_configure
parameter_list|(
name|int
name|flags
parameter_list|)
block|{
name|keyboard_t
modifier|*
name|kbd
decl_stmt|;
name|KBDC
name|kbdc
decl_stmt|;
name|int
name|arg
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|isa_device
modifier|*
name|dev
decl_stmt|;
comment|/* XXX: a kludge to obtain the device configuration flags */
name|dev
operator|=
name|find_isadev
argument_list|(
name|isa_devtab_tty
argument_list|,
operator|&
name|pckbddriver
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|!=
name|NULL
condition|)
name|flags
operator||=
name|dev
operator|->
name|id_flags
expr_stmt|;
comment|/* probe the default keyboard */
name|arg
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|arg
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|pckbd_probe
argument_list|(
name|PC98KBD_DEFAULT
argument_list|,
operator|&
name|kbd
argument_list|,
name|arg
argument_list|,
name|flags
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* initialize it */
name|kbdc
operator|=
operator|(
operator|(
name|pckbd_state_t
operator|*
operator|)
name|kbd
operator|->
name|kb_data
operator|)
operator|->
name|kbdc
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|KB_CONF_PROBE_ONLY
operator|)
operator|&&
operator|!
name|KBD_IS_PROBED
argument_list|(
name|kbd
argument_list|)
condition|)
block|{
if|if
condition|(
name|KBD_HAS_DEVICE
argument_list|(
name|kbd
argument_list|)
operator|&&
name|init_keyboard
argument_list|(
name|kbdc
argument_list|,
operator|&
name|kbd
operator|->
name|kb_type
argument_list|,
name|flags
argument_list|)
operator|&&
operator|(
name|flags
operator|&
name|KB_CONF_FAIL_IF_NO_KBD
operator|)
condition|)
return|return
literal|0
return|;
name|KBD_INIT_DONE
argument_list|(
name|kbd
argument_list|)
expr_stmt|;
block|}
comment|/* and register */
if|if
condition|(
operator|!
name|KBD_IS_CONFIGURED
argument_list|(
name|kbd
argument_list|)
condition|)
block|{
if|if
condition|(
name|kbd_register
argument_list|(
name|kbd
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|0
return|;
name|KBD_CONFIG_DONE
argument_list|(
name|kbd
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
comment|/* return the number of found keyboards */
block|}
end_function

begin_comment
comment|/* low-level functions */
end_comment

begin_comment
comment|/* initialize the keyboard_t structure and try to detect a keyboard */
end_comment

begin_function
specifier|static
name|int
name|pckbd_probe
parameter_list|(
name|int
name|unit
parameter_list|,
name|keyboard_t
modifier|*
modifier|*
name|kbdp
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|keyboard_t
modifier|*
name|kbd
decl_stmt|;
name|pckbd_state_t
modifier|*
name|state
decl_stmt|;
name|keymap_t
modifier|*
name|keymap
decl_stmt|;
name|accentmap_t
modifier|*
name|accmap
decl_stmt|;
name|fkeytab_t
modifier|*
name|fkeymap
decl_stmt|;
name|int
name|fkeymap_size
decl_stmt|;
name|KBDC
name|kbdc
decl_stmt|;
name|int
modifier|*
name|data
init|=
operator|(
name|int
operator|*
operator|)
name|arg
decl_stmt|;
if|if
condition|(
name|unit
operator|!=
name|PC98KBD_DEFAULT
condition|)
return|return
name|ENXIO
return|;
operator|*
name|kbdp
operator|=
name|kbd
operator|=
operator|&
name|default_kbd
expr_stmt|;
if|if
condition|(
name|KBD_IS_PROBED
argument_list|(
name|kbd
argument_list|)
condition|)
return|return
literal|0
return|;
name|state
operator|=
operator|&
name|default_kbd_state
expr_stmt|;
name|keymap
operator|=
operator|&
name|default_keymap
expr_stmt|;
name|accmap
operator|=
operator|&
name|default_accentmap
expr_stmt|;
name|fkeymap
operator|=
name|default_fkeytab
expr_stmt|;
name|fkeymap_size
operator|=
sizeof|sizeof
argument_list|(
name|default_fkeytab
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|default_fkeytab
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|state
operator|->
name|kbdc
operator|=
name|kbdc
operator|=
name|kbdc_open
argument_list|(
name|data
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|kbdc
operator|==
name|NULL
condition|)
return|return
name|ENXIO
return|;
name|kbd_init_struct
argument_list|(
name|kbd
argument_list|,
name|DRIVER_NAME
argument_list|,
name|KB_OTHER
argument_list|,
name|unit
argument_list|,
name|flags
argument_list|,
name|data
index|[
literal|0
index|]
argument_list|,
name|IO_KBDSIZE
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|key_map
argument_list|,
name|keymap
argument_list|,
sizeof|sizeof
argument_list|(
name|key_map
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|accent_map
argument_list|,
name|accmap
argument_list|,
sizeof|sizeof
argument_list|(
name|accent_map
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|fkey_tab
argument_list|,
name|fkeymap
argument_list|,
name|imin
argument_list|(
name|fkeymap_size
operator|*
sizeof|sizeof
argument_list|(
name|fkeymap
index|[
literal|0
index|]
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|fkey_tab
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|kbd_set_maps
argument_list|(
name|kbd
argument_list|,
name|keymap
argument_list|,
name|accmap
argument_list|,
name|fkeymap
argument_list|,
name|fkeymap_size
argument_list|)
expr_stmt|;
name|kbd
operator|->
name|kb_data
operator|=
operator|(
name|void
operator|*
operator|)
name|state
expr_stmt|;
if|if
condition|(
name|probe_keyboard
argument_list|(
name|kbdc
argument_list|,
name|flags
argument_list|)
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|KB_CONF_FAIL_IF_NO_KBD
condition|)
return|return
name|ENXIO
return|;
block|}
else|else
block|{
name|KBD_FOUND_DEVICE
argument_list|(
name|kbd
argument_list|)
expr_stmt|;
block|}
name|pckbd_clear_state
argument_list|(
name|kbd
argument_list|)
expr_stmt|;
name|state
operator|->
name|ks_mode
operator|=
name|K_XLATE
expr_stmt|;
name|KBD_PROBE_DONE
argument_list|(
name|kbd
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* reset and initialize the device */
end_comment

begin_function
specifier|static
name|int
name|pckbd_init
parameter_list|(
name|keyboard_t
modifier|*
name|kbd
parameter_list|)
block|{
name|KBDC
name|kbdc
decl_stmt|;
if|if
condition|(
operator|(
name|kbd
operator|==
name|NULL
operator|)
operator|||
operator|!
name|KBD_IS_PROBED
argument_list|(
name|kbd
argument_list|)
condition|)
return|return
name|ENXIO
return|;
comment|/* shouldn't happen */
name|kbdc
operator|=
operator|(
operator|(
name|pckbd_state_t
operator|*
operator|)
name|kbd
operator|->
name|kb_data
operator|)
operator|->
name|kbdc
expr_stmt|;
if|if
condition|(
name|kbdc
operator|==
name|NULL
condition|)
return|return
name|ENXIO
return|;
comment|/* shouldn't happen */
if|if
condition|(
operator|!
name|KBD_IS_INITIALIZED
argument_list|(
name|kbd
argument_list|)
condition|)
block|{
if|if
condition|(
name|KBD_HAS_DEVICE
argument_list|(
name|kbd
argument_list|)
operator|&&
name|init_keyboard
argument_list|(
name|kbdc
argument_list|,
operator|&
name|kbd
operator|->
name|kb_type
argument_list|,
name|kbd
operator|->
name|kb_config
argument_list|)
operator|&&
operator|(
name|kbd
operator|->
name|kb_config
operator|&
name|KB_CONF_FAIL_IF_NO_KBD
operator|)
condition|)
return|return
name|ENXIO
return|;
name|pckbd_ioctl
argument_list|(
name|kbd
argument_list|,
name|KDSETLED
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
operator|(
operator|(
name|pckbd_state_t
operator|*
operator|)
operator|(
name|kbd
operator|->
name|kb_data
operator|)
operator|)
operator|->
name|ks_state
argument_list|)
expr_stmt|;
name|KBD_INIT_DONE
argument_list|(
name|kbd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|KBD_IS_CONFIGURED
argument_list|(
name|kbd
argument_list|)
condition|)
block|{
if|if
condition|(
name|kbd_register
argument_list|(
name|kbd
argument_list|)
operator|<
literal|0
condition|)
return|return
name|ENXIO
return|;
name|KBD_CONFIG_DONE
argument_list|(
name|kbd
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* finish using this keyboard */
end_comment

begin_function
specifier|static
name|int
name|pckbd_term
parameter_list|(
name|keyboard_t
modifier|*
name|kbd
parameter_list|)
block|{
name|kbd_unregister
argument_list|(
name|kbd
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* keyboard interrupt routine */
end_comment

begin_function
specifier|static
name|int
name|pckbd_intr
parameter_list|(
name|keyboard_t
modifier|*
name|kbd
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
if|if
condition|(
name|KBD_IS_ACTIVE
argument_list|(
name|kbd
argument_list|)
operator|&&
name|KBD_IS_BUSY
argument_list|(
name|kbd
argument_list|)
condition|)
block|{
comment|/* let the callback function to process the input */
call|(
modifier|*
name|kbd
operator|->
name|kb_callback
operator|.
name|kc_func
call|)
argument_list|(
name|kbd
argument_list|,
name|KBDIO_KEYINPUT
argument_list|,
name|kbd
operator|->
name|kb_callback
operator|.
name|kc_arg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* read and discard the input; no one is waiting for input */
do|do
block|{
name|c
operator|=
name|pckbd_read_char
argument_list|(
name|kbd
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|!=
name|NOKEY
condition|)
do|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* test the interface to the device */
end_comment

begin_function
specifier|static
name|int
name|pckbd_test_if
parameter_list|(
name|keyboard_t
modifier|*
name|kbd
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*   * Enable the access to the device; until this function is called,  * the client cannot read from the keyboard.  */
end_comment

begin_function
specifier|static
name|int
name|pckbd_enable
parameter_list|(
name|keyboard_t
modifier|*
name|kbd
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|KBD_ACTIVATE
argument_list|(
name|kbd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* disallow the access to the device */
end_comment

begin_function
specifier|static
name|int
name|pckbd_disable
parameter_list|(
name|keyboard_t
modifier|*
name|kbd
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|KBD_DEACTIVATE
argument_list|(
name|kbd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* read one byte from the keyboard if it's allowed */
end_comment

begin_function
specifier|static
name|int
name|pckbd_read
parameter_list|(
name|keyboard_t
modifier|*
name|kbd
parameter_list|,
name|int
name|wait
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
if|if
condition|(
name|wait
condition|)
name|c
operator|=
name|read_kbd_data
argument_list|(
operator|(
operator|(
name|pckbd_state_t
operator|*
operator|)
name|kbd
operator|->
name|kb_data
operator|)
operator|->
name|kbdc
argument_list|)
expr_stmt|;
else|else
name|c
operator|=
name|read_kbd_data_no_wait
argument_list|(
operator|(
operator|(
name|pckbd_state_t
operator|*
operator|)
name|kbd
operator|->
name|kb_data
operator|)
operator|->
name|kbdc
argument_list|)
expr_stmt|;
return|return
operator|(
name|KBD_IS_ACTIVE
argument_list|(
name|kbd
argument_list|)
condition|?
name|c
else|:
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* check if data is waiting */
end_comment

begin_function
specifier|static
name|int
name|pckbd_check
parameter_list|(
name|keyboard_t
modifier|*
name|kbd
parameter_list|)
block|{
if|if
condition|(
operator|!
name|KBD_IS_ACTIVE
argument_list|(
name|kbd
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
name|kbdc_data_ready
argument_list|(
operator|(
operator|(
name|pckbd_state_t
operator|*
operator|)
name|kbd
operator|->
name|kb_data
operator|)
operator|->
name|kbdc
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* read char from the keyboard */
end_comment

begin_function
specifier|static
name|u_int
name|pckbd_read_char
parameter_list|(
name|keyboard_t
modifier|*
name|kbd
parameter_list|,
name|int
name|wait
parameter_list|)
block|{
name|pckbd_state_t
modifier|*
name|state
decl_stmt|;
name|u_int
name|action
decl_stmt|;
name|int
name|scancode
decl_stmt|;
name|int
name|keycode
decl_stmt|;
name|state
operator|=
operator|(
name|pckbd_state_t
operator|*
operator|)
name|kbd
operator|->
name|kb_data
expr_stmt|;
name|next_code
label|:
comment|/* do we have a composed char to return? */
if|if
condition|(
operator|!
operator|(
name|state
operator|->
name|ks_flags
operator|&
name|COMPOSE
operator|)
operator|&&
operator|(
name|state
operator|->
name|ks_composed_char
operator|>
literal|0
operator|)
condition|)
block|{
name|action
operator|=
name|state
operator|->
name|ks_composed_char
expr_stmt|;
name|state
operator|->
name|ks_composed_char
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|action
operator|>
name|UCHAR_MAX
condition|)
return|return
name|ERRKEY
return|;
return|return
name|action
return|;
block|}
comment|/* see if there is something in the keyboard port */
if|if
condition|(
name|wait
condition|)
block|{
do|do
block|{
name|scancode
operator|=
name|read_kbd_data
argument_list|(
name|state
operator|->
name|kbdc
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|scancode
operator|==
operator|-
literal|1
condition|)
do|;
block|}
else|else
block|{
name|scancode
operator|=
name|read_kbd_data_no_wait
argument_list|(
name|state
operator|->
name|kbdc
argument_list|)
expr_stmt|;
if|if
condition|(
name|scancode
operator|==
operator|-
literal|1
condition|)
return|return
name|NOKEY
return|;
block|}
comment|/* return the byte as is for the K_RAW mode */
if|if
condition|(
name|state
operator|->
name|ks_mode
operator|==
name|K_RAW
condition|)
return|return
name|scancode
return|;
comment|/* translate the scan code into a keycode */
name|keycode
operator|=
name|scancode
operator|&
literal|0x7F
expr_stmt|;
switch|switch
condition|(
name|scancode
condition|)
block|{
case|case
literal|0xF3
case|:
comment|/* GRPH (compose key) released */
if|if
condition|(
name|state
operator|->
name|ks_flags
operator|&
name|COMPOSE
condition|)
block|{
name|state
operator|->
name|ks_flags
operator|&=
operator|~
name|COMPOSE
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|ks_composed_char
operator|>
name|UCHAR_MAX
condition|)
name|state
operator|->
name|ks_composed_char
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
literal|0x73
case|:
comment|/* GRPH (compose key) pressed */
if|if
condition|(
operator|!
operator|(
name|state
operator|->
name|ks_flags
operator|&
name|COMPOSE
operator|)
condition|)
block|{
name|state
operator|->
name|ks_flags
operator||=
name|COMPOSE
expr_stmt|;
name|state
operator|->
name|ks_composed_char
operator|=
literal|0
expr_stmt|;
block|}
break|break;
block|}
comment|/* return the key code in the K_CODE mode */
if|if
condition|(
name|state
operator|->
name|ks_mode
operator|==
name|K_CODE
condition|)
return|return
operator|(
name|keycode
operator||
operator|(
name|scancode
operator|&
literal|0x80
operator|)
operator|)
return|;
comment|/* compose a character code */
if|if
condition|(
name|state
operator|->
name|ks_flags
operator|&
name|COMPOSE
condition|)
block|{
switch|switch
condition|(
name|scancode
condition|)
block|{
comment|/* key pressed, process it */
case|case
literal|0x42
case|:
case|case
literal|0x43
case|:
case|case
literal|0x44
case|:
comment|/* keypad 7,8,9 */
name|state
operator|->
name|ks_composed_char
operator|*=
literal|10
expr_stmt|;
name|state
operator|->
name|ks_composed_char
operator|+=
name|scancode
operator|-
literal|0x3B
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|ks_composed_char
operator|>
name|UCHAR_MAX
condition|)
return|return
name|ERRKEY
return|;
goto|goto
name|next_code
goto|;
case|case
literal|0x46
case|:
case|case
literal|0x47
case|:
case|case
literal|0x48
case|:
comment|/* keypad 4,5,6 */
name|state
operator|->
name|ks_composed_char
operator|*=
literal|10
expr_stmt|;
name|state
operator|->
name|ks_composed_char
operator|+=
name|scancode
operator|-
literal|0x42
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|ks_composed_char
operator|>
name|UCHAR_MAX
condition|)
return|return
name|ERRKEY
return|;
goto|goto
name|next_code
goto|;
case|case
literal|0x4A
case|:
case|case
literal|0x4B
case|:
case|case
literal|0x4C
case|:
comment|/* keypad 1,2,3 */
name|state
operator|->
name|ks_composed_char
operator|*=
literal|10
expr_stmt|;
name|state
operator|->
name|ks_composed_char
operator|+=
name|scancode
operator|-
literal|0x49
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|ks_composed_char
operator|>
name|UCHAR_MAX
condition|)
return|return
name|ERRKEY
return|;
goto|goto
name|next_code
goto|;
case|case
literal|0x4E
case|:
comment|/* keypad 0 */
name|state
operator|->
name|ks_composed_char
operator|*=
literal|10
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|ks_composed_char
operator|>
name|UCHAR_MAX
condition|)
return|return
name|ERRKEY
return|;
goto|goto
name|next_code
goto|;
comment|/* key released, no interest here */
case|case
literal|0xC2
case|:
case|case
literal|0xC3
case|:
case|case
literal|0xC4
case|:
comment|/* keypad 7,8,9 */
case|case
literal|0xC6
case|:
case|case
literal|0xC7
case|:
case|case
literal|0xC8
case|:
comment|/* keypad 4,5,6 */
case|case
literal|0xCA
case|:
case|case
literal|0xCB
case|:
case|case
literal|0xCC
case|:
comment|/* keypad 1,2,3 */
case|case
literal|0xCE
case|:
comment|/* keypad 0 */
goto|goto
name|next_code
goto|;
case|case
literal|0x73
case|:
comment|/* GRPH key */
break|break;
default|default:
if|if
condition|(
name|state
operator|->
name|ks_composed_char
operator|>
literal|0
condition|)
block|{
name|state
operator|->
name|ks_flags
operator|&=
operator|~
name|COMPOSE
expr_stmt|;
name|state
operator|->
name|ks_composed_char
operator|=
literal|0
expr_stmt|;
return|return
name|ERRKEY
return|;
block|}
break|break;
block|}
block|}
comment|/* keycode to key action */
name|action
operator|=
name|genkbd_keyaction
argument_list|(
name|kbd
argument_list|,
name|keycode
argument_list|,
name|scancode
operator|&
literal|0x80
argument_list|,
operator|&
name|state
operator|->
name|ks_state
argument_list|,
operator|&
name|state
operator|->
name|ks_accents
argument_list|)
expr_stmt|;
if|if
condition|(
name|action
operator|==
name|NOKEY
condition|)
goto|goto
name|next_code
goto|;
else|else
return|return
name|action
return|;
block|}
end_function

begin_comment
comment|/* check if char is waiting */
end_comment

begin_function
specifier|static
name|int
name|pckbd_check_char
parameter_list|(
name|keyboard_t
modifier|*
name|kbd
parameter_list|)
block|{
name|pckbd_state_t
modifier|*
name|state
decl_stmt|;
if|if
condition|(
operator|!
name|KBD_IS_ACTIVE
argument_list|(
name|kbd
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|state
operator|=
operator|(
name|pckbd_state_t
operator|*
operator|)
name|kbd
operator|->
name|kb_data
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|state
operator|->
name|ks_flags
operator|&
name|COMPOSE
operator|)
operator|&&
operator|(
name|state
operator|->
name|ks_composed_char
operator|>
literal|0
operator|)
condition|)
return|return
name|TRUE
return|;
return|return
name|kbdc_data_ready
argument_list|(
name|state
operator|->
name|kbdc
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* some useful control functions */
end_comment

begin_function
specifier|static
name|int
name|pckbd_ioctl
parameter_list|(
name|keyboard_t
modifier|*
name|kbd
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|)
block|{
name|pckbd_state_t
modifier|*
name|state
init|=
name|kbd
operator|->
name|kb_data
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|i
decl_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|KDGKBMODE
case|:
comment|/* get keyboard mode */
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|state
operator|->
name|ks_mode
expr_stmt|;
break|break;
case|case
name|KDSKBMODE
case|:
comment|/* set keyboard mode */
switch|switch
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
condition|)
block|{
case|case
name|K_XLATE
case|:
if|if
condition|(
name|state
operator|->
name|ks_mode
operator|!=
name|K_XLATE
condition|)
block|{
comment|/* make lock key state and LED state match */
name|state
operator|->
name|ks_state
operator|&=
operator|~
name|LOCK_MASK
expr_stmt|;
name|state
operator|->
name|ks_state
operator||=
name|KBD_LED_VAL
argument_list|(
name|kbd
argument_list|)
expr_stmt|;
block|}
comment|/* FALL THROUGH */
case|case
name|K_RAW
case|:
case|case
name|K_CODE
case|:
if|if
condition|(
name|state
operator|->
name|ks_mode
operator|!=
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
condition|)
block|{
name|pckbd_clear_state
argument_list|(
name|kbd
argument_list|)
expr_stmt|;
name|state
operator|->
name|ks_mode
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
expr_stmt|;
block|}
break|break;
default|default:
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
break|break;
case|case
name|KDGETLED
case|:
comment|/* get keyboard LED */
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|KBD_LED_VAL
argument_list|(
name|kbd
argument_list|)
expr_stmt|;
break|break;
case|case
name|KDSETLED
case|:
comment|/* set keyboard LED */
comment|/* NOTE: lock key state in ks_state won't be changed */
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|&
operator|~
name|LOCK_MASK
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|i
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
expr_stmt|;
comment|/* replace CAPS LED with ALTGR LED for ALTGR keyboards */
if|if
condition|(
name|kbd
operator|->
name|kb_keymap
operator|->
name|n_keys
operator|>
name|ALTGR_OFFSET
condition|)
block|{
if|if
condition|(
name|i
operator|&
name|ALKED
condition|)
name|i
operator||=
name|CLKED
expr_stmt|;
else|else
name|i
operator|&=
operator|~
name|CLKED
expr_stmt|;
block|}
name|KBD_LED_VAL
argument_list|(
name|kbd
argument_list|)
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
expr_stmt|;
break|break;
case|case
name|KDGKBSTATE
case|:
comment|/* get lock key state */
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|state
operator|->
name|ks_state
operator|&
name|LOCK_MASK
expr_stmt|;
break|break;
case|case
name|KDSKBSTATE
case|:
comment|/* set lock key state */
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|&
operator|~
name|LOCK_MASK
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|state
operator|->
name|ks_state
operator|&=
operator|~
name|LOCK_MASK
expr_stmt|;
name|state
operator|->
name|ks_state
operator||=
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* set LEDs and quit */
return|return
name|pckbd_ioctl
argument_list|(
name|kbd
argument_list|,
name|KDSETLED
argument_list|,
name|arg
argument_list|)
return|;
case|case
name|KDSETRAD
case|:
comment|/* set keyboard repeat rate */
break|break;
case|case
name|PIO_KEYMAP
case|:
comment|/* set keyboard translation table */
case|case
name|PIO_KEYMAPENT
case|:
comment|/* set keyboard translation table entry */
case|case
name|PIO_DEADKEYMAP
case|:
comment|/* set accent key translation table */
name|state
operator|->
name|ks_accents
operator|=
literal|0
expr_stmt|;
comment|/* FALL THROUGH */
default|default:
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|genkbd_commonioctl
argument_list|(
name|kbd
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|)
return|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* lock the access to the keyboard */
end_comment

begin_function
specifier|static
name|int
name|pckbd_lock
parameter_list|(
name|keyboard_t
modifier|*
name|kbd
parameter_list|,
name|int
name|lock
parameter_list|)
block|{
return|return
name|kbdc_lock
argument_list|(
operator|(
operator|(
name|pckbd_state_t
operator|*
operator|)
name|kbd
operator|->
name|kb_data
operator|)
operator|->
name|kbdc
argument_list|,
name|lock
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* clear the internal state of the keyboard */
end_comment

begin_function
specifier|static
name|void
name|pckbd_clear_state
parameter_list|(
name|keyboard_t
modifier|*
name|kbd
parameter_list|)
block|{
name|pckbd_state_t
modifier|*
name|state
decl_stmt|;
name|state
operator|=
operator|(
name|pckbd_state_t
operator|*
operator|)
name|kbd
operator|->
name|kb_data
expr_stmt|;
name|state
operator|->
name|ks_flags
operator|=
literal|0
expr_stmt|;
name|state
operator|->
name|ks_state
operator|&=
name|LOCK_MASK
expr_stmt|;
comment|/* preserve locking key state */
name|state
operator|->
name|ks_accents
operator|=
literal|0
expr_stmt|;
name|state
operator|->
name|ks_composed_char
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* save the internal state */
end_comment

begin_function
specifier|static
name|int
name|pckbd_get_state
parameter_list|(
name|keyboard_t
modifier|*
name|kbd
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
sizeof|sizeof
argument_list|(
name|pckbd_state_t
argument_list|)
return|;
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
name|pckbd_state_t
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|bcopy
argument_list|(
name|kbd
operator|->
name|kb_data
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|pckbd_state_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* set the internal state */
end_comment

begin_function
specifier|static
name|int
name|pckbd_set_state
parameter_list|(
name|keyboard_t
modifier|*
name|kbd
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
name|pckbd_state_t
argument_list|)
condition|)
return|return
name|ENOMEM
return|;
if|if
condition|(
operator|(
operator|(
name|pckbd_state_t
operator|*
operator|)
name|kbd
operator|->
name|kb_data
operator|)
operator|->
name|kbdc
operator|!=
operator|(
operator|(
name|pckbd_state_t
operator|*
operator|)
name|buf
operator|)
operator|->
name|kbdc
condition|)
return|return
name|ENOMEM
return|;
name|bcopy
argument_list|(
name|buf
argument_list|,
name|kbd
operator|->
name|kb_data
argument_list|,
sizeof|sizeof
argument_list|(
name|pckbd_state_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* local functions */
end_comment

begin_function
specifier|static
name|int
name|probe_keyboard
parameter_list|(
name|KBDC
name|kbdc
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|init_keyboard
parameter_list|(
name|KBDC
name|kbdc
parameter_list|,
name|int
modifier|*
name|type
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
operator|*
name|type
operator|=
name|KB_OTHER
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* keyboard I/O routines */
end_comment

begin_comment
comment|/* retry count */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|KBD_MAXRETRY
end_ifndef

begin_define
define|#
directive|define
name|KBD_MAXRETRY
value|3
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* timing parameters */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|KBD_RESETDELAY
end_ifndef

begin_define
define|#
directive|define
name|KBD_RESETDELAY
value|200
end_define

begin_comment
comment|/* wait 200msec after kbd/mouse reset */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|KBD_MAXWAIT
end_ifndef

begin_define
define|#
directive|define
name|KBD_MAXWAIT
value|5
end_define

begin_comment
comment|/* wait 5 times at most after reset */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* I/O recovery time */
end_comment

begin_define
define|#
directive|define
name|KBDC_DELAYTIME
value|37
end_define

begin_define
define|#
directive|define
name|KBDD_DELAYTIME
value|37
end_define

begin_comment
comment|/* I/O ports */
end_comment

begin_define
define|#
directive|define
name|KBD_STATUS_PORT
value|2
end_define

begin_comment
comment|/* status port, read */
end_comment

begin_define
define|#
directive|define
name|KBD_DATA_PORT
value|0
end_define

begin_comment
comment|/* data port, read */
end_comment

begin_comment
comment|/* status bits (KBD_STATUS_PORT) */
end_comment

begin_define
define|#
directive|define
name|KBDS_BUFFER_FULL
value|0x0002
end_define

begin_comment
comment|/* macros */
end_comment

begin_define
define|#
directive|define
name|kbdcp
parameter_list|(
name|p
parameter_list|)
value|((struct kbdc_softc *)(p))
end_define

begin_comment
comment|/* local variables */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|kbdc_softc
name|kbdc_softc
index|[
name|NPCKBD
index|]
init|=
block|{
block|{
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* associate a port number with a KBDC */
end_comment

begin_function
specifier|static
name|KBDC
name|kbdc_open
parameter_list|(
name|int
name|port
parameter_list|)
block|{
if|if
condition|(
name|port
operator|<=
literal|0
condition|)
name|port
operator|=
name|IO_KBD
expr_stmt|;
if|if
condition|(
name|NPCKBD
condition|)
block|{
comment|/* PC-98 has only one keyboard I/F */
name|kbdc_softc
index|[
literal|0
index|]
operator|.
name|port
operator|=
name|port
expr_stmt|;
name|kbdc_softc
index|[
literal|0
index|]
operator|.
name|lock
operator|=
name|FALSE
expr_stmt|;
return|return
operator|(
name|KBDC
operator|)
operator|&
name|kbdc_softc
index|[
literal|0
index|]
return|;
block|}
return|return
name|NULL
return|;
comment|/* You didn't include sc driver in your config file */
block|}
end_function

begin_comment
comment|/* set/reset polling lock */
end_comment

begin_function
specifier|static
name|int
name|kbdc_lock
parameter_list|(
name|KBDC
name|p
parameter_list|,
name|int
name|lock
parameter_list|)
block|{
name|int
name|prevlock
decl_stmt|;
name|prevlock
operator|=
name|kbdcp
argument_list|(
name|p
argument_list|)
operator|->
name|lock
expr_stmt|;
name|kbdcp
argument_list|(
name|p
argument_list|)
operator|->
name|lock
operator|=
name|lock
expr_stmt|;
return|return
operator|(
name|prevlock
operator|!=
name|lock
operator|)
return|;
block|}
end_function

begin_comment
comment|/* check if any data is waiting to be processed */
end_comment

begin_function
specifier|static
name|int
name|kbdc_data_ready
parameter_list|(
name|KBDC
name|p
parameter_list|)
block|{
return|return
operator|(
name|inb
argument_list|(
name|kbdcp
argument_list|(
name|p
argument_list|)
operator|->
name|port
operator|+
name|KBD_STATUS_PORT
argument_list|)
operator|&
name|KBDS_BUFFER_FULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* wait for data from the keyboard */
end_comment

begin_function
specifier|static
name|int
name|wait_for_kbd_data
parameter_list|(
name|struct
name|kbdc_softc
modifier|*
name|kbdc
parameter_list|)
block|{
comment|/* CPU will stay inside the loop for 200msec at most */
name|int
name|retry
init|=
literal|10000
decl_stmt|;
name|int
name|port
init|=
name|kbdc
operator|->
name|port
decl_stmt|;
while|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|port
operator|+
name|KBD_STATUS_PORT
argument_list|)
operator|&
name|KBDS_BUFFER_FULL
operator|)
condition|)
block|{
name|DELAY
argument_list|(
name|KBDD_DELAYTIME
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|KBDC_DELAYTIME
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|retry
operator|<
literal|0
condition|)
return|return
literal|0
return|;
block|}
name|DELAY
argument_list|(
name|KBDD_DELAYTIME
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* read one byte from the keyboard */
end_comment

begin_function
specifier|static
name|int
name|read_kbd_data
parameter_list|(
name|KBDC
name|p
parameter_list|)
block|{
if|if
condition|(
operator|!
name|wait_for_kbd_data
argument_list|(
name|kbdcp
argument_list|(
name|p
argument_list|)
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* timeout */
name|DELAY
argument_list|(
name|KBDC_DELAYTIME
argument_list|)
expr_stmt|;
return|return
name|inb
argument_list|(
name|kbdcp
argument_list|(
name|p
argument_list|)
operator|->
name|port
operator|+
name|KBD_DATA_PORT
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* read one byte from the keyboard, but return immediately if   * no data is waiting  */
end_comment

begin_function
specifier|static
name|int
name|read_kbd_data_no_wait
parameter_list|(
name|KBDC
name|p
parameter_list|)
block|{
if|if
condition|(
name|inb
argument_list|(
name|kbdcp
argument_list|(
name|p
argument_list|)
operator|->
name|port
operator|+
name|KBD_STATUS_PORT
argument_list|)
operator|&
name|KBDS_BUFFER_FULL
condition|)
block|{
name|DELAY
argument_list|(
name|KBDD_DELAYTIME
argument_list|)
expr_stmt|;
return|return
name|inb
argument_list|(
name|kbdcp
argument_list|(
name|p
argument_list|)
operator|->
name|port
operator|+
name|KBD_DATA_PORT
argument_list|)
return|;
block|}
return|return
operator|-
literal|1
return|;
comment|/* no data */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NPCKBD> 0 */
end_comment

end_unit

