begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * spkr.c -- device driver for console speaker  *  * v1.4 by Eric S. Raymond (esr@snark.thyrsus.com) Aug 1993  * modified for FreeBSD by Andrew A. Chernov<ache@astral.msk.su>  *  *    $Id: spkr.c,v 1.10 1998/01/24 02:54:39 eivind Exp $  */
end_comment

begin_comment
comment|/*  * modified for PC98 by Kakefuda  */
end_comment

begin_include
include|#
directive|include
file|"speaker.h"
end_include

begin_if
if|#
directive|if
name|NSPEAKER
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|"opt_devfs.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|PC98
end_ifdef

begin_include
include|#
directive|include
file|<pc98/pc98/pc98.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<i386/isa/isa.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<i386/isa/timerreg.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<machine/speaker.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEVFS
end_ifdef

begin_include
include|#
directive|include
file|<sys/devfsext.h>
end_include

begin_decl_stmt
specifier|static
name|void
modifier|*
name|devfs_token
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|d_open_t
name|spkropen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|spkrclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_write_t
name|spkrwrite
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|spkrioctl
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CDEV_MAJOR
value|26
end_define

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|spkr_cdevsw
init|=
block|{
name|spkropen
block|,
name|spkrclose
block|,
name|noread
block|,
name|spkrwrite
block|,
comment|/*26*/
name|spkrioctl
block|,
name|nostop
block|,
name|nullreset
block|,
name|nodevtotty
block|,
comment|/* spkr */
name|seltrue
block|,
name|nommap
block|,
name|NULL
block|,
literal|"spkr"
block|,
name|NULL
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**************** MACHINE DEPENDENT PART STARTS HERE *************************  *  * This section defines a function tone() which causes a tone of given  * frequency and duration from the ISA console speaker.  * Another function endtone() is defined to force sound off, and there is  * also a rest() entry point to do pauses.  *  * Audible sound is generated using the Programmable Interval Timer (PIT) and  * Programmable Peripheral Interface (PPI) attached to the ISA speaker. The  * PPI controls whether sound is passed through at all; the PIT's channel 2 is  * used to generate clicks (a square wave) of whatever frequency is desired.  */
end_comment

begin_comment
comment|/*  * PPI control values.  * XXX should be in a header and used in clock.c.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PC98
end_ifdef

begin_define
define|#
directive|define
name|PPI_SPKR
value|0x08
end_define

begin_comment
comment|/* turn these PPI bits on to pass sound */
end_comment

begin_define
define|#
directive|define
name|PIT_COUNT
value|0x3fdb
end_define

begin_comment
comment|/* PIT count address */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PPI_SPKR
value|0x03
end_define

begin_comment
comment|/* turn these PPI bits on to pass sound */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|SPKRPRI
value|PSOCK
end_define

begin_decl_stmt
specifier|static
name|char
name|endtone
decl_stmt|,
name|endrest
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tone
name|__P
argument_list|(
operator|(
name|unsigned
name|int
name|thz
operator|,
name|unsigned
name|int
name|ticks
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|rest
name|__P
argument_list|(
operator|(
name|int
name|ticks
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|playinit
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|playtone
name|__P
argument_list|(
operator|(
name|int
name|pitch
operator|,
name|int
name|value
operator|,
name|int
name|sustain
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|abs
name|__P
argument_list|(
operator|(
name|int
name|n
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|playstring
name|__P
argument_list|(
operator|(
name|char
operator|*
name|cp
operator|,
name|size_t
name|slen
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* emit tone of frequency thz for given number of ticks */
end_comment

begin_function
specifier|static
name|void
name|tone
parameter_list|(
name|thz
parameter_list|,
name|ticks
parameter_list|)
name|unsigned
name|int
name|thz
decl_stmt|,
name|ticks
decl_stmt|;
block|{
name|unsigned
name|int
name|divisor
decl_stmt|;
name|int
name|sps
decl_stmt|;
if|if
condition|(
name|thz
operator|<=
literal|0
condition|)
return|return;
name|divisor
operator|=
name|timer_freq
operator|/
name|thz
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"tone: thz=%d ticks=%d\n"
argument_list|,
name|thz
argument_list|,
name|ticks
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
comment|/* set timer to generate clicks at given frequency in Hertz */
name|sps
operator|=
name|splclock
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
if|if
condition|(
name|acquire_timer1
argument_list|(
name|TIMER_SEL1
operator||
name|TIMER_SQWAVE
operator||
name|TIMER_16BIT
argument_list|)
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|acquire_timer2
argument_list|(
name|TIMER_SEL2
operator||
name|TIMER_SQWAVE
operator||
name|TIMER_16BIT
argument_list|)
condition|)
block|{
endif|#
directive|endif
comment|/* enter list of waiting procs ??? */
name|splx
argument_list|(
name|sps
argument_list|)
expr_stmt|;
return|return;
block|}
name|splx
argument_list|(
name|sps
argument_list|)
expr_stmt|;
name|disable_intr
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|outb
argument_list|(
name|PIT_COUNT
argument_list|,
operator|(
name|divisor
operator|&
literal|0xff
operator|)
argument_list|)
expr_stmt|;
comment|/* send lo byte */
name|outb
argument_list|(
name|PIT_COUNT
argument_list|,
operator|(
name|divisor
operator|>>
literal|8
operator|)
argument_list|)
expr_stmt|;
comment|/* send hi byte */
else|#
directive|else
name|outb
argument_list|(
name|TIMER_CNTR2
argument_list|,
operator|(
name|divisor
operator|&
literal|0xff
operator|)
argument_list|)
expr_stmt|;
comment|/* send lo byte */
name|outb
argument_list|(
name|TIMER_CNTR2
argument_list|,
operator|(
name|divisor
operator|>>
literal|8
operator|)
argument_list|)
expr_stmt|;
comment|/* send hi byte */
endif|#
directive|endif
name|enable_intr
argument_list|()
expr_stmt|;
comment|/* turn the speaker on */
ifdef|#
directive|ifdef
name|PC98
name|outb
argument_list|(
name|IO_PPI
argument_list|,
name|inb
argument_list|(
name|IO_PPI
argument_list|)
operator|&
operator|~
name|PPI_SPKR
argument_list|)
expr_stmt|;
else|#
directive|else
name|outb
argument_list|(
name|IO_PPI
argument_list|,
name|inb
argument_list|(
name|IO_PPI
argument_list|)
operator||
name|PPI_SPKR
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*      * Set timeout to endtone function, then give up the timeslice.      * This is so other processes can execute while the tone is being      * emitted.      */
if|if
condition|(
name|ticks
operator|>
literal|0
condition|)
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|endtone
argument_list|,
name|SPKRPRI
operator||
name|PCATCH
argument_list|,
literal|"spkrtn"
argument_list|,
name|ticks
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|outb
argument_list|(
name|IO_PPI
argument_list|,
name|inb
argument_list|(
name|IO_PPI
argument_list|)
operator||
name|PPI_SPKR
argument_list|)
expr_stmt|;
name|sps
operator|=
name|splclock
argument_list|()
expr_stmt|;
name|release_timer1
argument_list|()
expr_stmt|;
name|splx
argument_list|(
name|sps
argument_list|)
expr_stmt|;
else|#
directive|else
name|outb
argument_list|(
name|IO_PPI
argument_list|,
name|inb
argument_list|(
name|IO_PPI
argument_list|)
operator|&
operator|~
name|PPI_SPKR
argument_list|)
expr_stmt|;
name|sps
operator|=
name|splclock
argument_list|()
expr_stmt|;
name|release_timer2
argument_list|()
expr_stmt|;
name|splx
argument_list|(
name|sps
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* rest for given number of ticks */
specifier|static
name|void
name|rest
parameter_list|(
name|ticks
parameter_list|)
name|int
name|ticks
decl_stmt|;
block|{
comment|/*      * Set timeout to endrest function, then give up the timeslice.      * This is so other processes can execute while the rest is being      * waited out.      */
ifdef|#
directive|ifdef
name|DEBUG
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"rest: %d\n"
argument_list|,
name|ticks
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
if|if
condition|(
name|ticks
operator|>
literal|0
condition|)
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|endrest
argument_list|,
name|SPKRPRI
operator||
name|PCATCH
argument_list|,
literal|"spkrrs"
argument_list|,
name|ticks
argument_list|)
expr_stmt|;
block|}
comment|/**************** PLAY STRING INTERPRETER BEGINS HERE **********************  *  * Play string interpretation is modelled on IBM BASIC 2.0's PLAY statement;  * M[LNS] are missing; the ~ synonym and the _ slur mark and the octave-  * tracking facility are added.  * Requires tone(), rest(), and endtone(). String play is not interruptible  * except possibly at physical block boundaries.  */
typedef|typedef
name|int
name|bool
typedef|;
define|#
directive|define
name|TRUE
value|1
define|#
directive|define
name|FALSE
value|0
define|#
directive|define
name|toupper
parameter_list|(
name|c
parameter_list|)
value|((c) - ' ' * (((c)>= 'a')&& ((c)<= 'z')))
define|#
directive|define
name|isdigit
parameter_list|(
name|c
parameter_list|)
value|(((c)>= '0')&& ((c)<= '9'))
define|#
directive|define
name|dtoi
parameter_list|(
name|c
parameter_list|)
value|((c) - '0')
specifier|static
name|int
name|octave
decl_stmt|;
comment|/* currently selected octave */
specifier|static
name|int
name|whole
decl_stmt|;
comment|/* whole-note time at current tempo, in ticks */
specifier|static
name|int
name|value
decl_stmt|;
comment|/* whole divisor for note time, quarter note = 1 */
specifier|static
name|int
name|fill
decl_stmt|;
comment|/* controls spacing of notes */
specifier|static
name|bool
name|octtrack
decl_stmt|;
comment|/* octave-tracking on? */
specifier|static
name|bool
name|octprefix
decl_stmt|;
comment|/* override current octave-tracking state? */
comment|/*  * Magic number avoidance...  */
define|#
directive|define
name|SECS_PER_MIN
value|60
comment|/* seconds per minute */
define|#
directive|define
name|WHOLE_NOTE
value|4
comment|/* quarter notes per whole note */
define|#
directive|define
name|MIN_VALUE
value|64
comment|/* the most we can divide a note by */
define|#
directive|define
name|DFLT_VALUE
value|4
comment|/* default value (quarter-note) */
define|#
directive|define
name|FILLTIME
value|8
comment|/* for articulation, break note in parts */
define|#
directive|define
name|STACCATO
value|6
comment|/* 6/8 = 3/4 of note is filled */
define|#
directive|define
name|NORMAL
value|7
comment|/* 7/8ths of note interval is filled */
define|#
directive|define
name|LEGATO
value|8
comment|/* all of note interval is filled */
define|#
directive|define
name|DFLT_OCTAVE
value|4
comment|/* default octave */
define|#
directive|define
name|MIN_TEMPO
value|32
comment|/* minimum tempo */
define|#
directive|define
name|DFLT_TEMPO
value|120
comment|/* default tempo */
define|#
directive|define
name|MAX_TEMPO
value|255
comment|/* max tempo */
define|#
directive|define
name|NUM_MULT
value|3
comment|/* numerator of dot multiplier */
define|#
directive|define
name|DENOM_MULT
value|2
comment|/* denominator of dot multiplier */
comment|/* letter to half-tone:  A   B  C  D  E  F  G */
specifier|static
name|int
name|notetab
index|[
literal|8
index|]
init|=
block|{
literal|9
block|,
literal|11
block|,
literal|0
block|,
literal|2
block|,
literal|4
block|,
literal|5
block|,
literal|7
block|}
decl_stmt|;
comment|/*  * This is the American Standard A440 Equal-Tempered scale with frequencies  * rounded to nearest integer. Thank Goddess for the good ol' CRC Handbook...  * our octave 0 is standard octave 2.  */
define|#
directive|define
name|OCTAVE_NOTES
value|12
comment|/* semitones per octave */
specifier|static
name|int
name|pitchtab
index|[]
init|=
block|{
comment|/*        C     C#    D     D#    E     F     F#    G     G#    A     A#    B*/
comment|/* 0 */
literal|65
block|,
literal|69
block|,
literal|73
block|,
literal|78
block|,
literal|82
block|,
literal|87
block|,
literal|93
block|,
literal|98
block|,
literal|103
block|,
literal|110
block|,
literal|117
block|,
literal|123
block|,
comment|/* 1 */
literal|131
block|,
literal|139
block|,
literal|147
block|,
literal|156
block|,
literal|165
block|,
literal|175
block|,
literal|185
block|,
literal|196
block|,
literal|208
block|,
literal|220
block|,
literal|233
block|,
literal|247
block|,
comment|/* 2 */
literal|262
block|,
literal|277
block|,
literal|294
block|,
literal|311
block|,
literal|330
block|,
literal|349
block|,
literal|370
block|,
literal|392
block|,
literal|415
block|,
literal|440
block|,
literal|466
block|,
literal|494
block|,
comment|/* 3 */
literal|523
block|,
literal|554
block|,
literal|587
block|,
literal|622
block|,
literal|659
block|,
literal|698
block|,
literal|740
block|,
literal|784
block|,
literal|831
block|,
literal|880
block|,
literal|932
block|,
literal|988
block|,
comment|/* 4 */
literal|1047
block|,
literal|1109
block|,
literal|1175
block|,
literal|1245
block|,
literal|1319
block|,
literal|1397
block|,
literal|1480
block|,
literal|1568
block|,
literal|1661
block|,
literal|1760
block|,
literal|1865
block|,
literal|1975
block|,
comment|/* 5 */
literal|2093
block|,
literal|2217
block|,
literal|2349
block|,
literal|2489
block|,
literal|2637
block|,
literal|2794
block|,
literal|2960
block|,
literal|3136
block|,
literal|3322
block|,
literal|3520
block|,
literal|3729
block|,
literal|3951
block|,
comment|/* 6 */
literal|4186
block|,
literal|4435
block|,
literal|4698
block|,
literal|4978
block|,
literal|5274
block|,
literal|5588
block|,
literal|5920
block|,
literal|6272
block|,
literal|6644
block|,
literal|7040
block|,
literal|7459
block|,
literal|7902
block|, }
decl_stmt|;
specifier|static
name|void
name|playinit
parameter_list|()
block|{
name|octave
operator|=
name|DFLT_OCTAVE
expr_stmt|;
name|whole
operator|=
operator|(
name|hz
operator|*
name|SECS_PER_MIN
operator|*
name|WHOLE_NOTE
operator|)
operator|/
name|DFLT_TEMPO
expr_stmt|;
name|fill
operator|=
name|NORMAL
expr_stmt|;
name|value
operator|=
name|DFLT_VALUE
expr_stmt|;
name|octtrack
operator|=
name|FALSE
expr_stmt|;
name|octprefix
operator|=
name|TRUE
expr_stmt|;
comment|/* act as though there was an initial O(n) */
block|}
comment|/* play tone of proper duration for current rhythm signature */
specifier|static
name|void
name|playtone
parameter_list|(
name|pitch
parameter_list|,
name|value
parameter_list|,
name|sustain
parameter_list|)
name|int
name|pitch
decl_stmt|,
name|value
decl_stmt|,
name|sustain
decl_stmt|;
block|{
specifier|register
name|int
name|sound
decl_stmt|,
name|silence
decl_stmt|,
name|snum
init|=
literal|1
decl_stmt|,
name|sdenom
init|=
literal|1
decl_stmt|;
comment|/* this weirdness avoids floating-point arithmetic */
for|for
control|(
init|;
name|sustain
condition|;
name|sustain
operator|--
control|)
block|{
comment|/* See the BUGS section in the man page for discussion */
name|snum
operator|*=
name|NUM_MULT
expr_stmt|;
name|sdenom
operator|*=
name|DENOM_MULT
expr_stmt|;
block|}
if|if
condition|(
name|value
operator|==
literal|0
operator|||
name|sdenom
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|pitch
operator|==
operator|-
literal|1
condition|)
name|rest
argument_list|(
name|whole
operator|*
name|snum
operator|/
operator|(
name|value
operator|*
name|sdenom
operator|)
argument_list|)
expr_stmt|;
else|else
block|{
name|sound
operator|=
operator|(
name|whole
operator|*
name|snum
operator|)
operator|/
operator|(
name|value
operator|*
name|sdenom
operator|)
operator|-
operator|(
name|whole
operator|*
operator|(
name|FILLTIME
operator|-
name|fill
operator|)
operator|)
operator|/
operator|(
name|value
operator|*
name|FILLTIME
operator|)
expr_stmt|;
name|silence
operator|=
name|whole
operator|*
operator|(
name|FILLTIME
operator|-
name|fill
operator|)
operator|*
name|snum
operator|/
operator|(
name|FILLTIME
operator|*
name|value
operator|*
name|sdenom
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"playtone: pitch %d for %d ticks, rest for %d ticks\n"
argument_list|,
name|pitch
argument_list|,
name|sound
argument_list|,
name|silence
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|tone
argument_list|(
name|pitchtab
index|[
name|pitch
index|]
argument_list|,
name|sound
argument_list|)
expr_stmt|;
if|if
condition|(
name|fill
operator|!=
name|LEGATO
condition|)
name|rest
argument_list|(
name|silence
argument_list|)
expr_stmt|;
block|}
block|}
specifier|static
name|int
name|abs
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
if|if
condition|(
name|n
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
name|n
operator|)
return|;
else|else
return|return
operator|(
name|n
operator|)
return|;
block|}
comment|/* interpret and play an item from a notation string */
specifier|static
name|void
name|playstring
parameter_list|(
name|cp
parameter_list|,
name|slen
parameter_list|)
name|char
modifier|*
name|cp
decl_stmt|;
name|size_t
name|slen
decl_stmt|;
block|{
name|int
name|pitch
decl_stmt|,
name|oldfill
decl_stmt|,
name|lastpitch
init|=
name|OCTAVE_NOTES
operator|*
name|DFLT_OCTAVE
decl_stmt|;
define|#
directive|define
name|GETNUM
parameter_list|(
name|cp
parameter_list|,
name|v
parameter_list|)
value|for(v=0; isdigit(cp[1])&& slen> 0; ) \ 				{v = v * 10 + (*++cp - '0'); slen--;}
for|for
control|(
init|;
name|slen
operator|--
condition|;
name|cp
operator|++
control|)
block|{
name|int
name|sustain
decl_stmt|,
name|timeval
decl_stmt|,
name|tempo
decl_stmt|;
specifier|register
name|char
name|c
init|=
name|toupper
argument_list|(
operator|*
name|cp
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"playstring: %c (%x)\n"
argument_list|,
name|c
argument_list|,
name|c
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'A'
case|:
case|case
literal|'B'
case|:
case|case
literal|'C'
case|:
case|case
literal|'D'
case|:
case|case
literal|'E'
case|:
case|case
literal|'F'
case|:
case|case
literal|'G'
case|:
comment|/* compute pitch */
name|pitch
operator|=
name|notetab
index|[
name|c
operator|-
literal|'A'
index|]
operator|+
name|octave
operator|*
name|OCTAVE_NOTES
expr_stmt|;
comment|/* this may be followed by an accidental sign */
if|if
condition|(
name|cp
index|[
literal|1
index|]
operator|==
literal|'#'
operator|||
name|cp
index|[
literal|1
index|]
operator|==
literal|'+'
condition|)
block|{
operator|++
name|pitch
expr_stmt|;
operator|++
name|cp
expr_stmt|;
name|slen
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cp
index|[
literal|1
index|]
operator|==
literal|'-'
condition|)
block|{
operator|--
name|pitch
expr_stmt|;
operator|++
name|cp
expr_stmt|;
name|slen
operator|--
expr_stmt|;
block|}
comment|/* 	     * If octave-tracking mode is on, and there has been no octave- 	     * setting prefix, find the version of the current letter note 	     * closest to the last regardless of octave. 	     */
if|if
condition|(
name|octtrack
operator|&&
operator|!
name|octprefix
condition|)
block|{
if|if
condition|(
name|abs
argument_list|(
name|pitch
operator|-
name|lastpitch
argument_list|)
operator|>
name|abs
argument_list|(
name|pitch
operator|+
name|OCTAVE_NOTES
operator|-
name|lastpitch
argument_list|)
condition|)
block|{
operator|++
name|octave
expr_stmt|;
name|pitch
operator|+=
name|OCTAVE_NOTES
expr_stmt|;
block|}
if|if
condition|(
name|abs
argument_list|(
name|pitch
operator|-
name|lastpitch
argument_list|)
operator|>
name|abs
argument_list|(
operator|(
name|pitch
operator|-
name|OCTAVE_NOTES
operator|)
operator|-
name|lastpitch
argument_list|)
condition|)
block|{
operator|--
name|octave
expr_stmt|;
name|pitch
operator|-=
name|OCTAVE_NOTES
expr_stmt|;
block|}
block|}
name|octprefix
operator|=
name|FALSE
expr_stmt|;
name|lastpitch
operator|=
name|pitch
expr_stmt|;
comment|/* ...which may in turn be followed by an override time value */
name|GETNUM
argument_list|(
name|cp
argument_list|,
name|timeval
argument_list|)
expr_stmt|;
if|if
condition|(
name|timeval
operator|<=
literal|0
operator|||
name|timeval
operator|>
name|MIN_VALUE
condition|)
name|timeval
operator|=
name|value
expr_stmt|;
comment|/* ...and/or sustain dots */
for|for
control|(
name|sustain
operator|=
literal|0
init|;
name|cp
index|[
literal|1
index|]
operator|==
literal|'.'
condition|;
name|cp
operator|++
control|)
block|{
name|slen
operator|--
expr_stmt|;
name|sustain
operator|++
expr_stmt|;
block|}
comment|/* ...and/or a slur mark */
name|oldfill
operator|=
name|fill
expr_stmt|;
if|if
condition|(
name|cp
index|[
literal|1
index|]
operator|==
literal|'_'
condition|)
block|{
name|fill
operator|=
name|LEGATO
expr_stmt|;
operator|++
name|cp
expr_stmt|;
name|slen
operator|--
expr_stmt|;
block|}
comment|/* time to emit the actual tone */
name|playtone
argument_list|(
name|pitch
argument_list|,
name|timeval
argument_list|,
name|sustain
argument_list|)
expr_stmt|;
name|fill
operator|=
name|oldfill
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
if|if
condition|(
name|cp
index|[
literal|1
index|]
operator|==
literal|'N'
operator|||
name|cp
index|[
literal|1
index|]
operator|==
literal|'n'
condition|)
block|{
name|octprefix
operator|=
name|octtrack
operator|=
name|FALSE
expr_stmt|;
operator|++
name|cp
expr_stmt|;
name|slen
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cp
index|[
literal|1
index|]
operator|==
literal|'L'
operator|||
name|cp
index|[
literal|1
index|]
operator|==
literal|'l'
condition|)
block|{
name|octtrack
operator|=
name|TRUE
expr_stmt|;
operator|++
name|cp
expr_stmt|;
name|slen
operator|--
expr_stmt|;
block|}
else|else
block|{
name|GETNUM
argument_list|(
name|cp
argument_list|,
name|octave
argument_list|)
expr_stmt|;
if|if
condition|(
name|octave
operator|>=
sizeof|sizeof
argument_list|(
name|pitchtab
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|pitchtab
index|[
literal|0
index|]
argument_list|)
operator|/
name|OCTAVE_NOTES
condition|)
name|octave
operator|=
name|DFLT_OCTAVE
expr_stmt|;
name|octprefix
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
case|case
literal|'>'
case|:
if|if
condition|(
name|octave
operator|<
sizeof|sizeof
argument_list|(
name|pitchtab
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|pitchtab
index|[
literal|0
index|]
argument_list|)
operator|/
name|OCTAVE_NOTES
operator|-
literal|1
condition|)
name|octave
operator|++
expr_stmt|;
name|octprefix
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
if|if
condition|(
name|octave
operator|>
literal|0
condition|)
name|octave
operator|--
expr_stmt|;
name|octprefix
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|GETNUM
argument_list|(
name|cp
argument_list|,
name|pitch
argument_list|)
expr_stmt|;
for|for
control|(
name|sustain
operator|=
literal|0
init|;
name|cp
index|[
literal|1
index|]
operator|==
literal|'.'
condition|;
name|cp
operator|++
control|)
block|{
name|slen
operator|--
expr_stmt|;
name|sustain
operator|++
expr_stmt|;
block|}
name|oldfill
operator|=
name|fill
expr_stmt|;
if|if
condition|(
name|cp
index|[
literal|1
index|]
operator|==
literal|'_'
condition|)
block|{
name|fill
operator|=
name|LEGATO
expr_stmt|;
operator|++
name|cp
expr_stmt|;
name|slen
operator|--
expr_stmt|;
block|}
name|playtone
argument_list|(
name|pitch
operator|-
literal|1
argument_list|,
name|value
argument_list|,
name|sustain
argument_list|)
expr_stmt|;
name|fill
operator|=
name|oldfill
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|GETNUM
argument_list|(
name|cp
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|<=
literal|0
operator|||
name|value
operator|>
name|MIN_VALUE
condition|)
name|value
operator|=
name|DFLT_VALUE
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
case|case
literal|'~'
case|:
comment|/* this may be followed by an override time value */
name|GETNUM
argument_list|(
name|cp
argument_list|,
name|timeval
argument_list|)
expr_stmt|;
if|if
condition|(
name|timeval
operator|<=
literal|0
operator|||
name|timeval
operator|>
name|MIN_VALUE
condition|)
name|timeval
operator|=
name|value
expr_stmt|;
for|for
control|(
name|sustain
operator|=
literal|0
init|;
name|cp
index|[
literal|1
index|]
operator|==
literal|'.'
condition|;
name|cp
operator|++
control|)
block|{
name|slen
operator|--
expr_stmt|;
name|sustain
operator|++
expr_stmt|;
block|}
name|playtone
argument_list|(
operator|-
literal|1
argument_list|,
name|timeval
argument_list|,
name|sustain
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|GETNUM
argument_list|(
name|cp
argument_list|,
name|tempo
argument_list|)
expr_stmt|;
if|if
condition|(
name|tempo
operator|<
name|MIN_TEMPO
operator|||
name|tempo
operator|>
name|MAX_TEMPO
condition|)
name|tempo
operator|=
name|DFLT_TEMPO
expr_stmt|;
name|whole
operator|=
operator|(
name|hz
operator|*
name|SECS_PER_MIN
operator|*
name|WHOLE_NOTE
operator|)
operator|/
name|tempo
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
if|if
condition|(
name|cp
index|[
literal|1
index|]
operator|==
literal|'N'
operator|||
name|cp
index|[
literal|1
index|]
operator|==
literal|'n'
condition|)
block|{
name|fill
operator|=
name|NORMAL
expr_stmt|;
operator|++
name|cp
expr_stmt|;
name|slen
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cp
index|[
literal|1
index|]
operator|==
literal|'L'
operator|||
name|cp
index|[
literal|1
index|]
operator|==
literal|'l'
condition|)
block|{
name|fill
operator|=
name|LEGATO
expr_stmt|;
operator|++
name|cp
expr_stmt|;
name|slen
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cp
index|[
literal|1
index|]
operator|==
literal|'S'
operator|||
name|cp
index|[
literal|1
index|]
operator|==
literal|'s'
condition|)
block|{
name|fill
operator|=
name|STACCATO
expr_stmt|;
operator|++
name|cp
expr_stmt|;
name|slen
operator|--
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
comment|/******************* UNIX DRIVER HOOKS BEGIN HERE **************************  *  * This section implements driver hooks to run playstring() and the tone(),  * endtone(), and rest() functions defined above.  */
specifier|static
name|int
name|spkr_active
init|=
name|FALSE
decl_stmt|;
comment|/* exclusion flag */
specifier|static
name|struct
name|buf
modifier|*
name|spkr_inbuf
decl_stmt|;
comment|/* incoming buf */
name|int
name|spkropen
parameter_list|(
name|dev
parameter_list|,
name|flags
parameter_list|,
name|fmt
parameter_list|,
name|p
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|fmt
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DEBUG
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"spkropen: entering with dev = %x\n"
argument_list|,
name|dev
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
if|if
condition|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
elseif|else
if|if
condition|(
name|spkr_active
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
else|else
block|{
ifdef|#
directive|ifdef
name|DEBUG
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"spkropen: about to perform play initialization\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|playinit
argument_list|()
expr_stmt|;
name|spkr_inbuf
operator|=
name|geteblk
argument_list|(
name|DEV_BSIZE
argument_list|)
expr_stmt|;
name|spkr_active
operator|=
name|TRUE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|int
name|spkrwrite
parameter_list|(
name|dev
parameter_list|,
name|uio
parameter_list|,
name|ioflag
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
name|int
name|ioflag
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"spkrwrite: entering with dev = %x, count = %d\n"
argument_list|,
name|dev
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
if|if
condition|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
elseif|else
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|>
operator|(
name|DEV_BSIZE
operator|-
literal|1
operator|)
condition|)
comment|/* prevent system crashes */
return|return
operator|(
name|E2BIG
operator|)
return|;
else|else
block|{
name|unsigned
name|n
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|n
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
name|cp
operator|=
name|spkr_inbuf
operator|->
name|b_data
expr_stmt|;
name|error
operator|=
name|uiomove
argument_list|(
name|cp
argument_list|,
name|n
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|cp
index|[
name|n
index|]
operator|=
literal|'\0'
expr_stmt|;
name|playstring
argument_list|(
name|cp
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
name|int
name|spkrclose
parameter_list|(
name|dev
parameter_list|,
name|flags
parameter_list|,
name|fmt
parameter_list|,
name|p
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|fmt
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DEBUG
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"spkrclose: entering with dev = %x\n"
argument_list|,
name|dev
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
if|if
condition|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
else|else
block|{
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|endtone
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|endrest
argument_list|)
expr_stmt|;
name|brelse
argument_list|(
name|spkr_inbuf
argument_list|)
expr_stmt|;
name|spkr_active
operator|=
name|FALSE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|int
name|spkrioctl
parameter_list|(
name|dev
parameter_list|,
name|cmd
parameter_list|,
name|cmdarg
parameter_list|,
name|flags
parameter_list|,
name|p
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|cmd
decl_stmt|;
name|caddr_t
name|cmdarg
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DEBUG
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"spkrioctl: entering with dev = %x, cmd = %x\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
if|if
condition|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
elseif|else
if|if
condition|(
name|cmd
operator|==
name|SPKRTONE
condition|)
block|{
name|tone_t
modifier|*
name|tp
init|=
operator|(
name|tone_t
operator|*
operator|)
name|cmdarg
decl_stmt|;
if|if
condition|(
name|tp
operator|->
name|frequency
operator|==
literal|0
condition|)
name|rest
argument_list|(
name|tp
operator|->
name|duration
argument_list|)
expr_stmt|;
else|else
name|tone
argument_list|(
name|tp
operator|->
name|frequency
argument_list|,
name|tp
operator|->
name|duration
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|cmd
operator|==
name|SPKRTUNE
condition|)
block|{
name|tone_t
modifier|*
name|tp
init|=
operator|(
name|tone_t
operator|*
operator|)
operator|(
operator|*
operator|(
name|caddr_t
operator|*
operator|)
name|cmdarg
operator|)
decl_stmt|;
name|tone_t
name|ttp
decl_stmt|;
name|int
name|error
decl_stmt|;
for|for
control|(
init|;
condition|;
name|tp
operator|++
control|)
block|{
name|error
operator|=
name|copyin
argument_list|(
name|tp
argument_list|,
operator|&
name|ttp
argument_list|,
sizeof|sizeof
argument_list|(
name|tone_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|ttp
operator|.
name|duration
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|ttp
operator|.
name|frequency
operator|==
literal|0
condition|)
name|rest
argument_list|(
name|ttp
operator|.
name|duration
argument_list|)
expr_stmt|;
else|else
name|tone
argument_list|(
name|ttp
operator|.
name|frequency
argument_list|,
name|ttp
operator|.
name|duration
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
specifier|static
name|spkr_devsw_installed
operator|=
literal|0
expr_stmt|;
specifier|static
name|void
name|spkr_drvinit
parameter_list|(
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|dev_t
name|dev
decl_stmt|;
if|if
condition|(
operator|!
name|spkr_devsw_installed
condition|)
block|{
name|dev
operator|=
name|makedev
argument_list|(
name|CDEV_MAJOR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cdevsw_add
argument_list|(
operator|&
name|dev
argument_list|,
operator|&
name|spkr_cdevsw
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|spkr_devsw_installed
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVFS
name|devfs_token
operator|=
name|devfs_add_devswf
argument_list|(
operator|&
name|spkr_cdevsw
argument_list|,
literal|0
argument_list|,
name|DV_CHR
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0600
argument_list|,
literal|"speaker"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
name|SYSINIT
argument_list|(
argument|spkrdev
argument_list|,
argument|SI_SUB_DRIVERS
argument_list|,
argument|SI_ORDER_MIDDLE+CDEV_MAJOR
argument_list|,
argument|spkr_drvinit
argument_list|,
argument|NULL
argument_list|)
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NSPEAKER> 0 */
end_comment

begin_comment
comment|/* spkr.c ends here */
end_comment

end_unit

