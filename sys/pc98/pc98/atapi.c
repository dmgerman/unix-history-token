begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Device-independent level for ATAPI drivers.  *  * Copyright (C) 1995 Cronyx Ltd.  * Author Serge Vakulenko,<vak@cronyx.ru>  *  * This software is distributed with NO WARRANTIES, not even the implied  * warranties for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  *  * Authors grant any other persons or organisations permission to use  * or modify this software as long as this message is kept with the software,  * all derivative works or modified versions.  *  * Version 1.9, Mon Oct  9 22:34:47 MSK 1995  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * The ATAPI level is implemented as a machine-dependent layer  * between the device driver and the IDE controller.  * All the machine- and controller dependency is isolated inside  * the ATAPI level, while all the device dependency is located  * in the device subdriver.  *  * It seems that an ATAPI bus will became popular for medium-speed  * storage devices such as CD-ROMs, magneto-optical disks, tape streamers etc.  *  * To ease the development of new ATAPI drivers, the subdriver  * interface was designed to be as simple as possible.  *  * Three routines are available for the subdriver to access the device:  *  *      struct atapires atapi_request_wait (ata, unit, cmd, a1, a2, a3, a4, a5,  *              a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, addr, count);  *      struct atapi *ata;  -- atapi controller descriptor  *      int unit;           -- device unit number on the IDE bus  *      u_char cmd;         -- ATAPI command code  *      u_char a1..a15;     -- ATAPI command arguments  *      char *addr;         -- address of the data buffer for i/o  *      int count;          -- data length,>0 for read ops,<0 for write ops  *  * The atapi_request_wait() function puts the op in the queue of ATAPI  * commands for the IDE controller, starts the controller, the waits for  * operation to be completed (using tsleep).  * The function should be called from the user phase only (open(), close(),  * ioctl() etc).  * Ata and unit args are the values which the subdriver gets from the ATAPI  * level via attach() call.  * Buffer pointed to by *addr should be placed in core memory, static  * or dynamic, but not in stack.  * The function returns the error code structure, which consists of:  * - atapi driver code value  * - controller status port value  * - controller error port value  *  *      struct atapires atapi_request_immediate (ata, unit, cmd, a1, a2, a3,  *              a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15,  *              addr, count);  *  * The atapi_request_immediate() function is similar to atapi_request_wait(),  * but it does not use interrupts for performing the request.  * It should be used during an attach phase to get parameters from the device.  *  *      void atapi_request_callback (ata, unit, cmd, a1, a2, a3, a4, a5,  *              a6, a7, a8, a9, a10, a11, a12, a13, a14, a15,  *              addr, count, done, x, y);  *      struct atapi *ata;  -- atapi controller descriptor  *      int unit;           -- device unit number on the IDE bus  *      u_char cmd;         -- ATAPI command code  *      u_char a1..a15;     -- ATAPI command arguments  *      char *addr;         -- address of the data buffer for i/o  *      int count;          -- data length,>0 for read ops,<0 for write ops  *      void (*done)();     -- function to call when op finished  *      void *x, *y;        -- arguments for done() function  *  * The atapi_request_callback() function puts the op in the queue of ATAPI  * commands for the IDE controller, starts the controller, then returns.  * When the operation finishes, then the callback function done()  * will be called on the interrupt level.  * The function is designed to be callable from the interrupt phase.  * The done() functions is called with the following arguments:  *      (void) (*done) (x, y, count, errcode)  *      void *x, *y;             -- arguments from the atapi_request_callback()  *      int count;               -- the data residual count  *      struct atapires errcode; -- error code structure, see above  *  * The new driver could be added in three steps:  * 1. Add entries for the new driver to bdevsw and cdevsw tables in conf.c.  *    You will need to make at least three routines: open(), close(),  *    strategy() and possibly ioctl().  * 2. Make attach() routine, which should allocate all the needed data  *    structures and print the device description string (see xxxattach()).  * 3. Add an appropriate case to the switch in atapi_attach() routine,  *    call attach() routine of the new driver here.  Add the appropriate  *    #include line at the top of attach.c.  * That's all!  *  * Use #define DEBUG in atapi.c to enable tracing of all i/o operations  * on the IDE bus.  */
end_comment

begin_undef
undef|#
directive|undef
name|DEBUG
end_undef

begin_include
include|#
directive|include
file|"opt_wcd.h"
end_include

begin_include
include|#
directive|include
file|"opt_wdc.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<pc98/pc98/atapi.h>
end_include

begin_comment
comment|/* this code is compiled part of the module */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
define|#
directive|define
name|print
parameter_list|(
name|s
parameter_list|)
value|printf s
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|print
parameter_list|(
name|s
parameter_list|)
value|{
comment|/*void*/
value|}
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * ATAPI packet command phase.  */
end_comment

begin_define
define|#
directive|define
name|PHASE_CMDOUT
value|(ARS_DRQ | ARI_CMD)
end_define

begin_define
define|#
directive|define
name|PHASE_DATAIN
value|(ARS_DRQ | ARI_IN)
end_define

begin_define
define|#
directive|define
name|PHASE_DATAOUT
value|ARS_DRQ
end_define

begin_define
define|#
directive|define
name|PHASE_COMPLETED
value|(ARI_IN | ARI_CMD)
end_define

begin_define
define|#
directive|define
name|PHASE_ABORTED
value|0
end_define

begin_comment
comment|/* nonstandard - for NEC 260 */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|atapi
name|atapitab
index|[
name|NWDC
index|]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|struct
name|atapi_params
modifier|*
name|atapi_probe
parameter_list|(
name|int
name|port
parameter_list|,
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|atapi_wait
parameter_list|(
name|int
name|port
parameter_list|,
name|u_char
name|bits_wanted
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|atapi_send_cmd
parameter_list|(
name|struct
name|atapi
modifier|*
name|ata
parameter_list|,
name|struct
name|atapicmd
modifier|*
name|ac
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|atapi_io
parameter_list|(
name|struct
name|atapi
modifier|*
name|ata
parameter_list|,
name|struct
name|atapicmd
modifier|*
name|ac
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|atapi_start_cmd
parameter_list|(
name|struct
name|atapi
modifier|*
name|ata
parameter_list|,
name|struct
name|atapicmd
modifier|*
name|ac
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|atapi_wait_cmd
parameter_list|(
name|struct
name|atapi
modifier|*
name|ata
parameter_list|,
name|struct
name|atapicmd
modifier|*
name|ac
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|wdstart
parameter_list|(
name|int
name|ctrlr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|acdattach
parameter_list|(
name|struct
name|atapi
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|atapi_params
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|wfdattach
parameter_list|(
name|struct
name|atapi
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|atapi_params
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|wstattach
parameter_list|(
name|struct
name|atapi
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|atapi_params
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Probe the ATAPI device at IDE controller `ctlr', drive `unit'.  * Called at splbio().  */
end_comment

begin_function
name|int
name|atapi_attach
parameter_list|(
name|int
name|ctlr
parameter_list|,
name|int
name|unit
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|struct
name|atapi
modifier|*
name|ata
init|=
name|atapitab
operator|+
name|ctlr
decl_stmt|;
name|struct
name|atapi_params
modifier|*
name|ap
decl_stmt|;
name|char
name|buf
index|[
sizeof|sizeof
argument_list|(
name|ap
operator|->
name|model
argument_list|)
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|revbuf
index|[
sizeof|sizeof
argument_list|(
name|ap
operator|->
name|revision
argument_list|)
operator|+
literal|1
index|]
decl_stmt|;
name|struct
name|atapicmd
modifier|*
name|ac
decl_stmt|;
name|print
argument_list|(
operator|(
literal|"atapi%d.%d at 0x%x: attach called\n"
operator|,
name|ctlr
operator|,
name|unit
operator|,
name|port
operator|)
argument_list|)
expr_stmt|;
name|ap
operator|=
name|atapi_probe
argument_list|(
name|port
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ap
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|bcopy
argument_list|(
name|ap
operator|->
name|model
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|buf
index|[
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|bcopy
argument_list|(
name|ap
operator|->
name|revision
argument_list|,
name|revbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|revbuf
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|revbuf
index|[
sizeof|sizeof
argument_list|(
name|revbuf
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"wdc%d: unit %d (atapi):<%s/%s>"
argument_list|,
name|ctlr
argument_list|,
name|unit
argument_list|,
name|buf
argument_list|,
name|revbuf
argument_list|)
expr_stmt|;
comment|/* device is removable */
if|if
condition|(
name|ap
operator|->
name|removable
condition|)
name|printf
argument_list|(
literal|", removable"
argument_list|)
expr_stmt|;
comment|/* packet command size */
switch|switch
condition|(
name|ap
operator|->
name|cmdsz
condition|)
block|{
case|case
name|AT_PSIZE_12
case|:
break|break;
case|case
name|AT_PSIZE_16
case|:
name|printf
argument_list|(
literal|", cmd16"
argument_list|)
expr_stmt|;
name|ata
operator|->
name|cmd16
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|", cmd%d"
argument_list|,
name|ap
operator|->
name|cmdsz
argument_list|)
expr_stmt|;
block|}
comment|/* DRQ type */
switch|switch
condition|(
name|ap
operator|->
name|drqtype
condition|)
block|{
case|case
name|AT_DRQT_MPROC
case|:
name|ata
operator|->
name|slow
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|AT_DRQT_INTR
case|:
name|printf
argument_list|(
literal|", intr"
argument_list|)
expr_stmt|;
name|ata
operator|->
name|intrcmd
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|AT_DRQT_ACCEL
case|:
name|printf
argument_list|(
literal|", accel"
argument_list|)
expr_stmt|;
name|ata
operator|->
name|accel
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|", drq%d"
argument_list|,
name|ap
operator|->
name|drqtype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ata
operator|->
name|slow
condition|)
name|ata
operator|->
name|intrcmd
operator|=
literal|0
expr_stmt|;
comment|/*  	 * If we have two devices, one supporting INTR and one ACCEL, we 	 * have to pessimise - clear INTR and set slow. 	 */
if|if
condition|(
name|ata
operator|->
name|accel
operator|&&
name|ata
operator|->
name|intrcmd
condition|)
block|{
name|ata
operator|->
name|intrcmd
operator|=
literal|0
expr_stmt|;
name|ata
operator|->
name|slow
operator|=
literal|1
expr_stmt|;
block|}
comment|/* overlap operation supported */
if|if
condition|(
name|ap
operator|->
name|ovlapflag
condition|)
name|printf
argument_list|(
literal|", ovlap"
argument_list|)
expr_stmt|;
comment|/* interleaved DMA supported */
if|if
condition|(
name|ap
operator|->
name|idmaflag
condition|)
name|printf
argument_list|(
literal|", idma"
argument_list|)
expr_stmt|;
comment|/* DMA supported */
elseif|else
if|if
condition|(
name|ap
operator|->
name|dmaflag
condition|)
name|printf
argument_list|(
literal|", dma"
argument_list|)
expr_stmt|;
comment|/* IORDY can be disabled */
if|if
condition|(
name|ap
operator|->
name|iordydis
condition|)
name|printf
argument_list|(
literal|", iordis"
argument_list|)
expr_stmt|;
comment|/* IORDY supported */
elseif|else
if|if
condition|(
name|ap
operator|->
name|iordyflag
condition|)
name|printf
argument_list|(
literal|", iordy"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|ata
operator|->
name|port
operator|=
name|port
expr_stmt|;
name|ata
operator|->
name|ctrlr
operator|=
name|ctlr
expr_stmt|;
name|ata
operator|->
name|attached
index|[
name|unit
index|]
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|ata
operator|->
name|debug
operator|=
literal|1
expr_stmt|;
else|#
directive|else
name|ata
operator|->
name|debug
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* Initialize free queue. */
name|ata
operator|->
name|cmdrq
index|[
literal|15
index|]
operator|.
name|next
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ac
operator|=
name|ata
operator|->
name|cmdrq
operator|+
literal|14
init|;
name|ac
operator|>=
name|ata
operator|->
name|cmdrq
condition|;
operator|--
name|ac
control|)
name|ac
operator|->
name|next
operator|=
name|ac
operator|+
literal|1
expr_stmt|;
name|ata
operator|->
name|free
operator|=
name|ata
operator|->
name|cmdrq
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|proto
operator|!=
name|AT_PROTO_ATAPI
condition|)
block|{
name|printf
argument_list|(
literal|"wdc%d: unit %d: unknown ATAPI protocol=%d\n"
argument_list|,
name|ctlr
argument_list|,
name|unit
argument_list|,
name|ap
operator|->
name|proto
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ap
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
switch|switch
condition|(
name|ap
operator|->
name|devtype
condition|)
block|{
default|default:
comment|/* unknown ATAPI device */
name|printf
argument_list|(
literal|"wdc%d: unit %d: unknown ATAPI type=%d\n"
argument_list|,
name|ctlr
argument_list|,
name|unit
argument_list|,
name|ap
operator|->
name|devtype
argument_list|)
expr_stmt|;
break|break;
case|case
name|AT_TYPE_DIRECT
case|:
comment|/* direct-access */
ifdef|#
directive|ifdef
name|DEV_WCD
comment|/* FALLTHROUGH */
else|#
directive|else
name|printf
argument_list|(
literal|"wdc%d: ATAPI Floppies not configured\n"
argument_list|,
name|ctlr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|AT_TYPE_CDROM
case|:
comment|/* CD-ROM device */
ifdef|#
directive|ifdef
name|DEV_WCD
comment|/* ATAPI CD-ROM& CD-R/RW drives */
if|if
condition|(
name|acdattach
argument_list|(
name|ata
argument_list|,
name|unit
argument_list|,
name|ap
argument_list|,
name|ata
operator|->
name|debug
argument_list|)
operator|<
literal|0
condition|)
break|break;
name|ata
operator|->
name|attached
index|[
name|unit
index|]
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
else|#
directive|else
name|printf
argument_list|(
literal|"wdc%d: ATAPI CD-ROMs not configured\n"
argument_list|,
name|ctlr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|AT_TYPE_TAPE
case|:
comment|/* streaming tape */
name|printf
argument_list|(
literal|"wdc%d: ATAPI streaming tapes not configured\n"
argument_list|,
name|ctlr
argument_list|)
expr_stmt|;
break|break;
case|case
name|AT_TYPE_OPTICAL
case|:
comment|/* optical disk */
if|#
directive|if
name|NWMD
operator|>
literal|0
comment|/* Add your driver here */
else|#
directive|else
name|printf
argument_list|(
literal|"wdc%d: ATAPI optical disks not supported yet\n"
argument_list|,
name|ctlr
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
comment|/* Attach failed. */
name|free
argument_list|(
name|ap
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|cmdname
parameter_list|(
name|u_char
name|cmd
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
literal|8
index|]
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
literal|0x00
case|:
return|return
operator|(
literal|"TEST_UNIT_READY"
operator|)
return|;
case|case
literal|0x01
case|:
return|return
operator|(
literal|"REZERO_UNIT"
operator|)
return|;
case|case
literal|0x03
case|:
return|return
operator|(
literal|"REQUEST_SENSE"
operator|)
return|;
case|case
literal|0x04
case|:
return|return
operator|(
literal|"FORMAT_UNIT"
operator|)
return|;
case|case
literal|0x1b
case|:
return|return
operator|(
literal|"START_STOP"
operator|)
return|;
case|case
literal|0x1e
case|:
return|return
operator|(
literal|"PREVENT_ALLOW"
operator|)
return|;
case|case
literal|0x25
case|:
return|return
operator|(
literal|"READ_CAPACITY"
operator|)
return|;
case|case
literal|0x28
case|:
return|return
operator|(
literal|"READ_BIG"
operator|)
return|;
case|case
literal|0x2a
case|:
return|return
operator|(
literal|"WRITE_BIG"
operator|)
return|;
case|case
literal|0x35
case|:
return|return
operator|(
literal|"SYNCHRONIZE_CACHE"
operator|)
return|;
case|case
literal|0x42
case|:
return|return
operator|(
literal|"READ_SUBCHANNEL"
operator|)
return|;
case|case
literal|0x43
case|:
return|return
operator|(
literal|"READ_TOC"
operator|)
return|;
case|case
literal|0x51
case|:
return|return
operator|(
literal|"READ_DISC_INFO"
operator|)
return|;
case|case
literal|0x52
case|:
return|return
operator|(
literal|"READ_TRACK_INFO"
operator|)
return|;
case|case
literal|0x53
case|:
return|return
operator|(
literal|"RESERVE_TRACK"
operator|)
return|;
case|case
literal|0x54
case|:
return|return
operator|(
literal|"SEND_OPC_INFO"
operator|)
return|;
case|case
literal|0x55
case|:
return|return
operator|(
literal|"MODE_SELECT"
operator|)
return|;
case|case
literal|0x58
case|:
return|return
operator|(
literal|"REPAIR_TRACK"
operator|)
return|;
case|case
literal|0x59
case|:
return|return
operator|(
literal|"READ_MASTER_CUE"
operator|)
return|;
case|case
literal|0x5a
case|:
return|return
operator|(
literal|"MODE_SENSE"
operator|)
return|;
case|case
literal|0x5b
case|:
return|return
operator|(
literal|"CLOSE_TRACK/SESSION"
operator|)
return|;
case|case
literal|0x5c
case|:
return|return
operator|(
literal|"READ_BUFFER_CAPACITY"
operator|)
return|;
case|case
literal|0x5d
case|:
return|return
operator|(
literal|"SEND_CUE_SHEET"
operator|)
return|;
case|case
literal|0x47
case|:
return|return
operator|(
literal|"PLAY_MSF"
operator|)
return|;
case|case
literal|0x4b
case|:
return|return
operator|(
literal|"PAUSE"
operator|)
return|;
case|case
literal|0x48
case|:
return|return
operator|(
literal|"PLAY_TRACK"
operator|)
return|;
case|case
literal|0xa1
case|:
return|return
operator|(
literal|"BLANK_CMD"
operator|)
return|;
case|case
literal|0xa5
case|:
return|return
operator|(
literal|"PLAY_BIG"
operator|)
return|;
case|case
literal|0xb4
case|:
return|return
operator|(
literal|"PLAY_CD"
operator|)
return|;
case|case
literal|0xbd
case|:
return|return
operator|(
literal|"ATAPI_MECH_STATUS"
operator|)
return|;
case|case
literal|0xbe
case|:
return|return
operator|(
literal|"READ_CD"
operator|)
return|;
block|}
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"[0x%x]"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bswap
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|u_short
modifier|*
name|p
init|=
operator|(
name|u_short
operator|*
operator|)
operator|(
name|buf
operator|+
name|len
operator|)
decl_stmt|;
while|while
condition|(
operator|--
name|p
operator|>=
operator|(
name|u_short
operator|*
operator|)
name|buf
condition|)
operator|*
name|p
operator|=
name|ntohs
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|btrim
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Remove the trailing spaces. */
for|for
control|(
name|p
operator|=
name|buf
init|;
name|p
operator|<
name|buf
operator|+
name|len
condition|;
operator|++
name|p
control|)
if|if
condition|(
operator|!
operator|*
name|p
condition|)
operator|*
name|p
operator|=
literal|' '
expr_stmt|;
for|for
control|(
name|p
operator|=
name|buf
operator|+
name|len
operator|-
literal|1
init|;
name|p
operator|>=
name|buf
operator|&&
operator|*
name|p
operator|==
literal|' '
condition|;
operator|--
name|p
control|)
operator|*
name|p
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Issue IDENTIFY command to ATAPI drive to ask it what it is.  */
end_comment

begin_function
specifier|static
name|struct
name|atapi_params
modifier|*
name|atapi_probe
parameter_list|(
name|int
name|port
parameter_list|,
name|int
name|unit
parameter_list|)
block|{
name|struct
name|atapi_params
modifier|*
name|ap
decl_stmt|;
name|char
name|tb
index|[
name|DEV_BSIZE
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|int
name|cnt
decl_stmt|;
name|outb
argument_list|(
literal|0x432
argument_list|,
name|unit
operator|%
literal|2
argument_list|)
expr_stmt|;
name|print
argument_list|(
operator|(
literal|"unit = %d,select %d\n"
operator|,
name|unit
operator|,
name|unit
operator|%
literal|2
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Wait for controller not busy. */
ifdef|#
directive|ifdef
name|PC98
name|outb
argument_list|(
name|port
operator|+
name|AR_DRIVE
argument_list|,
name|unit
operator|/
literal|2
condition|?
name|ARD_DRIVE1
else|:
name|ARD_DRIVE0
argument_list|)
expr_stmt|;
else|#
directive|else
name|outb
argument_list|(
name|port
operator|+
name|AR_DRIVE
argument_list|,
name|unit
condition|?
name|ARD_DRIVE1
else|:
name|ARD_DRIVE0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|atapi_wait
argument_list|(
name|port
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|print
argument_list|(
operator|(
literal|"atapiX.%d at 0x%x: controller busy, status=%b\n"
operator|,
name|unit
operator|,
name|port
operator|,
name|inb
argument_list|(
name|port
operator|+
name|AR_STATUS
argument_list|)
operator|,
name|ARS_BITS
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Issue ATAPI IDENTIFY command. */
ifdef|#
directive|ifdef
name|PC98
name|outb
argument_list|(
name|port
operator|+
name|AR_DRIVE
argument_list|,
name|unit
operator|/
literal|2
condition|?
name|ARD_DRIVE1
else|:
name|ARD_DRIVE0
argument_list|)
expr_stmt|;
comment|/* Wait for DRQ deassert. */
for|for
control|(
name|cnt
operator|=
literal|2000
init|;
name|cnt
operator|>
literal|0
condition|;
operator|--
name|cnt
control|)
if|if
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|port
operator|+
name|AR_STATUS
argument_list|)
operator|&
name|ARS_DRQ
operator|)
condition|)
break|break;
name|outb
argument_list|(
name|port
operator|+
name|AR_COMMAND
argument_list|,
name|ATAPIC_IDENTIFY
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|500
argument_list|)
expr_stmt|;
else|#
directive|else
name|outb
argument_list|(
name|port
operator|+
name|AR_DRIVE
argument_list|,
name|unit
condition|?
name|ARD_DRIVE1
else|:
name|ARD_DRIVE0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|port
operator|+
name|AR_COMMAND
argument_list|,
name|ATAPIC_IDENTIFY
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Check that device is present. */
if|if
condition|(
name|inb
argument_list|(
name|port
operator|+
name|AR_STATUS
argument_list|)
operator|==
literal|0xff
condition|)
block|{
name|print
argument_list|(
operator|(
literal|"atapiX.%d at 0x%x: no device\n"
operator|,
name|unit
operator|,
name|port
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
if|if
condition|(
name|unit
operator|/
literal|2
condition|)
else|#
directive|else
if|if
condition|(
name|unit
operator|==
literal|1
condition|)
endif|#
directive|endif
comment|/* Select unit 0. */
name|outb
argument_list|(
name|port
operator|+
name|AR_DRIVE
argument_list|,
name|ARD_DRIVE0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Wait for data ready. */
if|if
condition|(
name|atapi_wait
argument_list|(
name|port
argument_list|,
name|ARS_DRQ
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|print
argument_list|(
operator|(
literal|"atapiX.%d at 0x%x: identify not ready, status=%b\n"
operator|,
name|unit
operator|,
name|port
operator|,
name|inb
argument_list|(
name|port
operator|+
name|AR_STATUS
argument_list|)
operator|,
name|ARS_BITS
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
if|if
condition|(
name|unit
operator|/
literal|2
condition|)
else|#
directive|else
if|if
condition|(
name|unit
operator|==
literal|1
condition|)
endif|#
directive|endif
comment|/* Select unit 0. */
name|outb
argument_list|(
name|port
operator|+
name|AR_DRIVE
argument_list|,
name|ARD_DRIVE0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* check that DRQ isn't a fake */
if|if
condition|(
name|inb
argument_list|(
name|port
operator|+
name|AR_STATUS
argument_list|)
operator|==
literal|0xff
condition|)
block|{
name|print
argument_list|(
operator|(
literal|"atapiX.%d at 0x%x: no device\n"
operator|,
name|unit
operator|,
name|port
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
if|if
condition|(
name|unit
operator|/
literal|2
condition|)
else|#
directive|else
if|if
condition|(
name|unit
operator|==
literal|1
condition|)
endif|#
directive|endif
comment|/* Select unit 0. */
name|outb
argument_list|(
name|port
operator|+
name|AR_DRIVE
argument_list|,
name|ARD_DRIVE0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Obtain parameters. */
name|insw
argument_list|(
name|port
operator|+
name|AR_DATA
argument_list|,
name|tb
argument_list|,
sizeof|sizeof
argument_list|(
name|tb
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|ap
operator|=
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|ap
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ap
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|bcopy
argument_list|(
name|tb
argument_list|,
name|ap
argument_list|,
sizeof|sizeof
expr|*
name|ap
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
comment|/* 	 * Check model string. 	 * If all of it makes unprintable characters, ignore this device. 	 */
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
sizeof|sizeof
argument_list|(
name|ap
operator|->
name|model
argument_list|)
operator|-
literal|1
condition|;
name|cnt
operator|++
control|)
block|{
if|if
condition|(
name|ap
operator|->
name|model
index|[
name|cnt
index|]
operator|>=
literal|' '
condition|)
break|break;
block|}
if|if
condition|(
name|cnt
operator|>=
sizeof|sizeof
argument_list|(
name|ap
operator|->
name|model
argument_list|)
operator|-
literal|1
condition|)
block|{
name|free
argument_list|(
name|ap
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* 	 * Shuffle string byte order. 	 * Mitsumi and NEC drives don't need this. 	 */
if|if
condition|(
operator|!
operator|(
operator|(
name|ap
operator|->
name|model
index|[
literal|0
index|]
operator|==
literal|'N'
operator|&&
name|ap
operator|->
name|model
index|[
literal|1
index|]
operator|==
literal|'E'
operator|)
operator|||
operator|(
name|ap
operator|->
name|model
index|[
literal|0
index|]
operator|==
literal|'F'
operator|&&
name|ap
operator|->
name|model
index|[
literal|1
index|]
operator|==
literal|'X'
operator|)
operator|)
condition|)
name|bswap
argument_list|(
name|ap
operator|->
name|model
argument_list|,
sizeof|sizeof
argument_list|(
name|ap
operator|->
name|model
argument_list|)
argument_list|)
expr_stmt|;
name|bswap
argument_list|(
name|ap
operator|->
name|serial
argument_list|,
sizeof|sizeof
argument_list|(
name|ap
operator|->
name|serial
argument_list|)
argument_list|)
expr_stmt|;
name|bswap
argument_list|(
name|ap
operator|->
name|revision
argument_list|,
sizeof|sizeof
argument_list|(
name|ap
operator|->
name|revision
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Clean up the model name, serial and revision numbers. */
name|btrim
argument_list|(
name|ap
operator|->
name|model
argument_list|,
sizeof|sizeof
argument_list|(
name|ap
operator|->
name|model
argument_list|)
argument_list|)
expr_stmt|;
name|btrim
argument_list|(
name|ap
operator|->
name|serial
argument_list|,
sizeof|sizeof
argument_list|(
name|ap
operator|->
name|serial
argument_list|)
argument_list|)
expr_stmt|;
name|btrim
argument_list|(
name|ap
operator|->
name|revision
argument_list|,
sizeof|sizeof
argument_list|(
name|ap
operator|->
name|revision
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ap
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Wait uninterruptibly until controller is not busy and certain  * status bits are set.  * The wait is usually short unless it is for the controller to process  * an entire critical command.  * Return 1 for (possibly stale) controller errors, -1 for timeout errors,  * or 0 for no errors.  */
end_comment

begin_function
specifier|static
name|int
name|atapi_wait
parameter_list|(
name|int
name|port
parameter_list|,
name|u_char
name|bits_wanted
parameter_list|)
block|{
name|int
name|cnt
decl_stmt|;
name|u_char
name|s
decl_stmt|;
comment|/* Wait 5 sec for BUSY deassert. */
for|for
control|(
name|cnt
operator|=
literal|500000
init|;
name|cnt
operator|>
literal|0
condition|;
operator|--
name|cnt
control|)
block|{
name|s
operator|=
name|inb
argument_list|(
name|port
operator|+
name|AR_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|s
operator|&
name|ARS_BSY
operator|)
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cnt
operator|<=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|!
name|bits_wanted
condition|)
return|return
operator|(
name|s
operator|&
name|ARS_CHECK
operator|)
return|;
comment|/* Wait 50 msec for bits wanted. */
for|for
control|(
name|cnt
operator|=
literal|5000
init|;
name|cnt
operator|>
literal|0
condition|;
operator|--
name|cnt
control|)
block|{
name|s
operator|=
name|inb
argument_list|(
name|port
operator|+
name|AR_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|&
name|bits_wanted
operator|)
operator|==
name|bits_wanted
condition|)
return|return
operator|(
name|s
operator|&
name|ARS_CHECK
operator|)
return|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|void
name|atapi_debug
parameter_list|(
name|struct
name|atapi
modifier|*
name|ata
parameter_list|,
name|int
name|on
parameter_list|)
block|{
name|ata
operator|->
name|debug
operator|=
name|on
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|atapicmd
modifier|*
name|atapi_alloc
parameter_list|(
name|struct
name|atapi
modifier|*
name|ata
parameter_list|)
block|{
name|struct
name|atapicmd
modifier|*
name|ac
decl_stmt|;
while|while
condition|(
operator|!
name|ata
operator|->
name|free
condition|)
name|tsleep
argument_list|(
name|ata
argument_list|,
name|PRIBIO
argument_list|,
literal|"atacmd"
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|ac
operator|=
name|ata
operator|->
name|free
expr_stmt|;
name|ata
operator|->
name|free
operator|=
name|ac
operator|->
name|next
expr_stmt|;
name|ac
operator|->
name|busy
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|ac
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|atapi_free
parameter_list|(
name|struct
name|atapi
modifier|*
name|ata
parameter_list|,
name|struct
name|atapicmd
modifier|*
name|ac
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ata
operator|->
name|free
condition|)
name|wakeup
argument_list|(
name|ata
argument_list|)
expr_stmt|;
name|ac
operator|->
name|busy
operator|=
literal|0
expr_stmt|;
name|ac
operator|->
name|next
operator|=
name|ata
operator|->
name|free
expr_stmt|;
name|ata
operator|->
name|free
operator|=
name|ac
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add new command request to the end of the queue.  */
end_comment

begin_function
specifier|static
name|void
name|atapi_enqueue
parameter_list|(
name|struct
name|atapi
modifier|*
name|ata
parameter_list|,
name|struct
name|atapicmd
modifier|*
name|ac
parameter_list|)
block|{
name|ac
operator|->
name|next
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ata
operator|->
name|tail
condition|)
name|ata
operator|->
name|tail
operator|->
name|next
operator|=
name|ac
expr_stmt|;
else|else
name|ata
operator|->
name|queue
operator|=
name|ac
expr_stmt|;
name|ata
operator|->
name|tail
operator|=
name|ac
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|atapi_done
parameter_list|(
name|struct
name|atapi
modifier|*
name|ata
parameter_list|)
block|{
name|struct
name|atapicmd
modifier|*
name|ac
init|=
name|ata
operator|->
name|queue
decl_stmt|;
if|if
condition|(
operator|!
name|ac
condition|)
return|return;
comment|/* cannot happen */
name|ata
operator|->
name|queue
operator|=
name|ac
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|ata
operator|->
name|queue
condition|)
name|ata
operator|->
name|tail
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ac
operator|->
name|callback
condition|)
block|{
call|(
modifier|*
name|ac
operator|->
name|callback
call|)
argument_list|(
name|ac
operator|->
name|cbarg1
argument_list|,
name|ac
operator|->
name|cbarg2
argument_list|,
name|ac
operator|->
name|count
argument_list|,
name|ac
operator|->
name|result
argument_list|)
expr_stmt|;
name|atapi_free
argument_list|(
name|ata
argument_list|,
name|ac
argument_list|)
expr_stmt|;
block|}
else|else
name|wakeup
argument_list|(
name|ac
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Start new packet op.  Called from wdstart().  * Return 1 if op started, and we are waiting for interrupt.  * Return 0 when idle.  */
end_comment

begin_function
name|int
name|atapi_start
parameter_list|(
name|int
name|ctrlr
parameter_list|)
block|{
name|struct
name|atapi
modifier|*
name|ata
init|=
name|atapitab
operator|+
name|ctrlr
decl_stmt|;
name|struct
name|atapicmd
modifier|*
name|ac
decl_stmt|;
name|again
label|:
name|ac
operator|=
name|ata
operator|->
name|queue
expr_stmt|;
if|if
condition|(
operator|!
name|ac
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Start packet command. */
if|if
condition|(
name|atapi_start_cmd
argument_list|(
name|ata
argument_list|,
name|ac
argument_list|)
operator|<
literal|0
condition|)
block|{
name|atapi_done
argument_list|(
name|ata
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
if|if
condition|(
name|ata
operator|->
name|intrcmd
condition|)
comment|/* Wait for interrupt before sending packet command */
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Wait for DRQ. */
if|if
condition|(
name|atapi_wait_cmd
argument_list|(
name|ata
argument_list|,
name|ac
argument_list|)
operator|<
literal|0
condition|)
block|{
name|atapi_done
argument_list|(
name|ata
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
comment|/* Send packet command. */
name|atapi_send_cmd
argument_list|(
name|ata
argument_list|,
name|ac
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Start new packet op. Returns -1 on errors.  */
end_comment

begin_function
name|int
name|atapi_start_cmd
parameter_list|(
name|struct
name|atapi
modifier|*
name|ata
parameter_list|,
name|struct
name|atapicmd
modifier|*
name|ac
parameter_list|)
block|{
name|ac
operator|->
name|result
operator|.
name|error
operator|=
literal|0
expr_stmt|;
name|ac
operator|->
name|result
operator|.
name|status
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|outb
argument_list|(
literal|0x432
argument_list|,
operator|(
name|ac
operator|->
name|unit
operator|)
operator|%
literal|2
argument_list|)
expr_stmt|;
name|print
argument_list|(
operator|(
literal|"(ac->unit) = %d,select %d (2) \n"
operator|,
operator|(
name|ac
operator|->
name|unit
operator|)
operator|,
operator|(
name|ac
operator|->
name|unit
operator|)
operator|%
literal|2
operator|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ata
operator|->
name|port
operator|+
name|AR_DRIVE
argument_list|,
operator|(
name|ac
operator|->
name|unit
operator|)
operator|/
literal|2
condition|?
name|ARD_DRIVE1
else|:
name|ARD_DRIVE0
argument_list|)
expr_stmt|;
else|#
directive|else
name|outb
argument_list|(
name|ata
operator|->
name|port
operator|+
name|AR_DRIVE
argument_list|,
name|ac
operator|->
name|unit
condition|?
name|ARD_DRIVE1
else|:
name|ARD_DRIVE0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|atapi_wait
argument_list|(
name|ata
operator|->
name|port
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"atapi%d.%d: controller not ready for cmd\n"
argument_list|,
name|ata
operator|->
name|ctrlr
argument_list|,
name|ac
operator|->
name|unit
argument_list|)
expr_stmt|;
name|ac
operator|->
name|result
operator|.
name|code
operator|=
name|RES_NOTRDY
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Set up the controller registers. */
name|outb
argument_list|(
name|ata
operator|->
name|port
operator|+
name|AR_FEATURES
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ata
operator|->
name|port
operator|+
name|AR_IREASON
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ata
operator|->
name|port
operator|+
name|AR_TAG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ata
operator|->
name|port
operator|+
name|AR_CNTLO
argument_list|,
name|ac
operator|->
name|count
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ata
operator|->
name|port
operator|+
name|AR_CNTHI
argument_list|,
name|ac
operator|->
name|count
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ata
operator|->
name|port
operator|+
name|AR_COMMAND
argument_list|,
name|ATAPIC_PACKET
argument_list|)
expr_stmt|;
if|if
condition|(
name|ata
operator|->
name|debug
condition|)
name|printf
argument_list|(
literal|"atapi%d.%d: start\n"
argument_list|,
name|ata
operator|->
name|ctrlr
argument_list|,
name|ac
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Wait for DRQ before sending packet cmd. Returns -1 on errors.  */
end_comment

begin_function
name|int
name|atapi_wait_cmd
parameter_list|(
name|struct
name|atapi
modifier|*
name|ata
parameter_list|,
name|struct
name|atapicmd
modifier|*
name|ac
parameter_list|)
block|{
comment|/* Wait for DRQ from 100 usec to 3 msec for slow devices */
name|int
name|cnt
init|=
name|ata
operator|->
name|intrcmd
condition|?
literal|10000
else|:
name|ata
operator|->
name|slow
condition|?
literal|3000
else|:
literal|100
decl_stmt|;
name|int
name|ireason
init|=
literal|0
decl_stmt|,
name|phase
init|=
literal|0
decl_stmt|;
comment|/* Wait for command phase. */
for|for
control|(
init|;
name|cnt
operator|>
literal|0
condition|;
name|cnt
operator|-=
literal|10
control|)
block|{
name|ireason
operator|=
name|inb
argument_list|(
name|ata
operator|->
name|port
operator|+
name|AR_IREASON
argument_list|)
expr_stmt|;
name|ac
operator|->
name|result
operator|.
name|status
operator|=
name|inb
argument_list|(
name|ata
operator|->
name|port
operator|+
name|AR_STATUS
argument_list|)
expr_stmt|;
name|phase
operator|=
operator|(
name|ireason
operator|&
operator|(
name|ARI_CMD
operator||
name|ARI_IN
operator|)
operator|)
operator||
operator|(
name|ac
operator|->
name|result
operator|.
name|status
operator|&
operator|(
name|ARS_DRQ
operator||
name|ARS_BSY
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|phase
operator|==
name|PHASE_CMDOUT
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|phase
operator|!=
name|PHASE_CMDOUT
condition|)
block|{
name|ac
operator|->
name|result
operator|.
name|code
operator|=
name|RES_NODRQ
expr_stmt|;
name|ac
operator|->
name|result
operator|.
name|error
operator|=
name|inb
argument_list|(
name|ata
operator|->
name|port
operator|+
name|AR_ERROR
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"atapi%d.%d: invalid command phase, ireason=0x%x, status=%b, error=%b\n"
argument_list|,
name|ata
operator|->
name|ctrlr
argument_list|,
name|ac
operator|->
name|unit
argument_list|,
name|ireason
argument_list|,
name|ac
operator|->
name|result
operator|.
name|status
argument_list|,
name|ARS_BITS
argument_list|,
name|ac
operator|->
name|result
operator|.
name|error
argument_list|,
name|AER_BITS
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Send packet cmd.  */
end_comment

begin_function
name|void
name|atapi_send_cmd
parameter_list|(
name|struct
name|atapi
modifier|*
name|ata
parameter_list|,
name|struct
name|atapicmd
modifier|*
name|ac
parameter_list|)
block|{
name|outsw
argument_list|(
name|ata
operator|->
name|port
operator|+
name|AR_DATA
argument_list|,
name|ac
operator|->
name|cmd
argument_list|,
name|ata
operator|->
name|cmd16
condition|?
literal|8
else|:
literal|6
argument_list|)
expr_stmt|;
if|if
condition|(
name|ata
operator|->
name|debug
condition|)
name|printf
argument_list|(
literal|"atapi%d.%d: send cmd %s %x-%x-%x-%x-%x-%x-%x-%x-%x-%x-%x-%x-%x-%x-%x-%x\n"
argument_list|,
name|ata
operator|->
name|ctrlr
argument_list|,
name|ac
operator|->
name|unit
argument_list|,
name|cmdname
argument_list|(
name|ac
operator|->
name|cmd
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|0
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|1
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|2
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|3
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|4
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|5
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|6
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|7
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|8
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|9
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|10
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|11
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|12
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|13
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|14
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|15
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Interrupt routine for the controller.  Called from wdintr().  * Finish the started op, wakeup wait-type commands,  * run callbacks for callback-type commands, then return.  * Do not start new op here, it will be done by wdstart,  * which is called just after us.  * Return 1 if op continues, and we are waiting for new interrupt.  * Return 0 when idle.  */
end_comment

begin_function
name|int
name|atapi_intr
parameter_list|(
name|int
name|ctrlr
parameter_list|)
block|{
name|struct
name|atapi
modifier|*
name|ata
init|=
name|atapitab
operator|+
name|ctrlr
decl_stmt|;
name|struct
name|atapicmd
modifier|*
name|ac
init|=
name|ata
operator|->
name|queue
decl_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|outb
argument_list|(
literal|0x432
argument_list|,
operator|(
name|ac
operator|->
name|unit
operator|)
operator|%
literal|2
argument_list|)
expr_stmt|;
name|print
argument_list|(
operator|(
literal|"atapi_intr:(ac->unit)= %d,select %d\n"
operator|,
name|ac
operator|->
name|unit
operator|,
operator|(
name|ac
operator|->
name|unit
operator|)
operator|%
literal|2
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|ac
condition|)
block|{
name|printf
argument_list|(
literal|"atapi%d: stray interrupt\n"
argument_list|,
name|ata
operator|->
name|ctrlr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|atapi_io
argument_list|(
name|ata
argument_list|,
name|ac
argument_list|)
operator|>
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|atapi_done
argument_list|(
name|ata
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process the i/o phase, transferring the command/data to/from the device.  * Return 1 if op continues, and we are waiting for new interrupt.  * Return 0 when idle.  */
end_comment

begin_function
name|int
name|atapi_io
parameter_list|(
name|struct
name|atapi
modifier|*
name|ata
parameter_list|,
name|struct
name|atapicmd
modifier|*
name|ac
parameter_list|)
block|{
name|u_char
name|ireason
decl_stmt|;
name|u_short
name|len
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|atapi_wait
argument_list|(
name|ata
operator|->
name|port
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ac
operator|->
name|result
operator|.
name|status
operator|=
name|inb
argument_list|(
name|ata
operator|->
name|port
operator|+
name|AR_STATUS
argument_list|)
expr_stmt|;
name|ac
operator|->
name|result
operator|.
name|error
operator|=
name|inb
argument_list|(
name|ata
operator|->
name|port
operator|+
name|AR_ERROR
argument_list|)
expr_stmt|;
name|ac
operator|->
name|result
operator|.
name|code
operator|=
name|RES_NOTRDY
expr_stmt|;
name|printf
argument_list|(
literal|"atapi%d.%d: controller not ready, status=%b, error=%b\n"
argument_list|,
name|ata
operator|->
name|ctrlr
argument_list|,
name|ac
operator|->
name|unit
argument_list|,
name|ac
operator|->
name|result
operator|.
name|status
argument_list|,
name|ARS_BITS
argument_list|,
name|ac
operator|->
name|result
operator|.
name|error
argument_list|,
name|AER_BITS
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ac
operator|->
name|result
operator|.
name|status
operator|=
name|inb
argument_list|(
name|ata
operator|->
name|port
operator|+
name|AR_STATUS
argument_list|)
expr_stmt|;
name|ac
operator|->
name|result
operator|.
name|error
operator|=
name|inb
argument_list|(
name|ata
operator|->
name|port
operator|+
name|AR_ERROR
argument_list|)
expr_stmt|;
name|len
operator|=
name|inb
argument_list|(
name|ata
operator|->
name|port
operator|+
name|AR_CNTLO
argument_list|)
expr_stmt|;
name|len
operator||=
name|inb
argument_list|(
name|ata
operator|->
name|port
operator|+
name|AR_CNTHI
argument_list|)
operator|<<
literal|8
expr_stmt|;
name|ireason
operator|=
name|inb
argument_list|(
name|ata
operator|->
name|port
operator|+
name|AR_IREASON
argument_list|)
expr_stmt|;
if|if
condition|(
name|ata
operator|->
name|debug
condition|)
block|{
name|printf
argument_list|(
literal|"atapi%d.%d: intr ireason=0x%x, len=%d, status=%b, error=%b\n"
argument_list|,
name|ata
operator|->
name|ctrlr
argument_list|,
name|ac
operator|->
name|unit
argument_list|,
name|ireason
argument_list|,
name|len
argument_list|,
name|ac
operator|->
name|result
operator|.
name|status
argument_list|,
name|ARS_BITS
argument_list|,
name|ac
operator|->
name|result
operator|.
name|error
argument_list|,
name|AER_BITS
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
operator|(
name|ireason
operator|&
operator|(
name|ARI_CMD
operator||
name|ARI_IN
operator|)
operator|)
operator||
operator|(
name|ac
operator|->
name|result
operator|.
name|status
operator|&
name|ARS_DRQ
operator|)
condition|)
block|{
default|default:
name|printf
argument_list|(
literal|"atapi%d.%d: unknown phase\n"
argument_list|,
name|ata
operator|->
name|ctrlr
argument_list|,
name|ac
operator|->
name|unit
argument_list|)
expr_stmt|;
name|ac
operator|->
name|result
operator|.
name|code
operator|=
name|RES_ERR
expr_stmt|;
break|break;
case|case
name|PHASE_CMDOUT
case|:
comment|/* Send packet command. */
if|if
condition|(
operator|!
operator|(
name|ac
operator|->
name|result
operator|.
name|status
operator|&
name|ARS_DRQ
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"atapi%d.%d: no cmd drq\n"
argument_list|,
name|ata
operator|->
name|ctrlr
argument_list|,
name|ac
operator|->
name|unit
argument_list|)
expr_stmt|;
name|ac
operator|->
name|result
operator|.
name|code
operator|=
name|RES_NODRQ
expr_stmt|;
break|break;
block|}
name|atapi_send_cmd
argument_list|(
name|ata
argument_list|,
name|ac
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|PHASE_DATAOUT
case|:
comment|/* Write data */
if|if
condition|(
name|ac
operator|->
name|count
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"atapi%d.%d: invalid data direction\n"
argument_list|,
name|ata
operator|->
name|ctrlr
argument_list|,
name|ac
operator|->
name|unit
argument_list|)
expr_stmt|;
name|ac
operator|->
name|result
operator|.
name|code
operator|=
name|RES_INVDIR
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|-
name|ac
operator|->
name|count
operator|<
name|len
condition|)
block|{
name|print
argument_list|(
operator|(
literal|"atapi%d.%d: send data underrun, %d bytes left\n"
operator|,
name|ata
operator|->
name|ctrlr
operator|,
name|ac
operator|->
name|unit
operator|,
operator|-
name|ac
operator|->
name|count
operator|)
argument_list|)
expr_stmt|;
name|ac
operator|->
name|result
operator|.
name|code
operator|=
name|RES_UNDERRUN
expr_stmt|;
name|outsw
argument_list|(
name|ata
operator|->
name|port
operator|+
name|AR_DATA
argument_list|,
name|ac
operator|->
name|addr
argument_list|,
operator|-
name|ac
operator|->
name|count
operator|/
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|-
name|ac
operator|->
name|count
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|+=
sizeof|sizeof
argument_list|(
name|short
argument_list|)
control|)
name|outw
argument_list|(
name|ata
operator|->
name|port
operator|+
name|AR_DATA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|outsw
argument_list|(
name|ata
operator|->
name|port
operator|+
name|AR_DATA
argument_list|,
name|ac
operator|->
name|addr
argument_list|,
name|len
operator|/
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|ac
operator|->
name|addr
operator|+=
name|len
expr_stmt|;
name|ac
operator|->
name|count
operator|+=
name|len
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|PHASE_DATAIN
case|:
comment|/* Read data */
if|if
condition|(
name|ac
operator|->
name|count
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"atapi%d.%d: invalid data direction\n"
argument_list|,
name|ata
operator|->
name|ctrlr
argument_list|,
name|ac
operator|->
name|unit
argument_list|)
expr_stmt|;
name|ac
operator|->
name|result
operator|.
name|code
operator|=
name|RES_INVDIR
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ac
operator|->
name|count
operator|<
name|len
condition|)
block|{
name|print
argument_list|(
operator|(
literal|"atapi%d.%d: recv data overrun, %d bytes left\n"
operator|,
name|ata
operator|->
name|ctrlr
operator|,
name|ac
operator|->
name|unit
operator|,
name|ac
operator|->
name|count
operator|)
argument_list|)
expr_stmt|;
name|ac
operator|->
name|result
operator|.
name|code
operator|=
name|RES_OVERRUN
expr_stmt|;
name|insw
argument_list|(
name|ata
operator|->
name|port
operator|+
name|AR_DATA
argument_list|,
name|ac
operator|->
name|addr
argument_list|,
name|ac
operator|->
name|count
operator|/
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|ac
operator|->
name|count
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|+=
sizeof|sizeof
argument_list|(
name|short
argument_list|)
control|)
name|inw
argument_list|(
name|ata
operator|->
name|port
operator|+
name|AR_DATA
argument_list|)
expr_stmt|;
block|}
else|else
name|insw
argument_list|(
name|ata
operator|->
name|port
operator|+
name|AR_DATA
argument_list|,
name|ac
operator|->
name|addr
argument_list|,
name|len
operator|/
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|ac
operator|->
name|addr
operator|+=
name|len
expr_stmt|;
name|ac
operator|->
name|count
operator|-=
name|len
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|PHASE_ABORTED
case|:
case|case
name|PHASE_COMPLETED
case|:
if|if
condition|(
name|ac
operator|->
name|result
operator|.
name|status
operator|&
operator|(
name|ARS_CHECK
operator||
name|ARS_DF
operator|)
condition|)
name|ac
operator|->
name|result
operator|.
name|code
operator|=
name|RES_ERR
expr_stmt|;
elseif|else
if|if
condition|(
name|ac
operator|->
name|count
operator|<
literal|0
condition|)
block|{
name|print
argument_list|(
operator|(
literal|"atapi%d.%d: send data overrun, %d bytes left\n"
operator|,
name|ata
operator|->
name|ctrlr
operator|,
name|ac
operator|->
name|unit
operator|,
operator|-
name|ac
operator|->
name|count
operator|)
argument_list|)
expr_stmt|;
name|ac
operator|->
name|result
operator|.
name|code
operator|=
name|RES_OVERRUN
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ac
operator|->
name|count
operator|>
literal|0
condition|)
block|{
name|print
argument_list|(
operator|(
literal|"atapi%d.%d: recv data underrun, %d bytes left\n"
operator|,
name|ata
operator|->
name|ctrlr
operator|,
name|ac
operator|->
name|unit
operator|,
name|ac
operator|->
name|count
operator|)
argument_list|)
expr_stmt|;
name|ac
operator|->
name|result
operator|.
name|code
operator|=
name|RES_UNDERRUN
expr_stmt|;
name|bzero
argument_list|(
name|ac
operator|->
name|addr
argument_list|,
name|ac
operator|->
name|count
argument_list|)
expr_stmt|;
block|}
else|else
name|ac
operator|->
name|result
operator|.
name|code
operator|=
name|RES_OK
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Queue new packet request, then call wdstart().  * Called on splbio().  */
end_comment

begin_function
name|void
name|atapi_request_callback
parameter_list|(
name|struct
name|atapi
modifier|*
name|ata
parameter_list|,
name|int
name|unit
parameter_list|,
name|u_char
name|cmd
parameter_list|,
name|u_char
name|a1
parameter_list|,
name|u_char
name|a2
parameter_list|,
name|u_char
name|a3
parameter_list|,
name|u_char
name|a4
parameter_list|,
name|u_char
name|a5
parameter_list|,
name|u_char
name|a6
parameter_list|,
name|u_char
name|a7
parameter_list|,
name|u_char
name|a8
parameter_list|,
name|u_char
name|a9
parameter_list|,
name|u_char
name|a10
parameter_list|,
name|u_char
name|a11
parameter_list|,
name|u_char
name|a12
parameter_list|,
name|u_char
name|a13
parameter_list|,
name|u_char
name|a14
parameter_list|,
name|u_char
name|a15
parameter_list|,
name|char
modifier|*
name|addr
parameter_list|,
name|int
name|count
parameter_list|,
name|atapi_callback_t
modifier|*
name|done
parameter_list|,
name|void
modifier|*
name|x
parameter_list|,
name|void
modifier|*
name|y
parameter_list|)
block|{
name|struct
name|atapicmd
modifier|*
name|ac
decl_stmt|;
name|ac
operator|=
name|atapi_alloc
argument_list|(
name|ata
argument_list|)
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|0
index|]
operator|=
name|cmd
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|1
index|]
operator|=
name|a1
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|2
index|]
operator|=
name|a2
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|3
index|]
operator|=
name|a3
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|4
index|]
operator|=
name|a4
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|5
index|]
operator|=
name|a5
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|6
index|]
operator|=
name|a6
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|7
index|]
operator|=
name|a7
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|8
index|]
operator|=
name|a8
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|9
index|]
operator|=
name|a9
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|10
index|]
operator|=
name|a10
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|11
index|]
operator|=
name|a11
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|12
index|]
operator|=
name|a12
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|13
index|]
operator|=
name|a13
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|14
index|]
operator|=
name|a14
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|15
index|]
operator|=
name|a15
expr_stmt|;
name|ac
operator|->
name|unit
operator|=
name|unit
expr_stmt|;
name|ac
operator|->
name|addr
operator|=
name|addr
expr_stmt|;
name|ac
operator|->
name|count
operator|=
name|count
expr_stmt|;
name|ac
operator|->
name|callback
operator|=
name|done
expr_stmt|;
name|ac
operator|->
name|cbarg1
operator|=
name|x
expr_stmt|;
name|ac
operator|->
name|cbarg2
operator|=
name|y
expr_stmt|;
if|if
condition|(
name|ata
operator|->
name|debug
condition|)
name|printf
argument_list|(
literal|"atapi%d.%d: req cb %x-%x-%x-%x-%x-%x-%x-%x-%x-%x-%x-%x-%x-%x-%x-%x len=%d\n"
argument_list|,
name|ata
operator|->
name|ctrlr
argument_list|,
name|ac
operator|->
name|unit
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|0
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|1
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|2
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|3
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|4
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|5
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|6
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|7
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|8
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|9
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|10
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|11
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|12
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|13
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|14
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|15
index|]
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|atapi_enqueue
argument_list|(
name|ata
argument_list|,
name|ac
argument_list|)
expr_stmt|;
name|wdstart
argument_list|(
name|ata
operator|->
name|ctrlr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Queue new packet request, then call wdstart().  * Wait until the request is finished.  * Called on spl0().  * Return atapi error.  * Buffer pointed to by *addr should be placed in core memory, not in stack!  */
end_comment

begin_function
name|struct
name|atapires
name|atapi_request_wait
parameter_list|(
name|struct
name|atapi
modifier|*
name|ata
parameter_list|,
name|int
name|unit
parameter_list|,
name|u_char
name|cmd
parameter_list|,
name|u_char
name|a1
parameter_list|,
name|u_char
name|a2
parameter_list|,
name|u_char
name|a3
parameter_list|,
name|u_char
name|a4
parameter_list|,
name|u_char
name|a5
parameter_list|,
name|u_char
name|a6
parameter_list|,
name|u_char
name|a7
parameter_list|,
name|u_char
name|a8
parameter_list|,
name|u_char
name|a9
parameter_list|,
name|u_char
name|a10
parameter_list|,
name|u_char
name|a11
parameter_list|,
name|u_char
name|a12
parameter_list|,
name|u_char
name|a13
parameter_list|,
name|u_char
name|a14
parameter_list|,
name|u_char
name|a15
parameter_list|,
name|char
modifier|*
name|addr
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|struct
name|atapicmd
modifier|*
name|ac
decl_stmt|;
name|int
name|x
init|=
name|splbio
argument_list|()
decl_stmt|;
name|struct
name|atapires
name|result
decl_stmt|;
name|ac
operator|=
name|atapi_alloc
argument_list|(
name|ata
argument_list|)
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|0
index|]
operator|=
name|cmd
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|1
index|]
operator|=
name|a1
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|2
index|]
operator|=
name|a2
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|3
index|]
operator|=
name|a3
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|4
index|]
operator|=
name|a4
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|5
index|]
operator|=
name|a5
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|6
index|]
operator|=
name|a6
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|7
index|]
operator|=
name|a7
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|8
index|]
operator|=
name|a8
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|9
index|]
operator|=
name|a9
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|10
index|]
operator|=
name|a10
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|11
index|]
operator|=
name|a11
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|12
index|]
operator|=
name|a12
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|13
index|]
operator|=
name|a13
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|14
index|]
operator|=
name|a14
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|15
index|]
operator|=
name|a15
expr_stmt|;
name|ac
operator|->
name|unit
operator|=
name|unit
expr_stmt|;
name|ac
operator|->
name|addr
operator|=
name|addr
expr_stmt|;
name|ac
operator|->
name|count
operator|=
name|count
expr_stmt|;
name|ac
operator|->
name|callback
operator|=
literal|0
expr_stmt|;
name|ac
operator|->
name|cbarg1
operator|=
literal|0
expr_stmt|;
name|ac
operator|->
name|cbarg2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ata
operator|->
name|debug
condition|)
name|printf
argument_list|(
literal|"atapi%d.%d: req w %x-%x-%x-%x-%x-%x-%x-%x-%x-%x-%x-%x-%x-%x-%x-%x len=%d\n"
argument_list|,
name|ata
operator|->
name|ctrlr
argument_list|,
name|ac
operator|->
name|unit
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|0
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|1
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|2
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|3
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|4
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|5
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|6
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|7
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|8
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|9
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|10
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|11
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|12
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|13
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|14
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|15
index|]
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|atapi_enqueue
argument_list|(
name|ata
argument_list|,
name|ac
argument_list|)
expr_stmt|;
name|wdstart
argument_list|(
name|ata
operator|->
name|ctrlr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ata
operator|->
name|tail
operator|==
name|ac
condition|)
name|tsleep
argument_list|(
name|ac
argument_list|,
name|PRIBIO
argument_list|,
literal|"atareq"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|result
operator|=
name|ac
operator|->
name|result
expr_stmt|;
name|atapi_free
argument_list|(
name|ata
argument_list|,
name|ac
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Perform a packet command on the device.  * Should be called on splbio().  * Return atapi error.  */
end_comment

begin_function
name|struct
name|atapires
name|atapi_request_immediate
parameter_list|(
name|struct
name|atapi
modifier|*
name|ata
parameter_list|,
name|int
name|unit
parameter_list|,
name|u_char
name|cmd
parameter_list|,
name|u_char
name|a1
parameter_list|,
name|u_char
name|a2
parameter_list|,
name|u_char
name|a3
parameter_list|,
name|u_char
name|a4
parameter_list|,
name|u_char
name|a5
parameter_list|,
name|u_char
name|a6
parameter_list|,
name|u_char
name|a7
parameter_list|,
name|u_char
name|a8
parameter_list|,
name|u_char
name|a9
parameter_list|,
name|u_char
name|a10
parameter_list|,
name|u_char
name|a11
parameter_list|,
name|u_char
name|a12
parameter_list|,
name|u_char
name|a13
parameter_list|,
name|u_char
name|a14
parameter_list|,
name|u_char
name|a15
parameter_list|,
name|char
modifier|*
name|addr
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|struct
name|atapicmd
name|cmdbuf
decl_stmt|,
modifier|*
name|ac
init|=
operator|&
name|cmdbuf
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|0
index|]
operator|=
name|cmd
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|1
index|]
operator|=
name|a1
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|2
index|]
operator|=
name|a2
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|3
index|]
operator|=
name|a3
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|4
index|]
operator|=
name|a4
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|5
index|]
operator|=
name|a5
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|6
index|]
operator|=
name|a6
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|7
index|]
operator|=
name|a7
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|8
index|]
operator|=
name|a8
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|9
index|]
operator|=
name|a9
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|10
index|]
operator|=
name|a10
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|11
index|]
operator|=
name|a11
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|12
index|]
operator|=
name|a12
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|13
index|]
operator|=
name|a13
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|14
index|]
operator|=
name|a14
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|15
index|]
operator|=
name|a15
expr_stmt|;
name|ac
operator|->
name|unit
operator|=
name|unit
expr_stmt|;
name|ac
operator|->
name|addr
operator|=
name|addr
expr_stmt|;
name|ac
operator|->
name|count
operator|=
name|count
expr_stmt|;
name|ac
operator|->
name|callback
operator|=
literal|0
expr_stmt|;
name|ac
operator|->
name|cbarg1
operator|=
literal|0
expr_stmt|;
name|ac
operator|->
name|cbarg2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ata
operator|->
name|debug
condition|)
name|printf
argument_list|(
literal|"atapi%d.%d: req im %x-%x-%x-%x-%x-%x-%x-%x-%x-%x-%x-%x-%x-%x-%x-%x len=%d\n"
argument_list|,
name|ata
operator|->
name|ctrlr
argument_list|,
name|ac
operator|->
name|unit
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|0
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|1
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|2
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|3
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|4
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|5
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|6
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|7
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|8
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|9
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|10
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|11
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|12
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|13
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|14
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|15
index|]
argument_list|,
name|count
argument_list|)
expr_stmt|;
comment|/* Start packet command, wait for DRQ. */
if|if
condition|(
name|atapi_start_cmd
argument_list|(
name|ata
argument_list|,
name|ac
argument_list|)
operator|>=
literal|0
operator|&&
name|atapi_wait_cmd
argument_list|(
name|ata
argument_list|,
name|ac
argument_list|)
operator|>=
literal|0
condition|)
block|{
comment|/* Send packet command. */
name|atapi_send_cmd
argument_list|(
name|ata
argument_list|,
name|ac
argument_list|)
expr_stmt|;
comment|/* Wait for data i/o phase. */
for|for
control|(
name|cnt
operator|=
literal|20000
init|;
name|cnt
operator|>
literal|0
condition|;
operator|--
name|cnt
control|)
if|if
condition|(
operator|(
operator|(
name|inb
argument_list|(
name|ata
operator|->
name|port
operator|+
name|AR_IREASON
argument_list|)
operator|&
operator|(
name|ARI_CMD
operator||
name|ARI_IN
operator|)
operator|)
operator||
operator|(
name|inb
argument_list|(
name|ata
operator|->
name|port
operator|+
name|AR_STATUS
argument_list|)
operator|&
name|ARS_DRQ
operator|)
operator|)
operator|!=
name|PHASE_CMDOUT
condition|)
break|break;
comment|/* Do all needed i/o. */
while|while
condition|(
name|atapi_io
argument_list|(
name|ata
argument_list|,
name|ac
argument_list|)
condition|)
comment|/* Wait for DRQ deassert. */
for|for
control|(
name|cnt
operator|=
literal|2000
init|;
name|cnt
operator|>
literal|0
condition|;
operator|--
name|cnt
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ata
operator|->
name|port
operator|+
name|AR_STATUS
argument_list|)
operator|&
name|ARS_DRQ
operator|)
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|ac
operator|->
name|result
operator|)
return|;
block|}
end_function

end_unit

