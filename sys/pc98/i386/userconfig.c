begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**  ** Copyright (c) 1995  **      Michael Smith, msmith@atrad.adelaide.edu.au.  All rights reserved.  **  ** This code contains a module marked :   * Copyright (c) 1991 Regents of the University of California.  * All rights reserved.  * Copyright (c) 1994 Jordan K. Hubbard  * All rights reserved.  * Copyright (c) 1994 David Greenman  * All rights reserved.  *  * Many additional changes by Bruce Evans  *  * This code is derived from software contributed by the  * University of California Berkeley, Jordan K. Hubbard,  * David Greenman and Bruce Evans.   ** As such, it contains code subject to the above copyrights.  ** The module and its copyright can be found below.  **   ** Redistribution and use in source and binary forms, with or without  ** modification, are permitted provided that the following conditions  ** are met:  ** 1. Redistributions of source code must retain the above copyright  **    notice, this list of conditions and the following disclaimer as  **    the first lines of this file unmodified.  ** 2. Redistributions in binary form must reproduce the above copyright  **    notice, this list of conditions and the following disclaimer in the  **    documentation and/or other materials provided with the distribution.  ** 3. All advertising materials mentioning features or use of this software  **    must display the following acknowledgment:  **      This product includes software developed by Michael Smith.  ** 4. The name of the author may not be used to endorse or promote products  **    derived from this software without specific prior written permission.  **  ** THIS SOFTWARE IS PROVIDED BY MICHAEL SMITH ``AS IS'' AND ANY EXPRESS OR  ** IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  ** OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  ** IN NO EVENT SHALL MICHAEL SMITH BE LIABLE FOR ANY DIRECT, INDIRECT,  ** INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  ** NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  ** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  ** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  ** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  ** THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  **  **      $Id: userconfig.c,v 1.11 1996/11/02 10:39:03 asami Exp $  **/
end_comment

begin_comment
comment|/**  ** USERCONFIG  **  ** Kernel boot-time configuration manipulation tool for FreeBSD.  **  ** Two modes of operation are supported : the default is the line-editor mode,  ** the command "visual" invokes the fullscreen mode.  **  ** The line-editor mode is the old favorite from FreeBSD 2.0/20.05&c., the   ** fullscreen mode requires syscons or a minimal-ansi serial console.  **/
end_comment

begin_comment
comment|/**  ** USERCONFIG, visual mode.  **  **   msmith@atrad.adelaide.edu.au  **  ** Look for "EDIT THIS LIST" to add to the list of known devices  **   **  ** There are a number of assumptions made in this code.  **   ** - That the console supports a minimal set of ANSI escape sequences  **   (See the screen manipulation section for a summary)  **   and has at least 24 rows.  ** - That values less than or equal to zero for any of the device  **   parameters indicate that the driver does not use the parameter.  ** - That the only tunable parameter for PCI devices are their flags.  ** - That flags are _always_ editable.  **  ** Devices marked as disabled are imported as such.  PCI devices are   ** listed under a seperate heading for informational purposes only.  ** To date, there is no means for changing the behaviour of PCI drivers  ** from UserConfig.  **  ** Note that some EISA devices probably fall into this category as well,  ** and in fact the actual bus supported by some drivers is less than clear.  ** A longer-term goal might be to list drivers by instance rather than  ** per bus-presence.  **   ** For this tool to be useful, the list of devices below _MUST_ be updated   ** when a new driver is brought into the kernel.  It is not possible to   ** extract this information from the drivers in the kernel.  **  ** XXX - TODO:  **   ** - Display _what_ a device conflicts with.  ** - Implement page up/down (as what?)  ** - Wizard mode (no restrictions)  ** - Find out how to put syscons back into low-intensity mode so that the  **   !b escape is useful on the console.  **  ** - Only display headings with devices under them. (difficult)  **/
end_comment

begin_comment
comment|/*  * PC-9801 port by KATO Takenori<kato@eclogite.eps.nagoya-u.ac.jp>  */
end_comment

begin_include
include|#
directive|include
file|"opt_userconfig.h"
end_include

begin_include
include|#
directive|include
file|"pci.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<machine/cons.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcivar.h>
end_include

begin_decl_stmt
specifier|static
name|struct
name|isa_device
modifier|*
name|isa_devlist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list read by dset to extract changes */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USERCONFIG_BOOT
end_ifdef

begin_decl_stmt
name|char
name|userconfig_from_boot
index|[
literal|512
index|]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|getchar
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|next
init|=
name|userconfig_from_boot
decl_stmt|;
if|if
condition|(
name|next
operator|==
name|userconfig_from_boot
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|next
argument_list|,
literal|"USERCONFIG\n"
argument_list|,
literal|11
argument_list|)
condition|)
block|{
name|next
operator|++
expr_stmt|;
name|strcpy
argument_list|(
name|next
argument_list|,
literal|"quit\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|next
operator|+=
literal|11
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|next
condition|)
block|{
return|return
operator|(
operator|*
name|next
operator|++
operator|)
return|;
block|}
else|else
block|{
return|return
name|cngetc
argument_list|()
return|;
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !USERCONFIG_BOOT */
end_comment

begin_define
define|#
directive|define
name|getchar
parameter_list|()
value|cngetc()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USERCONFIG_BOOT */
end_comment

begin_define
define|#
directive|define
name|putchar
parameter_list|(
name|x
parameter_list|)
value|cnputc(x)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|VISUAL_USERCONFIG
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|isa_device
modifier|*
name|devtabs
index|[]
init|=
block|{
name|isa_devtab_bio
block|,
name|isa_devtab_tty
block|,
name|isa_devtab_net
block|,
name|isa_devtab_null
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|FALSE
end_ifndef

begin_define
define|#
directive|define
name|FALSE
value|(0)
end_define

begin_define
define|#
directive|define
name|TRUE
value|(!FALSE)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
name|dev
index|[
literal|16
index|]
decl_stmt|;
comment|/* device basename */
name|char
name|name
index|[
literal|60
index|]
decl_stmt|;
comment|/* long name */
name|int
name|attrib
decl_stmt|;
comment|/* things to do with the device */
name|int
name|class
decl_stmt|;
comment|/* device classification */
block|}
name|DEV_INFO
typedef|;
end_typedef

begin_define
define|#
directive|define
name|FLG_INVISIBLE
value|(1<<0)
end_define

begin_comment
comment|/* device should not be shown */
end_comment

begin_define
define|#
directive|define
name|FLG_MANDATORY
value|(1<<1)
end_define

begin_comment
comment|/* device can be edited but not disabled */
end_comment

begin_define
define|#
directive|define
name|FLG_FIXIRQ
value|(1<<2)
end_define

begin_comment
comment|/* device IRQ cannot be changed */
end_comment

begin_define
define|#
directive|define
name|FLG_FIXIOBASE
value|(1<<3)
end_define

begin_comment
comment|/* device iobase cannot be changed */
end_comment

begin_define
define|#
directive|define
name|FLG_FIXMADDR
value|(1<<4)
end_define

begin_comment
comment|/* device maddr cannot be changed */
end_comment

begin_define
define|#
directive|define
name|FLG_FIXMSIZE
value|(1<<5)
end_define

begin_comment
comment|/* device msize cannot be changed */
end_comment

begin_define
define|#
directive|define
name|FLG_FIXDRQ
value|(1<<6)
end_define

begin_comment
comment|/* device DRQ cannot be changed */
end_comment

begin_define
define|#
directive|define
name|FLG_FIXED
value|(FLG_FIXIRQ|FLG_FIXIOBASE|FLG_FIXMADDR|FLG_FIXMSIZE|FLG_FIXDRQ)
end_define

begin_define
define|#
directive|define
name|FLG_IMMUTABLE
value|(FLG_FIXED|FLG_MANDATORY)
end_define

begin_define
define|#
directive|define
name|CLS_STORAGE
value|1
end_define

begin_comment
comment|/* storage devices */
end_comment

begin_define
define|#
directive|define
name|CLS_NETWORK
value|2
end_define

begin_comment
comment|/* network interfaces */
end_comment

begin_define
define|#
directive|define
name|CLS_COMMS
value|3
end_define

begin_comment
comment|/* serial, parallel ports */
end_comment

begin_define
define|#
directive|define
name|CLS_INPUT
value|4
end_define

begin_comment
comment|/* user input : mice, keyboards, joysticks etc */
end_comment

begin_define
define|#
directive|define
name|CLS_MMEDIA
value|5
end_define

begin_comment
comment|/* "multimedia" devices (sound, video, etc) */
end_comment

begin_define
define|#
directive|define
name|CLS_PCI
value|254
end_define

begin_comment
comment|/* PCI devices */
end_comment

begin_define
define|#
directive|define
name|CLS_MISC
value|255
end_define

begin_comment
comment|/* none of the above */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
name|name
index|[
literal|60
index|]
decl_stmt|;
name|int
name|number
decl_stmt|;
block|}
name|DEVCLASS_INFO
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|DEVCLASS_INFO
name|devclass_names
index|[]
init|=
block|{
block|{
literal|"Storage :        "
block|,
name|CLS_STORAGE
block|}
block|,
block|{
literal|"Network :        "
block|,
name|CLS_NETWORK
block|}
block|,
block|{
literal|"Communications : "
block|,
name|CLS_COMMS
block|}
block|,
block|{
literal|"Input :          "
block|,
name|CLS_INPUT
block|}
block|,
block|{
literal|"Multimedia :     "
block|,
name|CLS_MMEDIA
block|}
block|,
block|{
literal|"PCI :            "
block|,
name|CLS_PCI
block|}
block|,
block|{
literal|"Miscellaneous :  "
block|,
name|CLS_MISC
block|}
block|,
block|{
literal|""
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/********************* EDIT THIS LIST **********************/
end_comment

begin_comment
comment|/** Notes :  **   ** - PCI devices should be marked FLG_IMMUTABLE.  They should not be movable  **   or editable, and have no attributes.  This is handled in getdevs() and  **   devinfo(), so drivers that have a presence on busses other than PCI  **   should have appropriate flags set below.  ** - Devices that shouldn't be seen or removed should be marked FLG_INVISIBLE.  ** - XXX The list below should be reviewed by the driver authors to verify  **   that the correct flags have been set for each driver, and that the  **   descriptions are accurate.  **/
end_comment

begin_decl_stmt
specifier|static
name|DEV_INFO
name|device_info
index|[]
init|=
block|{
comment|/*---Name-----   ---Description---------------------------------------------- */
ifdef|#
directive|ifdef
name|PC98
block|{
literal|"sbic"
block|,
literal|"PC-9801-55 SCSI Interface"
block|,
literal|0
block|,
name|CLS_STORAGE
block|}
block|,
block|{
literal|"bs"
block|,
literal|"PC-9801-55 SCSI Interface"
block|,
literal|0
block|,
name|CLS_STORAGE
block|}
block|,
block|{
literal|"ahc"
block|,
literal|"Adaptec 274x/284x/294x SCSI controller"
block|,
literal|0
block|,
name|CLS_STORAGE
block|}
block|,
block|{
literal|"aic"
block|,
literal|"Adaptec 152x SCSI and compatible sound cards"
block|,
literal|0
block|,
name|CLS_STORAGE
block|}
block|,
block|{
literal|"ncr"
block|,
literal|"NCR 53C810 SCSI controller"
block|,
name|FLG_FIXED
block|,
name|CLS_STORAGE
block|}
block|,
block|{
literal|"wdc"
block|,
literal|"IDE/ESDI/MFM disk controller"
block|,
literal|0
block|,
name|CLS_STORAGE
block|}
block|,
block|{
literal|"fdc"
block|,
literal|"Floppy disk controller"
block|,
name|FLG_FIXED
block|,
name|CLS_STORAGE
block|}
block|,
block|{
literal|"mcd"
block|,
literal|"Mitsumi CD-ROM"
block|,
literal|0
block|,
name|CLS_STORAGE
block|}
block|,
block|{
literal|"scd"
block|,
literal|"Sony CD-ROM"
block|,
literal|0
block|,
name|CLS_STORAGE
block|}
block|,
block|{
literal|"matcdc"
block|,
literal|"Matsushita/Panasonic/Creative CDROM"
block|,
literal|0
block|,
name|CLS_STORAGE
block|}
block|,
else|#
directive|else
block|{
literal|"bt"
block|,
literal|"Buslogic SCSI controller"
block|,
literal|0
block|,
name|CLS_STORAGE
block|}
block|,
block|{
literal|"ahc"
block|,
literal|"Adaptec 274x/284x/294x SCSI controller"
block|,
literal|0
block|,
name|CLS_STORAGE
block|}
block|,
block|{
literal|"ahb"
block|,
literal|"Adaptec 174x SCSI controller"
block|,
literal|0
block|,
name|CLS_STORAGE
block|}
block|,
block|{
literal|"aha"
block|,
literal|"Adaptec 154x SCSI controller"
block|,
literal|0
block|,
name|CLS_STORAGE
block|}
block|,
block|{
literal|"uha"
block|,
literal|"Ultrastor 14F/24F/34F SCSI controller"
block|,
literal|0
block|,
name|CLS_STORAGE
block|}
block|,
block|{
literal|"aic"
block|,
literal|"Adaptec 152x SCSI and compatible sound cards"
block|,
literal|0
block|,
name|CLS_STORAGE
block|}
block|,
block|{
literal|"nca"
block|,
literal|"ProAudio Spectrum SCSI and compatibles"
block|,
literal|0
block|,
name|CLS_STORAGE
block|}
block|,
block|{
literal|"sea"
block|,
literal|"Seagate ST01/ST02 SCSI and compatibles"
block|,
literal|0
block|,
name|CLS_STORAGE
block|}
block|,
block|{
literal|"wds"
block|,
literal|"Western Digitial WD7000 SCSI controller"
block|,
literal|0
block|,
name|CLS_STORAGE
block|}
block|,
block|{
literal|"ncr"
block|,
literal|"NCR 53C810 SCSI controller"
block|,
name|FLG_FIXED
block|,
name|CLS_STORAGE
block|}
block|,
block|{
literal|"wdc"
block|,
literal|"IDE/ESDI/MFM disk controller"
block|,
literal|0
block|,
name|CLS_STORAGE
block|}
block|,
block|{
literal|"fdc"
block|,
literal|"Floppy disk controller"
block|,
name|FLG_FIXED
block|,
name|CLS_STORAGE
block|}
block|,
block|{
literal|"mcd"
block|,
literal|"Mitsumi CD-ROM"
block|,
literal|0
block|,
name|CLS_STORAGE
block|}
block|,
block|{
literal|"scd"
block|,
literal|"Sony CD-ROM"
block|,
literal|0
block|,
name|CLS_STORAGE
block|}
block|,
block|{
literal|"matcdc"
block|,
literal|"Matsushita/Panasonic/Creative CDROM"
block|,
literal|0
block|,
name|CLS_STORAGE
block|}
block|,
block|{
literal|"wt"
block|,
literal|"Wangtek/Archive QIC-02 Tape drive"
block|,
literal|0
block|,
name|CLS_STORAGE
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PC98
block|{
literal|"ed"
block|,
literal|"NS8390 Ethernet adapters"
block|,
literal|0
block|,
name|CLS_NETWORK
block|}
block|,
else|#
directive|else
block|{
literal|"ed"
block|,
literal|"NE1000,NE2000,3C503,WD/SMC80xx Ethernet adapters"
block|,
literal|0
block|,
name|CLS_NETWORK
block|}
block|,
endif|#
directive|endif
block|{
literal|"el"
block|,
literal|"3C501 Ethernet adapter"
block|,
literal|0
block|,
name|CLS_NETWORK
block|}
block|,
block|{
literal|"ep"
block|,
literal|"3C509 Ethernet adapter"
block|,
literal|0
block|,
name|CLS_NETWORK
block|}
block|,
block|{
literal|"fe"
block|,
literal|"Fujitsu MD86960A/MB869685A Ethernet adapters"
block|,
literal|0
block|,
name|CLS_NETWORK
block|}
block|,
block|{
literal|"fea"
block|,
literal|"DEC DEFEA EISA FDDI adapter"
block|,
literal|0
block|,
name|CLS_NETWORK
block|}
block|,
block|{
literal|"fxp"
block|,
literal|"Intel EtherExpress Pro/100B Ethernet adapter"
block|,
literal|0
block|,
name|CLS_NETWORK
block|}
block|,
block|{
literal|"ie"
block|,
literal|"AT&T Starlan 10 and EN100, 3C507, NI5210 Ethernet adapters"
block|,
literal|0
block|,
name|CLS_NETWORK
block|}
block|,
block|{
literal|"ix"
block|,
literal|"Intel EtherExpress Ethernet adapter"
block|,
literal|0
block|,
name|CLS_NETWORK
block|}
block|,
block|{
literal|"le"
block|,
literal|"DEC Etherworks 2 and 3 Ethernet adapters"
block|,
literal|0
block|,
name|CLS_NETWORK
block|}
block|,
block|{
literal|"lnc"
block|,
literal|"Isolan, Novell NE2100/NE32-VL Ethernet adapters"
block|,
literal|0
block|,
name|CLS_NETWORK
block|}
block|,
block|{
literal|"vx"
block|,
literal|"3COM 3C590/3C595 Ethernet adapters"
block|,
literal|0
block|,
name|CLS_NETWORK
block|}
block|,
block|{
literal|"ze"
block|,
literal|"IBM/National Semiconductor PCMCIA Ethernet adapter"
block|,
literal|0
block|,
name|CLS_NETWORK
block|}
block|,
block|{
literal|"zp"
block|,
literal|"3COM PCMCIA Etherlink III Ethernet adapter"
block|,
literal|0
block|,
name|CLS_NETWORK
block|}
block|,
block|{
literal|"de"
block|,
literal|"DEC DC21040 Ethernet adapter"
block|,
name|FLG_FIXED
block|,
name|CLS_NETWORK
block|}
block|,
block|{
literal|"fpa"
block|,
literal|"DEC DEFPA PCI FDDI adapter"
block|,
name|FLG_FIXED
block|,
name|CLS_NETWORK
block|}
block|,
block|{
literal|"sio"
block|,
literal|"8250/16450/16550 Serial port"
block|,
literal|0
block|,
name|CLS_COMMS
block|}
block|,
ifndef|#
directive|ifndef
name|PC98
block|{
literal|"cx"
block|,
literal|"Cronyx/Sigma multiport sync/async adapter"
block|,
literal|0
block|,
name|CLS_COMMS
block|}
block|,
block|{
literal|"rc"
block|,
literal|"RISCom/8 multiport async adapter"
block|,
literal|0
block|,
name|CLS_COMMS
block|}
block|,
block|{
literal|"cy"
block|,
literal|"Cyclades multiport async adapter"
block|,
literal|0
block|,
name|CLS_COMMS
block|}
block|,
endif|#
directive|endif
block|{
literal|"lpt"
block|,
literal|"Parallel printer port"
block|,
literal|0
block|,
name|CLS_COMMS
block|}
block|,
ifndef|#
directive|ifndef
name|PC98
block|{
literal|"gp"
block|,
literal|"National Instruments AT-GPIB/TNT driver"
block|,
literal|0
block|,
name|CLS_COMMS
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PC98
block|{
literal|"mse"
block|,
literal|"Bus Mouse"
block|,
literal|0
block|,
name|CLS_INPUT
block|}
block|,
else|#
directive|else
block|{
literal|"mse"
block|,
literal|"Microsoft Bus Mouse"
block|,
literal|0
block|,
name|CLS_INPUT
block|}
block|,
block|{
literal|"psm"
block|,
literal|"PS/2 Mouse"
block|,
literal|0
block|,
name|CLS_INPUT
block|}
block|,
endif|#
directive|endif
block|{
literal|"joy"
block|,
literal|"Joystick"
block|,
name|FLG_FIXED
block|,
name|CLS_INPUT
block|}
block|,
block|{
literal|"vt"
block|,
literal|"PCVT console driver"
block|,
name|FLG_FIXED
block|,
name|CLS_INPUT
block|}
block|,
block|{
literal|"sc"
block|,
literal|"Syscons console driver"
block|,
name|FLG_FIXED
block|,
name|CLS_INPUT
block|}
block|,
ifdef|#
directive|ifdef
name|PC98
block|{
literal|"pcm"
block|,
literal|"PC-9801-86 Sound Board"
block|,
literal|0
block|,
name|CLS_MMEDIA
block|}
block|,
endif|#
directive|endif
block|{
literal|"sb"
block|,
literal|"Soundblaster PCM (SB, SBPro, SB16, ProAudio Spectrum)"
block|,
literal|0
block|,
name|CLS_MMEDIA
block|}
block|,
block|{
literal|"sbxvi"
block|,
literal|"Soundblaster 16"
block|,
literal|0
block|,
name|CLS_MMEDIA
block|}
block|,
block|{
literal|"sbmidi"
block|,
literal|"Soundblaster MIDI interface"
block|,
literal|0
block|,
name|CLS_MMEDIA
block|}
block|,
block|{
literal|"pas"
block|,
literal|"ProAudio Spectrum PCM and MIDI"
block|,
literal|0
block|,
name|CLS_MMEDIA
block|}
block|,
block|{
literal|"gus"
block|,
literal|"Gravis Ultrasound, Ultrasound 16 and Ultrasound MAX"
block|,
literal|0
block|,
name|CLS_MMEDIA
block|}
block|,
block|{
literal|"gusxvi"
block|,
literal|"Gravis Ultrasound 16-bit PCM"
block|,
literal|0
block|,
name|CLS_MMEDIA
block|}
block|,
block|{
literal|"gusmax"
block|,
literal|"Gravis Ultrasound MAX"
block|,
literal|0
block|,
name|CLS_MMEDIA
block|}
block|,
block|{
literal|"mss"
block|,
literal|"Microsoft Sound System"
block|,
literal|0
block|,
name|CLS_MMEDIA
block|}
block|,
block|{
literal|"opl"
block|,
literal|"OPL-2/3 FM, Soundblaster, SBPro, SB16, ProAudio Spectrum"
block|,
literal|0
block|,
name|CLS_MMEDIA
block|}
block|,
block|{
literal|"mpu"
block|,
literal|"Roland MPU401 MIDI"
block|,
literal|0
block|,
name|CLS_MMEDIA
block|}
block|,
block|{
literal|"uart"
block|,
literal|"6850 MIDI UART"
block|,
literal|0
block|,
name|CLS_MMEDIA
block|}
block|,
block|{
literal|"pca"
block|,
literal|"PC speaker PCM audio driver"
block|,
name|FLG_FIXED
block|,
name|CLS_MMEDIA
block|}
block|,
block|{
literal|"ctx"
block|,
literal|"Coretex-I frame grabber"
block|,
literal|0
block|,
name|CLS_MMEDIA
block|}
block|,
block|{
literal|"spigot"
block|,
literal|"Creative Labs Video Spigot video capture"
block|,
literal|0
block|,
name|CLS_MMEDIA
block|}
block|,
block|{
literal|"gsc"
block|,
literal|"Genius GS-4500 hand scanner"
block|,
literal|0
block|,
name|CLS_MMEDIA
block|}
block|,
block|{
literal|"qcam"
block|,
literal|"QuickCam parallel port camera"
block|,
literal|0
block|,
name|CLS_MMEDIA
block|}
block|,
block|{
literal|"apm"
block|,
literal|"Advanced Power Management"
block|,
name|FLG_FIXED
block|,
name|CLS_MISC
block|}
block|,
block|{
literal|"labpc"
block|,
literal|"National Instruments Lab-PC/Lab-PC+"
block|,
literal|0
block|,
name|CLS_MISC
block|}
block|,
block|{
literal|"npx"
block|,
literal|"Math coprocessor"
block|,
name|FLG_INVISIBLE
block|,
name|CLS_MISC
block|}
block|,
block|{
literal|"lkm"
block|,
literal|"Loadable PCI driver support"
block|,
name|FLG_INVISIBLE
block|,
name|CLS_MISC
block|}
block|,
block|{
literal|"vga"
block|,
literal|"Catchall PCI VGA driver"
block|,
name|FLG_INVISIBLE
block|,
name|CLS_MISC
block|}
block|,
block|{
literal|"chip"
block|,
literal|"PCI chipset support"
block|,
name|FLG_INVISIBLE
block|,
name|CLS_MISC
block|}
block|,
block|{
literal|"piix"
block|,
literal|"Intel 82371 Bus-master IDE controller"
block|,
name|FLG_INVISIBLE
block|,
name|CLS_MISC
block|}
block|,
block|{
literal|""
block|,
literal|""
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|_devlist_struct
block|{
name|char
name|name
index|[
literal|80
index|]
decl_stmt|;
name|int
name|attrib
decl_stmt|;
comment|/* flag values as per the FLG_* defines above */
name|int
name|class
decl_stmt|;
comment|/* disk, etc as per the CLS_* defines above */
name|char
name|dev
index|[
literal|16
index|]
decl_stmt|;
name|int
name|iobase
decl_stmt|,
name|irq
decl_stmt|,
name|drq
decl_stmt|,
name|maddr
decl_stmt|,
name|msize
decl_stmt|,
name|unit
decl_stmt|,
name|flags
decl_stmt|,
name|conflict_ok
decl_stmt|,
name|id
decl_stmt|;
name|int
name|comment
decl_stmt|;
comment|/* 0 = device, 1 = comment, 2 = collapsed comment */
name|int
name|conflicts
decl_stmt|;
comment|/* set/reset by findconflict, count of conflicts */
name|int
name|changed
decl_stmt|;
comment|/* nonzero if the device has been edited */
name|struct
name|isa_device
modifier|*
name|device
decl_stmt|;
name|struct
name|_devlist_struct
modifier|*
name|prev
decl_stmt|,
modifier|*
name|next
decl_stmt|;
block|}
name|DEV_LIST
typedef|;
end_typedef

begin_define
define|#
directive|define
name|DEV_DEVICE
value|0
end_define

begin_define
define|#
directive|define
name|DEV_COMMENT
value|1
end_define

begin_define
define|#
directive|define
name|DEV_ZOOMED
value|2
end_define

begin_define
define|#
directive|define
name|LIST_CURRENT
value|(1<<0)
end_define

begin_define
define|#
directive|define
name|LIST_SELECTED
value|(1<<1)
end_define

begin_define
define|#
directive|define
name|KEY_EXIT
value|0
end_define

begin_comment
comment|/* return codes from dolist() and friends */
end_comment

begin_define
define|#
directive|define
name|KEY_DO
value|1
end_define

begin_define
define|#
directive|define
name|KEY_DEL
value|2
end_define

begin_define
define|#
directive|define
name|KEY_TAB
value|3
end_define

begin_define
define|#
directive|define
name|KEY_REDRAW
value|4
end_define

begin_define
define|#
directive|define
name|KEY_UP
value|5
end_define

begin_comment
comment|/* these only returned from editval() */
end_comment

begin_define
define|#
directive|define
name|KEY_DOWN
value|6
end_define

begin_define
define|#
directive|define
name|KEY_LEFT
value|7
end_define

begin_define
define|#
directive|define
name|KEY_RIGHT
value|8
end_define

begin_define
define|#
directive|define
name|KEY_NULL
value|9
end_define

begin_comment
comment|/* this allows us to spin& redraw */
end_comment

begin_define
define|#
directive|define
name|KEY_ZOOM
value|10
end_define

begin_comment
comment|/* these for zoom all/collapse all */
end_comment

begin_define
define|#
directive|define
name|KEY_UNZOOM
value|11
end_define

begin_function_decl
specifier|static
name|void
name|redraw
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|insdev
parameter_list|(
name|DEV_LIST
modifier|*
name|dev
parameter_list|,
name|DEV_LIST
modifier|*
name|list
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|devinfo
parameter_list|(
name|DEV_LIST
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|visuserconfig
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|DEV_LIST
modifier|*
name|active
init|=
name|NULL
decl_stmt|,
modifier|*
name|inactive
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* driver lists */
end_comment

begin_decl_stmt
specifier|static
name|DEV_LIST
modifier|*
name|alist
decl_stmt|,
modifier|*
name|ilist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* visible heads of the driver lists */
end_comment

begin_decl_stmt
specifier|static
name|DEV_LIST
name|scratch
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* scratch record */
end_comment

begin_decl_stmt
specifier|static
name|int
name|conflicts
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* total conflict count */
end_comment

begin_decl_stmt
specifier|static
name|char
name|lines
index|[]
init|=
literal|"--------------------------------------------------------------------------------"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|spaces
index|[]
init|=
literal|"                                                                                     "
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**  ** Device manipulation stuff : find, describe, configure.  **/
end_comment

begin_comment
comment|/**  ** setdev  **  ** Sets the device referenced by (*dev) to the parameters in the struct,  ** and the enable flag according to (enabled)  **/
end_comment

begin_function
specifier|static
name|void
name|setdev
parameter_list|(
name|DEV_LIST
modifier|*
name|dev
parameter_list|,
name|int
name|enabled
parameter_list|)
block|{
if|if
condition|(
name|dev
operator|->
name|iobase
operator|==
operator|-
literal|2
condition|)
comment|/* PCI device */
return|return;
name|dev
operator|->
name|device
operator|->
name|id_iobase
operator|=
name|dev
operator|->
name|iobase
expr_stmt|;
comment|/* copy happy */
name|dev
operator|->
name|device
operator|->
name|id_irq
operator|=
call|(
name|u_short
call|)
argument_list|(
name|dev
operator|->
name|irq
operator|<
literal|16
condition|?
literal|1
operator|<<
name|dev
operator|->
name|irq
else|:
literal|0
argument_list|)
expr_stmt|;
comment|/* IRQ is bitfield */
name|dev
operator|->
name|device
operator|->
name|id_drq
operator|=
operator|(
name|short
operator|)
name|dev
operator|->
name|drq
expr_stmt|;
name|dev
operator|->
name|device
operator|->
name|id_maddr
operator|=
operator|(
name|caddr_t
operator|)
name|dev
operator|->
name|maddr
expr_stmt|;
name|dev
operator|->
name|device
operator|->
name|id_msize
operator|=
name|dev
operator|->
name|msize
expr_stmt|;
name|dev
operator|->
name|device
operator|->
name|id_flags
operator|=
name|dev
operator|->
name|flags
expr_stmt|;
name|dev
operator|->
name|device
operator|->
name|id_enabled
operator|=
name|enabled
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  ** getdevs  **  ** Walk the kernel device tables and build the active and inactive lists  **/
end_comment

begin_function
specifier|static
name|void
name|getdevs
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|isa_device
modifier|*
name|ap
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|devtabs
index|[
name|j
index|]
condition|;
name|j
operator|++
control|)
comment|/* ISA devices */
block|{
name|ap
operator|=
name|devtabs
index|[
name|j
index|]
expr_stmt|;
comment|/* pointer to array of devices */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ap
index|[
name|i
index|]
operator|.
name|id_id
condition|;
name|i
operator|++
control|)
comment|/* for each device in this table */
block|{
name|scratch
operator|.
name|unit
operator|=
name|ap
index|[
name|i
index|]
operator|.
name|id_unit
expr_stmt|;
comment|/* device parameters */
name|strcpy
argument_list|(
name|scratch
operator|.
name|dev
argument_list|,
name|ap
index|[
name|i
index|]
operator|.
name|id_driver
operator|->
name|name
argument_list|)
expr_stmt|;
name|scratch
operator|.
name|iobase
operator|=
name|ap
index|[
name|i
index|]
operator|.
name|id_iobase
expr_stmt|;
name|scratch
operator|.
name|irq
operator|=
name|ffs
argument_list|(
name|ap
index|[
name|i
index|]
operator|.
name|id_irq
argument_list|)
operator|-
literal|1
expr_stmt|;
name|scratch
operator|.
name|drq
operator|=
name|ap
index|[
name|i
index|]
operator|.
name|id_drq
expr_stmt|;
name|scratch
operator|.
name|maddr
operator|=
operator|(
name|int
operator|)
name|ap
index|[
name|i
index|]
operator|.
name|id_maddr
expr_stmt|;
name|scratch
operator|.
name|msize
operator|=
name|ap
index|[
name|i
index|]
operator|.
name|id_msize
expr_stmt|;
name|scratch
operator|.
name|flags
operator|=
name|ap
index|[
name|i
index|]
operator|.
name|id_flags
expr_stmt|;
name|scratch
operator|.
name|conflict_ok
operator|=
name|ap
index|[
name|i
index|]
operator|.
name|id_conflicts
expr_stmt|;
name|scratch
operator|.
name|comment
operator|=
name|DEV_DEVICE
expr_stmt|;
comment|/* admin stuff */
name|scratch
operator|.
name|conflicts
operator|=
literal|0
expr_stmt|;
name|scratch
operator|.
name|device
operator|=
operator|&
name|ap
index|[
name|i
index|]
expr_stmt|;
comment|/* save pointer for later reference */
name|scratch
operator|.
name|changed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|devinfo
argument_list|(
operator|&
name|scratch
argument_list|)
condition|)
comment|/* get more info on the device */
name|insdev
argument_list|(
operator|&
name|scratch
argument_list|,
name|ap
index|[
name|i
index|]
operator|.
name|id_enabled
condition|?
name|active
else|:
name|inactive
argument_list|)
expr_stmt|;
block|}
block|}
if|#
directive|if
name|NPCI
operator|>
literal|0
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pcidevice_set
operator|.
name|ls_length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pcidevice_set
operator|.
name|ls_items
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
operator|(
operator|(
specifier|const
expr|struct
name|pci_device
operator|*
operator|)
name|pcidevice_set
operator|.
name|ls_items
index|[
name|i
index|]
operator|)
operator|->
name|pd_name
condition|)
block|{
name|strcpy
argument_list|(
name|scratch
operator|.
name|dev
argument_list|,
operator|(
operator|(
specifier|const
expr|struct
name|pci_device
operator|*
operator|)
name|pcidevice_set
operator|.
name|ls_items
index|[
name|i
index|]
operator|)
operator|->
name|pd_name
argument_list|)
expr_stmt|;
name|scratch
operator|.
name|iobase
operator|=
operator|-
literal|2
expr_stmt|;
comment|/* mark as PCI for future reference */
name|scratch
operator|.
name|irq
operator|=
operator|-
literal|2
expr_stmt|;
name|scratch
operator|.
name|drq
operator|=
operator|-
literal|2
expr_stmt|;
name|scratch
operator|.
name|maddr
operator|=
operator|-
literal|2
expr_stmt|;
name|scratch
operator|.
name|msize
operator|=
operator|-
literal|2
expr_stmt|;
name|scratch
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|scratch
operator|.
name|conflict_ok
operator|=
literal|0
expr_stmt|;
comment|/* shouldn't conflict */
name|scratch
operator|.
name|comment
operator|=
name|DEV_DEVICE
expr_stmt|;
comment|/* is a device */
name|scratch
operator|.
name|unit
operator|=
literal|0
expr_stmt|;
comment|/* arbitrary number of them */
name|scratch
operator|.
name|conflicts
operator|=
literal|0
expr_stmt|;
name|scratch
operator|.
name|device
operator|=
name|NULL
expr_stmt|;
name|scratch
operator|.
name|changed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|devinfo
argument_list|(
operator|&
name|scratch
argument_list|)
condition|)
comment|/* look up name, set class and flags */
name|insdev
argument_list|(
operator|&
name|scratch
argument_list|,
name|active
argument_list|)
expr_stmt|;
comment|/* always active */
block|}
block|}
block|}
endif|#
directive|endif
comment|/* NPCI> 0 */
block|}
end_function

begin_comment
comment|/**  ** Devinfo  **  ** Fill in (dev->name), (dev->attrib) and (dev->type) from the device_info array.  ** If the device is unknown, put it in the CLS_MISC class, with no flags.  **  ** If the device is marked "invisible", return nonzero; the caller should  ** not insert any such device into either list.  **  ** PCI devices are always inserted into CLS_PCI, regardless of the class associated  ** with the driver type.  **/
end_comment

begin_function
specifier|static
name|int
name|devinfo
parameter_list|(
name|DEV_LIST
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|device_info
index|[
name|i
index|]
operator|.
name|class
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
name|device_info
index|[
name|i
index|]
operator|.
name|dev
argument_list|)
condition|)
block|{
if|if
condition|(
name|device_info
index|[
name|i
index|]
operator|.
name|attrib
operator|&
name|FLG_INVISIBLE
condition|)
comment|/* forget we ever saw this one */
return|return
operator|(
literal|1
operator|)
return|;
name|strcpy
argument_list|(
name|dev
operator|->
name|name
argument_list|,
name|device_info
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
comment|/* get the name */
if|if
condition|(
name|dev
operator|->
name|iobase
operator|==
operator|-
literal|2
condition|)
block|{
comment|/* is this a PCI device? */
name|dev
operator|->
name|attrib
operator|=
name|FLG_IMMUTABLE
expr_stmt|;
comment|/* dark green ones up the back... */
name|dev
operator|->
name|class
operator|=
name|CLS_PCI
expr_stmt|;
block|}
else|else
block|{
name|dev
operator|->
name|attrib
operator|=
name|device_info
index|[
name|i
index|]
operator|.
name|attrib
expr_stmt|;
comment|/* light green ones up the front */
name|dev
operator|->
name|class
operator|=
name|device_info
index|[
name|i
index|]
operator|.
name|class
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|strcpy
argument_list|(
name|dev
operator|->
name|name
argument_list|,
literal|"Unknown device"
argument_list|)
expr_stmt|;
name|dev
operator|->
name|attrib
operator|=
literal|0
expr_stmt|;
name|dev
operator|->
name|class
operator|=
name|CLS_MISC
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  ** List manipulation stuff : add, move, initialise, free, traverse  **  ** Note that there are assumptions throughout this code that  ** the first entry in a list will never move. (assumed to be  ** a comment).  **/
end_comment

begin_comment
comment|/**  ** Adddev  **   ** appends a copy of (dev) to the end of (*list)  **/
end_comment

begin_function
specifier|static
name|void
name|addev
parameter_list|(
name|DEV_LIST
modifier|*
name|dev
parameter_list|,
name|DEV_LIST
modifier|*
modifier|*
name|list
parameter_list|)
block|{
name|DEV_LIST
modifier|*
name|lp
decl_stmt|,
modifier|*
name|ap
decl_stmt|;
name|lp
operator|=
operator|(
name|DEV_LIST
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|DEV_LIST
argument_list|)
argument_list|,
name|M_DEVL
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|dev
argument_list|,
name|lp
argument_list|,
sizeof|sizeof
argument_list|(
name|DEV_LIST
argument_list|)
argument_list|)
expr_stmt|;
comment|/* create copied record */
if|if
condition|(
operator|*
name|list
condition|)
comment|/* list exists */
block|{
name|ap
operator|=
operator|*
name|list
expr_stmt|;
while|while
condition|(
name|ap
operator|->
name|next
condition|)
name|ap
operator|=
name|ap
operator|->
name|next
expr_stmt|;
comment|/* scoot to end of list */
name|lp
operator|->
name|prev
operator|=
name|ap
expr_stmt|;
name|lp
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|ap
operator|->
name|next
operator|=
name|lp
expr_stmt|;
block|}
else|else
block|{
comment|/* list does not yet exist */
operator|*
name|list
operator|=
name|lp
expr_stmt|;
name|lp
operator|->
name|prev
operator|=
name|lp
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
comment|/* list now exists */
block|}
block|}
end_function

begin_comment
comment|/**  ** Findspot  **  ** Finds the 'appropriate' place for (dev) in (list)  **  ** 'Appropriate' means in numeric order with other devices of the same type,  ** or in alphabetic order following a comment of the appropriate type.  ** or at the end of the list if an appropriate comment is not found. (this should  ** never happen)  ** (Note that the appropriate point is never the top, but may be the bottom)  **/
end_comment

begin_function
specifier|static
name|DEV_LIST
modifier|*
name|findspot
parameter_list|(
name|DEV_LIST
modifier|*
name|dev
parameter_list|,
name|DEV_LIST
modifier|*
name|list
parameter_list|)
block|{
name|DEV_LIST
modifier|*
name|ap
init|=
name|NULL
decl_stmt|;
comment|/* search for a previous instance of the same device */
if|if
condition|(
name|dev
operator|->
name|iobase
operator|!=
operator|-
literal|2
condition|)
comment|/* avoid PCI devices grouping with non-PCI devices */
block|{
for|for
control|(
name|ap
operator|=
name|list
init|;
name|ap
condition|;
name|ap
operator|=
name|ap
operator|->
name|next
control|)
block|{
if|if
condition|(
name|ap
operator|->
name|comment
operator|!=
name|DEV_DEVICE
condition|)
comment|/* ignore comments */
continue|continue;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
name|ap
operator|->
name|dev
argument_list|)
condition|)
comment|/* same base device */
block|{
if|if
condition|(
operator|(
name|dev
operator|->
name|unit
operator|<=
name|ap
operator|->
name|unit
operator|)
comment|/* belongs before (equal is bad) */
operator|||
operator|!
name|ap
operator|->
name|next
condition|)
comment|/* or end of list */
block|{
name|ap
operator|=
name|ap
operator|->
name|prev
expr_stmt|;
comment|/* back up one */
break|break;
comment|/* done here */
block|}
if|if
condition|(
name|ap
operator|->
name|next
condition|)
comment|/* if the next item exists */
block|{
if|if
condition|(
name|ap
operator|->
name|next
operator|->
name|comment
operator|!=
name|DEV_DEVICE
condition|)
comment|/* next is a comment */
break|break;
if|if
condition|(
name|strcmp
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
name|ap
operator|->
name|next
operator|->
name|dev
argument_list|)
condition|)
comment|/* next is a different device */
break|break;
block|}
block|}
block|}
block|}
if|if
condition|(
operator|!
name|ap
condition|)
comment|/* not sure yet */
block|{
comment|/* search for a class that the device might belong to */
for|for
control|(
name|ap
operator|=
name|list
init|;
name|ap
condition|;
name|ap
operator|=
name|ap
operator|->
name|next
control|)
block|{
if|if
condition|(
name|ap
operator|->
name|comment
operator|!=
name|DEV_DEVICE
condition|)
comment|/* look for simlar devices */
continue|continue;
if|if
condition|(
name|dev
operator|->
name|class
operator|!=
name|ap
operator|->
name|class
condition|)
comment|/* of same class too 8) */
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
name|ap
operator|->
name|dev
argument_list|)
operator|<
literal|0
condition|)
comment|/* belongs before the current entry */
block|{
name|ap
operator|=
name|ap
operator|->
name|prev
expr_stmt|;
comment|/* back up one */
break|break;
comment|/* done here */
block|}
if|if
condition|(
name|ap
operator|->
name|next
condition|)
comment|/* if the next item exists */
if|if
condition|(
name|ap
operator|->
name|next
operator|->
name|comment
operator|!=
name|DEV_DEVICE
condition|)
comment|/* next is a comment, go here */
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|ap
condition|)
comment|/* didn't find a match */
block|{
for|for
control|(
name|ap
operator|=
name|list
init|;
name|ap
operator|->
name|next
condition|;
name|ap
operator|=
name|ap
operator|->
name|next
control|)
comment|/* try for a matching comment */
if|if
condition|(
operator|(
name|ap
operator|->
name|comment
operator|!=
name|DEV_DEVICE
operator|)
operator|&&
operator|(
name|ap
operator|->
name|class
operator|==
name|dev
operator|->
name|class
operator|)
condition|)
comment|/* appropriate place? */
break|break;
block|}
comment|/* or just put up with last */
return|return
operator|(
name|ap
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  ** Insdev  **  ** Inserts a copy of (dev) at the appropriate point in (list)  **/
end_comment

begin_function
specifier|static
name|void
name|insdev
parameter_list|(
name|DEV_LIST
modifier|*
name|dev
parameter_list|,
name|DEV_LIST
modifier|*
name|list
parameter_list|)
block|{
name|DEV_LIST
modifier|*
name|lp
decl_stmt|,
modifier|*
name|ap
decl_stmt|;
name|lp
operator|=
operator|(
name|DEV_LIST
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|DEV_LIST
argument_list|)
argument_list|,
name|M_DEVL
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|dev
argument_list|,
name|lp
argument_list|,
sizeof|sizeof
argument_list|(
name|DEV_LIST
argument_list|)
argument_list|)
expr_stmt|;
comment|/* create copied record */
name|ap
operator|=
name|findspot
argument_list|(
name|lp
argument_list|,
name|list
argument_list|)
expr_stmt|;
comment|/* find appropriate spot */
name|lp
operator|->
name|next
operator|=
name|ap
operator|->
name|next
expr_stmt|;
comment|/* point to next */
if|if
condition|(
name|ap
operator|->
name|next
condition|)
name|ap
operator|->
name|next
operator|->
name|prev
operator|=
name|lp
expr_stmt|;
comment|/* point next to new */
name|lp
operator|->
name|prev
operator|=
name|ap
expr_stmt|;
comment|/* point new to current */
name|ap
operator|->
name|next
operator|=
name|lp
expr_stmt|;
comment|/* and current to new */
block|}
end_function

begin_comment
comment|/**  ** Movedev  **  ** Moves (dev) from its current list to an appropriate place in (list)  ** (dev) may not come from the top of a list, but it may from the bottom.  **/
end_comment

begin_function
specifier|static
name|void
name|movedev
parameter_list|(
name|DEV_LIST
modifier|*
name|dev
parameter_list|,
name|DEV_LIST
modifier|*
name|list
parameter_list|)
block|{
name|DEV_LIST
modifier|*
name|ap
decl_stmt|;
name|ap
operator|=
name|findspot
argument_list|(
name|dev
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|dev
operator|->
name|prev
operator|->
name|next
operator|=
name|dev
operator|->
name|next
expr_stmt|;
comment|/* remove from old list */
if|if
condition|(
name|dev
operator|->
name|next
condition|)
name|dev
operator|->
name|next
operator|->
name|prev
operator|=
name|dev
operator|->
name|prev
expr_stmt|;
name|dev
operator|->
name|next
operator|=
name|ap
operator|->
name|next
expr_stmt|;
comment|/* insert in new list */
if|if
condition|(
name|ap
operator|->
name|next
condition|)
name|ap
operator|->
name|next
operator|->
name|prev
operator|=
name|dev
expr_stmt|;
comment|/* point next to new */
name|dev
operator|->
name|prev
operator|=
name|ap
expr_stmt|;
comment|/* point new to current */
name|ap
operator|->
name|next
operator|=
name|dev
expr_stmt|;
comment|/* and current to new */
block|}
end_function

begin_comment
comment|/**  ** Initlist  **  ** Initialises (*list) with the basic headings  **/
end_comment

begin_function
specifier|static
name|void
name|initlist
parameter_list|(
name|DEV_LIST
modifier|*
modifier|*
name|list
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|devclass_names
index|[
name|i
index|]
operator|.
name|name
index|[
literal|0
index|]
condition|;
name|i
operator|++
control|)
comment|/* for each devtype name */
block|{
name|strcpy
argument_list|(
name|scratch
operator|.
name|name
argument_list|,
name|devclass_names
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|scratch
operator|.
name|comment
operator|=
name|DEV_ZOOMED
expr_stmt|;
name|scratch
operator|.
name|class
operator|=
name|devclass_names
index|[
name|i
index|]
operator|.
name|number
expr_stmt|;
name|scratch
operator|.
name|attrib
operator|=
name|FLG_MANDATORY
expr_stmt|;
comment|/* can't be moved */
name|addev
argument_list|(
operator|&
name|scratch
argument_list|,
name|list
argument_list|)
expr_stmt|;
comment|/* add to the list */
block|}
block|}
end_function

begin_comment
comment|/**  ** savelist  **  ** Walks (list) and saves the settings of any entry marked as changed.  **  ** The device's active field is set according to (active).  **  ** Builds the isa_devlist used by dset to extract the changed device information.  ** The code for this was taken almost verbatim from the original module.  **/
end_comment

begin_function
specifier|static
name|void
name|savelist
parameter_list|(
name|DEV_LIST
modifier|*
name|list
parameter_list|,
name|int
name|active
parameter_list|)
block|{
name|struct
name|isa_device
modifier|*
name|id_p
decl_stmt|,
modifier|*
name|id_pn
decl_stmt|;
while|while
condition|(
name|list
condition|)
block|{
if|if
condition|(
operator|(
name|list
operator|->
name|comment
operator|==
name|DEV_DEVICE
operator|)
operator|&&
name|list
operator|->
name|changed
condition|)
block|{
if|if
condition|(
operator|(
name|list
operator|->
name|iobase
operator|==
operator|-
literal|2
operator|)
operator|||
comment|/* is a PCI device; can't save */
operator|(
name|list
operator|->
name|device
operator|==
name|NULL
operator|)
condition|)
comment|/* no isa_device associated at all?! */
continue|continue;
name|setdev
argument_list|(
name|list
argument_list|,
name|active
argument_list|)
expr_stmt|;
comment|/* set the device itself */
name|id_pn
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|id_p
operator|=
name|isa_devlist
init|;
name|id_p
condition|;
name|id_p
operator|=
name|id_p
operator|->
name|id_next
control|)
block|{
comment|/* look on the list for it */
if|if
condition|(
name|id_p
operator|->
name|id_id
operator|==
name|list
operator|->
name|device
operator|->
name|id_id
condition|)
block|{
name|id_pn
operator|=
name|id_p
operator|->
name|id_next
expr_stmt|;
name|bcopy
argument_list|(
name|list
operator|->
name|device
argument_list|,
name|id_p
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|isa_device
argument_list|)
argument_list|)
expr_stmt|;
name|id_p
operator|->
name|id_next
operator|=
name|id_pn
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|id_pn
condition|)
comment|/* not already on the list */
block|{
name|id_pn
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|isa_device
argument_list|)
argument_list|,
name|M_DEVL
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|list
operator|->
name|device
argument_list|,
name|id_pn
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|isa_device
argument_list|)
argument_list|)
expr_stmt|;
name|id_pn
operator|->
name|id_next
operator|=
name|isa_devlist
expr_stmt|;
name|isa_devlist
operator|=
name|id_pn
expr_stmt|;
comment|/* park at top of list */
block|}
block|}
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  ** nukelist  **  ** Frees all storage in use by a (list).  **/
end_comment

begin_function
specifier|static
name|void
name|nukelist
parameter_list|(
name|DEV_LIST
modifier|*
name|list
parameter_list|)
block|{
name|DEV_LIST
modifier|*
name|dp
decl_stmt|;
if|if
condition|(
operator|!
name|list
condition|)
return|return;
while|while
condition|(
name|list
operator|->
name|prev
condition|)
comment|/* walk to head of list */
name|list
operator|=
name|list
operator|->
name|prev
expr_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|dp
operator|=
name|list
expr_stmt|;
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|dp
argument_list|,
name|M_DEVL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  ** prevent  **  ** Returns the previous entry in (list), skipping zoomed regions.  Returns NULL  ** if there is no previous entry. (Only possible if list->prev == NULL given the  ** premise that there is always a comment at the head of the list)  **/
end_comment

begin_function
specifier|static
name|DEV_LIST
modifier|*
name|prevent
parameter_list|(
name|DEV_LIST
modifier|*
name|list
parameter_list|)
block|{
name|DEV_LIST
modifier|*
name|dp
decl_stmt|;
if|if
condition|(
operator|!
name|list
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|dp
operator|=
name|list
operator|->
name|prev
expr_stmt|;
comment|/* start back one */
while|while
condition|(
name|dp
condition|)
block|{
if|if
condition|(
name|dp
operator|->
name|comment
operator|==
name|DEV_ZOOMED
condition|)
comment|/* previous section is zoomed */
return|return
operator|(
name|dp
operator|)
return|;
comment|/* so skip to comment */
if|if
condition|(
name|dp
operator|->
name|comment
operator|==
name|DEV_COMMENT
condition|)
comment|/* not zoomed */
return|return
operator|(
name|list
operator|->
name|prev
operator|)
return|;
comment|/* one back as normal */
name|dp
operator|=
name|dp
operator|->
name|prev
expr_stmt|;
comment|/* backpedal */
block|}
return|return
operator|(
name|dp
operator|)
return|;
comment|/* NULL, we can assume */
block|}
end_function

begin_comment
comment|/**  ** nextent  **  ** Returns the next entry in (list), skipping zoomed regions.  Returns NULL  ** if there is no next entry. (Possible if the current entry is last, or  ** if the current entry is the last heading and it's collapsed)  **/
end_comment

begin_function
specifier|static
name|DEV_LIST
modifier|*
name|nextent
parameter_list|(
name|DEV_LIST
modifier|*
name|list
parameter_list|)
block|{
name|DEV_LIST
modifier|*
name|dp
decl_stmt|;
if|if
condition|(
operator|!
name|list
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|list
operator|->
name|comment
operator|!=
name|DEV_ZOOMED
condition|)
comment|/* no reason to skip */
return|return
operator|(
name|list
operator|->
name|next
operator|)
return|;
name|dp
operator|=
name|list
operator|->
name|next
expr_stmt|;
while|while
condition|(
name|dp
condition|)
block|{
if|if
condition|(
name|dp
operator|->
name|comment
operator|!=
name|DEV_DEVICE
condition|)
comment|/* found another heading */
break|break;
name|dp
operator|=
name|dp
operator|->
name|next
expr_stmt|;
block|}
return|return
operator|(
name|dp
operator|)
return|;
comment|/* back we go */
block|}
end_function

begin_comment
comment|/**  ** ofsent  **  ** Returns the (ofs)th entry down from (list), or NULL if it doesn't exist   **/
end_comment

begin_function
specifier|static
name|DEV_LIST
modifier|*
name|ofsent
parameter_list|(
name|int
name|ofs
parameter_list|,
name|DEV_LIST
modifier|*
name|list
parameter_list|)
block|{
while|while
condition|(
name|ofs
operator|--
operator|&&
name|list
condition|)
name|list
operator|=
name|nextent
argument_list|(
name|list
argument_list|)
expr_stmt|;
return|return
operator|(
name|list
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  ** findconflict  **  ** Scans every element of (list) and sets the conflict tags appropriately  ** Returns the number of conflicts found.  **/
end_comment

begin_function
specifier|static
name|int
name|findconflict
parameter_list|(
name|DEV_LIST
modifier|*
name|list
parameter_list|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
comment|/* number of conflicts found */
name|DEV_LIST
modifier|*
name|dp
decl_stmt|,
modifier|*
name|sp
decl_stmt|;
for|for
control|(
name|dp
operator|=
name|list
init|;
name|dp
condition|;
name|dp
operator|=
name|dp
operator|->
name|next
control|)
comment|/* over the whole list */
block|{
if|if
condition|(
name|dp
operator|->
name|comment
operator|!=
name|DEV_DEVICE
condition|)
comment|/* comments don't usually conflict */
continue|continue;
if|if
condition|(
name|dp
operator|->
name|iobase
operator|==
operator|-
literal|2
condition|)
comment|/* it's a PCI device, not interested */
continue|continue;
name|dp
operator|->
name|conflicts
operator|=
literal|0
expr_stmt|;
comment|/* assume the best */
for|for
control|(
name|sp
operator|=
name|list
init|;
name|sp
condition|;
name|sp
operator|=
name|sp
operator|->
name|next
control|)
comment|/* scan the entire list for conflicts */
block|{
if|if
condition|(
name|sp
operator|->
name|comment
operator|!=
name|DEV_DEVICE
condition|)
comment|/* likewise */
continue|continue;
if|if
condition|(
name|dp
operator|->
name|iobase
operator|==
operator|-
literal|2
condition|)
comment|/* it's a PCI device, not interested */
continue|continue;
if|if
condition|(
name|sp
operator|==
name|dp
condition|)
comment|/* always conflict with itself */
continue|continue;
if|if
condition|(
name|sp
operator|->
name|conflict_ok
operator|&&
name|dp
operator|->
name|conflict_ok
condition|)
continue|continue;
comment|/* both allowed to conflict */
if|if
condition|(
operator|(
name|dp
operator|->
name|iobase
operator|>
literal|0
operator|)
operator|&&
comment|/* iobase conflict? */
operator|(
name|dp
operator|->
name|iobase
operator|==
name|sp
operator|->
name|iobase
operator|)
condition|)
name|dp
operator|->
name|conflicts
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|dp
operator|->
name|irq
operator|>
literal|0
operator|)
operator|&&
comment|/* irq conflict? */
operator|(
name|dp
operator|->
name|irq
operator|==
name|sp
operator|->
name|irq
operator|)
condition|)
name|dp
operator|->
name|conflicts
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|dp
operator|->
name|drq
operator|>
literal|0
operator|)
operator|&&
comment|/* drq conflict? */
operator|(
name|dp
operator|->
name|drq
operator|==
name|sp
operator|->
name|drq
operator|)
condition|)
name|dp
operator|->
name|conflicts
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|dp
operator|->
name|maddr
operator|>
literal|0
operator|)
operator|&&
comment|/* maddr conflict? */
operator|(
name|dp
operator|->
name|maddr
operator|==
name|sp
operator|->
name|maddr
operator|)
condition|)
name|dp
operator|->
name|conflicts
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|dp
operator|->
name|msize
operator|>
literal|0
operator|)
operator|&&
comment|/* msize conflict? */
operator|(
name|dp
operator|->
name|msize
operator|==
name|sp
operator|->
name|msize
operator|)
condition|)
name|dp
operator|->
name|conflicts
operator|=
literal|1
expr_stmt|;
block|}
name|count
operator|+=
name|dp
operator|->
name|conflicts
expr_stmt|;
comment|/* count conflicts */
block|}
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  ** expandlist  **  ** Unzooms all headings in (list)  **/
end_comment

begin_function
specifier|static
name|void
name|expandlist
parameter_list|(
name|DEV_LIST
modifier|*
name|list
parameter_list|)
block|{
while|while
condition|(
name|list
condition|)
block|{
if|if
condition|(
name|list
operator|->
name|comment
operator|==
name|DEV_COMMENT
condition|)
name|list
operator|->
name|comment
operator|=
name|DEV_ZOOMED
expr_stmt|;
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  ** collapselist  **  ** Zooms all headings in (list)  **/
end_comment

begin_function
specifier|static
name|void
name|collapselist
parameter_list|(
name|DEV_LIST
modifier|*
name|list
parameter_list|)
block|{
while|while
condition|(
name|list
condition|)
block|{
if|if
condition|(
name|list
operator|->
name|comment
operator|==
name|DEV_ZOOMED
condition|)
name|list
operator|->
name|comment
operator|=
name|DEV_COMMENT
expr_stmt|;
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  ** Screen-manipulation stuff  **  ** This is the basic screen layout :  **  **     0    5   10   15   20   25   30   35   40   45   50   55   60   67   70   75  **     |....|....|....|....|....|....|....|....|....|....|....|....|....|....|....|....  **    +--------------------------------------------------------------------------------+  ** 0 -|---Active Drivers----------------------------xx Conflicts------Dev---IRQ--Port--|  ** 1 -| ........................                                    .......  ..  0x....|  ** 2 -| ........................                                    .......  ..  0x....|  ** 3 -| ........................                                    .......  ..  0x....|  ** 4 -| ........................                                    .......  ..  0x....|  ** 5 -| ........................                                    .......  ..  0x....|  ** 6 -| ........................                                    .......  ..  0x....|  ** 7 -| ........................                                    .......  ..  0x....|  ** 8 -| ........................                                    .......  ..  0x....|  ** 9 -|---Inactive Drivers--------------------------------------------Dev--------------|  ** 10-| ........................                                    .......            |  ** 11-| ........................                                    .......            |  ** 12-| ........................                                    .......            |  ** 13-| ........................                                    .......            |  ** 14-| ........................                                    .......            |  ** 15-| ........................                                    .......            |  ** 16-| ........................                                    .......            |  ** 17-|------------------------------------------------------UP-DOWN-------------------|  ** 18-| Relevant parameters for the current device                                     |  ** 19-|                                                                                |  ** 20-|                                                                                |  ** 21-|--------------------------------------------------------------------------------|  ** 22-| Help texts go here                                                             |  ** 23-|                                                                                |  **    +--------------------------------------------------------------------------------+  **  ** Help texts  **  ** On a collapsed comment :  **  ** [Enter] Expand device list      [z]   Expand all lists  ** [TAB]   Change fields           [Q]   Save and Exit  **  ** On an expanded comment :  **   ** [Enter] Collapse device list    [Z]   Collapse all lists  ** [TAB]   Change fields           [Q]   Save and Exit  **  ** On a comment with no followers  **  **   ** [TAB]   Change fields           [Q]   Save and Exit  **  ** On a device in the active list  **  ** [Enter] Edit device parameters  [DEL] Disable device  ** [TAB]   Change fields           [Q]   Save and Exit  **  ** On a device in the inactive list  **  ** [Enter] Enable device  ** [TAB]   Change fields           [Q]   Save and Exit  **  ** While editing parameters  **  **<parameter-specific help here>  ** [TAB]   Change fields           [Q]   Save device parameters  **/
end_comment

begin_comment
comment|/**  **  ** The base-level screen primitives :  **  ** bold()	- enter bold mode 		\E[1m     (md)  ** inverse()   - enter inverse mode 		\E[7m     (so)  ** normal()	- clear bold/inverse mode 	\E[m      (se)  ** clear()	- clear the screen 		\E[H\E[J  (ce)  ** move(x,y)	- move the cursor to x,y 	\E[y;xH:  (cm)  **/
end_comment

begin_function
specifier|static
name|void
name|bold
parameter_list|(
name|void
parameter_list|)
block|{
name|printf
argument_list|(
literal|"\033[1m"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|inverse
parameter_list|(
name|void
parameter_list|)
block|{
name|printf
argument_list|(
literal|"\033[7m"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|normal
parameter_list|(
name|void
parameter_list|)
block|{
name|printf
argument_list|(
literal|"\033[m"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|clear
parameter_list|(
name|void
parameter_list|)
block|{
name|normal
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"\033[H\033[J"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|move
parameter_list|(
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
block|{
name|printf
argument_list|(
literal|"\033[%d;%dH"
argument_list|,
name|y
operator|+
literal|1
argument_list|,
name|x
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  **  ** High-level screen primitives :  **   ** putxyl(x,y,str,len)	- put (len) bytes of (str) at (x,y), supports embedded formatting  ** putxy(x,y,str)	- put (str) at (x,y), supports embedded formatting  ** erase(x,y,w,h)	- clear the box (x,y,w,h)  ** txtbox(x,y,w,y,str) - put (str) in a region at (x,y,w,h)  ** putmsg(str)		- put (str) in the message area  ** puthelp(str)	- put (str) in the upper helpline  ** pad(str,len)	- pad (str) to (len) with spaces  ** drawline(row,detail,list,inverse,*dhelp)  **			- draws a line for (*list) at (row) onscreen.  If (detail) is   **			  nonzero, include port, IRQ and maddr, if (inverse) is nonzero,  **			  draw the line in inverse video, and display (*dhelp) on the  **                       helpline.  ** drawlist(row,num,detail,list)  **			- draw (num) entries from (list) at (row) onscreen, passile (detail)  **			  through to drawline().  ** showparams(dev)	- displays the relevant parameters for (dev) below the lists onscreen.  ** yesno(str)		- displays (str) in the message area, and returns nonzero on 'y' or 'Y'  ** redraw();		- Redraws the entire screen layout, including the   **			- two list panels.  **/
end_comment

begin_comment
comment|/**   ** putxy  **   writes (str) at x,y onscreen  ** putxyl  **   writes up to (len) of (str) at x,y onscreen.  **  ** Supports embedded formatting :  ** !i - inverse mode.  ** !b - bold mode.  ** !n - normal mode.  **/
end_comment

begin_function
specifier|static
name|void
name|putxyl
parameter_list|(
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|char
modifier|*
name|str
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|move
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|normal
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|str
operator|)
operator|&&
operator|(
name|len
operator|--
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|str
operator|==
literal|'!'
condition|)
comment|/* format escape? */
block|{
switch|switch
condition|(
operator|*
operator|(
name|str
operator|+
literal|1
operator|)
condition|)
comment|/* depending on the next character */
block|{
case|case
literal|'i'
case|:
name|inverse
argument_list|()
expr_stmt|;
name|str
operator|+=
literal|2
expr_stmt|;
comment|/* skip formatting */
name|len
operator|++
expr_stmt|;
comment|/* doesn't count for length */
break|break;
case|case
literal|'b'
case|:
name|bold
argument_list|()
expr_stmt|;
name|str
operator|+=
literal|2
expr_stmt|;
comment|/* skip formatting */
name|len
operator|++
expr_stmt|;
comment|/* doesn't count for length */
break|break;
case|case
literal|'n'
case|:
name|normal
argument_list|()
expr_stmt|;
name|str
operator|+=
literal|2
expr_stmt|;
comment|/* skip formatting */
name|len
operator|++
expr_stmt|;
comment|/* doesn't count for length */
break|break;
default|default:
name|putchar
argument_list|(
operator|*
name|str
operator|++
argument_list|)
expr_stmt|;
comment|/* not an escape */
block|}
block|}
else|else
block|{
name|putchar
argument_list|(
operator|*
name|str
operator|++
argument_list|)
expr_stmt|;
comment|/* emit the character */
block|}
block|}
block|}
end_function

begin_define
define|#
directive|define
name|putxy
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|str
parameter_list|)
value|putxyl(x,y,str,-1)
end_define

begin_comment
comment|/**  ** erase  **  ** Erases the region (x,y,w,h)  **/
end_comment

begin_function
specifier|static
name|void
name|erase
parameter_list|(
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|normal
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|h
condition|;
name|i
operator|++
control|)
name|putxyl
argument_list|(
name|x
argument_list|,
name|y
operator|++
argument_list|,
name|spaces
argument_list|,
name|w
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**   ** txtbox  **  ** Writes (str) into the region (x,y,w,h), supports embedded formatting using  ** putxy.  Lines are not wrapped, newlines must be forced with \n.  **/
end_comment

begin_function
specifier|static
name|void
name|txtbox
parameter_list|(
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|w
parameter_list|,
name|int
name|h
parameter_list|,
name|char
modifier|*
name|str
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|h
operator|--
expr_stmt|;
while|while
condition|(
operator|(
name|str
index|[
name|i
index|]
operator|)
operator|&&
name|h
condition|)
block|{
if|if
condition|(
name|str
index|[
name|i
index|]
operator|==
literal|'\n'
condition|)
comment|/* newline */
block|{
name|putxyl
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|str
argument_list|,
operator|(
name|i
operator|<
name|w
operator|)
condition|?
name|i
else|:
name|w
argument_list|)
expr_stmt|;
comment|/* write lesser of i or w */
name|y
operator|++
expr_stmt|;
comment|/* move down */
name|h
operator|--
expr_stmt|;
comment|/* room for one less */
name|str
operator|+=
operator|(
name|i
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* skip first newline */
name|i
operator|=
literal|0
expr_stmt|;
comment|/* zero offset */
block|}
else|else
block|{
name|i
operator|++
expr_stmt|;
comment|/* next character */
block|}
block|}
if|if
condition|(
name|h
condition|)
comment|/* end of string, not region */
name|putxyl
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|str
argument_list|,
name|w
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  ** putmsg  **  ** writes (msg) in the helptext area  **/
end_comment

begin_function
specifier|static
name|void
name|putmsg
parameter_list|(
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|erase
argument_list|(
literal|0
argument_list|,
literal|18
argument_list|,
literal|80
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|/* clear area */
name|txtbox
argument_list|(
literal|0
argument_list|,
literal|18
argument_list|,
literal|80
argument_list|,
literal|3
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  ** puthelp  **  ** Writes (msg) in the helpline area  **/
end_comment

begin_function
specifier|static
name|void
name|puthelp
parameter_list|(
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|erase
argument_list|(
literal|0
argument_list|,
literal|22
argument_list|,
literal|80
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|putxy
argument_list|(
literal|0
argument_list|,
literal|22
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  ** masterhelp  **  ** Draws the help message at the bottom of the screen  **/
end_comment

begin_function
specifier|static
name|void
name|masterhelp
parameter_list|(
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|erase
argument_list|(
literal|0
argument_list|,
literal|23
argument_list|,
literal|80
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|putxy
argument_list|(
literal|0
argument_list|,
literal|23
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  ** pad   **  ** space-pads a (str) to (len) characters  **/
end_comment

begin_function
specifier|static
name|void
name|pad
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|str
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
comment|/* find the end of the string */
empty_stmt|;
if|if
condition|(
name|i
operator|>=
name|len
condition|)
comment|/* no padding needed */
return|return;
while|while
condition|(
name|i
operator|<
name|len
condition|)
comment|/* pad */
name|str
index|[
name|i
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
name|str
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  ** drawline  **  ** Displays entry (ofs) of (list) in region at (row) onscreen, optionally displaying  ** the port and IRQ fields if (detail) is nonzero.  If (inverse), in inverse video.  **  ** The text (dhelp) is displayed if the item is a normal device, otherwise  ** help is shown for normal or zoomed comments  **/
end_comment

begin_function
specifier|static
name|void
name|drawline
parameter_list|(
name|int
name|row
parameter_list|,
name|int
name|detail
parameter_list|,
name|DEV_LIST
modifier|*
name|list
parameter_list|,
name|int
name|inverse
parameter_list|,
name|char
modifier|*
name|dhelp
parameter_list|)
block|{
name|char
name|lbuf
index|[
literal|90
index|]
decl_stmt|,
name|nb
index|[
literal|70
index|]
decl_stmt|,
name|db
index|[
literal|20
index|]
decl_stmt|,
name|ib
index|[
literal|16
index|]
decl_stmt|,
name|pb
index|[
literal|16
index|]
decl_stmt|;
if|if
condition|(
name|list
operator|->
name|comment
operator|==
name|DEV_DEVICE
condition|)
block|{
name|nb
index|[
literal|0
index|]
operator|=
literal|' '
expr_stmt|;
name|strncpy
argument_list|(
name|nb
operator|+
literal|1
argument_list|,
name|list
operator|->
name|name
argument_list|,
literal|57
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strncpy
argument_list|(
name|nb
argument_list|,
name|list
operator|->
name|name
argument_list|,
literal|58
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|list
operator|->
name|comment
operator|==
name|DEV_ZOOMED
operator|)
operator|&&
operator|(
name|list
operator|->
name|next
operator|)
condition|)
if|if
condition|(
name|list
operator|->
name|next
operator|->
name|comment
operator|==
name|DEV_DEVICE
condition|)
comment|/* only mention if there's something hidden */
name|strcat
argument_list|(
name|nb
argument_list|,
literal|"  (Collapsed)"
argument_list|)
expr_stmt|;
block|}
name|nb
index|[
literal|58
index|]
operator|=
literal|'\0'
expr_stmt|;
name|pad
argument_list|(
name|nb
argument_list|,
literal|60
argument_list|)
expr_stmt|;
if|if
condition|(
name|list
operator|->
name|conflicts
condition|)
comment|/* device in conflict? */
if|if
condition|(
name|inverse
condition|)
block|{
name|strcpy
argument_list|(
name|nb
operator|+
literal|54
argument_list|,
literal|" !nCONF!i "
argument_list|)
expr_stmt|;
comment|/* tag conflict, careful of length */
block|}
else|else
block|{
name|strcpy
argument_list|(
name|nb
operator|+
literal|54
argument_list|,
literal|" !iCONF!n "
argument_list|)
expr_stmt|;
comment|/* tag conflict, careful of length */
block|}
if|if
condition|(
name|list
operator|->
name|comment
operator|==
name|DEV_DEVICE
condition|)
block|{
name|sprintf
argument_list|(
name|db
argument_list|,
literal|"%s%d"
argument_list|,
name|list
operator|->
name|dev
argument_list|,
name|list
operator|->
name|unit
argument_list|)
expr_stmt|;
name|pad
argument_list|(
name|db
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strcpy
argument_list|(
name|db
argument_list|,
literal|"        "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|list
operator|->
name|irq
operator|>
literal|0
operator|)
operator|&&
name|detail
operator|&&
operator|(
name|list
operator|->
name|comment
operator|==
name|DEV_DEVICE
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|ib
argument_list|,
literal|" %d"
argument_list|,
name|list
operator|->
name|irq
argument_list|)
expr_stmt|;
name|pad
argument_list|(
name|ib
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strcpy
argument_list|(
name|ib
argument_list|,
literal|"    "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|list
operator|->
name|iobase
operator|>
literal|0
operator|)
operator|&&
name|detail
operator|&&
operator|(
name|list
operator|->
name|comment
operator|==
name|DEV_DEVICE
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|pb
argument_list|,
literal|"0x%x"
argument_list|,
name|list
operator|->
name|iobase
argument_list|)
expr_stmt|;
name|pad
argument_list|(
name|pb
argument_list|,
literal|7
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strcpy
argument_list|(
name|pb
argument_list|,
literal|"       "
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|lbuf
argument_list|,
literal|"  %s%s%s%s%s"
argument_list|,
name|inverse
condition|?
literal|"!i"
else|:
literal|""
argument_list|,
name|nb
argument_list|,
name|db
argument_list|,
name|ib
argument_list|,
name|pb
argument_list|)
expr_stmt|;
name|putxyl
argument_list|(
literal|0
argument_list|,
name|row
argument_list|,
name|lbuf
argument_list|,
literal|80
argument_list|)
expr_stmt|;
if|if
condition|(
name|dhelp
condition|)
block|{
switch|switch
condition|(
name|list
operator|->
name|comment
condition|)
block|{
case|case
name|DEV_DEVICE
case|:
comment|/* ordinary device */
name|puthelp
argument_list|(
name|dhelp
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEV_COMMENT
case|:
name|puthelp
argument_list|(
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|list
operator|->
name|next
condition|)
if|if
condition|(
name|list
operator|->
name|next
operator|->
name|comment
operator|==
name|DEV_DEVICE
condition|)
name|puthelp
argument_list|(
literal|"  [!bEnter!n] Collapse device list    [!bC!n]    Collapse all lists"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEV_ZOOMED
case|:
name|puthelp
argument_list|(
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|list
operator|->
name|next
condition|)
if|if
condition|(
name|list
operator|->
name|next
operator|->
name|comment
operator|==
name|DEV_DEVICE
condition|)
name|puthelp
argument_list|(
literal|"  [!bEnter!n] Expand device list      [!bX!n]    Expand all lists"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|puthelp
argument_list|(
literal|"  WARNING: This list entry corrupted!"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|move
argument_list|(
literal|0
argument_list|,
name|row
argument_list|)
expr_stmt|;
comment|/* put the cursor somewhere relevant */
block|}
end_function

begin_comment
comment|/**  ** drawlist  **  ** Displays (num) lines of the contents of (list) at (row), optionally displaying the  ** port and IRQ fields as well if (detail) is nonzero  **  ** printf in the kernel is essentially useless, so we do most of the hard work ourselves here.  **/
end_comment

begin_function
specifier|static
name|void
name|drawlist
parameter_list|(
name|int
name|row
parameter_list|,
name|int
name|num
parameter_list|,
name|int
name|detail
parameter_list|,
name|DEV_LIST
modifier|*
name|list
parameter_list|)
block|{
name|int
name|ofs
decl_stmt|;
for|for
control|(
name|ofs
operator|=
literal|0
init|;
name|ofs
operator|<
name|num
condition|;
name|ofs
operator|++
control|)
block|{
if|if
condition|(
name|list
condition|)
block|{
name|drawline
argument_list|(
name|row
operator|+
name|ofs
argument_list|,
name|detail
argument_list|,
name|list
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|list
operator|=
name|nextent
argument_list|(
name|list
argument_list|)
expr_stmt|;
comment|/* move down visible list */
block|}
else|else
block|{
name|erase
argument_list|(
literal|0
argument_list|,
name|row
operator|+
name|ofs
argument_list|,
literal|80
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  ** redrawactive  **  ** Redraws the active list   **/
end_comment

begin_function
specifier|static
name|void
name|redrawactive
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|cbuf
index|[
literal|16
index|]
decl_stmt|;
if|if
condition|(
name|conflicts
condition|)
block|{
name|sprintf
argument_list|(
name|cbuf
argument_list|,
literal|"!i%d conflict%s"
argument_list|,
name|conflicts
argument_list|,
operator|(
name|conflicts
operator|>
literal|1
operator|)
condition|?
literal|"s"
else|:
literal|""
argument_list|)
expr_stmt|;
name|putxy
argument_list|(
literal|45
argument_list|,
literal|0
argument_list|,
name|cbuf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putxyl
argument_list|(
literal|45
argument_list|,
literal|0
argument_list|,
name|lines
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
name|drawlist
argument_list|(
literal|1
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
name|alist
argument_list|)
expr_stmt|;
comment|/* draw device lists */
block|}
end_function

begin_comment
comment|/**  ** redrawinactive  **  ** Redraws the inactive list   **/
end_comment

begin_function
specifier|static
name|void
name|redrawinactive
parameter_list|(
name|void
parameter_list|)
block|{
name|drawlist
argument_list|(
literal|10
argument_list|,
literal|7
argument_list|,
literal|0
argument_list|,
name|ilist
argument_list|)
expr_stmt|;
comment|/* draw device lists */
block|}
end_function

begin_comment
comment|/**  ** redraw  **  ** Clear the screen and redraw the entire layout  **/
end_comment

begin_function
specifier|static
name|void
name|redraw
parameter_list|(
name|void
parameter_list|)
block|{
name|clear
argument_list|()
expr_stmt|;
name|putxy
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|lines
argument_list|)
expr_stmt|;
name|putxy
argument_list|(
literal|3
argument_list|,
literal|0
argument_list|,
literal|"!bActive!n-!bDrivers"
argument_list|)
expr_stmt|;
name|putxy
argument_list|(
literal|63
argument_list|,
literal|0
argument_list|,
literal|"!bDev!n---!bIRQ!n--!bPort"
argument_list|)
expr_stmt|;
name|putxy
argument_list|(
literal|0
argument_list|,
literal|9
argument_list|,
name|lines
argument_list|)
expr_stmt|;
name|putxy
argument_list|(
literal|3
argument_list|,
literal|9
argument_list|,
literal|"!bInactive!n-!bDrivers"
argument_list|)
expr_stmt|;
name|putxy
argument_list|(
literal|63
argument_list|,
literal|9
argument_list|,
literal|"!bDev"
argument_list|)
expr_stmt|;
name|putxy
argument_list|(
literal|0
argument_list|,
literal|17
argument_list|,
name|lines
argument_list|)
expr_stmt|;
name|putxy
argument_list|(
literal|0
argument_list|,
literal|21
argument_list|,
name|lines
argument_list|)
expr_stmt|;
name|masterhelp
argument_list|(
literal|"  [!bTAB!n]   Change fields           [!bQ!n]   Save and Exit"
argument_list|)
expr_stmt|;
name|redrawactive
argument_list|()
expr_stmt|;
name|redrawinactive
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  ** yesnocancel  **  ** Put (str) in the message area, and return 1 if the user hits 'y' or 'Y',  ** 2 if they hit 'c' or 'C',  or 0 for 'n' or 'N'.  **/
end_comment

begin_function
specifier|static
name|int
name|yesnocancel
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|putmsg
argument_list|(
name|str
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
switch|switch
condition|(
name|getchar
argument_list|()
condition|)
block|{
case|case
operator|-
literal|1
case|:
case|case
literal|'n'
case|:
case|case
literal|'N'
case|:
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|'y'
case|:
case|case
literal|'Y'
case|:
return|return
operator|(
literal|1
operator|)
return|;
case|case
literal|'c'
case|:
case|case
literal|'C'
case|:
return|return
operator|(
literal|2
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/**  ** showparams  **  ** Show device parameters in the region below the lists  **  **     0    5   10   15   20   25   30   35   40   45   50   55   60   67   70   75  **     |....|....|....|....|....|....|....|....|....|....|....|....|....|....|....|....  **    +--------------------------------------------------------------------------------+  ** 17-|--------------------------------------------------------------------------------|  ** 18-| Port address : 0x0000     Memory address : 0x00000   Conflict allowed          |  ** 19-| IRQ number   : 00         Memory size    : 0x0000                              |  ** 20-| Flags        : 0x0000     DRQ number     : 00                                  |  ** 21-|--------------------------------------------------------------------------------|  **/
end_comment

begin_function
specifier|static
name|void
name|showparams
parameter_list|(
name|DEV_LIST
modifier|*
name|dev
parameter_list|)
block|{
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
name|erase
argument_list|(
literal|0
argument_list|,
literal|18
argument_list|,
literal|80
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|/* clear area */
if|if
condition|(
operator|!
name|dev
condition|)
return|return;
if|if
condition|(
name|dev
operator|->
name|comment
operator|!=
name|DEV_DEVICE
condition|)
return|return;
if|if
condition|(
name|dev
operator|->
name|iobase
operator|>
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"Port address : 0x%x"
argument_list|,
name|dev
operator|->
name|iobase
argument_list|)
expr_stmt|;
name|putxy
argument_list|(
literal|1
argument_list|,
literal|18
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|dev
operator|->
name|iobase
operator|==
operator|-
literal|2
condition|)
comment|/* a PCI device */
name|putmsg
argument_list|(
literal|" PCI devices are automatically configured."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dev
operator|->
name|irq
operator|>
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"IRQ number   : %d"
argument_list|,
name|dev
operator|->
name|irq
argument_list|)
expr_stmt|;
name|putxy
argument_list|(
literal|1
argument_list|,
literal|19
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"Flags        : 0x%x"
argument_list|,
name|dev
operator|->
name|flags
argument_list|)
expr_stmt|;
name|putxy
argument_list|(
literal|1
argument_list|,
literal|20
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|maddr
operator|>
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"Memory address : 0x%x"
argument_list|,
name|dev
operator|->
name|maddr
argument_list|)
expr_stmt|;
name|putxy
argument_list|(
literal|26
argument_list|,
literal|18
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dev
operator|->
name|msize
operator|>
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"Memory size    : 0x%x"
argument_list|,
name|dev
operator|->
name|msize
argument_list|)
expr_stmt|;
name|putxy
argument_list|(
literal|26
argument_list|,
literal|19
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dev
operator|->
name|drq
operator|>
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"DRQ number     : %d"
argument_list|,
name|dev
operator|->
name|drq
argument_list|)
expr_stmt|;
name|putxy
argument_list|(
literal|26
argument_list|,
literal|20
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dev
operator|->
name|conflict_ok
condition|)
name|putxy
argument_list|(
literal|54
argument_list|,
literal|18
argument_list|,
literal|"Conflict allowed"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  ** Editing functions for device parameters  **  ** editval(x,y,width,hex,min,max,val)	- Edit (*val) in a field (width) wide at (x,y)  **					  onscreen.  Refuse values outsise (min) and (max).  ** editparams(dev)			- Edit the parameters for (dev)  **/
end_comment

begin_define
define|#
directive|define
name|VetRet
parameter_list|(
name|code
parameter_list|)
define|\
value|{									\     if ((i>= min)&& (i<= max))
comment|/* legit? */
value|\     {									\ 	*val = i;							\ 	sprintf(buf,hex?"0x%x":"%d",i);					\ 	putxy(hex?x-2:x,y,buf);						\ 	return(code);
comment|/* all done and exit */
value|\     }									\     i = *val;
comment|/* restore original value */
value|\     delta = 1;
comment|/* restore other stuff */
value|\ }
end_define

begin_comment
comment|/**  ** editval  **  ** Edit (*val) at (x,y) in (hex)?hex:decimal mode, allowing values between (min) and (max)  ** in a field (width) wide. (Allow one space)  ** If (ro) is set, we're in "readonly" mode, so disallow edits.  **  ** Return KEY_TAB on \t, KEY_EXIT on 'q'  **/
end_comment

begin_function
specifier|static
name|int
name|editval
parameter_list|(
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|hex
parameter_list|,
name|int
name|min
parameter_list|,
name|int
name|max
parameter_list|,
name|int
modifier|*
name|val
parameter_list|,
name|int
name|ro
parameter_list|)
block|{
name|int
name|i
init|=
operator|*
name|val
decl_stmt|;
comment|/* work with copy of the value */
name|char
name|buf
index|[
literal|10
index|]
decl_stmt|,
name|tc
index|[
literal|8
index|]
decl_stmt|;
comment|/* display buffer, text copy */
name|int
name|xp
init|=
literal|0
decl_stmt|;
comment|/* cursor offset into text copy */
name|int
name|delta
init|=
literal|1
decl_stmt|;
comment|/* force redraw first time in */
name|int
name|c
decl_stmt|;
name|int
name|extended
init|=
literal|0
decl_stmt|;
comment|/* stage counter for extended key sequences */
if|if
condition|(
name|hex
condition|)
comment|/* we presume there's a leading 0x onscreen */
name|putxy
argument_list|(
name|x
operator|-
literal|2
argument_list|,
name|y
argument_list|,
literal|"!i0x"
argument_list|)
expr_stmt|;
comment|/* coz there sure is now */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|delta
condition|)
comment|/* only update if necessary */
block|{
name|sprintf
argument_list|(
name|tc
argument_list|,
name|hex
condition|?
literal|"%x"
else|:
literal|"%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* make a text copy of the value */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"!i%s"
argument_list|,
name|tc
argument_list|)
expr_stmt|;
comment|/* format for printing */
name|erase
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|width
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* clear the area */
name|putxy
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* write */
name|xp
operator|=
name|strlen
argument_list|(
name|tc
argument_list|)
expr_stmt|;
comment|/* cursor always at end */
name|move
argument_list|(
name|x
operator|+
name|xp
argument_list|,
name|y
argument_list|)
expr_stmt|;
comment|/* position the cursor */
block|}
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|extended
condition|)
comment|/* escape handling */
block|{
case|case
literal|0
case|:
if|if
condition|(
name|c
operator|==
literal|0x1b
condition|)
comment|/* esc? */
block|{
name|extended
operator|=
literal|1
expr_stmt|;
comment|/* flag and spin */
continue|continue;
block|}
name|extended
operator|=
literal|0
expr_stmt|;
break|break;
comment|/* nope, drop through */
case|case
literal|1
case|:
comment|/* there was an escape prefix */
if|if
condition|(
name|c
operator|==
literal|'['
operator|||
name|c
operator|==
literal|'O'
condition|)
comment|/* second character in sequence */
block|{
name|extended
operator|=
literal|2
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
literal|0x1b
condition|)
return|return
operator|(
name|KEY_EXIT
operator|)
return|;
comment|/* double esc exits */
name|extended
operator|=
literal|0
expr_stmt|;
break|break;
comment|/* nup, not a sequence. */
case|case
literal|2
case|:
name|extended
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
comment|/* looks like the real McCoy */
block|{
case|case
literal|'A'
case|:
name|VetRet
argument_list|(
name|KEY_UP
argument_list|)
expr_stmt|;
comment|/* leave if OK */
continue|continue;
case|case
literal|'B'
case|:
name|VetRet
argument_list|(
name|KEY_DOWN
argument_list|)
expr_stmt|;
comment|/* leave if OK */
continue|continue;
case|case
literal|'C'
case|:
name|VetRet
argument_list|(
name|KEY_RIGHT
argument_list|)
expr_stmt|;
comment|/* leave if OK */
continue|continue;
case|case
literal|'D'
case|:
name|VetRet
argument_list|(
name|KEY_LEFT
argument_list|)
expr_stmt|;
comment|/* leave if OK */
continue|continue;
default|default:
continue|continue;
block|}
block|}
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\t'
case|:
comment|/* trying to tab off */
name|VetRet
argument_list|(
name|KEY_TAB
argument_list|)
expr_stmt|;
comment|/* verify and maybe return */
break|break;
case|case
operator|-
literal|1
case|:
case|case
literal|'q'
case|:
case|case
literal|'Q'
case|:
name|VetRet
argument_list|(
name|KEY_EXIT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\b'
case|:
case|case
literal|'\177'
case|:
comment|/* BS or DEL */
if|if
condition|(
name|ro
condition|)
comment|/* readonly? */
block|{
name|puthelp
argument_list|(
literal|" !iThis value cannot be edited (Press ESC)"
argument_list|)
expr_stmt|;
while|while
condition|(
name|getchar
argument_list|()
operator|!=
literal|0x1b
condition|)
empty_stmt|;
comment|/* wait for key */
return|return
operator|(
name|KEY_NULL
operator|)
return|;
comment|/* spin */
block|}
if|if
condition|(
name|xp
condition|)
comment|/* still something left to delete */
block|{
name|i
operator|=
name|i
operator|/
operator|(
name|hex
condition|?
literal|0x10
else|:
literal|10
operator|)
expr_stmt|;
comment|/* strip last digit */
name|delta
operator|=
literal|1
expr_stmt|;
comment|/* force update */
block|}
break|break;
case|case
literal|588
case|:
name|VetRet
argument_list|(
name|KEY_UP
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
case|case
literal|'\n'
case|:
case|case
literal|596
case|:
name|VetRet
argument_list|(
name|KEY_DOWN
argument_list|)
expr_stmt|;
break|break;
case|case
literal|591
case|:
name|VetRet
argument_list|(
name|KEY_LEFT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|593
case|:
name|VetRet
argument_list|(
name|KEY_RIGHT
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|ro
condition|)
comment|/* readonly? */
block|{
name|puthelp
argument_list|(
literal|" !iThis value cannot be edited (Press ESC)"
argument_list|)
expr_stmt|;
while|while
condition|(
name|getchar
argument_list|()
operator|!=
literal|0x1b
condition|)
empty_stmt|;
comment|/* wait for key */
return|return
operator|(
name|KEY_NULL
operator|)
return|;
comment|/* spin */
block|}
if|if
condition|(
name|xp
operator|>=
name|width
condition|)
comment|/* no room for more characters anyway */
break|break;
if|if
condition|(
name|hex
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
name|c
operator|<=
literal|'9'
operator|)
condition|)
block|{
name|i
operator|=
name|i
operator|*
literal|0x10
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
comment|/* update value */
name|delta
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|c
operator|>=
literal|'a'
operator|)
operator|&&
operator|(
name|c
operator|<=
literal|'f'
operator|)
condition|)
block|{
name|i
operator|=
name|i
operator|*
literal|0x10
operator|+
operator|(
name|c
operator|-
literal|'a'
operator|+
literal|0xa
operator|)
expr_stmt|;
name|delta
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|c
operator|>=
literal|'A'
operator|)
operator|&&
operator|(
name|c
operator|<=
literal|'F'
operator|)
condition|)
block|{
name|i
operator|=
name|i
operator|*
literal|0x10
operator|+
operator|(
name|c
operator|-
literal|'A'
operator|+
literal|0xa
operator|)
expr_stmt|;
name|delta
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|c
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
name|c
operator|<=
literal|'9'
operator|)
condition|)
block|{
name|i
operator|=
name|i
operator|*
literal|10
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
comment|/* update value */
name|delta
operator|=
literal|1
expr_stmt|;
comment|/* force redraw */
break|break;
block|}
block|}
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  ** editparams  **  ** Edit the parameters for (dev)  **  ** Note that it's _always_ possible to edit the flags, otherwise it might be  ** possible for this to spin in an endless loop...  **     0    5   10   15   20   25   30   35   40   45   50   55   60   67   70   75  **     |....|....|....|....|....|....|....|....|....|....|....|....|....|....|....|....  **    +--------------------------------------------------------------------------------+  ** 17-|--------------------------------------------------------------------------------|  ** 18-| Port address : 0x0000     Memory address : 0x00000   Conflict allowed          |  ** 19-| IRQ number   : 00         Memory size    : 0x0000                              |  ** 20-| Flags        : 0x0000     DRQ number     : 00                                  |  ** 21-|--------------------------------------------------------------------------------|  **  ** The "intelligence" in this function that hops around based on the directional  ** returns from editval isn't very smart, and depends on the layout above.  **/
end_comment

begin_function
specifier|static
name|void
name|editparams
parameter_list|(
name|DEV_LIST
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|char
name|buf
index|[
literal|16
index|]
decl_stmt|;
comment|/* needs to fit the device name */
name|putxy
argument_list|(
literal|2
argument_list|,
literal|17
argument_list|,
literal|"!bParameters!n-!bfor!n-!bdevice!n-"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"!b%s"
argument_list|,
name|dev
operator|->
name|dev
argument_list|)
expr_stmt|;
name|putxy
argument_list|(
literal|24
argument_list|,
literal|17
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|erase
argument_list|(
literal|1
argument_list|,
literal|22
argument_list|,
literal|80
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|ep_iobase
label|:
if|if
condition|(
name|dev
operator|->
name|iobase
operator|>
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|PC98
name|puthelp
argument_list|(
literal|"  IO Port address (Hexadecimal, 0x1-0xffff)"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|editval
argument_list|(
literal|18
argument_list|,
literal|18
argument_list|,
literal|5
argument_list|,
literal|1
argument_list|,
literal|0x1
argument_list|,
literal|0xffff
argument_list|,
operator|&
operator|(
name|dev
operator|->
name|iobase
operator|)
argument_list|,
operator|(
name|dev
operator|->
name|attrib
operator|&
name|FLG_FIXIOBASE
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|puthelp
argument_list|(
literal|"  IO Port address (Hexadecimal, 0x1-0x2000)"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|editval
argument_list|(
literal|18
argument_list|,
literal|18
argument_list|,
literal|5
argument_list|,
literal|1
argument_list|,
literal|0x1
argument_list|,
literal|0x2000
argument_list|,
operator|&
operator|(
name|dev
operator|->
name|iobase
operator|)
argument_list|,
operator|(
name|dev
operator|->
name|attrib
operator|&
name|FLG_FIXIOBASE
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|ret
condition|)
block|{
case|case
name|KEY_EXIT
case|:
goto|goto
name|ep_exit
goto|;
case|case
name|KEY_RIGHT
case|:
if|if
condition|(
name|dev
operator|->
name|maddr
operator|>
literal|0
condition|)
goto|goto
name|ep_maddr
goto|;
break|break;
case|case
name|KEY_TAB
case|:
case|case
name|KEY_DOWN
case|:
goto|goto
name|ep_irq
goto|;
block|}
goto|goto
name|ep_iobase
goto|;
block|}
name|ep_irq
label|:
if|if
condition|(
name|dev
operator|->
name|irq
operator|>
literal|0
condition|)
block|{
name|puthelp
argument_list|(
literal|"  Interrupt number (Decimal, 1-15)"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|editval
argument_list|(
literal|16
argument_list|,
literal|19
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|15
argument_list|,
operator|&
operator|(
name|dev
operator|->
name|irq
operator|)
argument_list|,
operator|(
name|dev
operator|->
name|attrib
operator|&
name|FLG_FIXIRQ
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ret
condition|)
block|{
case|case
name|KEY_EXIT
case|:
goto|goto
name|ep_exit
goto|;
case|case
name|KEY_RIGHT
case|:
if|if
condition|(
name|dev
operator|->
name|msize
operator|>
literal|0
condition|)
goto|goto
name|ep_msize
goto|;
break|break;
case|case
name|KEY_UP
case|:
if|if
condition|(
name|dev
operator|->
name|iobase
operator|>
literal|0
condition|)
goto|goto
name|ep_iobase
goto|;
break|break;
case|case
name|KEY_TAB
case|:
case|case
name|KEY_DOWN
case|:
goto|goto
name|ep_flags
goto|;
block|}
goto|goto
name|ep_irq
goto|;
block|}
name|ep_flags
label|:
name|puthelp
argument_list|(
literal|"  Device-specific flag values."
argument_list|)
expr_stmt|;
name|ret
operator|=
name|editval
argument_list|(
literal|18
argument_list|,
literal|20
argument_list|,
literal|5
argument_list|,
literal|1
argument_list|,
literal|0x0
argument_list|,
literal|0xffff
argument_list|,
operator|&
operator|(
name|dev
operator|->
name|flags
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ret
condition|)
block|{
case|case
name|KEY_EXIT
case|:
goto|goto
name|ep_exit
goto|;
case|case
name|KEY_RIGHT
case|:
if|if
condition|(
name|dev
operator|->
name|drq
operator|>
literal|0
condition|)
goto|goto
name|ep_drq
goto|;
break|break;
case|case
name|KEY_UP
case|:
if|if
condition|(
name|dev
operator|->
name|irq
operator|>
literal|0
condition|)
goto|goto
name|ep_irq
goto|;
if|if
condition|(
name|dev
operator|->
name|iobase
operator|>
literal|0
condition|)
goto|goto
name|ep_iobase
goto|;
break|break;
case|case
name|KEY_DOWN
case|:
if|if
condition|(
name|dev
operator|->
name|maddr
operator|>
literal|0
condition|)
goto|goto
name|ep_maddr
goto|;
if|if
condition|(
name|dev
operator|->
name|msize
operator|>
literal|0
condition|)
goto|goto
name|ep_msize
goto|;
if|if
condition|(
name|dev
operator|->
name|drq
operator|>
literal|0
condition|)
goto|goto
name|ep_drq
goto|;
break|break;
case|case
name|KEY_TAB
case|:
goto|goto
name|ep_maddr
goto|;
block|}
goto|goto
name|ep_flags
goto|;
name|ep_maddr
label|:
if|if
condition|(
name|dev
operator|->
name|maddr
operator|>
literal|0
condition|)
block|{
name|puthelp
argument_list|(
literal|"  Device memory start address (Hexadecimal, 0x1-0xfffff)"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|editval
argument_list|(
literal|45
argument_list|,
literal|18
argument_list|,
literal|6
argument_list|,
literal|1
argument_list|,
literal|0x1
argument_list|,
literal|0xfffff
argument_list|,
operator|&
operator|(
name|dev
operator|->
name|maddr
operator|)
argument_list|,
operator|(
name|dev
operator|->
name|attrib
operator|&
name|FLG_FIXMADDR
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ret
condition|)
block|{
case|case
name|KEY_EXIT
case|:
goto|goto
name|ep_exit
goto|;
case|case
name|KEY_LEFT
case|:
if|if
condition|(
name|dev
operator|->
name|iobase
operator|>
literal|0
condition|)
goto|goto
name|ep_iobase
goto|;
break|break;
case|case
name|KEY_UP
case|:
goto|goto
name|ep_flags
goto|;
case|case
name|KEY_DOWN
case|:
if|if
condition|(
name|dev
operator|->
name|msize
operator|>
literal|0
condition|)
goto|goto
name|ep_msize
goto|;
if|if
condition|(
name|dev
operator|->
name|drq
operator|>
literal|0
condition|)
goto|goto
name|ep_drq
goto|;
break|break;
case|case
name|KEY_TAB
case|:
goto|goto
name|ep_msize
goto|;
block|}
goto|goto
name|ep_maddr
goto|;
block|}
name|ep_msize
label|:
if|if
condition|(
name|dev
operator|->
name|msize
operator|>
literal|0
condition|)
block|{
name|puthelp
argument_list|(
literal|"  Device memory size (Hexadecimal, 0x1-0x10000)"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|editval
argument_list|(
literal|45
argument_list|,
literal|19
argument_list|,
literal|5
argument_list|,
literal|1
argument_list|,
literal|0x1
argument_list|,
literal|0x10000
argument_list|,
operator|&
operator|(
name|dev
operator|->
name|msize
operator|)
argument_list|,
operator|(
name|dev
operator|->
name|attrib
operator|&
name|FLG_FIXMSIZE
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ret
condition|)
block|{
case|case
name|KEY_EXIT
case|:
goto|goto
name|ep_exit
goto|;
case|case
name|KEY_LEFT
case|:
if|if
condition|(
name|dev
operator|->
name|irq
operator|>
literal|0
condition|)
goto|goto
name|ep_irq
goto|;
break|break;
case|case
name|KEY_UP
case|:
if|if
condition|(
name|dev
operator|->
name|maddr
operator|>
literal|0
condition|)
goto|goto
name|ep_maddr
goto|;
goto|goto
name|ep_flags
goto|;
case|case
name|KEY_DOWN
case|:
if|if
condition|(
name|dev
operator|->
name|drq
operator|>
literal|0
condition|)
goto|goto
name|ep_drq
goto|;
break|break;
case|case
name|KEY_TAB
case|:
goto|goto
name|ep_drq
goto|;
block|}
goto|goto
name|ep_msize
goto|;
block|}
name|ep_drq
label|:
if|if
condition|(
name|dev
operator|->
name|drq
operator|>
literal|0
condition|)
block|{
name|puthelp
argument_list|(
literal|"  Device DMA request number (Decimal, 1-7)"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|editval
argument_list|(
literal|43
argument_list|,
literal|20
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|7
argument_list|,
operator|&
operator|(
name|dev
operator|->
name|drq
operator|)
argument_list|,
operator|(
name|dev
operator|->
name|attrib
operator|&
name|FLG_FIXDRQ
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ret
condition|)
block|{
case|case
name|KEY_EXIT
case|:
goto|goto
name|ep_exit
goto|;
case|case
name|KEY_LEFT
case|:
goto|goto
name|ep_flags
goto|;
case|case
name|KEY_UP
case|:
if|if
condition|(
name|dev
operator|->
name|msize
operator|>
literal|0
condition|)
goto|goto
name|ep_msize
goto|;
if|if
condition|(
name|dev
operator|->
name|maddr
operator|>
literal|0
condition|)
goto|goto
name|ep_maddr
goto|;
goto|goto
name|ep_flags
goto|;
case|case
name|KEY_TAB
case|:
goto|goto
name|ep_iobase
goto|;
block|}
goto|goto
name|ep_drq
goto|;
block|}
block|}
name|ep_exit
label|:
name|dev
operator|->
name|changed
operator|=
literal|1
expr_stmt|;
comment|/* mark as changed */
block|}
end_function

begin_comment
comment|/**   ** High-level control functions  **/
end_comment

begin_comment
comment|/**  ** dolist  **  ** Handle user movement within (*list) in the region starting at (row) onscreen with  ** (num) lines, starting at (*ofs) offset from row onscreen.  ** Pass (detail) on to drawing routines.  **  ** If the user hits a key other than a cursor key, maybe return a code.  **  ** (*list) points to the device at the top line in the region, (*ofs) is the   ** position of the highlight within the region.  All routines below  ** this take only a device and an absolute row : use ofsent() to find the   ** device, and add (*ofs) to (row) to find the absolute row.  **/
end_comment

begin_function
specifier|static
name|int
name|dolist
parameter_list|(
name|int
name|row
parameter_list|,
name|int
name|num
parameter_list|,
name|int
name|detail
parameter_list|,
name|int
modifier|*
name|ofs
parameter_list|,
name|DEV_LIST
modifier|*
modifier|*
name|list
parameter_list|,
name|char
modifier|*
name|dhelp
parameter_list|)
block|{
name|int
name|extended
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|;
name|DEV_LIST
modifier|*
name|lp
decl_stmt|;
name|int
name|delta
init|=
literal|1
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|delta
condition|)
block|{
name|showparams
argument_list|(
name|ofsent
argument_list|(
operator|*
name|ofs
argument_list|,
operator|*
name|list
argument_list|)
argument_list|)
expr_stmt|;
comment|/* show device parameters */
name|drawline
argument_list|(
name|row
operator|+
operator|*
name|ofs
argument_list|,
name|detail
argument_list|,
name|ofsent
argument_list|(
operator|*
name|ofs
argument_list|,
operator|*
name|list
argument_list|)
argument_list|,
literal|1
argument_list|,
name|dhelp
argument_list|)
expr_stmt|;
comment|/* highlight current line */
name|delta
operator|=
literal|0
expr_stmt|;
block|}
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
comment|/* get a character */
if|if
condition|(
operator|(
name|extended
operator|==
literal|2
operator|)
operator|||
operator|(
name|c
operator|==
literal|588
operator|)
operator|||
operator|(
name|c
operator|==
literal|596
operator|)
condition|)
comment|/* console gives "alternative" codes */
block|{
name|extended
operator|=
literal|0
expr_stmt|;
comment|/* no longer */
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|588
case|:
comment|/* syscons' idea of 'up' */
case|case
literal|'A'
case|:
comment|/* up */
if|if
condition|(
operator|*
name|ofs
condition|)
comment|/* just a move onscreen */
block|{
name|drawline
argument_list|(
name|row
operator|+
operator|*
name|ofs
argument_list|,
name|detail
argument_list|,
name|ofsent
argument_list|(
operator|*
name|ofs
argument_list|,
operator|*
name|list
argument_list|)
argument_list|,
literal|0
argument_list|,
name|dhelp
argument_list|)
expr_stmt|;
comment|/* unhighlight current line */
operator|(
operator|*
name|ofs
operator|)
operator|--
expr_stmt|;
comment|/* move up */
block|}
else|else
block|{
name|lp
operator|=
name|prevent
argument_list|(
operator|*
name|list
argument_list|)
expr_stmt|;
comment|/* can we go up? */
if|if
condition|(
operator|!
name|lp
condition|)
comment|/* no */
break|break;
operator|*
name|list
operator|=
name|lp
expr_stmt|;
comment|/* yes, move up list */
name|drawlist
argument_list|(
name|row
argument_list|,
name|num
argument_list|,
name|detail
argument_list|,
operator|*
name|list
argument_list|)
expr_stmt|;
block|}
name|delta
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|596
case|:
comment|/* dooby-do */
case|case
literal|'B'
case|:
comment|/* down */
name|lp
operator|=
name|ofsent
argument_list|(
operator|*
name|ofs
argument_list|,
operator|*
name|list
argument_list|)
expr_stmt|;
comment|/* get current item */
if|if
condition|(
operator|!
name|nextent
argument_list|(
name|lp
argument_list|)
condition|)
break|break;
comment|/* nothing more to move to */
name|drawline
argument_list|(
name|row
operator|+
operator|*
name|ofs
argument_list|,
name|detail
argument_list|,
name|ofsent
argument_list|(
operator|*
name|ofs
argument_list|,
operator|*
name|list
argument_list|)
argument_list|,
literal|0
argument_list|,
name|dhelp
argument_list|)
expr_stmt|;
comment|/* unhighlight current line */
if|if
condition|(
operator|*
name|ofs
operator|<
operator|(
name|num
operator|-
literal|1
operator|)
condition|)
comment|/* room to move onscreen? */
block|{
operator|(
operator|*
name|ofs
operator|)
operator|++
expr_stmt|;
block|}
else|else
block|{
operator|*
name|list
operator|=
name|nextent
argument_list|(
operator|*
name|list
argument_list|)
expr_stmt|;
comment|/* scroll region down */
name|drawlist
argument_list|(
name|row
argument_list|,
name|num
argument_list|,
name|detail
argument_list|,
operator|*
name|list
argument_list|)
expr_stmt|;
block|}
name|delta
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\033'
case|:
name|extended
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'['
case|:
comment|/* cheat : always preceeds cursor move */
case|case
literal|'O'
case|:
comment|/* ANSI application key mode */
if|if
condition|(
name|extended
operator|==
literal|1
condition|)
name|extended
operator|=
literal|2
expr_stmt|;
else|else
name|extended
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'Q'
case|:
case|case
literal|'q'
case|:
return|return
operator|(
name|KEY_EXIT
operator|)
return|;
comment|/* user requests exit */
case|case
literal|'\r'
case|:
case|case
literal|'\n'
case|:
return|return
operator|(
name|KEY_DO
operator|)
return|;
comment|/* "do" something */
case|case
literal|'\b'
case|:
case|case
literal|'\177'
case|:
case|case
literal|599
case|:
return|return
operator|(
name|KEY_DEL
operator|)
return|;
comment|/* "delete" response */
case|case
literal|'X'
case|:
case|case
literal|'x'
case|:
return|return
operator|(
name|KEY_UNZOOM
operator|)
return|;
comment|/* expand everything */
case|case
literal|'C'
case|:
case|case
literal|'c'
case|:
return|return
operator|(
name|KEY_ZOOM
operator|)
return|;
comment|/* collapse everything */
case|case
literal|'\t'
case|:
name|drawline
argument_list|(
name|row
operator|+
operator|*
name|ofs
argument_list|,
name|detail
argument_list|,
name|ofsent
argument_list|(
operator|*
name|ofs
argument_list|,
operator|*
name|list
argument_list|)
argument_list|,
literal|0
argument_list|,
name|dhelp
argument_list|)
expr_stmt|;
comment|/* unhighlight current line */
return|return
operator|(
name|KEY_TAB
operator|)
return|;
comment|/* "move" response */
case|case
literal|'\014'
case|:
comment|/* ^L, redraw */
return|return
operator|(
name|KEY_REDRAW
operator|)
return|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/**  ** visuserconfig  **   ** Do the fullscreen config thang  **/
end_comment

begin_function
specifier|static
name|int
name|visuserconfig
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|actofs
init|=
literal|0
decl_stmt|,
name|inactofs
init|=
literal|0
decl_stmt|,
name|mode
init|=
literal|0
decl_stmt|,
name|ret
init|=
operator|-
literal|1
decl_stmt|,
name|i
decl_stmt|;
name|DEV_LIST
modifier|*
name|dp
decl_stmt|;
name|initlist
argument_list|(
operator|&
name|active
argument_list|)
expr_stmt|;
name|initlist
argument_list|(
operator|&
name|inactive
argument_list|)
expr_stmt|;
name|alist
operator|=
name|active
expr_stmt|;
name|ilist
operator|=
name|inactive
expr_stmt|;
name|getdevs
argument_list|()
expr_stmt|;
name|conflicts
operator|=
name|findconflict
argument_list|(
name|active
argument_list|)
expr_stmt|;
comment|/* find conflicts in the active list only */
name|redraw
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
literal|0
case|:
comment|/* active devices */
name|ret
operator|=
name|dolist
argument_list|(
literal|1
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|actofs
argument_list|,
operator|&
name|alist
argument_list|,
literal|"  [!bEnter!n] Edit device parameters  [!bDEL!n] Disable device"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ret
condition|)
block|{
case|case
name|KEY_TAB
case|:
name|mode
operator|=
literal|1
expr_stmt|;
comment|/* swap lists */
break|break;
case|case
name|KEY_REDRAW
case|:
name|redraw
argument_list|()
expr_stmt|;
break|break;
case|case
name|KEY_ZOOM
case|:
name|alist
operator|=
name|active
expr_stmt|;
name|actofs
operator|=
literal|0
expr_stmt|;
name|expandlist
argument_list|(
name|active
argument_list|)
expr_stmt|;
name|redrawactive
argument_list|()
expr_stmt|;
break|break;
case|case
name|KEY_UNZOOM
case|:
name|alist
operator|=
name|active
expr_stmt|;
name|actofs
operator|=
literal|0
expr_stmt|;
name|collapselist
argument_list|(
name|active
argument_list|)
expr_stmt|;
name|redrawactive
argument_list|()
expr_stmt|;
break|break;
case|case
name|KEY_DEL
case|:
name|dp
operator|=
name|ofsent
argument_list|(
name|actofs
argument_list|,
name|alist
argument_list|)
expr_stmt|;
comment|/* get current device */
if|if
condition|(
name|dp
condition|)
comment|/* paranoia... */
block|{
if|if
condition|(
name|dp
operator|->
name|attrib
operator|&
name|FLG_MANDATORY
condition|)
comment|/* can't be deleted */
break|break;
if|if
condition|(
name|dp
operator|==
name|alist
condition|)
comment|/* moving top item on list? */
block|{
if|if
condition|(
name|dp
operator|->
name|next
condition|)
block|{
name|alist
operator|=
name|dp
operator|->
name|next
expr_stmt|;
comment|/* point list to non-moving item */
block|}
else|else
block|{
name|alist
operator|=
name|dp
operator|->
name|prev
expr_stmt|;
comment|/* end of list, go back instead */
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|dp
operator|->
name|next
condition|)
comment|/* moving last item on list? */
name|actofs
operator|--
expr_stmt|;
block|}
name|dp
operator|->
name|conflicts
operator|=
literal|0
expr_stmt|;
comment|/* no conflicts on the inactive list */
name|movedev
argument_list|(
name|dp
argument_list|,
name|inactive
argument_list|)
expr_stmt|;
comment|/* shift to inactive list */
name|conflicts
operator|=
name|findconflict
argument_list|(
name|active
argument_list|)
expr_stmt|;
comment|/* update conflict tags */
name|dp
operator|->
name|changed
operator|=
literal|1
expr_stmt|;
name|redrawactive
argument_list|()
expr_stmt|;
comment|/* redraw */
name|redrawinactive
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|KEY_DO
case|:
comment|/* edit device parameters */
name|dp
operator|=
name|ofsent
argument_list|(
name|actofs
argument_list|,
name|alist
argument_list|)
expr_stmt|;
comment|/* get current device */
if|if
condition|(
name|dp
condition|)
comment|/* paranoia... */
block|{
if|if
condition|(
name|dp
operator|->
name|comment
operator|==
name|DEV_DEVICE
condition|)
comment|/* can't edit comments, zoom? */
block|{
if|if
condition|(
name|dp
operator|->
name|iobase
operator|!=
operator|-
literal|2
condition|)
comment|/* can't edit PCI devices */
block|{
name|masterhelp
argument_list|(
literal|"  [!bTAB!n]   Change fields           [!bQ!n]   Save device parameters"
argument_list|)
expr_stmt|;
name|editparams
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|masterhelp
argument_list|(
literal|"  [!bTAB!n]   Change fields           [!bQ!n]   Save and Exit"
argument_list|)
expr_stmt|;
name|putxy
argument_list|(
literal|0
argument_list|,
literal|17
argument_list|,
name|lines
argument_list|)
expr_stmt|;
name|conflicts
operator|=
name|findconflict
argument_list|(
name|active
argument_list|)
expr_stmt|;
comment|/* update conflict tags */
block|}
block|}
else|else
block|{
comment|/* DO on comment = zoom */
switch|switch
condition|(
name|dp
operator|->
name|comment
condition|)
comment|/* Depends on current state */
block|{
case|case
name|DEV_COMMENT
case|:
comment|/* not currently zoomed */
name|dp
operator|->
name|comment
operator|=
name|DEV_ZOOMED
expr_stmt|;
break|break;
case|case
name|DEV_ZOOMED
case|:
name|dp
operator|->
name|comment
operator|=
name|DEV_COMMENT
expr_stmt|;
break|break;
block|}
block|}
name|redrawactive
argument_list|()
expr_stmt|;
block|}
break|break;
block|}
break|break;
case|case
literal|1
case|:
comment|/* inactive devices */
name|ret
operator|=
name|dolist
argument_list|(
literal|10
argument_list|,
literal|7
argument_list|,
literal|0
argument_list|,
operator|&
name|inactofs
argument_list|,
operator|&
name|ilist
argument_list|,
literal|"  [!bEnter!n] Enable device                                   "
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ret
condition|)
block|{
case|case
name|KEY_TAB
case|:
name|mode
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|KEY_REDRAW
case|:
name|redraw
argument_list|()
expr_stmt|;
break|break;
case|case
name|KEY_ZOOM
case|:
name|ilist
operator|=
name|inactive
expr_stmt|;
name|inactofs
operator|=
literal|0
expr_stmt|;
name|expandlist
argument_list|(
name|inactive
argument_list|)
expr_stmt|;
name|redrawinactive
argument_list|()
expr_stmt|;
break|break;
case|case
name|KEY_UNZOOM
case|:
name|ilist
operator|=
name|inactive
expr_stmt|;
name|inactofs
operator|=
literal|0
expr_stmt|;
name|collapselist
argument_list|(
name|inactive
argument_list|)
expr_stmt|;
name|redrawinactive
argument_list|()
expr_stmt|;
break|break;
case|case
name|KEY_DO
case|:
name|dp
operator|=
name|ofsent
argument_list|(
name|inactofs
argument_list|,
name|ilist
argument_list|)
expr_stmt|;
comment|/* get current device */
if|if
condition|(
name|dp
condition|)
comment|/* paranoia... */
block|{
if|if
condition|(
name|dp
operator|->
name|comment
operator|==
name|DEV_DEVICE
condition|)
comment|/* can't move comments, zoom? */
block|{
if|if
condition|(
name|dp
operator|==
name|ilist
condition|)
comment|/* moving top of list? */
block|{
if|if
condition|(
name|dp
operator|->
name|next
condition|)
block|{
name|ilist
operator|=
name|dp
operator|->
name|next
expr_stmt|;
comment|/* point list to non-moving item */
block|}
else|else
block|{
name|ilist
operator|=
name|dp
operator|->
name|prev
expr_stmt|;
comment|/* can't go down, go up instead */
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|dp
operator|->
name|next
condition|)
comment|/* last entry on list? */
name|inactofs
operator|--
expr_stmt|;
comment|/* shift cursor up one */
block|}
name|movedev
argument_list|(
name|dp
argument_list|,
name|active
argument_list|)
expr_stmt|;
comment|/* shift to active list */
name|conflicts
operator|=
name|findconflict
argument_list|(
name|active
argument_list|)
expr_stmt|;
comment|/* update conflict tags */
name|dp
operator|->
name|changed
operator|=
literal|1
expr_stmt|;
name|alist
operator|=
name|dp
expr_stmt|;
comment|/* put at top and current */
name|actofs
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|dp
operator|->
name|comment
operator|==
name|DEV_DEVICE
condition|)
name|dp
operator|=
name|dp
operator|->
name|prev
expr_stmt|;
comment|/* forcibly unzoom section */
name|dp
operator|->
name|comment
operator|=
name|DEV_COMMENT
expr_stmt|;
name|mode
operator|=
literal|0
expr_stmt|;
comment|/* and swap modes to follow it */
block|}
else|else
block|{
comment|/* DO on comment = zoom */
switch|switch
condition|(
name|dp
operator|->
name|comment
condition|)
comment|/* Depends on current state */
block|{
case|case
name|DEV_COMMENT
case|:
comment|/* not currently zoomed */
name|dp
operator|->
name|comment
operator|=
name|DEV_ZOOMED
expr_stmt|;
break|break;
case|case
name|DEV_ZOOMED
case|:
name|dp
operator|->
name|comment
operator|=
name|DEV_COMMENT
expr_stmt|;
break|break;
block|}
block|}
name|redrawactive
argument_list|()
expr_stmt|;
comment|/* redraw */
name|redrawinactive
argument_list|()
expr_stmt|;
block|}
break|break;
default|default:
comment|/* nothing else relevant here */
break|break;
block|}
break|break;
default|default:
name|mode
operator|=
literal|0
expr_stmt|;
comment|/* shouldn't happen... */
block|}
if|if
condition|(
name|ret
operator|==
name|KEY_EXIT
condition|)
block|{
name|i
operator|=
name|yesnocancel
argument_list|(
literal|" Save these parameters before exiting? (Yes/No/Cancel) "
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|2
case|:
comment|/* cancel */
name|redraw
argument_list|()
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* save and exit */
name|savelist
argument_list|(
name|active
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|savelist
argument_list|(
name|inactive
argument_list|,
literal|0
argument_list|)
expr_stmt|;
case|case
literal|0
case|:
comment|/* exit */
name|nukelist
argument_list|(
name|active
argument_list|)
expr_stmt|;
comment|/* clean up after ourselves */
name|nukelist
argument_list|(
name|inactive
argument_list|)
expr_stmt|;
name|normal
argument_list|()
expr_stmt|;
name|clear
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VISUAL_USERCONFIG */
end_comment

begin_comment
comment|/*  * Copyright (c) 1991 Regents of the University of California.  * All rights reserved.  * Copyright (c) 1994 Jordan K. Hubbard  * All rights reserved.  * Copyright (c) 1994 David Greenman  * All rights reserved.  *  * Many additional changes by Bruce Evans  *  * This code is derived from software contributed by the  * University of California Berkeley, Jordan K. Hubbard,  * David Greenman and Bruce Evans.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *      This product includes software developed by the University of  *      California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *      $Id: userconfig.c,v 1.11 1996/11/02 10:39:03 asami Exp $  */
end_comment

begin_include
include|#
directive|include
file|"scbus.h"
end_include

begin_include
include|#
directive|include
file|<scsi/scsiconf.h>
end_include

begin_define
define|#
directive|define
name|PARM_DEVSPEC
value|0x1
end_define

begin_define
define|#
directive|define
name|PARM_INT
value|0x2
end_define

begin_define
define|#
directive|define
name|PARM_ADDR
value|0x3
end_define

begin_typedef
typedef|typedef
struct|struct
name|_cmdparm
block|{
name|int
name|type
decl_stmt|;
union|union
block|{
name|struct
name|isa_device
modifier|*
name|dparm
decl_stmt|;
name|int
name|iparm
decl_stmt|;
name|void
modifier|*
name|aparm
decl_stmt|;
block|}
name|parm
union|;
block|}
name|CmdParm
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|CmdFunc
function_decl|)
parameter_list|(
name|CmdParm
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|_cmd
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|CmdFunc
name|handler
decl_stmt|;
name|CmdParm
modifier|*
name|parms
decl_stmt|;
block|}
name|Cmd
typedef|;
end_typedef

begin_if
if|#
directive|if
name|NSCBUS
operator|>
literal|0
end_if

begin_function_decl
specifier|static
name|void
name|lsscsi
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|list_scsi
parameter_list|(
name|CmdParm
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|lsdevtab
parameter_list|(
name|struct
name|isa_device
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|isa_device
modifier|*
name|find_device
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|isa_device
modifier|*
name|search_devtable
parameter_list|(
name|struct
name|isa_device
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cngets
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Cmd
modifier|*
name|parse_cmd
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|parse_args
parameter_list|(
name|char
modifier|*
parameter_list|,
name|CmdParm
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|long
name|strtoul
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|save_dev
parameter_list|(
name|struct
name|isa_device
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|list_devices
parameter_list|(
name|CmdParm
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_device_ioaddr
parameter_list|(
name|CmdParm
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_device_irq
parameter_list|(
name|CmdParm
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_device_drq
parameter_list|(
name|CmdParm
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_device_iosize
parameter_list|(
name|CmdParm
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_device_mem
parameter_list|(
name|CmdParm
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_device_flags
parameter_list|(
name|CmdParm
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_device_enable
parameter_list|(
name|CmdParm
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_device_disable
parameter_list|(
name|CmdParm
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|quitfunc
parameter_list|(
name|CmdParm
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|helpfunc
parameter_list|(
name|CmdParm
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USERCONFIG_BOOT
argument_list|)
operator|&&
name|defined
argument_list|(
name|VISUAL_USERCONFIG
argument_list|)
end_if

begin_function_decl
specifier|static
name|int
name|introfunc
parameter_list|(
name|CmdParm
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|lineno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CmdParm
name|addr_parms
index|[]
init|=
block|{
block|{
name|PARM_DEVSPEC
block|,
block|{}
block|}
block|,
block|{
name|PARM_ADDR
block|,
block|{}
block|}
block|,
block|{
operator|-
literal|1
block|,
block|{}
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CmdParm
name|int_parms
index|[]
init|=
block|{
block|{
name|PARM_DEVSPEC
block|,
block|{}
block|}
block|,
block|{
name|PARM_INT
block|,
block|{}
block|}
block|,
block|{
operator|-
literal|1
block|,
block|{}
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CmdParm
name|dev_parms
index|[]
init|=
block|{
block|{
name|PARM_DEVSPEC
block|,
block|{}
block|}
block|,
block|{
operator|-
literal|1
block|,
block|{}
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Cmd
name|CmdList
index|[]
init|=
block|{
block|{
literal|"?"
block|,
name|helpfunc
block|,
name|NULL
block|}
block|,
comment|/* ? (help)	*/
block|{
literal|"di"
block|,
name|set_device_disable
block|,
name|dev_parms
block|}
block|,
comment|/* disable dev	*/
block|{
literal|"dr"
block|,
name|set_device_drq
block|,
name|int_parms
block|}
block|,
comment|/* drq dev #	*/
block|{
literal|"en"
block|,
name|set_device_enable
block|,
name|dev_parms
block|}
block|,
comment|/* enable dev	*/
block|{
literal|"ex"
block|,
name|quitfunc
block|,
name|NULL
block|}
block|,
comment|/* exit (quit)	*/
block|{
literal|"f"
block|,
name|set_device_flags
block|,
name|int_parms
block|}
block|,
comment|/* flags dev mask */
block|{
literal|"h"
block|,
name|helpfunc
block|,
name|NULL
block|}
block|,
comment|/* help		*/
if|#
directive|if
name|defined
argument_list|(
name|USERCONFIG_BOOT
argument_list|)
operator|&&
name|defined
argument_list|(
name|VISUAL_USERCONFIG
argument_list|)
block|{
literal|"intro"
block|,
name|introfunc
block|,
name|NULL
block|}
block|,
comment|/* intro screen	*/
endif|#
directive|endif
block|{
literal|"iom"
block|,
name|set_device_mem
block|,
name|addr_parms
block|}
block|,
comment|/* iomem dev addr */
block|{
literal|"ios"
block|,
name|set_device_iosize
block|,
name|int_parms
block|}
block|,
comment|/* iosize dev size */
block|{
literal|"ir"
block|,
name|set_device_irq
block|,
name|int_parms
block|}
block|,
comment|/* irq dev #	*/
block|{
literal|"l"
block|,
name|list_devices
block|,
name|NULL
block|}
block|,
comment|/* ls, list	*/
block|{
literal|"po"
block|,
name|set_device_ioaddr
block|,
name|int_parms
block|}
block|,
comment|/* port dev addr */
block|{
literal|"res"
block|,
operator|(
name|CmdFunc
operator|)
name|cpu_reset
block|,
name|NULL
block|}
block|,
comment|/* reset CPU	*/
block|{
literal|"q"
block|,
name|quitfunc
block|,
name|NULL
block|}
block|,
comment|/* quit		*/
if|#
directive|if
name|NSCBUS
operator|>
literal|0
block|{
literal|"s"
block|,
name|list_scsi
block|,
name|NULL
block|}
block|,
comment|/* scsi */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|VISUAL_USERCONFIG
block|{
literal|"v"
block|,
operator|(
name|CmdFunc
operator|)
name|visuserconfig
block|,
name|NULL
block|}
block|,
comment|/* visual mode */
endif|#
directive|endif
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|userconfig
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|input
index|[
literal|80
index|]
decl_stmt|;
name|int
name|rval
decl_stmt|;
name|Cmd
modifier|*
name|cmd
decl_stmt|;
name|printf
argument_list|(
literal|"\nFreeBSD Kernel Configuration Utility - Version 1.1\n"
literal|" Type \"help\" for help"
ifdef|#
directive|ifdef
name|VISUAL_USERCONFIG
literal|" or \"visual\" to go to the visual\n"
literal|" configuration interface (requires MGA/VGA display or\n"
literal|" serial terminal capable of displaying ANSI graphics)"
endif|#
directive|endif
literal|".\n"
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"config> "
argument_list|)
expr_stmt|;
name|cngets
argument_list|(
name|input
argument_list|,
literal|80
argument_list|)
expr_stmt|;
if|if
condition|(
name|input
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
continue|continue;
name|cmd
operator|=
name|parse_cmd
argument_list|(
name|input
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cmd
condition|)
block|{
name|printf
argument_list|(
literal|"Invalid command or syntax.  Type `?' for help.\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|rval
operator|=
call|(
modifier|*
name|cmd
operator|->
name|handler
call|)
argument_list|(
name|cmd
operator|->
name|parms
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
condition|)
return|return;
block|}
block|}
end_function

begin_function
specifier|static
name|Cmd
modifier|*
name|parse_cmd
parameter_list|(
name|char
modifier|*
name|cmd
parameter_list|)
block|{
name|Cmd
modifier|*
name|cp
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|CmdList
init|;
name|cp
operator|->
name|name
condition|;
name|cp
operator|++
control|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|cp
operator|->
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|cp
operator|->
name|name
argument_list|,
name|cmd
argument_list|,
name|len
argument_list|)
condition|)
block|{
while|while
condition|(
operator|*
name|cmd
operator|&&
operator|*
name|cmd
operator|!=
literal|' '
operator|&&
operator|*
name|cmd
operator|!=
literal|'\t'
condition|)
operator|++
name|cmd
expr_stmt|;
if|if
condition|(
name|parse_args
argument_list|(
name|cmd
argument_list|,
name|cp
operator|->
name|parms
argument_list|)
condition|)
return|return
name|NULL
return|;
else|else
return|return
name|cp
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|parse_args
parameter_list|(
name|char
modifier|*
name|cmd
parameter_list|,
name|CmdParm
modifier|*
name|parms
parameter_list|)
block|{
while|while
condition|(
literal|1
condition|)
block|{
name|char
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
operator|*
name|cmd
operator|==
literal|' '
operator|||
operator|*
name|cmd
operator|==
literal|'\t'
condition|)
block|{
operator|++
name|cmd
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|parms
operator|==
name|NULL
operator|||
name|parms
operator|->
name|type
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|*
name|cmd
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
name|printf
argument_list|(
literal|"Extra arg(s): %s\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|parms
operator|->
name|type
operator|==
name|PARM_DEVSPEC
condition|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|char
name|devname
index|[
literal|64
index|]
decl_stmt|;
name|int
name|unit
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|cmd
operator|&&
operator|!
operator|(
operator|*
name|cmd
operator|==
literal|' '
operator|||
operator|*
name|cmd
operator|==
literal|'\t'
operator|||
operator|(
operator|*
name|cmd
operator|>=
literal|'0'
operator|&&
operator|*
name|cmd
operator|<=
literal|'9'
operator|)
operator|)
condition|)
name|devname
index|[
name|i
operator|++
index|]
operator|=
operator|*
operator|(
name|cmd
operator|++
operator|)
expr_stmt|;
name|devname
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|cmd
operator|>=
literal|'0'
operator|&&
operator|*
name|cmd
operator|<=
literal|'9'
condition|)
block|{
name|unit
operator|=
name|strtoul
argument_list|(
name|cmd
argument_list|,
operator|&
name|ptr
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|ptr
condition|)
block|{
name|printf
argument_list|(
literal|"Invalid device number\n"
argument_list|)
expr_stmt|;
comment|/* XXX should print invalid token here and elsewhere. */
return|return
literal|1
return|;
block|}
comment|/* XXX else should require end of token. */
name|cmd
operator|=
name|ptr
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|parms
operator|->
name|parm
operator|.
name|dparm
operator|=
name|find_device
argument_list|(
name|devname
argument_list|,
name|unit
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"No such device: %s%d\n"
argument_list|,
name|devname
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
operator|++
name|parms
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|parms
operator|->
name|type
operator|==
name|PARM_INT
condition|)
block|{
name|parms
operator|->
name|parm
operator|.
name|iparm
operator|=
name|strtoul
argument_list|(
name|cmd
argument_list|,
operator|&
name|ptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|ptr
condition|)
block|{
name|printf
argument_list|(
literal|"Invalid numeric argument\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|cmd
operator|=
name|ptr
expr_stmt|;
operator|++
name|parms
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|parms
operator|->
name|type
operator|==
name|PARM_ADDR
condition|)
block|{
name|parms
operator|->
name|parm
operator|.
name|aparm
operator|=
operator|(
name|void
operator|*
operator|)
name|strtoul
argument_list|(
name|cmd
argument_list|,
operator|&
name|ptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|ptr
condition|)
block|{
name|printf
argument_list|(
literal|"Invalid address argument\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|cmd
operator|=
name|ptr
expr_stmt|;
operator|++
name|parms
expr_stmt|;
continue|continue;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|list_devices
parameter_list|(
name|CmdParm
modifier|*
name|parms
parameter_list|)
block|{
name|lineno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|lsdevtab
argument_list|(
operator|&
name|isa_devtab_bio
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|lsdevtab
argument_list|(
operator|&
name|isa_devtab_tty
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|lsdevtab
argument_list|(
operator|&
name|isa_devtab_net
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|lsdevtab
argument_list|(
operator|&
name|isa_devtab_null
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_device_ioaddr
parameter_list|(
name|CmdParm
modifier|*
name|parms
parameter_list|)
block|{
name|parms
index|[
literal|0
index|]
operator|.
name|parm
operator|.
name|dparm
operator|->
name|id_iobase
operator|=
name|parms
index|[
literal|1
index|]
operator|.
name|parm
operator|.
name|iparm
expr_stmt|;
name|save_dev
argument_list|(
name|parms
index|[
literal|0
index|]
operator|.
name|parm
operator|.
name|dparm
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_device_irq
parameter_list|(
name|CmdParm
modifier|*
name|parms
parameter_list|)
block|{
name|unsigned
name|irq
decl_stmt|;
name|irq
operator|=
name|parms
index|[
literal|1
index|]
operator|.
name|parm
operator|.
name|iparm
expr_stmt|;
ifndef|#
directive|ifndef
name|PC98
if|if
condition|(
name|irq
operator|==
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|"Warning: Remapping IRQ 2 to IRQ 9 - see config(8)\n"
argument_list|)
expr_stmt|;
name|irq
operator|=
literal|9
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|irq
operator|!=
operator|-
literal|1
operator|&&
name|irq
operator|>
literal|15
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|irq
operator|!=
operator|-
literal|1
operator|&&
name|irq
operator|>
literal|15
condition|)
block|{
endif|#
directive|endif
name|printf
argument_list|(
literal|"An IRQ> 15 would be invalid.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|parms
index|[
literal|0
index|]
operator|.
name|parm
operator|.
name|dparm
operator|->
name|id_irq
operator|=
operator|(
name|irq
operator|<
literal|16
condition|?
literal|1
operator|<<
name|irq
else|:
literal|0
operator|)
expr_stmt|;
name|save_dev
argument_list|(
name|parms
index|[
literal|0
index|]
operator|.
name|parm
operator|.
name|dparm
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
specifier|static
name|int
name|set_device_drq
parameter_list|(
name|CmdParm
modifier|*
name|parms
parameter_list|)
block|{
name|unsigned
name|drq
decl_stmt|;
comment|/*      * The bounds checking is just to ensure that the value can be printed      * in 5 characters.  32768 gets converted to -32768 and doesn't fit.      */
name|drq
operator|=
name|parms
index|[
literal|1
index|]
operator|.
name|parm
operator|.
name|iparm
expr_stmt|;
name|parms
index|[
literal|0
index|]
operator|.
name|parm
operator|.
name|dparm
operator|->
name|id_drq
operator|=
operator|(
name|drq
operator|<
literal|32768
condition|?
name|drq
else|:
operator|-
literal|1
operator|)
expr_stmt|;
name|save_dev
argument_list|(
name|parms
index|[
literal|0
index|]
operator|.
name|parm
operator|.
name|dparm
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
specifier|static
name|int
name|set_device_iosize
parameter_list|(
name|CmdParm
modifier|*
name|parms
parameter_list|)
block|{
name|parms
index|[
literal|0
index|]
operator|.
name|parm
operator|.
name|dparm
operator|->
name|id_msize
operator|=
name|parms
index|[
literal|1
index|]
operator|.
name|parm
operator|.
name|iparm
expr_stmt|;
name|save_dev
argument_list|(
name|parms
index|[
literal|0
index|]
operator|.
name|parm
operator|.
name|dparm
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
specifier|static
name|int
name|set_device_mem
parameter_list|(
name|CmdParm
modifier|*
name|parms
parameter_list|)
block|{
name|parms
index|[
literal|0
index|]
operator|.
name|parm
operator|.
name|dparm
operator|->
name|id_maddr
operator|=
name|parms
index|[
literal|1
index|]
operator|.
name|parm
operator|.
name|aparm
expr_stmt|;
name|save_dev
argument_list|(
name|parms
index|[
literal|0
index|]
operator|.
name|parm
operator|.
name|dparm
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
specifier|static
name|int
name|set_device_flags
parameter_list|(
name|CmdParm
modifier|*
name|parms
parameter_list|)
block|{
name|parms
index|[
literal|0
index|]
operator|.
name|parm
operator|.
name|dparm
operator|->
name|id_flags
operator|=
name|parms
index|[
literal|1
index|]
operator|.
name|parm
operator|.
name|iparm
expr_stmt|;
name|save_dev
argument_list|(
name|parms
index|[
literal|0
index|]
operator|.
name|parm
operator|.
name|dparm
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
specifier|static
name|int
name|set_device_enable
parameter_list|(
name|CmdParm
modifier|*
name|parms
parameter_list|)
block|{
name|parms
index|[
literal|0
index|]
operator|.
name|parm
operator|.
name|dparm
operator|->
name|id_enabled
operator|=
name|TRUE
expr_stmt|;
name|save_dev
argument_list|(
name|parms
index|[
literal|0
index|]
operator|.
name|parm
operator|.
name|dparm
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
specifier|static
name|int
name|set_device_disable
parameter_list|(
name|CmdParm
modifier|*
name|parms
parameter_list|)
block|{
name|parms
index|[
literal|0
index|]
operator|.
name|parm
operator|.
name|dparm
operator|->
name|id_enabled
operator|=
name|FALSE
expr_stmt|;
name|save_dev
argument_list|(
name|parms
index|[
literal|0
index|]
operator|.
name|parm
operator|.
name|dparm
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
specifier|static
name|int
name|quitfunc
parameter_list|(
name|CmdParm
modifier|*
name|parms
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
specifier|static
name|int
name|helpfunc
parameter_list|(
name|CmdParm
modifier|*
name|parms
parameter_list|)
block|{
name|printf
argument_list|(
literal|"Command\t\t\tDescription\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"-------\t\t\t-----------\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ls\t\t\tList currently configured devices\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"port<devname><addr>\tSet device port (i/o address)\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"irq<devname><number>\tSet device irq\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"drq<devname><number>\tSet device drq\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"iomem<devname><addr>\tSet device maddr (memory address)\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"iosize<devname><size>\tSet device memory size\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"flags<devname><mask>\tSet device flags\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"enable<devname>\tEnable device\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"disable<devname>\tDisable device (will not be probed)\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"quit\t\t\tExit this configuration utility\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"reset\t\t\tReset CPU\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VISUAL_USERCONFIG
name|printf
argument_list|(
literal|"visual\t\t\tGo to fullscreen mode.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"help\t\t\tThis message\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Commands may be abbreviated to a unique prefix\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|USERCONFIG_BOOT
argument_list|)
operator|&&
name|defined
argument_list|(
name|VISUAL_USERCONFIG
argument_list|)
specifier|static
name|void
name|center
parameter_list|(
name|int
name|y
parameter_list|,
name|char
modifier|*
name|str
parameter_list|)
block|{
name|putxy
argument_list|(
operator|(
literal|80
operator|-
name|strlen
argument_list|(
name|str
argument_list|)
operator|)
operator|/
literal|2
argument_list|,
name|y
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
specifier|static
name|int
name|introfunc
parameter_list|(
name|CmdParm
modifier|*
name|parms
parameter_list|)
block|{
name|int
name|curr_item
decl_stmt|,
name|first_time
decl_stmt|;
specifier|static
name|char
modifier|*
name|choices
index|[]
init|=
block|{
literal|" Skip kernel configuration and continue with installation "
block|,
literal|" Start kernel configuration in Visual mode                "
block|,
literal|" Start kernel configuration in CLI mode (experts only)    "
block|,     }
decl_stmt|;
name|clear
argument_list|()
expr_stmt|;
name|center
argument_list|(
literal|2
argument_list|,
literal|"!bKernel Configuration Menu!n"
argument_list|)
expr_stmt|;
name|curr_item
operator|=
literal|0
expr_stmt|;
name|first_time
operator|=
literal|1
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|char
name|tmp
index|[
literal|80
index|]
decl_stmt|;
name|int
name|c
decl_stmt|,
name|i
decl_stmt|,
name|extended
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|tmp
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|curr_item
operator|==
name|i
condition|)
name|strcpy
argument_list|(
name|tmp
argument_list|,
literal|"!i"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmp
argument_list|,
name|choices
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|curr_item
operator|==
name|i
condition|)
name|strcat
argument_list|(
name|tmp
argument_list|,
literal|"!n"
argument_list|)
expr_stmt|;
name|putxy
argument_list|(
literal|10
argument_list|,
literal|5
operator|+
name|i
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|first_time
condition|)
block|{
name|putxy
argument_list|(
literal|2
argument_list|,
literal|10
argument_list|,
literal|"Here you have the chance to go into kernel configuration mode, making"
argument_list|)
expr_stmt|;
name|putxy
argument_list|(
literal|2
argument_list|,
literal|11
argument_list|,
literal|"any changes which may be necessary to properly adjust the kernel to"
argument_list|)
expr_stmt|;
name|putxy
argument_list|(
literal|2
argument_list|,
literal|12
argument_list|,
literal|"match your hardware configuration."
argument_list|)
expr_stmt|;
name|putxy
argument_list|(
literal|2
argument_list|,
literal|14
argument_list|,
literal|"If you are installing FreeBSD for the first time, select Visual Mode"
argument_list|)
expr_stmt|;
name|putxy
argument_list|(
literal|2
argument_list|,
literal|15
argument_list|,
literal|"(press Down-Arrow then ENTER)."
argument_list|)
expr_stmt|;
name|putxy
argument_list|(
literal|2
argument_list|,
literal|17
argument_list|,
literal|"If you need to do more specialized kernel configuration and are an"
argument_list|)
expr_stmt|;
name|putxy
argument_list|(
literal|2
argument_list|,
literal|18
argument_list|,
literal|"experienced FreeBSD user, select CLI mode."
argument_list|)
expr_stmt|;
name|putxy
argument_list|(
literal|2
argument_list|,
literal|20
argument_list|,
literal|"If you are !icertain!n that you do not need to configure your kernel"
argument_list|)
expr_stmt|;
name|putxy
argument_list|(
literal|2
argument_list|,
literal|21
argument_list|,
literal|"then simply press ENTER or Q now."
argument_list|)
expr_stmt|;
name|first_time
operator|=
literal|0
expr_stmt|;
block|}
name|move
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* move the cursor out of the way */
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|extended
operator|==
literal|2
operator|)
operator|||
operator|(
name|c
operator|==
literal|588
operator|)
operator|||
operator|(
name|c
operator|==
literal|596
operator|)
condition|)
block|{
comment|/* console gives "alternative" codes */
name|extended
operator|=
literal|0
expr_stmt|;
comment|/* no longer */
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|588
case|:
case|case
literal|'A'
case|:
comment|/* up */
if|if
condition|(
name|curr_item
operator|>
literal|0
condition|)
operator|--
name|curr_item
expr_stmt|;
break|break;
case|case
literal|596
case|:
case|case
literal|'B'
case|:
comment|/* down */
if|if
condition|(
name|curr_item
operator|<
literal|2
condition|)
operator|++
name|curr_item
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\033'
case|:
name|extended
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'['
case|:
comment|/* cheat : always preceeds cursor move */
case|case
literal|'O'
case|:
comment|/* ANSI application key mode */
if|if
condition|(
name|extended
operator|==
literal|1
condition|)
name|extended
operator|=
literal|2
expr_stmt|;
else|else
name|extended
operator|=
literal|0
expr_stmt|;
break|break;
case|case
operator|-
literal|1
case|:
case|case
literal|'Q'
case|:
case|case
literal|'q'
case|:
name|clear
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
comment|/* user requests exit */
case|case
literal|'\r'
case|:
case|case
literal|'\n'
case|:
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|curr_item
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|curr_item
operator|==
literal|1
condition|)
return|return
name|visuserconfig
argument_list|()
return|;
else|else
block|{
name|putxy
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|,
literal|"Type \"help\" for help or \"quit\" to exit."
argument_list|)
expr_stmt|;
name|move
argument_list|(
literal|0
argument_list|,
literal|3
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
block|}
block|}
block|}
block|}
endif|#
directive|endif
specifier|static
name|int
name|lsdevtab
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dt
parameter_list|)
block|{
for|for
control|(
init|;
name|dt
operator|->
name|id_id
operator|!=
literal|0
condition|;
name|dt
operator|++
control|)
block|{
name|int
name|i
decl_stmt|;
name|char
name|line
index|[
literal|80
index|]
decl_stmt|;
if|if
condition|(
name|lineno
operator|>=
literal|23
condition|)
block|{
name|printf
argument_list|(
literal|"<More> "
argument_list|)
expr_stmt|;
if|if
condition|(
name|getchar
argument_list|()
operator|==
literal|'q'
condition|)
block|{
name|printf
argument_list|(
literal|"quit\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|lineno
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|lineno
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Device   port       irq   drq   iomem   iosize   unit  flags      enabled\n"
argument_list|)
expr_stmt|;
operator|++
name|lineno
expr_stmt|;
block|}
comment|/* 	 * printf() doesn't support %#, %- or even field widths for strings, 	 * so formatting is not straightforward. 	 */
name|bzero
argument_list|(
name|line
argument_list|,
sizeof|sizeof
name|line
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"%s%d"
argument_list|,
name|dt
operator|->
name|id_driver
operator|->
name|name
argument_list|,
name|dt
operator|->
name|id_unit
argument_list|)
expr_stmt|;
comment|/* Missing: id_id (don't need it). */
comment|/* Missing: id_driver (useful if we could show it by name). */
name|sprintf
argument_list|(
name|line
operator|+
literal|9
argument_list|,
literal|"0x%x"
argument_list|,
name|dt
operator|->
name|id_iobase
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|line
operator|+
literal|20
argument_list|,
literal|"%d"
argument_list|,
name|ffs
argument_list|(
name|dt
operator|->
name|id_irq
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|line
operator|+
literal|26
argument_list|,
literal|"%d"
argument_list|,
name|dt
operator|->
name|id_drq
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|line
operator|+
literal|32
argument_list|,
literal|"0x%x"
argument_list|,
name|dt
operator|->
name|id_maddr
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|line
operator|+
literal|40
argument_list|,
literal|"%d"
argument_list|,
name|dt
operator|->
name|id_msize
argument_list|)
expr_stmt|;
comment|/* Missing: id_msize (0 at start, useful if we can get here later). */
comment|/* Missing: id_intr (useful if we could show it by name). */
comment|/* Display only: id_unit. */
name|sprintf
argument_list|(
name|line
operator|+
literal|49
argument_list|,
literal|"%d"
argument_list|,
name|dt
operator|->
name|id_unit
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|line
operator|+
literal|55
argument_list|,
literal|"0x%x"
argument_list|,
name|dt
operator|->
name|id_flags
argument_list|)
expr_stmt|;
comment|/* Missing: id_scsiid, id_alive, id_ri_flags, id_reconfig (0 now...) */
name|sprintf
argument_list|(
name|line
operator|+
literal|66
argument_list|,
literal|"%s"
argument_list|,
name|dt
operator|->
name|id_enabled
condition|?
literal|"Yes"
else|:
literal|"No"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|66
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|line
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
name|line
index|[
name|i
index|]
operator|=
literal|' '
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|line
argument_list|)
expr_stmt|;
operator|++
name|lineno
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
name|struct
name|isa_device
modifier|*
name|find_device
parameter_list|(
name|char
modifier|*
name|devname
parameter_list|,
name|int
name|unit
parameter_list|)
block|{
name|struct
name|isa_device
modifier|*
name|ret
decl_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|search_devtable
argument_list|(
operator|&
name|isa_devtab_bio
index|[
literal|0
index|]
argument_list|,
name|devname
argument_list|,
name|unit
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
name|ret
return|;
if|if
condition|(
operator|(
name|ret
operator|=
name|search_devtable
argument_list|(
operator|&
name|isa_devtab_tty
index|[
literal|0
index|]
argument_list|,
name|devname
argument_list|,
name|unit
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
name|ret
return|;
if|if
condition|(
operator|(
name|ret
operator|=
name|search_devtable
argument_list|(
operator|&
name|isa_devtab_net
index|[
literal|0
index|]
argument_list|,
name|devname
argument_list|,
name|unit
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
name|ret
return|;
if|if
condition|(
operator|(
name|ret
operator|=
name|search_devtable
argument_list|(
operator|&
name|isa_devtab_null
index|[
literal|0
index|]
argument_list|,
name|devname
argument_list|,
name|unit
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
name|ret
return|;
return|return
name|NULL
return|;
block|}
specifier|static
name|struct
name|isa_device
modifier|*
name|search_devtable
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dt
parameter_list|,
name|char
modifier|*
name|devname
parameter_list|,
name|int
name|unit
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|dt
operator|->
name|id_id
operator|!=
literal|0
condition|;
name|dt
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|dt
operator|->
name|id_driver
operator|->
name|name
argument_list|,
name|devname
argument_list|)
operator|&&
name|dt
operator|->
name|id_unit
operator|==
name|unit
condition|)
return|return
name|dt
return|;
return|return
name|NULL
return|;
block|}
specifier|static
name|void
name|cngets
parameter_list|(
name|char
modifier|*
name|input
parameter_list|,
name|int
name|maxin
parameter_list|)
block|{
name|int
name|c
decl_stmt|,
name|nchars
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
comment|/* Treat ^H or ^? as backspace */
if|if
condition|(
operator|(
name|c
operator|==
literal|'\010'
operator|||
name|c
operator|==
literal|'\177'
operator|)
condition|)
block|{
if|if
condition|(
name|nchars
condition|)
block|{
name|printf
argument_list|(
literal|"\010 \010"
argument_list|)
expr_stmt|;
operator|*
operator|--
name|input
operator|=
literal|'\0'
operator|,
operator|--
name|nchars
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* Treat ^U or ^X as kill line */
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'\025'
operator|||
name|c
operator|==
literal|'\030'
operator|)
condition|)
block|{
while|while
condition|(
name|nchars
condition|)
block|{
name|printf
argument_list|(
literal|"\010 \010"
argument_list|)
expr_stmt|;
operator|*
operator|--
name|input
operator|=
literal|'\0'
operator|,
operator|--
name|nchars
expr_stmt|;
block|}
continue|continue;
block|}
name|printf
argument_list|(
literal|"%c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|++
name|nchars
operator|==
name|maxin
operator|)
operator|||
operator|(
name|c
operator|==
literal|'\n'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'\r'
operator|)
operator|||
operator|(
name|c
operator|==
operator|-
literal|1
operator|)
condition|)
block|{
operator|*
name|input
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
operator|*
name|input
operator|++
operator|=
operator|(
name|u_char
operator|)
name|c
expr_stmt|;
block|}
block|}
comment|/*  * Kludges to get the library sources of strtoul.c to work in our  * environment.  isdigit() and isspace() could be used above too.  */
define|#
directive|define
name|isalpha
parameter_list|(
name|c
parameter_list|)
value|(((c)>= 'A'&& (c)<= 'Z') \ 			 || ((c)>= 'a'&& (c)<= 'z'))
comment|/* unsafe */
define|#
directive|define
name|isdigit
parameter_list|(
name|c
parameter_list|)
value|((unsigned)((c) - '0')<= '9' - '0')
define|#
directive|define
name|isspace
parameter_list|(
name|c
parameter_list|)
value|((c) == ' ' || (c) == '\t')
comment|/* unsafe */
define|#
directive|define
name|isupper
parameter_list|(
name|c
parameter_list|)
value|((unsigned)((c) - 'A')<= 'Z' - 'A')
specifier|static
name|int
name|errno
decl_stmt|;
comment|/*  * The following should be identical with the library sources for strtoul.c.  */
comment|/*  * Convert a string to an unsigned long integer.  *  * Ignores `locale' stuff.  Assumes that the upper and lower case  * alphabets and digits are each contiguous.  */
specifier|static
name|unsigned
name|long
name|strtoul
parameter_list|(
name|nptr
parameter_list|,
name|endptr
parameter_list|,
name|base
parameter_list|)
specifier|const
name|char
modifier|*
name|nptr
decl_stmt|;
name|char
modifier|*
modifier|*
name|endptr
decl_stmt|;
specifier|register
name|int
name|base
decl_stmt|;
block|{
specifier|register
specifier|const
name|char
modifier|*
name|s
init|=
name|nptr
decl_stmt|;
specifier|register
name|unsigned
name|long
name|acc
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|unsigned
name|long
name|cutoff
decl_stmt|;
specifier|register
name|int
name|neg
init|=
literal|0
decl_stmt|,
name|any
decl_stmt|,
name|cutlim
decl_stmt|;
comment|/* 	 * See strtol for comments as to the logic used. 	 */
do|do
block|{
name|c
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
do|;
if|if
condition|(
name|c
operator|==
literal|'-'
condition|)
block|{
name|neg
operator|=
literal|1
expr_stmt|;
name|c
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'+'
condition|)
name|c
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|base
operator|==
literal|0
operator|||
name|base
operator|==
literal|16
operator|)
operator|&&
name|c
operator|==
literal|'0'
operator|&&
operator|(
operator|*
name|s
operator|==
literal|'x'
operator|||
operator|*
name|s
operator|==
literal|'X'
operator|)
condition|)
block|{
name|c
operator|=
name|s
index|[
literal|1
index|]
expr_stmt|;
name|s
operator|+=
literal|2
expr_stmt|;
name|base
operator|=
literal|16
expr_stmt|;
block|}
if|if
condition|(
name|base
operator|==
literal|0
condition|)
name|base
operator|=
name|c
operator|==
literal|'0'
condition|?
literal|8
else|:
literal|10
expr_stmt|;
name|cutoff
operator|=
operator|(
name|unsigned
name|long
operator|)
name|ULONG_MAX
operator|/
operator|(
name|unsigned
name|long
operator|)
name|base
expr_stmt|;
name|cutlim
operator|=
operator|(
name|unsigned
name|long
operator|)
name|ULONG_MAX
operator|%
operator|(
name|unsigned
name|long
operator|)
name|base
expr_stmt|;
for|for
control|(
name|acc
operator|=
literal|0
operator|,
name|any
operator|=
literal|0
init|;
condition|;
name|c
operator|=
operator|*
name|s
operator|++
control|)
block|{
if|if
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
name|c
operator|-=
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|isalpha
argument_list|(
name|c
argument_list|)
condition|)
name|c
operator|-=
name|isupper
argument_list|(
name|c
argument_list|)
condition|?
literal|'A'
operator|-
literal|10
else|:
literal|'a'
operator|-
literal|10
expr_stmt|;
else|else
break|break;
if|if
condition|(
name|c
operator|>=
name|base
condition|)
break|break;
if|if
condition|(
name|any
operator|<
literal|0
operator|||
name|acc
operator|>
name|cutoff
operator|||
name|acc
operator|==
name|cutoff
operator|&&
name|c
operator|>
name|cutlim
condition|)
name|any
operator|=
operator|-
literal|1
expr_stmt|;
else|else
block|{
name|any
operator|=
literal|1
expr_stmt|;
name|acc
operator|*=
name|base
expr_stmt|;
name|acc
operator|+=
name|c
expr_stmt|;
block|}
block|}
if|if
condition|(
name|any
operator|<
literal|0
condition|)
block|{
name|acc
operator|=
name|ULONG_MAX
expr_stmt|;
name|errno
operator|=
name|ERANGE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|neg
condition|)
name|acc
operator|=
operator|-
name|acc
expr_stmt|;
if|if
condition|(
name|endptr
operator|!=
literal|0
condition|)
operator|*
name|endptr
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|any
condition|?
name|s
operator|-
literal|1
else|:
name|nptr
operator|)
expr_stmt|;
return|return
operator|(
name|acc
operator|)
return|;
block|}
if|#
directive|if
name|NSCBUS
operator|>
literal|0
comment|/* scsi: Support for displaying configured SCSI devices.  * There is no way to edit them, and this is inconsistent  * with the ISA method.  This is here as a basis for further work.  */
specifier|static
name|char
modifier|*
name|type_text
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
comment|/* XXX: This is bogus */
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"sd"
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|"disk"
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"st"
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|"tape"
return|;
return|return
literal|"device"
return|;
block|}
specifier|static
name|void
name|id_put
parameter_list|(
name|char
modifier|*
name|desc
parameter_list|,
name|int
name|id
parameter_list|)
block|{
if|if
condition|(
name|id
operator|!=
name|SCCONF_UNSPEC
condition|)
block|{
if|if
condition|(
name|desc
condition|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|==
name|SCCONF_ANY
condition|)
name|printf
argument_list|(
literal|"?"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%d"
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
block|}
specifier|static
name|void
name|lsscsi
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"scsi: (can't be edited):\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|scsi_cinit
index|[
name|i
index|]
operator|.
name|driver
condition|;
name|i
operator|++
control|)
block|{
name|id_put
argument_list|(
literal|"controller scbus"
argument_list|,
name|scsi_cinit
index|[
name|i
index|]
operator|.
name|bus
argument_list|)
expr_stmt|;
if|if
condition|(
name|scsi_cinit
index|[
name|i
index|]
operator|.
name|unit
operator|!=
operator|-
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|" at "
argument_list|)
expr_stmt|;
name|id_put
argument_list|(
name|scsi_cinit
index|[
name|i
index|]
operator|.
name|driver
argument_list|,
name|scsi_cinit
index|[
name|i
index|]
operator|.
name|unit
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|scsi_dinit
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"%s "
argument_list|,
name|type_text
argument_list|(
name|scsi_dinit
index|[
name|i
index|]
operator|.
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|id_put
argument_list|(
name|scsi_dinit
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|scsi_dinit
index|[
name|i
index|]
operator|.
name|unit
argument_list|)
expr_stmt|;
name|id_put
argument_list|(
literal|" at scbus"
argument_list|,
name|scsi_dinit
index|[
name|i
index|]
operator|.
name|cunit
argument_list|)
expr_stmt|;
name|id_put
argument_list|(
literal|" target "
argument_list|,
name|scsi_dinit
index|[
name|i
index|]
operator|.
name|target
argument_list|)
expr_stmt|;
name|id_put
argument_list|(
literal|" lun "
argument_list|,
name|scsi_dinit
index|[
name|i
index|]
operator|.
name|lun
argument_list|)
expr_stmt|;
if|if
condition|(
name|scsi_dinit
index|[
name|i
index|]
operator|.
name|flags
condition|)
name|printf
argument_list|(
literal|"flags 0x%x\n"
argument_list|,
name|scsi_dinit
index|[
name|i
index|]
operator|.
name|flags
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
specifier|static
name|int
name|list_scsi
parameter_list|(
name|CmdParm
modifier|*
name|parms
parameter_list|)
block|{
name|lineno
operator|=
literal|0
expr_stmt|;
name|lsscsi
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
specifier|static
name|int
name|save_dev
parameter_list|(
name|idev
parameter_list|)
name|struct
name|isa_device
modifier|*
name|idev
decl_stmt|;
block|{
name|struct
name|isa_device
modifier|*
name|id_p
decl_stmt|,
modifier|*
name|id_pn
decl_stmt|;
for|for
control|(
name|id_p
operator|=
name|isa_devlist
init|;
name|id_p
condition|;
name|id_p
operator|=
name|id_p
operator|->
name|id_next
control|)
block|{
if|if
condition|(
name|id_p
operator|->
name|id_id
operator|==
name|idev
operator|->
name|id_id
condition|)
block|{
name|id_pn
operator|=
name|id_p
operator|->
name|id_next
expr_stmt|;
name|bcopy
argument_list|(
name|idev
argument_list|,
name|id_p
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|isa_device
argument_list|)
argument_list|)
expr_stmt|;
name|id_p
operator|->
name|id_next
operator|=
name|id_pn
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
name|id_pn
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|isa_device
argument_list|)
argument_list|,
name|M_DEVL
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|idev
argument_list|,
name|id_pn
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|isa_device
argument_list|)
argument_list|)
expr_stmt|;
name|id_pn
operator|->
name|id_next
operator|=
name|isa_devlist
expr_stmt|;
name|isa_devlist
operator|=
name|id_pn
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

