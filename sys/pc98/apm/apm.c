begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * APM (Advanced Power Management) BIOS Device Driver  *  * Copyright (c) 1994 UKAI, Fumitoshi.  * Copyright (c) 1994-1995 by HOSOKAWA, Tatsumi<hosokawa@jp.FreeBSD.org>  * Copyright (c) 1996 Nate Williams<nate@FreeBSD.org>  * Copyright (c) 1997 Poul-Henning Kamp<phk@FreeBSD.org>  *  * This software may be used, modified, copied, and distributed, in  * both source and binary form provided that the above copyright and  * these terms are retained. Under no circumstances is the author  * responsible for the proper functioning of this software, nor does  * the author assume any responsibility for damages incurred with its  * use.  *  * Sep, 1994	Implemented on FreeBSD 1.1.5.1R (Toshiba AVS001WD)  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/reboot.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<machine/apm_bios.h>
end_include

begin_include
include|#
directive|include
file|<machine/segments.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<machine/pc/bios.h>
end_include

begin_include
include|#
directive|include
file|<machine/vm86.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|PC98
end_ifdef

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<pc98/apm/apm.h>
end_include

begin_comment
comment|/* Used by the apm_saver screen saver module */
end_comment

begin_decl_stmt
name|int
name|apm_display
name|__P
argument_list|(
operator|(
name|int
name|newstate
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|apm_softc
name|apm_softc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|apm_resume
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|apm_bioscall
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|apm_check_function_supported
name|__P
argument_list|(
operator|(
name|u_int
name|version
operator|,
name|u_int
name|func
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_long
name|apm_version
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|apm_evindex
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SCFLAG_ONORMAL
value|0x0000001
end_define

begin_define
define|#
directive|define
name|SCFLAG_OCTL
value|0x0000002
end_define

begin_define
define|#
directive|define
name|SCFLAG_OPEN
value|(SCFLAG_ONORMAL|SCFLAG_OCTL)
end_define

begin_define
define|#
directive|define
name|APMDEV
parameter_list|(
name|dev
parameter_list|)
value|(minor(dev)&0x0f)
end_define

begin_define
define|#
directive|define
name|APMDEV_NORMAL
value|0
end_define

begin_define
define|#
directive|define
name|APMDEV_CTL
value|8
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|PC98
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|bios32_apm98
name|__P
argument_list|(
operator|(
expr|struct
name|bios_regs
operator|*
operator|,
name|u_int
operator|,
name|u_short
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* PC98's SMM definition */
end_comment

begin_define
define|#
directive|define
name|APM_NECSMM_PORT
value|0x6b8e
end_define

begin_define
define|#
directive|define
name|APM_NECSMM_PORTSZ
value|1
end_define

begin_define
define|#
directive|define
name|APM_NECSMM_EN
value|0x10
end_define

begin_decl_stmt
specifier|static
name|__inline
name|void
name|apm_enable_smm
name|__P
argument_list|(
operator|(
expr|struct
name|apm_softc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|__inline
name|void
name|apm_disable_smm
name|__P
argument_list|(
operator|(
expr|struct
name|apm_softc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|apm_necsmm_addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int32_t
name|apm_necsmm_mask
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|apmhook
modifier|*
name|hook
index|[
name|NAPM_HOOK
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX */
end_comment

begin_define
define|#
directive|define
name|is_enabled
parameter_list|(
name|foo
parameter_list|)
value|((foo) ? "enabled" : "disabled")
end_define

begin_comment
comment|/* Map version number to integer (keeps ordering of version numbers) */
end_comment

begin_define
define|#
directive|define
name|INTVERSION
parameter_list|(
name|major
parameter_list|,
name|minor
parameter_list|)
value|((major)*100 + (minor))
end_define

begin_decl_stmt
specifier|static
name|struct
name|callout_handle
name|apm_timeout_ch
init|=
name|CALLOUT_HANDLE_INITIALIZER
argument_list|(
operator|&
name|apm_timeout_ch
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|timeout_t
name|apm_timeout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_open_t
name|apmopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|apmclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_write_t
name|apmwrite
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|apmioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_poll_t
name|apmpoll
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CDEV_MAJOR
value|39
end_define

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|apm_cdevsw
init|=
block|{
comment|/* open */
name|apmopen
block|,
comment|/* close */
name|apmclose
block|,
comment|/* read */
name|noread
block|,
comment|/* write */
name|apmwrite
block|,
comment|/* ioctl */
name|apmioctl
block|,
comment|/* poll */
name|apmpoll
block|,
comment|/* mmap */
name|nommap
block|,
comment|/* strategy */
name|nostrategy
block|,
comment|/* name */
literal|"apm"
block|,
comment|/* maj */
name|CDEV_MAJOR
block|,
comment|/* dump */
name|nodump
block|,
comment|/* psize */
name|nopsize
block|,
comment|/* flags */
literal|0
block|,
comment|/* bmaj */
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|apm_suspend_delay
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|apm_standby_delay
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|apm_suspend_delay
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|apm_suspend_delay
argument_list|,
literal|1
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|apm_standby_delay
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|apm_standby_delay
argument_list|,
literal|1
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|PC98
end_ifdef

begin_function
specifier|static
name|__inline
name|void
name|apm_enable_smm
parameter_list|(
name|sc
parameter_list|)
name|struct
name|apm_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|bus_space_tag_t
name|iot
init|=
name|sc
operator|->
name|sc_iot
decl_stmt|;
name|bus_space_handle_t
name|ioh
init|=
name|sc
operator|->
name|sc_ioh
decl_stmt|;
if|if
condition|(
name|apm_necsmm_addr
operator|!=
literal|0
condition|)
name|bus_space_write_1
argument_list|(
name|iot
argument_list|,
name|ioh
argument_list|,
literal|0
argument_list|,
operator|(
name|bus_space_read_1
argument_list|(
name|iot
argument_list|,
name|ioh
argument_list|,
literal|0
argument_list|)
operator||
operator|~
name|apm_necsmm_mask
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|apm_disable_smm
parameter_list|(
name|sc
parameter_list|)
name|struct
name|apm_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|bus_space_tag_t
name|iot
init|=
name|sc
operator|->
name|sc_iot
decl_stmt|;
name|bus_space_handle_t
name|ioh
init|=
name|sc
operator|->
name|sc_ioh
decl_stmt|;
if|if
condition|(
name|apm_necsmm_addr
operator|!=
literal|0
condition|)
name|bus_space_write_1
argument_list|(
name|iot
argument_list|,
name|ioh
argument_list|,
literal|0
argument_list|,
operator|(
name|bus_space_read_1
argument_list|(
name|iot
argument_list|,
name|ioh
argument_list|,
literal|0
argument_list|)
operator|&
name|apm_necsmm_mask
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * return  0 if the function successfull,  * return  1 if the function unsuccessfull,  * return -1 if the function unsupported.  */
end_comment

begin_function
specifier|static
name|int
name|apm_bioscall
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|apm_softc
modifier|*
name|sc
init|=
operator|&
name|apm_softc
decl_stmt|;
name|int
name|errno
init|=
literal|0
decl_stmt|;
name|u_int
name|apm_func
init|=
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|eax
operator|&
literal|0xff
decl_stmt|;
if|if
condition|(
operator|!
name|apm_check_function_supported
argument_list|(
name|sc
operator|->
name|intversion
argument_list|,
name|apm_func
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|APM_DEBUG
name|printf
argument_list|(
literal|"apm_bioscall: function 0x%x is not supported in v%d.%d\n"
argument_list|,
name|apm_func
argument_list|,
name|sc
operator|->
name|majorversion
argument_list|,
name|sc
operator|->
name|minorversion
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|sc
operator|->
name|bios_busy
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|set_bios_selectors
argument_list|(
operator|&
name|sc
operator|->
name|bios
operator|.
name|seg
argument_list|,
name|BIOSCODE_FLAG
operator||
name|BIOSDATA_FLAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|bios32_apm98
argument_list|(
operator|&
name|sc
operator|->
name|bios
operator|.
name|r
argument_list|,
name|sc
operator|->
name|bios
operator|.
name|entry
argument_list|,
name|GSEL
argument_list|(
name|GBIOSCODE32_SEL
argument_list|,
name|SEL_KPL
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
else|#
directive|else
if|if
condition|(
name|sc
operator|->
name|connectmode
operator|==
name|APM_PROT32CONNECT
condition|)
block|{
name|set_bios_selectors
argument_list|(
operator|&
name|sc
operator|->
name|bios
operator|.
name|seg
argument_list|,
name|BIOSCODE_FLAG
operator||
name|BIOSDATA_FLAG
argument_list|)
expr_stmt|;
name|errno
operator|=
name|bios32
argument_list|(
operator|&
name|sc
operator|->
name|bios
operator|.
name|r
argument_list|,
name|sc
operator|->
name|bios
operator|.
name|entry
argument_list|,
name|GSEL
argument_list|(
name|GBIOSCODE32_SEL
argument_list|,
name|SEL_KPL
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|errno
operator|=
name|bios16
argument_list|(
operator|&
name|sc
operator|->
name|bios
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|sc
operator|->
name|bios_busy
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|errno
operator|)
return|;
block|}
end_function

begin_comment
comment|/* check whether APM function is supported (1)  or not (0). */
end_comment

begin_function
specifier|static
name|int
name|apm_check_function_supported
parameter_list|(
name|u_int
name|version
parameter_list|,
name|u_int
name|func
parameter_list|)
block|{
comment|/* except driver version */
if|if
condition|(
name|func
operator|==
name|APM_DRVVERSION
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|PC98
if|if
condition|(
name|func
operator|==
name|APM_GETPWSTATUS
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
switch|switch
condition|(
name|version
condition|)
block|{
case|case
name|INTVERSION
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
case|:
if|if
condition|(
name|func
operator|>
name|APM_GETPMEVENT
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
comment|/* not supported */
block|}
break|break;
case|case
name|INTVERSION
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
case|:
if|if
condition|(
name|func
operator|>
name|APM_ENGAGEDISENGAGEPM
operator|&&
name|func
operator|<
name|APM_OEMFUNC
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
comment|/* not supported */
block|}
break|break;
case|case
name|INTVERSION
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
case|:
break|break;
block|}
return|return
operator|(
literal|1
operator|)
return|;
comment|/* supported */
block|}
end_function

begin_comment
comment|/* enable/disable power management */
end_comment

begin_function
specifier|static
name|int
name|apm_enable_disable_pm
parameter_list|(
name|int
name|enable
parameter_list|)
block|{
name|struct
name|apm_softc
modifier|*
name|sc
init|=
operator|&
name|apm_softc
decl_stmt|;
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|eax
operator|=
operator|(
name|APM_BIOS
operator|<<
literal|8
operator|)
operator||
name|APM_ENABLEDISABLEPM
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|intversion
operator|>=
name|INTVERSION
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
condition|)
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|ebx
operator|=
name|PMDV_ALLDEV
expr_stmt|;
else|else
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|ebx
operator|=
literal|0xffff
expr_stmt|;
comment|/* APM version 1.0 only */
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|ecx
operator|=
name|enable
expr_stmt|;
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|edx
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|apm_bioscall
argument_list|()
operator|)
return|;
block|}
end_function

begin_comment
comment|/* register driver version (APM 1.1 or later) */
end_comment

begin_function
specifier|static
name|int
name|apm_driver_version
parameter_list|(
name|int
name|version
parameter_list|)
block|{
name|struct
name|apm_softc
modifier|*
name|sc
init|=
operator|&
name|apm_softc
decl_stmt|;
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|eax
operator|=
operator|(
name|APM_BIOS
operator|<<
literal|8
operator|)
operator||
name|APM_DRVVERSION
expr_stmt|;
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|ebx
operator|=
literal|0x0
expr_stmt|;
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|ecx
operator|=
name|version
expr_stmt|;
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|edx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|apm_bioscall
argument_list|()
operator|==
literal|0
operator|&&
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|eax
operator|==
name|version
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Some old BIOSes don't return the connection version in %ax. */
if|if
condition|(
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|eax
operator|==
operator|(
operator|(
name|APM_BIOS
operator|<<
literal|8
operator|)
operator||
name|APM_DRVVERSION
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* engage/disengage power management (APM 1.1 or later) */
end_comment

begin_function
specifier|static
name|int
name|apm_engage_disengage_pm
parameter_list|(
name|int
name|engage
parameter_list|)
block|{
name|struct
name|apm_softc
modifier|*
name|sc
init|=
operator|&
name|apm_softc
decl_stmt|;
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|eax
operator|=
operator|(
name|APM_BIOS
operator|<<
literal|8
operator|)
operator||
name|APM_ENGAGEDISENGAGEPM
expr_stmt|;
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|ebx
operator|=
name|PMDV_ALLDEV
expr_stmt|;
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|ecx
operator|=
name|engage
expr_stmt|;
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|edx
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|apm_bioscall
argument_list|()
operator|)
return|;
block|}
end_function

begin_comment
comment|/* get PM event */
end_comment

begin_function
specifier|static
name|u_int
name|apm_getevent
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|apm_softc
modifier|*
name|sc
init|=
operator|&
name|apm_softc
decl_stmt|;
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|eax
operator|=
operator|(
name|APM_BIOS
operator|<<
literal|8
operator|)
operator||
name|APM_GETPMEVENT
expr_stmt|;
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|ebx
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|ecx
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|edx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|apm_bioscall
argument_list|()
condition|)
return|return
operator|(
name|PMEV_NOEVENT
operator|)
return|;
return|return
operator|(
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|ebx
operator|&
literal|0xffff
operator|)
return|;
block|}
end_function

begin_comment
comment|/* suspend entire system */
end_comment

begin_function
specifier|static
name|int
name|apm_suspend_system
parameter_list|(
name|int
name|state
parameter_list|)
block|{
name|struct
name|apm_softc
modifier|*
name|sc
init|=
operator|&
name|apm_softc
decl_stmt|;
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|eax
operator|=
operator|(
name|APM_BIOS
operator|<<
literal|8
operator|)
operator||
name|APM_SETPWSTATE
expr_stmt|;
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|ebx
operator|=
name|PMDV_ALLDEV
expr_stmt|;
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|ecx
operator|=
name|state
expr_stmt|;
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|edx
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|apm_disable_smm
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|apm_bioscall
argument_list|()
condition|)
block|{
name|printf
argument_list|(
literal|"Entire system suspend failure: errcode = %d\n"
argument_list|,
literal|0xff
operator|&
operator|(
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|eax
operator|>>
literal|8
operator|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
ifdef|#
directive|ifdef
name|PC98
name|apm_enable_smm
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Display control */
end_comment

begin_comment
comment|/*  * Experimental implementation: My laptop machine can't handle this function  * If your laptop can control the display via APM, please inform me.  *                            HOSOKAWA, Tatsumi<hosokawa@jp.FreeBSD.org>  */
end_comment

begin_function
name|int
name|apm_display
parameter_list|(
name|int
name|newstate
parameter_list|)
block|{
name|struct
name|apm_softc
modifier|*
name|sc
init|=
operator|&
name|apm_softc
decl_stmt|;
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|eax
operator|=
operator|(
name|APM_BIOS
operator|<<
literal|8
operator|)
operator||
name|APM_SETPWSTATE
expr_stmt|;
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|ebx
operator|=
name|PMDV_DISP0
expr_stmt|;
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|ecx
operator|=
name|newstate
condition|?
name|PMST_APMENABLED
else|:
name|PMST_SUSPEND
expr_stmt|;
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|edx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|apm_bioscall
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|/* If failed, then try to blank all display devices instead. */
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|eax
operator|=
operator|(
name|APM_BIOS
operator|<<
literal|8
operator|)
operator||
name|APM_SETPWSTATE
expr_stmt|;
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|ebx
operator|=
name|PMDV_DISPALL
expr_stmt|;
comment|/* all display devices */
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|ecx
operator|=
name|newstate
condition|?
name|PMST_APMENABLED
else|:
name|PMST_SUSPEND
expr_stmt|;
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|edx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|apm_bioscall
argument_list|()
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
name|printf
argument_list|(
literal|"Display off failure: errcode = %d\n"
argument_list|,
literal|0xff
operator|&
operator|(
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|eax
operator|>>
literal|8
operator|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Turn off the entire system.  */
end_comment

begin_function
specifier|static
name|void
name|apm_power_off
parameter_list|(
name|void
modifier|*
name|junk
parameter_list|,
name|int
name|howto
parameter_list|)
block|{
name|struct
name|apm_softc
modifier|*
name|sc
init|=
operator|&
name|apm_softc
decl_stmt|;
comment|/* Not halting powering off, or not active */
if|if
condition|(
operator|!
operator|(
name|howto
operator|&
name|RB_POWEROFF
operator|)
operator|||
operator|!
name|apm_softc
operator|.
name|active
condition|)
return|return;
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|eax
operator|=
operator|(
name|APM_BIOS
operator|<<
literal|8
operator|)
operator||
name|APM_SETPWSTATE
expr_stmt|;
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|ebx
operator|=
name|PMDV_ALLDEV
expr_stmt|;
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|ecx
operator|=
name|PMST_OFF
expr_stmt|;
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|edx
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|apm_bioscall
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* APM Battery low handler */
end_comment

begin_function
specifier|static
name|void
name|apm_battery_low
parameter_list|(
name|void
parameter_list|)
block|{
name|printf
argument_list|(
literal|"\007\007 * * * BATTERY IS LOW * * * \007\007"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* APM hook manager */
end_comment

begin_function
specifier|static
name|struct
name|apmhook
modifier|*
name|apm_add_hook
parameter_list|(
name|struct
name|apmhook
modifier|*
modifier|*
name|list
parameter_list|,
name|struct
name|apmhook
modifier|*
name|ah
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|struct
name|apmhook
modifier|*
name|p
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
ifdef|#
directive|ifdef
name|APM_DEBUG
name|printf
argument_list|(
literal|"Add hook \"%s\"\n"
argument_list|,
name|ah
operator|->
name|ah_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
if|if
condition|(
name|ah
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"illegal apm_hook!"
argument_list|)
expr_stmt|;
name|prev
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|*
name|list
init|;
name|p
operator|!=
name|NULL
condition|;
name|prev
operator|=
name|p
operator|,
name|p
operator|=
name|p
operator|->
name|ah_next
control|)
if|if
condition|(
name|p
operator|->
name|ah_order
operator|>
name|ah
operator|->
name|ah_order
condition|)
break|break;
if|if
condition|(
name|prev
operator|==
name|NULL
condition|)
block|{
name|ah
operator|->
name|ah_next
operator|=
operator|*
name|list
expr_stmt|;
operator|*
name|list
operator|=
name|ah
expr_stmt|;
block|}
else|else
block|{
name|ah
operator|->
name|ah_next
operator|=
name|prev
operator|->
name|ah_next
expr_stmt|;
name|prev
operator|->
name|ah_next
operator|=
name|ah
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|ah
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|apm_del_hook
parameter_list|(
name|struct
name|apmhook
modifier|*
modifier|*
name|list
parameter_list|,
name|struct
name|apmhook
modifier|*
name|ah
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|struct
name|apmhook
modifier|*
name|p
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|prev
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|*
name|list
init|;
name|p
operator|!=
name|NULL
condition|;
name|prev
operator|=
name|p
operator|,
name|p
operator|=
name|p
operator|->
name|ah_next
control|)
if|if
condition|(
name|p
operator|==
name|ah
condition|)
goto|goto
name|deleteit
goto|;
name|panic
argument_list|(
literal|"Tried to delete unregistered apm_hook."
argument_list|)
expr_stmt|;
goto|goto
name|nosuchnode
goto|;
name|deleteit
label|:
if|if
condition|(
name|prev
operator|!=
name|NULL
condition|)
name|prev
operator|->
name|ah_next
operator|=
name|p
operator|->
name|ah_next
expr_stmt|;
else|else
operator|*
name|list
operator|=
name|p
operator|->
name|ah_next
expr_stmt|;
name|nosuchnode
label|:
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* APM driver calls some functions automatically */
end_comment

begin_function
specifier|static
name|void
name|apm_execute_hook
parameter_list|(
name|struct
name|apmhook
modifier|*
name|list
parameter_list|)
block|{
name|struct
name|apmhook
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|list
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|ah_next
control|)
block|{
ifdef|#
directive|ifdef
name|APM_DEBUG
name|printf
argument_list|(
literal|"Execute APM hook \"%s.\"\n"
argument_list|,
name|p
operator|->
name|ah_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
operator|*
operator|(
name|p
operator|->
name|ah_fun
operator|)
operator|)
operator|(
name|p
operator|->
name|ah_arg
operator|)
condition|)
name|printf
argument_list|(
literal|"Warning: APM hook \"%s\" failed"
argument_list|,
name|p
operator|->
name|ah_name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* establish an apm hook */
end_comment

begin_function
name|struct
name|apmhook
modifier|*
name|apm_hook_establish
parameter_list|(
name|int
name|apmh
parameter_list|,
name|struct
name|apmhook
modifier|*
name|ah
parameter_list|)
block|{
if|if
condition|(
name|apmh
operator|<
literal|0
operator|||
name|apmh
operator|>=
name|NAPM_HOOK
condition|)
return|return
name|NULL
return|;
return|return
name|apm_add_hook
argument_list|(
operator|&
name|hook
index|[
name|apmh
index|]
argument_list|,
name|ah
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* disestablish an apm hook */
end_comment

begin_function
name|void
name|apm_hook_disestablish
parameter_list|(
name|int
name|apmh
parameter_list|,
name|struct
name|apmhook
modifier|*
name|ah
parameter_list|)
block|{
if|if
condition|(
name|apmh
operator|<
literal|0
operator|||
name|apmh
operator|>=
name|NAPM_HOOK
condition|)
return|return;
name|apm_del_hook
argument_list|(
operator|&
name|hook
index|[
name|apmh
index|]
argument_list|,
name|ah
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|timeval
name|suspend_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|timeval
name|diff_time
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|apm_default_resume
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|pl
decl_stmt|;
name|u_int
name|second
decl_stmt|,
name|minute
decl_stmt|,
name|hour
decl_stmt|;
name|struct
name|timeval
name|resume_time
decl_stmt|,
name|tmp_time
decl_stmt|;
comment|/* modified for adjkerntz */
name|pl
operator|=
name|splsoftclock
argument_list|()
expr_stmt|;
name|i8254_restore
argument_list|()
expr_stmt|;
comment|/* restore timer_freq and hz */
name|inittodr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* adjust time to RTC */
name|microtime
argument_list|(
operator|&
name|resume_time
argument_list|)
expr_stmt|;
name|getmicrotime
argument_list|(
operator|&
name|tmp_time
argument_list|)
expr_stmt|;
name|timevaladd
argument_list|(
operator|&
name|tmp_time
argument_list|,
operator|&
name|diff_time
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FIXME
comment|/* XXX THIS DOESN'T WORK!!! */
name|time
operator|=
name|tmp_time
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|APM_FIXUP_CALLTODO
comment|/* Calculate the delta time suspended */
name|timevalsub
argument_list|(
operator|&
name|resume_time
argument_list|,
operator|&
name|suspend_time
argument_list|)
expr_stmt|;
comment|/* Fixup the calltodo list with the delta time. */
name|adjust_timeout_calltodo
argument_list|(
operator|&
name|resume_time
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* APM_FIXUP_CALLTODOK */
name|splx
argument_list|(
name|pl
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|APM_FIXUP_CALLTODO
name|second
operator|=
name|resume_time
operator|.
name|tv_sec
operator|-
name|suspend_time
operator|.
name|tv_sec
expr_stmt|;
else|#
directive|else
comment|/* APM_FIXUP_CALLTODO */
comment|/*  	 * We've already calculated resume_time to be the delta between  	 * the suspend and the resume.  	 */
name|second
operator|=
name|resume_time
operator|.
name|tv_sec
expr_stmt|;
endif|#
directive|endif
comment|/* APM_FIXUP_CALLTODO */
name|hour
operator|=
name|second
operator|/
literal|3600
expr_stmt|;
name|second
operator|%=
literal|3600
expr_stmt|;
name|minute
operator|=
name|second
operator|/
literal|60
expr_stmt|;
name|second
operator|%=
literal|60
expr_stmt|;
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"resumed from suspended mode (slept %02d:%02d:%02d)\n"
argument_list|,
name|hour
argument_list|,
name|minute
argument_list|,
name|second
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|apm_default_suspend
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|pl
decl_stmt|;
name|pl
operator|=
name|splsoftclock
argument_list|()
expr_stmt|;
name|microtime
argument_list|(
operator|&
name|diff_time
argument_list|)
expr_stmt|;
name|inittodr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|microtime
argument_list|(
operator|&
name|suspend_time
argument_list|)
expr_stmt|;
name|timevalsub
argument_list|(
operator|&
name|diff_time
argument_list|,
operator|&
name|suspend_time
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|pl
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|apm_record_event
name|__P
argument_list|(
operator|(
expr|struct
name|apm_softc
operator|*
operator|,
name|u_int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|apm_processevent
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|u_int
name|apm_op_inprog
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|apm_do_suspend
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|apm_softc
modifier|*
name|sc
init|=
operator|&
name|apm_softc
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|!
name|sc
condition|)
return|return;
name|apm_op_inprog
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|suspends
operator|=
name|sc
operator|->
name|suspend_countdown
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|initialized
condition|)
block|{
name|error
operator|=
name|DEVICE_SUSPEND
argument_list|(
name|root_bus
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|DEVICE_RESUME
argument_list|(
name|root_bus
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|apm_execute_hook
argument_list|(
name|hook
index|[
name|APM_HOOK_SUSPEND
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|apm_suspend_system
argument_list|(
name|PMST_SUSPEND
argument_list|)
operator|==
literal|0
condition|)
block|{
name|apm_processevent
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* Failure, 'resume' the system again */
name|apm_execute_hook
argument_list|(
name|hook
index|[
name|APM_HOOK_RESUME
index|]
argument_list|)
expr_stmt|;
name|DEVICE_RESUME
argument_list|(
name|root_bus
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|apm_do_standby
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|apm_softc
modifier|*
name|sc
init|=
operator|&
name|apm_softc
decl_stmt|;
if|if
condition|(
operator|!
name|sc
condition|)
return|return;
name|apm_op_inprog
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|standbys
operator|=
name|sc
operator|->
name|standby_countdown
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|initialized
condition|)
block|{
comment|/* 		 * As far as standby, we don't need to execute  		 * all of suspend hooks. 		 */
name|apm_default_suspend
argument_list|(
operator|&
name|apm_softc
argument_list|)
expr_stmt|;
if|if
condition|(
name|apm_suspend_system
argument_list|(
name|PMST_STANDBY
argument_list|)
operator|==
literal|0
condition|)
name|apm_processevent
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|apm_lastreq_notify
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|apm_softc
modifier|*
name|sc
init|=
operator|&
name|apm_softc
decl_stmt|;
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|eax
operator|=
operator|(
name|APM_BIOS
operator|<<
literal|8
operator|)
operator||
name|APM_SETPWSTATE
expr_stmt|;
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|ebx
operator|=
name|PMDV_ALLDEV
expr_stmt|;
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|ecx
operator|=
name|PMST_LASTREQNOTIFY
expr_stmt|;
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|edx
operator|=
literal|0
expr_stmt|;
name|apm_bioscall
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|apm_lastreq_rejected
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|apm_softc
modifier|*
name|sc
init|=
operator|&
name|apm_softc
decl_stmt|;
if|if
condition|(
name|apm_op_inprog
operator|==
literal|0
condition|)
block|{
return|return
literal|1
return|;
comment|/* no operation in progress */
block|}
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|eax
operator|=
operator|(
name|APM_BIOS
operator|<<
literal|8
operator|)
operator||
name|APM_SETPWSTATE
expr_stmt|;
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|ebx
operator|=
name|PMDV_ALLDEV
expr_stmt|;
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|ecx
operator|=
name|PMST_LASTREQREJECT
expr_stmt|;
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|edx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|apm_bioscall
argument_list|()
condition|)
block|{
ifdef|#
directive|ifdef
name|APM_DEBUG
name|printf
argument_list|(
literal|"apm_lastreq_rejected: failed\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|1
return|;
block|}
name|apm_op_inprog
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Public interface to the suspend/resume:  *  * Execute suspend and resume hook before and after sleep, respectively.  *  */
end_comment

begin_function
name|void
name|apm_suspend
parameter_list|(
name|int
name|state
parameter_list|)
block|{
name|struct
name|apm_softc
modifier|*
name|sc
init|=
operator|&
name|apm_softc
decl_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|initialized
condition|)
return|return;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|PMST_SUSPEND
case|:
if|if
condition|(
name|sc
operator|->
name|suspends
condition|)
return|return;
name|sc
operator|->
name|suspends
operator|++
expr_stmt|;
name|sc
operator|->
name|suspend_countdown
operator|=
name|apm_suspend_delay
expr_stmt|;
break|break;
case|case
name|PMST_STANDBY
case|:
if|if
condition|(
name|sc
operator|->
name|standbys
condition|)
return|return;
name|sc
operator|->
name|standbys
operator|++
expr_stmt|;
name|sc
operator|->
name|standby_countdown
operator|=
name|apm_standby_delay
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"apm_suspend: Unknown Suspend state 0x%x\n"
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return;
block|}
name|apm_op_inprog
operator|++
expr_stmt|;
name|apm_lastreq_notify
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|apm_resume
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|apm_softc
modifier|*
name|sc
init|=
operator|&
name|apm_softc
decl_stmt|;
if|if
condition|(
operator|!
name|sc
condition|)
return|return;
if|if
condition|(
name|sc
operator|->
name|initialized
condition|)
block|{
name|apm_execute_hook
argument_list|(
name|hook
index|[
name|APM_HOOK_RESUME
index|]
argument_list|)
expr_stmt|;
name|DEVICE_RESUME
argument_list|(
name|root_bus
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* get power status per battery */
end_comment

begin_function
specifier|static
name|int
name|apm_get_pwstatus
parameter_list|(
name|apm_pwstatus_t
name|app
parameter_list|)
block|{
name|struct
name|apm_softc
modifier|*
name|sc
init|=
operator|&
name|apm_softc
decl_stmt|;
if|if
condition|(
name|app
operator|->
name|ap_device
operator|!=
name|PMDV_ALLDEV
operator|&&
operator|(
name|app
operator|->
name|ap_device
operator|<
name|PMDV_BATT0
operator|||
name|app
operator|->
name|ap_device
operator|>
name|PMDV_BATT_ALL
operator|)
condition|)
return|return
literal|1
return|;
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|eax
operator|=
operator|(
name|APM_BIOS
operator|<<
literal|8
operator|)
operator||
name|APM_GETPWSTATUS
expr_stmt|;
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|ebx
operator|=
name|app
operator|->
name|ap_device
expr_stmt|;
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|ecx
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|edx
operator|=
literal|0xffff
expr_stmt|;
comment|/* default to unknown battery time */
if|if
condition|(
name|apm_bioscall
argument_list|()
condition|)
return|return
literal|1
return|;
name|app
operator|->
name|ap_acline
operator|=
operator|(
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|ebx
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|app
operator|->
name|ap_batt_stat
operator|=
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|ebx
operator|&
literal|0xff
expr_stmt|;
name|app
operator|->
name|ap_batt_flag
operator|=
operator|(
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|ecx
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|app
operator|->
name|ap_batt_life
operator|=
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|ecx
operator|&
literal|0xff
expr_stmt|;
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|edx
operator|&=
literal|0xffff
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|edx
operator|==
literal|0xffff
condition|)
comment|/* Time is unknown */
name|app
operator|->
name|ap_batt_time
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|edx
operator|&
literal|0x8000
condition|)
comment|/* Time is in minutes */
name|app
operator|->
name|ap_batt_time
operator|=
operator|(
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|edx
operator|&
literal|0x7fff
operator|)
operator|*
literal|60
expr_stmt|;
else|else
comment|/* Time is in seconds */
name|app
operator|->
name|ap_batt_time
operator|=
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|edx
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* get APM information */
end_comment

begin_function
specifier|static
name|int
name|apm_get_info
parameter_list|(
name|apm_info_t
name|aip
parameter_list|)
block|{
name|struct
name|apm_softc
modifier|*
name|sc
init|=
operator|&
name|apm_softc
decl_stmt|;
name|struct
name|apm_pwstatus
name|aps
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|aps
argument_list|,
sizeof|sizeof
argument_list|(
name|aps
argument_list|)
argument_list|)
expr_stmt|;
name|aps
operator|.
name|ap_device
operator|=
name|PMDV_ALLDEV
expr_stmt|;
if|if
condition|(
name|apm_get_pwstatus
argument_list|(
operator|&
name|aps
argument_list|)
condition|)
return|return
literal|1
return|;
name|aip
operator|->
name|ai_infoversion
operator|=
literal|1
expr_stmt|;
name|aip
operator|->
name|ai_acline
operator|=
name|aps
operator|.
name|ap_acline
expr_stmt|;
name|aip
operator|->
name|ai_batt_stat
operator|=
name|aps
operator|.
name|ap_batt_stat
expr_stmt|;
name|aip
operator|->
name|ai_batt_life
operator|=
name|aps
operator|.
name|ap_batt_life
expr_stmt|;
name|aip
operator|->
name|ai_batt_time
operator|=
name|aps
operator|.
name|ap_batt_time
expr_stmt|;
name|aip
operator|->
name|ai_major
operator|=
operator|(
name|u_int
operator|)
name|sc
operator|->
name|majorversion
expr_stmt|;
name|aip
operator|->
name|ai_minor
operator|=
operator|(
name|u_int
operator|)
name|sc
operator|->
name|minorversion
expr_stmt|;
name|aip
operator|->
name|ai_status
operator|=
operator|(
name|u_int
operator|)
name|sc
operator|->
name|active
expr_stmt|;
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|eax
operator|=
operator|(
name|APM_BIOS
operator|<<
literal|8
operator|)
operator||
name|APM_GETCAPABILITIES
expr_stmt|;
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|ebx
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|ecx
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|edx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|apm_bioscall
argument_list|()
condition|)
block|{
name|aip
operator|->
name|ai_batteries
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Unknown */
name|aip
operator|->
name|ai_capabilities
operator|=
literal|0xff00
expr_stmt|;
comment|/* Unknown, with no bits set */
block|}
else|else
block|{
name|aip
operator|->
name|ai_batteries
operator|=
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|ebx
operator|&
literal|0xff
expr_stmt|;
name|aip
operator|->
name|ai_capabilities
operator|=
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|ecx
operator|&
literal|0xf
expr_stmt|;
block|}
name|bzero
argument_list|(
name|aip
operator|->
name|ai_spare
argument_list|,
sizeof|sizeof
name|aip
operator|->
name|ai_spare
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* inform APM BIOS that CPU is idle */
end_comment

begin_function
name|void
name|apm_cpu_idle
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|apm_softc
modifier|*
name|sc
init|=
operator|&
name|apm_softc
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|active
condition|)
block|{
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|eax
operator|=
operator|(
name|APM_BIOS
operator|<<
literal|8
operator|)
operator||
name|APM_CPUIDLE
expr_stmt|;
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|edx
operator|=
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|ecx
operator|=
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|ebx
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|apm_bioscall
argument_list|()
expr_stmt|;
block|}
comment|/* 	 * Some APM implementation halts CPU in BIOS, whenever 	 * "CPU-idle" function are invoked, but swtch() of 	 * FreeBSD halts CPU, therefore, CPU is halted twice 	 * in the sched loop. It makes the interrupt latency 	 * terribly long and be able to cause a serious problem 	 * in interrupt processing. We prevent it by removing 	 * "hlt" operation from swtch() and managed it under 	 * APM driver. 	 */
if|if
condition|(
operator|!
name|sc
operator|->
name|active
operator|||
name|sc
operator|->
name|always_halt_cpu
condition|)
asm|__asm("hlt");
comment|/* wait for interrupt */
block|}
end_function

begin_comment
comment|/* inform APM BIOS that CPU is busy */
end_comment

begin_function
name|void
name|apm_cpu_busy
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|apm_softc
modifier|*
name|sc
init|=
operator|&
name|apm_softc
decl_stmt|;
comment|/* 	 * The APM specification says this is only necessary if your BIOS 	 * slows down the processor in the idle task, otherwise it's not 	 * necessary. 	 */
if|if
condition|(
name|sc
operator|->
name|slow_idle_cpu
operator|&&
name|sc
operator|->
name|active
condition|)
block|{
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|eax
operator|=
operator|(
name|APM_BIOS
operator|<<
literal|8
operator|)
operator||
name|APM_CPUBUSY
expr_stmt|;
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|edx
operator|=
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|ecx
operator|=
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|ebx
operator|=
literal|0
expr_stmt|;
name|apm_bioscall
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * APM timeout routine:  *  * This routine is automatically called by timer once per second.  */
end_comment

begin_function
specifier|static
name|void
name|apm_timeout
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
name|struct
name|apm_softc
modifier|*
name|sc
init|=
operator|&
name|apm_softc
decl_stmt|;
if|if
condition|(
name|apm_op_inprog
condition|)
name|apm_lastreq_notify
argument_list|()
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|standbys
operator|&&
name|sc
operator|->
name|standby_countdown
operator|--
operator|<=
literal|0
condition|)
name|apm_do_standby
argument_list|()
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|suspends
operator|&&
name|sc
operator|->
name|suspend_countdown
operator|--
operator|<=
literal|0
condition|)
name|apm_do_suspend
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|bios_busy
condition|)
name|apm_processevent
argument_list|()
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|active
operator|==
literal|1
condition|)
comment|/* Run slightly more oftan than 1 Hz */
name|apm_timeout_ch
operator|=
name|timeout
argument_list|(
name|apm_timeout
argument_list|,
name|NULL
argument_list|,
name|hz
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* enable APM BIOS */
end_comment

begin_function
specifier|static
name|void
name|apm_event_enable
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|apm_softc
modifier|*
name|sc
init|=
operator|&
name|apm_softc
decl_stmt|;
ifdef|#
directive|ifdef
name|APM_DEBUG
name|printf
argument_list|(
literal|"called apm_event_enable()\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|initialized
condition|)
block|{
name|sc
operator|->
name|active
operator|=
literal|1
expr_stmt|;
name|apm_timeout
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* disable APM BIOS */
end_comment

begin_function
specifier|static
name|void
name|apm_event_disable
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|apm_softc
modifier|*
name|sc
init|=
operator|&
name|apm_softc
decl_stmt|;
ifdef|#
directive|ifdef
name|APM_DEBUG
name|printf
argument_list|(
literal|"called apm_event_disable()\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|initialized
condition|)
block|{
name|untimeout
argument_list|(
name|apm_timeout
argument_list|,
name|NULL
argument_list|,
name|apm_timeout_ch
argument_list|)
expr_stmt|;
name|sc
operator|->
name|active
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* halt CPU in scheduling loop */
end_comment

begin_function
specifier|static
name|void
name|apm_halt_cpu
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|apm_softc
modifier|*
name|sc
init|=
operator|&
name|apm_softc
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|initialized
condition|)
name|sc
operator|->
name|always_halt_cpu
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* don't halt CPU in scheduling loop */
end_comment

begin_function
specifier|static
name|void
name|apm_not_halt_cpu
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|apm_softc
modifier|*
name|sc
init|=
operator|&
name|apm_softc
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|initialized
condition|)
name|sc
operator|->
name|always_halt_cpu
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* device driver definitions */
end_comment

begin_comment
comment|/*  * Create "connection point"  */
end_comment

begin_function
specifier|static
name|void
name|apm_identify
parameter_list|(
name|driver_t
modifier|*
name|driver
parameter_list|,
name|device_t
name|parent
parameter_list|)
block|{
name|device_t
name|child
decl_stmt|;
name|child
operator|=
name|BUS_ADD_CHILD
argument_list|(
name|parent
argument_list|,
literal|0
argument_list|,
literal|"apm"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"apm_identify"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * probe for APM BIOS  */
end_comment

begin_function
specifier|static
name|int
name|apm_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
define|#
directive|define
name|APM_KERNBASE
value|KERNBASE
name|struct
name|vm86frame
name|vmf
decl_stmt|;
name|struct
name|apm_softc
modifier|*
name|sc
init|=
operator|&
name|apm_softc
decl_stmt|;
name|int
name|disabled
decl_stmt|,
name|flags
decl_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|int
name|rid
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|resource_int_value
argument_list|(
literal|"apm"
argument_list|,
literal|0
argument_list|,
literal|"disabled"
argument_list|,
operator|&
name|disabled
argument_list|)
operator|==
literal|0
operator|&&
name|disabled
operator|!=
literal|0
condition|)
return|return
name|ENXIO
return|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"APM BIOS"
argument_list|)
expr_stmt|;
if|if
condition|(
name|device_get_unit
argument_list|(
name|dev
argument_list|)
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"apm: Only one APM driver supported.\n"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
if|if
condition|(
name|resource_int_value
argument_list|(
literal|"apm"
argument_list|,
literal|0
argument_list|,
literal|"flags"
argument_list|,
operator|&
name|flags
argument_list|)
operator|!=
literal|0
condition|)
name|flags
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|vmf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vm86frame
argument_list|)
argument_list|)
expr_stmt|;
comment|/* safety */
name|bzero
argument_list|(
operator|&
name|apm_softc
argument_list|,
sizeof|sizeof
argument_list|(
name|apm_softc
argument_list|)
argument_list|)
expr_stmt|;
name|vmf
operator|.
name|vmf_ah
operator|=
name|APM_BIOS
expr_stmt|;
name|vmf
operator|.
name|vmf_al
operator|=
name|APM_INSTCHECK
expr_stmt|;
name|vmf
operator|.
name|vmf_bx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vm86_intcall
argument_list|(
name|APM_INT
argument_list|,
operator|&
name|vmf
argument_list|)
condition|)
return|return
name|ENXIO
return|;
comment|/* APM not found */
if|if
condition|(
name|vmf
operator|.
name|vmf_bx
operator|!=
literal|0x504d
condition|)
block|{
name|printf
argument_list|(
literal|"apm: incorrect signature (0x%x)\n"
argument_list|,
name|vmf
operator|.
name|vmf_bx
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
if|if
condition|(
operator|(
name|vmf
operator|.
name|vmf_cx
operator|&
operator|(
name|APM_32BIT_SUPPORT
operator||
name|APM_16BIT_SUPPORT
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"apm: protected mode connections are not supported\n"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|apm_version
operator|=
name|vmf
operator|.
name|vmf_ax
expr_stmt|;
name|sc
operator|->
name|slow_idle_cpu
operator|=
operator|(
operator|(
name|vmf
operator|.
name|vmf_cx
operator|&
name|APM_CPUIDLE_SLOW
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|sc
operator|->
name|disabled
operator|=
operator|(
operator|(
name|vmf
operator|.
name|vmf_cx
operator|&
name|APM_DISABLED
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|sc
operator|->
name|disengaged
operator|=
operator|(
operator|(
name|vmf
operator|.
name|vmf_cx
operator|&
name|APM_DISENGAGED
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|vmf
operator|.
name|vmf_ah
operator|=
name|APM_BIOS
expr_stmt|;
name|vmf
operator|.
name|vmf_al
operator|=
name|APM_DISCONNECT
expr_stmt|;
name|vmf
operator|.
name|vmf_bx
operator|=
literal|0
expr_stmt|;
name|vm86_intcall
argument_list|(
name|APM_INT
argument_list|,
operator|&
name|vmf
argument_list|)
expr_stmt|;
comment|/* disconnect, just in case */
ifdef|#
directive|ifdef
name|PC98
comment|/* PC98 have bogos APM 32bit BIOS */
if|if
condition|(
operator|(
name|vmf
operator|.
name|vmf_cx
operator|&
name|APM_32BIT_SUPPORT
operator|)
operator|==
literal|0
condition|)
return|return
name|ENXIO
return|;
name|rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_res
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|rid
argument_list|,
name|APM_NECSMM_PORT
argument_list|,
operator|~
literal|0
argument_list|,
name|APM_NECSMM_PORTSZ
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_res
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"apm: cannot open NEC smm device\n"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|rid
argument_list|,
name|sc
operator|->
name|sc_res
argument_list|)
expr_stmt|;
name|vmf
operator|.
name|vmf_ah
operator|=
name|APM_BIOS
expr_stmt|;
name|vmf
operator|.
name|vmf_al
operator|=
name|APM_PROT32CONNECT
expr_stmt|;
name|vmf
operator|.
name|vmf_bx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vm86_intcall
argument_list|(
name|APM_INT
argument_list|,
operator|&
name|vmf
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"apm: 32-bit connection error.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|sc
operator|->
name|bios
operator|.
name|seg
operator|.
name|code32
operator|.
name|base
operator|=
operator|(
name|vmf
operator|.
name|vmf_ax
operator|<<
literal|4
operator|)
operator|+
name|APM_KERNBASE
expr_stmt|;
name|sc
operator|->
name|bios
operator|.
name|seg
operator|.
name|code32
operator|.
name|limit
operator|=
literal|0xffff
expr_stmt|;
name|sc
operator|->
name|bios
operator|.
name|seg
operator|.
name|code16
operator|.
name|base
operator|=
operator|(
name|vmf
operator|.
name|vmf_cx
operator|<<
literal|4
operator|)
operator|+
name|APM_KERNBASE
expr_stmt|;
name|sc
operator|->
name|bios
operator|.
name|seg
operator|.
name|code16
operator|.
name|limit
operator|=
literal|0xffff
expr_stmt|;
name|sc
operator|->
name|bios
operator|.
name|seg
operator|.
name|data
operator|.
name|base
operator|=
operator|(
name|vmf
operator|.
name|vmf_dx
operator|<<
literal|4
operator|)
operator|+
name|APM_KERNBASE
expr_stmt|;
name|sc
operator|->
name|bios
operator|.
name|seg
operator|.
name|data
operator|.
name|limit
operator|=
literal|0xffff
expr_stmt|;
name|sc
operator|->
name|bios
operator|.
name|entry
operator|=
name|vmf
operator|.
name|vmf_ebx
expr_stmt|;
name|sc
operator|->
name|connectmode
operator|=
name|APM_PROT32CONNECT
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|(
name|vmf
operator|.
name|vmf_cx
operator|&
name|APM_32BIT_SUPPORT
operator|)
operator|!=
literal|0
condition|)
block|{
name|vmf
operator|.
name|vmf_ah
operator|=
name|APM_BIOS
expr_stmt|;
name|vmf
operator|.
name|vmf_al
operator|=
name|APM_PROT32CONNECT
expr_stmt|;
name|vmf
operator|.
name|vmf_bx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vm86_intcall
argument_list|(
name|APM_INT
argument_list|,
operator|&
name|vmf
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"apm: 32-bit connection error.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|sc
operator|->
name|bios
operator|.
name|seg
operator|.
name|code32
operator|.
name|base
operator|=
operator|(
name|vmf
operator|.
name|vmf_ax
operator|<<
literal|4
operator|)
operator|+
name|APM_KERNBASE
expr_stmt|;
name|sc
operator|->
name|bios
operator|.
name|seg
operator|.
name|code32
operator|.
name|limit
operator|=
literal|0xffff
expr_stmt|;
name|sc
operator|->
name|bios
operator|.
name|seg
operator|.
name|code16
operator|.
name|base
operator|=
operator|(
name|vmf
operator|.
name|vmf_cx
operator|<<
literal|4
operator|)
operator|+
name|APM_KERNBASE
expr_stmt|;
name|sc
operator|->
name|bios
operator|.
name|seg
operator|.
name|code16
operator|.
name|limit
operator|=
literal|0xffff
expr_stmt|;
name|sc
operator|->
name|bios
operator|.
name|seg
operator|.
name|data
operator|.
name|base
operator|=
operator|(
name|vmf
operator|.
name|vmf_dx
operator|<<
literal|4
operator|)
operator|+
name|APM_KERNBASE
expr_stmt|;
name|sc
operator|->
name|bios
operator|.
name|seg
operator|.
name|data
operator|.
name|limit
operator|=
literal|0xffff
expr_stmt|;
name|sc
operator|->
name|bios
operator|.
name|entry
operator|=
name|vmf
operator|.
name|vmf_ebx
expr_stmt|;
name|sc
operator|->
name|connectmode
operator|=
name|APM_PROT32CONNECT
expr_stmt|;
block|}
else|else
block|{
comment|/* use 16-bit connection */
name|vmf
operator|.
name|vmf_ah
operator|=
name|APM_BIOS
expr_stmt|;
name|vmf
operator|.
name|vmf_al
operator|=
name|APM_PROT16CONNECT
expr_stmt|;
name|vmf
operator|.
name|vmf_bx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vm86_intcall
argument_list|(
name|APM_INT
argument_list|,
operator|&
name|vmf
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"apm: 16-bit connection error.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|sc
operator|->
name|bios
operator|.
name|seg
operator|.
name|code16
operator|.
name|base
operator|=
operator|(
name|vmf
operator|.
name|vmf_ax
operator|<<
literal|4
operator|)
operator|+
name|APM_KERNBASE
expr_stmt|;
name|sc
operator|->
name|bios
operator|.
name|seg
operator|.
name|code16
operator|.
name|limit
operator|=
literal|0xffff
expr_stmt|;
name|sc
operator|->
name|bios
operator|.
name|seg
operator|.
name|data
operator|.
name|base
operator|=
operator|(
name|vmf
operator|.
name|vmf_cx
operator|<<
literal|4
operator|)
operator|+
name|APM_KERNBASE
expr_stmt|;
name|sc
operator|->
name|bios
operator|.
name|seg
operator|.
name|data
operator|.
name|limit
operator|=
literal|0xffff
expr_stmt|;
name|sc
operator|->
name|bios
operator|.
name|entry
operator|=
name|vmf
operator|.
name|vmf_bx
expr_stmt|;
name|sc
operator|->
name|connectmode
operator|=
name|APM_PROT16CONNECT
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * return 0 if the user will notice and handle the event,  * return 1 if the kernel driver should do so.  */
end_comment

begin_function
specifier|static
name|int
name|apm_record_event
parameter_list|(
name|struct
name|apm_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|event_type
parameter_list|)
block|{
name|struct
name|apm_event_info
modifier|*
name|evp
decl_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|SCFLAG_OPEN
operator|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
comment|/* no user waiting */
if|if
condition|(
name|sc
operator|->
name|event_count
operator|==
name|APM_NEVENTS
condition|)
return|return
literal|1
return|;
comment|/* overflow */
if|if
condition|(
name|sc
operator|->
name|event_filter
index|[
name|event_type
index|]
operator|==
literal|0
condition|)
return|return
literal|1
return|;
comment|/* not registered */
name|evp
operator|=
operator|&
name|sc
operator|->
name|event_list
index|[
name|sc
operator|->
name|event_ptr
index|]
expr_stmt|;
name|sc
operator|->
name|event_count
operator|++
expr_stmt|;
name|sc
operator|->
name|event_ptr
operator|++
expr_stmt|;
name|sc
operator|->
name|event_ptr
operator|%=
name|APM_NEVENTS
expr_stmt|;
name|evp
operator|->
name|type
operator|=
name|event_type
expr_stmt|;
name|evp
operator|->
name|index
operator|=
operator|++
name|apm_evindex
expr_stmt|;
name|selwakeup
argument_list|(
operator|&
name|sc
operator|->
name|sc_rsel
argument_list|)
expr_stmt|;
return|return
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|SCFLAG_OCTL
operator|)
condition|?
literal|0
else|:
literal|1
return|;
comment|/* user may handle */
block|}
end_function

begin_comment
comment|/* Process APM event */
end_comment

begin_function
specifier|static
name|void
name|apm_processevent
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|apm_event
decl_stmt|;
name|struct
name|apm_softc
modifier|*
name|sc
init|=
operator|&
name|apm_softc
decl_stmt|;
ifdef|#
directive|ifdef
name|APM_DEBUG
define|#
directive|define
name|OPMEV_DEBUGMESSAGE
parameter_list|(
name|symbol
parameter_list|)
value|case symbol: \ 	printf("Received APM Event: " #symbol "\n");
else|#
directive|else
define|#
directive|define
name|OPMEV_DEBUGMESSAGE
parameter_list|(
name|symbol
parameter_list|)
value|case symbol:
endif|#
directive|endif
do|do
block|{
name|apm_event
operator|=
name|apm_getevent
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|apm_event
condition|)
block|{
name|OPMEV_DEBUGMESSAGE
argument_list|(
name|PMEV_STANDBYREQ
argument_list|)
expr_stmt|;
if|if
condition|(
name|apm_op_inprog
operator|==
literal|0
condition|)
block|{
name|apm_op_inprog
operator|++
expr_stmt|;
if|if
condition|(
name|apm_record_event
argument_list|(
name|sc
argument_list|,
name|apm_event
argument_list|)
condition|)
block|{
name|apm_suspend
argument_list|(
name|PMST_STANDBY
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
name|OPMEV_DEBUGMESSAGE
argument_list|(
name|PMEV_USERSTANDBYREQ
argument_list|)
expr_stmt|;
if|if
condition|(
name|apm_op_inprog
operator|==
literal|0
condition|)
block|{
name|apm_op_inprog
operator|++
expr_stmt|;
if|if
condition|(
name|apm_record_event
argument_list|(
name|sc
argument_list|,
name|apm_event
argument_list|)
condition|)
block|{
name|apm_suspend
argument_list|(
name|PMST_STANDBY
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
name|OPMEV_DEBUGMESSAGE
argument_list|(
name|PMEV_SUSPENDREQ
argument_list|)
expr_stmt|;
name|apm_lastreq_notify
argument_list|()
expr_stmt|;
if|if
condition|(
name|apm_op_inprog
operator|==
literal|0
condition|)
block|{
name|apm_op_inprog
operator|++
expr_stmt|;
if|if
condition|(
name|apm_record_event
argument_list|(
name|sc
argument_list|,
name|apm_event
argument_list|)
condition|)
block|{
name|apm_do_suspend
argument_list|()
expr_stmt|;
block|}
block|}
return|return;
comment|/* XXX skip the rest */
name|OPMEV_DEBUGMESSAGE
argument_list|(
name|PMEV_USERSUSPENDREQ
argument_list|)
expr_stmt|;
name|apm_lastreq_notify
argument_list|()
expr_stmt|;
if|if
condition|(
name|apm_op_inprog
operator|==
literal|0
condition|)
block|{
name|apm_op_inprog
operator|++
expr_stmt|;
if|if
condition|(
name|apm_record_event
argument_list|(
name|sc
argument_list|,
name|apm_event
argument_list|)
condition|)
block|{
name|apm_do_suspend
argument_list|()
expr_stmt|;
block|}
block|}
return|return;
comment|/* XXX skip the rest */
name|OPMEV_DEBUGMESSAGE
argument_list|(
name|PMEV_CRITSUSPEND
argument_list|)
expr_stmt|;
name|apm_do_suspend
argument_list|()
expr_stmt|;
break|break;
name|OPMEV_DEBUGMESSAGE
argument_list|(
name|PMEV_NORMRESUME
argument_list|)
expr_stmt|;
name|apm_record_event
argument_list|(
name|sc
argument_list|,
name|apm_event
argument_list|)
expr_stmt|;
name|apm_resume
argument_list|()
expr_stmt|;
break|break;
name|OPMEV_DEBUGMESSAGE
argument_list|(
name|PMEV_CRITRESUME
argument_list|)
expr_stmt|;
name|apm_record_event
argument_list|(
name|sc
argument_list|,
name|apm_event
argument_list|)
expr_stmt|;
name|apm_resume
argument_list|()
expr_stmt|;
break|break;
name|OPMEV_DEBUGMESSAGE
argument_list|(
name|PMEV_STANDBYRESUME
argument_list|)
expr_stmt|;
name|apm_record_event
argument_list|(
name|sc
argument_list|,
name|apm_event
argument_list|)
expr_stmt|;
name|apm_resume
argument_list|()
expr_stmt|;
break|break;
name|OPMEV_DEBUGMESSAGE
argument_list|(
name|PMEV_BATTERYLOW
argument_list|)
expr_stmt|;
if|if
condition|(
name|apm_record_event
argument_list|(
name|sc
argument_list|,
name|apm_event
argument_list|)
condition|)
block|{
name|apm_battery_low
argument_list|()
expr_stmt|;
name|apm_suspend
argument_list|(
name|PMST_SUSPEND
argument_list|)
expr_stmt|;
block|}
break|break;
name|OPMEV_DEBUGMESSAGE
argument_list|(
name|PMEV_POWERSTATECHANGE
argument_list|)
expr_stmt|;
name|apm_record_event
argument_list|(
name|sc
argument_list|,
name|apm_event
argument_list|)
expr_stmt|;
break|break;
name|OPMEV_DEBUGMESSAGE
argument_list|(
name|PMEV_UPDATETIME
argument_list|)
expr_stmt|;
name|apm_record_event
argument_list|(
name|sc
argument_list|,
name|apm_event
argument_list|)
expr_stmt|;
name|inittodr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* adjust time to RTC */
break|break;
name|OPMEV_DEBUGMESSAGE
argument_list|(
name|PMEV_CAPABILITIESCHANGE
argument_list|)
expr_stmt|;
name|apm_record_event
argument_list|(
name|sc
argument_list|,
name|apm_event
argument_list|)
expr_stmt|;
break|break;
case|case
name|PMEV_NOEVENT
case|:
break|break;
default|default:
name|printf
argument_list|(
literal|"Unknown Original APM Event 0x%x\n"
argument_list|,
name|apm_event
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|apm_event
operator|!=
name|PMEV_NOEVENT
condition|)
do|;
ifdef|#
directive|ifdef
name|PC98
name|apm_disable_smm
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Attach APM:  *  * Initialize APM driver  */
end_comment

begin_function
specifier|static
name|int
name|apm_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|apm_softc
modifier|*
name|sc
init|=
operator|&
name|apm_softc
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|drv_version
decl_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|int
name|rid
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|resource_int_value
argument_list|(
literal|"apm"
argument_list|,
literal|0
argument_list|,
literal|"flags"
argument_list|,
operator|&
name|flags
argument_list|)
operator|!=
literal|0
condition|)
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flags
operator|&
literal|0x20
condition|)
name|statclock_disable
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|initialized
operator|=
literal|0
expr_stmt|;
comment|/* Must be externally enabled */
name|sc
operator|->
name|active
operator|=
literal|0
expr_stmt|;
comment|/* Always call HLT in idle loop */
name|sc
operator|->
name|always_halt_cpu
operator|=
literal|1
expr_stmt|;
comment|/* print bootstrap messages */
ifdef|#
directive|ifdef
name|APM_DEBUG
name|printf
argument_list|(
literal|"apm: APM BIOS version %04x\n"
argument_list|,
name|apm_version
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"apm: Code16 0x%08x, Data 0x%08x\n"
argument_list|,
name|sc
operator|->
name|bios
operator|.
name|seg
operator|.
name|code16
operator|.
name|base
argument_list|,
name|sc
operator|->
name|bios
operator|.
name|seg
operator|.
name|data
operator|.
name|base
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"apm: Code entry 0x%08x, Idling CPU %s, Management %s\n"
argument_list|,
name|sc
operator|->
name|bios
operator|.
name|entry
argument_list|,
name|is_enabled
argument_list|(
name|sc
operator|->
name|slow_idle_cpu
argument_list|)
argument_list|,
name|is_enabled
argument_list|(
operator|!
name|sc
operator|->
name|disabled
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"apm: CS_limit=0x%x, DS_limit=0x%x\n"
argument_list|,
name|sc
operator|->
name|bios
operator|.
name|seg
operator|.
name|code16
operator|.
name|limit
argument_list|,
name|sc
operator|->
name|bios
operator|.
name|seg
operator|.
name|data
operator|.
name|limit
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* APM_DEBUG */
ifdef|#
directive|ifdef
name|PC98
name|rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_res
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|rid
argument_list|,
name|APM_NECSMM_PORT
argument_list|,
operator|~
literal|0
argument_list|,
name|APM_NECSMM_PORTSZ
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_res
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"%s: counldn't map I/O ports"
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_iot
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|sc_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ioh
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|sc_res
argument_list|)
expr_stmt|;
if|if
condition|(
name|apm_version
operator|==
literal|0x112
operator|||
name|apm_version
operator|==
literal|0x111
operator|||
name|apm_version
operator|==
literal|0x110
condition|)
name|apm_necsmm_addr
operator|=
name|APM_NECSMM_PORT
expr_stmt|;
else|else
name|apm_necsmm_addr
operator|=
literal|0
expr_stmt|;
name|apm_necsmm_mask
operator|=
operator|~
name|APM_NECSMM_EN
expr_stmt|;
endif|#
directive|endif
comment|/* PC98 */
comment|/*          * In one test, apm bios version was 1.02; an attempt to register          * a 1.04 driver resulted in a 1.00 connection!  Registering a          * 1.02 driver resulted in a 1.02 connection.          */
name|drv_version
operator|=
name|apm_version
operator|>
literal|0x102
condition|?
literal|0x102
else|:
name|apm_version
expr_stmt|;
for|for
control|(
init|;
name|drv_version
operator|>
literal|0x100
condition|;
name|drv_version
operator|--
control|)
if|if
condition|(
name|apm_driver_version
argument_list|(
name|drv_version
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|sc
operator|->
name|minorversion
operator|=
operator|(
operator|(
name|drv_version
operator|&
literal|0x00f0
operator|)
operator|>>
literal|4
operator|)
operator|*
literal|10
operator|+
operator|(
operator|(
name|drv_version
operator|&
literal|0x000f
operator|)
operator|>>
literal|0
operator|)
expr_stmt|;
name|sc
operator|->
name|majorversion
operator|=
operator|(
operator|(
name|drv_version
operator|&
literal|0xf000
operator|)
operator|>>
literal|12
operator|)
operator|*
literal|10
operator|+
operator|(
operator|(
name|apm_version
operator|&
literal|0x0f00
operator|)
operator|>>
literal|8
operator|)
expr_stmt|;
name|sc
operator|->
name|intversion
operator|=
name|INTVERSION
argument_list|(
name|sc
operator|->
name|majorversion
argument_list|,
name|sc
operator|->
name|minorversion
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|APM_DEBUG
if|if
condition|(
name|sc
operator|->
name|intversion
operator|>=
name|INTVERSION
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
condition|)
name|printf
argument_list|(
literal|"apm: Engaged control %s\n"
argument_list|,
name|is_enabled
argument_list|(
operator|!
name|sc
operator|->
name|disengaged
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"apm: found APM BIOS v%ld.%ld, connected at v%d.%d\n"
argument_list|,
operator|(
operator|(
name|apm_version
operator|&
literal|0xf000
operator|)
operator|>>
literal|12
operator|)
operator|*
literal|10
operator|+
operator|(
operator|(
name|apm_version
operator|&
literal|0x0f00
operator|)
operator|>>
literal|8
operator|)
argument_list|,
operator|(
operator|(
name|apm_version
operator|&
literal|0x00f0
operator|)
operator|>>
literal|4
operator|)
operator|*
literal|10
operator|+
operator|(
operator|(
name|apm_version
operator|&
literal|0x000f
operator|)
operator|>>
literal|0
operator|)
argument_list|,
name|sc
operator|->
name|majorversion
argument_list|,
name|sc
operator|->
name|minorversion
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|APM_DEBUG
name|printf
argument_list|(
literal|"apm: Slow Idling CPU %s\n"
argument_list|,
name|is_enabled
argument_list|(
name|sc
operator|->
name|slow_idle_cpu
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* enable power management */
if|if
condition|(
name|sc
operator|->
name|disabled
condition|)
block|{
if|if
condition|(
name|apm_enable_disable_pm
argument_list|(
literal|1
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|APM_DEBUG
name|printf
argument_list|(
literal|"apm: *Warning* enable function failed! [%x]\n"
argument_list|,
operator|(
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|eax
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
comment|/* engage power managment (APM 1.1 or later) */
if|if
condition|(
name|sc
operator|->
name|intversion
operator|>=
name|INTVERSION
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
operator|&&
name|sc
operator|->
name|disengaged
condition|)
block|{
if|if
condition|(
name|apm_engage_disengage_pm
argument_list|(
literal|1
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|APM_DEBUG
name|printf
argument_list|(
literal|"apm: *Warning* engage function failed err=[%x]"
argument_list|,
operator|(
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|eax
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" (Docked or using external power?).\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
comment|/* default suspend hook */
name|sc
operator|->
name|sc_suspend
operator|.
name|ah_fun
operator|=
name|apm_default_suspend
expr_stmt|;
name|sc
operator|->
name|sc_suspend
operator|.
name|ah_arg
operator|=
name|sc
expr_stmt|;
name|sc
operator|->
name|sc_suspend
operator|.
name|ah_name
operator|=
literal|"default suspend"
expr_stmt|;
name|sc
operator|->
name|sc_suspend
operator|.
name|ah_order
operator|=
name|APM_MAX_ORDER
expr_stmt|;
comment|/* default resume hook */
name|sc
operator|->
name|sc_resume
operator|.
name|ah_fun
operator|=
name|apm_default_resume
expr_stmt|;
name|sc
operator|->
name|sc_resume
operator|.
name|ah_arg
operator|=
name|sc
expr_stmt|;
name|sc
operator|->
name|sc_resume
operator|.
name|ah_name
operator|=
literal|"default resume"
expr_stmt|;
name|sc
operator|->
name|sc_resume
operator|.
name|ah_order
operator|=
name|APM_MIN_ORDER
expr_stmt|;
name|apm_hook_establish
argument_list|(
name|APM_HOOK_SUSPEND
argument_list|,
operator|&
name|sc
operator|->
name|sc_suspend
argument_list|)
expr_stmt|;
name|apm_hook_establish
argument_list|(
name|APM_HOOK_RESUME
argument_list|,
operator|&
name|sc
operator|->
name|sc_resume
argument_list|)
expr_stmt|;
comment|/* Power the system off using APM */
name|EVENTHANDLER_REGISTER
argument_list|(
name|shutdown_final
argument_list|,
name|apm_power_off
argument_list|,
name|NULL
argument_list|,
name|SHUTDOWN_PRI_LAST
argument_list|)
expr_stmt|;
name|sc
operator|->
name|initialized
operator|=
literal|1
expr_stmt|;
name|make_dev
argument_list|(
operator|&
name|apm_cdevsw
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|5
argument_list|,
literal|0660
argument_list|,
literal|"apm"
argument_list|)
expr_stmt|;
name|make_dev
argument_list|(
operator|&
name|apm_cdevsw
argument_list|,
literal|8
argument_list|,
literal|0
argument_list|,
literal|5
argument_list|,
literal|0660
argument_list|,
literal|"apmctl"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|apmopen
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|apm_softc
modifier|*
name|sc
init|=
operator|&
name|apm_softc
decl_stmt|;
name|int
name|ctl
init|=
name|APMDEV
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|initialized
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
switch|switch
condition|(
name|ctl
condition|)
block|{
case|case
name|APMDEV_CTL
case|:
if|if
condition|(
operator|!
operator|(
name|flag
operator|&
name|FWRITE
operator|)
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SCFLAG_OCTL
condition|)
return|return
name|EBUSY
return|;
name|sc
operator|->
name|sc_flags
operator||=
name|SCFLAG_OCTL
expr_stmt|;
name|bzero
argument_list|(
name|sc
operator|->
name|event_filter
argument_list|,
sizeof|sizeof
name|sc
operator|->
name|event_filter
argument_list|)
expr_stmt|;
break|break;
case|case
name|APMDEV_NORMAL
case|:
name|sc
operator|->
name|sc_flags
operator||=
name|SCFLAG_ONORMAL
expr_stmt|;
break|break;
default|default:
return|return
name|ENXIO
return|;
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|apmclose
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|apm_softc
modifier|*
name|sc
init|=
operator|&
name|apm_softc
decl_stmt|;
name|int
name|ctl
init|=
name|APMDEV
argument_list|(
name|dev
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|ctl
condition|)
block|{
case|case
name|APMDEV_CTL
case|:
name|apm_lastreq_rejected
argument_list|()
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|SCFLAG_OCTL
expr_stmt|;
name|bzero
argument_list|(
name|sc
operator|->
name|event_filter
argument_list|,
sizeof|sizeof
name|sc
operator|->
name|event_filter
argument_list|)
expr_stmt|;
break|break;
case|case
name|APMDEV_NORMAL
case|:
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|SCFLAG_ONORMAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|SCFLAG_OPEN
operator|)
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|event_count
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|event_ptr
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|apmioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|apm_softc
modifier|*
name|sc
init|=
operator|&
name|apm_softc
decl_stmt|;
name|struct
name|apm_bios_arg
modifier|*
name|args
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|int
name|newstate
decl_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|initialized
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
ifdef|#
directive|ifdef
name|APM_DEBUG
name|printf
argument_list|(
literal|"APM ioctl: cmd = 0x%x\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|APMIO_SUSPEND
case|:
if|if
condition|(
operator|!
operator|(
name|flag
operator|&
name|FWRITE
operator|)
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
if|if
condition|(
name|sc
operator|->
name|active
condition|)
name|apm_suspend
argument_list|(
name|PMST_SUSPEND
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|APMIO_STANDBY
case|:
if|if
condition|(
operator|!
operator|(
name|flag
operator|&
name|FWRITE
operator|)
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
if|if
condition|(
name|sc
operator|->
name|active
condition|)
name|apm_suspend
argument_list|(
name|PMST_STANDBY
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|APMIO_GETINFO_OLD
case|:
block|{
name|struct
name|apm_info
name|info
decl_stmt|;
name|apm_info_old_t
name|aiop
decl_stmt|;
if|if
condition|(
name|apm_get_info
argument_list|(
operator|&
name|info
argument_list|)
condition|)
name|error
operator|=
name|ENXIO
expr_stmt|;
name|aiop
operator|=
operator|(
name|apm_info_old_t
operator|)
name|addr
expr_stmt|;
name|aiop
operator|->
name|ai_major
operator|=
name|info
operator|.
name|ai_major
expr_stmt|;
name|aiop
operator|->
name|ai_minor
operator|=
name|info
operator|.
name|ai_minor
expr_stmt|;
name|aiop
operator|->
name|ai_acline
operator|=
name|info
operator|.
name|ai_acline
expr_stmt|;
name|aiop
operator|->
name|ai_batt_stat
operator|=
name|info
operator|.
name|ai_batt_stat
expr_stmt|;
name|aiop
operator|->
name|ai_batt_life
operator|=
name|info
operator|.
name|ai_batt_life
expr_stmt|;
name|aiop
operator|->
name|ai_status
operator|=
name|info
operator|.
name|ai_status
expr_stmt|;
block|}
break|break;
case|case
name|APMIO_GETINFO
case|:
if|if
condition|(
name|apm_get_info
argument_list|(
operator|(
name|apm_info_t
operator|)
name|addr
argument_list|)
condition|)
name|error
operator|=
name|ENXIO
expr_stmt|;
break|break;
case|case
name|APMIO_GETPWSTATUS
case|:
if|if
condition|(
name|apm_get_pwstatus
argument_list|(
operator|(
name|apm_pwstatus_t
operator|)
name|addr
argument_list|)
condition|)
name|error
operator|=
name|ENXIO
expr_stmt|;
break|break;
case|case
name|APMIO_ENABLE
case|:
if|if
condition|(
operator|!
operator|(
name|flag
operator|&
name|FWRITE
operator|)
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
name|apm_event_enable
argument_list|()
expr_stmt|;
break|break;
case|case
name|APMIO_DISABLE
case|:
if|if
condition|(
operator|!
operator|(
name|flag
operator|&
name|FWRITE
operator|)
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
name|apm_event_disable
argument_list|()
expr_stmt|;
break|break;
case|case
name|APMIO_HALTCPU
case|:
if|if
condition|(
operator|!
operator|(
name|flag
operator|&
name|FWRITE
operator|)
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
name|apm_halt_cpu
argument_list|()
expr_stmt|;
break|break;
case|case
name|APMIO_NOTHALTCPU
case|:
if|if
condition|(
operator|!
operator|(
name|flag
operator|&
name|FWRITE
operator|)
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
name|apm_not_halt_cpu
argument_list|()
expr_stmt|;
break|break;
case|case
name|APMIO_DISPLAY
case|:
if|if
condition|(
operator|!
operator|(
name|flag
operator|&
name|FWRITE
operator|)
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
name|newstate
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
expr_stmt|;
if|if
condition|(
name|apm_display
argument_list|(
name|newstate
argument_list|)
condition|)
name|error
operator|=
name|ENXIO
expr_stmt|;
break|break;
case|case
name|APMIO_BIOS
case|:
if|if
condition|(
operator|!
operator|(
name|flag
operator|&
name|FWRITE
operator|)
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
comment|/* XXX compatibility with the old interface */
name|args
operator|=
operator|(
expr|struct
name|apm_bios_arg
operator|*
operator|)
name|addr
expr_stmt|;
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|eax
operator|=
name|args
operator|->
name|eax
expr_stmt|;
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|ebx
operator|=
name|args
operator|->
name|ebx
expr_stmt|;
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|ecx
operator|=
name|args
operator|->
name|ecx
expr_stmt|;
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|edx
operator|=
name|args
operator|->
name|edx
expr_stmt|;
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|esi
operator|=
name|args
operator|->
name|esi
expr_stmt|;
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|edi
operator|=
name|args
operator|->
name|edi
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|apm_bioscall
argument_list|()
operator|)
condition|)
block|{
comment|/* 			 * Return code 1 means bios call was unsuccessful. 			 * Error code is stored in %ah. 			 * Return code -1 means bios call was unsupported 			 * in the APM BIOS version. 			 */
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 			 * Return code 0 means bios call was successful. 			 * We need only %al and can discard %ah. 			 */
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|eax
operator|&=
literal|0xff
expr_stmt|;
block|}
name|args
operator|->
name|eax
operator|=
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|eax
expr_stmt|;
name|args
operator|->
name|ebx
operator|=
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|ebx
expr_stmt|;
name|args
operator|->
name|ecx
operator|=
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|ecx
expr_stmt|;
name|args
operator|->
name|edx
operator|=
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|edx
expr_stmt|;
name|args
operator|->
name|esi
operator|=
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|esi
expr_stmt|;
name|args
operator|->
name|edi
operator|=
name|sc
operator|->
name|bios
operator|.
name|r
operator|.
name|edi
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* for /dev/apmctl */
if|if
condition|(
name|APMDEV
argument_list|(
name|dev
argument_list|)
operator|==
name|APMDEV_CTL
condition|)
block|{
name|struct
name|apm_event_info
modifier|*
name|evp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|APMIO_NEXTEVENT
case|:
if|if
condition|(
operator|!
name|sc
operator|->
name|event_count
condition|)
block|{
name|error
operator|=
name|EAGAIN
expr_stmt|;
block|}
else|else
block|{
name|evp
operator|=
operator|(
expr|struct
name|apm_event_info
operator|*
operator|)
name|addr
expr_stmt|;
name|i
operator|=
name|sc
operator|->
name|event_ptr
operator|+
name|APM_NEVENTS
operator|-
name|sc
operator|->
name|event_count
expr_stmt|;
name|i
operator|%=
name|APM_NEVENTS
expr_stmt|;
operator|*
name|evp
operator|=
name|sc
operator|->
name|event_list
index|[
name|i
index|]
expr_stmt|;
name|sc
operator|->
name|event_count
operator|--
expr_stmt|;
block|}
break|break;
case|case
name|APMIO_REJECTLASTREQ
case|:
if|if
condition|(
name|apm_lastreq_rejected
argument_list|()
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
block|}
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|apmwrite
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
name|struct
name|apm_softc
modifier|*
name|sc
init|=
operator|&
name|apm_softc
decl_stmt|;
name|u_int
name|event_type
decl_stmt|;
name|int
name|error
decl_stmt|;
name|u_char
name|enabled
decl_stmt|;
if|if
condition|(
name|APMDEV
argument_list|(
name|dev
argument_list|)
operator|!=
name|APMDEV_CTL
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|!=
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
condition|)
return|return
operator|(
name|E2BIG
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|uiomove
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|event_type
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
argument_list|,
name|uio
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|event_type
operator|<
literal|0
operator|||
name|event_type
operator|>=
name|APM_NPMEV
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|sc
operator|->
name|event_filter
index|[
name|event_type
index|]
operator|==
literal|0
condition|)
block|{
name|enabled
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|enabled
operator|=
literal|0
expr_stmt|;
block|}
name|sc
operator|->
name|event_filter
index|[
name|event_type
index|]
operator|=
name|enabled
expr_stmt|;
ifdef|#
directive|ifdef
name|APM_DEBUG
name|printf
argument_list|(
literal|"apmwrite: event 0x%x %s\n"
argument_list|,
name|event_type
argument_list|,
name|is_enabled
argument_list|(
name|enabled
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|uio
operator|->
name|uio_resid
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|apmpoll
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|events
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|apm_softc
modifier|*
name|sc
init|=
operator|&
name|apm_softc
decl_stmt|;
name|int
name|revents
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|event_count
condition|)
block|{
name|revents
operator||=
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
expr_stmt|;
block|}
else|else
block|{
name|selrecord
argument_list|(
name|p
argument_list|,
operator|&
name|sc
operator|->
name|sc_rsel
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|revents
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|apm_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_identify
argument_list|,
name|apm_identify
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|apm_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|apm_attach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|apm_driver
init|=
block|{
literal|"apm"
block|,
name|apm_methods
block|,
literal|1
block|,
comment|/* no softc (XXX) */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|apm_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|apm
argument_list|,
name|nexus
argument_list|,
name|apm_driver
argument_list|,
name|apm_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

