begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: osf1_signal.c,v 1.4 1998/05/20 16:35:01 chs Exp $  */
end_comment

begin_comment
comment|/*  * Copyright (c) 1998-1999 Andrew Gallatin  *   * Taken from NetBSD's sys/compat/osf1/osf1_signal.c, which at the  * time *had no copyright*!  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer  *    in this position and unchanged.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software withough specific prior written permission  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/reboot.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmmeter.h>
end_include

begin_include
include|#
directive|include
file|<sys/msgbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/exec.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<net/netisr.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pager.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/reg.h>
end_include

begin_include
include|#
directive|include
file|<machine/pal.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpuconf.h>
end_include

begin_include
include|#
directive|include
file|<machine/bootinfo.h>
end_include

begin_include
include|#
directive|include
file|<machine/rpb.h>
end_include

begin_include
include|#
directive|include
file|<machine/prom.h>
end_include

begin_include
include|#
directive|include
file|<machine/chipset.h>
end_include

begin_include
include|#
directive|include
file|<machine/vmparam.h>
end_include

begin_include
include|#
directive|include
file|<machine/elf.h>
end_include

begin_include
include|#
directive|include
file|<ddb/ddb.h>
end_include

begin_include
include|#
directive|include
file|<alpha/alpha/db_instruction.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<alpha/osf1/osf1_signal.h>
end_include

begin_include
include|#
directive|include
file|<alpha/osf1/osf1_proto.h>
end_include

begin_include
include|#
directive|include
file|<alpha/osf1/osf1_syscall.h>
end_include

begin_include
include|#
directive|include
file|<alpha/osf1/osf1_util.h>
end_include

begin_include
include|#
directive|include
file|<alpha/osf1/osf1.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_define
define|#
directive|define
name|DPRINTF
value|uprintf
end_define

begin_decl_stmt
name|int
name|osf1_sigdbg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|bsd_to_osf1_sigaction
parameter_list|(
specifier|const
name|struct
name|sigaction
modifier|*
name|bsa
parameter_list|,
name|struct
name|osf1_sigaction
modifier|*
name|osa
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|osf1_to_bsd_sigaction
parameter_list|(
specifier|const
name|struct
name|osf1_sigaction
modifier|*
name|osa
parameter_list|,
name|struct
name|sigaction
modifier|*
name|bsa
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|sigemptyset
parameter_list|(
name|s
parameter_list|)
value|SIGEMPTYSET(*(s))
end_define

begin_define
define|#
directive|define
name|sigismember
parameter_list|(
name|s
parameter_list|,
name|n
parameter_list|)
value|SIGISMEMBER(*(s), n)
end_define

begin_define
define|#
directive|define
name|sigaddset
parameter_list|(
name|s
parameter_list|,
name|n
parameter_list|)
value|SIGADDSET(*(s), n)
end_define

begin_define
define|#
directive|define
name|osf1_sigmask
parameter_list|(
name|n
parameter_list|)
value|(1<< ((n) - 1))
end_define

begin_define
define|#
directive|define
name|osf1_sigemptyset
parameter_list|(
name|s
parameter_list|)
value|memset((s), 0, sizeof(*(s)))
end_define

begin_define
define|#
directive|define
name|osf1_sigfillset
parameter_list|(
name|s
parameter_list|)
value|memset((s), 0xffffffff, sizeof(*(s)))
end_define

begin_define
define|#
directive|define
name|osf1_sigismember
parameter_list|(
name|s
parameter_list|,
name|n
parameter_list|)
value|(*(s)& sigmask(n))
end_define

begin_define
define|#
directive|define
name|osf1_sigaddset
parameter_list|(
name|s
parameter_list|,
name|n
parameter_list|)
value|(*(s) |= sigmask(n))
end_define

begin_function
name|void
name|osf1_to_bsd_sigset
parameter_list|(
name|oss
parameter_list|,
name|bss
parameter_list|)
specifier|const
name|osf1_sigset_t
modifier|*
name|oss
decl_stmt|;
name|sigset_t
modifier|*
name|bss
decl_stmt|;
block|{
specifier|const
name|u_int32_t
modifier|*
name|obits
decl_stmt|;
name|SIGEMPTYSET
argument_list|(
operator|*
name|bss
argument_list|)
expr_stmt|;
name|obits
operator|=
operator|(
specifier|const
name|u_int32_t
operator|*
operator|)
name|oss
expr_stmt|;
name|bss
operator|->
name|__bits
index|[
literal|0
index|]
operator|=
name|obits
index|[
literal|0
index|]
expr_stmt|;
name|bss
operator|->
name|__bits
index|[
literal|1
index|]
operator|=
name|obits
index|[
literal|1
index|]
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bsd_to_osf1_sigset
parameter_list|(
name|bss
parameter_list|,
name|oss
parameter_list|)
specifier|const
name|sigset_t
modifier|*
name|bss
decl_stmt|;
name|osf1_sigset_t
modifier|*
name|oss
decl_stmt|;
block|{
name|u_int32_t
modifier|*
name|obits
decl_stmt|;
name|osf1_sigemptyset
argument_list|(
name|oss
argument_list|)
expr_stmt|;
name|obits
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
name|oss
expr_stmt|;
name|obits
index|[
literal|0
index|]
operator|=
name|bss
operator|->
name|__bits
index|[
literal|0
index|]
expr_stmt|;
name|obits
index|[
literal|1
index|]
operator|=
name|bss
operator|->
name|__bits
index|[
literal|1
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * XXX: Only a subset of the flags is currently implemented.  */
end_comment

begin_function
name|void
name|osf1_to_bsd_sigaction
parameter_list|(
name|osa
parameter_list|,
name|bsa
parameter_list|)
specifier|const
name|struct
name|osf1_sigaction
modifier|*
name|osa
decl_stmt|;
name|struct
name|sigaction
modifier|*
name|bsa
decl_stmt|;
block|{
name|bsa
operator|->
name|sa_handler
operator|=
name|osa
operator|->
name|osa_handler
expr_stmt|;
if|if
condition|(
name|osf1_sigdbg
condition|)
name|uprintf
argument_list|(
literal|"%s(%d): handler @0x%lx \n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|osa
operator|->
name|osa_handler
argument_list|)
expr_stmt|;
name|osf1_to_bsd_sigset
argument_list|(
operator|&
name|osa
operator|->
name|osa_mask
argument_list|,
operator|&
name|bsa
operator|->
name|sa_mask
argument_list|)
expr_stmt|;
name|bsa
operator|->
name|sa_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|osa
operator|->
name|osa_flags
operator|&
name|OSF1_SA_ONSTACK
operator|)
operator|!=
literal|0
condition|)
name|bsa
operator|->
name|sa_flags
operator||=
name|SA_ONSTACK
expr_stmt|;
if|if
condition|(
operator|(
name|osa
operator|->
name|osa_flags
operator|&
name|OSF1_SA_RESTART
operator|)
operator|!=
literal|0
condition|)
name|bsa
operator|->
name|sa_flags
operator||=
name|SA_RESTART
expr_stmt|;
if|if
condition|(
operator|(
name|osa
operator|->
name|osa_flags
operator|&
name|OSF1_SA_RESETHAND
operator|)
operator|!=
literal|0
condition|)
name|bsa
operator|->
name|sa_flags
operator||=
name|SA_RESETHAND
expr_stmt|;
if|if
condition|(
operator|(
name|osa
operator|->
name|osa_flags
operator|&
name|OSF1_SA_NOCLDSTOP
operator|)
operator|!=
literal|0
condition|)
name|bsa
operator|->
name|sa_flags
operator||=
name|SA_NOCLDSTOP
expr_stmt|;
if|if
condition|(
operator|(
name|osa
operator|->
name|osa_flags
operator|&
name|OSF1_SA_NODEFER
operator|)
operator|!=
literal|0
condition|)
name|bsa
operator|->
name|sa_flags
operator||=
name|SA_NODEFER
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bsd_to_osf1_sigaction
parameter_list|(
name|bsa
parameter_list|,
name|osa
parameter_list|)
specifier|const
name|struct
name|sigaction
modifier|*
name|bsa
decl_stmt|;
name|struct
name|osf1_sigaction
modifier|*
name|osa
decl_stmt|;
block|{
name|osa
operator|->
name|osa_handler
operator|=
name|bsa
operator|->
name|sa_handler
expr_stmt|;
name|bsd_to_osf1_sigset
argument_list|(
operator|&
name|bsa
operator|->
name|sa_mask
argument_list|,
operator|&
name|osa
operator|->
name|osa_mask
argument_list|)
expr_stmt|;
name|osa
operator|->
name|osa_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|bsa
operator|->
name|sa_flags
operator|&
name|SA_ONSTACK
operator|)
operator|!=
literal|0
condition|)
name|osa
operator|->
name|osa_flags
operator||=
name|SA_ONSTACK
expr_stmt|;
if|if
condition|(
operator|(
name|bsa
operator|->
name|sa_flags
operator|&
name|SA_RESTART
operator|)
operator|!=
literal|0
condition|)
name|osa
operator|->
name|osa_flags
operator||=
name|SA_RESTART
expr_stmt|;
if|if
condition|(
operator|(
name|bsa
operator|->
name|sa_flags
operator|&
name|SA_NOCLDSTOP
operator|)
operator|!=
literal|0
condition|)
name|osa
operator|->
name|osa_flags
operator||=
name|SA_NOCLDSTOP
expr_stmt|;
if|if
condition|(
operator|(
name|bsa
operator|->
name|sa_flags
operator|&
name|SA_NODEFER
operator|)
operator|!=
literal|0
condition|)
name|osa
operator|->
name|osa_flags
operator||=
name|SA_NODEFER
expr_stmt|;
if|if
condition|(
operator|(
name|bsa
operator|->
name|sa_flags
operator|&
name|SA_RESETHAND
operator|)
operator|!=
literal|0
condition|)
name|osa
operator|->
name|osa_flags
operator||=
name|SA_RESETHAND
expr_stmt|;
block|}
end_function

begin_function
name|void
name|osf1_to_bsd_sigaltstack
parameter_list|(
name|oss
parameter_list|,
name|bss
parameter_list|)
specifier|const
name|struct
name|osf1_sigaltstack
modifier|*
name|oss
decl_stmt|;
name|struct
name|sigaltstack
modifier|*
name|bss
decl_stmt|;
block|{
name|bss
operator|->
name|ss_sp
operator|=
name|oss
operator|->
name|ss_sp
expr_stmt|;
name|bss
operator|->
name|ss_size
operator|=
name|oss
operator|->
name|ss_size
expr_stmt|;
name|bss
operator|->
name|ss_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|oss
operator|->
name|ss_flags
operator|&
name|OSF1_SS_DISABLE
operator|)
operator|!=
literal|0
condition|)
name|bss
operator|->
name|ss_flags
operator||=
name|SS_DISABLE
expr_stmt|;
if|if
condition|(
operator|(
name|oss
operator|->
name|ss_flags
operator|&
name|OSF1_SS_ONSTACK
operator|)
operator|!=
literal|0
condition|)
name|bss
operator|->
name|ss_flags
operator||=
name|SS_ONSTACK
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bsd_to_osf1_sigaltstack
parameter_list|(
name|bss
parameter_list|,
name|oss
parameter_list|)
specifier|const
name|struct
name|sigaltstack
modifier|*
name|bss
decl_stmt|;
name|struct
name|osf1_sigaltstack
modifier|*
name|oss
decl_stmt|;
block|{
name|oss
operator|->
name|ss_sp
operator|=
name|bss
operator|->
name|ss_sp
expr_stmt|;
name|oss
operator|->
name|ss_size
operator|=
name|bss
operator|->
name|ss_size
expr_stmt|;
name|oss
operator|->
name|ss_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|bss
operator|->
name|ss_flags
operator|&
name|SS_DISABLE
operator|)
operator|!=
literal|0
condition|)
name|oss
operator|->
name|ss_flags
operator||=
name|OSF1_SS_DISABLE
expr_stmt|;
if|if
condition|(
operator|(
name|bss
operator|->
name|ss_flags
operator|&
name|SS_ONSTACK
operator|)
operator|!=
literal|0
condition|)
name|oss
operator|->
name|ss_flags
operator||=
name|OSF1_SS_ONSTACK
expr_stmt|;
block|}
end_function

begin_function
name|int
name|osf1_sigaction
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|osf1_sigaction_args
modifier|*
name|uap
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|caddr_t
name|sg
decl_stmt|;
name|struct
name|osf1_sigaction
modifier|*
name|nosa
decl_stmt|,
modifier|*
name|oosa
decl_stmt|,
name|tmposa
decl_stmt|;
name|struct
name|sigaction
modifier|*
name|nbsa
decl_stmt|,
modifier|*
name|obsa
decl_stmt|,
name|tmpbsa
decl_stmt|;
name|struct
name|sigaction_args
name|sa
decl_stmt|;
name|sg
operator|=
name|stackgap_init
argument_list|()
expr_stmt|;
name|nosa
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|nsa
argument_list|)
expr_stmt|;
name|oosa
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|osa
argument_list|)
expr_stmt|;
if|if
condition|(
name|osf1_sigdbg
operator|&&
name|uap
operator|->
name|sigtramp
condition|)
name|uprintf
argument_list|(
literal|"osf1_sigaction: trampoline handler at %p\n"
argument_list|,
name|uap
operator|->
name|sigtramp
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_md
operator|.
name|osf_sigtramp
operator|=
name|uap
operator|->
name|sigtramp
expr_stmt|;
if|if
condition|(
name|oosa
operator|!=
name|NULL
condition|)
name|obsa
operator|=
name|stackgap_alloc
argument_list|(
operator|&
name|sg
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sigaction
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|obsa
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|nosa
operator|!=
name|NULL
condition|)
block|{
name|nbsa
operator|=
name|stackgap_alloc
argument_list|(
operator|&
name|sg
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sigaction
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|nosa
argument_list|,
operator|&
name|tmposa
argument_list|,
sizeof|sizeof
argument_list|(
name|tmposa
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|osf1_to_bsd_sigaction
argument_list|(
operator|&
name|tmposa
argument_list|,
operator|&
name|tmpbsa
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|tmpbsa
argument_list|,
name|nbsa
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpbsa
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
block|}
else|else
name|nbsa
operator|=
name|NULL
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|sa
argument_list|,
name|sig
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|signum
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|sa
argument_list|,
name|act
argument_list|)
operator|=
name|nbsa
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|sa
argument_list|,
name|oact
argument_list|)
operator|=
name|obsa
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|sigaction
argument_list|(
name|td
argument_list|,
operator|&
name|sa
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
if|if
condition|(
name|oosa
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|obsa
argument_list|,
operator|&
name|tmpbsa
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpbsa
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|bsd_to_osf1_sigaction
argument_list|(
operator|&
name|tmpbsa
argument_list|,
operator|&
name|tmposa
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|tmposa
argument_list|,
name|oosa
argument_list|,
sizeof|sizeof
argument_list|(
name|tmposa
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|osf1_sigaltstack
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
specifier|register
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|osf1_sigaltstack_args
modifier|*
name|uap
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|caddr_t
name|sg
decl_stmt|;
name|struct
name|osf1_sigaltstack
modifier|*
name|noss
decl_stmt|,
modifier|*
name|ooss
decl_stmt|,
name|tmposs
decl_stmt|;
name|struct
name|sigaltstack
modifier|*
name|nbss
decl_stmt|,
modifier|*
name|obss
decl_stmt|,
name|tmpbss
decl_stmt|;
name|struct
name|sigaltstack_args
name|sa
decl_stmt|;
name|sg
operator|=
name|stackgap_init
argument_list|()
expr_stmt|;
name|noss
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|nss
argument_list|)
expr_stmt|;
name|ooss
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|oss
argument_list|)
expr_stmt|;
if|if
condition|(
name|ooss
operator|!=
name|NULL
condition|)
name|obss
operator|=
name|stackgap_alloc
argument_list|(
operator|&
name|sg
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sigaltstack
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|obss
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|noss
operator|!=
name|NULL
condition|)
block|{
name|nbss
operator|=
name|stackgap_alloc
argument_list|(
operator|&
name|sg
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sigaltstack
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|noss
argument_list|,
operator|&
name|tmposs
argument_list|,
sizeof|sizeof
argument_list|(
name|tmposs
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|osf1_to_bsd_sigaltstack
argument_list|(
operator|&
name|tmposs
argument_list|,
operator|&
name|tmpbss
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|tmpbss
argument_list|,
name|nbss
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpbss
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
block|}
else|else
name|nbss
operator|=
name|NULL
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|sa
argument_list|,
name|ss
argument_list|)
operator|=
name|nbss
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|sa
argument_list|,
name|oss
argument_list|)
operator|=
name|obss
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|sigaltstack
argument_list|(
name|td
argument_list|,
operator|&
name|sa
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
if|if
condition|(
name|obss
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|obss
argument_list|,
operator|&
name|tmpbss
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpbss
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|bsd_to_osf1_sigaltstack
argument_list|(
operator|&
name|tmpbss
argument_list|,
operator|&
name|tmposs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|tmposs
argument_list|,
name|ooss
argument_list|,
sizeof|sizeof
argument_list|(
name|tmposs
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|osf1_signal
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
specifier|register
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|osf1_signal_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|int
name|error
decl_stmt|,
name|signum
decl_stmt|;
name|caddr_t
name|sg
decl_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
name|sg
operator|=
name|stackgap_init
argument_list|()
expr_stmt|;
name|signum
operator|=
name|OSF1_SIGNO
argument_list|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|signum
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|signum
operator|<=
literal|0
operator|||
name|signum
operator|>
name|OSF1_NSIG
condition|)
block|{
if|if
condition|(
name|OSF1_SIGCALL
argument_list|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|signum
argument_list|)
argument_list|)
operator|==
name|OSF1_SIGNAL_MASK
operator|||
name|OSF1_SIGCALL
argument_list|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|signum
argument_list|)
argument_list|)
operator|==
name|OSF1_SIGDEFER_MASK
condition|)
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
switch|switch
condition|(
name|OSF1_SIGCALL
argument_list|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|signum
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|OSF1_SIGDEFER_MASK
case|:
comment|/* 		 * sigset is identical to signal() except 		 * that SIG_HOLD is allowed as 		 * an action. 		 */
if|if
condition|(
operator|(
name|u_long
operator|)
name|SCARG
argument_list|(
name|uap
argument_list|,
name|handler
argument_list|)
operator|==
name|OSF1_SIG_HOLD
condition|)
block|{
name|sigset_t
name|mask
decl_stmt|;
name|sigset_t
modifier|*
name|bmask
decl_stmt|;
name|struct
name|sigprocmask_args
name|sa
decl_stmt|;
name|bmask
operator|=
name|stackgap_alloc
argument_list|(
operator|&
name|sg
argument_list|,
sizeof|sizeof
argument_list|(
name|sigset_t
argument_list|)
argument_list|)
expr_stmt|;
name|SIGEMPTYSET
argument_list|(
name|mask
argument_list|)
expr_stmt|;
name|SIGADDSET
argument_list|(
name|mask
argument_list|,
name|signum
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|sa
argument_list|,
name|how
argument_list|)
operator|=
name|SIG_BLOCK
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|sa
argument_list|,
name|set
argument_list|)
operator|=
name|bmask
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|sa
argument_list|,
name|oset
argument_list|)
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|mask
argument_list|,
name|bmask
argument_list|,
sizeof|sizeof
argument_list|(
name|mask
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
name|sigprocmask
argument_list|(
name|td
argument_list|,
operator|&
name|sa
argument_list|)
return|;
block|}
comment|/* FALLTHROUGH */
case|case
name|OSF1_SIGNAL_MASK
case|:
block|{
name|struct
name|sigaction_args
name|sa_args
decl_stmt|;
name|struct
name|sigaction
modifier|*
name|nbsa
decl_stmt|,
modifier|*
name|obsa
decl_stmt|,
name|sa
decl_stmt|;
name|nbsa
operator|=
name|stackgap_alloc
argument_list|(
operator|&
name|sg
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sigaction
argument_list|)
argument_list|)
expr_stmt|;
name|obsa
operator|=
name|stackgap_alloc
argument_list|(
operator|&
name|sg
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sigaction
argument_list|)
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|sa_args
argument_list|,
name|sig
argument_list|)
operator|=
name|signum
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|sa_args
argument_list|,
name|act
argument_list|)
operator|=
name|nbsa
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|sa_args
argument_list|,
name|oact
argument_list|)
operator|=
name|obsa
expr_stmt|;
name|sa
operator|.
name|sa_handler
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|handler
argument_list|)
expr_stmt|;
name|SIGEMPTYSET
argument_list|(
name|sa
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
name|sa
operator|.
name|sa_flags
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
block|if (signum != SIGALRM) 				sa.sa_flags = SA_RESTART;
endif|#
directive|endif
if|if
condition|(
operator|(
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|sa
argument_list|,
name|nbsa
argument_list|,
sizeof|sizeof
argument_list|(
name|sa
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|sigaction
argument_list|(
name|td
argument_list|,
operator|&
name|sa_args
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"signal: sigaction failed: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|error
return|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|obsa
argument_list|,
operator|&
name|sa
argument_list|,
sizeof|sizeof
argument_list|(
name|sa
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
operator|(
name|long
operator|)
name|sa
operator|.
name|sa_handler
expr_stmt|;
return|return
literal|0
return|;
block|}
case|case
name|OSF1_SIGHOLD_MASK
case|:
block|{
name|struct
name|sigprocmask_args
name|sa
decl_stmt|;
name|sigset_t
name|set
decl_stmt|;
name|sigset_t
modifier|*
name|bset
decl_stmt|;
name|bset
operator|=
name|stackgap_alloc
argument_list|(
operator|&
name|sg
argument_list|,
sizeof|sizeof
argument_list|(
name|sigset_t
argument_list|)
argument_list|)
expr_stmt|;
name|SIGEMPTYSET
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|SIGADDSET
argument_list|(
name|set
argument_list|,
name|signum
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|sa
argument_list|,
name|how
argument_list|)
operator|=
name|SIG_BLOCK
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|sa
argument_list|,
name|set
argument_list|)
operator|=
name|bset
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|sa
argument_list|,
name|oset
argument_list|)
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|set
argument_list|,
name|bset
argument_list|,
sizeof|sizeof
argument_list|(
name|set
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
name|sigprocmask
argument_list|(
name|td
argument_list|,
operator|&
name|sa
argument_list|)
return|;
block|}
case|case
name|OSF1_SIGRELSE_MASK
case|:
block|{
name|struct
name|sigprocmask_args
name|sa
decl_stmt|;
name|sigset_t
name|set
decl_stmt|;
name|sigset_t
modifier|*
name|bset
decl_stmt|;
name|bset
operator|=
name|stackgap_alloc
argument_list|(
operator|&
name|sg
argument_list|,
sizeof|sizeof
argument_list|(
name|sigset_t
argument_list|)
argument_list|)
expr_stmt|;
name|SIGEMPTYSET
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|SIGADDSET
argument_list|(
name|set
argument_list|,
name|signum
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|sa
argument_list|,
name|how
argument_list|)
operator|=
name|SIG_UNBLOCK
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|sa
argument_list|,
name|set
argument_list|)
operator|=
name|bset
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|sa
argument_list|,
name|oset
argument_list|)
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|set
argument_list|,
name|bset
argument_list|,
sizeof|sizeof
argument_list|(
name|set
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
name|sigprocmask
argument_list|(
name|td
argument_list|,
operator|&
name|sa
argument_list|)
return|;
block|}
case|case
name|OSF1_SIGIGNORE_MASK
case|:
block|{
name|struct
name|sigaction_args
name|sa_args
decl_stmt|;
name|struct
name|sigaction
modifier|*
name|bsa
decl_stmt|,
name|sa
decl_stmt|;
name|bsa
operator|=
name|stackgap_alloc
argument_list|(
operator|&
name|sg
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sigaction
argument_list|)
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|sa_args
argument_list|,
name|sig
argument_list|)
operator|=
name|signum
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|sa_args
argument_list|,
name|act
argument_list|)
operator|=
name|bsa
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|sa_args
argument_list|,
name|oact
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|sa
operator|.
name|sa_handler
operator|=
name|SIG_IGN
expr_stmt|;
name|SIGEMPTYSET
argument_list|(
name|sa
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
name|sa
operator|.
name|sa_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|sa
argument_list|,
name|bsa
argument_list|,
sizeof|sizeof
argument_list|(
name|sa
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|sigaction
argument_list|(
name|td
argument_list|,
operator|&
name|sa_args
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"sigignore: sigaction failed\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
return|return
literal|0
return|;
block|}
case|case
name|OSF1_SIGPAUSE_MASK
case|:
block|{
name|struct
name|sigsuspend_args
name|sa
decl_stmt|;
name|sigset_t
name|set
decl_stmt|;
name|sigset_t
modifier|*
name|bmask
decl_stmt|;
name|bmask
operator|=
name|stackgap_alloc
argument_list|(
operator|&
name|sg
argument_list|,
sizeof|sizeof
argument_list|(
name|sigset_t
argument_list|)
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|set
operator|=
name|p
operator|->
name|p_sigmask
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|SIGDELSET
argument_list|(
name|set
argument_list|,
name|signum
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|sa
argument_list|,
name|sigmask
argument_list|)
operator|=
name|bmask
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|set
argument_list|,
name|bmask
argument_list|,
sizeof|sizeof
argument_list|(
name|set
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
name|sigsuspend
argument_list|(
name|td
argument_list|,
operator|&
name|sa
argument_list|)
return|;
block|}
default|default:
return|return
name|ENOSYS
return|;
block|}
block|}
end_function

begin_function
name|int
name|osf1_sigprocmask
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
specifier|register
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|osf1_sigprocmask_args
comment|/* { 		syscallarg(int) how; 		syscallarg(osf1_sigset_t *) set; 	} */
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|int
name|error
decl_stmt|;
name|osf1_sigset_t
name|oss
decl_stmt|;
name|sigset_t
name|bss
decl_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
comment|/* Fix the return value first if needed */
name|bsd_to_osf1_sigset
argument_list|(
operator|&
name|p
operator|->
name|p_sigmask
argument_list|,
operator|&
name|oss
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|oss
expr_stmt|;
name|osf1_to_bsd_sigset
argument_list|(
operator|&
name|uap
operator|->
name|mask
argument_list|,
operator|&
name|bss
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|how
argument_list|)
condition|)
block|{
case|case
name|OSF1_SIG_BLOCK
case|:
name|SIGSETOR
argument_list|(
name|p
operator|->
name|p_sigmask
argument_list|,
name|bss
argument_list|)
expr_stmt|;
name|SIG_CANTMASK
argument_list|(
name|p
operator|->
name|p_sigmask
argument_list|)
expr_stmt|;
break|break;
case|case
name|OSF1_SIG_UNBLOCK
case|:
name|SIGSETNAND
argument_list|(
name|p
operator|->
name|p_sigmask
argument_list|,
name|bss
argument_list|)
expr_stmt|;
name|signotify
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|OSF1_SIG_SETMASK
case|:
name|p
operator|->
name|p_sigmask
operator|=
name|bss
expr_stmt|;
name|SIG_CANTMASK
argument_list|(
name|p
operator|->
name|p_sigmask
argument_list|)
expr_stmt|;
name|signotify
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|osf1_sigpending
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
specifier|register
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|osf1_sigpending_args
comment|/* { 		syscallarg(osf1_sigset_t *) mask; 	} */
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|osf1_sigset_t
name|oss
decl_stmt|;
name|sigset_t
name|bss
decl_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|bss
operator|=
name|p
operator|->
name|p_siglist
expr_stmt|;
name|SIGSETAND
argument_list|(
name|bss
argument_list|,
name|p
operator|->
name|p_sigmask
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|bsd_to_osf1_sigset
argument_list|(
operator|&
name|bss
argument_list|,
operator|&
name|oss
argument_list|)
expr_stmt|;
return|return
name|copyout
argument_list|(
operator|&
name|oss
argument_list|,
name|SCARG
argument_list|(
name|uap
argument_list|,
name|mask
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|oss
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|osf1_sigsuspend
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
specifier|register
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|osf1_sigsuspend_args
comment|/* { 		syscallarg(osf1_sigset_t *) ss; 	} */
modifier|*
name|uap
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|caddr_t
name|sg
decl_stmt|;
name|osf1_sigset_t
name|oss
decl_stmt|;
name|sigset_t
name|bss
decl_stmt|;
name|sigset_t
modifier|*
name|bmask
decl_stmt|;
name|struct
name|sigsuspend_args
name|sa
decl_stmt|;
name|sg
operator|=
name|stackgap_init
argument_list|()
expr_stmt|;
name|bmask
operator|=
name|stackgap_alloc
argument_list|(
operator|&
name|sg
argument_list|,
sizeof|sizeof
argument_list|(
name|sigset_t
argument_list|)
argument_list|)
expr_stmt|;
name|oss
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|ss
argument_list|)
expr_stmt|;
name|osf1_to_bsd_sigset
argument_list|(
operator|&
name|oss
argument_list|,
operator|&
name|bss
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|sa
argument_list|,
name|sigmask
argument_list|)
operator|=
name|bmask
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|bss
argument_list|,
name|bmask
argument_list|,
sizeof|sizeof
argument_list|(
name|bss
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
name|sigsuspend
argument_list|(
name|td
argument_list|,
operator|&
name|sa
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|osf1_kill
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
specifier|register
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|osf1_kill_args
comment|/* { 		syscallarg(int) pid; 		syscallarg(int) signum; 	} */
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|kill_args
name|ka
decl_stmt|;
name|SCARG
argument_list|(
operator|&
name|ka
argument_list|,
name|pid
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|pid
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|ka
argument_list|,
name|signum
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|signum
argument_list|)
expr_stmt|;
return|return
name|kill
argument_list|(
name|td
argument_list|,
operator|&
name|ka
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Send an interrupt to process.  *  * Stack is set up to allow sigcode stored at top to call routine,  * followed by kcall to sigreturn routine below.  After sigreturn resets  * the signal mask, the stack, and the frame pointer, it returns to the  * user specified pc, psl.  */
end_comment

begin_function
name|void
name|osf1_sendsig
parameter_list|(
name|sig_t
name|catcher
parameter_list|,
name|int
name|sig
parameter_list|,
name|sigset_t
modifier|*
name|mask
parameter_list|,
name|u_long
name|code
parameter_list|)
block|{
name|int
name|fsize
decl_stmt|,
name|oonstack
decl_stmt|,
name|rndfsize
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|osiginfo_t
modifier|*
name|sip
decl_stmt|,
name|ksi
decl_stmt|;
name|struct
name|trapframe
modifier|*
name|frame
decl_stmt|;
name|struct
name|sigacts
modifier|*
name|psp
decl_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
name|PROC_LOCK_ASSERT
argument_list|(
name|p
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|psp
operator|=
name|p
operator|->
name|p_sigacts
expr_stmt|;
name|frame
operator|=
name|td
operator|->
name|td_frame
expr_stmt|;
name|oonstack
operator|=
name|sigonstack
argument_list|(
name|alpha_pal_rdusp
argument_list|()
argument_list|)
expr_stmt|;
name|fsize
operator|=
sizeof|sizeof
name|ksi
expr_stmt|;
name|rndfsize
operator|=
operator|(
operator|(
name|fsize
operator|+
literal|15
operator|)
operator|/
literal|16
operator|)
operator|*
literal|16
expr_stmt|;
comment|/* 	 * Allocate and validate space for the signal handler context. 	 * Note that if the stack is in P0 space, the call to grow() is a nop, 	 * and the useracc() check will fail if the process has not already 	 * allocated the space with a `brk'. 	 */
if|if
condition|(
operator|(
name|p
operator|->
name|p_flag
operator|&
name|P_ALTSTACK
operator|)
operator|&&
operator|!
name|oonstack
operator|&&
name|SIGISMEMBER
argument_list|(
name|psp
operator|->
name|ps_sigonstack
argument_list|,
name|sig
argument_list|)
condition|)
block|{
name|sip
operator|=
operator|(
name|osiginfo_t
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|p
operator|->
name|p_sigstk
operator|.
name|ss_sp
operator|+
name|p
operator|->
name|p_sigstk
operator|.
name|ss_size
operator|-
name|rndfsize
operator|)
expr_stmt|;
name|p
operator|->
name|p_sigstk
operator|.
name|ss_flags
operator||=
name|SS_ONSTACK
expr_stmt|;
block|}
else|else
name|sip
operator|=
operator|(
name|osiginfo_t
operator|*
operator|)
operator|(
name|alpha_pal_rdusp
argument_list|()
operator|-
name|rndfsize
operator|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|grow_stack
argument_list|(
name|p
argument_list|,
operator|(
name|u_long
operator|)
name|sip
argument_list|)
expr_stmt|;
if|if
condition|(
name|useracc
argument_list|(
operator|(
name|caddr_t
operator|)
name|sip
argument_list|,
name|fsize
argument_list|,
name|VM_PROT_WRITE
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Process has trashed its stack; give it an illegal 		 * instruction to halt it in its tracks. 		 */
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|SIGACTION
argument_list|(
name|p
argument_list|,
name|SIGILL
argument_list|)
operator|=
name|SIG_DFL
expr_stmt|;
name|SIGDELSET
argument_list|(
name|p
operator|->
name|p_sigignore
argument_list|,
name|SIGILL
argument_list|)
expr_stmt|;
name|SIGDELSET
argument_list|(
name|p
operator|->
name|p_sigcatch
argument_list|,
name|SIGILL
argument_list|)
expr_stmt|;
name|SIGDELSET
argument_list|(
name|p
operator|->
name|p_sigmask
argument_list|,
name|SIGILL
argument_list|)
expr_stmt|;
name|psignal
argument_list|(
name|p
argument_list|,
name|SIGILL
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Build the signal context to be used by sigreturn. 	 */
name|ksi
operator|.
name|si_sc
operator|.
name|sc_onstack
operator|=
operator|(
name|oonstack
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|bsd_to_osf1_sigset
argument_list|(
name|mask
argument_list|,
operator|&
name|ksi
operator|.
name|si_sc
operator|.
name|sc_mask
argument_list|)
expr_stmt|;
name|ksi
operator|.
name|si_sc
operator|.
name|sc_pc
operator|=
name|frame
operator|->
name|tf_regs
index|[
name|FRAME_PC
index|]
expr_stmt|;
name|ksi
operator|.
name|si_sc
operator|.
name|sc_ps
operator|=
name|frame
operator|->
name|tf_regs
index|[
name|FRAME_PS
index|]
expr_stmt|;
comment|/* copy the registers. */
name|fill_regs
argument_list|(
name|td
argument_list|,
operator|(
expr|struct
name|reg
operator|*
operator|)
name|ksi
operator|.
name|si_sc
operator|.
name|sc_regs
argument_list|)
expr_stmt|;
name|ksi
operator|.
name|si_sc
operator|.
name|sc_regs
index|[
name|R_ZERO
index|]
operator|=
literal|0xACEDBADE
expr_stmt|;
comment|/* magic number */
name|ksi
operator|.
name|si_sc
operator|.
name|sc_regs
index|[
name|R_SP
index|]
operator|=
name|alpha_pal_rdusp
argument_list|()
expr_stmt|;
comment|/* save the floating-point state, if necessary, then copy it. */
name|alpha_fpstate_save
argument_list|(
name|td
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* XXX maybe write=0 */
name|ksi
operator|.
name|si_sc
operator|.
name|sc_ownedfp
operator|=
name|td
operator|->
name|td_md
operator|.
name|md_flags
operator|&
name|MDP_FPUSED
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|td
operator|->
name|td_pcb
operator|->
name|pcb_fp
argument_list|,
operator|(
expr|struct
name|fpreg
operator|*
operator|)
name|ksi
operator|.
name|si_sc
operator|.
name|sc_fpregs
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fpreg
argument_list|)
argument_list|)
expr_stmt|;
name|ksi
operator|.
name|si_sc
operator|.
name|sc_fp_control
operator|=
name|td
operator|->
name|td_pcb
operator|->
name|pcb_fp_control
expr_stmt|;
name|bzero
argument_list|(
name|ksi
operator|.
name|si_sc
operator|.
name|sc_reserved
argument_list|,
sizeof|sizeof
name|ksi
operator|.
name|si_sc
operator|.
name|sc_reserved
argument_list|)
expr_stmt|;
comment|/* XXX */
name|ksi
operator|.
name|si_sc
operator|.
name|sc_xxx1
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* XXX */
name|ksi
operator|.
name|si_sc
operator|.
name|sc_xxx1
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* XXX */
name|ksi
operator|.
name|si_sc
operator|.
name|sc_traparg_a0
operator|=
name|frame
operator|->
name|tf_regs
index|[
name|FRAME_TRAPARG_A0
index|]
expr_stmt|;
name|ksi
operator|.
name|si_sc
operator|.
name|sc_traparg_a1
operator|=
name|frame
operator|->
name|tf_regs
index|[
name|FRAME_TRAPARG_A1
index|]
expr_stmt|;
name|ksi
operator|.
name|si_sc
operator|.
name|sc_traparg_a2
operator|=
name|frame
operator|->
name|tf_regs
index|[
name|FRAME_TRAPARG_A2
index|]
expr_stmt|;
name|ksi
operator|.
name|si_sc
operator|.
name|sc_xxx2
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* XXX */
name|ksi
operator|.
name|si_sc
operator|.
name|sc_xxx2
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* XXX */
name|ksi
operator|.
name|si_sc
operator|.
name|sc_xxx2
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
comment|/* XXX */
comment|/* Fill in POSIX parts */
name|ksi
operator|.
name|si_signo
operator|=
name|sig
expr_stmt|;
name|ksi
operator|.
name|si_code
operator|=
name|code
expr_stmt|;
name|ksi
operator|.
name|si_value
operator|.
name|sigval_ptr
operator|=
name|NULL
expr_stmt|;
comment|/* XXX */
comment|/* 	 * copy the frame out to userland. 	 */
operator|(
name|void
operator|)
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|ksi
argument_list|,
operator|(
name|caddr_t
operator|)
name|sip
argument_list|,
name|fsize
argument_list|)
expr_stmt|;
comment|/* 	 * Set up the registers to return to sigcode. 	 */
if|if
condition|(
name|osf1_sigdbg
condition|)
name|uprintf
argument_list|(
literal|"attempting to call osf1 sigtramp\n"
argument_list|)
expr_stmt|;
name|frame
operator|->
name|tf_regs
index|[
name|FRAME_PC
index|]
operator|=
operator|(
name|u_int64_t
operator|)
name|td
operator|->
name|td_md
operator|.
name|osf_sigtramp
expr_stmt|;
name|frame
operator|->
name|tf_regs
index|[
name|FRAME_A0
index|]
operator|=
name|sig
expr_stmt|;
name|frame
operator|->
name|tf_regs
index|[
name|FRAME_A1
index|]
operator|=
name|code
expr_stmt|;
name|frame
operator|->
name|tf_regs
index|[
name|FRAME_A2
index|]
operator|=
operator|(
name|u_int64_t
operator|)
name|sip
expr_stmt|;
name|frame
operator|->
name|tf_regs
index|[
name|FRAME_A3
index|]
operator|=
operator|(
name|u_int64_t
operator|)
name|catcher
expr_stmt|;
comment|/* a3 is pv */
name|frame
operator|->
name|tf_regs
index|[
name|FRAME_FLAGS
index|]
operator|=
literal|0
expr_stmt|;
comment|/* full restore */
name|alpha_pal_wrusp
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|sip
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * System call to cleanup state after a signal has been taken.  Reset signal  * mask and stack state from context left by sendsig (above).  Return to  * previous pc and psl as specified by context left by sendsig. Check  * carefully to make sure that the user has not modified the state to gain  * improper privileges.  */
end_comment

begin_function
name|int
name|osf1_sigreturn
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|osf1_sigreturn_args
comment|/* { 		struct osigcontext *sigcntxp; 	} */
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|osigcontext
name|ksc
decl_stmt|,
modifier|*
name|scp
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
name|scp
operator|=
name|uap
operator|->
name|sigcntxp
expr_stmt|;
if|if
condition|(
name|useracc
argument_list|(
operator|(
name|caddr_t
operator|)
name|scp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scp
argument_list|)
argument_list|,
name|VM_PROT_READ
argument_list|)
operator|==
literal|0
condition|)
block|{
name|uprintf
argument_list|(
literal|"uac fails\n"
argument_list|)
expr_stmt|;
name|uprintf
argument_list|(
literal|"scp: %p\n"
argument_list|,
name|scp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Test and fetch the context structure. 	 * We grab it all at once for speed. 	 */
if|if
condition|(
name|useracc
argument_list|(
operator|(
name|caddr_t
operator|)
name|scp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scp
argument_list|)
argument_list|,
name|VM_PROT_READ
argument_list|)
operator|==
literal|0
operator|||
name|copyin
argument_list|(
operator|(
name|caddr_t
operator|)
name|scp
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ksc
argument_list|,
sizeof|sizeof
name|ksc
argument_list|)
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
comment|/* 	 * Restore the user-supplied information. 	 */
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ksc
operator|.
name|sc_onstack
condition|)
name|p
operator|->
name|p_sigstk
operator|.
name|ss_flags
operator||=
name|SS_ONSTACK
expr_stmt|;
else|else
name|p
operator|->
name|p_sigstk
operator|.
name|ss_flags
operator|&=
operator|~
name|SS_ONSTACK
expr_stmt|;
comment|/* 	 * longjmp is still implemented by calling osigreturn. The new 	 * sigmask is stored in sc_reserved, sc_mask is only used for 	 * backward compatibility. 	 */
name|osf1_to_bsd_sigset
argument_list|(
operator|&
name|ksc
operator|.
name|sc_mask
argument_list|,
operator|&
name|p
operator|->
name|p_sigmask
argument_list|)
expr_stmt|;
name|SIG_CANTMASK
argument_list|(
name|p
operator|->
name|p_sigmask
argument_list|)
expr_stmt|;
name|signotify
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|set_regs
argument_list|(
name|td
argument_list|,
operator|(
expr|struct
name|reg
operator|*
operator|)
name|ksc
operator|.
name|sc_regs
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_frame
operator|->
name|tf_regs
index|[
name|FRAME_PC
index|]
operator|=
name|ksc
operator|.
name|sc_pc
expr_stmt|;
name|td
operator|->
name|td_frame
operator|->
name|tf_regs
index|[
name|FRAME_PS
index|]
operator|=
operator|(
name|ksc
operator|.
name|sc_ps
operator||
name|ALPHA_PSL_USERSET
operator|)
operator|&
operator|~
name|ALPHA_PSL_USERCLR
expr_stmt|;
name|td
operator|->
name|td_frame
operator|->
name|tf_regs
index|[
name|FRAME_FLAGS
index|]
operator|=
literal|0
expr_stmt|;
comment|/* full restore */
name|alpha_pal_wrusp
argument_list|(
name|ksc
operator|.
name|sc_regs
index|[
name|R_SP
index|]
argument_list|)
expr_stmt|;
comment|/* XXX ksc.sc_ownedfp ? */
name|alpha_fpstate_drop
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
expr|struct
name|fpreg
operator|*
operator|)
name|ksc
operator|.
name|sc_fpregs
argument_list|,
operator|&
name|td
operator|->
name|td_pcb
operator|->
name|pcb_fp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fpreg
argument_list|)
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_pcb
operator|->
name|pcb_fp_control
operator|=
name|ksc
operator|.
name|sc_fp_control
expr_stmt|;
return|return
operator|(
name|EJUSTRETURN
operator|)
return|;
block|}
end_function

begin_function_decl
specifier|extern
name|int
name|osigstack
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|osf1_osigstack_args
modifier|*
name|uap
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|osf1_osigstack
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
specifier|register
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|osf1_osigstack_args
comment|/* { 					struct sigstack *nss; 					struct sigstack *oss; 	} */
modifier|*
name|uap
decl_stmt|;
block|{
comment|/*	uprintf("osf1_osigstack: oss = %p, nss = %p",uap->oss, uap->nss); 	uprintf(" stack ptr = %p\n",p->p_sigacts->ps_sigstk.ss_sp);*/
return|return
operator|(
name|osigstack
argument_list|(
name|td
argument_list|,
name|uap
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

