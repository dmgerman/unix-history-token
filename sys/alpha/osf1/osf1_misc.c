begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: osf1_misc.c,v 1.14 1998/05/20 16:34:29 chs Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright (c) 1994, 1995 Carnegie-Mellon University.  * All rights reserved.  *  * Author: Chris G. Demetriou  *  * Permission to use, copy, modify and distribute this software and  * its documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *  * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"  * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND  * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *  * Carnegie Mellon requests users of this software to return to  *  *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *  * any improvements or extensions that they make and grant Carnegie the  * rights to redistribute these changes.  */
end_comment

begin_comment
comment|/*  * Additional Copyright (c) 1999 by Andrew Gallatin  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/dkstat.h>
end_include

begin_include
include|#
directive|include
file|<sys/exec.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/filedesc.h>
end_include

begin_include
include|#
directive|include
file|<sys/imgact.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_comment
comment|/* Must come after sys/malloc.h */
end_comment

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/reboot.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_include
include|#
directive|include
file|<sys/selinfo.h>
end_include

begin_include
include|#
directive|include
file|<sys/pipe.h>
end_include

begin_comment
comment|/* Must come after sys/selinfo.h */
end_comment

begin_include
include|#
directive|include
file|<sys/signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysent.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<sys/utsname.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<alpha/osf1/exec_ecoff.h>
end_include

begin_include
include|#
directive|include
file|<alpha/osf1/osf1_signal.h>
end_include

begin_include
include|#
directive|include
file|<alpha/osf1/osf1_proto.h>
end_include

begin_include
include|#
directive|include
file|<alpha/osf1/osf1_syscall.h>
end_include

begin_include
include|#
directive|include
file|<alpha/osf1/osf1_util.h>
end_include

begin_include
include|#
directive|include
file|<alpha/osf1/osf1.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpuconf.h>
end_include

begin_include
include|#
directive|include
file|<machine/fpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/rpb.h>
end_include

begin_function_decl
specifier|static
name|void
name|cvtstat2osf1
parameter_list|(
name|struct
name|stat
modifier|*
parameter_list|,
name|struct
name|osf1_stat
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|osf2bsd_pathconf
parameter_list|(
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
specifier|const
name|char
name|osf1_emul_path
index|[]
init|=
literal|"/compat/osf1"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * [ taken from the linux emulator ]  * Search an alternate path before passing pathname arguments on  * to system calls. Useful for keeping a separate 'emulation tree'.  *  * If cflag is set, we check if an attempt can be made to create  * the named file, i.e. we check if the directory it should  * be in exists.  */
end_comment

begin_function
name|int
name|osf1_emul_find
parameter_list|(
name|td
parameter_list|,
name|sgp
parameter_list|,
name|prefix
parameter_list|,
name|path
parameter_list|,
name|pbuf
parameter_list|,
name|cflag
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|caddr_t
modifier|*
name|sgp
decl_stmt|;
comment|/* Pointer to stackgap memory */
specifier|const
name|char
modifier|*
name|prefix
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
name|char
modifier|*
modifier|*
name|pbuf
decl_stmt|;
name|int
name|cflag
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|size_t
name|len
decl_stmt|,
name|sz
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|cp
decl_stmt|,
modifier|*
name|ptr
decl_stmt|;
name|struct
name|ucred
modifier|*
name|ucred
decl_stmt|;
name|struct
name|nameidata
name|nd
decl_stmt|;
name|struct
name|nameidata
name|ndroot
decl_stmt|;
name|struct
name|vattr
name|vat
decl_stmt|;
name|struct
name|vattr
name|vatroot
decl_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|MAXPATHLEN
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
operator|*
name|pbuf
operator|=
name|path
expr_stmt|;
for|for
control|(
name|ptr
operator|=
name|buf
init|;
operator|(
operator|*
name|ptr
operator|=
operator|*
name|prefix
operator|)
operator|!=
literal|'\0'
condition|;
name|ptr
operator|++
operator|,
name|prefix
operator|++
control|)
continue|continue;
name|sz
operator|=
name|MAXPATHLEN
operator|-
operator|(
name|ptr
operator|-
name|buf
operator|)
expr_stmt|;
comment|/* 	 * If sgp is not given then the path is already in kernel space 	 */
if|if
condition|(
name|sgp
operator|==
name|NULL
condition|)
name|error
operator|=
name|copystr
argument_list|(
name|path
argument_list|,
name|ptr
argument_list|,
name|sz
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|copyinstr
argument_list|(
name|path
argument_list|,
name|ptr
argument_list|,
name|sz
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
if|if
condition|(
operator|*
name|ptr
operator|!=
literal|'/'
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
comment|/* 	 *  We know that there is a / somewhere in this pathname. 	 *  Search backwards for it, to find the file's parent dir 	 *  to see if it exists in the alternate tree. If it does, 	 *  and we want to create a file (cflag is set). We don't 	 *  need to worry about the root comparison in this case. 	 */
if|if
condition|(
name|cflag
condition|)
block|{
for|for
control|(
name|cp
operator|=
operator|&
name|ptr
index|[
name|len
index|]
operator|-
literal|1
init|;
operator|*
name|cp
operator|!=
literal|'/'
condition|;
name|cp
operator|--
control|)
empty_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|NDINIT
argument_list|(
operator|&
name|nd
argument_list|,
name|LOOKUP
argument_list|,
name|FOLLOW
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|buf
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|namei
argument_list|(
operator|&
name|nd
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
operator|*
name|cp
operator|=
literal|'/'
expr_stmt|;
block|}
else|else
block|{
name|NDINIT
argument_list|(
operator|&
name|nd
argument_list|,
name|LOOKUP
argument_list|,
name|FOLLOW
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|buf
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|namei
argument_list|(
operator|&
name|nd
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* 		 * We now compare the vnode of the osf1_root to the one 		 * vnode asked. If they resolve to be the same, then we 		 * ignore the match so that the real root gets used. 		 * This avoids the problem of traversing "../.." to find the 		 * root directory and never finding it, because "/" resolves 		 * to the emulation root directory. This is expensive :-( 		 */
name|NDINIT
argument_list|(
operator|&
name|ndroot
argument_list|,
name|LOOKUP
argument_list|,
name|FOLLOW
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|osf1_emul_path
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|namei
argument_list|(
operator|&
name|ndroot
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Cannot happen! */
name|free
argument_list|(
name|buf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|nd
operator|.
name|ni_vp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|ucred
operator|=
name|td
operator|->
name|td_ucred
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|nd
operator|.
name|ni_vp
argument_list|,
operator|&
name|vat
argument_list|,
name|ucred
argument_list|,
name|td
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|ndroot
operator|.
name|ni_vp
argument_list|,
operator|&
name|vatroot
argument_list|,
name|ucred
argument_list|,
name|td
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|vat
operator|.
name|va_fsid
operator|==
name|vatroot
operator|.
name|va_fsid
operator|&&
name|vat
operator|.
name|va_fileid
operator|==
name|vatroot
operator|.
name|va_fileid
condition|)
block|{
name|error
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
if|if
condition|(
name|sgp
operator|==
name|NULL
condition|)
operator|*
name|pbuf
operator|=
name|buf
expr_stmt|;
else|else
block|{
name|sz
operator|=
operator|&
name|ptr
index|[
name|len
index|]
operator|-
name|buf
expr_stmt|;
operator|*
name|pbuf
operator|=
name|stackgap_alloc
argument_list|(
name|sgp
argument_list|,
name|sz
operator|+
literal|1
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
name|buf
argument_list|,
operator|*
name|pbuf
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
name|vrele
argument_list|(
name|nd
operator|.
name|ni_vp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cflag
condition|)
name|vrele
argument_list|(
name|ndroot
operator|.
name|ni_vp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
name|bad
label|:
name|vrele
argument_list|(
name|ndroot
operator|.
name|ni_vp
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|nd
operator|.
name|ni_vp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|osf1_open
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|osf1_open_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|open_args
comment|/* { 		syscallarg(char *) path; 		syscallarg(int) flags; 		syscallarg(int) mode; 	} */
name|a
decl_stmt|;
name|caddr_t
name|sg
decl_stmt|;
name|sg
operator|=
name|stackgap_init
argument_list|()
expr_stmt|;
name|CHECKALTEXIST
argument_list|(
name|td
argument_list|,
operator|&
name|sg
argument_list|,
name|uap
operator|->
name|path
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|a
argument_list|,
name|path
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|a
argument_list|,
name|flags
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* XXX translate */
name|SCARG
argument_list|(
operator|&
name|a
argument_list|,
name|mode
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
name|open
argument_list|(
name|td
argument_list|,
operator|&
name|a
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|extern
name|int
name|totalphysmem
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|osf1_getsysinfo
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|osf1_getsysinfo_args
modifier|*
name|uap
decl_stmt|;
block|{
name|int
name|error
decl_stmt|,
name|retval
decl_stmt|;
name|int
name|ncpus
init|=
literal|1
decl_stmt|;
comment|/* XXX until SMP */
name|int
name|ophysmem
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|long
name|percpu
decl_stmt|;
name|long
name|proctype
decl_stmt|;
name|struct
name|osf1_cpu_info
name|cpuinfo
decl_stmt|;
name|error
operator|=
name|retval
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|uap
operator|->
name|op
condition|)
block|{
case|case
name|OSF_GET_MAX_UPROCS
case|:
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|maxprocperuid
argument_list|,
name|uap
operator|->
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|maxprocperuid
argument_list|)
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OSF_GET_PHYSMEM
case|:
name|ophysmem
operator|=
name|totalphysmem
operator|*
operator|(
name|PAGE_SIZE
operator|>>
literal|10
operator|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|ophysmem
argument_list|,
name|uap
operator|->
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|ophysmem
argument_list|)
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OSF_GET_MAX_CPU
case|:
case|case
name|OSF_GET_CPUS_IN_BOX
case|:
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|ncpus
argument_list|,
name|uap
operator|->
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|ncpus
argument_list|)
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OSF_GET_IEEE_FP_CONTROL
case|:
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|td
operator|->
name|td_pcb
operator|->
name|pcb_fp_control
argument_list|,
name|uap
operator|->
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|td
operator|->
name|td_pcb
operator|->
name|pcb_fp_control
argument_list|)
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OSF_GET_CPU_INFO
case|:
if|if
condition|(
name|uap
operator|->
name|nbytes
operator|<
sizeof|sizeof
argument_list|(
name|cpuinfo
argument_list|)
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
else|else
block|{
name|bzero
argument_list|(
operator|&
name|cpuinfo
argument_list|,
sizeof|sizeof
argument_list|(
name|cpuinfo
argument_list|)
argument_list|)
expr_stmt|;
name|unit
operator|=
name|alpha_pal_whami
argument_list|()
expr_stmt|;
name|cpuinfo
operator|.
name|current_cpu
operator|=
name|unit
expr_stmt|;
name|cpuinfo
operator|.
name|cpus_in_box
operator|=
name|ncpus
expr_stmt|;
name|cpuinfo
operator|.
name|cpu_type
operator|=
name|LOCATE_PCS
argument_list|(
name|hwrpb
argument_list|,
name|unit
argument_list|)
operator|->
name|pcs_proc_type
expr_stmt|;
name|cpuinfo
operator|.
name|ncpus
operator|=
name|ncpus
expr_stmt|;
name|cpuinfo
operator|.
name|cpus_present
operator|=
name|ncpus
expr_stmt|;
name|cpuinfo
operator|.
name|cpus_running
operator|=
name|ncpus
expr_stmt|;
name|cpuinfo
operator|.
name|cpu_binding
operator|=
literal|1
expr_stmt|;
name|cpuinfo
operator|.
name|cpu_ex_binding
operator|=
literal|0
expr_stmt|;
name|cpuinfo
operator|.
name|mhz
operator|=
name|hwrpb
operator|->
name|rpb_cc_freq
operator|/
literal|1000000
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|cpuinfo
argument_list|,
name|uap
operator|->
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|cpuinfo
argument_list|)
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|OSF_GET_PROC_TYPE
case|:
if|if
condition|(
name|uap
operator|->
name|nbytes
operator|<
sizeof|sizeof
argument_list|(
name|proctype
argument_list|)
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
else|else
block|{
name|unit
operator|=
name|alpha_pal_whami
argument_list|()
expr_stmt|;
name|proctype
operator|=
name|LOCATE_PCS
argument_list|(
name|hwrpb
argument_list|,
name|unit
argument_list|)
operator|->
name|pcs_proc_type
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|proctype
argument_list|,
name|uap
operator|->
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|percpu
argument_list|)
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|OSF_GET_HWRPB
case|:
block|{
comment|/* note -- osf/1 doesn't have rpb_tbhint[8] */
name|unsigned
name|long
name|rpb_size
decl_stmt|;
name|rpb_size
operator|=
operator|(
name|unsigned
name|long
operator|)
operator|&
name|hwrpb
operator|->
name|rpb_tbhint
operator|-
operator|(
name|unsigned
name|long
operator|)
name|hwrpb
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|nbytes
operator|<
name|rpb_size
condition|)
block|{
name|uprintf
argument_list|(
literal|"nbytes = %ld, sizeof(struct rpb) = %ld\n"
argument_list|,
name|uap
operator|->
name|nbytes
argument_list|,
name|rpb_size
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|copyout
argument_list|(
name|hwrpb
argument_list|,
name|uap
operator|->
name|buffer
argument_list|,
name|rpb_size
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
block|}
block|}
break|break;
case|case
name|OSF_GET_PLATFORM_NAME
case|:
name|error
operator|=
name|copyout
argument_list|(
name|platform
operator|.
name|model
argument_list|,
name|uap
operator|->
name|buffer
argument_list|,
name|strlen
argument_list|(
name|platform
operator|.
name|model
argument_list|)
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"osf1_getsysinfo called with unknown op=%ld\n"
argument_list|,
name|uap
operator|->
name|op
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|retval
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|osf1_setsysinfo
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|osf1_setsysinfo_args
modifier|*
name|uap
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|uap
operator|->
name|op
condition|)
block|{
case|case
name|OSF_SET_IEEE_FP_CONTROL
case|:
block|{
name|u_int64_t
name|temp
decl_stmt|,
modifier|*
name|fp_control
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|buffer
argument_list|,
operator|&
name|temp
argument_list|,
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
argument_list|)
operator|)
condition|)
break|break;
name|fp_control
operator|=
operator|&
name|td
operator|->
name|td_pcb
operator|->
name|pcb_fp_control
expr_stmt|;
operator|*
name|fp_control
operator|=
name|temp
operator|&
name|IEEE_TRAP_ENABLE_MASK
expr_stmt|;
break|break;
block|}
default|default:
name|uprintf
argument_list|(
literal|"osf1_setsysinfo called with op=%ld\n"
argument_list|,
name|uap
operator|->
name|op
argument_list|)
expr_stmt|;
comment|/*error = EINVAL;*/
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|osf1_getrlimit
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|osf1_getrlimit_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|__getrlimit_args
comment|/* { 		syscallarg(u_int) which; 		syscallarg(struct rlimit *) rlp; 	} */
name|a
decl_stmt|;
if|if
condition|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|which
argument_list|)
operator|>=
name|OSF1_RLIMIT_NLIMITS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|which
argument_list|)
operator|<=
name|OSF1_RLIMIT_LASTCOMMON
condition|)
name|SCARG
argument_list|(
operator|&
name|a
argument_list|,
name|which
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|which
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|which
argument_list|)
operator|==
name|OSF1_RLIMIT_NOFILE
condition|)
name|SCARG
argument_list|(
operator|&
name|a
argument_list|,
name|which
argument_list|)
operator|=
name|RLIMIT_NOFILE
expr_stmt|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
name|SCARG
argument_list|(
operator|&
name|a
argument_list|,
name|rlp
argument_list|)
operator|=
operator|(
expr|struct
name|rlimit
operator|*
operator|)
name|SCARG
argument_list|(
name|uap
argument_list|,
name|rlp
argument_list|)
expr_stmt|;
return|return
name|getrlimit
argument_list|(
name|td
argument_list|,
operator|&
name|a
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|osf1_setrlimit
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|osf1_setrlimit_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|__setrlimit_args
comment|/* { 		syscallarg(u_int) which; 		syscallarg(struct rlimit *) rlp; 	} */
name|a
decl_stmt|;
if|if
condition|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|which
argument_list|)
operator|>=
name|OSF1_RLIMIT_NLIMITS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|which
argument_list|)
operator|<=
name|OSF1_RLIMIT_LASTCOMMON
condition|)
name|SCARG
argument_list|(
operator|&
name|a
argument_list|,
name|which
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|which
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|which
argument_list|)
operator|==
name|OSF1_RLIMIT_NOFILE
condition|)
name|SCARG
argument_list|(
operator|&
name|a
argument_list|,
name|which
argument_list|)
operator|=
name|RLIMIT_NOFILE
expr_stmt|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
name|SCARG
argument_list|(
operator|&
name|a
argument_list|,
name|rlp
argument_list|)
operator|=
operator|(
expr|struct
name|rlimit
operator|*
operator|)
name|SCARG
argument_list|(
name|uap
argument_list|,
name|rlp
argument_list|)
expr_stmt|;
return|return
name|setrlimit
argument_list|(
name|td
argument_list|,
operator|&
name|a
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  *  As linux says, this is a total guess.  */
end_comment

begin_function
name|int
name|osf1_set_program_attributes
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|osf1_set_program_attributes_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|vmspace
modifier|*
name|vm
init|=
name|td
operator|->
name|td_proc
operator|->
name|p_vmspace
decl_stmt|;
name|vm
operator|->
name|vm_taddr
operator|=
operator|(
name|caddr_t
operator|)
name|uap
operator|->
name|text_start
expr_stmt|;
name|vm
operator|->
name|vm_tsize
operator|=
name|btoc
argument_list|(
name|round_page
argument_list|(
name|uap
operator|->
name|text_len
argument_list|)
argument_list|)
expr_stmt|;
name|vm
operator|->
name|vm_daddr
operator|=
operator|(
name|caddr_t
operator|)
name|uap
operator|->
name|bss_start
expr_stmt|;
name|vm
operator|->
name|vm_dsize
operator|=
name|btoc
argument_list|(
name|round_page
argument_list|(
name|uap
operator|->
name|bss_len
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|KERN_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|int
name|osf1_mmap
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|osf1_mmap_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|mmap_args
comment|/* { 		syscallarg(caddr_t) addr; 		syscallarg(size_t) len; 		syscallarg(int) prot; 		syscallarg(int) flags; 		syscallarg(int) fd; 		syscallarg(long) pad; 		syscallarg(off_t) pos; 	} */
name|a
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|vm_map_t
name|map
decl_stmt|;
name|vm_offset_t
name|addr
decl_stmt|,
name|len
decl_stmt|,
name|newaddr
decl_stmt|;
name|GIANT_REQUIRED
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|a
argument_list|,
name|addr
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|a
argument_list|,
name|len
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|a
argument_list|,
name|prot
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|prot
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|a
argument_list|,
name|fd
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|a
argument_list|,
name|pad
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|a
argument_list|,
name|pos
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|a
argument_list|,
name|flags
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* 	 *  OSF/1's mmap, unlike FreeBSD's, does its best to map memory at the 	 *  user's requested address, even if MAP_FIXED is not set.  Here we 	 *  try to replicate this behaviour as much as we can because some 	 *  applications (like /sbin/loader) depend on having things put as 	 *  close to where they've requested as possible. 	 */
if|if
condition|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|addr
argument_list|)
operator|!=
name|NULL
condition|)
name|addr
operator|=
name|round_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|SCARG
argument_list|(
operator|&
name|a
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
else|else
comment|/* 	 *  Try to use the apparent OSF/1 default placement of 0x10000 for 	 *  NULL addrs, this helps to prevent non-64 bit clean binaries from 	 *  SEGV'ing. 	 */
name|addr
operator|=
name|round_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
literal|0x10000UL
argument_list|)
expr_stmt|;
name|len
operator|=
operator|(
name|vm_offset_t
operator|)
name|SCARG
argument_list|(
operator|&
name|a
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|map
operator|=
operator|&
name|td
operator|->
name|td_proc
operator|->
name|p_vmspace
operator|->
name|vm_map
expr_stmt|;
if|if
condition|(
operator|!
name|vm_map_findspace
argument_list|(
name|map
argument_list|,
name|addr
argument_list|,
name|len
argument_list|,
operator|&
name|newaddr
argument_list|)
condition|)
block|{
name|SCARG
argument_list|(
operator|&
name|a
argument_list|,
name|addr
argument_list|)
operator|=
operator|(
name|caddr_t
operator|)
name|newaddr
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|a
argument_list|,
name|flags
argument_list|)
operator||=
operator|(
name|MAP_FIXED
operator|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
else|else
name|uprintf
argument_list|(
literal|"osf1_mmap:vm_map_findspace failed for: %p 0x%lx\n"
argument_list|,
operator|(
name|caddr_t
operator|)
name|addr
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|flags
argument_list|)
operator|&
name|OSF1_MAP_SHARED
condition|)
name|SCARG
argument_list|(
operator|&
name|a
argument_list|,
name|flags
argument_list|)
operator||=
name|MAP_SHARED
expr_stmt|;
if|if
condition|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|flags
argument_list|)
operator|&
name|OSF1_MAP_PRIVATE
condition|)
name|SCARG
argument_list|(
operator|&
name|a
argument_list|,
name|flags
argument_list|)
operator||=
name|MAP_PRIVATE
expr_stmt|;
switch|switch
condition|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|flags
argument_list|)
operator|&
name|OSF1_MAP_TYPE
condition|)
block|{
case|case
name|OSF1_MAP_ANONYMOUS
case|:
name|SCARG
argument_list|(
operator|&
name|a
argument_list|,
name|flags
argument_list|)
operator||=
name|MAP_ANON
expr_stmt|;
break|break;
case|case
name|OSF1_MAP_FILE
case|:
name|SCARG
argument_list|(
operator|&
name|a
argument_list|,
name|flags
argument_list|)
operator||=
name|MAP_FILE
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|flags
argument_list|)
operator|&
name|OSF1_MAP_FIXED
condition|)
name|SCARG
argument_list|(
operator|&
name|a
argument_list|,
name|flags
argument_list|)
operator||=
name|MAP_FIXED
expr_stmt|;
if|if
condition|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|flags
argument_list|)
operator|&
name|OSF1_MAP_HASSEMAPHORE
condition|)
name|SCARG
argument_list|(
operator|&
name|a
argument_list|,
name|flags
argument_list|)
operator||=
name|MAP_HASSEMAPHORE
expr_stmt|;
if|if
condition|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|flags
argument_list|)
operator|&
name|OSF1_MAP_INHERIT
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|flags
argument_list|)
operator|&
name|OSF1_MAP_UNALIGNED
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 *  Emulate an osf/1 bug:  Apparently, mmap'ed segments are always 	 *  readable even if the user doesn't or in PROT_READ.  This causes 	 *  some buggy programs to segv. 	 */
name|SCARG
argument_list|(
operator|&
name|a
argument_list|,
name|prot
argument_list|)
operator||=
name|PROT_READ
expr_stmt|;
name|retval
operator|=
name|mmap
argument_list|(
name|td
argument_list|,
operator|&
name|a
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|uprintf
argument_list|(
literal|"\nosf1_mmap: addr=%p (%p), len = 0x%lx, prot=0x%x, fd=%d, pad=0, pos=0x%lx"
argument_list|,
name|SCARG
argument_list|(
name|uap
argument_list|,
name|addr
argument_list|)
argument_list|,
name|SCARG
argument_list|(
operator|&
name|a
argument_list|,
name|addr
argument_list|)
argument_list|,
name|SCARG
argument_list|(
name|uap
argument_list|,
name|len
argument_list|)
argument_list|,
name|SCARG
argument_list|(
name|uap
argument_list|,
name|prot
argument_list|)
argument_list|,
name|SCARG
argument_list|(
name|uap
argument_list|,
name|fd
argument_list|)
argument_list|,
name|SCARG
argument_list|(
name|uap
argument_list|,
name|pos
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" flags = 0x%x\n"
argument_list|,
name|SCARG
argument_list|(
name|uap
argument_list|,
name|flags
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|int
name|osf1_msync
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|osf1_msync_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|msync_args
name|a
decl_stmt|;
name|a
operator|.
name|addr
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|a
operator|.
name|len
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|a
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|flags
argument_list|)
operator|&
name|OSF1_MS_ASYNC
condition|)
name|SCARG
argument_list|(
operator|&
name|a
argument_list|,
name|flags
argument_list|)
operator||=
name|MS_ASYNC
expr_stmt|;
if|if
condition|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|flags
argument_list|)
operator|&
name|OSF1_MS_SYNC
condition|)
name|SCARG
argument_list|(
operator|&
name|a
argument_list|,
name|flags
argument_list|)
operator||=
name|MS_SYNC
expr_stmt|;
if|if
condition|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|flags
argument_list|)
operator|&
name|OSF1_MS_INVALIDATE
condition|)
name|SCARG
argument_list|(
operator|&
name|a
argument_list|,
name|flags
argument_list|)
operator||=
name|MS_INVALIDATE
expr_stmt|;
return|return
operator|(
name|msync
argument_list|(
name|td
argument_list|,
operator|&
name|a
argument_list|)
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|osf1_stat
block|{
name|int32_t
name|st_dev
decl_stmt|;
name|u_int32_t
name|st_ino
decl_stmt|;
name|u_int32_t
name|st_mode
decl_stmt|;
name|u_int16_t
name|st_nlink
decl_stmt|;
name|u_int32_t
name|st_uid
decl_stmt|;
name|u_int32_t
name|st_gid
decl_stmt|;
name|int32_t
name|st_rdev
decl_stmt|;
name|u_int64_t
name|st_size
decl_stmt|;
name|int32_t
name|st_atime_sec
decl_stmt|;
name|int32_t
name|st_spare1
decl_stmt|;
name|int32_t
name|st_mtime_sec
decl_stmt|;
name|int32_t
name|st_spare2
decl_stmt|;
name|int32_t
name|st_ctime_sec
decl_stmt|;
name|int32_t
name|st_spare3
decl_stmt|;
name|u_int32_t
name|st_blksize
decl_stmt|;
name|int32_t
name|st_blocks
decl_stmt|;
name|u_int32_t
name|st_flags
decl_stmt|;
name|u_int32_t
name|st_gen
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  *  Get file status; this version follows links.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|osf1_stat
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|osf1_stat_args
modifier|*
name|uap
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|struct
name|osf1_stat
name|osb
decl_stmt|;
name|struct
name|nameidata
name|nd
decl_stmt|;
name|caddr_t
name|sg
decl_stmt|;
name|sg
operator|=
name|stackgap_init
argument_list|()
expr_stmt|;
name|CHECKALTEXIST
argument_list|(
name|td
argument_list|,
operator|&
name|sg
argument_list|,
name|uap
operator|->
name|path
argument_list|)
expr_stmt|;
name|NDINIT
argument_list|(
operator|&
name|nd
argument_list|,
name|LOOKUP
argument_list|,
name|FOLLOW
operator||
name|LOCKLEAF
argument_list|,
name|UIO_USERSPACE
argument_list|,
name|SCARG
argument_list|(
name|uap
argument_list|,
name|path
argument_list|)
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|namei
argument_list|(
operator|&
name|nd
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|vn_stat
argument_list|(
name|nd
operator|.
name|ni_vp
argument_list|,
operator|&
name|sb
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|nd
operator|.
name|ni_vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|cvtstat2osf1
argument_list|(
operator|&
name|sb
argument_list|,
operator|&
name|osb
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|osb
argument_list|,
operator|(
name|caddr_t
operator|)
name|SCARG
argument_list|(
name|uap
argument_list|,
name|ub
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|osb
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  Get file status; this version does not follow links.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|osf1_lstat
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
specifier|register
name|struct
name|osf1_lstat_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|stat
name|sb
decl_stmt|;
name|struct
name|osf1_stat
name|osb
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|nameidata
name|nd
decl_stmt|;
name|caddr_t
name|sg
init|=
name|stackgap_init
argument_list|()
decl_stmt|;
name|CHECKALTEXIST
argument_list|(
name|td
argument_list|,
operator|&
name|sg
argument_list|,
name|uap
operator|->
name|path
argument_list|)
expr_stmt|;
name|NDINIT
argument_list|(
operator|&
name|nd
argument_list|,
name|LOOKUP
argument_list|,
name|NOFOLLOW
operator||
name|LOCKLEAF
argument_list|,
name|UIO_USERSPACE
argument_list|,
name|SCARG
argument_list|(
name|uap
argument_list|,
name|path
argument_list|)
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|namei
argument_list|(
operator|&
name|nd
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|vn_stat
argument_list|(
name|nd
operator|.
name|ni_vp
argument_list|,
operator|&
name|sb
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|nd
operator|.
name|ni_vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|cvtstat2osf1
argument_list|(
operator|&
name|sb
argument_list|,
operator|&
name|osb
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|osb
argument_list|,
operator|(
name|caddr_t
operator|)
name|SCARG
argument_list|(
name|uap
argument_list|,
name|ub
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|osb
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  Return status information about a file descriptor.  */
end_comment

begin_function
name|int
name|osf1_fstat
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
specifier|register
name|struct
name|osf1_fstat_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|struct
name|stat
name|ub
decl_stmt|;
name|struct
name|osf1_stat
name|oub
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|fget
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|fd
argument_list|,
operator|&
name|fp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|fo_stat
argument_list|(
name|fp
argument_list|,
operator|&
name|ub
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|fdrop
argument_list|(
name|fp
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|cvtstat2osf1
argument_list|(
operator|&
name|ub
argument_list|,
operator|&
name|oub
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|oub
argument_list|,
operator|(
name|caddr_t
operator|)
name|SCARG
argument_list|(
name|uap
argument_list|,
name|sb
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|oub
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|1
end_if

begin_define
define|#
directive|define
name|bsd2osf_dev
parameter_list|(
name|dev
parameter_list|)
value|(umajor(dev)<< 20 | uminor(dev))
end_define

begin_define
define|#
directive|define
name|osf2bsd_dev
parameter_list|(
name|dev
parameter_list|)
value|umakedev((umajor(dev)>> 20)& 0xfff, uminor(dev)& 0xfffff)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|minor
parameter_list|(
name|x
parameter_list|)
value|((int)((x)&0xffff00ff))
end_define

begin_define
define|#
directive|define
name|major
parameter_list|(
name|x
parameter_list|)
value|((int)(((u_int)(x)>> 8)&0xff))
end_define

begin_define
define|#
directive|define
name|makedev
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|((dev_t)(((x)<< 8) | (y)))
end_define

begin_define
define|#
directive|define
name|bsd2osf_dev
parameter_list|(
name|dev
parameter_list|)
value|(major(dev)<< 20 | minor(dev))
end_define

begin_define
define|#
directive|define
name|osf2bsd_dev
parameter_list|(
name|dev
parameter_list|)
value|makedev(((dev)>> 20)& 0xfff, (dev)& 0xfffff)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Convert from a stat structure to an osf1 stat structure.  */
end_comment

begin_function
specifier|static
name|void
name|cvtstat2osf1
parameter_list|(
name|st
parameter_list|,
name|ost
parameter_list|)
name|struct
name|stat
modifier|*
name|st
decl_stmt|;
name|struct
name|osf1_stat
modifier|*
name|ost
decl_stmt|;
block|{
name|ost
operator|->
name|st_dev
operator|=
name|bsd2osf_dev
argument_list|(
name|st
operator|->
name|st_dev
argument_list|)
expr_stmt|;
name|ost
operator|->
name|st_ino
operator|=
name|st
operator|->
name|st_ino
expr_stmt|;
name|ost
operator|->
name|st_mode
operator|=
name|st
operator|->
name|st_mode
expr_stmt|;
name|ost
operator|->
name|st_nlink
operator|=
name|st
operator|->
name|st_nlink
expr_stmt|;
name|ost
operator|->
name|st_uid
operator|=
name|st
operator|->
name|st_uid
operator|==
operator|-
literal|2
condition|?
operator|(
name|u_int16_t
operator|)
operator|-
literal|2
else|:
name|st
operator|->
name|st_uid
expr_stmt|;
name|ost
operator|->
name|st_gid
operator|=
name|st
operator|->
name|st_gid
operator|==
operator|-
literal|2
condition|?
operator|(
name|u_int16_t
operator|)
operator|-
literal|2
else|:
name|st
operator|->
name|st_gid
expr_stmt|;
name|ost
operator|->
name|st_rdev
operator|=
name|bsd2osf_dev
argument_list|(
name|st
operator|->
name|st_rdev
argument_list|)
expr_stmt|;
name|ost
operator|->
name|st_size
operator|=
name|st
operator|->
name|st_size
expr_stmt|;
name|ost
operator|->
name|st_atime_sec
operator|=
name|st
operator|->
name|st_atime
expr_stmt|;
name|ost
operator|->
name|st_spare1
operator|=
literal|0
expr_stmt|;
name|ost
operator|->
name|st_mtime_sec
operator|=
name|st
operator|->
name|st_mtime
expr_stmt|;
name|ost
operator|->
name|st_spare2
operator|=
literal|0
expr_stmt|;
name|ost
operator|->
name|st_ctime_sec
operator|=
name|st
operator|->
name|st_ctime
expr_stmt|;
name|ost
operator|->
name|st_spare3
operator|=
literal|0
expr_stmt|;
name|ost
operator|->
name|st_blksize
operator|=
name|st
operator|->
name|st_blksize
expr_stmt|;
name|ost
operator|->
name|st_blocks
operator|=
name|st
operator|->
name|st_blocks
expr_stmt|;
name|ost
operator|->
name|st_flags
operator|=
name|st
operator|->
name|st_flags
expr_stmt|;
name|ost
operator|->
name|st_gen
operator|=
name|st
operator|->
name|st_gen
expr_stmt|;
block|}
end_function

begin_function
name|int
name|osf1_mknod
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|osf1_mknod_args
modifier|*
name|uap
decl_stmt|;
block|{
if|#
directive|if
name|notanymore
name|struct
name|mknod_args
name|a
decl_stmt|;
name|caddr_t
name|sg
decl_stmt|;
name|sg
operator|=
name|stackgap_init
argument_list|()
expr_stmt|;
name|CHECKALTEXIST
argument_list|(
name|td
argument_list|,
operator|&
name|sg
argument_list|,
name|uap
operator|->
name|path
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|a
argument_list|,
name|path
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|a
argument_list|,
name|mode
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|a
argument_list|,
name|dev
argument_list|)
operator|=
name|osf2bsd_dev
argument_list|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|mknod
argument_list|(
name|td
argument_list|,
operator|&
name|a
argument_list|)
return|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"osf1_mknod no longer implemented\n"
argument_list|)
expr_stmt|;
return|return
name|ENOSYS
return|;
block|}
end_function

begin_function
name|int
name|osf1_access
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|osf1_access_args
modifier|*
name|uap
decl_stmt|;
block|{
name|caddr_t
name|sg
decl_stmt|;
name|sg
operator|=
name|stackgap_init
argument_list|()
expr_stmt|;
name|CHECKALTEXIST
argument_list|(
name|td
argument_list|,
operator|&
name|sg
argument_list|,
name|uap
operator|->
name|path
argument_list|)
expr_stmt|;
return|return
name|access
argument_list|(
name|td
argument_list|,
operator|(
expr|struct
name|access_args
operator|*
operator|)
name|uap
argument_list|)
return|;
block|}
end_function

begin_struct
struct|struct
name|osf1_flock
block|{
name|short
name|l_type
decl_stmt|;
name|short
name|l_whence
decl_stmt|;
name|off_t
name|l_start
decl_stmt|;
name|off_t
name|l_len
decl_stmt|;
name|pid_t
name|l_pid
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|int
name|osf1_fcntl
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|osf1_fcntl_args
modifier|*
name|uap
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|long
name|tmp
decl_stmt|;
name|caddr_t
name|oarg
decl_stmt|,
name|sg
decl_stmt|;
name|struct
name|fcntl_args
name|a
decl_stmt|;
name|struct
name|osf1_flock
name|osf_flock
decl_stmt|;
name|struct
name|flock
name|bsd_flock
decl_stmt|;
name|struct
name|flock
modifier|*
name|nflock
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|cmd
argument_list|)
condition|)
block|{
case|case
name|F_SETFL
case|:
name|SCARG
argument_list|(
operator|&
name|a
argument_list|,
name|fd
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|a
argument_list|,
name|cmd
argument_list|)
operator|=
name|F_SETFL
expr_stmt|;
comment|/* need to translate flags here */
name|tmp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|long
operator|)
name|SCARG
argument_list|(
name|uap
argument_list|,
name|arg
argument_list|)
operator|&
name|OSF1_FNONBLOCK
condition|)
name|tmp
operator||=
name|FNONBLOCK
expr_stmt|;
if|if
condition|(
operator|(
name|long
operator|)
name|SCARG
argument_list|(
name|uap
argument_list|,
name|arg
argument_list|)
operator|&
name|OSF1_FAPPEND
condition|)
name|tmp
operator||=
name|FAPPEND
expr_stmt|;
if|if
condition|(
operator|(
name|long
operator|)
name|SCARG
argument_list|(
name|uap
argument_list|,
name|arg
argument_list|)
operator|&
name|OSF1_FDEFER
condition|)
name|tmp
operator||=
name|FDEFER
expr_stmt|;
if|if
condition|(
operator|(
name|long
operator|)
name|SCARG
argument_list|(
name|uap
argument_list|,
name|arg
argument_list|)
operator|&
name|OSF1_FASYNC
condition|)
name|tmp
operator||=
name|FASYNC
expr_stmt|;
if|if
condition|(
operator|(
name|long
operator|)
name|SCARG
argument_list|(
name|uap
argument_list|,
name|arg
argument_list|)
operator|&
name|OSF1_FCREAT
condition|)
name|tmp
operator||=
name|O_CREAT
expr_stmt|;
if|if
condition|(
operator|(
name|long
operator|)
name|SCARG
argument_list|(
name|uap
argument_list|,
name|arg
argument_list|)
operator|&
name|OSF1_FTRUNC
condition|)
name|tmp
operator||=
name|O_TRUNC
expr_stmt|;
if|if
condition|(
operator|(
name|long
operator|)
name|SCARG
argument_list|(
name|uap
argument_list|,
name|arg
argument_list|)
operator|&
name|OSF1_FEXCL
condition|)
name|tmp
operator||=
name|O_EXCL
expr_stmt|;
if|if
condition|(
operator|(
name|long
operator|)
name|SCARG
argument_list|(
name|uap
argument_list|,
name|arg
argument_list|)
operator|&
name|OSF1_FNDELAY
condition|)
name|tmp
operator||=
name|FNDELAY
expr_stmt|;
if|if
condition|(
operator|(
name|long
operator|)
name|SCARG
argument_list|(
name|uap
argument_list|,
name|arg
argument_list|)
operator|&
name|OSF1_FSYNC
condition|)
name|tmp
operator||=
name|FFSYNC
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|a
argument_list|,
name|arg
argument_list|)
operator|=
name|tmp
expr_stmt|;
name|error
operator|=
name|fcntl
argument_list|(
name|td
argument_list|,
operator|&
name|a
argument_list|)
expr_stmt|;
break|break;
case|case
name|F_SETLK
case|:
case|case
name|F_SETLKW
case|:
case|case
name|F_GETLK
case|:
comment|/* 		 *  The OSF/1 flock stucture has a different order than 		 *  the BSD one, but all else is the same.  We must 		 *  reorder the one we've gotten so that flock() groks it. 		 */
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|arg
argument_list|,
operator|&
name|osf_flock
argument_list|,
sizeof|sizeof
argument_list|(
name|osf_flock
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
name|bsd_flock
operator|.
name|l_type
operator|=
name|osf_flock
operator|.
name|l_type
expr_stmt|;
name|bsd_flock
operator|.
name|l_whence
operator|=
name|osf_flock
operator|.
name|l_whence
expr_stmt|;
name|bsd_flock
operator|.
name|l_start
operator|=
name|osf_flock
operator|.
name|l_start
expr_stmt|;
name|bsd_flock
operator|.
name|l_len
operator|=
name|osf_flock
operator|.
name|l_len
expr_stmt|;
name|bsd_flock
operator|.
name|l_pid
operator|=
name|osf_flock
operator|.
name|l_pid
expr_stmt|;
name|sg
operator|=
name|stackgap_init
argument_list|()
expr_stmt|;
name|nflock
operator|=
name|stackgap_alloc
argument_list|(
operator|&
name|sg
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|flock
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|bsd_flock
argument_list|,
name|nflock
argument_list|,
sizeof|sizeof
argument_list|(
name|bsd_flock
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|oarg
operator|=
name|uap
operator|->
name|arg
expr_stmt|;
name|uap
operator|->
name|arg
operator|=
name|nflock
expr_stmt|;
name|error
operator|=
name|fcntl
argument_list|(
name|td
argument_list|,
operator|(
expr|struct
name|fcntl_args
operator|*
operator|)
name|uap
argument_list|)
expr_stmt|;
comment|/*		if (error) { 			printf("fcntl called with cmd=%d, args=0x%lx\n returns %d\n",uap->cmd,(long)uap->arg,error); 			printf("bsd_flock.l_type = 0x%x\n", bsd_flock.l_type); 			printf("bsd_flock.l_whence = 0x%x\n", bsd_flock.l_whence); 			printf("bsd_flock.l_start = 0x%lx\n", bsd_flock.l_start); 			printf("bsd_flock.l_len = 0x%lx\n", bsd_flock.l_len); 			printf("bsd_flock.l_pid = 0x%x\n", bsd_flock.l_pid); 		} */
if|if
condition|(
operator|(
name|uap
operator|->
name|cmd
operator|==
name|F_GETLK
operator|)
operator|&&
operator|!
name|error
condition|)
block|{
name|osf_flock
operator|.
name|l_type
operator|=
name|F_UNLCK
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|osf_flock
argument_list|,
name|oarg
argument_list|,
sizeof|sizeof
argument_list|(
name|osf_flock
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
block|}
break|break;
default|default:
name|error
operator|=
name|fcntl
argument_list|(
name|td
argument_list|,
operator|(
expr|struct
name|fcntl_args
operator|*
operator|)
name|uap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|uap
operator|->
name|cmd
operator|==
name|OSF1_F_GETFL
operator|)
operator|&&
operator|!
name|error
condition|)
block|{
name|tmp
operator|=
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|&
name|O_ACCMODE
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|&
name|FNONBLOCK
condition|)
name|tmp
operator||=
name|OSF1_FNONBLOCK
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|&
name|FAPPEND
condition|)
name|tmp
operator||=
name|OSF1_FAPPEND
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|&
name|FDEFER
condition|)
name|tmp
operator||=
name|OSF1_FDEFER
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|&
name|FASYNC
condition|)
name|tmp
operator||=
name|OSF1_FASYNC
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|&
name|O_CREAT
condition|)
name|tmp
operator||=
name|OSF1_FCREAT
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|&
name|O_TRUNC
condition|)
name|tmp
operator||=
name|OSF1_FTRUNC
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|&
name|O_EXCL
condition|)
name|tmp
operator||=
name|OSF1_FEXCL
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|&
name|FNDELAY
condition|)
name|tmp
operator||=
name|OSF1_FNDELAY
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|&
name|FFSYNC
condition|)
name|tmp
operator||=
name|OSF1_FSYNC
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|tmp
expr_stmt|;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|int osf1_fcntl(td, uap) 	struct thread *td; 	struct osf1_fcntl_args *uap; { 	struct fcntl_args a; 	long tmp; 	int error;  	SCARG(&a, fd) = SCARG(uap, fd);  	switch (SCARG(uap, cmd)) {  	case OSF1_F_DUPFD: 		SCARG(&a, cmd) = F_DUPFD; 		SCARG(&a, arg) = (long)SCARG(uap, arg); 		break;  	case OSF1_F_GETFD: 		SCARG(&a, cmd) = F_GETFD; 		SCARG(&a, arg) = (long)SCARG(uap, arg); 		break;  	case OSF1_F_SETFD: 		SCARG(&a, cmd) = F_SETFD; 		SCARG(&a, arg) = (long)SCARG(uap, arg); 		break;  	case OSF1_F_GETFL: 		SCARG(&a, cmd) = F_GETFL; 		SCARG(&a, arg) = (long)SCARG(uap, arg);
comment|/* ignored */
end_comment

begin_comment
unit|break;  	case OSF1_F_SETFL: 		SCARG(&a, cmd) = F_SETFL; 		tmp = 0; 		if ((long)SCARG(uap, arg)& OSF1_FAPPEND) 			tmp |= FAPPEND; 		if ((long)SCARG(uap, arg)& OSF1_FNONBLOCK) 			tmp |= FNONBLOCK; 		if ((long)SCARG(uap, arg)& OSF1_FASYNC) 			tmp |= FASYNC; 		if ((long)SCARG(uap, arg)& OSF1_FSYNC) 			tmp |= FFSYNC; 		SCARG(&a, arg) = tmp; 		break;  	default:
comment|/* XXX other cases */
end_comment

begin_comment
unit|return (EINVAL); 	}  	error = fcntl(td,&a);  	if (error) 		return error;  	switch (SCARG(uap, cmd)) { 	case OSF1_F_GETFL:
comment|/* XXX */
end_comment

begin_endif
unit|break; 	}  	return error; }
endif|#
directive|endif
end_endif

begin_function
name|int
name|osf1_socket
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|osf1_socket_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|socket_args
name|a
decl_stmt|;
if|if
condition|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|type
argument_list|)
operator|>
name|AF_LINK
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* XXX After AF_LINK, divergence. */
name|SCARG
argument_list|(
operator|&
name|a
argument_list|,
name|domain
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|domain
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|a
argument_list|,
name|type
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|a
argument_list|,
name|protocol
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|protocol
argument_list|)
expr_stmt|;
return|return
name|socket
argument_list|(
name|td
argument_list|,
operator|&
name|a
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|osf1_sendto
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
specifier|register
name|struct
name|osf1_sendto_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|sendto_args
name|a
decl_stmt|;
if|if
condition|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|flags
argument_list|)
operator|&
operator|~
literal|0x7f
condition|)
comment|/* unsupported flags */
return|return
operator|(
name|EINVAL
operator|)
return|;
name|SCARG
argument_list|(
operator|&
name|a
argument_list|,
name|s
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|a
argument_list|,
name|buf
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|a
argument_list|,
name|len
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|a
argument_list|,
name|flags
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|a
argument_list|,
name|to
argument_list|)
operator|=
operator|(
name|caddr_t
operator|)
name|SCARG
argument_list|(
name|uap
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|a
argument_list|,
name|tolen
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|tolen
argument_list|)
expr_stmt|;
return|return
name|sendto
argument_list|(
name|td
argument_list|,
operator|&
name|a
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|osf1_reboot
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|osf1_reboot_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|reboot_args
name|a
decl_stmt|;
if|if
condition|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|opt
argument_list|)
operator|&
operator|~
name|OSF1_RB_ALLFLAGS
operator|&&
name|SCARG
argument_list|(
name|uap
argument_list|,
name|opt
argument_list|)
operator|&
operator|(
name|OSF1_RB_ALTBOOT
operator||
name|OSF1_RB_UNIPROC
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|SCARG
argument_list|(
operator|&
name|a
argument_list|,
name|opt
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|opt
argument_list|)
operator|&
name|OSF1_RB_ASKNAME
condition|)
name|SCARG
argument_list|(
operator|&
name|a
argument_list|,
name|opt
argument_list|)
operator||=
name|RB_ASKNAME
expr_stmt|;
if|if
condition|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|opt
argument_list|)
operator|&
name|OSF1_RB_SINGLE
condition|)
name|SCARG
argument_list|(
operator|&
name|a
argument_list|,
name|opt
argument_list|)
operator||=
name|RB_SINGLE
expr_stmt|;
if|if
condition|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|opt
argument_list|)
operator|&
name|OSF1_RB_NOSYNC
condition|)
name|SCARG
argument_list|(
operator|&
name|a
argument_list|,
name|opt
argument_list|)
operator||=
name|RB_NOSYNC
expr_stmt|;
if|if
condition|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|opt
argument_list|)
operator|&
name|OSF1_RB_HALT
condition|)
name|SCARG
argument_list|(
operator|&
name|a
argument_list|,
name|opt
argument_list|)
operator||=
name|RB_HALT
expr_stmt|;
if|if
condition|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|opt
argument_list|)
operator|&
name|OSF1_RB_INITNAME
condition|)
name|SCARG
argument_list|(
operator|&
name|a
argument_list|,
name|opt
argument_list|)
operator||=
name|RB_INITNAME
expr_stmt|;
if|if
condition|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|opt
argument_list|)
operator|&
name|OSF1_RB_DFLTROOT
condition|)
name|SCARG
argument_list|(
operator|&
name|a
argument_list|,
name|opt
argument_list|)
operator||=
name|RB_DFLTROOT
expr_stmt|;
return|return
name|reboot
argument_list|(
name|td
argument_list|,
operator|&
name|a
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|osf1_lseek
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|osf1_lseek_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|lseek_args
name|a
decl_stmt|;
name|SCARG
argument_list|(
operator|&
name|a
argument_list|,
name|fd
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|a
argument_list|,
name|pad
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|a
argument_list|,
name|offset
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|a
argument_list|,
name|whence
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|whence
argument_list|)
expr_stmt|;
return|return
name|lseek
argument_list|(
name|td
argument_list|,
operator|&
name|a
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  *  OSF/1 defines _POSIX_SAVED_IDS, which means that our normal  *  setuid() won't work.  *  *  Instead, by P1003.1b-1993, setuid() is supposed to work like:  *	If the process has appropriate [super-user] priviledges, the  *	    setuid() function sets the real user ID, effective user  *	    ID, and the saved set-user-ID to uid.  *	If the process does not have appropriate priviledges, but uid  *	    is equal to the real user ID or the saved set-user-ID, the  *	    setuid() function sets the effective user ID to uid; the  *	    real user ID and saved set-user-ID remain unchanged by  *	    this function call.  */
end_comment

begin_function
name|int
name|osf1_setuid
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|osf1_setuid_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uid_t
name|uid
decl_stmt|;
name|struct
name|ucred
modifier|*
name|newcred
decl_stmt|,
modifier|*
name|oldcred
decl_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
name|uid
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|uid
argument_list|)
expr_stmt|;
name|oldcred
operator|=
name|p
operator|->
name|p_ucred
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|suser_cred
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
name|PRISON_ROOT
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|uid
operator|!=
name|oldcred
operator|->
name|cr_ruid
operator|&&
name|uid
operator|!=
name|oldcred
operator|->
name|cr_svuid
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|newcred
operator|=
name|crdup
argument_list|(
name|oldcred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|uid
operator|!=
name|oldcred
operator|->
name|cr_ruid
condition|)
block|{
name|change_ruid
argument_list|(
name|newcred
argument_list|,
name|uid
argument_list|)
expr_stmt|;
name|setsugid
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|oldcred
operator|->
name|cr_svuid
operator|!=
name|uid
condition|)
block|{
name|change_svuid
argument_list|(
name|newcred
argument_list|,
name|uid
argument_list|)
expr_stmt|;
name|setsugid
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|newcred
operator|->
name|cr_uid
operator|!=
name|uid
condition|)
block|{
name|change_euid
argument_list|(
name|newcred
argument_list|,
name|uid
argument_list|)
expr_stmt|;
name|setsugid
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|p_ucred
operator|=
name|newcred
expr_stmt|;
name|crfree
argument_list|(
name|oldcred
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  OSF/1 defines _POSIX_SAVED_IDS, which means that our normal  *  setgid() won't work.  *  *  If you change "uid" to "gid" in the discussion, above, about  *  setuid(), you'll get a correct description of setgid().  */
end_comment

begin_function
name|int
name|osf1_setgid
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|osf1_setgid_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|int
name|error
decl_stmt|;
name|gid_t
name|gid
decl_stmt|;
name|struct
name|ucred
modifier|*
name|newcred
decl_stmt|,
modifier|*
name|oldcred
decl_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
name|gid
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|gid
argument_list|)
expr_stmt|;
name|oldcred
operator|=
name|p
operator|->
name|p_ucred
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|error
operator|=
name|suser_cred
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
name|PRISON_ROOT
argument_list|)
operator|)
operator|!=
literal|0
operator|)
operator|&&
name|gid
operator|!=
name|oldcred
operator|->
name|cr_rgid
operator|&&
name|gid
operator|!=
name|oldcred
operator|->
name|cr_svgid
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|newcred
operator|=
name|crdup
argument_list|(
name|oldcred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|gid
operator|!=
name|oldcred
operator|->
name|cr_rgid
condition|)
block|{
name|change_rgid
argument_list|(
name|newcred
argument_list|,
name|gid
argument_list|)
expr_stmt|;
name|setsugid
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|oldcred
operator|->
name|cr_svgid
operator|!=
name|gid
condition|)
block|{
name|change_svgid
argument_list|(
name|newcred
argument_list|,
name|gid
argument_list|)
expr_stmt|;
name|setsugid
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|newcred
operator|->
name|cr_groups
index|[
literal|0
index|]
operator|!=
name|gid
condition|)
block|{
name|change_egid
argument_list|(
name|newcred
argument_list|,
name|gid
argument_list|)
expr_stmt|;
name|setsugid
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|p_ucred
operator|=
name|newcred
expr_stmt|;
name|crfree
argument_list|(
name|oldcred
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  The structures end up being the same... but we can't be sure that  *  the other word of our iov_len is zero!  */
end_comment

begin_struct
struct|struct
name|osf1_iovec
block|{
name|char
modifier|*
name|iov_base
decl_stmt|;
name|int
name|iov_len
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|STACKGAPLEN
value|400
end_define

begin_function
name|int
name|osf1_readv
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|osf1_readv_args
modifier|*
name|uap
decl_stmt|;
block|{
name|int
name|error
decl_stmt|,
name|osize
decl_stmt|,
name|nsize
decl_stmt|,
name|i
decl_stmt|;
name|caddr_t
name|sg
decl_stmt|;
name|struct
name|readv_args
comment|/* { 		syscallarg(int) fd; 		syscallarg(struct iovec *) iovp; 		syscallarg(u_int) iovcnt; 	} */
name|a
decl_stmt|;
name|struct
name|osf1_iovec
modifier|*
name|oio
decl_stmt|;
name|struct
name|iovec
modifier|*
name|nio
decl_stmt|;
name|sg
operator|=
name|stackgap_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|iovcnt
argument_list|)
operator|>
operator|(
name|STACKGAPLEN
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|iovec
argument_list|)
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|osize
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|iovcnt
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|osf1_iovec
argument_list|)
expr_stmt|;
name|nsize
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|iovcnt
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|iovec
argument_list|)
expr_stmt|;
name|oio
operator|=
name|malloc
argument_list|(
name|osize
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|nio
operator|=
name|malloc
argument_list|(
name|nsize
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|iovp
argument_list|)
argument_list|,
name|oio
argument_list|,
name|osize
argument_list|)
operator|)
condition|)
goto|goto
name|punt
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SCARG
argument_list|(
name|uap
argument_list|,
name|iovcnt
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|nio
index|[
name|i
index|]
operator|.
name|iov_base
operator|=
name|oio
index|[
name|i
index|]
operator|.
name|iov_base
expr_stmt|;
name|nio
index|[
name|i
index|]
operator|.
name|iov_len
operator|=
name|oio
index|[
name|i
index|]
operator|.
name|iov_len
expr_stmt|;
block|}
name|SCARG
argument_list|(
operator|&
name|a
argument_list|,
name|fd
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|a
argument_list|,
name|iovp
argument_list|)
operator|=
name|stackgap_alloc
argument_list|(
operator|&
name|sg
argument_list|,
name|nsize
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|a
argument_list|,
name|iovcnt
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|iovcnt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyout
argument_list|(
name|nio
argument_list|,
operator|(
name|caddr_t
operator|)
name|SCARG
argument_list|(
operator|&
name|a
argument_list|,
name|iovp
argument_list|)
argument_list|,
name|nsize
argument_list|)
operator|)
condition|)
goto|goto
name|punt
goto|;
name|error
operator|=
name|readv
argument_list|(
name|td
argument_list|,
operator|&
name|a
argument_list|)
expr_stmt|;
name|punt
label|:
name|free
argument_list|(
name|oio
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nio
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|osf1_writev
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|osf1_writev_args
modifier|*
name|uap
decl_stmt|;
block|{
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|nsize
decl_stmt|,
name|osize
decl_stmt|;
name|caddr_t
name|sg
decl_stmt|;
name|struct
name|writev_args
comment|/* { 		syscallarg(int) fd; 		syscallarg(struct iovec *) iovp; 		syscallarg(u_int) iovcnt; 	} */
name|a
decl_stmt|;
name|struct
name|osf1_iovec
modifier|*
name|oio
decl_stmt|;
name|struct
name|iovec
modifier|*
name|nio
decl_stmt|;
name|sg
operator|=
name|stackgap_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|iovcnt
argument_list|)
operator|>
operator|(
name|STACKGAPLEN
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|iovec
argument_list|)
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|osize
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|iovcnt
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|osf1_iovec
argument_list|)
expr_stmt|;
name|nsize
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|iovcnt
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|iovec
argument_list|)
expr_stmt|;
name|oio
operator|=
name|malloc
argument_list|(
name|osize
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|nio
operator|=
name|malloc
argument_list|(
name|nsize
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|iovp
argument_list|)
argument_list|,
name|oio
argument_list|,
name|osize
argument_list|)
operator|)
condition|)
goto|goto
name|punt
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SCARG
argument_list|(
name|uap
argument_list|,
name|iovcnt
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|nio
index|[
name|i
index|]
operator|.
name|iov_base
operator|=
name|oio
index|[
name|i
index|]
operator|.
name|iov_base
expr_stmt|;
name|nio
index|[
name|i
index|]
operator|.
name|iov_len
operator|=
name|oio
index|[
name|i
index|]
operator|.
name|iov_len
expr_stmt|;
block|}
name|SCARG
argument_list|(
operator|&
name|a
argument_list|,
name|fd
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|a
argument_list|,
name|iovp
argument_list|)
operator|=
name|stackgap_alloc
argument_list|(
operator|&
name|sg
argument_list|,
name|nsize
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|a
argument_list|,
name|iovcnt
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|iovcnt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyout
argument_list|(
name|nio
argument_list|,
operator|(
name|caddr_t
operator|)
name|SCARG
argument_list|(
operator|&
name|a
argument_list|,
name|iovp
argument_list|)
argument_list|,
name|nsize
argument_list|)
operator|)
condition|)
goto|goto
name|punt
goto|;
name|error
operator|=
name|writev
argument_list|(
name|td
argument_list|,
operator|&
name|a
argument_list|)
expr_stmt|;
name|punt
label|:
name|free
argument_list|(
name|oio
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nio
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  More of the stupid off_t padding!  */
end_comment

begin_function
name|int
name|osf1_truncate
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|osf1_truncate_args
modifier|*
name|uap
decl_stmt|;
block|{
name|caddr_t
name|sg
decl_stmt|;
name|struct
name|truncate_args
name|a
decl_stmt|;
name|sg
operator|=
name|stackgap_init
argument_list|()
expr_stmt|;
name|CHECKALTEXIST
argument_list|(
name|td
argument_list|,
operator|&
name|sg
argument_list|,
name|uap
operator|->
name|path
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|a
argument_list|,
name|path
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|a
argument_list|,
name|pad
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|a
argument_list|,
name|length
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return
name|truncate
argument_list|(
name|td
argument_list|,
operator|&
name|a
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|osf1_ftruncate
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|osf1_ftruncate_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|ftruncate_args
name|a
decl_stmt|;
name|SCARG
argument_list|(
operator|&
name|a
argument_list|,
name|fd
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|a
argument_list|,
name|pad
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|a
argument_list|,
name|length
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return
name|ftruncate
argument_list|(
name|td
argument_list|,
operator|&
name|a
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|osf2bsd_pathconf
parameter_list|(
name|name
parameter_list|)
name|int
modifier|*
name|name
decl_stmt|;
block|{
switch|switch
condition|(
operator|*
name|name
condition|)
block|{
case|case
name|_OSF1_PC_LINK_MAX
case|:
case|case
name|_OSF1_PC_MAX_CANON
case|:
case|case
name|_OSF1_PC_MAX_INPUT
case|:
case|case
name|_OSF1_PC_NAME_MAX
case|:
operator|*
name|name
operator|-=
literal|10
expr_stmt|;
break|break;
case|case
name|_OSF1_PC_PATH_MAX
case|:
case|case
name|_OSF1_PC_PIPE_BUF
case|:
operator|*
name|name
operator|-=
literal|9
expr_stmt|;
case|case
name|_OSF1_PC_NO_TRUNC
case|:
operator|*
name|name
operator|=
name|_PC_NO_TRUNC
expr_stmt|;
break|break;
case|case
name|_OSF1_PC_CHOWN_RESTRICTED
case|:
operator|*
name|name
operator|=
name|_PC_CHOWN_RESTRICTED
expr_stmt|;
break|break;
case|case
name|_OSF1_PC_VDISABLE
case|:
operator|*
name|name
operator|=
name|_PC_VDISABLE
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|osf1_pathconf
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|osf1_pathconf_args
modifier|*
name|uap
decl_stmt|;
block|{
if|if
condition|(
name|osf2bsd_pathconf
argument_list|(
operator|&
name|uap
operator|->
name|name
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
else|else
return|return
operator|(
name|pathconf
argument_list|(
name|td
argument_list|,
operator|(
name|void
operator|*
operator|)
name|uap
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|osf1_fpathconf
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|osf1_fpathconf_args
modifier|*
name|uap
decl_stmt|;
block|{
if|if
condition|(
name|osf2bsd_pathconf
argument_list|(
operator|&
name|uap
operator|->
name|name
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
else|else
return|return
operator|(
name|fpathconf
argument_list|(
name|td
argument_list|,
operator|(
name|void
operator|*
operator|)
name|uap
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|osf1_getrusage
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|osf1_getrusage_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|rusage
modifier|*
name|rup
decl_stmt|;
name|struct
name|osf1_rusage
name|oru
decl_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
switch|switch
condition|(
name|uap
operator|->
name|who
condition|)
block|{
case|case
name|RUSAGE_SELF
case|:
name|rup
operator|=
operator|&
name|p
operator|->
name|p_stats
operator|->
name|p_ru
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|calcru
argument_list|(
name|p
argument_list|,
operator|&
name|rup
operator|->
name|ru_utime
argument_list|,
operator|&
name|rup
operator|->
name|ru_stime
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
break|break;
case|case
name|RUSAGE_CHILDREN
case|:
name|rup
operator|=
operator|&
name|p
operator|->
name|p_stats
operator|->
name|p_cru
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|TV_CP
argument_list|(
name|rup
operator|->
name|ru_utime
argument_list|,
name|oru
operator|.
name|ru_utime
argument_list|)
expr_stmt|;
name|TV_CP
argument_list|(
name|rup
operator|->
name|ru_stime
argument_list|,
name|oru
operator|.
name|ru_stime
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
operator|(
name|rup
operator|->
name|ru_first
operator|)
argument_list|,
operator|&
operator|(
name|oru
operator|.
name|ru_first
operator|)
argument_list|,
operator|(
operator|&
operator|(
name|oru
operator|.
name|ru_last
operator|)
operator|-
operator|&
operator|(
name|oru
operator|.
name|ru_first
operator|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|oru
argument_list|,
operator|(
name|caddr_t
operator|)
name|uap
operator|->
name|rusage
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|osf1_rusage
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|osf1_wait4
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|osf1_wait4_args
modifier|*
name|uap
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|caddr_t
name|sg
decl_stmt|;
name|struct
name|osf1_rusage
modifier|*
name|orusage
decl_stmt|,
name|oru
decl_stmt|;
name|struct
name|rusage
modifier|*
name|rusage
init|=
name|NULL
decl_stmt|,
name|ru
decl_stmt|;
name|orusage
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|rusage
argument_list|)
expr_stmt|;
if|if
condition|(
name|orusage
condition|)
block|{
name|sg
operator|=
name|stackgap_init
argument_list|()
expr_stmt|;
name|rusage
operator|=
name|stackgap_alloc
argument_list|(
operator|&
name|sg
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rusage
argument_list|)
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
name|uap
argument_list|,
name|rusage
argument_list|)
operator|=
operator|(
expr|struct
name|osf1_rusage
operator|*
operator|)
name|rusage
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|wait4
argument_list|(
name|td
argument_list|,
operator|(
expr|struct
name|wait_args
operator|*
operator|)
name|uap
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
if|if
condition|(
name|orusage
operator|&&
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|rusage
argument_list|,
operator|&
name|ru
argument_list|,
sizeof|sizeof
argument_list|(
name|ru
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|TV_CP
argument_list|(
name|ru
operator|.
name|ru_utime
argument_list|,
name|oru
operator|.
name|ru_utime
argument_list|)
expr_stmt|;
name|TV_CP
argument_list|(
name|ru
operator|.
name|ru_stime
argument_list|,
name|oru
operator|.
name|ru_stime
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|ru
operator|.
name|ru_first
argument_list|,
operator|&
name|oru
operator|.
name|ru_first
argument_list|,
operator|(
operator|&
operator|(
name|oru
operator|.
name|ru_last
operator|)
operator|-
operator|&
operator|(
name|oru
operator|.
name|ru_first
operator|)
operator|)
argument_list|)
expr_stmt|;
name|copyout
argument_list|(
operator|&
name|oru
argument_list|,
name|orusage
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|osf1_rusage
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|osf1_madvise
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|osf1_madvise_args
modifier|*
name|uap
decl_stmt|;
block|{
comment|/* XXX */
return|return
name|EINVAL
return|;
block|}
end_function

begin_function
name|int
name|osf1_execve
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|osf1_execve_args
modifier|*
name|uap
decl_stmt|;
block|{
name|caddr_t
name|sg
decl_stmt|;
name|struct
name|execve_args
name|ap
decl_stmt|;
name|sg
operator|=
name|stackgap_init
argument_list|()
expr_stmt|;
name|CHECKALTEXIST
argument_list|(
name|td
argument_list|,
operator|&
name|sg
argument_list|,
name|SCARG
argument_list|(
name|uap
argument_list|,
name|path
argument_list|)
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|ap
argument_list|,
name|fname
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|ap
argument_list|,
name|argv
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|argp
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|ap
argument_list|,
name|envv
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|envp
argument_list|)
expr_stmt|;
return|return
name|execve
argument_list|(
name|td
argument_list|,
operator|&
name|ap
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|osf1_usleep_thread
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|osf1_usleep_thread_args
modifier|*
name|uap
decl_stmt|;
block|{
name|int
name|error
decl_stmt|,
name|s
decl_stmt|,
name|timo
decl_stmt|;
name|struct
name|osf1_timeval
name|time
decl_stmt|;
name|struct
name|timeval
name|difftv
decl_stmt|,
name|endtv
decl_stmt|,
name|sleeptv
decl_stmt|,
name|tv
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|sleep
argument_list|)
argument_list|,
operator|&
name|time
argument_list|,
sizeof|sizeof
name|time
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|sleeptv
operator|.
name|tv_sec
operator|=
operator|(
name|u_long
operator|)
name|time
operator|.
name|tv_sec
expr_stmt|;
name|sleeptv
operator|.
name|tv_usec
operator|=
operator|(
name|u_long
operator|)
name|time
operator|.
name|tv_usec
expr_stmt|;
name|timo
operator|=
name|tvtohz
argument_list|(
operator|&
name|sleeptv
argument_list|)
expr_stmt|;
comment|/* 	 *  Some callers use usleep(0) as a sort of thread-yield so make 	 *  sure that the timeout is non-zero. 	 */
if|if
condition|(
name|timo
operator|==
literal|0
condition|)
name|timo
operator|=
literal|1
expr_stmt|;
name|s
operator|=
name|splclock
argument_list|()
expr_stmt|;
name|microtime
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|tsleep
argument_list|(
name|td
argument_list|,
name|PUSER
operator||
name|PCATCH
argument_list|,
literal|"OSF/1"
argument_list|,
name|timo
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|slept
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|s
operator|=
name|splclock
argument_list|()
expr_stmt|;
name|microtime
argument_list|(
operator|&
name|endtv
argument_list|)
expr_stmt|;
name|timersub
argument_list|(
operator|&
name|time
argument_list|,
operator|&
name|endtv
argument_list|,
operator|&
name|difftv
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|tv
operator|.
name|tv_sec
operator|<
literal|0
operator|||
name|tv
operator|.
name|tv_usec
operator|<
literal|0
condition|)
name|tv
operator|.
name|tv_sec
operator|=
name|tv
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|TV_CP
argument_list|(
name|difftv
argument_list|,
name|time
argument_list|)
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|time
argument_list|,
name|SCARG
argument_list|(
name|uap
argument_list|,
name|slept
argument_list|)
argument_list|,
sizeof|sizeof
name|time
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|osf1_gettimeofday
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
specifier|register
name|struct
name|osf1_gettimeofday_args
modifier|*
name|uap
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|struct
name|timeval
name|atv
decl_stmt|;
name|struct
name|osf1_timeval
name|otv
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|tp
condition|)
block|{
name|microtime
argument_list|(
operator|&
name|atv
argument_list|)
expr_stmt|;
name|otv
operator|.
name|tv_sec
operator|=
name|atv
operator|.
name|tv_sec
expr_stmt|;
name|otv
operator|.
name|tv_usec
operator|=
name|atv
operator|.
name|tv_usec
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|otv
argument_list|,
operator|(
name|caddr_t
operator|)
name|uap
operator|->
name|tp
argument_list|,
sizeof|sizeof
argument_list|(
name|otv
argument_list|)
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|uap
operator|->
name|tzp
condition|)
name|error
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tz
argument_list|,
operator|(
name|caddr_t
operator|)
name|uap
operator|->
name|tzp
argument_list|,
sizeof|sizeof
argument_list|(
name|tz
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|osf1_select
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
specifier|register
name|struct
name|osf1_select_args
modifier|*
name|uap
decl_stmt|;
block|{
if|if
condition|(
name|uap
operator|->
name|tv
condition|)
block|{
name|int
name|error
decl_stmt|;
name|caddr_t
name|sg
decl_stmt|;
name|struct
name|osf1_timeval
name|otv
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|sg
operator|=
name|stackgap_init
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
operator|(
name|caddr_t
operator|)
name|uap
operator|->
name|tv
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|otv
argument_list|,
sizeof|sizeof
argument_list|(
name|otv
argument_list|)
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|TV_CP
argument_list|(
name|otv
argument_list|,
name|tv
argument_list|)
expr_stmt|;
name|uap
operator|->
name|tv
operator|=
name|stackgap_alloc
argument_list|(
operator|&
name|sg
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|timeval
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tv
argument_list|,
operator|(
name|caddr_t
operator|)
name|uap
operator|->
name|tv
argument_list|,
sizeof|sizeof
argument_list|(
name|tv
argument_list|)
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
name|select
argument_list|(
name|td
argument_list|,
operator|(
expr|struct
name|select_args
operator|*
operator|)
name|uap
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|osf1_setitimer
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|osf1_setitimer_args
modifier|*
name|uap
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|caddr_t
name|old_oitv
decl_stmt|,
name|sg
decl_stmt|;
name|struct
name|itimerval
name|itv
decl_stmt|;
name|struct
name|osf1_itimerval
name|otv
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|old_oitv
operator|=
operator|(
name|caddr_t
operator|)
name|uap
operator|->
name|oitv
expr_stmt|;
name|sg
operator|=
name|stackgap_init
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
operator|(
name|caddr_t
operator|)
name|uap
operator|->
name|itv
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|otv
argument_list|,
sizeof|sizeof
argument_list|(
name|otv
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s(%d): error = %d\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|TV_CP
argument_list|(
name|otv
operator|.
name|it_interval
argument_list|,
name|itv
operator|.
name|it_interval
argument_list|)
expr_stmt|;
name|TV_CP
argument_list|(
name|otv
operator|.
name|it_value
argument_list|,
name|itv
operator|.
name|it_value
argument_list|)
expr_stmt|;
name|uap
operator|->
name|itv
operator|=
name|stackgap_alloc
argument_list|(
operator|&
name|sg
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|itimerval
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|itv
argument_list|,
operator|(
name|caddr_t
operator|)
name|uap
operator|->
name|itv
argument_list|,
sizeof|sizeof
argument_list|(
name|itv
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s(%d): error = %d\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|uap
operator|->
name|oitv
operator|=
name|stackgap_alloc
argument_list|(
operator|&
name|sg
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|itimerval
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|setitimer
argument_list|(
name|td
argument_list|,
operator|(
expr|struct
name|setitimer_args
operator|*
operator|)
name|uap
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s(%d): error = %d\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
operator|(
name|caddr_t
operator|)
name|uap
operator|->
name|oitv
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|itv
argument_list|,
sizeof|sizeof
argument_list|(
name|itv
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s(%d): error = %d\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|TV_CP
argument_list|(
name|itv
operator|.
name|it_interval
argument_list|,
name|otv
operator|.
name|it_interval
argument_list|)
expr_stmt|;
name|TV_CP
argument_list|(
name|itv
operator|.
name|it_value
argument_list|,
name|otv
operator|.
name|it_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_oitv
operator|&&
operator|(
name|error
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|otv
argument_list|,
name|old_oitv
argument_list|,
sizeof|sizeof
argument_list|(
name|otv
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s(%d): error = %d\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|osf1_getitimer
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|osf1_getitimer_args
modifier|*
name|uap
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|caddr_t
name|old_itv
decl_stmt|,
name|sg
decl_stmt|;
name|struct
name|itimerval
name|itv
decl_stmt|;
name|struct
name|osf1_itimerval
name|otv
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|old_itv
operator|=
operator|(
name|caddr_t
operator|)
name|uap
operator|->
name|itv
expr_stmt|;
name|sg
operator|=
name|stackgap_init
argument_list|()
expr_stmt|;
name|uap
operator|->
name|itv
operator|=
name|stackgap_alloc
argument_list|(
operator|&
name|sg
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|itimerval
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|getitimer
argument_list|(
name|td
argument_list|,
operator|(
expr|struct
name|getitimer_args
operator|*
operator|)
name|uap
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s(%d): error = %d\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
operator|(
name|caddr_t
operator|)
name|uap
operator|->
name|itv
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|itv
argument_list|,
sizeof|sizeof
argument_list|(
name|itv
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s(%d): error = %d\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|TV_CP
argument_list|(
name|itv
operator|.
name|it_interval
argument_list|,
name|otv
operator|.
name|it_interval
argument_list|)
expr_stmt|;
name|TV_CP
argument_list|(
name|itv
operator|.
name|it_value
argument_list|,
name|otv
operator|.
name|it_value
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|otv
argument_list|,
name|old_itv
argument_list|,
sizeof|sizeof
argument_list|(
name|otv
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s(%d): error = %d\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|osf1_proplist_syscall
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|osf1_proplist_syscall_args
modifier|*
name|uap
decl_stmt|;
block|{
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
end_function

begin_function
name|int
name|osf1_ntpgettime
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|osf1_ntpgettime_args
modifier|*
name|uap
decl_stmt|;
block|{
return|return
operator|(
name|ENOSYS
operator|)
return|;
block|}
end_function

begin_function
name|int
name|osf1_ntpadjtime
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|osf1_ntpadjtime_args
modifier|*
name|uap
decl_stmt|;
block|{
return|return
operator|(
name|ENOSYS
operator|)
return|;
block|}
end_function

begin_function
name|int
name|osf1_setpgrp
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|osf1_setpgrp_args
modifier|*
name|uap
decl_stmt|;
block|{
return|return
operator|(
name|setpgid
argument_list|(
name|td
argument_list|,
operator|(
expr|struct
name|setpgid_args
operator|*
operator|)
name|uap
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|osf1_uswitch
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|osf1_uswitch_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|vm_map_entry_t
name|entry
decl_stmt|;
name|vm_offset_t
name|zero
decl_stmt|;
name|GIANT_REQUIRED
expr_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
name|zero
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|cmd
operator|==
name|OSF1_USC_GET
condition|)
block|{
if|if
condition|(
name|vm_map_lookup_entry
argument_list|(
operator|&
operator|(
name|p
operator|->
name|p_vmspace
operator|->
name|vm_map
operator|)
argument_list|,
literal|0
argument_list|,
operator|&
name|entry
argument_list|)
condition|)
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|OSF1_USW_NULLP
expr_stmt|;
else|else
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|KERN_SUCCESS
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|uap
operator|->
name|cmd
operator|==
name|OSF1_USC_SET
condition|)
if|if
condition|(
name|uap
operator|->
name|mask
operator|&
name|OSF1_USW_NULLP
condition|)
block|{
name|rv
operator|=
name|vm_mmap
argument_list|(
operator|&
operator|(
name|p
operator|->
name|p_vmspace
operator|->
name|vm_map
operator|)
argument_list|,
operator|&
name|zero
argument_list|,
name|PAGE_SIZE
argument_list|,
name|VM_PROT_READ
argument_list|,
name|VM_PROT_ALL
argument_list|,
name|MAP_PRIVATE
operator||
name|MAP_FIXED
operator||
name|MAP_ANON
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rv
condition|)
return|return
operator|(
name|KERN_SUCCESS
operator|)
return|;
else|else
block|{
name|printf
argument_list|(
literal|"osf1_uswitch:vm_mmap of zero page failed with status %d\n"
argument_list|,
name|rv
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
block|}
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
name|int
name|osf1_classcntl
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|osf1_classcntl_args
modifier|*
name|uap
decl_stmt|;
block|{
return|return
operator|(
name|EACCES
operator|)
return|;
comment|/* class scheduling not enabled */
block|}
end_function

begin_struct
struct|struct
name|osf1_tbl_loadavg
block|{
union|union
block|{
name|long
name|l
index|[
literal|3
index|]
decl_stmt|;
name|double
name|d
index|[
literal|3
index|]
decl_stmt|;
block|}
name|tl_avenrun
union|;
name|int
name|tl_lscale
decl_stmt|;
name|long
name|tl_mach_factor
index|[
literal|3
index|]
decl_stmt|;
comment|/* ???? */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|osf1_tbl_sysinfo
block|{
name|long
name|si_user
decl_stmt|;
name|long
name|si_nice
decl_stmt|;
name|long
name|si_sys
decl_stmt|;
name|long
name|si_idle
decl_stmt|;
name|long
name|si_hz
decl_stmt|;
name|long
name|si_phz
decl_stmt|;
name|long
name|si_boottime
decl_stmt|;
name|long
name|wait
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|TBL_LOADAVG
value|3
end_define

begin_define
define|#
directive|define
name|TBL_SYSINFO
value|12
end_define

begin_function
name|int
name|osf1_table
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|osf1_table_args
comment|/*{ 				long id; 				long index; 				void *addr; 				long nel; 				u_long lel; 				}*/
modifier|*
name|uap
decl_stmt|;
block|{
name|int
name|retval
decl_stmt|;
name|struct
name|osf1_tbl_loadavg
name|ld
decl_stmt|;
name|struct
name|osf1_tbl_sysinfo
name|si
decl_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|uap
operator|->
name|id
condition|)
block|{
case|case
name|TBL_LOADAVG
case|:
comment|/* xemacs wants this */
if|if
condition|(
operator|(
name|uap
operator|->
name|index
operator|!=
literal|0
operator|)
operator|||
operator|(
name|uap
operator|->
name|nel
operator|!=
literal|1
operator|)
condition|)
name|retval
operator|=
name|EINVAL
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|averunnable
argument_list|,
operator|&
name|ld
argument_list|,
sizeof|sizeof
argument_list|(
name|averunnable
argument_list|)
argument_list|)
expr_stmt|;
name|ld
operator|.
name|tl_lscale
operator|=
operator|(
name|u_int
operator|)
name|averunnable
operator|.
name|fscale
expr_stmt|;
name|retval
operator|=
name|copyout
argument_list|(
operator|&
name|ld
argument_list|,
name|uap
operator|->
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|ld
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TBL_SYSINFO
case|:
if|if
condition|(
operator|(
name|uap
operator|->
name|index
operator|!=
literal|0
operator|)
operator|||
operator|(
name|uap
operator|->
name|nel
operator|!=
literal|1
operator|)
condition|)
name|retval
operator|=
name|EINVAL
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|si
argument_list|,
sizeof|sizeof
argument_list|(
name|si
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|si.si_user = cp_time[CP_USER]; 		si.si_nice = cp_time[CP_NICE]; 		si.si_sys  = cp_time[CP_SYS]; 		si.si_idle = cp_time[CP_IDLE]; 		si.wait    = cp_time[CP_INTR];
endif|#
directive|endif
name|si
operator|.
name|si_hz
operator|=
name|hz
expr_stmt|;
name|si
operator|.
name|si_phz
operator|=
name|profhz
expr_stmt|;
name|si
operator|.
name|si_boottime
operator|=
name|boottime
operator|.
name|tv_sec
expr_stmt|;
name|retval
operator|=
name|copyout
argument_list|(
operator|&
name|si
argument_list|,
name|uap
operator|->
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|si
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"osf1_table: %ld, %ld, %p, %ld %ld\n"
argument_list|,
name|uap
operator|->
name|id
argument_list|,
name|uap
operator|->
name|index
argument_list|,
name|uap
operator|->
name|addr
argument_list|,
name|uap
operator|->
name|nel
argument_list|,
name|uap
operator|->
name|lel
argument_list|)
expr_stmt|;
name|retval
operator|=
name|EINVAL
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_function
name|int
name|osf1_sysinfo
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|osf1_sysinfo_args
comment|/*{ 				int cmd; 				char *buf; 				long count; 				}*/
modifier|*
name|uap
decl_stmt|;
block|{
name|int
name|name
index|[
literal|2
index|]
decl_stmt|,
name|retval
decl_stmt|;
name|size_t
name|bytes
decl_stmt|,
name|len
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|string
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|uap
operator|->
name|cmd
condition|)
block|{
case|case
literal|1
case|:
comment|/* OS */
name|string
operator|=
literal|"OSF1"
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* hostname, from ogethostname */
name|len
operator|=
name|uap
operator|->
name|count
expr_stmt|;
name|name
index|[
literal|0
index|]
operator|=
name|CTL_KERN
expr_stmt|;
name|name
index|[
literal|1
index|]
operator|=
name|KERN_HOSTNAME
expr_stmt|;
name|retval
operator|=
name|userland_sysctl
argument_list|(
name|td
argument_list|,
name|name
argument_list|,
literal|2
argument_list|,
name|uap
operator|->
name|buf
argument_list|,
operator|&
name|len
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|bytes
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|bytes
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
break|break;
case|case
literal|3
case|:
comment|/* release of osf1 */
name|string
operator|=
literal|"V4.0"
expr_stmt|;
break|break;
case|case
literal|4
case|:
comment|/* minor version of osf1 */
name|string
operator|=
literal|"878"
expr_stmt|;
break|break;
case|case
literal|5
case|:
comment|/* machine or arch */
case|case
literal|6
case|:
name|string
operator|=
literal|"alpha"
expr_stmt|;
break|break;
case|case
literal|7
case|:
comment|/* serial number, real osf1 returns 0! */
name|string
operator|=
literal|"0"
expr_stmt|;
break|break;
case|case
literal|8
case|:
comment|/* HW vendor */
name|string
operator|=
literal|"Digital"
expr_stmt|;
break|break;
case|case
literal|9
case|:
comment|/* dunno, this is what du does.. */
return|return
operator|(
name|ENOSYS
operator|)
return|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|bytes
operator|=
name|min
argument_list|(
name|uap
operator|->
name|count
argument_list|,
name|strlen
argument_list|(
name|string
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|copyout
argument_list|(
name|string
argument_list|,
name|uap
operator|->
name|buf
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|bytes
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

