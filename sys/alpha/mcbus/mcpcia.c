begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/*  * Copyright (c) 2000 Matthew Jacob  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/interrupt.h>
end_include

begin_include
include|#
directive|include
file|<machine/swiz.h>
end_include

begin_include
include|#
directive|include
file|<machine/intr.h>
end_include

begin_include
include|#
directive|include
file|<machine/intrcnt.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<machine/sgmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<alpha/mcbus/mcbusreg.h>
end_include

begin_include
include|#
directive|include
file|<alpha/mcbus/mcbusvar.h>
end_include

begin_include
include|#
directive|include
file|<alpha/mcbus/mcpciareg.h>
end_include

begin_include
include|#
directive|include
file|<alpha/mcbus/mcpciavar.h>
end_include

begin_include
include|#
directive|include
file|<alpha/pci/pcibus.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|"alphapci_if.h"
end_include

begin_include
include|#
directive|include
file|"pcib_if.h"
end_include

begin_decl_stmt
specifier|static
name|devclass_t
name|mcpcia_devclass
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We're only allowing for one MCBUS right now */
end_comment

begin_decl_stmt
specifier|static
name|device_t
name|mcpcias
index|[
name|MCPCIA_PER_MCBUS
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|KV
parameter_list|(
name|pa
parameter_list|)
value|((void *)ALPHA_PHYS_TO_K0SEG(pa))
end_define

begin_struct
struct|struct
name|mcpcia_softc
block|{
name|struct
name|mcpcia_softc
modifier|*
name|next
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
comment|/* backpointer */
name|u_int64_t
name|sysbase
decl_stmt|;
comment|/* shorthand */
name|vm_offset_t
name|dmem_base
decl_stmt|;
comment|/* dense memory */
name|vm_offset_t
name|smem_base
decl_stmt|;
comment|/* sparse memory */
name|vm_offset_t
name|io_base
decl_stmt|;
comment|/* sparse i/o */
name|int
name|mcpcia_inst
decl_stmt|;
comment|/* our mcpcia instance # */
name|struct
name|swiz_space
name|io_space
decl_stmt|;
comment|/* accessor for ports */
name|struct
name|swiz_space
name|mem_space
decl_stmt|;
comment|/* accessor for memory */
name|struct
name|rman
name|io_rman
decl_stmt|;
comment|/* resource manager for ports */
name|struct
name|rman
name|mem_rman
decl_stmt|;
comment|/* resource manager for memory */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|mcpcia_softc
modifier|*
name|mcpcia_eisa
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|void
name|dec_kn300_cons_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|driver_intr_t
name|mcpcia_intr
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|mcpcia_enable_intr
parameter_list|(
name|struct
name|mcpcia_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mcpcia_disable_intr
parameter_list|(
name|struct
name|mcpcia_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * SGMAP window for ISA: 8M at 8M  */
end_comment

begin_define
define|#
directive|define
name|MCPCIA_ISA_SG_MAPPED_BASE
value|(8*1024*1024)
end_define

begin_define
define|#
directive|define
name|MCPCIA_ISA_SG_MAPPED_SIZE
value|(8*1024*1024)
end_define

begin_comment
comment|/*  * Direct-mapped window: 2G at 2G  */
end_comment

begin_define
define|#
directive|define
name|MCPCIA_DIRECT_MAPPED_BASE
value|(2UL*1024UL*1024UL*1024UL)
end_define

begin_define
define|#
directive|define
name|MCPCIA_DIRECT_MAPPED_SIZE
value|(2UL*1024UL*1024UL*1024UL)
end_define

begin_comment
comment|/*  * SGMAP window for PCI: 1G at 1G  */
end_comment

begin_define
define|#
directive|define
name|MCPCIA_PCI_SG_MAPPED_BASE
value|(1UL*1024UL*1024UL*1024UL)
end_define

begin_define
define|#
directive|define
name|MCPCIA_PCI_SG_MAPPED_SIZE
value|(1UL*1024UL*1024UL*1024UL)
end_define

begin_define
define|#
directive|define
name|MCPCIA_SGTLB_INVALIDATE
parameter_list|(
name|sc
parameter_list|)
define|\
value|do {									\ 	alpha_mb();							\ 	REGVAL(MCPCIA_SG_TBIA(sc)) = 0xdeadbeef;			\ 	alpha_mb();							\ } while (0)
end_define

begin_function_decl
specifier|static
name|void
name|mcpcia_dma_init
parameter_list|(
name|struct
name|mcpcia_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mcpcia_sgmap_map
parameter_list|(
name|void
modifier|*
parameter_list|,
name|bus_addr_t
parameter_list|,
name|vm_offset_t
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|MCPCIA_SOFTC
parameter_list|(
name|dev
parameter_list|)
value|(struct mcpcia_softc *) device_get_softc(dev)
end_define

begin_decl_stmt
specifier|static
name|struct
name|mcpcia_softc
modifier|*
name|mcpcia_root
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|mcpcia_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|device_t
name|child
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|struct
name|mcpcia_softc
modifier|*
name|xc
decl_stmt|,
modifier|*
name|sc
init|=
name|MCPCIA_SOFTC
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|unit
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|mcpcias
index|[
name|unit
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"%s: already attached\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|EEXIST
return|;
block|}
name|sc
operator|->
name|mcpcia_inst
operator|=
name|unit
expr_stmt|;
if|if
condition|(
operator|(
name|xc
operator|=
name|mcpcia_root
operator|)
operator|==
name|NULL
condition|)
block|{
name|mcpcia_root
operator|=
name|sc
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|xc
operator|->
name|next
condition|)
name|xc
operator|=
name|xc
operator|->
name|next
expr_stmt|;
name|xc
operator|->
name|next
operator|=
name|sc
expr_stmt|;
block|}
name|sc
operator|->
name|dev
operator|=
name|mcpcias
index|[
name|unit
index|]
operator|=
name|dev
expr_stmt|;
comment|/* PROBE ? */
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"MCPCIA PCI Adapter"
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|==
literal|0
condition|)
block|{
name|pci_init_resources
argument_list|()
expr_stmt|;
block|}
name|child
operator|=
name|device_add_child
argument_list|(
name|dev
argument_list|,
literal|"pci"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|device_set_ivars
argument_list|(
name|child
argument_list|,
operator|&
name|sc
operator|->
name|mcpcia_inst
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mcpcia_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|mcpcia_softc
modifier|*
name|sc
init|=
name|MCPCIA_SOFTC
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|device_t
name|p
init|=
name|device_get_parent
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|vm_offset_t
name|regs
decl_stmt|;
name|u_int32_t
name|ctl
decl_stmt|;
name|int
name|mid
decl_stmt|,
name|gid
decl_stmt|,
name|rval
decl_stmt|;
name|void
modifier|*
name|intr
decl_stmt|;
name|mid
operator|=
name|mcbus_get_mid
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|gid
operator|=
name|mcbus_get_gid
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sysbase
operator|=
name|MCBUS_IOSPACE
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|gid
operator|)
operator|<<
name|MCBUS_GID_SHIFT
operator|)
operator||
expr|\
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|mid
operator|)
operator|<<
name|MCBUS_MID_SHIFT
operator|)
expr_stmt|;
name|regs
operator|=
operator|(
name|vm_offset_t
operator|)
name|KV
argument_list|(
name|sc
operator|->
name|sysbase
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dmem_base
operator|=
name|regs
operator|+
name|MCPCIA_PCI_DENSE
expr_stmt|;
name|sc
operator|->
name|smem_base
operator|=
name|regs
operator|+
name|MCPCIA_PCI_SPARSE
expr_stmt|;
name|sc
operator|->
name|io_base
operator|=
name|regs
operator|+
name|MCPCIA_PCI_IOSPACE
expr_stmt|;
name|swiz_init_space
argument_list|(
operator|&
name|sc
operator|->
name|io_space
argument_list|,
name|sc
operator|->
name|io_base
argument_list|)
expr_stmt|;
name|swiz_init_space
argument_list|(
operator|&
name|sc
operator|->
name|mem_space
argument_list|,
name|sc
operator|->
name|smem_base
argument_list|)
expr_stmt|;
name|sc
operator|->
name|io_rman
operator|.
name|rm_start
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|io_rman
operator|.
name|rm_end
operator|=
operator|~
literal|0u
expr_stmt|;
name|sc
operator|->
name|io_rman
operator|.
name|rm_type
operator|=
name|RMAN_ARRAY
expr_stmt|;
name|sc
operator|->
name|io_rman
operator|.
name|rm_descr
operator|=
literal|"I/O ports"
expr_stmt|;
if|if
condition|(
name|rman_init
argument_list|(
operator|&
name|sc
operator|->
name|io_rman
argument_list|)
operator|||
name|rman_manage_region
argument_list|(
operator|&
name|sc
operator|->
name|io_rman
argument_list|,
literal|0x0
argument_list|,
operator|(
literal|1L
operator|<<
literal|32
operator|)
argument_list|)
condition|)
name|panic
argument_list|(
literal|"mcpcia_attach: io_rman"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mem_rman
operator|.
name|rm_start
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|mem_rman
operator|.
name|rm_end
operator|=
operator|~
literal|0u
expr_stmt|;
name|sc
operator|->
name|mem_rman
operator|.
name|rm_type
operator|=
name|RMAN_ARRAY
expr_stmt|;
name|sc
operator|->
name|mem_rman
operator|.
name|rm_descr
operator|=
literal|"I/O memory"
expr_stmt|;
if|if
condition|(
name|rman_init
argument_list|(
operator|&
name|sc
operator|->
name|mem_rman
argument_list|)
operator|||
name|rman_manage_region
argument_list|(
operator|&
name|sc
operator|->
name|mem_rman
argument_list|,
literal|0x0
argument_list|,
operator|(
literal|1L
operator|<<
literal|32
operator|)
argument_list|)
condition|)
name|panic
argument_list|(
literal|"mcpcia_attach: mem_rman"
argument_list|)
expr_stmt|;
comment|/*  	 * Disable interrupts and clear errors prior to probing 	 */
name|REGVAL
argument_list|(
name|MCPCIA_INT_MASK0
argument_list|(
name|sc
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|REGVAL
argument_list|(
name|MCPCIA_INT_MASK1
argument_list|(
name|sc
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|REGVAL
argument_list|(
name|MCPCIA_CAP_ERR
argument_list|(
name|sc
argument_list|)
argument_list|)
operator|=
literal|0xFFFFFFFF
expr_stmt|;
name|alpha_mb
argument_list|()
expr_stmt|;
comment|/* 	 * Say who we are 	 */
name|ctl
operator|=
name|REGVAL
argument_list|(
name|MCPCIA_PCI_REV
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: Horse Revision %d, %s Handed Saddle Revision %d,"
literal|" CAP Revision %d\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|HORSE_REV
argument_list|(
name|ctl
argument_list|)
argument_list|,
operator|(
name|SADDLE_TYPE
argument_list|(
name|ctl
argument_list|)
operator|&
literal|1
operator|)
condition|?
literal|"Right"
else|:
literal|"Left"
argument_list|,
name|SADDLE_REV
argument_list|(
name|ctl
argument_list|)
argument_list|,
name|CAP_REV
argument_list|(
name|ctl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * See if we're the fella with the EISA bus... 	 */
if|if
condition|(
name|EISA_PRESENT
argument_list|(
name|REGVAL
argument_list|(
name|MCPCIA_PCI_REV
argument_list|(
name|sc
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|mcpcia_eisa
operator|=
name|sc
expr_stmt|;
block|}
comment|/* 	 * Set up DMA stuff here. 	 */
name|mcpcia_dma_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Register our interrupt service requirements with out parent. 	 */
name|rval
operator|=
name|BUS_SETUP_INTR
argument_list|(
name|p
argument_list|,
name|dev
argument_list|,
name|NULL
argument_list|,
name|INTR_TYPE_MISC
argument_list|,
name|mcpcia_intr
argument_list|,
literal|0
argument_list|,
operator|&
name|intr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sc
operator|==
name|mcpcia_eisa
condition|)
block|{
name|busspace_isa_io
operator|=
operator|(
expr|struct
name|alpha_busspace
operator|*
operator|)
operator|&
name|sc
operator|->
name|io_space
expr_stmt|;
name|busspace_isa_mem
operator|=
operator|(
expr|struct
name|alpha_busspace
operator|*
operator|)
operator|&
name|sc
operator|->
name|mem_space
expr_stmt|;
name|printf
argument_list|(
literal|"Attaching Real Console\n"
argument_list|)
expr_stmt|;
name|mcpcia_enable_intr
argument_list|(
name|sc
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|dec_kn300_cons_init
argument_list|()
expr_stmt|;
comment|/* 			 * Enable EISA interrupts. 			 */
name|mcpcia_enable_intr
argument_list|(
name|sc
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
name|bus_generic_attach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mcpcia_enable_intr
parameter_list|(
name|struct
name|mcpcia_softc
modifier|*
name|sc
parameter_list|,
name|int
name|irq
parameter_list|)
block|{
name|REGVAL
argument_list|(
name|MCPCIA_INT_MASK0
argument_list|(
name|sc
argument_list|)
argument_list|)
operator||=
operator|(
literal|1
operator|<<
name|irq
operator|)
expr_stmt|;
name|alpha_mb
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mcpcia_disable_intr
parameter_list|(
name|struct
name|mcpcia_softc
modifier|*
name|sc
parameter_list|,
name|int
name|irq
parameter_list|)
block|{
comment|/* 	 * We need to write to INT_REQ as well as INT_MASK0 in case we 	 * are trying to mask an interrupt which is already 	 * asserted. Writing a 1 bit to INT_REQ clears the 	 * corresponding bit in the register. 	 */
name|REGVAL
argument_list|(
name|MCPCIA_INT_MASK0
argument_list|(
name|sc
argument_list|)
argument_list|)
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|irq
operator|)
expr_stmt|;
name|REGVAL
argument_list|(
name|MCPCIA_INT_REQ
argument_list|(
name|sc
argument_list|)
argument_list|)
operator|=
operator|(
literal|1
operator|<<
name|irq
operator|)
expr_stmt|;
name|alpha_mb
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mcpcia_disable_intr_vec
parameter_list|(
name|int
name|vector
parameter_list|)
block|{
name|int
name|mid
decl_stmt|,
name|irq
decl_stmt|;
name|struct
name|mcpcia_softc
modifier|*
name|sc
init|=
name|mcpcia_root
decl_stmt|;
if|if
condition|(
name|vector
operator|<
name|MCPCIA_VEC_PCI
condition|)
block|{
name|printf
argument_list|(
literal|"EISA disable (0x%x)\n"
argument_list|,
name|vector
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|vector
operator|==
name|MCPCIA_VEC_NCR
condition|)
block|{
name|mid
operator|=
literal|5
expr_stmt|;
name|irq
operator|=
literal|16
expr_stmt|;
block|}
else|else
block|{
name|int
name|tmp
decl_stmt|,
name|slot
decl_stmt|;
name|tmp
operator|=
name|vector
operator|-
name|MCPCIA_VEC_PCI
expr_stmt|;
name|mid
operator|=
operator|(
name|tmp
operator|/
name|MCPCIA_VECWIDTH_PER_MCPCIA
operator|)
operator|+
literal|4
expr_stmt|;
name|tmp
operator|&=
operator|(
name|MCPCIA_VECWIDTH_PER_MCPCIA
operator|-
literal|1
operator|)
expr_stmt|;
name|slot
operator|=
name|tmp
operator|/
name|MCPCIA_VECWIDTH_PER_SLOT
expr_stmt|;
if|if
condition|(
name|slot
operator|<
literal|2
operator|||
name|slot
operator|>
literal|5
condition|)
block|{
name|printf
argument_list|(
literal|"Bad slot (%d) for vector %x\n"
argument_list|,
name|slot
argument_list|,
name|vector
argument_list|)
expr_stmt|;
return|return;
block|}
name|tmp
operator|-=
operator|(
literal|2
operator|*
name|MCPCIA_VECWIDTH_PER_SLOT
operator|)
expr_stmt|;
name|irq
operator|=
operator|(
name|tmp
operator|>>
name|MCPCIA_VECWIDTH_PER_INTPIN
operator|)
operator|&
literal|0xf
expr_stmt|;
block|}
comment|/*	printf("D<%03x>=%d,%d\n", vector, mid, irq); */
while|while
condition|(
name|sc
condition|)
block|{
if|if
condition|(
name|mcbus_get_mid
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
operator|==
name|mid
condition|)
block|{
break|break;
block|}
name|sc
operator|=
name|sc
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"couldn't find MCPCIA softc for vector 0x%x"
argument_list|,
name|vector
argument_list|)
expr_stmt|;
block|}
name|mcpcia_disable_intr
argument_list|(
name|sc
argument_list|,
name|irq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mcpcia_enable_intr_vec
parameter_list|(
name|int
name|vector
parameter_list|)
block|{
name|int
name|mid
decl_stmt|,
name|irq
decl_stmt|;
name|struct
name|mcpcia_softc
modifier|*
name|sc
init|=
name|mcpcia_root
decl_stmt|;
if|if
condition|(
name|vector
operator|<
name|MCPCIA_VEC_PCI
condition|)
block|{
name|printf
argument_list|(
literal|"EISA ensable (0x%x)\n"
argument_list|,
name|vector
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|vector
operator|==
name|MCPCIA_VEC_NCR
condition|)
block|{
name|mid
operator|=
literal|5
expr_stmt|;
name|irq
operator|=
literal|16
expr_stmt|;
block|}
else|else
block|{
name|int
name|tmp
decl_stmt|,
name|slot
decl_stmt|;
name|tmp
operator|=
name|vector
operator|-
name|MCPCIA_VEC_PCI
expr_stmt|;
name|mid
operator|=
operator|(
name|tmp
operator|/
name|MCPCIA_VECWIDTH_PER_MCPCIA
operator|)
operator|+
literal|4
expr_stmt|;
name|tmp
operator|&=
operator|(
name|MCPCIA_VECWIDTH_PER_MCPCIA
operator|-
literal|1
operator|)
expr_stmt|;
name|slot
operator|=
name|tmp
operator|/
name|MCPCIA_VECWIDTH_PER_SLOT
expr_stmt|;
if|if
condition|(
name|slot
operator|<
literal|2
operator|||
name|slot
operator|>
literal|5
condition|)
block|{
name|printf
argument_list|(
literal|"Bad slot (%d) for vector %x\n"
argument_list|,
name|slot
argument_list|,
name|vector
argument_list|)
expr_stmt|;
return|return;
block|}
name|tmp
operator|-=
operator|(
literal|2
operator|*
name|MCPCIA_VECWIDTH_PER_SLOT
operator|)
expr_stmt|;
name|irq
operator|=
operator|(
name|tmp
operator|>>
name|MCPCIA_VECWIDTH_PER_INTPIN
operator|)
operator|&
literal|0xf
expr_stmt|;
block|}
comment|/*	printf("E<%03x>=%d,%d\n", vector, mid, irq); */
while|while
condition|(
name|sc
condition|)
block|{
if|if
condition|(
name|mcbus_get_mid
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
operator|==
name|mid
condition|)
block|{
break|break;
block|}
name|sc
operator|=
name|sc
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"couldn't find MCPCIA softc for vector 0x%x"
argument_list|,
name|vector
argument_list|)
expr_stmt|;
block|}
name|mcpcia_enable_intr
argument_list|(
name|sc
argument_list|,
name|irq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mcpcia_setup_intr
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|struct
name|resource
modifier|*
name|ir
parameter_list|,
name|int
name|flags
parameter_list|,
name|driver_intr_t
modifier|*
name|intr
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|void
modifier|*
modifier|*
name|cp
parameter_list|)
block|{
name|struct
name|mcpcia_softc
modifier|*
name|sc
init|=
name|MCPCIA_SOFTC
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|slot
decl_stmt|,
name|mid
decl_stmt|,
name|gid
decl_stmt|,
name|birq
decl_stmt|,
name|irq
decl_stmt|,
name|error
decl_stmt|,
name|intpin
decl_stmt|,
name|h
decl_stmt|;
name|intpin
operator|=
name|pci_get_intpin
argument_list|(
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|intpin
operator|==
literal|0
condition|)
block|{
comment|/* No IRQ used */
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|intpin
operator|<
literal|1
operator|||
name|intpin
operator|>
literal|4
condition|)
block|{
comment|/* Bad IRQ */
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|slot
operator|=
name|pci_get_slot
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|mid
operator|=
name|mcbus_get_mid
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|gid
operator|=
name|mcbus_get_gid
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|slot
operator|==
literal|0
condition|)
block|{
name|device_t
name|bdev
decl_stmt|;
comment|/* bridged - get slot from grandparent */
comment|/* note that this is broken for all but the most trival case */
name|bdev
operator|=
name|device_get_parent
argument_list|(
name|device_get_parent
argument_list|(
name|child
argument_list|)
argument_list|)
expr_stmt|;
name|slot
operator|=
name|pci_get_slot
argument_list|(
name|bdev
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mid
operator|==
literal|5
operator|&&
name|slot
operator|==
literal|1
condition|)
block|{
name|irq
operator|=
literal|16
expr_stmt|;
comment|/* MID 5, slot 1, is the internal NCR 53c810 */
block|}
elseif|else
if|if
condition|(
name|slot
operator|>=
literal|2
operator|&&
name|slot
operator|<=
literal|5
condition|)
block|{
name|irq
operator|=
operator|(
operator|(
name|slot
operator|-
literal|2
operator|)
operator|*
literal|4
operator|)
operator|+
operator|(
name|intpin
operator|-
literal|1
operator|)
expr_stmt|;
block|}
else|else
block|{
name|device_printf
argument_list|(
name|child
argument_list|,
literal|"weird slot number (%d); can't make irq\n"
argument_list|,
name|slot
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|error
operator|=
name|rman_activate_resource
argument_list|(
name|ir
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
comment|/* 	 * We now construct a vector as the hardware would, unless 	 * this is the internal NCR 53c810 interrupt. 	 */
if|if
condition|(
name|irq
operator|==
literal|16
condition|)
block|{
name|h
operator|=
name|MCPCIA_VEC_NCR
expr_stmt|;
block|}
else|else
block|{
name|h
operator|=
name|MCPCIA_VEC_PCI
operator|+
operator|(
operator|(
name|mid
operator|-
name|MCPCIA_PCI_MIDMIN
operator|)
operator|*
name|MCPCIA_VECWIDTH_PER_MCPCIA
operator|)
operator|+
operator|(
name|slot
operator|*
name|MCPCIA_VECWIDTH_PER_SLOT
operator|)
operator|+
operator|(
operator|(
name|intpin
operator|-
literal|1
operator|)
operator|*
name|MCPCIA_VECWIDTH_PER_INTPIN
operator|)
expr_stmt|;
block|}
name|birq
operator|=
name|irq
operator|+
name|INTRCNT_KN300_IRQ
expr_stmt|;
name|error
operator|=
name|alpha_setup_intr
argument_list|(
name|device_get_nameunit
argument_list|(
name|child
argument_list|)
argument_list|,
name|h
argument_list|,
name|intr
argument_list|,
name|arg
argument_list|,
name|flags
argument_list|,
name|cp
argument_list|,
operator|&
name|intrcnt
index|[
name|birq
index|]
argument_list|,
name|mcpcia_disable_intr_vec
argument_list|,
name|mcpcia_enable_intr_vec
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|mcpcia_enable_intr
argument_list|(
name|sc
argument_list|,
name|irq
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|child
argument_list|,
literal|"interrupting at IRQ 0x%x int%c (vec 0x%x)\n"
argument_list|,
name|irq
argument_list|,
name|intpin
operator|-
literal|1
operator|+
literal|'A'
argument_list|,
name|h
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mcpcia_teardown_intr
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|struct
name|resource
modifier|*
name|i
parameter_list|,
name|void
modifier|*
name|c
parameter_list|)
block|{
name|struct
name|mcpcia_softc
modifier|*
name|sc
init|=
name|MCPCIA_SOFTC
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|slot
decl_stmt|,
name|mid
decl_stmt|,
name|intpin
decl_stmt|,
name|irq
decl_stmt|;
name|intpin
operator|=
name|pci_get_intpin
argument_list|(
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|intpin
operator|==
literal|0
condition|)
block|{
comment|/* No IRQ used */
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|intpin
operator|<
literal|1
operator|||
name|intpin
operator|>
literal|4
condition|)
block|{
comment|/* Bad IRQ */
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|slot
operator|=
name|pci_get_slot
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|mid
operator|=
name|mcbus_get_mid
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|mid
operator|==
literal|5
operator|&&
name|slot
operator|==
literal|1
condition|)
block|{
name|irq
operator|=
literal|16
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|slot
operator|>=
literal|2
operator|&&
name|slot
operator|<=
literal|5
condition|)
block|{
name|irq
operator|=
operator|(
operator|(
name|slot
operator|-
literal|2
operator|)
operator|<<
literal|4
operator|)
operator|+
operator|(
name|intpin
operator|-
literal|1
operator|)
expr_stmt|;
block|}
else|else
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|mcpcia_disable_intr
argument_list|(
name|sc
argument_list|,
name|irq
argument_list|)
expr_stmt|;
name|alpha_teardown_intr
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
operator|(
name|rman_deactivate_resource
argument_list|(
name|i
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mcpcia_read_ivar
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|which
parameter_list|,
name|u_long
modifier|*
name|result
parameter_list|)
block|{
switch|switch
condition|(
name|which
condition|)
block|{
case|case
name|PCIB_IVAR_BUS
case|:
operator|*
name|result
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|ENOENT
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|mcpcia_cvt_dense
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|vm_offset_t
name|addr
parameter_list|)
block|{
name|struct
name|mcpcia_softc
modifier|*
name|sc
init|=
name|MCPCIA_SOFTC
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|addr
operator|&=
literal|0xffffffffUL
expr_stmt|;
return|return
operator|(
name|void
operator|*
operator|)
name|KV
argument_list|(
name|addr
operator||
name|sc
operator|->
name|dmem_base
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|alpha_busspace
modifier|*
name|mcpcia_get_bustag
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|struct
name|mcpcia_softc
modifier|*
name|sc
init|=
name|MCPCIA_SOFTC
argument_list|(
name|dev
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SYS_RES_IOPORT
case|:
return|return
operator|(
expr|struct
name|alpha_busspace
operator|*
operator|)
operator|&
name|sc
operator|->
name|io_space
return|;
case|case
name|SYS_RES_MEMORY
case|:
return|return
operator|(
expr|struct
name|alpha_busspace
operator|*
operator|)
operator|&
name|sc
operator|->
name|mem_space
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|rman
modifier|*
name|mcpcia_get_rman
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|struct
name|mcpcia_softc
modifier|*
name|sc
init|=
name|MCPCIA_SOFTC
argument_list|(
name|dev
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SYS_RES_IOPORT
case|:
return|return
operator|&
name|sc
operator|->
name|io_rman
return|;
case|case
name|SYS_RES_MEMORY
case|:
return|return
operator|&
name|sc
operator|->
name|mem_rman
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mcpcia_maxslots
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
return|return
operator|(
name|MCPCIA_MAXDEV
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int32_t
name|mcpcia_read_config
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|bus
parameter_list|,
name|int
name|slot
parameter_list|,
name|int
name|func
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|sz
parameter_list|)
block|{
name|struct
name|mcpcia_softc
modifier|*
name|sc
init|=
name|MCPCIA_SOFTC
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u_int32_t
modifier|*
name|dp
decl_stmt|,
name|data
decl_stmt|,
name|rvp
decl_stmt|;
name|u_int64_t
name|paddr
decl_stmt|;
name|rvp
operator|=
name|data
operator|=
operator|~
literal|0
expr_stmt|;
comment|/* 	 * There's nothing in slot 0 on a primary bus. 	 */
if|if
condition|(
name|bus
operator|==
literal|0
operator|&&
operator|(
name|slot
operator|<
literal|1
operator|||
name|slot
operator|>=
name|MCPCIA_MAXDEV
operator|)
condition|)
return|return
operator|(
name|data
operator|)
return|;
name|paddr
operator|=
name|bus
operator|<<
literal|21
expr_stmt|;
name|paddr
operator||=
name|slot
operator|<<
literal|16
expr_stmt|;
name|paddr
operator||=
name|func
operator|<<
literal|13
expr_stmt|;
name|paddr
operator||=
operator|(
operator|(
name|sz
operator|-
literal|1
operator|)
operator|<<
literal|3
operator|)
expr_stmt|;
name|paddr
operator||=
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
operator|(
name|off
operator|>>
literal|2
operator|)
operator|<<
literal|7
argument_list|)
operator|)
expr_stmt|;
name|paddr
operator||=
name|MCPCIA_PCI_CONF
expr_stmt|;
name|paddr
operator||=
name|sc
operator|->
name|sysbase
expr_stmt|;
name|dp
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
name|KV
argument_list|(
name|paddr
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|printf("CFGREAD MID %d %d.%d.%d sz %d off %d -> paddr 0x%x", mcbus_get_mid(dev), bus , slot, func, sz, off, paddr);
endif|#
directive|endif
if|if
condition|(
name|badaddr
argument_list|(
name|dp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dp
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|data
operator|=
operator|*
name|dp
expr_stmt|;
block|}
if|if
condition|(
name|data
operator|!=
operator|~
literal|0
condition|)
block|{
if|if
condition|(
name|sz
operator|==
literal|1
condition|)
block|{
name|rvp
operator|=
name|SPARSE_BYTE_EXTRACT
argument_list|(
name|off
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sz
operator|==
literal|2
condition|)
block|{
name|rvp
operator|=
name|SPARSE_WORD_EXTRACT
argument_list|(
name|off
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rvp
operator|=
name|data
expr_stmt|;
block|}
block|}
else|else
block|{
name|rvp
operator|=
name|data
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|printf(" data 0x%x -> 0x%x\n", data, rvp);
endif|#
directive|endif
return|return
operator|(
name|rvp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mcpcia_write_config
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|bus
parameter_list|,
name|int
name|slot
parameter_list|,
name|int
name|func
parameter_list|,
name|int
name|off
parameter_list|,
name|u_int32_t
name|data
parameter_list|,
name|int
name|sz
parameter_list|)
block|{
name|struct
name|mcpcia_softc
modifier|*
name|sc
init|=
name|MCPCIA_SOFTC
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u_int32_t
modifier|*
name|dp
decl_stmt|;
name|u_int64_t
name|paddr
decl_stmt|;
comment|/* 	 * There's nothing in slot 0 on a primary bus. 	 */
if|if
condition|(
name|bus
operator|!=
literal|0
operator|&&
operator|(
name|slot
operator|<
literal|1
operator|||
name|slot
operator|>=
name|MCPCIA_MAXDEV
operator|)
condition|)
return|return;
name|paddr
operator|=
name|bus
operator|<<
literal|21
expr_stmt|;
name|paddr
operator||=
name|slot
operator|<<
literal|16
expr_stmt|;
name|paddr
operator||=
name|func
operator|<<
literal|13
expr_stmt|;
name|paddr
operator||=
operator|(
operator|(
name|sz
operator|-
literal|1
operator|)
operator|<<
literal|3
operator|)
expr_stmt|;
name|paddr
operator||=
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
operator|(
name|off
operator|>>
literal|2
operator|)
operator|<<
literal|7
argument_list|)
operator|)
expr_stmt|;
name|paddr
operator||=
name|MCPCIA_PCI_CONF
expr_stmt|;
name|paddr
operator||=
name|sc
operator|->
name|sysbase
expr_stmt|;
name|dp
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
name|KV
argument_list|(
name|paddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|badaddr
argument_list|(
name|dp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dp
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|u_int32_t
name|new_data
decl_stmt|;
if|if
condition|(
name|sz
operator|==
literal|1
condition|)
block|{
name|new_data
operator|=
name|SPARSE_BYTE_INSERT
argument_list|(
name|off
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sz
operator|==
literal|2
condition|)
block|{
name|new_data
operator|=
name|SPARSE_WORD_INSERT
argument_list|(
name|off
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|new_data
operator|=
name|data
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|printf("CFGWRITE MID%d %d.%d.%d sz %d off %d paddr %lx, data %x new_data %x\n", mcbus_get_mid(dev), bus , slot, func, sz, off, paddr, data, new_data);
endif|#
directive|endif
operator|*
name|dp
operator|=
name|new_data
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mcpcia_sgmap_map
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_addr_t
name|ba
parameter_list|,
name|vm_offset_t
name|pa
parameter_list|)
block|{
name|u_int64_t
modifier|*
name|sgtable
init|=
name|arg
decl_stmt|;
name|int
name|index
init|=
name|alpha_btop
argument_list|(
name|ba
operator|-
name|MCPCIA_ISA_SG_MAPPED_BASE
argument_list|)
decl_stmt|;
if|if
condition|(
name|pa
condition|)
block|{
if|if
condition|(
name|pa
operator|>
operator|(
literal|1L
operator|<<
literal|32
operator|)
condition|)
name|panic
argument_list|(
literal|"mcpcia_sgmap_map: can't map address 0x%lx"
argument_list|,
name|pa
argument_list|)
expr_stmt|;
name|sgtable
index|[
name|index
index|]
operator|=
operator|(
operator|(
name|pa
operator|>>
literal|13
operator|)
operator|<<
literal|1
operator|)
operator||
literal|1
expr_stmt|;
block|}
else|else
block|{
name|sgtable
index|[
name|index
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|alpha_mb
argument_list|()
expr_stmt|;
name|MCPCIA_SGTLB_INVALIDATE
argument_list|(
name|mcpcia_eisa
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mcpcia_dma_init
parameter_list|(
name|struct
name|mcpcia_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* 	 * Disable all windows first. 	 */
name|REGVAL
argument_list|(
name|MCPCIA_W0_BASE
argument_list|(
name|sc
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|REGVAL
argument_list|(
name|MCPCIA_W1_BASE
argument_list|(
name|sc
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|REGVAL
argument_list|(
name|MCPCIA_W2_BASE
argument_list|(
name|sc
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|REGVAL
argument_list|(
name|MCPCIA_W3_BASE
argument_list|(
name|sc
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|REGVAL
argument_list|(
name|MCPCIA_T0_BASE
argument_list|(
name|sc
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|REGVAL
argument_list|(
name|MCPCIA_T1_BASE
argument_list|(
name|sc
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|REGVAL
argument_list|(
name|MCPCIA_T2_BASE
argument_list|(
name|sc
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|REGVAL
argument_list|(
name|MCPCIA_T3_BASE
argument_list|(
name|sc
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|alpha_mb
argument_list|()
expr_stmt|;
comment|/* 	 * Set up window 0 as an 8MB SGMAP-mapped window starting at 8MB. 	 * Do this only for the EISA carrying MCPCIA. Partly because 	 * there's only one chipset sgmap thingie. 	 */
if|if
condition|(
name|sc
operator|==
name|mcpcia_eisa
condition|)
block|{
name|void
modifier|*
name|sgtable
decl_stmt|;
name|REGVAL
argument_list|(
name|MCPCIA_W0_MASK
argument_list|(
name|sc
argument_list|)
argument_list|)
operator|=
name|MCPCIA_WMASK_8M
expr_stmt|;
name|sgtable
operator|=
name|contigmalloc
argument_list|(
literal|8192
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|,
literal|0
argument_list|,
literal|1L
operator|<<
literal|34
argument_list|,
literal|32
operator|<<
literal|10
argument_list|,
literal|1L
operator|<<
literal|34
argument_list|)
expr_stmt|;
if|if
condition|(
name|sgtable
operator|==
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"mcpcia_dma_init: cannot allocate sgmap"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|REGVAL
argument_list|(
name|MCPCIA_T0_BASE
argument_list|(
name|sc
argument_list|)
argument_list|)
operator|=
name|pmap_kextract
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|sgtable
argument_list|)
operator|>>
name|MCPCIA_TBASEX_SHIFT
expr_stmt|;
name|alpha_mb
argument_list|()
expr_stmt|;
name|REGVAL
argument_list|(
name|MCPCIA_W0_BASE
argument_list|(
name|sc
argument_list|)
argument_list|)
operator|=
name|MCPCIA_WBASE_EN
operator||
name|MCPCIA_WBASE_SG
operator||
name|MCPCIA_ISA_SG_MAPPED_BASE
expr_stmt|;
name|alpha_mb
argument_list|()
expr_stmt|;
name|MCPCIA_SGTLB_INVALIDATE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|chipset
operator|.
name|sgmap
operator|=
name|sgmap_map_create
argument_list|(
name|MCPCIA_ISA_SG_MAPPED_BASE
argument_list|,
name|MCPCIA_ISA_SG_MAPPED_BASE
operator|+
name|MCPCIA_ISA_SG_MAPPED_SIZE
operator|-
literal|1
argument_list|,
name|mcpcia_sgmap_map
argument_list|,
name|sgtable
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Set up window 1 as a 2 GB Direct-mapped window starting at 2GB. 	 */
name|REGVAL
argument_list|(
name|MCPCIA_W1_MASK
argument_list|(
name|sc
argument_list|)
argument_list|)
operator|=
name|MCPCIA_WMASK_2G
expr_stmt|;
name|REGVAL
argument_list|(
name|MCPCIA_T1_BASE
argument_list|(
name|sc
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|alpha_mb
argument_list|()
expr_stmt|;
name|REGVAL
argument_list|(
name|MCPCIA_W1_BASE
argument_list|(
name|sc
argument_list|)
argument_list|)
operator|=
name|MCPCIA_DIRECT_MAPPED_BASE
operator||
name|MCPCIA_WBASE_EN
expr_stmt|;
name|alpha_mb
argument_list|()
expr_stmt|;
comment|/* 	 * When we get around to redoing the 'chipset' stuff to have more 	 * than one sgmap handler... 	 */
if|#
directive|if
literal|0
comment|/* 	 * Set up window 2 as a 1G SGMAP-mapped window starting at 1G. 	 */
block|REGVAL(MCPCIA_W2_MASK(sc)) = MCPCIA_WMASK_1G; 	REGVAL(MCPCIA_T2_BASE(sc)) = 		ccp->cc_pci_sgmap.aps_ptpa>> MCPCIA_TBASEX_SHIFT; 	alpha_mb(); 	REGVAL(MCPCIA_W2_BASE(sc)) = 		MCPCIA_WBASE_EN | MCPCIA_WBASE_SG | MCPCIA_PCI_SG_MAPPED_BASE; 	alpha_mb();
endif|#
directive|endif
comment|/* XXX XXX BEGIN XXX XXX */
block|{
comment|/* XXX */
name|alpha_XXX_dmamap_or
operator|=
name|MCPCIA_DIRECT_MAPPED_BASE
expr_stmt|;
comment|/* XXX */
block|}
comment|/* XXX */
comment|/* XXX XXX END XXX XXX */
block|}
end_function

begin_comment
comment|/*  */
end_comment

begin_function
specifier|static
name|void
name|mcpcia_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|unsigned
name|long
name|vec
init|=
operator|(
name|unsigned
name|long
operator|)
name|arg
decl_stmt|;
comment|/* 	 * Check for I2C interrupts.  These are technically within 	 * the PCI vector range, but no PCI device should ever map 	 * to them. 	 */
if|if
condition|(
name|vec
operator|==
name|MCPCIA_I2C_CVEC
condition|)
block|{
name|printf
argument_list|(
literal|"i2c: controller interrupt\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|vec
operator|==
name|MCPCIA_I2C_BVEC
condition|)
block|{
name|printf
argument_list|(
literal|"i2c: bus interrupt\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|alpha_dispatch_intr
argument_list|(
name|NULL
argument_list|,
name|vec
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|mcpcia_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|mcpcia_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|mcpcia_attach
argument_list|)
block|,
comment|/* Bus interface */
name|DEVMETHOD
argument_list|(
name|bus_print_child
argument_list|,
name|bus_generic_print_child
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_read_ivar
argument_list|,
name|mcpcia_read_ivar
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_setup_intr
argument_list|,
name|mcpcia_setup_intr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_teardown_intr
argument_list|,
name|mcpcia_teardown_intr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_alloc_resource
argument_list|,
name|pci_alloc_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_release_resource
argument_list|,
name|pci_release_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_activate_resource
argument_list|,
name|pci_activate_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_deactivate_resource
argument_list|,
name|pci_deactivate_resource
argument_list|)
block|,
comment|/* alphapci interface */
name|DEVMETHOD
argument_list|(
name|alphapci_cvt_dense
argument_list|,
name|mcpcia_cvt_dense
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|alphapci_get_bustag
argument_list|,
name|mcpcia_get_bustag
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|alphapci_get_rman
argument_list|,
name|mcpcia_get_rman
argument_list|)
block|,
comment|/* pcib interface */
name|DEVMETHOD
argument_list|(
name|pcib_maxslots
argument_list|,
name|mcpcia_maxslots
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pcib_read_config
argument_list|,
name|mcpcia_read_config
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pcib_write_config
argument_list|,
name|mcpcia_write_config
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pcib_route_interrupt
argument_list|,
name|alpha_pci_route_interrupt
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|mcpcia_driver
init|=
block|{
literal|"pcib"
block|,
name|mcpcia_methods
block|,
expr|sizeof
operator|(
expr|struct
name|mcpcia_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|pcib
argument_list|,
name|mcbus
argument_list|,
name|mcpcia_driver
argument_list|,
name|mcpcia_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

