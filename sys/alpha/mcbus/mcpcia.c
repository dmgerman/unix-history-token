begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/*  * Copyright (c) 2000 Matthew Jacob  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<machine/swiz.h>
end_include

begin_include
include|#
directive|include
file|<machine/intr.h>
end_include

begin_include
include|#
directive|include
file|<machine/intrcnt.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<machine/sgmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<alpha/mcbus/mcbusreg.h>
end_include

begin_include
include|#
directive|include
file|<alpha/mcbus/mcbusvar.h>
end_include

begin_include
include|#
directive|include
file|<alpha/mcbus/mcpciareg.h>
end_include

begin_include
include|#
directive|include
file|<alpha/mcbus/mcpciavar.h>
end_include

begin_include
include|#
directive|include
file|<alpha/pci/pcibus.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcivar.h>
end_include

begin_decl_stmt
specifier|static
name|devclass_t
name|mcpcia_devclass
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We're only allowing for one MCBUS right now */
end_comment

begin_decl_stmt
specifier|static
name|device_t
name|mcpcias
index|[
name|MCPCIA_PER_MCBUS
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|KV
parameter_list|(
name|pa
parameter_list|)
value|((void *)ALPHA_PHYS_TO_K0SEG(pa))
end_define

begin_struct
struct|struct
name|mcpcia_softc
block|{
name|struct
name|mcpcia_softc
modifier|*
name|next
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
comment|/* backpointer */
name|u_int64_t
name|sysbase
decl_stmt|;
comment|/* shorthand */
name|vm_offset_t
name|dmem_base
decl_stmt|;
comment|/* dense memory */
name|vm_offset_t
name|smem_base
decl_stmt|;
comment|/* sparse memory */
name|vm_offset_t
name|io_base
decl_stmt|;
comment|/* sparse i/o */
name|int
name|mcpcia_inst
decl_stmt|;
comment|/* our mcpcia instance # */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|mcpcia_softc
modifier|*
name|mcpcia_eisa
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|void
name|dec_kn300_cons_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mcpcia_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mcpcia_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mcpcia_setup_intr
parameter_list|(
name|device_t
parameter_list|,
name|device_t
parameter_list|,
name|struct
name|resource
modifier|*
parameter_list|,
name|int
parameter_list|,
name|driver_intr_t
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|void
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mcpcia_teardown_intr
parameter_list|(
name|device_t
parameter_list|,
name|device_t
parameter_list|,
name|struct
name|resource
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|driver_intr_t
name|mcpcia_intr
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|mcpcia_enable_intr
parameter_list|(
name|struct
name|mcpcia_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mcpcia_disable_intr
parameter_list|(
name|struct
name|mcpcia_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|mcpcia_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|mcpcia_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|mcpcia_attach
argument_list|)
block|,
comment|/* Bus interface */
name|DEVMETHOD
argument_list|(
name|bus_setup_intr
argument_list|,
name|mcpcia_setup_intr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_teardown_intr
argument_list|,
name|mcpcia_teardown_intr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_alloc_resource
argument_list|,
name|pci_alloc_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_release_resource
argument_list|,
name|pci_release_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_activate_resource
argument_list|,
name|pci_activate_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_deactivate_resource
argument_list|,
name|pci_deactivate_resource
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|mcpcia_driver
init|=
block|{
literal|"mcpcia"
block|,
name|mcpcia_methods
block|,
expr|sizeof
operator|(
expr|struct
name|mcpcia_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * SGMAP window for ISA: 8M at 8M  */
end_comment

begin_define
define|#
directive|define
name|MCPCIA_ISA_SG_MAPPED_BASE
value|(8*1024*1024)
end_define

begin_define
define|#
directive|define
name|MCPCIA_ISA_SG_MAPPED_SIZE
value|(8*1024*1024)
end_define

begin_comment
comment|/*  * Direct-mapped window: 2G at 2G  */
end_comment

begin_define
define|#
directive|define
name|MCPCIA_DIRECT_MAPPED_BASE
value|(2UL*1024UL*1024UL*1024UL)
end_define

begin_define
define|#
directive|define
name|MCPCIA_DIRECT_MAPPED_SIZE
value|(2UL*1024UL*1024UL*1024UL)
end_define

begin_comment
comment|/*  * SGMAP window for PCI: 1G at 1G  */
end_comment

begin_define
define|#
directive|define
name|MCPCIA_PCI_SG_MAPPED_BASE
value|(1UL*1024UL*1024UL*1024UL)
end_define

begin_define
define|#
directive|define
name|MCPCIA_PCI_SG_MAPPED_SIZE
value|(1UL*1024UL*1024UL*1024UL)
end_define

begin_define
define|#
directive|define
name|MCPCIA_SGTLB_INVALIDATE
parameter_list|(
name|sc
parameter_list|)
define|\
value|do {									\ 	alpha_mb();							\ 	REGVAL(MCPCIA_SG_TBIA(sc)) = 0xdeadbeef;			\ 	alpha_mb();							\ } while (0)
end_define

begin_function_decl
specifier|static
name|void
name|mcpcia_dma_init
parameter_list|(
name|struct
name|mcpcia_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mcpcia_sgmap_map
parameter_list|(
name|void
modifier|*
parameter_list|,
name|vm_offset_t
parameter_list|,
name|vm_offset_t
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|MCPCIA_SOFTC
parameter_list|(
name|dev
parameter_list|)
value|(struct mcpcia_softc *) device_get_softc(dev)
end_define

begin_decl_stmt
specifier|static
name|struct
name|mcpcia_softc
modifier|*
name|mcpcia_root
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|alpha_chipset_inb_t
name|mcpcia_inb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|alpha_chipset_inw_t
name|mcpcia_inw
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|alpha_chipset_inl_t
name|mcpcia_inl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|alpha_chipset_outb_t
name|mcpcia_outb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|alpha_chipset_outw_t
name|mcpcia_outw
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|alpha_chipset_outl_t
name|mcpcia_outl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|alpha_chipset_readb_t
name|mcpcia_readb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|alpha_chipset_readw_t
name|mcpcia_readw
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|alpha_chipset_readl_t
name|mcpcia_readl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|alpha_chipset_writeb_t
name|mcpcia_writeb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|alpha_chipset_writew_t
name|mcpcia_writew
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|alpha_chipset_writel_t
name|mcpcia_writel
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|alpha_chipset_maxdevs_t
name|mcpcia_maxdevs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|alpha_chipset_cfgreadb_t
name|mcpcia_cfgreadb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|alpha_chipset_cfgreadw_t
name|mcpcia_cfgreadw
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|alpha_chipset_cfgreadl_t
name|mcpcia_cfgreadl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|alpha_chipset_cfgwriteb_t
name|mcpcia_cfgwriteb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|alpha_chipset_cfgwritew_t
name|mcpcia_cfgwritew
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|alpha_chipset_cfgwritel_t
name|mcpcia_cfgwritel
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|alpha_chipset_t
name|mcpcia_chipset
init|=
block|{
name|mcpcia_inb
block|,
name|mcpcia_inw
block|,
name|mcpcia_inl
block|,
name|mcpcia_outb
block|,
name|mcpcia_outw
block|,
name|mcpcia_outl
block|,
name|mcpcia_readb
block|,
name|mcpcia_readw
block|,
name|mcpcia_readl
block|,
name|mcpcia_writeb
block|,
name|mcpcia_writew
block|,
name|mcpcia_writel
block|,
name|mcpcia_maxdevs
block|,
name|mcpcia_cfgreadb
block|,
name|mcpcia_cfgreadw
block|,
name|mcpcia_cfgreadl
block|,
name|mcpcia_cfgwriteb
block|,
name|mcpcia_cfgwritew
block|,
name|mcpcia_cfgwritel
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MCPCIA_NMBR
parameter_list|(
name|port
parameter_list|)
value|((port>> 30)& 0x3)
end_define

begin_define
define|#
directive|define
name|MCPCIA_INST
parameter_list|(
name|port
parameter_list|)
value|mcpcias[MCPCIA_NMBR(port)]
end_define

begin_define
define|#
directive|define
name|MCPCIA_ADDR
parameter_list|(
name|port
parameter_list|)
value|(port& 0x3fffffff)
end_define

begin_function
specifier|static
name|u_int8_t
name|mcpcia_inb
parameter_list|(
name|u_int32_t
name|port
parameter_list|)
block|{
name|struct
name|mcpcia_softc
modifier|*
name|sc
init|=
name|MCPCIA_SOFTC
argument_list|(
name|MCPCIA_INST
argument_list|(
name|port
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|port
operator|<
operator|(
literal|1
operator|<<
literal|16
operator|)
condition|)
block|{
if|if
condition|(
name|mcpcia_eisa
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
literal|0xff
operator|)
return|;
block|}
return|return
name|SPARSE_READ_BYTE
argument_list|(
name|mcpcia_eisa
operator|->
name|io_base
argument_list|,
name|port
argument_list|)
return|;
block|}
return|return
name|SPARSE_READ_BYTE
argument_list|(
name|sc
operator|->
name|io_base
argument_list|,
name|MCPCIA_ADDR
argument_list|(
name|port
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int16_t
name|mcpcia_inw
parameter_list|(
name|u_int32_t
name|port
parameter_list|)
block|{
name|struct
name|mcpcia_softc
modifier|*
name|sc
init|=
name|MCPCIA_SOFTC
argument_list|(
name|MCPCIA_INST
argument_list|(
name|port
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|port
operator|<
operator|(
literal|1
operator|<<
literal|16
operator|)
condition|)
block|{
if|if
condition|(
name|mcpcia_eisa
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
literal|0xffff
operator|)
return|;
block|}
return|return
name|SPARSE_READ_WORD
argument_list|(
name|mcpcia_eisa
operator|->
name|io_base
argument_list|,
name|port
argument_list|)
return|;
block|}
return|return
name|SPARSE_READ_WORD
argument_list|(
name|sc
operator|->
name|io_base
argument_list|,
name|MCPCIA_ADDR
argument_list|(
name|port
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int32_t
name|mcpcia_inl
parameter_list|(
name|u_int32_t
name|port
parameter_list|)
block|{
name|struct
name|mcpcia_softc
modifier|*
name|sc
init|=
name|MCPCIA_SOFTC
argument_list|(
name|MCPCIA_INST
argument_list|(
name|port
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|SPARSE_READ_LONG
argument_list|(
name|sc
operator|->
name|io_base
argument_list|,
name|MCPCIA_ADDR
argument_list|(
name|port
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mcpcia_outb
parameter_list|(
name|u_int32_t
name|port
parameter_list|,
name|u_int8_t
name|data
parameter_list|)
block|{
name|struct
name|mcpcia_softc
modifier|*
name|sc
init|=
name|MCPCIA_SOFTC
argument_list|(
name|MCPCIA_INST
argument_list|(
name|port
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|port
operator|<
operator|(
literal|1
operator|<<
literal|16
operator|)
condition|)
block|{
if|if
condition|(
name|mcpcia_eisa
condition|)
name|SPARSE_WRITE_BYTE
argument_list|(
name|mcpcia_eisa
operator|->
name|io_base
argument_list|,
name|port
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SPARSE_WRITE_BYTE
argument_list|(
name|sc
operator|->
name|io_base
argument_list|,
name|MCPCIA_ADDR
argument_list|(
name|port
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
name|alpha_mb
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mcpcia_outw
parameter_list|(
name|u_int32_t
name|port
parameter_list|,
name|u_int16_t
name|data
parameter_list|)
block|{
name|struct
name|mcpcia_softc
modifier|*
name|sc
init|=
name|MCPCIA_SOFTC
argument_list|(
name|MCPCIA_INST
argument_list|(
name|port
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|port
operator|<
operator|(
literal|1
operator|<<
literal|16
operator|)
condition|)
block|{
if|if
condition|(
name|mcpcia_eisa
condition|)
name|SPARSE_WRITE_WORD
argument_list|(
name|mcpcia_eisa
operator|->
name|io_base
argument_list|,
name|port
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SPARSE_WRITE_WORD
argument_list|(
name|sc
operator|->
name|io_base
argument_list|,
name|MCPCIA_ADDR
argument_list|(
name|port
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
name|alpha_mb
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mcpcia_outl
parameter_list|(
name|u_int32_t
name|port
parameter_list|,
name|u_int32_t
name|data
parameter_list|)
block|{
name|struct
name|mcpcia_softc
modifier|*
name|sc
init|=
name|MCPCIA_SOFTC
argument_list|(
name|MCPCIA_INST
argument_list|(
name|port
argument_list|)
argument_list|)
decl_stmt|;
name|SPARSE_WRITE_LONG
argument_list|(
name|sc
operator|->
name|io_base
argument_list|,
name|MCPCIA_ADDR
argument_list|(
name|port
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|alpha_mb
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u_int8_t
name|mcpcia_readb
parameter_list|(
name|u_int32_t
name|pa
parameter_list|)
block|{
name|struct
name|mcpcia_softc
modifier|*
name|sc
init|=
name|MCPCIA_SOFTC
argument_list|(
name|MCPCIA_INST
argument_list|(
name|pa
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|pa
operator|<
operator|(
literal|8
operator|<<
literal|20
operator|)
condition|)
block|{
if|if
condition|(
name|mcpcia_eisa
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
literal|0xff
operator|)
return|;
block|}
return|return
name|SPARSE_READ_BYTE
argument_list|(
name|mcpcia_eisa
operator|->
name|smem_base
argument_list|,
name|pa
argument_list|)
return|;
block|}
return|return
name|SPARSE_READ_BYTE
argument_list|(
name|sc
operator|->
name|smem_base
argument_list|,
name|MCPCIA_ADDR
argument_list|(
name|pa
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int16_t
name|mcpcia_readw
parameter_list|(
name|u_int32_t
name|pa
parameter_list|)
block|{
name|struct
name|mcpcia_softc
modifier|*
name|sc
init|=
name|MCPCIA_SOFTC
argument_list|(
name|MCPCIA_INST
argument_list|(
name|pa
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|pa
operator|<
operator|(
literal|8
operator|<<
literal|20
operator|)
condition|)
block|{
if|if
condition|(
name|mcpcia_eisa
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
literal|0xffff
operator|)
return|;
block|}
return|return
name|SPARSE_READ_WORD
argument_list|(
name|mcpcia_eisa
operator|->
name|smem_base
argument_list|,
name|pa
argument_list|)
return|;
block|}
return|return
name|SPARSE_READ_WORD
argument_list|(
name|sc
operator|->
name|smem_base
argument_list|,
name|MCPCIA_ADDR
argument_list|(
name|pa
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int32_t
name|mcpcia_readl
parameter_list|(
name|u_int32_t
name|pa
parameter_list|)
block|{
name|struct
name|mcpcia_softc
modifier|*
name|sc
init|=
name|MCPCIA_SOFTC
argument_list|(
name|MCPCIA_INST
argument_list|(
name|pa
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|SPARSE_READ_LONG
argument_list|(
name|sc
operator|->
name|smem_base
argument_list|,
name|MCPCIA_ADDR
argument_list|(
name|pa
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mcpcia_writeb
parameter_list|(
name|u_int32_t
name|pa
parameter_list|,
name|u_int8_t
name|data
parameter_list|)
block|{
name|struct
name|mcpcia_softc
modifier|*
name|sc
init|=
name|MCPCIA_SOFTC
argument_list|(
name|MCPCIA_INST
argument_list|(
name|pa
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|pa
operator|<
operator|(
literal|8
operator|<<
literal|20
operator|)
condition|)
block|{
if|if
condition|(
name|mcpcia_eisa
condition|)
name|SPARSE_WRITE_BYTE
argument_list|(
name|mcpcia_eisa
operator|->
name|smem_base
argument_list|,
name|pa
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SPARSE_WRITE_BYTE
argument_list|(
name|sc
operator|->
name|smem_base
argument_list|,
name|MCPCIA_ADDR
argument_list|(
name|pa
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
name|alpha_mb
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mcpcia_writew
parameter_list|(
name|u_int32_t
name|pa
parameter_list|,
name|u_int16_t
name|data
parameter_list|)
block|{
name|struct
name|mcpcia_softc
modifier|*
name|sc
init|=
name|MCPCIA_SOFTC
argument_list|(
name|MCPCIA_INST
argument_list|(
name|pa
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|pa
operator|<
operator|(
literal|8
operator|<<
literal|20
operator|)
condition|)
block|{
if|if
condition|(
name|mcpcia_eisa
condition|)
name|SPARSE_WRITE_WORD
argument_list|(
name|mcpcia_eisa
operator|->
name|smem_base
argument_list|,
name|pa
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SPARSE_WRITE_WORD
argument_list|(
name|sc
operator|->
name|smem_base
argument_list|,
name|MCPCIA_ADDR
argument_list|(
name|pa
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
name|alpha_mb
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mcpcia_writel
parameter_list|(
name|u_int32_t
name|pa
parameter_list|,
name|u_int32_t
name|data
parameter_list|)
block|{
name|struct
name|mcpcia_softc
modifier|*
name|sc
init|=
name|MCPCIA_SOFTC
argument_list|(
name|MCPCIA_INST
argument_list|(
name|pa
argument_list|)
argument_list|)
decl_stmt|;
name|SPARSE_WRITE_LONG
argument_list|(
name|sc
operator|->
name|smem_base
argument_list|,
name|MCPCIA_ADDR
argument_list|(
name|pa
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|alpha_mb
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mcpcia_maxdevs
parameter_list|(
name|u_int
name|b
parameter_list|)
block|{
return|return
operator|(
name|MCPCIA_MAXDEV
operator|)
return|;
block|}
end_function

begin_function_decl
specifier|static
name|u_int32_t
name|mcpcia_cfgread
parameter_list|(
name|u_int
parameter_list|,
name|u_int
parameter_list|,
name|u_int
parameter_list|,
name|u_int
parameter_list|,
name|u_int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mcpcia_cfgwrite
parameter_list|(
name|u_int
parameter_list|,
name|u_int
parameter_list|,
name|u_int
parameter_list|,
name|u_int
parameter_list|,
name|u_int
parameter_list|,
name|int
parameter_list|,
name|u_int32_t
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
literal|0
end_if

begin_define
define|#
directive|define
name|RCFGP
value|printf
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|RCFGP
value|if (0) printf
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|u_int32_t
name|mcpcia_cfgread
parameter_list|(
name|u_int
name|bh
parameter_list|,
name|u_int
name|bus
parameter_list|,
name|u_int
name|slot
parameter_list|,
name|u_int
name|func
parameter_list|,
name|u_int
name|off
parameter_list|,
name|int
name|sz
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|struct
name|mcpcia_softc
modifier|*
name|sc
decl_stmt|;
name|u_int32_t
modifier|*
name|dp
decl_stmt|,
name|data
decl_stmt|,
name|rvp
decl_stmt|;
name|u_int64_t
name|paddr
decl_stmt|;
name|RCFGP
argument_list|(
literal|"CFGREAD %u.%u.%u.%u.%u.%d"
argument_list|,
name|bh
argument_list|,
name|bus
argument_list|,
name|slot
argument_list|,
name|func
argument_list|,
name|off
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|rvp
operator|=
name|data
operator|=
operator|~
literal|0
expr_stmt|;
if|if
condition|(
name|bh
operator|==
operator|(
name|u_int8_t
operator|)
operator|-
literal|1
condition|)
name|bh
operator|=
name|bus
operator|>>
literal|4
expr_stmt|;
name|dev
operator|=
name|mcpcias
index|[
name|bh
index|]
expr_stmt|;
if|if
condition|(
name|dev
operator|==
operator|(
name|device_t
operator|)
literal|0
condition|)
block|{
name|RCFGP
argument_list|(
literal|" (no dev)\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|data
operator|)
return|;
block|}
name|sc
operator|=
name|MCPCIA_SOFTC
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|bus
operator|&=
literal|0xf
expr_stmt|;
comment|/* 	 * There's nothing in slot 0 on a primary bus. 	 */
if|if
condition|(
name|bus
operator|==
literal|0
operator|&&
operator|(
name|slot
operator|<
literal|1
operator|||
name|slot
operator|>=
name|MCPCIA_MAXDEV
operator|)
condition|)
block|{
name|RCFGP
argument_list|(
literal|" (no slot)\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|data
operator|)
return|;
block|}
name|paddr
operator|=
name|bus
operator|<<
literal|21
expr_stmt|;
name|paddr
operator||=
name|slot
operator|<<
literal|16
expr_stmt|;
name|paddr
operator||=
name|func
operator|<<
literal|13
expr_stmt|;
name|paddr
operator||=
operator|(
operator|(
name|sz
operator|-
literal|1
operator|)
operator|<<
literal|3
operator|)
expr_stmt|;
name|paddr
operator||=
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
operator|(
name|off
operator|>>
literal|2
operator|)
operator|<<
literal|7
argument_list|)
operator|)
expr_stmt|;
name|paddr
operator||=
name|MCPCIA_PCI_CONF
expr_stmt|;
name|paddr
operator||=
name|sc
operator|->
name|sysbase
expr_stmt|;
name|dp
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
name|KV
argument_list|(
name|paddr
argument_list|)
expr_stmt|;
name|RCFGP
argument_list|(
literal|" hose %d MID%d paddr 0x%lx"
argument_list|,
name|bh
argument_list|,
name|mcbus_get_mid
argument_list|(
name|dev
argument_list|)
argument_list|,
name|paddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|badaddr
argument_list|(
name|dp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dp
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|data
operator|=
operator|*
name|dp
expr_stmt|;
block|}
if|if
condition|(
name|data
operator|!=
operator|~
literal|0
condition|)
block|{
if|if
condition|(
name|sz
operator|==
literal|1
condition|)
block|{
name|rvp
operator|=
name|SPARSE_BYTE_EXTRACT
argument_list|(
name|off
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sz
operator|==
literal|2
condition|)
block|{
name|rvp
operator|=
name|SPARSE_WORD_EXTRACT
argument_list|(
name|off
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rvp
operator|=
name|data
expr_stmt|;
block|}
block|}
else|else
block|{
name|rvp
operator|=
name|data
expr_stmt|;
block|}
name|RCFGP
argument_list|(
literal|" data %x->0x%x\n"
argument_list|,
name|data
argument_list|,
name|rvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|rvp
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_define
define|#
directive|define
name|WCFGP
value|printf
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|WCFGP
value|if (0) printf
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|mcpcia_cfgwrite
parameter_list|(
name|u_int
name|bh
parameter_list|,
name|u_int
name|bus
parameter_list|,
name|u_int
name|slot
parameter_list|,
name|u_int
name|func
parameter_list|,
name|u_int
name|off
parameter_list|,
name|int
name|sz
parameter_list|,
name|u_int32_t
name|data
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|struct
name|mcpcia_softc
modifier|*
name|sc
decl_stmt|;
name|u_int32_t
modifier|*
name|dp
decl_stmt|;
name|u_int64_t
name|paddr
decl_stmt|;
name|WCFGP
argument_list|(
literal|"CFGWRITE %u.%u.%u.%u.%u.%d"
argument_list|,
name|bh
argument_list|,
name|bus
argument_list|,
name|slot
argument_list|,
name|func
argument_list|,
name|off
argument_list|,
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|bh
operator|==
operator|(
name|u_int8_t
operator|)
operator|-
literal|1
condition|)
name|bh
operator|=
name|bus
operator|>>
literal|4
expr_stmt|;
name|dev
operator|=
name|mcpcias
index|[
name|bh
index|]
expr_stmt|;
if|if
condition|(
name|dev
operator|==
operator|(
name|device_t
operator|)
literal|0
condition|)
block|{
name|WCFGP
argument_list|(
literal|" (no dev)\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|sc
operator|=
name|MCPCIA_SOFTC
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|bus
operator|&=
literal|0xf
expr_stmt|;
comment|/* 	 * There's nothing in slot 0 on a primary bus. 	 */
if|if
condition|(
name|bus
operator|==
literal|0
operator|&&
operator|(
name|slot
operator|<
literal|1
operator|||
name|slot
operator|>=
name|MCPCIA_MAXDEV
operator|)
condition|)
block|{
name|WCFGP
argument_list|(
literal|" (no slot)\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|paddr
operator|=
name|bus
operator|<<
literal|21
expr_stmt|;
name|paddr
operator||=
name|slot
operator|<<
literal|16
expr_stmt|;
name|paddr
operator||=
name|func
operator|<<
literal|13
expr_stmt|;
name|paddr
operator||=
operator|(
operator|(
name|sz
operator|-
literal|1
operator|)
operator|<<
literal|3
operator|)
expr_stmt|;
name|paddr
operator||=
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
operator|(
name|off
operator|>>
literal|2
operator|)
operator|<<
literal|7
argument_list|)
operator|)
expr_stmt|;
name|paddr
operator||=
name|MCPCIA_PCI_CONF
expr_stmt|;
name|paddr
operator||=
name|sc
operator|->
name|sysbase
expr_stmt|;
name|dp
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
name|KV
argument_list|(
name|paddr
argument_list|)
expr_stmt|;
name|WCFGP
argument_list|(
literal|" hose %d MID%d paddr 0x%lx\n"
argument_list|,
name|bh
argument_list|,
name|mcbus_get_mid
argument_list|(
name|dev
argument_list|)
argument_list|,
name|paddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|badaddr
argument_list|(
name|dp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dp
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|u_int32_t
name|new_data
decl_stmt|;
if|if
condition|(
name|sz
operator|==
literal|1
condition|)
block|{
name|new_data
operator|=
name|SPARSE_BYTE_INSERT
argument_list|(
name|off
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sz
operator|==
literal|2
condition|)
block|{
name|new_data
operator|=
name|SPARSE_WORD_INSERT
argument_list|(
name|off
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|new_data
operator|=
name|data
expr_stmt|;
block|}
operator|*
name|dp
operator|=
name|new_data
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|u_int8_t
name|mcpcia_cfgreadb
parameter_list|(
name|u_int
name|h
parameter_list|,
name|u_int
name|b
parameter_list|,
name|u_int
name|s
parameter_list|,
name|u_int
name|f
parameter_list|,
name|u_int
name|r
parameter_list|)
block|{
return|return
operator|(
name|u_int8_t
operator|)
name|mcpcia_cfgread
argument_list|(
name|h
argument_list|,
name|b
argument_list|,
name|s
argument_list|,
name|f
argument_list|,
name|r
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int16_t
name|mcpcia_cfgreadw
parameter_list|(
name|u_int
name|h
parameter_list|,
name|u_int
name|b
parameter_list|,
name|u_int
name|s
parameter_list|,
name|u_int
name|f
parameter_list|,
name|u_int
name|r
parameter_list|)
block|{
return|return
operator|(
name|u_int16_t
operator|)
name|mcpcia_cfgread
argument_list|(
name|h
argument_list|,
name|b
argument_list|,
name|s
argument_list|,
name|f
argument_list|,
name|r
argument_list|,
literal|2
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int32_t
name|mcpcia_cfgreadl
parameter_list|(
name|u_int
name|h
parameter_list|,
name|u_int
name|b
parameter_list|,
name|u_int
name|s
parameter_list|,
name|u_int
name|f
parameter_list|,
name|u_int
name|r
parameter_list|)
block|{
return|return
name|mcpcia_cfgread
argument_list|(
name|h
argument_list|,
name|b
argument_list|,
name|s
argument_list|,
name|f
argument_list|,
name|r
argument_list|,
literal|4
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mcpcia_cfgwriteb
parameter_list|(
name|u_int
name|h
parameter_list|,
name|u_int
name|b
parameter_list|,
name|u_int
name|s
parameter_list|,
name|u_int
name|f
parameter_list|,
name|u_int
name|r
parameter_list|,
name|u_int8_t
name|data
parameter_list|)
block|{
name|mcpcia_cfgwrite
argument_list|(
name|h
argument_list|,
name|b
argument_list|,
name|s
argument_list|,
name|f
argument_list|,
name|r
argument_list|,
literal|1
argument_list|,
operator|(
name|u_int32_t
operator|)
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mcpcia_cfgwritew
parameter_list|(
name|u_int
name|h
parameter_list|,
name|u_int
name|b
parameter_list|,
name|u_int
name|s
parameter_list|,
name|u_int
name|f
parameter_list|,
name|u_int
name|r
parameter_list|,
name|u_int16_t
name|data
parameter_list|)
block|{
name|mcpcia_cfgwrite
argument_list|(
name|h
argument_list|,
name|b
argument_list|,
name|s
argument_list|,
name|f
argument_list|,
name|r
argument_list|,
literal|2
argument_list|,
operator|(
name|u_int32_t
operator|)
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mcpcia_cfgwritel
parameter_list|(
name|u_int
name|h
parameter_list|,
name|u_int
name|b
parameter_list|,
name|u_int
name|s
parameter_list|,
name|u_int
name|f
parameter_list|,
name|u_int
name|r
parameter_list|,
name|u_int32_t
name|data
parameter_list|)
block|{
name|mcpcia_cfgwrite
argument_list|(
name|h
argument_list|,
name|b
argument_list|,
name|s
argument_list|,
name|f
argument_list|,
name|r
argument_list|,
literal|4
argument_list|,
operator|(
name|u_int32_t
operator|)
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mcpcia_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|device_t
name|child
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|struct
name|mcpcia_softc
modifier|*
name|xc
decl_stmt|,
modifier|*
name|sc
init|=
name|MCPCIA_SOFTC
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|unit
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|mcpcias
index|[
name|unit
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"%s: already attached\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|EEXIST
return|;
block|}
name|sc
operator|->
name|mcpcia_inst
operator|=
name|unit
expr_stmt|;
if|if
condition|(
operator|(
name|xc
operator|=
name|mcpcia_root
operator|)
operator|==
name|NULL
condition|)
block|{
name|mcpcia_root
operator|=
name|sc
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|xc
operator|->
name|next
condition|)
name|xc
operator|=
name|xc
operator|->
name|next
expr_stmt|;
name|xc
operator|->
name|next
operator|=
name|sc
expr_stmt|;
block|}
name|sc
operator|->
name|dev
operator|=
name|mcpcias
index|[
name|unit
index|]
operator|=
name|dev
expr_stmt|;
comment|/* PROBE ? */
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"MCPCIA PCI Adapter"
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|==
literal|0
condition|)
block|{
name|pci_init_resources
argument_list|()
expr_stmt|;
block|}
name|child
operator|=
name|device_add_child
argument_list|(
name|dev
argument_list|,
literal|"pcib"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|device_set_ivars
argument_list|(
name|child
argument_list|,
operator|&
name|sc
operator|->
name|mcpcia_inst
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mcpcia_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|mcpcia_softc
modifier|*
name|sc
init|=
name|MCPCIA_SOFTC
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|device_t
name|p
init|=
name|device_get_parent
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|vm_offset_t
name|regs
decl_stmt|;
name|u_int32_t
name|ctl
decl_stmt|;
name|int
name|mid
decl_stmt|,
name|gid
decl_stmt|,
name|rval
decl_stmt|;
name|void
modifier|*
name|intr
decl_stmt|;
name|chipset
operator|=
name|mcpcia_chipset
expr_stmt|;
name|mid
operator|=
name|mcbus_get_mid
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|gid
operator|=
name|mcbus_get_gid
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sysbase
operator|=
name|MCBUS_IOSPACE
operator||
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|gid
operator|)
operator|<<
name|MCBUS_GID_SHIFT
operator|)
operator||
expr|\
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|mid
operator|)
operator|<<
name|MCBUS_MID_SHIFT
operator|)
expr_stmt|;
name|regs
operator|=
operator|(
name|vm_offset_t
operator|)
name|KV
argument_list|(
name|sc
operator|->
name|sysbase
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dmem_base
operator|=
name|regs
operator|+
name|MCPCIA_PCI_DENSE
expr_stmt|;
name|sc
operator|->
name|smem_base
operator|=
name|regs
operator|+
name|MCPCIA_PCI_SPARSE
expr_stmt|;
name|sc
operator|->
name|io_base
operator|=
name|regs
operator|+
name|MCPCIA_PCI_IOSPACE
expr_stmt|;
comment|/*  	 * Disable interrupts and clear errors prior to probing 	 */
name|REGVAL
argument_list|(
name|MCPCIA_INT_MASK0
argument_list|(
name|sc
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|REGVAL
argument_list|(
name|MCPCIA_INT_MASK1
argument_list|(
name|sc
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|REGVAL
argument_list|(
name|MCPCIA_CAP_ERR
argument_list|(
name|sc
argument_list|)
argument_list|)
operator|=
literal|0xFFFFFFFF
expr_stmt|;
name|alpha_mb
argument_list|()
expr_stmt|;
comment|/* 	 * Say who we are 	 */
name|ctl
operator|=
name|REGVAL
argument_list|(
name|MCPCIA_PCI_REV
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: Horse Revision %d, %s Handed Saddle Revision %d,"
literal|" CAP Revision %d\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|HORSE_REV
argument_list|(
name|ctl
argument_list|)
argument_list|,
operator|(
name|SADDLE_TYPE
argument_list|(
name|ctl
argument_list|)
operator|&
literal|1
operator|)
condition|?
literal|"Right"
else|:
literal|"Left"
argument_list|,
name|SADDLE_REV
argument_list|(
name|ctl
argument_list|)
argument_list|,
name|CAP_REV
argument_list|(
name|ctl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * See if we're the fella with the EISA bus... 	 */
if|if
condition|(
name|EISA_PRESENT
argument_list|(
name|REGVAL
argument_list|(
name|MCPCIA_PCI_REV
argument_list|(
name|sc
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|mcpcia_eisa
operator|=
name|sc
expr_stmt|;
block|}
comment|/* 	 * Set up DMA stuff here. 	 */
name|mcpcia_dma_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Register our interrupt service requirements with out parent. 	 */
name|rval
operator|=
name|BUS_SETUP_INTR
argument_list|(
name|p
argument_list|,
name|dev
argument_list|,
name|NULL
argument_list|,
name|INTR_TYPE_MISC
argument_list|,
name|mcpcia_intr
argument_list|,
literal|0
argument_list|,
operator|&
name|intr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sc
operator|==
name|mcpcia_eisa
condition|)
block|{
name|printf
argument_list|(
literal|"Attaching Real Console\n"
argument_list|)
expr_stmt|;
name|dec_kn300_cons_init
argument_list|()
expr_stmt|;
comment|/* 			 * Enable EISA interrupts. 			 */
name|mcpcia_enable_intr
argument_list|(
name|sc
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
name|bus_generic_attach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mcpcia_enable_intr
parameter_list|(
name|struct
name|mcpcia_softc
modifier|*
name|sc
parameter_list|,
name|int
name|irq
parameter_list|)
block|{
name|alpha_mb
argument_list|()
expr_stmt|;
name|REGVAL
argument_list|(
name|MCPCIA_INT_MASK0
argument_list|(
name|sc
argument_list|)
argument_list|)
operator||=
operator|(
literal|1
operator|<<
name|irq
operator|)
expr_stmt|;
name|alpha_mb
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mcpcia_disable_intr
parameter_list|(
name|struct
name|mcpcia_softc
modifier|*
name|sc
parameter_list|,
name|int
name|irq
parameter_list|)
block|{
name|alpha_mb
argument_list|()
expr_stmt|;
name|REGVAL
argument_list|(
name|MCPCIA_INT_MASK0
argument_list|(
name|sc
argument_list|)
argument_list|)
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|irq
operator|)
expr_stmt|;
name|alpha_mb
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mcpcia_setup_intr
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|struct
name|resource
modifier|*
name|ir
parameter_list|,
name|int
name|flags
parameter_list|,
name|driver_intr_t
modifier|*
name|intr
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|void
modifier|*
modifier|*
name|cp
parameter_list|)
block|{
name|struct
name|mcpcia_softc
modifier|*
name|sc
init|=
name|MCPCIA_SOFTC
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|slot
decl_stmt|,
name|mid
decl_stmt|,
name|gid
decl_stmt|,
name|birq
decl_stmt|,
name|irq
decl_stmt|,
name|error
decl_stmt|,
name|intpin
decl_stmt|,
name|h
decl_stmt|;
name|intpin
operator|=
name|pci_get_intpin
argument_list|(
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|intpin
operator|==
literal|0
condition|)
block|{
comment|/* No IRQ used */
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|intpin
operator|<
literal|1
operator|||
name|intpin
operator|>
literal|4
condition|)
block|{
comment|/* Bad IRQ */
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|slot
operator|=
name|pci_get_slot
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|mid
operator|=
name|mcbus_get_mid
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|gid
operator|=
name|mcbus_get_gid
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|slot
operator|==
literal|0
condition|)
block|{
name|device_t
name|bdev
decl_stmt|;
comment|/* bridged - get slot from granparent */
comment|/* note that this is broken for all but the most trival case */
name|bdev
operator|=
name|device_get_parent
argument_list|(
name|device_get_parent
argument_list|(
name|child
argument_list|)
argument_list|)
expr_stmt|;
name|slot
operator|=
name|pci_get_slot
argument_list|(
name|bdev
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mid
operator|==
literal|5
operator|&&
name|slot
operator|==
literal|1
condition|)
block|{
name|irq
operator|=
literal|16
expr_stmt|;
comment|/* MID 5, slot 1, is the internal NCR 53c810 */
block|}
elseif|else
if|if
condition|(
name|slot
operator|>=
literal|2
operator|&&
name|slot
operator|<=
literal|5
condition|)
block|{
name|irq
operator|=
operator|(
name|slot
operator|-
literal|2
operator|)
operator|*
literal|4
expr_stmt|;
block|}
else|else
block|{
name|device_printf
argument_list|(
name|child
argument_list|,
literal|"wierd slot number (%d); can't make irq\n"
argument_list|,
name|slot
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|error
operator|=
name|rman_activate_resource
argument_list|(
name|ir
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
comment|/* 	 * We now construct a vector as the hardware would, unless 	 * this is the internal NCR 53c810 interrupt. 	 */
if|if
condition|(
name|irq
operator|==
literal|16
condition|)
block|{
name|h
operator|=
name|MCPCIA_VEC_NCR
expr_stmt|;
block|}
else|else
block|{
name|h
operator|=
name|MCPCIA_VEC_PCI
operator|+
operator|(
operator|(
name|mid
operator|-
literal|4
operator|)
operator|*
name|MCPCIA_VECWIDTH_PER_MCPCIA
operator|)
operator|+
operator|(
name|slot
operator|*
name|MCPCIA_VECWIDTH_PER_SLOT
operator|)
operator|+
operator|(
operator|(
name|intpin
operator|-
literal|1
operator|)
operator|*
name|MCPCIA_VECWIDTH_PER_INTPIN
operator|)
expr_stmt|;
block|}
name|birq
operator|=
name|irq
operator|+
name|INTRCNT_KN300_IRQ
expr_stmt|;
name|error
operator|=
name|alpha_setup_intr
argument_list|(
name|h
argument_list|,
name|intr
argument_list|,
name|arg
argument_list|,
name|cp
argument_list|,
operator|&
name|intrcnt
index|[
name|birq
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|mcpcia_enable_intr
argument_list|(
name|sc
argument_list|,
name|irq
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|child
argument_list|,
literal|"interrupting at IRQ 0x%x int%c (vec 0x%x)\n"
argument_list|,
name|irq
argument_list|,
name|intpin
operator|-
literal|1
operator|+
literal|'A'
argument_list|,
name|h
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mcpcia_teardown_intr
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|struct
name|resource
modifier|*
name|i
parameter_list|,
name|void
modifier|*
name|c
parameter_list|)
block|{
name|struct
name|mcpcia_softc
modifier|*
name|sc
init|=
name|MCPCIA_SOFTC
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|slot
decl_stmt|,
name|mid
decl_stmt|,
name|irq
decl_stmt|;
name|slot
operator|=
name|pci_get_slot
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|mid
operator|=
name|mcbus_get_mid
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|mid
operator|==
literal|5
operator|&&
name|slot
operator|==
literal|1
condition|)
block|{
name|irq
operator|=
literal|16
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|slot
operator|>=
literal|2
operator|&&
name|slot
operator|<=
literal|5
condition|)
block|{
name|irq
operator|=
operator|(
name|slot
operator|-
literal|2
operator|)
operator|*
literal|4
expr_stmt|;
block|}
else|else
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|mcpcia_disable_intr
argument_list|(
name|sc
argument_list|,
name|irq
argument_list|)
expr_stmt|;
name|alpha_teardown_intr
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
operator|(
name|rman_deactivate_resource
argument_list|(
name|i
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mcpcia_sgmap_map
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|vm_offset_t
name|ba
parameter_list|,
name|vm_offset_t
name|pa
parameter_list|)
block|{
name|u_int64_t
modifier|*
name|sgtable
init|=
name|arg
decl_stmt|;
name|int
name|index
init|=
name|alpha_btop
argument_list|(
name|ba
operator|-
name|MCPCIA_ISA_SG_MAPPED_BASE
argument_list|)
decl_stmt|;
if|if
condition|(
name|pa
condition|)
block|{
if|if
condition|(
name|pa
operator|>
operator|(
literal|1L
operator|<<
literal|32
operator|)
condition|)
name|panic
argument_list|(
literal|"mcpcia_sgmap_map: can't map address 0x%lx"
argument_list|,
name|pa
argument_list|)
expr_stmt|;
name|sgtable
index|[
name|index
index|]
operator|=
operator|(
operator|(
name|pa
operator|>>
literal|13
operator|)
operator|<<
literal|1
operator|)
operator||
literal|1
expr_stmt|;
block|}
else|else
block|{
name|sgtable
index|[
name|index
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|alpha_mb
argument_list|()
expr_stmt|;
name|MCPCIA_SGTLB_INVALIDATE
argument_list|(
name|mcpcia_eisa
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mcpcia_dma_init
parameter_list|(
name|struct
name|mcpcia_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* 	 * Disable all windows first. 	 */
name|REGVAL
argument_list|(
name|MCPCIA_W0_BASE
argument_list|(
name|sc
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|REGVAL
argument_list|(
name|MCPCIA_W1_BASE
argument_list|(
name|sc
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|REGVAL
argument_list|(
name|MCPCIA_W2_BASE
argument_list|(
name|sc
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|REGVAL
argument_list|(
name|MCPCIA_W3_BASE
argument_list|(
name|sc
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|REGVAL
argument_list|(
name|MCPCIA_T0_BASE
argument_list|(
name|sc
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|REGVAL
argument_list|(
name|MCPCIA_T1_BASE
argument_list|(
name|sc
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|REGVAL
argument_list|(
name|MCPCIA_T2_BASE
argument_list|(
name|sc
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|REGVAL
argument_list|(
name|MCPCIA_T3_BASE
argument_list|(
name|sc
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|alpha_mb
argument_list|()
expr_stmt|;
comment|/* 	 * Set up window 0 as an 8MB SGMAP-mapped window starting at 8MB. 	 * Do this only for the EISA carrying MCPCIA. Partly because 	 * there's only one chipset sgmap thingie. 	 */
if|if
condition|(
name|sc
operator|==
name|mcpcia_eisa
condition|)
block|{
name|void
modifier|*
name|sgtable
decl_stmt|;
name|REGVAL
argument_list|(
name|MCPCIA_W0_MASK
argument_list|(
name|sc
argument_list|)
argument_list|)
operator|=
name|MCPCIA_WMASK_8M
expr_stmt|;
name|sgtable
operator|=
name|contigmalloc
argument_list|(
literal|8192
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|,
literal|0
argument_list|,
literal|1L
operator|<<
literal|34
argument_list|,
literal|32
operator|<<
literal|10
argument_list|,
literal|1L
operator|<<
literal|34
argument_list|)
expr_stmt|;
if|if
condition|(
name|sgtable
operator|==
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"mcpcia_dma_init: cannot allocate sgmap"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|REGVAL
argument_list|(
name|MCPCIA_T0_BASE
argument_list|(
name|sc
argument_list|)
argument_list|)
operator|=
name|pmap_kextract
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|sgtable
argument_list|)
operator|>>
name|MCPCIA_TBASEX_SHIFT
expr_stmt|;
name|alpha_mb
argument_list|()
expr_stmt|;
name|REGVAL
argument_list|(
name|MCPCIA_W0_BASE
argument_list|(
name|sc
argument_list|)
argument_list|)
operator|=
name|MCPCIA_WBASE_EN
operator||
name|MCPCIA_WBASE_SG
operator||
name|MCPCIA_ISA_SG_MAPPED_BASE
expr_stmt|;
name|alpha_mb
argument_list|()
expr_stmt|;
name|MCPCIA_SGTLB_INVALIDATE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|chipset
operator|.
name|sgmap
operator|=
name|sgmap_map_create
argument_list|(
name|MCPCIA_ISA_SG_MAPPED_BASE
argument_list|,
name|MCPCIA_ISA_SG_MAPPED_BASE
operator|+
name|MCPCIA_ISA_SG_MAPPED_SIZE
operator|-
literal|1
argument_list|,
name|mcpcia_sgmap_map
argument_list|,
name|sgtable
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Set up window 1 as a 2 GB Direct-mapped window starting at 2GB. 	 */
name|REGVAL
argument_list|(
name|MCPCIA_W1_MASK
argument_list|(
name|sc
argument_list|)
argument_list|)
operator|=
name|MCPCIA_WMASK_2G
expr_stmt|;
name|REGVAL
argument_list|(
name|MCPCIA_T1_BASE
argument_list|(
name|sc
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|alpha_mb
argument_list|()
expr_stmt|;
name|REGVAL
argument_list|(
name|MCPCIA_W1_BASE
argument_list|(
name|sc
argument_list|)
argument_list|)
operator|=
name|MCPCIA_DIRECT_MAPPED_BASE
operator||
name|MCPCIA_WBASE_EN
expr_stmt|;
name|alpha_mb
argument_list|()
expr_stmt|;
comment|/* 	 * When we get around to redoing the 'chipset' stuff to have more 	 * than one sgmap handler... 	 */
if|#
directive|if
literal|0
comment|/* 	 * Set up window 2 as a 1G SGMAP-mapped window starting at 1G. 	 */
block|REGVAL(MCPCIA_W2_MASK(sc)) = MCPCIA_WMASK_1G; 	REGVAL(MCPCIA_T2_BASE(sc)) = 		ccp->cc_pci_sgmap.aps_ptpa>> MCPCIA_TBASEX_SHIFT; 	alpha_mb(); 	REGVAL(MCPCIA_W2_BASE(sc)) = 		MCPCIA_WBASE_EN | MCPCIA_WBASE_SG | MCPCIA_PCI_SG_MAPPED_BASE; 	alpha_mb();
endif|#
directive|endif
comment|/* XXX XXX BEGIN XXX XXX */
block|{
comment|/* XXX */
name|alpha_XXX_dmamap_or
operator|=
name|MCPCIA_DIRECT_MAPPED_BASE
expr_stmt|;
comment|/* XXX */
block|}
comment|/* XXX */
comment|/* XXX XXX END XXX XXX */
block|}
end_function

begin_comment
comment|/*  */
end_comment

begin_function
specifier|static
name|void
name|mcpcia_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|unsigned
name|long
name|vec
init|=
operator|(
name|unsigned
name|long
operator|)
name|arg
decl_stmt|;
comment|/* 	 * Check for I2C interrupts.  These are technically within 	 * the PCI vector range, but no PCI device should ever map 	 * to them. 	 */
if|if
condition|(
name|vec
operator|==
name|MCPCIA_I2C_CVEC
condition|)
block|{
name|printf
argument_list|(
literal|"i2c: controller interrupt\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|vec
operator|==
name|MCPCIA_I2C_BVEC
condition|)
block|{
name|printf
argument_list|(
literal|"i2c: bus interrupt\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|alpha_dispatch_intr
argument_list|(
name|NULL
argument_list|,
name|vec
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|mcpcia
argument_list|,
name|mcbus
argument_list|,
name|mcpcia_driver
argument_list|,
name|mcpcia_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

