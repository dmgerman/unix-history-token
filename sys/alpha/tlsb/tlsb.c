begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/*  * Copyright (c) 1997, 2000 by Matthew Jacob  * NASA AMES Research Center.  * All rights reserved.  *  * Based in part upon a prototype version by Jason Thorpe  * Copyright (c) 1996 by Jason Thorpe.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice immediately at the beginning of the file, without modification,  *    this list of conditions, and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Autoconfiguration and support routines for the TurboLaser System Bus  * found on AlphaServer 8200 and 8400 systems.  */
end_comment

begin_include
include|#
directive|include
file|"opt_simos.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<machine/rpb.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpuconf.h>
end_include

begin_include
include|#
directive|include
file|<alpha/tlsb/tlsbreg.h>
end_include

begin_include
include|#
directive|include
file|<alpha/tlsb/tlsbvar.h>
end_include

begin_decl_stmt
name|struct
name|tlsb_device
modifier|*
name|tlsb_primary_cpu
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|KV
parameter_list|(
name|_addr
parameter_list|)
value|((caddr_t)ALPHA_PHYS_TO_K0SEG((_addr)))
end_define

begin_struct
struct|struct
name|tlsb_softc
block|{
name|driver_intr_t
modifier|*
name|zsc_intr
decl_stmt|;
name|void
modifier|*
name|zsc_arg
decl_stmt|;
name|driver_intr_t
modifier|*
name|sub_intr
decl_stmt|;
name|device_t
name|tlsb_dev
decl_stmt|;
name|int
name|tlsb_map
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|tlsb_add_child
parameter_list|(
name|struct
name|tlsb_softc
modifier|*
parameter_list|,
name|struct
name|tlsb_device
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|tlsb_node_type_str
parameter_list|(
name|u_int32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tlsb_intr
parameter_list|(
name|void
modifier|*
parameter_list|,
name|u_long
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|tlsb_softc
modifier|*
name|tlsb0_softc
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|tlsb_devclass
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Device methods  */
end_comment

begin_function_decl
specifier|static
name|int
name|tlsb_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tlsb_print_child
parameter_list|(
name|device_t
parameter_list|,
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tlsb_read_ivar
parameter_list|(
name|device_t
parameter_list|,
name|device_t
parameter_list|,
name|int
parameter_list|,
name|u_long
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tlsb_setup_intr
parameter_list|(
name|device_t
parameter_list|,
name|device_t
parameter_list|,
name|struct
name|resource
modifier|*
parameter_list|,
name|int
parameter_list|,
name|driver_intr_t
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|void
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tlsb_teardown_intr
parameter_list|(
name|device_t
parameter_list|,
name|device_t
parameter_list|,
name|struct
name|resource
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|tlsb_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|tlsb_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|bus_generic_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|bus_generic_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|bus_generic_shutdown
argument_list|)
block|,
comment|/* Bus interface */
name|DEVMETHOD
argument_list|(
name|bus_print_child
argument_list|,
name|tlsb_print_child
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_read_ivar
argument_list|,
name|tlsb_read_ivar
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_write_ivar
argument_list|,
name|bus_generic_write_ivar
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_setup_intr
argument_list|,
name|tlsb_setup_intr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_teardown_intr
argument_list|,
name|tlsb_teardown_intr
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|tlsb_driver
init|=
block|{
literal|"tlsb"
block|,
name|tlsb_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|tlsb_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * At 'probe' time, we add all the devices which we know about to the  * bus.  The generic attach routine will probe and attach them if they  * are alive.  */
end_comment

begin_function
specifier|static
name|int
name|tlsb_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|tlsb_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|tlsb_device
modifier|*
name|tdev
decl_stmt|;
name|u_int32_t
name|tldev
decl_stmt|;
name|int
name|node
decl_stmt|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"TurboLaser Backplane Bus"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tlsb_dev
operator|=
name|dev
expr_stmt|;
name|tlsb0_softc
operator|=
name|sc
expr_stmt|;
name|set_iointr
argument_list|(
name|tlsb_intr
argument_list|)
expr_stmt|;
comment|/* 	 * Attempt to find all devices on the bus, including 	 * CPUs, memory modules, and I/O modules. 	 */
for|for
control|(
name|node
operator|=
literal|0
init|;
name|node
operator|<=
name|TLSB_NODE_MAX
condition|;
operator|++
name|node
control|)
block|{
comment|/* 		 * Check for invalid address. 		 */
ifdef|#
directive|ifdef
name|SIMOS
if|if
condition|(
name|node
operator|!=
literal|0
operator|&&
name|node
operator|!=
literal|8
condition|)
block|{
continue|continue;
block|}
elseif|else
if|if
condition|(
name|node
operator|==
literal|0
condition|)
block|{
name|tldev
operator|=
name|TLDEV_DTYPE_SCPU4
expr_stmt|;
block|}
else|else
block|{
name|tldev
operator|=
name|TLDEV_DTYPE_KFTIA
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|badaddr
argument_list|(
name|TLSB_NODE_REG_ADDR
argument_list|(
name|node
argument_list|,
name|TLDEV
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
argument_list|)
condition|)
continue|continue;
name|tldev
operator|=
name|TLSB_GET_NODEREG
argument_list|(
name|node
argument_list|,
name|TLDEV
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|tldev
operator|==
literal|0
condition|)
block|{
comment|/* Nothing at this node. */
continue|continue;
block|}
name|tdev
operator|=
operator|(
expr|struct
name|tlsb_device
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|tlsb_device
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tdev
condition|)
block|{
name|printf
argument_list|(
literal|"tlsb_probe: unable to malloc softc\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|sc
operator|->
name|tlsb_map
operator||=
operator|(
literal|1
operator|<<
name|node
operator|)
expr_stmt|;
name|tdev
operator|->
name|td_node
operator|=
name|node
expr_stmt|;
name|tdev
operator|->
name|td_tldev
operator|=
name|tldev
expr_stmt|;
name|tlsb_add_child
argument_list|(
name|sc
argument_list|,
name|tdev
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tlsb_print_child
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|tlsb_device
modifier|*
name|tdev
init|=
name|DEVTOTLSB
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|retval
operator|+=
name|bus_print_child_header
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|printf
argument_list|(
literal|" at %s node %d\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|tdev
operator|->
name|td_node
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tlsb_read_ivar
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|index
parameter_list|,
name|u_long
modifier|*
name|result
parameter_list|)
block|{
name|struct
name|tlsb_device
modifier|*
name|tdev
init|=
name|DEVTOTLSB
argument_list|(
name|child
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|index
condition|)
block|{
case|case
name|TLSB_IVAR_NODE
case|:
operator|*
name|result
operator|=
name|tdev
operator|->
name|td_node
expr_stmt|;
break|break;
case|case
name|TLSB_IVAR_DTYPE
case|:
operator|*
name|result
operator|=
name|TLDEV_DTYPE
argument_list|(
name|tdev
operator|->
name|td_tldev
argument_list|)
expr_stmt|;
break|break;
case|case
name|TLSB_IVAR_SWREV
case|:
operator|*
name|result
operator|=
name|TLDEV_SWREV
argument_list|(
name|tdev
operator|->
name|td_tldev
argument_list|)
expr_stmt|;
break|break;
case|case
name|TLSB_IVAR_HWREV
case|:
operator|*
name|result
operator|=
name|TLDEV_HWREV
argument_list|(
name|tdev
operator|->
name|td_tldev
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tlsb_setup_intr
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|struct
name|resource
modifier|*
name|i
parameter_list|,
name|int
name|f
parameter_list|,
name|driver_intr_t
modifier|*
name|intr
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|void
modifier|*
modifier|*
name|c
parameter_list|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|device_get_name
argument_list|(
name|child
argument_list|)
argument_list|,
literal|"zsc"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|tlsb0_softc
operator|->
name|zsc_intr
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|tlsb0_softc
operator|->
name|zsc_intr
operator|=
name|intr
expr_stmt|;
name|tlsb0_softc
operator|->
name|zsc_arg
operator|=
name|arg
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|device_get_name
argument_list|(
name|child
argument_list|)
argument_list|,
literal|"dwlpx"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|tlsb0_softc
operator|->
name|sub_intr
operator|==
name|NULL
condition|)
name|tlsb0_softc
operator|->
name|sub_intr
operator|=
name|intr
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|tlsb_teardown_intr
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|struct
name|resource
modifier|*
name|i
parameter_list|,
name|void
modifier|*
name|c
parameter_list|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|device_get_name
argument_list|(
name|child
argument_list|)
argument_list|,
literal|"zsc"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tlsb0_softc
operator|->
name|zsc_intr
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"dwlpx"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tlsb0_softc
operator|->
name|sub_intr
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|tlsb_intr
parameter_list|(
name|void
modifier|*
name|frame
parameter_list|,
name|u_long
name|vector
parameter_list|)
block|{
if|if
condition|(
name|vector
operator|&&
name|tlsb0_softc
operator|->
name|sub_intr
condition|)
call|(
modifier|*
name|tlsb0_softc
operator|->
name|sub_intr
call|)
argument_list|(
operator|(
name|void
operator|*
operator|)
name|vector
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tlsb_add_child
parameter_list|(
name|struct
name|tlsb_softc
modifier|*
name|tlsb
parameter_list|,
name|struct
name|tlsb_device
modifier|*
name|tdev
parameter_list|)
block|{
specifier|static
name|int
name|kftproto
decl_stmt|,
name|memproto
decl_stmt|,
name|cpuproto
decl_stmt|;
name|u_int32_t
name|dtype
init|=
name|tdev
operator|->
name|td_tldev
operator|&
name|TLDEV_DTYPE_MASK
decl_stmt|;
name|int
name|i
decl_stmt|,
name|unit
decl_stmt|,
name|ordr
decl_stmt|,
name|units
init|=
literal|1
decl_stmt|;
name|char
modifier|*
name|dn
decl_stmt|;
name|device_t
name|cd
decl_stmt|;
comment|/* 	 * We want CPU and Memory boards to configure first, and we want the 	 * I/O boards to configure in reverse slot number order. This is 	 * further complicated by the possibility of dual CPU nodes. 	 */
name|ordr
operator|=
name|tdev
operator|->
name|td_node
operator|<<
literal|1
expr_stmt|;
switch|switch
condition|(
name|dtype
condition|)
block|{
case|case
name|TLDEV_DTYPE_KFTHA
case|:
case|case
name|TLDEV_DTYPE_KFTIA
case|:
name|ordr
operator|=
literal|16
operator|+
operator|(
name|TLSB_NODE_MAX
operator|-
name|tdev
operator|->
name|td_node
operator|)
expr_stmt|;
name|dn
operator|=
literal|"kft"
expr_stmt|;
name|unit
operator|=
name|kftproto
operator|++
expr_stmt|;
break|break;
case|case
name|TLDEV_DTYPE_MS7CC
case|:
name|dn
operator|=
literal|"tlsbmem"
expr_stmt|;
name|unit
operator|=
name|memproto
operator|++
expr_stmt|;
break|break;
case|case
name|TLDEV_DTYPE_SCPU4
case|:
case|case
name|TLDEV_DTYPE_SCPU16
case|:
name|dn
operator|=
literal|"tlsbcpu"
expr_stmt|;
name|unit
operator|=
name|cpuproto
operator|++
expr_stmt|;
break|break;
case|case
name|TLDEV_DTYPE_DCPU4
case|:
case|case
name|TLDEV_DTYPE_DCPU16
case|:
name|units
operator|=
literal|2
expr_stmt|;
name|dn
operator|=
literal|"tlsbcpu"
expr_stmt|;
name|unit
operator|=
name|cpuproto
expr_stmt|;
name|cpuproto
operator|+=
literal|2
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"tlsb_add_child: unknown TLSB node type 0x%x\n"
argument_list|,
name|dtype
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|units
condition|;
name|i
operator|++
operator|,
name|unit
operator|++
control|)
block|{
name|cd
operator|=
name|device_add_child_ordered
argument_list|(
name|tlsb
operator|->
name|tlsb_dev
argument_list|,
name|ordr
argument_list|,
name|dn
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|cd
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|device_set_ivars
argument_list|(
name|cd
argument_list|,
name|tdev
argument_list|)
expr_stmt|;
name|device_set_desc
argument_list|(
name|cd
argument_list|,
name|tlsb_node_type_str
argument_list|(
name|dtype
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|tlsb_node_type_str
parameter_list|(
name|u_int32_t
name|dtype
parameter_list|)
block|{
specifier|static
name|char
name|tmp
index|[
literal|64
index|]
decl_stmt|;
switch|switch
condition|(
name|dtype
operator|&
name|TLDEV_DTYPE_MASK
condition|)
block|{
case|case
name|TLDEV_DTYPE_KFTHA
case|:
return|return
operator|(
literal|"KFTHA I/O interface"
operator|)
return|;
case|case
name|TLDEV_DTYPE_KFTIA
case|:
return|return
operator|(
literal|"KFTIA I/O interface"
operator|)
return|;
case|case
name|TLDEV_DTYPE_MS7CC
case|:
return|return
operator|(
literal|"MS7CC Memory Module"
operator|)
return|;
case|case
name|TLDEV_DTYPE_SCPU4
case|:
return|return
operator|(
literal|"Single CPU, 4MB cache"
operator|)
return|;
case|case
name|TLDEV_DTYPE_SCPU16
case|:
return|return
operator|(
literal|"Single CPU, 16MB cache"
operator|)
return|;
case|case
name|TLDEV_DTYPE_DCPU4
case|:
return|return
operator|(
literal|"Dual CPU, 4MB cache"
operator|)
return|;
case|case
name|TLDEV_DTYPE_DCPU16
case|:
return|return
operator|(
literal|"Dual CPU, 16MB cache"
operator|)
return|;
default|default:
name|bzero
argument_list|(
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|,
literal|"unknown, type 0x%x"
argument_list|,
name|dtype
argument_list|)
expr_stmt|;
return|return
operator|(
name|tmp
operator|)
return|;
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|tlsb
argument_list|,
name|root
argument_list|,
name|tlsb_driver
argument_list|,
name|tlsb_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

