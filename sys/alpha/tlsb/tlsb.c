begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/* $NetBSD: tlsb.c,v 1.10 1998/05/14 00:01:32 thorpej Exp $ */
end_comment

begin_comment
comment|/*  * Copyright (c) 1997 by Matthew Jacob  * NASA AMES Research Center.  * All rights reserved.  *  * Based in part upon a prototype version by Jason Thorpe  * Copyright (c) 1996 by Jason Thorpe.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice immediately at the beginning of the file, without modification,  *    this list of conditions, and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Autoconfiguration and support routines for the TurboLaser System Bus  * found on AlphaServer 8200 and 8400 systems.  */
end_comment

begin_include
include|#
directive|include
file|"opt_simos.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<machine/rpb.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpuconf.h>
end_include

begin_include
include|#
directive|include
file|<alpha/tlsb/tlsbreg.h>
end_include

begin_include
include|#
directive|include
file|<alpha/tlsb/tlsbvar.h>
end_include

begin_comment
comment|/* #include "locators.h" */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|cputype
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|KV
parameter_list|(
name|_addr
parameter_list|)
value|((caddr_t)ALPHA_PHYS_TO_K0SEG((_addr)))
end_define

begin_comment
comment|/*  * The structure used to attach devices to the TurboLaser.  */
end_comment

begin_struct
struct|struct
name|tlsb_device
block|{
name|int
name|td_node
decl_stmt|;
comment|/* node number */
name|u_int16_t
name|td_dtype
decl_stmt|;
comment|/* device type */
name|u_int8_t
name|td_swrev
decl_stmt|;
comment|/* software revision */
name|u_int8_t
name|td_hwrev
decl_stmt|;
comment|/* hardware revision */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|DEVTOTLSB
parameter_list|(
name|dev
parameter_list|)
value|((struct tlsb_device*) device_get_ivars(dev))
end_define

begin_struct
struct|struct
name|intr_mapping
block|{
name|STAILQ_ENTRY
argument_list|(
argument|intr_mapping
argument_list|)
name|queue
expr_stmt|;
name|driver_intr_t
modifier|*
name|intr
decl_stmt|;
name|void
modifier|*
name|arg
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|tlsb_softc
block|{
name|STAILQ_HEAD
argument_list|(
argument_list|,
argument|intr_mapping
argument_list|)
name|intr_handlers
expr_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|char
modifier|*
name|tlsb_node_type_str
parameter_list|(
name|u_int32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tlsb_intr
parameter_list|(
name|void
modifier|*
name|frame
parameter_list|,
name|u_long
name|vector
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* There can be only one. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|tlsb_found
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|tlsb_softc
modifier|*
name|tlsb0_softc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|tlsb_devclass
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Device methods  */
end_comment

begin_function_decl
specifier|static
name|int
name|tlsb_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tlsb_print_child
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tlsb_read_ivar
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|which
parameter_list|,
name|u_long
modifier|*
name|result
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tlsb_setup_intr
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|struct
name|resource
modifier|*
name|irq
parameter_list|,
name|int
name|flags
parameter_list|,
name|driver_intr_t
modifier|*
name|intr
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|void
modifier|*
modifier|*
name|cookiep
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tlsb_teardown_intr
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|struct
name|resource
modifier|*
name|irq
parameter_list|,
name|void
modifier|*
name|cookie
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|tlsb_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|tlsb_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|bus_generic_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|bus_generic_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|bus_generic_shutdown
argument_list|)
block|,
comment|/* Bus interface */
name|DEVMETHOD
argument_list|(
name|bus_print_child
argument_list|,
name|tlsb_print_child
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_read_ivar
argument_list|,
name|tlsb_read_ivar
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_write_ivar
argument_list|,
name|bus_generic_write_ivar
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_setup_intr
argument_list|,
name|tlsb_setup_intr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_teardown_intr
argument_list|,
name|tlsb_teardown_intr
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|tlsb_driver
init|=
block|{
literal|"tlsb"
block|,
name|tlsb_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|tlsb_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * At 'probe' time, we add all the devices which we know about to the  * bus.  The generic attach routine will probe and attach them if they  * are alive.  */
end_comment

begin_function
specifier|static
name|int
name|tlsb_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|tlsb_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|tlsb_device
modifier|*
name|tdev
decl_stmt|;
name|u_int32_t
name|tldev
decl_stmt|;
name|u_int8_t
name|vid
decl_stmt|;
name|int
name|node
decl_stmt|;
name|device_t
name|child
decl_stmt|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"TurboLaser bus"
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|intr_handlers
argument_list|)
expr_stmt|;
name|tlsb0_softc
operator|=
name|sc
expr_stmt|;
name|set_iointr
argument_list|(
name|tlsb_intr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Probing for devices on the TurboLaser bus:\n"
argument_list|)
expr_stmt|;
name|tlsb_found
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Attempt to find all devices on the bus, including 	 * CPUs, memory modules, and I/O modules. 	 */
comment|/* 	 * Sigh. I would like to just start off nicely, 	 * but I need to treat I/O modules differently- 	 * The highest priority I/O node has to be in 	 * node #8, and I want to find it *first*, since 	 * it will have the primary disks (most likely) 	 * on it. 	 */
comment|/* 	 * XXX dfr: I don't see why I need to do this 	 */
for|for
control|(
name|node
operator|=
literal|0
init|;
name|node
operator|<=
name|TLSB_NODE_MAX
condition|;
operator|++
name|node
control|)
block|{
comment|/* 		 * Check for invalid address.  This may not really 		 * be necessary, but what the heck... 		 */
if|if
condition|(
name|badaddr
argument_list|(
name|TLSB_NODE_REG_ADDR
argument_list|(
name|node
argument_list|,
name|TLDEV
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
argument_list|)
condition|)
continue|continue;
name|tldev
operator|=
name|TLSB_GET_NODEREG
argument_list|(
name|node
argument_list|,
name|TLDEV
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIMOS
if|if
condition|(
name|node
operator|!=
literal|0
operator|&&
name|node
operator|!=
literal|8
condition|)
continue|continue;
endif|#
directive|endif
if|if
condition|(
name|tldev
operator|==
literal|0
condition|)
block|{
comment|/* Nothing at this node. */
continue|continue;
block|}
if|#
directive|if
literal|0
block|if (TLDEV_ISIOPORT(tldev)) 			continue;
comment|/* not interested right now */
endif|#
directive|endif
name|tdev
operator|=
operator|(
expr|struct
name|tlsb_device
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|tlsb_device
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tdev
condition|)
continue|continue;
name|tdev
operator|->
name|td_node
operator|=
name|node
expr_stmt|;
ifdef|#
directive|ifdef
name|SIMOS
if|if
condition|(
name|node
operator|==
literal|0
condition|)
name|tdev
operator|->
name|td_dtype
operator|=
name|TLDEV_DTYPE_SCPU4
expr_stmt|;
elseif|else
if|if
condition|(
name|node
operator|==
literal|8
condition|)
name|tdev
operator|->
name|td_dtype
operator|=
name|TLDEV_DTYPE_KFTIA
expr_stmt|;
else|#
directive|else
name|tdev
operator|->
name|td_dtype
operator|=
name|TLDEV_DTYPE
argument_list|(
name|tldev
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tdev
operator|->
name|td_swrev
operator|=
name|TLDEV_SWREV
argument_list|(
name|tldev
argument_list|)
expr_stmt|;
name|tdev
operator|->
name|td_hwrev
operator|=
name|TLDEV_HWREV
argument_list|(
name|tldev
argument_list|)
expr_stmt|;
name|child
operator|=
name|device_add_child
argument_list|(
name|dev
argument_list|,
name|NULL
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|device_set_ivars
argument_list|(
name|child
argument_list|,
name|tdev
argument_list|)
expr_stmt|;
name|device_set_desc
argument_list|(
name|child
argument_list|,
name|tlsb_node_type_str
argument_list|(
name|tdev
operator|->
name|td_dtype
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * Deal with hooking CPU instances to TurboLaser nodes. 		 */
if|if
condition|(
name|TLDEV_ISCPU
argument_list|(
name|tldev
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s%d node %d: %s"
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|node
argument_list|,
name|tlsb_node_type_str
argument_list|(
name|tldev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 			 * Hook in the first CPU unit. 			 */
name|vid
operator|=
operator|(
name|TLSB_GET_NODEREG
argument_list|(
name|node
argument_list|,
name|TLVID
argument_list|)
operator|&
name|TLVID_VIDA_MASK
operator|)
operator|>>
name|TLVID_VIDA_SHIFT
expr_stmt|;
name|printf
argument_list|(
literal|", VID %d\n"
argument_list|,
name|vid
argument_list|)
expr_stmt|;
name|TLSB_PUT_NODEREG
argument_list|(
name|node
argument_list|,
name|TLCPUMASK
argument_list|,
operator|(
literal|1
operator|<<
name|vid
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tlsb_print_child
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|tlsb_device
modifier|*
name|tdev
init|=
name|DEVTOTLSB
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|retval
operator|+=
name|bus_print_child_header
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|printf
argument_list|(
literal|" at %s node %d\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|tdev
operator|->
name|td_node
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tlsb_read_ivar
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|index
parameter_list|,
name|u_long
modifier|*
name|result
parameter_list|)
block|{
name|struct
name|tlsb_device
modifier|*
name|tdev
init|=
name|DEVTOTLSB
argument_list|(
name|child
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|index
condition|)
block|{
case|case
name|TLSB_IVAR_NODE
case|:
operator|*
name|result
operator|=
name|tdev
operator|->
name|td_node
expr_stmt|;
break|break;
case|case
name|TLSB_IVAR_DTYPE
case|:
operator|*
name|result
operator|=
name|tdev
operator|->
name|td_dtype
expr_stmt|;
break|break;
case|case
name|TLSB_IVAR_SWREV
case|:
operator|*
name|result
operator|=
name|tdev
operator|->
name|td_swrev
expr_stmt|;
break|break;
case|case
name|TLSB_IVAR_HWREV
case|:
operator|*
name|result
operator|=
name|tdev
operator|->
name|td_hwrev
expr_stmt|;
break|break;
block|}
return|return
name|ENOENT
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tlsb_setup_intr
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|struct
name|resource
modifier|*
name|irq
parameter_list|,
name|int
name|flags
parameter_list|,
name|driver_intr_t
modifier|*
name|intr
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|void
modifier|*
modifier|*
name|cookiep
parameter_list|)
block|{
name|struct
name|tlsb_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|intr_mapping
modifier|*
name|i
decl_stmt|;
name|i
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|intr_mapping
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|i
condition|)
return|return
name|ENOMEM
return|;
name|i
operator|->
name|intr
operator|=
name|intr
expr_stmt|;
name|i
operator|->
name|arg
operator|=
name|arg
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|intr_handlers
argument_list|,
name|i
argument_list|,
name|queue
argument_list|)
expr_stmt|;
operator|*
name|cookiep
operator|=
name|i
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tlsb_teardown_intr
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|struct
name|resource
modifier|*
name|irq
parameter_list|,
name|void
modifier|*
name|cookie
parameter_list|)
block|{
name|struct
name|tlsb_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|intr_mapping
modifier|*
name|i
init|=
name|cookie
decl_stmt|;
name|STAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|intr_handlers
argument_list|,
name|i
argument_list|,
name|intr_mapping
argument_list|,
name|queue
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|i
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|tlsb_intr
parameter_list|(
name|void
modifier|*
name|frame
parameter_list|,
name|u_long
name|vector
parameter_list|)
block|{
name|struct
name|tlsb_softc
modifier|*
name|sc
init|=
name|tlsb0_softc
decl_stmt|;
name|struct
name|intr_mapping
modifier|*
name|i
decl_stmt|;
comment|/* 	 * XXX for SimOS, broadcast the interrupt.  A real implementation 	 * will decode the vector to extract node and host etc. 	 */
for|for
control|(
name|i
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|intr_handlers
argument_list|)
init|;
name|i
condition|;
name|i
operator|=
name|STAILQ_NEXT
argument_list|(
name|i
argument_list|,
name|queue
argument_list|)
control|)
name|i
operator|->
name|intr
argument_list|(
name|i
operator|->
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|tlsb
argument_list|,
name|root
argument_list|,
name|tlsb_driver
argument_list|,
name|tlsb_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|char
modifier|*
name|tlsb_node_type_str
parameter_list|(
name|u_int32_t
name|dtype
parameter_list|)
block|{
specifier|static
name|char
name|tlsb_line
index|[
literal|64
index|]
decl_stmt|;
switch|switch
condition|(
name|dtype
operator|&
name|TLDEV_DTYPE_MASK
condition|)
block|{
case|case
name|TLDEV_DTYPE_KFTHA
case|:
return|return
operator|(
literal|"KFTHA I/O interface"
operator|)
return|;
case|case
name|TLDEV_DTYPE_KFTIA
case|:
return|return
operator|(
literal|"KFTIA I/O interface"
operator|)
return|;
case|case
name|TLDEV_DTYPE_MS7CC
case|:
return|return
operator|(
literal|"MS7CC Memory Module"
operator|)
return|;
case|case
name|TLDEV_DTYPE_SCPU4
case|:
return|return
operator|(
literal|"Single CPU, 4MB cache"
operator|)
return|;
case|case
name|TLDEV_DTYPE_SCPU16
case|:
return|return
operator|(
literal|"Single CPU, 16MB cache"
operator|)
return|;
case|case
name|TLDEV_DTYPE_DCPU4
case|:
return|return
operator|(
literal|"Dual CPU, 4MB cache"
operator|)
return|;
case|case
name|TLDEV_DTYPE_DCPU16
case|:
return|return
operator|(
literal|"Dual CPU, 16MB cache"
operator|)
return|;
default|default:
name|bzero
argument_list|(
name|tlsb_line
argument_list|,
sizeof|sizeof
argument_list|(
name|tlsb_line
argument_list|)
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|tlsb_line
argument_list|,
sizeof|sizeof
argument_list|(
name|tlsb_line
argument_list|)
argument_list|,
literal|"unknown, dtype 0x%x"
argument_list|,
name|dtype
argument_list|)
expr_stmt|;
return|return
operator|(
name|tlsb_line
operator|)
return|;
block|}
comment|/* NOTREACHED */
block|}
end_function

end_unit

