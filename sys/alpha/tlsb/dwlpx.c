begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1998 Doug Rabson  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * Based very closely on NetBSD version-  *  * Copyright (c) 1997 by Matthew Jacob  * NASA AMES Research Center.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice immediately at the beginning of the file, without modification,  *    this list of conditions, and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/interrupt.h>
end_include

begin_include
include|#
directive|include
file|<machine/swiz.h>
end_include

begin_include
include|#
directive|include
file|<machine/intr.h>
end_include

begin_include
include|#
directive|include
file|<machine/intrcnt.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<machine/sgmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<alpha/tlsb/tlsbreg.h>
end_include

begin_include
include|#
directive|include
file|<alpha/tlsb/tlsbvar.h>
end_include

begin_include
include|#
directive|include
file|<alpha/tlsb/kftxxreg.h>
end_include

begin_include
include|#
directive|include
file|<alpha/tlsb/kftxxvar.h>
end_include

begin_include
include|#
directive|include
file|<alpha/tlsb/dwlpxreg.h>
end_include

begin_include
include|#
directive|include
file|<alpha/tlsb/dwlpxvar.h>
end_include

begin_include
include|#
directive|include
file|<alpha/pci/pcibus.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|"alphapci_if.h"
end_include

begin_include
include|#
directive|include
file|"pcib_if.h"
end_include

begin_decl_stmt
specifier|static
name|devclass_t
name|dwlpx_devclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_t
name|dwlpxs
index|[
name|DWLPX_NIONODE
index|]
index|[
name|DWLPX_NHOSE
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|KV
parameter_list|(
name|pa
parameter_list|)
value|((void *)ALPHA_PHYS_TO_K0SEG(pa))
end_define

begin_struct
struct|struct
name|dwlpx_softc
block|{
name|struct
name|dwlpx_softc
modifier|*
name|next
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
comment|/* backpointer */
name|u_int64_t
name|sysbase
decl_stmt|;
comment|/* shorthand */
name|vm_offset_t
name|dmem_base
decl_stmt|;
comment|/* dense memory */
name|vm_offset_t
name|smem_base
decl_stmt|;
comment|/* sparse memory */
name|vm_offset_t
name|io_base
decl_stmt|;
comment|/* sparse i/o */
name|struct
name|swiz_space
name|io_space
decl_stmt|;
comment|/* accessor for ports */
name|struct
name|swiz_space
name|mem_space
decl_stmt|;
comment|/* accessor for memory */
name|struct
name|rman
name|io_rman
decl_stmt|;
comment|/* resource manager for ports */
name|struct
name|rman
name|mem_rman
decl_stmt|;
comment|/* resource manager for memory */
name|int
name|bushose
decl_stmt|;
comment|/* our bus&& hose */
name|u_int
label|:
literal|26
operator|,
name|nhpc
operator|:
literal|2
operator|,
comment|/* how many HPCs */
name|dwlpb
operator|:
literal|1
operator|,
comment|/* this is a DWLPB */
name|sgmapsz
operator|:
literal|3
expr_stmt|;
comment|/* Scatter Gather map size */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|driver_intr_t
name|dwlpx_intr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int32_t
name|imaskcache
index|[
name|DWLPX_NIONODE
index|]
index|[
name|DWLPX_NHOSE
index|]
index|[
name|NHPC
index|]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|dwlpx_eintr
parameter_list|(
name|unsigned
name|long
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Direct-mapped window: 2G at 2G  */
end_comment

begin_define
define|#
directive|define
name|DWLPx_DIRECT_MAPPED_BASE
value|(2UL*1024UL*1024UL*1024UL)
end_define

begin_define
define|#
directive|define
name|DWLPx_DIRECT_MAPPED_SIZE
value|(2UL*1024UL*1024UL*1024UL)
end_define

begin_define
define|#
directive|define
name|DWLPx_DIRECT_MAPPED_WMASK
value|PCIA_WMASK_2G
end_define

begin_comment
comment|/*  * SGMAP window A: 256M at 1.75G or 1G at 1G  */
end_comment

begin_define
define|#
directive|define
name|DWLPx_SG_MAPPED_SIZE
parameter_list|(
name|x
parameter_list|)
value|((x) * PAGE_SIZE)
end_define

begin_function_decl
specifier|static
name|void
name|dwlpx_dma_init
parameter_list|(
name|struct
name|dwlpx_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|DWLPX_SOFTC
parameter_list|(
name|dev
parameter_list|)
value|(struct dwlpx_softc *) device_get_softc(dev)
end_define

begin_decl_stmt
specifier|static
name|struct
name|dwlpx_softc
modifier|*
name|dwlpx_root
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|dwlpx_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|device_t
name|child
decl_stmt|;
name|u_int32_t
name|ctl
decl_stmt|;
name|struct
name|dwlpx_softc
modifier|*
name|xc
decl_stmt|,
modifier|*
name|sc
init|=
name|DWLPX_SOFTC
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|ls
decl_stmt|;
name|int
name|io
decl_stmt|,
name|hose
decl_stmt|;
name|io
operator|=
name|kft_get_node
argument_list|(
name|dev
argument_list|)
operator|-
literal|4
expr_stmt|;
name|hose
operator|=
name|kft_get_hosenum
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bushose
operator|=
operator|(
name|io
operator|<<
literal|2
operator|)
operator||
name|hose
expr_stmt|;
if|if
condition|(
name|dwlpxs
index|[
name|io
index|]
index|[
name|hose
index|]
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"already attached\n"
argument_list|)
expr_stmt|;
return|return
name|EEXIST
return|;
block|}
if|if
condition|(
operator|(
name|xc
operator|=
name|dwlpx_root
operator|)
operator|==
name|NULL
condition|)
block|{
name|dwlpx_root
operator|=
name|sc
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|xc
operator|->
name|next
condition|)
name|xc
operator|=
name|xc
operator|->
name|next
expr_stmt|;
name|xc
operator|->
name|next
operator|=
name|sc
expr_stmt|;
block|}
name|sc
operator|->
name|dev
operator|=
name|dwlpxs
index|[
name|io
index|]
index|[
name|hose
index|]
operator|=
name|dev
expr_stmt|;
name|ls
operator|=
name|DWLPX_BASE
argument_list|(
name|io
operator|+
literal|4
argument_list|,
name|hose
argument_list|)
expr_stmt|;
for|for
control|(
name|sc
operator|->
name|nhpc
operator|=
literal|1
init|;
name|sc
operator|->
name|nhpc
operator|<
name|NHPC
condition|;
name|sc
operator|->
name|nhpc
operator|++
control|)
block|{
if|if
condition|(
name|badaddr
argument_list|(
name|KV
argument_list|(
name|PCIA_CTL
argument_list|(
name|sc
operator|->
name|nhpc
argument_list|)
operator|+
name|ls
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|ctl
argument_list|)
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|nhpc
operator|!=
name|NHPC
condition|)
block|{
name|REGVAL
argument_list|(
name|PCIA_ERR
argument_list|(
literal|0
argument_list|)
operator|+
name|ls
argument_list|)
operator|=
name|PCIA_ERR_ALLERR
expr_stmt|;
block|}
name|ctl
operator|=
name|REGVAL
argument_list|(
name|PCIA_PRESENT
operator|+
name|ls
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ctl
operator|>>
name|PCIA_PRESENT_REVSHIFT
operator|)
operator|&
name|PCIA_PRESENT_REVMASK
condition|)
block|{
name|sc
operator|->
name|dwlpb
operator|=
literal|1
expr_stmt|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"DWLPB PCI adapter"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"DWLPA PCI adapter"
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sgmapsz
operator|=
name|DWLPX_SG32K
expr_stmt|;
if|if
condition|(
name|device_get_unit
argument_list|(
name|dev
argument_list|)
operator|==
literal|0
condition|)
block|{
name|pci_init_resources
argument_list|()
expr_stmt|;
block|}
name|child
operator|=
name|device_add_child
argument_list|(
name|dev
argument_list|,
literal|"pci"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|device_set_ivars
argument_list|(
name|child
argument_list|,
operator|&
name|sc
operator|->
name|bushose
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dwlpx_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|dwlpx_softc
modifier|*
name|sc
init|=
name|DWLPX_SOFTC
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|device_t
name|parent
init|=
name|device_get_parent
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|vm_offset_t
name|regs
decl_stmt|;
name|u_int32_t
name|ctl
decl_stmt|;
name|int
name|i
decl_stmt|,
name|io
decl_stmt|,
name|hose
decl_stmt|;
name|void
modifier|*
name|intr
decl_stmt|;
name|io
operator|=
name|kft_get_node
argument_list|(
name|dev
argument_list|)
operator|-
literal|4
expr_stmt|;
name|hose
operator|=
name|kft_get_hosenum
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sysbase
operator|=
name|DWLPX_BASE
argument_list|(
name|io
operator|+
literal|4
argument_list|,
name|hose
argument_list|)
expr_stmt|;
name|regs
operator|=
operator|(
name|vm_offset_t
operator|)
name|KV
argument_list|(
name|sc
operator|->
name|sysbase
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dmem_base
operator|=
name|regs
operator|+
name|DWLPX_PCI_DENSE
expr_stmt|;
name|sc
operator|->
name|smem_base
operator|=
name|regs
operator|+
name|DWLPX_PCI_SPARSE
expr_stmt|;
name|sc
operator|->
name|io_base
operator|=
name|regs
operator|+
name|DWLPX_PCI_IOSPACE
expr_stmt|;
comment|/* 	 * Maybe initialise busspace_isa_io and busspace_isa_mem 	 * here. Does the 8200 actually have any ISA slots? 	 */
name|swiz_init_space
argument_list|(
operator|&
name|sc
operator|->
name|io_space
argument_list|,
name|sc
operator|->
name|io_base
argument_list|)
expr_stmt|;
name|swiz_init_space
argument_list|(
operator|&
name|sc
operator|->
name|mem_space
argument_list|,
name|sc
operator|->
name|smem_base
argument_list|)
expr_stmt|;
name|sc
operator|->
name|io_rman
operator|.
name|rm_start
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|io_rman
operator|.
name|rm_end
operator|=
operator|~
literal|0u
expr_stmt|;
name|sc
operator|->
name|io_rman
operator|.
name|rm_type
operator|=
name|RMAN_ARRAY
expr_stmt|;
name|sc
operator|->
name|io_rman
operator|.
name|rm_descr
operator|=
literal|"I/O ports"
expr_stmt|;
if|if
condition|(
name|rman_init
argument_list|(
operator|&
name|sc
operator|->
name|io_rman
argument_list|)
operator|||
name|rman_manage_region
argument_list|(
operator|&
name|sc
operator|->
name|io_rman
argument_list|,
literal|0x0
argument_list|,
operator|(
literal|1L
operator|<<
literal|32
operator|)
argument_list|)
condition|)
name|panic
argument_list|(
literal|"dwlpx_attach: io_rman"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mem_rman
operator|.
name|rm_start
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|mem_rman
operator|.
name|rm_end
operator|=
operator|~
literal|0u
expr_stmt|;
name|sc
operator|->
name|mem_rman
operator|.
name|rm_type
operator|=
name|RMAN_ARRAY
expr_stmt|;
name|sc
operator|->
name|mem_rman
operator|.
name|rm_descr
operator|=
literal|"I/O memory"
expr_stmt|;
if|if
condition|(
name|rman_init
argument_list|(
operator|&
name|sc
operator|->
name|mem_rman
argument_list|)
operator|||
name|rman_manage_region
argument_list|(
operator|&
name|sc
operator|->
name|mem_rman
argument_list|,
literal|0x0
argument_list|,
operator|(
literal|1L
operator|<<
literal|32
operator|)
argument_list|)
condition|)
name|panic
argument_list|(
literal|"dwlpx_attach: mem_rman"
argument_list|)
expr_stmt|;
comment|/* 	 * Set up interrupt stuff for this DWLPX. 	 * 	 * Note that all PCI interrupt pins are disabled at this time. 	 * 	 * Do this even for all HPCs- even for the 	 * nonexistent one on hose zero of a KFTIA. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NHPC
condition|;
name|i
operator|++
control|)
block|{
name|REGVAL
argument_list|(
name|PCIA_IMASK
argument_list|(
name|i
argument_list|)
operator|+
name|sc
operator|->
name|sysbase
argument_list|)
operator|=
name|DWLPX_IMASK_DFLT
expr_stmt|;
name|REGVAL
argument_list|(
name|PCIA_ERRVEC
argument_list|(
name|i
argument_list|)
operator|+
name|sc
operator|->
name|sysbase
argument_list|)
operator|=
name|DWLPX_ERRVEC
argument_list|(
name|io
argument_list|,
name|hose
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DWLPX_MAXDEV
condition|;
name|i
operator|++
control|)
block|{
name|u_int16_t
name|vec
decl_stmt|;
name|int
name|ss
decl_stmt|,
name|hpc
decl_stmt|;
name|vec
operator|=
name|DWLPX_MVEC
argument_list|(
name|io
argument_list|,
name|hose
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ss
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|4
condition|)
block|{
name|hpc
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|<
literal|8
condition|)
block|{
name|ss
operator|-=
literal|4
expr_stmt|;
name|hpc
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ss
operator|-=
literal|8
expr_stmt|;
name|hpc
operator|=
literal|2
expr_stmt|;
block|}
name|REGVAL
argument_list|(
name|PCIA_DEVVEC
argument_list|(
name|hpc
argument_list|,
name|ss
argument_list|,
literal|1
argument_list|)
operator|+
name|sc
operator|->
name|sysbase
argument_list|)
operator|=
name|vec
expr_stmt|;
name|REGVAL
argument_list|(
name|PCIA_DEVVEC
argument_list|(
name|hpc
argument_list|,
name|ss
argument_list|,
literal|2
argument_list|)
operator|+
name|sc
operator|->
name|sysbase
argument_list|)
operator|=
name|vec
expr_stmt|;
name|REGVAL
argument_list|(
name|PCIA_DEVVEC
argument_list|(
name|hpc
argument_list|,
name|ss
argument_list|,
literal|3
argument_list|)
operator|+
name|sc
operator|->
name|sysbase
argument_list|)
operator|=
name|vec
expr_stmt|;
name|REGVAL
argument_list|(
name|PCIA_DEVVEC
argument_list|(
name|hpc
argument_list|,
name|ss
argument_list|,
literal|4
argument_list|)
operator|+
name|sc
operator|->
name|sysbase
argument_list|)
operator|=
name|vec
expr_stmt|;
block|}
comment|/* 	 * Establish HAE values, as well as make sure of sanity elsewhere. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|nhpc
condition|;
name|i
operator|++
control|)
block|{
name|ctl
operator|=
name|REGVAL
argument_list|(
name|PCIA_CTL
argument_list|(
name|i
argument_list|)
operator|+
name|sc
operator|->
name|sysbase
argument_list|)
expr_stmt|;
name|ctl
operator|&=
literal|0x0fffffff
expr_stmt|;
name|ctl
operator|&=
operator|~
operator|(
name|PCIA_CTL_MHAE
argument_list|(
literal|0x1f
argument_list|)
operator||
name|PCIA_CTL_IHAE
argument_list|(
literal|0x1f
argument_list|)
operator|)
expr_stmt|;
comment|/* 		 * I originally also had it or'ing in 3, which makes no sense. 		 */
name|ctl
operator||=
name|PCIA_CTL_RMMENA
operator||
name|PCIA_CTL_RMMARB
expr_stmt|;
comment|/* 		 * Only valid if we're attached to a KFTIA or a KTHA. 		 */
name|ctl
operator||=
name|PCIA_CTL_3UP
expr_stmt|;
name|ctl
operator||=
name|PCIA_CTL_CUTENA
expr_stmt|;
comment|/* 		 * Fit in appropriate S/G Map Ram size. 		 */
if|if
condition|(
name|sc
operator|->
name|sgmapsz
operator|==
name|DWLPX_SG32K
condition|)
name|ctl
operator||=
name|PCIA_CTL_SG32K
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|sgmapsz
operator|==
name|DWLPX_SG128K
condition|)
name|ctl
operator||=
name|PCIA_CTL_SG128K
expr_stmt|;
else|else
name|ctl
operator||=
name|PCIA_CTL_SG32K
expr_stmt|;
name|REGVAL
argument_list|(
name|PCIA_CTL
argument_list|(
name|i
argument_list|)
operator|+
name|sc
operator|->
name|sysbase
argument_list|)
operator|=
name|ctl
expr_stmt|;
block|}
comment|/* 	 * Enable TBIT if required 	 */
if|if
condition|(
name|sc
operator|->
name|sgmapsz
operator|==
name|DWLPX_SG128K
condition|)
name|REGVAL
argument_list|(
name|PCIA_TBIT
operator|+
name|sc
operator|->
name|sysbase
argument_list|)
operator|=
literal|1
expr_stmt|;
name|alpha_mb
argument_list|()
expr_stmt|;
for|for
control|(
name|io
operator|=
literal|0
init|;
name|io
operator|<
name|DWLPX_NIONODE
condition|;
name|io
operator|++
control|)
block|{
for|for
control|(
name|hose
operator|=
literal|0
init|;
name|hose
operator|<
name|DWLPX_NHOSE
condition|;
name|hose
operator|++
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NHPC
condition|;
name|i
operator|++
control|)
block|{
name|imaskcache
index|[
name|io
index|]
index|[
name|hose
index|]
index|[
name|i
index|]
operator|=
name|DWLPX_IMASK_DFLT
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Set up DMA stuff here. 	 */
name|dwlpx_dma_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Register our interrupt service requirements with our parent. 	 */
name|i
operator|=
name|BUS_SETUP_INTR
argument_list|(
name|parent
argument_list|,
name|dev
argument_list|,
name|NULL
argument_list|,
name|INTR_TYPE_MISC
argument_list|,
name|dwlpx_intr
argument_list|,
literal|0
argument_list|,
operator|&
name|intr
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|bus_generic_attach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|dwlpx_enadis_intr
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|dwlpx_enadis_intr
parameter_list|(
name|int
name|vector
parameter_list|,
name|int
name|intpin
parameter_list|,
name|int
name|onoff
parameter_list|)
block|{
name|unsigned
name|long
name|paddr
decl_stmt|;
name|u_int32_t
name|val
decl_stmt|;
name|int
name|device
decl_stmt|,
name|ionode
decl_stmt|,
name|hose
decl_stmt|,
name|hpc
decl_stmt|;
name|ionode
operator|=
name|DWLPX_MVEC_IONODE
argument_list|(
name|vector
argument_list|)
expr_stmt|;
name|hose
operator|=
name|DWLPX_MVEC_HOSE
argument_list|(
name|vector
argument_list|)
expr_stmt|;
name|device
operator|=
name|DWLPX_MVEC_PCISLOT
argument_list|(
name|vector
argument_list|)
expr_stmt|;
name|paddr
operator|=
operator|(
literal|1LL
operator|<<
literal|39
operator|)
expr_stmt|;
name|paddr
operator||=
operator|(
name|unsigned
name|long
operator|)
name|ionode
operator|<<
literal|36
expr_stmt|;
name|paddr
operator||=
operator|(
name|unsigned
name|long
operator|)
name|hose
operator|<<
literal|34
expr_stmt|;
if|if
condition|(
name|device
operator|<
literal|4
condition|)
block|{
name|hpc
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|device
operator|<
literal|8
condition|)
block|{
name|hpc
operator|=
literal|1
expr_stmt|;
name|device
operator|-=
literal|4
expr_stmt|;
block|}
else|else
block|{
name|hpc
operator|=
literal|2
expr_stmt|;
name|device
operator|-=
literal|8
expr_stmt|;
block|}
name|intpin
operator|<<=
operator|(
name|device
operator|<<
literal|2
operator|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|icu_lock
argument_list|)
expr_stmt|;
name|val
operator|=
name|imaskcache
index|[
name|ionode
index|]
index|[
name|hose
index|]
index|[
name|hpc
index|]
expr_stmt|;
if|if
condition|(
name|onoff
condition|)
name|val
operator||=
name|intpin
expr_stmt|;
else|else
name|val
operator|&=
operator|~
name|intpin
expr_stmt|;
name|imaskcache
index|[
name|ionode
index|]
index|[
name|hose
index|]
index|[
name|hpc
index|]
operator|=
name|val
expr_stmt|;
name|REGVAL
argument_list|(
name|PCIA_IMASK
argument_list|(
name|hpc
argument_list|)
operator|+
name|paddr
argument_list|)
operator|=
name|val
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|icu_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|dwlpx_setup_intr
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|struct
name|resource
modifier|*
name|irq
parameter_list|,
name|int
name|flags
parameter_list|,
name|driver_intr_t
modifier|*
name|intr
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|void
modifier|*
modifier|*
name|cookiep
parameter_list|)
block|{
name|struct
name|dwlpx_softc
modifier|*
name|sc
init|=
name|DWLPX_SOFTC
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|slot
decl_stmt|,
name|ionode
decl_stmt|,
name|hose
decl_stmt|,
name|error
decl_stmt|,
name|vector
decl_stmt|,
name|intpin
decl_stmt|;
name|error
operator|=
name|rman_activate_resource
argument_list|(
name|irq
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|intpin
operator|=
name|pci_get_intpin
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|slot
operator|=
name|pci_get_slot
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|ionode
operator|=
name|sc
operator|->
name|bushose
operator|>>
literal|2
expr_stmt|;
name|hose
operator|=
name|sc
operator|->
name|bushose
operator|&
literal|0x3
expr_stmt|;
name|vector
operator|=
name|DWLPX_MVEC
argument_list|(
name|ionode
argument_list|,
name|hose
argument_list|,
name|slot
argument_list|)
expr_stmt|;
name|error
operator|=
name|alpha_setup_intr
argument_list|(
name|device_get_nameunit
argument_list|(
name|child
condition|?
name|child
else|:
name|dev
argument_list|)
argument_list|,
name|vector
argument_list|,
name|intr
argument_list|,
name|arg
argument_list|,
name|flags
argument_list|,
name|cookiep
argument_list|,
operator|&
name|intrcnt
index|[
name|INTRCNT_KN8AE_IRQ
index|]
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|dwlpx_enadis_intr
argument_list|(
name|vector
argument_list|,
name|intpin
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|child
argument_list|,
literal|"Node %d Hose %d Slot %d interrupting at TLSB "
literal|"vector 0x%x intpin %d\n"
argument_list|,
name|ionode
operator|+
literal|4
argument_list|,
name|hose
argument_list|,
name|slot
argument_list|,
name|vector
argument_list|,
name|intpin
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dwlpx_teardown_intr
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|struct
name|resource
modifier|*
name|irq
parameter_list|,
name|void
modifier|*
name|c
parameter_list|)
block|{
name|struct
name|dwlpx_softc
modifier|*
name|sc
init|=
name|DWLPX_SOFTC
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|slot
decl_stmt|,
name|ionode
decl_stmt|,
name|hose
decl_stmt|,
name|vector
decl_stmt|,
name|intpin
decl_stmt|;
name|intpin
operator|=
name|pci_get_intpin
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|slot
operator|=
name|pci_get_slot
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|ionode
operator|=
name|sc
operator|->
name|bushose
operator|>>
literal|2
expr_stmt|;
name|hose
operator|=
name|sc
operator|->
name|bushose
operator|&
literal|0x3
expr_stmt|;
name|vector
operator|=
name|DWLPX_MVEC
argument_list|(
name|ionode
argument_list|,
name|hose
argument_list|,
name|slot
argument_list|)
expr_stmt|;
name|dwlpx_enadis_intr
argument_list|(
name|vector
argument_list|,
name|intpin
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|alpha_teardown_intr
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
name|rman_deactivate_resource
argument_list|(
name|irq
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dwlpx_read_ivar
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|which
parameter_list|,
name|u_long
modifier|*
name|result
parameter_list|)
block|{
switch|switch
condition|(
name|which
condition|)
block|{
case|case
name|PCIB_IVAR_BUS
case|:
operator|*
name|result
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|ENOENT
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|dwlpx_cvt_dense
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|vm_offset_t
name|addr
parameter_list|)
block|{
name|struct
name|dwlpx_softc
modifier|*
name|sc
init|=
name|DWLPX_SOFTC
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|addr
operator|&=
literal|0xffffffffUL
expr_stmt|;
return|return
operator|(
name|void
operator|*
operator|)
name|KV
argument_list|(
name|addr
operator||
name|sc
operator|->
name|dmem_base
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|kobj_t
name|dwlpx_get_bustag
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|struct
name|dwlpx_softc
modifier|*
name|sc
init|=
name|DWLPX_SOFTC
argument_list|(
name|dev
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SYS_RES_IOPORT
case|:
return|return
operator|(
name|kobj_t
operator|)
operator|&
name|sc
operator|->
name|io_space
return|;
case|case
name|SYS_RES_MEMORY
case|:
return|return
operator|(
name|kobj_t
operator|)
operator|&
name|sc
operator|->
name|mem_space
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|rman
modifier|*
name|dwlpx_get_rman
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|struct
name|dwlpx_softc
modifier|*
name|sc
init|=
name|DWLPX_SOFTC
argument_list|(
name|dev
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SYS_RES_IOPORT
case|:
return|return
operator|&
name|sc
operator|->
name|io_rman
return|;
case|case
name|SYS_RES_MEMORY
case|:
return|return
operator|&
name|sc
operator|->
name|mem_rman
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dwlpx_maxslots
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
return|return
operator|(
name|DWLPX_MAXDEV
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int32_t
name|dwlpx_read_config
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|bus
parameter_list|,
name|int
name|slot
parameter_list|,
name|int
name|func
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|sz
parameter_list|)
block|{
name|struct
name|dwlpx_softc
modifier|*
name|sc
init|=
name|DWLPX_SOFTC
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u_int32_t
modifier|*
name|dp
decl_stmt|,
name|data
decl_stmt|,
name|rvp
decl_stmt|,
name|pci_idsel
decl_stmt|,
name|hpcdev
decl_stmt|;
name|unsigned
name|long
name|paddr
decl_stmt|;
name|int
name|hose
decl_stmt|,
name|ionode
decl_stmt|;
name|int
name|secondary
init|=
literal|0
decl_stmt|,
name|s
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
name|rvp
operator|=
name|data
operator|=
operator|~
literal|0
expr_stmt|;
name|ionode
operator|=
operator|(
operator|(
name|sc
operator|->
name|bushose
operator|>>
literal|2
operator|)
operator|&
literal|0x7
operator|)
expr_stmt|;
name|hose
operator|=
operator|(
name|sc
operator|->
name|bushose
operator|&
literal|0x3
operator|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|nhpc
operator|<
literal|1
condition|)
return|return
operator|(
name|data
operator|)
return|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|nhpc
operator|<
literal|2
operator|&&
name|slot
operator|>=
literal|4
condition|)
return|return
operator|(
name|data
operator|)
return|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|nhpc
operator|<
literal|3
operator|&&
name|slot
operator|>=
literal|8
condition|)
return|return
operator|(
name|data
operator|)
return|;
elseif|else
if|if
condition|(
name|slot
operator|>=
name|DWLPX_MAXDEV
condition|)
return|return
operator|(
name|data
operator|)
return|;
name|hpcdev
operator|=
name|slot
operator|>>
literal|2
expr_stmt|;
name|pci_idsel
operator|=
operator|(
literal|1
operator|<<
operator|(
operator|(
name|slot
operator|&
literal|0x3
operator|)
operator|+
literal|2
operator|)
operator|)
expr_stmt|;
name|paddr
operator|=
operator|(
name|hpcdev
operator|<<
literal|22
operator|)
operator||
operator|(
name|pci_idsel
operator|<<
literal|16
operator|)
operator||
operator|(
name|func
operator|<<
literal|13
operator|)
expr_stmt|;
if|if
condition|(
name|secondary
condition|)
block|{
name|paddr
operator|&=
literal|0x1fffff
expr_stmt|;
name|paddr
operator||=
operator|(
name|secondary
operator|<<
literal|21
operator|)
expr_stmt|;
if|#
directive|if
literal|0
block|printf("read secondary %d reg %x (paddr %lx)", 		    secondary, offset, tag);
endif|#
directive|endif
name|alpha_pal_draina
argument_list|()
expr_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
comment|/* 		 * Set up HPCs for type 1 cycles. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|nhpc
condition|;
name|i
operator|++
control|)
block|{
name|rvp
operator|=
name|REGVAL
argument_list|(
name|PCIA_CTL
argument_list|(
name|i
argument_list|)
operator|+
name|sc
operator|->
name|sysbase
argument_list|)
operator||
name|PCIA_CTL_T1CYC
expr_stmt|;
name|alpha_mb
argument_list|()
expr_stmt|;
name|REGVAL
argument_list|(
name|PCIA_CTL
argument_list|(
name|i
argument_list|)
operator|+
name|sc
operator|->
name|sysbase
argument_list|)
operator|=
name|rvp
expr_stmt|;
name|alpha_mb
argument_list|()
expr_stmt|;
block|}
block|}
name|paddr
operator||=
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
operator|(
name|off
operator|>>
literal|2
operator|)
operator|<<
literal|7
argument_list|)
operator|)
expr_stmt|;
name|paddr
operator||=
operator|(
operator|(
name|sz
operator|-
literal|1
operator|)
operator|<<
literal|3
operator|)
expr_stmt|;
name|paddr
operator||=
name|DWLPX_PCI_CONF
expr_stmt|;
name|paddr
operator||=
operator|(
operator|(
name|unsigned
name|long
operator|)
name|hose
operator|)
operator|<<
literal|34
expr_stmt|;
name|paddr
operator||=
operator|(
operator|(
name|unsigned
name|long
operator|)
name|ionode
operator|)
operator|<<
literal|36
expr_stmt|;
name|paddr
operator||=
literal|1L
operator|<<
literal|39
expr_stmt|;
name|dp
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
name|KV
argument_list|(
name|paddr
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|printf("CFGREAD %d.%d.%d.%d.%d.%d.%d -> paddr 0x%lx", ionode+4, hose, bus, slot, func, off, sz, paddr);
endif|#
directive|endif
if|if
condition|(
name|badaddr
argument_list|(
name|dp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dp
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|data
operator|=
operator|*
name|dp
expr_stmt|;
block|}
if|if
condition|(
name|secondary
condition|)
block|{
name|alpha_pal_draina
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|nhpc
condition|;
name|i
operator|++
control|)
block|{
name|rvp
operator|=
name|REGVAL
argument_list|(
name|PCIA_CTL
argument_list|(
name|i
argument_list|)
operator|+
name|sc
operator|->
name|sysbase
argument_list|)
operator|&
operator|~
name|PCIA_CTL_T1CYC
expr_stmt|;
name|alpha_mb
argument_list|()
expr_stmt|;
name|REGVAL
argument_list|(
name|PCIA_CTL
argument_list|(
name|i
argument_list|)
operator|+
name|sc
operator|->
name|sysbase
argument_list|)
operator|=
name|rvp
expr_stmt|;
name|alpha_mb
argument_list|()
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|data
operator|!=
operator|~
literal|0
condition|)
block|{
if|if
condition|(
name|sz
operator|==
literal|1
condition|)
block|{
name|rvp
operator|=
name|SPARSE_BYTE_EXTRACT
argument_list|(
name|off
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sz
operator|==
literal|2
condition|)
block|{
name|rvp
operator|=
name|SPARSE_WORD_EXTRACT
argument_list|(
name|off
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rvp
operator|=
name|data
expr_stmt|;
block|}
block|}
else|else
block|{
name|rvp
operator|=
name|data
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|printf(" data 0x%x -> 0x%x\n", data, rvp);
endif|#
directive|endif
return|return
operator|(
name|rvp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dwlpx_write_config
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|bus
parameter_list|,
name|int
name|slot
parameter_list|,
name|int
name|func
parameter_list|,
name|int
name|off
parameter_list|,
name|u_int32_t
name|data
parameter_list|,
name|int
name|sz
parameter_list|)
block|{
name|struct
name|dwlpx_softc
modifier|*
name|sc
init|=
name|DWLPX_SOFTC
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|hose
decl_stmt|,
name|ionode
decl_stmt|;
name|int
name|secondary
init|=
literal|0
decl_stmt|,
name|s
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
name|u_int32_t
modifier|*
name|dp
decl_stmt|,
name|rvp
decl_stmt|,
name|pci_idsel
decl_stmt|,
name|hpcdev
decl_stmt|;
name|unsigned
name|long
name|paddr
decl_stmt|;
name|ionode
operator|=
operator|(
operator|(
name|sc
operator|->
name|bushose
operator|>>
literal|2
operator|)
operator|&
literal|0x7
operator|)
expr_stmt|;
name|hose
operator|=
operator|(
name|sc
operator|->
name|bushose
operator|&
literal|0x3
operator|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|nhpc
operator|<
literal|1
condition|)
return|return;
elseif|else
if|if
condition|(
name|sc
operator|->
name|nhpc
operator|<
literal|2
operator|&&
name|slot
operator|>=
literal|4
condition|)
return|return;
elseif|else
if|if
condition|(
name|sc
operator|->
name|nhpc
operator|<
literal|3
operator|&&
name|slot
operator|>=
literal|8
condition|)
return|return;
elseif|else
if|if
condition|(
name|slot
operator|>=
name|DWLPX_MAXDEV
condition|)
return|return;
name|hpcdev
operator|=
name|slot
operator|>>
literal|2
expr_stmt|;
name|pci_idsel
operator|=
operator|(
literal|1
operator|<<
operator|(
operator|(
name|slot
operator|&
literal|0x3
operator|)
operator|+
literal|2
operator|)
operator|)
expr_stmt|;
name|paddr
operator|=
operator|(
name|hpcdev
operator|<<
literal|22
operator|)
operator||
operator|(
name|pci_idsel
operator|<<
literal|16
operator|)
operator||
operator|(
name|func
operator|<<
literal|13
operator|)
expr_stmt|;
if|if
condition|(
name|secondary
condition|)
block|{
name|paddr
operator|&=
literal|0x1fffff
expr_stmt|;
name|paddr
operator||=
operator|(
name|secondary
operator|<<
literal|21
operator|)
expr_stmt|;
if|#
directive|if
literal|0
block|printf("write secondary %d reg %x (paddr %lx)", 		    secondary, offset, tag);
endif|#
directive|endif
name|alpha_pal_draina
argument_list|()
expr_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
comment|/* 		 * Set up HPCs for type 1 cycles. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|nhpc
condition|;
name|i
operator|++
control|)
block|{
name|rvp
operator|=
name|REGVAL
argument_list|(
name|PCIA_CTL
argument_list|(
name|i
argument_list|)
operator|+
name|sc
operator|->
name|sysbase
argument_list|)
operator||
name|PCIA_CTL_T1CYC
expr_stmt|;
name|alpha_mb
argument_list|()
expr_stmt|;
name|REGVAL
argument_list|(
name|PCIA_CTL
argument_list|(
name|i
argument_list|)
operator|+
name|sc
operator|->
name|sysbase
argument_list|)
operator|=
name|rvp
expr_stmt|;
name|alpha_mb
argument_list|()
expr_stmt|;
block|}
block|}
name|paddr
operator||=
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
operator|(
name|off
operator|>>
literal|2
operator|)
operator|<<
literal|7
argument_list|)
operator|)
expr_stmt|;
name|paddr
operator||=
operator|(
operator|(
name|sz
operator|-
literal|1
operator|)
operator|<<
literal|3
operator|)
expr_stmt|;
name|paddr
operator||=
name|DWLPX_PCI_CONF
expr_stmt|;
name|paddr
operator||=
operator|(
operator|(
name|unsigned
name|long
operator|)
name|hose
operator|)
operator|<<
literal|34
expr_stmt|;
name|paddr
operator||=
operator|(
operator|(
name|unsigned
name|long
operator|)
name|ionode
operator|)
operator|<<
literal|36
expr_stmt|;
name|paddr
operator||=
literal|1L
operator|<<
literal|39
expr_stmt|;
name|dp
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
name|KV
argument_list|(
name|paddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|badaddr
argument_list|(
name|dp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dp
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|u_int32_t
name|new_data
decl_stmt|;
if|if
condition|(
name|sz
operator|==
literal|1
condition|)
block|{
name|new_data
operator|=
name|SPARSE_BYTE_INSERT
argument_list|(
name|off
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sz
operator|==
literal|2
condition|)
block|{
name|new_data
operator|=
name|SPARSE_WORD_INSERT
argument_list|(
name|off
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|new_data
operator|=
name|data
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|printf("CFGWRITE %d.%d.%d.%d.%d.%d.%d paddr 0x%lx data 0x%x -> 0x%x\n", ionode+4, hose, bus, slot, func, off, sz, paddr, data, new_data);
endif|#
directive|endif
operator|*
name|dp
operator|=
name|new_data
expr_stmt|;
block|}
if|if
condition|(
name|secondary
condition|)
block|{
name|alpha_pal_draina
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|nhpc
condition|;
name|i
operator|++
control|)
block|{
name|rvp
operator|=
name|REGVAL
argument_list|(
name|PCIA_CTL
argument_list|(
name|i
argument_list|)
operator|+
name|sc
operator|->
name|sysbase
argument_list|)
operator|&
operator|~
name|PCIA_CTL_T1CYC
expr_stmt|;
name|alpha_mb
argument_list|()
expr_stmt|;
name|REGVAL
argument_list|(
name|PCIA_CTL
argument_list|(
name|i
argument_list|)
operator|+
name|sc
operator|->
name|sysbase
argument_list|)
operator|=
name|rvp
expr_stmt|;
name|alpha_mb
argument_list|()
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dwlpx_dma_init
parameter_list|(
name|struct
name|dwlpx_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tbl
decl_stmt|,
name|sgwmask
decl_stmt|,
name|sgwbase
decl_stmt|,
name|sgwend
decl_stmt|;
name|int
name|i
decl_stmt|,
name|lim
decl_stmt|;
comment|/* 	 * Determine size of Window C based on the amount of SGMAP 	 * page table SRAM available. 	 */
if|if
condition|(
name|sc
operator|->
name|sgmapsz
operator|==
name|DWLPX_SG128K
condition|)
block|{
name|lim
operator|=
literal|128
operator|*
literal|1024
expr_stmt|;
name|sgwmask
operator|=
name|PCIA_WMASK_1G
expr_stmt|;
name|sgwbase
operator|=
literal|1UL
operator|*
literal|1024UL
operator|*
literal|1024UL
operator|*
literal|1024UL
expr_stmt|;
block|}
else|else
block|{
name|lim
operator|=
literal|32
operator|*
literal|1024
expr_stmt|;
name|sgwmask
operator|=
name|PCIA_WMASK_256M
expr_stmt|;
name|sgwbase
operator|=
literal|1UL
operator|*
literal|1024UL
operator|*
literal|1024UL
operator|*
literal|1024UL
operator|+
literal|3UL
operator|*
literal|256UL
operator|*
literal|1024UL
operator|*
literal|1024UL
expr_stmt|;
block|}
name|sgwend
operator|=
name|sgwbase
operator|+
operator|(
name|lim
operator|*
literal|8192
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* 	 * A few notes about SGMAP-mapped DMA on the DWLPx: 	 * 	 * The DWLPx has PCIA-resident SRAM that is used for 	 * the SGMAP page table; there is no TLB.  The DWLPA 	 * has room for 32K entries, yielding a total of 256M 	 * of sgva space.  The DWLPB has 32K entries or 128K 	 * entries, depending on TBIT, yielding either 256M or 	 * 1G of sgva space. 	 */
comment|/* 	 * Initialize the page table. 	 */
name|tbl
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
name|ALPHA_PHYS_TO_K0SEG
argument_list|(
name|PCIA_SGMAP_PT
operator|+
name|sc
operator|->
name|sysbase
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lim
condition|;
name|i
operator|++
control|)
name|tbl
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
comment|/* XXX NOT DONE YET XXX */
comment|/* 	 * Initialize the SGMAP for window C: 	 * 	 *	Size: 256M or 1GB 	 *	Window base: 1GB 	 *	SGVA base: 0 	 */
block|chipset.sgmap = sgmap_map_create(sgwbase, sgwend, dwlpx_sgmap_map, tbl);
endif|#
directive|endif
comment|/* 	 * Set up DMA windows for this DWLPx. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|nhpc
condition|;
name|i
operator|++
control|)
block|{
name|REGVAL
argument_list|(
name|PCIA_WMASK_A
argument_list|(
name|i
argument_list|)
operator|+
name|sc
operator|->
name|sysbase
argument_list|)
operator|=
name|DWLPx_DIRECT_MAPPED_WMASK
expr_stmt|;
name|REGVAL
argument_list|(
name|PCIA_TBASE_A
argument_list|(
name|i
argument_list|)
operator|+
name|sc
operator|->
name|sysbase
argument_list|)
operator|=
literal|0
expr_stmt|;
name|REGVAL
argument_list|(
name|PCIA_WBASE_A
argument_list|(
name|i
argument_list|)
operator|+
name|sc
operator|->
name|sysbase
argument_list|)
operator|=
name|DWLPx_DIRECT_MAPPED_BASE
operator||
name|PCIA_WBASE_W_EN
expr_stmt|;
name|REGVAL
argument_list|(
name|PCIA_WMASK_B
argument_list|(
name|i
argument_list|)
operator|+
name|sc
operator|->
name|sysbase
argument_list|)
operator|=
literal|0
expr_stmt|;
name|REGVAL
argument_list|(
name|PCIA_TBASE_B
argument_list|(
name|i
argument_list|)
operator|+
name|sc
operator|->
name|sysbase
argument_list|)
operator|=
literal|0
expr_stmt|;
name|REGVAL
argument_list|(
name|PCIA_WBASE_B
argument_list|(
name|i
argument_list|)
operator|+
name|sc
operator|->
name|sysbase
argument_list|)
operator|=
literal|0
expr_stmt|;
name|REGVAL
argument_list|(
name|PCIA_WMASK_C
argument_list|(
name|i
argument_list|)
operator|+
name|sc
operator|->
name|sysbase
argument_list|)
operator|=
name|sgwmask
expr_stmt|;
name|REGVAL
argument_list|(
name|PCIA_TBASE_C
argument_list|(
name|i
argument_list|)
operator|+
name|sc
operator|->
name|sysbase
argument_list|)
operator|=
literal|0
expr_stmt|;
name|REGVAL
argument_list|(
name|PCIA_WBASE_C
argument_list|(
name|i
argument_list|)
operator|+
name|sc
operator|->
name|sysbase
argument_list|)
operator|=
name|sgwbase
operator||
name|PCIA_WBASE_W_EN
operator||
name|PCIA_WBASE_SG_EN
expr_stmt|;
block|}
name|alpha_mb
argument_list|()
expr_stmt|;
comment|/* XXX XXX BEGIN XXX XXX */
block|{
comment|/* XXX */
name|alpha_XXX_dmamap_or
operator|=
name|DWLPx_DIRECT_MAPPED_BASE
expr_stmt|;
comment|/* XXX */
block|}
comment|/* XXX */
comment|/* XXX XXX END XXX XXX */
block|}
end_function

begin_comment
comment|/*  */
end_comment

begin_function
specifier|static
name|void
name|dwlpx_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|unsigned
name|long
name|vec
init|=
operator|(
name|unsigned
name|long
operator|)
name|arg
decl_stmt|;
if|if
condition|(
operator|(
name|vec
operator|&
name|DWLPX_VEC_EMARK
operator|)
operator|!=
literal|0
condition|)
block|{
name|dwlpx_eintr
argument_list|(
name|vec
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|vec
operator|&
name|DWLPX_VEC_MARK
operator|)
operator|==
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"dwlpx_intr: bad vector %p"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|alpha_dispatch_intr
argument_list|(
name|NULL
argument_list|,
name|vec
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dwlpx_eintr
parameter_list|(
name|unsigned
name|long
name|vec
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|;
name|struct
name|dwlpx_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|ionode
decl_stmt|,
name|hosenum
decl_stmt|,
name|i
decl_stmt|;
struct|struct
block|{
name|u_int32_t
name|err
decl_stmt|;
name|u_int32_t
name|addr
decl_stmt|;
block|}
name|hpcs
index|[
name|NHPC
index|]
struct|;
name|ionode
operator|=
operator|(
name|vec
operator|>>
literal|8
operator|)
operator|&
literal|0xf
expr_stmt|;
name|hosenum
operator|=
operator|(
name|vec
operator|>>
literal|4
operator|)
operator|&
literal|0x7
expr_stmt|;
if|if
condition|(
name|ionode
operator|>=
name|DWLPX_NIONODE
operator|||
name|hosenum
operator|>=
name|DWLPX_NHOSE
condition|)
block|{
name|panic
argument_list|(
literal|"dwlpx_iointr: mangled vector 0x%lx"
argument_list|,
name|vec
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|dev
operator|=
name|dwlpxs
index|[
name|ionode
index|]
index|[
name|hosenum
index|]
expr_stmt|;
name|sc
operator|=
name|DWLPX_SOFTC
argument_list|(
name|dev
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|nhpc
condition|;
name|i
operator|++
control|)
block|{
name|hpcs
index|[
name|i
index|]
operator|.
name|err
operator|=
name|REGVAL
argument_list|(
name|PCIA_ERR
argument_list|(
name|i
argument_list|)
operator|+
name|sc
operator|->
name|sysbase
argument_list|)
expr_stmt|;
name|hpcs
index|[
name|i
index|]
operator|.
name|addr
operator|=
name|REGVAL
argument_list|(
name|PCIA_FADR
argument_list|(
name|i
argument_list|)
operator|+
name|sc
operator|->
name|sysbase
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%s: node %d hose %d error interrupt\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|ionode
operator|+
literal|4
argument_list|,
name|hosenum
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|nhpc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|hpcs
index|[
name|i
index|]
operator|.
name|err
operator|&
name|PCIA_ERR_ERROR
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|printf
argument_list|(
literal|"\tHPC %d: ERR=0x%08x; DMA %s Memory, "
literal|"Failing Address 0x%x\n"
argument_list|,
name|i
argument_list|,
name|hpcs
index|[
name|i
index|]
operator|.
name|err
argument_list|,
name|hpcs
index|[
name|i
index|]
operator|.
name|addr
operator|&
literal|0x1
condition|?
literal|"write to"
else|:
literal|"read from"
argument_list|,
name|hpcs
index|[
name|i
index|]
operator|.
name|addr
operator|&
operator|~
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|hpcs
index|[
name|i
index|]
operator|.
name|err
operator|&
name|PCIA_ERR_SERR_L
condition|)
name|printf
argument_list|(
literal|"\t       PCI device asserted SERR_L\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hpcs
index|[
name|i
index|]
operator|.
name|err
operator|&
name|PCIA_ERR_ILAT
condition|)
name|printf
argument_list|(
literal|"\t       Incremental Latency Exceeded\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hpcs
index|[
name|i
index|]
operator|.
name|err
operator|&
name|PCIA_ERR_SGPRTY
condition|)
name|printf
argument_list|(
literal|"\t       CPU access of SG RAM Parity Error\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hpcs
index|[
name|i
index|]
operator|.
name|err
operator|&
name|PCIA_ERR_ILLCSR
condition|)
name|printf
argument_list|(
literal|"\t       Illegal CSR Address Error\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hpcs
index|[
name|i
index|]
operator|.
name|err
operator|&
name|PCIA_ERR_PCINXM
condition|)
name|printf
argument_list|(
literal|"\t       Nonexistent PCI Address Error\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hpcs
index|[
name|i
index|]
operator|.
name|err
operator|&
name|PCIA_ERR_DSCERR
condition|)
name|printf
argument_list|(
literal|"\t       PCI Target Disconnect Error\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hpcs
index|[
name|i
index|]
operator|.
name|err
operator|&
name|PCIA_ERR_ABRT
condition|)
name|printf
argument_list|(
literal|"\t       PCI Target Abort Error\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hpcs
index|[
name|i
index|]
operator|.
name|err
operator|&
name|PCIA_ERR_WPRTY
condition|)
name|printf
argument_list|(
literal|"\t       PCI Write Parity Error\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hpcs
index|[
name|i
index|]
operator|.
name|err
operator|&
name|PCIA_ERR_DPERR
condition|)
name|printf
argument_list|(
literal|"\t       PCI Data Parity Error\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hpcs
index|[
name|i
index|]
operator|.
name|err
operator|&
name|PCIA_ERR_APERR
condition|)
name|printf
argument_list|(
literal|"\t       PCI Address Parity Error\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hpcs
index|[
name|i
index|]
operator|.
name|err
operator|&
name|PCIA_ERR_DFLT
condition|)
name|printf
argument_list|(
literal|"\t       SG Map RAM Invalid Entry Error\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hpcs
index|[
name|i
index|]
operator|.
name|err
operator|&
name|PCIA_ERR_DPRTY
condition|)
name|printf
argument_list|(
literal|"\t       DMA access of SG RAM Parity Error\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hpcs
index|[
name|i
index|]
operator|.
name|err
operator|&
name|PCIA_ERR_DRPERR
condition|)
name|printf
argument_list|(
literal|"\t       DMA Read Return Parity Error\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hpcs
index|[
name|i
index|]
operator|.
name|err
operator|&
name|PCIA_ERR_MABRT
condition|)
name|printf
argument_list|(
literal|"\t       PCI Master Abort Error\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hpcs
index|[
name|i
index|]
operator|.
name|err
operator|&
name|PCIA_ERR_CPRTY
condition|)
name|printf
argument_list|(
literal|"\t       CSR Parity Error\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hpcs
index|[
name|i
index|]
operator|.
name|err
operator|&
name|PCIA_ERR_COVR
condition|)
name|printf
argument_list|(
literal|"\t       CSR Overrun Error\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hpcs
index|[
name|i
index|]
operator|.
name|err
operator|&
name|PCIA_ERR_MBPERR
condition|)
name|printf
argument_list|(
literal|"\t       Mailbox Parity Error\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hpcs
index|[
name|i
index|]
operator|.
name|err
operator|&
name|PCIA_ERR_MBILI
condition|)
name|printf
argument_list|(
literal|"\t       Mailbox Illegal Length Error\n"
argument_list|)
expr_stmt|;
name|REGVAL
argument_list|(
name|PCIA_ERR
argument_list|(
name|i
argument_list|)
operator|+
name|sc
operator|->
name|sysbase
argument_list|)
operator|=
name|hpcs
index|[
name|i
index|]
operator|.
name|err
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|dwlpx_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|dwlpx_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|dwlpx_attach
argument_list|)
block|,
comment|/* Bus interface */
name|DEVMETHOD
argument_list|(
name|bus_print_child
argument_list|,
name|bus_generic_print_child
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_read_ivar
argument_list|,
name|dwlpx_read_ivar
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_setup_intr
argument_list|,
name|dwlpx_setup_intr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_teardown_intr
argument_list|,
name|dwlpx_teardown_intr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_alloc_resource
argument_list|,
name|alpha_pci_alloc_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_release_resource
argument_list|,
name|pci_release_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_activate_resource
argument_list|,
name|pci_activate_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_deactivate_resource
argument_list|,
name|pci_deactivate_resource
argument_list|)
block|,
comment|/* alphapci interface */
name|DEVMETHOD
argument_list|(
name|alphapci_cvt_dense
argument_list|,
name|dwlpx_cvt_dense
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|alphapci_get_bustag
argument_list|,
name|dwlpx_get_bustag
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|alphapci_get_rman
argument_list|,
name|dwlpx_get_rman
argument_list|)
block|,
comment|/* pcib interface */
name|DEVMETHOD
argument_list|(
name|pcib_maxslots
argument_list|,
name|dwlpx_maxslots
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pcib_read_config
argument_list|,
name|dwlpx_read_config
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pcib_write_config
argument_list|,
name|dwlpx_write_config
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pcib_route_interrupt
argument_list|,
name|alpha_pci_route_interrupt
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|dwlpx_driver
init|=
block|{
literal|"pcib"
block|,
name|dwlpx_methods
block|,
expr|sizeof
operator|(
expr|struct
name|dwlpx_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|pcib
argument_list|,
name|kft
argument_list|,
name|dwlpx_driver
argument_list|,
name|dwlpx_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

