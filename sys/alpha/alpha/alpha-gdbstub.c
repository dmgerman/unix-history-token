begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/****************************************************************************  		THIS SOFTWARE IS NOT COPYRIGHTED     HP offers the following for use in the public domain.  HP makes no    warranty with regard to the software or its performance and the    user accepts the software "AS IS" with all faults.     HP DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED, WITH REGARD    TO THIS SOFTWARE INCLUDING BUT NOT LIMITED TO THE WARRANTIES    OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  ****************************************************************************/
end_comment

begin_comment
comment|/****************************************************************************  *  Header: remcom.c,v 1.34 91/03/09 12:29:49 glenne Exp $  *  *  Module name: remcom.c $  *  Revision: 1.34 $  *  Date: 91/03/09 12:29:49 $  *  Contributor:     Lake Stevens Instrument Division$  *  *  Description:     low level support for gdb debugger. $  *  *  Considerations:  only works on target hardware $  *  *  Written by:      Glenn Engel $  *  ModuleState:     Experimental $  *  *  NOTES:           See Below $  *  *  Modified for FreeBSD by Stu Grossman.  *  *  To enable debugger support, two things need to happen.  One, a  *  call to set_debug_traps() is necessary in order to allow any breakpoints  *  or error conditions to be properly intercepted and reported to gdb.  *  Two, a breakpoint needs to be generated to begin communication.  This  *  is most easily accomplished by a call to breakpoint().  Breakpoint()  *  simulates a breakpoint by executing a trap #1.  *  *  The external function exceptionHandler() is  *  used to attach a specific handler to a specific 386 vector number.  *  It should use the same privilege level it runs at.  It should  *  install it as an interrupt gate so that interrupts are masked  *  while the handler runs.  *  Also, need to assign exceptionHook and oldExceptionHook.  *  *  Because gdb will sometimes write to the stack area to execute function  *  calls, this program cannot rely on using the supervisor stack so it  *  uses its own stack area reserved in the int array remcomStack.  *  *************  *  *    The following gdb commands are supported:  *  * command          function                               Return value  *  *    g             return the value of the CPU registers  hex data or ENN  *    G             set the value of the CPU registers     OK or ENN  *  *    mAA..AA,LLLL  Read LLLL bytes at address AA..AA      hex data or ENN  *    MAA..AA,LLLL: Write LLLL bytes at address AA.AA      OK or ENN  *  *    c             Resume at current address              SNN   ( signal NN)  *    cAA..AA       Continue at address AA..AA             SNN  *  *    s             Step one instruction                   SNN  *    sAA..AA       Step one instruction from AA..AA       SNN  *  *    k             kill  *  *    ?             What was the last sigval ?             SNN   (signal NN)  *  *    D             detach                                 OK  *  * All commands and responses are sent with a packet which includes a  * checksum.  A packet consists of  *  * $<packet info>#<checksum>.  *  * where  *<packet info> ::<characters representing the command or response>  *<checksum>    ::< two hex digits computed as modulo 256 sum of<packetinfo>>  *  * When a packet is received, it is first acknowledged with either '+' or '-'.  * '+' indicates a successful transfer.  '-' indicates a failed transfer.  *  * Example:  *  * Host:                  Reply:  * $m0,10#2a               +$00010203040506070809101112131415#42  *  ****************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/reboot.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/cons.h>
end_include

begin_include
include|#
directive|include
file|<machine/reg.h>
end_include

begin_include
include|#
directive|include
file|<ddb/ddb.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_comment
comment|/* #include "sio.h" */
end_comment

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_include
include|#
directive|include
file|"sio.h"
end_include

begin_if
if|#
directive|if
name|NSIO
operator|==
literal|0
end_if

begin_function
name|void
name|gdb_handle_exception
parameter_list|(
name|db_regs_t
modifier|*
name|raw_regs
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|code
parameter_list|)
block|{ }
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/************************************************************************/
end_comment

begin_function_decl
name|void
name|gdb_handle_exception
parameter_list|(
name|db_regs_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|jmp_buf
name|db_jmpbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/************************************************************************/
end_comment

begin_comment
comment|/* BUFMAX defines the maximum number of characters in inbound/outbound buffers*/
end_comment

begin_comment
comment|/* at least NUMREGBYTES*2 are needed for register packets */
end_comment

begin_define
define|#
directive|define
name|BUFMAX
value|1500
end_define

begin_comment
comment|/* Create private copies of common functions used by the stub.  This prevents    nasty interactions between app code and the stub (for instance if user steps    into strlen, etc..) */
end_comment

begin_comment
comment|/* XXX this is fairly bogus.  strlen() and strcpy() should be reentrant,    and are reentrant under FreeBSD.  In any case, our versions should not    be named the same as the standard versions, so that the address `strlen'    is unambiguous...  */
end_comment

begin_function
specifier|static
name|int
name|strlen
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|s1
init|=
name|s
decl_stmt|;
while|while
condition|(
operator|*
name|s1
operator|++
operator|!=
literal|'\000'
condition|)
empty_stmt|;
return|return
name|s1
operator|-
name|s
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|strcpy
parameter_list|(
name|char
modifier|*
name|dst
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|)
block|{
name|char
modifier|*
name|retval
init|=
name|dst
decl_stmt|;
while|while
condition|(
operator|(
operator|*
name|dst
operator|++
operator|=
operator|*
name|src
operator|++
operator|)
operator|!=
literal|'\000'
condition|)
empty_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* XXX sio always uses its major with minor 0 no matter what we specify.  */
end_comment

begin_define
define|#
directive|define
name|REMOTE_DEV
value|0
end_define

begin_function
specifier|static
name|int
name|putDebugChar
parameter_list|(
name|int
name|c
parameter_list|)
comment|/* write a single character      */
block|{
if|#
directive|if
name|NSIO
operator|>
literal|0
name|siogdbputc
argument_list|(
name|c
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|getDebugChar
parameter_list|(
name|void
parameter_list|)
comment|/* read and return a single char */
block|{
if|#
directive|if
name|NSIO
operator|>
literal|0
return|return
name|siogdbgetc
argument_list|()
return|;
else|#
directive|else
return|return
literal|0
return|;
endif|#
directive|endif
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
name|hexchars
index|[]
init|=
literal|"0123456789abcdef"
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|hex
parameter_list|(
name|char
name|ch
parameter_list|)
block|{
if|if
condition|(
operator|(
name|ch
operator|>=
literal|'a'
operator|)
operator|&&
operator|(
name|ch
operator|<=
literal|'f'
operator|)
condition|)
return|return
operator|(
name|ch
operator|-
literal|'a'
operator|+
literal|10
operator|)
return|;
if|if
condition|(
operator|(
name|ch
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
name|ch
operator|<=
literal|'9'
operator|)
condition|)
return|return
operator|(
name|ch
operator|-
literal|'0'
operator|)
return|;
if|if
condition|(
operator|(
name|ch
operator|>=
literal|'A'
operator|)
operator|&&
operator|(
name|ch
operator|<=
literal|'F'
operator|)
condition|)
return|return
operator|(
name|ch
operator|-
literal|'A'
operator|+
literal|10
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* scan for the sequence $<data>#<checksum>     */
end_comment

begin_function
specifier|static
name|void
name|getpacket
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|)
block|{
name|unsigned
name|char
name|checksum
decl_stmt|;
name|unsigned
name|char
name|xmitcsum
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|count
decl_stmt|;
name|unsigned
name|char
name|ch
decl_stmt|;
do|do
block|{
comment|/* wait around for the start character, ignore all other characters */
while|while
condition|(
operator|(
name|ch
operator|=
operator|(
name|getDebugChar
argument_list|()
operator|&
literal|0x7f
operator|)
operator|)
operator|!=
literal|'$'
condition|)
empty_stmt|;
name|checksum
operator|=
literal|0
expr_stmt|;
name|xmitcsum
operator|=
operator|-
literal|1
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
comment|/* now, read until a # or end of buffer is found */
while|while
condition|(
name|count
operator|<
name|BUFMAX
condition|)
block|{
name|ch
operator|=
name|getDebugChar
argument_list|()
operator|&
literal|0x7f
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'#'
condition|)
break|break;
name|checksum
operator|=
name|checksum
operator|+
name|ch
expr_stmt|;
name|buffer
index|[
name|count
index|]
operator|=
name|ch
expr_stmt|;
name|count
operator|=
name|count
operator|+
literal|1
expr_stmt|;
block|}
name|buffer
index|[
name|count
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'#'
condition|)
block|{
name|xmitcsum
operator|=
name|hex
argument_list|(
name|getDebugChar
argument_list|()
operator|&
literal|0x7f
argument_list|)
operator|<<
literal|4
expr_stmt|;
name|xmitcsum
operator|+=
name|hex
argument_list|(
name|getDebugChar
argument_list|()
operator|&
literal|0x7f
argument_list|)
expr_stmt|;
if|if
condition|(
name|checksum
operator|!=
name|xmitcsum
condition|)
name|putDebugChar
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
comment|/* failed checksum */
else|else
block|{
name|putDebugChar
argument_list|(
literal|'+'
argument_list|)
expr_stmt|;
comment|/* successful transfer */
comment|/* if a sequence char is present, reply the sequence ID */
if|if
condition|(
name|buffer
index|[
literal|2
index|]
operator|==
literal|':'
condition|)
block|{
name|putDebugChar
argument_list|(
name|buffer
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|putDebugChar
argument_list|(
name|buffer
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* remove sequence chars from buffer */
name|count
operator|=
name|strlen
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|3
init|;
name|i
operator|<=
name|count
condition|;
name|i
operator|++
control|)
name|buffer
index|[
name|i
operator|-
literal|3
index|]
operator|=
name|buffer
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
block|}
block|}
do|while
condition|(
name|checksum
operator|!=
name|xmitcsum
condition|)
do|;
if|if
condition|(
name|strlen
argument_list|(
name|buffer
argument_list|)
operator|>=
name|BUFMAX
condition|)
name|panic
argument_list|(
literal|"kgdb: buffer overflow"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* send the packet in buffer.  */
end_comment

begin_function
specifier|static
name|void
name|putpacket
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|)
block|{
name|unsigned
name|char
name|checksum
decl_stmt|;
name|int
name|count
decl_stmt|;
name|unsigned
name|char
name|ch
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|buffer
argument_list|)
operator|>=
name|BUFMAX
condition|)
name|panic
argument_list|(
literal|"kgdb: buffer overflow"
argument_list|)
expr_stmt|;
comment|/*  $<packet info>#<checksum>. */
do|do
block|{
comment|/*  * This is a non-standard hack to allow use of the serial console for  * operation as well as debugging.  Simply turn on 'remotechat' in gdb.  *  * This extension is not part of the Cygnus protocol, is kinda gross,  * but gets the job done.  */
ifdef|#
directive|ifdef
name|GDB_REMOTE_CHAT
name|putDebugChar
argument_list|(
literal|'|'
argument_list|)
expr_stmt|;
name|putDebugChar
argument_list|(
literal|'|'
argument_list|)
expr_stmt|;
name|putDebugChar
argument_list|(
literal|'|'
argument_list|)
expr_stmt|;
name|putDebugChar
argument_list|(
literal|'|'
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|putDebugChar
argument_list|(
literal|'$'
argument_list|)
expr_stmt|;
name|checksum
operator|=
literal|0
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|buffer
index|[
name|count
index|]
operator|)
operator|!=
literal|0
condition|)
block|{
name|putDebugChar
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|checksum
operator|+=
name|ch
expr_stmt|;
name|count
operator|+=
literal|1
expr_stmt|;
block|}
name|putDebugChar
argument_list|(
literal|'#'
argument_list|)
expr_stmt|;
name|putDebugChar
argument_list|(
name|hexchars
index|[
name|checksum
operator|>>
literal|4
index|]
argument_list|)
expr_stmt|;
name|putDebugChar
argument_list|(
name|hexchars
index|[
name|checksum
operator|&
literal|0xf
index|]
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|getDebugChar
argument_list|()
operator|&
literal|0x7f
operator|)
operator|!=
literal|'+'
condition|)
do|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
name|remcomInBuffer
index|[
name|BUFMAX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|remcomOutBuffer
index|[
name|BUFMAX
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|get_char
parameter_list|(
name|vm_offset_t
name|addr
parameter_list|)
block|{
name|char
name|data
decl_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|db_jmpbuf
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|db_read_bytes
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
return|return
name|data
operator|&
literal|0xff
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_char
parameter_list|(
name|vm_offset_t
name|addr
parameter_list|,
name|int
name|val
parameter_list|)
block|{
name|char
name|data
decl_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|db_jmpbuf
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|data
operator|=
name|val
expr_stmt|;
name|db_write_bytes
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* convert the memory pointed to by mem into hex, placing result in buf */
end_comment

begin_comment
comment|/* return a pointer to the last char put in buf (null) */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|mem2hex
parameter_list|(
name|vm_offset_t
name|mem
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|ch
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|ch
operator|=
name|get_char
argument_list|(
name|mem
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
operator|-
literal|1
condition|)
return|return
name|NULL
return|;
operator|*
name|buf
operator|++
operator|=
name|hexchars
index|[
name|ch
operator|>>
literal|4
index|]
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|hexchars
index|[
name|ch
operator|%
literal|16
index|]
expr_stmt|;
block|}
operator|*
name|buf
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_comment
comment|/* convert the hex array pointed to by buf into binary to be placed in mem */
end_comment

begin_comment
comment|/* return a pointer to the character AFTER the last byte written */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|hex2mem
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|vm_offset_t
name|mem
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|int
name|rv
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|ch
operator|=
name|hex
argument_list|(
operator|*
name|buf
operator|++
argument_list|)
operator|<<
literal|4
expr_stmt|;
name|ch
operator|=
name|ch
operator|+
name|hex
argument_list|(
operator|*
name|buf
operator|++
argument_list|)
expr_stmt|;
name|rv
operator|=
name|set_char
argument_list|(
name|mem
operator|++
argument_list|,
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
operator|-
literal|1
condition|)
return|return
name|NULL
return|;
block|}
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_comment
comment|/* this function takes the 386 exception vector and attempts to    translate this number into a unix compatible signal value */
end_comment

begin_function
specifier|static
name|int
name|computeSignal
parameter_list|(
name|int
name|entry
parameter_list|,
name|int
name|code
parameter_list|)
block|{
switch|switch
condition|(
name|entry
condition|)
block|{
case|case
name|ALPHA_KENTRY_INT
case|:
case|case
name|ALPHA_KENTRY_ARITH
case|:
return|return
name|SIGILL
return|;
comment|/* ? can this happen? */
case|case
name|ALPHA_KENTRY_MM
case|:
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|ALPHA_MMCSR_INVALTRANS
case|:
return|return
name|SIGSEGV
return|;
case|case
name|ALPHA_MMCSR_ACCESS
case|:
case|case
name|ALPHA_MMCSR_FOR
case|:
case|case
name|ALPHA_MMCSR_FOE
case|:
case|case
name|ALPHA_MMCSR_FOW
case|:
return|return
name|SIGBUS
return|;
block|}
case|case
name|ALPHA_KENTRY_IF
case|:
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|ALPHA_IF_CODE_BUGCHK
case|:
case|case
name|ALPHA_IF_CODE_BPT
case|:
return|return
name|SIGTRAP
return|;
case|case
name|ALPHA_IF_CODE_GENTRAP
case|:
case|case
name|ALPHA_IF_CODE_FEN
case|:
case|case
name|ALPHA_IF_CODE_OPDEC
case|:
return|return
name|SIGILL
return|;
block|}
case|case
name|ALPHA_KENTRY_UNA
case|:
return|return
name|SIGSEGV
return|;
case|case
name|ALPHA_KENTRY_SYS
case|:
return|return
name|SIGILL
return|;
block|}
return|return
name|SIGILL
return|;
block|}
end_function

begin_comment
comment|/*  * While we find nice hex chars, build an int.  * Return number of chars processed.  */
end_comment

begin_function
specifier|static
name|int
name|hexToInt
parameter_list|(
name|char
modifier|*
modifier|*
name|ptr
parameter_list|,
name|long
modifier|*
name|intValue
parameter_list|)
block|{
name|int
name|numChars
init|=
literal|0
decl_stmt|;
name|int
name|hexValue
decl_stmt|;
operator|*
name|intValue
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
operator|*
name|ptr
condition|)
block|{
name|hexValue
operator|=
name|hex
argument_list|(
operator|*
operator|*
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|hexValue
operator|>=
literal|0
condition|)
block|{
operator|*
name|intValue
operator|=
operator|(
operator|*
name|intValue
operator|<<
literal|4
operator|)
operator||
name|hexValue
expr_stmt|;
name|numChars
operator|++
expr_stmt|;
block|}
else|else
break|break;
operator|(
operator|*
name|ptr
operator|)
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|numChars
operator|)
return|;
block|}
end_function

begin_enum
specifier|static
enum|enum
block|{
name|NONE
block|,
name|NORMAL
block|,
name|BRANCH
block|}
name|ss_mode
init|=
name|NONE
enum|;
end_enum

begin_struct
struct|struct
name|ss_bpt
block|{
name|int
name|active
decl_stmt|;
name|vm_offset_t
name|addr
decl_stmt|;
name|u_int32_t
name|contents
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|ss_bpt
name|ss_bp1
decl_stmt|,
name|ss_bp2
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|set_bpt
parameter_list|(
name|struct
name|ss_bpt
modifier|*
name|bp
parameter_list|)
block|{
name|u_int32_t
name|bp_ins
init|=
name|BKPT_INST
decl_stmt|;
if|if
condition|(
name|bp
operator|->
name|active
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|badaddr
argument_list|(
operator|(
name|caddr_t
operator|)
name|bp
operator|->
name|addr
argument_list|,
literal|4
argument_list|)
condition|)
return|return
literal|0
return|;
name|db_read_bytes
argument_list|(
name|bp
operator|->
name|addr
argument_list|,
literal|4
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|bp
operator|->
name|contents
argument_list|)
expr_stmt|;
name|db_write_bytes
argument_list|(
name|bp
operator|->
name|addr
argument_list|,
literal|4
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|bp_ins
argument_list|)
expr_stmt|;
name|bp
operator|->
name|active
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|clear_bpt
parameter_list|(
name|struct
name|ss_bpt
modifier|*
name|bp
parameter_list|)
block|{
if|if
condition|(
operator|!
name|bp
operator|->
name|active
condition|)
return|return;
if|if
condition|(
name|badaddr
argument_list|(
operator|(
name|caddr_t
operator|)
name|bp
operator|->
name|addr
argument_list|,
literal|4
argument_list|)
condition|)
return|return;
name|db_write_bytes
argument_list|(
name|bp
operator|->
name|addr
argument_list|,
literal|4
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|bp
operator|->
name|contents
argument_list|)
expr_stmt|;
name|bp
operator|->
name|active
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_single_step
parameter_list|(
name|db_regs_t
modifier|*
name|regs
parameter_list|)
block|{
name|u_int32_t
name|ins
decl_stmt|;
name|vm_offset_t
name|pc
init|=
name|regs
operator|->
name|tf_regs
index|[
name|FRAME_PC
index|]
decl_stmt|;
if|if
condition|(
name|ss_mode
operator|!=
name|NONE
condition|)
block|{
name|printf
argument_list|(
literal|"single_step botch\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|badaddr
argument_list|(
operator|(
name|caddr_t
operator|)
name|pc
argument_list|,
literal|4
argument_list|)
condition|)
return|return
literal|0
return|;
name|db_read_bytes
argument_list|(
name|pc
argument_list|,
literal|4
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ins
argument_list|)
expr_stmt|;
name|ss_bp1
operator|.
name|addr
operator|=
name|pc
operator|+
literal|4
expr_stmt|;
if|if
condition|(
name|db_inst_branch
argument_list|(
name|ins
argument_list|)
condition|)
block|{
name|ss_bp2
operator|.
name|addr
operator|=
name|db_branch_taken
argument_list|(
name|ins
argument_list|,
name|pc
argument_list|,
name|regs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set_bpt
argument_list|(
operator|&
name|ss_bp1
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|set_bpt
argument_list|(
operator|&
name|ss_bp2
argument_list|)
condition|)
block|{
name|clear_bpt
argument_list|(
operator|&
name|ss_bp1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|ss_mode
operator|=
name|BRANCH
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|set_bpt
argument_list|(
operator|&
name|ss_bp1
argument_list|)
condition|)
return|return
literal|0
return|;
name|ss_mode
operator|=
name|NORMAL
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|clear_single_step
parameter_list|(
name|db_regs_t
modifier|*
name|regs
parameter_list|)
block|{
comment|/* if we hit one of the step breakpoints, adjust pc */
if|if
condition|(
name|ss_mode
operator|==
name|BRANCH
condition|)
block|{
comment|/* remove in reverse order in case they are at the same address */
if|if
condition|(
name|regs
operator|->
name|tf_regs
index|[
name|FRAME_PC
index|]
operator|==
name|ss_bp1
operator|.
name|addr
operator|+
literal|4
operator|||
name|regs
operator|->
name|tf_regs
index|[
name|FRAME_PC
index|]
operator|==
name|ss_bp2
operator|.
name|addr
operator|+
literal|4
condition|)
name|regs
operator|->
name|tf_regs
index|[
name|FRAME_PC
index|]
operator|-=
literal|4
expr_stmt|;
name|clear_bpt
argument_list|(
operator|&
name|ss_bp2
argument_list|)
expr_stmt|;
name|clear_bpt
argument_list|(
operator|&
name|ss_bp1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ss_mode
operator|==
name|NORMAL
condition|)
block|{
if|if
condition|(
name|regs
operator|->
name|tf_regs
index|[
name|FRAME_PC
index|]
operator|==
name|ss_bp1
operator|.
name|addr
operator|+
literal|4
condition|)
name|regs
operator|->
name|tf_regs
index|[
name|FRAME_PC
index|]
operator|-=
literal|4
expr_stmt|;
name|clear_bpt
argument_list|(
operator|&
name|ss_bp1
argument_list|)
expr_stmt|;
block|}
name|ss_mode
operator|=
name|NONE
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|NUMREGBYTES
value|(sizeof registers)
end_define

begin_define
define|#
directive|define
name|PC
value|64
end_define

begin_define
define|#
directive|define
name|SP
value|30
end_define

begin_define
define|#
directive|define
name|FP
value|15
end_define

begin_define
define|#
directive|define
name|VFP
value|65
end_define

begin_define
define|#
directive|define
name|NUM_REGS
value|66
end_define

begin_comment
comment|/*  * Map trapframe indices into gdb (integer) register indices.  * Entries not in integer register set are set to -1.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|tf2gdb
index|[
name|FRAME_SIZE
index|]
init|=
block|{
comment|/*0*/
name|R_V0
block|,
name|R_T0
block|,
name|R_T1
block|,
name|R_T2
block|,
name|R_T3
block|,
name|R_T4
block|,
name|R_T5
block|,
name|R_T6
block|,
comment|/*8*/
name|R_T7
block|,
name|R_S0
block|,
name|R_S1
block|,
name|R_S2
block|,
name|R_S3
block|,
name|R_S4
block|,
name|R_S5
block|,
name|R_S6
block|,
comment|/*16*/
name|R_A3
block|,
name|R_A4
block|,
name|R_A5
block|,
name|R_T8
block|,
name|R_T9
block|,
name|R_T10
block|,
name|R_T11
block|,
name|R_RA
block|,
comment|/*24*/
name|R_T12
block|,
name|R_AT
block|,
name|R_SP
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/*32*/
name|R_GP
block|,
name|R_A0
block|,
name|R_A1
block|,
name|R_A2
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Map gdb register indices back to trapframe.  * Entries not in trapframe are set to -1.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|gdb2tf
index|[
name|NUM_REGS
index|]
init|=
block|{
comment|/* integer registers */
name|FRAME_V0
block|,
name|FRAME_T0
block|,
name|FRAME_T1
block|,
name|FRAME_T2
block|,
name|FRAME_T3
block|,
name|FRAME_T4
block|,
name|FRAME_T5
block|,
name|FRAME_T6
block|,
name|FRAME_T7
block|,
name|FRAME_S0
block|,
name|FRAME_S1
block|,
name|FRAME_S2
block|,
name|FRAME_S3
block|,
name|FRAME_S4
block|,
name|FRAME_S5
block|,
name|FRAME_S6
block|,
name|FRAME_A0
block|,
name|FRAME_A1
block|,
name|FRAME_A2
block|,
name|FRAME_A3
block|,
name|FRAME_A4
block|,
name|FRAME_A5
block|,
name|FRAME_T8
block|,
name|FRAME_T9
block|,
name|FRAME_T10
block|,
name|FRAME_T11
block|,
name|FRAME_RA
block|,
name|FRAME_T12
block|,
name|FRAME_AT
block|,
name|FRAME_GP
block|,
name|FRAME_SP
block|,
operator|-
literal|1
block|,
comment|/* float registers */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* misc registers */
name|FRAME_PC
block|,
operator|-
literal|1
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This function does all command procesing for interfacing to gdb.  */
end_comment

begin_function
name|void
name|gdb_handle_exception
parameter_list|(
name|db_regs_t
modifier|*
name|raw_regs
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|code
parameter_list|)
block|{
name|int
name|sigval
decl_stmt|;
name|long
name|addr
decl_stmt|,
name|length
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
struct|struct
name|alpharegs
block|{
name|u_int64_t
name|r
index|[
literal|32
index|]
decl_stmt|;
name|u_int64_t
name|f
index|[
literal|32
index|]
decl_stmt|;
name|u_int64_t
name|pc
decl_stmt|,
name|vfp
decl_stmt|;
block|}
struct|;
specifier|static
name|struct
name|alpharegs
name|registers
decl_stmt|;
name|int
name|i
decl_stmt|;
name|clear_single_step
argument_list|(
name|raw_regs
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|registers
argument_list|,
sizeof|sizeof
name|registers
argument_list|)
expr_stmt|;
comment|/*    * Map trapframe to registers.    * Ignore float regs for now.    */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FRAME_SIZE
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|tf2gdb
index|[
name|i
index|]
operator|>=
literal|0
condition|)
name|registers
operator|.
name|r
index|[
name|tf2gdb
index|[
name|i
index|]
index|]
operator|=
name|raw_regs
operator|->
name|tf_regs
index|[
name|i
index|]
expr_stmt|;
name|registers
operator|.
name|pc
operator|=
name|raw_regs
operator|->
name|tf_regs
index|[
name|FRAME_PC
index|]
expr_stmt|;
comment|/* reply to host that an exception has occurred */
name|sigval
operator|=
name|computeSignal
argument_list|(
name|type
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|remcomOutBuffer
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|'T'
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|hexchars
index|[
name|sigval
operator|>>
literal|4
index|]
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|hexchars
index|[
name|sigval
operator|&
literal|0xf
index|]
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|hexchars
index|[
name|PC
operator|>>
literal|4
index|]
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|hexchars
index|[
name|PC
operator|&
literal|0xf
index|]
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|':'
expr_stmt|;
name|ptr
operator|=
name|mem2hex
argument_list|(
operator|(
name|vm_offset_t
operator|)
operator|&
name|registers
operator|.
name|pc
argument_list|,
name|ptr
argument_list|,
literal|8
argument_list|)
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|';'
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|hexchars
index|[
name|FP
operator|>>
literal|4
index|]
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|hexchars
index|[
name|FP
operator|&
literal|0xf
index|]
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|':'
expr_stmt|;
name|ptr
operator|=
name|mem2hex
argument_list|(
operator|(
name|vm_offset_t
operator|)
operator|&
name|registers
operator|.
name|r
index|[
name|FP
index|]
argument_list|,
name|ptr
argument_list|,
literal|8
argument_list|)
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|';'
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|hexchars
index|[
name|SP
operator|>>
literal|4
index|]
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|hexchars
index|[
name|SP
operator|&
literal|0xf
index|]
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|':'
expr_stmt|;
name|ptr
operator|=
name|mem2hex
argument_list|(
operator|(
name|vm_offset_t
operator|)
operator|&
name|registers
operator|.
name|r
index|[
name|SP
index|]
argument_list|,
name|ptr
argument_list|,
literal|8
argument_list|)
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|';'
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|0
expr_stmt|;
name|putpacket
argument_list|(
name|remcomOutBuffer
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|remcomOutBuffer
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|getpacket
argument_list|(
name|remcomInBuffer
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|remcomInBuffer
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'?'
case|:
name|remcomOutBuffer
index|[
literal|0
index|]
operator|=
literal|'S'
expr_stmt|;
name|remcomOutBuffer
index|[
literal|1
index|]
operator|=
name|hexchars
index|[
name|sigval
operator|>>
literal|4
index|]
expr_stmt|;
name|remcomOutBuffer
index|[
literal|2
index|]
operator|=
name|hexchars
index|[
name|sigval
operator|%
literal|16
index|]
expr_stmt|;
name|remcomOutBuffer
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
comment|/* detach; say OK and turn off gdb */
name|putpacket
argument_list|(
name|remcomOutBuffer
argument_list|)
expr_stmt|;
name|boothowto
operator|&=
operator|~
name|RB_GDB
expr_stmt|;
return|return;
case|case
literal|'k'
case|:
name|prom_halt
argument_list|()
expr_stmt|;
comment|/*NOTREACHED*/
break|break;
case|case
literal|'g'
case|:
comment|/* return the value of the CPU registers */
name|mem2hex
argument_list|(
operator|(
name|vm_offset_t
operator|)
operator|&
name|registers
argument_list|,
name|remcomOutBuffer
argument_list|,
name|NUMREGBYTES
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
comment|/* set the value of the CPU registers - return OK */
name|hex2mem
argument_list|(
operator|&
name|remcomInBuffer
index|[
literal|1
index|]
argument_list|,
operator|(
name|vm_offset_t
operator|)
operator|&
name|registers
argument_list|,
name|NUMREGBYTES
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|remcomOutBuffer
argument_list|,
literal|"OK"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
comment|/* Set the value of one register */
block|{
name|long
name|regno
decl_stmt|;
name|ptr
operator|=
operator|&
name|remcomInBuffer
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|hexToInt
argument_list|(
operator|&
name|ptr
argument_list|,
operator|&
name|regno
argument_list|)
operator|&&
operator|*
name|ptr
operator|++
operator|==
literal|'='
operator|&&
name|regno
operator|<
name|NUM_REGS
condition|)
block|{
name|hex2mem
argument_list|(
name|ptr
argument_list|,
operator|(
name|vm_offset_t
operator|)
operator|&
name|registers
operator|+
name|regno
operator|*
literal|8
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|remcomOutBuffer
argument_list|,
literal|"OK"
argument_list|)
expr_stmt|;
block|}
else|else
name|strcpy
argument_list|(
name|remcomOutBuffer
argument_list|,
literal|"P01"
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'m'
case|:
comment|/* mAA..AA,LLLL  Read LLLL bytes at address AA..AA */
comment|/* Try to read %x,%x.  */
name|ptr
operator|=
operator|&
name|remcomInBuffer
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|hexToInt
argument_list|(
operator|&
name|ptr
argument_list|,
operator|&
name|addr
argument_list|)
operator|&&
operator|*
operator|(
name|ptr
operator|++
operator|)
operator|==
literal|','
operator|&&
name|hexToInt
argument_list|(
operator|&
name|ptr
argument_list|,
operator|&
name|length
argument_list|)
condition|)
block|{
if|if
condition|(
name|mem2hex
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|addr
argument_list|,
name|remcomOutBuffer
argument_list|,
name|length
argument_list|)
operator|==
name|NULL
condition|)
name|strcpy
argument_list|(
name|remcomOutBuffer
argument_list|,
literal|"E03"
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
name|strcpy
argument_list|(
name|remcomOutBuffer
argument_list|,
literal|"E01"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
comment|/* MAA..AA,LLLL: Write LLLL bytes at address AA.AA return OK */
comment|/* Try to read '%x,%x:'.  */
name|ptr
operator|=
operator|&
name|remcomInBuffer
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|hexToInt
argument_list|(
operator|&
name|ptr
argument_list|,
operator|&
name|addr
argument_list|)
operator|&&
operator|*
operator|(
name|ptr
operator|++
operator|)
operator|==
literal|','
operator|&&
name|hexToInt
argument_list|(
operator|&
name|ptr
argument_list|,
operator|&
name|length
argument_list|)
operator|&&
operator|*
operator|(
name|ptr
operator|++
operator|)
operator|==
literal|':'
condition|)
block|{
if|if
condition|(
name|hex2mem
argument_list|(
name|ptr
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|addr
argument_list|,
name|length
argument_list|)
operator|==
name|NULL
condition|)
name|strcpy
argument_list|(
name|remcomOutBuffer
argument_list|,
literal|"E03"
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|remcomOutBuffer
argument_list|,
literal|"OK"
argument_list|)
expr_stmt|;
block|}
else|else
name|strcpy
argument_list|(
name|remcomOutBuffer
argument_list|,
literal|"E02"
argument_list|)
expr_stmt|;
break|break;
comment|/* cAA..AA    Continue at address AA..AA(optional) */
comment|/* sAA..AA   Step one instruction from AA..AA(optional) */
case|case
literal|'c'
case|:
case|case
literal|'s'
case|:
comment|/* try to read optional parameter, pc unchanged if no parm */
name|ptr
operator|=
operator|&
name|remcomInBuffer
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|hexToInt
argument_list|(
operator|&
name|ptr
argument_list|,
operator|&
name|addr
argument_list|)
condition|)
name|registers
operator|.
name|pc
operator|=
name|addr
expr_stmt|;
comment|/* 	   * Map gdb registers back to trapframe (ignoring fp regs). 	   */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_REGS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|gdb2tf
index|[
name|i
index|]
operator|>=
literal|0
condition|)
name|raw_regs
operator|->
name|tf_regs
index|[
name|gdb2tf
index|[
name|i
index|]
index|]
operator|=
name|registers
operator|.
name|r
index|[
name|i
index|]
expr_stmt|;
name|raw_regs
operator|->
name|tf_regs
index|[
name|FRAME_PC
index|]
operator|=
name|registers
operator|.
name|pc
expr_stmt|;
if|if
condition|(
name|remcomInBuffer
index|[
literal|0
index|]
operator|==
literal|'s'
condition|)
if|if
condition|(
operator|!
name|set_single_step
argument_list|(
name|raw_regs
argument_list|)
condition|)
name|printf
argument_list|(
literal|"Can't set single step breakpoint\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* switch */
comment|/* reply to the request */
name|putpacket
argument_list|(
name|remcomOutBuffer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NSIO> 0 */
end_comment

end_unit

