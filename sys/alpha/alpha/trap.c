begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/* $NetBSD: trap.c,v 1.31 1998/03/26 02:21:46 thorpej Exp $ */
end_comment

begin_comment
comment|/*  * Copyright (c) 1994, 1995, 1996 Carnegie-Mellon University.  * All rights reserved.  *  * Author: Chris G. Demetriou  *   * Permission to use, copy, modify and distribute this software and  * its documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *   * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"   * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND   * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *   * Carnegie Mellon requests users of this software to return to  *  *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *  * any improvements or extensions that they make and grant Carnegie the  * rights to redistribute these changes.  */
end_comment

begin_comment
comment|/* #include "opt_fix_unaligned_vax_fp.h" */
end_comment

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_include
include|#
directive|include
file|"opt_ktrace.h"
end_include

begin_include
include|#
directive|include
file|"opt_simos.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/exec.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmmeter.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysent.h>
end_include

begin_include
include|#
directive|include
file|<sys/syscall.h>
end_include

begin_include
include|#
directive|include
file|<sys/pioctl.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/reg.h>
end_include

begin_include
include|#
directive|include
file|<machine/pal.h>
end_include

begin_include
include|#
directive|include
file|<machine/fpu.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|KTRACE
end_ifdef

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktrace.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_include
include|#
directive|include
file|<ddb/ddb.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<alpha/alpha/db_instruction.h>
end_include

begin_comment
comment|/* for handle_opdec() */
end_comment

begin_function_decl
name|unsigned
name|long
name|Sfloat_to_reg
parameter_list|(
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|unsigned
name|int
name|reg_to_Sfloat
parameter_list|(
name|unsigned
name|long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|unsigned
name|long
name|Tfloat_reg_cvt
parameter_list|(
name|unsigned
name|long
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|FIX_UNALIGNED_VAX_FP
end_ifdef

begin_function_decl
name|unsigned
name|long
name|Ffloat_to_reg
parameter_list|(
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|unsigned
name|int
name|reg_to_Ffloat
parameter_list|(
name|unsigned
name|long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|unsigned
name|long
name|Gfloat_reg_cvt
parameter_list|(
name|unsigned
name|long
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|int
name|unaligned_fixup
parameter_list|(
name|unsigned
name|long
parameter_list|,
name|unsigned
name|long
parameter_list|,
name|unsigned
name|long
parameter_list|,
name|struct
name|thread
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|handle_opdec
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|u_int64_t
modifier|*
name|ucodep
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|printtrap
parameter_list|(
specifier|const
name|unsigned
name|long
parameter_list|,
specifier|const
name|unsigned
name|long
parameter_list|,
specifier|const
name|unsigned
name|long
parameter_list|,
specifier|const
name|unsigned
name|long
parameter_list|,
name|struct
name|trapframe
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|WITNESS
end_ifdef

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|syscallnames
index|[]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|arith_exceptions
index|[]
init|=
block|{
literal|"software completion"
block|,
literal|"invalid operation"
block|,
literal|"division by zero"
block|,
literal|"overflow"
block|,
literal|"underflow"
block|,
literal|"inexact result"
block|,
literal|"integer overflow"
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|instruction_faults
index|[]
init|=
block|{
literal|"bpt"
block|,
literal|"bugchk"
block|,
literal|"gentrap"
block|,
literal|"FEN"
block|,
literal|"opDec"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|interrupt_types
index|[]
init|=
block|{
literal|"interprocessor"
block|,
literal|"clock"
block|,
literal|"correctable error"
block|,
literal|"machine check"
block|,
literal|"I/O device"
block|,
literal|"performance counter"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|mmfault_types
index|[]
init|=
block|{
literal|"translation not valid"
block|,
literal|"access violation"
block|,
literal|"fault on read"
block|,
literal|"fault on execute"
block|,
literal|"fault on write"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|mmfault_causes
index|[]
init|=
block|{
literal|"instruction fetch"
block|,
literal|"load instructon"
block|,
literal|"store instruction"
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|printtrap
parameter_list|(
name|a0
parameter_list|,
name|a1
parameter_list|,
name|a2
parameter_list|,
name|entry
parameter_list|,
name|framep
parameter_list|,
name|isfatal
parameter_list|,
name|user
parameter_list|)
specifier|const
name|unsigned
name|long
name|a0
decl_stmt|,
name|a1
decl_stmt|,
name|a2
decl_stmt|,
name|entry
decl_stmt|;
name|struct
name|trapframe
modifier|*
name|framep
decl_stmt|;
name|int
name|isfatal
decl_stmt|,
name|user
decl_stmt|;
block|{
name|char
name|ubuf
index|[
literal|64
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|entryname
decl_stmt|;
name|unsigned
name|long
name|i
decl_stmt|;
switch|switch
condition|(
name|entry
condition|)
block|{
case|case
name|ALPHA_KENTRY_INT
case|:
name|entryname
operator|=
literal|"interrupt"
expr_stmt|;
break|break;
case|case
name|ALPHA_KENTRY_ARITH
case|:
name|entryname
operator|=
literal|"arithmetic trap"
expr_stmt|;
break|break;
case|case
name|ALPHA_KENTRY_MM
case|:
name|entryname
operator|=
literal|"memory management fault"
expr_stmt|;
break|break;
case|case
name|ALPHA_KENTRY_IF
case|:
name|entryname
operator|=
literal|"instruction fault"
expr_stmt|;
break|break;
case|case
name|ALPHA_KENTRY_UNA
case|:
name|entryname
operator|=
literal|"unaligned access fault"
expr_stmt|;
break|break;
case|case
name|ALPHA_KENTRY_SYS
case|:
name|entryname
operator|=
literal|"system call"
expr_stmt|;
break|break;
default|default:
name|snprintf
argument_list|(
name|ubuf
argument_list|,
sizeof|sizeof
argument_list|(
name|ubuf
argument_list|)
argument_list|,
literal|"type %lx"
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|entryname
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|ubuf
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s %s trap:\n"
argument_list|,
name|isfatal
condition|?
literal|"fatal"
else|:
literal|"handled"
argument_list|,
name|user
condition|?
literal|"user"
else|:
literal|"kernel"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    trap entry     = 0x%lx (%s)\n"
argument_list|,
name|entry
argument_list|,
name|entryname
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
name|printf
argument_list|(
literal|"    cpuid          = %d\n"
argument_list|,
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|entry
condition|)
block|{
case|case
name|ALPHA_KENTRY_INT
case|:
name|printf
argument_list|(
literal|"    interrupt type = "
argument_list|)
expr_stmt|;
if|if
condition|(
name|a0
operator|<
literal|5
condition|)
block|{
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|interrupt_types
index|[
name|a0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|a0
operator|>
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"    vector         = 0x%lx\n"
argument_list|,
name|a1
argument_list|)
expr_stmt|;
if|if
condition|(
name|a0
operator|<
literal|3
condition|)
name|printf
argument_list|(
literal|"    logout area    = 0x%lx\n"
argument_list|,
name|a2
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|printf
argument_list|(
literal|"0x%lx (unknown)\n"
argument_list|,
name|a0
argument_list|)
expr_stmt|;
break|break;
case|case
name|ALPHA_KENTRY_ARITH
case|:
name|printf
argument_list|(
literal|"    exception type = "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|a0
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|arith_exceptions
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|a0
operator|&
operator|(
operator|~
literal|0
operator|-
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
condition|)
name|printf
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    register mask  = 0x%lx"
argument_list|,
name|a1
argument_list|)
expr_stmt|;
break|break;
case|case
name|ALPHA_KENTRY_MM
case|:
name|printf
argument_list|(
literal|"    faulting va    = 0x%lx\n"
argument_list|,
name|a0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    type           = "
argument_list|)
expr_stmt|;
if|if
condition|(
name|a1
operator|<
literal|5
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|mmfault_types
index|[
name|a1
index|]
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"0x%lx (unknown)\n"
argument_list|,
name|a1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    cause          = "
argument_list|)
expr_stmt|;
name|i
operator|=
name|a2
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|3
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|mmfault_causes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"0x%lx (unknown)\n"
argument_list|,
name|a2
argument_list|)
expr_stmt|;
break|break;
case|case
name|ALPHA_KENTRY_IF
case|:
name|printf
argument_list|(
literal|"    fault type     = "
argument_list|)
expr_stmt|;
if|if
condition|(
name|a0
operator|<
literal|5
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|instruction_faults
index|[
name|a0
index|]
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"0x%lx (unknown)\n"
argument_list|,
name|a0
argument_list|)
expr_stmt|;
break|break;
case|case
name|ALPHA_KENTRY_UNA
case|:
name|printf
argument_list|(
literal|"    faulting va    = 0x%lx\n"
argument_list|,
name|a0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    opcode         = 0x%lx\n"
argument_list|,
name|a1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    register       = 0x%lx\n"
argument_list|,
name|a2
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"    a0             = 0x%lx\n"
argument_list|,
name|a0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    a1             = 0x%lx\n"
argument_list|,
name|a1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    a2             = 0x%lx\n"
argument_list|,
name|a2
argument_list|)
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|"    pc             = 0x%lx\n"
argument_list|,
name|framep
operator|->
name|tf_regs
index|[
name|FRAME_PC
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    ra             = 0x%lx\n"
argument_list|,
name|framep
operator|->
name|tf_regs
index|[
name|FRAME_RA
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    sp             = 0x%lx\n"
argument_list|,
name|framep
operator|->
name|tf_regs
index|[
name|FRAME_SP
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|curthread
operator|!=
name|NULL
operator|&&
operator|(
name|curthread
operator|->
name|td_proc
operator|->
name|p_flag
operator|&
name|P_KTHREAD
operator|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"    usp            = 0x%lx\n"
argument_list|,
name|alpha_pal_rdusp
argument_list|()
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    curthread      = %p\n"
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
if|if
condition|(
name|curthread
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"        pid = %d, comm = %s\n"
argument_list|,
name|curthread
operator|->
name|td_proc
operator|->
name|p_pid
argument_list|,
name|curthread
operator|->
name|td_proc
operator|->
name|p_comm
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Trap is called from locore to handle most types of processor traps.  * System calls are broken out for efficiency and ASTs are broken out  * to make the code a bit cleaner and more representative of the  * Alpha architecture.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|trap
parameter_list|(
name|a0
parameter_list|,
name|a1
parameter_list|,
name|a2
parameter_list|,
name|entry
parameter_list|,
name|framep
parameter_list|)
specifier|const
name|unsigned
name|long
name|a0
decl_stmt|,
name|a1
decl_stmt|,
name|a2
decl_stmt|,
name|entry
decl_stmt|;
name|struct
name|trapframe
modifier|*
name|framep
decl_stmt|;
block|{
specifier|register
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
specifier|register
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|u_int64_t
name|ucode
decl_stmt|;
name|u_int
name|sticks
decl_stmt|;
name|int
name|user
decl_stmt|;
ifdef|#
directive|ifdef
name|SMP
name|register_t
name|s
decl_stmt|;
endif|#
directive|endif
comment|/* 	 * Find our per-cpu globals. 	 */
ifdef|#
directive|ifdef
name|SMP
name|s
operator|=
name|intr_disable
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|pcpup
operator|=
operator|(
expr|struct
name|pcpu
operator|*
operator|)
name|alpha_pal_rdval
argument_list|()
expr_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
if|if
condition|(
name|td
operator|==
name|NULL
condition|)
block|{
name|printtrap
argument_list|(
name|a0
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|entry
argument_list|,
name|framep
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cpu_halt
argument_list|()
expr_stmt|;
block|}
name|td
operator|->
name|td_md
operator|.
name|md_kernnest
operator|++
expr_stmt|;
name|intr_restore
argument_list|(
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
comment|/* 	GIANT_REQUIRED; 	 * Giant hasn't been acquired yet. 	 */
name|cnt
operator|.
name|v_trap
operator|++
expr_stmt|;
name|ucode
operator|=
literal|0
expr_stmt|;
name|user
operator|=
operator|(
name|framep
operator|->
name|tf_regs
index|[
name|FRAME_PS
index|]
operator|&
name|ALPHA_PSL_USERMODE
operator|)
operator|!=
literal|0
expr_stmt|;
name|CTR5
argument_list|(
name|KTR_TRAP
argument_list|,
literal|"%s trap: pid %d, (%lx, %lx, %lx)"
argument_list|,
name|user
condition|?
literal|"user"
else|:
literal|"kernel"
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|a0
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|)
expr_stmt|;
if|if
condition|(
name|user
condition|)
block|{
name|sticks
operator|=
name|td
operator|->
name|td_kse
operator|->
name|ke_sticks
expr_stmt|;
name|td
operator|->
name|td_frame
operator|=
name|framep
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_ucred
operator|!=
name|p
operator|->
name|p_ucred
condition|)
name|cred_update_thread
argument_list|(
name|td
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sticks
operator|=
literal|0
expr_stmt|;
comment|/* XXX bogus -Wuninitialized warning */
name|KASSERT
argument_list|(
name|cold
operator|||
name|td
operator|->
name|td_ucred
operator|!=
name|NULL
argument_list|,
operator|(
literal|"kernel trap doesn't have ucred"
operator|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|user
condition|)
name|alpha_fpstate_check
argument_list|(
name|td
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|entry
condition|)
block|{
case|case
name|ALPHA_KENTRY_UNA
case|:
comment|/* 		 * If user-land, do whatever fixups, printing, and 		 * signalling is appropriate (based on system-wide 		 * and per-process unaligned-access-handling flags). 		 */
if|if
condition|(
name|user
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|i
operator|=
name|unaligned_fixup
argument_list|(
name|a0
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
name|ucode
operator|=
name|a0
expr_stmt|;
comment|/* VA */
break|break;
block|}
comment|/* 		 * Unaligned access from kernel mode is always an error, 		 * EVEN IF A COPY FAULT HANDLER IS SET! 		 * 		 * It's an error if a copy fault handler is set because 		 * the various routines which do user-initiated copies 		 * do so in a bcopy-like manner.  In other words, the 		 * kernel never assumes that pointers provided by the 		 * user are properly aligned, and so if the kernel 		 * does cause an unaligned access it's a kernel bug. 		 */
goto|goto
name|dopanic
goto|;
case|case
name|ALPHA_KENTRY_ARITH
case|:
comment|/*  		 * If user-land, give a SIGFPE if software completion 		 * is not requested or if the completion fails. 		 */
if|if
condition|(
name|user
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
if|if
condition|(
name|a0
operator|&
name|EXCSUM_SWC
condition|)
if|if
condition|(
name|fp_software_completion
argument_list|(
name|a1
argument_list|,
name|td
argument_list|)
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|i
operator|=
name|SIGFPE
expr_stmt|;
name|ucode
operator|=
name|a0
expr_stmt|;
comment|/* exception summary */
break|break;
block|}
comment|/* Always fatal in kernel.  Should never happen. */
goto|goto
name|dopanic
goto|;
case|case
name|ALPHA_KENTRY_IF
case|:
comment|/* 		 * These are always fatal in kernel, and should never happen. 		 */
if|if
condition|(
operator|!
name|user
condition|)
block|{
ifdef|#
directive|ifdef
name|DDB
comment|/* 			 * ...unless, of course, DDB is configured; BUGCHK 			 * is used to invoke the kernel debugger, and we 			 * might have set a breakpoint. 			 */
if|if
condition|(
name|a0
operator|==
name|ALPHA_IF_CODE_BUGCHK
operator|||
name|a0
operator|==
name|ALPHA_IF_CODE_BPT
ifdef|#
directive|ifdef
name|SIMOS
operator|||
name|a0
operator|==
name|ALPHA_IF_CODE_GENTRAP
endif|#
directive|endif
condition|)
block|{
if|if
condition|(
name|kdb_trap
argument_list|(
name|a0
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|entry
argument_list|,
name|framep
argument_list|)
condition|)
goto|goto
name|out
goto|;
block|}
comment|/* 			 * If we get here, DDB did _not_ handle the 			 * trap, and we need to PANIC! 			 */
endif|#
directive|endif
goto|goto
name|dopanic
goto|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|a0
condition|)
block|{
case|case
name|ALPHA_IF_CODE_GENTRAP
case|:
if|if
condition|(
name|framep
operator|->
name|tf_regs
index|[
name|FRAME_A0
index|]
operator|==
operator|-
literal|2
condition|)
block|{
comment|/* weird! */
name|i
operator|=
name|SIGFPE
expr_stmt|;
name|ucode
operator|=
name|a0
expr_stmt|;
comment|/* exception summary */
break|break;
block|}
comment|/* FALLTHROUTH */
case|case
name|ALPHA_IF_CODE_BPT
case|:
case|case
name|ALPHA_IF_CODE_BUGCHK
case|:
if|if
condition|(
name|td
operator|->
name|td_md
operator|.
name|md_flags
operator|&
operator|(
name|MDP_STEP1
operator||
name|MDP_STEP2
operator|)
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|ptrace_clear_single_step
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_frame
operator|->
name|tf_regs
index|[
name|FRAME_PC
index|]
operator|-=
literal|4
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
block|}
name|ucode
operator|=
name|a0
expr_stmt|;
comment|/* trap type */
name|i
operator|=
name|SIGTRAP
expr_stmt|;
break|break;
case|case
name|ALPHA_IF_CODE_OPDEC
case|:
name|i
operator|=
name|handle_opdec
argument_list|(
name|td
argument_list|,
operator|&
name|ucode
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
break|break;
case|case
name|ALPHA_IF_CODE_FEN
case|:
comment|/* 			 * on exit from the kernel, if thread == fpcurthread, 			 * FP is enabled. 			 */
if|if
condition|(
name|PCPU_GET
argument_list|(
name|fpcurthread
argument_list|)
operator|==
name|td
condition|)
block|{
name|printf
argument_list|(
literal|"trap: fp disabled for fpcurthread == %p"
argument_list|,
name|td
argument_list|)
expr_stmt|;
goto|goto
name|dopanic
goto|;
block|}
name|alpha_fpstate_switch
argument_list|(
name|td
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
default|default:
name|printf
argument_list|(
literal|"trap: unknown IF type 0x%lx\n"
argument_list|,
name|a0
argument_list|)
expr_stmt|;
goto|goto
name|dopanic
goto|;
block|}
break|break;
case|case
name|ALPHA_KENTRY_MM
case|:
switch|switch
condition|(
name|a1
condition|)
block|{
case|case
name|ALPHA_MMCSR_FOR
case|:
case|case
name|ALPHA_MMCSR_FOE
case|:
case|case
name|ALPHA_MMCSR_FOW
case|:
name|pmap_emulate_reference
argument_list|(
name|p
operator|->
name|p_vmspace
argument_list|,
name|a0
argument_list|,
name|user
argument_list|,
name|a1
operator|==
name|ALPHA_MMCSR_FOW
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
case|case
name|ALPHA_MMCSR_INVALTRANS
case|:
case|case
name|ALPHA_MMCSR_ACCESS
case|:
block|{
specifier|register
name|vm_offset_t
name|va
decl_stmt|;
specifier|register
name|struct
name|vmspace
modifier|*
name|vm
init|=
name|NULL
decl_stmt|;
specifier|register
name|vm_map_t
name|map
decl_stmt|;
name|vm_prot_t
name|ftype
init|=
literal|0
decl_stmt|;
name|int
name|rv
decl_stmt|;
comment|/* 			 * If it was caused by fuswintr or suswintr, 			 * just punt.  Note that we check the faulting 			 * address against the address accessed by 			 * [fs]uswintr, in case another fault happens 			 * when they are running. 			 */
if|if
condition|(
operator|!
name|user
operator|&&
name|td
operator|!=
name|NULL
operator|&&
name|td
operator|->
name|td_pcb
operator|->
name|pcb_onfault
operator|==
operator|(
name|unsigned
name|long
operator|)
name|fswintrberr
operator|&&
name|td
operator|->
name|td_pcb
operator|->
name|pcb_accessaddr
operator|==
name|a0
condition|)
block|{
name|framep
operator|->
name|tf_regs
index|[
name|FRAME_PC
index|]
operator|=
name|td
operator|->
name|td_pcb
operator|->
name|pcb_onfault
expr_stmt|;
name|td
operator|->
name|td_pcb
operator|->
name|pcb_onfault
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
comment|/* 			 * It is only a kernel address space fault iff: 			 *	1. !user and 			 *	2. pcb_onfault not set or 			 *	3. pcb_onfault set but kernel space data fault 			 * The last can occur during an exec() copyin where the 			 * argument space is lazy-allocated. 			 * 			 * For the purposes of the Linux emulator, we allow 			 * kernel accesses to a small region of the 			 * user stack which the emulator uses to 			 * translate syscall arguments. 			 */
if|if
condition|(
operator|!
name|user
operator|&&
operator|(
operator|(
name|a0
operator|>=
name|VM_MIN_KERNEL_ADDRESS
operator|)
operator|||
operator|(
name|td
operator|==
name|NULL
operator|)
operator|||
operator|(
name|td
operator|->
name|td_pcb
operator|->
name|pcb_onfault
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|a0
operator|>=
name|trunc_page
argument_list|(
name|PS_STRINGS
operator|-
name|szsigcode
operator|-
name|SPARE_USRSPACE
argument_list|)
operator|&&
name|a0
operator|<
name|round_page
argument_list|(
name|PS_STRINGS
operator|-
name|szsigcode
argument_list|)
condition|)
block|{
name|vm
operator|=
name|p
operator|->
name|p_vmspace
expr_stmt|;
name|map
operator|=
operator|&
name|vm
operator|->
name|vm_map
expr_stmt|;
block|}
else|else
block|{
name|map
operator|=
name|kernel_map
expr_stmt|;
block|}
block|}
else|else
block|{
name|vm
operator|=
name|p
operator|->
name|p_vmspace
expr_stmt|;
name|map
operator|=
operator|&
name|vm
operator|->
name|vm_map
expr_stmt|;
block|}
switch|switch
condition|(
name|a2
condition|)
block|{
case|case
operator|-
literal|1
case|:
comment|/* instruction fetch fault */
case|case
literal|0
case|:
comment|/* load instruction */
name|ftype
operator|=
name|VM_PROT_READ
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* store instruction */
name|ftype
operator|=
name|VM_PROT_WRITE
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
default|default:
comment|/* XXX gcc -Wuninitialized */
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
goto|goto
name|dopanic
goto|;
endif|#
directive|endif
block|}
name|va
operator|=
name|trunc_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|a0
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|!=
name|kernel_map
condition|)
block|{
comment|/* 				 * Keep swapout from messing with us 				 * during thiscritical time. 				 */
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|++
name|p
operator|->
name|p_lock
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* 				 * Grow the stack if necessary 				 */
comment|/* vm_map_growstack fails only if va falls into 				 * a growable stack region and the stack growth 				 * fails.  It succeeds if va was not within 				 * a growable stack region, or if the stack  				 * growth succeeded. 				 */
if|if
condition|(
name|vm_map_growstack
argument_list|(
name|p
argument_list|,
name|va
argument_list|)
operator|!=
name|KERN_SUCCESS
condition|)
name|rv
operator|=
name|KERN_FAILURE
expr_stmt|;
else|else
comment|/* Fault in the user page: */
name|rv
operator|=
name|vm_fault
argument_list|(
name|map
argument_list|,
name|va
argument_list|,
name|ftype
argument_list|,
operator|(
name|ftype
operator|&
name|VM_PROT_WRITE
operator|)
condition|?
name|VM_FAULT_DIRTY
else|:
name|VM_FAULT_NORMAL
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|--
name|p
operator|->
name|p_lock
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Don't have to worry about process 				 * locking or stacks in the kernel. 				 */
name|rv
operator|=
name|vm_fault
argument_list|(
name|map
argument_list|,
name|va
argument_list|,
name|ftype
argument_list|,
name|VM_FAULT_NORMAL
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * If this was a stack access we keep track of the 			 * maximum accessed stack size.  Also, if vm_fault 			 * gets a protection failure it is due to accessing 			 * the stack region outside the current limit and 			 * we need to reflect that as an access error. 			 */
if|if
condition|(
name|map
operator|!=
name|kernel_map
operator|&&
operator|(
name|caddr_t
operator|)
name|va
operator|>=
name|vm
operator|->
name|vm_maxsaddr
operator|&&
operator|(
name|caddr_t
operator|)
name|va
operator|<
operator|(
name|caddr_t
operator|)
name|USRSTACK
condition|)
block|{
if|if
condition|(
name|rv
operator|==
name|KERN_SUCCESS
condition|)
block|{
name|unsigned
name|long
name|nss
decl_stmt|,
name|rp
decl_stmt|;
name|rp
operator|=
name|round_page
argument_list|(
name|USRSTACK
operator|-
name|va
argument_list|)
expr_stmt|;
name|nss
operator|=
name|alpha_btop
argument_list|(
name|rp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nss
operator|>
name|vm
operator|->
name|vm_ssize
condition|)
name|vm
operator|->
name|vm_ssize
operator|=
name|nss
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rv
operator|==
name|KERN_PROTECTION_FAILURE
condition|)
name|rv
operator|=
name|KERN_INVALID_ADDRESS
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
name|KERN_SUCCESS
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|!
name|user
condition|)
block|{
comment|/* Check for copyin/copyout fault */
if|if
condition|(
name|td
operator|!=
name|NULL
operator|&&
name|td
operator|->
name|td_pcb
operator|->
name|pcb_onfault
operator|!=
literal|0
condition|)
block|{
name|framep
operator|->
name|tf_regs
index|[
name|FRAME_PC
index|]
operator|=
name|td
operator|->
name|td_pcb
operator|->
name|pcb_onfault
expr_stmt|;
name|td
operator|->
name|td_pcb
operator|->
name|pcb_onfault
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
goto|goto
name|dopanic
goto|;
block|}
name|ucode
operator|=
name|a0
expr_stmt|;
name|i
operator|=
name|SIGSEGV
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printtrap
argument_list|(
name|a0
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|entry
argument_list|,
name|framep
argument_list|,
literal|1
argument_list|,
name|user
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
default|default:
name|printf
argument_list|(
literal|"trap: unknown MMCSR value 0x%lx\n"
argument_list|,
name|a1
argument_list|)
expr_stmt|;
goto|goto
name|dopanic
goto|;
block|}
break|break;
default|default:
goto|goto
name|dopanic
goto|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|printtrap
argument_list|(
name|a0
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|entry
argument_list|,
name|framep
argument_list|,
literal|1
argument_list|,
name|user
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|framep
operator|->
name|tf_regs
index|[
name|FRAME_TRAPARG_A0
index|]
operator|=
name|a0
expr_stmt|;
name|framep
operator|->
name|tf_regs
index|[
name|FRAME_TRAPARG_A1
index|]
operator|=
name|a1
expr_stmt|;
name|framep
operator|->
name|tf_regs
index|[
name|FRAME_TRAPARG_A2
index|]
operator|=
name|a2
expr_stmt|;
name|trapsignal
argument_list|(
name|p
argument_list|,
name|i
argument_list|,
name|ucode
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|user
condition|)
block|{
name|framep
operator|->
name|tf_regs
index|[
name|FRAME_SP
index|]
operator|=
name|alpha_pal_rdusp
argument_list|()
expr_stmt|;
name|userret
argument_list|(
name|td
argument_list|,
name|framep
argument_list|,
name|sticks
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|Giant
argument_list|,
name|MA_NOTOWNED
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|cred_free_thread
argument_list|(
name|td
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return;
name|dopanic
label|:
name|printtrap
argument_list|(
name|a0
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|entry
argument_list|,
name|framep
argument_list|,
literal|1
argument_list|,
name|user
argument_list|)
expr_stmt|;
comment|/* XXX dump registers */
ifdef|#
directive|ifdef
name|DDB
name|kdb_trap
argument_list|(
name|a0
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|entry
argument_list|,
name|framep
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|panic
argument_list|(
literal|"trap"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process a system call.  *  * System calls are strange beasts.  They are passed the syscall number  * in v0, and the arguments in the registers (as normal).  They return  * an error flag in a3 (if a3 != 0 on return, the syscall had an error),  * and the return value (if any) in v0.  *  * The assembly stub takes care of moving the call number into a register  * we can get to, and moves all of the argument registers into their places  * in the trap frame.  On return, it restores the callee-saved registers,  * a3, and v0 from the frame before returning to the user process.  */
end_comment

begin_function
name|void
name|syscall
parameter_list|(
name|code
parameter_list|,
name|framep
parameter_list|)
name|u_int64_t
name|code
decl_stmt|;
name|struct
name|trapframe
modifier|*
name|framep
decl_stmt|;
block|{
name|struct
name|sysent
modifier|*
name|callp
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|u_int64_t
name|opc
decl_stmt|;
name|u_int
name|sticks
decl_stmt|;
name|u_int64_t
name|args
index|[
literal|10
index|]
decl_stmt|;
comment|/* XXX */
name|u_int
name|hidden
init|=
literal|0
decl_stmt|,
name|nargs
decl_stmt|;
ifdef|#
directive|ifdef
name|SMP
name|register_t
name|s
decl_stmt|;
endif|#
directive|endif
comment|/* 	 * Find our per-cpu globals. 	 */
ifdef|#
directive|ifdef
name|SMP
name|s
operator|=
name|intr_disable
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|pcpup
operator|=
operator|(
expr|struct
name|pcpu
operator|*
operator|)
name|alpha_pal_rdval
argument_list|()
expr_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
name|td
operator|->
name|td_md
operator|.
name|md_kernnest
operator|++
expr_stmt|;
name|intr_restore
argument_list|(
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
name|framep
operator|->
name|tf_regs
index|[
name|FRAME_TRAPARG_A0
index|]
operator|=
literal|0
expr_stmt|;
name|framep
operator|->
name|tf_regs
index|[
name|FRAME_TRAPARG_A1
index|]
operator|=
literal|0
expr_stmt|;
name|framep
operator|->
name|tf_regs
index|[
name|FRAME_TRAPARG_A2
index|]
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|notdef
comment|/* can't happen, ever. */
if|if
condition|(
operator|(
name|framep
operator|->
name|tf_regs
index|[
name|FRAME_PS
index|]
operator|&
name|ALPHA_PSL_USERMODE
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"syscall"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cnt
operator|.
name|v_syscall
operator|++
expr_stmt|;
name|td
operator|->
name|td_frame
operator|=
name|framep
expr_stmt|;
name|opc
operator|=
name|framep
operator|->
name|tf_regs
index|[
name|FRAME_PC
index|]
operator|-
literal|4
expr_stmt|;
name|sticks
operator|=
name|td
operator|->
name|td_kse
operator|->
name|ke_sticks
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_ucred
operator|!=
name|p
operator|->
name|p_ucred
condition|)
name|cred_update_thread
argument_list|(
name|td
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|alpha_fpstate_check
argument_list|(
name|td
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|p
operator|->
name|p_sysent
operator|->
name|sv_prepsyscall
condition|)
block|{
comment|/* (*p->p_sysent->sv_prepsyscall)(framep, args,&code,&params); */
name|panic
argument_list|(
literal|"prepsyscall"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * syscall() and __syscall() are handled the same on 		 * the alpha, as everything is 64-bit aligned, anyway. 		 */
if|if
condition|(
name|code
operator|==
name|SYS_syscall
operator|||
name|code
operator|==
name|SYS___syscall
condition|)
block|{
comment|/* 			 * Code is first argument, followed by actual args. 			 */
name|code
operator|=
name|framep
operator|->
name|tf_regs
index|[
name|FRAME_A0
index|]
expr_stmt|;
name|hidden
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p
operator|->
name|p_sysent
operator|->
name|sv_mask
condition|)
name|code
operator|&=
name|p
operator|->
name|p_sysent
operator|->
name|sv_mask
expr_stmt|;
if|if
condition|(
name|code
operator|>=
name|p
operator|->
name|p_sysent
operator|->
name|sv_size
condition|)
name|callp
operator|=
operator|&
name|p
operator|->
name|p_sysent
operator|->
name|sv_table
index|[
literal|0
index|]
expr_stmt|;
else|else
name|callp
operator|=
operator|&
name|p
operator|->
name|p_sysent
operator|->
name|sv_table
index|[
name|code
index|]
expr_stmt|;
name|nargs
operator|=
operator|(
name|callp
operator|->
name|sy_narg
operator|&
name|SYF_ARGMASK
operator|)
operator|+
name|hidden
expr_stmt|;
switch|switch
condition|(
name|nargs
condition|)
block|{
default|default:
if|if
condition|(
name|nargs
operator|>
literal|10
condition|)
comment|/* XXX */
name|panic
argument_list|(
literal|"syscall: too many args (%d)"
argument_list|,
name|nargs
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
call|(
name|caddr_t
call|)
argument_list|(
name|alpha_pal_rdusp
argument_list|()
argument_list|)
argument_list|,
operator|&
name|args
index|[
literal|6
index|]
argument_list|,
operator|(
name|nargs
operator|-
literal|6
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|u_int64_t
argument_list|)
argument_list|)
expr_stmt|;
case|case
literal|6
case|:
name|args
index|[
literal|5
index|]
operator|=
name|framep
operator|->
name|tf_regs
index|[
name|FRAME_A5
index|]
expr_stmt|;
case|case
literal|5
case|:
name|args
index|[
literal|4
index|]
operator|=
name|framep
operator|->
name|tf_regs
index|[
name|FRAME_A4
index|]
expr_stmt|;
case|case
literal|4
case|:
name|args
index|[
literal|3
index|]
operator|=
name|framep
operator|->
name|tf_regs
index|[
name|FRAME_A3
index|]
expr_stmt|;
case|case
literal|3
case|:
name|args
index|[
literal|2
index|]
operator|=
name|framep
operator|->
name|tf_regs
index|[
name|FRAME_A2
index|]
expr_stmt|;
case|case
literal|2
case|:
name|args
index|[
literal|1
index|]
operator|=
name|framep
operator|->
name|tf_regs
index|[
name|FRAME_A1
index|]
expr_stmt|;
case|case
literal|1
case|:
name|args
index|[
literal|0
index|]
operator|=
name|framep
operator|->
name|tf_regs
index|[
name|FRAME_A0
index|]
expr_stmt|;
case|case
literal|0
case|:
break|break;
block|}
comment|/* 	 * Try to run the syscall without the MP lock if the syscall 	 * is MP safe 	 */
if|if
condition|(
operator|(
name|callp
operator|->
name|sy_narg
operator|&
name|SYF_MPSAFE
operator|)
operator|==
literal|0
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|KTRACE
if|if
condition|(
name|KTRPOINT
argument_list|(
name|p
argument_list|,
name|KTR_SYSCALL
argument_list|)
condition|)
block|{
name|ktrsyscall
argument_list|(
name|p
operator|->
name|p_tracep
argument_list|,
name|code
argument_list|,
operator|(
name|callp
operator|->
name|sy_narg
operator|&
name|SYF_ARGMASK
operator|)
argument_list|,
name|args
operator|+
name|hidden
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|STOPEVENT
argument_list|(
name|p
argument_list|,
name|S_SCE
argument_list|,
operator|(
name|callp
operator|->
name|sy_narg
operator|&
name|SYF_ARGMASK
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
call|(
modifier|*
name|callp
operator|->
name|sy_call
call|)
argument_list|(
name|td
argument_list|,
name|args
operator|+
name|hidden
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|error
condition|)
block|{
case|case
literal|0
case|:
name|framep
operator|->
name|tf_regs
index|[
name|FRAME_V0
index|]
operator|=
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
expr_stmt|;
name|framep
operator|->
name|tf_regs
index|[
name|FRAME_A4
index|]
operator|=
name|td
operator|->
name|td_retval
index|[
literal|1
index|]
expr_stmt|;
name|framep
operator|->
name|tf_regs
index|[
name|FRAME_A3
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ERESTART
case|:
name|framep
operator|->
name|tf_regs
index|[
name|FRAME_PC
index|]
operator|=
name|opc
expr_stmt|;
break|break;
case|case
name|EJUSTRETURN
case|:
break|break;
default|default:
if|if
condition|(
name|p
operator|->
name|p_sysent
operator|->
name|sv_errsize
condition|)
block|{
if|if
condition|(
name|error
operator|>=
name|p
operator|->
name|p_sysent
operator|->
name|sv_errsize
condition|)
name|error
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* XXX */
else|else
name|error
operator|=
name|p
operator|->
name|p_sysent
operator|->
name|sv_errtbl
index|[
name|error
index|]
expr_stmt|;
block|}
name|framep
operator|->
name|tf_regs
index|[
name|FRAME_V0
index|]
operator|=
name|error
expr_stmt|;
name|framep
operator|->
name|tf_regs
index|[
name|FRAME_A3
index|]
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|userret
argument_list|(
name|td
argument_list|,
name|framep
argument_list|,
name|sticks
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KTRACE
if|if
condition|(
name|KTRPOINT
argument_list|(
name|p
argument_list|,
name|KTR_SYSRET
argument_list|)
condition|)
block|{
name|ktrsysret
argument_list|(
name|p
operator|->
name|p_tracep
argument_list|,
name|code
argument_list|,
name|error
argument_list|,
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * Release Giant if we had to get it.  Don't use mtx_owned(), 	 * we want to catch broken syscalls. 	 */
if|if
condition|(
operator|(
name|callp
operator|->
name|sy_narg
operator|&
name|SYF_MPSAFE
operator|)
operator|==
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * This works because errno is findable through the 	 * register set.  If we ever support an emulation where this 	 * is not the case, this code will need to be revisited. 	 */
name|STOPEVENT
argument_list|(
name|p
argument_list|,
name|S_SCX
argument_list|,
name|code
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|cred_free_thread
argument_list|(
name|td
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|WITNESS
if|if
condition|(
name|witness_list
argument_list|(
name|td
argument_list|)
condition|)
block|{
name|panic
argument_list|(
literal|"system call %s returning with mutex(s) held\n"
argument_list|,
name|syscallnames
index|[
name|code
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_NOTOWNED
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|Giant
argument_list|,
name|MA_NOTOWNED
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Unaligned access handler.  It's not clear that this can get much slower...  *  */
end_comment

begin_decl_stmt
specifier|const
specifier|static
name|int
name|reg_to_framereg
index|[
literal|32
index|]
init|=
block|{
name|FRAME_V0
block|,
name|FRAME_T0
block|,
name|FRAME_T1
block|,
name|FRAME_T2
block|,
name|FRAME_T3
block|,
name|FRAME_T4
block|,
name|FRAME_T5
block|,
name|FRAME_T6
block|,
name|FRAME_T7
block|,
name|FRAME_S0
block|,
name|FRAME_S1
block|,
name|FRAME_S2
block|,
name|FRAME_S3
block|,
name|FRAME_S4
block|,
name|FRAME_S5
block|,
name|FRAME_S6
block|,
name|FRAME_A0
block|,
name|FRAME_A1
block|,
name|FRAME_A2
block|,
name|FRAME_A3
block|,
name|FRAME_A4
block|,
name|FRAME_A5
block|,
name|FRAME_T8
block|,
name|FRAME_T9
block|,
name|FRAME_T10
block|,
name|FRAME_T11
block|,
name|FRAME_RA
block|,
name|FRAME_T12
block|,
name|FRAME_AT
block|,
name|FRAME_GP
block|,
name|FRAME_SP
block|,
operator|-
literal|1
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|irp
parameter_list|(
name|td
parameter_list|,
name|reg
parameter_list|)
define|\
value|((reg_to_framereg[(reg)] == -1) ? NULL :			\&(td)->td_frame->tf_regs[reg_to_framereg[(reg)]])
end_define

begin_define
define|#
directive|define
name|frp
parameter_list|(
name|td
parameter_list|,
name|reg
parameter_list|)
define|\
value|(&(td)->td_pcb->pcb_fp.fpr_regs[(reg)])
end_define

begin_define
define|#
directive|define
name|unaligned_load
parameter_list|(
name|storage
parameter_list|,
name|ptrf
parameter_list|,
name|mod
parameter_list|)
define|\
value|if (copyin((caddr_t)va,&(storage), sizeof (storage)) == 0&&	\ 	    (regptr = ptrf(td, reg)) != NULL)				\ 		signal = 0;						\ 	else								\ 		break;							\ 	*regptr = mod (storage);
end_define

begin_define
define|#
directive|define
name|unaligned_store
parameter_list|(
name|storage
parameter_list|,
name|ptrf
parameter_list|,
name|mod
parameter_list|)
define|\
value|if ((regptr = ptrf(td, reg)) == NULL)				\ 		(storage) = 0;						\ 	else								\ 		(storage) = mod (*regptr);				\ 	if (copyout(&(storage), (caddr_t)va, sizeof (storage)) == 0)	\ 		signal = 0;						\ 	else								\ 		break;
end_define

begin_define
define|#
directive|define
name|unaligned_load_integer
parameter_list|(
name|storage
parameter_list|)
define|\
value|unaligned_load(storage, irp, )
end_define

begin_define
define|#
directive|define
name|unaligned_store_integer
parameter_list|(
name|storage
parameter_list|)
define|\
value|unaligned_store(storage, irp, )
end_define

begin_define
define|#
directive|define
name|unaligned_load_floating
parameter_list|(
name|storage
parameter_list|,
name|mod
parameter_list|)
define|\
value|alpha_fpstate_save(td, 1);					\ 	unaligned_load(storage, frp, mod)
end_define

begin_define
define|#
directive|define
name|unaligned_store_floating
parameter_list|(
name|storage
parameter_list|,
name|mod
parameter_list|)
define|\
value|alpha_fpstate_save(td, 0);					\ 	unaligned_store(storage, frp, mod)
end_define

begin_function
name|unsigned
name|long
name|Sfloat_to_reg
parameter_list|(
name|s
parameter_list|)
name|unsigned
name|int
name|s
decl_stmt|;
block|{
name|unsigned
name|long
name|sign
decl_stmt|,
name|expn
decl_stmt|,
name|frac
decl_stmt|;
name|unsigned
name|long
name|result
decl_stmt|;
name|sign
operator|=
operator|(
name|s
operator|&
literal|0x80000000
operator|)
operator|>>
literal|31
expr_stmt|;
name|expn
operator|=
operator|(
name|s
operator|&
literal|0x7f800000
operator|)
operator|>>
literal|23
expr_stmt|;
name|frac
operator|=
operator|(
name|s
operator|&
literal|0x007fffff
operator|)
operator|>>
literal|0
expr_stmt|;
comment|/* map exponent part, as appropriate. */
if|if
condition|(
name|expn
operator|==
literal|0xff
condition|)
name|expn
operator|=
literal|0x7ff
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|expn
operator|&
literal|0x80
operator|)
operator|!=
literal|0
condition|)
name|expn
operator|=
operator|(
literal|0x400
operator||
operator|(
name|expn
operator|&
operator|~
literal|0x80
operator|)
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|expn
operator|&
literal|0x80
operator|)
operator|==
literal|0
operator|&&
name|expn
operator|!=
literal|0
condition|)
name|expn
operator|=
operator|(
literal|0x380
operator||
operator|(
name|expn
operator|&
operator|~
literal|0x80
operator|)
operator|)
expr_stmt|;
name|result
operator|=
operator|(
name|sign
operator|<<
literal|63
operator|)
operator||
operator|(
name|expn
operator|<<
literal|52
operator|)
operator||
operator|(
name|frac
operator|<<
literal|29
operator|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|unsigned
name|int
name|reg_to_Sfloat
parameter_list|(
name|r
parameter_list|)
name|unsigned
name|long
name|r
decl_stmt|;
block|{
name|unsigned
name|long
name|sign
decl_stmt|,
name|expn
decl_stmt|,
name|frac
decl_stmt|;
name|unsigned
name|int
name|result
decl_stmt|;
name|sign
operator|=
operator|(
name|r
operator|&
literal|0x8000000000000000
operator|)
operator|>>
literal|63
expr_stmt|;
name|expn
operator|=
operator|(
name|r
operator|&
literal|0x7ff0000000000000
operator|)
operator|>>
literal|52
expr_stmt|;
name|frac
operator|=
operator|(
name|r
operator|&
literal|0x000fffffe0000000
operator|)
operator|>>
literal|29
expr_stmt|;
comment|/* map exponent part, as appropriate. */
name|expn
operator|=
operator|(
name|expn
operator|&
literal|0x7f
operator|)
operator||
operator|(
operator|(
name|expn
operator|&
literal|0x400
operator|)
operator|!=
literal|0
condition|?
literal|0x80
else|:
literal|0x00
operator|)
expr_stmt|;
name|result
operator|=
operator|(
name|sign
operator|<<
literal|31
operator|)
operator||
operator|(
name|expn
operator|<<
literal|23
operator|)
operator||
operator|(
name|frac
operator|<<
literal|0
operator|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Conversion of T floating datums to and from register format  * requires no bit reordering whatsoever.  */
end_comment

begin_function
name|unsigned
name|long
name|Tfloat_reg_cvt
parameter_list|(
name|input
parameter_list|)
name|unsigned
name|long
name|input
decl_stmt|;
block|{
return|return
operator|(
name|input
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|FIX_UNALIGNED_VAX_FP
end_ifdef

begin_function
name|unsigned
name|long
name|Ffloat_to_reg
parameter_list|(
name|f
parameter_list|)
name|unsigned
name|int
name|f
decl_stmt|;
block|{
name|unsigned
name|long
name|sign
decl_stmt|,
name|expn
decl_stmt|,
name|frlo
decl_stmt|,
name|frhi
decl_stmt|;
name|unsigned
name|long
name|result
decl_stmt|;
name|sign
operator|=
operator|(
name|f
operator|&
literal|0x00008000
operator|)
operator|>>
literal|15
expr_stmt|;
name|expn
operator|=
operator|(
name|f
operator|&
literal|0x00007f80
operator|)
operator|>>
literal|7
expr_stmt|;
name|frhi
operator|=
operator|(
name|f
operator|&
literal|0x0000007f
operator|)
operator|>>
literal|0
expr_stmt|;
name|frlo
operator|=
operator|(
name|f
operator|&
literal|0xffff0000
operator|)
operator|>>
literal|16
expr_stmt|;
comment|/* map exponent part, as appropriate. */
if|if
condition|(
operator|(
name|expn
operator|&
literal|0x80
operator|)
operator|!=
literal|0
condition|)
name|expn
operator|=
operator|(
literal|0x400
operator||
operator|(
name|expn
operator|&
operator|~
literal|0x80
operator|)
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|expn
operator|&
literal|0x80
operator|)
operator|==
literal|0
operator|&&
name|expn
operator|!=
literal|0
condition|)
name|expn
operator|=
operator|(
literal|0x380
operator||
operator|(
name|expn
operator|&
operator|~
literal|0x80
operator|)
operator|)
expr_stmt|;
name|result
operator|=
operator|(
name|sign
operator|<<
literal|63
operator|)
operator||
operator|(
name|expn
operator|<<
literal|52
operator|)
operator||
operator|(
name|frhi
operator|<<
literal|45
operator|)
operator||
operator|(
name|frlo
operator|<<
literal|29
operator|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|unsigned
name|int
name|reg_to_Ffloat
parameter_list|(
name|r
parameter_list|)
name|unsigned
name|long
name|r
decl_stmt|;
block|{
name|unsigned
name|long
name|sign
decl_stmt|,
name|expn
decl_stmt|,
name|frhi
decl_stmt|,
name|frlo
decl_stmt|;
name|unsigned
name|int
name|result
decl_stmt|;
name|sign
operator|=
operator|(
name|r
operator|&
literal|0x8000000000000000
operator|)
operator|>>
literal|63
expr_stmt|;
name|expn
operator|=
operator|(
name|r
operator|&
literal|0x7ff0000000000000
operator|)
operator|>>
literal|52
expr_stmt|;
name|frhi
operator|=
operator|(
name|r
operator|&
literal|0x000fe00000000000
operator|)
operator|>>
literal|45
expr_stmt|;
name|frlo
operator|=
operator|(
name|r
operator|&
literal|0x00001fffe0000000
operator|)
operator|>>
literal|29
expr_stmt|;
comment|/* map exponent part, as appropriate. */
name|expn
operator|=
operator|(
name|expn
operator|&
literal|0x7f
operator|)
operator||
operator|(
operator|(
name|expn
operator|&
literal|0x400
operator|)
operator|!=
literal|0
condition|?
literal|0x80
else|:
literal|0x00
operator|)
expr_stmt|;
name|result
operator|=
operator|(
name|sign
operator|<<
literal|15
operator|)
operator||
operator|(
name|expn
operator|<<
literal|7
operator|)
operator||
operator|(
name|frhi
operator|<<
literal|0
operator|)
operator||
operator|(
name|frlo
operator|<<
literal|16
operator|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Conversion of G floating datums to and from register format is  * symmetrical.  Just swap shorts in the quad...  */
end_comment

begin_function
name|unsigned
name|long
name|Gfloat_reg_cvt
parameter_list|(
name|input
parameter_list|)
name|unsigned
name|long
name|input
decl_stmt|;
block|{
name|unsigned
name|long
name|a
decl_stmt|,
name|b
decl_stmt|,
name|c
decl_stmt|,
name|d
decl_stmt|;
name|unsigned
name|long
name|result
decl_stmt|;
name|a
operator|=
operator|(
name|input
operator|&
literal|0x000000000000ffff
operator|)
operator|>>
literal|0
expr_stmt|;
name|b
operator|=
operator|(
name|input
operator|&
literal|0x00000000ffff0000
operator|)
operator|>>
literal|16
expr_stmt|;
name|c
operator|=
operator|(
name|input
operator|&
literal|0x0000ffff00000000
operator|)
operator|>>
literal|32
expr_stmt|;
name|d
operator|=
operator|(
name|input
operator|&
literal|0xffff000000000000
operator|)
operator|>>
literal|48
expr_stmt|;
name|result
operator|=
operator|(
name|a
operator|<<
literal|48
operator|)
operator||
operator|(
name|b
operator|<<
literal|32
operator|)
operator||
operator|(
name|c
operator|<<
literal|16
operator|)
operator||
operator|(
name|d
operator|<<
literal|0
operator|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FIX_UNALIGNED_VAX_FP */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|alpha_unaligned_print
decl_stmt|,
name|alpha_unaligned_fix
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|alpha_unaligned_sigbus
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|unaligned_fixup
parameter_list|(
name|va
parameter_list|,
name|opcode
parameter_list|,
name|reg
parameter_list|,
name|td
parameter_list|)
name|unsigned
name|long
name|va
decl_stmt|,
name|opcode
decl_stmt|,
name|reg
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
block|{
name|int
name|doprint
decl_stmt|,
name|dofix
decl_stmt|,
name|dosigbus
decl_stmt|;
name|int
name|signal
decl_stmt|,
name|size
decl_stmt|;
specifier|const
name|char
modifier|*
name|type
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|unsigned
name|long
modifier|*
name|regptr
decl_stmt|,
name|longdata
decl_stmt|,
name|uac
decl_stmt|;
name|int
name|intdata
decl_stmt|;
comment|/* signed to get extension when storing */
struct|struct
block|{
specifier|const
name|char
modifier|*
name|type
decl_stmt|;
comment|/* opcode name */
name|int
name|size
decl_stmt|;
comment|/* size, 0 if fixup not supported */
block|}
name|tab
index|[
literal|0x10
index|]
init|=
block|{
ifdef|#
directive|ifdef
name|FIX_UNALIGNED_VAX_FP
block|{
literal|"ldf"
block|,
literal|4
block|}
block|,
block|{
literal|"ldg"
block|,
literal|8
block|}
block|,
else|#
directive|else
block|{
literal|"ldf"
block|,
literal|0
block|}
block|,
block|{
literal|"ldg"
block|,
literal|0
block|}
block|,
endif|#
directive|endif
block|{
literal|"lds"
block|,
literal|4
block|}
block|,
block|{
literal|"ldt"
block|,
literal|8
block|}
block|,
ifdef|#
directive|ifdef
name|FIX_UNALIGNED_VAX_FP
block|{
literal|"stf"
block|,
literal|4
block|}
block|,
block|{
literal|"stg"
block|,
literal|8
block|}
block|,
else|#
directive|else
block|{
literal|"stf"
block|,
literal|0
block|}
block|,
block|{
literal|"stg"
block|,
literal|0
block|}
block|,
endif|#
directive|endif
block|{
literal|"sts"
block|,
literal|4
block|}
block|,
block|{
literal|"stt"
block|,
literal|8
block|}
block|,
block|{
literal|"ldl"
block|,
literal|4
block|}
block|,
block|{
literal|"ldq"
block|,
literal|8
block|}
block|,
block|{
literal|"ldl_l"
block|,
literal|0
block|}
block|,
block|{
literal|"ldq_l"
block|,
literal|0
block|}
block|,
comment|/* can't fix */
block|{
literal|"stl"
block|,
literal|4
block|}
block|,
block|{
literal|"stq"
block|,
literal|8
block|}
block|,
block|{
literal|"stl_c"
block|,
literal|0
block|}
block|,
block|{
literal|"stq_c"
block|,
literal|0
block|}
block|,
comment|/* can't fix */
block|}
struct|;
comment|/* 	 * Figure out what actions to take. 	 * 	 */
if|if
condition|(
name|td
condition|)
block|{
name|uac
operator|=
name|td
operator|->
name|td_md
operator|.
name|md_flags
operator|&
name|MDP_UAC_MASK
expr_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
block|}
else|else
block|{
name|uac
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|NULL
expr_stmt|;
block|}
name|doprint
operator|=
name|alpha_unaligned_print
operator|&&
operator|!
operator|(
name|uac
operator|&
name|MDP_UAC_NOPRINT
operator|)
expr_stmt|;
name|dofix
operator|=
name|alpha_unaligned_fix
operator|&&
operator|!
operator|(
name|uac
operator|&
name|MDP_UAC_NOFIX
operator|)
expr_stmt|;
name|dosigbus
operator|=
name|alpha_unaligned_sigbus
operator||
operator|(
name|uac
operator|&
name|MDP_UAC_SIGBUS
operator|)
expr_stmt|;
comment|/* 	 * Find out which opcode it is.  Arrange to have the opcode 	 * printed if it's an unknown opcode. 	 */
if|if
condition|(
name|opcode
operator|>=
literal|0x20
operator|&&
name|opcode
operator|<=
literal|0x2f
condition|)
block|{
name|type
operator|=
name|tab
index|[
name|opcode
operator|-
literal|0x20
index|]
operator|.
name|type
expr_stmt|;
name|size
operator|=
name|tab
index|[
name|opcode
operator|-
literal|0x20
index|]
operator|.
name|size
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
literal|"0x%lx"
expr_stmt|;
name|size
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * See if the user can access the memory in question. 	 * Even if it's an unknown opcode, SEGV if the access 	 * should have failed. 	 */
if|if
condition|(
operator|!
name|useracc
argument_list|(
operator|(
name|caddr_t
operator|)
name|va
argument_list|,
name|size
condition|?
name|size
else|:
literal|1
argument_list|,
name|VM_PROT_WRITE
argument_list|)
condition|)
block|{
name|signal
operator|=
name|SIGSEGV
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * If we're supposed to be noisy, squawk now. 	 */
if|if
condition|(
name|doprint
condition|)
block|{
name|uprintf
argument_list|(
literal|"pid %d (%s): unaligned access: va=0x%lx pc=0x%lx ra=0x%lx op="
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|p
operator|->
name|p_comm
argument_list|,
name|va
argument_list|,
name|td
operator|->
name|td_frame
operator|->
name|tf_regs
index|[
name|FRAME_PC
index|]
argument_list|,
name|td
operator|->
name|td_frame
operator|->
name|tf_regs
index|[
name|FRAME_RA
index|]
argument_list|)
expr_stmt|;
name|uprintf
argument_list|(
name|type
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
name|uprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we should try to fix it and know how, give it a shot. 	 * 	 * We never allow bad data to be unknowingly used by the 	 * user process.  That is, if we decide not to fix up an 	 * access we cause a SIGBUS rather than letting the user 	 * process go on without warning. 	 * 	 * If we're trying to do a fixup, we assume that things 	 * will be botched.  If everything works out OK,  	 * unaligned_{load,store}_* clears the signal flag. 	 */
name|signal
operator|=
name|SIGBUS
expr_stmt|;
if|if
condition|(
name|dofix
operator|&&
name|size
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
name|opcode
condition|)
block|{
ifdef|#
directive|ifdef
name|FIX_UNALIGNED_VAX_FP
case|case
literal|0x20
case|:
comment|/* ldf */
name|unaligned_load_floating
argument_list|(
name|intdata
argument_list|,
name|Ffloat_to_reg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x21
case|:
comment|/* ldg */
name|unaligned_load_floating
argument_list|(
name|longdata
argument_list|,
name|Gfloat_reg_cvt
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|0x22
case|:
comment|/* lds */
name|unaligned_load_floating
argument_list|(
name|intdata
argument_list|,
name|Sfloat_to_reg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x23
case|:
comment|/* ldt */
name|unaligned_load_floating
argument_list|(
name|longdata
argument_list|,
name|Tfloat_reg_cvt
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|FIX_UNALIGNED_VAX_FP
case|case
literal|0x24
case|:
comment|/* stf */
name|unaligned_store_floating
argument_list|(
name|intdata
argument_list|,
name|reg_to_Ffloat
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x25
case|:
comment|/* stg */
name|unaligned_store_floating
argument_list|(
name|longdata
argument_list|,
name|Gfloat_reg_cvt
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|0x26
case|:
comment|/* sts */
name|unaligned_store_floating
argument_list|(
name|intdata
argument_list|,
name|reg_to_Sfloat
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x27
case|:
comment|/* stt */
name|unaligned_store_floating
argument_list|(
name|longdata
argument_list|,
name|Tfloat_reg_cvt
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x28
case|:
comment|/* ldl */
name|unaligned_load_integer
argument_list|(
name|intdata
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x29
case|:
comment|/* ldq */
name|unaligned_load_integer
argument_list|(
name|longdata
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x2c
case|:
comment|/* stl */
name|unaligned_store_integer
argument_list|(
name|intdata
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x2d
case|:
comment|/* stq */
name|unaligned_store_integer
argument_list|(
name|longdata
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
default|default:
name|panic
argument_list|(
literal|"unaligned_fixup: can't get here"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
comment|/* 	 * Force SIGBUS if requested. 	 */
if|if
condition|(
name|dosigbus
condition|)
name|signal
operator|=
name|SIGBUS
expr_stmt|;
name|out
label|:
return|return
operator|(
name|signal
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Reserved/unimplemented instruction (opDec fault) handler  *  * Argument is the process that caused it.  No useful information  * is passed to the trap handler other than the fault type.  The  * address of the instruction that caused the fault is 4 less than  * the PC stored in the trap frame.  *  * If the instruction is emulated successfully, this function returns 0.  * Otherwise, this function returns the signal to deliver to the process,  * and fills in *ucodep with the code to be delivered.  */
end_comment

begin_function
name|int
name|handle_opdec
parameter_list|(
name|td
parameter_list|,
name|ucodep
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|u_int64_t
modifier|*
name|ucodep
decl_stmt|;
block|{
name|alpha_instruction
name|inst
decl_stmt|;
name|register_t
modifier|*
name|regptr
decl_stmt|,
name|memaddr
decl_stmt|;
name|u_int64_t
name|inst_pc
decl_stmt|;
name|int
name|sig
decl_stmt|;
comment|/* 	 * Read USP into frame in case it's going to be used or modified. 	 * This keeps us from having to check for it in lots of places 	 * later. 	 */
name|td
operator|->
name|td_frame
operator|->
name|tf_regs
index|[
name|FRAME_SP
index|]
operator|=
name|alpha_pal_rdusp
argument_list|()
expr_stmt|;
name|inst_pc
operator|=
name|memaddr
operator|=
name|td
operator|->
name|td_frame
operator|->
name|tf_regs
index|[
name|FRAME_PC
index|]
operator|-
literal|4
expr_stmt|;
if|if
condition|(
name|copyin
argument_list|(
operator|(
name|caddr_t
operator|)
name|inst_pc
argument_list|,
operator|&
name|inst
argument_list|,
sizeof|sizeof
argument_list|(
name|inst
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * really, this should never happen, but in case it 		 * does we handle it. 		 */
name|printf
argument_list|(
literal|"WARNING: handle_opdec() couldn't fetch instruction\n"
argument_list|)
expr_stmt|;
goto|goto
name|sigsegv
goto|;
block|}
switch|switch
condition|(
name|inst
operator|.
name|generic_format
operator|.
name|opcode
condition|)
block|{
case|case
name|op_ldbu
case|:
case|case
name|op_ldwu
case|:
case|case
name|op_stw
case|:
case|case
name|op_stb
case|:
name|regptr
operator|=
name|irp
argument_list|(
name|td
argument_list|,
name|inst
operator|.
name|mem_format
operator|.
name|rs
argument_list|)
expr_stmt|;
if|if
condition|(
name|regptr
operator|!=
name|NULL
condition|)
name|memaddr
operator|=
operator|*
name|regptr
expr_stmt|;
else|else
name|memaddr
operator|=
literal|0
expr_stmt|;
name|memaddr
operator|+=
name|inst
operator|.
name|mem_format
operator|.
name|displacement
expr_stmt|;
name|regptr
operator|=
name|irp
argument_list|(
name|td
argument_list|,
name|inst
operator|.
name|mem_format
operator|.
name|rd
argument_list|)
expr_stmt|;
if|if
condition|(
name|inst
operator|.
name|mem_format
operator|.
name|opcode
operator|==
name|op_ldwu
operator|||
name|inst
operator|.
name|mem_format
operator|.
name|opcode
operator|==
name|op_stw
condition|)
block|{
if|if
condition|(
name|memaddr
operator|&
literal|0x01
condition|)
block|{
name|sig
operator|=
name|unaligned_fixup
argument_list|(
name|memaddr
argument_list|,
name|inst
operator|.
name|mem_format
operator|.
name|opcode
argument_list|,
name|inst
operator|.
name|mem_format
operator|.
name|rd
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|sig
condition|)
goto|goto
name|unaligned_fixup_sig
goto|;
break|break;
block|}
block|}
if|if
condition|(
name|inst
operator|.
name|mem_format
operator|.
name|opcode
operator|==
name|op_ldbu
condition|)
block|{
name|u_int8_t
name|b
decl_stmt|;
comment|/* XXX ONLY WORKS ON LITTLE-ENDIAN ALPHA */
if|if
condition|(
name|copyin
argument_list|(
operator|(
name|caddr_t
operator|)
name|memaddr
argument_list|,
operator|&
name|b
argument_list|,
sizeof|sizeof
argument_list|(
name|b
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|sigsegv
goto|;
if|if
condition|(
name|regptr
operator|!=
name|NULL
condition|)
operator|*
name|regptr
operator|=
name|b
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|inst
operator|.
name|mem_format
operator|.
name|opcode
operator|==
name|op_ldwu
condition|)
block|{
name|u_int16_t
name|w
decl_stmt|;
comment|/* XXX ONLY WORKS ON LITTLE-ENDIAN ALPHA */
if|if
condition|(
name|copyin
argument_list|(
operator|(
name|caddr_t
operator|)
name|memaddr
argument_list|,
operator|&
name|w
argument_list|,
sizeof|sizeof
argument_list|(
name|w
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|sigsegv
goto|;
if|if
condition|(
name|regptr
operator|!=
name|NULL
condition|)
operator|*
name|regptr
operator|=
name|w
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|inst
operator|.
name|mem_format
operator|.
name|opcode
operator|==
name|op_stw
condition|)
block|{
name|u_int16_t
name|w
decl_stmt|;
comment|/* XXX ONLY WORKS ON LITTLE-ENDIAN ALPHA */
name|w
operator|=
operator|(
name|regptr
operator|!=
name|NULL
operator|)
condition|?
operator|*
name|regptr
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|copyout
argument_list|(
operator|&
name|w
argument_list|,
operator|(
name|caddr_t
operator|)
name|memaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|w
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|sigsegv
goto|;
block|}
elseif|else
if|if
condition|(
name|inst
operator|.
name|mem_format
operator|.
name|opcode
operator|==
name|op_stb
condition|)
block|{
name|u_int8_t
name|b
decl_stmt|;
comment|/* XXX ONLY WORKS ON LITTLE-ENDIAN ALPHA */
name|b
operator|=
operator|(
name|regptr
operator|!=
name|NULL
operator|)
condition|?
operator|*
name|regptr
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|copyout
argument_list|(
operator|&
name|b
argument_list|,
operator|(
name|caddr_t
operator|)
name|memaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|b
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|sigsegv
goto|;
block|}
break|break;
case|case
name|op_intmisc
case|:
if|if
condition|(
name|inst
operator|.
name|operate_generic_format
operator|.
name|function
operator|==
name|op_sextb
operator|&&
name|inst
operator|.
name|operate_generic_format
operator|.
name|ra
operator|==
literal|31
condition|)
block|{
name|int8_t
name|b
decl_stmt|;
if|if
condition|(
name|inst
operator|.
name|operate_generic_format
operator|.
name|is_lit
condition|)
block|{
name|b
operator|=
name|inst
operator|.
name|operate_lit_format
operator|.
name|literal
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|inst
operator|.
name|operate_reg_format
operator|.
name|sbz
operator|!=
literal|0
condition|)
goto|goto
name|sigill
goto|;
name|regptr
operator|=
name|irp
argument_list|(
name|td
argument_list|,
name|inst
operator|.
name|operate_reg_format
operator|.
name|rt
argument_list|)
expr_stmt|;
name|b
operator|=
operator|(
name|regptr
operator|!=
name|NULL
operator|)
condition|?
operator|*
name|regptr
else|:
literal|0
expr_stmt|;
block|}
name|regptr
operator|=
name|irp
argument_list|(
name|td
argument_list|,
name|inst
operator|.
name|operate_generic_format
operator|.
name|rc
argument_list|)
expr_stmt|;
if|if
condition|(
name|regptr
operator|!=
name|NULL
condition|)
operator|*
name|regptr
operator|=
name|b
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|inst
operator|.
name|operate_generic_format
operator|.
name|function
operator|==
name|op_sextw
operator|&&
name|inst
operator|.
name|operate_generic_format
operator|.
name|ra
operator|==
literal|31
condition|)
block|{
name|int16_t
name|w
decl_stmt|;
if|if
condition|(
name|inst
operator|.
name|operate_generic_format
operator|.
name|is_lit
condition|)
block|{
name|w
operator|=
name|inst
operator|.
name|operate_lit_format
operator|.
name|literal
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|inst
operator|.
name|operate_reg_format
operator|.
name|sbz
operator|!=
literal|0
condition|)
goto|goto
name|sigill
goto|;
name|regptr
operator|=
name|irp
argument_list|(
name|td
argument_list|,
name|inst
operator|.
name|operate_reg_format
operator|.
name|rt
argument_list|)
expr_stmt|;
name|w
operator|=
operator|(
name|regptr
operator|!=
name|NULL
operator|)
condition|?
operator|*
name|regptr
else|:
literal|0
expr_stmt|;
block|}
name|regptr
operator|=
name|irp
argument_list|(
name|td
argument_list|,
name|inst
operator|.
name|operate_generic_format
operator|.
name|rc
argument_list|)
expr_stmt|;
if|if
condition|(
name|regptr
operator|!=
name|NULL
condition|)
operator|*
name|regptr
operator|=
name|w
expr_stmt|;
break|break;
block|}
goto|goto
name|sigill
goto|;
default|default:
goto|goto
name|sigill
goto|;
block|}
comment|/* 	 * Write back USP.  Note that in the error cases below, 	 * nothing will have been successfully modified so we don't 	 * have to write it out. 	 */
name|alpha_pal_wrusp
argument_list|(
name|td
operator|->
name|td_frame
operator|->
name|tf_regs
index|[
name|FRAME_SP
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|sigill
label|:
operator|*
name|ucodep
operator|=
name|ALPHA_IF_CODE_OPDEC
expr_stmt|;
comment|/* trap type */
return|return
operator|(
name|SIGILL
operator|)
return|;
name|sigsegv
label|:
name|sig
operator|=
name|SIGSEGV
expr_stmt|;
name|td
operator|->
name|td_frame
operator|->
name|tf_regs
index|[
name|FRAME_PC
index|]
operator|=
name|inst_pc
expr_stmt|;
comment|/* re-run instr. */
name|unaligned_fixup_sig
label|:
operator|*
name|ucodep
operator|=
name|memaddr
expr_stmt|;
comment|/* faulting address */
return|return
operator|(
name|sig
operator|)
return|;
block|}
end_function

end_unit

