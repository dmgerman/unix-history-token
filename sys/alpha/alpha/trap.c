begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/* $NetBSD: trap.c,v 1.31 1998/03/26 02:21:46 thorpej Exp $ */
end_comment

begin_comment
comment|/*  * Copyright (c) 1994, 1995, 1996 Carnegie-Mellon University.  * All rights reserved.  *  * Author: Chris G. Demetriou  *   * Permission to use, copy, modify and distribute this software and  * its documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *   * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"   * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND   * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *   * Carnegie Mellon requests users of this software to return to  *  *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *  * any improvements or extensions that they make and grant Carnegie the  * rights to redistribute these changes.  */
end_comment

begin_comment
comment|/* #include "opt_fix_unaligned_vax_fp.h" */
end_comment

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_include
include|#
directive|include
file|"opt_ktrace.h"
end_include

begin_include
include|#
directive|include
file|"opt_simos.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/exec.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmmeter.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysent.h>
end_include

begin_include
include|#
directive|include
file|<sys/syscall.h>
end_include

begin_include
include|#
directive|include
file|<sys/pioctl.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/reg.h>
end_include

begin_include
include|#
directive|include
file|<machine/pal.h>
end_include

begin_include
include|#
directive|include
file|<machine/fpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/smp.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|KTRACE
end_ifdef

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktrace.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_include
include|#
directive|include
file|<ddb/ddb.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|u_int32_t
name|want_resched
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|userret
name|__P
argument_list|(
operator|(
expr|struct
name|proc
operator|*
operator|,
name|u_int64_t
operator|,
name|u_quad_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|long
name|Sfloat_to_reg
name|__P
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
name|reg_to_Sfloat
name|__P
argument_list|(
operator|(
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|long
name|Tfloat_reg_cvt
name|__P
argument_list|(
operator|(
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|FIX_UNALIGNED_VAX_FP
end_ifdef

begin_decl_stmt
name|unsigned
name|long
name|Ffloat_to_reg
name|__P
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
name|reg_to_Ffloat
name|__P
argument_list|(
operator|(
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|long
name|Gfloat_reg_cvt
name|__P
argument_list|(
operator|(
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|unaligned_fixup
name|__P
argument_list|(
operator|(
name|unsigned
name|long
operator|,
name|unsigned
name|long
operator|,
name|unsigned
name|long
operator|,
expr|struct
name|proc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|printtrap
name|__P
argument_list|(
operator|(
specifier|const
name|unsigned
name|long
operator|,
specifier|const
name|unsigned
name|long
operator|,
specifier|const
name|unsigned
name|long
operator|,
specifier|const
name|unsigned
name|long
operator|,
expr|struct
name|trapframe
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|WITNESS
end_ifdef

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|syscallnames
index|[]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Define the code needed before returning to user mode, for  * trap and syscall.  */
end_comment

begin_function
specifier|static
name|int
name|userret
parameter_list|(
name|p
parameter_list|,
name|pc
parameter_list|,
name|oticks
parameter_list|,
name|have_giant
parameter_list|)
specifier|register
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|u_int64_t
name|pc
decl_stmt|;
name|u_quad_t
name|oticks
decl_stmt|;
name|int
name|have_giant
decl_stmt|;
block|{
name|int
name|sig
decl_stmt|,
name|s
decl_stmt|;
comment|/* take pending signals */
while|while
condition|(
operator|(
name|sig
operator|=
name|CURSIG
argument_list|(
name|p
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|have_giant
operator|==
literal|0
condition|)
block|{
name|mtx_enter
argument_list|(
operator|&
name|Giant
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|have_giant
operator|=
literal|1
expr_stmt|;
block|}
name|postsig
argument_list|(
name|sig
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|p_priority
operator|=
name|p
operator|->
name|p_usrpri
expr_stmt|;
if|if
condition|(
name|want_resched
condition|)
block|{
comment|/* 		 * Since we are curproc, a clock interrupt could 		 * change our priority without changing run queues 		 * (the running process is not kept on a run queue). 		 * If this happened after we setrunqueue ourselves but 		 * before we switch()'ed, we might not be on the queue 		 * indicated by our priority. 		 */
name|s
operator|=
name|splstatclock
argument_list|()
expr_stmt|;
name|mtx_enter
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
name|DROP_GIANT_NOSWITCH
argument_list|()
expr_stmt|;
name|setrunqueue
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_stats
operator|->
name|p_ru
operator|.
name|ru_nivcsw
operator|++
expr_stmt|;
name|mi_switch
argument_list|()
expr_stmt|;
name|mtx_exit
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
name|PICKUP_GIANT
argument_list|()
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|sig
operator|=
name|CURSIG
argument_list|(
name|p
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|have_giant
operator|==
literal|0
condition|)
block|{
name|mtx_enter
argument_list|(
operator|&
name|Giant
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|have_giant
operator|=
literal|1
expr_stmt|;
block|}
name|postsig
argument_list|(
name|sig
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * If profiling, charge recent system time to the trapped pc. 	 */
if|if
condition|(
name|p
operator|->
name|p_flag
operator|&
name|P_PROFIL
condition|)
block|{
if|if
condition|(
name|have_giant
operator|==
literal|0
condition|)
block|{
name|mtx_enter
argument_list|(
operator|&
name|Giant
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|have_giant
operator|=
literal|1
expr_stmt|;
block|}
name|addupc_task
argument_list|(
name|p
argument_list|,
name|pc
argument_list|,
call|(
name|int
call|)
argument_list|(
name|p
operator|->
name|p_sticks
operator|-
name|oticks
argument_list|)
operator|*
name|psratio
argument_list|)
expr_stmt|;
block|}
name|curpriority
operator|=
name|p
operator|->
name|p_priority
expr_stmt|;
return|return
operator|(
name|have_giant
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|printtrap
parameter_list|(
name|a0
parameter_list|,
name|a1
parameter_list|,
name|a2
parameter_list|,
name|entry
parameter_list|,
name|framep
parameter_list|,
name|isfatal
parameter_list|,
name|user
parameter_list|)
specifier|const
name|unsigned
name|long
name|a0
decl_stmt|,
name|a1
decl_stmt|,
name|a2
decl_stmt|,
name|entry
decl_stmt|;
name|struct
name|trapframe
modifier|*
name|framep
decl_stmt|;
name|int
name|isfatal
decl_stmt|,
name|user
decl_stmt|;
block|{
name|char
name|ubuf
index|[
literal|64
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|entryname
decl_stmt|;
switch|switch
condition|(
name|entry
condition|)
block|{
case|case
name|ALPHA_KENTRY_INT
case|:
name|entryname
operator|=
literal|"interrupt"
expr_stmt|;
break|break;
case|case
name|ALPHA_KENTRY_ARITH
case|:
name|entryname
operator|=
literal|"arithmetic trap"
expr_stmt|;
break|break;
case|case
name|ALPHA_KENTRY_MM
case|:
name|entryname
operator|=
literal|"memory management fault"
expr_stmt|;
break|break;
case|case
name|ALPHA_KENTRY_IF
case|:
name|entryname
operator|=
literal|"instruction fault"
expr_stmt|;
break|break;
case|case
name|ALPHA_KENTRY_UNA
case|:
name|entryname
operator|=
literal|"unaligned access fault"
expr_stmt|;
break|break;
case|case
name|ALPHA_KENTRY_SYS
case|:
name|entryname
operator|=
literal|"system call"
expr_stmt|;
break|break;
default|default:
name|snprintf
argument_list|(
name|ubuf
argument_list|,
sizeof|sizeof
argument_list|(
name|ubuf
argument_list|)
argument_list|,
literal|"type %lx"
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|entryname
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|ubuf
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s %s trap:\n"
argument_list|,
name|isfatal
condition|?
literal|"fatal"
else|:
literal|"handled"
argument_list|,
name|user
condition|?
literal|"user"
else|:
literal|"kernel"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    trap entry = 0x%lx (%s)\n"
argument_list|,
name|entry
argument_list|,
name|entryname
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    a0         = 0x%lx\n"
argument_list|,
name|a0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    a1         = 0x%lx\n"
argument_list|,
name|a1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    a2         = 0x%lx\n"
argument_list|,
name|a2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    pc         = 0x%lx\n"
argument_list|,
name|framep
operator|->
name|tf_regs
index|[
name|FRAME_PC
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    ra         = 0x%lx\n"
argument_list|,
name|framep
operator|->
name|tf_regs
index|[
name|FRAME_RA
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    curproc    = %p\n"
argument_list|,
name|curproc
argument_list|)
expr_stmt|;
if|if
condition|(
name|curproc
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"        pid = %d, comm = %s\n"
argument_list|,
name|curproc
operator|->
name|p_pid
argument_list|,
name|curproc
operator|->
name|p_comm
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Trap is called from locore to handle most types of processor traps.  * System calls are broken out for efficiency and ASTs are broken out  * to make the code a bit cleaner and more representative of the  * Alpha architecture.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|trap
parameter_list|(
name|a0
parameter_list|,
name|a1
parameter_list|,
name|a2
parameter_list|,
name|entry
parameter_list|,
name|framep
parameter_list|)
specifier|const
name|unsigned
name|long
name|a0
decl_stmt|,
name|a1
decl_stmt|,
name|a2
decl_stmt|,
name|entry
decl_stmt|;
name|struct
name|trapframe
modifier|*
name|framep
decl_stmt|;
block|{
specifier|register
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|u_int64_t
name|ucode
decl_stmt|;
name|u_quad_t
name|sticks
decl_stmt|;
name|int
name|user
decl_stmt|;
comment|/* 	 * Find our per-cpu globals. 	 */
name|globalp
operator|=
operator|(
expr|struct
name|globaldata
operator|*
operator|)
name|alpha_pal_rdval
argument_list|()
expr_stmt|;
name|cnt
operator|.
name|v_trap
operator|++
expr_stmt|;
name|p
operator|=
name|curproc
expr_stmt|;
name|ucode
operator|=
literal|0
expr_stmt|;
name|user
operator|=
operator|(
name|framep
operator|->
name|tf_regs
index|[
name|FRAME_PS
index|]
operator|&
name|ALPHA_PSL_USERMODE
operator|)
operator|!=
literal|0
expr_stmt|;
if|if
condition|(
name|user
condition|)
block|{
name|sticks
operator|=
name|p
operator|->
name|p_sticks
expr_stmt|;
name|p
operator|->
name|p_md
operator|.
name|md_tf
operator|=
name|framep
expr_stmt|;
if|#
directive|if
literal|0
comment|/* This is to catch some wierd stuff on the UDB (mj) */
block|if (framep->tf_regs[FRAME_PC]> 0&&  		    framep->tf_regs[FRAME_PC]< 0x120000000) { 			printf("PC Out of Whack\n"); 			printtrap(a0, a1, a2, entry, framep, 1, user); 		}
endif|#
directive|endif
block|}
else|else
block|{
name|sticks
operator|=
literal|0
expr_stmt|;
comment|/* XXX bogus -Wuninitialized warning */
block|}
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|user
condition|)
name|alpha_fpstate_check
argument_list|(
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|entry
condition|)
block|{
case|case
name|ALPHA_KENTRY_UNA
case|:
comment|/* 		 * If user-land, do whatever fixups, printing, and 		 * signalling is appropriate (based on system-wide 		 * and per-process unaligned-access-handling flags). 		 */
if|if
condition|(
name|user
condition|)
block|{
name|mtx_enter
argument_list|(
operator|&
name|Giant
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|unaligned_fixup
argument_list|(
name|a0
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|p
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|mtx_exit
argument_list|(
operator|&
name|Giant
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|mtx_exit
argument_list|(
operator|&
name|Giant
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|ucode
operator|=
name|a0
expr_stmt|;
comment|/* VA */
break|break;
block|}
comment|/* 		 * Unaligned access from kernel mode is always an error, 		 * EVEN IF A COPY FAULT HANDLER IS SET! 		 * 		 * It's an error if a copy fault handler is set because 		 * the various routines which do user-initiated copies 		 * do so in a bcopy-like manner.  In other words, the 		 * kernel never assumes that pointers provided by the 		 * user are properly aligned, and so if the kernel 		 * does cause an unaligned access it's a kernel bug. 		 */
goto|goto
name|dopanic
goto|;
case|case
name|ALPHA_KENTRY_ARITH
case|:
comment|/*  		 * If user-land, give a SIGFPE if software completion 		 * is not requested or if the completion fails. 		 */
if|if
condition|(
name|user
condition|)
block|{
name|mtx_enter
argument_list|(
operator|&
name|Giant
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
if|if
condition|(
name|a0
operator|&
name|EXCSUM_SWC
condition|)
if|if
condition|(
name|fp_software_completion
argument_list|(
name|a1
argument_list|,
name|p
argument_list|)
condition|)
block|{
name|mtx_exit
argument_list|(
operator|&
name|Giant
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|mtx_exit
argument_list|(
operator|&
name|Giant
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|i
operator|=
name|SIGFPE
expr_stmt|;
name|ucode
operator|=
name|a0
expr_stmt|;
comment|/* exception summary */
break|break;
block|}
comment|/* Always fatal in kernel.  Should never happen. */
goto|goto
name|dopanic
goto|;
case|case
name|ALPHA_KENTRY_IF
case|:
comment|/* 		 * These are always fatal in kernel, and should never 		 * happen. 		 */
if|if
condition|(
operator|!
name|user
condition|)
block|{
ifdef|#
directive|ifdef
name|DDB
comment|/* 			 * ...unless, of course, DDB is configured; BUGCHK 			 * is used to invoke the kernel debugger, and we 			 * might have set a breakpoint. 			 */
if|if
condition|(
name|a0
operator|==
name|ALPHA_IF_CODE_BUGCHK
operator|||
name|a0
operator|==
name|ALPHA_IF_CODE_BPT
ifdef|#
directive|ifdef
name|SIMOS
operator|||
name|a0
operator|==
name|ALPHA_IF_CODE_GENTRAP
endif|#
directive|endif
condition|)
block|{
if|if
condition|(
name|kdb_trap
argument_list|(
name|a0
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|entry
argument_list|,
name|framep
argument_list|)
condition|)
goto|goto
name|out
goto|;
block|}
comment|/* 			 * If we get here, DDB did _not_ handle the 			 * trap, and we need to PANIC! 			 */
endif|#
directive|endif
goto|goto
name|dopanic
goto|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|a0
condition|)
block|{
case|case
name|ALPHA_IF_CODE_GENTRAP
case|:
if|if
condition|(
name|framep
operator|->
name|tf_regs
index|[
name|FRAME_A0
index|]
operator|==
operator|-
literal|2
condition|)
block|{
comment|/* weird! */
name|i
operator|=
name|SIGFPE
expr_stmt|;
name|ucode
operator|=
name|a0
expr_stmt|;
comment|/* exception summary */
break|break;
block|}
comment|/* FALLTHROUTH */
case|case
name|ALPHA_IF_CODE_BPT
case|:
case|case
name|ALPHA_IF_CODE_BUGCHK
case|:
if|if
condition|(
name|p
operator|->
name|p_md
operator|.
name|md_flags
operator|&
operator|(
name|MDP_STEP1
operator||
name|MDP_STEP2
operator|)
condition|)
block|{
name|ptrace_clear_single_step
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_md
operator|.
name|md_tf
operator|->
name|tf_regs
index|[
name|FRAME_PC
index|]
operator|-=
literal|4
expr_stmt|;
block|}
name|ucode
operator|=
name|a0
expr_stmt|;
comment|/* trap type */
name|i
operator|=
name|SIGTRAP
expr_stmt|;
break|break;
case|case
name|ALPHA_IF_CODE_OPDEC
case|:
name|ucode
operator|=
name|a0
expr_stmt|;
comment|/* trap type */
name|i
operator|=
name|SIGILL
expr_stmt|;
break|break;
case|case
name|ALPHA_IF_CODE_FEN
case|:
comment|/* 			 * on exit from the kernel, if proc == fpcurproc, 			 * FP is enabled. 			 */
if|if
condition|(
name|fpcurproc
operator|==
name|p
condition|)
block|{
name|printf
argument_list|(
literal|"trap: fp disabled for fpcurproc == %p"
argument_list|,
name|p
argument_list|)
expr_stmt|;
goto|goto
name|dopanic
goto|;
block|}
name|alpha_fpstate_switch
argument_list|(
name|p
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
default|default:
name|printf
argument_list|(
literal|"trap: unknown IF type 0x%lx\n"
argument_list|,
name|a0
argument_list|)
expr_stmt|;
goto|goto
name|dopanic
goto|;
block|}
break|break;
case|case
name|ALPHA_KENTRY_MM
case|:
switch|switch
condition|(
name|a1
condition|)
block|{
case|case
name|ALPHA_MMCSR_FOR
case|:
case|case
name|ALPHA_MMCSR_FOE
case|:
name|pmap_emulate_reference
argument_list|(
name|p
argument_list|,
name|a0
argument_list|,
name|user
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
case|case
name|ALPHA_MMCSR_FOW
case|:
name|pmap_emulate_reference
argument_list|(
name|p
argument_list|,
name|a0
argument_list|,
name|user
argument_list|,
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
case|case
name|ALPHA_MMCSR_INVALTRANS
case|:
case|case
name|ALPHA_MMCSR_ACCESS
case|:
block|{
specifier|register
name|vm_offset_t
name|va
decl_stmt|;
specifier|register
name|struct
name|vmspace
modifier|*
name|vm
init|=
name|NULL
decl_stmt|;
specifier|register
name|vm_map_t
name|map
decl_stmt|;
name|vm_prot_t
name|ftype
init|=
literal|0
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|mtx_enter
argument_list|(
operator|&
name|Giant
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
comment|/* 			 * If it was caused by fuswintr or suswintr, 			 * just punt.  Note that we check the faulting 			 * address against the address accessed by 			 * [fs]uswintr, in case another fault happens 			 * when they are running. 			 */
if|if
condition|(
operator|!
name|user
operator|&&
name|p
operator|!=
name|NULL
operator|&&
name|p
operator|->
name|p_addr
operator|->
name|u_pcb
operator|.
name|pcb_onfault
operator|==
operator|(
name|unsigned
name|long
operator|)
name|fswintrberr
operator|&&
name|p
operator|->
name|p_addr
operator|->
name|u_pcb
operator|.
name|pcb_accessaddr
operator|==
name|a0
condition|)
block|{
name|framep
operator|->
name|tf_regs
index|[
name|FRAME_PC
index|]
operator|=
name|p
operator|->
name|p_addr
operator|->
name|u_pcb
operator|.
name|pcb_onfault
expr_stmt|;
name|p
operator|->
name|p_addr
operator|->
name|u_pcb
operator|.
name|pcb_onfault
operator|=
literal|0
expr_stmt|;
name|mtx_exit
argument_list|(
operator|&
name|Giant
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 			 * It is only a kernel address space fault iff: 			 *	1. !user and 			 *	2. pcb_onfault not set or 			 *	3. pcb_onfault set but kernel space data fault 			 * The last can occur during an exec() copyin where the 			 * argument space is lazy-allocated. 			 * 			 * For the purposes of the Linux emulator, we allow 			 * kernel accesses to a small region of the 			 * user stack which the emulator uses to 			 * translate syscall arguments. 			 */
if|if
condition|(
operator|!
name|user
operator|&&
operator|(
operator|(
name|a0
operator|>=
name|VM_MIN_KERNEL_ADDRESS
operator|)
operator|||
operator|(
name|p
operator|==
name|NULL
operator|)
operator|||
operator|(
name|p
operator|->
name|p_addr
operator|->
name|u_pcb
operator|.
name|pcb_onfault
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|a0
operator|>=
name|trunc_page
argument_list|(
name|PS_STRINGS
operator|-
name|szsigcode
operator|-
name|SPARE_USRSPACE
argument_list|)
operator|&&
name|a0
operator|<
name|round_page
argument_list|(
name|PS_STRINGS
operator|-
name|szsigcode
argument_list|)
condition|)
block|{
name|vm
operator|=
name|p
operator|->
name|p_vmspace
expr_stmt|;
name|map
operator|=
operator|&
name|vm
operator|->
name|vm_map
expr_stmt|;
block|}
else|else
block|{
name|map
operator|=
name|kernel_map
expr_stmt|;
block|}
block|}
else|else
block|{
name|vm
operator|=
name|p
operator|->
name|p_vmspace
expr_stmt|;
name|map
operator|=
operator|&
name|vm
operator|->
name|vm_map
expr_stmt|;
block|}
switch|switch
condition|(
name|a2
condition|)
block|{
case|case
operator|-
literal|1
case|:
comment|/* instruction fetch fault */
case|case
literal|0
case|:
comment|/* load instruction */
name|ftype
operator|=
name|VM_PROT_READ
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* store instruction */
name|ftype
operator|=
name|VM_PROT_WRITE
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
default|default:
comment|/* XXX gcc -Wuninitialized */
goto|goto
name|dopanic
goto|;
endif|#
directive|endif
block|}
name|va
operator|=
name|trunc_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|a0
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|!=
name|kernel_map
condition|)
block|{
comment|/* 				 * Keep swapout from messing with us 				 * during thiscritical time. 				 */
operator|++
name|p
operator|->
name|p_lock
expr_stmt|;
comment|/* 				 * Grow the stack if necessary 				 */
comment|/* grow_stack returns false only if va falls into 				 * a growable stack region and the stack growth 				 * fails.  It returns true if va was not within 				 * a growable stack region, or if the stack  				 * growth succeeded. 				 */
if|if
condition|(
operator|!
name|grow_stack
argument_list|(
name|p
argument_list|,
name|va
argument_list|)
condition|)
block|{
name|rv
operator|=
name|KERN_FAILURE
expr_stmt|;
operator|--
name|p
operator|->
name|p_lock
expr_stmt|;
goto|goto
name|nogo
goto|;
block|}
comment|/* Fault in the user page: */
name|rv
operator|=
name|vm_fault
argument_list|(
name|map
argument_list|,
name|va
argument_list|,
name|ftype
argument_list|,
operator|(
name|ftype
operator|&
name|VM_PROT_WRITE
operator|)
condition|?
name|VM_FAULT_DIRTY
else|:
name|VM_FAULT_NORMAL
argument_list|)
expr_stmt|;
operator|--
name|p
operator|->
name|p_lock
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Don't have to worry about process 				 * locking or stacks in the kernel. 				 */
name|rv
operator|=
name|vm_fault
argument_list|(
name|map
argument_list|,
name|va
argument_list|,
name|ftype
argument_list|,
name|VM_FAULT_NORMAL
argument_list|)
expr_stmt|;
block|}
name|nogo
label|:
empty_stmt|;
comment|/* 			 * If this was a stack access we keep track of the 			 * maximum accessed stack size.  Also, if vm_fault 			 * gets a protection failure it is due to accessing 			 * the stack region outside the current limit and 			 * we need to reflect that as an access error. 			 */
if|if
condition|(
name|map
operator|!=
name|kernel_map
operator|&&
operator|(
name|caddr_t
operator|)
name|va
operator|>=
name|vm
operator|->
name|vm_maxsaddr
operator|&&
operator|(
name|caddr_t
operator|)
name|va
operator|<
operator|(
name|caddr_t
operator|)
name|USRSTACK
condition|)
block|{
if|if
condition|(
name|rv
operator|==
name|KERN_SUCCESS
condition|)
block|{
name|unsigned
name|nss
decl_stmt|;
name|nss
operator|=
name|alpha_btop
argument_list|(
name|round_page
argument_list|(
name|USRSTACK
operator|-
name|va
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nss
operator|>
name|vm
operator|->
name|vm_ssize
condition|)
name|vm
operator|->
name|vm_ssize
operator|=
name|nss
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rv
operator|==
name|KERN_PROTECTION_FAILURE
condition|)
name|rv
operator|=
name|KERN_INVALID_ADDRESS
expr_stmt|;
block|}
if|if
condition|(
name|rv
operator|==
name|KERN_SUCCESS
condition|)
block|{
name|mtx_exit
argument_list|(
operator|&
name|Giant
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|mtx_exit
argument_list|(
operator|&
name|Giant
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|user
condition|)
block|{
comment|/* Check for copyin/copyout fault */
if|if
condition|(
name|p
operator|!=
name|NULL
operator|&&
name|p
operator|->
name|p_addr
operator|->
name|u_pcb
operator|.
name|pcb_onfault
operator|!=
literal|0
condition|)
block|{
name|framep
operator|->
name|tf_regs
index|[
name|FRAME_PC
index|]
operator|=
name|p
operator|->
name|p_addr
operator|->
name|u_pcb
operator|.
name|pcb_onfault
expr_stmt|;
name|p
operator|->
name|p_addr
operator|->
name|u_pcb
operator|.
name|pcb_onfault
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
goto|goto
name|dopanic
goto|;
block|}
name|ucode
operator|=
name|a0
expr_stmt|;
name|i
operator|=
name|SIGSEGV
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printtrap
argument_list|(
name|a0
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|entry
argument_list|,
name|framep
argument_list|,
literal|1
argument_list|,
name|user
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
default|default:
name|printf
argument_list|(
literal|"trap: unknown MMCSR value 0x%lx\n"
argument_list|,
name|a1
argument_list|)
expr_stmt|;
goto|goto
name|dopanic
goto|;
block|}
break|break;
default|default:
goto|goto
name|dopanic
goto|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|printtrap
argument_list|(
name|a0
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|entry
argument_list|,
name|framep
argument_list|,
literal|1
argument_list|,
name|user
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|framep
operator|->
name|tf_regs
index|[
name|FRAME_TRAPARG_A0
index|]
operator|=
name|a0
expr_stmt|;
name|framep
operator|->
name|tf_regs
index|[
name|FRAME_TRAPARG_A1
index|]
operator|=
name|a1
expr_stmt|;
name|framep
operator|->
name|tf_regs
index|[
name|FRAME_TRAPARG_A2
index|]
operator|=
name|a2
expr_stmt|;
name|trapsignal
argument_list|(
name|p
argument_list|,
name|i
argument_list|,
name|ucode
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|user
condition|)
block|{
name|framep
operator|->
name|tf_regs
index|[
name|FRAME_SP
index|]
operator|=
name|alpha_pal_rdusp
argument_list|()
expr_stmt|;
if|if
condition|(
name|userret
argument_list|(
name|p
argument_list|,
name|framep
operator|->
name|tf_regs
index|[
name|FRAME_PC
index|]
argument_list|,
name|sticks
argument_list|,
literal|0
argument_list|)
condition|)
name|mtx_exit
argument_list|(
operator|&
name|Giant
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
block|}
return|return;
name|dopanic
label|:
name|printtrap
argument_list|(
name|a0
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|entry
argument_list|,
name|framep
argument_list|,
literal|1
argument_list|,
name|user
argument_list|)
expr_stmt|;
comment|/* XXX dump registers */
ifdef|#
directive|ifdef
name|DDB
name|kdb_trap
argument_list|(
name|a0
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|entry
argument_list|,
name|framep
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|panic
argument_list|(
literal|"trap"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process a system call.  *  * System calls are strange beasts.  They are passed the syscall number  * in v0, and the arguments in the registers (as normal).  They return  * an error flag in a3 (if a3 != 0 on return, the syscall had an error),  * and the return value (if any) in v0.  *  * The assembly stub takes care of moving the call number into a register  * we can get to, and moves all of the argument registers into their places  * in the trap frame.  On return, it restores the callee-saved registers,  * a3, and v0 from the frame before returning to the user process.  */
end_comment

begin_function
name|void
name|syscall
parameter_list|(
name|code
parameter_list|,
name|framep
parameter_list|)
name|u_int64_t
name|code
decl_stmt|;
name|struct
name|trapframe
modifier|*
name|framep
decl_stmt|;
block|{
name|struct
name|sysent
modifier|*
name|callp
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|u_int64_t
name|opc
decl_stmt|;
name|u_quad_t
name|sticks
decl_stmt|;
name|u_int64_t
name|args
index|[
literal|10
index|]
decl_stmt|;
comment|/* XXX */
name|u_int
name|hidden
init|=
literal|0
decl_stmt|,
name|nargs
decl_stmt|;
comment|/* 	 * Find our per-cpu globals. 	 */
name|globalp
operator|=
operator|(
expr|struct
name|globaldata
operator|*
operator|)
name|alpha_pal_rdval
argument_list|()
expr_stmt|;
name|mtx_enter
argument_list|(
operator|&
name|Giant
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|framep
operator|->
name|tf_regs
index|[
name|FRAME_TRAPARG_A0
index|]
operator|=
literal|0
expr_stmt|;
name|framep
operator|->
name|tf_regs
index|[
name|FRAME_TRAPARG_A1
index|]
operator|=
literal|0
expr_stmt|;
name|framep
operator|->
name|tf_regs
index|[
name|FRAME_TRAPARG_A2
index|]
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|notdef
comment|/* can't happen, ever. */
if|if
condition|(
operator|(
name|framep
operator|->
name|tf_regs
index|[
name|FRAME_PS
index|]
operator|&
name|ALPHA_PSL_USERMODE
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"syscall"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cnt
operator|.
name|v_syscall
operator|++
expr_stmt|;
name|p
operator|=
name|curproc
expr_stmt|;
name|p
operator|->
name|p_md
operator|.
name|md_tf
operator|=
name|framep
expr_stmt|;
name|opc
operator|=
name|framep
operator|->
name|tf_regs
index|[
name|FRAME_PC
index|]
operator|-
literal|4
expr_stmt|;
name|sticks
operator|=
name|p
operator|->
name|p_sticks
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|alpha_fpstate_check
argument_list|(
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|p
operator|->
name|p_sysent
operator|->
name|sv_prepsyscall
condition|)
block|{
comment|/* (*p->p_sysent->sv_prepsyscall)(framep, args,&code,&params); */
name|panic
argument_list|(
literal|"prepsyscall"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * syscall() and __syscall() are handled the same on 		 * the alpha, as everything is 64-bit aligned, anyway. 		 */
if|if
condition|(
name|code
operator|==
name|SYS_syscall
operator|||
name|code
operator|==
name|SYS___syscall
condition|)
block|{
comment|/* 			 * Code is first argument, followed by actual args. 			 */
name|code
operator|=
name|framep
operator|->
name|tf_regs
index|[
name|FRAME_A0
index|]
expr_stmt|;
name|hidden
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p
operator|->
name|p_sysent
operator|->
name|sv_mask
condition|)
name|code
operator|&=
name|p
operator|->
name|p_sysent
operator|->
name|sv_mask
expr_stmt|;
if|if
condition|(
name|code
operator|>=
name|p
operator|->
name|p_sysent
operator|->
name|sv_size
condition|)
name|callp
operator|=
operator|&
name|p
operator|->
name|p_sysent
operator|->
name|sv_table
index|[
literal|0
index|]
expr_stmt|;
else|else
name|callp
operator|=
operator|&
name|p
operator|->
name|p_sysent
operator|->
name|sv_table
index|[
name|code
index|]
expr_stmt|;
name|nargs
operator|=
operator|(
name|callp
operator|->
name|sy_narg
operator|&
name|SYF_ARGMASK
operator|)
operator|+
name|hidden
expr_stmt|;
switch|switch
condition|(
name|nargs
condition|)
block|{
default|default:
if|if
condition|(
name|nargs
operator|>
literal|10
condition|)
comment|/* XXX */
name|panic
argument_list|(
literal|"syscall: too many args (%d)"
argument_list|,
name|nargs
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
call|(
name|caddr_t
call|)
argument_list|(
name|alpha_pal_rdusp
argument_list|()
argument_list|)
argument_list|,
operator|&
name|args
index|[
literal|6
index|]
argument_list|,
operator|(
name|nargs
operator|-
literal|6
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|u_int64_t
argument_list|)
argument_list|)
expr_stmt|;
case|case
literal|6
case|:
name|args
index|[
literal|5
index|]
operator|=
name|framep
operator|->
name|tf_regs
index|[
name|FRAME_A5
index|]
expr_stmt|;
case|case
literal|5
case|:
name|args
index|[
literal|4
index|]
operator|=
name|framep
operator|->
name|tf_regs
index|[
name|FRAME_A4
index|]
expr_stmt|;
case|case
literal|4
case|:
name|args
index|[
literal|3
index|]
operator|=
name|framep
operator|->
name|tf_regs
index|[
name|FRAME_A3
index|]
expr_stmt|;
case|case
literal|3
case|:
name|args
index|[
literal|2
index|]
operator|=
name|framep
operator|->
name|tf_regs
index|[
name|FRAME_A2
index|]
expr_stmt|;
case|case
literal|2
case|:
name|args
index|[
literal|1
index|]
operator|=
name|framep
operator|->
name|tf_regs
index|[
name|FRAME_A1
index|]
expr_stmt|;
case|case
literal|1
case|:
name|args
index|[
literal|0
index|]
operator|=
name|framep
operator|->
name|tf_regs
index|[
name|FRAME_A0
index|]
expr_stmt|;
case|case
literal|0
case|:
break|break;
block|}
ifdef|#
directive|ifdef
name|KTRACE
if|if
condition|(
name|KTRPOINT
argument_list|(
name|p
argument_list|,
name|KTR_SYSCALL
argument_list|)
condition|)
name|ktrsyscall
argument_list|(
name|p
operator|->
name|p_tracep
argument_list|,
name|code
argument_list|,
operator|(
name|callp
operator|->
name|sy_narg
operator|&
name|SYF_ARGMASK
operator|)
argument_list|,
name|args
operator|+
name|hidden
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|p
operator|->
name|p_retval
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|p_retval
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|STOPEVENT
argument_list|(
name|p
argument_list|,
name|S_SCE
argument_list|,
operator|(
name|callp
operator|->
name|sy_narg
operator|&
name|SYF_ARGMASK
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
call|(
modifier|*
name|callp
operator|->
name|sy_call
call|)
argument_list|(
name|p
argument_list|,
name|args
operator|+
name|hidden
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|error
condition|)
block|{
case|case
literal|0
case|:
name|framep
operator|->
name|tf_regs
index|[
name|FRAME_V0
index|]
operator|=
name|p
operator|->
name|p_retval
index|[
literal|0
index|]
expr_stmt|;
name|framep
operator|->
name|tf_regs
index|[
name|FRAME_A4
index|]
operator|=
name|p
operator|->
name|p_retval
index|[
literal|1
index|]
expr_stmt|;
name|framep
operator|->
name|tf_regs
index|[
name|FRAME_A3
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ERESTART
case|:
name|framep
operator|->
name|tf_regs
index|[
name|FRAME_PC
index|]
operator|=
name|opc
expr_stmt|;
break|break;
case|case
name|EJUSTRETURN
case|:
break|break;
default|default:
if|if
condition|(
name|p
operator|->
name|p_sysent
operator|->
name|sv_errsize
condition|)
block|{
if|if
condition|(
name|error
operator|>=
name|p
operator|->
name|p_sysent
operator|->
name|sv_errsize
condition|)
name|error
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* XXX */
else|else
name|error
operator|=
name|p
operator|->
name|p_sysent
operator|->
name|sv_errtbl
index|[
name|error
index|]
expr_stmt|;
block|}
name|framep
operator|->
name|tf_regs
index|[
name|FRAME_V0
index|]
operator|=
name|error
expr_stmt|;
name|framep
operator|->
name|tf_regs
index|[
name|FRAME_A3
index|]
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/*          * Reinitialize proc pointer `p' as it may be different          * if this is a child returning from fork syscall.          */
name|p
operator|=
name|curproc
expr_stmt|;
name|userret
argument_list|(
name|p
argument_list|,
name|framep
operator|->
name|tf_regs
index|[
name|FRAME_PC
index|]
argument_list|,
name|sticks
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KTRACE
if|if
condition|(
name|KTRPOINT
argument_list|(
name|p
argument_list|,
name|KTR_SYSRET
argument_list|)
condition|)
name|ktrsysret
argument_list|(
name|p
operator|->
name|p_tracep
argument_list|,
name|code
argument_list|,
name|error
argument_list|,
name|p
operator|->
name|p_retval
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * This works because errno is findable through the 	 * register set.  If we ever support an emulation where this 	 * is not the case, this code will need to be revisited. 	 */
name|STOPEVENT
argument_list|(
name|p
argument_list|,
name|S_SCX
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|mtx_exit
argument_list|(
operator|&
name|Giant
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_NOTOWNED
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|Giant
argument_list|,
name|MA_NOTOWNED
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|WITNESS
if|if
condition|(
name|witness_list
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|panic
argument_list|(
literal|"system call %s returning with mutex(s) held\n"
argument_list|,
name|syscallnames
index|[
name|code
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Process the tail end of a fork() for the child.  */
end_comment

begin_function
name|void
name|child_return
parameter_list|(
name|p
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|have_giant
decl_stmt|;
comment|/* 	 * Return values in the frame set by cpu_fork(). 	 */
name|have_giant
operator|=
name|userret
argument_list|(
name|p
argument_list|,
name|p
operator|->
name|p_md
operator|.
name|md_tf
operator|->
name|tf_regs
index|[
name|FRAME_PC
index|]
argument_list|,
literal|0
argument_list|,
name|mtx_owned
argument_list|(
operator|&
name|Giant
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KTRACE
if|if
condition|(
name|KTRPOINT
argument_list|(
name|p
argument_list|,
name|KTR_SYSRET
argument_list|)
condition|)
block|{
if|if
condition|(
name|have_giant
operator|==
literal|0
condition|)
block|{
name|mtx_enter
argument_list|(
operator|&
name|Giant
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|have_giant
operator|=
literal|1
expr_stmt|;
block|}
name|ktrsysret
argument_list|(
name|p
operator|->
name|p_tracep
argument_list|,
name|SYS_fork
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|have_giant
condition|)
name|mtx_exit
argument_list|(
operator|&
name|Giant
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process an asynchronous software trap.  * This is relatively easy.  */
end_comment

begin_function
name|void
name|ast
parameter_list|(
name|framep
parameter_list|)
name|struct
name|trapframe
modifier|*
name|framep
decl_stmt|;
block|{
specifier|register
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|u_quad_t
name|sticks
decl_stmt|;
name|mtx_enter
argument_list|(
operator|&
name|Giant
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|p
operator|=
name|curproc
expr_stmt|;
name|sticks
operator|=
name|p
operator|->
name|p_sticks
expr_stmt|;
name|p
operator|->
name|p_md
operator|.
name|md_tf
operator|=
name|framep
expr_stmt|;
comment|/* 	 * XXX - is this still correct?  What about a clock interrupt 	 * that runs hardclock() and triggers a delayed SIGVTALRM or 	 * SIGPROF? 	 */
if|if
condition|(
operator|(
name|framep
operator|->
name|tf_regs
index|[
name|FRAME_PS
index|]
operator|&
name|ALPHA_PSL_USERMODE
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"ast and not user"
argument_list|)
expr_stmt|;
name|cnt
operator|.
name|v_soft
operator|++
expr_stmt|;
name|PCPU_SET
argument_list|(
name|astpending
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_flag
operator|&
name|P_OWEUPC
condition|)
block|{
name|p
operator|->
name|p_flag
operator|&=
operator|~
name|P_OWEUPC
expr_stmt|;
name|addupc_task
argument_list|(
name|p
argument_list|,
name|p
operator|->
name|p_stats
operator|->
name|p_prof
operator|.
name|pr_addr
argument_list|,
name|p
operator|->
name|p_stats
operator|->
name|p_prof
operator|.
name|pr_ticks
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|p_flag
operator|&
name|P_ALRMPEND
condition|)
block|{
name|p
operator|->
name|p_flag
operator|&=
operator|~
name|P_ALRMPEND
expr_stmt|;
name|psignal
argument_list|(
name|p
argument_list|,
name|SIGVTALRM
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|p_flag
operator|&
name|P_PROFPEND
condition|)
block|{
name|p
operator|->
name|p_flag
operator|&=
operator|~
name|P_PROFPEND
expr_stmt|;
name|psignal
argument_list|(
name|p
argument_list|,
name|SIGPROF
argument_list|)
expr_stmt|;
block|}
name|userret
argument_list|(
name|p
argument_list|,
name|framep
operator|->
name|tf_regs
index|[
name|FRAME_PC
index|]
argument_list|,
name|sticks
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mtx_exit
argument_list|(
operator|&
name|Giant
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Unaligned access handler.  It's not clear that this can get much slower...  *  */
end_comment

begin_decl_stmt
specifier|const
specifier|static
name|int
name|reg_to_framereg
index|[
literal|32
index|]
init|=
block|{
name|FRAME_V0
block|,
name|FRAME_T0
block|,
name|FRAME_T1
block|,
name|FRAME_T2
block|,
name|FRAME_T3
block|,
name|FRAME_T4
block|,
name|FRAME_T5
block|,
name|FRAME_T6
block|,
name|FRAME_T7
block|,
name|FRAME_S0
block|,
name|FRAME_S1
block|,
name|FRAME_S2
block|,
name|FRAME_S3
block|,
name|FRAME_S4
block|,
name|FRAME_S5
block|,
name|FRAME_S6
block|,
name|FRAME_A0
block|,
name|FRAME_A1
block|,
name|FRAME_A2
block|,
name|FRAME_A3
block|,
name|FRAME_A4
block|,
name|FRAME_A5
block|,
name|FRAME_T8
block|,
name|FRAME_T9
block|,
name|FRAME_T10
block|,
name|FRAME_T11
block|,
name|FRAME_RA
block|,
name|FRAME_T12
block|,
name|FRAME_AT
block|,
name|FRAME_GP
block|,
name|FRAME_SP
block|,
operator|-
literal|1
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|irp
parameter_list|(
name|p
parameter_list|,
name|reg
parameter_list|)
define|\
value|((reg_to_framereg[(reg)] == -1) ? NULL :			\&(p)->p_md.md_tf->tf_regs[reg_to_framereg[(reg)]])
end_define

begin_define
define|#
directive|define
name|frp
parameter_list|(
name|p
parameter_list|,
name|reg
parameter_list|)
define|\
value|(&(p)->p_addr->u_pcb.pcb_fp.fpr_regs[(reg)])
end_define

begin_define
define|#
directive|define
name|unaligned_load
parameter_list|(
name|storage
parameter_list|,
name|ptrf
parameter_list|,
name|mod
parameter_list|)
define|\
value|if (copyin((caddr_t)va,&(storage), sizeof (storage)) == 0&&	\ 	    (regptr = ptrf(p, reg)) != NULL)				\ 		signal = 0;						\ 	else								\ 		break;							\ 	*regptr = mod (storage);
end_define

begin_define
define|#
directive|define
name|unaligned_store
parameter_list|(
name|storage
parameter_list|,
name|ptrf
parameter_list|,
name|mod
parameter_list|)
define|\
value|if ((regptr = ptrf(p, reg)) == NULL)				\ 		break;							\ 	(storage) = mod (*regptr);					\ 	if (copyout(&(storage), (caddr_t)va, sizeof (storage)) == 0)	\ 		signal = 0;						\ 	else								\ 		break;
end_define

begin_define
define|#
directive|define
name|unaligned_load_integer
parameter_list|(
name|storage
parameter_list|)
define|\
value|unaligned_load(storage, irp, )
end_define

begin_define
define|#
directive|define
name|unaligned_store_integer
parameter_list|(
name|storage
parameter_list|)
define|\
value|unaligned_store(storage, irp, )
end_define

begin_define
define|#
directive|define
name|unaligned_load_floating
parameter_list|(
name|storage
parameter_list|,
name|mod
parameter_list|)
define|\
value|alpha_fpstate_save(p, 1);					\ 	unaligned_load(storage, frp, mod)
end_define

begin_define
define|#
directive|define
name|unaligned_store_floating
parameter_list|(
name|storage
parameter_list|,
name|mod
parameter_list|)
define|\
value|alpha_fpstate_save(p, 0);					\ 	unaligned_store(storage, frp, mod)
end_define

begin_function
name|unsigned
name|long
name|Sfloat_to_reg
parameter_list|(
name|s
parameter_list|)
name|unsigned
name|int
name|s
decl_stmt|;
block|{
name|unsigned
name|long
name|sign
decl_stmt|,
name|expn
decl_stmt|,
name|frac
decl_stmt|;
name|unsigned
name|long
name|result
decl_stmt|;
name|sign
operator|=
operator|(
name|s
operator|&
literal|0x80000000
operator|)
operator|>>
literal|31
expr_stmt|;
name|expn
operator|=
operator|(
name|s
operator|&
literal|0x7f800000
operator|)
operator|>>
literal|23
expr_stmt|;
name|frac
operator|=
operator|(
name|s
operator|&
literal|0x007fffff
operator|)
operator|>>
literal|0
expr_stmt|;
comment|/* map exponent part, as appropriate. */
if|if
condition|(
name|expn
operator|==
literal|0xff
condition|)
name|expn
operator|=
literal|0x7ff
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|expn
operator|&
literal|0x80
operator|)
operator|!=
literal|0
condition|)
name|expn
operator|=
operator|(
literal|0x400
operator||
operator|(
name|expn
operator|&
operator|~
literal|0x80
operator|)
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|expn
operator|&
literal|0x80
operator|)
operator|==
literal|0
operator|&&
name|expn
operator|!=
literal|0
condition|)
name|expn
operator|=
operator|(
literal|0x380
operator||
operator|(
name|expn
operator|&
operator|~
literal|0x80
operator|)
operator|)
expr_stmt|;
name|result
operator|=
operator|(
name|sign
operator|<<
literal|63
operator|)
operator||
operator|(
name|expn
operator|<<
literal|52
operator|)
operator||
operator|(
name|frac
operator|<<
literal|29
operator|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|unsigned
name|int
name|reg_to_Sfloat
parameter_list|(
name|r
parameter_list|)
name|unsigned
name|long
name|r
decl_stmt|;
block|{
name|unsigned
name|long
name|sign
decl_stmt|,
name|expn
decl_stmt|,
name|frac
decl_stmt|;
name|unsigned
name|int
name|result
decl_stmt|;
name|sign
operator|=
operator|(
name|r
operator|&
literal|0x8000000000000000
operator|)
operator|>>
literal|63
expr_stmt|;
name|expn
operator|=
operator|(
name|r
operator|&
literal|0x7ff0000000000000
operator|)
operator|>>
literal|52
expr_stmt|;
name|frac
operator|=
operator|(
name|r
operator|&
literal|0x000fffffe0000000
operator|)
operator|>>
literal|29
expr_stmt|;
comment|/* map exponent part, as appropriate. */
name|expn
operator|=
operator|(
name|expn
operator|&
literal|0x7f
operator|)
operator||
operator|(
operator|(
name|expn
operator|&
literal|0x400
operator|)
operator|!=
literal|0
condition|?
literal|0x80
else|:
literal|0x00
operator|)
expr_stmt|;
name|result
operator|=
operator|(
name|sign
operator|<<
literal|31
operator|)
operator||
operator|(
name|expn
operator|<<
literal|23
operator|)
operator||
operator|(
name|frac
operator|<<
literal|0
operator|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Conversion of T floating datums to and from register format  * requires no bit reordering whatsoever.  */
end_comment

begin_function
name|unsigned
name|long
name|Tfloat_reg_cvt
parameter_list|(
name|input
parameter_list|)
name|unsigned
name|long
name|input
decl_stmt|;
block|{
return|return
operator|(
name|input
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|FIX_UNALIGNED_VAX_FP
end_ifdef

begin_function
name|unsigned
name|long
name|Ffloat_to_reg
parameter_list|(
name|f
parameter_list|)
name|unsigned
name|int
name|f
decl_stmt|;
block|{
name|unsigned
name|long
name|sign
decl_stmt|,
name|expn
decl_stmt|,
name|frlo
decl_stmt|,
name|frhi
decl_stmt|;
name|unsigned
name|long
name|result
decl_stmt|;
name|sign
operator|=
operator|(
name|f
operator|&
literal|0x00008000
operator|)
operator|>>
literal|15
expr_stmt|;
name|expn
operator|=
operator|(
name|f
operator|&
literal|0x00007f80
operator|)
operator|>>
literal|7
expr_stmt|;
name|frhi
operator|=
operator|(
name|f
operator|&
literal|0x0000007f
operator|)
operator|>>
literal|0
expr_stmt|;
name|frlo
operator|=
operator|(
name|f
operator|&
literal|0xffff0000
operator|)
operator|>>
literal|16
expr_stmt|;
comment|/* map exponent part, as appropriate. */
if|if
condition|(
operator|(
name|expn
operator|&
literal|0x80
operator|)
operator|!=
literal|0
condition|)
name|expn
operator|=
operator|(
literal|0x400
operator||
operator|(
name|expn
operator|&
operator|~
literal|0x80
operator|)
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|expn
operator|&
literal|0x80
operator|)
operator|==
literal|0
operator|&&
name|expn
operator|!=
literal|0
condition|)
name|expn
operator|=
operator|(
literal|0x380
operator||
operator|(
name|expn
operator|&
operator|~
literal|0x80
operator|)
operator|)
expr_stmt|;
name|result
operator|=
operator|(
name|sign
operator|<<
literal|63
operator|)
operator||
operator|(
name|expn
operator|<<
literal|52
operator|)
operator||
operator|(
name|frhi
operator|<<
literal|45
operator|)
operator||
operator|(
name|frlo
operator|<<
literal|29
operator|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|unsigned
name|int
name|reg_to_Ffloat
parameter_list|(
name|r
parameter_list|)
name|unsigned
name|long
name|r
decl_stmt|;
block|{
name|unsigned
name|long
name|sign
decl_stmt|,
name|expn
decl_stmt|,
name|frhi
decl_stmt|,
name|frlo
decl_stmt|;
name|unsigned
name|int
name|result
decl_stmt|;
name|sign
operator|=
operator|(
name|r
operator|&
literal|0x8000000000000000
operator|)
operator|>>
literal|63
expr_stmt|;
name|expn
operator|=
operator|(
name|r
operator|&
literal|0x7ff0000000000000
operator|)
operator|>>
literal|52
expr_stmt|;
name|frhi
operator|=
operator|(
name|r
operator|&
literal|0x000fe00000000000
operator|)
operator|>>
literal|45
expr_stmt|;
name|frlo
operator|=
operator|(
name|r
operator|&
literal|0x00001fffe0000000
operator|)
operator|>>
literal|29
expr_stmt|;
comment|/* map exponent part, as appropriate. */
name|expn
operator|=
operator|(
name|expn
operator|&
literal|0x7f
operator|)
operator||
operator|(
operator|(
name|expn
operator|&
literal|0x400
operator|)
operator|!=
literal|0
condition|?
literal|0x80
else|:
literal|0x00
operator|)
expr_stmt|;
name|result
operator|=
operator|(
name|sign
operator|<<
literal|15
operator|)
operator||
operator|(
name|expn
operator|<<
literal|7
operator|)
operator||
operator|(
name|frhi
operator|<<
literal|0
operator|)
operator||
operator|(
name|frlo
operator|<<
literal|16
operator|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Conversion of G floating datums to and from register format is  * symmetrical.  Just swap shorts in the quad...  */
end_comment

begin_function
name|unsigned
name|long
name|Gfloat_reg_cvt
parameter_list|(
name|input
parameter_list|)
name|unsigned
name|long
name|input
decl_stmt|;
block|{
name|unsigned
name|long
name|a
decl_stmt|,
name|b
decl_stmt|,
name|c
decl_stmt|,
name|d
decl_stmt|;
name|unsigned
name|long
name|result
decl_stmt|;
name|a
operator|=
operator|(
name|input
operator|&
literal|0x000000000000ffff
operator|)
operator|>>
literal|0
expr_stmt|;
name|b
operator|=
operator|(
name|input
operator|&
literal|0x00000000ffff0000
operator|)
operator|>>
literal|16
expr_stmt|;
name|c
operator|=
operator|(
name|input
operator|&
literal|0x0000ffff00000000
operator|)
operator|>>
literal|32
expr_stmt|;
name|d
operator|=
operator|(
name|input
operator|&
literal|0xffff000000000000
operator|)
operator|>>
literal|48
expr_stmt|;
name|result
operator|=
operator|(
name|a
operator|<<
literal|48
operator|)
operator||
operator|(
name|b
operator|<<
literal|32
operator|)
operator||
operator|(
name|c
operator|<<
literal|16
operator|)
operator||
operator|(
name|d
operator|<<
literal|0
operator|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FIX_UNALIGNED_VAX_FP */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|alpha_unaligned_print
decl_stmt|,
name|alpha_unaligned_fix
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|alpha_unaligned_sigbus
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|unaligned_fixup
parameter_list|(
name|va
parameter_list|,
name|opcode
parameter_list|,
name|reg
parameter_list|,
name|p
parameter_list|)
name|unsigned
name|long
name|va
decl_stmt|,
name|opcode
decl_stmt|,
name|reg
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|doprint
decl_stmt|,
name|dofix
decl_stmt|,
name|dosigbus
decl_stmt|;
name|int
name|signal
decl_stmt|,
name|size
decl_stmt|;
specifier|const
name|char
modifier|*
name|type
decl_stmt|;
name|unsigned
name|long
modifier|*
name|regptr
decl_stmt|,
name|longdata
decl_stmt|,
name|uac
decl_stmt|;
name|int
name|intdata
decl_stmt|;
comment|/* signed to get extension when storing */
struct|struct
block|{
specifier|const
name|char
modifier|*
name|type
decl_stmt|;
comment|/* opcode name */
name|int
name|size
decl_stmt|;
comment|/* size, 0 if fixup not supported */
block|}
name|tab
index|[
literal|0x10
index|]
init|=
block|{
ifdef|#
directive|ifdef
name|FIX_UNALIGNED_VAX_FP
block|{
literal|"ldf"
block|,
literal|4
block|}
block|,
block|{
literal|"ldg"
block|,
literal|8
block|}
block|,
else|#
directive|else
block|{
literal|"ldf"
block|,
literal|0
block|}
block|,
block|{
literal|"ldg"
block|,
literal|0
block|}
block|,
endif|#
directive|endif
block|{
literal|"lds"
block|,
literal|4
block|}
block|,
block|{
literal|"ldt"
block|,
literal|8
block|}
block|,
ifdef|#
directive|ifdef
name|FIX_UNALIGNED_VAX_FP
block|{
literal|"stf"
block|,
literal|4
block|}
block|,
block|{
literal|"stg"
block|,
literal|8
block|}
block|,
else|#
directive|else
block|{
literal|"stf"
block|,
literal|0
block|}
block|,
block|{
literal|"stg"
block|,
literal|0
block|}
block|,
endif|#
directive|endif
block|{
literal|"sts"
block|,
literal|4
block|}
block|,
block|{
literal|"stt"
block|,
literal|8
block|}
block|,
block|{
literal|"ldl"
block|,
literal|4
block|}
block|,
block|{
literal|"ldq"
block|,
literal|8
block|}
block|,
block|{
literal|"ldl_l"
block|,
literal|0
block|}
block|,
block|{
literal|"ldq_l"
block|,
literal|0
block|}
block|,
comment|/* can't fix */
block|{
literal|"stl"
block|,
literal|4
block|}
block|,
block|{
literal|"stq"
block|,
literal|8
block|}
block|,
block|{
literal|"stl_c"
block|,
literal|0
block|}
block|,
block|{
literal|"stq_c"
block|,
literal|0
block|}
block|,
comment|/* can't fix */
block|}
struct|;
comment|/* 	 * Figure out what actions to take. 	 * 	 */
if|if
condition|(
name|p
condition|)
name|uac
operator|=
name|p
operator|->
name|p_md
operator|.
name|md_flags
operator|&
name|MDP_UAC_MASK
expr_stmt|;
else|else
name|uac
operator|=
literal|0
expr_stmt|;
name|doprint
operator|=
name|alpha_unaligned_print
operator|&&
operator|!
operator|(
name|uac
operator|&
name|MDP_UAC_NOPRINT
operator|)
expr_stmt|;
name|dofix
operator|=
name|alpha_unaligned_fix
operator|&&
operator|!
operator|(
name|uac
operator|&
name|MDP_UAC_NOFIX
operator|)
expr_stmt|;
name|dosigbus
operator|=
name|alpha_unaligned_sigbus
operator||
operator|(
name|uac
operator|&
name|MDP_UAC_SIGBUS
operator|)
expr_stmt|;
comment|/* 	 * Find out which opcode it is.  Arrange to have the opcode 	 * printed if it's an unknown opcode. 	 */
if|if
condition|(
name|opcode
operator|>=
literal|0x20
operator|&&
name|opcode
operator|<=
literal|0x2f
condition|)
block|{
name|type
operator|=
name|tab
index|[
name|opcode
operator|-
literal|0x20
index|]
operator|.
name|type
expr_stmt|;
name|size
operator|=
name|tab
index|[
name|opcode
operator|-
literal|0x20
index|]
operator|.
name|size
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
literal|"0x%lx"
expr_stmt|;
name|size
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * See if the user can access the memory in question. 	 * Even if it's an unknown opcode, SEGV if the access 	 * should have failed. 	 */
if|if
condition|(
operator|!
name|useracc
argument_list|(
operator|(
name|caddr_t
operator|)
name|va
argument_list|,
name|size
condition|?
name|size
else|:
literal|1
argument_list|,
name|VM_PROT_WRITE
argument_list|)
condition|)
block|{
name|signal
operator|=
name|SIGSEGV
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * If we're supposed to be noisy, squawk now. 	 */
if|if
condition|(
name|doprint
condition|)
block|{
name|uprintf
argument_list|(
literal|"pid %d (%s): unaligned access: va=0x%lx pc=0x%lx ra=0x%lx op="
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|p
operator|->
name|p_comm
argument_list|,
name|va
argument_list|,
name|p
operator|->
name|p_md
operator|.
name|md_tf
operator|->
name|tf_regs
index|[
name|FRAME_PC
index|]
argument_list|,
name|p
operator|->
name|p_md
operator|.
name|md_tf
operator|->
name|tf_regs
index|[
name|FRAME_RA
index|]
argument_list|)
expr_stmt|;
name|uprintf
argument_list|(
name|type
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
name|uprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we should try to fix it and know how, give it a shot. 	 * 	 * We never allow bad data to be unknowingly used by the 	 * user process.  That is, if we decide not to fix up an 	 * access we cause a SIGBUS rather than letting the user 	 * process go on without warning. 	 * 	 * If we're trying to do a fixup, we assume that things 	 * will be botched.  If everything works out OK,  	 * unaligned_{load,store}_* clears the signal flag. 	 */
name|signal
operator|=
name|SIGBUS
expr_stmt|;
if|if
condition|(
name|dofix
operator|&&
name|size
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
name|opcode
condition|)
block|{
ifdef|#
directive|ifdef
name|FIX_UNALIGNED_VAX_FP
case|case
literal|0x20
case|:
comment|/* ldf */
name|unaligned_load_floating
argument_list|(
name|intdata
argument_list|,
name|Ffloat_to_reg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x21
case|:
comment|/* ldg */
name|unaligned_load_floating
argument_list|(
name|longdata
argument_list|,
name|Gfloat_reg_cvt
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|0x22
case|:
comment|/* lds */
name|unaligned_load_floating
argument_list|(
name|intdata
argument_list|,
name|Sfloat_to_reg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x23
case|:
comment|/* ldt */
name|unaligned_load_floating
argument_list|(
name|longdata
argument_list|,
name|Tfloat_reg_cvt
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|FIX_UNALIGNED_VAX_FP
case|case
literal|0x24
case|:
comment|/* stf */
name|unaligned_store_floating
argument_list|(
name|intdata
argument_list|,
name|reg_to_Ffloat
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x25
case|:
comment|/* stg */
name|unaligned_store_floating
argument_list|(
name|longdata
argument_list|,
name|Gfloat_reg_cvt
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|0x26
case|:
comment|/* sts */
name|unaligned_store_floating
argument_list|(
name|intdata
argument_list|,
name|reg_to_Sfloat
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x27
case|:
comment|/* stt */
name|unaligned_store_floating
argument_list|(
name|longdata
argument_list|,
name|Tfloat_reg_cvt
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x28
case|:
comment|/* ldl */
name|unaligned_load_integer
argument_list|(
name|intdata
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x29
case|:
comment|/* ldq */
name|unaligned_load_integer
argument_list|(
name|longdata
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x2c
case|:
comment|/* stl */
name|unaligned_store_integer
argument_list|(
name|intdata
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x2d
case|:
comment|/* stq */
name|unaligned_store_integer
argument_list|(
name|longdata
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
default|default:
name|panic
argument_list|(
literal|"unaligned_fixup: can't get here"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
comment|/* 	 * Force SIGBUS if requested. 	 */
if|if
condition|(
name|dosigbus
condition|)
name|signal
operator|=
name|SIGBUS
expr_stmt|;
name|out
label|:
return|return
operator|(
name|signal
operator|)
return|;
block|}
end_function

end_unit

