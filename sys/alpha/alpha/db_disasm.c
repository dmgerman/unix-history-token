begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/* $NetBSD: db_disasm.c,v 1.4 1997/09/16 22:52:40 thorpej Exp $ */
end_comment

begin_comment
comment|/*   * Mach Operating System  * Copyright (c) 1991,1990,1989,1988,1987 Carnegie Mellon University  * All Rights Reserved.  *   * Permission to use, copy, modify and distribute this software and its  * documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *   * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"  * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR  * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *   * Carnegie Mellon requests users of this software to return to  *   *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *   * any improvements or extensions that they make and grant Carnegie Mellon  * the rights to redistribute these changes.  */
end_comment

begin_comment
comment|/*  *	File: db_disasm.c  * 	Author: Alessandro Forin, Carnegie Mellon University  *	Date:	11/91  *  *	Disassembler for Alpha  *  *	Modified for NetBSD/alpha by:  *  *	Christopher G. Demetriou, Carnegie Mellon University  *  *	Jason R. Thorpe, Numerical Aerospace Simulation Facility,  *	NASA Ames Research Center  *  *	This code was derived exclusively from information available in  *	"Alpha Architecture Reference Manual", Richard L. Sites ed.  *	Digital Press, Burlington, MA 01803  *	ISBN 1-55558-098-X, Order no. EY-L520E-DP  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_comment
comment|/* RCS ID& Copyright macro defns */
end_comment

begin_comment
comment|/* __KERNEL_RCSID(0, "$NetBSD: db_disasm.c,v 1.4 1997/09/16 22:52:40 thorpej Exp $"); */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<machine/db_machdep.h>
end_include

begin_include
include|#
directive|include
file|<alpha/alpha/db_instruction.h>
end_include

begin_include
include|#
directive|include
file|<machine/pal.h>
end_include

begin_include
include|#
directive|include
file|<ddb/ddb.h>
end_include

begin_include
include|#
directive|include
file|<ddb/db_access.h>
end_include

begin_include
include|#
directive|include
file|<ddb/db_sym.h>
end_include

begin_include
include|#
directive|include
file|<ddb/db_output.h>
end_include

begin_comment
comment|/*  * This would belong in a header file, except noone else needs it  */
end_comment

begin_typedef
typedef|typedef
union|union
block|{
comment|/* 	 *	All instructions are 32 bits wide, PAL included 	 */
name|unsigned
name|int
name|bits
decl_stmt|;
comment|/* 	 *	Internal processor register access instrs 	 *	specify the IPR index, doubly specify the 	 *	(same) GP register as src/dest, and qualifiers 	 *	for the IPR set involved (abox/ibox/tmp) 	 */
struct|struct
block|{
name|unsigned
name|index
range|:
literal|5
decl_stmt|,
name|regset
range|:
literal|3
decl_stmt|,
comment|/* a,i,p */
name|xxx
range|:
literal|8
decl_stmt|,
name|rs
range|:
literal|5
decl_stmt|,
name|rd
range|:
literal|5
decl_stmt|,
name|opcode
range|:
literal|6
decl_stmt|;
block|}
name|mXpr_format
struct|;
comment|/* 	 *	Load/store instructions have a 12 bit displacement, 	 *	and two register specifiers just as normal ld/st. 	 *	Four bits have special meanings: 	 *		phy: bypass the MMU (physical access) 	 *		alt: use mode in ALT register for checks, 	 *		     or if PHY is also on locked/linked access 	 *		rwc: read-with-write-check (probew) 	 *		qw:  quadword access 	 */
struct|struct
block|{
name|signed
name|int
name|displacement
range|:
literal|12
decl_stmt|;
name|unsigned
name|qw
range|:
literal|1
decl_stmt|,
name|qualif
range|:
literal|3
decl_stmt|,
name|rs
range|:
literal|5
decl_stmt|,
name|rd
range|:
literal|5
decl_stmt|,
name|opcode
range|:
literal|6
decl_stmt|;
block|}
name|mem_format
struct|;
comment|/* 	 *	Return from exception or interrupt has 	 *	a branch-like encoding, but only one 	 *	instantiation is actually usable. 	 */
struct|struct
block|{
name|unsigned
name|xxx
range|:
literal|14
decl_stmt|,
name|zero
range|:
literal|1
decl_stmt|,
comment|/* branch prediction! */
name|one
range|:
literal|1
decl_stmt|,
name|rb
range|:
literal|5
decl_stmt|,
comment|/* r31 or stall */
name|ra
range|:
literal|5
decl_stmt|,
comment|/* r31 or stall */
name|opcode
range|:
literal|6
decl_stmt|;
block|}
name|rei_format
struct|;
block|}
name|pal_instruction
typedef|;
end_typedef

begin_comment
comment|/*  * Major opcodes  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|op_name
index|[
literal|64
index|]
init|=
block|{
comment|/* 0 */
literal|"call_pal"
block|,
literal|"op1"
block|,
literal|"op2"
block|,
literal|"op3"
block|,
literal|"op4"
block|,
literal|"op5"
block|,
literal|"op6"
block|,
literal|"op7"
block|,
comment|/* 8 */
literal|"lda"
block|,
literal|"ldah"
block|,
literal|"ldbu"
block|,
literal|"ldq_u"
block|,
literal|"ldwu"
block|,
literal|"stw"
block|,
literal|"stb"
block|,
literal|"stq_u"
block|,
comment|/*16 */
literal|"arit"
block|,
literal|"logical"
block|,
literal|"bit"
block|,
literal|"mul"
block|,
literal|"op20"
block|,
literal|"vaxf"
block|,
literal|"ieeef"
block|,
literal|"anyf"
block|,
comment|/*24 */
literal|"spec"
block|,
literal|"hw_mfpr"
block|,
literal|"jump"
block|,
literal|"hw_ld"
block|,
literal|"intmisc"
block|,
literal|"hw_mtpr"
block|,
literal|"hw_rei"
block|,
literal|"hw_st"
block|,
comment|/*32 */
literal|"ldf"
block|,
literal|"ldg"
block|,
literal|"lds"
block|,
literal|"ldt"
block|,
literal|"stf"
block|,
literal|"stg"
block|,
literal|"sts"
block|,
literal|"stt"
block|,
comment|/*40 */
literal|"ldl"
block|,
literal|"ldq"
block|,
literal|"ldl_l"
block|,
literal|"ldq_l"
block|,
literal|"stl"
block|,
literal|"stq"
block|,
literal|"stl_c"
block|,
literal|"stq_c"
block|,
comment|/*48 */
literal|"br"
block|,
literal|"fbeq"
block|,
literal|"fblt"
block|,
literal|"fble"
block|,
literal|"bsr"
block|,
literal|"fbne"
block|,
literal|"fbge"
block|,
literal|"fbgt"
block|,
comment|/*56 */
literal|"blbc"
block|,
literal|"beq"
block|,
literal|"blt"
block|,
literal|"ble"
block|,
literal|"blbs"
block|,
literal|"bne"
block|,
literal|"bge"
block|,
literal|"bgt"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The function field is too big (7 or 11 bits), so the sub-tables  * are addressed in a somewhat complicated manner to save  * space.  After all, alu operations is what RISCs are good at.  */
end_comment

begin_struct
struct|struct
name|tbl
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|code
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|tbl
name|pal_op_tbl
index|[]
init|=
block|{
comment|/* Common PAL function codes. */
block|{
literal|"halt"
block|,
name|PAL_halt
block|}
block|,
block|{
literal|"cflush"
block|,
name|PAL_cflush
block|}
block|,
block|{
literal|"draina"
block|,
name|PAL_draina
block|}
block|,
block|{
literal|"cserve"
block|,
name|PAL_cserve
block|, }
block|,
block|{
literal|"swppal"
block|,
name|PAL_swppal
block|}
block|,
block|{
literal|"ipir"
block|,
name|PAL_ipir
block|}
block|,
block|{
literal|"bpt"
block|,
name|PAL_bpt
block|}
block|,
block|{
literal|"bugchk"
block|,
name|PAL_bugchk
block|}
block|,
block|{
literal|"imb"
block|,
name|PAL_imb
block|}
block|,
block|{
literal|"rdunique"
block|,
name|PAL_rdunique
block|}
block|,
block|{
literal|"wrunique"
block|,
name|PAL_wrunique
block|}
block|,
block|{
literal|"gentrap"
block|,
name|PAL_gentrap
block|}
block|,
comment|/* OSF/1 PAL function codes. */
block|{
literal|"osf1_rdmces"
block|,
name|PAL_OSF1_rdmces
block|}
block|,
block|{
literal|"osf1_wrmces"
block|,
name|PAL_OSF1_wrmces
block|}
block|,
block|{
literal|"osf1_wrfen"
block|,
name|PAL_OSF1_wrfen
block|}
block|,
block|{
literal|"osf1_wrvptptr"
block|,
name|PAL_OSF1_wrvptptr
block|}
block|,
block|{
literal|"osf1_swpctx"
block|,
name|PAL_OSF1_swpctx
block|}
block|,
block|{
literal|"osf1_wrval"
block|,
name|PAL_OSF1_wrval
block|}
block|,
block|{
literal|"osf1_rdval"
block|,
name|PAL_OSF1_rdval
block|}
block|,
block|{
literal|"osf1_tbi"
block|,
name|PAL_OSF1_tbi
block|}
block|,
block|{
literal|"osf1_wrent"
block|,
name|PAL_OSF1_wrent
block|}
block|,
block|{
literal|"osf1_swpipl"
block|,
name|PAL_OSF1_swpipl
block|}
block|,
block|{
literal|"osf1_rdps"
block|,
name|PAL_OSF1_rdps
block|}
block|,
block|{
literal|"osf1_wrkgp"
block|,
name|PAL_OSF1_wrkgp
block|}
block|,
block|{
literal|"osf1_wrusp"
block|,
name|PAL_OSF1_wrusp
block|}
block|,
block|{
literal|"osf1_wrperfmon"
block|,
name|PAL_OSF1_wrperfmon
block|}
block|,
block|{
literal|"osf1_rdusp"
block|,
name|PAL_OSF1_rdusp
block|}
block|,
block|{
literal|"osf1_whami"
block|,
name|PAL_OSF1_whami
block|}
block|,
block|{
literal|"osf1_retsys"
block|,
name|PAL_OSF1_retsys
block|}
block|,
block|{
literal|"osf1_rti"
block|,
name|PAL_OSF1_rti
block|}
block|,
block|{
literal|"osf1_callsys"
block|,
name|PAL_OSF1_callsys
block|}
block|,
block|{
name|NULL
block|,
operator|-
literal|1
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|pal_opname
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|pal_opname
parameter_list|(
name|op
parameter_list|)
name|int
name|op
decl_stmt|;
block|{
specifier|static
name|char
name|unk
index|[
literal|8
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|pal_op_tbl
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pal_op_tbl
index|[
name|i
index|]
operator|.
name|code
operator|==
name|op
condition|)
return|return
operator|(
name|pal_op_tbl
index|[
name|i
index|]
operator|.
name|name
operator|)
return|;
block|}
name|snprintf
argument_list|(
name|unk
argument_list|,
sizeof|sizeof
argument_list|(
name|unk
argument_list|)
argument_list|,
literal|"0x%x"
argument_list|,
name|op
argument_list|)
expr_stmt|;
return|return
operator|(
name|unk
operator|)
return|;
block|}
end_function

begin_comment
comment|/* HW (PAL) instruction qualifiers, stright tables */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|mXpr_name
index|[
literal|8
index|]
init|=
block|{
literal|""
block|,
literal|"/i"
block|,
literal|"/a"
block|,
literal|"/ai"
block|,
literal|"/p"
block|,
literal|"/pi"
block|,
literal|"/pa"
block|,
literal|"/pai"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|hwlds_name
index|[
literal|8
index|]
init|=
block|{
literal|""
block|,
literal|"/r"
block|,
literal|"/a"
block|,
literal|"/ar"
block|,
literal|"/p"
block|,
literal|"/p?r"
block|,
literal|"_l-c"
block|,
literal|"_l-c/?r"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * For this one we take the low nibble (valid values 0/2/9/b/d)  * and shift it down one to get the row index.  Within a row  * we can just take the high nibble deprived of the high bit  * (valid values 0/1/2/3/4/6).  We could have used a flat 64  * entry array, but in this way we use just 48 pointers.  * BUGFIX: the 'cmpbge 0x0f' opcode fits in here too  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|arit_c0
index|[
literal|8
index|]
init|=
block|{
literal|"addl"
block|,
literal|0
block|,
literal|"addq"
block|,
literal|0
block|,
literal|"addl/v"
block|,
literal|0
block|,
literal|"addq/v"
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|arit_c2
index|[
literal|8
index|]
init|=
block|{
literal|"s4addl"
block|,
literal|"s8addl"
block|,
literal|"s4addq"
block|,
literal|"s8addq"
block|,  }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|arit_c9
index|[
literal|8
index|]
init|=
block|{
literal|"subl"
block|,
literal|0
block|,
literal|"subq"
block|,
literal|0
block|,
literal|"subl/v"
block|,
literal|0
block|,
literal|"subq/v"
block|,  }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|arit_cB
index|[
literal|8
index|]
init|=
block|{
literal|"s4subl"
block|,
literal|"s8subl"
block|,
literal|"s4subq"
block|,
literal|"s8subq"
block|,  }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|arit_cD
index|[
literal|8
index|]
init|=
block|{
literal|0
block|,
literal|"cmpult"
block|,
literal|"cmpeq"
block|,
literal|"cmpule"
block|,
literal|"cmplt"
block|,
literal|0
block|,
literal|"cmple"
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|arit_cF
index|[
literal|1
index|]
init|=
block|{
literal|"cmpbge"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
modifier|*
name|arit_opname
index|[
literal|8
index|]
init|=
block|{
name|arit_c0
block|,
name|arit_c2
block|,
literal|0
block|,
literal|0
block|,
name|arit_c9
block|,
name|arit_cB
block|,
name|arit_cD
block|,
name|arit_cF
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|__inline
specifier|const
name|char
modifier|*
name|arit_name
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|__inline
specifier|const
name|char
modifier|*
name|arit_name
parameter_list|(
name|op
parameter_list|)
name|int
name|op
decl_stmt|;
block|{
specifier|static
name|char
name|unk
index|[
literal|32
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|arit_opname
index|[
operator|(
operator|(
name|op
operator|)
operator|&
literal|0xe
operator|)
operator|>>
literal|1
index|]
condition|)
name|name
operator|=
name|arit_opname
index|[
operator|(
operator|(
name|op
operator|)
operator|&
literal|0xe
operator|)
operator|>>
literal|1
index|]
index|[
operator|(
operator|(
name|op
operator|)
operator|&
literal|0x70
operator|)
operator|>>
literal|4
index|]
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
return|return
operator|(
name|name
operator|)
return|;
name|snprintf
argument_list|(
name|unk
argument_list|,
sizeof|sizeof
argument_list|(
name|unk
argument_list|)
argument_list|,
literal|"?arit 0x%x?"
argument_list|,
name|op
argument_list|)
expr_stmt|;
return|return
operator|(
name|unk
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Something similar for this one, except there are only  * 16 entries so the row indexing is done by enumeration  * of the low nibble (valid values 0/4/6/8).  Then we can  * just shift the high nibble to index inside the row  * (valid values are 0/2/4 or 1/2/4/6)  *  * There are two functions that don't play by these simple rules,  * so we special-case them.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|logical_c0
index|[
literal|4
index|]
init|=
block|{
literal|"and"
block|,
literal|"or"
block|,
literal|"xor"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|logical_c4
index|[
literal|4
index|]
init|=
block|{
literal|"cmovlbs"
block|,
literal|"cmoveq"
block|,
literal|"cmovlt"
block|,
literal|"cmovle"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|logical_c6
index|[
literal|4
index|]
init|=
block|{
literal|"cmovlbc"
block|,
literal|"cmovne"
block|,
literal|"cmovge"
block|,
literal|"cmovgt"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|logical_c8
index|[
literal|4
index|]
init|=
block|{
literal|"andnot"
block|,
literal|"ornot"
block|,
literal|"xornot"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|__inline
specifier|const
name|char
modifier|*
name|logical_name
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|__inline
specifier|const
name|char
modifier|*
name|logical_name
parameter_list|(
name|op
parameter_list|)
name|int
name|op
decl_stmt|;
block|{
specifier|static
name|char
name|unk
index|[
literal|32
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|op
operator|==
name|op_amask
condition|)
return|return
operator|(
literal|"amask"
operator|)
return|;
elseif|else
if|if
condition|(
name|op
operator|==
name|op_implver
condition|)
return|return
operator|(
literal|"implver"
operator|)
return|;
switch|switch
condition|(
name|op
operator|&
literal|0xf
condition|)
block|{
case|case
literal|0
case|:
name|name
operator|=
name|logical_c0
index|[
operator|(
operator|(
name|op
operator|)
operator|>>
literal|5
operator|)
operator|&
literal|3
index|]
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|name
operator|=
name|logical_c4
index|[
operator|(
operator|(
name|op
operator|)
operator|>>
literal|5
operator|)
operator|&
literal|3
index|]
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|name
operator|=
name|logical_c6
index|[
operator|(
operator|(
name|op
operator|)
operator|>>
literal|5
operator|)
operator|&
literal|3
index|]
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|name
operator|=
name|logical_c8
index|[
operator|(
operator|(
name|op
operator|)
operator|>>
literal|5
operator|)
operator|&
literal|3
index|]
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
return|return
operator|(
name|name
operator|)
return|;
name|snprintf
argument_list|(
name|unk
argument_list|,
sizeof|sizeof
argument_list|(
name|unk
argument_list|)
argument_list|,
literal|"?logical 0x%x?"
argument_list|,
name|op
argument_list|)
expr_stmt|;
return|return
operator|(
name|unk
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This is the messy one. First, we single out the dense  * case of a 3 in the high nibble (valid values 0/1/2/4/6/9/b/c).  * Then the case of a 2 in the low nibble (valid values 0/1/2/5/6/7).  * For the remaining codes (6/7/a/b) we do as above: high  * nibble has valid values 0/1/2 or 5/6/7.  The low nibble  * can be used as row index picking bits 0 and 2, for the  * high one just the lower two bits.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|bitop_c3
index|[
literal|8
index|]
init|=
block|{
literal|"zapnot"
block|,
literal|"mskql"
block|,
literal|"srl"
block|,
literal|"extql"
block|,
literal|"sll"
block|,
literal|"insql"
block|,
literal|"sra"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|bitop_c2
index|[
literal|8
index|]
init|=
block|{
literal|"mskbl"
block|,
literal|"mskwl"
block|,
literal|"mskll"
block|,
literal|0
comment|/*mskql*/
block|,
literal|0
block|,
literal|"mskwh"
block|,
literal|"msklh"
block|,
literal|"mskqh"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|bitop_c67ab
index|[
literal|4
index|]
index|[
literal|4
index|]
init|=
block|{
comment|/* a */
block|{
literal|0
block|,
literal|"extwh"
block|,
literal|"extlh"
block|,
literal|"extqh"
block|}
block|,
comment|/* b */
block|{
literal|"insbl"
block|,
literal|"inswl"
block|,
literal|"insll"
block|,
literal|0
block|}
block|,
comment|/* 6 */
block|{
literal|"extbl"
block|,
literal|"extwl"
block|,
literal|"extll"
block|,
literal|0
block|}
block|,
comment|/* 7 */
block|{
literal|0
block|,
literal|"inswh"
block|,
literal|"inslh"
block|,
literal|"insqh"
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|__inline
specifier|const
name|char
modifier|*
name|bitop_name
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|__inline
specifier|const
name|char
modifier|*
name|bitop_name
parameter_list|(
name|op
parameter_list|)
name|int
name|op
decl_stmt|;
block|{
specifier|static
name|char
name|unk
index|[
literal|32
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|(
name|op
operator|&
literal|0x70
operator|)
operator|==
literal|0x30
condition|)
name|name
operator|=
operator|(
name|op
operator|==
name|op_zap
operator|)
condition|?
literal|"zap"
else|:
name|bitop_c3
index|[
operator|(
operator|(
name|op
operator|)
operator|&
literal|0xe
operator|)
operator|>>
literal|1
index|]
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|op
operator|&
literal|0xf
operator|)
operator|==
literal|0x02
condition|)
name|name
operator|=
name|bitop_c2
index|[
operator|(
name|op
operator|)
operator|>>
literal|4
index|]
expr_stmt|;
else|else
name|name
operator|=
name|bitop_c67ab
index|[
operator|(
operator|(
operator|(
name|op
operator|)
operator|&
literal|1
operator|)
operator||
operator|(
operator|(
operator|(
name|op
operator|)
operator|&
literal|0x4
operator|)
operator|>>
literal|1
operator|)
operator|)
index|]
index|[
operator|(
operator|(
operator|(
name|op
operator|)
operator|&
literal|0x30
operator|)
operator|>>
literal|4
operator|)
index|]
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
return|return
operator|(
name|name
operator|)
return|;
name|snprintf
argument_list|(
name|unk
argument_list|,
sizeof|sizeof
argument_list|(
name|unk
argument_list|)
argument_list|,
literal|"?bit 0x%x?"
argument_list|,
name|op
argument_list|)
expr_stmt|;
return|return
operator|(
name|unk
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Only 5 entries in this one  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|mul_opname
index|[
literal|4
index|]
init|=
block|{
literal|"mull"
block|,
literal|"mulq"
block|,
literal|"mull/v"
block|,
literal|"mulq/v"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|__inline
specifier|const
name|char
modifier|*
name|mul_name
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|__inline
specifier|const
name|char
modifier|*
name|mul_name
parameter_list|(
name|op
parameter_list|)
name|int
name|op
decl_stmt|;
block|{
specifier|static
name|char
name|unk
index|[
literal|32
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
name|name
operator|=
operator|(
name|op
operator|==
name|op_umulh
operator|)
condition|?
literal|"umulh"
else|:
name|mul_opname
index|[
operator|(
operator|(
name|op
operator|)
operator|>>
literal|5
operator|)
operator|&
literal|3
index|]
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
return|return
operator|(
name|name
operator|)
return|;
name|snprintf
argument_list|(
name|unk
argument_list|,
sizeof|sizeof
argument_list|(
name|unk
argument_list|)
argument_list|,
literal|"?mul 0x%x?"
argument_list|,
name|op
argument_list|)
expr_stmt|;
return|return
operator|(
name|unk
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * These are few, the high nibble is enough to dispatch.  * We single out the "f" case to halve the table size.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|special_opname
index|[
literal|8
index|]
init|=
block|{
literal|"drain_t"
block|,
literal|0
block|,
literal|"mb"
block|,
literal|0
block|,
literal|"fetch"
block|,
literal|"fetch_m"
block|,
literal|"rpcc"
block|,
literal|"rc"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|__inline
specifier|const
name|char
modifier|*
name|special_name
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|__inline
specifier|const
name|char
modifier|*
name|special_name
parameter_list|(
name|op
parameter_list|)
name|int
name|op
decl_stmt|;
block|{
specifier|static
name|char
name|unk
index|[
literal|32
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
operator|(
name|op
operator|==
name|op_rs
operator|)
condition|?
literal|"rs"
else|:
name|special_opname
index|[
operator|(
name|op
operator|)
operator|>>
literal|13
index|]
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
return|return
operator|(
name|name
operator|)
return|;
name|snprintf
argument_list|(
name|unk
argument_list|,
sizeof|sizeof
argument_list|(
name|unk
argument_list|)
argument_list|,
literal|"?special 0x%x?"
argument_list|,
name|op
argument_list|)
expr_stmt|;
return|return
operator|(
name|unk
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This is trivial  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|jump_opname
index|[
literal|4
index|]
init|=
block|{
literal|"jmp"
block|,
literal|"jsr"
block|,
literal|"ret"
block|,
literal|"jcr"
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|jump_name
parameter_list|(
name|ix
parameter_list|)
value|jump_opname[ix]
end_define

begin_comment
comment|/*  * For all but 4 of these, we can dispatch on the lower nibble of  * the "function".  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|intmisc_opname_3x
index|[
literal|16
index|]
init|=
block|{
literal|"ctpop"
block|,
literal|"perr"
block|,
literal|"ctlz"
block|,
literal|"cttz"
block|,
literal|"unpkbw"
block|,
literal|"unpkbl"
block|,
literal|"pkwb"
block|,
literal|"pklb"
block|,
literal|"minsb8"
block|,
literal|"minsw4"
block|,
literal|"minub8"
block|,
literal|"minuw4"
block|,
literal|"maxub8"
block|,
literal|"maxuw4"
block|,
literal|"maxsb8"
block|,
literal|"maxsw4"
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|__inline
specifier|const
name|char
modifier|*
name|intmisc_name
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|__inline
specifier|const
name|char
modifier|*
name|intmisc_name
parameter_list|(
name|op
parameter_list|)
name|int
name|op
decl_stmt|;
block|{
specifier|static
name|char
name|unk
index|[
literal|32
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|op
operator|&
literal|0xf0
operator|)
operator|==
literal|0x30
condition|)
return|return
operator|(
name|intmisc_opname_3x
index|[
name|op
operator|&
literal|0x0f
index|]
operator|)
return|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|op_sextb
case|:
return|return
operator|(
literal|"sextb"
operator|)
return|;
case|case
name|op_sextw
case|:
return|return
operator|(
literal|"sextw"
operator|)
return|;
case|case
name|op_ftoit
case|:
return|return
operator|(
literal|"ftoit"
operator|)
return|;
case|case
name|op_ftois
case|:
return|return
operator|(
literal|"ftois"
operator|)
return|;
block|}
name|snprintf
argument_list|(
name|unk
argument_list|,
sizeof|sizeof
argument_list|(
name|unk
argument_list|)
argument_list|,
literal|"?intmisc 0x%x?"
argument_list|,
name|op
argument_list|)
expr_stmt|;
return|return
operator|(
name|unk
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|float_name
name|__P
argument_list|(
operator|(
specifier|const
expr|struct
name|tbl
index|[]
operator|,
name|int
operator|,
specifier|const
name|char
operator|*
name|type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|float_name
parameter_list|(
name|tbl
parameter_list|,
name|op
parameter_list|,
name|type
parameter_list|)
specifier|const
name|struct
name|tbl
name|tbl
index|[]
decl_stmt|;
name|int
name|op
decl_stmt|;
specifier|const
name|char
modifier|*
name|type
decl_stmt|;
block|{
specifier|static
name|char
name|unk
index|[
literal|32
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|tbl
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|tbl
index|[
name|i
index|]
operator|.
name|code
operator|==
name|op
condition|)
return|return
operator|(
name|tbl
index|[
name|i
index|]
operator|.
name|name
operator|)
return|;
block|}
name|snprintf
argument_list|(
name|unk
argument_list|,
sizeof|sizeof
argument_list|(
name|unk
argument_list|)
argument_list|,
literal|"?%s 0x%x?"
argument_list|,
name|type
argument_list|,
name|op
argument_list|)
expr_stmt|;
return|return
operator|(
name|unk
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|vaxf_name
parameter_list|(
name|op
parameter_list|)
value|float_name(vaxf_tbl, op, "vaxfl")
end_define

begin_define
define|#
directive|define
name|ieeef_name
parameter_list|(
name|op
parameter_list|)
value|float_name(ieeef_tbl, op, "ieeefl")
end_define

begin_define
define|#
directive|define
name|anyf_name
parameter_list|(
name|op
parameter_list|)
value|float_name(anyf_tbl, op, "anyfl")
end_define

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|tbl
name|anyf_tbl
index|[]
init|=
block|{
block|{
literal|"cvtlq"
block|,
literal|0x010
block|}
block|,
block|{
literal|"cpys"
block|,
literal|0x020
block|}
block|,
block|{
literal|"cpysn"
block|,
literal|0x021
block|}
block|,
block|{
literal|"cpyse"
block|,
literal|0x022
block|}
block|,
block|{
literal|"mt_fpcr"
block|,
literal|0x024
block|}
block|,
block|{
literal|"mf_fpcr"
block|,
literal|0x025
block|}
block|,
block|{
literal|"fcmoveq"
block|,
literal|0x02a
block|}
block|,
block|{
literal|"fcmovne"
block|,
literal|0x02b
block|}
block|,
block|{
literal|"fcmovlt"
block|,
literal|0x02c
block|}
block|,
block|{
literal|"fcmovge"
block|,
literal|0x02d
block|}
block|,
block|{
literal|"fcmovle"
block|,
literal|0x02e
block|}
block|,
block|{
literal|"fcmovgt"
block|,
literal|0x02f
block|}
block|,
block|{
literal|"cvtql"
block|,
literal|0x030
block|}
block|,
block|{
literal|"cvtql/v"
block|,
literal|0x130
block|}
block|,
block|{
literal|"cvtql/sv"
block|,
literal|0x330
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|tbl
name|ieeef_tbl
index|[]
init|=
block|{
block|{
literal|"adds/c"
block|,
literal|0x000
block|}
block|,
block|{
literal|"subs/c"
block|,
literal|0x001
block|}
block|,
block|{
literal|"muls/c"
block|,
literal|0x002
block|}
block|,
block|{
literal|"divs/c"
block|,
literal|0x003
block|}
block|,
block|{
literal|"addt/c"
block|,
literal|0x020
block|}
block|,
block|{
literal|"subt/c"
block|,
literal|0x021
block|}
block|,
block|{
literal|"mult/c"
block|,
literal|0x022
block|}
block|,
block|{
literal|"divt/c"
block|,
literal|0x023
block|}
block|,
block|{
literal|"cvtts/c"
block|,
literal|0x02c
block|}
block|,
block|{
literal|"cvttq/c"
block|,
literal|0x02f
block|}
block|,
block|{
literal|"cvtqs/c"
block|,
literal|0x03c
block|}
block|,
block|{
literal|"cvtqt/c"
block|,
literal|0x03e
block|}
block|,
block|{
literal|"adds/m"
block|,
literal|0x040
block|}
block|,
block|{
literal|"subs/m"
block|,
literal|0x041
block|}
block|,
block|{
literal|"muls/m"
block|,
literal|0x042
block|}
block|,
block|{
literal|"divs/m"
block|,
literal|0x043
block|}
block|,
block|{
literal|"addt/m"
block|,
literal|0x060
block|}
block|,
block|{
literal|"subt/m"
block|,
literal|0x061
block|}
block|,
block|{
literal|"mult/m"
block|,
literal|0x062
block|}
block|,
block|{
literal|"divt/m"
block|,
literal|0x063
block|}
block|,
block|{
literal|"cvtts/m"
block|,
literal|0x06c
block|}
block|,
block|{
literal|"cvtqs/m"
block|,
literal|0x07c
block|}
block|,
block|{
literal|"cvtqt/m"
block|,
literal|0x07e
block|}
block|,
block|{
literal|"adds"
block|,
literal|0x080
block|}
block|,
block|{
literal|"subs"
block|,
literal|0x081
block|}
block|,
block|{
literal|"muls"
block|,
literal|0x082
block|}
block|,
block|{
literal|"divs"
block|,
literal|0x083
block|}
block|,
block|{
literal|"addt"
block|,
literal|0x0a0
block|}
block|,
block|{
literal|"subt"
block|,
literal|0x0a1
block|}
block|,
block|{
literal|"mult"
block|,
literal|0x0a2
block|}
block|,
block|{
literal|"divt"
block|,
literal|0x0a3
block|}
block|,
block|{
literal|"cmptun"
block|,
literal|0x0a4
block|}
block|,
block|{
literal|"cmpteq"
block|,
literal|0x0a5
block|}
block|,
block|{
literal|"cmptlt"
block|,
literal|0x0a6
block|}
block|,
block|{
literal|"cmptle"
block|,
literal|0x0a7
block|}
block|,
block|{
literal|"cvtts"
block|,
literal|0x0ac
block|}
block|,
block|{
literal|"cvttq"
block|,
literal|0x0af
block|}
block|,
block|{
literal|"cvtqs"
block|,
literal|0x0bc
block|}
block|,
block|{
literal|"cvtqt"
block|,
literal|0x0be
block|}
block|,
block|{
literal|"adds/d"
block|,
literal|0x0c0
block|}
block|,
block|{
literal|"subs/d"
block|,
literal|0x0c1
block|}
block|,
block|{
literal|"muls/d"
block|,
literal|0x0c2
block|}
block|,
block|{
literal|"divs/d"
block|,
literal|0x0c3
block|}
block|,
block|{
literal|"addt/d"
block|,
literal|0x0e0
block|}
block|,
block|{
literal|"subt/d"
block|,
literal|0x0e1
block|}
block|,
block|{
literal|"mult/d"
block|,
literal|0x0e2
block|}
block|,
block|{
literal|"divt/d"
block|,
literal|0x0e3
block|}
block|,
block|{
literal|"cvtts/d"
block|,
literal|0x0ec
block|}
block|,
block|{
literal|"cvtqs/d"
block|,
literal|0x0fc
block|}
block|,
block|{
literal|"cvtqt/d"
block|,
literal|0x0fe
block|}
block|,
block|{
literal|"adds/uc"
block|,
literal|0x100
block|}
block|,
block|{
literal|"subs/uc"
block|,
literal|0x101
block|}
block|,
block|{
literal|"muls/uc"
block|,
literal|0x102
block|}
block|,
block|{
literal|"divs/uc"
block|,
literal|0x103
block|}
block|,
block|{
literal|"addt/uc"
block|,
literal|0x120
block|}
block|,
block|{
literal|"subt/uc"
block|,
literal|0x121
block|}
block|,
block|{
literal|"mult/uc"
block|,
literal|0x122
block|}
block|,
block|{
literal|"divt/uc"
block|,
literal|0x123
block|}
block|,
block|{
literal|"cvtts/uc"
block|,
literal|0x12c
block|}
block|,
block|{
literal|"cvttq/vc"
block|,
literal|0x12f
block|}
block|,
block|{
literal|"adds/um"
block|,
literal|0x140
block|}
block|,
block|{
literal|"subs/um"
block|,
literal|0x141
block|}
block|,
block|{
literal|"muls/um"
block|,
literal|0x142
block|}
block|,
block|{
literal|"divs/um"
block|,
literal|0x143
block|}
block|,
block|{
literal|"addt/um"
block|,
literal|0x160
block|}
block|,
block|{
literal|"subt/um"
block|,
literal|0x161
block|}
block|,
block|{
literal|"mult/um"
block|,
literal|0x162
block|}
block|,
block|{
literal|"divt/um"
block|,
literal|0x163
block|}
block|,
block|{
literal|"cvtts/um"
block|,
literal|0x16c
block|}
block|,
block|{
literal|"adds/u"
block|,
literal|0x180
block|}
block|,
block|{
literal|"subs/u"
block|,
literal|0x181
block|}
block|,
block|{
literal|"muls/u"
block|,
literal|0x182
block|}
block|,
block|{
literal|"divs/u"
block|,
literal|0x183
block|}
block|,
block|{
literal|"addt/u"
block|,
literal|0x1a0
block|}
block|,
block|{
literal|"subt/u"
block|,
literal|0x1a1
block|}
block|,
block|{
literal|"mult/u"
block|,
literal|0x1a2
block|}
block|,
block|{
literal|"divt/u"
block|,
literal|0x1a3
block|}
block|,
block|{
literal|"cvtts/u"
block|,
literal|0x1ac
block|}
block|,
block|{
literal|"cvttq/v"
block|,
literal|0x1af
block|}
block|,
block|{
literal|"adds/ud"
block|,
literal|0x1c0
block|}
block|,
block|{
literal|"subs/ud"
block|,
literal|0x1c1
block|}
block|,
block|{
literal|"muls/ud"
block|,
literal|0x1c2
block|}
block|,
block|{
literal|"divs/ud"
block|,
literal|0x1c3
block|}
block|,
block|{
literal|"addt/ud"
block|,
literal|0x1e0
block|}
block|,
block|{
literal|"subt/ud"
block|,
literal|0x1e1
block|}
block|,
block|{
literal|"mult/ud"
block|,
literal|0x1e2
block|}
block|,
block|{
literal|"divt/ud"
block|,
literal|0x1e3
block|}
block|,
block|{
literal|"cvtts/ud"
block|,
literal|0x1ec
block|}
block|,
block|{
literal|"adds/suc"
block|,
literal|0x500
block|}
block|,
block|{
literal|"subs/suc"
block|,
literal|0x501
block|}
block|,
block|{
literal|"muls/suc"
block|,
literal|0x502
block|}
block|,
block|{
literal|"divs/suc"
block|,
literal|0x503
block|}
block|,
block|{
literal|"addt/suc"
block|,
literal|0x520
block|}
block|,
block|{
literal|"subt/suc"
block|,
literal|0x521
block|}
block|,
block|{
literal|"mult/suc"
block|,
literal|0x522
block|}
block|,
block|{
literal|"divt/suc"
block|,
literal|0x523
block|}
block|,
block|{
literal|"cvtts/suc"
block|,
literal|0x52c
block|}
block|,
block|{
literal|"cvttq/svc"
block|,
literal|0x52f
block|}
block|,
block|{
literal|"adds/sum"
block|,
literal|0x540
block|}
block|,
block|{
literal|"subs/sum"
block|,
literal|0x541
block|}
block|,
block|{
literal|"muls/sum"
block|,
literal|0x542
block|}
block|,
block|{
literal|"divs/sum"
block|,
literal|0x543
block|}
block|,
block|{
literal|"addt/sum"
block|,
literal|0x560
block|}
block|,
block|{
literal|"subt/sum"
block|,
literal|0x561
block|}
block|,
block|{
literal|"mult/sum"
block|,
literal|0x562
block|}
block|,
block|{
literal|"divt/sum"
block|,
literal|0x563
block|}
block|,
block|{
literal|"cvtts/sum"
block|,
literal|0x56c
block|}
block|,
block|{
literal|"adds/su"
block|,
literal|0x580
block|}
block|,
block|{
literal|"subs/su"
block|,
literal|0x581
block|}
block|,
block|{
literal|"muls/su"
block|,
literal|0x582
block|}
block|,
block|{
literal|"divs/su"
block|,
literal|0x583
block|}
block|,
block|{
literal|"addt/su"
block|,
literal|0x5a0
block|}
block|,
block|{
literal|"subt/su"
block|,
literal|0x5a1
block|}
block|,
block|{
literal|"mult/su"
block|,
literal|0x5a2
block|}
block|,
block|{
literal|"divt/su"
block|,
literal|0x5a3
block|}
block|,
block|{
literal|"cmptun/su"
block|,
literal|0x5a4
block|}
block|,
block|{
literal|"cmpteq/su"
block|,
literal|0x5a5
block|}
block|,
block|{
literal|"cmptlt/su"
block|,
literal|0x5a6
block|}
block|,
block|{
literal|"cmptle/su"
block|,
literal|0x5a7
block|}
block|,
block|{
literal|"cvtts/su"
block|,
literal|0x5ac
block|}
block|,
block|{
literal|"cvttq/sv"
block|,
literal|0x5af
block|}
block|,
block|{
literal|"adds/sud"
block|,
literal|0x5c0
block|}
block|,
block|{
literal|"subs/sud"
block|,
literal|0x5c1
block|}
block|,
block|{
literal|"muls/sud"
block|,
literal|0x5c2
block|}
block|,
block|{
literal|"divs/sud"
block|,
literal|0x5c3
block|}
block|,
block|{
literal|"addt/sud"
block|,
literal|0x5e0
block|}
block|,
block|{
literal|"subt/sud"
block|,
literal|0x5e1
block|}
block|,
block|{
literal|"mult/sud"
block|,
literal|0x5e2
block|}
block|,
block|{
literal|"divt/sud"
block|,
literal|0x5e3
block|}
block|,
block|{
literal|"cvtts/sud"
block|,
literal|0x5ec
block|}
block|,
block|{
literal|"adds/suic"
block|,
literal|0x700
block|}
block|,
block|{
literal|"subs/suic"
block|,
literal|0x701
block|}
block|,
block|{
literal|"muls/suic"
block|,
literal|0x702
block|}
block|,
block|{
literal|"divs/suic"
block|,
literal|0x703
block|}
block|,
block|{
literal|"addt/suic"
block|,
literal|0x720
block|}
block|,
block|{
literal|"subt/suic"
block|,
literal|0x721
block|}
block|,
block|{
literal|"mult/suic"
block|,
literal|0x722
block|}
block|,
block|{
literal|"divt/suic"
block|,
literal|0x723
block|}
block|,
block|{
literal|"cvtts/suic"
block|,
literal|0x72c
block|}
block|,
block|{
literal|"cvttq/svic"
block|,
literal|0x72f
block|}
block|,
block|{
literal|"cvtqs/suic"
block|,
literal|0x73c
block|}
block|,
block|{
literal|"cvtqt/suic"
block|,
literal|0x73e
block|}
block|,
block|{
literal|"adds/suim"
block|,
literal|0x740
block|}
block|,
block|{
literal|"subs/suim"
block|,
literal|0x741
block|}
block|,
block|{
literal|"muls/suim"
block|,
literal|0x742
block|}
block|,
block|{
literal|"divs/suim"
block|,
literal|0x743
block|}
block|,
block|{
literal|"addt/suim"
block|,
literal|0x760
block|}
block|,
block|{
literal|"subt/suim"
block|,
literal|0x761
block|}
block|,
block|{
literal|"mult/suim"
block|,
literal|0x762
block|}
block|,
block|{
literal|"divt/suim"
block|,
literal|0x763
block|}
block|,
block|{
literal|"cvtts/suim"
block|,
literal|0x76c
block|}
block|,
block|{
literal|"cvtqs/suim"
block|,
literal|0x77c
block|}
block|,
block|{
literal|"cvtqt/suim"
block|,
literal|0x77e
block|}
block|,
block|{
literal|"adds/sui"
block|,
literal|0x780
block|}
block|,
block|{
literal|"subs/sui"
block|,
literal|0x781
block|}
block|,
block|{
literal|"muls/sui"
block|,
literal|0x782
block|}
block|,
block|{
literal|"divs/sui"
block|,
literal|0x783
block|}
block|,
block|{
literal|"addt/sui"
block|,
literal|0x7a0
block|}
block|,
block|{
literal|"subt/sui"
block|,
literal|0x7a1
block|}
block|,
block|{
literal|"mult/sui"
block|,
literal|0x7a2
block|}
block|,
block|{
literal|"divt/sui"
block|,
literal|0x7a3
block|}
block|,
block|{
literal|"cvtts/sui"
block|,
literal|0x7ac
block|}
block|,
block|{
literal|"cvttq/svi"
block|,
literal|0x7af
block|}
block|,
block|{
literal|"cvtqs/sui"
block|,
literal|0x7bc
block|}
block|,
block|{
literal|"cvtqt/sui"
block|,
literal|0x7be
block|}
block|,
block|{
literal|"adds/suid"
block|,
literal|0x7c0
block|}
block|,
block|{
literal|"subs/suid"
block|,
literal|0x7c1
block|}
block|,
block|{
literal|"muls/suid"
block|,
literal|0x7c2
block|}
block|,
block|{
literal|"divs/suid"
block|,
literal|0x7c3
block|}
block|,
block|{
literal|"addt/suid"
block|,
literal|0x7e0
block|}
block|,
block|{
literal|"subt/suid"
block|,
literal|0x7e1
block|}
block|,
block|{
literal|"mult/suid"
block|,
literal|0x7e2
block|}
block|,
block|{
literal|"divt/suid"
block|,
literal|0x7e3
block|}
block|,
block|{
literal|"cvtts/suid"
block|,
literal|0x7ec
block|}
block|,
block|{
literal|"cvtqs/suid"
block|,
literal|0x7fc
block|}
block|,
block|{
literal|"cvtqt/suid"
block|,
literal|0x7fe
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|tbl
name|vaxf_tbl
index|[]
init|=
block|{
block|{
literal|"addf/c"
block|,
literal|0x000
block|}
block|,
block|{
literal|"subf/c"
block|,
literal|0x001
block|}
block|,
block|{
literal|"mulf/c"
block|,
literal|0x002
block|}
block|,
block|{
literal|"divf/c"
block|,
literal|0x003
block|}
block|,
block|{
literal|"cvtdg/c"
block|,
literal|0x01e
block|}
block|,
block|{
literal|"addg/c"
block|,
literal|0x020
block|}
block|,
block|{
literal|"subg/c"
block|,
literal|0x021
block|}
block|,
block|{
literal|"mulg/c"
block|,
literal|0x022
block|}
block|,
block|{
literal|"divg/c"
block|,
literal|0x023
block|}
block|,
block|{
literal|"cvtgf/c"
block|,
literal|0x02c
block|}
block|,
block|{
literal|"cvtgd/c"
block|,
literal|0x02d
block|}
block|,
block|{
literal|"cvtgq/c"
block|,
literal|0x02f
block|}
block|,
block|{
literal|"cvtqf/c"
block|,
literal|0x03c
block|}
block|,
block|{
literal|"cvtqg/c"
block|,
literal|0x03e
block|}
block|,
block|{
literal|"addf"
block|,
literal|0x080
block|}
block|,
block|{
literal|"subf"
block|,
literal|0x081
block|}
block|,
block|{
literal|"mulf"
block|,
literal|0x082
block|}
block|,
block|{
literal|"divf"
block|,
literal|0x083
block|}
block|,
block|{
literal|"cvtdg"
block|,
literal|0x09e
block|}
block|,
block|{
literal|"addg"
block|,
literal|0x0a0
block|}
block|,
block|{
literal|"subg"
block|,
literal|0x0a1
block|}
block|,
block|{
literal|"mulg"
block|,
literal|0x0a2
block|}
block|,
block|{
literal|"divg"
block|,
literal|0x0a3
block|}
block|,
block|{
literal|"cmpgeq"
block|,
literal|0x0a5
block|}
block|,
block|{
literal|"cmpglt"
block|,
literal|0x0a6
block|}
block|,
block|{
literal|"cmpgle"
block|,
literal|0x0a7
block|}
block|,
block|{
literal|"cvtgf"
block|,
literal|0x0ac
block|}
block|,
block|{
literal|"cvtgd"
block|,
literal|0x0ad
block|}
block|,
block|{
literal|"cvtgq"
block|,
literal|0x0af
block|}
block|,
block|{
literal|"cvtqf"
block|,
literal|0x0bc
block|}
block|,
block|{
literal|"cvtqg"
block|,
literal|0x0be
block|}
block|,
block|{
literal|"addf/uc"
block|,
literal|0x100
block|}
block|,
block|{
literal|"subf/uc"
block|,
literal|0x101
block|}
block|,
block|{
literal|"mulf/uc"
block|,
literal|0x102
block|}
block|,
block|{
literal|"divf/uc"
block|,
literal|0x103
block|}
block|,
block|{
literal|"cvtdg/uc"
block|,
literal|0x11e
block|}
block|,
block|{
literal|"addg/uc"
block|,
literal|0x120
block|}
block|,
block|{
literal|"subg/uc"
block|,
literal|0x121
block|}
block|,
block|{
literal|"mulg/uc"
block|,
literal|0x122
block|}
block|,
block|{
literal|"divg/uc"
block|,
literal|0x123
block|}
block|,
block|{
literal|"cvtgf/uc"
block|,
literal|0x12c
block|}
block|,
block|{
literal|"cvtgd/uc"
block|,
literal|0x12d
block|}
block|,
block|{
literal|"cvtgq/vc"
block|,
literal|0x12f
block|}
block|,
block|{
literal|"addf/u"
block|,
literal|0x180
block|}
block|,
block|{
literal|"subf/u"
block|,
literal|0x181
block|}
block|,
block|{
literal|"mulf/u"
block|,
literal|0x182
block|}
block|,
block|{
literal|"divf/u"
block|,
literal|0x183
block|}
block|,
block|{
literal|"cvtdg/u"
block|,
literal|0x19e
block|}
block|,
block|{
literal|"addg/u"
block|,
literal|0x1a0
block|}
block|,
block|{
literal|"subg/u"
block|,
literal|0x1a1
block|}
block|,
block|{
literal|"mulg/u"
block|,
literal|0x1a2
block|}
block|,
block|{
literal|"divg/u"
block|,
literal|0x1a3
block|}
block|,
block|{
literal|"cvtgf/u"
block|,
literal|0x1ac
block|}
block|,
block|{
literal|"cvtgd/u"
block|,
literal|0x1ad
block|}
block|,
block|{
literal|"cvtgq/v"
block|,
literal|0x1af
block|}
block|,
block|{
literal|"addf/sc"
block|,
literal|0x400
block|}
block|,
block|{
literal|"subf/sc"
block|,
literal|0x401
block|}
block|,
block|{
literal|"mulf/sc"
block|,
literal|0x402
block|}
block|,
block|{
literal|"divf/sc"
block|,
literal|0x403
block|}
block|,
block|{
literal|"cvtdg/sc"
block|,
literal|0x41e
block|}
block|,
block|{
literal|"addg/sc"
block|,
literal|0x420
block|}
block|,
block|{
literal|"subg/sc"
block|,
literal|0x421
block|}
block|,
block|{
literal|"mulg/sc"
block|,
literal|0x422
block|}
block|,
block|{
literal|"divg/sc"
block|,
literal|0x423
block|}
block|,
block|{
literal|"cvtgf/sc"
block|,
literal|0x42c
block|}
block|,
block|{
literal|"cvtgd/sc"
block|,
literal|0x42d
block|}
block|,
block|{
literal|"cvtgq/sc"
block|,
literal|0x42f
block|}
block|,
block|{
literal|"cvtqf/sc"
block|,
literal|0x43c
block|}
block|,
block|{
literal|"cvtqg/sc"
block|,
literal|0x43e
block|}
block|,
block|{
literal|"addf/s"
block|,
literal|0x480
block|}
block|,
block|{
literal|"subf/s"
block|,
literal|0x481
block|}
block|,
block|{
literal|"mulf/s"
block|,
literal|0x482
block|}
block|,
block|{
literal|"divf/s"
block|,
literal|0x483
block|}
block|,
block|{
literal|"cvtdg/s"
block|,
literal|0x49e
block|}
block|,
block|{
literal|"addg/s"
block|,
literal|0x4a0
block|}
block|,
block|{
literal|"subg/s"
block|,
literal|0x4a1
block|}
block|,
block|{
literal|"mulg/s"
block|,
literal|0x4a2
block|}
block|,
block|{
literal|"divg/s"
block|,
literal|0x4a3
block|}
block|,
block|{
literal|"cmpgeq/s"
block|,
literal|0x4a5
block|}
block|,
block|{
literal|"cmpglt/s"
block|,
literal|0x4a6
block|}
block|,
block|{
literal|"cmpgle/s"
block|,
literal|0x4a7
block|}
block|,
block|{
literal|"cvtgf/s"
block|,
literal|0x4ac
block|}
block|,
block|{
literal|"cvtgd/s"
block|,
literal|0x4ad
block|}
block|,
block|{
literal|"cvtgq/s"
block|,
literal|0x4af
block|}
block|,
block|{
literal|"cvtqf/s"
block|,
literal|0x4bc
block|}
block|,
block|{
literal|"cvtqg/s"
block|,
literal|0x4be
block|}
block|,
block|{
literal|"addf/suc"
block|,
literal|0x500
block|}
block|,
block|{
literal|"subf/suc"
block|,
literal|0x501
block|}
block|,
block|{
literal|"mulf/suc"
block|,
literal|0x502
block|}
block|,
block|{
literal|"divf/suc"
block|,
literal|0x503
block|}
block|,
block|{
literal|"cvtdg/suc"
block|,
literal|0x51e
block|}
block|,
block|{
literal|"addg/suc"
block|,
literal|0x520
block|}
block|,
block|{
literal|"subg/suc"
block|,
literal|0x521
block|}
block|,
block|{
literal|"mulg/suc"
block|,
literal|0x522
block|}
block|,
block|{
literal|"divg/suc"
block|,
literal|0x523
block|}
block|,
block|{
literal|"cvtgf/suc"
block|,
literal|0x52c
block|}
block|,
block|{
literal|"cvtgd/suc"
block|,
literal|0x52d
block|}
block|,
block|{
literal|"cvtgq/svc"
block|,
literal|0x52f
block|}
block|,
block|{
literal|"addf/su"
block|,
literal|0x580
block|}
block|,
block|{
literal|"subf/su"
block|,
literal|0x581
block|}
block|,
block|{
literal|"mulf/su"
block|,
literal|0x582
block|}
block|,
block|{
literal|"divf/su"
block|,
literal|0x583
block|}
block|,
block|{
literal|"cvtdg/su"
block|,
literal|0x59e
block|}
block|,
block|{
literal|"addg/su"
block|,
literal|0x5a0
block|}
block|,
block|{
literal|"subg/su"
block|,
literal|0x5a1
block|}
block|,
block|{
literal|"mulg/su"
block|,
literal|0x5a2
block|}
block|,
block|{
literal|"divg/su"
block|,
literal|0x5a3
block|}
block|,
block|{
literal|"cvtgf/su"
block|,
literal|0x5ac
block|}
block|,
block|{
literal|"cvtgd/su"
block|,
literal|0x5ad
block|}
block|,
block|{
literal|"cvtgq/sv"
block|,
literal|0x5af
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * General purpose registers  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|name_of_register
index|[
literal|32
index|]
init|=
block|{
literal|"v0"
block|,
literal|"t0"
block|,
literal|"t1"
block|,
literal|"t2"
block|,
literal|"t3"
block|,
literal|"t4"
block|,
literal|"t5"
block|,
literal|"t6"
block|,
literal|"t7"
block|,
literal|"s0"
block|,
literal|"s1"
block|,
literal|"s2"
block|,
literal|"s3"
block|,
literal|"s4"
block|,
literal|"s5"
block|,
literal|"s6"
block|,
literal|"a0"
block|,
literal|"a1"
block|,
literal|"a2"
block|,
literal|"a3"
block|,
literal|"a4"
block|,
literal|"a5"
block|,
literal|"t8"
block|,
literal|"t9"
block|,
literal|"t10"
block|,
literal|"t11"
block|,
literal|"ra"
block|,
literal|"pv"
block|,
literal|"at"
block|,
literal|"gp"
block|,
literal|"sp"
block|,
literal|"zero"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|regcount
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* how many regs used in this inst */
end_comment

begin_decl_stmt
specifier|static
name|int
name|regnum
index|[
literal|3
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* which regs used in this inst */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|register_name
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|register_name
parameter_list|(
name|ireg
parameter_list|)
name|int
name|ireg
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|regcount
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regnum
index|[
name|i
index|]
operator|==
name|ireg
condition|)
break|break;
if|if
condition|(
name|i
operator|>=
name|regcount
condition|)
name|regnum
index|[
name|regcount
operator|++
index|]
operator|=
name|ireg
expr_stmt|;
return|return
operator|(
name|name_of_register
index|[
name|ireg
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Disassemble instruction at 'loc'.  'altfmt' specifies an  * (optional) alternate format.  Return address of start of  * next instruction.  */
end_comment

begin_decl_stmt
name|int
name|alpha_print_instruction
name|__P
argument_list|(
operator|(
name|db_addr_t
operator|,
name|alpha_instruction
operator|,
name|boolean_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|db_addr_t
name|db_disasm
parameter_list|(
name|loc
parameter_list|,
name|altfmt
parameter_list|)
name|db_addr_t
name|loc
decl_stmt|;
name|boolean_t
name|altfmt
decl_stmt|;
block|{
name|alpha_instruction
name|inst
decl_stmt|;
name|inst
operator|.
name|bits
operator|=
name|db_get_value
argument_list|(
name|loc
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|loc
operator|+=
name|alpha_print_instruction
argument_list|(
name|loc
argument_list|,
name|inst
argument_list|,
name|altfmt
argument_list|)
expr_stmt|;
return|return
operator|(
name|loc
operator|)
return|;
block|}
end_function

begin_function
name|int
name|alpha_print_instruction
parameter_list|(
name|iadr
parameter_list|,
name|i
parameter_list|,
name|showregs
parameter_list|)
name|db_addr_t
name|iadr
decl_stmt|;
name|alpha_instruction
name|i
decl_stmt|;
name|boolean_t
name|showregs
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|opcode
decl_stmt|;
name|int
name|ireg
decl_stmt|;
name|long
name|signed_immediate
decl_stmt|;
name|boolean_t
name|fstore
decl_stmt|;
name|pal_instruction
name|p
decl_stmt|;
name|regcount
operator|=
literal|0
expr_stmt|;
name|fstore
operator|=
name|FALSE
expr_stmt|;
name|opcode
operator|=
name|op_name
index|[
name|i
operator|.
name|mem_format
operator|.
name|opcode
index|]
expr_stmt|;
comment|/* 	 *	Dispatch directly on the opcode, save code 	 *	duplication sometimes via "harmless gotos". 	 */
switch|switch
condition|(
name|i
operator|.
name|mem_format
operator|.
name|opcode
condition|)
block|{
case|case
name|op_pal
case|:
comment|/* "call_pal" is a long string; just use a space. */
name|db_printf
argument_list|(
literal|"%s %s"
argument_list|,
name|opcode
argument_list|,
name|pal_opname
argument_list|(
name|i
operator|.
name|pal_format
operator|.
name|function
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|op_lda
case|:
case|case
name|op_ldah
case|:
case|case
name|op_ldbu
case|:
case|case
name|op_ldq_u
case|:
case|case
name|op_ldwu
case|:
case|case
name|op_stw
case|:
case|case
name|op_stb
case|:
case|case
name|op_stq_u
case|:
comment|/* 		 * These loadstores are here to make compiling the 		 * switch a bit easier.  Could embellish the output 		 * someday, too. 		 */
goto|goto
name|loadstore
goto|;
break|break;
case|case
name|op_arit
case|:
comment|/* 		 * For this and the following three groups we 		 * just need different opcode strings 		 */
name|opcode
operator|=
name|arit_name
argument_list|(
name|i
operator|.
name|operate_lit_format
operator|.
name|function
argument_list|)
expr_stmt|;
goto|goto
name|operate
goto|;
break|break;
case|case
name|op_logical
case|:
name|opcode
operator|=
name|logical_name
argument_list|(
name|i
operator|.
name|operate_lit_format
operator|.
name|function
argument_list|)
expr_stmt|;
goto|goto
name|operate
goto|;
break|break;
case|case
name|op_bit
case|:
name|opcode
operator|=
name|bitop_name
argument_list|(
name|i
operator|.
name|operate_lit_format
operator|.
name|function
argument_list|)
expr_stmt|;
goto|goto
name|operate
goto|;
break|break;
case|case
name|op_mul
case|:
name|opcode
operator|=
name|mul_name
argument_list|(
name|i
operator|.
name|operate_lit_format
operator|.
name|function
argument_list|)
expr_stmt|;
name|operate
label|:
comment|/* 		 * Nice and uniform, just check for literals 		 */
name|db_printf
argument_list|(
literal|"%s\t%s,"
argument_list|,
name|opcode
argument_list|,
name|register_name
argument_list|(
name|i
operator|.
name|operate_lit_format
operator|.
name|rs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|operate_lit_format
operator|.
name|one
condition|)
name|db_printf
argument_list|(
literal|"#0x%x"
argument_list|,
name|i
operator|.
name|operate_lit_format
operator|.
name|literal
argument_list|)
expr_stmt|;
else|else
name|db_printf
argument_list|(
literal|"%s"
argument_list|,
name|register_name
argument_list|(
name|i
operator|.
name|operate_reg_format
operator|.
name|rt
argument_list|)
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|",%s"
argument_list|,
name|register_name
argument_list|(
name|i
operator|.
name|operate_lit_format
operator|.
name|rd
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|op_vax_float
case|:
comment|/* 		 * The three floating point groups are even simpler 		 */
name|opcode
operator|=
name|vaxf_name
argument_list|(
name|i
operator|.
name|float_format
operator|.
name|function
argument_list|)
expr_stmt|;
goto|goto
name|foperate
goto|;
break|break;
case|case
name|op_ieee_float
case|:
name|opcode
operator|=
name|ieeef_name
argument_list|(
name|i
operator|.
name|float_format
operator|.
name|function
argument_list|)
expr_stmt|;
goto|goto
name|foperate
goto|;
break|break;
case|case
name|op_any_float
case|:
name|opcode
operator|=
name|anyf_name
argument_list|(
name|i
operator|.
name|float_format
operator|.
name|function
argument_list|)
expr_stmt|;
name|foperate
label|:
name|db_printf
argument_list|(
literal|"%s\tf%d,f%d,f%d"
argument_list|,
name|opcode
argument_list|,
name|i
operator|.
name|float_format
operator|.
name|fs
argument_list|,
name|i
operator|.
name|float_format
operator|.
name|ft
argument_list|,
name|i
operator|.
name|float_format
operator|.
name|fd
argument_list|)
expr_stmt|;
break|break;
case|case
name|op_special
case|:
comment|/* 		 * Miscellaneous. 		 */
block|{
specifier|register
name|unsigned
name|int
name|code
decl_stmt|;
name|code
operator|=
operator|(
name|i
operator|.
name|mem_format
operator|.
name|displacement
operator|)
operator|&
literal|0xffff
expr_stmt|;
name|opcode
operator|=
name|special_name
argument_list|(
name|code
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|op_fetch
case|:
case|case
name|op_fetch_m
case|:
name|db_printf
argument_list|(
literal|"%s\t0(%s)"
argument_list|,
name|opcode
argument_list|,
name|register_name
argument_list|(
name|i
operator|.
name|mem_format
operator|.
name|rs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|op_rpcc
case|:
case|case
name|op_rc
case|:
case|case
name|op_rs
case|:
name|db_printf
argument_list|(
literal|"%s\t%s"
argument_list|,
name|opcode
argument_list|,
name|register_name
argument_list|(
name|i
operator|.
name|mem_format
operator|.
name|rd
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|op_draint
case|:
case|case
name|op_mb
case|:
default|default:
name|db_printf
argument_list|(
literal|"%s"
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
name|op_j
case|:
comment|/* 		 * Jump instructions really are of two sorts, 		 * depending on the use of the hint info. 		 */
name|opcode
operator|=
name|jump_name
argument_list|(
name|i
operator|.
name|jump_format
operator|.
name|action
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|i
operator|.
name|jump_format
operator|.
name|action
condition|)
block|{
case|case
name|op_jmp
case|:
case|case
name|op_jsr
case|:
name|db_printf
argument_list|(
literal|"%s\t%s,(%s),"
argument_list|,
name|opcode
argument_list|,
name|register_name
argument_list|(
name|i
operator|.
name|jump_format
operator|.
name|rd
argument_list|)
argument_list|,
name|register_name
argument_list|(
name|i
operator|.
name|jump_format
operator|.
name|rs
argument_list|)
argument_list|)
expr_stmt|;
name|signed_immediate
operator|=
name|i
operator|.
name|jump_format
operator|.
name|hint
expr_stmt|;
goto|goto
name|branch_displacement
goto|;
break|break;
case|case
name|op_ret
case|:
case|case
name|op_jcr
case|:
name|db_printf
argument_list|(
literal|"%s\t%s,(%s)"
argument_list|,
name|opcode
argument_list|,
name|register_name
argument_list|(
name|i
operator|.
name|jump_format
operator|.
name|rd
argument_list|)
argument_list|,
name|register_name
argument_list|(
name|i
operator|.
name|jump_format
operator|.
name|rs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|op_intmisc
case|:
comment|/* 		 * These are just in "operate" format. 		 */
name|opcode
operator|=
name|intmisc_name
argument_list|(
name|i
operator|.
name|operate_lit_format
operator|.
name|function
argument_list|)
expr_stmt|;
goto|goto
name|operate
goto|;
break|break;
comment|/* HW instructions, possibly chip-specific XXXX */
case|case
name|op_pal19
case|:
comment|/* "hw_mfpr" */
case|case
name|op_pal1d
case|:
comment|/* "hw_mtpr" */
name|p
operator|.
name|bits
operator|=
name|i
operator|.
name|bits
expr_stmt|;
name|db_printf
argument_list|(
literal|"\t%s%s\t%s, %d"
argument_list|,
name|opcode
argument_list|,
name|mXpr_name
index|[
name|p
operator|.
name|mXpr_format
operator|.
name|regset
index|]
argument_list|,
name|register_name
argument_list|(
name|p
operator|.
name|mXpr_format
operator|.
name|rd
argument_list|)
argument_list|,
name|p
operator|.
name|mXpr_format
operator|.
name|index
argument_list|)
expr_stmt|;
break|break;
case|case
name|op_pal1b
case|:
comment|/* "hw_ld" */
case|case
name|op_pal1f
case|:
comment|/* "hw_st" */
name|p
operator|.
name|bits
operator|=
name|i
operator|.
name|bits
expr_stmt|;
name|db_printf
argument_list|(
literal|"\t%s%c%s\t%s,"
argument_list|,
name|opcode
argument_list|,
operator|(
name|p
operator|.
name|mem_format
operator|.
name|qw
operator|)
condition|?
literal|'q'
else|:
literal|'l'
argument_list|,
name|hwlds_name
index|[
name|p
operator|.
name|mem_format
operator|.
name|qualif
index|]
argument_list|,
name|register_name
argument_list|(
name|p
operator|.
name|mem_format
operator|.
name|rd
argument_list|)
argument_list|)
expr_stmt|;
name|signed_immediate
operator|=
operator|(
name|long
operator|)
name|p
operator|.
name|mem_format
operator|.
name|displacement
expr_stmt|;
goto|goto
name|loadstore_address
goto|;
case|case
name|op_pal1e
case|:
comment|/* "hw_rei" */
name|db_printf
argument_list|(
literal|"\t%s"
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
break|break;
case|case
name|op_ldf
case|:
case|case
name|op_ldg
case|:
case|case
name|op_lds
case|:
case|case
name|op_ldt
case|:
case|case
name|op_stf
case|:
case|case
name|op_stg
case|:
case|case
name|op_sts
case|:
case|case
name|op_stt
case|:
name|fstore
operator|=
name|TRUE
expr_stmt|;
comment|/* fall through */
case|case
name|op_ldl
case|:
case|case
name|op_ldq
case|:
case|case
name|op_ldl_l
case|:
case|case
name|op_ldq_l
case|:
case|case
name|op_stl
case|:
case|case
name|op_stq
case|:
case|case
name|op_stl_c
case|:
case|case
name|op_stq_c
case|:
comment|/* 		 * Memory operations, including floats 		 */
name|loadstore
label|:
if|if
condition|(
name|fstore
condition|)
name|db_printf
argument_list|(
literal|"%s\tf%d,"
argument_list|,
name|opcode
argument_list|,
name|i
operator|.
name|mem_format
operator|.
name|rd
argument_list|)
expr_stmt|;
else|else
name|db_printf
argument_list|(
literal|"%s\t%s,"
argument_list|,
name|opcode
argument_list|,
name|register_name
argument_list|(
name|i
operator|.
name|mem_format
operator|.
name|rd
argument_list|)
argument_list|)
expr_stmt|;
name|signed_immediate
operator|=
operator|(
name|long
operator|)
name|i
operator|.
name|mem_format
operator|.
name|displacement
expr_stmt|;
name|loadstore_address
label|:
name|db_printf
argument_list|(
literal|"%+#lx(%s)"
argument_list|,
name|signed_immediate
argument_list|,
name|register_name
argument_list|(
name|i
operator|.
name|mem_format
operator|.
name|rs
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * For convenience, do the address computation 		 */
if|if
condition|(
name|showregs
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|mem_format
operator|.
name|opcode
operator|==
name|op_ldah
condition|)
name|signed_immediate
operator|<<=
literal|16
expr_stmt|;
name|db_printf
argument_list|(
literal|"<0x%lx>"
argument_list|,
name|signed_immediate
operator|+
name|db_register_value
argument_list|(
name|DDB_REGS
argument_list|,
name|i
operator|.
name|mem_format
operator|.
name|rs
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|op_br
case|:
case|case
name|op_fbeq
case|:
case|case
name|op_fblt
case|:
case|case
name|op_fble
case|:
case|case
name|op_bsr
case|:
case|case
name|op_fbne
case|:
case|case
name|op_fbge
case|:
case|case
name|op_fbgt
case|:
case|case
name|op_blbc
case|:
case|case
name|op_beq
case|:
case|case
name|op_blt
case|:
case|case
name|op_ble
case|:
case|case
name|op_blbs
case|:
case|case
name|op_bne
case|:
case|case
name|op_bge
case|:
case|case
name|op_bgt
case|:
comment|/* 		 * We want to know where we are branching to 		 */
name|signed_immediate
operator|=
operator|(
name|long
operator|)
name|i
operator|.
name|branch_format
operator|.
name|displacement
expr_stmt|;
name|db_printf
argument_list|(
literal|"%s\t%s,"
argument_list|,
name|opcode
argument_list|,
name|register_name
argument_list|(
name|i
operator|.
name|branch_format
operator|.
name|rd
argument_list|)
argument_list|)
expr_stmt|;
name|branch_displacement
label|:
name|db_printsym
argument_list|(
name|iadr
operator|+
sizeof|sizeof
argument_list|(
name|alpha_instruction
argument_list|)
operator|+
operator|(
name|signed_immediate
operator|<<
literal|2
operator|)
argument_list|,
name|DB_STGY_PROC
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* 		 * Shouldn't happen 		 */
name|db_printf
argument_list|(
literal|"? 0x%x ?"
argument_list|,
name|i
operator|.
name|bits
argument_list|)
expr_stmt|;
block|}
comment|/* 	 *	Print out the registers used in this instruction 	 */
if|if
condition|(
name|showregs
operator|&&
name|regcount
operator|>
literal|0
condition|)
block|{
name|db_printf
argument_list|(
literal|"\t<"
argument_list|)
expr_stmt|;
for|for
control|(
name|ireg
operator|=
literal|0
init|;
name|ireg
operator|<
name|regcount
condition|;
name|ireg
operator|++
control|)
block|{
if|if
condition|(
name|ireg
operator|!=
literal|0
condition|)
name|db_printf
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"%s=0x%lx"
argument_list|,
name|name_of_register
index|[
name|regnum
index|[
name|ireg
index|]
index|]
argument_list|,
name|db_register_value
argument_list|(
name|DDB_REGS
argument_list|,
name|regnum
index|[
name|ireg
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|db_printf
argument_list|(
literal|">"
argument_list|)
expr_stmt|;
block|}
name|db_printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
operator|(
sizeof|sizeof
argument_list|(
name|alpha_instruction
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

