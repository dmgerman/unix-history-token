begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $NetBSD: prom.c,v 1.22 1998/02/27 04:03:00 thorpej Exp $ */
end_comment

begin_comment
comment|/*   * Copyright (c) 1992, 1994, 1995, 1996 Carnegie Mellon University  * All Rights Reserved.  *   * Permission to use, copy, modify and distribute this software and its  * documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *   * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"  * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR  * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *   * Carnegie Mellon requests users of this software to return to  *   *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *   * any improvements or extensions that they make and grant Carnegie Mellon  * the rights to redistribute these changes.  */
end_comment

begin_include
include|#
directive|include
file|"opt_simos.h"
end_include

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_comment
comment|/* RCS ID& Copyright macro defns */
end_comment

begin_comment
comment|/* __KERNEL_RCSID(0, "$NetBSD: prom.c,v 1.22 1998/02/27 04:03:00 thorpej Exp $"); */
end_comment

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_prot.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<machine/rpb.h>
end_include

begin_include
include|#
directive|include
file|<machine/prom.h>
end_include

begin_include
include|#
directive|include
file|<machine/vmparam.h>
end_include

begin_include
include|#
directive|include
file|<machine/cons.h>
end_include

begin_comment
comment|/* XXX this is to fake out the console routines, while booting. */
end_comment

begin_decl_stmt
name|struct
name|consdev
name|promcons
init|=
block|{
name|NULL
block|,
name|NULL
block|,
name|promcngetc
block|,
name|promcncheckc
block|,
name|promcnputc
block|,
name|NULL
block|,
name|makedev
argument_list|(
literal|97
argument_list|,
literal|0
argument_list|)
block|,
name|CN_NORMAL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rpb
modifier|*
name|hwrpb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|alpha_console
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|prom_vec
name|prom_dispatch_v
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|prom_mapped
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Is PROM still mapped? */
end_comment

begin_decl_stmt
name|pt_entry_t
name|rom_pte
decl_stmt|,
name|saved_pte
index|[
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX */
end_comment

begin_decl_stmt
specifier|static
name|pt_entry_t
modifier|*
name|rom_lev1map
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|pcb
modifier|*
name|curpcb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|pt_entry_t
modifier|*
name|Lev1map
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|prom_cache_sync
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|pt_entry_t
modifier|*
name|rom_lev1map
parameter_list|()
block|{
name|struct
name|alpha_pcb
modifier|*
name|apcb
decl_stmt|;
comment|/* 	 * We may be called before the first context switch 	 * after alpha_init(), in which case we just need 	 * to use the kernel Lev1map. 	 */
if|if
condition|(
name|curpcb
operator|==
literal|0
condition|)
return|return
operator|(
name|Lev1map
operator|)
return|;
comment|/* 	 * Find the level 1 map that we're currently running on. 	 */
name|apcb
operator|=
operator|(
expr|struct
name|alpha_pcb
operator|*
operator|)
name|ALPHA_PHYS_TO_K0SEG
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|curpcb
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|pt_entry_t
operator|*
operator|)
name|ALPHA_PHYS_TO_K0SEG
argument_list|(
name|alpha_ptob
argument_list|(
name|apcb
operator|->
name|apcb_ptbr
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|init_prom_interface
parameter_list|(
name|rpb
parameter_list|)
name|struct
name|rpb
modifier|*
name|rpb
decl_stmt|;
block|{
name|struct
name|crb
modifier|*
name|c
decl_stmt|;
name|c
operator|=
operator|(
expr|struct
name|crb
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|rpb
operator|+
name|rpb
operator|->
name|rpb_crb_off
operator|)
expr_stmt|;
name|prom_dispatch_v
operator|.
name|routine_arg
operator|=
name|c
operator|->
name|crb_v_dispatch
expr_stmt|;
name|prom_dispatch_v
operator|.
name|routine
operator|=
name|c
operator|->
name|crb_v_dispatch
operator|->
name|entry_va
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|extern
name|struct
name|consdev
modifier|*
name|cn_tab
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|init_bootstrap_console
parameter_list|()
block|{
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|init_prom_interface
argument_list|(
name|hwrpb
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIMOS
name|alpha_console
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|prom_getenv
argument_list|(
name|PROM_E_TTY_DEV
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|alpha_console
operator|=
name|buf
index|[
literal|0
index|]
operator|-
literal|'0'
expr_stmt|;
endif|#
directive|endif
comment|/* XXX fake out the console routines, for now */
name|cn_tab
operator|=
operator|&
name|promcons
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|enter_prom
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|leave_prom
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|_PMAP_MAY_USE_PROM_CONSOLE
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|prom_cache_sync
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|enter_prom
parameter_list|()
block|{
name|int
name|s
init|=
name|splhigh
argument_list|()
decl_stmt|;
name|pt_entry_t
modifier|*
name|lev1map
decl_stmt|;
if|if
condition|(
operator|!
name|prom_mapped
condition|)
block|{
ifdef|#
directive|ifdef
name|SIMOS
comment|/* 		 * SimOS console uses floating point. 		 */
if|if
condition|(
name|curproc
operator|!=
name|fpcurproc
condition|)
block|{
name|alpha_pal_wrfen
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|fpcurproc
condition|)
name|savefpstate
argument_list|(
operator|&
name|fpcurproc
operator|->
name|p_addr
operator|->
name|u_pcb
operator|.
name|pcb_fp
argument_list|)
expr_stmt|;
name|fpcurproc
operator|=
name|curproc
expr_stmt|;
name|restorefpstate
argument_list|(
operator|&
name|fpcurproc
operator|->
name|p_addr
operator|->
name|u_pcb
operator|.
name|pcb_fp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|pmap_uses_prom_console
argument_list|()
condition|)
name|panic
argument_list|(
literal|"enter_prom"
argument_list|)
expr_stmt|;
name|lev1map
operator|=
name|rom_lev1map
argument_list|()
expr_stmt|;
comment|/* XXX */
name|saved_pte
index|[
literal|0
index|]
operator|=
name|lev1map
index|[
literal|0
index|]
expr_stmt|;
comment|/* XXX */
name|lev1map
index|[
literal|0
index|]
operator|=
name|rom_pte
expr_stmt|;
comment|/* XXX */
name|prom_cache_sync
argument_list|()
expr_stmt|;
comment|/* XXX */
block|}
return|return
name|s
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|leave_prom
name|__P
argument_list|(
operator|(
name|s
operator|)
argument_list|)
name|int
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|pt_entry_t
modifier|*
name|lev1map
decl_stmt|;
if|if
condition|(
operator|!
name|prom_mapped
condition|)
block|{
if|if
condition|(
operator|!
name|pmap_uses_prom_console
argument_list|()
condition|)
name|panic
argument_list|(
literal|"leave_prom"
argument_list|)
expr_stmt|;
name|lev1map
operator|=
name|rom_lev1map
argument_list|()
expr_stmt|;
comment|/* XXX */
name|lev1map
index|[
literal|0
index|]
operator|=
name|saved_pte
index|[
literal|0
index|]
expr_stmt|;
comment|/* XXX */
name|prom_cache_sync
argument_list|()
expr_stmt|;
comment|/* XXX */
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
specifier|static
name|void
name|prom_cache_sync
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
block|{
name|ALPHA_TBIA
argument_list|()
expr_stmt|;
name|alpha_pal_imb
argument_list|()
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/*  * promcnputc:  *  * Remap char before passing off to prom.  *  * Prom only takes 32 bit addresses. Copy char somewhere prom can  * find it. This routine will stop working after pmap_rid_of_console   * is called in alpha_init. This is due to the hard coded address  * of the console area.  */
end_comment

begin_function
name|void
name|promcnputc
parameter_list|(
name|dev
parameter_list|,
name|c
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|c
decl_stmt|;
block|{
name|prom_return_t
name|ret
decl_stmt|;
name|unsigned
name|char
modifier|*
name|to
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
literal|0x20000000
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|enter_prom
argument_list|()
expr_stmt|;
comment|/* splhigh() and map prom */
operator|*
name|to
operator|=
name|c
expr_stmt|;
do|do
block|{
name|ret
operator|.
name|bits
operator|=
name|prom_putstr
argument_list|(
name|alpha_console
argument_list|,
name|to
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|ret
operator|.
name|u
operator|.
name|retval
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
do|;
name|leave_prom
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* unmap prom and splx(s) */
block|}
end_function

begin_comment
comment|/*  * promcngetc:  *  * Wait for the prom to get a real char and pass it back.  */
end_comment

begin_function
name|int
name|promcngetc
parameter_list|(
name|dev
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
block|{
name|prom_return_t
name|ret
decl_stmt|;
name|int
name|s
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|s
operator|=
name|enter_prom
argument_list|()
expr_stmt|;
name|ret
operator|.
name|bits
operator|=
name|prom_getc
argument_list|(
name|alpha_console
argument_list|)
expr_stmt|;
name|leave_prom
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|.
name|u
operator|.
name|status
operator|==
literal|0
operator|||
name|ret
operator|.
name|u
operator|.
name|status
operator|==
literal|1
condition|)
return|return
operator|(
name|ret
operator|.
name|u
operator|.
name|retval
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * promcncheckc  *  * If a char is ready, return it, otherwise return -1.  */
end_comment

begin_function
name|int
name|promcncheckc
parameter_list|(
name|dev
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
block|{
name|prom_return_t
name|ret
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|enter_prom
argument_list|()
expr_stmt|;
name|ret
operator|.
name|bits
operator|=
name|prom_getc
argument_list|(
name|alpha_console
argument_list|)
expr_stmt|;
name|leave_prom
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|.
name|u
operator|.
name|status
operator|==
literal|0
operator|||
name|ret
operator|.
name|u
operator|.
name|status
operator|==
literal|1
condition|)
return|return
operator|(
name|ret
operator|.
name|u
operator|.
name|retval
operator|)
return|;
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|prom_getenv
parameter_list|(
name|id
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|)
name|int
name|id
decl_stmt|,
name|len
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
block|{
name|unsigned
name|char
modifier|*
name|to
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
literal|0x20000000
decl_stmt|;
name|prom_return_t
name|ret
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|enter_prom
argument_list|()
expr_stmt|;
name|ret
operator|.
name|bits
operator|=
name|prom_getenv_disp
argument_list|(
name|id
argument_list|,
name|to
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|to
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|leave_prom
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|.
name|u
operator|.
name|status
operator|&
literal|0x4
condition|)
name|ret
operator|.
name|u
operator|.
name|retval
operator|=
literal|0
expr_stmt|;
name|buf
index|[
name|ret
operator|.
name|u
operator|.
name|retval
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|ret
operator|.
name|bits
operator|)
return|;
block|}
end_function

begin_function
name|void
name|prom_halt
parameter_list|(
name|halt
parameter_list|)
name|int
name|halt
decl_stmt|;
block|{
name|struct
name|pcs
modifier|*
name|p
decl_stmt|;
comment|/* 	 * Turn off interrupts, for sanity. 	 */
operator|(
name|void
operator|)
name|splhigh
argument_list|()
expr_stmt|;
comment|/* 	 * Set "boot request" part of the CPU state depending on what 	 * we want to happen when we halt. 	 */
name|p
operator|=
operator|(
expr|struct
name|pcs
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|hwrpb
operator|+
name|hwrpb
operator|->
name|rpb_pcs_off
operator|+
operator|(
name|hwrpb
operator|->
name|rpb_primary_cpu_id
operator|*
name|hwrpb
operator|->
name|rpb_pcs_size
operator|)
operator|)
expr_stmt|;
name|p
operator|->
name|pcs_flags
operator|&=
operator|~
operator|(
name|PCS_RC
operator||
name|PCS_HALT_REQ
operator|)
expr_stmt|;
if|if
condition|(
name|halt
condition|)
name|p
operator|->
name|pcs_flags
operator||=
name|PCS_HALT_STAY_HALTED
expr_stmt|;
else|else
name|p
operator|->
name|pcs_flags
operator||=
name|PCS_HALT_WARM_BOOT
expr_stmt|;
comment|/* 	 * Halt the machine. 	 */
name|alpha_pal_halt
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|u_int64_t
name|hwrpb_checksum
parameter_list|()
block|{
name|u_int64_t
modifier|*
name|p
decl_stmt|,
name|sum
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|p
operator|=
operator|(
name|u_int64_t
operator|*
operator|)
name|hwrpb
operator|,
name|sum
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|offsetof
argument_list|(
expr|struct
name|rpb
argument_list|,
name|rpb_checksum
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|u_int64_t
argument_list|)
operator|)
condition|;
name|i
operator|++
operator|,
name|p
operator|++
control|)
name|sum
operator|+=
operator|*
name|p
expr_stmt|;
return|return
operator|(
name|sum
operator|)
return|;
block|}
end_function

begin_function
name|void
name|hwrpb_restart_setup
parameter_list|()
block|{
name|struct
name|pcs
modifier|*
name|p
decl_stmt|;
comment|/* Clear bootstrap-in-progress flag since we're done bootstrapping */
name|p
operator|=
operator|(
expr|struct
name|pcs
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|hwrpb
operator|+
name|hwrpb
operator|->
name|rpb_pcs_off
operator|)
expr_stmt|;
name|p
operator|->
name|pcs_flags
operator|&=
operator|~
name|PCS_BIP
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|proc0
operator|.
name|p_addr
operator|->
name|u_pcb
operator|.
name|pcb_hw
argument_list|,
name|p
operator|->
name|pcs_hwpcb
argument_list|,
sizeof|sizeof
name|proc0
operator|.
name|p_addr
operator|->
name|u_pcb
operator|.
name|pcb_hw
argument_list|)
expr_stmt|;
name|hwrpb
operator|->
name|rpb_vptb
operator|=
name|VPTBASE
expr_stmt|;
comment|/* when 'c'ontinuing from console halt, do a dump */
name|hwrpb
operator|->
name|rpb_rest_term
operator|=
operator|(
name|u_int64_t
operator|)
operator|&
name|XentRestart
expr_stmt|;
name|hwrpb
operator|->
name|rpb_rest_term_val
operator|=
literal|0x1
expr_stmt|;
if|#
directive|if
literal|0
comment|/* don't know what this is really used by, so don't mess with it. */
block|hwrpb->rpb_restart = (u_int64_t)&XentRestart; 	hwrpb->rpb_restart_val = 0x2;
endif|#
directive|endif
name|hwrpb
operator|->
name|rpb_checksum
operator|=
name|hwrpb_checksum
argument_list|()
expr_stmt|;
name|p
operator|->
name|pcs_flags
operator||=
operator|(
name|PCS_RC
operator||
name|PCS_CV
operator|)
expr_stmt|;
block|}
end_function

begin_function
name|u_int64_t
name|console_restart
parameter_list|(
name|ra
parameter_list|,
name|ai
parameter_list|,
name|pv
parameter_list|)
name|u_int64_t
name|ra
decl_stmt|,
name|ai
decl_stmt|,
name|pv
decl_stmt|;
block|{
name|struct
name|pcs
modifier|*
name|p
decl_stmt|;
comment|/* Clear restart-capable flag, since we can no longer restart. */
name|p
operator|=
operator|(
expr|struct
name|pcs
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|hwrpb
operator|+
name|hwrpb
operator|->
name|rpb_pcs_off
operator|)
expr_stmt|;
name|p
operator|->
name|pcs_flags
operator|&=
operator|~
name|PCS_RC
expr_stmt|;
name|panic
argument_list|(
literal|"user requested console halt"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

end_unit

