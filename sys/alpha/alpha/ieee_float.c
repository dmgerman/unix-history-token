begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1998 Doug Rabson  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * An implementation of IEEE 754 floating point arithmetic supporting  * multiply, divide, addition, subtraction and conversion to and from  * integer.  Probably not the fastest floating point code in the world  * but it should be pretty accurate.  *  * A special thanks to John Polstra for pointing out some problems  * with an earlier version of this code and for educating me as to the  * correct use of sticky bits.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|TEST
end_ifdef

begin_include
include|#
directive|include
file|"../include/fpu.h"
end_include

begin_include
include|#
directive|include
file|"ieee_float.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysent.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<machine/fpu.h>
end_include

begin_include
include|#
directive|include
file|<alpha/alpha/ieee_float.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * The number of fraction bits in a T format float.  */
end_comment

begin_define
define|#
directive|define
name|T_FRACBITS
value|52
end_define

begin_comment
comment|/*  * The number of fraction bits in a S format float.  */
end_comment

begin_define
define|#
directive|define
name|S_FRACBITS
value|23
end_define

begin_comment
comment|/*  * Mask the fraction part of a float to contain only those bits which  * should be in single precision number.  */
end_comment

begin_define
define|#
directive|define
name|S_FRACMASK
value|((1ULL<< 52) - (1ULL<< 29))
end_define

begin_comment
comment|/*  * The number of extra zero bits we shift into the fraction part  * to gain accuracy.  Two guard bits and one sticky bit are required  * to ensure accurate rounding.  */
end_comment

begin_define
define|#
directive|define
name|FRAC_SHIFT
value|3
end_define

begin_comment
comment|/*  * Values for 1.0 and 2.0 fractions (including the extra FRAC_SHIFT  * bits).  */
end_comment

begin_define
define|#
directive|define
name|ONE
value|(1ULL<< (T_FRACBITS + FRAC_SHIFT))
end_define

begin_define
define|#
directive|define
name|TWO
value|(ONE + ONE)
end_define

begin_comment
comment|/*  * The maximum and minimum values for S and T format exponents.  */
end_comment

begin_define
define|#
directive|define
name|T_MAXEXP
value|0x3ff
end_define

begin_define
define|#
directive|define
name|T_MINEXP
value|-0x3fe
end_define

begin_define
define|#
directive|define
name|S_MAXEXP
value|0x7f
end_define

begin_define
define|#
directive|define
name|S_MINEXP
value|-0x7e
end_define

begin_comment
comment|/*  * Exponent values in registers are biased by adding this value.  */
end_comment

begin_define
define|#
directive|define
name|BIAS_EXP
value|0x3ff
end_define

begin_comment
comment|/*  * Exponent value for INF and NaN.  */
end_comment

begin_define
define|#
directive|define
name|NAN_EXP
value|0x7ff
end_define

begin_comment
comment|/*  * If this bit is set in the fraction part of a NaN, then the number  * is a quiet NaN, i.e. no traps are generated.  */
end_comment

begin_define
define|#
directive|define
name|QNAN_BIT
value|(1ULL<< 51)
end_define

begin_comment
comment|/*  * Return true if the number is any kind of NaN.  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|isNaN
parameter_list|(
name|fp_register_t
name|f
parameter_list|)
block|{
return|return
name|f
operator|.
name|t
operator|.
name|exponent
operator|==
name|NAN_EXP
operator|&&
name|f
operator|.
name|t
operator|.
name|fraction
operator|!=
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Return true if the number is a quiet NaN.  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|isQNaN
parameter_list|(
name|fp_register_t
name|f
parameter_list|)
block|{
return|return
name|f
operator|.
name|t
operator|.
name|exponent
operator|==
name|NAN_EXP
operator|&&
operator|(
name|f
operator|.
name|t
operator|.
name|fraction
operator|&
name|QNAN_BIT
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return true if the number is a signalling NaN.  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|isSNaN
parameter_list|(
name|fp_register_t
name|f
parameter_list|)
block|{
return|return
name|isNaN
argument_list|(
name|f
argument_list|)
operator|&&
operator|!
name|isQNaN
argument_list|(
name|f
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return true if the number is +/- INF.  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|isINF
parameter_list|(
name|fp_register_t
name|f
parameter_list|)
block|{
return|return
name|f
operator|.
name|t
operator|.
name|exponent
operator|==
name|NAN_EXP
operator|&&
name|f
operator|.
name|t
operator|.
name|fraction
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Return true if the number is +/- 0.  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|isZERO
parameter_list|(
name|fp_register_t
name|f
parameter_list|)
block|{
return|return
name|f
operator|.
name|t
operator|.
name|exponent
operator|==
literal|0
operator|&&
name|f
operator|.
name|t
operator|.
name|fraction
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Return true if the number is denormalised.  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|isDENORM
parameter_list|(
name|fp_register_t
name|f
parameter_list|)
block|{
return|return
name|f
operator|.
name|t
operator|.
name|exponent
operator|==
literal|0
operator|&&
name|f
operator|.
name|t
operator|.
name|fraction
operator|!=
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Extract the exponent part of a float register.  If the exponent is  * zero, the number may be denormalised (if the fraction is nonzero).  * If so, return the minimum exponent for the source datatype.  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|getexp
parameter_list|(
name|fp_register_t
name|f
parameter_list|,
name|int
name|src
parameter_list|)
block|{
name|int
name|minexp
index|[]
init|=
block|{
name|S_MINEXP
block|,
literal|0
block|,
name|T_MINEXP
block|,
literal|0
block|}
decl_stmt|;
if|if
condition|(
name|f
operator|.
name|t
operator|.
name|exponent
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|f
operator|.
name|t
operator|.
name|fraction
condition|)
return|return
name|minexp
index|[
name|src
index|]
return|;
else|else
return|return
literal|0
return|;
block|}
return|return
name|f
operator|.
name|t
operator|.
name|exponent
operator|-
name|BIAS_EXP
return|;
block|}
end_function

begin_comment
comment|/*  * Extract the fraction part of a float register, shift it up a bit  * to give extra accuracy and add in the implicit 1 bit.  Must be  * careful to handle denormalised numbers and zero correctly.  */
end_comment

begin_function
specifier|static
name|__inline
name|u_int64_t
name|getfrac
parameter_list|(
name|fp_register_t
name|f
parameter_list|)
block|{
if|if
condition|(
name|f
operator|.
name|t
operator|.
name|exponent
operator|==
literal|0
condition|)
return|return
name|f
operator|.
name|t
operator|.
name|fraction
operator|<<
name|FRAC_SHIFT
return|;
else|else
return|return
operator|(
name|f
operator|.
name|t
operator|.
name|fraction
operator|<<
name|FRAC_SHIFT
operator|)
operator||
name|ONE
return|;
block|}
end_function

begin_comment
comment|/*  * Make a float (in register format) from a sign, exponent and  * fraction, normalising and rounding as necessary.  * Return the float and set *status if any traps are generated.  */
end_comment

begin_function
specifier|static
name|fp_register_t
name|makefloat
parameter_list|(
name|int
name|sign
parameter_list|,
name|int
name|exp
parameter_list|,
name|u_int64_t
name|frac
parameter_list|,
name|int
name|src
parameter_list|,
name|int
name|rnd
parameter_list|,
name|u_int64_t
name|control
parameter_list|,
name|u_int64_t
modifier|*
name|status
parameter_list|)
block|{
name|fp_register_t
name|f
decl_stmt|;
name|int
name|minexp
init|=
literal|0
decl_stmt|,
name|maxexp
init|=
literal|0
decl_stmt|,
name|alpha
init|=
literal|0
decl_stmt|;
name|u_int64_t
name|epsilon
init|=
literal|0
decl_stmt|,
name|max
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|frac
operator|==
literal|0
condition|)
block|{
name|f
operator|.
name|t
operator|.
name|sign
operator|=
name|sign
expr_stmt|;
name|f
operator|.
name|t
operator|.
name|exponent
operator|=
literal|0
expr_stmt|;
name|f
operator|.
name|t
operator|.
name|fraction
operator|=
literal|0
expr_stmt|;
return|return
name|f
return|;
block|}
if|if
condition|(
name|frac
operator|>=
name|TWO
condition|)
block|{
comment|/* 		 * Fraction is>= 2.0. 		 * Shift the fraction down, preserving the 'sticky' 		 * bit. 		 */
while|while
condition|(
name|frac
operator|>=
name|TWO
condition|)
block|{
name|frac
operator|=
operator|(
name|frac
operator|>>
literal|1
operator|)
operator||
operator|(
name|frac
operator|&
literal|1
operator|)
expr_stmt|;
name|exp
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|frac
operator|<
name|ONE
condition|)
block|{
comment|/* 		 * Fraction is< 1.0. Shift it up. 		 */
while|while
condition|(
name|frac
operator|<
name|ONE
condition|)
block|{
name|frac
operator|=
operator|(
name|frac
operator|<<
literal|1
operator|)
operator||
operator|(
name|frac
operator|&
literal|1
operator|)
expr_stmt|;
name|exp
operator|--
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|src
condition|)
block|{
case|case
name|S_FORMAT
case|:
name|minexp
operator|=
name|S_MINEXP
expr_stmt|;
name|maxexp
operator|=
name|S_MAXEXP
expr_stmt|;
name|alpha
operator|=
literal|0xc0
expr_stmt|;
name|epsilon
operator|=
operator|(
literal|1ULL
operator|<<
operator|(
name|T_FRACBITS
operator|-
name|S_FRACBITS
operator|+
name|FRAC_SHIFT
operator|)
operator|)
expr_stmt|;
name|max
operator|=
name|TWO
operator|-
name|epsilon
expr_stmt|;
break|break;
case|case
name|T_FORMAT
case|:
name|minexp
operator|=
name|T_MINEXP
expr_stmt|;
name|maxexp
operator|=
name|T_MAXEXP
expr_stmt|;
name|alpha
operator|=
literal|0x600
expr_stmt|;
name|epsilon
operator|=
operator|(
literal|1ULL
operator|<<
name|FRAC_SHIFT
operator|)
expr_stmt|;
name|max
operator|=
name|TWO
operator|-
name|epsilon
expr_stmt|;
break|break;
block|}
comment|/* 	 * Handle underflow before rounding so that denormalised 	 * numbers are rounded correctly. 	 */
if|if
condition|(
name|exp
operator|<
name|minexp
condition|)
block|{
operator|*
name|status
operator||=
name|FPCR_INE
expr_stmt|;
if|if
condition|(
name|control
operator|&
name|IEEE_TRAP_ENABLE_UNF
condition|)
block|{
operator|*
name|status
operator||=
name|FPCR_UNF
expr_stmt|;
name|exp
operator|+=
name|alpha
expr_stmt|;
block|}
else|else
block|{
comment|/* denormalise */
while|while
condition|(
name|exp
operator|<
name|minexp
condition|)
block|{
name|exp
operator|++
expr_stmt|;
name|frac
operator|=
operator|(
name|frac
operator|>>
literal|1
operator|)
operator||
operator|(
name|frac
operator|&
literal|1
operator|)
expr_stmt|;
block|}
name|exp
operator|=
name|minexp
operator|-
literal|1
expr_stmt|;
block|}
block|}
comment|/* 	 * Round the fraction according to the rounding mode. 	 */
if|if
condition|(
name|frac
operator|&
operator|(
name|epsilon
operator|-
literal|1
operator|)
condition|)
block|{
name|u_int64_t
name|fraclo
decl_stmt|,
name|frachi
decl_stmt|;
name|u_int64_t
name|difflo
decl_stmt|,
name|diffhi
decl_stmt|;
name|fraclo
operator|=
name|frac
operator|&
name|max
expr_stmt|;
name|frachi
operator|=
name|fraclo
operator|+
name|epsilon
expr_stmt|;
switch|switch
condition|(
name|rnd
condition|)
block|{
case|case
name|ROUND_CHOP
case|:
name|frac
operator|=
name|fraclo
expr_stmt|;
break|break;
case|case
name|ROUND_MINUS_INF
case|:
if|if
condition|(
name|f
operator|.
name|t
operator|.
name|sign
condition|)
name|frac
operator|=
name|frachi
expr_stmt|;
else|else
name|frac
operator|=
name|fraclo
expr_stmt|;
break|break;
case|case
name|ROUND_NORMAL
case|:
name|difflo
operator|=
name|frac
operator|-
name|fraclo
expr_stmt|;
name|diffhi
operator|=
name|frachi
operator|-
name|frac
expr_stmt|;
if|if
condition|(
name|difflo
operator|<
name|diffhi
condition|)
name|frac
operator|=
name|fraclo
expr_stmt|;
elseif|else
if|if
condition|(
name|diffhi
operator|<
name|difflo
condition|)
name|frac
operator|=
name|frachi
expr_stmt|;
elseif|else
comment|/* round to even */
if|if
condition|(
name|fraclo
operator|&
name|epsilon
condition|)
name|frac
operator|=
name|frachi
expr_stmt|;
else|else
name|frac
operator|=
name|fraclo
expr_stmt|;
break|break;
case|case
name|ROUND_PLUS_INF
case|:
if|if
condition|(
name|f
operator|.
name|t
operator|.
name|sign
condition|)
name|frac
operator|=
name|fraclo
expr_stmt|;
else|else
name|frac
operator|=
name|frachi
expr_stmt|;
break|break;
block|}
comment|/* 		 * Rounding up may take us to TWO if 		 * fraclo == (TWO - epsilon).  Also If fraclo has been 		 * denormalised to (ONE - epsilon) then there is a 		 * possibility that we will round to ONE exactly. 		 */
if|if
condition|(
name|frac
operator|>=
name|TWO
condition|)
block|{
name|frac
operator|=
operator|(
name|frac
operator|>>
literal|1
operator|)
operator|&
operator|~
operator|(
name|epsilon
operator|-
literal|1
operator|)
expr_stmt|;
name|exp
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|exp
operator|==
name|minexp
operator|-
literal|1
operator|&&
name|frac
operator|==
name|ONE
condition|)
block|{
comment|/* Renormalise to ONE * 2^minexp */
name|exp
operator|=
name|minexp
expr_stmt|;
block|}
operator|*
name|status
operator||=
name|FPCR_INE
expr_stmt|;
block|}
comment|/* 	 * Check for overflow and round to the correct INF as needed. 	 */
if|if
condition|(
name|exp
operator|>
name|maxexp
condition|)
block|{
operator|*
name|status
operator||=
name|FPCR_OVF
operator||
name|FPCR_INE
expr_stmt|;
if|if
condition|(
name|control
operator|&
name|IEEE_TRAP_ENABLE_OVF
condition|)
block|{
name|exp
operator|-=
name|alpha
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|rnd
condition|)
block|{
case|case
name|ROUND_CHOP
case|:
name|exp
operator|=
name|maxexp
expr_stmt|;
name|frac
operator|=
name|max
expr_stmt|;
break|break;
case|case
name|ROUND_MINUS_INF
case|:
if|if
condition|(
name|sign
condition|)
block|{
name|exp
operator|=
name|maxexp
operator|+
literal|1
expr_stmt|;
comment|/* INF */
name|frac
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|exp
operator|=
name|maxexp
expr_stmt|;
name|frac
operator|=
name|max
expr_stmt|;
block|}
break|break;
case|case
name|ROUND_NORMAL
case|:
name|exp
operator|=
name|maxexp
operator|+
literal|1
expr_stmt|;
comment|/* INF */
name|frac
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ROUND_PLUS_INF
case|:
if|if
condition|(
name|sign
condition|)
block|{
name|exp
operator|=
name|maxexp
expr_stmt|;
name|frac
operator|=
name|max
expr_stmt|;
block|}
else|else
block|{
name|exp
operator|=
name|maxexp
operator|+
literal|1
expr_stmt|;
comment|/* INF */
name|frac
operator|=
literal|0
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
name|f
operator|.
name|t
operator|.
name|sign
operator|=
name|sign
expr_stmt|;
if|if
condition|(
name|exp
operator|>
name|maxexp
condition|)
comment|/* NaN, INF */
name|f
operator|.
name|t
operator|.
name|exponent
operator|=
name|NAN_EXP
expr_stmt|;
elseif|else
if|if
condition|(
name|exp
operator|<
name|minexp
condition|)
comment|/* denorm, zero */
name|f
operator|.
name|t
operator|.
name|exponent
operator|=
literal|0
expr_stmt|;
else|else
name|f
operator|.
name|t
operator|.
name|exponent
operator|=
name|exp
operator|+
name|BIAS_EXP
expr_stmt|;
name|f
operator|.
name|t
operator|.
name|fraction
operator|=
operator|(
name|frac
operator|&
operator|~
name|ONE
operator|)
operator|>>
name|FRAC_SHIFT
expr_stmt|;
return|return
name|f
return|;
block|}
end_function

begin_comment
comment|/*  * Return the canonical quiet NaN in register format.  */
end_comment

begin_function
specifier|static
name|fp_register_t
name|makeQNaN
parameter_list|(
name|void
parameter_list|)
block|{
name|fp_register_t
name|f
decl_stmt|;
name|f
operator|.
name|t
operator|.
name|sign
operator|=
literal|0
expr_stmt|;
name|f
operator|.
name|t
operator|.
name|exponent
operator|=
name|NAN_EXP
expr_stmt|;
name|f
operator|.
name|t
operator|.
name|fraction
operator|=
name|QNAN_BIT
expr_stmt|;
return|return
name|f
return|;
block|}
end_function

begin_comment
comment|/*  * Return +/- INF.  */
end_comment

begin_function
specifier|static
name|fp_register_t
name|makeINF
parameter_list|(
name|int
name|sign
parameter_list|)
block|{
name|fp_register_t
name|f
decl_stmt|;
name|f
operator|.
name|t
operator|.
name|sign
operator|=
name|sign
expr_stmt|;
name|f
operator|.
name|t
operator|.
name|exponent
operator|=
name|NAN_EXP
expr_stmt|;
name|f
operator|.
name|t
operator|.
name|fraction
operator|=
literal|0
expr_stmt|;
return|return
name|f
return|;
block|}
end_function

begin_comment
comment|/*  * Return +/- 0.  */
end_comment

begin_function
specifier|static
name|fp_register_t
name|makeZERO
parameter_list|(
name|int
name|sign
parameter_list|)
block|{
name|fp_register_t
name|f
decl_stmt|;
name|f
operator|.
name|t
operator|.
name|sign
operator|=
name|sign
expr_stmt|;
name|f
operator|.
name|t
operator|.
name|exponent
operator|=
literal|0
expr_stmt|;
name|f
operator|.
name|t
operator|.
name|fraction
operator|=
literal|0
expr_stmt|;
return|return
name|f
return|;
block|}
end_function

begin_function
name|fp_register_t
name|ieee_add
parameter_list|(
name|fp_register_t
name|fa
parameter_list|,
name|fp_register_t
name|fb
parameter_list|,
name|int
name|src
parameter_list|,
name|int
name|rnd
parameter_list|,
name|u_int64_t
name|control
parameter_list|,
name|u_int64_t
modifier|*
name|status
parameter_list|)
block|{
name|int
name|shift
decl_stmt|;
name|int
name|expa
decl_stmt|,
name|expb
decl_stmt|,
name|exp
decl_stmt|;
name|u_int64_t
name|fraca
decl_stmt|,
name|fracb
decl_stmt|,
name|frac
decl_stmt|;
name|int
name|sign
decl_stmt|,
name|sticky
decl_stmt|;
comment|/* First handle NaNs */
if|if
condition|(
name|isNaN
argument_list|(
name|fa
argument_list|)
operator|||
name|isNaN
argument_list|(
name|fb
argument_list|)
condition|)
block|{
name|fp_register_t
name|result
decl_stmt|;
comment|/* Instructions Descriptions (I) section 4.7.10.4 */
if|if
condition|(
name|isQNaN
argument_list|(
name|fb
argument_list|)
condition|)
name|result
operator|=
name|fb
expr_stmt|;
elseif|else
if|if
condition|(
name|isSNaN
argument_list|(
name|fb
argument_list|)
condition|)
block|{
name|result
operator|=
name|fb
expr_stmt|;
name|result
operator|.
name|t
operator|.
name|fraction
operator||=
name|QNAN_BIT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isQNaN
argument_list|(
name|fa
argument_list|)
condition|)
name|result
operator|=
name|fa
expr_stmt|;
elseif|else
if|if
condition|(
name|isSNaN
argument_list|(
name|fa
argument_list|)
condition|)
block|{
name|result
operator|=
name|fa
expr_stmt|;
name|result
operator|.
name|t
operator|.
name|fraction
operator||=
name|QNAN_BIT
expr_stmt|;
block|}
comment|/* If either operand is a signalling NaN, trap. */
if|if
condition|(
name|isSNaN
argument_list|(
name|fa
argument_list|)
operator|||
name|isSNaN
argument_list|(
name|fb
argument_list|)
condition|)
operator|*
name|status
operator||=
name|FPCR_INV
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/* Handle +/- INF */
if|if
condition|(
name|isINF
argument_list|(
name|fa
argument_list|)
condition|)
if|if
condition|(
name|isINF
argument_list|(
name|fb
argument_list|)
condition|)
if|if
condition|(
name|fa
operator|.
name|t
operator|.
name|sign
operator|!=
name|fb
operator|.
name|t
operator|.
name|sign
condition|)
block|{
comment|/* If adding -INF to +INF, generate a trap. */
operator|*
name|status
operator||=
name|FPCR_INV
expr_stmt|;
return|return
name|makeQNaN
argument_list|()
return|;
block|}
else|else
return|return
name|fa
return|;
else|else
return|return
name|fa
return|;
elseif|else
if|if
condition|(
name|isINF
argument_list|(
name|fb
argument_list|)
condition|)
return|return
name|fb
return|;
comment|/* 	 * Unpack the registers. 	 */
name|expa
operator|=
name|getexp
argument_list|(
name|fa
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|expb
operator|=
name|getexp
argument_list|(
name|fb
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|fraca
operator|=
name|getfrac
argument_list|(
name|fa
argument_list|)
expr_stmt|;
name|fracb
operator|=
name|getfrac
argument_list|(
name|fb
argument_list|)
expr_stmt|;
name|shift
operator|=
name|expa
operator|-
name|expb
expr_stmt|;
if|if
condition|(
name|shift
operator|<
literal|0
condition|)
block|{
name|shift
operator|=
operator|-
name|shift
expr_stmt|;
name|exp
operator|=
name|expb
expr_stmt|;
name|sticky
operator|=
operator|(
name|fraca
operator|&
operator|(
operator|(
literal|1ULL
operator|<<
name|shift
operator|)
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
expr_stmt|;
if|if
condition|(
name|shift
operator|>=
literal|64
condition|)
name|fraca
operator|=
name|sticky
expr_stmt|;
else|else
name|fraca
operator|=
operator|(
name|fraca
operator|>>
name|shift
operator|)
operator||
name|sticky
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|shift
operator|>
literal|0
condition|)
block|{
name|exp
operator|=
name|expa
expr_stmt|;
name|sticky
operator|=
operator|(
name|fracb
operator|&
operator|(
operator|(
literal|1ULL
operator|<<
name|shift
operator|)
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
expr_stmt|;
if|if
condition|(
name|shift
operator|>=
literal|64
condition|)
name|fracb
operator|=
name|sticky
expr_stmt|;
else|else
name|fracb
operator|=
operator|(
name|fracb
operator|>>
name|shift
operator|)
operator||
name|sticky
expr_stmt|;
block|}
else|else
name|exp
operator|=
name|expa
expr_stmt|;
if|if
condition|(
name|fa
operator|.
name|t
operator|.
name|sign
condition|)
name|fraca
operator|=
operator|-
name|fraca
expr_stmt|;
if|if
condition|(
name|fb
operator|.
name|t
operator|.
name|sign
condition|)
name|fracb
operator|=
operator|-
name|fracb
expr_stmt|;
name|frac
operator|=
name|fraca
operator|+
name|fracb
expr_stmt|;
if|if
condition|(
name|frac
operator|>>
literal|63
condition|)
block|{
name|sign
operator|=
literal|1
expr_stmt|;
name|frac
operator|=
operator|-
name|frac
expr_stmt|;
block|}
else|else
name|sign
operator|=
literal|0
expr_stmt|;
comment|/* -0 + -0 = -0 */
if|if
condition|(
name|fa
operator|.
name|t
operator|.
name|exponent
operator|==
literal|0
operator|&&
name|fa
operator|.
name|t
operator|.
name|fraction
operator|==
literal|0
operator|&&
name|fb
operator|.
name|t
operator|.
name|exponent
operator|==
literal|0
operator|&&
name|fb
operator|.
name|t
operator|.
name|fraction
operator|==
literal|0
condition|)
name|sign
operator|=
name|fa
operator|.
name|t
operator|.
name|sign
operator|&&
name|fb
operator|.
name|t
operator|.
name|sign
expr_stmt|;
return|return
name|makefloat
argument_list|(
name|sign
argument_list|,
name|exp
argument_list|,
name|frac
argument_list|,
name|src
argument_list|,
name|rnd
argument_list|,
name|control
argument_list|,
name|status
argument_list|)
return|;
block|}
end_function

begin_function
name|fp_register_t
name|ieee_sub
parameter_list|(
name|fp_register_t
name|fa
parameter_list|,
name|fp_register_t
name|fb
parameter_list|,
name|int
name|src
parameter_list|,
name|int
name|rnd
parameter_list|,
name|u_int64_t
name|control
parameter_list|,
name|u_int64_t
modifier|*
name|status
parameter_list|)
block|{
name|fb
operator|.
name|t
operator|.
name|sign
operator|=
operator|!
name|fb
operator|.
name|t
operator|.
name|sign
expr_stmt|;
return|return
name|ieee_add
argument_list|(
name|fa
argument_list|,
name|fb
argument_list|,
name|src
argument_list|,
name|rnd
argument_list|,
name|control
argument_list|,
name|status
argument_list|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
block|{
name|u_int64_t
name|lo
decl_stmt|;
name|u_int64_t
name|hi
decl_stmt|;
block|}
name|u_int128_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|SRL128
parameter_list|(
name|x
parameter_list|,
name|b
parameter_list|)
define|\
value|do {						\ 	x.lo>>= b;				\ 	x.lo |= x.hi<< (64 - b);		\ 	x.hi>>= b;				\ } while (0)
end_define

begin_define
define|#
directive|define
name|SLL128
parameter_list|(
name|x
parameter_list|,
name|b
parameter_list|)
define|\
value|do {						\ 	if (b>= 64) {				\ 		x.hi = x.lo<< (b - 64);	\ 		x.lo = 0;			\ 	} else {				\ 		x.hi<<= b;			\ 		x.hi |= x.lo>> (64 - b);	\ 		x.lo<<= b;			\ 	}					\ } while (0)
end_define

begin_define
define|#
directive|define
name|SUB128
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
define|\
value|do {						\ 	int borrow = a.lo< b.lo;		\ 	a.lo = a.lo - b.lo;			\ 	a.hi = a.hi - b.hi - borrow;		\ } while (0)
end_define

begin_define
define|#
directive|define
name|LESS128
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(a.hi< b.hi || (a.hi == b.hi&& a.lo< b.lo))
end_define

begin_function
name|fp_register_t
name|ieee_mul
parameter_list|(
name|fp_register_t
name|fa
parameter_list|,
name|fp_register_t
name|fb
parameter_list|,
name|int
name|src
parameter_list|,
name|int
name|rnd
parameter_list|,
name|u_int64_t
name|control
parameter_list|,
name|u_int64_t
modifier|*
name|status
parameter_list|)
block|{
name|int
name|expa
decl_stmt|,
name|expb
decl_stmt|,
name|exp
decl_stmt|;
name|u_int64_t
name|fraca
decl_stmt|,
name|fracb
decl_stmt|,
name|tmp
decl_stmt|;
name|u_int128_t
name|frac
decl_stmt|;
name|int
name|sign
decl_stmt|;
comment|/* First handle NaNs */
if|if
condition|(
name|isNaN
argument_list|(
name|fa
argument_list|)
operator|||
name|isNaN
argument_list|(
name|fb
argument_list|)
condition|)
block|{
name|fp_register_t
name|result
decl_stmt|;
comment|/* Instructions Descriptions (I) section 4.7.10.4 */
if|if
condition|(
name|isQNaN
argument_list|(
name|fb
argument_list|)
condition|)
name|result
operator|=
name|fb
expr_stmt|;
elseif|else
if|if
condition|(
name|isSNaN
argument_list|(
name|fb
argument_list|)
condition|)
block|{
name|result
operator|=
name|fb
expr_stmt|;
name|result
operator|.
name|t
operator|.
name|fraction
operator||=
name|QNAN_BIT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isQNaN
argument_list|(
name|fa
argument_list|)
condition|)
name|result
operator|=
name|fa
expr_stmt|;
elseif|else
if|if
condition|(
name|isSNaN
argument_list|(
name|fa
argument_list|)
condition|)
block|{
name|result
operator|=
name|fa
expr_stmt|;
name|result
operator|.
name|t
operator|.
name|fraction
operator||=
name|QNAN_BIT
expr_stmt|;
block|}
comment|/* If either operand is a signalling NaN, trap. */
if|if
condition|(
name|isSNaN
argument_list|(
name|fa
argument_list|)
operator|||
name|isSNaN
argument_list|(
name|fb
argument_list|)
condition|)
operator|*
name|status
operator||=
name|FPCR_INV
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/* Handle INF and 0 */
if|if
condition|(
operator|(
name|isINF
argument_list|(
name|fa
argument_list|)
operator|&&
name|isZERO
argument_list|(
name|fb
argument_list|)
operator|)
operator|||
operator|(
name|isZERO
argument_list|(
name|fa
argument_list|)
operator|&&
name|isINF
argument_list|(
name|fb
argument_list|)
operator|)
condition|)
block|{
comment|/* INF * 0 = NaN */
operator|*
name|status
operator||=
name|FPCR_INV
expr_stmt|;
return|return
name|makeQNaN
argument_list|()
return|;
block|}
elseif|else
comment|/* If either is INF or zero, get the sign right */
if|if
condition|(
name|isINF
argument_list|(
name|fa
argument_list|)
operator|||
name|isINF
argument_list|(
name|fb
argument_list|)
condition|)
return|return
name|makeINF
argument_list|(
name|fa
operator|.
name|t
operator|.
name|sign
operator|^
name|fb
operator|.
name|t
operator|.
name|sign
argument_list|)
return|;
elseif|else
if|if
condition|(
name|isZERO
argument_list|(
name|fa
argument_list|)
operator|||
name|isZERO
argument_list|(
name|fb
argument_list|)
condition|)
return|return
name|makeZERO
argument_list|(
name|fa
operator|.
name|t
operator|.
name|sign
operator|^
name|fb
operator|.
name|t
operator|.
name|sign
argument_list|)
return|;
comment|/* 	 * Unpack the registers. 	 */
name|expa
operator|=
name|getexp
argument_list|(
name|fa
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|expb
operator|=
name|getexp
argument_list|(
name|fb
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|fraca
operator|=
name|getfrac
argument_list|(
name|fa
argument_list|)
expr_stmt|;
name|fracb
operator|=
name|getfrac
argument_list|(
name|fb
argument_list|)
expr_stmt|;
name|sign
operator|=
name|fa
operator|.
name|t
operator|.
name|sign
operator|^
name|fb
operator|.
name|t
operator|.
name|sign
expr_stmt|;
define|#
directive|define
name|LO32
parameter_list|(
name|x
parameter_list|)
value|((x)& ((1ULL<< 32) - 1))
define|#
directive|define
name|HI32
parameter_list|(
name|x
parameter_list|)
value|((x)>> 32)
comment|/* 	 * Calculate the 128bit result of multiplying fraca and fracb. 	 */
name|frac
operator|.
name|lo
operator|=
name|fraca
operator|*
name|fracb
expr_stmt|;
ifdef|#
directive|ifdef
name|__alpha__
comment|/* 	 * The alpha has a handy instruction to find the high word. 	 */
asm|__asm__
specifier|__volatile__
asm|("umulh %1,%2,%0" 			      : "=r"(tmp) 			      : "r"(fraca), "r"(fracb));
name|frac
operator|.
name|hi
operator|=
name|tmp
expr_stmt|;
else|#
directive|else
comment|/* 	 * Do the multiply longhand otherwise. 	 */
name|frac
operator|.
name|hi
operator|=
name|HI32
argument_list|(
name|LO32
argument_list|(
name|fraca
argument_list|)
operator|*
name|HI32
argument_list|(
name|fracb
argument_list|)
operator|+
name|HI32
argument_list|(
name|fraca
argument_list|)
operator|*
name|LO32
argument_list|(
name|fracb
argument_list|)
operator|+
name|HI32
argument_list|(
name|LO32
argument_list|(
name|fraca
argument_list|)
operator|*
name|LO32
argument_list|(
name|fracb
argument_list|)
argument_list|)
argument_list|)
operator|+
name|HI32
argument_list|(
name|fraca
argument_list|)
operator|*
name|HI32
argument_list|(
name|fracb
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|exp
operator|=
name|expa
operator|+
name|expb
operator|-
operator|(
name|T_FRACBITS
operator|+
name|FRAC_SHIFT
operator|)
expr_stmt|;
while|while
condition|(
name|frac
operator|.
name|hi
operator|>
literal|0
condition|)
block|{
name|int
name|sticky
decl_stmt|;
name|exp
operator|++
expr_stmt|;
name|sticky
operator|=
name|frac
operator|.
name|lo
operator|&
literal|1
expr_stmt|;
name|SRL128
argument_list|(
name|frac
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|frac
operator|.
name|lo
operator||=
name|sticky
expr_stmt|;
block|}
return|return
name|makefloat
argument_list|(
name|sign
argument_list|,
name|exp
argument_list|,
name|frac
operator|.
name|lo
argument_list|,
name|src
argument_list|,
name|rnd
argument_list|,
name|control
argument_list|,
name|status
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int128_t
name|divide_128
parameter_list|(
name|u_int128_t
name|a
parameter_list|,
name|u_int128_t
name|b
parameter_list|)
block|{
name|u_int128_t
name|result
decl_stmt|;
name|u_int64_t
name|bit
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Make a couple of assumptions on the numbers passed in.  The 	 * value in 'a' will have bits set in the upper 64 bits only 	 * and the number in 'b' will have zeros in the upper 64 bits. 	 * Also, 'b' will not be zero. 	 */
ifdef|#
directive|ifdef
name|TEST
if|if
condition|(
name|a
operator|.
name|hi
operator|==
literal|0
operator|||
name|b
operator|.
name|hi
operator|!=
literal|0
operator|||
name|b
operator|.
name|lo
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Find out how many bits of zeros are at the beginning of the divisor. 	 */
name|i
operator|=
literal|64
expr_stmt|;
name|bit
operator|=
literal|1ULL
operator|<<
literal|63
expr_stmt|;
while|while
condition|(
name|i
operator|<
literal|127
condition|)
block|{
if|if
condition|(
name|b
operator|.
name|lo
operator|&
name|bit
condition|)
break|break;
name|i
operator|++
expr_stmt|;
name|bit
operator|>>=
literal|1
expr_stmt|;
block|}
comment|/* 	 * Find out how much to shift the divisor so that its msb 	 * matches the msb of the dividend. 	 */
name|bit
operator|=
literal|1ULL
operator|<<
literal|63
expr_stmt|;
while|while
condition|(
name|i
condition|)
block|{
if|if
condition|(
name|a
operator|.
name|hi
operator|&
name|bit
condition|)
break|break;
name|i
operator|--
expr_stmt|;
name|bit
operator|>>=
literal|1
expr_stmt|;
block|}
name|result
operator|.
name|lo
operator|=
literal|0
expr_stmt|;
name|result
operator|.
name|hi
operator|=
literal|0
expr_stmt|;
name|SLL128
argument_list|(
name|b
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* 	 * Calculate the result in two parts to avoid keeping a 128bit 	 * value for the result bit. 	 */
if|if
condition|(
name|i
operator|>=
literal|64
condition|)
block|{
name|bit
operator|=
literal|1ULL
operator|<<
operator|(
name|i
operator|-
literal|64
operator|)
expr_stmt|;
while|while
condition|(
name|bit
condition|)
block|{
if|if
condition|(
operator|!
name|LESS128
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
condition|)
block|{
name|result
operator|.
name|hi
operator||=
name|bit
expr_stmt|;
name|SUB128
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|a
operator|.
name|lo
operator|&&
operator|!
name|a
operator|.
name|hi
condition|)
return|return
name|result
return|;
block|}
name|bit
operator|>>=
literal|1
expr_stmt|;
name|SRL128
argument_list|(
name|b
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
literal|63
expr_stmt|;
block|}
name|bit
operator|=
literal|1ULL
operator|<<
name|i
expr_stmt|;
while|while
condition|(
name|bit
condition|)
block|{
if|if
condition|(
operator|!
name|LESS128
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
condition|)
block|{
name|result
operator|.
name|lo
operator||=
name|bit
expr_stmt|;
name|SUB128
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|a
operator|.
name|lo
operator|&&
operator|!
name|a
operator|.
name|hi
condition|)
return|return
name|result
return|;
block|}
name|bit
operator|>>=
literal|1
expr_stmt|;
name|SRL128
argument_list|(
name|b
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
name|fp_register_t
name|ieee_div
parameter_list|(
name|fp_register_t
name|fa
parameter_list|,
name|fp_register_t
name|fb
parameter_list|,
name|int
name|src
parameter_list|,
name|int
name|rnd
parameter_list|,
name|u_int64_t
name|control
parameter_list|,
name|u_int64_t
modifier|*
name|status
parameter_list|)
block|{
name|int
name|expa
decl_stmt|,
name|expb
decl_stmt|,
name|exp
decl_stmt|;
name|u_int128_t
name|fraca
decl_stmt|,
name|fracb
decl_stmt|,
name|frac
decl_stmt|;
name|int
name|sign
decl_stmt|;
comment|/* First handle NaNs, INFs and ZEROs */
if|if
condition|(
name|isNaN
argument_list|(
name|fa
argument_list|)
operator|||
name|isNaN
argument_list|(
name|fb
argument_list|)
condition|)
block|{
name|fp_register_t
name|result
decl_stmt|;
comment|/* Instructions Descriptions (I) section 4.7.10.4 */
if|if
condition|(
name|isQNaN
argument_list|(
name|fb
argument_list|)
condition|)
name|result
operator|=
name|fb
expr_stmt|;
elseif|else
if|if
condition|(
name|isSNaN
argument_list|(
name|fb
argument_list|)
condition|)
block|{
name|result
operator|=
name|fb
expr_stmt|;
name|result
operator|.
name|t
operator|.
name|fraction
operator||=
name|QNAN_BIT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isQNaN
argument_list|(
name|fa
argument_list|)
condition|)
name|result
operator|=
name|fa
expr_stmt|;
elseif|else
if|if
condition|(
name|isSNaN
argument_list|(
name|fa
argument_list|)
condition|)
block|{
name|result
operator|=
name|fa
expr_stmt|;
name|result
operator|.
name|t
operator|.
name|fraction
operator||=
name|QNAN_BIT
expr_stmt|;
block|}
comment|/* If either operand is a signalling NaN, trap. */
if|if
condition|(
name|isSNaN
argument_list|(
name|fa
argument_list|)
operator|||
name|isSNaN
argument_list|(
name|fb
argument_list|)
condition|)
operator|*
name|status
operator||=
name|FPCR_INV
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/* Handle INF and 0 */
if|if
condition|(
name|isINF
argument_list|(
name|fa
argument_list|)
operator|&&
name|isINF
argument_list|(
name|fb
argument_list|)
condition|)
block|{
operator|*
name|status
operator||=
name|FPCR_INV
expr_stmt|;
return|return
name|makeQNaN
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|isZERO
argument_list|(
name|fb
argument_list|)
condition|)
if|if
condition|(
name|isZERO
argument_list|(
name|fa
argument_list|)
condition|)
block|{
operator|*
name|status
operator||=
name|FPCR_INV
expr_stmt|;
return|return
name|makeQNaN
argument_list|()
return|;
block|}
else|else
block|{
operator|*
name|status
operator||=
name|FPCR_DZE
expr_stmt|;
return|return
name|makeINF
argument_list|(
name|fa
operator|.
name|t
operator|.
name|sign
operator|^
name|fb
operator|.
name|t
operator|.
name|sign
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|isZERO
argument_list|(
name|fa
argument_list|)
condition|)
return|return
name|makeZERO
argument_list|(
name|fa
operator|.
name|t
operator|.
name|sign
operator|^
name|fb
operator|.
name|t
operator|.
name|sign
argument_list|)
return|;
comment|/* 	 * Unpack the registers. 	 */
name|expa
operator|=
name|getexp
argument_list|(
name|fa
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|expb
operator|=
name|getexp
argument_list|(
name|fb
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|fraca
operator|.
name|hi
operator|=
name|getfrac
argument_list|(
name|fa
argument_list|)
expr_stmt|;
name|fraca
operator|.
name|lo
operator|=
literal|0
expr_stmt|;
name|fracb
operator|.
name|lo
operator|=
name|getfrac
argument_list|(
name|fb
argument_list|)
expr_stmt|;
name|fracb
operator|.
name|hi
operator|=
literal|0
expr_stmt|;
name|sign
operator|=
name|fa
operator|.
name|t
operator|.
name|sign
operator|^
name|fb
operator|.
name|t
operator|.
name|sign
expr_stmt|;
name|frac
operator|=
name|divide_128
argument_list|(
name|fraca
argument_list|,
name|fracb
argument_list|)
expr_stmt|;
name|exp
operator|=
name|expa
operator|-
name|expb
operator|-
operator|(
literal|64
operator|-
name|T_FRACBITS
operator|-
name|FRAC_SHIFT
operator|)
expr_stmt|;
while|while
condition|(
name|frac
operator|.
name|hi
operator|>
literal|0
condition|)
block|{
name|int
name|sticky
decl_stmt|;
name|exp
operator|++
expr_stmt|;
name|sticky
operator|=
name|frac
operator|.
name|lo
operator|&
literal|1
expr_stmt|;
name|SRL128
argument_list|(
name|frac
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|frac
operator|.
name|lo
operator||=
name|sticky
expr_stmt|;
block|}
name|frac
operator|.
name|lo
operator||=
literal|1
expr_stmt|;
return|return
name|makefloat
argument_list|(
name|sign
argument_list|,
name|exp
argument_list|,
name|frac
operator|.
name|lo
argument_list|,
name|src
argument_list|,
name|rnd
argument_list|,
name|control
argument_list|,
name|status
argument_list|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|IEEE_TRUE
value|0x4000000000000000ULL
end_define

begin_define
define|#
directive|define
name|IEEE_FALSE
value|0
end_define

begin_function
name|fp_register_t
name|ieee_cmpun
parameter_list|(
name|fp_register_t
name|fa
parameter_list|,
name|fp_register_t
name|fb
parameter_list|,
name|u_int64_t
modifier|*
name|status
parameter_list|)
block|{
name|fp_register_t
name|result
decl_stmt|;
if|if
condition|(
name|isNaN
argument_list|(
name|fa
argument_list|)
operator|||
name|isNaN
argument_list|(
name|fb
argument_list|)
condition|)
block|{
if|if
condition|(
name|isSNaN
argument_list|(
name|fa
argument_list|)
operator|||
name|isSNaN
argument_list|(
name|fb
argument_list|)
condition|)
operator|*
name|status
operator||=
name|FPCR_INV
expr_stmt|;
name|result
operator|.
name|q
operator|=
name|IEEE_TRUE
expr_stmt|;
block|}
else|else
name|result
operator|.
name|q
operator|=
name|IEEE_FALSE
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|fp_register_t
name|ieee_cmpeq
parameter_list|(
name|fp_register_t
name|fa
parameter_list|,
name|fp_register_t
name|fb
parameter_list|,
name|u_int64_t
modifier|*
name|status
parameter_list|)
block|{
name|fp_register_t
name|result
decl_stmt|;
if|if
condition|(
name|isNaN
argument_list|(
name|fa
argument_list|)
operator|||
name|isNaN
argument_list|(
name|fb
argument_list|)
condition|)
block|{
if|if
condition|(
name|isSNaN
argument_list|(
name|fa
argument_list|)
operator|||
name|isSNaN
argument_list|(
name|fb
argument_list|)
condition|)
operator|*
name|status
operator||=
name|FPCR_INV
expr_stmt|;
name|result
operator|.
name|q
operator|=
name|IEEE_FALSE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|isZERO
argument_list|(
name|fa
argument_list|)
operator|&&
name|isZERO
argument_list|(
name|fb
argument_list|)
condition|)
name|result
operator|.
name|q
operator|=
name|IEEE_TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|fa
operator|.
name|q
operator|==
name|fb
operator|.
name|q
condition|)
name|result
operator|.
name|q
operator|=
name|IEEE_TRUE
expr_stmt|;
else|else
name|result
operator|.
name|q
operator|=
name|IEEE_FALSE
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
name|fp_register_t
name|ieee_cmplt
parameter_list|(
name|fp_register_t
name|fa
parameter_list|,
name|fp_register_t
name|fb
parameter_list|,
name|u_int64_t
modifier|*
name|status
parameter_list|)
block|{
name|fp_register_t
name|result
decl_stmt|;
if|if
condition|(
name|isNaN
argument_list|(
name|fa
argument_list|)
operator|||
name|isNaN
argument_list|(
name|fb
argument_list|)
condition|)
block|{
if|if
condition|(
name|isSNaN
argument_list|(
name|fa
argument_list|)
operator|||
name|isSNaN
argument_list|(
name|fb
argument_list|)
condition|)
operator|*
name|status
operator||=
name|FPCR_INV
expr_stmt|;
name|result
operator|.
name|q
operator|=
name|IEEE_FALSE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|isZERO
argument_list|(
name|fa
argument_list|)
operator|&&
name|isZERO
argument_list|(
name|fb
argument_list|)
condition|)
name|result
operator|.
name|q
operator|=
name|IEEE_FALSE
expr_stmt|;
elseif|else
if|if
condition|(
name|fa
operator|.
name|t
operator|.
name|sign
condition|)
block|{
comment|/* fa is negative */
if|if
condition|(
operator|!
name|fb
operator|.
name|t
operator|.
name|sign
condition|)
comment|/* fb is positive, return true */
name|result
operator|.
name|q
operator|=
name|IEEE_TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|fa
operator|.
name|t
operator|.
name|exponent
operator|>
name|fb
operator|.
name|t
operator|.
name|exponent
condition|)
comment|/* fa has a larger exponent, return true */
name|result
operator|.
name|q
operator|=
name|IEEE_TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|fa
operator|.
name|t
operator|.
name|exponent
operator|==
name|fb
operator|.
name|t
operator|.
name|exponent
operator|&&
name|fa
operator|.
name|t
operator|.
name|fraction
operator|>
name|fb
operator|.
name|t
operator|.
name|fraction
condition|)
comment|/* compare fractions */
name|result
operator|.
name|q
operator|=
name|IEEE_TRUE
expr_stmt|;
else|else
name|result
operator|.
name|q
operator|=
name|IEEE_FALSE
expr_stmt|;
block|}
else|else
block|{
comment|/* fa is positive */
if|if
condition|(
name|fb
operator|.
name|t
operator|.
name|sign
condition|)
comment|/* fb is negative, return false */
name|result
operator|.
name|q
operator|=
name|IEEE_FALSE
expr_stmt|;
elseif|else
if|if
condition|(
name|fb
operator|.
name|t
operator|.
name|exponent
operator|>
name|fa
operator|.
name|t
operator|.
name|exponent
condition|)
comment|/* fb has a larger exponent, return true */
name|result
operator|.
name|q
operator|=
name|IEEE_TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|fa
operator|.
name|t
operator|.
name|exponent
operator|==
name|fb
operator|.
name|t
operator|.
name|exponent
operator|&&
name|fa
operator|.
name|t
operator|.
name|fraction
operator|<
name|fb
operator|.
name|t
operator|.
name|fraction
condition|)
comment|/* compare fractions */
name|result
operator|.
name|q
operator|=
name|IEEE_TRUE
expr_stmt|;
else|else
name|result
operator|.
name|q
operator|=
name|IEEE_FALSE
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
name|fp_register_t
name|ieee_cmple
parameter_list|(
name|fp_register_t
name|fa
parameter_list|,
name|fp_register_t
name|fb
parameter_list|,
name|u_int64_t
modifier|*
name|status
parameter_list|)
block|{
name|fp_register_t
name|result
decl_stmt|;
if|if
condition|(
name|isNaN
argument_list|(
name|fa
argument_list|)
operator|||
name|isNaN
argument_list|(
name|fb
argument_list|)
condition|)
block|{
if|if
condition|(
name|isSNaN
argument_list|(
name|fa
argument_list|)
operator|||
name|isSNaN
argument_list|(
name|fb
argument_list|)
condition|)
operator|*
name|status
operator||=
name|FPCR_INV
expr_stmt|;
name|result
operator|.
name|q
operator|=
name|IEEE_FALSE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|isZERO
argument_list|(
name|fa
argument_list|)
operator|&&
name|isZERO
argument_list|(
name|fb
argument_list|)
condition|)
name|result
operator|.
name|q
operator|=
name|IEEE_TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|fa
operator|.
name|t
operator|.
name|sign
condition|)
block|{
comment|/* fa is negative */
if|if
condition|(
operator|!
name|fb
operator|.
name|t
operator|.
name|sign
condition|)
comment|/* fb is positive, return true */
name|result
operator|.
name|q
operator|=
name|IEEE_TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|fa
operator|.
name|t
operator|.
name|exponent
operator|>
name|fb
operator|.
name|t
operator|.
name|exponent
condition|)
comment|/* fa has a larger exponent, return true */
name|result
operator|.
name|q
operator|=
name|IEEE_TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|fa
operator|.
name|t
operator|.
name|exponent
operator|==
name|fb
operator|.
name|t
operator|.
name|exponent
operator|&&
name|fa
operator|.
name|t
operator|.
name|fraction
operator|>=
name|fb
operator|.
name|t
operator|.
name|fraction
condition|)
comment|/* compare fractions */
name|result
operator|.
name|q
operator|=
name|IEEE_TRUE
expr_stmt|;
else|else
name|result
operator|.
name|q
operator|=
name|IEEE_FALSE
expr_stmt|;
block|}
else|else
block|{
comment|/* fa is positive */
if|if
condition|(
name|fb
operator|.
name|t
operator|.
name|sign
condition|)
comment|/* fb is negative, return false */
name|result
operator|.
name|q
operator|=
name|IEEE_FALSE
expr_stmt|;
elseif|else
if|if
condition|(
name|fb
operator|.
name|t
operator|.
name|exponent
operator|>
name|fa
operator|.
name|t
operator|.
name|exponent
condition|)
comment|/* fb has a larger exponent, return true */
name|result
operator|.
name|q
operator|=
name|IEEE_TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|fa
operator|.
name|t
operator|.
name|exponent
operator|==
name|fb
operator|.
name|t
operator|.
name|exponent
operator|&&
name|fa
operator|.
name|t
operator|.
name|fraction
operator|<=
name|fb
operator|.
name|t
operator|.
name|fraction
condition|)
comment|/* compare fractions */
name|result
operator|.
name|q
operator|=
name|IEEE_TRUE
expr_stmt|;
else|else
name|result
operator|.
name|q
operator|=
name|IEEE_FALSE
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
name|fp_register_t
name|ieee_convert_S_T
parameter_list|(
name|fp_register_t
name|f
parameter_list|,
name|int
name|rnd
parameter_list|,
name|u_int64_t
name|control
parameter_list|,
name|u_int64_t
modifier|*
name|status
parameter_list|)
block|{
comment|/* 	 * Handle exceptional values. 	 */
if|if
condition|(
name|isNaN
argument_list|(
name|f
argument_list|)
condition|)
block|{
comment|/* Instructions Descriptions (I) section 4.7.10.1 */
name|f
operator|.
name|t
operator|.
name|fraction
operator||=
name|QNAN_BIT
expr_stmt|;
operator|*
name|status
operator||=
name|FPCR_INV
expr_stmt|;
block|}
if|if
condition|(
name|isQNaN
argument_list|(
name|f
argument_list|)
operator|||
name|isINF
argument_list|(
name|f
argument_list|)
condition|)
return|return
name|f
return|;
comment|/* 	 * If the number is a denormalised float, renormalise. 	 */
if|if
condition|(
name|isDENORM
argument_list|(
name|f
argument_list|)
condition|)
return|return
name|makefloat
argument_list|(
name|f
operator|.
name|t
operator|.
name|sign
argument_list|,
name|getexp
argument_list|(
name|f
argument_list|,
name|S_FORMAT
argument_list|)
argument_list|,
name|getfrac
argument_list|(
name|f
argument_list|)
argument_list|,
name|T_FORMAT
argument_list|,
name|rnd
argument_list|,
name|control
argument_list|,
name|status
argument_list|)
return|;
else|else
return|return
name|f
return|;
block|}
end_function

begin_function
name|fp_register_t
name|ieee_convert_T_S
parameter_list|(
name|fp_register_t
name|f
parameter_list|,
name|int
name|rnd
parameter_list|,
name|u_int64_t
name|control
parameter_list|,
name|u_int64_t
modifier|*
name|status
parameter_list|)
block|{
comment|/* 	 * Handle exceptional values. 	 */
if|if
condition|(
name|isNaN
argument_list|(
name|f
argument_list|)
condition|)
block|{
comment|/* Instructions Descriptions (I) section 4.7.10.1 */
name|f
operator|.
name|t
operator|.
name|fraction
operator||=
name|QNAN_BIT
expr_stmt|;
name|f
operator|.
name|t
operator|.
name|fraction
operator|&=
operator|~
name|S_FRACMASK
expr_stmt|;
operator|*
name|status
operator||=
name|FPCR_INV
expr_stmt|;
block|}
if|if
condition|(
name|isQNaN
argument_list|(
name|f
argument_list|)
operator|||
name|isINF
argument_list|(
name|f
argument_list|)
condition|)
return|return
name|f
return|;
return|return
name|makefloat
argument_list|(
name|f
operator|.
name|t
operator|.
name|sign
argument_list|,
name|getexp
argument_list|(
name|f
argument_list|,
name|T_FORMAT
argument_list|)
argument_list|,
name|getfrac
argument_list|(
name|f
argument_list|)
argument_list|,
name|S_FORMAT
argument_list|,
name|rnd
argument_list|,
name|control
argument_list|,
name|status
argument_list|)
return|;
block|}
end_function

begin_function
name|fp_register_t
name|ieee_convert_Q_S
parameter_list|(
name|fp_register_t
name|f
parameter_list|,
name|int
name|rnd
parameter_list|,
name|u_int64_t
name|control
parameter_list|,
name|u_int64_t
modifier|*
name|status
parameter_list|)
block|{
name|u_int64_t
name|frac
init|=
name|f
operator|.
name|q
decl_stmt|;
name|int
name|sign
decl_stmt|,
name|exponent
decl_stmt|;
if|if
condition|(
name|frac
operator|>>
literal|63
condition|)
block|{
name|sign
operator|=
literal|1
expr_stmt|;
name|frac
operator|=
operator|-
name|frac
expr_stmt|;
block|}
else|else
name|sign
operator|=
literal|0
expr_stmt|;
comment|/* 	 * We shift up one bit to leave the sticky bit clear.  This is 	 * possible unless frac == (1<<63), in which case the sticky 	 * bit is already clear. 	 */
name|exponent
operator|=
name|T_FRACBITS
operator|+
name|FRAC_SHIFT
expr_stmt|;
if|if
condition|(
name|frac
operator|<
operator|(
literal|1ULL
operator|<<
literal|63
operator|)
condition|)
block|{
name|frac
operator|<<=
literal|1
expr_stmt|;
name|exponent
operator|--
expr_stmt|;
block|}
return|return
name|makefloat
argument_list|(
name|sign
argument_list|,
name|exponent
argument_list|,
name|frac
argument_list|,
name|S_FORMAT
argument_list|,
name|rnd
argument_list|,
name|control
argument_list|,
name|status
argument_list|)
return|;
block|}
end_function

begin_function
name|fp_register_t
name|ieee_convert_Q_T
parameter_list|(
name|fp_register_t
name|f
parameter_list|,
name|int
name|rnd
parameter_list|,
name|u_int64_t
name|control
parameter_list|,
name|u_int64_t
modifier|*
name|status
parameter_list|)
block|{
name|u_int64_t
name|frac
init|=
name|f
operator|.
name|q
decl_stmt|;
name|int
name|sign
decl_stmt|,
name|exponent
decl_stmt|;
if|if
condition|(
name|frac
operator|>>
literal|63
condition|)
block|{
name|sign
operator|=
literal|1
expr_stmt|;
name|frac
operator|=
operator|-
name|frac
expr_stmt|;
block|}
else|else
name|sign
operator|=
literal|0
expr_stmt|;
comment|/* 	 * We shift up one bit to leave the sticky bit clear.  This is 	 * possible unless frac == (1<<63), in which case the sticky 	 * bit is already clear. 	 */
name|exponent
operator|=
name|T_FRACBITS
operator|+
name|FRAC_SHIFT
expr_stmt|;
if|if
condition|(
name|frac
operator|<
operator|(
literal|1ULL
operator|<<
literal|63
operator|)
condition|)
block|{
name|frac
operator|<<=
literal|1
expr_stmt|;
name|exponent
operator|--
expr_stmt|;
block|}
return|return
name|makefloat
argument_list|(
name|sign
argument_list|,
name|exponent
argument_list|,
name|frac
argument_list|,
name|T_FORMAT
argument_list|,
name|rnd
argument_list|,
name|control
argument_list|,
name|status
argument_list|)
return|;
block|}
end_function

begin_function
name|fp_register_t
name|ieee_convert_T_Q
parameter_list|(
name|fp_register_t
name|f
parameter_list|,
name|int
name|rnd
parameter_list|,
name|u_int64_t
name|control
parameter_list|,
name|u_int64_t
modifier|*
name|status
parameter_list|)
block|{
name|u_int64_t
name|frac
decl_stmt|;
name|int
name|exp
decl_stmt|;
comment|/* 	 * Handle exceptional values. 	 */
if|if
condition|(
name|isNaN
argument_list|(
name|f
argument_list|)
condition|)
block|{
comment|/* Instructions Descriptions (I) section 4.7.10.1 */
if|if
condition|(
name|isSNaN
argument_list|(
name|f
argument_list|)
condition|)
operator|*
name|status
operator||=
name|FPCR_INV
expr_stmt|;
name|f
operator|.
name|q
operator|=
literal|0
expr_stmt|;
return|return
name|f
return|;
block|}
if|if
condition|(
name|isINF
argument_list|(
name|f
argument_list|)
condition|)
block|{
comment|/* Instructions Descriptions (I) section 4.7.10.1 */
operator|*
name|status
operator||=
name|FPCR_INV
expr_stmt|;
name|f
operator|.
name|q
operator|=
literal|0
expr_stmt|;
return|return
name|f
return|;
block|}
name|exp
operator|=
name|getexp
argument_list|(
name|f
argument_list|,
name|T_FORMAT
argument_list|)
operator|-
operator|(
name|T_FRACBITS
operator|+
name|FRAC_SHIFT
operator|)
expr_stmt|;
name|frac
operator|=
name|getfrac
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|exp
operator|>
literal|64
operator|||
name|frac
operator|>=
operator|(
literal|1
operator|<<
operator|(
literal|64
operator|-
name|exp
operator|)
operator|)
condition|)
operator|*
name|status
operator||=
name|FPCR_IOV
operator||
name|FPCR_INE
expr_stmt|;
if|if
condition|(
name|exp
operator|<
literal|64
condition|)
name|frac
operator|<<=
name|exp
expr_stmt|;
else|else
name|frac
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|exp
operator|<
literal|0
condition|)
block|{
name|u_int64_t
name|mask
decl_stmt|;
name|u_int64_t
name|fraclo
decl_stmt|,
name|frachi
decl_stmt|;
name|u_int64_t
name|diffhi
decl_stmt|,
name|difflo
decl_stmt|;
name|exp
operator|=
operator|-
name|exp
expr_stmt|;
if|if
condition|(
name|exp
operator|>
literal|64
condition|)
block|{
name|fraclo
operator|=
literal|0
expr_stmt|;
name|diffhi
operator|=
literal|0
expr_stmt|;
name|difflo
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|frac
condition|)
block|{
name|frachi
operator|=
literal|1
expr_stmt|;
operator|*
name|status
operator||=
name|FPCR_INE
expr_stmt|;
block|}
else|else
name|frachi
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|exp
operator|==
literal|64
condition|)
block|{
name|fraclo
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|frac
condition|)
block|{
name|frachi
operator|=
literal|1
expr_stmt|;
name|difflo
operator|=
name|frac
expr_stmt|;
name|diffhi
operator|=
operator|-
name|frac
expr_stmt|;
operator|*
name|status
operator||=
name|FPCR_INE
expr_stmt|;
block|}
else|else
block|{
name|frachi
operator|=
literal|0
expr_stmt|;
name|difflo
operator|=
literal|0
expr_stmt|;
name|diffhi
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|mask
operator|=
operator|(
literal|1
operator|<<
name|exp
operator|)
operator|-
literal|1
expr_stmt|;
name|fraclo
operator|=
name|frac
operator|>>
name|exp
expr_stmt|;
if|if
condition|(
name|frac
operator|&
name|mask
condition|)
block|{
name|frachi
operator|=
name|fraclo
operator|+
literal|1
expr_stmt|;
name|difflo
operator|=
name|frac
operator|-
operator|(
name|fraclo
operator|<<
name|exp
operator|)
expr_stmt|;
name|diffhi
operator|=
operator|(
name|frachi
operator|<<
name|exp
operator|)
operator|-
name|frac
expr_stmt|;
operator|*
name|status
operator||=
name|FPCR_INE
expr_stmt|;
block|}
else|else
block|{
name|frachi
operator|=
name|fraclo
expr_stmt|;
name|difflo
operator|=
literal|0
expr_stmt|;
name|diffhi
operator|=
literal|0
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|rnd
condition|)
block|{
case|case
name|ROUND_CHOP
case|:
name|frac
operator|=
name|fraclo
expr_stmt|;
break|break;
case|case
name|ROUND_MINUS_INF
case|:
if|if
condition|(
name|f
operator|.
name|t
operator|.
name|sign
condition|)
name|frac
operator|=
name|frachi
expr_stmt|;
else|else
name|frac
operator|=
name|fraclo
expr_stmt|;
break|break;
case|case
name|ROUND_NORMAL
case|:
if|#
directive|if
literal|0
comment|/* 			 * Round to nearest. 			 */
block|if (difflo< diffhi) 				frac = fraclo; 			else if (diffhi> difflo) 				frac = frachi; 			else if (fraclo& 1) 				frac = frachi; 			else 				frac = fraclo;
else|#
directive|else
comment|/* 			 * Round to zero. 			 */
name|frac
operator|=
name|fraclo
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|ROUND_PLUS_INF
case|:
if|if
condition|(
name|f
operator|.
name|t
operator|.
name|sign
condition|)
name|frac
operator|=
name|fraclo
expr_stmt|;
else|else
name|frac
operator|=
name|frachi
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|f
operator|.
name|t
operator|.
name|sign
condition|)
block|{
if|if
condition|(
name|frac
operator|>
operator|(
literal|1ULL
operator|<<
literal|63
operator|)
condition|)
operator|*
name|status
operator||=
name|FPCR_IOV
operator||
name|FPCR_INE
expr_stmt|;
name|frac
operator|=
operator|-
name|frac
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|frac
operator|>
operator|(
literal|1ULL
operator|<<
literal|63
operator|)
operator|-
literal|1
condition|)
operator|*
name|status
operator||=
name|FPCR_IOV
operator||
name|FPCR_INE
expr_stmt|;
block|}
name|f
operator|.
name|q
operator|=
name|frac
expr_stmt|;
return|return
name|f
return|;
block|}
end_function

begin_function
name|fp_register_t
name|ieee_convert_S_Q
parameter_list|(
name|fp_register_t
name|f
parameter_list|,
name|int
name|rnd
parameter_list|,
name|u_int64_t
name|control
parameter_list|,
name|u_int64_t
modifier|*
name|status
parameter_list|)
block|{
name|f
operator|=
name|ieee_convert_S_T
argument_list|(
name|f
argument_list|,
name|rnd
argument_list|,
name|control
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
name|ieee_convert_T_Q
argument_list|(
name|f
argument_list|,
name|rnd
argument_list|,
name|control
argument_list|,
name|status
argument_list|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|KERNEL
end_ifndef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_union
union|union
name|value
block|{
name|double
name|d
decl_stmt|;
name|fp_register_t
name|r
decl_stmt|;
block|}
union|;
end_union

begin_function
specifier|static
name|double
name|random_double
parameter_list|()
block|{
name|union
name|value
name|a
decl_stmt|;
name|int
name|exp
decl_stmt|;
name|a
operator|.
name|r
operator|.
name|t
operator|.
name|fraction
operator|=
operator|(
operator|(
name|long
name|long
operator|)
name|random
argument_list|()
operator|&
operator|(
literal|1ULL
operator|<<
literal|20
operator|)
operator|-
literal|1
operator|)
operator|<<
literal|32
operator||
name|random
argument_list|()
expr_stmt|;
name|exp
operator|=
name|random
argument_list|()
operator|&
literal|0x7ff
expr_stmt|;
if|#
directive|if
literal|1
if|if
condition|(
name|exp
operator|==
literal|0
condition|)
name|exp
operator|=
literal|1
expr_stmt|;
comment|/* no denorms */
elseif|else
if|if
condition|(
name|exp
operator|==
literal|0x7ff
condition|)
name|exp
operator|=
literal|0x7fe
expr_stmt|;
comment|/* no NaNs and INFs */
endif|#
directive|endif
name|a
operator|.
name|r
operator|.
name|t
operator|.
name|exponent
operator|=
name|exp
expr_stmt|;
name|a
operator|.
name|r
operator|.
name|t
operator|.
name|sign
operator|=
name|random
argument_list|()
operator|&
literal|1
expr_stmt|;
return|return
name|a
operator|.
name|d
return|;
block|}
end_function

begin_function
specifier|static
name|float
name|random_float
parameter_list|()
block|{
name|union
name|value
name|a
decl_stmt|;
name|int
name|exp
decl_stmt|;
name|a
operator|.
name|r
operator|.
name|t
operator|.
name|fraction
operator|=
operator|(
operator|(
name|long
operator|)
name|random
argument_list|()
operator|&
operator|(
literal|1ULL
operator|<<
literal|23
operator|)
operator|-
literal|1
operator|)
operator|<<
literal|29
expr_stmt|;
name|exp
operator|=
name|random
argument_list|()
operator|&
literal|0xff
expr_stmt|;
if|#
directive|if
literal|1
if|if
condition|(
name|exp
operator|==
literal|0
condition|)
name|exp
operator|=
literal|1
expr_stmt|;
comment|/* no denorms */
elseif|else
if|if
condition|(
name|exp
operator|==
literal|0xff
condition|)
name|exp
operator|=
literal|0xfe
expr_stmt|;
comment|/* no NaNs and INFs */
endif|#
directive|endif
comment|/* map exponent from S to T format */
if|if
condition|(
name|exp
operator|==
literal|255
condition|)
name|a
operator|.
name|r
operator|.
name|t
operator|.
name|exponent
operator|=
literal|0x7ff
expr_stmt|;
elseif|else
if|if
condition|(
name|exp
operator|&
literal|0x80
condition|)
name|a
operator|.
name|r
operator|.
name|t
operator|.
name|exponent
operator|=
literal|0x400
operator|+
operator|(
name|exp
operator|&
literal|0x7f
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|exp
condition|)
name|a
operator|.
name|r
operator|.
name|t
operator|.
name|exponent
operator|=
literal|0x380
operator|+
name|exp
expr_stmt|;
else|else
name|a
operator|.
name|r
operator|.
name|t
operator|.
name|exponent
operator|=
literal|0
expr_stmt|;
name|a
operator|.
name|r
operator|.
name|t
operator|.
name|sign
operator|=
name|random
argument_list|()
operator|&
literal|1
expr_stmt|;
return|return
name|a
operator|.
name|d
return|;
block|}
end_function

begin_comment
comment|/*  * Ignore epsilon errors  */
end_comment

begin_function
name|int
name|equal_T
parameter_list|(
name|union
name|value
name|a
parameter_list|,
name|union
name|value
name|b
parameter_list|)
block|{
if|if
condition|(
name|isZERO
argument_list|(
name|a
operator|.
name|r
argument_list|)
operator|&&
name|isZERO
argument_list|(
name|b
operator|.
name|r
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|a
operator|.
name|r
operator|.
name|t
operator|.
name|sign
operator|!=
name|b
operator|.
name|r
operator|.
name|t
operator|.
name|sign
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|a
operator|.
name|r
operator|.
name|t
operator|.
name|exponent
operator|!=
name|b
operator|.
name|r
operator|.
name|t
operator|.
name|exponent
condition|)
return|return
literal|0
return|;
return|return
name|a
operator|.
name|r
operator|.
name|t
operator|.
name|fraction
operator|==
name|b
operator|.
name|r
operator|.
name|t
operator|.
name|fraction
return|;
block|}
end_function

begin_function
name|int
name|equal_S
parameter_list|(
name|union
name|value
name|a
parameter_list|,
name|union
name|value
name|b
parameter_list|)
block|{
name|int64_t
name|epsilon
init|=
literal|1ULL
operator|<<
literal|29
decl_stmt|;
if|if
condition|(
name|isZERO
argument_list|(
name|a
operator|.
name|r
argument_list|)
operator|&&
name|isZERO
argument_list|(
name|b
operator|.
name|r
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|a
operator|.
name|r
operator|.
name|t
operator|.
name|sign
operator|!=
name|b
operator|.
name|r
operator|.
name|t
operator|.
name|sign
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|a
operator|.
name|r
operator|.
name|t
operator|.
name|exponent
operator|!=
name|b
operator|.
name|r
operator|.
name|t
operator|.
name|exponent
condition|)
return|return
literal|0
return|;
return|return
operator|(
operator|(
name|a
operator|.
name|r
operator|.
name|t
operator|.
name|fraction
operator|&
operator|~
operator|(
name|epsilon
operator|-
literal|1
operator|)
operator|)
operator|==
operator|(
name|b
operator|.
name|r
operator|.
name|t
operator|.
name|fraction
operator|&
operator|~
operator|(
name|epsilon
operator|-
literal|1
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|ITER
value|1000000
end_define

begin_function
specifier|static
name|void
name|test_double_add
parameter_list|()
block|{
name|union
name|value
name|a
decl_stmt|,
name|b
decl_stmt|,
name|c
decl_stmt|,
name|x
decl_stmt|;
name|u_int64_t
name|status
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ITER
condition|;
name|i
operator|++
control|)
block|{
name|a
operator|.
name|d
operator|=
name|random_double
argument_list|()
expr_stmt|;
name|b
operator|.
name|d
operator|=
name|random_double
argument_list|()
expr_stmt|;
name|status
operator|=
literal|0
expr_stmt|;
name|c
operator|.
name|r
operator|=
name|ieee_add
argument_list|(
name|a
operator|.
name|r
argument_list|,
name|b
operator|.
name|r
argument_list|,
name|T_FORMAT
argument_list|,
name|ROUND_NORMAL
argument_list|,
literal|0
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
comment|/* ignore NaN and INF */
if|if
condition|(
name|isNaN
argument_list|(
name|c
operator|.
name|r
argument_list|)
operator|||
name|isINF
argument_list|(
name|c
operator|.
name|r
argument_list|)
operator|||
name|isDENORM
argument_list|(
name|c
operator|.
name|r
argument_list|)
condition|)
continue|continue;
name|x
operator|.
name|d
operator|=
name|a
operator|.
name|d
operator|+
name|b
operator|.
name|d
expr_stmt|;
if|if
condition|(
operator|!
name|equal_T
argument_list|(
name|c
argument_list|,
name|x
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"bad double add, %g + %g = %g (should be %g)\n"
argument_list|,
name|a
operator|.
name|d
argument_list|,
name|b
operator|.
name|d
argument_list|,
name|c
operator|.
name|d
argument_list|,
name|x
operator|.
name|d
argument_list|)
expr_stmt|;
name|c
operator|.
name|r
operator|=
name|ieee_add
argument_list|(
name|a
operator|.
name|r
argument_list|,
name|b
operator|.
name|r
argument_list|,
name|T_FORMAT
argument_list|,
name|ROUND_NORMAL
argument_list|,
literal|0
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|test_single_add
parameter_list|()
block|{
name|union
name|value
name|a
decl_stmt|,
name|b
decl_stmt|,
name|c
decl_stmt|,
name|x
decl_stmt|,
name|t
decl_stmt|;
name|float
name|xf
decl_stmt|;
name|u_int64_t
name|status
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ITER
condition|;
name|i
operator|++
control|)
block|{
if|#
directive|if
literal|0
block|if (i == 0) { 			a.r.q = 0xb33acf292ca49700ULL; 			b.r.q = 0xcad3191058a693aeULL; 		}
endif|#
directive|endif
name|a
operator|.
name|d
operator|=
name|random_float
argument_list|()
expr_stmt|;
name|b
operator|.
name|d
operator|=
name|random_float
argument_list|()
expr_stmt|;
name|status
operator|=
literal|0
expr_stmt|;
name|c
operator|.
name|r
operator|=
name|ieee_add
argument_list|(
name|a
operator|.
name|r
argument_list|,
name|b
operator|.
name|r
argument_list|,
name|S_FORMAT
argument_list|,
name|ROUND_NORMAL
argument_list|,
literal|0
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
comment|/* ignore NaN and INF */
if|if
condition|(
name|isNaN
argument_list|(
name|c
operator|.
name|r
argument_list|)
operator|||
name|isINF
argument_list|(
name|c
operator|.
name|r
argument_list|)
operator|||
name|isDENORM
argument_list|(
name|c
operator|.
name|r
argument_list|)
condition|)
continue|continue;
name|xf
operator|=
name|a
operator|.
name|d
operator|+
name|b
operator|.
name|d
expr_stmt|;
name|x
operator|.
name|d
operator|=
name|xf
expr_stmt|;
name|t
operator|.
name|r
operator|=
name|ieee_convert_S_T
argument_list|(
name|c
operator|.
name|r
argument_list|,
name|ROUND_NORMAL
argument_list|,
literal|0
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|equal_S
argument_list|(
name|t
argument_list|,
name|x
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"bad single add, %g + %g = %g (should be %g)\n"
argument_list|,
name|a
operator|.
name|d
argument_list|,
name|b
operator|.
name|d
argument_list|,
name|t
operator|.
name|d
argument_list|,
name|x
operator|.
name|d
argument_list|)
expr_stmt|;
name|c
operator|.
name|r
operator|=
name|ieee_add
argument_list|(
name|a
operator|.
name|r
argument_list|,
name|b
operator|.
name|r
argument_list|,
name|S_FORMAT
argument_list|,
name|ROUND_NORMAL
argument_list|,
literal|0
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|test_double_mul
parameter_list|()
block|{
name|union
name|value
name|a
decl_stmt|,
name|b
decl_stmt|,
name|c
decl_stmt|,
name|x
decl_stmt|;
name|u_int64_t
name|status
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ITER
condition|;
name|i
operator|++
control|)
block|{
name|a
operator|.
name|d
operator|=
name|random_double
argument_list|()
expr_stmt|;
name|b
operator|.
name|d
operator|=
name|random_double
argument_list|()
expr_stmt|;
name|status
operator|=
literal|0
expr_stmt|;
name|c
operator|.
name|r
operator|=
name|ieee_mul
argument_list|(
name|a
operator|.
name|r
argument_list|,
name|b
operator|.
name|r
argument_list|,
name|T_FORMAT
argument_list|,
name|ROUND_NORMAL
argument_list|,
literal|0
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
comment|/* ignore NaN and INF */
if|if
condition|(
name|isNaN
argument_list|(
name|c
operator|.
name|r
argument_list|)
operator|||
name|isINF
argument_list|(
name|c
operator|.
name|r
argument_list|)
operator|||
name|isDENORM
argument_list|(
name|c
operator|.
name|r
argument_list|)
condition|)
continue|continue;
name|x
operator|.
name|d
operator|=
name|a
operator|.
name|d
operator|*
name|b
operator|.
name|d
expr_stmt|;
if|if
condition|(
operator|!
name|equal_T
argument_list|(
name|c
argument_list|,
name|x
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"bad double mul, %g * %g = %g (should be %g)\n"
argument_list|,
name|a
operator|.
name|d
argument_list|,
name|b
operator|.
name|d
argument_list|,
name|c
operator|.
name|d
argument_list|,
name|x
operator|.
name|d
argument_list|)
expr_stmt|;
name|c
operator|.
name|r
operator|=
name|ieee_mul
argument_list|(
name|a
operator|.
name|r
argument_list|,
name|b
operator|.
name|r
argument_list|,
name|T_FORMAT
argument_list|,
name|ROUND_NORMAL
argument_list|,
literal|0
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|test_single_mul
parameter_list|()
block|{
name|union
name|value
name|a
decl_stmt|,
name|b
decl_stmt|,
name|c
decl_stmt|,
name|x
decl_stmt|,
name|t
decl_stmt|;
name|float
name|xf
decl_stmt|;
name|u_int64_t
name|status
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ITER
condition|;
name|i
operator|++
control|)
block|{
name|a
operator|.
name|d
operator|=
name|random_double
argument_list|()
expr_stmt|;
name|b
operator|.
name|d
operator|=
name|random_double
argument_list|()
expr_stmt|;
name|status
operator|=
literal|0
expr_stmt|;
name|c
operator|.
name|r
operator|=
name|ieee_mul
argument_list|(
name|a
operator|.
name|r
argument_list|,
name|b
operator|.
name|r
argument_list|,
name|S_FORMAT
argument_list|,
name|ROUND_NORMAL
argument_list|,
literal|0
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
comment|/* ignore NaN and INF */
if|if
condition|(
name|isNaN
argument_list|(
name|c
operator|.
name|r
argument_list|)
operator|||
name|isINF
argument_list|(
name|c
operator|.
name|r
argument_list|)
operator|||
name|isDENORM
argument_list|(
name|c
operator|.
name|r
argument_list|)
condition|)
continue|continue;
name|xf
operator|=
name|a
operator|.
name|d
operator|*
name|b
operator|.
name|d
expr_stmt|;
name|x
operator|.
name|d
operator|=
name|xf
expr_stmt|;
name|t
operator|.
name|r
operator|=
name|ieee_convert_S_T
argument_list|(
name|c
operator|.
name|r
argument_list|,
name|ROUND_NORMAL
argument_list|,
literal|0
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|equal_S
argument_list|(
name|t
argument_list|,
name|x
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"bad single mul, %g * %g = %g (should be %g)\n"
argument_list|,
name|a
operator|.
name|d
argument_list|,
name|b
operator|.
name|d
argument_list|,
name|t
operator|.
name|d
argument_list|,
name|x
operator|.
name|d
argument_list|)
expr_stmt|;
name|c
operator|.
name|r
operator|=
name|ieee_mul
argument_list|(
name|a
operator|.
name|r
argument_list|,
name|b
operator|.
name|r
argument_list|,
name|T_FORMAT
argument_list|,
name|ROUND_NORMAL
argument_list|,
literal|0
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|test_double_div
parameter_list|()
block|{
name|union
name|value
name|a
decl_stmt|,
name|b
decl_stmt|,
name|c
decl_stmt|,
name|x
decl_stmt|;
name|u_int64_t
name|status
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ITER
condition|;
name|i
operator|++
control|)
block|{
name|a
operator|.
name|d
operator|=
name|random_double
argument_list|()
expr_stmt|;
name|b
operator|.
name|d
operator|=
name|random_double
argument_list|()
expr_stmt|;
name|status
operator|=
literal|0
expr_stmt|;
name|c
operator|.
name|r
operator|=
name|ieee_div
argument_list|(
name|a
operator|.
name|r
argument_list|,
name|b
operator|.
name|r
argument_list|,
name|T_FORMAT
argument_list|,
name|ROUND_NORMAL
argument_list|,
literal|0
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
comment|/* ignore NaN and INF */
if|if
condition|(
name|isNaN
argument_list|(
name|c
operator|.
name|r
argument_list|)
operator|||
name|isINF
argument_list|(
name|c
operator|.
name|r
argument_list|)
operator|||
name|isDENORM
argument_list|(
name|c
operator|.
name|r
argument_list|)
condition|)
continue|continue;
name|x
operator|.
name|d
operator|=
name|a
operator|.
name|d
operator|/
name|b
operator|.
name|d
expr_stmt|;
if|if
condition|(
operator|!
name|equal_T
argument_list|(
name|c
argument_list|,
name|x
argument_list|)
operator|&&
operator|!
name|isZERO
argument_list|(
name|x
operator|.
name|r
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"bad double div, %g / %g = %g (should be %g)\n"
argument_list|,
name|a
operator|.
name|d
argument_list|,
name|b
operator|.
name|d
argument_list|,
name|c
operator|.
name|d
argument_list|,
name|x
operator|.
name|d
argument_list|)
expr_stmt|;
name|c
operator|.
name|r
operator|=
name|ieee_div
argument_list|(
name|a
operator|.
name|r
argument_list|,
name|b
operator|.
name|r
argument_list|,
name|T_FORMAT
argument_list|,
name|ROUND_NORMAL
argument_list|,
literal|0
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|test_single_div
parameter_list|()
block|{
name|union
name|value
name|a
decl_stmt|,
name|b
decl_stmt|,
name|c
decl_stmt|,
name|x
decl_stmt|,
name|t
decl_stmt|;
name|float
name|xf
decl_stmt|;
name|u_int64_t
name|status
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ITER
condition|;
name|i
operator|++
control|)
block|{
name|a
operator|.
name|d
operator|=
name|random_double
argument_list|()
expr_stmt|;
name|b
operator|.
name|d
operator|=
name|random_double
argument_list|()
expr_stmt|;
name|status
operator|=
literal|0
expr_stmt|;
name|c
operator|.
name|r
operator|=
name|ieee_div
argument_list|(
name|a
operator|.
name|r
argument_list|,
name|b
operator|.
name|r
argument_list|,
name|S_FORMAT
argument_list|,
name|ROUND_NORMAL
argument_list|,
literal|0
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
comment|/* ignore NaN and INF */
if|if
condition|(
name|isNaN
argument_list|(
name|c
operator|.
name|r
argument_list|)
operator|||
name|isINF
argument_list|(
name|c
operator|.
name|r
argument_list|)
operator|||
name|isDENORM
argument_list|(
name|c
operator|.
name|r
argument_list|)
condition|)
continue|continue;
name|xf
operator|=
name|a
operator|.
name|d
operator|/
name|b
operator|.
name|d
expr_stmt|;
name|x
operator|.
name|d
operator|=
name|xf
expr_stmt|;
name|t
operator|.
name|r
operator|=
name|ieee_convert_S_T
argument_list|(
name|c
operator|.
name|r
argument_list|,
name|ROUND_NORMAL
argument_list|,
literal|0
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|equal_S
argument_list|(
name|t
argument_list|,
name|x
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"bad single div, %g / %g = %g (should be %g)\n"
argument_list|,
name|a
operator|.
name|d
argument_list|,
name|b
operator|.
name|d
argument_list|,
name|t
operator|.
name|d
argument_list|,
name|x
operator|.
name|d
argument_list|)
expr_stmt|;
name|c
operator|.
name|r
operator|=
name|ieee_mul
argument_list|(
name|a
operator|.
name|r
argument_list|,
name|b
operator|.
name|r
argument_list|,
name|T_FORMAT
argument_list|,
name|ROUND_NORMAL
argument_list|,
literal|0
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|test_convert_int_to_double
parameter_list|()
block|{
name|union
name|value
name|a
decl_stmt|,
name|c
decl_stmt|,
name|x
decl_stmt|;
name|u_int64_t
name|status
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ITER
condition|;
name|i
operator|++
control|)
block|{
name|a
operator|.
name|r
operator|.
name|q
operator|=
operator|(
name|u_int64_t
operator|)
name|random
argument_list|()
operator|<<
literal|32
operator||
name|random
argument_list|()
expr_stmt|;
name|status
operator|=
literal|0
expr_stmt|;
name|c
operator|.
name|r
operator|=
name|ieee_convert_Q_T
argument_list|(
name|a
operator|.
name|r
argument_list|,
name|ROUND_NORMAL
argument_list|,
literal|0
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
comment|/* ignore NaN and INF */
if|if
condition|(
name|isNaN
argument_list|(
name|c
operator|.
name|r
argument_list|)
operator|||
name|isINF
argument_list|(
name|c
operator|.
name|r
argument_list|)
condition|)
continue|continue;
name|x
operator|.
name|d
operator|=
operator|(
name|double
operator|)
name|a
operator|.
name|r
operator|.
name|q
expr_stmt|;
if|if
condition|(
name|c
operator|.
name|d
operator|!=
name|x
operator|.
name|d
condition|)
block|{
name|printf
argument_list|(
literal|"bad convert double, (double)%qx = %g (should be %g)\n"
argument_list|,
name|a
operator|.
name|r
operator|.
name|q
argument_list|,
name|c
operator|.
name|d
argument_list|,
name|x
operator|.
name|d
argument_list|)
expr_stmt|;
name|c
operator|.
name|r
operator|=
name|ieee_convert_Q_T
argument_list|(
name|a
operator|.
name|r
argument_list|,
name|ROUND_NORMAL
argument_list|,
literal|0
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|test_convert_int_to_single
parameter_list|()
block|{
name|union
name|value
name|a
decl_stmt|,
name|c
decl_stmt|,
name|x
decl_stmt|,
name|t
decl_stmt|;
name|float
name|xf
decl_stmt|;
name|u_int64_t
name|status
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ITER
condition|;
name|i
operator|++
control|)
block|{
name|a
operator|.
name|r
operator|.
name|q
operator|=
operator|(
name|unsigned
name|long
name|long
operator|)
name|random
argument_list|()
operator|<<
literal|32
operator||
name|random
argument_list|()
expr_stmt|;
name|status
operator|=
literal|0
expr_stmt|;
name|c
operator|.
name|r
operator|=
name|ieee_convert_Q_S
argument_list|(
name|a
operator|.
name|r
argument_list|,
name|ROUND_NORMAL
argument_list|,
literal|0
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
comment|/* ignore NaN and INF */
if|if
condition|(
name|isNaN
argument_list|(
name|c
operator|.
name|r
argument_list|)
operator|||
name|isINF
argument_list|(
name|c
operator|.
name|r
argument_list|)
condition|)
continue|continue;
name|xf
operator|=
operator|(
name|float
operator|)
name|a
operator|.
name|r
operator|.
name|q
expr_stmt|;
name|x
operator|.
name|d
operator|=
name|xf
expr_stmt|;
name|t
operator|.
name|r
operator|=
name|ieee_convert_S_T
argument_list|(
name|c
operator|.
name|r
argument_list|,
name|ROUND_NORMAL
argument_list|,
literal|0
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|.
name|d
operator|!=
name|x
operator|.
name|d
condition|)
block|{
name|printf
argument_list|(
literal|"bad convert single, (double)%qx = %g (should be %g)\n"
argument_list|,
name|a
operator|.
name|r
operator|.
name|q
argument_list|,
name|c
operator|.
name|d
argument_list|,
name|x
operator|.
name|d
argument_list|)
expr_stmt|;
name|c
operator|.
name|r
operator|=
name|ieee_convert_Q_S
argument_list|(
name|a
operator|.
name|r
argument_list|,
name|ROUND_NORMAL
argument_list|,
literal|0
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|test_convert_double_to_int
parameter_list|()
block|{
name|union
name|value
name|a
decl_stmt|,
name|c
decl_stmt|;
name|u_int64_t
name|status
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ITER
condition|;
name|i
operator|++
control|)
block|{
name|a
operator|.
name|d
operator|=
name|random_double
argument_list|()
expr_stmt|;
name|status
operator|=
literal|0
expr_stmt|;
name|c
operator|.
name|r
operator|=
name|ieee_convert_T_Q
argument_list|(
name|a
operator|.
name|r
argument_list|,
name|ROUND_NORMAL
argument_list|,
literal|0
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|c
operator|.
name|r
operator|.
name|q
operator|!=
operator|(
name|int
operator|)
name|a
operator|.
name|d
condition|)
block|{
name|printf
argument_list|(
literal|"bad convert double, (int)%g = %d (should be %d)\n"
argument_list|,
name|a
operator|.
name|d
argument_list|,
operator|(
name|int
operator|)
name|c
operator|.
name|r
operator|.
name|q
argument_list|,
operator|(
name|int
operator|)
name|a
operator|.
name|d
argument_list|)
expr_stmt|;
name|c
operator|.
name|r
operator|=
name|ieee_convert_T_Q
argument_list|(
name|a
operator|.
name|r
argument_list|,
name|ROUND_NORMAL
argument_list|,
literal|0
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|srandom
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|test_double_div
argument_list|()
expr_stmt|;
name|test_single_div
argument_list|()
expr_stmt|;
name|test_double_add
argument_list|()
expr_stmt|;
name|test_single_add
argument_list|()
expr_stmt|;
name|test_double_mul
argument_list|()
expr_stmt|;
name|test_single_mul
argument_list|()
expr_stmt|;
name|test_convert_int_to_double
argument_list|()
expr_stmt|;
name|test_convert_int_to_single
argument_list|()
expr_stmt|;
if|#
directive|if
literal|0
comment|/* x86 generates SIGFPE on overflows. */
block|test_convert_double_to_int();
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

