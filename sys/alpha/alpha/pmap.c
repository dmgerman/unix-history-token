begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1991 Regents of the University of California.  * All rights reserved.  * Copyright (c) 1994 John S. Dyson  * All rights reserved.  * Copyright (c) 1994 David Greenman  * All rights reserved.  * Copyright (c) 1998 Doug Rabson  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * the Systems Programming Group of the University of Utah Computer  * Science Department and William Jolitz of UUNET Technologies Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	from:	@(#)pmap.c	7.7 (Berkeley)	5/12/91  *	from:	i386 Id: pmap.c,v 1.193 1998/04/19 15:22:48 bde Exp  *		with some ideas from NetBSD's alpha pmap  */
end_comment

begin_comment
comment|/*  *	Manages physical address maps.  *  *	In addition to hardware address maps, this  *	module is called upon to provide software-use-only  *	maps which may or may not be stored in the same  *	form as hardware maps.  These pseudo-maps are  *	used to store intermediate results from copy  *	operations to and from address spaces.  *  *	Since the information managed by this module is  *	also stored by the logical address mapping module,  *	this module may throw away valid virtual-to-physical  *	mappings at almost any time.  However, invalidations  *	of virtual-to-physical mappings must be done as  *	requested.  *  *	In order to cope with hardware architectures which  *	make virtual-to-physical map invalidates expensive,  *	this module may delay invalidate or reduced protection  *	operations until such time as they are actually  *	necessary.  This module is given full information as  *	to which processors are currently using which maps,  *	and to when physical maps must be made correct.  */
end_comment

begin_comment
comment|/*  * Notes for alpha pmap.  *   * On alpha, pm_pdeobj will hold lev1, lev2 and lev3 page tables.  * Indices from 0 to NUSERLEV3MAPS-1 will map user lev3 page tables,  * indices from NUSERLEV3MAPS to NUSERLEV3MAPS+NUSERLEV2MAPS-1 will  * map user lev2 page tables and index NUSERLEV3MAPS+NUSERLEV2MAPS  * will map the lev1 page table.  The lev1 table will self map at  * address VADDR(PTLEV1I,0,0).  *   * The vm_object kptobj holds the kernel page tables on i386 (62 or 63  * of them, depending on whether the system is SMP).  On alpha, kptobj  * will hold the lev3 and lev2 page tables for K1SEG.  Indices 0 to  * NKLEV3MAPS-1 will map kernel lev3 page tables and indices  * NKLEV3MAPS to NKLEV3MAPS+NKLEV2MAPS will map lev2 page tables. (XXX  * should the kernel Lev1map be inserted into this object?).  *   * pvtmmap is not needed for alpha since K0SEG maps all of physical  * memory.  *   *   * alpha virtual memory map:  *   *   *  Address							Lev1 index  *   * 	         	---------------------------------  *  0000000000000000    | 				|	0  * 		        |				|  * 		        |				|  * 		        |				|  * 		        |				|  * 		       ---      		       ---  * 		                User space (USEG)  * 		       ---      		       ---  * 		        |				|  * 		        |				|  * 		        |				|  * 		        |				|  *  000003ffffffffff    |				|	511=UMAXLEV1I  * 	                ---------------------------------  *  fffffc0000000000    |				|	512=K0SEGLEV1I  * 	                |	Kernel code/data/bss	|  * 	                |				|  * 	                |				|  * 	                |				|  * 	               ---			       ---  * 	                	K0SEG  * 	               ---			       ---  * 	                |				|  * 	                |	1-1 physical/virtual	|  * 	                |				|  * 	                |				|  *  fffffdffffffffff    |				|  * 	                ---------------------------------  *  fffffe0000000000    |				|	768=K1SEGLEV1I  * 	                |	Kernel dynamic data	|  * 	                |				|  * 	                |				|  * 	                |				|  * 	               ---			       ---  * 	                	K1SEG  * 	               ---	        	       ---  * 	                |				|  * 	                |	mapped by ptes		|  * 	                |				|  * 	                |				|  *  fffffff7ffffffff    |				|  * 	                ---------------------------------  *  fffffffe00000000    | 				|	1023=PTLEV1I  * 		        |	PTmap (pte self map)	|  *  ffffffffffffffff	|				|  * 			---------------------------------  *   */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/msgbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmmeter.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pageout.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pager.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/pcb.h>
end_include

begin_include
include|#
directive|include
file|<machine/rpb.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|PMAP_SHPGPERPROC
end_ifndef

begin_define
define|#
directive|define
name|PMAP_SHPGPERPROC
value|200
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DIAGNOSTIC
argument_list|)
end_if

begin_define
define|#
directive|define
name|PMAP_DIAGNOSTIC
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
literal|0
end_if

begin_define
define|#
directive|define
name|PMAP_DIAGNOSTIC
end_define

begin_define
define|#
directive|define
name|PMAP_DEBUG
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|PMAP_DIAGNOSTIC
argument_list|)
end_if

begin_define
define|#
directive|define
name|PMAP_INLINE
value|__inline
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PMAP_INLINE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Some macros for manipulating virtual addresses  */
end_comment

begin_define
define|#
directive|define
name|ALPHA_L1SIZE
value|(1L<< ALPHA_L1SHIFT)
end_define

begin_define
define|#
directive|define
name|ALPHA_L2SIZE
value|(1L<< ALPHA_L2SHIFT)
end_define

begin_define
define|#
directive|define
name|alpha_l1trunc
parameter_list|(
name|va
parameter_list|)
value|((va)& ~(ALPHA_L1SIZE-1))
end_define

begin_define
define|#
directive|define
name|alpha_l2trunc
parameter_list|(
name|va
parameter_list|)
value|((va)& ~(ALPHA_L2SIZE-1))
end_define

begin_comment
comment|/*  * Get PDEs and PTEs for user/kernel address space  */
end_comment

begin_define
define|#
directive|define
name|pmap_pte_w
parameter_list|(
name|pte
parameter_list|)
value|((*(pte)& PG_W) != 0)
end_define

begin_define
define|#
directive|define
name|pmap_pte_managed
parameter_list|(
name|pte
parameter_list|)
value|((*(pte)& PG_MANAGED) != 0)
end_define

begin_define
define|#
directive|define
name|pmap_pte_v
parameter_list|(
name|pte
parameter_list|)
value|((*(pte)& PG_V) != 0)
end_define

begin_define
define|#
directive|define
name|pmap_pte_pa
parameter_list|(
name|pte
parameter_list|)
value|alpha_ptob(ALPHA_PTE_TO_PFN(*(pte)))
end_define

begin_define
define|#
directive|define
name|pmap_pte_prot
parameter_list|(
name|pte
parameter_list|)
value|(*(pte)& PG_PROT)
end_define

begin_define
define|#
directive|define
name|pmap_pte_set_w
parameter_list|(
name|pte
parameter_list|,
name|v
parameter_list|)
value|((v)?(*pte |= PG_W):(*pte&= ~PG_W))
end_define

begin_define
define|#
directive|define
name|pmap_pte_set_prot
parameter_list|(
name|pte
parameter_list|,
name|v
parameter_list|)
value|((*pte&= ~PG_PROT), (*pte |= (v)))
end_define

begin_comment
comment|/*  * Given a map and a machine independent protection code,  * convert to an alpha protection code.  */
end_comment

begin_define
define|#
directive|define
name|pte_prot
parameter_list|(
name|m
parameter_list|,
name|p
parameter_list|)
value|(protection_codes[m == kernel_pmap ? 0 : 1][p])
end_define

begin_decl_stmt
name|int
name|protection_codes
index|[
literal|2
index|]
index|[
literal|8
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Return non-zero if this pmap is currently active  */
end_comment

begin_define
define|#
directive|define
name|pmap_isactive
parameter_list|(
name|pmap
parameter_list|)
value|(pmap->pm_active)
end_define

begin_comment
comment|/*   * Extract level 1, 2 and 3 page table indices from a va  */
end_comment

begin_define
define|#
directive|define
name|PTMASK
value|((1<< ALPHA_PTSHIFT) - 1)
end_define

begin_define
define|#
directive|define
name|pmap_lev1_index
parameter_list|(
name|va
parameter_list|)
value|(((va)>> ALPHA_L1SHIFT)& PTMASK)
end_define

begin_define
define|#
directive|define
name|pmap_lev2_index
parameter_list|(
name|va
parameter_list|)
value|(((va)>> ALPHA_L2SHIFT)& PTMASK)
end_define

begin_define
define|#
directive|define
name|pmap_lev3_index
parameter_list|(
name|va
parameter_list|)
value|(((va)>> ALPHA_L3SHIFT)& PTMASK)
end_define

begin_comment
comment|/*  * Given a physical address, construct a pte  */
end_comment

begin_define
define|#
directive|define
name|pmap_phys_to_pte
parameter_list|(
name|pa
parameter_list|)
value|ALPHA_PTE_FROM_PFN(alpha_btop(pa))
end_define

begin_comment
comment|/*  * Given a page frame number, construct a k0seg va  */
end_comment

begin_define
define|#
directive|define
name|pmap_k0seg_to_pfn
parameter_list|(
name|va
parameter_list|)
value|alpha_btop(ALPHA_K0SEG_TO_PHYS(va))
end_define

begin_comment
comment|/*  * Given a pte, construct a k0seg va  */
end_comment

begin_define
define|#
directive|define
name|pmap_k0seg_to_pte
parameter_list|(
name|va
parameter_list|)
value|ALPHA_PTE_FROM_PFN(pmap_k0seg_to_pfn(va))
end_define

begin_comment
comment|/*  * Lev1map:  *  *	Kernel level 1 page table.  This maps all kernel level 2  *	page table pages, and is used as a template for all user  *	pmap level 1 page tables.  When a new user level 1 page  *	table is allocated, all Lev1map PTEs for kernel addresses  *	are copied to the new map.  *  * Lev2map:  *  *	Initial set of kernel level 2 page table pages.  These  *	map the kernel level 3 page table pages.  As kernel  *	level 3 page table pages are added, more level 2 page  *	table pages may be added to map them.  These pages are  *	never freed.  *  * Lev3map:  *  *	Initial set of kernel level 3 page table pages.  These  *	map pages in K1SEG.  More level 3 page table pages may  *	be added at run-time if additional K1SEG address space  *	is required.  These pages are never freed.  *  * Lev2mapsize:  *  *	Number of entries in the initial Lev2map.  *  * Lev3mapsize:  *  *	Number of entries in the initial Lev3map.  *  * NOTE: When mappings are inserted into the kernel pmap, all  * level 2 and level 3 page table pages must already be allocated  * and mapped into the parent page table.  */
end_comment

begin_decl_stmt
name|pt_entry_t
modifier|*
name|Lev1map
decl_stmt|,
modifier|*
name|Lev2map
decl_stmt|,
modifier|*
name|Lev3map
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_size_t
name|Lev2mapsize
decl_stmt|,
name|Lev3mapsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Statically allocated kernel pmap  */
end_comment

begin_decl_stmt
name|struct
name|pmap
name|kernel_pmap_store
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_offset_t
name|virtual_avail
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* VA of first avail page (after kernel bss) */
end_comment

begin_decl_stmt
name|vm_offset_t
name|virtual_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* VA of last avail page (end of kernel AS) */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nklev3
decl_stmt|,
name|nklev2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_offset_t
name|kernel_vm_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Data for the ASN allocator  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pmap_maxasn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|pmap_t
name|pmap_active
index|[
name|MAXCPU
index|]
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|LIST_HEAD
argument_list|(
argument_list|,
argument|pmap
argument_list|)
name|allpmaps
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|allpmaps_lock
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Data for the pv entry allocation mechanism  */
end_comment

begin_decl_stmt
specifier|static
name|uma_zone_t
name|pvzone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pv_entry_count
init|=
literal|0
decl_stmt|,
name|pv_entry_max
init|=
literal|0
decl_stmt|,
name|pv_entry_high_water
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pmap_pagedaemon_waken
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|PMAP_INLINE
name|void
name|free_pv_entry
parameter_list|(
name|pv_entry_t
name|pv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|pv_entry_t
name|get_pv_entry
parameter_list|(
name|pmap_t
name|locked_pmap
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|alpha_protection_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmap_changebit
parameter_list|(
name|vm_page_t
name|m
parameter_list|,
name|int
name|bit
parameter_list|,
name|boolean_t
name|setem
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|vm_page_t
name|pmap_enter_quick_locked
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|m
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|,
name|vm_page_t
name|mpte
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pmap_remove_pte
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|pt_entry_t
modifier|*
name|ptq
parameter_list|,
name|vm_offset_t
name|sva
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmap_remove_page
parameter_list|(
name|struct
name|pmap
modifier|*
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pmap_remove_entry
parameter_list|(
name|struct
name|pmap
modifier|*
name|pmap
parameter_list|,
name|vm_page_t
name|m
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmap_insert_entry
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|mpte
parameter_list|,
name|vm_page_t
name|m
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|boolean_t
name|pmap_try_insert_pv_entry
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|mpte
parameter_list|,
name|vm_page_t
name|m
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|vm_page_t
name|pmap_allocpte
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|vm_page_t
name|_pmap_allocpte
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|unsigned
name|ptepindex
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|_pmap_unwire_pte_hold
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|m
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pmap_unuse_pt
parameter_list|(
name|pmap_t
parameter_list|,
name|vm_offset_t
parameter_list|,
name|vm_page_t
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|SMP
end_ifdef

begin_function_decl
specifier|static
name|void
name|pmap_invalidate_page_action
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmap_invalidate_all_action
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *	Routine:	pmap_lev1pte  *	Function:  *		Extract the level 1 page table entry associated  *		with the given map/virtual_address pair.  */
end_comment

begin_function
specifier|static
name|PMAP_INLINE
name|pt_entry_t
modifier|*
name|pmap_lev1pte
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
if|if
condition|(
operator|!
name|pmap
condition|)
return|return
literal|0
return|;
return|return
operator|&
name|pmap
operator|->
name|pm_lev1
index|[
name|pmap_lev1_index
argument_list|(
name|va
argument_list|)
index|]
return|;
block|}
end_function

begin_comment
comment|/*  *	Routine:	pmap_lev2pte  *	Function:  *		Extract the level 2 page table entry associated  *		with the given map/virtual_address pair.  */
end_comment

begin_function
specifier|static
name|PMAP_INLINE
name|pt_entry_t
modifier|*
name|pmap_lev2pte
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|pt_entry_t
modifier|*
name|l1pte
decl_stmt|;
name|pt_entry_t
modifier|*
name|l2map
decl_stmt|;
name|l1pte
operator|=
name|pmap_lev1pte
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pmap_pte_v
argument_list|(
name|l1pte
argument_list|)
condition|)
return|return
literal|0
return|;
name|l2map
operator|=
operator|(
name|pt_entry_t
operator|*
operator|)
name|ALPHA_PHYS_TO_K0SEG
argument_list|(
name|pmap_pte_pa
argument_list|(
name|l1pte
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|&
name|l2map
index|[
name|pmap_lev2_index
argument_list|(
name|va
argument_list|)
index|]
return|;
block|}
end_function

begin_comment
comment|/*  *	Routine:	pmap_lev3pte  *	Function:  *		Extract the level 3 page table entry associated  *		with the given map/virtual_address pair.  */
end_comment

begin_function
specifier|static
name|PMAP_INLINE
name|pt_entry_t
modifier|*
name|pmap_lev3pte
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|pt_entry_t
modifier|*
name|l2pte
decl_stmt|;
name|pt_entry_t
modifier|*
name|l3map
decl_stmt|;
name|l2pte
operator|=
name|pmap_lev2pte
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|l2pte
operator|||
operator|!
name|pmap_pte_v
argument_list|(
name|l2pte
argument_list|)
condition|)
return|return
literal|0
return|;
name|l3map
operator|=
operator|(
name|pt_entry_t
operator|*
operator|)
name|ALPHA_PHYS_TO_K0SEG
argument_list|(
name|pmap_pte_pa
argument_list|(
name|l2pte
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|&
name|l3map
index|[
name|pmap_lev3_index
argument_list|(
name|va
argument_list|)
index|]
return|;
block|}
end_function

begin_function
name|vm_offset_t
name|pmap_steal_memory
parameter_list|(
name|vm_size_t
name|size
parameter_list|)
block|{
name|vm_size_t
name|bank_size
decl_stmt|;
name|vm_offset_t
name|pa
decl_stmt|,
name|va
decl_stmt|;
name|size
operator|=
name|round_page
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|bank_size
operator|=
name|phys_avail
index|[
literal|1
index|]
operator|-
name|phys_avail
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
name|size
operator|>
name|bank_size
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|phys_avail
index|[
name|i
operator|+
literal|2
index|]
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|phys_avail
index|[
name|i
index|]
operator|=
name|phys_avail
index|[
name|i
operator|+
literal|2
index|]
expr_stmt|;
name|phys_avail
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|phys_avail
index|[
name|i
operator|+
literal|3
index|]
expr_stmt|;
block|}
name|phys_avail
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|phys_avail
index|[
name|i
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|phys_avail
index|[
literal|0
index|]
condition|)
name|panic
argument_list|(
literal|"pmap_steal_memory: out of memory"
argument_list|)
expr_stmt|;
name|bank_size
operator|=
name|phys_avail
index|[
literal|1
index|]
operator|-
name|phys_avail
index|[
literal|0
index|]
expr_stmt|;
block|}
name|pa
operator|=
name|phys_avail
index|[
literal|0
index|]
expr_stmt|;
name|phys_avail
index|[
literal|0
index|]
operator|+=
name|size
expr_stmt|;
name|va
operator|=
name|ALPHA_PHYS_TO_K0SEG
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|va
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|va
return|;
block|}
end_function

begin_decl_stmt
specifier|extern
name|pt_entry_t
name|rom_pte
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|prom_mapped
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX */
end_comment

begin_comment
comment|/*  *	Bootstrap the system enough to run with virtual memory.  */
end_comment

begin_function
name|void
name|pmap_bootstrap
parameter_list|(
name|vm_offset_t
name|ptaddr
parameter_list|,
name|u_int
name|maxasn
parameter_list|)
block|{
name|pt_entry_t
name|newpte
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Setup ASNs. PCPU_GET(next_asn) and PCPU_GET(current_asngen) are set 	 * up already. 	 */
name|pmap_maxasn
operator|=
name|maxasn
expr_stmt|;
comment|/* 	 * Allocate a level 1 map for the kernel. 	 */
name|Lev1map
operator|=
operator|(
name|pt_entry_t
operator|*
operator|)
name|pmap_steal_memory
argument_list|(
name|PAGE_SIZE
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate a level 2 map for the kernel 	 */
name|Lev2map
operator|=
operator|(
name|pt_entry_t
operator|*
operator|)
name|pmap_steal_memory
argument_list|(
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|Lev2mapsize
operator|=
name|PAGE_SIZE
expr_stmt|;
comment|/* 	 * Allocate some level 3 maps for the kernel 	 */
name|Lev3map
operator|=
operator|(
name|pt_entry_t
operator|*
operator|)
name|pmap_steal_memory
argument_list|(
name|PAGE_SIZE
operator|*
name|NKPT
argument_list|)
expr_stmt|;
name|Lev3mapsize
operator|=
name|NKPT
operator|*
name|PAGE_SIZE
expr_stmt|;
comment|/* Map all of the level 2 maps */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|howmany
argument_list|(
name|Lev2mapsize
argument_list|,
name|PAGE_SIZE
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|long
name|pfn
init|=
name|pmap_k0seg_to_pfn
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|Lev2map
argument_list|)
operator|+
name|i
decl_stmt|;
name|newpte
operator|=
name|ALPHA_PTE_FROM_PFN
argument_list|(
name|pfn
argument_list|)
expr_stmt|;
name|newpte
operator||=
name|PG_V
operator||
name|PG_ASM
operator||
name|PG_KRE
operator||
name|PG_KWE
operator||
name|PG_W
expr_stmt|;
name|Lev1map
index|[
name|K1SEGLEV1I
operator|+
name|i
index|]
operator|=
name|newpte
expr_stmt|;
block|}
comment|/* Setup the mapping for the prom console */
block|{
if|if
condition|(
name|pmap_uses_prom_console
argument_list|()
condition|)
block|{
comment|/* XXX save old pte so that we can remap prom if necessary */
name|rom_pte
operator|=
operator|*
operator|(
name|pt_entry_t
operator|*
operator|)
name|ptaddr
operator|&
operator|~
name|PG_ASM
expr_stmt|;
comment|/* XXX */
block|}
name|prom_mapped
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Actually, this code lies.  The prom is still mapped, and will 		 * remain so until the context switch after alpha_init() returns. 		 * Printfs using the firmware before then will end up frobbing 		 * Lev1map unnecessarily, but that's OK. 		 */
block|}
comment|/* 	 * Level 1 self mapping. 	 * 	 * Don't set PG_ASM since the self-mapping is different for each 	 * address space. 	 */
name|newpte
operator|=
name|pmap_k0seg_to_pte
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|Lev1map
argument_list|)
expr_stmt|;
name|newpte
operator||=
name|PG_V
operator||
name|PG_KRE
operator||
name|PG_KWE
expr_stmt|;
name|Lev1map
index|[
name|PTLEV1I
index|]
operator|=
name|newpte
expr_stmt|;
comment|/* Map all of the level 3 maps */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|howmany
argument_list|(
name|Lev3mapsize
argument_list|,
name|PAGE_SIZE
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|long
name|pfn
init|=
name|pmap_k0seg_to_pfn
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|Lev3map
argument_list|)
operator|+
name|i
decl_stmt|;
name|newpte
operator|=
name|ALPHA_PTE_FROM_PFN
argument_list|(
name|pfn
argument_list|)
expr_stmt|;
name|newpte
operator||=
name|PG_V
operator||
name|PG_ASM
operator||
name|PG_KRE
operator||
name|PG_KWE
operator||
name|PG_W
expr_stmt|;
name|Lev2map
index|[
name|i
index|]
operator|=
name|newpte
expr_stmt|;
block|}
name|virtual_avail
operator|=
name|VM_MIN_KERNEL_ADDRESS
expr_stmt|;
name|virtual_end
operator|=
name|VPTBASE
expr_stmt|;
comment|/* 	 * Initialize protection array. 	 */
name|alpha_protection_init
argument_list|()
expr_stmt|;
comment|/* 	 * Initialize the kernel pmap (which is statically allocated). 	 */
name|PMAP_LOCK_INIT
argument_list|(
name|kernel_pmap
argument_list|)
expr_stmt|;
name|kernel_pmap
operator|->
name|pm_lev1
operator|=
name|Lev1map
expr_stmt|;
name|kernel_pmap
operator|->
name|pm_active
operator|=
operator|~
literal|0
expr_stmt|;
name|kernel_pmap
operator|->
name|pm_asn
index|[
name|alpha_pal_whami
argument_list|()
index|]
operator|.
name|asn
operator|=
literal|0
expr_stmt|;
name|kernel_pmap
operator|->
name|pm_asn
index|[
name|alpha_pal_whami
argument_list|()
index|]
operator|.
name|gen
operator|=
literal|1
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|kernel_pmap
operator|->
name|pm_pvlist
argument_list|)
expr_stmt|;
name|nklev3
operator|=
name|NKPT
expr_stmt|;
name|nklev2
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Initialize list of pmaps. 	 */
name|LIST_INIT
argument_list|(
operator|&
name|allpmaps
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|allpmaps
argument_list|,
name|kernel_pmap
argument_list|,
name|pm_list
argument_list|)
expr_stmt|;
comment|/* 	 * Set up proc0's PCB such that the ptbr points to the right place 	 * and has the kernel pmap's. 	 */
name|thread0
operator|.
name|td_pcb
operator|->
name|pcb_hw
operator|.
name|apcb_ptbr
operator|=
name|ALPHA_K0SEG_TO_PHYS
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|Lev1map
argument_list|)
operator|>>
name|PAGE_SHIFT
expr_stmt|;
name|thread0
operator|.
name|td_pcb
operator|->
name|pcb_hw
operator|.
name|apcb_asn
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|int
name|pmap_uses_prom_console
parameter_list|()
block|{
name|int
name|cputype
decl_stmt|;
name|cputype
operator|=
name|hwrpb
operator|->
name|rpb_type
expr_stmt|;
return|return
operator|(
name|cputype
operator|==
name|ST_DEC_21000
operator|||
name|ST_DEC_4100
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	Initialize a vm_page's machine-dependent fields.  */
end_comment

begin_function
name|void
name|pmap_page_init
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|TAILQ_INIT
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|)
expr_stmt|;
name|m
operator|->
name|md
operator|.
name|pv_list_count
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Initialize the pmap module.  *	Called by vm_init, to initialize any structures that the pmap  *	system needs to map virtual memory.  */
end_comment

begin_function
name|void
name|pmap_init
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|shpgperproc
init|=
name|PMAP_SHPGPERPROC
decl_stmt|;
comment|/* 	 * Initialize the address space (zone) for the pv entries.  Set a 	 * high water mark so that the system can recover from excessive 	 * numbers of pv entries. 	 */
name|pvzone
operator|=
name|uma_zcreate
argument_list|(
literal|"PV ENTRY"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pv_entry
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
name|UMA_ZONE_VM
operator||
name|UMA_ZONE_NOFREE
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"vm.pmap.shpgperproc"
argument_list|,
operator|&
name|shpgperproc
argument_list|)
expr_stmt|;
name|pv_entry_max
operator|=
name|shpgperproc
operator|*
name|maxproc
operator|+
name|cnt
operator|.
name|v_page_count
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"vm.pmap.pv_entries"
argument_list|,
operator|&
name|pv_entry_max
argument_list|)
expr_stmt|;
name|pv_entry_high_water
operator|=
literal|9
operator|*
operator|(
name|pv_entry_max
operator|/
literal|10
operator|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pmap_init2
parameter_list|()
block|{ }
end_function

begin_comment
comment|/***************************************************  * Manipulate TLBs for a pmap  ***************************************************/
end_comment

begin_function
specifier|static
name|void
name|pmap_invalidate_asn
parameter_list|(
name|pmap_t
name|pmap
parameter_list|)
block|{
name|pmap
operator|->
name|pm_asn
index|[
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
index|]
operator|.
name|gen
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|pmap_invalidate_page_arg
block|{
name|pmap_t
name|pmap
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|pmap_invalidate_page
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SMP
name|struct
name|pmap_invalidate_page_arg
name|arg
decl_stmt|;
name|arg
operator|.
name|pmap
operator|=
name|pmap
expr_stmt|;
name|arg
operator|.
name|va
operator|=
name|va
expr_stmt|;
name|smp_rendezvous
argument_list|(
literal|0
argument_list|,
name|pmap_invalidate_page_action
argument_list|,
literal|0
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pmap_invalidate_page_action
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|pmap_t
name|pmap
init|=
operator|(
operator|(
expr|struct
name|pmap_invalidate_page_arg
operator|*
operator|)
name|arg
operator|)
operator|->
name|pmap
decl_stmt|;
name|vm_offset_t
name|va
init|=
operator|(
operator|(
expr|struct
name|pmap_invalidate_page_arg
operator|*
operator|)
name|arg
operator|)
operator|->
name|va
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pmap
operator|->
name|pm_active
operator|&
name|PCPU_GET
argument_list|(
name|cpumask
argument_list|)
condition|)
block|{
name|ALPHA_TBIS
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|alpha_pal_imb
argument_list|()
expr_stmt|;
comment|/* XXX overkill? */
block|}
else|else
block|{
name|pmap_invalidate_asn
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|pmap_invalidate_all
parameter_list|(
name|pmap_t
name|pmap
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SMP
name|smp_rendezvous
argument_list|(
literal|0
argument_list|,
name|pmap_invalidate_all_action
argument_list|,
literal|0
argument_list|,
operator|(
name|void
operator|*
operator|)
name|pmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pmap_invalidate_all_action
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|pmap_t
name|pmap
init|=
operator|(
name|pmap_t
operator|)
name|arg
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pmap
operator|->
name|pm_active
operator|&
name|PCPU_GET
argument_list|(
name|cpumask
argument_list|)
condition|)
block|{
name|ALPHA_TBIA
argument_list|()
expr_stmt|;
name|alpha_pal_imb
argument_list|()
expr_stmt|;
comment|/* XXX overkill? */
block|}
else|else
name|pmap_invalidate_asn
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pmap_get_asn
parameter_list|(
name|pmap_t
name|pmap
parameter_list|)
block|{
if|if
condition|(
name|PCPU_GET
argument_list|(
name|next_asn
argument_list|)
operator|>
name|pmap_maxasn
condition|)
block|{
comment|/* 		 * Start a new ASN generation. 		 * 		 * Invalidate all per-process mappings and I-cache 		 */
name|PCPU_SET
argument_list|(
name|next_asn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PCPU_SET
argument_list|(
name|current_asngen
argument_list|,
operator|(
name|PCPU_GET
argument_list|(
name|current_asngen
argument_list|)
operator|+
literal|1
operator|)
operator|&
name|ASNGEN_MASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|PCPU_GET
argument_list|(
name|current_asngen
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Clear the pm_asn[].gen of all pmaps. 			 * This is safe since it is only called from 			 * pmap_activate after it has deactivated 			 * the old pmap and it only affects this cpu. 			 */
name|pmap_t
name|tpmap
decl_stmt|;
ifdef|#
directive|ifdef
name|PMAP_DIAGNOSTIC
name|printf
argument_list|(
literal|"pmap_get_asn: generation rollover\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PCPU_SET
argument_list|(
name|current_asngen
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|allpmaps_lock
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|tpmap
argument_list|,
argument|&allpmaps
argument_list|,
argument|pm_list
argument_list|)
block|{
name|tpmap
operator|->
name|pm_asn
index|[
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
index|]
operator|.
name|gen
operator|=
literal|0
expr_stmt|;
block|}
name|mtx_unlock_spin
argument_list|(
operator|&
name|allpmaps_lock
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Since we are about to start re-using ASNs, we must 		 * clear out the TLB and the I-cache since they are tagged 		 * with the ASN. 		 */
name|ALPHA_TBIAP
argument_list|()
expr_stmt|;
name|alpha_pal_imb
argument_list|()
expr_stmt|;
comment|/* XXX overkill? */
block|}
name|pmap
operator|->
name|pm_asn
index|[
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
index|]
operator|.
name|asn
operator|=
name|PCPU_GET
argument_list|(
name|next_asn
argument_list|)
expr_stmt|;
name|PCPU_SET
argument_list|(
name|next_asn
argument_list|,
name|PCPU_GET
argument_list|(
name|next_asn
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|pmap
operator|->
name|pm_asn
index|[
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
index|]
operator|.
name|gen
operator|=
name|PCPU_GET
argument_list|(
name|current_asngen
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/***************************************************  * Low level helper routines.....  ***************************************************/
end_comment

begin_comment
comment|/*  *	Routine:	pmap_extract  *	Function:  *		Extract the physical page address associated  *		with the given map/virtual_address pair.  */
end_comment

begin_function
name|vm_paddr_t
name|pmap_extract
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
name|vm_paddr_t
name|pa
decl_stmt|;
name|pa
operator|=
literal|0
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|pte
operator|=
name|pmap_lev3pte
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|pte
operator|!=
name|NULL
operator|&&
name|pmap_pte_v
argument_list|(
name|pte
argument_list|)
condition|)
name|pa
operator|=
name|pmap_pte_pa
argument_list|(
name|pte
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
return|return
operator|(
name|pa
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	Routine:	pmap_extract_and_hold  *	Function:  *		Atomically extract and hold the physical page  *		with the given pmap and virtual address pair  *		if that mapping permits the given protection.  */
end_comment

begin_function
name|vm_page_t
name|pmap_extract_and_hold
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|)
block|{
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|pte
operator|=
name|pmap_lev3pte
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|pte
operator|!=
name|NULL
operator|&&
name|pmap_pte_v
argument_list|(
name|pte
argument_list|)
operator|&&
operator|(
operator|*
name|pte
operator|&
name|pte_prot
argument_list|(
name|pmap
argument_list|,
name|prot
argument_list|)
operator|)
operator|==
name|pte_prot
argument_list|(
name|pmap
argument_list|,
name|prot
argument_list|)
condition|)
block|{
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pmap_pte_pa
argument_list|(
name|pte
argument_list|)
argument_list|)
expr_stmt|;
name|vm_page_hold
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_comment
comment|/***************************************************  * Low level mapping routines.....  ***************************************************/
end_comment

begin_comment
comment|/*  * Add a list of wired pages to the kva  * this routine is only used for temporary  * kernel mappings that do not need to have  * page modification or references recorded.  * Note that old mappings are simply written  * over.  The page *must* be wired.  */
end_comment

begin_function
name|void
name|pmap_qenter
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
modifier|*
name|m
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|vm_offset_t
name|tva
init|=
name|va
operator|+
name|i
operator|*
name|PAGE_SIZE
decl_stmt|;
name|pt_entry_t
name|npte
init|=
name|pmap_phys_to_pte
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
index|[
name|i
index|]
argument_list|)
argument_list|)
operator||
name|PG_ASM
operator||
name|PG_KRE
operator||
name|PG_KWE
operator||
name|PG_V
decl_stmt|;
name|pt_entry_t
name|opte
decl_stmt|;
name|pte
operator|=
name|vtopte
argument_list|(
name|tva
argument_list|)
expr_stmt|;
name|opte
operator|=
operator|*
name|pte
expr_stmt|;
operator|*
name|pte
operator|=
name|npte
expr_stmt|;
if|if
condition|(
name|opte
condition|)
name|pmap_invalidate_page
argument_list|(
name|kernel_pmap
argument_list|,
name|tva
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * this routine jerks page mappings from the  * kernel -- it is meant only for temporary mappings.  */
end_comment

begin_function
name|void
name|pmap_qremove
parameter_list|(
name|va
parameter_list|,
name|count
parameter_list|)
name|vm_offset_t
name|va
decl_stmt|;
name|int
name|count
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
specifier|register
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|pte
operator|=
name|vtopte
argument_list|(
name|va
argument_list|)
expr_stmt|;
operator|*
name|pte
operator|=
literal|0
expr_stmt|;
name|pmap_invalidate_page
argument_list|(
name|kernel_pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|va
operator|+=
name|PAGE_SIZE
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * add a wired page to the kva  * note that in order for the mapping to take effect -- you  * should do a invltlb after doing the pmap_kenter...  */
end_comment

begin_function
name|PMAP_INLINE
name|void
name|pmap_kenter
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|vm_offset_t
name|pa
parameter_list|)
block|{
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
name|pt_entry_t
name|npte
decl_stmt|,
name|opte
decl_stmt|;
name|npte
operator|=
name|pmap_phys_to_pte
argument_list|(
name|pa
argument_list|)
operator||
name|PG_ASM
operator||
name|PG_KRE
operator||
name|PG_KWE
operator||
name|PG_V
expr_stmt|;
name|pte
operator|=
name|vtopte
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|opte
operator|=
operator|*
name|pte
expr_stmt|;
operator|*
name|pte
operator|=
name|npte
expr_stmt|;
if|if
condition|(
name|opte
condition|)
name|pmap_invalidate_page
argument_list|(
name|kernel_pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * remove a page from the kernel pagetables  */
end_comment

begin_function
name|PMAP_INLINE
name|void
name|pmap_kremove
parameter_list|(
name|vm_offset_t
name|va
parameter_list|)
block|{
specifier|register
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
name|pte
operator|=
name|vtopte
argument_list|(
name|va
argument_list|)
expr_stmt|;
operator|*
name|pte
operator|=
literal|0
expr_stmt|;
name|pmap_invalidate_page
argument_list|(
name|kernel_pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Used to map a range of physical addresses into kernel  *	virtual address space.  *  *	The value passed in '*virt' is a suggested virtual address for  *	the mapping. Architectures which can support a direct-mapped  *	physical to virtual region can return the appropriate address  *	within that region, leaving '*virt' unchanged. Other  *	architectures should map the pages starting at '*virt' and  *	update '*virt' with the first usable address after the mapped  *	region.  */
end_comment

begin_function
name|vm_offset_t
name|pmap_map
parameter_list|(
name|vm_offset_t
modifier|*
name|virt
parameter_list|,
name|vm_offset_t
name|start
parameter_list|,
name|vm_offset_t
name|end
parameter_list|,
name|int
name|prot
parameter_list|)
block|{
return|return
name|ALPHA_PHYS_TO_K0SEG
argument_list|(
name|start
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/***************************************************  * Page table page management routines.....  ***************************************************/
end_comment

begin_comment
comment|/*  * This routine unholds page table pages, and if the hold count  * drops to zero, then it decrements the wire count.  */
end_comment

begin_function
specifier|static
name|PMAP_INLINE
name|int
name|pmap_unwire_pte_hold
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|m
parameter_list|)
block|{
operator|--
name|m
operator|->
name|wire_count
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|wire_count
operator|==
literal|0
condition|)
return|return
name|_pmap_unwire_pte_hold
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|m
argument_list|)
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|_pmap_unwire_pte_hold
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|m
parameter_list|)
block|{
name|vm_offset_t
name|pteva
decl_stmt|;
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
comment|/* 	 * unmap the page table page 	 */
if|if
condition|(
name|m
operator|->
name|pindex
operator|>=
name|NUSERLEV3MAPS
condition|)
block|{
comment|/* Level 2 page table */
name|pte
operator|=
name|pmap_lev1pte
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|pteva
operator|=
operator|(
name|vm_offset_t
operator|)
name|PTlev2
operator|+
name|alpha_ptob
argument_list|(
name|m
operator|->
name|pindex
operator|-
name|NUSERLEV3MAPS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Level 3 page table */
name|pte
operator|=
name|pmap_lev2pte
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|pteva
operator|=
operator|(
name|vm_offset_t
operator|)
name|PTmap
operator|+
name|alpha_ptob
argument_list|(
name|m
operator|->
name|pindex
argument_list|)
expr_stmt|;
block|}
operator|*
name|pte
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|pindex
operator|<
name|NUSERLEV3MAPS
condition|)
block|{
comment|/* unhold the level 2 page table */
name|vm_page_t
name|lev2pg
decl_stmt|;
name|lev2pg
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pmap_pte_pa
argument_list|(
name|pmap_lev1pte
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|pmap_unwire_pte_hold
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|lev2pg
argument_list|)
expr_stmt|;
block|}
operator|--
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
expr_stmt|;
comment|/* 	 * Do a invltlb to make the invalidated mapping 	 * take effect immediately. 	 */
name|pmap_invalidate_page
argument_list|(
name|pmap
argument_list|,
name|pteva
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap
operator|->
name|pm_ptphint
operator|==
name|m
condition|)
name|pmap
operator|->
name|pm_ptphint
operator|=
name|NULL
expr_stmt|;
name|vm_page_free_zero
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|cnt
operator|.
name|v_wire_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * After removing a page table entry, this routine is used to  * conditionally free the page, and manage the hold/wire counts.  */
end_comment

begin_function
specifier|static
name|int
name|pmap_unuse_pt
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|mpte
parameter_list|)
block|{
name|unsigned
name|ptepindex
decl_stmt|;
if|if
condition|(
name|va
operator|>=
name|VM_MAXUSER_ADDRESS
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|mpte
operator|==
name|NULL
condition|)
block|{
name|ptepindex
operator|=
operator|(
name|va
operator|>>
name|ALPHA_L2SHIFT
operator|)
expr_stmt|;
if|if
condition|(
name|pmap
operator|->
name|pm_ptphint
operator|&&
operator|(
name|pmap
operator|->
name|pm_ptphint
operator|->
name|pindex
operator|==
name|ptepindex
operator|)
condition|)
block|{
name|mpte
operator|=
name|pmap
operator|->
name|pm_ptphint
expr_stmt|;
block|}
else|else
block|{
name|mpte
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pmap_pte_pa
argument_list|(
name|pmap_lev2pte
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|pmap
operator|->
name|pm_ptphint
operator|=
name|mpte
expr_stmt|;
block|}
block|}
return|return
name|pmap_unwire_pte_hold
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|mpte
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|pmap_pinit0
parameter_list|(
name|pmap
parameter_list|)
name|struct
name|pmap
modifier|*
name|pmap
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|PMAP_LOCK_INIT
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|pmap
operator|->
name|pm_lev1
operator|=
name|Lev1map
expr_stmt|;
name|pmap
operator|->
name|pm_ptphint
operator|=
name|NULL
expr_stmt|;
name|pmap
operator|->
name|pm_active
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXCPU
condition|;
name|i
operator|++
control|)
block|{
name|pmap
operator|->
name|pm_asn
index|[
name|i
index|]
operator|.
name|asn
operator|=
literal|0
expr_stmt|;
name|pmap
operator|->
name|pm_asn
index|[
name|i
index|]
operator|.
name|gen
operator|=
literal|0
expr_stmt|;
block|}
name|TAILQ_INIT
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvlist
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|pmap
operator|->
name|pm_stats
argument_list|,
sizeof|sizeof
name|pmap
operator|->
name|pm_stats
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|allpmaps_lock
argument_list|,
literal|"allpmaps"
argument_list|,
name|NULL
argument_list|,
name|MTX_SPIN
operator||
name|MTX_QUIET
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|allpmaps
argument_list|,
name|pmap
argument_list|,
name|pm_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize a preallocated and zeroed pmap structure,  * such as one in a vmspace structure.  */
end_comment

begin_function
name|void
name|pmap_pinit
parameter_list|(
name|pmap
parameter_list|)
specifier|register
name|struct
name|pmap
modifier|*
name|pmap
decl_stmt|;
block|{
name|vm_page_t
name|lev1pg
decl_stmt|;
name|int
name|i
decl_stmt|;
name|PMAP_LOCK_INIT
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
comment|/* 	 * allocate the page directory page 	 */
while|while
condition|(
operator|(
name|lev1pg
operator|=
name|vm_page_alloc
argument_list|(
name|NULL
argument_list|,
name|NUSERLEV3MAPS
operator|+
name|NUSERLEV2MAPS
argument_list|,
name|VM_ALLOC_NOOBJ
operator||
name|VM_ALLOC_NORMAL
operator||
name|VM_ALLOC_WIRED
operator||
name|VM_ALLOC_ZERO
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|VM_WAIT
expr_stmt|;
name|pmap
operator|->
name|pm_lev1
operator|=
operator|(
name|pt_entry_t
operator|*
operator|)
name|ALPHA_PHYS_TO_K0SEG
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|lev1pg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lev1pg
operator|->
name|flags
operator|&
name|PG_ZERO
operator|)
operator|==
literal|0
condition|)
name|bzero
argument_list|(
name|pmap
operator|->
name|pm_lev1
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
comment|/* install self-referential address mapping entry (not PG_ASM) */
name|pmap
operator|->
name|pm_lev1
index|[
name|PTLEV1I
index|]
operator|=
name|pmap_phys_to_pte
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|lev1pg
argument_list|)
argument_list|)
operator||
name|PG_V
operator||
name|PG_KRE
operator||
name|PG_KWE
expr_stmt|;
name|pmap
operator|->
name|pm_ptphint
operator|=
name|NULL
expr_stmt|;
name|pmap
operator|->
name|pm_active
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXCPU
condition|;
name|i
operator|++
control|)
block|{
name|pmap
operator|->
name|pm_asn
index|[
name|i
index|]
operator|.
name|asn
operator|=
literal|0
expr_stmt|;
name|pmap
operator|->
name|pm_asn
index|[
name|i
index|]
operator|.
name|gen
operator|=
literal|0
expr_stmt|;
block|}
name|TAILQ_INIT
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvlist
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|pmap
operator|->
name|pm_stats
argument_list|,
sizeof|sizeof
name|pmap
operator|->
name|pm_stats
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|allpmaps_lock
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|allpmaps
argument_list|,
name|pmap
argument_list|,
name|pm_list
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|allpmaps_lock
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|PTlev1
operator|+
name|K1SEGLEV1I
argument_list|,
name|pmap
operator|->
name|pm_lev1
operator|+
name|K1SEGLEV1I
argument_list|,
name|nklev2
operator|*
name|PTESIZE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * this routine is called if the page table page is not  * mapped correctly.  */
end_comment

begin_function
specifier|static
name|vm_page_t
name|_pmap_allocpte
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|unsigned
name|ptepindex
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
name|vm_offset_t
name|ptepa
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|flags
operator|&
operator|(
name|M_NOWAIT
operator||
name|M_WAITOK
operator|)
operator|)
operator|==
name|M_NOWAIT
operator|||
operator|(
name|flags
operator|&
operator|(
name|M_NOWAIT
operator||
name|M_WAITOK
operator|)
operator|)
operator|==
name|M_WAITOK
argument_list|,
operator|(
literal|"_pmap_allocpte: flags is neither M_NOWAIT nor M_WAITOK"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Find or fabricate a new pagetable page 	 */
if|if
condition|(
operator|(
name|m
operator|=
name|vm_page_alloc
argument_list|(
name|NULL
argument_list|,
name|ptepindex
argument_list|,
name|VM_ALLOC_NOOBJ
operator||
name|VM_ALLOC_WIRED
operator||
name|VM_ALLOC_ZERO
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|M_WAITOK
condition|)
block|{
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
name|VM_WAIT
expr_stmt|;
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Indicate the need to retry.  While waiting, the page table 		 * page may have been allocated. 		 */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_ZERO
operator|)
operator|==
literal|0
condition|)
name|pmap_zero_page
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* 	 * Map the pagetable page into the process address space, if 	 * it isn't already there. 	 */
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|++
expr_stmt|;
name|ptepa
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptepindex
operator|>=
name|NUSERLEV3MAPS
condition|)
block|{
name|pte
operator|=
operator|&
name|pmap
operator|->
name|pm_lev1
index|[
name|ptepindex
operator|-
name|NUSERLEV3MAPS
index|]
expr_stmt|;
block|}
else|else
block|{
name|int
name|l1index
init|=
name|ptepindex
operator|>>
name|ALPHA_PTSHIFT
decl_stmt|;
name|pt_entry_t
modifier|*
name|l1pte
init|=
operator|&
name|pmap
operator|->
name|pm_lev1
index|[
name|l1index
index|]
decl_stmt|;
name|pt_entry_t
modifier|*
name|l2map
decl_stmt|;
if|if
condition|(
operator|!
name|pmap_pte_v
argument_list|(
name|l1pte
argument_list|)
condition|)
block|{
if|if
condition|(
name|_pmap_allocpte
argument_list|(
name|pmap
argument_list|,
name|NUSERLEV3MAPS
operator|+
name|l1index
argument_list|,
name|flags
argument_list|)
operator|==
name|NULL
condition|)
block|{
operator|--
name|m
operator|->
name|wire_count
expr_stmt|;
name|vm_page_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
else|else
block|{
name|vm_page_t
name|l2page
decl_stmt|;
name|l2page
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pmap_pte_pa
argument_list|(
name|l1pte
argument_list|)
argument_list|)
expr_stmt|;
name|l2page
operator|->
name|wire_count
operator|++
expr_stmt|;
block|}
name|l2map
operator|=
operator|(
name|pt_entry_t
operator|*
operator|)
name|ALPHA_PHYS_TO_K0SEG
argument_list|(
name|pmap_pte_pa
argument_list|(
name|l1pte
argument_list|)
argument_list|)
expr_stmt|;
name|pte
operator|=
operator|&
name|l2map
index|[
name|ptepindex
operator|&
operator|(
operator|(
literal|1
operator|<<
name|ALPHA_PTSHIFT
operator|)
operator|-
literal|1
operator|)
index|]
expr_stmt|;
block|}
operator|*
name|pte
operator|=
name|pmap_phys_to_pte
argument_list|(
name|ptepa
argument_list|)
operator||
name|PG_KRE
operator||
name|PG_KWE
operator||
name|PG_V
expr_stmt|;
comment|/* 	 * Set the page table hint 	 */
name|pmap
operator|->
name|pm_ptphint
operator|=
name|m
expr_stmt|;
return|return
name|m
return|;
block|}
end_function

begin_function
specifier|static
name|vm_page_t
name|pmap_allocpte
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|unsigned
name|ptepindex
decl_stmt|;
name|pt_entry_t
modifier|*
name|lev2pte
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
comment|/* 	 * Calculate pagetable page index 	 */
name|ptepindex
operator|=
name|va
operator|>>
operator|(
name|PAGE_SHIFT
operator|+
name|ALPHA_PTSHIFT
operator|)
expr_stmt|;
name|retry
label|:
comment|/* 	 * Get the level2 entry 	 */
name|lev2pte
operator|=
name|pmap_lev2pte
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
comment|/* 	 * If the page table page is mapped, we just increment the 	 * hold count, and activate it. 	 */
if|if
condition|(
name|lev2pte
operator|&&
name|pmap_pte_v
argument_list|(
name|lev2pte
argument_list|)
condition|)
block|{
comment|/* 		 * In order to get the page table page, try the 		 * hint first. 		 */
if|if
condition|(
name|pmap
operator|->
name|pm_ptphint
operator|&&
operator|(
name|pmap
operator|->
name|pm_ptphint
operator|->
name|pindex
operator|==
name|ptepindex
operator|)
condition|)
block|{
name|m
operator|=
name|pmap
operator|->
name|pm_ptphint
expr_stmt|;
block|}
else|else
block|{
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pmap_pte_pa
argument_list|(
name|lev2pte
argument_list|)
argument_list|)
expr_stmt|;
name|pmap
operator|->
name|pm_ptphint
operator|=
name|m
expr_stmt|;
block|}
name|m
operator|->
name|wire_count
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Here if the pte page isn't mapped, or if it has been 		 * deallocated. 		 */
name|m
operator|=
name|_pmap_allocpte
argument_list|(
name|pmap
argument_list|,
name|ptepindex
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
goto|goto
name|retry
goto|;
block|}
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_comment
comment|/*************************************************** * Pmap allocation/deallocation routines.  ***************************************************/
end_comment

begin_comment
comment|/*  * Release any resources held by the given physical map.  * Called when a pmap initialized by pmap_pinit is being released.  * Should only be called if the map contains no valid mappings.  */
end_comment

begin_function
name|void
name|pmap_release
parameter_list|(
name|pmap_t
name|pmap
parameter_list|)
block|{
name|vm_page_t
name|lev1pg
decl_stmt|;
name|KASSERT
argument_list|(
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_release: pmap resident count %ld != 0"
operator|,
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|)
argument_list|)
expr_stmt|;
name|lev1pg
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pmap_pte_pa
argument_list|(
operator|&
name|pmap
operator|->
name|pm_lev1
index|[
name|PTLEV1I
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|lev1pg
operator|->
name|pindex
operator|==
name|NUSERLEV3MAPS
operator|+
name|NUSERLEV2MAPS
argument_list|,
operator|(
literal|"pmap_release: PTLEV1I page has unexpected pindex %ld"
operator|,
name|lev1pg
operator|->
name|pindex
operator|)
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|allpmaps_lock
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|pmap
argument_list|,
name|pm_list
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|allpmaps_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Level1  pages need to have the kernel 	 * stuff cleared, so they can go into the zero queue also. 	 */
name|bzero
argument_list|(
name|pmap
operator|->
name|pm_lev1
operator|+
name|K1SEGLEV1I
argument_list|,
name|nklev2
operator|*
name|PTESIZE
argument_list|)
expr_stmt|;
name|pmap
operator|->
name|pm_lev1
index|[
name|PTLEV1I
index|]
operator|=
literal|0
expr_stmt|;
name|PMAP_LOCK_DESTROY
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
name|lev1pg
operator|->
name|wire_count
operator|--
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|cnt
operator|.
name|v_wire_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vm_page_free_zero
argument_list|(
name|lev1pg
argument_list|)
expr_stmt|;
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * grow the number of kernel page table entries, if needed  */
end_comment

begin_function
name|void
name|pmap_growkernel
parameter_list|(
name|vm_offset_t
name|addr
parameter_list|)
block|{
comment|/* XXX come back to this */
name|struct
name|pmap
modifier|*
name|pmap
decl_stmt|;
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
name|pt_entry_t
name|newlev1
decl_stmt|,
name|newlev2
decl_stmt|;
name|vm_offset_t
name|pa
decl_stmt|;
name|vm_page_t
name|nkpg
decl_stmt|;
name|critical_enter
argument_list|()
expr_stmt|;
if|if
condition|(
name|kernel_vm_end
operator|==
literal|0
condition|)
block|{
name|kernel_vm_end
operator|=
name|VM_MIN_KERNEL_ADDRESS
expr_stmt|;
empty_stmt|;
comment|/* Count the level 2 page tables */
name|nklev2
operator|=
literal|0
expr_stmt|;
name|nklev3
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|pmap_pte_v
argument_list|(
name|pmap_lev1pte
argument_list|(
name|kernel_pmap
argument_list|,
name|kernel_vm_end
argument_list|)
argument_list|)
condition|)
block|{
name|nklev2
operator|++
expr_stmt|;
name|nklev3
operator|+=
operator|(
literal|1L
operator|<<
name|ALPHA_PTSHIFT
operator|)
expr_stmt|;
name|kernel_vm_end
operator|+=
name|ALPHA_L1SIZE
expr_stmt|;
block|}
comment|/* Count the level 3 page tables in the last level 2 page table */
name|kernel_vm_end
operator|-=
name|ALPHA_L1SIZE
expr_stmt|;
name|nklev3
operator|-=
operator|(
literal|1
operator|<<
name|ALPHA_PTSHIFT
operator|)
expr_stmt|;
while|while
condition|(
name|pmap_pte_v
argument_list|(
name|pmap_lev2pte
argument_list|(
name|kernel_pmap
argument_list|,
name|kernel_vm_end
argument_list|)
argument_list|)
condition|)
block|{
name|nklev3
operator|++
expr_stmt|;
name|kernel_vm_end
operator|+=
name|ALPHA_L2SIZE
expr_stmt|;
block|}
block|}
name|addr
operator|=
operator|(
name|addr
operator|+
name|ALPHA_L2SIZE
operator|)
operator|&
operator|~
operator|(
name|ALPHA_L2SIZE
operator|-
literal|1
operator|)
expr_stmt|;
while|while
condition|(
name|kernel_vm_end
operator|<
name|addr
condition|)
block|{
comment|/* 		 * If the level 1 pte is invalid, allocate a new level 2 page table 		 */
name|pte
operator|=
name|pmap_lev1pte
argument_list|(
name|kernel_pmap
argument_list|,
name|kernel_vm_end
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pmap_pte_v
argument_list|(
name|pte
argument_list|)
condition|)
block|{
name|int
name|pindex
init|=
name|NKLEV3MAPS
operator|+
name|pmap_lev1_index
argument_list|(
name|kernel_vm_end
argument_list|)
operator|-
name|K1SEGLEV1I
decl_stmt|;
name|nkpg
operator|=
name|vm_page_alloc
argument_list|(
name|NULL
argument_list|,
name|pindex
argument_list|,
name|VM_ALLOC_NOOBJ
operator||
name|VM_ALLOC_INTERRUPT
operator||
name|VM_ALLOC_WIRED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nkpg
condition|)
name|panic
argument_list|(
literal|"pmap_growkernel: no memory to grow kernel"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"pmap_growkernel: growing to %lx\n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"pmap_growkernel: adding new level2 page table\n"
argument_list|)
expr_stmt|;
name|nklev2
operator|++
expr_stmt|;
name|pmap_zero_page
argument_list|(
name|nkpg
argument_list|)
expr_stmt|;
name|pa
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|nkpg
argument_list|)
expr_stmt|;
name|newlev1
operator|=
name|pmap_phys_to_pte
argument_list|(
name|pa
argument_list|)
operator||
name|PG_V
operator||
name|PG_ASM
operator||
name|PG_KRE
operator||
name|PG_KWE
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|allpmaps_lock
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|pmap
argument_list|,
argument|&allpmaps
argument_list|,
argument|pm_list
argument_list|)
block|{
operator|*
name|pmap_lev1pte
argument_list|(
name|pmap
argument_list|,
name|kernel_vm_end
argument_list|)
operator|=
name|newlev1
expr_stmt|;
block|}
name|mtx_unlock_spin
argument_list|(
operator|&
name|allpmaps_lock
argument_list|)
expr_stmt|;
operator|*
name|pte
operator|=
name|newlev1
expr_stmt|;
name|pmap_invalidate_all
argument_list|(
name|kernel_pmap
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If the level 2 pte is invalid, allocate a new level 3 page table 		 */
name|pte
operator|=
name|pmap_lev2pte
argument_list|(
name|kernel_pmap
argument_list|,
name|kernel_vm_end
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap_pte_v
argument_list|(
name|pte
argument_list|)
condition|)
block|{
name|kernel_vm_end
operator|=
operator|(
name|kernel_vm_end
operator|+
name|ALPHA_L2SIZE
operator|)
operator|&
operator|~
operator|(
name|ALPHA_L2SIZE
operator|-
literal|1
operator|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * This index is bogus, but out of the way 		 */
name|nkpg
operator|=
name|vm_page_alloc
argument_list|(
name|NULL
argument_list|,
name|nklev3
argument_list|,
name|VM_ALLOC_NOOBJ
operator||
name|VM_ALLOC_INTERRUPT
operator||
name|VM_ALLOC_WIRED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nkpg
condition|)
name|panic
argument_list|(
literal|"pmap_growkernel: no memory to grow kernel"
argument_list|)
expr_stmt|;
name|nklev3
operator|++
expr_stmt|;
name|pmap_zero_page
argument_list|(
name|nkpg
argument_list|)
expr_stmt|;
name|pa
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|nkpg
argument_list|)
expr_stmt|;
name|newlev2
operator|=
name|pmap_phys_to_pte
argument_list|(
name|pa
argument_list|)
operator||
name|PG_V
operator||
name|PG_ASM
operator||
name|PG_KRE
operator||
name|PG_KWE
expr_stmt|;
operator|*
name|pte
operator|=
name|newlev2
expr_stmt|;
name|kernel_vm_end
operator|=
operator|(
name|kernel_vm_end
operator|+
name|ALPHA_L2SIZE
operator|)
operator|&
operator|~
operator|(
name|ALPHA_L2SIZE
operator|-
literal|1
operator|)
expr_stmt|;
block|}
name|critical_exit
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/***************************************************  * page management routines.  ***************************************************/
end_comment

begin_comment
comment|/*  * free the pv_entry back to the free list  */
end_comment

begin_function
specifier|static
name|PMAP_INLINE
name|void
name|free_pv_entry
parameter_list|(
name|pv_entry_t
name|pv
parameter_list|)
block|{
name|pv_entry_count
operator|--
expr_stmt|;
name|uma_zfree
argument_list|(
name|pvzone
argument_list|,
name|pv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * get a new pv_entry, allocating a block from the system  * when needed.  */
end_comment

begin_function
specifier|static
name|pv_entry_t
name|get_pv_entry
parameter_list|(
name|pmap_t
name|locked_pmap
parameter_list|)
block|{
specifier|static
specifier|const
name|struct
name|timeval
name|printinterval
init|=
block|{
literal|60
block|,
literal|0
block|}
decl_stmt|;
specifier|static
name|struct
name|timeval
name|lastprint
decl_stmt|;
name|struct
name|vpgqueues
modifier|*
name|vpq
decl_stmt|;
name|pmap_t
name|pmap
decl_stmt|;
name|pt_entry_t
modifier|*
name|pte
decl_stmt|,
name|tpte
decl_stmt|;
name|pv_entry_t
name|allocated_pv
decl_stmt|,
name|next_pv
decl_stmt|,
name|pv
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|PMAP_LOCK_ASSERT
argument_list|(
name|locked_pmap
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|vm_page_queue_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|allocated_pv
operator|=
name|uma_zalloc
argument_list|(
name|pvzone
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|allocated_pv
operator|!=
name|NULL
condition|)
block|{
name|pv_entry_count
operator|++
expr_stmt|;
if|if
condition|(
name|pv_entry_count
operator|>
name|pv_entry_high_water
condition|)
name|pagedaemon_wakeup
argument_list|()
expr_stmt|;
else|else
return|return
operator|(
name|allocated_pv
operator|)
return|;
block|}
comment|/* 	 * Reclaim pv entries: At first, destroy mappings to inactive 	 * pages.  After that, if a pv entry is still needed, destroy 	 * mappings to active pages. 	 */
if|if
condition|(
name|ratecheck
argument_list|(
operator|&
name|lastprint
argument_list|,
operator|&
name|printinterval
argument_list|)
condition|)
name|printf
argument_list|(
literal|"Approaching the limit on PV entries, "
literal|"increase the vm.pmap.shpgperproc tunable.\n"
argument_list|)
expr_stmt|;
name|vpq
operator|=
operator|&
name|vm_page_queues
index|[
name|PQ_INACTIVE
index|]
expr_stmt|;
name|retry
label|:
name|TAILQ_FOREACH
argument_list|(
argument|m
argument_list|,
argument|&vpq->pl
argument_list|,
argument|pageq
argument_list|)
block|{
if|if
condition|(
name|m
operator|->
name|hold_count
operator|||
name|m
operator|->
name|busy
operator|||
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_BUSY
operator|)
condition|)
continue|continue;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|pv
argument_list|,
argument|&m->md.pv_list
argument_list|,
argument|pv_list
argument_list|,
argument|next_pv
argument_list|)
block|{
name|va
operator|=
name|pv
operator|->
name|pv_va
expr_stmt|;
name|pmap
operator|=
name|pv
operator|->
name|pv_pmap
expr_stmt|;
comment|/* Avoid deadlock and lock recursion. */
if|if
condition|(
name|pmap
operator|>
name|locked_pmap
condition|)
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pmap
operator|!=
name|locked_pmap
operator|&&
operator|!
name|PMAP_TRYLOCK
argument_list|(
name|pmap
argument_list|)
condition|)
continue|continue;
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|--
expr_stmt|;
name|pte
operator|=
name|pmap_lev3pte
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|tpte
operator|=
operator|*
name|pte
expr_stmt|;
operator|*
name|pte
operator|=
literal|0
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|tpte
operator|&
name|PG_W
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"get_pv_entry: wired pte %#lx"
operator|,
name|tpte
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tpte
operator|&
name|PG_FOR
operator|)
operator|==
literal|0
condition|)
name|vm_page_flag_set
argument_list|(
name|m
argument_list|,
name|PG_REFERENCED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tpte
operator|&
name|PG_FOW
operator|)
operator|==
literal|0
condition|)
name|vm_page_dirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|pmap_invalidate_page
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvlist
argument_list|,
name|pv
argument_list|,
name|pv_plist
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|,
name|pv
argument_list|,
name|pv_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|)
condition|)
name|vm_page_flag_clear
argument_list|(
name|m
argument_list|,
name|PG_WRITEABLE
argument_list|)
expr_stmt|;
name|m
operator|->
name|md
operator|.
name|pv_list_count
operator|--
expr_stmt|;
name|pmap_unuse_pt
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|pv
operator|->
name|pv_ptem
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap
operator|!=
name|locked_pmap
condition|)
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|allocated_pv
operator|==
name|NULL
condition|)
name|allocated_pv
operator|=
name|pv
expr_stmt|;
else|else
name|free_pv_entry
argument_list|(
name|pv
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|allocated_pv
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|vpq
operator|==
operator|&
name|vm_page_queues
index|[
name|PQ_INACTIVE
index|]
condition|)
block|{
name|vpq
operator|=
operator|&
name|vm_page_queues
index|[
name|PQ_ACTIVE
index|]
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|panic
argument_list|(
literal|"get_pv_entry: increase the vm.pmap.shpgperproc tunable"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|allocated_pv
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pmap_remove_entry
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_page_t
name|m
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|pv_entry_t
name|pv
decl_stmt|;
name|int
name|rtval
decl_stmt|;
name|PMAP_LOCK_ASSERT
argument_list|(
name|pmap
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|vm_page_queue_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|md
operator|.
name|pv_list_count
operator|<
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&m->md.pv_list
argument_list|,
argument|pv_list
argument_list|)
block|{
if|if
condition|(
name|pmap
operator|==
name|pv
operator|->
name|pv_pmap
operator|&&
name|va
operator|==
name|pv
operator|->
name|pv_va
condition|)
break|break;
block|}
block|}
else|else
block|{
name|TAILQ_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&pmap->pm_pvlist
argument_list|,
argument|pv_plist
argument_list|)
block|{
if|if
condition|(
name|va
operator|==
name|pv
operator|->
name|pv_va
condition|)
break|break;
block|}
block|}
name|rtval
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pv
condition|)
block|{
name|rtval
operator|=
name|pmap_unuse_pt
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|pv
operator|->
name|pv_ptem
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|,
name|pv
argument_list|,
name|pv_list
argument_list|)
expr_stmt|;
name|m
operator|->
name|md
operator|.
name|pv_list_count
operator|--
expr_stmt|;
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|)
operator|==
name|NULL
condition|)
name|vm_page_flag_clear
argument_list|(
name|m
argument_list|,
name|PG_WRITEABLE
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvlist
argument_list|,
name|pv
argument_list|,
name|pv_plist
argument_list|)
expr_stmt|;
name|free_pv_entry
argument_list|(
name|pv
argument_list|)
expr_stmt|;
block|}
return|return
name|rtval
return|;
block|}
end_function

begin_comment
comment|/*  * Create a pv entry for page at pa for  * (pmap, va).  */
end_comment

begin_function
specifier|static
name|void
name|pmap_insert_entry
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|mpte
parameter_list|,
name|vm_page_t
name|m
parameter_list|)
block|{
name|pv_entry_t
name|pv
decl_stmt|;
name|pv
operator|=
name|get_pv_entry
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|pv
operator|->
name|pv_va
operator|=
name|va
expr_stmt|;
name|pv
operator|->
name|pv_pmap
operator|=
name|pmap
expr_stmt|;
name|pv
operator|->
name|pv_ptem
operator|=
name|mpte
expr_stmt|;
name|PMAP_LOCK_ASSERT
argument_list|(
name|pmap
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|vm_page_queue_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvlist
argument_list|,
name|pv
argument_list|,
name|pv_plist
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|,
name|pv
argument_list|,
name|pv_list
argument_list|)
expr_stmt|;
name|m
operator|->
name|md
operator|.
name|pv_list_count
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Conditionally create a pv entry.  */
end_comment

begin_function
specifier|static
name|boolean_t
name|pmap_try_insert_pv_entry
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|mpte
parameter_list|,
name|vm_page_t
name|m
parameter_list|)
block|{
name|pv_entry_t
name|pv
decl_stmt|;
name|PMAP_LOCK_ASSERT
argument_list|(
name|pmap
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|vm_page_queue_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|pv_entry_count
operator|<
name|pv_entry_high_water
operator|&&
operator|(
name|pv
operator|=
name|uma_zalloc
argument_list|(
name|pvzone
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|pv_entry_count
operator|++
expr_stmt|;
name|pv
operator|->
name|pv_va
operator|=
name|va
expr_stmt|;
name|pv
operator|->
name|pv_pmap
operator|=
name|pmap
expr_stmt|;
name|pv
operator|->
name|pv_ptem
operator|=
name|mpte
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvlist
argument_list|,
name|pv
argument_list|,
name|pv_plist
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|,
name|pv
argument_list|,
name|pv_list
argument_list|)
expr_stmt|;
name|m
operator|->
name|md
operator|.
name|pv_list_count
operator|++
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
else|else
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * pmap_remove_pte: do the things to unmap a page in a process  */
end_comment

begin_function
specifier|static
name|int
name|pmap_remove_pte
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|pt_entry_t
modifier|*
name|ptq
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|pt_entry_t
name|oldpte
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|PMAP_LOCK_ASSERT
argument_list|(
name|pmap
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|oldpte
operator|=
operator|*
name|ptq
expr_stmt|;
operator|*
name|ptq
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|oldpte
operator|&
name|PG_W
condition|)
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|-=
literal|1
expr_stmt|;
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|oldpte
operator|&
name|PG_MANAGED
condition|)
block|{
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pmap_pte_pa
argument_list|(
operator|&
name|oldpte
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|oldpte
operator|&
name|PG_FOW
operator|)
operator|==
literal|0
condition|)
name|vm_page_dirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|oldpte
operator|&
name|PG_FOR
operator|)
operator|==
literal|0
condition|)
name|vm_page_flag_set
argument_list|(
name|m
argument_list|,
name|PG_REFERENCED
argument_list|)
expr_stmt|;
return|return
name|pmap_remove_entry
argument_list|(
name|pmap
argument_list|,
name|m
argument_list|,
name|va
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|pmap_unuse_pt
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|NULL
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Remove a single page from a process address space  */
end_comment

begin_function
specifier|static
name|void
name|pmap_remove_page
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
specifier|register
name|pt_entry_t
modifier|*
name|ptq
decl_stmt|;
name|PMAP_LOCK_ASSERT
argument_list|(
name|pmap
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|ptq
operator|=
name|pmap_lev3pte
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
comment|/* 	 * if there is no pte for this address, just skip it!!! 	 */
if|if
condition|(
operator|!
name|ptq
operator|||
operator|!
name|pmap_pte_v
argument_list|(
name|ptq
argument_list|)
condition|)
return|return;
comment|/* 	 * get a local va for mappings for this pmap. 	 */
operator|(
name|void
operator|)
name|pmap_remove_pte
argument_list|(
name|pmap
argument_list|,
name|ptq
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|pmap_invalidate_page
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Remove the given range of addresses from the specified map.  *  *	It is assumed that the start and end are properly  *	rounded to the page size.  */
end_comment

begin_function
name|void
name|pmap_remove
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|sva
parameter_list|,
name|vm_offset_t
name|eva
parameter_list|)
block|{
name|vm_offset_t
name|va
decl_stmt|,
name|nva
decl_stmt|;
comment|/* 	 * Perform an unsynchronized read.  This is, however, safe. 	 */
if|if
condition|(
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|==
literal|0
condition|)
return|return;
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
comment|/* 	 * special handling of removing one page.  a very 	 * common operation and easy to short circuit some 	 * code. 	 */
if|if
condition|(
name|sva
operator|+
name|PAGE_SIZE
operator|==
name|eva
condition|)
block|{
name|pmap_remove_page
argument_list|(
name|pmap
argument_list|,
name|sva
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
for|for
control|(
name|va
operator|=
name|sva
init|;
name|va
operator|<
name|eva
condition|;
name|va
operator|=
name|nva
control|)
block|{
if|if
condition|(
operator|!
name|pmap_pte_v
argument_list|(
name|pmap_lev1pte
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
argument_list|)
condition|)
block|{
name|nva
operator|=
name|alpha_l1trunc
argument_list|(
name|va
operator|+
name|ALPHA_L1SIZE
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|pmap_pte_v
argument_list|(
name|pmap_lev2pte
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
argument_list|)
condition|)
block|{
name|nva
operator|=
name|alpha_l2trunc
argument_list|(
name|va
operator|+
name|ALPHA_L2SIZE
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|pmap_remove_page
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|nva
operator|=
name|va
operator|+
name|PAGE_SIZE
expr_stmt|;
block|}
name|out
label|:
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Routine:	pmap_remove_all  *	Function:  *		Removes this physical page from  *		all physical maps in which it resides.  *		Reflects back modify bits to the pager.  *  *	Notes:  *		Original versions of this routine were very  *		inefficient because they iteratively called  *		pmap_remove (slow...)  */
end_comment

begin_function
name|void
name|pmap_remove_all
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
specifier|register
name|pv_entry_t
name|pv
decl_stmt|;
name|pt_entry_t
modifier|*
name|pte
decl_stmt|,
name|tpte
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|PMAP_DIAGNOSTIC
argument_list|)
comment|/* 	 * XXX this makes pmap_page_protect(NONE) illegal for non-managed 	 * pages! 	 */
if|if
condition|(
name|m
operator|->
name|flags
operator|&
name|PG_FICTITIOUS
condition|)
block|{
name|panic
argument_list|(
literal|"pmap_page_protect: illegal for unmanaged page, va: 0x%lx"
argument_list|,
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
while|while
condition|(
operator|(
name|pv
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|PMAP_LOCK
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|)
expr_stmt|;
name|pte
operator|=
name|pmap_lev3pte
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
name|pv
operator|->
name|pv_pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|--
expr_stmt|;
if|if
condition|(
name|pmap_pte_pa
argument_list|(
name|pte
argument_list|)
operator|!=
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
condition|)
name|panic
argument_list|(
literal|"pmap_remove_all: pv_table for %lx is inconsistent"
argument_list|,
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|tpte
operator|=
operator|*
name|pte
expr_stmt|;
operator|*
name|pte
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tpte
operator|&
name|PG_W
condition|)
name|pv
operator|->
name|pv_pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|--
expr_stmt|;
comment|/* 		 * Update the vm_page_t clean and reference bits. 		 */
if|if
condition|(
operator|(
name|tpte
operator|&
name|PG_FOW
operator|)
operator|==
literal|0
condition|)
name|vm_page_dirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tpte
operator|&
name|PG_FOR
operator|)
operator|==
literal|0
condition|)
name|vm_page_flag_set
argument_list|(
name|m
argument_list|,
name|PG_REFERENCED
argument_list|)
expr_stmt|;
name|pmap_invalidate_page
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pv
operator|->
name|pv_pmap
operator|->
name|pm_pvlist
argument_list|,
name|pv
argument_list|,
name|pv_plist
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|,
name|pv
argument_list|,
name|pv_list
argument_list|)
expr_stmt|;
name|m
operator|->
name|md
operator|.
name|pv_list_count
operator|--
expr_stmt|;
name|pmap_unuse_pt
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|,
name|pv
operator|->
name|pv_ptem
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|)
expr_stmt|;
name|free_pv_entry
argument_list|(
name|pv
argument_list|)
expr_stmt|;
block|}
name|vm_page_flag_clear
argument_list|(
name|m
argument_list|,
name|PG_WRITEABLE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Set the physical protection on the  *	specified range of this map as requested.  */
end_comment

begin_function
name|void
name|pmap_protect
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|sva
parameter_list|,
name|vm_offset_t
name|eva
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|)
block|{
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
name|int
name|newprot
decl_stmt|;
if|if
condition|(
operator|(
name|prot
operator|&
name|VM_PROT_READ
operator|)
operator|==
name|VM_PROT_NONE
condition|)
block|{
name|pmap_remove
argument_list|(
name|pmap
argument_list|,
name|sva
argument_list|,
name|eva
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|prot
operator|&
name|VM_PROT_WRITE
condition|)
return|return;
name|newprot
operator|=
name|pte_prot
argument_list|(
name|pmap
argument_list|,
name|prot
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sva
operator|&
name|PAGE_MASK
operator|)
operator|||
operator|(
name|eva
operator|&
name|PAGE_MASK
operator|)
condition|)
name|panic
argument_list|(
literal|"pmap_protect: unaligned addresses"
argument_list|)
expr_stmt|;
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
while|while
condition|(
name|sva
operator|<
name|eva
condition|)
block|{
comment|/* 		 * If level 1 pte is invalid, skip this segment 		 */
name|pte
operator|=
name|pmap_lev1pte
argument_list|(
name|pmap
argument_list|,
name|sva
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pmap_pte_v
argument_list|(
name|pte
argument_list|)
condition|)
block|{
name|sva
operator|=
name|alpha_l1trunc
argument_list|(
name|sva
argument_list|)
operator|+
name|ALPHA_L1SIZE
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * If level 2 pte is invalid, skip this segment 		 */
name|pte
operator|=
name|pmap_lev2pte
argument_list|(
name|pmap
argument_list|,
name|sva
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pmap_pte_v
argument_list|(
name|pte
argument_list|)
condition|)
block|{
name|sva
operator|=
name|alpha_l2trunc
argument_list|(
name|sva
argument_list|)
operator|+
name|ALPHA_L2SIZE
expr_stmt|;
continue|continue;
block|}
comment|/*  		 * If level 3 pte is invalid, skip this page 		 */
name|pte
operator|=
name|pmap_lev3pte
argument_list|(
name|pmap
argument_list|,
name|sva
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pmap_pte_v
argument_list|(
name|pte
argument_list|)
condition|)
block|{
name|sva
operator|+=
name|PAGE_SIZE
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|pmap_pte_prot
argument_list|(
name|pte
argument_list|)
operator|!=
name|newprot
condition|)
block|{
name|pt_entry_t
name|oldpte
init|=
operator|*
name|pte
decl_stmt|;
name|vm_page_t
name|m
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|(
name|oldpte
operator|&
name|PG_FOR
operator|)
operator|==
literal|0
condition|)
block|{
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pmap_pte_pa
argument_list|(
name|pte
argument_list|)
argument_list|)
expr_stmt|;
name|vm_page_flag_set
argument_list|(
name|m
argument_list|,
name|PG_REFERENCED
argument_list|)
expr_stmt|;
name|oldpte
operator||=
operator|(
name|PG_FOR
operator||
name|PG_FOE
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|oldpte
operator|&
name|PG_FOW
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pmap_pte_pa
argument_list|(
name|pte
argument_list|)
argument_list|)
expr_stmt|;
name|vm_page_dirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|oldpte
operator||=
name|PG_FOW
expr_stmt|;
block|}
name|oldpte
operator|=
operator|(
name|oldpte
operator|&
operator|~
name|PG_PROT
operator|)
operator||
name|newprot
expr_stmt|;
operator|*
name|pte
operator|=
name|oldpte
expr_stmt|;
name|pmap_invalidate_page
argument_list|(
name|pmap
argument_list|,
name|sva
argument_list|)
expr_stmt|;
block|}
name|sva
operator|+=
name|PAGE_SIZE
expr_stmt|;
block|}
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Insert the given physical page (p) at  *	the specified virtual address (v) in the  *	target physical map with the protection requested.  *  *	If specified, the page will be wired down, meaning  *	that the related pte can not be reclaimed.  *  *	NB:  This is the only routine which MAY NOT lazy-evaluate  *	or lose information.  That is, this routine must actually  *	insert this page into the given map NOW.  */
end_comment

begin_function
name|void
name|pmap_enter
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|m
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|,
name|boolean_t
name|wired
parameter_list|)
block|{
name|vm_offset_t
name|pa
decl_stmt|;
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
name|vm_offset_t
name|opa
decl_stmt|;
name|pt_entry_t
name|origpte
decl_stmt|,
name|newpte
decl_stmt|;
name|vm_page_t
name|mpte
decl_stmt|;
name|int
name|managed
decl_stmt|;
name|va
operator|&=
operator|~
name|PAGE_MASK
expr_stmt|;
ifdef|#
directive|ifdef
name|PMAP_DIAGNOSTIC
if|if
condition|(
name|va
operator|>
name|VM_MAX_KERNEL_ADDRESS
condition|)
name|panic
argument_list|(
literal|"pmap_enter: toobig"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mpte
operator|=
name|NULL
expr_stmt|;
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
comment|/* 	 * In the case that a page table page is not 	 * resident, we are creating it here. 	 */
if|if
condition|(
name|va
operator|<
name|VM_MAXUSER_ADDRESS
condition|)
block|{
name|mpte
operator|=
name|pmap_allocpte
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
block|}
name|pte
operator|=
name|pmap_lev3pte
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
comment|/* 	 * Page Directory table entry not valid, we need a new PT page 	 */
if|if
condition|(
name|pte
operator|==
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"pmap_enter: invalid kernel page tables pmap=%p, va=0x%lx\n"
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
block|}
name|origpte
operator|=
operator|*
name|pte
expr_stmt|;
name|pa
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|managed
operator|=
literal|0
expr_stmt|;
name|opa
operator|=
name|pmap_pte_pa
argument_list|(
name|pte
argument_list|)
expr_stmt|;
comment|/* 	 * Mapping has not changed, must be protection or wiring change. 	 */
if|if
condition|(
name|origpte
operator|&&
operator|(
name|opa
operator|==
name|pa
operator|)
condition|)
block|{
comment|/* 		 * Wiring change, just update stats. We don't worry about 		 * wiring PT pages as they remain resident as long as there 		 * are valid mappings in them. Hence, if a user page is wired, 		 * the PT page will be also. 		 */
if|if
condition|(
name|wired
operator|&&
operator|(
operator|(
name|origpte
operator|&
name|PG_W
operator|)
operator|==
literal|0
operator|)
condition|)
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|wired
operator|&&
operator|(
name|origpte
operator|&
name|PG_W
operator|)
condition|)
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|--
expr_stmt|;
comment|/* 		 * Remove extra pte reference 		 */
if|if
condition|(
name|mpte
condition|)
name|mpte
operator|->
name|wire_count
operator|--
expr_stmt|;
comment|/* 		 * We might be turning off write access to the page, 		 * so we go ahead and sense modify status. 		 */
if|if
condition|(
name|origpte
operator|&
name|PG_MANAGED
condition|)
block|{
if|if
condition|(
operator|(
name|origpte
operator|&
name|PG_FOW
operator|)
operator|!=
name|PG_FOW
condition|)
name|vm_page_dirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|managed
operator|=
name|origpte
operator|&
name|PG_MANAGED
expr_stmt|;
goto|goto
name|validate
goto|;
block|}
comment|/* 	 * Mapping has changed, invalidate old range and fall through to 	 * handle validating new mapping. 	 */
if|if
condition|(
name|opa
condition|)
block|{
name|int
name|err
decl_stmt|;
name|err
operator|=
name|pmap_remove_pte
argument_list|(
name|pmap
argument_list|,
name|pte
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|panic
argument_list|(
literal|"pmap_enter: pte vanished, va: 0x%lx"
argument_list|,
name|va
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Enter on the PV list if part of our managed memory. Note that we 	 * raise IPL while manipulating pv_table since pmap_enter can be 	 * called at interrupt time. 	 */
if|if
condition|(
operator|(
name|m
operator|->
name|flags
operator|&
operator|(
name|PG_FICTITIOUS
operator||
name|PG_UNMANAGED
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|KASSERT
argument_list|(
name|va
operator|<
name|kmi
operator|.
name|clean_sva
operator|||
name|va
operator|>=
name|kmi
operator|.
name|clean_eva
argument_list|,
operator|(
literal|"pmap_enter: managed mapping within the clean submap"
operator|)
argument_list|)
expr_stmt|;
name|pmap_insert_entry
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|mpte
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|managed
operator||=
name|PG_MANAGED
expr_stmt|;
block|}
comment|/* 	 * Increment counters 	 */
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|++
expr_stmt|;
if|if
condition|(
name|wired
condition|)
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|++
expr_stmt|;
name|validate
label|:
comment|/* 	 * Now validate mapping with desired protection/wiring. 	 */
name|newpte
operator|=
name|pmap_phys_to_pte
argument_list|(
name|pa
argument_list|)
operator||
name|pte_prot
argument_list|(
name|pmap
argument_list|,
name|prot
argument_list|)
operator||
name|PG_V
operator||
name|managed
expr_stmt|;
if|if
condition|(
name|managed
condition|)
block|{
comment|/* 		 * Set up referenced/modified emulation for the new 		 * mapping. Any old referenced/modified emulation 		 * results for the old mapping will have been recorded 		 * either in pmap_remove_pte() or above in the code 		 * which handles protection and/or wiring changes. 		 */
name|newpte
operator||=
operator|(
name|PG_FOR
operator||
name|PG_FOW
operator||
name|PG_FOE
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|wired
condition|)
name|newpte
operator||=
name|PG_W
expr_stmt|;
comment|/* 	 * if the mapping or permission bits are different, we need 	 * to update the pte. 	 */
if|if
condition|(
name|origpte
operator|!=
name|newpte
condition|)
block|{
operator|*
name|pte
operator|=
name|newpte
expr_stmt|;
if|if
condition|(
name|origpte
condition|)
name|pmap_invalidate_page
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|prot
operator|&
name|VM_PROT_EXECUTE
condition|)
name|alpha_pal_imb
argument_list|()
expr_stmt|;
block|}
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Maps a sequence of resident pages belonging to the same object.  * The sequence begins with the given page m_start.  This page is  * mapped at the given virtual address start.  Each subsequent page is  * mapped at a virtual address that is offset from start by the same  * amount as the page is offset from m_start within the object.  The  * last page in the sequence is the page with the largest offset from  * m_start that can be mapped at a virtual address less than the given  * virtual address end.  Not every virtual page between start and end  * is mapped; only those for which a resident page exists with the  * corresponding offset from m_start are mapped.  */
end_comment

begin_function
name|void
name|pmap_enter_object
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|start
parameter_list|,
name|vm_offset_t
name|end
parameter_list|,
name|vm_page_t
name|m_start
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|)
block|{
name|vm_page_t
name|m
decl_stmt|,
name|mpte
decl_stmt|;
name|vm_pindex_t
name|diff
decl_stmt|,
name|psize
decl_stmt|;
name|VM_OBJECT_LOCK_ASSERT
argument_list|(
name|m_start
operator|->
name|object
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|psize
operator|=
name|atop
argument_list|(
name|end
operator|-
name|start
argument_list|)
expr_stmt|;
name|mpte
operator|=
name|NULL
expr_stmt|;
name|m
operator|=
name|m_start
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
while|while
condition|(
name|m
operator|!=
name|NULL
operator|&&
operator|(
name|diff
operator|=
name|m
operator|->
name|pindex
operator|-
name|m_start
operator|->
name|pindex
operator|)
operator|<
name|psize
condition|)
block|{
name|mpte
operator|=
name|pmap_enter_quick_locked
argument_list|(
name|pmap
argument_list|,
name|start
operator|+
name|ptoa
argument_list|(
name|diff
argument_list|)
argument_list|,
name|m
argument_list|,
name|prot
argument_list|,
name|mpte
argument_list|)
expr_stmt|;
name|m
operator|=
name|TAILQ_NEXT
argument_list|(
name|m
argument_list|,
name|listq
argument_list|)
expr_stmt|;
block|}
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * this code makes some *MAJOR* assumptions:  * 1. Current pmap& pmap exists.  * 2. Not wired.  * 3. Read access.  * 4. No page table pages.  * but is *MUCH* faster than pmap_enter...  */
end_comment

begin_function
name|vm_page_t
name|pmap_enter_quick
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|m
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|,
name|vm_page_t
name|mpte
parameter_list|)
block|{
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|mpte
operator|=
name|pmap_enter_quick_locked
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|m
argument_list|,
name|prot
argument_list|,
name|mpte
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
return|return
operator|(
name|mpte
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|vm_page_t
name|pmap_enter_quick_locked
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|m
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|,
name|vm_page_t
name|mpte
parameter_list|)
block|{
specifier|register
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
name|int
name|managed
decl_stmt|;
name|KASSERT
argument_list|(
name|va
operator|<
name|kmi
operator|.
name|clean_sva
operator|||
name|va
operator|>=
name|kmi
operator|.
name|clean_eva
operator|||
operator|(
name|m
operator|->
name|flags
operator|&
operator|(
name|PG_FICTITIOUS
operator||
name|PG_UNMANAGED
operator|)
operator|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"pmap_enter_quick_locked: managed mapping within the clean submap"
operator|)
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|vm_page_queue_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|PMAP_LOCK_ASSERT
argument_list|(
name|pmap
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* 	 * In the case that a page table page is not 	 * resident, we are creating it here. 	 */
if|if
condition|(
name|va
operator|<
name|VM_MAXUSER_ADDRESS
condition|)
block|{
name|unsigned
name|ptepindex
decl_stmt|;
name|pt_entry_t
modifier|*
name|l2pte
decl_stmt|;
comment|/* 		 * Calculate lev2 page index 		 */
name|ptepindex
operator|=
name|va
operator|>>
name|ALPHA_L2SHIFT
expr_stmt|;
if|if
condition|(
name|mpte
operator|&&
operator|(
name|mpte
operator|->
name|pindex
operator|==
name|ptepindex
operator|)
condition|)
block|{
name|mpte
operator|->
name|wire_count
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Get the level 2 entry 			 */
name|l2pte
operator|=
name|pmap_lev2pte
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
comment|/* 			 * If the level 2 page table is mapped, we just increment 			 * the hold count, and activate it. 			 */
if|if
condition|(
name|l2pte
operator|&&
name|pmap_pte_v
argument_list|(
name|l2pte
argument_list|)
condition|)
block|{
if|if
condition|(
name|pmap
operator|->
name|pm_ptphint
operator|&&
operator|(
name|pmap
operator|->
name|pm_ptphint
operator|->
name|pindex
operator|==
name|ptepindex
operator|)
condition|)
block|{
name|mpte
operator|=
name|pmap
operator|->
name|pm_ptphint
expr_stmt|;
block|}
else|else
block|{
name|mpte
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pmap_pte_pa
argument_list|(
name|l2pte
argument_list|)
argument_list|)
expr_stmt|;
name|pmap
operator|->
name|pm_ptphint
operator|=
name|mpte
expr_stmt|;
block|}
name|mpte
operator|->
name|wire_count
operator|++
expr_stmt|;
block|}
else|else
block|{
name|mpte
operator|=
name|_pmap_allocpte
argument_list|(
name|pmap
argument_list|,
name|ptepindex
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpte
operator|==
name|NULL
condition|)
return|return
operator|(
name|mpte
operator|)
return|;
block|}
block|}
block|}
else|else
block|{
name|mpte
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * This call to vtopte makes the assumption that we are 	 * entering the page into the current pmap.  In order to support 	 * quick entry into any pmap, one would likely use pmap_pte_quick. 	 * But that isn't as quick as vtopte. 	 */
name|pte
operator|=
name|vtopte
argument_list|(
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pte
condition|)
block|{
if|if
condition|(
name|mpte
operator|!=
name|NULL
condition|)
block|{
name|pmap_unwire_pte_hold
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|mpte
argument_list|)
expr_stmt|;
name|mpte
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|mpte
operator|)
return|;
block|}
comment|/* 	 * Enter on the PV list if part of our managed memory. 	 */
name|managed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|flags
operator|&
operator|(
name|PG_FICTITIOUS
operator||
name|PG_UNMANAGED
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|pmap_try_insert_pv_entry
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|mpte
argument_list|,
name|m
argument_list|)
condition|)
block|{
if|if
condition|(
name|mpte
operator|!=
name|NULL
condition|)
block|{
name|pmap_unwire_pte_hold
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|mpte
argument_list|)
expr_stmt|;
name|mpte
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|mpte
operator|)
return|;
block|}
name|managed
operator|=
name|PG_MANAGED
operator||
name|PG_FOR
operator||
name|PG_FOW
operator||
name|PG_FOE
expr_stmt|;
block|}
comment|/* 	 * Increment counters 	 */
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|++
expr_stmt|;
comment|/* 	 * Validate the mapping with limited access, read and/or execute but 	 * not write. 	 */
operator|*
name|pte
operator|=
name|pmap_phys_to_pte
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
operator||
name|PG_V
operator||
name|pte_prot
argument_list|(
name|pmap
argument_list|,
name|prot
operator|&
operator|(
name|VM_PROT_READ
operator||
name|VM_PROT_EXECUTE
operator|)
argument_list|)
operator||
name|managed
expr_stmt|;
return|return
name|mpte
return|;
block|}
end_function

begin_comment
comment|/*  * Make temporary mapping for a physical address. This is called  * during dump.  */
end_comment

begin_function
name|void
modifier|*
name|pmap_kenter_temporary
parameter_list|(
name|vm_offset_t
name|pa
parameter_list|,
name|int
name|i
parameter_list|)
block|{
return|return
operator|(
name|void
operator|*
operator|)
name|ALPHA_PHYS_TO_K0SEG
argument_list|(
name|pa
operator|-
operator|(
name|i
operator|*
name|PAGE_SIZE
operator|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * pmap_object_init_pt preloads the ptes for a given object  * into the specified pmap.  This eliminates the blast of soft  * faults on process startup and immediately after an mmap.  */
end_comment

begin_function
name|void
name|pmap_object_init_pt
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|addr
parameter_list|,
name|vm_object_t
name|object
parameter_list|,
name|vm_pindex_t
name|pindex
parameter_list|,
name|vm_size_t
name|size
parameter_list|)
block|{
name|VM_OBJECT_LOCK_ASSERT
argument_list|(
name|object
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|object
operator|->
name|type
operator|==
name|OBJT_DEVICE
argument_list|,
operator|(
literal|"pmap_object_init_pt: non-device object"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Routine:	pmap_change_wiring  *	Function:	Change the wiring attribute for a map/virtual-address  *			pair.  *	In/out conditions:  *			The mapping must already exist in the pmap.  */
end_comment

begin_function
name|void
name|pmap_change_wiring
parameter_list|(
name|pmap
parameter_list|,
name|va
parameter_list|,
name|wired
parameter_list|)
specifier|register
name|pmap_t
name|pmap
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
name|boolean_t
name|wired
decl_stmt|;
block|{
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|pte
operator|=
name|pmap_lev3pte
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|wired
operator|&&
operator|!
name|pmap_pte_w
argument_list|(
name|pte
argument_list|)
condition|)
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|wired
operator|&&
name|pmap_pte_w
argument_list|(
name|pte
argument_list|)
condition|)
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|--
expr_stmt|;
comment|/* 	 * Wiring is not a hardware characteristic so there is no need to 	 * invalidate TLB. 	 */
name|pmap_pte_set_w
argument_list|(
name|pte
argument_list|,
name|wired
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Copy the range specified by src_addr/len  *	from the source map to the range dst_addr/len  *	in the destination map.  *  *	This routine is only advisory and need not do anything.  */
end_comment

begin_function
name|void
name|pmap_copy
parameter_list|(
name|pmap_t
name|dst_pmap
parameter_list|,
name|pmap_t
name|src_pmap
parameter_list|,
name|vm_offset_t
name|dst_addr
parameter_list|,
name|vm_size_t
name|len
parameter_list|,
name|vm_offset_t
name|src_addr
parameter_list|)
block|{ }
end_function

begin_comment
comment|/*  *	pmap_zero_page zeros the specified hardware page by  *	mapping it into virtual memory and using bzero to clear  *	its contents.  */
end_comment

begin_function
name|void
name|pmap_zero_page
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|vm_offset_t
name|va
init|=
name|ALPHA_PHYS_TO_K0SEG
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|va
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	pmap_zero_page_area zeros the specified hardware page by  *	mapping it into virtual memory and using bzero to clear  *	its contents.  *  *	off and size must reside within a single page.  */
end_comment

begin_function
name|void
name|pmap_zero_page_area
parameter_list|(
name|vm_page_t
name|m
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|vm_offset_t
name|va
init|=
name|ALPHA_PHYS_TO_K0SEG
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|caddr_t
operator|)
name|va
operator|+
name|off
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	pmap_zero_page_idle zeros the specified hardware page by  *	mapping it into virtual memory and using bzero to clear  *	its contents.  This is for the vm_pagezero idle process.  */
end_comment

begin_function
name|void
name|pmap_zero_page_idle
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|vm_offset_t
name|va
init|=
name|ALPHA_PHYS_TO_K0SEG
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|va
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	pmap_copy_page copies the specified (machine independent)  *	page by mapping the page into virtual memory and using  *	bcopy to copy the page, one machine dependent page at a  *	time.  */
end_comment

begin_function
name|void
name|pmap_copy_page
parameter_list|(
name|vm_page_t
name|msrc
parameter_list|,
name|vm_page_t
name|mdst
parameter_list|)
block|{
name|vm_offset_t
name|src
init|=
name|ALPHA_PHYS_TO_K0SEG
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|msrc
argument_list|)
argument_list|)
decl_stmt|;
name|vm_offset_t
name|dst
init|=
name|ALPHA_PHYS_TO_K0SEG
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|mdst
argument_list|)
argument_list|)
decl_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|src
argument_list|,
operator|(
name|caddr_t
operator|)
name|dst
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Returns true if the pmap's pv is one of the first  * 16 pvs linked to from this page.  This count may  * be changed upwards or downwards in the future; it  * is only necessary that true be returned for a small  * subset of pmaps for proper page aging.  */
end_comment

begin_function
name|boolean_t
name|pmap_page_exists_quick
parameter_list|(
name|pmap
parameter_list|,
name|m
parameter_list|)
name|pmap_t
name|pmap
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
block|{
name|pv_entry_t
name|pv
decl_stmt|;
name|int
name|loops
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|m
operator|->
name|flags
operator|&
name|PG_FICTITIOUS
condition|)
return|return
name|FALSE
return|;
comment|/* 	 * Not found, check current mappings returning immediately if found. 	 */
name|TAILQ_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&m->md.pv_list
argument_list|,
argument|pv_list
argument_list|)
block|{
if|if
condition|(
name|pv
operator|->
name|pv_pmap
operator|==
name|pmap
condition|)
block|{
return|return
name|TRUE
return|;
block|}
name|loops
operator|++
expr_stmt|;
if|if
condition|(
name|loops
operator|>=
literal|16
condition|)
break|break;
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|PMAP_REMOVE_PAGES_CURPROC_ONLY
end_define

begin_comment
comment|/*  * Remove all pages from specified address space  * this aids process exit speeds.  Also, this code  * is special cased for current process only, but  * can have the more generic (and slightly slower)  * mode enabled.  This is much faster than pmap_remove  * in the case of running down an entire address space.  */
end_comment

begin_function
name|void
name|pmap_remove_pages
parameter_list|(
name|pmap
parameter_list|,
name|sva
parameter_list|,
name|eva
parameter_list|)
name|pmap_t
name|pmap
decl_stmt|;
name|vm_offset_t
name|sva
decl_stmt|,
name|eva
decl_stmt|;
block|{
name|pt_entry_t
modifier|*
name|pte
decl_stmt|,
name|tpte
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|pv_entry_t
name|pv
decl_stmt|,
name|npv
decl_stmt|;
ifdef|#
directive|ifdef
name|PMAP_REMOVE_PAGES_CURPROC_ONLY
if|if
condition|(
name|pmap
operator|!=
name|vmspace_pmap
argument_list|(
name|curthread
operator|->
name|td_proc
operator|->
name|p_vmspace
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"warning: pmap_remove_pages called with non-current pmap\n"
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
for|for
control|(
name|pv
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvlist
argument_list|)
init|;
name|pv
condition|;
name|pv
operator|=
name|npv
control|)
block|{
if|if
condition|(
name|pv
operator|->
name|pv_va
operator|>=
name|eva
operator|||
name|pv
operator|->
name|pv_va
operator|<
name|sva
condition|)
block|{
name|npv
operator|=
name|TAILQ_NEXT
argument_list|(
name|pv
argument_list|,
name|pv_plist
argument_list|)
expr_stmt|;
continue|continue;
block|}
ifdef|#
directive|ifdef
name|PMAP_REMOVE_PAGES_CURPROC_ONLY
name|pte
operator|=
name|vtopte
argument_list|(
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
else|#
directive|else
name|pte
operator|=
name|pmap_pte_quick
argument_list|(
name|pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|pmap_pte_v
argument_list|(
name|pte
argument_list|)
condition|)
name|panic
argument_list|(
literal|"pmap_remove_pages: page on pm_pvlist has no pte\n"
argument_list|)
expr_stmt|;
name|tpte
operator|=
operator|*
name|pte
expr_stmt|;
comment|/*  * We cannot remove wired pages from a process' mapping at this time  */
if|if
condition|(
name|tpte
operator|&
name|PG_W
condition|)
block|{
name|npv
operator|=
name|TAILQ_NEXT
argument_list|(
name|pv
argument_list|,
name|pv_plist
argument_list|)
expr_stmt|;
continue|continue;
block|}
operator|*
name|pte
operator|=
literal|0
expr_stmt|;
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pmap_pte_pa
argument_list|(
operator|&
name|tpte
argument_list|)
argument_list|)
expr_stmt|;
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|tpte
operator|&
name|PG_FOW
operator|)
operator|==
literal|0
condition|)
name|vm_page_dirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|npv
operator|=
name|TAILQ_NEXT
argument_list|(
name|pv
argument_list|,
name|pv_plist
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvlist
argument_list|,
name|pv
argument_list|,
name|pv_plist
argument_list|)
expr_stmt|;
name|m
operator|->
name|md
operator|.
name|pv_list_count
operator|--
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|,
name|pv
argument_list|,
name|pv_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|)
condition|)
name|vm_page_flag_clear
argument_list|(
name|m
argument_list|,
name|PG_WRITEABLE
argument_list|)
expr_stmt|;
name|pmap_unuse_pt
argument_list|(
name|pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|,
name|pv
operator|->
name|pv_ptem
argument_list|)
expr_stmt|;
name|free_pv_entry
argument_list|(
name|pv
argument_list|)
expr_stmt|;
block|}
name|pmap_invalidate_all
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * this routine is used to modify bits in ptes  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|pmap_changebit
parameter_list|(
name|vm_page_t
name|m
parameter_list|,
name|int
name|bit
parameter_list|,
name|boolean_t
name|setem
parameter_list|)
block|{
name|pv_entry_t
name|pv
decl_stmt|;
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
name|int
name|changed
decl_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_FICTITIOUS
operator|)
operator|||
operator|(
operator|!
name|setem
operator|&&
name|bit
operator|==
operator|(
name|PG_UWE
operator||
name|PG_KWE
operator|)
operator|&&
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_WRITEABLE
operator|)
operator|==
literal|0
operator|)
condition|)
return|return;
name|changed
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Loop over all current mappings setting/clearing as appropos If 	 * setting RO do we need to clear the VAC? 	 */
name|TAILQ_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&m->md.pv_list
argument_list|,
argument|pv_list
argument_list|)
block|{
name|PMAP_LOCK
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|)
expr_stmt|;
name|pte
operator|=
name|pmap_lev3pte
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
name|changed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|setem
condition|)
block|{
operator|*
name|pte
operator||=
name|bit
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|pt_entry_t
name|pbits
init|=
operator|*
name|pte
decl_stmt|;
if|if
condition|(
name|pbits
operator|&
name|bit
condition|)
block|{
name|changed
operator|=
literal|1
expr_stmt|;
operator|*
name|pte
operator|=
name|pbits
operator|&
operator|~
name|bit
expr_stmt|;
block|}
block|}
if|if
condition|(
name|changed
condition|)
name|pmap_invalidate_page
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|setem
operator|&&
name|bit
operator|==
operator|(
name|PG_UWE
operator||
name|PG_KWE
operator|)
condition|)
name|vm_page_flag_clear
argument_list|(
name|m
argument_list|,
name|PG_WRITEABLE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *      pmap_page_protect:  *  *      Lower the permission for all mappings to a given page.  */
end_comment

begin_function
name|void
name|pmap_page_protect
parameter_list|(
name|vm_page_t
name|m
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|)
block|{
if|if
condition|(
operator|(
name|prot
operator|&
name|VM_PROT_WRITE
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|prot
operator|&
operator|(
name|VM_PROT_READ
operator||
name|VM_PROT_EXECUTE
operator|)
condition|)
block|{
name|pmap_changebit
argument_list|(
name|m
argument_list|,
name|PG_KWE
operator||
name|PG_UWE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pmap_remove_all
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  *	pmap_ts_referenced:  *  *	Return a count of reference bits for a page, clearing those bits.  *	It is not necessary for every reference bit to be cleared, but it  *	is necessary that 0 only be returned when there are truly no  *	reference bits set.  *  *	XXX: The exact number of bits to check and clear is a matter that  *	should be tested and standardized at some point in the future for  *	optimal aging of shared pages.  */
end_comment

begin_function
name|int
name|pmap_ts_referenced
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|pv_entry_t
name|pv
decl_stmt|;
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
name|int
name|count
decl_stmt|;
if|if
condition|(
name|m
operator|->
name|flags
operator|&
name|PG_FICTITIOUS
condition|)
return|return
literal|0
return|;
comment|/* 	 * Loop over current mappings looking for any which have don't 	 * have PG_FOR set (i.e. ones where we have taken an emulate 	 * reference trap recently). 	 */
name|count
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&m->md.pv_list
argument_list|,
argument|pv_list
argument_list|)
block|{
name|PMAP_LOCK
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|)
expr_stmt|;
name|pte
operator|=
name|pmap_lev3pte
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|pte
operator|&
name|PG_FOR
operator|)
condition|)
block|{
name|count
operator|++
expr_stmt|;
operator|*
name|pte
operator||=
name|PG_FOR
operator||
name|PG_FOE
expr_stmt|;
name|pmap_invalidate_page
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
block|}
name|PMAP_UNLOCK
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|)
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/*  *	pmap_is_modified:  *  *	Return whether or not the specified physical page was modified  *	in any physical maps.  */
end_comment

begin_function
name|boolean_t
name|pmap_is_modified
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|pv_entry_t
name|pv
decl_stmt|;
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
name|boolean_t
name|rv
decl_stmt|;
name|rv
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|flags
operator|&
name|PG_FICTITIOUS
condition|)
return|return
operator|(
name|rv
operator|)
return|;
comment|/* 	 * A page is modified if any mapping has had its PG_FOW flag 	 * cleared. 	 */
name|TAILQ_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&m->md.pv_list
argument_list|,
argument|pv_list
argument_list|)
block|{
name|PMAP_LOCK
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|)
expr_stmt|;
name|pte
operator|=
name|pmap_lev3pte
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
name|rv
operator|=
operator|!
operator|(
operator|*
name|pte
operator|&
name|PG_FOW
operator|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
condition|)
break|break;
block|}
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	pmap_is_prefaultable:  *  *	Return whether or not the specified virtual address is elgible  *	for prefault.  */
end_comment

begin_function
name|boolean_t
name|pmap_is_prefaultable
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|addr
parameter_list|)
block|{
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
name|boolean_t
name|rv
decl_stmt|;
name|rv
operator|=
name|FALSE
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap_pte_v
argument_list|(
name|pmap_lev1pte
argument_list|(
name|pmap
argument_list|,
name|addr
argument_list|)
argument_list|)
operator|&&
name|pmap_pte_v
argument_list|(
name|pmap_lev2pte
argument_list|(
name|pmap
argument_list|,
name|addr
argument_list|)
argument_list|)
condition|)
block|{
name|pte
operator|=
name|vtopte
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|rv
operator|=
operator|*
name|pte
operator|==
literal|0
expr_stmt|;
block|}
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	Clear the modify bits on the specified physical page.  */
end_comment

begin_function
name|void
name|pmap_clear_modify
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|pv_entry_t
name|pv
decl_stmt|;
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
if|if
condition|(
name|m
operator|->
name|flags
operator|&
name|PG_FICTITIOUS
condition|)
return|return;
comment|/* 	 * Loop over current mappings setting PG_FOW where needed. 	 */
name|TAILQ_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&m->md.pv_list
argument_list|,
argument|pv_list
argument_list|)
block|{
name|PMAP_LOCK
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|)
expr_stmt|;
name|pte
operator|=
name|pmap_lev3pte
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|pte
operator|&
name|PG_FOW
operator|)
condition|)
block|{
operator|*
name|pte
operator||=
name|PG_FOW
expr_stmt|;
name|pmap_invalidate_page
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
block|}
name|PMAP_UNLOCK
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *	pmap_clear_reference:  *  *	Clear the reference bit on the specified physical page.  */
end_comment

begin_function
name|void
name|pmap_clear_reference
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|pv_entry_t
name|pv
decl_stmt|;
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
if|if
condition|(
name|m
operator|->
name|flags
operator|&
name|PG_FICTITIOUS
condition|)
return|return;
comment|/* 	 * Loop over current mappings setting PG_FOR and PG_FOE where needed. 	 */
name|TAILQ_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&m->md.pv_list
argument_list|,
argument|pv_list
argument_list|)
block|{
name|PMAP_LOCK
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|)
expr_stmt|;
name|pte
operator|=
name|pmap_lev3pte
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|pte
operator|&
operator|(
name|PG_FOR
operator||
name|PG_FOE
operator|)
operator|)
condition|)
block|{
operator|*
name|pte
operator||=
operator|(
name|PG_FOR
operator||
name|PG_FOE
operator|)
expr_stmt|;
name|pmap_invalidate_page
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
block|}
name|PMAP_UNLOCK
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * pmap_emulate_reference:  *  *	Emulate reference and/or modified bit hits.  *	From NetBSD  */
end_comment

begin_function
name|void
name|pmap_emulate_reference
parameter_list|(
name|struct
name|vmspace
modifier|*
name|vm
parameter_list|,
name|vm_offset_t
name|v
parameter_list|,
name|int
name|user
parameter_list|,
name|int
name|write
parameter_list|)
block|{
name|pmap_t
name|pmap
decl_stmt|;
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
comment|/* 	 * Convert process and virtual address to physical address. 	 */
if|if
condition|(
name|v
operator|>=
name|VM_MIN_KERNEL_ADDRESS
condition|)
block|{
if|if
condition|(
name|user
condition|)
name|panic
argument_list|(
literal|"pmap_emulate_reference: user ref to kernel"
argument_list|)
expr_stmt|;
name|pmap
operator|=
name|kernel_pmap
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|pte
operator|=
name|vtopte
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|KASSERT
argument_list|(
name|vm
operator|!=
name|NULL
argument_list|,
operator|(
literal|"pmap_emulate_reference: bad vmspace"
operator|)
argument_list|)
expr_stmt|;
name|pmap
operator|=
operator|&
name|vm
operator|->
name|vm_pmap
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|pte
operator|=
name|pmap_lev3pte
argument_list|(
name|pmap
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Another CPU can modify the pmap between the emulation trap and this 	 * CPU locking the pmap.  As a result, the pte may be inconsistent 	 * with the access that caused the emulation trap.  In such cases, 	 * invalidate this CPU's TLB entry and return. 	 */
if|if
condition|(
operator|!
name|pmap_pte_v
argument_list|(
name|pte
argument_list|)
condition|)
goto|goto
name|tbis
goto|;
comment|/* 	 * Twiddle the appropriate bits to reflect the reference 	 * and/or modification.. 	 * 	 * The rules: 	 * 	(1) always mark page as used, and 	 *	(2) if it was a write fault, mark page as modified. 	 */
if|if
condition|(
name|write
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|pte
operator|&
operator|(
name|user
condition|?
name|PG_UWE
else|:
name|PG_UWE
operator||
name|PG_KWE
operator|)
operator|)
condition|)
goto|goto
name|tbis
goto|;
if|if
condition|(
operator|!
operator|(
operator|*
name|pte
operator|&
name|PG_FOW
operator|)
condition|)
goto|goto
name|tbis
goto|;
operator|*
name|pte
operator|&=
operator|~
operator|(
name|PG_FOR
operator||
name|PG_FOE
operator||
name|PG_FOW
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|pte
operator|&
operator|(
name|user
condition|?
name|PG_URE
else|:
name|PG_URE
operator||
name|PG_KRE
operator|)
operator|)
condition|)
goto|goto
name|tbis
goto|;
if|if
condition|(
operator|!
operator|(
operator|*
name|pte
operator|&
operator|(
name|PG_FOR
operator||
name|PG_FOE
operator|)
operator|)
condition|)
goto|goto
name|tbis
goto|;
operator|*
name|pte
operator|&=
operator|~
operator|(
name|PG_FOR
operator||
name|PG_FOE
operator|)
expr_stmt|;
block|}
name|tbis
label|:
name|ALPHA_TBIS
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Miscellaneous support routines follow  */
end_comment

begin_function
specifier|static
name|void
name|alpha_protection_init
parameter_list|()
block|{
name|int
name|prot
decl_stmt|,
modifier|*
name|kp
decl_stmt|,
modifier|*
name|up
decl_stmt|;
name|kp
operator|=
name|protection_codes
index|[
literal|0
index|]
expr_stmt|;
name|up
operator|=
name|protection_codes
index|[
literal|1
index|]
expr_stmt|;
for|for
control|(
name|prot
operator|=
literal|0
init|;
name|prot
operator|<
literal|8
condition|;
name|prot
operator|++
control|)
block|{
switch|switch
condition|(
name|prot
condition|)
block|{
case|case
name|VM_PROT_NONE
operator||
name|VM_PROT_NONE
operator||
name|VM_PROT_NONE
case|:
operator|*
name|kp
operator|++
operator|=
name|PG_ASM
expr_stmt|;
operator|*
name|up
operator|++
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|VM_PROT_READ
operator||
name|VM_PROT_NONE
operator||
name|VM_PROT_NONE
case|:
case|case
name|VM_PROT_READ
operator||
name|VM_PROT_NONE
operator||
name|VM_PROT_EXECUTE
case|:
case|case
name|VM_PROT_NONE
operator||
name|VM_PROT_NONE
operator||
name|VM_PROT_EXECUTE
case|:
operator|*
name|kp
operator|++
operator|=
name|PG_ASM
operator||
name|PG_KRE
expr_stmt|;
operator|*
name|up
operator|++
operator|=
name|PG_URE
operator||
name|PG_KRE
expr_stmt|;
break|break;
case|case
name|VM_PROT_NONE
operator||
name|VM_PROT_WRITE
operator||
name|VM_PROT_NONE
case|:
operator|*
name|kp
operator|++
operator|=
name|PG_ASM
operator||
name|PG_KWE
expr_stmt|;
operator|*
name|up
operator|++
operator|=
name|PG_UWE
operator||
name|PG_KWE
expr_stmt|;
break|break;
case|case
name|VM_PROT_NONE
operator||
name|VM_PROT_WRITE
operator||
name|VM_PROT_EXECUTE
case|:
case|case
name|VM_PROT_READ
operator||
name|VM_PROT_WRITE
operator||
name|VM_PROT_NONE
case|:
case|case
name|VM_PROT_READ
operator||
name|VM_PROT_WRITE
operator||
name|VM_PROT_EXECUTE
case|:
operator|*
name|kp
operator|++
operator|=
name|PG_ASM
operator||
name|PG_KWE
operator||
name|PG_KRE
expr_stmt|;
operator|*
name|up
operator|++
operator|=
name|PG_UWE
operator||
name|PG_URE
operator||
name|PG_KWE
operator||
name|PG_KRE
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Map a set of physical memory pages into the kernel virtual  * address space. Return a pointer to where it is mapped. This  * routine is intended to be used for mapping device memory,  * NOT real memory.  */
end_comment

begin_function
name|void
modifier|*
name|pmap_mapdev
parameter_list|(
name|pa
parameter_list|,
name|size
parameter_list|)
name|vm_offset_t
name|pa
decl_stmt|;
name|vm_size_t
name|size
decl_stmt|;
block|{
return|return
operator|(
name|void
operator|*
operator|)
name|ALPHA_PHYS_TO_K0SEG
argument_list|(
name|pa
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|pmap_unmapdev
parameter_list|(
name|va
parameter_list|,
name|size
parameter_list|)
name|vm_offset_t
name|va
decl_stmt|;
name|vm_size_t
name|size
decl_stmt|;
block|{ }
end_function

begin_comment
comment|/*  * perform the pmap work for mincore  */
end_comment

begin_function
name|int
name|pmap_mincore
parameter_list|(
name|pmap
parameter_list|,
name|addr
parameter_list|)
name|pmap_t
name|pmap
decl_stmt|;
name|vm_offset_t
name|addr
decl_stmt|;
block|{
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|,
name|pte
decl_stmt|;
name|int
name|val
init|=
literal|0
decl_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|ptep
operator|=
name|pmap_lev3pte
argument_list|(
name|pmap
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|pte
operator|=
operator|(
name|ptep
operator|!=
name|NULL
operator|)
condition|?
operator|*
name|ptep
else|:
literal|0
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|pte
operator|&
name|PG_V
condition|)
block|{
name|vm_page_t
name|m
decl_stmt|;
name|vm_offset_t
name|pa
decl_stmt|;
name|val
operator|=
name|MINCORE_INCORE
expr_stmt|;
if|if
condition|(
operator|(
name|pte
operator|&
name|PG_MANAGED
operator|)
operator|==
literal|0
condition|)
return|return
name|val
return|;
name|pa
operator|=
name|alpha_ptob
argument_list|(
name|ALPHA_PTE_TO_PFN
argument_list|(
name|pte
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pa
argument_list|)
expr_stmt|;
comment|/* 		 * Modified by us 		 */
if|if
condition|(
operator|(
name|pte
operator|&
name|PG_FOW
operator|)
operator|==
literal|0
condition|)
name|val
operator||=
name|MINCORE_MODIFIED
operator||
name|MINCORE_MODIFIED_OTHER
expr_stmt|;
else|else
block|{
comment|/* 			 * Modified by someone 			 */
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|dirty
operator|||
name|pmap_is_modified
argument_list|(
name|m
argument_list|)
condition|)
name|val
operator||=
name|MINCORE_MODIFIED_OTHER
expr_stmt|;
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
block|}
comment|/* 		 * Referenced by us 		 */
if|if
condition|(
operator|(
name|pte
operator|&
operator|(
name|PG_FOR
operator||
name|PG_FOE
operator|)
operator|)
operator|==
literal|0
condition|)
name|val
operator||=
name|MINCORE_REFERENCED
operator||
name|MINCORE_REFERENCED_OTHER
expr_stmt|;
else|else
block|{
comment|/* 			 * Referenced by someone 			 */
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_REFERENCED
operator|)
operator|||
name|pmap_ts_referenced
argument_list|(
name|m
argument_list|)
condition|)
block|{
name|val
operator||=
name|MINCORE_REFERENCED_OTHER
expr_stmt|;
name|vm_page_flag_set
argument_list|(
name|m
argument_list|,
name|PG_REFERENCED
argument_list|)
expr_stmt|;
block|}
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|val
return|;
block|}
end_function

begin_function
name|void
name|pmap_activate
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|pmap_t
name|pmap
decl_stmt|;
name|pmap
operator|=
name|vmspace_pmap
argument_list|(
name|td
operator|->
name|td_proc
operator|->
name|p_vmspace
argument_list|)
expr_stmt|;
name|critical_enter
argument_list|()
expr_stmt|;
if|if
condition|(
name|pmap_active
index|[
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
index|]
operator|&&
name|pmap
operator|!=
name|pmap_active
index|[
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
index|]
condition|)
block|{
name|atomic_clear_32
argument_list|(
operator|&
name|pmap_active
index|[
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
index|]
operator|->
name|pm_active
argument_list|,
name|PCPU_GET
argument_list|(
name|cpumask
argument_list|)
argument_list|)
expr_stmt|;
name|pmap_active
index|[
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|td
operator|->
name|td_pcb
operator|->
name|pcb_hw
operator|.
name|apcb_ptbr
operator|=
name|ALPHA_K0SEG_TO_PHYS
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|pmap
operator|->
name|pm_lev1
argument_list|)
operator|>>
name|PAGE_SHIFT
expr_stmt|;
if|if
condition|(
name|pmap
operator|->
name|pm_asn
index|[
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
index|]
operator|.
name|gen
operator|!=
name|PCPU_GET
argument_list|(
name|current_asngen
argument_list|)
condition|)
name|pmap_get_asn
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|pmap_active
index|[
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
index|]
operator|=
name|pmap
expr_stmt|;
name|atomic_set_32
argument_list|(
operator|&
name|pmap
operator|->
name|pm_active
argument_list|,
name|PCPU_GET
argument_list|(
name|cpumask
argument_list|)
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_pcb
operator|->
name|pcb_hw
operator|.
name|apcb_asn
operator|=
name|pmap
operator|->
name|pm_asn
index|[
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
index|]
operator|.
name|asn
expr_stmt|;
name|critical_exit
argument_list|()
expr_stmt|;
if|if
condition|(
name|td
operator|==
name|curthread
condition|)
block|{
name|alpha_pal_swpctx
argument_list|(
operator|(
name|u_long
operator|)
name|td
operator|->
name|td_md
operator|.
name|md_pcbpaddr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|pmap_deactivate
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|pmap_t
name|pmap
decl_stmt|;
name|pmap
operator|=
name|vmspace_pmap
argument_list|(
name|td
operator|->
name|td_proc
operator|->
name|p_vmspace
argument_list|)
expr_stmt|;
name|atomic_clear_32
argument_list|(
operator|&
name|pmap
operator|->
name|pm_active
argument_list|,
name|PCPU_GET
argument_list|(
name|cpumask
argument_list|)
argument_list|)
expr_stmt|;
name|pmap_active
index|[
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|vm_offset_t
name|pmap_addr_hint
parameter_list|(
name|vm_object_t
name|obj
parameter_list|,
name|vm_offset_t
name|addr
parameter_list|,
name|vm_size_t
name|size
parameter_list|)
block|{
return|return
name|addr
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_if
if|#
directive|if
name|defined
argument_list|(
name|PMAP_DEBUG
argument_list|)
end_if

begin_endif
unit|pmap_pid_dump(int pid) { 	pmap_t pmap; 	struct proc *p; 	int npte = 0; 	int index;  	sx_slock(&allproc_lock); 	LIST_FOREACH(p,&allproc, p_list) { 		if (p->p_pid != pid) 			continue;  		if (p->p_vmspace) { 			int i,j; 			index = 0; 			pmap = vmspace_pmap(p->p_vmspace); 			for (i = 0; i< NPDEPG; i++) { 				pd_entry_t *pde; 				pt_entry_t *pte; 				vm_offset_t base = i<< PDRSHIFT; 				 				pde =&pmap->pm_pdir[i]; 				if (pde&& pmap_pde_v(pde)) { 					for (j = 0; j< NPTEPG; j++) { 						vm_offset_t va = base + (j<< PAGE_SHIFT); 						if (va>= (vm_offset_t) VM_MIN_KERNEL_ADDRESS) { 							if (index) { 								index = 0; 								printf("\n"); 							} 							sx_sunlock(&allproc_lock); 							return npte; 						} 						pte = pmap_pte_quick(pmap, va); 						if (pte&& pmap_pte_v(pte)) { 							vm_offset_t pa; 							vm_page_t m; 							pa = *(int *)pte; 							m = PHYS_TO_VM_PAGE(pa); 							printf("va: 0x%x, pt: 0x%x, h: %d, w: %d, f: 0x%x", 								va, pa, m->hold_count, m->wire_count, m->flags); 							npte++; 							index++; 							if (index>= 2) { 								index = 0; 								printf("\n"); 							} else { 								printf(" "); 							} 						} 					} 				} 			} 		} 	} 	sx_sunlock(&allproc_lock); 	return npte; }
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
end_if

begin_comment
unit|static void	pads(pmap_t pm); void		pmap_pvdump(vm_offset_t pa);
comment|/* print address space of pmap*/
end_comment

begin_endif
unit|static void pads(pm) 	pmap_t pm; { 	int i, j; 	vm_offset_t va; 	pt_entry_t *ptep;  	if (pm == kernel_pmap) 		return; 	for (i = 0; i< NPDEPG; i++) 		if (pm->pm_pdir[i]) 			for (j = 0; j< NPTEPG; j++) { 				va = (i<< PDRSHIFT) + (j<< PAGE_SHIFT); 				if (pm == kernel_pmap&& va< KERNBASE) 					continue; 				if (pm != kernel_pmap&& va> UPT_MAX_ADDRESS) 					continue; 				ptep = pmap_pte_quick(pm, va); 				if (pmap_pte_v(ptep)) 					printf("%x:%x ", va, *(int *) ptep); 			};  }  void pmap_pvdump(pa) 	vm_offset_t pa; { 	pv_entry_t pv; 	vm_page_t m;  	printf("pa %x", pa); 	m = PHYS_TO_VM_PAGE(pa); 	TAILQ_FOREACH(pv,&m->md.pv_list, pv_list) { 		printf(" -> pmap %p, va %x", (void *)pv->pv_pmap, pv->pv_va); 		pads(pv->pv_pmap); 	} 	printf(" "); }
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

end_unit

