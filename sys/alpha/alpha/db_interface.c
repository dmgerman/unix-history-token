begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $NetBSD: db_interface.c,v 1.2 1997/09/16 19:07:19 thorpej Exp $ */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/*   * Mach Operating System  * Copyright (c) 1992,1991,1990 Carnegie Mellon University  * All Rights Reserved.  *   * Permission to use, copy, modify and distribute this software and its  * documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *   * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS   * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR  * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *   * Carnegie Mellon requests users of this software to return to  *   *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *   * any improvements or extensions that they make and grant Carnegie the  * rights to redistribute these changes.  *  *	db_interface.c,v 2.4 1991/02/05 17:11:13 mrt (CMU)  */
end_comment

begin_comment
comment|/*  * Parts of this file are derived from Mach 3:  *  *	File: alpha_instruction.c  *	Author: Alessandro Forin, Carnegie Mellon University  *	Date:	6/92  */
end_comment

begin_comment
comment|/*  * Interface to DDB.  *  * Modified for NetBSD/alpha by:  *  *	Christopher G. Demetriou, Carnegie Mellon University  *  *	Jason R. Thorpe, Numerical Aerospace Simulation Facility,  *	NASA Ames Research Center  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_comment
comment|/* RCS ID& Copyright macro defns */
end_comment

begin_comment
comment|/* __KERNEL_RCSID(0, "$NetBSD: db_interface.c,v 1.2 1997/09/16 19:07:19 thorpej Exp $"); */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/reboot.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/cons.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/pcpu.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<machine/db_machdep.h>
end_include

begin_include
include|#
directive|include
file|<machine/pal.h>
end_include

begin_include
include|#
directive|include
file|<machine/prom.h>
end_include

begin_include
include|#
directive|include
file|<alpha/alpha/db_instruction.h>
end_include

begin_include
include|#
directive|include
file|<ddb/ddb.h>
end_include

begin_include
include|#
directive|include
file|<ddb/db_access.h>
end_include

begin_include
include|#
directive|include
file|<ddb/db_sym.h>
end_include

begin_include
include|#
directive|include
file|<ddb/db_variables.h>
end_include

begin_include
include|#
directive|include
file|<machine/setjmp.h>
end_include

begin_decl_stmt
specifier|static
name|jmp_buf
modifier|*
name|db_nofault
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|jmp_buf
name|db_jmpbuf
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|void
name|gdb_handle_exception
parameter_list|(
name|db_regs_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|extern char *trap_type[]; extern int trap_types;
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|db_active
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|ddbprinttrap
parameter_list|(
name|unsigned
name|long
parameter_list|,
name|unsigned
name|long
parameter_list|,
name|unsigned
name|long
parameter_list|,
name|unsigned
name|long
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|db_variable
name|db_regs
index|[]
init|=
block|{
block|{
literal|"v0"
block|,
operator|&
name|ddb_regs
operator|.
name|tf_regs
index|[
name|FRAME_V0
index|]
block|,
name|FCN_NULL
block|}
block|,
block|{
literal|"t0"
block|,
operator|&
name|ddb_regs
operator|.
name|tf_regs
index|[
name|FRAME_T0
index|]
block|,
name|FCN_NULL
block|}
block|,
block|{
literal|"t1"
block|,
operator|&
name|ddb_regs
operator|.
name|tf_regs
index|[
name|FRAME_T1
index|]
block|,
name|FCN_NULL
block|}
block|,
block|{
literal|"t2"
block|,
operator|&
name|ddb_regs
operator|.
name|tf_regs
index|[
name|FRAME_T2
index|]
block|,
name|FCN_NULL
block|}
block|,
block|{
literal|"t3"
block|,
operator|&
name|ddb_regs
operator|.
name|tf_regs
index|[
name|FRAME_T3
index|]
block|,
name|FCN_NULL
block|}
block|,
block|{
literal|"t4"
block|,
operator|&
name|ddb_regs
operator|.
name|tf_regs
index|[
name|FRAME_T4
index|]
block|,
name|FCN_NULL
block|}
block|,
block|{
literal|"t5"
block|,
operator|&
name|ddb_regs
operator|.
name|tf_regs
index|[
name|FRAME_T5
index|]
block|,
name|FCN_NULL
block|}
block|,
block|{
literal|"t6"
block|,
operator|&
name|ddb_regs
operator|.
name|tf_regs
index|[
name|FRAME_T6
index|]
block|,
name|FCN_NULL
block|}
block|,
block|{
literal|"t7"
block|,
operator|&
name|ddb_regs
operator|.
name|tf_regs
index|[
name|FRAME_T7
index|]
block|,
name|FCN_NULL
block|}
block|,
block|{
literal|"s0"
block|,
operator|&
name|ddb_regs
operator|.
name|tf_regs
index|[
name|FRAME_S0
index|]
block|,
name|FCN_NULL
block|}
block|,
block|{
literal|"s1"
block|,
operator|&
name|ddb_regs
operator|.
name|tf_regs
index|[
name|FRAME_S1
index|]
block|,
name|FCN_NULL
block|}
block|,
block|{
literal|"s2"
block|,
operator|&
name|ddb_regs
operator|.
name|tf_regs
index|[
name|FRAME_S2
index|]
block|,
name|FCN_NULL
block|}
block|,
block|{
literal|"s3"
block|,
operator|&
name|ddb_regs
operator|.
name|tf_regs
index|[
name|FRAME_S3
index|]
block|,
name|FCN_NULL
block|}
block|,
block|{
literal|"s4"
block|,
operator|&
name|ddb_regs
operator|.
name|tf_regs
index|[
name|FRAME_S4
index|]
block|,
name|FCN_NULL
block|}
block|,
block|{
literal|"s5"
block|,
operator|&
name|ddb_regs
operator|.
name|tf_regs
index|[
name|FRAME_S5
index|]
block|,
name|FCN_NULL
block|}
block|,
block|{
literal|"s6"
block|,
operator|&
name|ddb_regs
operator|.
name|tf_regs
index|[
name|FRAME_S6
index|]
block|,
name|FCN_NULL
block|}
block|,
block|{
literal|"a0"
block|,
operator|&
name|ddb_regs
operator|.
name|tf_regs
index|[
name|FRAME_A0
index|]
block|,
name|FCN_NULL
block|}
block|,
block|{
literal|"a1"
block|,
operator|&
name|ddb_regs
operator|.
name|tf_regs
index|[
name|FRAME_A1
index|]
block|,
name|FCN_NULL
block|}
block|,
block|{
literal|"a2"
block|,
operator|&
name|ddb_regs
operator|.
name|tf_regs
index|[
name|FRAME_A2
index|]
block|,
name|FCN_NULL
block|}
block|,
block|{
literal|"a3"
block|,
operator|&
name|ddb_regs
operator|.
name|tf_regs
index|[
name|FRAME_A3
index|]
block|,
name|FCN_NULL
block|}
block|,
block|{
literal|"a4"
block|,
operator|&
name|ddb_regs
operator|.
name|tf_regs
index|[
name|FRAME_A4
index|]
block|,
name|FCN_NULL
block|}
block|,
block|{
literal|"a5"
block|,
operator|&
name|ddb_regs
operator|.
name|tf_regs
index|[
name|FRAME_A5
index|]
block|,
name|FCN_NULL
block|}
block|,
block|{
literal|"t8"
block|,
operator|&
name|ddb_regs
operator|.
name|tf_regs
index|[
name|FRAME_T8
index|]
block|,
name|FCN_NULL
block|}
block|,
block|{
literal|"t9"
block|,
operator|&
name|ddb_regs
operator|.
name|tf_regs
index|[
name|FRAME_T9
index|]
block|,
name|FCN_NULL
block|}
block|,
block|{
literal|"t10"
block|,
operator|&
name|ddb_regs
operator|.
name|tf_regs
index|[
name|FRAME_T10
index|]
block|,
name|FCN_NULL
block|}
block|,
block|{
literal|"t11"
block|,
operator|&
name|ddb_regs
operator|.
name|tf_regs
index|[
name|FRAME_T11
index|]
block|,
name|FCN_NULL
block|}
block|,
block|{
literal|"ra"
block|,
operator|&
name|ddb_regs
operator|.
name|tf_regs
index|[
name|FRAME_RA
index|]
block|,
name|FCN_NULL
block|}
block|,
block|{
literal|"t12"
block|,
operator|&
name|ddb_regs
operator|.
name|tf_regs
index|[
name|FRAME_T12
index|]
block|,
name|FCN_NULL
block|}
block|,
block|{
literal|"at"
block|,
operator|&
name|ddb_regs
operator|.
name|tf_regs
index|[
name|FRAME_AT
index|]
block|,
name|FCN_NULL
block|}
block|,
block|{
literal|"gp"
block|,
operator|&
name|ddb_regs
operator|.
name|tf_regs
index|[
name|FRAME_GP
index|]
block|,
name|FCN_NULL
block|}
block|,
block|{
literal|"sp"
block|,
operator|&
name|ddb_regs
operator|.
name|tf_regs
index|[
name|FRAME_SP
index|]
block|,
name|FCN_NULL
block|}
block|,
block|{
literal|"pc"
block|,
operator|&
name|ddb_regs
operator|.
name|tf_regs
index|[
name|FRAME_PC
index|]
block|,
name|FCN_NULL
block|}
block|,
block|{
literal|"ps"
block|,
operator|&
name|ddb_regs
operator|.
name|tf_regs
index|[
name|FRAME_PS
index|]
block|,
name|FCN_NULL
block|}
block|,
block|{
literal|"ai"
block|,
operator|&
name|ddb_regs
operator|.
name|tf_regs
index|[
name|FRAME_T11
index|]
block|,
name|FCN_NULL
block|}
block|,
block|{
literal|"pv"
block|,
operator|&
name|ddb_regs
operator|.
name|tf_regs
index|[
name|FRAME_T12
index|]
block|,
name|FCN_NULL
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|db_variable
modifier|*
name|db_eregs
init|=
name|db_regs
operator|+
sizeof|sizeof
argument_list|(
name|db_regs
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|db_regs
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Print trap reason.  */
end_comment

begin_function
name|void
name|ddbprinttrap
parameter_list|(
name|a0
parameter_list|,
name|a1
parameter_list|,
name|a2
parameter_list|,
name|entry
parameter_list|)
name|unsigned
name|long
name|a0
decl_stmt|,
name|a1
decl_stmt|,
name|a2
decl_stmt|,
name|entry
decl_stmt|;
block|{
comment|/* XXX Implement. */
name|printf
argument_list|(
literal|"ddbprinttrap(0x%lx, 0x%lx, 0x%lx, 0x%lx)\n"
argument_list|,
name|a0
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  ddb_trap - field a kernel trap  */
end_comment

begin_function
name|int
name|kdb_trap
parameter_list|(
name|a0
parameter_list|,
name|a1
parameter_list|,
name|a2
parameter_list|,
name|entry
parameter_list|,
name|regs
parameter_list|)
name|unsigned
name|long
name|a0
decl_stmt|,
name|a1
decl_stmt|,
name|a2
decl_stmt|,
name|entry
decl_stmt|;
name|db_regs_t
modifier|*
name|regs
decl_stmt|;
block|{
name|int
name|ddb_mode
init|=
operator|!
operator|(
name|boothowto
operator|&
name|RB_GDB
operator|)
decl_stmt|;
name|register_t
name|s
decl_stmt|;
comment|/* 	 * Don't bother checking for usermode, since a benign entry 	 * by the kernel (call to Debugger() or a breakpoint) has 	 * already checked for usermode.  If neither of those 	 * conditions exist, something Bad has happened. 	 */
if|if
condition|(
name|entry
operator|!=
name|ALPHA_KENTRY_IF
operator|||
operator|(
name|a0
operator|!=
name|ALPHA_IF_CODE_BUGCHK
operator|&&
name|a0
operator|!=
name|ALPHA_IF_CODE_BPT
operator|&&
name|a0
operator|!=
name|ALPHA_IF_CODE_GENTRAP
operator|)
condition|)
block|{
if|#
directive|if
literal|0
block|if (ddb_mode) { 			db_printf("ddbprinttrap from 0x%lx\n",
comment|/* XXX */
block|regs->tf_regs[FRAME_PC]); 			ddbprinttrap(a0, a1, a2, entry);
comment|/* 			 * Tell caller "We did NOT handle the trap." 			 * Caller should panic, or whatever. 			 */
block|return (0); 		}
endif|#
directive|endif
if|if
condition|(
name|db_nofault
condition|)
block|{
name|jmp_buf
modifier|*
name|no_fault
init|=
name|db_nofault
decl_stmt|;
name|db_nofault
operator|=
literal|0
expr_stmt|;
name|longjmp
argument_list|(
operator|*
name|no_fault
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * XXX Should switch to DDB's own stack, here. 	 */
name|ddb_regs
operator|=
operator|*
name|regs
expr_stmt|;
name|s
operator|=
name|intr_disable
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|db_printf
argument_list|(
literal|"stopping %x\n"
argument_list|,
name|PCPU_GET
argument_list|(
name|other_cpus
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|stop_cpus
argument_list|(
name|PCPU_GET
argument_list|(
name|other_cpus
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|db_printf
argument_list|(
literal|"stopped_cpus=%x\n"
argument_list|,
name|stopped_cpus
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|db_active
operator|++
expr_stmt|;
if|if
condition|(
name|ddb_mode
condition|)
block|{
name|cndbctl
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
comment|/* DDB active, unblank video */
name|db_trap
argument_list|(
name|entry
argument_list|,
name|a0
argument_list|)
expr_stmt|;
comment|/* Where the work happens */
name|cndbctl
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
comment|/* DDB inactive */
block|}
else|else
name|gdb_handle_exception
argument_list|(
operator|&
name|ddb_regs
argument_list|,
name|entry
argument_list|,
name|a0
argument_list|)
expr_stmt|;
name|db_active
operator|--
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
name|restart_cpus
argument_list|(
name|stopped_cpus
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|intr_restore
argument_list|(
name|s
argument_list|)
expr_stmt|;
operator|*
name|regs
operator|=
name|ddb_regs
expr_stmt|;
comment|/* 	 * Tell caller "We HAVE handled the trap." 	 */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read bytes from kernel address space for debugger.  */
end_comment

begin_function
name|void
name|db_read_bytes
parameter_list|(
name|addr
parameter_list|,
name|size
parameter_list|,
name|data
parameter_list|)
name|vm_offset_t
name|addr
decl_stmt|;
specifier|register
name|size_t
name|size
decl_stmt|;
specifier|register
name|char
modifier|*
name|data
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|src
decl_stmt|;
name|db_nofault
operator|=
operator|&
name|db_jmpbuf
expr_stmt|;
name|src
operator|=
operator|(
name|char
operator|*
operator|)
name|addr
expr_stmt|;
while|while
condition|(
name|size
operator|--
operator|>
literal|0
condition|)
operator|*
name|data
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
name|db_nofault
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Write bytes to kernel address space for debugger.  */
end_comment

begin_function
name|void
name|db_write_bytes
parameter_list|(
name|addr
parameter_list|,
name|size
parameter_list|,
name|data
parameter_list|)
name|vm_offset_t
name|addr
decl_stmt|;
specifier|register
name|size_t
name|size
decl_stmt|;
specifier|register
name|char
modifier|*
name|data
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|dst
decl_stmt|;
name|db_nofault
operator|=
operator|&
name|db_jmpbuf
expr_stmt|;
name|dst
operator|=
operator|(
name|char
operator|*
operator|)
name|addr
expr_stmt|;
while|while
condition|(
name|size
operator|--
operator|>
literal|0
condition|)
operator|*
name|dst
operator|++
operator|=
operator|*
name|data
operator|++
expr_stmt|;
name|alpha_pal_imb
argument_list|()
expr_stmt|;
name|db_nofault
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Debugger
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|u_int
name|saveintr
decl_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|saveintr
operator|=
name|alpha_pal_swpipl
argument_list|(
name|ALPHA_PSL_IPL_HIGH
argument_list|)
expr_stmt|;
asm|__asm("call_pal 0x81");
comment|/* XXX bugchk */
name|alpha_pal_swpipl
argument_list|(
name|saveintr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Alpha-specific ddb commands:  *  *	halt		set halt bit in rpb and halt  *	reboot		set reboot bit in rpb and halt  */
end_comment

begin_macro
name|DB_COMMAND
argument_list|(
argument|halt
argument_list|,
argument|db_mach_halt
argument_list|)
end_macro

begin_block
block|{
name|prom_halt
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|DB_COMMAND
argument_list|(
argument|reboot
argument_list|,
argument|db_mach_reboot
argument_list|)
end_macro

begin_block
block|{
name|prom_halt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Map Alpha register numbers to trapframe/db_regs_t offsets.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|reg_to_frame
index|[
literal|32
index|]
init|=
block|{
name|FRAME_V0
block|,
name|FRAME_T0
block|,
name|FRAME_T1
block|,
name|FRAME_T2
block|,
name|FRAME_T3
block|,
name|FRAME_T4
block|,
name|FRAME_T5
block|,
name|FRAME_T6
block|,
name|FRAME_T7
block|,
name|FRAME_S0
block|,
name|FRAME_S1
block|,
name|FRAME_S2
block|,
name|FRAME_S3
block|,
name|FRAME_S4
block|,
name|FRAME_S5
block|,
name|FRAME_S6
block|,
name|FRAME_A0
block|,
name|FRAME_A1
block|,
name|FRAME_A2
block|,
name|FRAME_A3
block|,
name|FRAME_A4
block|,
name|FRAME_A5
block|,
name|FRAME_T8
block|,
name|FRAME_T9
block|,
name|FRAME_T10
block|,
name|FRAME_T11
block|,
name|FRAME_RA
block|,
name|FRAME_T12
block|,
name|FRAME_AT
block|,
name|FRAME_GP
block|,
name|FRAME_SP
block|,
operator|-
literal|1
block|,
comment|/* zero */
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|u_long
name|db_register_value
parameter_list|(
name|regs
parameter_list|,
name|regno
parameter_list|)
name|db_regs_t
modifier|*
name|regs
decl_stmt|;
name|int
name|regno
decl_stmt|;
block|{
if|if
condition|(
name|regno
operator|>
literal|31
operator|||
name|regno
operator|<
literal|0
condition|)
block|{
name|db_printf
argument_list|(
literal|" **** STRANGE REGISTER NUMBER %d **** "
argument_list|,
name|regno
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|regno
operator|==
literal|31
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|regs
operator|->
name|tf_regs
index|[
name|reg_to_frame
index|[
name|regno
index|]
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Support functions for software single-step.  */
end_comment

begin_function
name|boolean_t
name|db_inst_call
parameter_list|(
name|ins
parameter_list|)
name|int
name|ins
decl_stmt|;
block|{
name|alpha_instruction
name|insn
decl_stmt|;
name|insn
operator|.
name|bits
operator|=
name|ins
expr_stmt|;
return|return
operator|(
operator|(
name|insn
operator|.
name|branch_format
operator|.
name|opcode
operator|==
name|op_bsr
operator|)
operator|||
operator|(
operator|(
name|insn
operator|.
name|jump_format
operator|.
name|opcode
operator|==
name|op_j
operator|)
operator|&&
operator|(
name|insn
operator|.
name|jump_format
operator|.
name|action
operator|&
literal|1
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|boolean_t
name|db_inst_return
parameter_list|(
name|ins
parameter_list|)
name|int
name|ins
decl_stmt|;
block|{
name|alpha_instruction
name|insn
decl_stmt|;
name|insn
operator|.
name|bits
operator|=
name|ins
expr_stmt|;
return|return
operator|(
operator|(
name|insn
operator|.
name|jump_format
operator|.
name|opcode
operator|==
name|op_j
operator|)
operator|&&
operator|(
name|insn
operator|.
name|jump_format
operator|.
name|action
operator|==
name|op_ret
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|boolean_t
name|db_inst_trap_return
parameter_list|(
name|ins
parameter_list|)
name|int
name|ins
decl_stmt|;
block|{
name|alpha_instruction
name|insn
decl_stmt|;
name|insn
operator|.
name|bits
operator|=
name|ins
expr_stmt|;
return|return
operator|(
operator|(
name|insn
operator|.
name|pal_format
operator|.
name|opcode
operator|==
name|op_pal
operator|)
operator|&&
operator|(
name|insn
operator|.
name|pal_format
operator|.
name|function
operator|==
name|PAL_OSF1_rti
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|boolean_t
name|db_inst_branch
parameter_list|(
name|ins
parameter_list|)
name|int
name|ins
decl_stmt|;
block|{
name|alpha_instruction
name|insn
decl_stmt|;
name|insn
operator|.
name|bits
operator|=
name|ins
expr_stmt|;
switch|switch
condition|(
name|insn
operator|.
name|branch_format
operator|.
name|opcode
condition|)
block|{
case|case
name|op_j
case|:
case|case
name|op_br
case|:
case|case
name|op_fbeq
case|:
case|case
name|op_fblt
case|:
case|case
name|op_fble
case|:
case|case
name|op_fbne
case|:
case|case
name|op_fbge
case|:
case|case
name|op_fbgt
case|:
case|case
name|op_blbc
case|:
case|case
name|op_beq
case|:
case|case
name|op_blt
case|:
case|case
name|op_ble
case|:
case|case
name|op_blbs
case|:
case|case
name|op_bne
case|:
case|case
name|op_bge
case|:
case|case
name|op_bgt
case|:
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_function
name|boolean_t
name|db_inst_unconditional_flow_transfer
parameter_list|(
name|ins
parameter_list|)
name|int
name|ins
decl_stmt|;
block|{
name|alpha_instruction
name|insn
decl_stmt|;
name|insn
operator|.
name|bits
operator|=
name|ins
expr_stmt|;
switch|switch
condition|(
name|insn
operator|.
name|branch_format
operator|.
name|opcode
condition|)
block|{
case|case
name|op_j
case|:
case|case
name|op_br
case|:
return|return
operator|(
name|TRUE
operator|)
return|;
case|case
name|op_pal
case|:
switch|switch
condition|(
name|insn
operator|.
name|pal_format
operator|.
name|function
condition|)
block|{
case|case
name|PAL_OSF1_retsys
case|:
case|case
name|PAL_OSF1_rti
case|:
case|case
name|PAL_OSF1_callsys
case|:
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|boolean_t db_inst_spill(ins, regn) 	int ins, regn; { 	alpha_instruction insn;  	insn.bits = ins; 	return ((insn.mem_format.opcode == op_stq)&& 	    (insn.mem_format.rd == regn)); }
endif|#
directive|endif
end_endif

begin_function
name|boolean_t
name|db_inst_load
parameter_list|(
name|ins
parameter_list|)
name|int
name|ins
decl_stmt|;
block|{
name|alpha_instruction
name|insn
decl_stmt|;
name|insn
operator|.
name|bits
operator|=
name|ins
expr_stmt|;
comment|/* Loads. */
if|if
condition|(
name|insn
operator|.
name|mem_format
operator|.
name|opcode
operator|==
name|op_ldbu
operator|||
name|insn
operator|.
name|mem_format
operator|.
name|opcode
operator|==
name|op_ldq_u
operator|||
name|insn
operator|.
name|mem_format
operator|.
name|opcode
operator|==
name|op_ldwu
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
if|if
condition|(
operator|(
name|insn
operator|.
name|mem_format
operator|.
name|opcode
operator|>=
name|op_ldf
operator|)
operator|&&
operator|(
name|insn
operator|.
name|mem_format
operator|.
name|opcode
operator|<=
name|op_ldt
operator|)
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
if|if
condition|(
operator|(
name|insn
operator|.
name|mem_format
operator|.
name|opcode
operator|>=
name|op_ldl
operator|)
operator|&&
operator|(
name|insn
operator|.
name|mem_format
operator|.
name|opcode
operator|<=
name|op_ldq_l
operator|)
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
comment|/* Prefetches. */
if|if
condition|(
name|insn
operator|.
name|mem_format
operator|.
name|opcode
operator|==
name|op_special
condition|)
block|{
comment|/* Note: MB is treated as a store. */
if|if
condition|(
operator|(
name|insn
operator|.
name|mem_format
operator|.
name|displacement
operator|==
operator|(
name|short
operator|)
name|op_fetch
operator|)
operator|||
operator|(
name|insn
operator|.
name|mem_format
operator|.
name|displacement
operator|==
operator|(
name|short
operator|)
name|op_fetch_m
operator|)
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_function
name|boolean_t
name|db_inst_store
parameter_list|(
name|ins
parameter_list|)
name|int
name|ins
decl_stmt|;
block|{
name|alpha_instruction
name|insn
decl_stmt|;
name|insn
operator|.
name|bits
operator|=
name|ins
expr_stmt|;
comment|/* Stores. */
if|if
condition|(
name|insn
operator|.
name|mem_format
operator|.
name|opcode
operator|==
name|op_stw
operator|||
name|insn
operator|.
name|mem_format
operator|.
name|opcode
operator|==
name|op_stb
operator|||
name|insn
operator|.
name|mem_format
operator|.
name|opcode
operator|==
name|op_stq_u
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
if|if
condition|(
operator|(
name|insn
operator|.
name|mem_format
operator|.
name|opcode
operator|>=
name|op_stf
operator|)
operator|&&
operator|(
name|insn
operator|.
name|mem_format
operator|.
name|opcode
operator|<=
name|op_stt
operator|)
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
if|if
condition|(
operator|(
name|insn
operator|.
name|mem_format
operator|.
name|opcode
operator|>=
name|op_stl
operator|)
operator|&&
operator|(
name|insn
operator|.
name|mem_format
operator|.
name|opcode
operator|<=
name|op_stq_c
operator|)
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
comment|/* Barriers. */
if|if
condition|(
name|insn
operator|.
name|mem_format
operator|.
name|opcode
operator|==
name|op_special
condition|)
block|{
if|if
condition|(
name|insn
operator|.
name|mem_format
operator|.
name|displacement
operator|==
name|op_mb
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_function
name|db_addr_t
name|db_branch_taken
parameter_list|(
name|ins
parameter_list|,
name|pc
parameter_list|,
name|regs
parameter_list|)
name|int
name|ins
decl_stmt|;
name|db_addr_t
name|pc
decl_stmt|;
name|db_regs_t
modifier|*
name|regs
decl_stmt|;
block|{
name|alpha_instruction
name|insn
decl_stmt|;
name|db_addr_t
name|newpc
decl_stmt|;
name|insn
operator|.
name|bits
operator|=
name|ins
expr_stmt|;
switch|switch
condition|(
name|insn
operator|.
name|branch_format
operator|.
name|opcode
condition|)
block|{
comment|/* 	 * Jump format: target PC is (contents of instruction's "RB")& ~3. 	 */
case|case
name|op_j
case|:
name|newpc
operator|=
name|db_register_value
argument_list|(
name|regs
argument_list|,
name|insn
operator|.
name|jump_format
operator|.
name|rs
argument_list|)
operator|&
operator|~
literal|3
expr_stmt|;
break|break;
comment|/* 	 * Branch format: target PC is 	 *	(new PC) + (4 * sign-ext(displacement)). 	 */
case|case
name|op_br
case|:
case|case
name|op_fbeq
case|:
case|case
name|op_fblt
case|:
case|case
name|op_fble
case|:
case|case
name|op_bsr
case|:
case|case
name|op_fbne
case|:
case|case
name|op_fbge
case|:
case|case
name|op_fbgt
case|:
case|case
name|op_blbc
case|:
case|case
name|op_beq
case|:
case|case
name|op_blt
case|:
case|case
name|op_ble
case|:
case|case
name|op_blbs
case|:
case|case
name|op_bne
case|:
case|case
name|op_bge
case|:
case|case
name|op_bgt
case|:
name|newpc
operator|=
operator|(
name|insn
operator|.
name|branch_format
operator|.
name|displacement
operator|<<
literal|2
operator|)
operator|+
operator|(
name|pc
operator|+
literal|4
operator|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"DDB: db_inst_branch_taken on non-branch!\n"
argument_list|)
expr_stmt|;
name|newpc
operator|=
name|pc
expr_stmt|;
comment|/* XXX */
block|}
return|return
operator|(
name|newpc
operator|)
return|;
block|}
end_function

begin_function
name|void
name|db_show_mdpcpu
parameter_list|(
name|struct
name|pcpu
modifier|*
name|pc
parameter_list|)
block|{
name|db_printf
argument_list|(
literal|"ipis         = 0x%lx\n"
argument_list|,
name|pc
operator|->
name|pc_pending_ipis
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"next ASN     = %d\n"
argument_list|,
name|pc
operator|->
name|pc_next_asn
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

