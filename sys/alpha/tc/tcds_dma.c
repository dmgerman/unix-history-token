begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $Id$ */
end_comment

begin_comment
comment|/*	$NetBSD: tcds_dma.c,v 1.6.4.1 1996/09/10 17:28:19 cgd Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright (c) 1994 Peter Galbavy.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Peter Galbavy.  * 4. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/device.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/device.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<scsi/scsiconf.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<alpha/tc/tcreg.h>
end_include

begin_include
include|#
directive|include
file|<alpha/tc/tcvar.h>
end_include

begin_include
include|#
directive|include
file|<alpha/tc/tcdsreg.h>
end_include

begin_include
include|#
directive|include
file|<alpha/tc/tcdsvar.h>
end_include

begin_include
include|#
directive|include
file|<alpha/tc/espreg.h>
end_include

begin_include
include|#
directive|include
file|<alpha/tc/espvar.h>
end_include

begin_function
name|void
name|tcds_dma_reset
parameter_list|(
name|sc
parameter_list|)
name|struct
name|tcds_slotconfig
modifier|*
name|sc
decl_stmt|;
block|{
comment|/* TCDS SCSI disable/reset/enable. */
name|tcds_scsi_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* XXX */
name|sc
operator|->
name|sc_active
operator|=
literal|0
expr_stmt|;
comment|/* and of course we aren't */
block|}
end_function

begin_function
name|int
name|tcds_dma_isintr
parameter_list|(
name|sc
parameter_list|)
name|struct
name|tcds_slotconfig
modifier|*
name|sc
decl_stmt|;
block|{
name|int
name|x
decl_stmt|;
name|x
operator|=
name|tcds_scsi_isintr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Clear the TCDS interrupt bit. */
operator|(
name|void
operator|)
name|tcds_scsi_isintr
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* XXX */
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/*  * Pseudo (chained) interrupt from the esp driver to kick the  * current running DMA transfer. I am replying on espintr() to  * pickup and clean errors for now  *  * return 1 if it was a DMA continue.  */
end_comment

begin_function
name|int
name|tcds_dma_intr
parameter_list|(
name|sc
parameter_list|)
name|struct
name|tcds_slotconfig
modifier|*
name|sc
decl_stmt|;
block|{
name|u_int32_t
name|dud
decl_stmt|;
name|int
name|trans
init|=
literal|0
decl_stmt|,
name|resid
init|=
literal|0
decl_stmt|;
name|u_int32_t
modifier|*
name|addr
decl_stmt|,
name|dudmask
decl_stmt|;
name|u_char
name|tcl
decl_stmt|,
name|tcm
decl_stmt|,
name|tch
decl_stmt|;
name|ESP_DMA
argument_list|(
operator|(
literal|"tcds_dma %d: intr"
operator|,
name|sc
operator|->
name|sc_slot
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tcds_scsi_iserr
argument_list|(
name|sc
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* This is an "assertion" :) */
if|if
condition|(
name|sc
operator|->
name|sc_active
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"dmaintr: DMA wasn't active"
argument_list|)
expr_stmt|;
comment|/* DMA has stopped */
name|tcds_dma_enable
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_active
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dmasize
operator|==
literal|0
condition|)
block|{
comment|/* A "Transfer Pad" operation completed */
name|tcl
operator|=
name|ESP_READ_REG
argument_list|(
name|sc
operator|->
name|sc_esp
argument_list|,
name|ESP_TCL
argument_list|)
expr_stmt|;
name|tcm
operator|=
name|ESP_READ_REG
argument_list|(
name|sc
operator|->
name|sc_esp
argument_list|,
name|ESP_TCM
argument_list|)
expr_stmt|;
name|ESP_DMA
argument_list|(
operator|(
literal|"dmaintr: discarded %d bytes (tcl=%d, tcm=%d)\n"
operator|,
name|tcl
operator||
operator|(
name|tcm
operator|<<
literal|8
operator|)
operator|,
name|tcl
operator|,
name|tcm
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_iswrite
operator|&&
operator|(
name|resid
operator|=
operator|(
name|ESP_READ_REG
argument_list|(
name|sc
operator|->
name|sc_esp
argument_list|,
name|ESP_FFLAG
argument_list|)
operator|&
name|ESPFIFO_FF
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"empty FIFO of %d "
argument_list|,
name|resid
argument_list|)
expr_stmt|;
name|ESPCMD
argument_list|(
name|sc
operator|->
name|sc_esp
argument_list|,
name|ESPCMD_FLUSH
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|resid
operator|+=
operator|(
name|tcl
operator|=
name|ESP_READ_REG
argument_list|(
name|sc
operator|->
name|sc_esp
argument_list|,
name|ESP_TCL
argument_list|)
operator|)
expr_stmt|;
name|resid
operator|+=
operator|(
name|tcm
operator|=
name|ESP_READ_REG
argument_list|(
name|sc
operator|->
name|sc_esp
argument_list|,
name|ESP_TCM
argument_list|)
operator|)
operator|<<
literal|8
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_esp
operator|->
name|sc_rev
operator|==
name|ESP200
condition|)
name|resid
operator|+=
operator|(
name|tch
operator|=
name|ESP_READ_REG
argument_list|(
name|sc
operator|->
name|sc_esp
argument_list|,
name|ESP_TCH
argument_list|)
operator|)
operator|<<
literal|16
expr_stmt|;
else|else
name|tch
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|resid
operator|==
literal|0
operator|&&
operator|(
name|sc
operator|->
name|sc_esp
operator|->
name|sc_rev
operator|<=
name|ESP100A
operator|)
operator|&&
operator|(
name|sc
operator|->
name|sc_esp
operator|->
name|sc_espstat
operator|&
name|ESPSTAT_TC
operator|)
operator|==
literal|0
condition|)
name|resid
operator|=
literal|65536
expr_stmt|;
name|trans
operator|=
name|sc
operator|->
name|sc_dmasize
operator|-
name|resid
expr_stmt|;
if|if
condition|(
name|trans
operator|<
literal|0
condition|)
block|{
comment|/* transferred< 0 ? */
name|printf
argument_list|(
literal|"tcds_dma %d: xfer (%d)> req (%d)\n"
argument_list|,
name|sc
operator|->
name|sc_slot
argument_list|,
name|trans
argument_list|,
name|sc
operator|->
name|sc_dmasize
argument_list|)
expr_stmt|;
name|trans
operator|=
name|sc
operator|->
name|sc_dmasize
expr_stmt|;
block|}
name|ESP_DMA
argument_list|(
operator|(
literal|"dmaintr: tcl=%d, tcm=%d, tch=%d; trans=%d, resid=%d\n"
operator|,
name|tcl
operator|,
name|tcm
operator|,
name|tch
operator|,
name|trans
operator|,
name|resid
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Clean up unaligned DMAs into main memory. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_iswrite
condition|)
block|{
comment|/* Handle unaligned starting address, length. */
name|dud
operator|=
operator|*
name|sc
operator|->
name|sc_dud0
expr_stmt|;
if|if
condition|(
operator|(
name|dud
operator|&
name|TCDS_DUD0_VALIDBITS
operator|)
operator|!=
literal|0
condition|)
block|{
name|addr
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
operator|(
operator|(
name|vm_offset_t
operator|)
name|sc
operator|->
name|sc_dmaaddr
operator|&
operator|~
literal|0x3
operator|)
expr_stmt|;
name|dudmask
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dud
operator|&
name|TCDS_DUD0_VALID00
condition|)
name|panic
argument_list|(
literal|"tcds_dma: dud0 byte 0 valid"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dud
operator|&
name|TCDS_DUD0_VALID01
condition|)
name|dudmask
operator||=
name|TCDS_DUD_BYTE01
expr_stmt|;
if|if
condition|(
name|dud
operator|&
name|TCDS_DUD0_VALID10
condition|)
name|dudmask
operator||=
name|TCDS_DUD_BYTE10
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|dud
operator|&
name|TCDS_DUD0_VALID11
condition|)
name|dudmask
operator||=
name|TCDS_DUD_BYTE11
expr_stmt|;
endif|#
directive|endif
name|ESP_DMA
argument_list|(
operator|(
literal|"dud0 at 0x%lx dudmask 0x%x\n"
operator|,
name|addr
operator|,
name|dudmask
operator|)
argument_list|)
expr_stmt|;
name|addr
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
name|ALPHA_PHYS_TO_K0SEG
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|addr
argument_list|)
expr_stmt|;
operator|*
name|addr
operator|=
operator|(
operator|*
name|addr
operator|&
operator|~
name|dudmask
operator|)
operator||
operator|(
name|dud
operator|&
name|dudmask
operator|)
expr_stmt|;
block|}
name|dud
operator|=
operator|*
name|sc
operator|->
name|sc_dud1
expr_stmt|;
if|if
condition|(
operator|(
name|dud
operator|&
name|TCDS_DUD1_VALIDBITS
operator|)
operator|!=
literal|0
condition|)
block|{
name|addr
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
operator|(
operator|(
name|vm_offset_t
operator|)
operator|*
name|sc
operator|->
name|sc_sda
operator|<<
literal|2
operator|)
expr_stmt|;
name|dudmask
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dud
operator|&
name|TCDS_DUD1_VALID00
condition|)
name|dudmask
operator||=
name|TCDS_DUD_BYTE00
expr_stmt|;
if|if
condition|(
name|dud
operator|&
name|TCDS_DUD1_VALID01
condition|)
name|dudmask
operator||=
name|TCDS_DUD_BYTE01
expr_stmt|;
if|if
condition|(
name|dud
operator|&
name|TCDS_DUD1_VALID10
condition|)
name|dudmask
operator||=
name|TCDS_DUD_BYTE10
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|dud
operator|&
name|TCDS_DUD1_VALID11
condition|)
name|panic
argument_list|(
literal|"tcds_dma: dud1 byte 3 valid"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ESP_DMA
argument_list|(
operator|(
literal|"dud1 at 0x%lx dudmask 0x%x\n"
operator|,
name|addr
operator|,
name|dudmask
operator|)
argument_list|)
expr_stmt|;
name|addr
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
name|ALPHA_PHYS_TO_K0SEG
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|addr
argument_list|)
expr_stmt|;
operator|*
name|addr
operator|=
operator|(
operator|*
name|addr
operator|&
operator|~
name|dudmask
operator|)
operator||
operator|(
name|dud
operator|&
name|dudmask
operator|)
expr_stmt|;
block|}
comment|/* XXX deal with saved residual byte? */
block|}
operator|*
name|sc
operator|->
name|sc_dmalen
operator|-=
name|trans
expr_stmt|;
operator|*
name|sc
operator|->
name|sc_dmaaddr
operator|+=
name|trans
expr_stmt|;
if|#
directive|if
literal|0
comment|/* this is not normal operation just yet */
block|if (*sc->sc_dmalen == 0 || 	    sc->sc_esp->sc_phase != sc->sc_esp->sc_prevphase) 		return 0;
comment|/* and again */
block|dma_start(sc, sc->sc_dmaaddr, sc->sc_dmalen, sc->sc_iswrite); 	return 1;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_define
define|#
directive|define
name|DMAMAX
parameter_list|(
name|a
parameter_list|)
value|(0x02000 - ((a)& 0x1fff))
end_define

begin_comment
comment|/*  * start a dma transfer or keep it going  */
end_comment

begin_function
name|int
name|tcds_dma_setup
parameter_list|(
name|sc
parameter_list|,
name|addr
parameter_list|,
name|len
parameter_list|,
name|datain
parameter_list|,
name|dmasize
parameter_list|)
name|struct
name|tcds_slotconfig
modifier|*
name|sc
decl_stmt|;
name|caddr_t
modifier|*
name|addr
decl_stmt|;
name|size_t
modifier|*
name|len
decl_stmt|,
decl|*
name|dmasize
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|datain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* DMA into main memory */
end_comment

begin_block
block|{
name|u_int32_t
name|dic
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|sc
operator|->
name|sc_dmaaddr
operator|=
name|addr
expr_stmt|;
name|sc
operator|->
name|sc_dmalen
operator|=
name|len
expr_stmt|;
name|sc
operator|->
name|sc_iswrite
operator|=
name|datain
expr_stmt|;
name|ESP_DMA
argument_list|(
operator|(
literal|"tcds_dma %d: start %d@0x%lx,%d\n"
operator|,
name|sc
operator|->
name|sc_slot
operator|,
operator|*
name|sc
operator|->
name|sc_dmalen
operator|,
operator|*
name|sc
operator|->
name|sc_dmaaddr
operator|,
name|sc
operator|->
name|sc_iswrite
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * the rules say we cannot transfer more than the limit 	 * of this DMA chip (64k) and we cannot cross a 8k boundary. 	 */
name|size
operator|=
name|min
argument_list|(
operator|*
name|dmasize
argument_list|,
name|DMAMAX
argument_list|(
operator|(
name|size_t
operator|)
operator|*
name|sc
operator|->
name|sc_dmaaddr
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|dmasize
operator|=
name|sc
operator|->
name|sc_dmasize
operator|=
name|size
expr_stmt|;
name|ESP_DMA
argument_list|(
operator|(
literal|"dma_start: dmasize = %d\n"
operator|,
name|sc
operator|->
name|sc_dmasize
operator|)
argument_list|)
expr_stmt|;
comment|/* Load address, set/clear unaligned transfer and read/write bits. */
comment|/* XXX PICK AN ADDRESS TYPE, AND STICK TO IT! */
if|if
condition|(
operator|(
name|u_long
operator|)
operator|*
name|addr
operator|>
name|avail_end
condition|)
block|{
operator|*
name|sc
operator|->
name|sc_sda
operator|=
name|pmap_kextract
argument_list|(
operator|(
name|u_long
operator|)
operator|*
name|addr
argument_list|)
operator|>>
literal|2
expr_stmt|;
block|}
else|else
block|{
operator|*
name|sc
operator|->
name|sc_sda
operator|=
name|ALPHA_K0SEG_TO_PHYS
argument_list|(
operator|(
name|u_long
operator|)
operator|*
name|addr
argument_list|)
operator|>>
literal|2
expr_stmt|;
block|}
name|alpha_mb
argument_list|()
expr_stmt|;
name|dic
operator|=
operator|*
name|sc
operator|->
name|sc_dic
expr_stmt|;
name|dic
operator|&=
operator|~
name|TCDS_DIC_ADDRMASK
expr_stmt|;
name|dic
operator||=
operator|(
name|vm_offset_t
operator|)
operator|*
name|addr
operator|&
name|TCDS_DIC_ADDRMASK
expr_stmt|;
if|if
condition|(
name|datain
condition|)
name|dic
operator||=
name|TCDS_DIC_WRITE
expr_stmt|;
else|else
name|dic
operator|&=
operator|~
name|TCDS_DIC_WRITE
expr_stmt|;
operator|*
name|sc
operator|->
name|sc_dic
operator|=
name|dic
expr_stmt|;
name|alpha_mb
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_function
name|void
name|tcds_dma_go
parameter_list|(
name|sc
parameter_list|)
name|struct
name|tcds_slotconfig
modifier|*
name|sc
decl_stmt|;
block|{
comment|/* mark unit as DMA-active */
name|sc
operator|->
name|sc_active
operator|=
literal|1
expr_stmt|;
comment|/* Start DMA */
name|tcds_dma_enable
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|tcds_dma_isactive
parameter_list|(
name|sc
parameter_list|)
name|struct
name|tcds_slotconfig
modifier|*
name|sc
decl_stmt|;
block|{
return|return
operator|(
name|sc
operator|->
name|sc_active
operator|)
return|;
block|}
end_function

end_unit

