begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/*	$NetBSD: am7990.c,v 1.43 1998/03/29 22:36:42 mycroft Exp $	*/
end_comment

begin_comment
comment|/*-  * Copyright (c) 1997 The NetBSD Foundation, Inc.  * All rights reserved.  *  * This code is derived from software contributed to The NetBSD Foundation  * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,  * NASA Ames Research Center.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the NetBSD  *	Foundation, Inc. and its contributors.  * 4. Neither the name of The NetBSD Foundation nor the names of its  *    contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*-  * Copyright (c) 1995 Charles M. Hannum.  All rights reserved.  * Copyright (c) 1992, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Ralph Campbell and Rick Macklem.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)if_le.c	8.2 (Berkeley) 11/16/93  */
end_comment

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/netisr.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<alpha/tc/am7990reg.h>
end_include

begin_include
include|#
directive|include
file|<alpha/tc/am7990var.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|LEDEBUG
end_ifdef

begin_decl_stmt
name|void
name|am7990_recv_print
name|__P
argument_list|(
operator|(
expr|struct
name|am7990_softc
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|am7990_xmit_print
name|__P
argument_list|(
operator|(
expr|struct
name|am7990_softc
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|integrate
name|void
name|am7990_rint
name|__P
argument_list|(
operator|(
expr|struct
name|am7990_softc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|integrate
name|void
name|am7990_tint
name|__P
argument_list|(
operator|(
expr|struct
name|am7990_softc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|integrate
name|int
name|am7990_put
name|__P
argument_list|(
operator|(
expr|struct
name|am7990_softc
operator|*
operator|,
name|int
operator|,
expr|struct
name|mbuf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|integrate
name|struct
name|mbuf
modifier|*
name|am7990_get
name|__P
argument_list|(
operator|(
expr|struct
name|am7990_softc
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|integrate
name|void
name|am7990_read
name|__P
argument_list|(
operator|(
expr|struct
name|am7990_softc
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* hide void am7990_shutdown __P((void *)); */
end_comment

begin_decl_stmt
name|int
name|am7990_mediachange
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|am7990_mediastatus
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|,
expr|struct
name|ifmediareq
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ifp
value|(&sc->sc_ethercom.ac_if)
end_define

begin_decl_stmt
specifier|static
name|__inline
name|u_int16_t
name|ether_cmp
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|ether_sprintf
parameter_list|(
name|u_char
modifier|*
name|ap
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Compare two Ether/802 addresses for equality, inlined and  * unrolled for speed.  Use this like bcmp().  *  * XXX: Add<machine/inlines.h> for stuff like this?  * XXX: or maybe add it to libkern.h instead?  *  * "I'd love to have an inline assembler version of this."  * XXX: Who wanted that? mycroft?  I wrote one, but this  * version in C is as good as hand-coded assembly. -gwr  *  * Please do NOT tweak this without looking at the actual  * assembly code generated before and after your tweaks!  */
end_comment

begin_function
specifier|static
name|__inline
name|u_int16_t
name|ether_cmp
parameter_list|(
name|one
parameter_list|,
name|two
parameter_list|)
name|void
modifier|*
name|one
decl_stmt|,
decl|*
name|two
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|u_int16_t
modifier|*
name|a
init|=
operator|(
name|u_short
operator|*
operator|)
name|one
decl_stmt|;
specifier|register
name|u_int16_t
modifier|*
name|b
init|=
operator|(
name|u_short
operator|*
operator|)
name|two
decl_stmt|;
specifier|register
name|u_int16_t
name|diff
decl_stmt|;
ifdef|#
directive|ifdef
name|m68k
comment|/* 	 * The post-increment-pointer form produces the best 	 * machine code for m68k.  This was carefully tuned 	 * so it compiles to just 8 short (2-byte) op-codes! 	 */
name|diff
operator|=
operator|*
name|a
operator|++
operator|-
operator|*
name|b
operator|++
expr_stmt|;
name|diff
operator||=
operator|*
name|a
operator|++
operator|-
operator|*
name|b
operator|++
expr_stmt|;
name|diff
operator||=
operator|*
name|a
operator|++
operator|-
operator|*
name|b
operator|++
expr_stmt|;
else|#
directive|else
comment|/* 	 * Most modern CPUs do better with a single expresion. 	 * Note that short-cut evaluation is NOT helpful here, 	 * because it just makes the code longer, not faster! 	 */
name|diff
operator|=
operator|(
name|a
index|[
literal|0
index|]
operator|-
name|b
index|[
literal|0
index|]
operator|)
operator||
operator|(
name|a
index|[
literal|1
index|]
operator|-
name|b
index|[
literal|1
index|]
operator|)
operator||
operator|(
name|a
index|[
literal|2
index|]
operator|-
name|b
index|[
literal|2
index|]
operator|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|diff
operator|)
return|;
block|}
end_block

begin_define
define|#
directive|define
name|ETHER_CMP
value|ether_cmp
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|LANCE_REVC_BUG
end_ifdef

begin_comment
comment|/* Make sure this is short-aligned, for ether_cmp(). */
end_comment

begin_decl_stmt
specifier|static
name|u_int16_t
name|bcast_enaddr
index|[
literal|3
index|]
init|=
block|{
operator|~
literal|0
block|,
operator|~
literal|0
block|,
operator|~
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|am7990_config
parameter_list|(
name|sc
parameter_list|)
name|struct
name|am7990_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|int
name|mem
decl_stmt|,
name|i
decl_stmt|;
comment|/* Make sure the chip is stopped. */
name|am7990_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Initialize ifnet structure. */
name|ifp
operator|->
name|if_unit
operator|=
name|sc
operator|->
name|unit
expr_stmt|;
name|ifp
operator|->
name|if_name
operator|=
literal|"le"
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|am7990_start
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|am7990_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_output
operator|=
name|ether_output
expr_stmt|;
name|ifp
operator|->
name|if_watchdog
operator|=
name|am7990_watchdog
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
ifdef|#
directive|ifdef
name|LANCE_REVC_BUG
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_MULTICAST
expr_stmt|;
endif|#
directive|endif
comment|/* Initialize ifmedia structures. */
name|ifmedia_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_media
argument_list|,
literal|0
argument_list|,
name|am7990_mediachange
argument_list|,
name|am7990_mediastatus
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_supmedia
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|sc_nsupmedia
condition|;
name|i
operator|++
control|)
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|sc_media
argument_list|,
name|sc
operator|->
name|sc_supmedia
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
operator|&
name|sc
operator|->
name|sc_media
argument_list|,
name|sc
operator|->
name|sc_defaultmedia
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|sc_media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_MANUAL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
operator|&
name|sc
operator|->
name|sc_media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_MANUAL
argument_list|)
expr_stmt|;
block|}
comment|/* Attach the interface. */
name|bcopy
argument_list|(
name|sc
operator|->
name|sc_enaddr
argument_list|,
operator|(
operator|(
expr|struct
name|arpcom
operator|*
operator|)
name|ifp
operator|)
operator|->
name|ac_enaddr
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: address %s\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|ether_sprintf
argument_list|(
name|sc
operator|->
name|sc_enaddr
argument_list|)
argument_list|)
expr_stmt|;
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|ETHER_BPF_SUPPORTED
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|sc_memsize
condition|)
block|{
case|case
literal|8192
case|:
name|sc
operator|->
name|sc_nrbuf
operator|=
literal|4
expr_stmt|;
name|sc
operator|->
name|sc_ntbuf
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|16384
case|:
name|sc
operator|->
name|sc_nrbuf
operator|=
literal|8
expr_stmt|;
name|sc
operator|->
name|sc_ntbuf
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|32768
case|:
name|sc
operator|->
name|sc_nrbuf
operator|=
literal|16
expr_stmt|;
name|sc
operator|->
name|sc_ntbuf
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|65536
case|:
name|sc
operator|->
name|sc_nrbuf
operator|=
literal|32
expr_stmt|;
name|sc
operator|->
name|sc_ntbuf
operator|=
literal|8
expr_stmt|;
break|break;
case|case
literal|131072
case|:
name|sc
operator|->
name|sc_nrbuf
operator|=
literal|64
expr_stmt|;
name|sc
operator|->
name|sc_ntbuf
operator|=
literal|16
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"am7990_config: weird memory size"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%s: %d receive buffers, %d transmit buffers\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_nrbuf
argument_list|,
name|sc
operator|->
name|sc_ntbuf
argument_list|)
expr_stmt|;
comment|/* 	sc->sc_sh = shutdownhook_establish(am7990_shutdown, sc); 	if (sc->sc_sh == NULL) 		panic("am7990_config: can't establish shutdownhook"); */
name|sc
operator|->
name|sc_rbufaddr
operator|=
name|malloc
argument_list|(
name|sc
operator|->
name|sc_nrbuf
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_tbufaddr
operator|=
name|malloc
argument_list|(
name|sc
operator|->
name|sc_ntbuf
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|mem
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_initaddr
operator|=
name|mem
expr_stmt|;
name|mem
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|leinit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rmdaddr
operator|=
name|mem
expr_stmt|;
name|mem
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|lermd
argument_list|)
operator|*
name|sc
operator|->
name|sc_nrbuf
expr_stmt|;
name|sc
operator|->
name|sc_tmdaddr
operator|=
name|mem
expr_stmt|;
name|mem
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|letmd
argument_list|)
operator|*
name|sc
operator|->
name|sc_ntbuf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|sc_nrbuf
condition|;
name|i
operator|++
operator|,
name|mem
operator|+=
name|LEBLEN
control|)
name|sc
operator|->
name|sc_rbufaddr
index|[
name|i
index|]
operator|=
name|mem
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|sc_ntbuf
condition|;
name|i
operator|++
operator|,
name|mem
operator|+=
name|LEBLEN
control|)
name|sc
operator|->
name|sc_tbufaddr
index|[
name|i
index|]
operator|=
name|mem
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
if|if
condition|(
name|mem
operator|>
operator|...
condition|)
name|panic
argument_list|(
operator|...
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|NRND
operator|>
literal|0
name|rnd_attach_source
argument_list|(
operator|&
name|sc
operator|->
name|rnd_source
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|RND_TYPE_NET
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|am7990_reset
parameter_list|(
name|sc
parameter_list|)
name|struct
name|am7990_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|am7990_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set up the initialization block and the descriptor rings.  */
end_comment

begin_function
name|void
name|am7990_meminit
parameter_list|(
name|sc
parameter_list|)
specifier|register
name|struct
name|am7990_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|u_long
name|a
decl_stmt|;
name|int
name|bix
decl_stmt|;
name|struct
name|leinit
name|init
decl_stmt|;
name|struct
name|lermd
name|rmd
decl_stmt|;
name|struct
name|letmd
name|tmd
decl_stmt|;
name|u_int8_t
modifier|*
name|myaddr
decl_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
condition|)
name|init
operator|.
name|init_mode
operator|=
name|LE_MODE_NORMAL
operator||
name|LE_MODE_PROM
expr_stmt|;
else|else
name|init
operator|.
name|init_mode
operator|=
name|LE_MODE_NORMAL
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_initmodemedia
operator|==
literal|1
condition|)
name|init
operator|.
name|init_mode
operator||=
name|LE_MODE_PSEL0
expr_stmt|;
comment|/* 	 * Update our private copy of the Ethernet address. 	 * We NEED the copy so we can ensure its alignment! 	 */
name|bcopy
argument_list|(
operator|(
operator|(
expr|struct
name|arpcom
operator|*
operator|)
name|ifp
operator|)
operator|->
name|ac_enaddr
argument_list|,
name|sc
operator|->
name|sc_enaddr
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|myaddr
operator|=
name|sc
operator|->
name|sc_enaddr
expr_stmt|;
name|init
operator|.
name|init_padr
index|[
literal|0
index|]
operator|=
operator|(
name|myaddr
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|myaddr
index|[
literal|0
index|]
expr_stmt|;
name|init
operator|.
name|init_padr
index|[
literal|1
index|]
operator|=
operator|(
name|myaddr
index|[
literal|3
index|]
operator|<<
literal|8
operator|)
operator||
name|myaddr
index|[
literal|2
index|]
expr_stmt|;
name|init
operator|.
name|init_padr
index|[
literal|2
index|]
operator|=
operator|(
name|myaddr
index|[
literal|5
index|]
operator|<<
literal|8
operator|)
operator||
name|myaddr
index|[
literal|4
index|]
expr_stmt|;
name|am7990_setladrf
argument_list|(
operator|&
name|sc
operator|->
name|sc_ethercom
argument_list|,
name|init
operator|.
name|init_ladrf
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_last_rd
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_first_td
operator|=
name|sc
operator|->
name|sc_last_td
operator|=
name|sc
operator|->
name|sc_no_td
operator|=
literal|0
expr_stmt|;
name|a
operator|=
name|sc
operator|->
name|sc_addr
operator|+
name|LE_RMDADDR
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|init
operator|.
name|init_rdra
operator|=
name|a
expr_stmt|;
name|init
operator|.
name|init_rlen
operator|=
operator|(
name|a
operator|>>
literal|16
operator|)
operator||
operator|(
operator|(
name|ffs
argument_list|(
name|sc
operator|->
name|sc_nrbuf
argument_list|)
operator|-
literal|1
operator|)
operator|<<
literal|13
operator|)
expr_stmt|;
name|a
operator|=
name|sc
operator|->
name|sc_addr
operator|+
name|LE_TMDADDR
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|init
operator|.
name|init_tdra
operator|=
name|a
expr_stmt|;
name|init
operator|.
name|init_tlen
operator|=
operator|(
name|a
operator|>>
literal|16
operator|)
operator||
operator|(
operator|(
name|ffs
argument_list|(
name|sc
operator|->
name|sc_ntbuf
argument_list|)
operator|-
literal|1
operator|)
operator|<<
literal|13
operator|)
expr_stmt|;
call|(
modifier|*
name|sc
operator|->
name|sc_copytodesc
call|)
argument_list|(
name|sc
argument_list|,
operator|&
name|init
argument_list|,
name|LE_INITADDR
argument_list|(
name|sc
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|init
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Set up receive ring descriptors. 	 */
for|for
control|(
name|bix
operator|=
literal|0
init|;
name|bix
operator|<
name|sc
operator|->
name|sc_nrbuf
condition|;
name|bix
operator|++
control|)
block|{
name|a
operator|=
name|sc
operator|->
name|sc_addr
operator|+
name|LE_RBUFADDR
argument_list|(
name|sc
argument_list|,
name|bix
argument_list|)
expr_stmt|;
name|rmd
operator|.
name|rmd0
operator|=
name|a
expr_stmt|;
name|rmd
operator|.
name|rmd1_hadr
operator|=
name|a
operator|>>
literal|16
expr_stmt|;
name|rmd
operator|.
name|rmd1_bits
operator|=
name|LE_R1_OWN
expr_stmt|;
name|rmd
operator|.
name|rmd2
operator|=
operator|-
name|LEBLEN
operator||
name|LE_XMD2_ONES
expr_stmt|;
name|rmd
operator|.
name|rmd3
operator|=
literal|0
expr_stmt|;
call|(
modifier|*
name|sc
operator|->
name|sc_copytodesc
call|)
argument_list|(
name|sc
argument_list|,
operator|&
name|rmd
argument_list|,
name|LE_RMDADDR
argument_list|(
name|sc
argument_list|,
name|bix
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|rmd
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Set up transmit ring descriptors. 	 */
for|for
control|(
name|bix
operator|=
literal|0
init|;
name|bix
operator|<
name|sc
operator|->
name|sc_ntbuf
condition|;
name|bix
operator|++
control|)
block|{
name|a
operator|=
name|sc
operator|->
name|sc_addr
operator|+
name|LE_TBUFADDR
argument_list|(
name|sc
argument_list|,
name|bix
argument_list|)
expr_stmt|;
name|tmd
operator|.
name|tmd0
operator|=
name|a
expr_stmt|;
name|tmd
operator|.
name|tmd1_hadr
operator|=
name|a
operator|>>
literal|16
expr_stmt|;
name|tmd
operator|.
name|tmd1_bits
operator|=
literal|0
expr_stmt|;
name|tmd
operator|.
name|tmd2
operator|=
literal|0
operator||
name|LE_XMD2_ONES
expr_stmt|;
name|tmd
operator|.
name|tmd3
operator|=
literal|0
expr_stmt|;
call|(
modifier|*
name|sc
operator|->
name|sc_copytodesc
call|)
argument_list|(
name|sc
argument_list|,
operator|&
name|tmd
argument_list|,
name|LE_TMDADDR
argument_list|(
name|sc
argument_list|,
name|bix
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|tmd
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|am7990_stop
parameter_list|(
name|sc
parameter_list|)
name|struct
name|am7990_softc
modifier|*
name|sc
decl_stmt|;
block|{
call|(
modifier|*
name|sc
operator|->
name|sc_wrcsr
call|)
argument_list|(
name|sc
argument_list|,
name|LE_CSR0
argument_list|,
name|LE_C0_STOP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialization of interface; set up initialization block  * and transmit/receive descriptor rings.  */
end_comment

begin_function
name|void
name|am7990_init
parameter_list|(
name|sc
parameter_list|)
specifier|register
name|struct
name|am7990_softc
modifier|*
name|sc
decl_stmt|;
block|{
specifier|register
name|int
name|timo
decl_stmt|;
name|u_long
name|a
decl_stmt|;
call|(
modifier|*
name|sc
operator|->
name|sc_wrcsr
call|)
argument_list|(
name|sc
argument_list|,
name|LE_CSR0
argument_list|,
name|LE_C0_STOP
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* Newer LANCE chips have a reset register */
if|if
condition|(
name|sc
operator|->
name|sc_hwreset
condition|)
call|(
modifier|*
name|sc
operator|->
name|sc_hwreset
call|)
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Set the correct byte swapping mode, etc. */
call|(
modifier|*
name|sc
operator|->
name|sc_wrcsr
call|)
argument_list|(
name|sc
argument_list|,
name|LE_CSR3
argument_list|,
name|sc
operator|->
name|sc_conf3
argument_list|)
expr_stmt|;
comment|/* Set up LANCE init block. */
name|am7990_meminit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Give LANCE the physical address of its init block. */
name|a
operator|=
name|sc
operator|->
name|sc_addr
operator|+
name|LE_INITADDR
argument_list|(
name|sc
argument_list|)
expr_stmt|;
call|(
modifier|*
name|sc
operator|->
name|sc_wrcsr
call|)
argument_list|(
name|sc
argument_list|,
name|LE_CSR1
argument_list|,
name|a
argument_list|)
expr_stmt|;
call|(
modifier|*
name|sc
operator|->
name|sc_wrcsr
call|)
argument_list|(
name|sc
argument_list|,
name|LE_CSR2
argument_list|,
name|a
operator|>>
literal|16
argument_list|)
expr_stmt|;
comment|/* Try to initialize the LANCE. */
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
call|(
modifier|*
name|sc
operator|->
name|sc_wrcsr
call|)
argument_list|(
name|sc
argument_list|,
name|LE_CSR0
argument_list|,
name|LE_C0_INIT
argument_list|)
expr_stmt|;
comment|/* Wait for initialization to finish. */
for|for
control|(
name|timo
operator|=
literal|100000
init|;
name|timo
condition|;
name|timo
operator|--
control|)
if|if
condition|(
call|(
modifier|*
name|sc
operator|->
name|sc_rdcsr
call|)
argument_list|(
name|sc
argument_list|,
name|LE_CSR0
argument_list|)
operator|&
name|LE_C0_IDON
condition|)
break|break;
if|if
condition|(
call|(
modifier|*
name|sc
operator|->
name|sc_rdcsr
call|)
argument_list|(
name|sc
argument_list|,
name|LE_CSR0
argument_list|)
operator|&
name|LE_C0_IDON
condition|)
block|{
comment|/* Start the LANCE. */
call|(
modifier|*
name|sc
operator|->
name|sc_wrcsr
call|)
argument_list|(
name|sc
argument_list|,
name|LE_CSR0
argument_list|,
name|LE_C0_INEA
operator||
name|LE_C0_STRT
operator||
name|LE_C0_IDON
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
name|am7990_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"%s: card failed to initialize\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_hwinit
condition|)
call|(
modifier|*
name|sc
operator|->
name|sc_hwinit
call|)
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Routine to copy from mbuf chain to transmit buffer in  * network buffer memory.  */
end_comment

begin_function
name|integrate
name|int
name|am7990_put
parameter_list|(
name|sc
parameter_list|,
name|boff
parameter_list|,
name|m
parameter_list|)
name|struct
name|am7990_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|boff
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|,
name|tlen
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|m
condition|;
name|m
operator|=
name|n
control|)
block|{
name|len
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|MFREE
argument_list|(
name|m
argument_list|,
name|n
argument_list|)
expr_stmt|;
continue|continue;
block|}
call|(
modifier|*
name|sc
operator|->
name|sc_copytobuf
call|)
argument_list|(
name|sc
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|boff
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|boff
operator|+=
name|len
expr_stmt|;
name|tlen
operator|+=
name|len
expr_stmt|;
name|MFREE
argument_list|(
name|m
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tlen
operator|<
name|LEMINSIZE
condition|)
block|{
call|(
modifier|*
name|sc
operator|->
name|sc_zerobuf
call|)
argument_list|(
name|sc
argument_list|,
name|boff
argument_list|,
name|LEMINSIZE
operator|-
name|tlen
argument_list|)
expr_stmt|;
name|tlen
operator|=
name|LEMINSIZE
expr_stmt|;
block|}
return|return
operator|(
name|tlen
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Pull data off an interface.  * Len is length of data, with local net header stripped.  * We copy the data into mbufs.  When full cluster sized units are present  * we copy into clusters.  */
end_comment

begin_function
name|integrate
name|struct
name|mbuf
modifier|*
name|am7990_get
parameter_list|(
name|sc
parameter_list|,
name|boff
parameter_list|,
name|totlen
parameter_list|)
name|struct
name|am7990_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|boff
decl_stmt|,
name|totlen
decl_stmt|;
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|top
decl_stmt|,
modifier|*
modifier|*
name|mp
decl_stmt|;
name|int
name|len
decl_stmt|;
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|totlen
expr_stmt|;
name|len
operator|=
name|MHLEN
expr_stmt|;
name|top
operator|=
literal|0
expr_stmt|;
name|mp
operator|=
operator|&
name|top
expr_stmt|;
while|while
condition|(
name|totlen
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|top
condition|)
block|{
name|MGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|top
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|len
operator|=
name|MLEN
expr_stmt|;
block|}
if|if
condition|(
name|totlen
operator|>=
name|MINCLSIZE
condition|)
block|{
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|top
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|len
operator|=
name|MCLBYTES
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|top
condition|)
block|{
specifier|register
name|int
name|pad
init|=
name|ALIGN
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
decl_stmt|;
name|m
operator|->
name|m_data
operator|+=
name|pad
expr_stmt|;
name|len
operator|-=
name|pad
expr_stmt|;
block|}
name|m
operator|->
name|m_len
operator|=
name|len
operator|=
name|min
argument_list|(
name|totlen
argument_list|,
name|len
argument_list|)
expr_stmt|;
call|(
modifier|*
name|sc
operator|->
name|sc_copyfrombuf
call|)
argument_list|(
name|sc
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|boff
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|boff
operator|+=
name|len
expr_stmt|;
name|totlen
operator|-=
name|len
expr_stmt|;
operator|*
name|mp
operator|=
name|m
expr_stmt|;
name|mp
operator|=
operator|&
name|m
operator|->
name|m_next
expr_stmt|;
block|}
return|return
operator|(
name|top
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Pass a packet to the higher levels.  */
end_comment

begin_function
name|integrate
name|void
name|am7990_read
parameter_list|(
name|sc
parameter_list|,
name|boff
parameter_list|,
name|len
parameter_list|)
specifier|register
name|struct
name|am7990_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|boff
decl_stmt|,
name|len
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
if|if
condition|(
name|len
operator|<=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
operator|||
name|len
operator|>
name|ETHERMTU
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|LEDEBUG
name|printf
argument_list|(
literal|"%s: invalid packet size %d; dropping\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
comment|/* Pull packet off interface. */
name|m
operator|=
name|am7990_get
argument_list|(
name|sc
argument_list|,
name|boff
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
comment|/* We assume that the header fit entirely in one mbuf. */
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LANCE_REVC_BUG
comment|/* 	 * The old LANCE (Rev. C) chips have a bug which causes 	 * garbage to be inserted in front of the received packet. 	 * The work-around is to ignore packets with an invalid 	 * destination address (garbage will usually not match). 	 * Of course, this precludes multicast support... 	 */
if|if
condition|(
name|ETHER_CMP
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|,
name|sc
operator|->
name|sc_enaddr
argument_list|)
operator|&&
name|ETHER_CMP
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|,
name|bcast_enaddr
argument_list|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* Pass the packet up, with the ether header sort-of removed. */
name|m_adj
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
name|ether_input
argument_list|(
name|ifp
argument_list|,
name|eh
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|integrate
name|void
name|am7990_rint
parameter_list|(
name|sc
parameter_list|)
name|struct
name|am7990_softc
modifier|*
name|sc
decl_stmt|;
block|{
specifier|register
name|int
name|bix
decl_stmt|;
name|int
name|rp
decl_stmt|;
name|struct
name|lermd
name|rmd
decl_stmt|;
name|bix
operator|=
name|sc
operator|->
name|sc_last_rd
expr_stmt|;
comment|/* Process all buffers with valid data. */
for|for
control|(
init|;
condition|;
control|)
block|{
name|rp
operator|=
name|LE_RMDADDR
argument_list|(
name|sc
argument_list|,
name|bix
argument_list|)
expr_stmt|;
call|(
modifier|*
name|sc
operator|->
name|sc_copyfromdesc
call|)
argument_list|(
name|sc
argument_list|,
operator|&
name|rmd
argument_list|,
name|rp
argument_list|,
sizeof|sizeof
argument_list|(
name|rmd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rmd
operator|.
name|rmd1_bits
operator|&
name|LE_R1_OWN
condition|)
break|break;
if|if
condition|(
name|rmd
operator|.
name|rmd1_bits
operator|&
name|LE_R1_ERR
condition|)
block|{
if|if
condition|(
name|rmd
operator|.
name|rmd1_bits
operator|&
name|LE_R1_ENP
condition|)
block|{
ifdef|#
directive|ifdef
name|LEDEBUG
if|if
condition|(
operator|(
name|rmd
operator|.
name|rmd1_bits
operator|&
name|LE_R1_OFLO
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|rmd
operator|.
name|rmd1_bits
operator|&
name|LE_R1_FRAM
condition|)
name|printf
argument_list|(
literal|"%s: framing error\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rmd
operator|.
name|rmd1_bits
operator|&
name|LE_R1_CRC
condition|)
name|printf
argument_list|(
literal|"%s: crc mismatch\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
else|else
block|{
if|if
condition|(
name|rmd
operator|.
name|rmd1_bits
operator|&
name|LE_R1_OFLO
condition|)
name|printf
argument_list|(
literal|"%s: overflow\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rmd
operator|.
name|rmd1_bits
operator|&
name|LE_R1_BUFF
condition|)
name|printf
argument_list|(
literal|"%s: receive buffer error\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|rmd
operator|.
name|rmd1_bits
operator|&
operator|(
name|LE_R1_STP
operator||
name|LE_R1_ENP
operator|)
operator|)
operator|!=
operator|(
name|LE_R1_STP
operator||
name|LE_R1_ENP
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: dropping chained buffer\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|LEDEBUG
if|if
condition|(
name|sc
operator|->
name|sc_debug
condition|)
name|am7990_recv_print
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_last_rd
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|am7990_read
argument_list|(
name|sc
argument_list|,
name|LE_RBUFADDR
argument_list|(
name|sc
argument_list|,
name|bix
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|rmd
operator|.
name|rmd3
operator|-
literal|4
argument_list|)
expr_stmt|;
block|}
name|rmd
operator|.
name|rmd1_bits
operator|=
name|LE_R1_OWN
expr_stmt|;
name|rmd
operator|.
name|rmd2
operator|=
operator|-
name|LEBLEN
operator||
name|LE_XMD2_ONES
expr_stmt|;
name|rmd
operator|.
name|rmd3
operator|=
literal|0
expr_stmt|;
call|(
modifier|*
name|sc
operator|->
name|sc_copytodesc
call|)
argument_list|(
name|sc
argument_list|,
operator|&
name|rmd
argument_list|,
name|rp
argument_list|,
sizeof|sizeof
argument_list|(
name|rmd
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LEDEBUG
if|if
condition|(
name|sc
operator|->
name|sc_debug
condition|)
name|printf
argument_list|(
literal|"sc->sc_last_rd = %x, rmd: "
literal|"ladr %04x, hadr %02x, flags %02x, "
literal|"bcnt %04x, mcnt %04x\n"
argument_list|,
name|sc
operator|->
name|sc_last_rd
argument_list|,
name|rmd
operator|.
name|rmd0
argument_list|,
name|rmd
operator|.
name|rmd1_hadr
argument_list|,
name|rmd
operator|.
name|rmd1_bits
argument_list|,
name|rmd
operator|.
name|rmd2
argument_list|,
name|rmd
operator|.
name|rmd3
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|++
name|bix
operator|==
name|sc
operator|->
name|sc_nrbuf
condition|)
name|bix
operator|=
literal|0
expr_stmt|;
block|}
name|sc
operator|->
name|sc_last_rd
operator|=
name|bix
expr_stmt|;
block|}
end_function

begin_function
name|integrate
name|void
name|am7990_tint
parameter_list|(
name|sc
parameter_list|)
specifier|register
name|struct
name|am7990_softc
modifier|*
name|sc
decl_stmt|;
block|{
specifier|register
name|int
name|bix
decl_stmt|;
name|struct
name|letmd
name|tmd
decl_stmt|;
name|bix
operator|=
name|sc
operator|->
name|sc_first_td
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_no_td
operator|<=
literal|0
condition|)
break|break;
ifdef|#
directive|ifdef
name|LEDEBUG
if|if
condition|(
name|sc
operator|->
name|sc_debug
condition|)
name|printf
argument_list|(
literal|"trans tmd: "
literal|"ladr %04x, hadr %02x, flags %02x, "
literal|"bcnt %04x, mcnt %04x\n"
argument_list|,
name|tmd
operator|.
name|tmd0
argument_list|,
name|tmd
operator|.
name|tmd1_hadr
argument_list|,
name|tmd
operator|.
name|tmd1_bits
argument_list|,
name|tmd
operator|.
name|tmd2
argument_list|,
name|tmd
operator|.
name|tmd3
argument_list|)
expr_stmt|;
endif|#
directive|endif
call|(
modifier|*
name|sc
operator|->
name|sc_copyfromdesc
call|)
argument_list|(
name|sc
argument_list|,
operator|&
name|tmd
argument_list|,
name|LE_TMDADDR
argument_list|(
name|sc
argument_list|,
name|bix
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|tmd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmd
operator|.
name|tmd1_bits
operator|&
name|LE_T1_OWN
condition|)
break|break;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
if|if
condition|(
name|tmd
operator|.
name|tmd1_bits
operator|&
name|LE_T1_ERR
condition|)
block|{
if|if
condition|(
name|tmd
operator|.
name|tmd3
operator|&
name|LE_T3_BUFF
condition|)
name|printf
argument_list|(
literal|"%s: transmit buffer error\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tmd
operator|.
name|tmd3
operator|&
name|LE_T3_UFLO
condition|)
name|printf
argument_list|(
literal|"%s: underflow\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmd
operator|.
name|tmd3
operator|&
operator|(
name|LE_T3_BUFF
operator||
name|LE_T3_UFLO
operator|)
condition|)
block|{
name|am7990_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|tmd
operator|.
name|tmd3
operator|&
name|LE_T3_LCAR
condition|)
block|{
name|sc
operator|->
name|sc_havecarrier
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_nocarrier
condition|)
call|(
modifier|*
name|sc
operator|->
name|sc_nocarrier
call|)
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%s: lost carrier\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tmd
operator|.
name|tmd3
operator|&
name|LE_T3_LCOL
condition|)
name|ifp
operator|->
name|if_collisions
operator|++
expr_stmt|;
if|if
condition|(
name|tmd
operator|.
name|tmd3
operator|&
name|LE_T3_RTRY
condition|)
block|{
name|printf
argument_list|(
literal|"%s: excessive collisions, tdr %d\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|tmd
operator|.
name|tmd3
operator|&
name|LE_T3_TDR_MASK
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_collisions
operator|+=
literal|16
expr_stmt|;
block|}
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|tmd
operator|.
name|tmd1_bits
operator|&
name|LE_T1_ONE
condition|)
name|ifp
operator|->
name|if_collisions
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|tmd
operator|.
name|tmd1_bits
operator|&
name|LE_T1_MORE
condition|)
comment|/* Real number is unknown. */
name|ifp
operator|->
name|if_collisions
operator|+=
literal|2
expr_stmt|;
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|++
name|bix
operator|==
name|sc
operator|->
name|sc_ntbuf
condition|)
name|bix
operator|=
literal|0
expr_stmt|;
operator|--
name|sc
operator|->
name|sc_no_td
expr_stmt|;
block|}
name|sc
operator|->
name|sc_first_td
operator|=
name|bix
expr_stmt|;
name|am7990_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_no_td
operator|==
literal|0
condition|)
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Controller interrupt.  */
end_comment

begin_function
name|void
name|am7990_intr
parameter_list|(
name|arg
parameter_list|)
specifier|register
name|void
modifier|*
name|arg
decl_stmt|;
block|{
specifier|register
name|struct
name|am7990_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
specifier|register
name|u_int16_t
name|isr
decl_stmt|;
name|isr
operator|=
call|(
modifier|*
name|sc
operator|->
name|sc_rdcsr
call|)
argument_list|(
name|sc
argument_list|,
name|LE_CSR0
argument_list|)
operator||
name|sc
operator|->
name|sc_saved_csr0
expr_stmt|;
name|sc
operator|->
name|sc_saved_csr0
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|LEDEBUG
if|if
condition|(
name|sc
operator|->
name|sc_debug
condition|)
name|printf
argument_list|(
literal|"%s: am7990_intr entering with isr=%04x\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|isr
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|isr
operator|&
name|LE_C0_INTR
operator|)
operator|==
literal|0
condition|)
return|return;
call|(
modifier|*
name|sc
operator|->
name|sc_wrcsr
call|)
argument_list|(
name|sc
argument_list|,
name|LE_CSR0
argument_list|,
name|isr
operator|&
operator|(
name|LE_C0_INEA
operator||
name|LE_C0_BABL
operator||
name|LE_C0_MISS
operator||
name|LE_C0_MERR
operator||
name|LE_C0_RINT
operator||
name|LE_C0_TINT
operator||
name|LE_C0_IDON
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|isr
operator|&
name|LE_C0_ERR
condition|)
block|{
if|if
condition|(
name|isr
operator|&
name|LE_C0_BABL
condition|)
block|{
ifdef|#
directive|ifdef
name|LEDEBUG
name|printf
argument_list|(
literal|"%s: babble\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|if (isr& LE_C0_CERR) { 			printf("%s: collision error\n", 				device_get_nameunit(sc->sc_dev)); 			ifp->if_collisions++; 		}
endif|#
directive|endif
if|if
condition|(
name|isr
operator|&
name|LE_C0_MISS
condition|)
block|{
ifdef|#
directive|ifdef
name|LEDEBUG
name|printf
argument_list|(
literal|"%s: missed packet\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|isr
operator|&
name|LE_C0_MERR
condition|)
block|{
name|printf
argument_list|(
literal|"%s: memory error\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
name|am7990_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
operator|(
name|isr
operator|&
name|LE_C0_RXON
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: receiver disabled\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|am7990_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|isr
operator|&
name|LE_C0_TXON
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: transmitter disabled\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|am7990_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Pretend we have carrier; if we don't this will be cleared 	 * shortly. 	 */
name|sc
operator|->
name|sc_havecarrier
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|isr
operator|&
name|LE_C0_RINT
condition|)
name|am7990_rint
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|isr
operator|&
name|LE_C0_TINT
condition|)
name|am7990_tint
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|#
directive|if
name|NRND
operator|>
literal|0
name|rnd_add_uint32
argument_list|(
operator|&
name|sc
operator|->
name|rnd_source
argument_list|,
name|isr
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
end_function

begin_undef
undef|#
directive|undef
name|ifp
end_undef

begin_function
name|void
name|am7990_watchdog
parameter_list|(
name|ifp
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|struct
name|am7990_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: device timeout\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|ifp
operator|->
name|if_oerrors
expr_stmt|;
name|am7990_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|am7990_mediachange
parameter_list|(
name|ifp
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|struct
name|am7990_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_mediachange
condition|)
return|return
operator|(
call|(
modifier|*
name|sc
operator|->
name|sc_mediachange
call|)
argument_list|(
name|sc
argument_list|)
operator|)
return|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
name|void
name|am7990_mediastatus
parameter_list|(
name|ifp
parameter_list|,
name|ifmr
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ifmediareq
modifier|*
name|ifmr
decl_stmt|;
block|{
name|struct
name|am7990_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
condition|)
return|return;
name|ifmr
operator|->
name|ifm_status
operator|=
name|IFM_AVALID
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_havecarrier
condition|)
name|ifmr
operator|->
name|ifm_status
operator||=
name|IFM_ACTIVE
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_mediastatus
condition|)
call|(
modifier|*
name|sc
operator|->
name|sc_mediastatus
call|)
argument_list|(
name|sc
argument_list|,
name|ifmr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Setup output on interface.  * Get another datagram to send off of the interface queue, and map it to the  * interface before starting the output.  * Called only at splimp or interrupt level.  */
end_comment

begin_function
name|void
name|am7990_start
parameter_list|(
name|ifp
parameter_list|)
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
specifier|register
name|struct
name|am7990_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
specifier|register
name|int
name|bix
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|letmd
name|tmd
decl_stmt|;
name|int
name|rp
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
operator|(
name|IFF_RUNNING
operator||
name|IFF_OACTIVE
operator|)
operator|)
operator|!=
name|IFF_RUNNING
condition|)
return|return;
name|bix
operator|=
name|sc
operator|->
name|sc_last_td
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|rp
operator|=
name|LE_TMDADDR
argument_list|(
name|sc
argument_list|,
name|bix
argument_list|)
expr_stmt|;
call|(
modifier|*
name|sc
operator|->
name|sc_copyfromdesc
call|)
argument_list|(
name|sc
argument_list|,
operator|&
name|tmd
argument_list|,
name|rp
argument_list|,
sizeof|sizeof
argument_list|(
name|tmd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmd
operator|.
name|tmd1_bits
operator|&
name|LE_T1_OWN
condition|)
block|{
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
name|printf
argument_list|(
literal|"missing buffer, no_td = %d, last_td = %d\n"
argument_list|,
name|sc
operator|->
name|sc_no_td
argument_list|,
name|sc
operator|->
name|sc_last_td
argument_list|)
expr_stmt|;
block|}
name|IF_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
break|break;
comment|/* 		 * If BPF is listening on this interface, let it see the packet 		 * before we commit it to the wire. 		 */
if|if
condition|(
name|ifp
operator|->
name|if_bpf
condition|)
name|bpf_mtap
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* 		 * Copy the mbuf chain into the transmit buffer. 		 */
name|len
operator|=
name|am7990_put
argument_list|(
name|sc
argument_list|,
name|LE_TBUFADDR
argument_list|(
name|sc
argument_list|,
name|bix
argument_list|)
argument_list|,
name|m
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LEDEBUG
if|if
condition|(
name|len
operator|>
name|ETHERMTU
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
condition|)
name|printf
argument_list|(
literal|"packet length %d\n"
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ifp
operator|->
name|if_timer
operator|=
literal|5
expr_stmt|;
comment|/* 		 * Init transmit registers, and set transmit start flag. 		 */
name|tmd
operator|.
name|tmd1_bits
operator|=
name|LE_T1_OWN
operator||
name|LE_T1_STP
operator||
name|LE_T1_ENP
expr_stmt|;
name|tmd
operator|.
name|tmd2
operator|=
operator|-
name|len
operator||
name|LE_XMD2_ONES
expr_stmt|;
name|tmd
operator|.
name|tmd3
operator|=
literal|0
expr_stmt|;
call|(
modifier|*
name|sc
operator|->
name|sc_copytodesc
call|)
argument_list|(
name|sc
argument_list|,
operator|&
name|tmd
argument_list|,
name|rp
argument_list|,
sizeof|sizeof
argument_list|(
name|tmd
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LEDEBUG
if|if
condition|(
name|sc
operator|->
name|sc_debug
condition|)
name|am7990_xmit_print
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_last_td
argument_list|)
expr_stmt|;
endif|#
directive|endif
call|(
modifier|*
name|sc
operator|->
name|sc_wrcsr
call|)
argument_list|(
name|sc
argument_list|,
name|LE_CSR0
argument_list|,
name|LE_C0_INEA
operator||
name|LE_C0_TDMD
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|bix
operator|==
name|sc
operator|->
name|sc_ntbuf
condition|)
name|bix
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|++
name|sc
operator|->
name|sc_no_td
operator|==
name|sc
operator|->
name|sc_ntbuf
condition|)
block|{
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
break|break;
block|}
block|}
name|sc
operator|->
name|sc_last_td
operator|=
name|bix
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process an ioctl request.  */
end_comment

begin_function
name|int
name|am7990_ioctl
parameter_list|(
name|ifp
parameter_list|,
name|cmd
parameter_list|,
name|data
parameter_list|)
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|u_long
name|cmd
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
block|{
specifier|register
name|struct
name|am7990_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ifaddr
modifier|*
name|ifa
init|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
switch|switch
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|am7990_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|arp_ifinit
argument_list|(
operator|(
expr|struct
name|arpcom
operator|*
operator|)
name|ifp
argument_list|,
name|ifa
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NS
case|case
name|AF_NS
case|:
block|{
specifier|register
name|struct
name|ns_addr
modifier|*
name|ina
init|=
operator|&
name|IA_SNS
argument_list|(
name|ifa
argument_list|)
operator|->
name|sns_addr
decl_stmt|;
if|if
condition|(
name|ns_nullhost
argument_list|(
operator|*
name|ina
argument_list|)
condition|)
name|ina
operator|->
name|x_host
operator|=
operator|*
operator|(
expr|union
name|ns_host
operator|*
operator|)
name|LLADDR
argument_list|(
name|ifp
operator|->
name|if_sadl
argument_list|)
expr_stmt|;
else|else
block|{
name|bcopy
argument_list|(
name|ina
operator|->
name|x_host
operator|.
name|c_host
argument_list|,
name|LLADDR
argument_list|(
name|ifp
operator|->
name|if_sadl
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_enaddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Set new address. */
name|am7990_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
default|default:
name|am7990_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|SIOCSIFFLAGS
case|:
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
operator|&&
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * If interface is marked down and it is running, then 			 * stop it. 			 */
name|am7990_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * If interface is marked up and it is stopped, then 			 * start it. 			 */
name|am7990_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Reset the interface to pick up changes in any other 			 * flags that affect hardware registers. 			 */
comment|/*am7990_stop(sc);*/
name|am7990_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|LEDEBUG
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
name|sc
operator|->
name|sc_debug
operator|=
literal|1
expr_stmt|;
else|else
name|sc
operator|->
name|sc_debug
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
comment|/* 		 * Multicast list has changed; set the hardware filter 		 * accordingly. 		 */
name|am7990_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SIOCGIFMEDIA
case|:
case|case
name|SIOCSIFMEDIA
case|:
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|sc
operator|->
name|sc_media
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* hide void am7990_shutdown(arg) 	void *arg; {  	am7990_stop((struct am7990_softc *)arg); } */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|LEDEBUG
end_ifdef

begin_function
name|void
name|am7990_recv_print
parameter_list|(
name|sc
parameter_list|,
name|no
parameter_list|)
name|struct
name|am7990_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|no
decl_stmt|;
block|{
name|struct
name|lermd
name|rmd
decl_stmt|;
name|u_int16_t
name|len
decl_stmt|;
name|struct
name|ether_header
name|eh
decl_stmt|;
call|(
modifier|*
name|sc
operator|->
name|sc_copyfromdesc
call|)
argument_list|(
name|sc
argument_list|,
operator|&
name|rmd
argument_list|,
name|LE_RMDADDR
argument_list|(
name|sc
argument_list|,
name|no
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|rmd
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|rmd
operator|.
name|rmd3
expr_stmt|;
name|printf
argument_list|(
literal|"%s: receive buffer %d, len = %d\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|no
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: status %04x\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
call|(
modifier|*
name|sc
operator|->
name|sc_rdcsr
call|)
argument_list|(
name|sc
argument_list|,
name|LE_CSR0
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: ladr %04x, hadr %02x, flags %02x, bcnt %04x, mcnt %04x\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|rmd
operator|.
name|rmd0
argument_list|,
name|rmd
operator|.
name|rmd1_hadr
argument_list|,
name|rmd
operator|.
name|rmd1_bits
argument_list|,
name|rmd
operator|.
name|rmd2
argument_list|,
name|rmd
operator|.
name|rmd3
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>=
sizeof|sizeof
argument_list|(
name|eh
argument_list|)
condition|)
block|{
call|(
modifier|*
name|sc
operator|->
name|sc_copyfrombuf
call|)
argument_list|(
name|sc
argument_list|,
operator|&
name|eh
argument_list|,
name|LE_RBUFADDR
argument_list|(
name|sc
argument_list|,
name|no
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|eh
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: dst %s"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|ether_sprintf
argument_list|(
name|eh
operator|.
name|ether_dhost
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" src %s type %04x\n"
argument_list|,
name|ether_sprintf
argument_list|(
name|eh
operator|.
name|ether_shost
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|eh
operator|.
name|ether_type
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|am7990_xmit_print
parameter_list|(
name|sc
parameter_list|,
name|no
parameter_list|)
name|struct
name|am7990_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|no
decl_stmt|;
block|{
name|struct
name|letmd
name|tmd
decl_stmt|;
name|u_int16_t
name|len
decl_stmt|;
name|struct
name|ether_header
name|eh
decl_stmt|;
call|(
modifier|*
name|sc
operator|->
name|sc_copyfromdesc
call|)
argument_list|(
name|sc
argument_list|,
operator|&
name|tmd
argument_list|,
name|LE_TMDADDR
argument_list|(
name|sc
argument_list|,
name|no
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|tmd
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
operator|-
name|tmd
operator|.
name|tmd2
expr_stmt|;
name|printf
argument_list|(
literal|"%s: transmit buffer %d, len = %d\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|no
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: status %04x\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
call|(
modifier|*
name|sc
operator|->
name|sc_rdcsr
call|)
argument_list|(
name|sc
argument_list|,
name|LE_CSR0
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: ladr %04x, hadr %02x, flags %02x, bcnt %04x, mcnt %04x\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|tmd
operator|.
name|tmd0
argument_list|,
name|tmd
operator|.
name|tmd1_hadr
argument_list|,
name|tmd
operator|.
name|tmd1_bits
argument_list|,
name|tmd
operator|.
name|tmd2
argument_list|,
name|tmd
operator|.
name|tmd3
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>=
sizeof|sizeof
argument_list|(
name|eh
argument_list|)
condition|)
block|{
call|(
modifier|*
name|sc
operator|->
name|sc_copyfrombuf
call|)
argument_list|(
name|sc
argument_list|,
operator|&
name|eh
argument_list|,
name|LE_TBUFADDR
argument_list|(
name|sc
argument_list|,
name|no
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|eh
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: dst %s"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|ether_sprintf
argument_list|(
name|eh
operator|.
name|ether_dhost
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" src %s type %04x\n"
argument_list|,
name|ether_sprintf
argument_list|(
name|eh
operator|.
name|ether_shost
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|eh
operator|.
name|ether_type
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LEDEBUG */
end_comment

begin_comment
comment|/*  * Set up the logical address filter.  */
end_comment

begin_function
name|void
name|am7990_setladrf
parameter_list|(
name|ac
parameter_list|,
name|af
parameter_list|)
name|struct
name|arpcom
modifier|*
name|ac
decl_stmt|;
name|u_int16_t
modifier|*
name|af
decl_stmt|;
block|{
if|#
directive|if
literal|0
block|struct ifnet *ifp =&ac->ac_if; 	struct ether_multi *enm; 	register u_char *cp; 	register u_int32_t crc; 	static const u_int32_t crctab[] = { 		0x00000000, 0x1db71064, 0x3b6e20c8, 0x26d930ac, 		0x76dc4190, 0x6b6b51f4, 0x4db26158, 0x5005713c, 		0xedb88320, 0xf00f9344, 0xd6d6a3e8, 0xcb61b38c, 		0x9b64c2b0, 0x86d3d2d4, 0xa00ae278, 0xbdbdf21c 	}; 	register int len; 	struct ether_multistep step;
comment|/* 	 * Set up multicast address filter by passing all multicast addresses 	 * through a crc generator, and then using the high order 6 bits as an 	 * index into the 64 bit logical address filter.  The high order bit 	 * selects the word, while the rest of the bits select the bit within 	 * the word. 	 */
block|if (ifp->if_flags& IFF_PROMISC) 		goto allmulti;  	af[0] = af[1] = af[2] = af[3] = 0x0000; 	ETHER_FIRST_MULTI(step, ac, enm); 	while (enm != NULL) { 		if (ETHER_CMP(enm->enm_addrlo, enm->enm_addrhi)) {
comment|/* 			 * We must listen to a range of multicast addresses. 			 * For now, just accept all multicasts, rather than 			 * trying to set only those filter bits needed to match 			 * the range.  (At this time, the only use of address 			 * ranges is for IP multicast routing, for which the 			 * range is big enough to require all bits set.) 			 */
block|goto allmulti; 		}  		cp = enm->enm_addrlo; 		crc = 0xffffffff; 		for (len = sizeof(enm->enm_addrlo); --len>= 0;) { 			crc ^= *cp++; 			crc = (crc>> 4) ^ crctab[crc& 0xf]; 			crc = (crc>> 4) ^ crctab[crc& 0xf]; 		}
comment|/* Just want the 6 most significant bits. */
block|crc>>= 26;
comment|/* Set the corresponding bit in the filter. */
block|af[crc>> 4] |= 1<< (crc& 0xf);  		ETHER_NEXT_MULTI(step, enm); 	} 	ifp->if_flags&= ~IFF_ALLMULTI; 	return;  allmulti: 	ifp->if_flags |= IFF_ALLMULTI; 	af[0] = af[1] = af[2] = af[3] = 0xffff;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Routines for accessing the transmit and receive buffers.  * The various CPU and adapter configurations supported by this  * driver require three different access methods for buffers  * and descriptors:  *	(1) contig (contiguous data; no padding),  *	(2) gap2 (two bytes of data followed by two bytes of padding),  *	(3) gap16 (16 bytes of data followed by 16 bytes of padding).  */
end_comment

begin_comment
comment|/*  * contig: contiguous data with no padding.  *  * Buffers may have any alignment.  */
end_comment

begin_function
name|void
name|am7990_copytobuf_contig
parameter_list|(
name|sc
parameter_list|,
name|from
parameter_list|,
name|boff
parameter_list|,
name|len
parameter_list|)
name|struct
name|am7990_softc
modifier|*
name|sc
decl_stmt|;
name|void
modifier|*
name|from
decl_stmt|;
name|int
name|boff
decl_stmt|,
name|len
decl_stmt|;
block|{
specifier|volatile
name|caddr_t
name|buf
init|=
name|sc
operator|->
name|sc_mem
decl_stmt|;
comment|/* 	 * Just call bcopy() to do the work. 	 */
name|bcopy
argument_list|(
name|from
argument_list|,
name|buf
operator|+
name|boff
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|am7990_copyfrombuf_contig
parameter_list|(
name|sc
parameter_list|,
name|to
parameter_list|,
name|boff
parameter_list|,
name|len
parameter_list|)
name|struct
name|am7990_softc
modifier|*
name|sc
decl_stmt|;
name|void
modifier|*
name|to
decl_stmt|;
name|int
name|boff
decl_stmt|,
name|len
decl_stmt|;
block|{
specifier|volatile
name|caddr_t
name|buf
init|=
name|sc
operator|->
name|sc_mem
decl_stmt|;
comment|/* 	 * Just call bcopy() to do the work. 	 */
name|bcopy
argument_list|(
name|buf
operator|+
name|boff
argument_list|,
name|to
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|am7990_zerobuf_contig
parameter_list|(
name|sc
parameter_list|,
name|boff
parameter_list|,
name|len
parameter_list|)
name|struct
name|am7990_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|boff
decl_stmt|,
name|len
decl_stmt|;
block|{
specifier|volatile
name|caddr_t
name|buf
init|=
name|sc
operator|->
name|sc_mem
decl_stmt|;
comment|/* 	 * Just let bzero() do the work 	 */
name|bzero
argument_list|(
name|buf
operator|+
name|boff
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*  * Examples only; duplicate these and tweak (if necessary) in  * machine-specific front-ends.  */
end_comment

begin_comment
comment|/*  * gap2: two bytes of data followed by two bytes of pad.  *  * Buffers must be 4-byte aligned.  The code doesn't worry about  * doing an extra byte.  */
end_comment

begin_comment
unit|void am7990_copytobuf_gap2(sc, fromv, boff, len) 	struct am7990_softc *sc; 	void *fromv; 	int boff; 	register int len; { 	volatile caddr_t buf = sc->sc_mem; 	register caddr_t from = fromv; 	register volatile u_int16_t *bptr;  	if (boff& 0x1) {
comment|/* handle unaligned first byte */
end_comment

begin_comment
unit|bptr = ((volatile u_int16_t *)buf) + (boff - 1); 		*bptr = (*from++<< 8) | (*bptr& 0xff); 		bptr += 2; 		len--; 	} else 		bptr = ((volatile u_int16_t *)buf) + boff; 	while (len> 1) { 		*bptr = (from[1]<< 8) | (from[0]& 0xff); 		bptr += 2; 		from += 2; 		len -= 2; 	} 	if (len == 1) 		*bptr = (u_int16_t)*from; }  void am7990_copyfrombuf_gap2(sc, tov, boff, len) 	struct am7990_softc *sc; 	void *tov; 	int boff, len; { 	volatile caddr_t buf = sc->sc_mem; 	register caddr_t to = tov; 	register volatile u_int16_t *bptr; 	register u_int16_t tmp;  	if (boff& 0x1) {
comment|/* handle unaligned first byte */
end_comment

begin_comment
unit|bptr = ((volatile u_int16_t *)buf) + (boff - 1); 		*to++ = (*bptr>> 8)& 0xff; 		bptr += 2; 		len--; 	} else 		bptr = ((volatile u_int16_t *)buf) + boff; 	while (len> 1) { 		tmp = *bptr; 		*to++ = tmp& 0xff; 		*to++ = (tmp>> 8)& 0xff; 		bptr += 2; 		len -= 2; 	} 	if (len == 1) 		*to = *bptr& 0xff; }  void am7990_zerobuf_gap2(sc, boff, len) 	struct am7990_softc *sc; 	int boff, len; { 	volatile caddr_t buf = sc->sc_mem; 	register volatile u_int16_t *bptr;  	if ((unsigned)boff& 0x1) { 		bptr = ((volatile u_int16_t *)buf) + (boff - 1); 		*bptr&= 0xff; 		bptr += 2; 		len--; 	} else 		bptr = ((volatile u_int16_t *)buf) + boff; 	while (len> 0) { 		*bptr = 0; 		bptr += 2; 		len -= 2; 	} }
comment|/*  * gap16: 16 bytes of data followed by 16 bytes of pad.  *  * Buffers must be 32-byte aligned.  */
end_comment

begin_endif
unit|void am7990_copytobuf_gap16(sc, fromv, boff, len) 	struct am7990_softc *sc; 	void *fromv; 	int boff; 	register int len; { 	volatile caddr_t buf = sc->sc_mem; 	register caddr_t from = fromv; 	register caddr_t bptr; 	register int xfer;  	bptr = buf + ((boff<< 1)& ~0x1f); 	boff&= 0xf; 	xfer = min(len, 16 - boff); 	while (len> 0) { 		bcopy(from, bptr + boff, xfer); 		from += xfer; 		bptr += 32; 		boff = 0; 		len -= xfer; 		xfer = min(len, 16); 	} }  void am7990_copyfrombuf_gap16(sc, tov, boff, len) 	struct am7990_softc *sc; 	void *tov; 	int boff, len; { 	volatile caddr_t buf = sc->sc_mem; 	register caddr_t to = tov; 	register caddr_t bptr; 	register int xfer;  	bptr = buf + ((boff<< 1)& ~0x1f); 	boff&= 0xf; 	xfer = min(len, 16 - boff); 	while (len> 0) { 		bcopy(bptr + boff, to, xfer); 		to += xfer; 		bptr += 32; 		boff = 0; 		len -= xfer; 		xfer = min(len, 16); 	} }  void am7990_zerobuf_gap16(sc, boff, len) 	struct am7990_softc *sc; 	int boff, len; { 	volatile caddr_t buf = sc->sc_mem; 	register caddr_t bptr; 	register int xfer;  	bptr = buf + ((boff<< 1)& ~0x1f); 	boff&= 0xf; 	xfer = min(len, 16 - boff); 	while (len> 0) { 		bzero(bptr + boff, xfer); 		bptr += 32; 		boff = 0; 		len -= xfer; 		xfer = min(len, 16); 	} }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Example only */
end_comment

begin_function
name|char
modifier|*
name|ether_sprintf
parameter_list|(
name|ap
parameter_list|)
specifier|register
name|u_char
modifier|*
name|ap
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
specifier|static
name|char
name|etherbuf
index|[
literal|18
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
init|=
name|etherbuf
decl_stmt|;
specifier|static
name|char
name|digits
index|[]
init|=
literal|"0123456789abcdef"
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|cp
operator|++
operator|=
name|digits
index|[
operator|*
name|ap
operator|>>
literal|4
index|]
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|digits
index|[
operator|*
name|ap
operator|++
operator|&
literal|0xf
index|]
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|':'
expr_stmt|;
block|}
operator|*
operator|--
name|cp
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|etherbuf
operator|)
return|;
block|}
end_function

end_unit

