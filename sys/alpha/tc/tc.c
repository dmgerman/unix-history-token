begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/*  * Copyright (c) 1994, 1995, 1996 Carnegie-Mellon University.  * All rights reserved.  *  * Author: Chris G. Demetriou  *   * Permission to use, copy, modify and distribute this software and  * its documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *   * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"   * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND   * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *   * Carnegie Mellon requests users of this software to return to  *  *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *  * any improvements or extensions that they make and grant Carnegie the  * rights to redistribute these changes.  */
end_comment

begin_include
include|#
directive|include
file|"opt_cpu.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<machine/rpb.h>
end_include

begin_include
include|#
directive|include
file|<alpha/tc/tcreg.h>
end_include

begin_include
include|#
directive|include
file|<alpha/tc/tcvar.h>
end_include

begin_include
include|#
directive|include
file|<alpha/tc/tcdevs.h>
end_include

begin_include
include|#
directive|include
file|<alpha/tc/ioasicreg.h>
end_include

begin_comment
comment|/*#include<alpha/tc/dwlpxreg.h>*/
end_comment

begin_define
define|#
directive|define
name|KV
parameter_list|(
name|pa
parameter_list|)
value|ALPHA_PHYS_TO_K0SEG(pa)
end_define

begin_decl_stmt
specifier|static
name|devclass_t
name|tc_devclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|device_t
name|tc0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX only one for now */
end_comment

begin_struct
struct|struct
name|tc_softc
block|{
name|device_t
name|sc_dv
decl_stmt|;
name|int
name|sc_speed
decl_stmt|;
name|int
name|sc_nslots
decl_stmt|;
name|int
name|nbuiltins
decl_stmt|;
name|struct
name|tc_builtin
modifier|*
name|builtins
decl_stmt|;
name|struct
name|tc_slotdesc
modifier|*
name|sc_slots
decl_stmt|;
name|void
argument_list|(
argument|*sc_intr_establish
argument_list|)
name|__P
argument_list|(
operator|(
expr|struct
name|device
operator|*
operator|,
name|void
operator|*
operator|,
name|tc_intrlevel_t
operator|,
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|,
name|void
operator|*
operator|)
argument_list|)
expr_stmt|;
name|void
argument_list|(
argument|*sc_intr_disestablish
argument_list|)
name|__P
argument_list|(
operator|(
expr|struct
name|device
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/*        bus_dma_tag_t (*sc_get_dma_tag) __P((int)); */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|NTC_ROMOFFS
value|2
end_define

begin_decl_stmt
specifier|static
name|tc_offset_t
name|tc_slot_romoffs
index|[
name|NTC_ROMOFFS
index|]
init|=
block|{
name|TC_SLOT_ROM
block|,
name|TC_SLOT_PROTOROM
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|TC_SOFTC
parameter_list|(
name|dev
parameter_list|)
value|(struct tc_softc*) device_get_softc(dev)
end_define

begin_function_decl
specifier|static
name|int
name|tc_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tc_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|tc_checkslot
parameter_list|(
name|tc_addr_t
name|slotbase
parameter_list|,
name|char
modifier|*
name|namep
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|tc_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|tc_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|tc_attach
argument_list|)
block|,
comment|/* Bus interface */
name|DEVMETHOD
argument_list|(
name|bus_print_child
argument_list|,
name|bus_generic_print_child
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|tc_driver
init|=
block|{
literal|"tc"
block|,
name|tc_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|tc_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|C
parameter_list|(
name|x
parameter_list|)
value|((void *)(u_long)x)
end_define

begin_decl_stmt
name|int
name|tc_intrnull
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|tcintr
block|{
name|int
argument_list|(
argument|*tci_func
argument_list|)
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
expr_stmt|;
name|void
modifier|*
name|tci_arg
decl_stmt|;
block|}
struct|;
end_struct

begin_ifdef
ifdef|#
directive|ifdef
name|DEC_3000_300
end_ifdef

begin_decl_stmt
name|void
name|tc_3000_300_intr_setup
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|tc_3000_300_intr_establish
name|__P
argument_list|(
operator|(
expr|struct
name|device
operator|*
operator|,
name|void
operator|*
operator|,
name|tc_intrlevel_t
operator|,
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|tc_3000_300_intr_disestablish
name|__P
argument_list|(
operator|(
expr|struct
name|device
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|tc_3000_300_iointr
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DEC_3000_300_IOASIC_ADDR
value|KV(0x1a0000000)
end_define

begin_decl_stmt
name|struct
name|tc_slotdesc
name|tc_3000_300_slots
index|[]
init|=
block|{
block|{
name|KV
argument_list|(
literal|0x100000000
argument_list|)
block|,
name|C
argument_list|(
name|TC_3000_300_DEV_OPT0
argument_list|)
block|, }
block|,
comment|/* 0 - opt slot 0 */
block|{
name|KV
argument_list|(
literal|0x120000000
argument_list|)
block|,
name|C
argument_list|(
name|TC_3000_300_DEV_OPT1
argument_list|)
block|, }
block|,
comment|/* 1 - opt slot 1 */
block|{
name|KV
argument_list|(
literal|0x180000000
argument_list|)
block|,
name|C
argument_list|(
name|TC_3000_300_DEV_BOGUS
argument_list|)
block|, }
block|,
comment|/* 2 - TCDS ASIC */
block|{
name|KV
argument_list|(
literal|0x1a0000000
argument_list|)
block|,
name|C
argument_list|(
name|TC_3000_300_DEV_BOGUS
argument_list|)
block|, }
block|,
comment|/* 3 - IOCTL ASIC */
block|{
name|KV
argument_list|(
literal|0x1c0000000
argument_list|)
block|,
name|C
argument_list|(
name|TC_3000_300_DEV_CXTURBO
argument_list|)
block|, }
block|,
comment|/* 4 - CXTurbo */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|tc_3000_300_nslots
init|=
sizeof|sizeof
argument_list|(
name|tc_3000_300_slots
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|tc_3000_300_slots
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|tc_builtin
name|tc_3000_300_builtins
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|notyet
block|{
literal|"PMAGB-BA"
block|,
literal|4
block|,
literal|0x02000000
block|,
name|C
argument_list|(
name|TC_3000_300_DEV_CXTURBO
argument_list|)
block|,      }
block|,
endif|#
directive|endif
block|{
literal|"ioasic"
block|,
literal|3
block|,
literal|0x00000000
block|,
name|C
argument_list|(
name|TC_3000_300_DEV_IOASIC
argument_list|)
block|,       }
block|,
block|{
literal|"tcds"
block|,
literal|2
block|,
literal|0x00000000
block|,
name|C
argument_list|(
name|TC_3000_300_DEV_TCDS
argument_list|)
block|,         }
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|tc_3000_300_nbuiltins
init|=
sizeof|sizeof
argument_list|(
name|tc_3000_300_builtins
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|tc_3000_300_builtins
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|tcintr
name|tc_3000_300_intr
index|[
name|TC_3000_300_NCOOKIES
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEC_3000_300 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEC_3000_500
end_ifdef

begin_decl_stmt
name|void
name|tc_3000_500_intr_setup
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|tc_3000_500_intr_establish
name|__P
argument_list|(
operator|(
expr|struct
name|device
operator|*
operator|,
name|void
operator|*
operator|,
name|tc_intrlevel_t
operator|,
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|tc_3000_500_intr_disestablish
name|__P
argument_list|(
operator|(
expr|struct
name|device
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|tc_3000_500_iointr
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|tc_slotdesc
name|tc_3000_500_slots
index|[]
init|=
block|{
block|{
name|KV
argument_list|(
literal|0x100000000
argument_list|)
block|,
name|C
argument_list|(
name|TC_3000_500_DEV_OPT0
argument_list|)
block|, }
block|,
comment|/* 0 - opt slot 0 */
block|{
name|KV
argument_list|(
literal|0x120000000
argument_list|)
block|,
name|C
argument_list|(
name|TC_3000_500_DEV_OPT1
argument_list|)
block|, }
block|,
comment|/* 1 - opt slot 1 */
block|{
name|KV
argument_list|(
literal|0x140000000
argument_list|)
block|,
name|C
argument_list|(
name|TC_3000_500_DEV_OPT2
argument_list|)
block|, }
block|,
comment|/* 2 - opt slot 2 */
block|{
name|KV
argument_list|(
literal|0x160000000
argument_list|)
block|,
name|C
argument_list|(
name|TC_3000_500_DEV_OPT3
argument_list|)
block|, }
block|,
comment|/* 3 - opt slot 3 */
block|{
name|KV
argument_list|(
literal|0x180000000
argument_list|)
block|,
name|C
argument_list|(
name|TC_3000_500_DEV_OPT4
argument_list|)
block|, }
block|,
comment|/* 4 - opt slot 4 */
block|{
name|KV
argument_list|(
literal|0x1a0000000
argument_list|)
block|,
name|C
argument_list|(
name|TC_3000_500_DEV_OPT5
argument_list|)
block|, }
block|,
comment|/* 5 - opt slot 5 */
block|{
name|KV
argument_list|(
literal|0x1c0000000
argument_list|)
block|,
name|C
argument_list|(
name|TC_3000_500_DEV_BOGUS
argument_list|)
block|, }
block|,
comment|/* 6 - TCDS ASIC */
block|{
name|KV
argument_list|(
literal|0x1e0000000
argument_list|)
block|,
name|C
argument_list|(
name|TC_3000_500_DEV_BOGUS
argument_list|)
block|, }
block|,
comment|/* 7 - IOCTL ASIC */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|tc_3000_500_nslots
init|=
sizeof|sizeof
argument_list|(
name|tc_3000_500_slots
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|tc_3000_500_slots
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|tc_builtin
name|tc_3000_500_builtins
index|[]
init|=
block|{
block|{
literal|"ioasic"
block|,
literal|7
block|,
literal|0x00000000
block|,
name|C
argument_list|(
name|TC_3000_500_DEV_IOASIC
argument_list|)
block|,       }
block|,
ifdef|#
directive|ifdef
name|notyet
block|{
literal|"PMAGB-BA"
block|,
literal|7
block|,
literal|0x02000000
block|,
name|C
argument_list|(
name|TC_3000_500_DEV_CXTURBO
argument_list|)
block|,      }
block|,
endif|#
directive|endif
block|{
literal|"tcds"
block|,
literal|6
block|,
literal|0x00000000
block|,
name|C
argument_list|(
name|TC_3000_500_DEV_TCDS
argument_list|)
block|,         }
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|tc_3000_500_nbuiltins
init|=
sizeof|sizeof
argument_list|(
name|tc_3000_500_builtins
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|tc_3000_500_builtins
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int32_t
name|tc_3000_500_intrbits
index|[
name|TC_3000_500_NCOOKIES
index|]
init|=
block|{
name|TC_3000_500_IR_OPT0
block|,
name|TC_3000_500_IR_OPT1
block|,
name|TC_3000_500_IR_OPT2
block|,
name|TC_3000_500_IR_OPT3
block|,
name|TC_3000_500_IR_OPT4
block|,
name|TC_3000_500_IR_OPT5
block|,
name|TC_3000_500_IR_TCDS
block|,
name|TC_3000_500_IR_IOASIC
block|,
name|TC_3000_500_IR_CXTURBO
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|tcintr
name|tc_3000_500_intr
index|[
name|TC_3000_500_NCOOKIES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int32_t
name|tc_3000_500_imask
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* intrs we want to ignore; mirrors IMR. */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEC_3000_500 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEC_3000_300
end_ifdef

begin_function
name|void
name|tc_3000_300_intr_setup
parameter_list|()
block|{
specifier|volatile
name|u_int32_t
modifier|*
name|imskp
decl_stmt|;
name|u_long
name|i
decl_stmt|;
comment|/*          * Disable all interrupts that we can (can't disable builtins).          */
name|imskp
operator|=
operator|(
specifier|volatile
name|u_int32_t
operator|*
operator|)
name|IOASIC_REG_IMSK
argument_list|(
name|DEC_3000_300_IOASIC_ADDR
argument_list|)
expr_stmt|;
operator|*
name|imskp
operator|&=
operator|~
operator|(
name|IOASIC_INTR_300_OPT0
operator||
name|IOASIC_INTR_300_OPT1
operator|)
expr_stmt|;
comment|/*          * Set up interrupt handlers.          */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TC_3000_300_NCOOKIES
condition|;
name|i
operator|++
control|)
block|{
name|tc_3000_300_intr
index|[
name|i
index|]
operator|.
name|tci_func
operator|=
name|tc_intrnull
expr_stmt|;
name|tc_3000_300_intr
index|[
name|i
index|]
operator|.
name|tci_arg
operator|=
operator|(
name|void
operator|*
operator|)
name|i
expr_stmt|;
block|}
block|}
end_function

begin_function_decl
name|void
name|tc_3000_300_intr_establish
parameter_list|(
name|tcadev
parameter_list|,
name|cookie
parameter_list|,
name|level
parameter_list|,
name|func
parameter_list|,
name|arg
parameter_list|)
name|struct
name|device
modifier|*
name|tcadev
decl_stmt|;
name|void
modifier|*
name|cookie
decl_stmt|,
decl|*
name|arg
decl_stmt|;
end_function_decl

begin_decl_stmt
name|tc_intrlevel_t
name|level
decl_stmt|;
end_decl_stmt

begin_macro
name|int
argument_list|(
argument|*func
argument_list|)
end_macro

begin_expr_stmt
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|volatile
name|u_int32_t
modifier|*
name|imskp
decl_stmt|;
name|u_long
name|dev
init|=
operator|(
name|u_long
operator|)
name|cookie
decl_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
comment|/* XXX bounds-check cookie. */
endif|#
directive|endif
if|if
condition|(
name|tc_3000_300_intr
index|[
name|dev
index|]
operator|.
name|tci_func
operator|!=
name|tc_intrnull
condition|)
name|panic
argument_list|(
literal|"tc_3000_300_intr_establish: cookie %ld twice"
argument_list|,
name|dev
argument_list|)
expr_stmt|;
name|tc_3000_300_intr
index|[
name|dev
index|]
operator|.
name|tci_func
operator|=
name|func
expr_stmt|;
name|tc_3000_300_intr
index|[
name|dev
index|]
operator|.
name|tci_arg
operator|=
name|arg
expr_stmt|;
name|imskp
operator|=
operator|(
specifier|volatile
name|u_int32_t
operator|*
operator|)
name|IOASIC_REG_IMSK
argument_list|(
name|DEC_3000_300_IOASIC_ADDR
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dev
condition|)
block|{
case|case
name|TC_3000_300_DEV_OPT0
case|:
operator|*
name|imskp
operator||=
name|IOASIC_INTR_300_OPT0
expr_stmt|;
break|break;
case|case
name|TC_3000_300_DEV_OPT1
case|:
operator|*
name|imskp
operator||=
name|IOASIC_INTR_300_OPT1
expr_stmt|;
break|break;
default|default:
comment|/* interrupts for builtins always enabled */
break|break;
block|}
block|}
end_block

begin_function
name|void
name|tc_3000_300_intr_disestablish
parameter_list|(
name|tcadev
parameter_list|,
name|cookie
parameter_list|)
name|struct
name|device
modifier|*
name|tcadev
decl_stmt|;
name|void
modifier|*
name|cookie
decl_stmt|;
block|{
specifier|volatile
name|u_int32_t
modifier|*
name|imskp
decl_stmt|;
name|u_long
name|dev
init|=
operator|(
name|u_long
operator|)
name|cookie
decl_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
comment|/* XXX bounds-check cookie. */
endif|#
directive|endif
if|if
condition|(
name|tc_3000_300_intr
index|[
name|dev
index|]
operator|.
name|tci_func
operator|==
name|tc_intrnull
condition|)
name|panic
argument_list|(
literal|"tc_3000_300_intr_disestablish: cookie %ld bad intr"
argument_list|,
name|dev
argument_list|)
expr_stmt|;
name|imskp
operator|=
operator|(
specifier|volatile
name|u_int32_t
operator|*
operator|)
name|IOASIC_REG_IMSK
argument_list|(
name|DEC_3000_300_IOASIC_ADDR
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dev
condition|)
block|{
case|case
name|TC_3000_300_DEV_OPT0
case|:
operator|*
name|imskp
operator|&=
operator|~
name|IOASIC_INTR_300_OPT0
expr_stmt|;
break|break;
case|case
name|TC_3000_300_DEV_OPT1
case|:
operator|*
name|imskp
operator|&=
operator|~
name|IOASIC_INTR_300_OPT1
expr_stmt|;
break|break;
default|default:
comment|/* interrupts for builtins always enabled */
break|break;
block|}
name|tc_3000_300_intr
index|[
name|dev
index|]
operator|.
name|tci_func
operator|=
name|tc_intrnull
expr_stmt|;
name|tc_3000_300_intr
index|[
name|dev
index|]
operator|.
name|tci_arg
operator|=
operator|(
name|void
operator|*
operator|)
name|dev
expr_stmt|;
block|}
end_function

begin_function
name|void
name|tc_3000_300_iointr
parameter_list|(
name|framep
parameter_list|,
name|vec
parameter_list|)
name|void
modifier|*
name|framep
decl_stmt|;
name|unsigned
name|long
name|vec
decl_stmt|;
block|{
name|u_int32_t
name|tcir
decl_stmt|,
name|ioasicir
decl_stmt|,
name|ioasicimr
decl_stmt|;
name|int
name|ifound
decl_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|int
name|s
decl_stmt|;
if|if
condition|(
name|vec
operator|!=
literal|0x800
condition|)
name|panic
argument_list|(
literal|"INVALID ASSUMPTION: vec 0x%lx, not 0x800"
argument_list|,
name|vec
argument_list|)
expr_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|ALPHA_PSL_IPL_IO
condition|)
name|panic
argument_list|(
literal|"INVALID ASSUMPTION: IPL %d, not %d"
argument_list|,
name|s
argument_list|,
name|ALPHA_PSL_IPL_IO
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
do|do
block|{
name|tc_syncbus
argument_list|()
expr_stmt|;
comment|/* find out what interrupts/errors occurred */
name|tcir
operator|=
operator|*
operator|(
specifier|volatile
name|u_int32_t
operator|*
operator|)
name|TC_3000_300_IR
expr_stmt|;
name|ioasicir
operator|=
operator|*
operator|(
specifier|volatile
name|u_int32_t
operator|*
operator|)
name|IOASIC_REG_INTR
argument_list|(
name|DEC_3000_300_IOASIC_ADDR
argument_list|)
expr_stmt|;
name|ioasicimr
operator|=
operator|*
operator|(
specifier|volatile
name|u_int32_t
operator|*
operator|)
name|IOASIC_REG_IMSK
argument_list|(
name|DEC_3000_300_IOASIC_ADDR
argument_list|)
expr_stmt|;
name|tc_mb
argument_list|()
expr_stmt|;
comment|/* Ignore interrupts that aren't enabled out. */
name|ioasicir
operator|&=
name|ioasicimr
expr_stmt|;
comment|/* clear the interrupts/errors we found. */
operator|*
operator|(
specifier|volatile
name|u_int32_t
operator|*
operator|)
name|TC_3000_300_IR
operator|=
name|tcir
expr_stmt|;
comment|/* XXX can't clear TC option slot interrupts here? */
name|tc_wmb
argument_list|()
expr_stmt|;
name|ifound
operator|=
literal|0
expr_stmt|;
define|#
directive|define
name|CHECKINTR
parameter_list|(
name|slot
parameter_list|,
name|flag
parameter_list|)
define|\
value|if (flag) {                                             \                         ifound = 1;                                     \                         (*tc_3000_300_intr[slot].tci_func)              \                             (tc_3000_300_intr[slot].tci_arg);           \                 }
comment|/* Do them in order of priority; highest slot # first. */
name|CHECKINTR
argument_list|(
name|TC_3000_300_DEV_CXTURBO
argument_list|,
name|tcir
operator|&
name|TC_3000_300_IR_CXTURBO
argument_list|)
expr_stmt|;
name|CHECKINTR
argument_list|(
name|TC_3000_300_DEV_IOASIC
argument_list|,
operator|(
name|tcir
operator|&
name|TC_3000_300_IR_IOASIC
operator|)
operator|&&
operator|(
name|ioasicir
operator|&
operator|~
operator|(
name|IOASIC_INTR_300_OPT1
operator||
name|IOASIC_INTR_300_OPT0
operator|)
operator|)
argument_list|)
expr_stmt|;
name|CHECKINTR
argument_list|(
name|TC_3000_300_DEV_TCDS
argument_list|,
name|tcir
operator|&
name|TC_3000_300_IR_TCDS
argument_list|)
expr_stmt|;
name|CHECKINTR
argument_list|(
name|TC_3000_300_DEV_OPT1
argument_list|,
name|ioasicir
operator|&
name|IOASIC_INTR_300_OPT1
argument_list|)
expr_stmt|;
name|CHECKINTR
argument_list|(
name|TC_3000_300_DEV_OPT0
argument_list|,
name|ioasicir
operator|&
name|IOASIC_INTR_300_OPT0
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|CHECKINTR
ifdef|#
directive|ifdef
name|DIAGNOSTIC
define|#
directive|define
name|PRINTINTR
parameter_list|(
name|msg
parameter_list|,
name|bits
parameter_list|)
define|\
value|if (tcir& bits)                                                \                 printf(msg);
name|PRINTINTR
argument_list|(
literal|"BCache tag parity error\n"
argument_list|,
name|TC_3000_300_IR_BCTAGPARITY
argument_list|)
expr_stmt|;
name|PRINTINTR
argument_list|(
literal|"TC overrun error\n"
argument_list|,
name|TC_3000_300_IR_TCOVERRUN
argument_list|)
expr_stmt|;
name|PRINTINTR
argument_list|(
literal|"TC I/O timeout\n"
argument_list|,
name|TC_3000_300_IR_TCTIMEOUT
argument_list|)
expr_stmt|;
name|PRINTINTR
argument_list|(
literal|"Bcache parity error\n"
argument_list|,
name|TC_3000_300_IR_BCACHEPARITY
argument_list|)
expr_stmt|;
name|PRINTINTR
argument_list|(
literal|"Memory parity error\n"
argument_list|,
name|TC_3000_300_IR_MEMPARITY
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|PRINTINTR
endif|#
directive|endif
block|}
do|while
condition|(
name|ifound
condition|)
do|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEC_3000_300 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEC_3000_500
end_ifdef

begin_function
name|void
name|tc_3000_500_intr_setup
parameter_list|()
block|{
name|u_long
name|i
decl_stmt|;
comment|/*          * Disable all slot interrupts.  Note that this cannot          * actually disable CXTurbo, TCDS, and IOASIC interrupts.          */
name|tc_3000_500_imask
operator|=
operator|*
operator|(
specifier|volatile
name|u_int32_t
operator|*
operator|)
name|TC_3000_500_IMR_READ
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TC_3000_500_NCOOKIES
condition|;
name|i
operator|++
control|)
name|tc_3000_500_imask
operator||=
name|tc_3000_500_intrbits
index|[
name|i
index|]
expr_stmt|;
operator|*
operator|(
specifier|volatile
name|u_int32_t
operator|*
operator|)
name|TC_3000_500_IMR_WRITE
operator|=
name|tc_3000_500_imask
expr_stmt|;
name|tc_mb
argument_list|()
expr_stmt|;
comment|/*          * Set up interrupt handlers.          */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TC_3000_500_NCOOKIES
condition|;
name|i
operator|++
control|)
block|{
name|tc_3000_500_intr
index|[
name|i
index|]
operator|.
name|tci_func
operator|=
name|tc_intrnull
expr_stmt|;
name|tc_3000_500_intr
index|[
name|i
index|]
operator|.
name|tci_arg
operator|=
operator|(
name|void
operator|*
operator|)
name|i
expr_stmt|;
block|}
block|}
end_function

begin_function_decl
name|void
name|tc_3000_500_intr_establish
parameter_list|(
name|tcadev
parameter_list|,
name|cookie
parameter_list|,
name|level
parameter_list|,
name|func
parameter_list|,
name|arg
parameter_list|)
name|struct
name|device
modifier|*
name|tcadev
decl_stmt|;
name|void
modifier|*
name|cookie
decl_stmt|,
decl|*
name|arg
decl_stmt|;
end_function_decl

begin_decl_stmt
name|tc_intrlevel_t
name|level
decl_stmt|;
end_decl_stmt

begin_macro
name|int
argument_list|(
argument|*func
argument_list|)
end_macro

begin_expr_stmt
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|u_long
name|dev
init|=
operator|(
name|u_long
operator|)
name|cookie
decl_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
comment|/* XXX bounds-check cookie. */
endif|#
directive|endif
if|if
condition|(
name|tc_3000_500_intr
index|[
name|dev
index|]
operator|.
name|tci_func
operator|!=
name|tc_intrnull
condition|)
name|panic
argument_list|(
literal|"tc_3000_500_intr_establish: cookie %ld twice"
argument_list|,
name|dev
argument_list|)
expr_stmt|;
name|tc_3000_500_intr
index|[
name|dev
index|]
operator|.
name|tci_func
operator|=
name|func
expr_stmt|;
name|tc_3000_500_intr
index|[
name|dev
index|]
operator|.
name|tci_arg
operator|=
name|arg
expr_stmt|;
name|tc_3000_500_imask
operator|&=
operator|~
name|tc_3000_500_intrbits
index|[
name|dev
index|]
expr_stmt|;
operator|*
operator|(
specifier|volatile
name|u_int32_t
operator|*
operator|)
name|TC_3000_500_IMR_WRITE
operator|=
name|tc_3000_500_imask
expr_stmt|;
name|tc_mb
argument_list|()
expr_stmt|;
block|}
end_block

begin_function
name|void
name|tc_3000_500_intr_disestablish
parameter_list|(
name|tcadev
parameter_list|,
name|cookie
parameter_list|)
name|struct
name|device
modifier|*
name|tcadev
decl_stmt|;
name|void
modifier|*
name|cookie
decl_stmt|;
block|{
name|u_long
name|dev
init|=
operator|(
name|u_long
operator|)
name|cookie
decl_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
comment|/* XXX bounds-check cookie. */
endif|#
directive|endif
if|if
condition|(
name|tc_3000_500_intr
index|[
name|dev
index|]
operator|.
name|tci_func
operator|==
name|tc_intrnull
condition|)
name|panic
argument_list|(
literal|"tc_3000_500_intr_disestablish: cookie %ld bad intr"
argument_list|,
name|dev
argument_list|)
expr_stmt|;
name|tc_3000_500_imask
operator||=
name|tc_3000_500_intrbits
index|[
name|dev
index|]
expr_stmt|;
operator|*
operator|(
specifier|volatile
name|u_int32_t
operator|*
operator|)
name|TC_3000_500_IMR_WRITE
operator|=
name|tc_3000_500_imask
expr_stmt|;
name|tc_mb
argument_list|()
expr_stmt|;
name|tc_3000_500_intr
index|[
name|dev
index|]
operator|.
name|tci_func
operator|=
name|tc_intrnull
expr_stmt|;
name|tc_3000_500_intr
index|[
name|dev
index|]
operator|.
name|tci_arg
operator|=
operator|(
name|void
operator|*
operator|)
name|dev
expr_stmt|;
block|}
end_function

begin_function
name|void
name|tc_3000_500_iointr
parameter_list|(
name|framep
parameter_list|,
name|vec
parameter_list|)
name|void
modifier|*
name|framep
decl_stmt|;
name|unsigned
name|long
name|vec
decl_stmt|;
block|{
name|u_int32_t
name|ir
decl_stmt|;
name|int
name|ifound
decl_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|int
name|s
decl_stmt|;
if|if
condition|(
name|vec
operator|!=
literal|0x800
condition|)
name|panic
argument_list|(
literal|"INVALID ASSUMPTION: vec 0x%lx, not 0x800"
argument_list|,
name|vec
argument_list|)
expr_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|ALPHA_PSL_IPL_IO
condition|)
name|panic
argument_list|(
literal|"INVALID ASSUMPTION: IPL %d, not %d"
argument_list|,
name|s
argument_list|,
name|ALPHA_PSL_IPL_IO
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
do|do
block|{
name|tc_syncbus
argument_list|()
expr_stmt|;
name|ir
operator|=
operator|*
operator|(
specifier|volatile
name|u_int32_t
operator|*
operator|)
name|TC_3000_500_IR_CLEAR
expr_stmt|;
comment|/* Ignore interrupts that we haven't enabled. */
name|ir
operator|&=
operator|~
operator|(
name|tc_3000_500_imask
operator|&
literal|0x1ff
operator|)
expr_stmt|;
name|ifound
operator|=
literal|0
expr_stmt|;
define|#
directive|define
name|CHECKINTR
parameter_list|(
name|slot
parameter_list|)
define|\
value|if (ir& tc_3000_500_intrbits[slot]) {                  \                         ifound = 1;                                     \                         (*tc_3000_500_intr[slot].tci_func)              \                             (tc_3000_500_intr[slot].tci_arg);           \                 }
comment|/* Do them in order of priority; highest slot # first. */
name|CHECKINTR
argument_list|(
name|TC_3000_500_DEV_CXTURBO
argument_list|)
expr_stmt|;
name|CHECKINTR
argument_list|(
name|TC_3000_500_DEV_IOASIC
argument_list|)
expr_stmt|;
name|CHECKINTR
argument_list|(
name|TC_3000_500_DEV_TCDS
argument_list|)
expr_stmt|;
name|CHECKINTR
argument_list|(
name|TC_3000_500_DEV_OPT5
argument_list|)
expr_stmt|;
name|CHECKINTR
argument_list|(
name|TC_3000_500_DEV_OPT4
argument_list|)
expr_stmt|;
name|CHECKINTR
argument_list|(
name|TC_3000_500_DEV_OPT3
argument_list|)
expr_stmt|;
name|CHECKINTR
argument_list|(
name|TC_3000_500_DEV_OPT2
argument_list|)
expr_stmt|;
name|CHECKINTR
argument_list|(
name|TC_3000_500_DEV_OPT1
argument_list|)
expr_stmt|;
name|CHECKINTR
argument_list|(
name|TC_3000_500_DEV_OPT0
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|CHECKINTR
ifdef|#
directive|ifdef
name|DIAGNOSTIC
define|#
directive|define
name|PRINTINTR
parameter_list|(
name|msg
parameter_list|,
name|bits
parameter_list|)
define|\
value|if (ir& bits)                                                  \                 printf(msg);
name|PRINTINTR
argument_list|(
literal|"Second error occurred\n"
argument_list|,
name|TC_3000_500_IR_ERR2
argument_list|)
expr_stmt|;
name|PRINTINTR
argument_list|(
literal|"DMA buffer error\n"
argument_list|,
name|TC_3000_500_IR_DMABE
argument_list|)
expr_stmt|;
name|PRINTINTR
argument_list|(
literal|"DMA cross 2K boundary\n"
argument_list|,
name|TC_3000_500_IR_DMA2K
argument_list|)
expr_stmt|;
name|PRINTINTR
argument_list|(
literal|"TC reset in progress\n"
argument_list|,
name|TC_3000_500_IR_TCRESET
argument_list|)
expr_stmt|;
name|PRINTINTR
argument_list|(
literal|"TC parity error\n"
argument_list|,
name|TC_3000_500_IR_TCPAR
argument_list|)
expr_stmt|;
name|PRINTINTR
argument_list|(
literal|"DMA tag error\n"
argument_list|,
name|TC_3000_500_IR_DMATAG
argument_list|)
expr_stmt|;
name|PRINTINTR
argument_list|(
literal|"Single-bit error\n"
argument_list|,
name|TC_3000_500_IR_DMASBE
argument_list|)
expr_stmt|;
name|PRINTINTR
argument_list|(
literal|"Double-bit error\n"
argument_list|,
name|TC_3000_500_IR_DMADBE
argument_list|)
expr_stmt|;
name|PRINTINTR
argument_list|(
literal|"TC I/O timeout\n"
argument_list|,
name|TC_3000_500_IR_TCTIMEOUT
argument_list|)
expr_stmt|;
name|PRINTINTR
argument_list|(
literal|"DMA block too long\n"
argument_list|,
name|TC_3000_500_IR_DMABLOCK
argument_list|)
expr_stmt|;
name|PRINTINTR
argument_list|(
literal|"Invalid I/O address\n"
argument_list|,
name|TC_3000_500_IR_IOADDR
argument_list|)
expr_stmt|;
name|PRINTINTR
argument_list|(
literal|"DMA scatter/gather invalid\n"
argument_list|,
name|TC_3000_500_IR_DMASG
argument_list|)
expr_stmt|;
name|PRINTINTR
argument_list|(
literal|"Scatter/gather parity error\n"
argument_list|,
name|TC_3000_500_IR_SGPAR
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|PRINTINTR
endif|#
directive|endif
block|}
do|while
condition|(
name|ifound
condition|)
do|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*  * tc_3000_500_ioslot --  *      Set the PBS bits for devices on the TC.  */
end_comment

begin_endif
unit|void tc_3000_500_ioslot(slot, flags, set)         u_int32_t slot, flags;         int set; {         volatile u_int32_t *iosp;         u_int32_t ios;         int s;                  iosp = (volatile u_int32_t *)TC_3000_500_IOSLOT;         ios = *iosp;         flags<<= (slot * 3);         if (set)                 ios |= flags;         else                 ios&= ~flags;         s = splhigh();         *iosp = ios;         tc_mb();         splx(s); }
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEC_3000_500 */
end_comment

begin_function
name|int
name|tc_intrnull
parameter_list|(
name|val
parameter_list|)
name|void
modifier|*
name|val
decl_stmt|;
block|{
name|panic
argument_list|(
literal|"tc_intrnull: uncaught TC intr for cookie %ld\n"
argument_list|,
operator|(
name|u_long
operator|)
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|tc_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
if|if
condition|(
operator|(
name|hwrpb
operator|->
name|rpb_type
operator|!=
name|ST_DEC_3000_300
operator|)
operator|&&
operator|(
name|hwrpb
operator|->
name|rpb_type
operator|!=
name|ST_DEC_3000_500
operator|)
condition|)
return|return
name|ENXIO
return|;
name|tc0
operator|=
name|dev
expr_stmt|;
if|if
condition|(
name|hwrpb
operator|->
name|rpb_type
operator|==
name|ST_DEC_3000_300
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"12.5 Mhz Turbochannel Bus"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"25 Mhz Turbochannel Bus"
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tc_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|tc_softc
modifier|*
name|sc
init|=
name|TC_SOFTC
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|tc_addr_t
name|tcaddr
decl_stmt|;
specifier|const
name|struct
name|tc_builtin
modifier|*
name|builtin
decl_stmt|;
name|struct
name|tc_attach_args
modifier|*
name|ta
decl_stmt|;
name|int
name|i
decl_stmt|;
name|device_t
name|child
init|=
name|NULL
decl_stmt|;
name|tc0
operator|=
name|dev
expr_stmt|;
switch|switch
condition|(
name|hwrpb
operator|->
name|rpb_type
condition|)
block|{
ifdef|#
directive|ifdef
name|DEC_3000_300
case|case
name|ST_DEC_3000_300
case|:
name|sc
operator|->
name|sc_speed
operator|=
name|TC_SPEED_12_5_MHZ
expr_stmt|;
name|sc
operator|->
name|sc_nslots
operator|=
name|tc_3000_300_nslots
expr_stmt|;
name|sc
operator|->
name|sc_slots
operator|=
name|tc_3000_300_slots
expr_stmt|;
name|sc
operator|->
name|nbuiltins
operator|=
name|tc_3000_300_nbuiltins
expr_stmt|;
name|sc
operator|->
name|builtins
operator|=
name|tc_3000_300_builtins
expr_stmt|;
name|tc_3000_300_intr_setup
argument_list|()
expr_stmt|;
name|set_iointr
argument_list|(
name|tc_3000_300_iointr
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_intr_establish
operator|=
name|tc_3000_300_intr_establish
expr_stmt|;
name|sc
operator|->
name|sc_intr_disestablish
operator|=
name|tc_3000_300_intr_disestablish
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* DEC_3000_500 */
ifdef|#
directive|ifdef
name|DEC_3000_500
case|case
name|ST_DEC_3000_500
case|:
name|sc
operator|->
name|sc_speed
operator|=
name|TC_SPEED_25_MHZ
expr_stmt|;
name|sc
operator|->
name|sc_nslots
operator|=
name|tc_3000_500_nslots
expr_stmt|;
name|sc
operator|->
name|sc_slots
operator|=
name|tc_3000_500_slots
expr_stmt|;
name|sc
operator|->
name|nbuiltins
operator|=
name|tc_3000_500_nbuiltins
expr_stmt|;
name|sc
operator|->
name|builtins
operator|=
name|tc_3000_500_builtins
expr_stmt|;
name|tc_3000_500_intr_setup
argument_list|()
expr_stmt|;
name|set_iointr
argument_list|(
name|tc_3000_500_iointr
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_intr_establish
operator|=
name|tc_3000_500_intr_establish
expr_stmt|;
name|sc
operator|->
name|sc_intr_disestablish
operator|=
name|tc_3000_500_intr_disestablish
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* DEC_3000_500 */
default|default:
name|panic
argument_list|(
literal|"tcattach: bad cpu type"
argument_list|)
expr_stmt|;
block|}
comment|/*          * Try to configure each built-in device          */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|nbuiltins
condition|;
name|i
operator|++
control|)
block|{
name|builtin
operator|=
operator|&
name|sc
operator|->
name|builtins
index|[
name|i
index|]
expr_stmt|;
name|tcaddr
operator|=
name|sc
operator|->
name|sc_slots
index|[
name|builtin
operator|->
name|tcb_slot
index|]
operator|.
name|tcs_addr
operator|+
name|builtin
operator|->
name|tcb_offset
expr_stmt|;
if|if
condition|(
name|tc_badaddr
argument_list|(
name|tcaddr
argument_list|)
condition|)
continue|continue;
name|ta
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|tc_attach_args
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ta
condition|)
continue|continue;
name|ta
operator|->
name|ta_slot
operator|=
name|builtin
operator|->
name|tcb_slot
expr_stmt|;
name|ta
operator|->
name|ta_offset
operator|=
name|builtin
operator|->
name|tcb_offset
expr_stmt|;
name|ta
operator|->
name|ta_addr
operator|=
name|tcaddr
expr_stmt|;
name|ta
operator|->
name|ta_cookie
operator|=
name|builtin
operator|->
name|tcb_cookie
expr_stmt|;
name|ta
operator|->
name|ta_busspeed
operator|=
name|sc
operator|->
name|sc_speed
expr_stmt|;
name|child
operator|=
name|device_add_child
argument_list|(
name|dev
argument_list|,
name|builtin
operator|->
name|tcb_modname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|device_set_ivars
argument_list|(
name|child
argument_list|,
name|ta
argument_list|)
expr_stmt|;
name|device_probe_and_attach
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|tc_checkslot
parameter_list|(
name|slotbase
parameter_list|,
name|namep
parameter_list|)
name|tc_addr_t
name|slotbase
decl_stmt|;
name|char
modifier|*
name|namep
decl_stmt|;
block|{
name|struct
name|tc_rommap
modifier|*
name|romp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTC_ROMOFFS
condition|;
name|i
operator|++
control|)
block|{
name|romp
operator|=
operator|(
expr|struct
name|tc_rommap
operator|*
operator|)
operator|(
name|slotbase
operator|+
name|tc_slot_romoffs
index|[
name|i
index|]
operator|)
expr_stmt|;
switch|switch
condition|(
name|romp
operator|->
name|tcr_width
operator|.
name|v
condition|)
block|{
case|case
literal|1
case|:
case|case
literal|2
case|:
case|case
literal|4
case|:
break|break;
default|default:
continue|continue;
block|}
if|if
condition|(
name|romp
operator|->
name|tcr_stride
operator|.
name|v
operator|!=
literal|4
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|4
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|romp
operator|->
name|tcr_test
index|[
name|j
operator|+
literal|0
operator|*
name|romp
operator|->
name|tcr_stride
operator|.
name|v
index|]
operator|!=
literal|0x55
operator|||
name|romp
operator|->
name|tcr_test
index|[
name|j
operator|+
literal|1
operator|*
name|romp
operator|->
name|tcr_stride
operator|.
name|v
index|]
operator|!=
literal|0x00
operator|||
name|romp
operator|->
name|tcr_test
index|[
name|j
operator|+
literal|2
operator|*
name|romp
operator|->
name|tcr_stride
operator|.
name|v
index|]
operator|!=
literal|0xaa
operator|||
name|romp
operator|->
name|tcr_test
index|[
name|j
operator|+
literal|3
operator|*
name|romp
operator|->
name|tcr_stride
operator|.
name|v
index|]
operator|!=
literal|0xff
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|TC_ROM_LLEN
condition|;
name|j
operator|++
control|)
name|namep
index|[
name|j
index|]
operator|=
name|romp
operator|->
name|tcr_modname
index|[
name|j
index|]
operator|.
name|v
expr_stmt|;
name|namep
index|[
name|j
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function_decl
name|void
name|tc_intr_establish
parameter_list|(
name|dev
parameter_list|,
name|cookie
parameter_list|,
name|level
parameter_list|,
name|handler
parameter_list|,
name|arg
parameter_list|)
name|struct
name|device
modifier|*
name|dev
decl_stmt|;
name|void
modifier|*
name|cookie
decl_stmt|,
decl|*
name|arg
decl_stmt|;
end_function_decl

begin_decl_stmt
name|tc_intrlevel_t
name|level
decl_stmt|;
end_decl_stmt

begin_macro
name|int
argument_list|(
argument|*handler
argument_list|)
end_macro

begin_expr_stmt
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|tc_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|tc_softc
operator|*
operator|)
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
call|(
modifier|*
name|sc
operator|->
name|sc_intr_establish
call|)
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|cookie
argument_list|,
name|level
argument_list|,
name|handler
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|void
name|tc_intr_disestablish
parameter_list|(
name|dev
parameter_list|,
name|cookie
parameter_list|)
name|struct
name|device
modifier|*
name|dev
decl_stmt|;
name|void
modifier|*
name|cookie
decl_stmt|;
block|{
name|struct
name|tc_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|tc_softc
operator|*
operator|)
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
call|(
modifier|*
name|sc
operator|->
name|sc_intr_disestablish
call|)
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|cookie
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|tc
argument_list|,
name|tcasic
argument_list|,
name|tc_driver
argument_list|,
name|tc_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

