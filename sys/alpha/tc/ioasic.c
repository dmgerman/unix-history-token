begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/* from $NetBSD: ioasic.c,v 1.19 1998/05/27 00:18:13 thorpej Exp $ */
end_comment

begin_comment
comment|/*-  * Copyright (c) 1997, 1998 The NetBSD Foundation, Inc.  * All rights reserved.  *  * This code is derived from software contributed to The NetBSD Foundation  * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,  * NASA Ames Research Center.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the NetBSD  *	Foundation, Inc. and its contributors.  * 4. Neither the name of The NetBSD Foundation nor the names of its  *    contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Copyright (c) 1994, 1995, 1996 Carnegie-Mellon University.  * All rights reserved.  *  * Author: Keith Bostic, Chris G. Demetriou  *   * Permission to use, copy, modify and distribute this software and  * its documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *   * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"   * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND   * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *   * Carnegie Mellon requests users of this software to return to  *  *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *  * any improvements or extensions that they make and grant Carnegie the  * rights to redistribute these changes.  */
end_comment

begin_include
include|#
directive|include
file|"opt_cpu.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<machine/rpb.h>
end_include

begin_include
include|#
directive|include
file|<alpha/tc/tcreg.h>
end_include

begin_include
include|#
directive|include
file|<alpha/tc/tcvar.h>
end_include

begin_include
include|#
directive|include
file|<alpha/tc/tcdevs.h>
end_include

begin_include
include|#
directive|include
file|<alpha/tc/ioasicreg.h>
end_include

begin_include
include|#
directive|include
file|<alpha/tc/ioasicvar.h>
end_include

begin_define
define|#
directive|define
name|KV
parameter_list|(
name|pa
parameter_list|)
value|ALPHA_PHYS_TO_K0SEG(pa)
end_define

begin_decl_stmt
specifier|static
name|devclass_t
name|ioasic_devclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_t
name|ioasic0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* there can be only one */
end_comment

begin_struct
struct|struct
name|ioasic_softc
block|{
name|device_t
name|sc_dv
decl_stmt|;
name|vm_offset_t
name|sc_base
decl_stmt|;
name|void
modifier|*
name|sc_cookie
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|IOASIC_SOFTC
parameter_list|(
name|dev
parameter_list|)
value|(struct ioasic_softc*) device_get_softc(dev)
end_define

begin_function_decl
specifier|static
name|int
name|ioasic_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ioasic_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|driver_intr_t
name|ioasic_intrnull
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|ioasic_print_child
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ioasic_lance_dma_setup
parameter_list|(
name|void
modifier|*
name|v
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ioasic_intr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|caddr_t
name|le_iomem
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_method_t
name|ioasic_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|ioasic_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|ioasic_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_print_child
argument_list|,
name|ioasic_print_child
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|ioasic_driver
init|=
block|{
literal|"ioasic"
block|,
name|ioasic_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ioasic_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|IOASIC_DEV_LANCE
value|0
end_define

begin_define
define|#
directive|define
name|IOASIC_DEV_SCC0
value|1
end_define

begin_define
define|#
directive|define
name|IOASIC_DEV_SCC1
value|2
end_define

begin_define
define|#
directive|define
name|IOASIC_DEV_ISDN
value|3
end_define

begin_define
define|#
directive|define
name|IOASIC_DEV_BOGUS
value|-1
end_define

begin_define
define|#
directive|define
name|IOASIC_NCOOKIES
value|4
end_define

begin_define
define|#
directive|define
name|C
parameter_list|(
name|x
parameter_list|)
value|((void *)(u_long)x)
end_define

begin_decl_stmt
name|struct
name|ioasic_dev
name|ioasic_devs
index|[]
init|=
block|{
block|{
literal|"le"
block|,
literal|0x000c0000
block|,
literal|0
block|,
name|C
argument_list|(
name|IOASIC_DEV_LANCE
argument_list|)
block|,
name|IOASIC_INTR_LANCE
block|, }
block|,
ifdef|#
directive|ifdef
name|notyet
block|{
literal|"z8530   "
block|,
literal|0x00100000
block|,
literal|0
block|,
name|C
argument_list|(
name|IOASIC_DEV_SCC0
argument_list|)
block|,
name|IOASIC_INTR_SCC_0
block|, }
block|,
block|{
literal|"z8530   "
block|,
literal|0x00180000
block|,
literal|0
block|,
name|C
argument_list|(
name|IOASIC_DEV_SCC1
argument_list|)
block|,
name|IOASIC_INTR_SCC_1
block|, }
block|,
endif|#
directive|endif
block|{
literal|"mcclock"
block|,
literal|0x00200000
block|,
literal|0
block|,
name|C
argument_list|(
name|IOASIC_DEV_BOGUS
argument_list|)
block|,
literal|0
block|,                 }
block|,
ifdef|#
directive|ifdef
name|notyet
block|{
literal|"AMD79c30"
block|,
literal|0x00240000
block|,
literal|0
block|,
name|C
argument_list|(
name|IOASIC_DEV_ISDN
argument_list|)
block|,
name|IOASIC_INTR_ISDN
block|,  }
block|,
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ioasic_ndevs
init|=
sizeof|sizeof
argument_list|(
name|ioasic_devs
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|ioasic_devs
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|ioasicintr
block|{
name|void
function_decl|(
modifier|*
name|iai_func
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
name|void
modifier|*
name|iai_arg
decl_stmt|;
block|}
name|ioasicintrs
index|[
name|IOASIC_NCOOKIES
index|]
struct|;
end_struct

begin_decl_stmt
name|tc_addr_t
name|ioasic_base
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX XXX XXX */
end_comment

begin_function
specifier|static
name|int
name|ioasic_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
if|if
condition|(
name|ioasic0
condition|)
return|return
name|ENXIO
return|;
if|if
condition|(
operator|(
name|hwrpb
operator|->
name|rpb_type
operator|!=
name|ST_DEC_3000_300
operator|)
operator|&&
operator|(
name|hwrpb
operator|->
name|rpb_type
operator|!=
name|ST_DEC_3000_500
operator|)
condition|)
return|return
name|ENXIO
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"ioasic"
argument_list|)
condition|)
block|{
return|return
name|ENXIO
return|;
block|}
name|ioasic0
operator|=
name|dev
expr_stmt|;
if|if
condition|(
name|hwrpb
operator|->
name|rpb_type
operator|==
name|ST_DEC_3000_300
condition|)
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Turbochannel ioasic: slow mode"
argument_list|)
expr_stmt|;
else|else
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Turbochannel ioasic: fast mode"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ioasic_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|device_t
name|child
decl_stmt|;
name|struct
name|ioasic_softc
modifier|*
name|sc
init|=
name|IOASIC_SOFTC
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|tc_attach_args
modifier|*
name|ta
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|device_t
name|parent
init|=
name|device_get_parent
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u_long
name|i
decl_stmt|;
name|ioasic0
operator|=
name|dev
expr_stmt|;
name|sc
operator|->
name|sc_base
operator|=
name|ta
operator|->
name|ta_addr
expr_stmt|;
name|sc
operator|->
name|sc_cookie
operator|=
name|ta
operator|->
name|ta_cookie
expr_stmt|;
name|ioasic_base
operator|=
name|sc
operator|->
name|sc_base
expr_stmt|;
ifdef|#
directive|ifdef
name|DEC_3000_300
if|if
condition|(
name|hwrpb
operator|->
name|rpb_type
operator|==
name|ST_DEC_3000_300
condition|)
block|{
operator|*
operator|(
specifier|volatile
name|u_int
operator|*
operator|)
name|IOASIC_REG_CSR
argument_list|(
name|sc
operator|->
name|sc_base
argument_list|)
operator||=
name|IOASIC_CSR_FASTMODE
expr_stmt|;
name|tc_mb
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*          * Turn off all device interrupt bits.          * (This does _not_ include 3000/300 TC option slot bits.          */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ioasic_ndevs
condition|;
name|i
operator|++
control|)
operator|*
operator|(
specifier|volatile
name|u_int32_t
operator|*
operator|)
name|IOASIC_REG_IMSK
argument_list|(
name|ioasic_base
argument_list|)
operator|&=
operator|~
name|ioasic_devs
index|[
name|i
index|]
operator|.
name|iad_intrbits
expr_stmt|;
name|tc_mb
argument_list|()
expr_stmt|;
comment|/*          * Set up interrupt handlers.          */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IOASIC_NCOOKIES
condition|;
name|i
operator|++
control|)
block|{
name|ioasicintrs
index|[
name|i
index|]
operator|.
name|iai_func
operator|=
name|ioasic_intrnull
expr_stmt|;
name|ioasicintrs
index|[
name|i
index|]
operator|.
name|iai_arg
operator|=
operator|(
name|void
operator|*
operator|)
name|i
expr_stmt|;
block|}
name|tc_intr_establish
argument_list|(
name|parent
argument_list|,
name|sc
operator|->
name|sc_cookie
argument_list|,
literal|0
argument_list|,
name|ioasic_intr
argument_list|,
name|sc
argument_list|)
expr_stmt|;
define|#
directive|define
name|LANCE_DMA_SIZE
value|128*1024
define|#
directive|define
name|LANCE_DMA_ALIGN
value|128*1024
comment|/*          * Set up the LANCE DMA area.          */
name|le_iomem
operator|=
operator|(
name|caddr_t
operator|)
name|vm_page_alloc_contig
argument_list|(
name|round_page
argument_list|(
name|LANCE_DMA_SIZE
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
name|LANCE_DMA_ALIGN
argument_list|)
expr_stmt|;
name|le_iomem
operator|=
operator|(
name|caddr_t
operator|)
name|ALPHA_PHYS_TO_K0SEG
argument_list|(
name|vtophys
argument_list|(
name|le_iomem
argument_list|)
argument_list|)
expr_stmt|;
name|ioasic_lance_dma_setup
argument_list|(
operator|(
name|void
operator|*
operator|)
name|le_iomem
argument_list|)
expr_stmt|;
comment|/* 	 * round up our children  	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ioasic_ndevs
condition|;
name|i
operator|++
control|)
block|{
name|ioasic_devs
index|[
name|i
index|]
operator|.
name|iada_addr
operator|=
name|sc
operator|->
name|sc_base
operator|+
name|ioasic_devs
index|[
name|i
index|]
operator|.
name|iad_offset
expr_stmt|;
name|child
operator|=
name|device_add_child
argument_list|(
name|dev
argument_list|,
name|ioasic_devs
index|[
name|i
index|]
operator|.
name|iad_modname
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|device_set_ivars
argument_list|(
name|child
argument_list|,
operator|&
name|ioasic_devs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|device_probe_and_attach
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ioasic_intrnull
parameter_list|(
name|void
modifier|*
name|val
parameter_list|)
block|{
name|panic
argument_list|(
literal|"ioasic_intrnull: uncaught IOASIC intr for cookie %ld\n"
argument_list|,
operator|(
name|u_long
operator|)
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ioasic_print_child
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ioasic_dev
modifier|*
name|ioasic
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|retval
operator|+=
name|bus_print_child_header
argument_list|(
name|bus
argument_list|,
name|dev
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|printf
argument_list|(
literal|" on %s offset 0x%x\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|bus
argument_list|)
argument_list|,
name|ioasic
operator|->
name|iad_offset
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|ioasic_lance_ether_address
parameter_list|()
block|{
return|return
operator|(
name|u_char
operator|*
operator|)
name|IOASIC_SYS_ETHER_ADDRESS
argument_list|(
name|ioasic_base
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ioasic_lance_dma_setup
parameter_list|(
name|void
modifier|*
name|v
parameter_list|)
block|{
specifier|volatile
name|u_int32_t
modifier|*
name|ldp
decl_stmt|;
name|tc_addr_t
name|tca
decl_stmt|;
name|tca
operator|=
operator|(
name|tc_addr_t
operator|)
name|v
expr_stmt|;
name|tca
operator|&=
literal|0xffffffff
expr_stmt|;
name|ldp
operator|=
operator|(
specifier|volatile
name|u_int
operator|*
operator|)
name|IOASIC_REG_LANCE_DMAPTR
argument_list|(
name|ioasic_base
argument_list|)
expr_stmt|;
operator|*
name|ldp
operator|=
operator|(
operator|(
name|tca
operator|<<
literal|3
operator|)
operator|&
operator|~
operator|(
name|tc_addr_t
operator|)
literal|0x1f
operator|)
operator||
operator|(
operator|(
name|tca
operator|>>
literal|29
operator|)
operator|&
literal|0x1f
operator|)
expr_stmt|;
name|tc_wmb
argument_list|()
expr_stmt|;
operator|*
operator|(
specifier|volatile
name|u_int32_t
operator|*
operator|)
name|IOASIC_REG_CSR
argument_list|(
name|ioasic_base
argument_list|)
operator||=
name|IOASIC_CSR_DMAEN_LANCE
expr_stmt|;
name|tc_mb
argument_list|()
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|void
name|ioasic_intr_establish
argument_list|(
name|ioa
argument_list|,
name|cookie
argument_list|,
name|level
argument_list|,
name|func
argument_list|,
name|arg
argument_list|)
name|device_t
name|ioa
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
modifier|*
name|cookie
decl_stmt|,
modifier|*
name|arg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tc_intrlevel_t
name|level
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_block
block|{
name|u_long
name|dev
decl_stmt|,
name|i
decl_stmt|;
name|dev
operator|=
operator|(
name|u_long
operator|)
name|cookie
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
comment|/* XXX check cookie. */
endif|#
directive|endif
if|if
condition|(
name|ioasicintrs
index|[
name|dev
index|]
operator|.
name|iai_func
operator|!=
name|ioasic_intrnull
condition|)
name|panic
argument_list|(
literal|"ioasic_intr_establish: cookie %ld twice"
argument_list|,
name|dev
argument_list|)
expr_stmt|;
name|ioasicintrs
index|[
name|dev
index|]
operator|.
name|iai_func
operator|=
name|func
expr_stmt|;
name|ioasicintrs
index|[
name|dev
index|]
operator|.
name|iai_arg
operator|=
name|arg
expr_stmt|;
comment|/* Enable interrupts for the device. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ioasic_ndevs
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ioasic_devs
index|[
name|i
index|]
operator|.
name|iad_cookie
operator|==
name|cookie
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|ioasic_ndevs
condition|)
name|panic
argument_list|(
literal|"ioasic_intr_establish: invalid cookie."
argument_list|)
expr_stmt|;
operator|*
operator|(
specifier|volatile
name|u_int32_t
operator|*
operator|)
name|IOASIC_REG_IMSK
argument_list|(
name|ioasic_base
argument_list|)
operator||=
name|ioasic_devs
index|[
name|i
index|]
operator|.
name|iad_intrbits
expr_stmt|;
name|tc_mb
argument_list|()
expr_stmt|;
block|}
end_block

begin_function
name|void
name|ioasic_intr_disestablish
parameter_list|(
name|ioa
parameter_list|,
name|cookie
parameter_list|)
name|device_t
name|ioa
decl_stmt|;
name|void
modifier|*
name|cookie
decl_stmt|;
block|{
name|u_long
name|dev
decl_stmt|,
name|i
decl_stmt|;
name|dev
operator|=
operator|(
name|u_long
operator|)
name|cookie
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
comment|/* XXX check cookie. */
endif|#
directive|endif
if|if
condition|(
name|ioasicintrs
index|[
name|dev
index|]
operator|.
name|iai_func
operator|==
name|ioasic_intrnull
condition|)
name|panic
argument_list|(
literal|"ioasic_intr_disestablish: cookie %ld missing intr"
argument_list|,
name|dev
argument_list|)
expr_stmt|;
comment|/* Enable interrupts for the device. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ioasic_ndevs
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ioasic_devs
index|[
name|i
index|]
operator|.
name|iad_cookie
operator|==
name|cookie
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|ioasic_ndevs
condition|)
name|panic
argument_list|(
literal|"ioasic_intr_disestablish: invalid cookie."
argument_list|)
expr_stmt|;
operator|*
operator|(
specifier|volatile
name|u_int32_t
operator|*
operator|)
name|IOASIC_REG_IMSK
argument_list|(
name|ioasic_base
argument_list|)
operator|&=
operator|~
name|ioasic_devs
index|[
name|i
index|]
operator|.
name|iad_intrbits
expr_stmt|;
name|tc_mb
argument_list|()
expr_stmt|;
name|ioasicintrs
index|[
name|dev
index|]
operator|.
name|iai_func
operator|=
name|ioasic_intrnull
expr_stmt|;
name|ioasicintrs
index|[
name|dev
index|]
operator|.
name|iai_arg
operator|=
operator|(
name|void
operator|*
operator|)
name|dev
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * asic_intr --  *      ASIC interrupt handler.  */
end_comment

begin_function
name|int
name|ioasic_intr
parameter_list|(
name|val
parameter_list|)
name|void
modifier|*
name|val
decl_stmt|;
block|{
specifier|register
name|struct
name|ioasic_softc
modifier|*
name|sc
init|=
name|val
decl_stmt|;
specifier|register
name|int
name|ifound
decl_stmt|;
name|int
name|gifound
decl_stmt|;
name|u_int32_t
name|sir
decl_stmt|;
specifier|volatile
name|u_int32_t
modifier|*
name|sirp
decl_stmt|;
name|sirp
operator|=
operator|(
specifier|volatile
name|u_int32_t
operator|*
operator|)
name|IOASIC_REG_INTR
argument_list|(
name|sc
operator|->
name|sc_base
argument_list|)
expr_stmt|;
name|gifound
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|ifound
operator|=
literal|0
expr_stmt|;
name|tc_syncbus
argument_list|()
expr_stmt|;
name|sir
operator|=
operator|*
name|sirp
expr_stmt|;
comment|/* XXX DUPLICATION OF INTERRUPT BIT INFORMATION... */
define|#
directive|define
name|CHECKINTR
parameter_list|(
name|slot
parameter_list|,
name|bits
parameter_list|)
define|\
value|if (sir& bits) {                                       \                         ifound = 1;                                     \                         (*ioasicintrs[slot].iai_func)                   \                             (ioasicintrs[slot].iai_arg);                \                 }
name|CHECKINTR
argument_list|(
name|IOASIC_DEV_SCC0
argument_list|,
name|IOASIC_INTR_SCC_0
argument_list|)
expr_stmt|;
name|CHECKINTR
argument_list|(
name|IOASIC_DEV_SCC1
argument_list|,
name|IOASIC_INTR_SCC_1
argument_list|)
expr_stmt|;
name|CHECKINTR
argument_list|(
name|IOASIC_DEV_LANCE
argument_list|,
name|IOASIC_INTR_LANCE
argument_list|)
expr_stmt|;
name|CHECKINTR
argument_list|(
name|IOASIC_DEV_ISDN
argument_list|,
name|IOASIC_INTR_ISDN
argument_list|)
expr_stmt|;
name|gifound
operator||=
name|ifound
expr_stmt|;
block|}
do|while
condition|(
name|ifound
condition|)
do|;
return|return
operator|(
name|gifound
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|ioasic
argument_list|,
name|tc
argument_list|,
name|ioasic_driver
argument_list|,
name|ioasic_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

