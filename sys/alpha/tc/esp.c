begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $Id$ */
end_comment

begin_comment
comment|/*	$NetBSD: esp.c,v 1.8.4.2 1996/09/10 17:28:16 cgd Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright (c) 1994 Peter Galbavy  * Copyright (c) 1995 Paul Kranenburg  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Peter Galbavy  * 4. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Based on aic6360 by Jarle Greipsland  *  * Acknowledgements: Many of the algorithms used in this driver are  * inspired by the work of Julian Elischer (julian@tfs.com) and  * Charles Hannum (mycroft@duality.gnu.ai.mit.edu).  Thanks a million!  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/device.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_comment
comment|/*#include<sys/ioctl.h>*/
end_comment

begin_include
include|#
directive|include
file|<sys/device.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_comment
comment|/*#include<sys/user.h>*/
end_comment

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<scsi/scsiconf.h>
end_include

begin_include
include|#
directive|include
file|<scsi/scsi_message.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<alpha/tc/tcreg.h>
end_include

begin_include
include|#
directive|include
file|<alpha/tc/tcvar.h>
end_include

begin_include
include|#
directive|include
file|<alpha/tc/tcdsreg.h>
end_include

begin_include
include|#
directive|include
file|<alpha/tc/tcdsvar.h>
end_include

begin_include
include|#
directive|include
file|<alpha/tc/espreg.h>
end_include

begin_include
include|#
directive|include
file|<alpha/tc/espvar.h>
end_include

begin_decl_stmt
name|int
name|esp_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*ESP_SHOWPHASE|ESP_SHOWMISC|ESP_SHOWTRAC|ESP_SHOWCMDS;*/
end_comment

begin_comment
comment|/*static*/
end_comment

begin_decl_stmt
name|void
name|espattach
name|__P
argument_list|(
operator|(
expr|struct
name|device
operator|*
operator|,
expr|struct
name|device
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*static*/
end_comment

begin_decl_stmt
name|int
name|espmatch
name|__P
argument_list|(
operator|(
expr|struct
name|device
operator|*
operator|,
name|void
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*static*/
end_comment

begin_decl_stmt
name|int
name|espprint
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*static*/
end_comment

begin_decl_stmt
name|u_int
name|esp_adapter_info
name|__P
argument_list|(
operator|(
expr|struct
name|esp_softc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*static*/
end_comment

begin_decl_stmt
name|void
name|espreadregs
name|__P
argument_list|(
operator|(
expr|struct
name|esp_softc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*static*/
end_comment

begin_decl_stmt
name|void
name|espselect
name|__P
argument_list|(
operator|(
expr|struct
name|esp_softc
operator|*
operator|,
name|u_char
operator|,
name|u_char
operator|,
name|u_char
operator|*
operator|,
name|u_char
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*static*/
end_comment

begin_decl_stmt
name|void
name|esp_scsi_reset
name|__P
argument_list|(
operator|(
expr|struct
name|esp_softc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*static*/
end_comment

begin_decl_stmt
name|void
name|esp_reset
name|__P
argument_list|(
operator|(
expr|struct
name|esp_softc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*static*/
end_comment

begin_decl_stmt
name|void
name|esp_init
name|__P
argument_list|(
operator|(
expr|struct
name|esp_softc
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*static*/
end_comment

begin_decl_stmt
name|int
name|esp_scsi_cmd
name|__P
argument_list|(
operator|(
expr|struct
name|scsi_xfer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*static*/
end_comment

begin_decl_stmt
name|int
name|esp_poll
name|__P
argument_list|(
operator|(
expr|struct
name|esp_softc
operator|*
operator|,
expr|struct
name|ecb
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*static*/
end_comment

begin_decl_stmt
name|void
name|esp_sched
name|__P
argument_list|(
operator|(
expr|struct
name|esp_softc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*static*/
end_comment

begin_decl_stmt
name|void
name|esp_done
name|__P
argument_list|(
operator|(
expr|struct
name|ecb
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*static*/
end_comment

begin_decl_stmt
name|void
name|esp_msgin
name|__P
argument_list|(
operator|(
expr|struct
name|esp_softc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*static*/
end_comment

begin_decl_stmt
name|void
name|esp_msgout
name|__P
argument_list|(
operator|(
expr|struct
name|esp_softc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*static*/
end_comment

begin_decl_stmt
name|int
name|espintr
name|__P
argument_list|(
operator|(
expr|struct
name|esp_softc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*static*/
end_comment

begin_decl_stmt
name|void
name|esp_timeout
name|__P
argument_list|(
operator|(
name|void
operator|*
name|arg
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*static*/
end_comment

begin_decl_stmt
name|void
name|esp_abort
name|__P
argument_list|(
operator|(
expr|struct
name|esp_softc
operator|*
operator|,
expr|struct
name|ecb
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int32_t
name|esp_info
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|esp_stp2cpb
name|__P
argument_list|(
operator|(
expr|struct
name|esp_softc
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|esp_cpb2stp
name|__P
argument_list|(
operator|(
expr|struct
name|esp_softc
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|esp_min_phys
parameter_list|(
name|struct
name|buf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|esp_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|esp_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|esp_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|esp_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|esp_attach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ESP_SOFTC
parameter_list|(
name|dev
parameter_list|)
value|(struct esp_softc*) device_get_softc(dev)
end_define

begin_decl_stmt
specifier|static
name|driver_t
name|esp_driver
init|=
block|{
literal|"esp"
block|,
name|esp_methods
block|,
name|DRIVER_TYPE_BIO
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|esp_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|scsi_adapter
name|esp_switch
init|=
block|{
name|esp_scsi_cmd
block|,
name|esp_min_phys
block|,
comment|/* no max at this level; handled by DMA code */
name|NULL
block|,
name|NULL
block|,
name|esp_info
block|,
literal|"esp"
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|scsi_device
name|esp_dev
init|=
block|{
name|NULL
block|,
comment|/* Use default error handler */
name|NULL
block|,
comment|/* have a queue, served by this */
name|NULL
block|,
comment|/* have no async handler */
name|NULL
block|,
comment|/* Use default 'done' routine */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|esp_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|esp
argument_list|,
name|tcds
argument_list|,
name|esp_driver
argument_list|,
name|esp_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|esp_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|device_get_name
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
literal|"tcds"
argument_list|)
condition|)
block|{
return|return
name|ENXIO
return|;
block|}
else|else
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"NCR53C94"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Attach this instance, and then all the sub-devices  */
end_comment

begin_function
name|int
name|esp_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|esp_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|tcdsdev_attach_args
modifier|*
name|tcdsdev
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|scsibus_data
modifier|*
name|scbus
decl_stmt|;
name|sc
operator|->
name|sc_reg
operator|=
operator|(
specifier|volatile
name|u_int32_t
operator|*
operator|)
name|tcdsdev
operator|->
name|tcdsda_addr
expr_stmt|;
name|sc
operator|->
name|sc_cookie
operator|=
name|tcdsdev
operator|->
name|tcdsda_cookie
expr_stmt|;
name|sc
operator|->
name|sc_dma
operator|=
name|tcdsdev
operator|->
name|tcdsda_sc
expr_stmt|;
name|tcds_intr_establish
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_cookie
argument_list|,
literal|0
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|)
name|espintr
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/*	if (parent->dv_cfdata->cf_driver ==&tcds_cd) { 		sc->sc_id = tcdsdev->tcdsda_id; 		sc->sc_freq = tcdsdev->tcdsda_freq; 		} else*/
block|{
comment|/* XXX */
name|sc
operator|->
name|sc_id
operator|=
literal|7
expr_stmt|;
name|sc
operator|->
name|sc_freq
operator|=
literal|25000000
expr_stmt|;
block|}
comment|/* gimme Mhz */
name|sc
operator|->
name|sc_freq
operator|/=
literal|1000000
expr_stmt|;
name|sc
operator|->
name|sc_dma
operator|->
name|sc_esp
operator|=
name|sc
expr_stmt|;
comment|/* XXX */
comment|/* 	 * It is necessary to try to load the 2nd config register here, 	 * to find out what rev the esp chip is, else the esp_reset 	 * will not set up the defaults correctly. 	 */
name|sc
operator|->
name|sc_cfg1
operator|=
name|sc
operator|->
name|sc_id
operator||
name|ESPCFG1_PARENB
expr_stmt|;
name|sc
operator|->
name|sc_cfg2
operator|=
name|ESPCFG2_SCSI2
expr_stmt|;
name|sc
operator|->
name|sc_cfg3
operator|=
literal|0x4
expr_stmt|;
comment|/* Save residual byte. XXX??? */
name|sc
operator|->
name|sc_rev
operator|=
name|NCR53C94
expr_stmt|;
comment|/* 	 * This is the value used to start sync negotiations 	 * Note that the ESP register "SYNCTP" is programmed 	 * in "clocks per byte", and has a minimum value of 4. 	 * The SCSI period used in negotiation is one-fourth 	 * of the time (in nanoseconds) needed to transfer one byte. 	 * Since the chip's clock is given in MHz, we have the following 	 * formula: 4 * period = (1000 / freq) * 4 	 */
name|sc
operator|->
name|sc_minsync
operator|=
literal|1000
operator|/
name|sc
operator|->
name|sc_freq
expr_stmt|;
name|sc
operator|->
name|sc_maxxfer
operator|=
literal|64
operator|*
literal|1024
expr_stmt|;
name|sc
operator|->
name|sc_ccf
operator|=
name|FREQTOCCF
argument_list|(
name|sc
operator|->
name|sc_freq
argument_list|)
expr_stmt|;
comment|/* The value *must not* be == 1. Make it 2 */
if|if
condition|(
name|sc
operator|->
name|sc_ccf
operator|==
literal|1
condition|)
name|sc
operator|->
name|sc_ccf
operator|=
literal|2
expr_stmt|;
comment|/* 	 * The recommended timeout is 250ms. This register is loaded 	 * with a value calculated as follows, from the docs: 	 * 	 *		(timout period) x (CLK frequency) 	 *	reg = ------------------------------------- 	 *		 8192 x (Clock Conversion Factor) 	 * 	 * Since CCF has a linear relation to CLK, this generally computes 	 * to the constant of 153. 	 */
name|sc
operator|->
name|sc_timeout
operator|=
operator|(
operator|(
literal|250
operator|*
literal|1000
operator|)
operator|*
name|sc
operator|->
name|sc_freq
operator|)
operator|/
operator|(
literal|8192
operator|*
name|sc
operator|->
name|sc_ccf
operator|)
expr_stmt|;
comment|/* CCF register only has 3 bits; 0 is actually 8 */
name|sc
operator|->
name|sc_ccf
operator|&=
literal|7
expr_stmt|;
comment|/* Reset state& bus */
name|sc
operator|->
name|sc_state
operator|=
literal|0
expr_stmt|;
name|esp_init
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"esp%d: %dMhz, target %d\n"
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_freq
argument_list|,
name|sc
operator|->
name|sc_id
argument_list|)
expr_stmt|;
comment|/* 	 * fill in the prototype scsi_link. 	 */
name|sc
operator|->
name|sc_link
operator|.
name|adapter_softc
operator|=
name|sc
expr_stmt|;
name|sc
operator|->
name|sc_link
operator|.
name|adapter_targ
operator|=
name|sc
operator|->
name|sc_id
expr_stmt|;
name|sc
operator|->
name|sc_link
operator|.
name|adapter
operator|=
operator|&
name|esp_switch
expr_stmt|;
name|sc
operator|->
name|sc_link
operator|.
name|device
operator|=
operator|&
name|esp_dev
expr_stmt|;
comment|/*	sc->sc_link.openings = 2;*/
name|sc
operator|->
name|sc_link
operator|.
name|fordriver
operator|=
literal|0
expr_stmt|;
comment|/* 	 * If the boot path is "esp" at the moment and it's me, then 	 * walk our pointer to the sub-device, ready for the config 	 * below. 	 */
comment|/* 	 * Now try to attach all the sub-devices 	 */
comment|/*	config_found(self,&sc->sc_link, espprint);*/
name|scbus
operator|=
name|scsi_alloc_bus
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|scbus
condition|)
return|return
name|ENXIO
return|;
name|scbus
operator|->
name|adapter_link
operator|=
operator|&
name|sc
operator|->
name|sc_link
expr_stmt|;
name|scbus
operator|->
name|maxtarg
operator|=
literal|7
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|unsigned
name|t_from
init|=
literal|0
decl_stmt|;
name|unsigned
name|t_to
init|=
name|scbus
operator|->
name|maxtarg
decl_stmt|;
name|unsigned
name|myaddr
init|=
name|sc
operator|->
name|sc_id
decl_stmt|;
name|char
modifier|*
name|txt_and
init|=
literal|""
decl_stmt|;
name|printf
argument_list|(
literal|"esp%d scanning for targets "
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|t_from
operator|<
name|myaddr
condition|)
block|{
name|printf
argument_list|(
literal|"%d..%d "
argument_list|,
name|t_from
argument_list|,
name|myaddr
operator|-
literal|1
argument_list|)
expr_stmt|;
name|txt_and
operator|=
literal|"and "
expr_stmt|;
block|}
if|if
condition|(
name|myaddr
operator|<
name|t_to
condition|)
name|printf
argument_list|(
literal|"%s%d..%d "
argument_list|,
name|txt_and
argument_list|,
name|myaddr
operator|+
literal|1
argument_list|,
name|t_to
argument_list|)
expr_stmt|;
block|}
name|scsi_attachdevs
argument_list|(
name|scbus
argument_list|)
expr_stmt|;
name|scbus
operator|=
name|NULL
expr_stmt|;
comment|/* Upper-level SCSI code owns this now */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * This is the generic esp reset function. It does not reset the SCSI bus,  * only this controllers, but kills any on-going commands, and also stops  * and resets the DMA.  *  * After reset, registers are loaded with the defaults from the attach  * routine above.  */
end_comment

begin_function
name|void
name|esp_reset
parameter_list|(
name|sc
parameter_list|)
name|struct
name|esp_softc
modifier|*
name|sc
decl_stmt|;
block|{
comment|/* reset DMA first */
name|DMA_RESET
argument_list|(
name|sc
operator|->
name|sc_dma
argument_list|)
expr_stmt|;
comment|/* reset SCSI chip */
name|ESPCMD
argument_list|(
name|sc
argument_list|,
name|ESPCMD_RSTCHIP
argument_list|)
expr_stmt|;
name|ESPCMD
argument_list|(
name|sc
argument_list|,
name|ESPCMD_NOP
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|500
argument_list|)
expr_stmt|;
comment|/* do these backwards, and fall through */
switch|switch
condition|(
name|sc
operator|->
name|sc_rev
condition|)
block|{
case|case
name|NCR53C94
case|:
case|case
name|ESP200
case|:
name|ESP_WRITE_REG
argument_list|(
name|sc
argument_list|,
name|ESP_CFG3
argument_list|,
name|sc
operator|->
name|sc_cfg3
argument_list|)
expr_stmt|;
case|case
name|ESP100A
case|:
name|ESP_WRITE_REG
argument_list|(
name|sc
argument_list|,
name|ESP_CFG2
argument_list|,
name|sc
operator|->
name|sc_cfg2
argument_list|)
expr_stmt|;
case|case
name|ESP100
case|:
name|ESP_WRITE_REG
argument_list|(
name|sc
argument_list|,
name|ESP_CFG1
argument_list|,
name|sc
operator|->
name|sc_cfg1
argument_list|)
expr_stmt|;
name|ESP_WRITE_REG
argument_list|(
name|sc
argument_list|,
name|ESP_CCF
argument_list|,
name|sc
operator|->
name|sc_ccf
argument_list|)
expr_stmt|;
name|ESP_WRITE_REG
argument_list|(
name|sc
argument_list|,
name|ESP_SYNCOFF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ESP_WRITE_REG
argument_list|(
name|sc
argument_list|,
name|ESP_TIMEOUT
argument_list|,
name|sc
operator|->
name|sc_timeout
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"%s: unknown revision code, assuming ESP100\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|)
expr_stmt|;
name|ESP_WRITE_REG
argument_list|(
name|sc
argument_list|,
name|ESP_CFG1
argument_list|,
name|sc
operator|->
name|sc_cfg1
argument_list|)
expr_stmt|;
name|ESP_WRITE_REG
argument_list|(
name|sc
argument_list|,
name|ESP_CCF
argument_list|,
name|sc
operator|->
name|sc_ccf
argument_list|)
expr_stmt|;
name|ESP_WRITE_REG
argument_list|(
name|sc
argument_list|,
name|ESP_SYNCOFF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ESP_WRITE_REG
argument_list|(
name|sc
argument_list|,
name|ESP_TIMEOUT
argument_list|,
name|sc
operator|->
name|sc_timeout
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Reset the SCSI bus, but not the chip  */
end_comment

begin_function
name|void
name|esp_scsi_reset
parameter_list|(
name|sc
parameter_list|)
name|struct
name|esp_softc
modifier|*
name|sc
decl_stmt|;
block|{
comment|/* 	 * XXX STOP DMA FIRST 	 */
name|printf
argument_list|(
literal|"esp: resetting SCSI bus\n"
argument_list|)
expr_stmt|;
name|ESPCMD
argument_list|(
name|sc
argument_list|,
name|ESPCMD_RSTSCSI
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|u_int32_t
name|esp_info
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
comment|/* may be changed later */
block|}
end_function

begin_comment
comment|/*  * Initialize esp state machine  */
end_comment

begin_function
name|void
name|esp_init
parameter_list|(
name|sc
parameter_list|,
name|doreset
parameter_list|)
name|struct
name|esp_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|doreset
decl_stmt|;
block|{
name|struct
name|ecb
modifier|*
name|ecb
decl_stmt|;
name|int
name|r
decl_stmt|;
name|ESP_TRACE
argument_list|(
operator|(
literal|"[ESP_INIT(%d)] "
operator|,
name|doreset
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|==
literal|0
condition|)
block|{
comment|/* First time through */
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|ready_list
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|nexus_list
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|free_list
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_nexus
operator|=
name|NULL
expr_stmt|;
name|ecb
operator|=
name|sc
operator|->
name|sc_ecb
expr_stmt|;
name|bzero
argument_list|(
name|ecb
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_ecb
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_ecb
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|ecb
argument_list|)
condition|;
name|r
operator|++
control|)
block|{
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|free_list
argument_list|,
name|ecb
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|ECB_SETQ
argument_list|(
name|ecb
argument_list|,
name|ECB_QFREE
argument_list|)
expr_stmt|;
name|ecb
operator|++
expr_stmt|;
block|}
name|bzero
argument_list|(
name|sc
operator|->
name|sc_tinfo
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_tinfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|sc_flags
operator||=
name|ESP_ABORTING
expr_stmt|;
name|sc
operator|->
name|sc_state
operator|=
name|ESP_IDLE
expr_stmt|;
name|ecb
operator|=
name|sc
operator|->
name|sc_nexus
expr_stmt|;
if|if
condition|(
name|ecb
operator|!=
name|NULL
condition|)
block|{
name|ecb
operator|->
name|xs
operator|->
name|error
operator|=
name|XS_TIMEOUT
expr_stmt|;
name|esp_done
argument_list|(
name|ecb
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_nexus
operator|=
name|NULL
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|ecb
operator|=
name|sc
operator|->
name|nexus_list
operator|.
name|tqh_first
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ecb
operator|->
name|xs
operator|->
name|error
operator|=
name|XS_TIMEOUT
expr_stmt|;
name|esp_done
argument_list|(
name|ecb
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * reset the chip to a known state 	 */
name|esp_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_phase
operator|=
name|sc
operator|->
name|sc_prevphase
operator|=
name|INVALID_PHASE
expr_stmt|;
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
literal|8
condition|;
name|r
operator|++
control|)
block|{
name|struct
name|esp_tinfo
modifier|*
name|tp
init|=
operator|&
name|sc
operator|->
name|sc_tinfo
index|[
name|r
index|]
decl_stmt|;
comment|/* XXX - config flags per target: low bits: no reselect; high bits: no synch */
comment|/*		int fl = sc->sc_dev.dv_cfdata->cf_flags;*/
name|int
name|fl
init|=
literal|0
decl_stmt|;
name|tp
operator|->
name|flags
operator|=
operator|(
operator|(
name|sc
operator|->
name|sc_minsync
operator|&&
operator|!
operator|(
name|fl
operator|&
operator|(
literal|1
operator|<<
operator|(
name|r
operator|+
literal|8
operator|)
operator|)
operator|)
operator|)
condition|?
name|T_NEGOTIATE
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|fl
operator|&
operator|(
literal|1
operator|<<
name|r
operator|)
operator|)
condition|?
name|T_RSELECTOFF
else|:
literal|0
operator|)
operator||
name|T_NEED_TO_RESET
expr_stmt|;
name|tp
operator|->
name|period
operator|=
name|sc
operator|->
name|sc_minsync
expr_stmt|;
name|tp
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
block|}
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|ESP_ABORTING
expr_stmt|;
if|if
condition|(
name|doreset
condition|)
block|{
name|sc
operator|->
name|sc_state
operator|=
name|ESP_SBR
expr_stmt|;
name|ESPCMD
argument_list|(
name|sc
argument_list|,
name|ESPCMD_RSTSCSI
argument_list|)
expr_stmt|;
return|return;
block|}
name|sc
operator|->
name|sc_state
operator|=
name|ESP_IDLE
expr_stmt|;
name|esp_sched
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Read the ESP registers, and save their contents for later use.  * ESP_STAT, ESP_STEP& ESP_INTR are mostly zeroed out when reading  * ESP_INTR - so make sure it is the last read.  *  * I think that (from reading the docs) most bits in these registers  * only make sense when he DMA CSR has an interrupt showing. Call only  * if an interrupt is pending.  */
end_comment

begin_function
name|void
name|espreadregs
parameter_list|(
name|sc
parameter_list|)
name|struct
name|esp_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|sc
operator|->
name|sc_espstat
operator|=
name|ESP_READ_REG
argument_list|(
name|sc
argument_list|,
name|ESP_STAT
argument_list|)
expr_stmt|;
comment|/* Only the stepo bits are of interest */
name|sc
operator|->
name|sc_espstep
operator|=
name|ESP_READ_REG
argument_list|(
name|sc
argument_list|,
name|ESP_STEP
argument_list|)
operator|&
name|ESPSTEP_MASK
expr_stmt|;
name|sc
operator|->
name|sc_espintr
operator|=
name|ESP_READ_REG
argument_list|(
name|sc
argument_list|,
name|ESP_INTR
argument_list|)
expr_stmt|;
comment|/* Clear the TCDS interrupt bit. */
operator|(
name|void
operator|)
name|tcds_scsi_isintr
argument_list|(
name|sc
operator|->
name|sc_dma
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Determine the SCSI bus phase, return either a real SCSI bus phase 	 * or some pseudo phase we use to detect certain exceptions. 	 */
name|sc
operator|->
name|sc_phase
operator|=
operator|(
name|sc
operator|->
name|sc_espintr
operator|&
name|ESPINTR_DIS
operator|)
condition|?
comment|/* Disconnected */
name|BUSFREE_PHASE
else|:
name|sc
operator|->
name|sc_espstat
operator|&
name|ESPSTAT_PHASE
expr_stmt|;
name|ESP_MISC
argument_list|(
operator|(
literal|"regs[intr=%02x,stat=%02x,step=%02x] "
operator|,
name|sc
operator|->
name|sc_espintr
operator|,
name|sc
operator|->
name|sc_espstat
operator|,
name|sc
operator|->
name|sc_espstep
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Convert Synchronous Transfer Period to chip register Clock Per Byte value.  */
end_comment

begin_function
name|int
name|esp_stp2cpb
parameter_list|(
name|sc
parameter_list|,
name|period
parameter_list|)
name|struct
name|esp_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|period
decl_stmt|;
block|{
name|int
name|v
decl_stmt|;
name|v
operator|=
operator|(
name|sc
operator|->
name|sc_freq
operator|*
name|period
operator|)
operator|/
literal|250
expr_stmt|;
if|if
condition|(
name|esp_cpb2stp
argument_list|(
name|sc
argument_list|,
name|v
argument_list|)
operator|<
name|period
condition|)
comment|/* Correct round-down error */
name|v
operator|++
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_comment
comment|/*  * Convert chip register Clock Per Byte value to Synchronous Transfer Period.  */
end_comment

begin_function
name|int
name|esp_cpb2stp
parameter_list|(
name|sc
parameter_list|,
name|cpb
parameter_list|)
name|struct
name|esp_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|cpb
decl_stmt|;
block|{
return|return
operator|(
operator|(
literal|250
operator|*
name|cpb
operator|)
operator|/
name|sc
operator|->
name|sc_freq
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Send a command to a target, set the driver state to ESP_SELECTING  * and let the caller take care of the rest.  *  * Keeping this as a function allows me to say that this may be done  * by DMA instead of programmed I/O soon.  */
end_comment

begin_function
name|void
name|espselect
parameter_list|(
name|sc
parameter_list|,
name|target
parameter_list|,
name|lun
parameter_list|,
name|cmd
parameter_list|,
name|clen
parameter_list|)
name|struct
name|esp_softc
modifier|*
name|sc
decl_stmt|;
name|u_char
name|target
decl_stmt|,
name|lun
decl_stmt|;
name|u_char
modifier|*
name|cmd
decl_stmt|;
name|u_char
name|clen
decl_stmt|;
block|{
name|struct
name|esp_tinfo
modifier|*
name|ti
init|=
operator|&
name|sc
operator|->
name|sc_tinfo
index|[
name|target
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ESP_TRACE
argument_list|(
operator|(
literal|"[espselect(t%d,l%d,cmd:%x)] "
operator|,
name|target
operator|,
name|lun
operator|,
operator|*
operator|(
name|u_char
operator|*
operator|)
name|cmd
operator|)
argument_list|)
expr_stmt|;
comment|/* new state ESP_SELECTING */
name|sc
operator|->
name|sc_state
operator|=
name|ESP_SELECTING
expr_stmt|;
name|ESPCMD
argument_list|(
name|sc
argument_list|,
name|ESPCMD_FLUSH
argument_list|)
expr_stmt|;
comment|/* 	 * The docs say the target register is never reset, and I 	 * can't think of a better place to set it 	 */
name|ESP_WRITE_REG
argument_list|(
name|sc
argument_list|,
name|ESP_SELID
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|ti
operator|->
name|flags
operator|&
name|T_SYNCMODE
condition|)
block|{
name|ESP_WRITE_REG
argument_list|(
name|sc
argument_list|,
name|ESP_SYNCOFF
argument_list|,
name|ti
operator|->
name|offset
argument_list|)
expr_stmt|;
name|ESP_WRITE_REG
argument_list|(
name|sc
argument_list|,
name|ESP_SYNCTP
argument_list|,
name|esp_stp2cpb
argument_list|(
name|sc
argument_list|,
name|ti
operator|->
name|period
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ESP_WRITE_REG
argument_list|(
name|sc
argument_list|,
name|ESP_SYNCOFF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ESP_WRITE_REG
argument_list|(
name|sc
argument_list|,
name|ESP_SYNCTP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Who am I. This is where we tell the target that we are 	 * happy for it to disconnect etc. 	 */
name|ESP_WRITE_REG
argument_list|(
name|sc
argument_list|,
name|ESP_FIFO
argument_list|,
name|MSG_IDENTIFY
argument_list|(
name|lun
argument_list|,
operator|(
name|ti
operator|->
name|flags
operator|&
name|T_RSELECTOFF
operator|)
condition|?
literal|0
else|:
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ti
operator|->
name|flags
operator|&
name|T_NEGOTIATE
condition|)
block|{
comment|/* Arbitrate, select and stop after IDENTIFY message */
name|ESPCMD
argument_list|(
name|sc
argument_list|,
name|ESPCMD_SELATNS
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Now the command into the FIFO */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|clen
condition|;
name|i
operator|++
control|)
name|ESP_WRITE_REG
argument_list|(
name|sc
argument_list|,
name|ESP_FIFO
argument_list|,
operator|*
name|cmd
operator|++
argument_list|)
expr_stmt|;
comment|/* And get the targets attention */
name|ESPCMD
argument_list|(
name|sc
argument_list|,
name|ESPCMD_SELATN
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * DRIVER FUNCTIONS CALLABLE FROM HIGHER LEVEL DRIVERS  */
end_comment

begin_comment
comment|/*  * Start a SCSI-command  * This function is called by the higher level SCSI-driver to queue/run  * SCSI-commands.  */
end_comment

begin_function
name|int
name|esp_scsi_cmd
parameter_list|(
name|xs
parameter_list|)
name|struct
name|scsi_xfer
modifier|*
name|xs
decl_stmt|;
block|{
name|struct
name|scsi_link
modifier|*
name|sc_link
init|=
name|xs
operator|->
name|sc_link
decl_stmt|;
name|struct
name|esp_softc
modifier|*
name|sc
init|=
name|sc_link
operator|->
name|adapter_softc
decl_stmt|;
name|struct
name|ecb
modifier|*
name|ecb
decl_stmt|;
name|int
name|s
decl_stmt|,
name|flags
decl_stmt|;
name|ESP_TRACE
argument_list|(
operator|(
literal|"[esp_scsi_cmd] "
operator|)
argument_list|)
expr_stmt|;
name|ESP_CMDS
argument_list|(
operator|(
literal|"[0x%x, %d]->%d "
operator|,
operator|(
name|int
operator|)
name|xs
operator|->
name|cmd
operator|->
name|opcode
operator|,
name|xs
operator|->
name|cmdlen
operator|,
name|sc_link
operator|->
name|target
operator|)
argument_list|)
expr_stmt|;
name|flags
operator|=
name|xs
operator|->
name|flags
expr_stmt|;
comment|/* Get a esp command block */
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|ecb
operator|=
name|sc
operator|->
name|free_list
operator|.
name|tqh_first
expr_stmt|;
if|if
condition|(
name|ecb
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|free_list
argument_list|,
name|ecb
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|ECB_SETQ
argument_list|(
name|ecb
argument_list|,
name|ECB_QNONE
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecb
operator|==
name|NULL
condition|)
block|{
name|ESP_MISC
argument_list|(
operator|(
literal|"TRY_AGAIN_LATER"
operator|)
argument_list|)
expr_stmt|;
return|return
name|TRY_AGAIN_LATER
return|;
block|}
comment|/* Initialize ecb */
name|ecb
operator|->
name|xs
operator|=
name|xs
expr_stmt|;
name|bcopy
argument_list|(
name|xs
operator|->
name|cmd
argument_list|,
operator|&
name|ecb
operator|->
name|cmd
argument_list|,
name|xs
operator|->
name|cmdlen
argument_list|)
expr_stmt|;
name|ecb
operator|->
name|clen
operator|=
name|xs
operator|->
name|cmdlen
expr_stmt|;
name|ecb
operator|->
name|daddr
operator|=
name|xs
operator|->
name|data
expr_stmt|;
name|ecb
operator|->
name|dleft
operator|=
name|xs
operator|->
name|datalen
expr_stmt|;
name|ecb
operator|->
name|stat
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|ready_list
argument_list|,
name|ecb
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|ECB_SETQ
argument_list|(
name|ecb
argument_list|,
name|ECB_QREADY
argument_list|)
expr_stmt|;
name|ecb
operator|->
name|timeout_ch
operator|=
name|timeout
argument_list|(
name|esp_timeout
argument_list|,
name|ecb
argument_list|,
operator|(
name|xs
operator|->
name|timeout
operator|*
name|hz
operator|)
operator|/
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|==
name|ESP_IDLE
condition|)
name|esp_sched
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SCSI_NOMASK
condition|)
block|{
comment|/* Not allowed to use interrupts, use polling instead */
return|return
name|esp_poll
argument_list|(
name|sc
argument_list|,
name|ecb
argument_list|)
return|;
block|}
name|ESP_MISC
argument_list|(
operator|(
literal|"SUCCESSFULLY_QUEUED"
operator|)
argument_list|)
expr_stmt|;
return|return
name|SUCCESSFULLY_QUEUED
return|;
block|}
end_function

begin_comment
comment|/*  * Used when interrupt driven I/O isn't allowed, e.g. during boot.  */
end_comment

begin_function
name|int
name|esp_poll
parameter_list|(
name|sc
parameter_list|,
name|ecb
parameter_list|)
name|struct
name|esp_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ecb
modifier|*
name|ecb
decl_stmt|;
block|{
name|struct
name|scsi_xfer
modifier|*
name|xs
init|=
name|ecb
operator|->
name|xs
decl_stmt|;
name|int
name|count
init|=
name|xs
operator|->
name|timeout
operator|*
literal|100
decl_stmt|;
name|ESP_TRACE
argument_list|(
operator|(
literal|"[esp_poll] "
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|count
condition|)
block|{
if|if
condition|(
name|DMA_ISINTR
argument_list|(
name|sc
operator|->
name|sc_dma
argument_list|)
condition|)
block|{
name|espintr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|alternatively
if|if
condition|(
name|ESP_READ_REG
argument_list|(
name|sc
argument_list|,
name|ESP_STAT
argument_list|)
operator|&
name|ESPSTAT_INT
condition|)
name|espintr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|xs
operator|->
name|flags
operator|&
name|ITSDONE
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|==
name|ESP_IDLE
condition|)
block|{
name|ESP_TRACE
argument_list|(
operator|(
literal|"[esp_poll: rescheduling] "
operator|)
argument_list|)
expr_stmt|;
name|esp_sched
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|count
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|ESP_MISC
argument_list|(
operator|(
literal|"esp_poll: timeout"
operator|)
argument_list|)
expr_stmt|;
name|esp_timeout
argument_list|(
operator|(
name|caddr_t
operator|)
name|ecb
argument_list|)
expr_stmt|;
block|}
return|return
name|COMPLETE
return|;
block|}
end_function

begin_comment
comment|/*  * LOW LEVEL SCSI UTILITIES  */
end_comment

begin_comment
comment|/*  * Schedule a scsi operation.  This has now been pulled out of the interrupt  * handler so that we may call it from esp_scsi_cmd and esp_done.  This may  * save us an unecessary interrupt just to get things going.  Should only be  * called when state == ESP_IDLE and at bio pl.  */
end_comment

begin_function
name|void
name|esp_sched
parameter_list|(
name|sc
parameter_list|)
name|struct
name|esp_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|scsi_link
modifier|*
name|sc_link
decl_stmt|;
name|struct
name|ecb
modifier|*
name|ecb
decl_stmt|;
name|int
name|t
decl_stmt|;
name|ESP_TRACE
argument_list|(
operator|(
literal|"[esp_sched] "
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|!=
name|ESP_IDLE
condition|)
name|panic
argument_list|(
literal|"esp_sched: not IDLE (state=%d)"
argument_list|,
name|sc
operator|->
name|sc_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|ESP_ABORTING
condition|)
return|return;
comment|/* 	 * Find first ecb in ready queue that is for a target/lunit 	 * combinations that is not busy. 	 */
for|for
control|(
name|ecb
operator|=
name|sc
operator|->
name|ready_list
operator|.
name|tqh_first
init|;
name|ecb
condition|;
name|ecb
operator|=
name|ecb
operator|->
name|chain
operator|.
name|tqe_next
control|)
block|{
name|sc_link
operator|=
name|ecb
operator|->
name|xs
operator|->
name|sc_link
expr_stmt|;
name|t
operator|=
name|sc_link
operator|->
name|target
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|sc_tinfo
index|[
name|t
index|]
operator|.
name|lubusy
operator|&
operator|(
literal|1
operator|<<
name|sc_link
operator|->
name|lun
operator|)
operator|)
condition|)
block|{
name|struct
name|esp_tinfo
modifier|*
name|ti
init|=
operator|&
name|sc
operator|->
name|sc_tinfo
index|[
name|t
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|ecb
operator|->
name|flags
operator|&
name|ECB_QBITS
operator|)
operator|!=
name|ECB_QREADY
condition|)
name|panic
argument_list|(
literal|"esp: busy entry on ready list"
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|ready_list
argument_list|,
name|ecb
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|ECB_SETQ
argument_list|(
name|ecb
argument_list|,
name|ECB_QNONE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_nexus
operator|=
name|ecb
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_prevphase
operator|=
name|INVALID_PHASE
expr_stmt|;
name|sc
operator|->
name|sc_dp
operator|=
name|ecb
operator|->
name|daddr
expr_stmt|;
name|sc
operator|->
name|sc_dleft
operator|=
name|ecb
operator|->
name|dleft
expr_stmt|;
name|ti
operator|->
name|lubusy
operator||=
operator|(
literal|1
operator|<<
name|sc_link
operator|->
name|lun
operator|)
expr_stmt|;
comment|/*XXX*/
if|if
condition|(
name|sc
operator|->
name|sc_msgpriq
condition|)
block|{
name|printf
argument_list|(
literal|"esp: message queue not empty: %x!\n"
argument_list|,
name|sc
operator|->
name|sc_msgpriq
argument_list|)
expr_stmt|;
block|}
comment|/*XXX*/
name|sc
operator|->
name|sc_msgpriq
operator|=
name|sc
operator|->
name|sc_msgout
operator|=
literal|0
expr_stmt|;
name|espselect
argument_list|(
name|sc
argument_list|,
name|t
argument_list|,
name|sc_link
operator|->
name|lun
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|ecb
operator|->
name|cmd
argument_list|,
name|ecb
operator|->
name|clen
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
name|ESP_MISC
argument_list|(
operator|(
literal|"%d:%d busy\n"
operator|,
name|t
operator|,
name|sc_link
operator|->
name|lun
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * POST PROCESSING OF SCSI_CMD (usually current)  */
end_comment

begin_function
name|void
name|esp_done
parameter_list|(
name|ecb
parameter_list|)
name|struct
name|ecb
modifier|*
name|ecb
decl_stmt|;
block|{
name|struct
name|scsi_xfer
modifier|*
name|xs
init|=
name|ecb
operator|->
name|xs
decl_stmt|;
name|struct
name|scsi_link
modifier|*
name|sc_link
init|=
name|xs
operator|->
name|sc_link
decl_stmt|;
name|struct
name|esp_softc
modifier|*
name|sc
init|=
name|sc_link
operator|->
name|adapter_softc
decl_stmt|;
name|struct
name|esp_tinfo
modifier|*
name|ti
init|=
operator|&
name|sc
operator|->
name|sc_tinfo
index|[
name|sc_link
operator|->
name|target
index|]
decl_stmt|;
name|ESP_TRACE
argument_list|(
operator|(
literal|"[esp_done(error:%x)] "
operator|,
name|xs
operator|->
name|error
operator|)
argument_list|)
expr_stmt|;
name|untimeout
argument_list|(
name|esp_timeout
argument_list|,
name|ecb
argument_list|,
name|ecb
operator|->
name|timeout_ch
argument_list|)
expr_stmt|;
comment|/* 	 * Now, if we've come here with no error code, i.e. we've kept the 	 * initial XS_NOERROR, and the status code signals that we should 	 * check sense, we'll need to set up a request sense cmd block and 	 * push the command back into the ready queue *before* any other 	 * commands for this target/lunit, else we lose the sense info. 	 * We don't support chk sense conditions for the request sense cmd. 	 */
if|if
condition|(
name|xs
operator|->
name|error
operator|==
name|XS_NOERROR
condition|)
block|{
if|if
condition|(
operator|(
name|ecb
operator|->
name|flags
operator|&
name|ECB_ABORTED
operator|)
operator|!=
literal|0
condition|)
block|{
name|xs
operator|->
name|error
operator|=
name|XS_TIMEOUT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ecb
operator|->
name|flags
operator|&
name|ECB_CHKSENSE
operator|)
operator|!=
literal|0
condition|)
block|{
name|xs
operator|->
name|error
operator|=
name|XS_SENSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ecb
operator|->
name|stat
operator|&
name|ST_MASK
operator|)
operator|==
name|SCSI_CHECK
condition|)
block|{
name|struct
name|scsi_sense
modifier|*
name|ss
init|=
operator|(
name|void
operator|*
operator|)
operator|&
name|ecb
operator|->
name|cmd
decl_stmt|;
name|ESP_MISC
argument_list|(
operator|(
literal|"requesting sense "
operator|)
argument_list|)
expr_stmt|;
comment|/* First, save the return values */
name|xs
operator|->
name|resid
operator|=
name|ecb
operator|->
name|dleft
expr_stmt|;
name|xs
operator|->
name|status
operator|=
name|ecb
operator|->
name|stat
expr_stmt|;
comment|/* Next, setup a request sense command block */
name|bzero
argument_list|(
name|ss
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ss
argument_list|)
argument_list|)
expr_stmt|;
name|ss
operator|->
name|op_code
operator|=
name|REQUEST_SENSE
expr_stmt|;
comment|/*ss->byte2 = sc_link->lun<< 5;*/
name|ss
operator|->
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_sense_data
argument_list|)
expr_stmt|;
name|ecb
operator|->
name|clen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|ss
argument_list|)
expr_stmt|;
name|ecb
operator|->
name|daddr
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|xs
operator|->
name|sense
expr_stmt|;
name|ecb
operator|->
name|dleft
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_sense_data
argument_list|)
expr_stmt|;
name|ecb
operator|->
name|flags
operator||=
name|ECB_CHKSENSE
expr_stmt|;
comment|/*XXX - must take off queue here */
if|if
condition|(
name|ecb
operator|!=
name|sc
operator|->
name|sc_nexus
condition|)
block|{
name|panic
argument_list|(
literal|"%s: esp_sched: floating ecb %p"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|ecb
argument_list|)
expr_stmt|;
block|}
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|ready_list
argument_list|,
name|ecb
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|ECB_SETQ
argument_list|(
name|ecb
argument_list|,
name|ECB_QREADY
argument_list|)
expr_stmt|;
name|ti
operator|->
name|lubusy
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|sc_link
operator|->
name|lun
operator|)
expr_stmt|;
name|ti
operator|->
name|senses
operator|++
expr_stmt|;
name|timeout
argument_list|(
name|esp_timeout
argument_list|,
name|ecb
argument_list|,
operator|(
name|xs
operator|->
name|timeout
operator|*
name|hz
operator|)
operator|/
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_nexus
operator|==
name|ecb
condition|)
block|{
name|sc
operator|->
name|sc_nexus
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_state
operator|=
name|ESP_IDLE
expr_stmt|;
name|esp_sched
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
else|else
block|{
name|xs
operator|->
name|resid
operator|=
name|ecb
operator|->
name|dleft
expr_stmt|;
block|}
block|}
name|xs
operator|->
name|flags
operator||=
name|ITSDONE
expr_stmt|;
ifdef|#
directive|ifdef
name|ESP_DEBUG
if|if
condition|(
name|esp_debug
operator|&
name|ESP_SHOWMISC
condition|)
block|{
name|printf
argument_list|(
literal|"err=0x%02x "
argument_list|,
name|xs
operator|->
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|xs
operator|->
name|error
operator|==
name|XS_SENSE
condition|)
block|{
name|printf
argument_list|(
literal|"sense=%2x; "
argument_list|,
name|xs
operator|->
name|sense
operator|.
name|error_code
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|xs
operator|->
name|resid
operator|||
name|xs
operator|->
name|error
operator|>
name|XS_SENSE
operator|)
operator|&&
name|esp_debug
operator|&
name|ESP_SHOWMISC
condition|)
block|{
if|if
condition|(
name|xs
operator|->
name|resid
condition|)
name|printf
argument_list|(
literal|"esp_done: resid=%d\n"
argument_list|,
name|xs
operator|->
name|resid
argument_list|)
expr_stmt|;
if|if
condition|(
name|xs
operator|->
name|error
condition|)
name|printf
argument_list|(
literal|"esp_done: error=%d\n"
argument_list|,
name|xs
operator|->
name|error
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * Remove the ECB from whatever queue it's on. 	 */
switch|switch
condition|(
name|ecb
operator|->
name|flags
operator|&
name|ECB_QBITS
condition|)
block|{
case|case
name|ECB_QNONE
case|:
if|if
condition|(
name|ecb
operator|!=
name|sc
operator|->
name|sc_nexus
condition|)
block|{
name|panic
argument_list|(
literal|"%s: floating ecb"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_nexus
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_state
operator|=
name|ESP_IDLE
expr_stmt|;
name|ti
operator|->
name|lubusy
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|sc_link
operator|->
name|lun
operator|)
expr_stmt|;
name|esp_sched
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|ECB_QREADY
case|:
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|ready_list
argument_list|,
name|ecb
argument_list|,
name|chain
argument_list|)
expr_stmt|;
break|break;
case|case
name|ECB_QNEXUS
case|:
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|nexus_list
argument_list|,
name|ecb
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|ti
operator|->
name|lubusy
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|sc_link
operator|->
name|lun
operator|)
expr_stmt|;
break|break;
case|case
name|ECB_QFREE
case|:
name|panic
argument_list|(
literal|"%s: dequeue: busy ecb on free list"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"%s: dequeue: unknown queue %d"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|ecb
operator|->
name|flags
operator|&
name|ECB_QBITS
argument_list|)
expr_stmt|;
block|}
comment|/* Put it on the free list, and clear flags. */
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|free_list
argument_list|,
name|ecb
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|ecb
operator|->
name|flags
operator|=
name|ECB_QFREE
expr_stmt|;
name|ti
operator|->
name|cmds
operator|++
expr_stmt|;
name|scsi_done
argument_list|(
name|xs
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * INTERRUPT/PROTOCOL ENGINE  */
end_comment

begin_comment
comment|/*  * Schedule an outgoing message by prioritizing it, and asserting  * attention on the bus. We can only do this when we are the initiator  * else there will be an illegal command interrupt.  */
end_comment

begin_define
define|#
directive|define
name|esp_sched_msgout
parameter_list|(
name|m
parameter_list|)
define|\
value|do {				\ 		ESP_MISC(("esp_sched_msgout %d ", m)); \ 		ESPCMD(sc, ESPCMD_SETATN);	\ 		sc->sc_msgpriq |= (m);	\ 	} while (0)
end_define

begin_define
define|#
directive|define
name|IS1BYTEMSG
parameter_list|(
name|m
parameter_list|)
value|(((m) != 1&& (m)< 0x20) || (m)& 0x80)
end_define

begin_define
define|#
directive|define
name|IS2BYTEMSG
parameter_list|(
name|m
parameter_list|)
value|(((m)& 0xf0) == 0x20)
end_define

begin_define
define|#
directive|define
name|ISEXTMSG
parameter_list|(
name|m
parameter_list|)
value|((m) == 1)
end_define

begin_comment
comment|/*  * Get an incoming message as initiator.  *  * The SCSI bus must already be in MESSAGE_IN_PHASE and there is a  * byte in the FIFO  */
end_comment

begin_function
name|void
name|esp_msgin
parameter_list|(
name|sc
parameter_list|)
specifier|register
name|struct
name|esp_softc
modifier|*
name|sc
decl_stmt|;
block|{
specifier|register
name|int
name|v
decl_stmt|;
name|ESP_TRACE
argument_list|(
operator|(
literal|"[esp_msgin(curmsglen:%d)] "
operator|,
name|sc
operator|->
name|sc_imlen
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ESP_READ_REG
argument_list|(
name|sc
argument_list|,
name|ESP_FFLAG
argument_list|)
operator|&
name|ESPFIFO_FF
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: msgin: no msg byte available\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Prepare for a new message.  A message should (according 	 * to the SCSI standard) be transmitted in one single 	 * MESSAGE_IN_PHASE. If we have been in some other phase, 	 * then this is a new message. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_prevphase
operator|!=
name|MESSAGE_IN_PHASE
condition|)
block|{
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|ESP_DROP_MSGI
expr_stmt|;
name|sc
operator|->
name|sc_imlen
operator|=
literal|0
expr_stmt|;
block|}
name|v
operator|=
name|ESP_READ_REG
argument_list|(
name|sc
argument_list|,
name|ESP_FIFO
argument_list|)
expr_stmt|;
name|ESP_MISC
argument_list|(
operator|(
literal|"<msgbyte:0x%02x>"
operator|,
name|v
operator|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (sc->sc_state == ESP_RESELECTED&& sc->sc_imlen == 0) {
comment|/* 		 * Which target is reselecting us? (The ID bit really) 		 */
block|sc->sc_selid = v; 		sc->sc_selid&= ~(1<<sc->sc_id); 		ESP_MISC(("selid=0x%2x ", sc->sc_selid)); 		return; 	}
endif|#
directive|endif
name|sc
operator|->
name|sc_imess
index|[
name|sc
operator|->
name|sc_imlen
index|]
operator|=
name|v
expr_stmt|;
comment|/* 	 * If we're going to reject the message, don't bother storing 	 * the incoming bytes.  But still, we need to ACK them. 	 */
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|ESP_DROP_MSGI
operator|)
condition|)
block|{
name|ESPCMD
argument_list|(
name|sc
argument_list|,
name|ESPCMD_SETATN
argument_list|)
expr_stmt|;
name|ESPCMD
argument_list|(
name|sc
argument_list|,
name|ESPCMD_MSGOK
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"<dropping msg byte %x>"
argument_list|,
name|sc
operator|->
name|sc_imess
index|[
name|sc
operator|->
name|sc_imlen
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_imlen
operator|>=
name|ESP_MAX_MSG_LEN
condition|)
block|{
name|esp_sched_msgout
argument_list|(
name|SEND_REJECT
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|ESP_DROP_MSGI
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|sc_imlen
operator|++
expr_stmt|;
comment|/* 		 * This testing is suboptimal, but most 		 * messages will be of the one byte variety, so 		 * it should not effect performance 		 * significantly. 		 */
if|if
condition|(
name|sc
operator|->
name|sc_imlen
operator|==
literal|1
operator|&&
name|IS1BYTEMSG
argument_list|(
name|sc
operator|->
name|sc_imess
index|[
literal|0
index|]
argument_list|)
condition|)
goto|goto
name|gotit
goto|;
if|if
condition|(
name|sc
operator|->
name|sc_imlen
operator|==
literal|2
operator|&&
name|IS2BYTEMSG
argument_list|(
name|sc
operator|->
name|sc_imess
index|[
literal|0
index|]
argument_list|)
condition|)
goto|goto
name|gotit
goto|;
if|if
condition|(
name|sc
operator|->
name|sc_imlen
operator|>=
literal|3
operator|&&
name|ISEXTMSG
argument_list|(
name|sc
operator|->
name|sc_imess
index|[
literal|0
index|]
argument_list|)
operator|&&
name|sc
operator|->
name|sc_imlen
operator|==
name|sc
operator|->
name|sc_imess
index|[
literal|1
index|]
operator|+
literal|2
condition|)
goto|goto
name|gotit
goto|;
block|}
comment|/* Ack what we have so far */
name|ESPCMD
argument_list|(
name|sc
argument_list|,
name|ESPCMD_MSGOK
argument_list|)
expr_stmt|;
return|return;
name|gotit
label|:
name|ESP_MSGS
argument_list|(
operator|(
literal|"gotmsg(%x)"
operator|,
name|sc
operator|->
name|sc_imess
index|[
literal|0
index|]
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Now we should have a complete message (1 byte, 2 byte 	 * and moderately long extended messages).  We only handle 	 * extended messages which total length is shorter than 	 * ESP_MAX_MSG_LEN.  Longer messages will be amputated. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|==
name|ESP_HASNEXUS
condition|)
block|{
name|struct
name|ecb
modifier|*
name|ecb
init|=
name|sc
operator|->
name|sc_nexus
decl_stmt|;
name|struct
name|esp_tinfo
modifier|*
name|ti
init|=
operator|&
name|sc
operator|->
name|sc_tinfo
index|[
name|ecb
operator|->
name|xs
operator|->
name|sc_link
operator|->
name|target
index|]
decl_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|sc_imess
index|[
literal|0
index|]
condition|)
block|{
case|case
name|MSG_CMDCOMPLETE
case|:
name|ESP_MSGS
argument_list|(
operator|(
literal|"cmdcomplete "
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dleft
operator|<
literal|0
condition|)
block|{
name|struct
name|scsi_link
modifier|*
name|sc_link
init|=
name|ecb
operator|->
name|xs
operator|->
name|sc_link
decl_stmt|;
name|printf
argument_list|(
literal|"esp: %d extra bytes from %d:%d\n"
argument_list|,
operator|-
name|sc
operator|->
name|sc_dleft
argument_list|,
name|sc_link
operator|->
name|target
argument_list|,
name|sc_link
operator|->
name|lun
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_dleft
operator|=
literal|0
expr_stmt|;
block|}
name|ecb
operator|->
name|xs
operator|->
name|resid
operator|=
name|ecb
operator|->
name|dleft
operator|=
name|sc
operator|->
name|sc_dleft
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|ESP_BUSFREE_OK
expr_stmt|;
break|break;
case|case
name|MSG_MESSAGE_REJECT
case|:
if|if
condition|(
name|esp_debug
operator|&
name|ESP_SHOWMSGS
condition|)
name|printf
argument_list|(
literal|"%s: our msg rejected by target\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
comment|/* XXX - must remember last message */
name|sc_print_addr
argument_list|(
name|ecb
operator|->
name|xs
operator|->
name|sc_link
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"MSG_MESSAGE_REJECT>>"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|ESP_SYNCHNEGO
condition|)
block|{
name|ti
operator|->
name|period
operator|=
name|ti
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|ESP_SYNCHNEGO
expr_stmt|;
name|ti
operator|->
name|flags
operator|&=
operator|~
name|T_NEGOTIATE
expr_stmt|;
block|}
comment|/* Not all targets understand INITIATOR_DETECTED_ERR */
if|if
condition|(
name|sc
operator|->
name|sc_msgout
operator|==
name|SEND_INIT_DET_ERR
condition|)
name|esp_sched_msgout
argument_list|(
name|SEND_ABORT
argument_list|)
expr_stmt|;
break|break;
case|case
name|MSG_NOOP
case|:
name|ESP_MSGS
argument_list|(
operator|(
literal|"noop "
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|MSG_DISCONNECT
case|:
name|ESP_MSGS
argument_list|(
operator|(
literal|"disconnect "
operator|)
argument_list|)
expr_stmt|;
name|ti
operator|->
name|dconns
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|ESP_DISCON
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|ESP_BUSFREE_OK
expr_stmt|;
define|#
directive|define
name|SDEV_AUTOSAVE
value|(0x01)
if|if
condition|(
operator|(
name|ecb
operator|->
name|xs
operator|->
name|sc_link
operator|->
name|quirks
operator|&
name|SDEV_AUTOSAVE
operator|)
operator|==
literal|0
condition|)
break|break;
comment|/*FALLTHROUGH*/
case|case
name|MSG_SAVEDATAPOINTER
case|:
name|ESP_MSGS
argument_list|(
operator|(
literal|"save datapointer "
operator|)
argument_list|)
expr_stmt|;
name|ecb
operator|->
name|dleft
operator|=
name|sc
operator|->
name|sc_dleft
expr_stmt|;
name|ecb
operator|->
name|daddr
operator|=
name|sc
operator|->
name|sc_dp
expr_stmt|;
break|break;
case|case
name|MSG_RESTOREPOINTERS
case|:
name|ESP_MSGS
argument_list|(
operator|(
literal|"restore datapointer "
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ecb
condition|)
block|{
name|esp_sched_msgout
argument_list|(
name|SEND_ABORT
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: no DATAPOINTERs to restore\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|)
expr_stmt|;
break|break;
block|}
name|sc
operator|->
name|sc_dp
operator|=
name|ecb
operator|->
name|daddr
expr_stmt|;
name|sc
operator|->
name|sc_dleft
operator|=
name|ecb
operator|->
name|dleft
expr_stmt|;
break|break;
case|case
name|MSG_PARITY_ERROR
case|:
name|printf
argument_list|(
literal|"%s:target%d: MSG_PARITY_ERROR\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|ecb
operator|->
name|xs
operator|->
name|sc_link
operator|->
name|target
argument_list|)
expr_stmt|;
break|break;
case|case
name|MSG_EXTENDED
case|:
name|ESP_MSGS
argument_list|(
operator|(
literal|"extended(%x) "
operator|,
name|sc
operator|->
name|sc_imess
index|[
literal|2
index|]
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|sc_imess
index|[
literal|2
index|]
condition|)
block|{
case|case
name|MSG_EXT_SDTR
case|:
name|ESP_MSGS
argument_list|(
operator|(
literal|"SDTR period %d, offset %d "
operator|,
name|sc
operator|->
name|sc_imess
index|[
literal|3
index|]
operator|,
name|sc
operator|->
name|sc_imess
index|[
literal|4
index|]
operator|)
argument_list|)
expr_stmt|;
name|ti
operator|->
name|period
operator|=
name|sc
operator|->
name|sc_imess
index|[
literal|3
index|]
expr_stmt|;
name|ti
operator|->
name|offset
operator|=
name|sc
operator|->
name|sc_imess
index|[
literal|4
index|]
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_minsync
operator|==
literal|0
condition|)
block|{
comment|/* We won't do synch */
name|ti
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|esp_sched_msgout
argument_list|(
name|SEND_SDTR
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ti
operator|->
name|offset
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s:%d: async\n"
argument_list|,
literal|"esp"
argument_list|,
name|ecb
operator|->
name|xs
operator|->
name|sc_link
operator|->
name|target
argument_list|)
expr_stmt|;
name|ti
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|ESP_SYNCHNEGO
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ti
operator|->
name|period
operator|>
literal|124
condition|)
block|{
name|printf
argument_list|(
literal|"%s:%d: async\n"
argument_list|,
literal|"esp"
argument_list|,
name|ecb
operator|->
name|xs
operator|->
name|sc_link
operator|->
name|target
argument_list|)
expr_stmt|;
name|ti
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|esp_sched_msgout
argument_list|(
name|SEND_SDTR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|r
init|=
literal|250
operator|/
name|ti
operator|->
name|period
decl_stmt|;
name|int
name|s
init|=
operator|(
literal|100
operator|*
literal|250
operator|)
operator|/
name|ti
operator|->
name|period
operator|-
literal|100
operator|*
name|r
decl_stmt|;
name|int
name|p
decl_stmt|;
name|p
operator|=
name|esp_stp2cpb
argument_list|(
name|sc
argument_list|,
name|ti
operator|->
name|period
argument_list|)
expr_stmt|;
name|ti
operator|->
name|period
operator|=
name|esp_cpb2stp
argument_list|(
name|sc
argument_list|,
name|p
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ESP_DEBUG
name|sc_print_addr
argument_list|(
name|ecb
operator|->
name|xs
operator|->
name|sc_link
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|ESP_SYNCHNEGO
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Target initiated negotiation */
if|if
condition|(
name|ti
operator|->
name|flags
operator|&
name|T_SYNCMODE
condition|)
block|{
name|ti
operator|->
name|flags
operator|&=
operator|~
name|T_SYNCMODE
expr_stmt|;
ifdef|#
directive|ifdef
name|ESP_DEBUG
name|printf
argument_list|(
literal|"renegotiated "
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|ESP_WRITE_REG
argument_list|(
name|sc
argument_list|,
name|ESP_SYNCOFF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ESP_WRITE_REG
argument_list|(
name|sc
argument_list|,
name|ESP_SYNCTP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Clamp to our maxima */
if|if
condition|(
name|ti
operator|->
name|period
operator|<
name|sc
operator|->
name|sc_minsync
condition|)
name|ti
operator|->
name|period
operator|=
name|sc
operator|->
name|sc_minsync
expr_stmt|;
if|if
condition|(
name|ti
operator|->
name|offset
operator|>
literal|15
condition|)
name|ti
operator|->
name|offset
operator|=
literal|15
expr_stmt|;
name|esp_sched_msgout
argument_list|(
name|SEND_SDTR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* we are sync */
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|ESP_SYNCHNEGO
expr_stmt|;
name|ESP_WRITE_REG
argument_list|(
name|sc
argument_list|,
name|ESP_SYNCOFF
argument_list|,
name|ti
operator|->
name|offset
argument_list|)
expr_stmt|;
name|ESP_WRITE_REG
argument_list|(
name|sc
argument_list|,
name|ESP_SYNCTP
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|ti
operator|->
name|flags
operator||=
name|T_SYNCMODE
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ESP_DEBUG
name|printf
argument_list|(
literal|"max sync rate %d.%02dMb/s\n"
argument_list|,
name|r
argument_list|,
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|ti
operator|->
name|flags
operator|&=
operator|~
name|T_NEGOTIATE
expr_stmt|;
break|break;
default|default:
comment|/* Extended messages we don't handle */
name|ESPCMD
argument_list|(
name|sc
argument_list|,
name|ESPCMD_SETATN
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|ESP_MSGS
argument_list|(
operator|(
literal|"ident "
operator|)
argument_list|)
expr_stmt|;
comment|/* thanks for that ident... */
if|if
condition|(
operator|!
name|MSG_ISIDENTIFY
argument_list|(
name|sc
operator|->
name|sc_imess
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|ESP_MISC
argument_list|(
operator|(
literal|"unknown "
operator|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: unimplemented message: %d\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|sc
operator|->
name|sc_imess
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ESPCMD
argument_list|(
name|sc
argument_list|,
name|ESPCMD_SETATN
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|==
name|ESP_RESELECTED
condition|)
block|{
name|struct
name|scsi_link
modifier|*
name|sc_link
init|=
name|NULL
decl_stmt|;
name|struct
name|ecb
modifier|*
name|ecb
decl_stmt|;
name|struct
name|esp_tinfo
modifier|*
name|ti
decl_stmt|;
name|u_char
name|lunit
decl_stmt|;
if|if
condition|(
name|MSG_ISIDENTIFY
argument_list|(
name|sc
operator|->
name|sc_imess
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
comment|/* Identify? */
name|ESP_MISC
argument_list|(
operator|(
literal|"searching "
operator|)
argument_list|)
expr_stmt|;
comment|/* 			 * Search wait queue for disconnected cmd 			 * The list should be short, so I haven't bothered with 			 * any more sophisticated structures than a simple 			 * singly linked list. 			 */
name|lunit
operator|=
name|sc
operator|->
name|sc_imess
index|[
literal|0
index|]
operator|&
literal|0x07
expr_stmt|;
for|for
control|(
name|ecb
operator|=
name|sc
operator|->
name|nexus_list
operator|.
name|tqh_first
init|;
name|ecb
condition|;
name|ecb
operator|=
name|ecb
operator|->
name|chain
operator|.
name|tqe_next
control|)
block|{
name|sc_link
operator|=
name|ecb
operator|->
name|xs
operator|->
name|sc_link
expr_stmt|;
if|if
condition|(
name|sc_link
operator|->
name|lun
operator|==
name|lunit
operator|&&
name|sc
operator|->
name|sc_selid
operator|==
operator|(
literal|1
operator|<<
name|sc_link
operator|->
name|target
operator|)
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|nexus_list
argument_list|,
name|ecb
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|ECB_SETQ
argument_list|(
name|ecb
argument_list|,
name|ECB_QNONE
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|ecb
condition|)
block|{
comment|/* Invalid reselection! */
name|esp_sched_msgout
argument_list|(
name|SEND_ABORT
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"esp: invalid reselect (idbit=0x%2x)\n"
argument_list|,
name|sc
operator|->
name|sc_selid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Reestablish nexus */
comment|/* 				 * Setup driver data structures and 				 * do an implicit RESTORE POINTERS 				 */
name|ti
operator|=
operator|&
name|sc
operator|->
name|sc_tinfo
index|[
name|sc_link
operator|->
name|target
index|]
expr_stmt|;
name|sc
operator|->
name|sc_nexus
operator|=
name|ecb
expr_stmt|;
name|sc
operator|->
name|sc_dp
operator|=
name|ecb
operator|->
name|daddr
expr_stmt|;
name|sc
operator|->
name|sc_dleft
operator|=
name|ecb
operator|->
name|dleft
expr_stmt|;
name|sc
operator|->
name|sc_tinfo
index|[
name|sc_link
operator|->
name|target
index|]
operator|.
name|lubusy
operator||=
operator|(
literal|1
operator|<<
name|sc_link
operator|->
name|lun
operator|)
expr_stmt|;
if|if
condition|(
name|ti
operator|->
name|flags
operator|&
name|T_SYNCMODE
condition|)
block|{
name|ESP_WRITE_REG
argument_list|(
name|sc
argument_list|,
name|ESP_SYNCOFF
argument_list|,
name|ti
operator|->
name|offset
argument_list|)
expr_stmt|;
name|ESP_WRITE_REG
argument_list|(
name|sc
argument_list|,
name|ESP_SYNCTP
argument_list|,
name|esp_stp2cpb
argument_list|(
name|sc
argument_list|,
name|ti
operator|->
name|period
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ESP_WRITE_REG
argument_list|(
name|sc
argument_list|,
name|ESP_SYNCOFF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ESP_WRITE_REG
argument_list|(
name|sc
argument_list|,
name|ESP_SYNCTP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|ESP_MISC
argument_list|(
operator|(
literal|"... found ecb"
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_state
operator|=
name|ESP_HASNEXUS
expr_stmt|;
block|}
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%s: bogus reselect (no IDENTIFY) %0x2x\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|sc
operator|->
name|sc_selid
argument_list|)
expr_stmt|;
name|esp_sched_msgout
argument_list|(
name|SEND_DEV_RESET
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Neither ESP_HASNEXUS nor ESP_RESELECTED! */
name|printf
argument_list|(
literal|"%s: unexpected message in; will send DEV_RESET\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|)
expr_stmt|;
name|esp_sched_msgout
argument_list|(
name|SEND_DEV_RESET
argument_list|)
expr_stmt|;
block|}
comment|/* Ack last message byte */
name|ESPCMD
argument_list|(
name|sc
argument_list|,
name|ESPCMD_MSGOK
argument_list|)
expr_stmt|;
comment|/* Done, reset message pointer. */
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|ESP_DROP_MSGI
expr_stmt|;
name|sc
operator|->
name|sc_imlen
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Send the highest priority, scheduled message  */
end_comment

begin_function
name|void
name|esp_msgout
parameter_list|(
name|sc
parameter_list|)
specifier|register
name|struct
name|esp_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|esp_tinfo
modifier|*
name|ti
decl_stmt|;
name|struct
name|ecb
modifier|*
name|ecb
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|ESP_TRACE
argument_list|(
operator|(
literal|"[esp_msgout(priq:%x, prevphase:%x)]"
operator|,
name|sc
operator|->
name|sc_msgpriq
operator|,
name|sc
operator|->
name|sc_prevphase
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_prevphase
operator|!=
name|MESSAGE_OUT_PHASE
condition|)
block|{
comment|/* Pick up highest priority message */
name|sc
operator|->
name|sc_msgout
operator|=
name|sc
operator|->
name|sc_msgpriq
operator|&
operator|-
name|sc
operator|->
name|sc_msgpriq
expr_stmt|;
name|sc
operator|->
name|sc_omlen
operator|=
literal|1
expr_stmt|;
comment|/* "Default" message len */
switch|switch
condition|(
name|sc
operator|->
name|sc_msgout
condition|)
block|{
case|case
name|SEND_SDTR
case|:
name|ecb
operator|=
name|sc
operator|->
name|sc_nexus
expr_stmt|;
name|ti
operator|=
operator|&
name|sc
operator|->
name|sc_tinfo
index|[
name|ecb
operator|->
name|xs
operator|->
name|sc_link
operator|->
name|target
index|]
expr_stmt|;
name|sc
operator|->
name|sc_omess
index|[
literal|0
index|]
operator|=
name|MSG_EXTENDED
expr_stmt|;
name|sc
operator|->
name|sc_omess
index|[
literal|1
index|]
operator|=
literal|3
expr_stmt|;
name|sc
operator|->
name|sc_omess
index|[
literal|2
index|]
operator|=
name|MSG_EXT_SDTR
expr_stmt|;
name|sc
operator|->
name|sc_omess
index|[
literal|3
index|]
operator|=
name|ti
operator|->
name|period
expr_stmt|;
name|sc
operator|->
name|sc_omess
index|[
literal|4
index|]
operator|=
name|ti
operator|->
name|offset
expr_stmt|;
name|sc
operator|->
name|sc_omlen
operator|=
literal|5
expr_stmt|;
break|break;
case|case
name|SEND_IDENTIFY
case|:
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|!=
name|ESP_HASNEXUS
condition|)
block|{
name|printf
argument_list|(
literal|"esp at line %d: no nexus"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
name|ecb
operator|=
name|sc
operator|->
name|sc_nexus
expr_stmt|;
name|sc
operator|->
name|sc_omess
index|[
literal|0
index|]
operator|=
name|MSG_IDENTIFY
argument_list|(
name|ecb
operator|->
name|xs
operator|->
name|sc_link
operator|->
name|lun
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|SEND_DEV_RESET
case|:
name|sc
operator|->
name|sc_omess
index|[
literal|0
index|]
operator|=
name|MSG_BUS_DEV_RESET
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|ESP_BUSFREE_OK
expr_stmt|;
name|ecb
operator|=
name|sc
operator|->
name|sc_nexus
expr_stmt|;
name|ti
operator|=
operator|&
name|sc
operator|->
name|sc_tinfo
index|[
name|ecb
operator|->
name|xs
operator|->
name|sc_link
operator|->
name|target
index|]
expr_stmt|;
name|ti
operator|->
name|flags
operator|&=
operator|~
name|T_SYNCMODE
expr_stmt|;
name|ti
operator|->
name|flags
operator||=
name|T_NEGOTIATE
expr_stmt|;
break|break;
case|case
name|SEND_PARITY_ERROR
case|:
name|sc
operator|->
name|sc_omess
index|[
literal|0
index|]
operator|=
name|MSG_PARITY_ERROR
expr_stmt|;
break|break;
case|case
name|SEND_ABORT
case|:
name|sc
operator|->
name|sc_omess
index|[
literal|0
index|]
operator|=
name|MSG_ABORT
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|ESP_BUSFREE_OK
expr_stmt|;
break|break;
case|case
name|SEND_INIT_DET_ERR
case|:
name|sc
operator|->
name|sc_omess
index|[
literal|0
index|]
operator|=
name|MSG_INITIATOR_DET_ERR
expr_stmt|;
break|break;
case|case
name|SEND_REJECT
case|:
name|sc
operator|->
name|sc_omess
index|[
literal|0
index|]
operator|=
name|MSG_MESSAGE_REJECT
expr_stmt|;
break|break;
default|default:
name|sc
operator|->
name|sc_omess
index|[
literal|0
index|]
operator|=
name|MSG_NOOP
expr_stmt|;
break|break;
block|}
name|sc
operator|->
name|sc_omp
operator|=
name|sc
operator|->
name|sc_omess
expr_stmt|;
block|}
if|#
directive|if
literal|1
comment|/* (re)send the message */
name|size
operator|=
name|min
argument_list|(
name|sc
operator|->
name|sc_omlen
argument_list|,
name|sc
operator|->
name|sc_maxxfer
argument_list|)
expr_stmt|;
name|DMA_SETUP
argument_list|(
name|sc
operator|->
name|sc_dma
argument_list|,
operator|&
name|sc
operator|->
name|sc_omp
argument_list|,
operator|&
name|sc
operator|->
name|sc_omlen
argument_list|,
literal|0
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
comment|/* Program the SCSI counter */
name|ESP_WRITE_REG
argument_list|(
name|sc
argument_list|,
name|ESP_TCL
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|ESP_WRITE_REG
argument_list|(
name|sc
argument_list|,
name|ESP_TCM
argument_list|,
name|size
operator|>>
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_cfg2
operator|&
name|ESPCFG2_FE
condition|)
block|{
name|ESP_WRITE_REG
argument_list|(
name|sc
argument_list|,
name|ESP_TCH
argument_list|,
name|size
operator|>>
literal|16
argument_list|)
expr_stmt|;
block|}
comment|/* load the count in */
name|ESPCMD
argument_list|(
name|sc
argument_list|,
name|ESPCMD_NOP
operator||
name|ESPCMD_DMA
argument_list|)
expr_stmt|;
name|ESPCMD
argument_list|(
name|sc
argument_list|,
operator|(
name|size
operator|==
literal|0
condition|?
name|ESPCMD_TRPAD
else|:
name|ESPCMD_TRANS
operator|)
operator||
name|ESPCMD_DMA
argument_list|)
expr_stmt|;
name|DMA_GO
argument_list|(
name|sc
operator|->
name|sc_dma
argument_list|)
expr_stmt|;
else|#
directive|else
block|{
name|int
name|i
decl_stmt|;
name|ESPCMD
argument_list|(
name|sc
argument_list|,
name|ESPCMD_FLUSH
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|sc_omlen
condition|;
name|i
operator|++
control|)
name|ESP_WRITE_REG
argument_list|(
name|sc
argument_list|,
name|FIFO
argument_list|,
name|sc
operator|->
name|sc_omess
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ESPCMD
argument_list|(
name|sc
argument_list|,
name|ESPCMD_TRANS
argument_list|)
expr_stmt|;
if|#
directive|if
name|test_stuck_on_msgout
name|printf
argument_list|(
literal|"<<XXXmsgoutdoneXXX>>"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * This is the most critical part of the driver, and has to know  * how to deal with *all* error conditions and phases from the SCSI  * bus. If there are no errors and the DMA was active, then call the  * DMA pseudo-interrupt handler. If this returns 1, then that was it  * and we can return from here without further processing.  *  * Most of this needs verifying.  */
end_comment

begin_function
name|int
name|espintr
parameter_list|(
name|sc
parameter_list|)
specifier|register
name|struct
name|esp_softc
modifier|*
name|sc
decl_stmt|;
block|{
specifier|register
name|struct
name|ecb
modifier|*
name|ecb
decl_stmt|;
specifier|register
name|struct
name|scsi_link
modifier|*
name|sc_link
decl_stmt|;
name|struct
name|esp_tinfo
modifier|*
name|ti
decl_stmt|;
name|int
name|loop
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|ESP_TRACE
argument_list|(
operator|(
literal|"[espintr]"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * I have made some (maybe seriously flawed) assumptions here, 	 * but basic testing (uncomment the printf() below), show that 	 * certainly something happens when this loop is here. 	 * 	 * The idea is that many of the SCSI operations take very little 	 * time, and going away and getting interrupted is too high an 	 * overhead to pay. For example, selecting, sending a message 	 * and command and then doing some work can be done in one "pass". 	 * 	 * The DELAY is not variable because I do not understand that the 	 * DELAY loop should be fixed-time regardless of CPU speed, but 	 * I am *assuming* that the faster SCSI processors get things done 	 * quicker (sending a command byte etc), and so there is no 	 * need to be too slow. 	 * 	 * This is a heuristic. It is 2 when at 20Mhz, 2 at 25Mhz and 1 	 * at 40Mhz. This needs testing. 	 */
for|for
control|(
name|loop
operator|=
literal|0
init|;
literal|1
condition|;
name|loop
operator|++
operator|,
name|DELAY
argument_list|(
literal|50
operator|/
name|sc
operator|->
name|sc_freq
argument_list|)
control|)
block|{
comment|/* a feeling of deja-vu */
if|if
condition|(
operator|!
name|DMA_ISINTR
argument_list|(
name|sc
operator|->
name|sc_dma
argument_list|)
condition|)
return|return
operator|(
name|loop
operator|!=
literal|0
operator|)
return|;
if|#
directive|if
literal|0
block|if (loop) 			printf("*");
endif|#
directive|endif
comment|/* and what do the registers say... */
name|espreadregs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_intrcnt
operator|.
name|ev_count
operator|++
expr_stmt|;
comment|/* 		 * At the moment, only a SCSI Bus Reset or Illegal 		 * Command are classed as errors. A disconnect is a 		 * valid condition, and we let the code check is the 		 * "ESP_BUSFREE_OK" flag was set before declaring it 		 * and error. 		 * 		 * Also, the status register tells us about "Gross 		 * Errors" and "Parity errors". Only the Gross Error 		 * is really bad, and the parity errors are dealt 		 * with later 		 * 		 * TODO 		 *	If there are too many parity error, go to slow 		 *	cable mode ? 		 */
comment|/* SCSI Reset */
if|if
condition|(
name|sc
operator|->
name|sc_espintr
operator|&
name|ESPINTR_SBR
condition|)
block|{
if|if
condition|(
name|ESP_READ_REG
argument_list|(
name|sc
argument_list|,
name|ESP_FFLAG
argument_list|)
operator|&
name|ESPFIFO_FF
condition|)
block|{
name|ESPCMD
argument_list|(
name|sc
argument_list|,
name|ESPCMD_FLUSH
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|!=
name|ESP_SBR
condition|)
block|{
name|printf
argument_list|(
literal|"%s: SCSI bus reset\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|)
expr_stmt|;
name|esp_init
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Restart everything */
return|return
literal|1
return|;
block|}
if|#
directive|if
literal|0
comment|/*XXX*/
block|printf("<expected bus reset: " 				"[intr %x, stat %x, step %d]>\n", 				sc->sc_espintr, sc->sc_espstat, 				sc->sc_espstep);
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|sc_nexus
condition|)
name|panic
argument_list|(
literal|"%s: nexus in reset state"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_state
operator|=
name|ESP_IDLE
expr_stmt|;
name|esp_sched
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|ecb
operator|=
name|sc
operator|->
name|sc_nexus
expr_stmt|;
define|#
directive|define
name|ESPINTR_ERR
value|(ESPINTR_SBR|ESPINTR_ILL)
if|if
condition|(
name|sc
operator|->
name|sc_espintr
operator|&
name|ESPINTR_ERR
operator|||
name|sc
operator|->
name|sc_espstat
operator|&
name|ESPSTAT_GE
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_espstat
operator|&
name|ESPSTAT_GE
condition|)
block|{
comment|/* no target ? */
if|if
condition|(
name|ESP_READ_REG
argument_list|(
name|sc
argument_list|,
name|ESP_FFLAG
argument_list|)
operator|&
name|ESPFIFO_FF
condition|)
block|{
name|ESPCMD
argument_list|(
name|sc
argument_list|,
name|ESPCMD_FLUSH
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|==
name|ESP_HASNEXUS
operator|||
name|sc
operator|->
name|sc_state
operator|==
name|ESP_SELECTING
condition|)
block|{
name|ecb
operator|->
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
name|esp_done
argument_list|(
name|ecb
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_espintr
operator|&
name|ESPINTR_ILL
condition|)
block|{
comment|/* illegal command, out of sync ? */
name|printf
argument_list|(
literal|"%s: illegal command: 0x%x (state %d, phase %x, prevphase %x)\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|sc
operator|->
name|sc_lastcmd
argument_list|,
name|sc
operator|->
name|sc_state
argument_list|,
name|sc
operator|->
name|sc_phase
argument_list|,
name|sc
operator|->
name|sc_prevphase
argument_list|)
expr_stmt|;
if|if
condition|(
name|ESP_READ_REG
argument_list|(
name|sc
argument_list|,
name|ESP_FFLAG
argument_list|)
operator|&
name|ESPFIFO_FF
condition|)
block|{
name|ESPCMD
argument_list|(
name|sc
argument_list|,
name|ESPCMD_FLUSH
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|esp_init
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Restart everything */
return|return
literal|1
return|;
block|}
block|}
comment|/* 		 * Call if DMA is active. 		 * 		 * If DMA_INTR returns true, then maybe go 'round the loop 		 * again in case there is no more DMA queued, but a phase 		 * change is expected. 		 */
if|if
condition|(
name|DMA_ISACTIVE
argument_list|(
name|sc
operator|->
name|sc_dma
argument_list|)
condition|)
block|{
name|DMA_INTR
argument_list|(
name|sc
operator|->
name|sc_dma
argument_list|)
expr_stmt|;
comment|/* If DMA active here, then go back to work... */
if|if
condition|(
name|DMA_ISACTIVE
argument_list|(
name|sc
operator|->
name|sc_dma
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|sc
operator|->
name|sc_dleft
operator|==
literal|0
operator|&&
operator|(
name|sc
operator|->
name|sc_espstat
operator|&
name|ESPSTAT_TC
operator|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"%s: !TC [intr %x, stat %x, step %d]"
literal|" prevphase %x, resid %x\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|sc
operator|->
name|sc_espintr
argument_list|,
name|sc
operator|->
name|sc_espstat
argument_list|,
name|sc
operator|->
name|sc_espstep
argument_list|,
name|sc
operator|->
name|sc_prevphase
argument_list|,
name|ecb
condition|?
name|ecb
operator|->
name|dleft
else|:
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* Unreliable on some ESP revisions? */
block|if ((sc->sc_espstat& ESPSTAT_INT) == 0) { 			printf("%s: spurious interrupt\n", sc->sc_dev.dv_xname); 			return 1; 		}
endif|#
directive|endif
comment|/* 		 * check for less serious errors 		 */
if|if
condition|(
name|sc
operator|->
name|sc_espstat
operator|&
name|ESPSTAT_PE
condition|)
block|{
name|printf
argument_list|(
literal|"%s: SCSI bus parity error\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_prevphase
operator|==
name|MESSAGE_IN_PHASE
condition|)
name|esp_sched_msgout
argument_list|(
name|SEND_PARITY_ERROR
argument_list|)
expr_stmt|;
else|else
name|esp_sched_msgout
argument_list|(
name|SEND_INIT_DET_ERR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_espintr
operator|&
name|ESPINTR_DIS
condition|)
block|{
name|ESP_MISC
argument_list|(
operator|(
literal|"<DISC [intr %x, stat %x, step %d]>"
operator|,
name|sc
operator|->
name|sc_espintr
operator|,
name|sc
operator|->
name|sc_espstat
operator|,
name|sc
operator|->
name|sc_espstep
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ESP_READ_REG
argument_list|(
name|sc
argument_list|,
name|ESP_FFLAG
argument_list|)
operator|&
name|ESPFIFO_FF
condition|)
block|{
name|ESPCMD
argument_list|(
name|sc
argument_list|,
name|ESPCMD_FLUSH
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * This command must (apparently) be issued within 			 * 250mS of a disconnect. So here you are... 			 */
name|ESPCMD
argument_list|(
name|sc
argument_list|,
name|ESPCMD_ENSEL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|!=
name|ESP_IDLE
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|ESP_SYNCHNEGO
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|ESP_DEBUG
if|if
condition|(
name|ecb
condition|)
name|sc_print_addr
argument_list|(
name|ecb
operator|->
name|xs
operator|->
name|sc_link
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sync nego not completed!\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|ESP_SYNCHNEGO
expr_stmt|;
name|sc
operator|->
name|sc_tinfo
index|[
name|ecb
operator|->
name|xs
operator|->
name|sc_link
operator|->
name|target
index|]
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_tinfo
index|[
name|ecb
operator|->
name|xs
operator|->
name|sc_link
operator|->
name|target
index|]
operator|.
name|flags
operator|&=
operator|~
name|T_NEGOTIATE
expr_stmt|;
block|}
comment|/*XXX*/
name|sc
operator|->
name|sc_msgpriq
operator|=
name|sc
operator|->
name|sc_msgout
operator|=
literal|0
expr_stmt|;
comment|/* it may be OK to disconnect */
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|ESP_BUSFREE_OK
operator|)
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|==
name|ESP_HASNEXUS
condition|)
block|{
name|sc_print_addr
argument_list|(
name|ecb
operator|->
name|xs
operator|->
name|sc_link
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"disconnect without"
literal|"warning\n"
argument_list|)
expr_stmt|;
block|}
name|ecb
operator|->
name|xs
operator|->
name|error
operator|=
name|XS_TIMEOUT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|ESP_DISCON
condition|)
block|{
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|nexus_list
argument_list|,
name|ecb
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|ECB_SETQ
argument_list|(
name|ecb
argument_list|,
name|ECB_QNEXUS
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_nexus
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|ESP_DISCON
expr_stmt|;
name|sc
operator|->
name|sc_state
operator|=
name|ESP_IDLE
expr_stmt|;
if|#
directive|if
name|ESP_DEBUG
if|if
condition|(
operator|(
name|esp_debug
operator|&
literal|0x10000
operator|)
operator|&&
name|ecb
operator|->
name|dleft
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: silly disconnect (ecb %p [stat %x])\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|ecb
argument_list|,
name|ecb
operator|->
name|stat
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|esp_sched
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|esp_done
argument_list|(
name|ecb
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|printf
argument_list|(
literal|"%s: DISCONNECT in IDLE state!\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|)
expr_stmt|;
block|}
comment|/* did a message go out OK ? This must be broken */
if|if
condition|(
name|sc
operator|->
name|sc_prevphase
operator|==
name|MESSAGE_OUT_PHASE
operator|&&
name|sc
operator|->
name|sc_phase
operator|!=
name|MESSAGE_OUT_PHASE
condition|)
block|{
comment|/* we have sent it */
if|if
condition|(
name|sc
operator|->
name|sc_msgout
operator|==
name|SEND_SDTR
operator|&&
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|ESP_SYNCHNEGO
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* We've just accepted new sync parameters */
name|sc
operator|->
name|sc_tinfo
index|[
name|ecb
operator|->
name|xs
operator|->
name|sc_link
operator|->
name|target
index|]
operator|.
name|flags
operator||=
name|T_SYNCMODE
expr_stmt|;
if|if
condition|(
name|ecb
condition|)
name|sc_print_addr
argument_list|(
name|ecb
operator|->
name|xs
operator|->
name|sc_link
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"NO nexus: "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"target put in SYNC mode\n"
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_msgpriq
operator|&=
operator|~
name|sc
operator|->
name|sc_msgout
expr_stmt|;
name|sc
operator|->
name|sc_msgout
operator|=
literal|0
expr_stmt|;
block|}
switch|switch
condition|(
name|sc
operator|->
name|sc_state
condition|)
block|{
case|case
name|ESP_SBR
case|:
name|printf
argument_list|(
literal|"%s: waiting for SCSI Bus Reset to happen\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|ESP_RESELECTED
case|:
comment|/* 			 * we must be continuing a message ? 			 */
if|if
condition|(
name|sc
operator|->
name|sc_phase
operator|!=
name|MESSAGE_IN_PHASE
condition|)
block|{
name|printf
argument_list|(
literal|"%s: target didn't identify\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|)
expr_stmt|;
name|esp_init
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|printf
argument_list|(
literal|"<<RESELECT CONT'd>>"
argument_list|)
expr_stmt|;
if|#
directive|if
name|XXXX
name|esp_msgin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|!=
name|ESP_HASNEXUS
condition|)
block|{
comment|/* IDENTIFY fail?! */
name|printf
argument_list|(
literal|"%s: identify failed\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|)
expr_stmt|;
name|esp_init
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
endif|#
directive|endif
break|break;
case|case
name|ESP_IDLE
case|:
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|ESP_ICCS
condition|)
name|printf
argument_list|(
literal|"[[esp: BUMMER]]"
argument_list|)
expr_stmt|;
case|case
name|ESP_SELECTING
case|:
if|if
condition|(
name|sc
operator|->
name|sc_espintr
operator|&
name|ESPINTR_RESEL
condition|)
block|{
comment|/* 				 * If we're trying to select a 				 * target ourselves, push our command 				 * back into the ready list. 				 */
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|==
name|ESP_SELECTING
condition|)
block|{
name|ESP_MISC
argument_list|(
operator|(
literal|"backoff selector "
operator|)
argument_list|)
expr_stmt|;
name|sc_link
operator|=
name|sc
operator|->
name|sc_nexus
operator|->
name|xs
operator|->
name|sc_link
expr_stmt|;
name|ti
operator|=
operator|&
name|sc
operator|->
name|sc_tinfo
index|[
name|sc_link
operator|->
name|target
index|]
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|ready_list
argument_list|,
name|sc
operator|->
name|sc_nexus
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|ECB_SETQ
argument_list|(
name|sc
operator|->
name|sc_nexus
argument_list|,
name|ECB_QREADY
argument_list|)
expr_stmt|;
name|ti
operator|->
name|lubusy
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|sc_link
operator|->
name|lun
operator|)
expr_stmt|;
name|ecb
operator|=
name|sc
operator|->
name|sc_nexus
operator|=
name|NULL
expr_stmt|;
block|}
name|sc
operator|->
name|sc_state
operator|=
name|ESP_RESELECTED
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_phase
operator|!=
name|MESSAGE_IN_PHASE
condition|)
block|{
comment|/* 					 * Things are seriously fucked up. 					 * Pull the brakes, i.e. reset 					 */
name|printf
argument_list|(
literal|"%s: target didn't identify\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|)
expr_stmt|;
name|esp_init
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|(
name|ESP_READ_REG
argument_list|(
name|sc
argument_list|,
name|ESP_FFLAG
argument_list|)
operator|&
name|ESPFIFO_FF
operator|)
operator|!=
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|"%s: RESELECT: %d bytes in FIFO!\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|ESP_READ_REG
argument_list|(
name|sc
argument_list|,
name|ESP_FFLAG
argument_list|)
operator|&
name|ESPFIFO_FF
argument_list|)
expr_stmt|;
name|esp_init
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|sc
operator|->
name|sc_selid
operator|=
name|ESP_READ_REG
argument_list|(
name|sc
argument_list|,
name|ESP_FIFO
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_selid
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|sc
operator|->
name|sc_id
operator|)
expr_stmt|;
name|ESP_MISC
argument_list|(
operator|(
literal|"selid=0x%2x "
operator|,
name|sc
operator|->
name|sc_selid
operator|)
argument_list|)
expr_stmt|;
name|esp_msgin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Handle identify message */
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|!=
name|ESP_HASNEXUS
condition|)
block|{
comment|/* IDENTIFY fail?! */
name|printf
argument_list|(
literal|"%s: identify failed\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|)
expr_stmt|;
name|esp_init
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
continue|continue;
comment|/* ie. next phase expected soon */
block|}
define|#
directive|define
name|ESPINTR_DONE
value|(ESPINTR_FC|ESPINTR_BS)
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_espintr
operator|&
name|ESPINTR_DONE
operator|)
operator|==
name|ESPINTR_DONE
condition|)
block|{
name|ecb
operator|=
name|sc
operator|->
name|sc_nexus
expr_stmt|;
if|if
condition|(
operator|!
name|ecb
condition|)
name|panic
argument_list|(
literal|"esp: not nexus at sc->sc_nexus"
argument_list|)
expr_stmt|;
name|sc_link
operator|=
name|ecb
operator|->
name|xs
operator|->
name|sc_link
expr_stmt|;
name|ti
operator|=
operator|&
name|sc
operator|->
name|sc_tinfo
index|[
name|sc_link
operator|->
name|target
index|]
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|sc_espstep
condition|)
block|{
case|case
literal|0
case|:
name|printf
argument_list|(
literal|"%s: select timeout/no disconnect\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|)
expr_stmt|;
name|esp_abort
argument_list|(
name|sc
argument_list|,
name|ecb
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
literal|1
case|:
if|if
condition|(
operator|(
name|ti
operator|->
name|flags
operator|&
name|T_NEGOTIATE
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: step 1& !NEG\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|)
expr_stmt|;
name|esp_abort
argument_list|(
name|sc
argument_list|,
name|ecb
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_phase
operator|!=
name|MESSAGE_OUT_PHASE
condition|)
block|{
name|printf
argument_list|(
literal|"%s: !MSGOUT\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|)
expr_stmt|;
name|esp_abort
argument_list|(
name|sc
argument_list|,
name|ecb
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Start negotiating */
name|ti
operator|->
name|period
operator|=
name|sc
operator|->
name|sc_minsync
expr_stmt|;
name|ti
operator|->
name|offset
operator|=
literal|15
expr_stmt|;
name|sc
operator|->
name|sc_msgpriq
operator|=
name|SEND_SDTR
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|ESP_SYNCHNEGO
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* 					 * Grr, this is supposed to mean 					 * "target left command phase 					 *  prematurely". It seems to happen 					 * regularly when sync mode is on. 					 * Look at FIFO to see if command 					 * went out. 					 * (Timing problems?) 					 */
if|if
condition|(
operator|(
name|ESP_READ_REG
argument_list|(
name|sc
argument_list|,
name|ESP_FFLAG
argument_list|)
operator|&
name|ESPFIFO_FF
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Hope for the best.. */
break|break;
block|}
name|printf
argument_list|(
literal|"(%s:%d:%d): selection failed;"
literal|" %d left in FIFO "
literal|"[intr %x, stat %x, step %d]\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|sc_link
operator|->
name|target
argument_list|,
name|sc_link
operator|->
name|lun
argument_list|,
name|ESP_READ_REG
argument_list|(
name|sc
argument_list|,
name|ESP_FFLAG
argument_list|)
operator|&
name|ESPFIFO_FF
argument_list|,
name|sc
operator|->
name|sc_espintr
argument_list|,
name|sc
operator|->
name|sc_espstat
argument_list|,
name|sc
operator|->
name|sc_espstep
argument_list|)
expr_stmt|;
name|ESPCMD
argument_list|(
name|sc
argument_list|,
name|ESPCMD_FLUSH
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|ESP_ABORTING
expr_stmt|;
name|esp_sched_msgout
argument_list|(
name|SEND_ABORT
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
literal|2
case|:
comment|/* Select stuck at Command Phase */
name|ESPCMD
argument_list|(
name|sc
argument_list|,
name|ESPCMD_FLUSH
argument_list|)
expr_stmt|;
case|case
literal|4
case|:
comment|/* So far, everything went fine */
name|sc
operator|->
name|sc_msgpriq
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|#
directive|if
literal|0
comment|/* Why set msgpriq? (and not raise ATN) */
block|if (ecb->xs->flags& SCSI_RESET) 					sc->sc_msgpriq = SEND_DEV_RESET; 				else if (ti->flags& T_NEGOTIATE) 					sc->sc_msgpriq = 					    SEND_IDENTIFY | SEND_SDTR; 				else 					sc->sc_msgpriq = SEND_IDENTIFY;
endif|#
directive|endif
name|sc
operator|->
name|sc_state
operator|=
name|ESP_HASNEXUS
expr_stmt|;
comment|/*???sc->sc_flags = 0; */
name|sc
operator|->
name|sc_prevphase
operator|=
name|INVALID_PHASE
expr_stmt|;
comment|/* ?? */
name|sc
operator|->
name|sc_dp
operator|=
name|ecb
operator|->
name|daddr
expr_stmt|;
name|sc
operator|->
name|sc_dleft
operator|=
name|ecb
operator|->
name|dleft
expr_stmt|;
name|ti
operator|->
name|lubusy
operator||=
operator|(
literal|1
operator|<<
name|sc_link
operator|->
name|lun
operator|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%s: unexpected status after select"
literal|": [intr %x, stat %x, step %x]\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|sc
operator|->
name|sc_espintr
argument_list|,
name|sc
operator|->
name|sc_espstat
argument_list|,
name|sc
operator|->
name|sc_espstep
argument_list|)
expr_stmt|;
name|ESPCMD
argument_list|(
name|sc
argument_list|,
name|ESPCMD_FLUSH
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|esp_abort
argument_list|(
name|sc
argument_list|,
name|ecb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|==
name|ESP_IDLE
condition|)
block|{
name|printf
argument_list|(
literal|"%s: stray interrupt\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
case|case
name|ESP_HASNEXUS
case|:
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|ESP_ICCS
condition|)
block|{
name|unsigned
name|char
name|msg
decl_stmt|;
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|ESP_ICCS
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|sc_espintr
operator|&
name|ESPINTR_DONE
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: ICCS: "
literal|": [intr %x, stat %x, step %x]\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|sc
operator|->
name|sc_espintr
argument_list|,
name|sc
operator|->
name|sc_espstat
argument_list|,
name|sc
operator|->
name|sc_espstep
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ESP_READ_REG
argument_list|(
name|sc
argument_list|,
name|ESP_FFLAG
argument_list|)
operator|&
name|ESPFIFO_FF
operator|)
operator|!=
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|"%s: ICCS: expected 2, got %d "
literal|": [intr %x, stat %x, step %x]\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|ESP_READ_REG
argument_list|(
name|sc
argument_list|,
name|ESP_FFLAG
argument_list|)
operator|&
name|ESPFIFO_FF
argument_list|,
name|sc
operator|->
name|sc_espintr
argument_list|,
name|sc
operator|->
name|sc_espstat
argument_list|,
name|sc
operator|->
name|sc_espstep
argument_list|)
expr_stmt|;
name|ESPCMD
argument_list|(
name|sc
argument_list|,
name|ESPCMD_FLUSH
argument_list|)
expr_stmt|;
name|esp_abort
argument_list|(
name|sc
argument_list|,
name|ecb
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|ecb
operator|->
name|stat
operator|=
name|ESP_READ_REG
argument_list|(
name|sc
argument_list|,
name|ESP_FIFO
argument_list|)
expr_stmt|;
name|msg
operator|=
name|ESP_READ_REG
argument_list|(
name|sc
argument_list|,
name|ESP_FIFO
argument_list|)
expr_stmt|;
name|ESP_PHASE
argument_list|(
operator|(
literal|"<stat:(%x,%x)>"
operator|,
name|ecb
operator|->
name|stat
operator|,
name|msg
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|==
name|MSG_CMDCOMPLETE
condition|)
block|{
name|sc
operator|->
name|sc_flags
operator||=
name|ESP_BUSFREE_OK
expr_stmt|;
name|ecb
operator|->
name|xs
operator|->
name|resid
operator|=
name|ecb
operator|->
name|dleft
operator|=
name|sc
operator|->
name|sc_dleft
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"%s: STATUS_PHASE: msg %d\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|ESPCMD
argument_list|(
name|sc
argument_list|,
name|ESPCMD_MSGOK
argument_list|)
expr_stmt|;
continue|continue;
comment|/* ie. wait for disconnect */
block|}
break|break;
default|default:
name|panic
argument_list|(
literal|"%s: invalid state: %d"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|sc
operator|->
name|sc_state
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Driver is now in state ESP_HASNEXUS, i.e. we 		 * have a current command working the SCSI bus. 		 */
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|!=
name|ESP_HASNEXUS
operator|||
name|ecb
operator|==
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"esp no nexus"
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|sc
operator|->
name|sc_phase
condition|)
block|{
case|case
name|MESSAGE_OUT_PHASE
case|:
name|ESP_PHASE
argument_list|(
operator|(
literal|"MESSAGE_OUT_PHASE "
operator|)
argument_list|)
expr_stmt|;
name|esp_msgout
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_prevphase
operator|=
name|MESSAGE_OUT_PHASE
expr_stmt|;
break|break;
case|case
name|MESSAGE_IN_PHASE
case|:
name|ESP_PHASE
argument_list|(
operator|(
literal|"MESSAGE_IN_PHASE "
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_espintr
operator|&
name|ESPINTR_BS
condition|)
block|{
name|ESPCMD
argument_list|(
name|sc
argument_list|,
name|ESPCMD_FLUSH
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|ESP_WAITI
expr_stmt|;
name|ESPCMD
argument_list|(
name|sc
argument_list|,
name|ESPCMD_TRANS
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|sc_espintr
operator|&
name|ESPINTR_FC
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|ESP_WAITI
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: MSGIN: unexpected FC bit: "
literal|"[intr %x, stat %x, step %x]\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|sc
operator|->
name|sc_espintr
argument_list|,
name|sc
operator|->
name|sc_espstat
argument_list|,
name|sc
operator|->
name|sc_espstep
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|ESP_WAITI
expr_stmt|;
name|esp_msgin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%s: MSGIN: weird bits: "
literal|"[intr %x, stat %x, step %x]\n"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|sc
operator|->
name|sc_espintr
argument_list|,
name|sc
operator|->
name|sc_espstat
argument_list|,
name|sc
operator|->
name|sc_espstep
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_prevphase
operator|=
name|MESSAGE_IN_PHASE
expr_stmt|;
break|break;
case|case
name|COMMAND_PHASE
case|:
block|{
comment|/* well, this means send the command again */
name|u_char
modifier|*
name|cmd
init|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|ecb
operator|->
name|cmd
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ESP_PHASE
argument_list|(
operator|(
literal|"COMMAND_PHASE 0x%02x (%d) "
operator|,
name|ecb
operator|->
name|cmd
operator|.
name|opcode
operator|,
name|ecb
operator|->
name|clen
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ESP_READ_REG
argument_list|(
name|sc
argument_list|,
name|ESP_FFLAG
argument_list|)
operator|&
name|ESPFIFO_FF
condition|)
block|{
name|ESPCMD
argument_list|(
name|sc
argument_list|,
name|ESPCMD_FLUSH
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Now the command into the FIFO */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ecb
operator|->
name|clen
condition|;
name|i
operator|++
control|)
name|ESP_WRITE_REG
argument_list|(
name|sc
argument_list|,
name|ESP_FIFO
argument_list|,
operator|*
name|cmd
operator|++
argument_list|)
expr_stmt|;
name|ESPCMD
argument_list|(
name|sc
argument_list|,
name|ESPCMD_TRANS
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_prevphase
operator|=
name|COMMAND_PHASE
expr_stmt|;
block|}
break|break;
case|case
name|DATA_OUT_PHASE
case|:
name|ESP_PHASE
argument_list|(
operator|(
literal|"DATA_OUT_PHASE [%d] "
operator|,
name|sc
operator|->
name|sc_dleft
operator|)
argument_list|)
expr_stmt|;
name|ESPCMD
argument_list|(
name|sc
argument_list|,
name|ESPCMD_FLUSH
argument_list|)
expr_stmt|;
name|size
operator|=
name|min
argument_list|(
name|sc
operator|->
name|sc_dleft
argument_list|,
name|sc
operator|->
name|sc_maxxfer
argument_list|)
expr_stmt|;
name|DMA_SETUP
argument_list|(
name|sc
operator|->
name|sc_dma
argument_list|,
operator|&
name|sc
operator|->
name|sc_dp
argument_list|,
operator|&
name|sc
operator|->
name|sc_dleft
argument_list|,
literal|0
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_prevphase
operator|=
name|DATA_OUT_PHASE
expr_stmt|;
goto|goto
name|setup_xfer
goto|;
case|case
name|DATA_IN_PHASE
case|:
name|ESP_PHASE
argument_list|(
operator|(
literal|"DATA_IN_PHASE "
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_rev
operator|==
name|ESP100
condition|)
name|ESPCMD
argument_list|(
name|sc
argument_list|,
name|ESPCMD_FLUSH
argument_list|)
expr_stmt|;
name|size
operator|=
name|min
argument_list|(
name|sc
operator|->
name|sc_dleft
argument_list|,
name|sc
operator|->
name|sc_maxxfer
argument_list|)
expr_stmt|;
name|DMA_SETUP
argument_list|(
name|sc
operator|->
name|sc_dma
argument_list|,
operator|&
name|sc
operator|->
name|sc_dp
argument_list|,
operator|&
name|sc
operator|->
name|sc_dleft
argument_list|,
literal|1
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_prevphase
operator|=
name|DATA_IN_PHASE
expr_stmt|;
name|setup_xfer
label|:
comment|/* Program the SCSI counter */
name|ESP_WRITE_REG
argument_list|(
name|sc
argument_list|,
name|ESP_TCL
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|ESP_WRITE_REG
argument_list|(
name|sc
argument_list|,
name|ESP_TCM
argument_list|,
name|size
operator|>>
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_cfg2
operator|&
name|ESPCFG2_FE
condition|)
block|{
name|ESP_WRITE_REG
argument_list|(
name|sc
argument_list|,
name|ESP_TCH
argument_list|,
name|size
operator|>>
literal|16
argument_list|)
expr_stmt|;
block|}
comment|/* load the count in */
name|ESPCMD
argument_list|(
name|sc
argument_list|,
name|ESPCMD_NOP
operator||
name|ESPCMD_DMA
argument_list|)
expr_stmt|;
comment|/* 			 * Note that if `size' is 0, we've already transceived 			 * all the bytes we want but we're still in DATA PHASE. 			 * Apparently, the device needs padding. Also, a 			 * transfer size of 0 means "maximum" to the chip 			 * DMA logic. 			 */
name|ESPCMD
argument_list|(
name|sc
argument_list|,
operator|(
name|size
operator|==
literal|0
condition|?
name|ESPCMD_TRPAD
else|:
name|ESPCMD_TRANS
operator|)
operator||
name|ESPCMD_DMA
argument_list|)
expr_stmt|;
name|DMA_GO
argument_list|(
name|sc
operator|->
name|sc_dma
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|STATUS_PHASE
case|:
name|ESP_PHASE
argument_list|(
operator|(
literal|"STATUS_PHASE "
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|ESP_ICCS
expr_stmt|;
name|ESPCMD
argument_list|(
name|sc
argument_list|,
name|ESPCMD_ICCS
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_prevphase
operator|=
name|STATUS_PHASE
expr_stmt|;
break|break;
case|case
name|INVALID_PHASE
case|:
break|break;
case|case
name|BUSFREE_PHASE
case|:
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|ESP_BUSFREE_OK
condition|)
block|{
comment|/*It's fun the 1st time.. */
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|ESP_BUSFREE_OK
expr_stmt|;
block|}
break|break;
default|default:
name|panic
argument_list|(
literal|"esp: bogus bus phase\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|panic
argument_list|(
literal|"esp: should not get here.."
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|esp_abort
parameter_list|(
name|sc
parameter_list|,
name|ecb
parameter_list|)
name|struct
name|esp_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ecb
modifier|*
name|ecb
decl_stmt|;
block|{
if|if
condition|(
name|ecb
operator|==
name|sc
operator|->
name|sc_nexus
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|==
name|ESP_HASNEXUS
condition|)
block|{
name|sc
operator|->
name|sc_flags
operator||=
name|ESP_ABORTING
expr_stmt|;
name|esp_sched_msgout
argument_list|(
name|SEND_ABORT
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|==
name|ESP_IDLE
condition|)
name|esp_sched
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|esp_timeout
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|int
name|s
init|=
name|splbio
argument_list|()
decl_stmt|;
name|struct
name|ecb
modifier|*
name|ecb
init|=
operator|(
expr|struct
name|ecb
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|esp_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|scsi_xfer
modifier|*
name|xs
init|=
name|ecb
operator|->
name|xs
decl_stmt|;
name|sc
operator|=
name|xs
operator|->
name|sc_link
operator|->
name|adapter_softc
expr_stmt|;
name|sc_print_addr
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|)
expr_stmt|;
name|again
label|:
name|printf
argument_list|(
literal|"%s: timed out [ecb %p (flags 0x%x, dleft %x, stat %x)], "
literal|"<state %d, nexus %p, phase(c %x, p %x), resid %x, msg(q %x,o %x) %s>"
argument_list|,
name|sc
operator|->
name|sc_dev
operator|.
name|dv_xname
argument_list|,
name|ecb
argument_list|,
name|ecb
operator|->
name|flags
argument_list|,
name|ecb
operator|->
name|dleft
argument_list|,
name|ecb
operator|->
name|stat
argument_list|,
name|sc
operator|->
name|sc_state
argument_list|,
name|sc
operator|->
name|sc_nexus
argument_list|,
name|sc
operator|->
name|sc_phase
argument_list|,
name|sc
operator|->
name|sc_prevphase
argument_list|,
name|sc
operator|->
name|sc_dleft
argument_list|,
name|sc
operator|->
name|sc_msgpriq
argument_list|,
name|sc
operator|->
name|sc_msgout
argument_list|,
name|DMA_ISACTIVE
argument_list|(
name|sc
operator|->
name|sc_dma
argument_list|)
condition|?
literal|"DMA active"
else|:
literal|""
argument_list|)
expr_stmt|;
if|#
directive|if
name|ESP_DEBUG
operator|>
literal|0
name|printf
argument_list|(
literal|"TRACE: %s."
argument_list|,
name|ecb
operator|->
name|trace
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ecb
operator|->
name|flags
operator|&
name|ECB_ABORTED
condition|)
block|{
comment|/* abort timed out */
name|printf
argument_list|(
literal|" AGAIN\n"
argument_list|)
expr_stmt|;
name|esp_init
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* abort the operation that has timed out */
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|xs
operator|->
name|error
operator|=
name|XS_TIMEOUT
expr_stmt|;
name|ecb
operator|->
name|flags
operator||=
name|ECB_ABORTED
expr_stmt|;
name|esp_abort
argument_list|(
name|sc
argument_list|,
name|ecb
argument_list|)
expr_stmt|;
comment|/* 2 secs for the abort */
if|if
condition|(
operator|(
name|xs
operator|->
name|flags
operator|&
name|SCSI_NOMASK
operator|)
operator|==
literal|0
condition|)
name|timeout
argument_list|(
name|esp_timeout
argument_list|,
name|ecb
argument_list|,
literal|2
operator|*
name|hz
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|count
init|=
literal|200000
decl_stmt|;
while|while
condition|(
name|count
condition|)
block|{
if|if
condition|(
name|DMA_ISINTR
argument_list|(
name|sc
operator|->
name|sc_dma
argument_list|)
condition|)
block|{
name|espintr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|xs
operator|->
name|flags
operator|&
name|ITSDONE
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
operator|--
name|count
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|==
literal|0
condition|)
goto|goto
name|again
goto|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|esp_min_phys
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{ 	 }
end_function

end_unit

