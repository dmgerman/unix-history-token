begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the project nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/* KAME $Id: key.c,v 1.1.6.5.2.19 1999/07/22 14:09:24 itojun Exp $ */
end_comment

begin_comment
comment|/*  * This code is referd to RFC 2367  */
end_comment

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|"opt_ipsec.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/domain.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<net/raw_cb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_pcb.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_include
include|#
directive|include
file|<netinet6/ip6.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/in6_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/in6_pcb.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INET6 */
end_comment

begin_include
include|#
directive|include
file|<net/pfkeyv2.h>
end_include

begin_include
include|#
directive|include
file|<netkey/key_var.h>
end_include

begin_include
include|#
directive|include
file|<netkey/keydb.h>
end_include

begin_include
include|#
directive|include
file|<netkey/key.h>
end_include

begin_include
include|#
directive|include
file|<netkey/keysock.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|IPSEC_DEBUG
end_ifdef

begin_include
include|#
directive|include
file|<netkey/key_debug.h>
end_include

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|KEYDEBUG
parameter_list|(
name|lev
parameter_list|,
name|arg
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netinet6/ipsec.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/ah.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_include
include|#
directive|include
file|<netinet6/ipsec6.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/ah6.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|IPSEC_ESP
end_ifdef

begin_include
include|#
directive|include
file|<netinet6/esp.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_include
include|#
directive|include
file|<netinet6/esp6.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_SECA
argument_list|,
literal|"key mgmt"
argument_list|,
literal|"security associations, key management"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|IPSEC_DEBUG
argument_list|)
end_if

begin_decl_stmt
name|u_int32_t
name|key_debug_level
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(IPSEC_DEBUG) */
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|key_spi_trycnt
init|=
literal|1000
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int32_t
name|key_spi_minval
init|=
literal|0x100
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int32_t
name|key_spi_maxval
init|=
literal|0x0fffffff
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX */
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|key_int_random
init|=
literal|60
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*interval to initialize randseed,1(m)*/
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|key_larval_lifetime
init|=
literal|30
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* interval to expire acquiring, 30(s)*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|key_blockacq_count
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* counter for blocking SADB_ACQUIRE.*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|key_blockacq_lifetime
init|=
literal|20
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* lifetime for blocking SADB_ACQUIRE.*/
end_comment

begin_decl_stmt
specifier|static
name|u_int32_t
name|acq_seq
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|key_tick_init_random
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|LIST_HEAD
argument_list|(
argument|_sptree
argument_list|,
argument|secpolicy
argument_list|)
name|sptree
index|[
name|IPSEC_DIR_MAX
index|]
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* SPD */
end_comment

begin_expr_stmt
specifier|static
name|LIST_HEAD
argument_list|(
argument|_sahtree
argument_list|,
argument|secashead
argument_list|)
name|sahtree
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* SAD */
end_comment

begin_expr_stmt
specifier|static
name|LIST_HEAD
argument_list|(
argument|_regtree
argument_list|,
argument|secreg
argument_list|)
name|regtree
index|[
name|SADB_SATYPE_MAX
operator|+
literal|1
index|]
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* registed list */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|IPSEC_NONBLOCK_ACQUIRE
end_ifndef

begin_expr_stmt
specifier|static
name|LIST_HEAD
argument_list|(
argument|_acqtree
argument_list|,
argument|secacq
argument_list|)
name|acqtree
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* acquiring list */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|key_cb
name|key_cb
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* search order for SAs */
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|saorder_state_valid
index|[]
init|=
block|{
name|SADB_SASTATE_MATURE
block|,
name|SADB_SASTATE_DYING
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|saorder_state_alive
index|[]
init|=
block|{
comment|/* except DEAD */
name|SADB_SASTATE_MATURE
block|,
name|SADB_SASTATE_DYING
block|,
name|SADB_SASTATE_LARVAL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|saorder_state_any
index|[]
init|=
block|{
name|SADB_SASTATE_MATURE
block|,
name|SADB_SASTATE_DYING
block|,
name|SADB_SASTATE_LARVAL
block|,
name|SADB_SASTATE_DEAD
block|}
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|IPSEC_DEBUG
argument_list|)
end_if

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_key
argument_list|,
name|KEYCTL_DEBUG_LEVEL
argument_list|,
name|debug
argument_list|,
name|CTLFLAG_RW
argument_list|, \
operator|&
name|key_debug_level
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(IPSEC_DEBUG) */
end_comment

begin_comment
comment|/* max count of trial for the decision of spi value */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_key
argument_list|,
name|KEYCTL_SPI_TRY
argument_list|,
name|spi_trycnt
argument_list|,
name|CTLFLAG_RW
argument_list|, \
operator|&
name|key_spi_trycnt
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* minimum spi value to allocate automatically. */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_key
argument_list|,
name|KEYCTL_SPI_MIN_VALUE
argument_list|,
name|spi_minval
argument_list|,
name|CTLFLAG_RW
argument_list|, \
operator|&
name|key_spi_minval
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* maximun spi value to allocate automatically. */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_key
argument_list|,
name|KEYCTL_SPI_MAX_VALUE
argument_list|,
name|spi_maxval
argument_list|,
name|CTLFLAG_RW
argument_list|, \
operator|&
name|key_spi_maxval
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* interval to initialize randseed */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_key
argument_list|,
name|KEYCTL_RANDOM_INT
argument_list|,
name|int_random
argument_list|,
name|CTLFLAG_RW
argument_list|, \
operator|&
name|key_int_random
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* lifetime for larval SA */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_key
argument_list|,
name|KEYCTL_LARVAL_LIFETIME
argument_list|,
name|larval_lifetime
argument_list|,
name|CTLFLAG_RW
argument_list|, \
operator|&
name|key_larval_lifetime
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* counter for blocking to send SADB_ACQUIRE to IKEd */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_key
argument_list|,
name|KEYCTL_BLOCKACQ_COUNT
argument_list|,
name|blockacq_count
argument_list|,
name|CTLFLAG_RW
argument_list|, \
operator|&
name|key_blockacq_count
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* lifetime for blocking to send SADB_ACQUIRE to IKEd */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_key
argument_list|,
name|KEYCTL_BLOCKACQ_LIFETIME
argument_list|,
name|blockacq_lifetime
argument_list|,
name|CTLFLAG_RW
argument_list|, \
operator|&
name|key_blockacq_lifetime
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|__LIST_FOREACH
parameter_list|(
name|elm
parameter_list|,
name|head
parameter_list|,
name|field
parameter_list|)
define|\
value|for (elm = LIST_FIRST(head); elm; elm = LIST_NEXT(elm, field))
end_define

begin_define
define|#
directive|define
name|__LIST_CHAINED
parameter_list|(
name|elm
parameter_list|)
define|\
value|(!((elm)->chain.le_next == NULL&& (elm)->chain.le_prev == NULL))
end_define

begin_define
define|#
directive|define
name|KEY_CHKSASTATE
parameter_list|(
name|head
parameter_list|,
name|sav
parameter_list|,
name|name
parameter_list|)
value|{                                    \ 	if ((head) != (sav)) {                                               \ 		printf("%s: state mismatched (TREE=%d SA=%d)\n",             \ 			(name), (head), (sav));                              \ 		continue;                                                    \ 	}                                                                    \ }
end_define

begin_define
define|#
directive|define
name|KEY_CHKSPDIR
parameter_list|(
name|head
parameter_list|,
name|sp
parameter_list|,
name|name
parameter_list|)
value|{                                       \ 	if ((head) != (sp)) {                                                \ 		printf("%s: direction mismatched (TREE=%d SP=%d), "          \ 			"anyway continue.\n",                                \ 			(name), (head), (sp));                               \ 	}                                                                    \ }
end_define

begin_define
define|#
directive|define
name|KMALLOC
parameter_list|(
name|p
parameter_list|,
name|t
parameter_list|,
name|n
parameter_list|)
define|\
value|((p) = (t) malloc((unsigned long)(n), M_SECA, M_NOWAIT))
end_define

begin_define
define|#
directive|define
name|KFREE
parameter_list|(
name|p
parameter_list|)
define|\
value|free((caddr_t)(p), M_SECA);
end_define

begin_define
define|#
directive|define
name|KEY_NEWBUF
parameter_list|(
name|dst
parameter_list|,
name|t
parameter_list|,
name|src
parameter_list|,
name|len
parameter_list|)
define|\
value|((dst) = (t)key_newbuf((src), (len)))
end_define

begin_comment
comment|/*  * set parameters into secpolicyindex buffer.  * Must allocate secpolicyindex buffer passed to this function.  */
end_comment

begin_define
define|#
directive|define
name|KEY_SETSECSPIDX
parameter_list|(
name|_dir
parameter_list|,
name|s
parameter_list|,
name|d
parameter_list|,
name|ps
parameter_list|,
name|pd
parameter_list|,
name|ulp
parameter_list|,
name|idx
parameter_list|)
value|do {                   \ 	bzero((idx), sizeof(struct secpolicyindex));                             \ 	(idx)->dir = (_dir);                                                 \ 	(idx)->prefs = (ps);                                                 \ 	(idx)->prefd = (pd);                                                 \ 	(idx)->ul_proto = (ulp);                                             \ 	bcopy((s),&(idx)->src, ((struct sockaddr *)(s))->sa_len);           \ 	bcopy((d),&(idx)->dst, ((struct sockaddr *)(d))->sa_len);           \ } while (0)
end_define

begin_comment
comment|/*  * set parameters into secasindex buffer.  * Must allocate secasindex buffer before calling this function.  */
end_comment

begin_define
define|#
directive|define
name|KEY_SETSECASIDX
parameter_list|(
name|p
parameter_list|,
name|m
parameter_list|,
name|s
parameter_list|,
name|d
parameter_list|,
name|idx
parameter_list|)
value|do {                                \ 	bzero((idx), sizeof(struct secasindex));                             \ 	(idx)->proto = (p);                                                  \ 	(idx)->mode = (m);                                                   \ 	bcopy((s),&(idx)->src, ((struct sockaddr *)(s))->sa_len);           \ 	bcopy((d),&(idx)->dst, ((struct sockaddr *)(d))->sa_len);           \ } while (0)
end_define

begin_comment
comment|/* key statistics */
end_comment

begin_struct
struct|struct
name|_keystat
block|{
name|u_long
name|getspi_count
decl_stmt|;
comment|/* the avarage of count to try to get new SPI */
block|}
name|keystat
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|secasvar
modifier|*
name|key_allocsa_policy
name|__P
argument_list|(
operator|(
expr|struct
name|ipsecrequest
operator|*
name|isr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|key_freesp_so
name|__P
argument_list|(
operator|(
expr|struct
name|secpolicy
operator|*
operator|*
name|sp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|secasvar
modifier|*
name|key_do_allocsa_policy
name|__P
argument_list|(
operator|(
expr|struct
name|secashead
operator|*
name|sah
operator|,
name|u_int
name|state
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|key_delsp
name|__P
argument_list|(
operator|(
expr|struct
name|secpolicy
operator|*
name|sp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|secpolicy
modifier|*
name|key_getsp
name|__P
argument_list|(
operator|(
expr|struct
name|secpolicyindex
operator|*
name|spidx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|sadb_msg
modifier|*
name|key_spdadd
name|__P
argument_list|(
operator|(
name|caddr_t
operator|*
name|mhp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|sadb_msg
modifier|*
name|key_spddelete
name|__P
argument_list|(
operator|(
name|caddr_t
operator|*
name|mhp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|sadb_msg
modifier|*
name|key_spdflush
name|__P
argument_list|(
operator|(
name|caddr_t
operator|*
name|mhp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|key_spddump
name|__P
argument_list|(
operator|(
name|caddr_t
operator|*
name|mhp
operator|,
expr|struct
name|socket
operator|*
name|so
operator|,
name|int
name|target
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|key_setdumpsp
name|__P
argument_list|(
operator|(
expr|struct
name|sadb_msg
operator|*
name|newmsg
operator|,
expr|struct
name|secpolicy
operator|*
name|sp
operator|,
name|u_int8_t
name|type
operator|,
name|u_int32_t
name|seq
operator|,
name|u_int32_t
name|pid
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|key_getspmsglen
name|__P
argument_list|(
operator|(
expr|struct
name|secpolicy
operator|*
name|sp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|key_getspreqmsglen
name|__P
argument_list|(
operator|(
expr|struct
name|secpolicy
operator|*
name|sp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|secashead
modifier|*
name|key_newsah
name|__P
argument_list|(
operator|(
expr|struct
name|secasindex
operator|*
name|saidx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|key_delsah
name|__P
argument_list|(
operator|(
expr|struct
name|secashead
operator|*
name|sah
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|secasvar
modifier|*
name|key_newsav
name|__P
argument_list|(
operator|(
name|caddr_t
operator|*
name|mhp
operator|,
expr|struct
name|secashead
operator|*
name|sah
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|key_delsav
name|__P
argument_list|(
operator|(
expr|struct
name|secasvar
operator|*
name|sav
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|secashead
modifier|*
name|key_getsah
name|__P
argument_list|(
operator|(
expr|struct
name|secasindex
operator|*
name|saidx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|secasvar
modifier|*
name|key_checkspidup
name|__P
argument_list|(
operator|(
expr|struct
name|secasindex
operator|*
name|saidx
operator|,
name|u_int32_t
name|spi
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|secasvar
modifier|*
name|key_getsavbyspi
name|__P
argument_list|(
operator|(
expr|struct
name|secashead
operator|*
name|sah
operator|,
name|u_int32_t
name|spi
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|key_setsaval
name|__P
argument_list|(
operator|(
expr|struct
name|secasvar
operator|*
name|sav
operator|,
name|caddr_t
operator|*
name|mhp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|key_getmsglen
name|__P
argument_list|(
operator|(
expr|struct
name|secasvar
operator|*
name|sav
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|key_mature
name|__P
argument_list|(
operator|(
expr|struct
name|secasvar
operator|*
name|sav
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|key_setdumpsa
name|__P
argument_list|(
operator|(
expr|struct
name|sadb_msg
operator|*
name|newmsg
operator|,
expr|struct
name|secasvar
operator|*
name|sav
operator|,
name|u_int8_t
name|type
operator|,
name|u_int8_t
name|satype
operator|,
name|u_int32_t
name|seq
operator|,
name|u_int32_t
name|pid
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|caddr_t
name|key_setsadbmsg
name|__P
argument_list|(
operator|(
name|caddr_t
name|buf
operator|,
name|u_int8_t
name|type
operator|,
name|int
name|tlen
operator|,
name|u_int8_t
name|satype
operator|,
name|u_int32_t
name|seq
operator|,
name|pid_t
name|pid
operator|,
name|u_int8_t
name|reserved1
operator|,
name|u_int8_t
name|reserved2
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|caddr_t
name|key_setsadbsa
name|__P
argument_list|(
operator|(
name|caddr_t
name|buf
operator|,
expr|struct
name|secasvar
operator|*
name|sav
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|caddr_t
name|key_setsadbaddr
name|__P
argument_list|(
operator|(
name|caddr_t
name|buf
operator|,
name|u_int16_t
name|exttype
operator|,
expr|struct
name|sockaddr
operator|*
name|saddr
operator|,
name|u_int8_t
name|prefixlen
operator|,
name|u_int16_t
name|ul_proto
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|caddr_t
name|key_setsadbident
name|__P
argument_list|(
operator|(
name|caddr_t
name|buf
operator|,
name|u_int16_t
name|exttype
operator|,
name|u_int16_t
name|idtype
operator|,
name|caddr_t
name|string
operator|,
name|int
name|stringlen
operator|,
name|u_int64_t
name|id
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|caddr_t
name|key_setsadbext
name|__P
argument_list|(
operator|(
name|caddr_t
name|p
operator|,
name|caddr_t
name|ext
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
modifier|*
name|key_newbuf
name|__P
argument_list|(
operator|(
name|void
operator|*
name|src
operator|,
name|u_int
name|len
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|key_ismyaddr6
name|__P
argument_list|(
operator|(
name|caddr_t
name|addr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|key_cmpsaidx_exactly
name|__P
argument_list|(
operator|(
expr|struct
name|secasindex
operator|*
name|saidx0
operator|,
expr|struct
name|secasindex
operator|*
name|saidx1
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|key_cmpsaidx_withmode
name|__P
argument_list|(
operator|(
expr|struct
name|secasindex
operator|*
name|saidx0
operator|,
expr|struct
name|secasindex
operator|*
name|saidx1
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|key_cmpspidx_exactly
name|__P
argument_list|(
operator|(
expr|struct
name|secpolicyindex
operator|*
name|spidx0
operator|,
expr|struct
name|secpolicyindex
operator|*
name|spidx1
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|key_cmpspidx_withmask
name|__P
argument_list|(
operator|(
expr|struct
name|secpolicyindex
operator|*
name|spidx0
operator|,
expr|struct
name|secpolicyindex
operator|*
name|spidx1
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|key_bbcmp
name|__P
argument_list|(
operator|(
name|caddr_t
name|p1
operator|,
name|caddr_t
name|p2
operator|,
name|u_int
name|bits
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int16_t
name|key_satype2proto
name|__P
argument_list|(
operator|(
name|u_int8_t
name|satype
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int8_t
name|key_proto2satype
name|__P
argument_list|(
operator|(
name|u_int16_t
name|proto
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|sadb_msg
modifier|*
name|key_getspi
name|__P
argument_list|(
operator|(
name|caddr_t
operator|*
name|mhp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int32_t
name|key_do_getnewspi
name|__P
argument_list|(
operator|(
expr|struct
name|sadb_spirange
operator|*
name|spirange
operator|,
expr|struct
name|secasindex
operator|*
name|saidx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|sadb_msg
modifier|*
name|key_update
name|__P
argument_list|(
operator|(
name|caddr_t
operator|*
name|mhp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|secasvar
modifier|*
name|key_getsavbyseq
name|__P
argument_list|(
operator|(
expr|struct
name|secashead
operator|*
name|sah
operator|,
name|u_int32_t
name|seq
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|sadb_msg
modifier|*
name|key_add
name|__P
argument_list|(
operator|(
name|caddr_t
operator|*
name|mhp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|sadb_msg
modifier|*
name|key_getmsgbuf_x1
name|__P
argument_list|(
operator|(
name|caddr_t
operator|*
name|mhp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|sadb_msg
modifier|*
name|key_delete
name|__P
argument_list|(
operator|(
name|caddr_t
operator|*
name|mhp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|sadb_msg
modifier|*
name|key_get
name|__P
argument_list|(
operator|(
name|caddr_t
operator|*
name|mhp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|key_acquire
name|__P
argument_list|(
operator|(
expr|struct
name|secasindex
operator|*
name|saidx
operator|,
expr|struct
name|secpolicyindex
operator|*
name|spidx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|secacq
modifier|*
name|key_newacq
name|__P
argument_list|(
operator|(
expr|struct
name|secasindex
operator|*
name|saidx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|secacq
modifier|*
name|key_getacq
name|__P
argument_list|(
operator|(
expr|struct
name|secasindex
operator|*
name|saidx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|secacq
modifier|*
name|key_getacqbyseq
name|__P
argument_list|(
operator|(
name|u_int32_t
name|seq
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|sadb_msg
modifier|*
name|key_acquire2
name|__P
argument_list|(
operator|(
name|caddr_t
operator|*
name|mhp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|sadb_msg
modifier|*
name|key_register
name|__P
argument_list|(
operator|(
name|caddr_t
operator|*
name|mhp
operator|,
expr|struct
name|socket
operator|*
name|so
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|key_expire
name|__P
argument_list|(
operator|(
expr|struct
name|secasvar
operator|*
name|sav
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|sadb_msg
modifier|*
name|key_flush
name|__P
argument_list|(
operator|(
name|caddr_t
operator|*
name|mhp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|key_dump
name|__P
argument_list|(
operator|(
name|caddr_t
operator|*
name|mhp
operator|,
expr|struct
name|socket
operator|*
name|so
operator|,
name|int
name|target
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|key_promisc
name|__P
argument_list|(
operator|(
name|caddr_t
operator|*
name|mhp
operator|,
expr|struct
name|socket
operator|*
name|so
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|key_sendall
name|__P
argument_list|(
operator|(
expr|struct
name|sadb_msg
operator|*
name|msg
operator|,
name|u_int
name|len
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|key_align
name|__P
argument_list|(
operator|(
expr|struct
name|sadb_msg
operator|*
name|msg
operator|,
name|caddr_t
operator|*
name|mhp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|key_sa_chgstate
name|__P
argument_list|(
operator|(
expr|struct
name|secasvar
operator|*
name|sav
operator|,
name|u_int8_t
name|state
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* %%% IPsec policy management */
end_comment

begin_comment
comment|/*  * allocating a SP for OUTBOUND or INBOUND packet.  * Must call key_freesp() later.  * OUT:	NULL:	not found  *	others:	found and return the pointer.  */
end_comment

begin_function
name|struct
name|secpolicy
modifier|*
name|key_allocsp
parameter_list|(
name|spidx
parameter_list|,
name|dir
parameter_list|)
name|struct
name|secpolicyindex
modifier|*
name|spidx
decl_stmt|;
name|u_int
name|dir
decl_stmt|;
block|{
name|struct
name|secpolicy
modifier|*
name|sp
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* sanity check */
if|if
condition|(
name|spidx
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_allocsp: NULL pointer is passed.\n"
argument_list|)
expr_stmt|;
comment|/* check direction */
switch|switch
condition|(
name|dir
condition|)
block|{
case|case
name|IPSEC_DIR_INBOUND
case|:
case|case
name|IPSEC_DIR_OUTBOUND
case|:
break|break;
default|default:
name|panic
argument_list|(
literal|"key_allocsp: Invalid direction is passed.\n"
argument_list|)
expr_stmt|;
block|}
comment|/* get a SP entry */
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
comment|/*called from softclock()*/
name|KEYDEBUG
argument_list|(
argument|KEYDEBUG_IPSEC_DATA
argument_list|,
argument|printf(
literal|"*** objects\n"
argument|); 		kdebug_secpolicyindex(spidx)
argument_list|)
empty_stmt|;
name|__LIST_FOREACH
argument_list|(
argument|sp
argument_list|,
argument|&sptree[dir]
argument_list|,
argument|chain
argument_list|)
block|{
name|KEYDEBUG
argument_list|(
argument|KEYDEBUG_IPSEC_DATA
argument_list|,
argument|printf(
literal|"*** in SPD\n"
argument|); 			kdebug_secpolicyindex(&sp->spidx)
argument_list|)
empty_stmt|;
if|if
condition|(
name|sp
operator|->
name|state
operator|==
name|IPSEC_SPSTATE_DEAD
condition|)
continue|continue;
if|if
condition|(
name|key_cmpspidx_withmask
argument_list|(
operator|&
name|sp
operator|->
name|spidx
argument_list|,
name|spidx
argument_list|)
condition|)
goto|goto
name|found
goto|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
name|found
label|:
comment|/* sanity check */
name|KEY_CHKSPDIR
argument_list|(
name|sp
operator|->
name|spidx
operator|.
name|dir
argument_list|,
name|dir
argument_list|,
literal|"key_allocsp"
argument_list|)
expr_stmt|;
comment|/* found a SPD entry */
name|sp
operator|->
name|refcnt
operator|++
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|KEYDEBUG
argument_list|(
name|KEYDEBUG_IPSEC_STAMP
argument_list|,
name|printf
argument_list|(
literal|"DP key_allocsp cause refcnt++:%d SP:%p\n"
argument_list|,
name|sp
operator|->
name|refcnt
argument_list|,
name|sp
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|sp
return|;
block|}
end_function

begin_comment
comment|/*  * checking each request entries in SP, and acquire SA if need.  * OUT:	0: there are valid requests.  *	ENOENT: policy may be valid, but SA with REQUIRE is on acquiring.  */
end_comment

begin_function
name|int
name|key_checkrequest
parameter_list|(
name|isr
parameter_list|)
name|struct
name|ipsecrequest
modifier|*
name|isr
decl_stmt|;
block|{
name|u_int
name|level
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* sanity check */
if|if
condition|(
name|isr
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_checkrequest: NULL pointer is passed.\n"
argument_list|)
expr_stmt|;
comment|/* check mode */
switch|switch
condition|(
name|isr
operator|->
name|saidx
operator|.
name|mode
condition|)
block|{
case|case
name|IPSEC_MODE_TRANSPORT
case|:
case|case
name|IPSEC_MODE_TUNNEL
case|:
break|break;
case|case
name|IPSEC_MODE_ANY
case|:
default|default:
name|panic
argument_list|(
literal|"key_checkrequest: Invalid policy defined.\n"
argument_list|)
expr_stmt|;
block|}
comment|/* get current level */
name|level
operator|=
name|ipsec_get_reqlevel
argument_list|(
name|isr
argument_list|)
expr_stmt|;
comment|/* 	 * We don't allocate new SA if the state of SA in the holder is 	 * SADB_SASTATE_MATURE, and if this is newer one. 	 */
if|if
condition|(
name|isr
operator|->
name|sav
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * XXX While SA is hanging on policy request(isr), its refcnt 		 * can not be zero.  So isr->sav->sah is valid pointer if 		 * isr->sav != NULL.  But that may not be true in fact. 		 * There may be missunderstanding by myself.  Anyway I set 		 * zero to isr->sav->sah when isr->sav is flushed. 		 * I must check to have conviction this issue. 		 */
if|if
condition|(
name|isr
operator|->
name|sav
operator|->
name|sah
operator|!=
name|NULL
operator|&&
name|isr
operator|->
name|sav
operator|!=
operator|(
expr|struct
name|secasvar
operator|*
operator|)
name|LIST_FIRST
argument_list|(
operator|&
name|isr
operator|->
name|sav
operator|->
name|sah
operator|->
name|savtree
index|[
name|SADB_SASTATE_MATURE
index|]
argument_list|)
condition|)
block|{
name|KEYDEBUG
argument_list|(
name|KEYDEBUG_IPSEC_STAMP
argument_list|,
name|printf
argument_list|(
literal|"DP checkrequest calls free SA:%p\n"
argument_list|,
name|isr
operator|->
name|sav
argument_list|)
argument_list|)
expr_stmt|;
name|key_freesav
argument_list|(
name|isr
operator|->
name|sav
argument_list|)
expr_stmt|;
block|}
name|isr
operator|->
name|sav
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* new SA allocation if no SA found. */
if|if
condition|(
name|isr
operator|->
name|sav
operator|==
name|NULL
condition|)
name|isr
operator|->
name|sav
operator|=
name|key_allocsa_policy
argument_list|(
name|isr
argument_list|)
expr_stmt|;
comment|/* When there is SA. */
if|if
condition|(
name|isr
operator|->
name|sav
operator|!=
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* there is no SA */
if|if
condition|(
operator|(
name|error
operator|=
name|key_acquire
argument_list|(
operator|&
name|isr
operator|->
name|saidx
argument_list|,
operator|&
name|isr
operator|->
name|sp
operator|->
name|spidx
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* XXX What I do ? */
name|printf
argument_list|(
literal|"key_checkrequest: error %d returned "
literal|"from key_acquire.\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
return|return
name|level
operator|==
name|IPSEC_LEVEL_REQUIRE
condition|?
name|ENOENT
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * allocating a SA for policy entry from SAD.  * NOTE: searching SAD of aliving state.  * OUT:	NULL:	not found.  *	others:	found and return the pointer.  */
end_comment

begin_function
specifier|static
name|struct
name|secasvar
modifier|*
name|key_allocsa_policy
parameter_list|(
name|isr
parameter_list|)
name|struct
name|ipsecrequest
modifier|*
name|isr
decl_stmt|;
block|{
name|struct
name|secashead
modifier|*
name|sah
decl_stmt|;
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|;
name|u_int
name|stateidx
decl_stmt|,
name|state
decl_stmt|;
name|__LIST_FOREACH
argument_list|(
argument|sah
argument_list|,
argument|&sahtree
argument_list|,
argument|chain
argument_list|)
block|{
if|if
condition|(
name|sah
operator|->
name|state
operator|==
name|SADB_SASTATE_DEAD
condition|)
continue|continue;
if|if
condition|(
name|key_cmpsaidx_withmode
argument_list|(
operator|&
name|sah
operator|->
name|saidx
argument_list|,
operator|&
name|isr
operator|->
name|saidx
argument_list|)
condition|)
goto|goto
name|found
goto|;
block|}
return|return
name|NULL
return|;
name|found
label|:
comment|/* search valid state */
for|for
control|(
name|stateidx
operator|=
literal|0
init|;
name|stateidx
operator|<
name|_ARRAYLEN
argument_list|(
name|saorder_state_valid
argument_list|)
condition|;
name|stateidx
operator|++
control|)
block|{
name|state
operator|=
name|saorder_state_valid
index|[
name|stateidx
index|]
expr_stmt|;
name|sav
operator|=
name|key_do_allocsa_policy
argument_list|(
name|sah
argument_list|,
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|!=
name|NULL
condition|)
return|return
name|sav
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * searching SAD with direction, protocol, mode and state.  * called by key_allocsa_policy().  * OUT:  *	NULL	: not found  *	others	: found, pointer to a SA.  */
end_comment

begin_function
specifier|static
name|struct
name|secasvar
modifier|*
name|key_do_allocsa_policy
parameter_list|(
name|sah
parameter_list|,
name|state
parameter_list|)
name|struct
name|secashead
modifier|*
name|sah
decl_stmt|;
name|u_int
name|state
decl_stmt|;
block|{
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|,
modifier|*
name|candidate
decl_stmt|;
comment|/* initilize */
name|candidate
operator|=
name|NULL
expr_stmt|;
name|__LIST_FOREACH
argument_list|(
argument|sav
argument_list|,
argument|&sah->savtree[state]
argument_list|,
argument|chain
argument_list|)
block|{
comment|/* sanity check */
name|KEY_CHKSASTATE
argument_list|(
name|sav
operator|->
name|state
argument_list|,
name|state
argument_list|,
literal|"key_do_allocsa_policy"
argument_list|)
expr_stmt|;
comment|/* initialize */
if|if
condition|(
name|candidate
operator|==
name|NULL
condition|)
block|{
name|candidate
operator|=
name|sav
expr_stmt|;
continue|continue;
block|}
comment|/* Which SA is the better ? */
comment|/* sanity check 2 */
if|if
condition|(
name|candidate
operator|->
name|lft_c
operator|==
name|NULL
operator|||
name|sav
operator|->
name|lft_c
operator|==
name|NULL
condition|)
block|{
comment|/*XXX do panic ? */
name|printf
argument_list|(
literal|"key_do_allocsa_policy: "
literal|"lifetime_current is NULL.\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* XXX What the best method is to compare ? */
if|if
condition|(
name|candidate
operator|->
name|lft_c
operator|->
name|sadb_lifetime_addtime
operator|<
name|sav
operator|->
name|lft_c
operator|->
name|sadb_lifetime_addtime
condition|)
block|{
name|candidate
operator|=
name|sav
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|candidate
condition|)
block|{
name|candidate
operator|->
name|refcnt
operator|++
expr_stmt|;
name|KEYDEBUG
argument_list|(
name|KEYDEBUG_IPSEC_STAMP
argument_list|,
name|printf
argument_list|(
literal|"DP allocsa_policy cause "
literal|"refcnt++:%d SA:%p\n"
argument_list|,
name|candidate
operator|->
name|refcnt
argument_list|,
name|candidate
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|candidate
return|;
block|}
end_function

begin_comment
comment|/*  * allocating a SA entry for a *INBOUND* packet.  * Must call key_freesav() later.  * OUT: positive:	pointer to a sav.  *	NULL:		not found, or error occured.  */
end_comment

begin_function
name|struct
name|secasvar
modifier|*
name|key_allocsa
parameter_list|(
name|family
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|,
name|proto
parameter_list|,
name|spi
parameter_list|)
name|u_int
name|family
decl_stmt|,
name|proto
decl_stmt|;
name|caddr_t
name|src
decl_stmt|,
name|dst
decl_stmt|;
name|u_int32_t
name|spi
decl_stmt|;
block|{
name|struct
name|secashead
modifier|*
name|sah
decl_stmt|;
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|;
name|u_int
name|stateidx
decl_stmt|,
name|state
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* sanity check */
if|if
condition|(
name|src
operator|==
name|NULL
operator|||
name|dst
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_allocsa: NULL pointer is passed.\n"
argument_list|)
expr_stmt|;
comment|/* 	 * searching SAD. 	 * XXX: to be checked internal IP header somewhere.  Also when 	 * IPsec tunnel packet is received.  But ESP tunnel mode is 	 * encrypted so we can't check internal IP header. 	 */
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
comment|/*called from softclock()*/
name|__LIST_FOREACH
argument_list|(
argument|sah
argument_list|,
argument|&sahtree
argument_list|,
argument|chain
argument_list|)
block|{
comment|/* search valid state */
for|for
control|(
name|stateidx
operator|=
literal|0
init|;
name|stateidx
operator|<
name|_ARRAYLEN
argument_list|(
name|saorder_state_valid
argument_list|)
condition|;
name|stateidx
operator|++
control|)
block|{
name|state
operator|=
name|saorder_state_valid
index|[
name|stateidx
index|]
expr_stmt|;
name|__LIST_FOREACH
argument_list|(
argument|sav
argument_list|,
argument|&sah->savtree[state]
argument_list|,
argument|chain
argument_list|)
block|{
comment|/* sanity check */
name|KEY_CHKSASTATE
argument_list|(
name|sav
operator|->
name|state
argument_list|,
name|state
argument_list|,
literal|"key_allocsav"
argument_list|)
expr_stmt|;
if|if
condition|(
name|proto
operator|!=
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|proto
condition|)
continue|continue;
if|if
condition|(
name|spi
operator|!=
name|sav
operator|->
name|spi
condition|)
continue|continue;
if|if
condition|(
name|key_bbcmp
argument_list|(
name|src
argument_list|,
name|_INADDRBYSA
argument_list|(
operator|&
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|src
argument_list|)
argument_list|,
name|_INALENBYAF
argument_list|(
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|src
operator|.
name|__ss_family
argument_list|)
operator|<<
literal|3
argument_list|)
operator|&&
name|key_bbcmp
argument_list|(
name|dst
argument_list|,
name|_INADDRBYSA
argument_list|(
operator|&
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|dst
argument_list|)
argument_list|,
name|_INALENBYAF
argument_list|(
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|dst
operator|.
name|__ss_family
argument_list|)
operator|<<
literal|3
argument_list|)
condition|)
goto|goto
name|found
goto|;
block|}
block|}
block|}
comment|/* not found */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
name|found
label|:
name|sav
operator|->
name|refcnt
operator|++
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|KEYDEBUG
argument_list|(
name|KEYDEBUG_IPSEC_STAMP
argument_list|,
name|printf
argument_list|(
literal|"DP allocsa cause refcnt++:%d SA:%p\n"
argument_list|,
name|sav
operator|->
name|refcnt
argument_list|,
name|sav
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|sav
return|;
block|}
end_function

begin_comment
comment|/*  * Must be called after calling key_allocsp().  * For both the packet without socket and key_freeso().  */
end_comment

begin_function
name|void
name|key_freesp
parameter_list|(
name|sp
parameter_list|)
name|struct
name|secpolicy
modifier|*
name|sp
decl_stmt|;
block|{
comment|/* sanity check */
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_freesp: NULL pointer is passed.\n"
argument_list|)
expr_stmt|;
name|sp
operator|->
name|refcnt
operator|--
expr_stmt|;
name|KEYDEBUG
argument_list|(
name|KEYDEBUG_IPSEC_STAMP
argument_list|,
name|printf
argument_list|(
literal|"DP freesp cause refcnt--:%d SP:%p\n"
argument_list|,
name|sp
operator|->
name|refcnt
argument_list|,
name|sp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|refcnt
operator|==
literal|0
condition|)
name|key_delsp
argument_list|(
name|sp
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Must be called after calling key_allocsp().  * For the packet with socket.  */
end_comment

begin_function
name|void
name|key_freeso
parameter_list|(
name|so
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
block|{
comment|/* sanity check */
if|if
condition|(
name|so
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_freeso: NULL pointer is passed.\n"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|so
operator|->
name|so_proto
operator|->
name|pr_domain
operator|->
name|dom_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|PF_INET
case|:
block|{
name|struct
name|inpcb
modifier|*
name|pcb
init|=
name|sotoinpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
comment|/* Does it have a PCB ? */
if|if
condition|(
name|pcb
operator|==
name|NULL
condition|)
return|return;
name|key_freesp_so
argument_list|(
operator|&
name|pcb
operator|->
name|inp_sp
operator|->
name|sp_in
argument_list|)
expr_stmt|;
name|key_freesp_so
argument_list|(
operator|&
name|pcb
operator|->
name|inp_sp
operator|->
name|sp_out
argument_list|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|PF_INET6
case|:
block|{
name|struct
name|in6pcb
modifier|*
name|pcb
init|=
name|sotoin6pcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
comment|/* Does it have a PCB ? */
if|if
condition|(
name|pcb
operator|==
name|NULL
condition|)
return|return;
name|key_freesp_so
argument_list|(
operator|&
name|pcb
operator|->
name|in6p_sp
operator|->
name|sp_in
argument_list|)
expr_stmt|;
name|key_freesp_so
argument_list|(
operator|&
name|pcb
operator|->
name|in6p_sp
operator|->
name|sp_out
argument_list|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
comment|/* INET6 */
default|default:
name|printf
argument_list|(
literal|"key_freeso: unknown address family=%d.\n"
argument_list|,
name|so
operator|->
name|so_proto
operator|->
name|pr_domain
operator|->
name|dom_family
argument_list|)
expr_stmt|;
return|return;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|key_freesp_so
parameter_list|(
name|sp
parameter_list|)
name|struct
name|secpolicy
modifier|*
modifier|*
name|sp
decl_stmt|;
block|{
comment|/* sanity check */
if|if
condition|(
name|sp
operator|==
name|NULL
operator|||
operator|*
name|sp
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_freesp_so: sp == NULL\n"
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
operator|*
name|sp
operator|)
operator|->
name|policy
condition|)
block|{
case|case
name|IPSEC_POLICY_IPSEC
case|:
name|KEYDEBUG
argument_list|(
name|KEYDEBUG_IPSEC_STAMP
argument_list|,
name|printf
argument_list|(
literal|"DP freeso calls free SP:%p\n"
argument_list|,
operator|*
name|sp
argument_list|)
argument_list|)
expr_stmt|;
name|key_freesp
argument_list|(
operator|*
name|sp
argument_list|)
expr_stmt|;
operator|*
name|sp
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|IPSEC_POLICY_ENTRUST
case|:
case|case
name|IPSEC_POLICY_BYPASS
case|:
return|return;
default|default:
name|panic
argument_list|(
literal|"key_freesp_so: Invalid policy found %d"
argument_list|,
operator|(
operator|*
name|sp
operator|)
operator|->
name|policy
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * Must be called after calling key_allocsa().  * This function is called by key_freesp() to free some SA allocated  * for a policy.  */
end_comment

begin_function
name|void
name|key_freesav
parameter_list|(
name|sav
parameter_list|)
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|;
block|{
comment|/* sanity check */
if|if
condition|(
name|sav
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_freesav: NULL pointer is passed.\n"
argument_list|)
expr_stmt|;
name|sav
operator|->
name|refcnt
operator|--
expr_stmt|;
name|KEYDEBUG
argument_list|(
name|KEYDEBUG_IPSEC_STAMP
argument_list|,
name|printf
argument_list|(
literal|"DP freesav cause refcnt--:%d SA:%p SPI %d\n"
argument_list|,
name|sav
operator|->
name|refcnt
argument_list|,
name|sav
argument_list|,
operator|(
name|u_int32_t
operator|)
name|ntohl
argument_list|(
name|sav
operator|->
name|spi
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|refcnt
operator|==
literal|0
condition|)
name|key_delsav
argument_list|(
name|sav
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* %%% SPD management */
end_comment

begin_comment
comment|/*  * free security policy entry.  */
end_comment

begin_function
specifier|static
name|void
name|key_delsp
parameter_list|(
name|sp
parameter_list|)
name|struct
name|secpolicy
modifier|*
name|sp
decl_stmt|;
block|{
name|int
name|s
decl_stmt|;
comment|/* sanity check */
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_delsp: NULL pointer is passed.\n"
argument_list|)
expr_stmt|;
name|sp
operator|->
name|state
operator|=
name|IPSEC_SPSTATE_DEAD
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|refcnt
operator|>
literal|0
condition|)
return|return;
comment|/* can't free */
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
comment|/*called from softclock()*/
comment|/* remove from SP index */
if|if
condition|(
name|__LIST_CHAINED
argument_list|(
name|sp
argument_list|)
condition|)
name|LIST_REMOVE
argument_list|(
name|sp
argument_list|,
name|chain
argument_list|)
expr_stmt|;
block|{
name|struct
name|ipsecrequest
modifier|*
name|isr
init|=
name|sp
operator|->
name|req
decl_stmt|,
modifier|*
name|nextisr
decl_stmt|;
while|while
condition|(
name|isr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|isr
operator|->
name|sav
operator|!=
name|NULL
condition|)
block|{
name|KEYDEBUG
argument_list|(
name|KEYDEBUG_IPSEC_STAMP
argument_list|,
name|printf
argument_list|(
literal|"DP delsp calls free SA:%p\n"
argument_list|,
name|isr
operator|->
name|sav
argument_list|)
argument_list|)
expr_stmt|;
name|key_freesav
argument_list|(
name|isr
operator|->
name|sav
argument_list|)
expr_stmt|;
name|isr
operator|->
name|sav
operator|=
name|NULL
expr_stmt|;
block|}
name|nextisr
operator|=
name|isr
operator|->
name|next
expr_stmt|;
name|KFREE
argument_list|(
name|isr
argument_list|)
expr_stmt|;
name|isr
operator|=
name|nextisr
expr_stmt|;
block|}
block|}
name|KFREE
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * search SPD  * OUT:	NULL	: not found  *	others	: found, pointer to a SP.  */
end_comment

begin_function
specifier|static
name|struct
name|secpolicy
modifier|*
name|key_getsp
parameter_list|(
name|spidx
parameter_list|)
name|struct
name|secpolicyindex
modifier|*
name|spidx
decl_stmt|;
block|{
name|struct
name|secpolicy
modifier|*
name|sp
decl_stmt|;
comment|/* sanity check */
if|if
condition|(
name|spidx
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_getsp: NULL pointer is passed.\n"
argument_list|)
expr_stmt|;
name|__LIST_FOREACH
argument_list|(
argument|sp
argument_list|,
argument|&sptree[spidx->dir]
argument_list|,
argument|chain
argument_list|)
block|{
if|if
condition|(
name|sp
operator|->
name|state
operator|==
name|IPSEC_SPSTATE_DEAD
condition|)
continue|continue;
if|if
condition|(
name|key_cmpspidx_exactly
argument_list|(
name|spidx
argument_list|,
operator|&
name|sp
operator|->
name|spidx
argument_list|)
condition|)
block|{
name|sp
operator|->
name|refcnt
operator|++
expr_stmt|;
return|return
name|sp
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|struct
name|secpolicy
modifier|*
name|key_newsp
parameter_list|()
block|{
name|struct
name|secpolicy
modifier|*
name|newsp
init|=
name|NULL
decl_stmt|;
name|KMALLOC
argument_list|(
name|newsp
argument_list|,
expr|struct
name|secpolicy
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|newsp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newsp
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"key_newsp: No more memory.\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|bzero
argument_list|(
name|newsp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|newsp
argument_list|)
argument_list|)
expr_stmt|;
name|newsp
operator|->
name|refcnt
operator|=
literal|1
expr_stmt|;
name|newsp
operator|->
name|req
operator|=
name|NULL
expr_stmt|;
return|return
name|newsp
return|;
block|}
end_function

begin_comment
comment|/*  * create secpolicy structure from sadb_x_policy structure.  * NOTE: `state', `secpolicyindex' in secpolicy structure are not set,  * so must be set properly later.  */
end_comment

begin_function
name|struct
name|secpolicy
modifier|*
name|key_msg2sp
parameter_list|(
name|xpl0
parameter_list|)
name|struct
name|sadb_x_policy
modifier|*
name|xpl0
decl_stmt|;
block|{
name|struct
name|secpolicy
modifier|*
name|newsp
decl_stmt|;
comment|/* sanity check */
if|if
condition|(
name|xpl0
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_msg2sp: NULL pointer was passed.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|newsp
operator|=
name|key_newsp
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|newsp
operator|->
name|spidx
operator|.
name|dir
operator|=
name|xpl0
operator|->
name|sadb_x_policy_dir
expr_stmt|;
name|newsp
operator|->
name|policy
operator|=
name|xpl0
operator|->
name|sadb_x_policy_type
expr_stmt|;
comment|/* check policy */
switch|switch
condition|(
name|xpl0
operator|->
name|sadb_x_policy_type
condition|)
block|{
case|case
name|IPSEC_POLICY_DISCARD
case|:
case|case
name|IPSEC_POLICY_NONE
case|:
case|case
name|IPSEC_POLICY_ENTRUST
case|:
case|case
name|IPSEC_POLICY_BYPASS
case|:
name|newsp
operator|->
name|req
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|IPSEC_POLICY_IPSEC
case|:
block|{
name|int
name|tlen
decl_stmt|;
name|struct
name|sadb_x_ipsecrequest
modifier|*
name|xisr
decl_stmt|;
name|struct
name|ipsecrequest
modifier|*
modifier|*
name|p_isr
init|=
operator|&
name|newsp
operator|->
name|req
decl_stmt|;
comment|/* validity check */
if|if
condition|(
name|PFKEY_EXTLEN
argument_list|(
name|xpl0
argument_list|)
operator|<=
sizeof|sizeof
argument_list|(
operator|*
name|xpl0
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"key_msg2sp: Invalid msg length.\n"
argument_list|)
expr_stmt|;
name|key_freesp
argument_list|(
name|newsp
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|tlen
operator|=
name|PFKEY_EXTLEN
argument_list|(
name|xpl0
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|xpl0
argument_list|)
expr_stmt|;
name|xisr
operator|=
operator|(
expr|struct
name|sadb_x_ipsecrequest
operator|*
operator|)
operator|(
name|xpl0
operator|+
literal|1
operator|)
expr_stmt|;
while|while
condition|(
name|tlen
operator|>
literal|0
condition|)
block|{
comment|/* length check */
if|if
condition|(
name|xisr
operator|->
name|sadb_x_ipsecrequest_len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|xisr
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"key_msg2sp: "
literal|"invalid ipsecrequest length.\n"
argument_list|)
expr_stmt|;
name|key_freesp
argument_list|(
name|newsp
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* allocate request buffer */
name|KMALLOC
argument_list|(
operator|*
name|p_isr
argument_list|,
expr|struct
name|ipsecrequest
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|p_isr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|p_isr
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"key_msg2sp: No more memory.\n"
argument_list|)
expr_stmt|;
name|key_freesp
argument_list|(
name|newsp
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|bzero
argument_list|(
operator|*
name|p_isr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|p_isr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set values */
operator|(
operator|*
name|p_isr
operator|)
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|xisr
operator|->
name|sadb_x_ipsecrequest_proto
condition|)
block|{
case|case
name|IPPROTO_ESP
case|:
case|case
name|IPPROTO_AH
case|:
break|break;
default|default:
name|printf
argument_list|(
literal|"key_msg2sp: invalid proto type=%u\n"
argument_list|,
name|xisr
operator|->
name|sadb_x_ipsecrequest_proto
argument_list|)
expr_stmt|;
name|key_freesp
argument_list|(
name|newsp
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|(
operator|*
name|p_isr
operator|)
operator|->
name|saidx
operator|.
name|proto
operator|=
name|xisr
operator|->
name|sadb_x_ipsecrequest_proto
expr_stmt|;
switch|switch
condition|(
name|xisr
operator|->
name|sadb_x_ipsecrequest_mode
condition|)
block|{
case|case
name|IPSEC_MODE_TRANSPORT
case|:
case|case
name|IPSEC_MODE_TUNNEL
case|:
break|break;
case|case
name|IPSEC_MODE_ANY
case|:
default|default:
name|printf
argument_list|(
literal|"key_msg2sp: invalid mode=%u\n"
argument_list|,
name|xisr
operator|->
name|sadb_x_ipsecrequest_mode
argument_list|)
expr_stmt|;
name|key_freesp
argument_list|(
name|newsp
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|(
operator|*
name|p_isr
operator|)
operator|->
name|saidx
operator|.
name|mode
operator|=
name|xisr
operator|->
name|sadb_x_ipsecrequest_mode
expr_stmt|;
switch|switch
condition|(
name|xisr
operator|->
name|sadb_x_ipsecrequest_level
condition|)
block|{
case|case
name|IPSEC_LEVEL_DEFAULT
case|:
case|case
name|IPSEC_LEVEL_USE
case|:
case|case
name|IPSEC_LEVEL_REQUIRE
case|:
break|break;
default|default:
name|printf
argument_list|(
literal|"key_msg2sp: invalid level=%u\n"
argument_list|,
name|xisr
operator|->
name|sadb_x_ipsecrequest_level
argument_list|)
expr_stmt|;
name|key_freesp
argument_list|(
name|newsp
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|(
operator|*
name|p_isr
operator|)
operator|->
name|level
operator|=
name|xisr
operator|->
name|sadb_x_ipsecrequest_level
expr_stmt|;
comment|/* set IP addresses if there */
if|if
condition|(
name|xisr
operator|->
name|sadb_x_ipsecrequest_len
operator|>
sizeof|sizeof
argument_list|(
operator|*
name|xisr
argument_list|)
condition|)
block|{
name|struct
name|sockaddr
modifier|*
name|paddr
decl_stmt|;
name|paddr
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
name|xisr
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* validity check */
if|if
condition|(
name|paddr
operator|->
name|sa_len
operator|>
sizeof|sizeof
argument_list|(
operator|(
operator|*
name|p_isr
operator|)
operator|->
name|saidx
operator|.
name|src
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"key_msg2sp: invalid request "
literal|"address length.\n"
argument_list|)
expr_stmt|;
name|key_freesp
argument_list|(
name|newsp
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|bcopy
argument_list|(
name|paddr
argument_list|,
operator|&
operator|(
operator|*
name|p_isr
operator|)
operator|->
name|saidx
operator|.
name|src
argument_list|,
name|paddr
operator|->
name|sa_len
argument_list|)
expr_stmt|;
name|paddr
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|paddr
operator|+
name|paddr
operator|->
name|sa_len
operator|)
expr_stmt|;
comment|/* validity check */
if|if
condition|(
name|paddr
operator|->
name|sa_len
operator|>
sizeof|sizeof
argument_list|(
operator|(
operator|*
name|p_isr
operator|)
operator|->
name|saidx
operator|.
name|dst
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"key_msg2sp: invalid request "
literal|"address length.\n"
argument_list|)
expr_stmt|;
name|key_freesp
argument_list|(
name|newsp
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|bcopy
argument_list|(
name|paddr
argument_list|,
operator|&
operator|(
operator|*
name|p_isr
operator|)
operator|->
name|saidx
operator|.
name|dst
argument_list|,
name|paddr
operator|->
name|sa_len
argument_list|)
expr_stmt|;
block|}
operator|(
operator|*
name|p_isr
operator|)
operator|->
name|sav
operator|=
name|NULL
expr_stmt|;
operator|(
operator|*
name|p_isr
operator|)
operator|->
name|sp
operator|=
name|newsp
expr_stmt|;
comment|/* initialization for the next. */
name|p_isr
operator|=
operator|&
operator|(
operator|*
name|p_isr
operator|)
operator|->
name|next
expr_stmt|;
name|tlen
operator|-=
name|xisr
operator|->
name|sadb_x_ipsecrequest_len
expr_stmt|;
comment|/* validity check */
if|if
condition|(
name|tlen
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"key_msg2sp: becoming tlen< 0.\n"
argument_list|)
expr_stmt|;
name|key_freesp
argument_list|(
name|newsp
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|xisr
operator|=
operator|(
expr|struct
name|sadb_x_ipsecrequest
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|xisr
operator|+
name|xisr
operator|->
name|sadb_x_ipsecrequest_len
operator|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|printf
argument_list|(
literal|"key_msg2sp: invalid policy type.\n"
argument_list|)
expr_stmt|;
name|key_freesp
argument_list|(
name|newsp
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|newsp
return|;
block|}
end_function

begin_comment
comment|/*  * copy secpolicy struct to sadb_x_policy structure indicated.  */
end_comment

begin_function
name|struct
name|sadb_x_policy
modifier|*
name|key_sp2msg
parameter_list|(
name|sp
parameter_list|)
name|struct
name|secpolicy
modifier|*
name|sp
decl_stmt|;
block|{
name|struct
name|sadb_x_policy
modifier|*
name|xpl
decl_stmt|;
name|int
name|tlen
decl_stmt|;
name|caddr_t
name|p
decl_stmt|;
comment|/* sanity check. */
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_sp2msg: NULL pointer was passed.\n"
argument_list|)
expr_stmt|;
name|tlen
operator|=
name|key_getspreqmsglen
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|KMALLOC
argument_list|(
name|xpl
argument_list|,
expr|struct
name|sadb_x_policy
operator|*
argument_list|,
name|tlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|xpl
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"key_sp2msg: No more memory.\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|bzero
argument_list|(
name|xpl
argument_list|,
name|tlen
argument_list|)
expr_stmt|;
name|xpl
operator|->
name|sadb_x_policy_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|tlen
argument_list|)
expr_stmt|;
name|xpl
operator|->
name|sadb_x_policy_exttype
operator|=
name|SADB_X_EXT_POLICY
expr_stmt|;
name|xpl
operator|->
name|sadb_x_policy_type
operator|=
name|sp
operator|->
name|policy
expr_stmt|;
name|xpl
operator|->
name|sadb_x_policy_dir
operator|=
name|sp
operator|->
name|spidx
operator|.
name|dir
expr_stmt|;
name|p
operator|=
operator|(
name|caddr_t
operator|)
name|xpl
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|xpl
argument_list|)
expr_stmt|;
comment|/* if is the policy for ipsec ? */
if|if
condition|(
name|sp
operator|->
name|policy
operator|==
name|IPSEC_POLICY_IPSEC
condition|)
block|{
name|struct
name|sadb_x_ipsecrequest
modifier|*
name|xisr
decl_stmt|;
name|struct
name|ipsecrequest
modifier|*
name|isr
decl_stmt|;
for|for
control|(
name|isr
operator|=
name|sp
operator|->
name|req
init|;
name|isr
operator|!=
name|NULL
condition|;
name|isr
operator|=
name|isr
operator|->
name|next
control|)
block|{
name|xisr
operator|=
operator|(
expr|struct
name|sadb_x_ipsecrequest
operator|*
operator|)
name|p
expr_stmt|;
name|xisr
operator|->
name|sadb_x_ipsecrequest_proto
operator|=
name|isr
operator|->
name|saidx
operator|.
name|proto
expr_stmt|;
name|xisr
operator|->
name|sadb_x_ipsecrequest_mode
operator|=
name|isr
operator|->
name|saidx
operator|.
name|mode
expr_stmt|;
name|xisr
operator|->
name|sadb_x_ipsecrequest_level
operator|=
name|isr
operator|->
name|level
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|xisr
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|isr
operator|->
name|saidx
operator|.
name|src
argument_list|,
name|p
argument_list|,
name|isr
operator|->
name|saidx
operator|.
name|src
operator|.
name|__ss_len
argument_list|)
expr_stmt|;
name|p
operator|+=
name|isr
operator|->
name|saidx
operator|.
name|src
operator|.
name|__ss_len
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|isr
operator|->
name|saidx
operator|.
name|dst
argument_list|,
name|p
argument_list|,
name|isr
operator|->
name|saidx
operator|.
name|dst
operator|.
name|__ss_len
argument_list|)
expr_stmt|;
name|p
operator|+=
name|isr
operator|->
name|saidx
operator|.
name|src
operator|.
name|__ss_len
expr_stmt|;
name|xisr
operator|->
name|sadb_x_ipsecrequest_len
operator|=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|xisr
argument_list|)
operator|+
name|isr
operator|->
name|saidx
operator|.
name|src
operator|.
name|__ss_len
operator|+
name|isr
operator|->
name|saidx
operator|.
name|dst
operator|.
name|__ss_len
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|xpl
return|;
block|}
end_function

begin_comment
comment|/*  * SADB_SPDADD processing  * add a entry to SP database, when received  *<base, address(SD), policy>  * from the user(?).  * Adding to SP database,  * and send  *<base, address(SD), policy>  * to the socket which was send.  *  * IN:	mhp: pointer to the pointer to each header.  * OUT:	NULL if fail.  *	other if success, return pointer to the message to send.  *  */
end_comment

begin_function
specifier|static
name|struct
name|sadb_msg
modifier|*
name|key_spdadd
parameter_list|(
name|mhp
parameter_list|)
name|caddr_t
modifier|*
name|mhp
decl_stmt|;
block|{
name|struct
name|sadb_msg
modifier|*
name|msg0
decl_stmt|;
name|struct
name|sadb_address
modifier|*
name|src0
decl_stmt|,
modifier|*
name|dst0
decl_stmt|;
name|struct
name|sadb_x_policy
modifier|*
name|xpl0
decl_stmt|;
name|struct
name|secpolicyindex
name|spidx
decl_stmt|;
name|struct
name|secpolicy
modifier|*
name|newsp
decl_stmt|;
comment|/* sanity check */
if|if
condition|(
name|mhp
operator|==
name|NULL
operator|||
name|mhp
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_spdadd: NULL pointer is passed.\n"
argument_list|)
expr_stmt|;
name|msg0
operator|=
operator|(
expr|struct
name|sadb_msg
operator|*
operator|)
name|mhp
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|mhp
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
operator|==
name|NULL
operator|||
name|mhp
index|[
name|SADB_EXT_ADDRESS_DST
index|]
operator|==
name|NULL
operator|||
name|mhp
index|[
name|SADB_X_EXT_POLICY
index|]
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"key_spdadd: invalid message is passed.\n"
argument_list|)
expr_stmt|;
name|msg0
operator|->
name|sadb_msg_errno
operator|=
name|EINVAL
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|src0
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
name|mhp
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
expr_stmt|;
name|dst0
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
name|mhp
index|[
name|SADB_EXT_ADDRESS_DST
index|]
expr_stmt|;
name|xpl0
operator|=
operator|(
expr|struct
name|sadb_x_policy
operator|*
operator|)
name|mhp
index|[
name|SADB_X_EXT_POLICY
index|]
expr_stmt|;
comment|/* make secindex */
name|KEY_SETSECSPIDX
argument_list|(
name|xpl0
operator|->
name|sadb_x_policy_dir
argument_list|,
name|src0
operator|+
literal|1
argument_list|,
name|dst0
operator|+
literal|1
argument_list|,
name|src0
operator|->
name|sadb_address_prefixlen
argument_list|,
name|dst0
operator|->
name|sadb_address_prefixlen
argument_list|,
name|src0
operator|->
name|sadb_address_proto
argument_list|,
operator|&
name|spidx
argument_list|)
expr_stmt|;
comment|/* checking the direciton. */
switch|switch
condition|(
name|xpl0
operator|->
name|sadb_x_policy_dir
condition|)
block|{
case|case
name|IPSEC_DIR_INBOUND
case|:
case|case
name|IPSEC_DIR_OUTBOUND
case|:
break|break;
default|default:
name|printf
argument_list|(
literal|"key_spdadd: Invalid SP direction.\n"
argument_list|)
expr_stmt|;
name|msg0
operator|->
name|sadb_msg_errno
operator|=
name|EINVAL
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Is there SP in SPD ? */
name|newsp
operator|=
name|key_getsp
argument_list|(
operator|&
name|spidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|newsp
operator|!=
name|NULL
condition|)
block|{
name|key_freesp
argument_list|(
name|newsp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"key_spdadd: a SP entry exists already.\n"
argument_list|)
expr_stmt|;
name|msg0
operator|->
name|sadb_msg_errno
operator|=
name|EEXIST
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* check policy */
comment|/* key_spdadd() accepts DISCARD, NONE and IPSEC. */
if|if
condition|(
name|xpl0
operator|->
name|sadb_x_policy_type
operator|==
name|IPSEC_POLICY_ENTRUST
operator|||
name|xpl0
operator|->
name|sadb_x_policy_type
operator|==
name|IPSEC_POLICY_BYPASS
condition|)
block|{
name|printf
argument_list|(
literal|"key_spdadd: Invalid policy type.\n"
argument_list|)
expr_stmt|;
name|msg0
operator|->
name|sadb_msg_errno
operator|=
name|EINVAL
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* allocation new SP entry */
if|if
condition|(
operator|(
name|newsp
operator|=
name|key_msg2sp
argument_list|(
name|xpl0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msg0
operator|->
name|sadb_msg_errno
operator|=
name|ENOBUFS
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|KEY_SETSECSPIDX
argument_list|(
name|xpl0
operator|->
name|sadb_x_policy_dir
argument_list|,
name|src0
operator|+
literal|1
argument_list|,
name|dst0
operator|+
literal|1
argument_list|,
name|src0
operator|->
name|sadb_address_prefixlen
argument_list|,
name|dst0
operator|->
name|sadb_address_prefixlen
argument_list|,
name|src0
operator|->
name|sadb_address_proto
argument_list|,
operator|&
name|newsp
operator|->
name|spidx
argument_list|)
expr_stmt|;
name|newsp
operator|->
name|refcnt
operator|=
literal|1
expr_stmt|;
comment|/* do not reclaim until I say I do */
name|newsp
operator|->
name|state
operator|=
name|IPSEC_SPSTATE_ALIVE
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|sptree
index|[
name|newsp
operator|->
name|spidx
operator|.
name|dir
index|]
argument_list|,
name|newsp
argument_list|,
name|chain
argument_list|)
expr_stmt|;
block|{
name|struct
name|sadb_msg
modifier|*
name|newmsg
decl_stmt|;
name|u_int
name|len
decl_stmt|;
name|caddr_t
name|p
decl_stmt|;
comment|/* create new sadb_msg to reply. */
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
operator|+
name|PFKEY_EXTLEN
argument_list|(
name|mhp
index|[
name|SADB_X_EXT_POLICY
index|]
argument_list|)
operator|+
name|PFKEY_EXTLEN
argument_list|(
name|mhp
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
argument_list|)
operator|+
name|PFKEY_EXTLEN
argument_list|(
name|mhp
index|[
name|SADB_EXT_ADDRESS_DST
index|]
argument_list|)
expr_stmt|;
name|KMALLOC
argument_list|(
name|newmsg
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|newmsg
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"key_spdadd: No more memory.\n"
argument_list|)
expr_stmt|;
name|msg0
operator|->
name|sadb_msg_errno
operator|=
name|ENOBUFS
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|newmsg
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|msg0
argument_list|,
operator|(
name|caddr_t
operator|)
name|newmsg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|msg0
argument_list|)
argument_list|)
expr_stmt|;
name|newmsg
operator|->
name|sadb_msg_errno
operator|=
literal|0
expr_stmt|;
name|newmsg
operator|->
name|sadb_msg_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|caddr_t
operator|)
name|newmsg
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|msg0
argument_list|)
expr_stmt|;
name|p
operator|=
name|key_setsadbext
argument_list|(
name|p
argument_list|,
name|mhp
index|[
name|SADB_X_EXT_POLICY
index|]
argument_list|)
expr_stmt|;
name|p
operator|=
name|key_setsadbext
argument_list|(
name|p
argument_list|,
name|mhp
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
argument_list|)
expr_stmt|;
name|p
operator|=
name|key_setsadbext
argument_list|(
name|p
argument_list|,
name|mhp
index|[
name|SADB_EXT_ADDRESS_DST
index|]
argument_list|)
expr_stmt|;
return|return
name|newmsg
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * SADB_SPDDELETE processing  * receive  *<base, address(SD), policy(*)>  * from the user(?), and set SADB_SASTATE_DEAD,  * and send,  *<base, address(SD), policy(*)>  * to the ikmpd.  * policy(*) including direction of policy.  *  * IN:	mhp: pointer to the pointer to each header.  * OUT:	other if success, return pointer to the message to send.  *	0 if fail.  */
end_comment

begin_function
specifier|static
name|struct
name|sadb_msg
modifier|*
name|key_spddelete
parameter_list|(
name|mhp
parameter_list|)
name|caddr_t
modifier|*
name|mhp
decl_stmt|;
block|{
name|struct
name|sadb_msg
modifier|*
name|msg0
decl_stmt|;
name|struct
name|sadb_address
modifier|*
name|src0
decl_stmt|,
modifier|*
name|dst0
decl_stmt|;
name|struct
name|sadb_x_policy
modifier|*
name|xpl0
decl_stmt|;
name|struct
name|secpolicyindex
name|spidx
decl_stmt|;
name|struct
name|secpolicy
modifier|*
name|sp
decl_stmt|;
comment|/* sanity check */
if|if
condition|(
name|mhp
operator|==
name|NULL
operator|||
name|mhp
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_spddelete: NULL pointer is passed.\n"
argument_list|)
expr_stmt|;
name|msg0
operator|=
operator|(
expr|struct
name|sadb_msg
operator|*
operator|)
name|mhp
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|mhp
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
operator|==
name|NULL
operator|||
name|mhp
index|[
name|SADB_EXT_ADDRESS_DST
index|]
operator|==
name|NULL
operator|||
name|mhp
index|[
name|SADB_X_EXT_POLICY
index|]
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"key_spddelete: invalid message is passed.\n"
argument_list|)
expr_stmt|;
name|msg0
operator|->
name|sadb_msg_errno
operator|=
name|EINVAL
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|src0
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
operator|(
name|mhp
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
operator|)
expr_stmt|;
name|dst0
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
operator|(
name|mhp
index|[
name|SADB_EXT_ADDRESS_DST
index|]
operator|)
expr_stmt|;
name|xpl0
operator|=
operator|(
expr|struct
name|sadb_x_policy
operator|*
operator|)
name|mhp
index|[
name|SADB_X_EXT_POLICY
index|]
expr_stmt|;
comment|/* make secindex */
name|KEY_SETSECSPIDX
argument_list|(
name|xpl0
operator|->
name|sadb_x_policy_dir
argument_list|,
name|src0
operator|+
literal|1
argument_list|,
name|dst0
operator|+
literal|1
argument_list|,
name|src0
operator|->
name|sadb_address_prefixlen
argument_list|,
name|dst0
operator|->
name|sadb_address_prefixlen
argument_list|,
name|src0
operator|->
name|sadb_address_proto
argument_list|,
operator|&
name|spidx
argument_list|)
expr_stmt|;
comment|/* checking the direciton. */
switch|switch
condition|(
name|xpl0
operator|->
name|sadb_x_policy_dir
condition|)
block|{
case|case
name|IPSEC_DIR_INBOUND
case|:
case|case
name|IPSEC_DIR_OUTBOUND
case|:
break|break;
default|default:
name|printf
argument_list|(
literal|"key_spddelete: Invalid SP direction.\n"
argument_list|)
expr_stmt|;
name|msg0
operator|->
name|sadb_msg_errno
operator|=
name|EINVAL
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Is there SP in SPD ? */
if|if
condition|(
operator|(
name|sp
operator|=
name|key_getsp
argument_list|(
operator|&
name|spidx
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"key_spddelete: no SP found.\n"
argument_list|)
expr_stmt|;
name|msg0
operator|->
name|sadb_msg_errno
operator|=
name|ENOENT
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|sp
operator|->
name|state
operator|=
name|IPSEC_SPSTATE_DEAD
expr_stmt|;
name|key_freesp
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|{
name|struct
name|sadb_msg
modifier|*
name|newmsg
decl_stmt|;
name|u_int
name|len
decl_stmt|;
name|caddr_t
name|p
decl_stmt|;
comment|/* create new sadb_msg to reply. */
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
operator|+
name|PFKEY_EXTLEN
argument_list|(
name|mhp
index|[
name|SADB_X_EXT_POLICY
index|]
argument_list|)
operator|+
name|PFKEY_EXTLEN
argument_list|(
name|mhp
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
argument_list|)
operator|+
name|PFKEY_EXTLEN
argument_list|(
name|mhp
index|[
name|SADB_EXT_ADDRESS_DST
index|]
argument_list|)
expr_stmt|;
name|KMALLOC
argument_list|(
name|newmsg
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|newmsg
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"key_spddelete: No more memory.\n"
argument_list|)
expr_stmt|;
name|msg0
operator|->
name|sadb_msg_errno
operator|=
name|ENOBUFS
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|newmsg
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|mhp
index|[
literal|0
index|]
argument_list|,
operator|(
name|caddr_t
operator|)
name|newmsg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|msg0
argument_list|)
argument_list|)
expr_stmt|;
name|newmsg
operator|->
name|sadb_msg_errno
operator|=
literal|0
expr_stmt|;
name|newmsg
operator|->
name|sadb_msg_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|caddr_t
operator|)
name|newmsg
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|msg0
argument_list|)
expr_stmt|;
name|p
operator|=
name|key_setsadbext
argument_list|(
name|p
argument_list|,
name|mhp
index|[
name|SADB_X_EXT_POLICY
index|]
argument_list|)
expr_stmt|;
name|p
operator|=
name|key_setsadbext
argument_list|(
name|p
argument_list|,
name|mhp
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
argument_list|)
expr_stmt|;
name|p
operator|=
name|key_setsadbext
argument_list|(
name|p
argument_list|,
name|mhp
index|[
name|SADB_EXT_ADDRESS_DST
index|]
argument_list|)
expr_stmt|;
return|return
name|newmsg
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * SADB_SPDFLUSH processing  * receive  *<base>  * from the user, and free all entries in secpctree.  * and send,  *<base>  * to the user.  * NOTE: what to do is only marking SADB_SASTATE_DEAD.  *  * IN:	mhp: pointer to the pointer to each header.  * OUT:	other if success, return pointer to the message to send.  *	0 if fail.  */
end_comment

begin_function
specifier|static
name|struct
name|sadb_msg
modifier|*
name|key_spdflush
parameter_list|(
name|mhp
parameter_list|)
name|caddr_t
modifier|*
name|mhp
decl_stmt|;
block|{
name|struct
name|sadb_msg
modifier|*
name|msg0
decl_stmt|;
name|struct
name|secpolicy
modifier|*
name|sp
decl_stmt|;
name|u_int
name|dir
decl_stmt|;
comment|/* sanity check */
if|if
condition|(
name|mhp
operator|==
name|NULL
operator|||
name|mhp
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_spdflush: NULL pointer is passed.\n"
argument_list|)
expr_stmt|;
name|msg0
operator|=
operator|(
expr|struct
name|sadb_msg
operator|*
operator|)
name|mhp
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|dir
operator|=
literal|0
init|;
name|dir
operator|<
name|IPSEC_DIR_MAX
condition|;
name|dir
operator|++
control|)
block|{
name|__LIST_FOREACH
argument_list|(
argument|sp
argument_list|,
argument|&sptree[dir]
argument_list|,
argument|chain
argument_list|)
block|{
name|sp
operator|->
name|state
operator|=
name|IPSEC_SPSTATE_DEAD
expr_stmt|;
block|}
block|}
block|{
name|struct
name|sadb_msg
modifier|*
name|newmsg
decl_stmt|;
name|u_int
name|len
decl_stmt|;
comment|/* create new sadb_msg to reply. */
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
expr_stmt|;
name|KMALLOC
argument_list|(
name|newmsg
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|newmsg
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"key_spdflush: No more memory.\n"
argument_list|)
expr_stmt|;
name|msg0
operator|->
name|sadb_msg_errno
operator|=
name|ENOBUFS
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|newmsg
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|mhp
index|[
literal|0
index|]
argument_list|,
operator|(
name|caddr_t
operator|)
name|newmsg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|msg0
argument_list|)
argument_list|)
expr_stmt|;
name|newmsg
operator|->
name|sadb_msg_errno
operator|=
literal|0
expr_stmt|;
name|newmsg
operator|->
name|sadb_msg_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
name|newmsg
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * SADB_SPDDUMP processing  * receive  *<base>  * from the user, and dump all SP leaves  * and send,  *<base> .....  * to the ikmpd.  *  * IN:	mhp: pointer to the pointer to each header.  * OUT:	other if success, return pointer to the message to send.  *	0 if fail.  */
end_comment

begin_function
specifier|static
name|int
name|key_spddump
parameter_list|(
name|mhp
parameter_list|,
name|so
parameter_list|,
name|target
parameter_list|)
name|caddr_t
modifier|*
name|mhp
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|int
name|target
decl_stmt|;
block|{
name|struct
name|sadb_msg
modifier|*
name|msg0
decl_stmt|;
name|struct
name|secpolicy
modifier|*
name|sp
decl_stmt|;
name|int
name|len
decl_stmt|,
name|cnt
decl_stmt|,
name|cnt_sanity
decl_stmt|;
name|struct
name|sadb_msg
modifier|*
name|newmsg
decl_stmt|;
name|u_int
name|dir
decl_stmt|;
comment|/* sanity check */
if|if
condition|(
name|mhp
operator|==
name|NULL
operator|||
name|mhp
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_spddump: NULL pointer is passed.\n"
argument_list|)
expr_stmt|;
name|msg0
operator|=
operator|(
expr|struct
name|sadb_msg
operator|*
operator|)
name|mhp
index|[
literal|0
index|]
expr_stmt|;
comment|/* search SPD entry and get buffer size. */
name|cnt
operator|=
name|cnt_sanity
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|dir
operator|=
literal|0
init|;
name|dir
operator|<
name|IPSEC_DIR_MAX
condition|;
name|dir
operator|++
control|)
block|{
name|__LIST_FOREACH
argument_list|(
argument|sp
argument_list|,
argument|&sptree[dir]
argument_list|,
argument|chain
argument_list|)
block|{
name|cnt
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cnt
operator|==
literal|0
condition|)
return|return
name|ENOENT
return|;
name|newmsg
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|dir
operator|=
literal|0
init|;
name|dir
operator|<
name|IPSEC_DIR_MAX
condition|;
name|dir
operator|++
control|)
block|{
name|__LIST_FOREACH
argument_list|(
argument|sp
argument_list|,
argument|&sptree[dir]
argument_list|,
argument|chain
argument_list|)
block|{
name|len
operator|=
name|key_getspmsglen
argument_list|(
name|sp
argument_list|)
expr_stmt|;
comment|/* making buffer */
name|KMALLOC
argument_list|(
name|newmsg
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|newmsg
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"key_spddump: No more memory.\n"
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|newmsg
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|--
name|cnt
expr_stmt|;
operator|(
name|void
operator|)
name|key_setdumpsp
argument_list|(
name|newmsg
argument_list|,
name|sp
argument_list|,
name|SADB_X_SPDDUMP
argument_list|,
name|cnt
argument_list|,
name|msg0
operator|->
name|sadb_msg_pid
argument_list|)
expr_stmt|;
name|key_sendup
argument_list|(
name|so
argument_list|,
name|newmsg
argument_list|,
name|len
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|KFREE
argument_list|(
name|newmsg
argument_list|)
expr_stmt|;
name|newmsg
operator|=
name|NULL
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|u_int
name|key_setdumpsp
parameter_list|(
name|newmsg
parameter_list|,
name|sp
parameter_list|,
name|type
parameter_list|,
name|seq
parameter_list|,
name|pid
parameter_list|)
name|struct
name|sadb_msg
modifier|*
name|newmsg
decl_stmt|;
name|struct
name|secpolicy
modifier|*
name|sp
decl_stmt|;
name|u_int8_t
name|type
decl_stmt|;
name|u_int32_t
name|seq
decl_stmt|,
name|pid
decl_stmt|;
block|{
name|u_int
name|tlen
decl_stmt|;
name|caddr_t
name|p
decl_stmt|;
name|tlen
operator|=
name|key_getspmsglen
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|p
operator|=
name|key_setsadbmsg
argument_list|(
operator|(
name|caddr_t
operator|)
name|newmsg
argument_list|,
name|type
argument_list|,
name|tlen
argument_list|,
name|SADB_SATYPE_UNSPEC
argument_list|,
name|seq
argument_list|,
name|pid
argument_list|,
name|IPSEC_MODE_ANY
argument_list|,
name|sp
operator|->
name|refcnt
argument_list|)
expr_stmt|;
name|p
operator|=
name|key_setsadbaddr
argument_list|(
name|p
argument_list|,
name|SADB_EXT_ADDRESS_SRC
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sp
operator|->
name|spidx
operator|.
name|src
argument_list|,
name|sp
operator|->
name|spidx
operator|.
name|prefs
argument_list|,
name|sp
operator|->
name|spidx
operator|.
name|ul_proto
argument_list|)
expr_stmt|;
name|p
operator|=
name|key_setsadbaddr
argument_list|(
name|p
argument_list|,
name|SADB_EXT_ADDRESS_DST
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sp
operator|->
name|spidx
operator|.
name|dst
argument_list|,
name|sp
operator|->
name|spidx
operator|.
name|prefd
argument_list|,
name|sp
operator|->
name|spidx
operator|.
name|ul_proto
argument_list|)
expr_stmt|;
block|{
name|struct
name|sadb_x_policy
modifier|*
name|tmp
decl_stmt|;
if|if
condition|(
operator|(
name|tmp
operator|=
name|key_sp2msg
argument_list|(
name|sp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"key_setdumpsp: No more memory.\n"
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
comment|/* validity check */
if|if
condition|(
name|key_getspreqmsglen
argument_list|(
name|sp
argument_list|)
operator|!=
name|PFKEY_UNUNIT64
argument_list|(
name|tmp
operator|->
name|sadb_x_policy_len
argument_list|)
condition|)
name|panic
argument_list|(
literal|"key_setdumpsp: length mismatch."
literal|"sp:%d msg:%d\n"
argument_list|,
name|key_getspreqmsglen
argument_list|(
name|sp
argument_list|)
argument_list|,
name|PFKEY_UNUNIT64
argument_list|(
name|tmp
operator|->
name|sadb_x_policy_len
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|tmp
argument_list|,
name|p
argument_list|,
name|PFKEY_UNUNIT64
argument_list|(
name|tmp
operator|->
name|sadb_x_policy_len
argument_list|)
argument_list|)
expr_stmt|;
name|KFREE
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
return|return
name|tlen
return|;
block|}
end_function

begin_comment
comment|/* get sadb message length for a SP. */
end_comment

begin_function
specifier|static
name|u_int
name|key_getspmsglen
parameter_list|(
name|sp
parameter_list|)
name|struct
name|secpolicy
modifier|*
name|sp
decl_stmt|;
block|{
name|u_int
name|tlen
decl_stmt|;
comment|/* sanity check */
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_getspmsglen: NULL pointer is passed.\n"
argument_list|)
expr_stmt|;
name|tlen
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_address
argument_list|)
operator|+
name|PFKEY_ALIGN8
argument_list|(
name|_SALENBYAF
argument_list|(
name|sp
operator|->
name|spidx
operator|.
name|src
operator|.
name|__ss_family
argument_list|)
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_address
argument_list|)
operator|+
name|PFKEY_ALIGN8
argument_list|(
name|_SALENBYAF
argument_list|(
name|sp
operator|->
name|spidx
operator|.
name|dst
operator|.
name|__ss_family
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|tlen
operator|+=
name|key_getspreqmsglen
argument_list|(
name|sp
argument_list|)
expr_stmt|;
return|return
name|tlen
return|;
block|}
end_function

begin_comment
comment|/*  * get PFKEY message length for security policy and request.  */
end_comment

begin_function
specifier|static
name|u_int
name|key_getspreqmsglen
parameter_list|(
name|sp
parameter_list|)
name|struct
name|secpolicy
modifier|*
name|sp
decl_stmt|;
block|{
name|u_int
name|tlen
decl_stmt|;
name|tlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_x_policy
argument_list|)
expr_stmt|;
comment|/* if is the policy for ipsec ? */
if|if
condition|(
name|sp
operator|->
name|policy
operator|!=
name|IPSEC_POLICY_IPSEC
condition|)
return|return
name|tlen
return|;
comment|/* get length of ipsec requests */
block|{
name|struct
name|ipsecrequest
modifier|*
name|isr
decl_stmt|;
name|int
name|len
decl_stmt|;
for|for
control|(
name|isr
operator|=
name|sp
operator|->
name|req
init|;
name|isr
operator|!=
name|NULL
condition|;
name|isr
operator|=
name|isr
operator|->
name|next
control|)
block|{
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_x_ipsecrequest
argument_list|)
operator|+
name|isr
operator|->
name|saidx
operator|.
name|src
operator|.
name|__ss_len
operator|+
name|isr
operator|->
name|saidx
operator|.
name|dst
operator|.
name|__ss_len
expr_stmt|;
name|tlen
operator|+=
name|PFKEY_ALIGN8
argument_list|(
name|len
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|tlen
return|;
block|}
end_function

begin_comment
comment|/* %%% SAD management */
end_comment

begin_comment
comment|/*  * allocating a memory for new SA head, and copy from the values of mhp.  * OUT:	NULL	: failure due to the lack of memory.  *	others	: pointer to new SA head.  */
end_comment

begin_function
specifier|static
name|struct
name|secashead
modifier|*
name|key_newsah
parameter_list|(
name|saidx
parameter_list|)
name|struct
name|secasindex
modifier|*
name|saidx
decl_stmt|;
block|{
name|struct
name|secashead
modifier|*
name|newsah
decl_stmt|;
name|u_int
name|stateidx
decl_stmt|;
comment|/* sanity check */
if|if
condition|(
name|saidx
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_newsaidx: NULL pointer is passed.\n"
argument_list|)
expr_stmt|;
name|KMALLOC
argument_list|(
name|newsah
argument_list|,
expr|struct
name|secashead
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|secashead
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newsah
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|newsah
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|secashead
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|saidx
argument_list|,
operator|&
name|newsah
operator|->
name|saidx
argument_list|,
sizeof|sizeof
argument_list|(
name|newsah
operator|->
name|saidx
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|stateidx
operator|=
literal|0
init|;
name|stateidx
operator|<
name|_ARRAYLEN
argument_list|(
name|saorder_state_any
argument_list|)
condition|;
name|stateidx
operator|++
control|)
block|{
name|LIST_INIT
argument_list|(
operator|&
name|newsah
operator|->
name|savtree
index|[
name|saorder_state_any
index|[
name|stateidx
index|]
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* add to saidxtree */
name|newsah
operator|->
name|state
operator|=
name|SADB_SASTATE_MATURE
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|sahtree
argument_list|,
name|newsah
argument_list|,
name|chain
argument_list|)
expr_stmt|;
return|return
operator|(
name|newsah
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * delete SA index and all SA registerd.  */
end_comment

begin_function
specifier|static
name|void
name|key_delsah
parameter_list|(
name|sah
parameter_list|)
name|struct
name|secashead
modifier|*
name|sah
decl_stmt|;
block|{
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|,
modifier|*
name|nextsav
decl_stmt|;
name|u_int
name|stateidx
decl_stmt|,
name|state
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* sanity check */
if|if
condition|(
name|sah
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_delsah: NULL pointer is passed.\n"
argument_list|)
expr_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
comment|/*called from softclock()*/
comment|/* remove from tree of SA index */
if|if
condition|(
name|__LIST_CHAINED
argument_list|(
name|sah
argument_list|)
condition|)
name|LIST_REMOVE
argument_list|(
name|sah
argument_list|,
name|chain
argument_list|)
expr_stmt|;
comment|/* searching all SA registerd in the secindex. */
for|for
control|(
name|stateidx
operator|=
literal|0
init|;
name|stateidx
operator|<
name|_ARRAYLEN
argument_list|(
name|saorder_state_any
argument_list|)
condition|;
name|stateidx
operator|++
control|)
block|{
name|state
operator|=
name|saorder_state_any
index|[
name|stateidx
index|]
expr_stmt|;
for|for
control|(
name|sav
operator|=
operator|(
expr|struct
name|secasvar
operator|*
operator|)
name|LIST_FIRST
argument_list|(
operator|&
name|sah
operator|->
name|savtree
index|[
name|state
index|]
argument_list|)
init|;
name|sav
operator|!=
name|NULL
condition|;
name|sav
operator|=
name|nextsav
control|)
block|{
name|nextsav
operator|=
name|LIST_NEXT
argument_list|(
name|sav
argument_list|,
name|chain
argument_list|)
expr_stmt|;
comment|/* sanity check */
name|KEY_CHKSASTATE
argument_list|(
name|state
argument_list|,
name|sav
operator|->
name|state
argument_list|,
literal|"key_delsah"
argument_list|)
expr_stmt|;
comment|/* remove back pointer */
name|sav
operator|->
name|sah
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|refcnt
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"key_delsah: why refcnt< 0 ?, "
literal|"sav->refcnt=%d\n"
argument_list|,
name|sav
operator|->
name|refcnt
argument_list|)
expr_stmt|;
block|}
name|key_freesav
argument_list|(
name|sav
argument_list|)
expr_stmt|;
name|sav
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sah
operator|->
name|sa_route
operator|.
name|ro_rt
condition|)
block|{
name|RTFREE
argument_list|(
name|sah
operator|->
name|sa_route
operator|.
name|ro_rt
argument_list|)
expr_stmt|;
name|sah
operator|->
name|sa_route
operator|.
name|ro_rt
operator|=
operator|(
expr|struct
name|rtentry
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
name|KFREE
argument_list|(
name|sah
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * allocating a new SA with LARVAL state.  key_add() and key_getspi() call,  * and copy the values of mhp into new buffer.  * When SAD message type is GETSPI:  *	to set sequence number from acq_seq++,  *	to set zero to SPI.  *	not to call key_setsava().  * OUT:	NULL	: fail  *	others	: pointer to new secasvar.  */
end_comment

begin_function
specifier|static
name|struct
name|secasvar
modifier|*
name|key_newsav
parameter_list|(
name|mhp
parameter_list|,
name|sah
parameter_list|)
name|caddr_t
modifier|*
name|mhp
decl_stmt|;
name|struct
name|secashead
modifier|*
name|sah
decl_stmt|;
block|{
name|struct
name|secasvar
modifier|*
name|newsav
decl_stmt|;
name|struct
name|sadb_msg
modifier|*
name|msg0
decl_stmt|;
comment|/* sanity check */
if|if
condition|(
name|mhp
operator|==
name|NULL
operator|||
name|mhp
index|[
literal|0
index|]
operator|==
name|NULL
operator|||
name|sah
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_newsa: NULL pointer is passed.\n"
argument_list|)
expr_stmt|;
name|msg0
operator|=
operator|(
expr|struct
name|sadb_msg
operator|*
operator|)
name|mhp
index|[
literal|0
index|]
expr_stmt|;
name|KMALLOC
argument_list|(
name|newsav
argument_list|,
expr|struct
name|secasvar
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|secasvar
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newsav
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"key_newsa: No more memory.\n"
argument_list|)
expr_stmt|;
name|msg0
operator|->
name|sadb_msg_errno
operator|=
name|ENOBUFS
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|newsav
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|secasvar
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|msg0
operator|->
name|sadb_msg_type
condition|)
block|{
case|case
name|SADB_GETSPI
case|:
name|newsav
operator|->
name|spi
operator|=
literal|0
expr_stmt|;
comment|/* sync sequence number */
if|if
condition|(
name|msg0
operator|->
name|sadb_msg_seq
operator|==
literal|0
condition|)
name|newsav
operator|->
name|seq
operator|=
operator|(
name|acq_seq
operator|=
operator|(
name|acq_seq
operator|==
operator|~
literal|0
condition|?
literal|1
else|:
operator|++
name|acq_seq
operator|)
operator|)
expr_stmt|;
else|else
name|newsav
operator|->
name|seq
operator|=
name|msg0
operator|->
name|sadb_msg_seq
expr_stmt|;
break|break;
case|case
name|SADB_ADD
case|:
comment|/* sanity check */
if|if
condition|(
name|mhp
index|[
name|SADB_EXT_SA
index|]
operator|==
name|NULL
condition|)
block|{
name|KFREE
argument_list|(
name|newsav
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"key_newsa: invalid message is passed.\n"
argument_list|)
expr_stmt|;
name|msg0
operator|->
name|sadb_msg_errno
operator|=
name|EINVAL
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|newsav
operator|->
name|spi
operator|=
operator|(
operator|(
expr|struct
name|sadb_sa
operator|*
operator|)
name|mhp
index|[
name|SADB_EXT_SA
index|]
operator|)
operator|->
name|sadb_sa_spi
expr_stmt|;
name|newsav
operator|->
name|seq
operator|=
name|msg0
operator|->
name|sadb_msg_seq
expr_stmt|;
break|break;
default|default:
name|KFREE
argument_list|(
name|newsav
argument_list|)
expr_stmt|;
name|msg0
operator|->
name|sadb_msg_errno
operator|=
name|EINVAL
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* copy sav values */
if|if
condition|(
name|msg0
operator|->
name|sadb_msg_type
operator|!=
name|SADB_GETSPI
operator|&&
name|key_setsaval
argument_list|(
name|newsav
argument_list|,
name|mhp
argument_list|)
condition|)
block|{
name|KFREE
argument_list|(
name|newsav
argument_list|)
expr_stmt|;
comment|/* msg0->sadb_msg_errno is set at key_setsaval. */
return|return
name|NULL
return|;
block|}
comment|/* reset tick */
name|newsav
operator|->
name|tick
operator|=
literal|0
expr_stmt|;
name|newsav
operator|->
name|pid
operator|=
name|msg0
operator|->
name|sadb_msg_pid
expr_stmt|;
comment|/* add to satree */
name|newsav
operator|->
name|sah
operator|=
name|sah
expr_stmt|;
name|newsav
operator|->
name|refcnt
operator|=
literal|1
expr_stmt|;
name|newsav
operator|->
name|state
operator|=
name|SADB_SASTATE_LARVAL
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|sah
operator|->
name|savtree
index|[
name|SADB_SASTATE_LARVAL
index|]
argument_list|,
name|newsav
argument_list|,
name|chain
argument_list|)
expr_stmt|;
return|return
name|newsav
return|;
block|}
end_function

begin_comment
comment|/*  * free() SA variable entry.  */
end_comment

begin_function
specifier|static
name|void
name|key_delsav
parameter_list|(
name|sav
parameter_list|)
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|;
block|{
comment|/* sanity check */
if|if
condition|(
name|sav
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_delsav: NULL pointer is passed.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|refcnt
operator|>
literal|0
condition|)
return|return;
comment|/* can't free */
comment|/* remove from SA header */
if|if
condition|(
name|__LIST_CHAINED
argument_list|(
name|sav
argument_list|)
condition|)
name|LIST_REMOVE
argument_list|(
name|sav
argument_list|,
name|chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|key_auth
operator|!=
name|NULL
condition|)
name|KFREE
argument_list|(
name|sav
operator|->
name|key_auth
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|key_enc
operator|!=
name|NULL
condition|)
name|KFREE
argument_list|(
name|sav
operator|->
name|key_enc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|replay
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|sav
operator|->
name|replay
operator|->
name|bitmap
operator|!=
name|NULL
condition|)
name|KFREE
argument_list|(
name|sav
operator|->
name|replay
operator|->
name|bitmap
argument_list|)
expr_stmt|;
name|KFREE
argument_list|(
name|sav
operator|->
name|replay
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sav
operator|->
name|lft_c
operator|!=
name|NULL
condition|)
name|KFREE
argument_list|(
name|sav
operator|->
name|lft_c
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|lft_h
operator|!=
name|NULL
condition|)
name|KFREE
argument_list|(
name|sav
operator|->
name|lft_h
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|lft_s
operator|!=
name|NULL
condition|)
name|KFREE
argument_list|(
name|sav
operator|->
name|lft_s
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|iv
operator|!=
name|NULL
condition|)
name|KFREE
argument_list|(
name|sav
operator|->
name|iv
argument_list|)
expr_stmt|;
if|#
directive|if
name|notyet
if|if
condition|(
name|sav
operator|->
name|misc1
operator|!=
name|NULL
condition|)
name|KFREE
argument_list|(
name|sav
operator|->
name|misc1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|misc2
operator|!=
name|NULL
condition|)
name|KFREE
argument_list|(
name|sav
operator|->
name|misc2
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|misc3
operator|!=
name|NULL
condition|)
name|KFREE
argument_list|(
name|sav
operator|->
name|misc3
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sav
operator|->
name|sah
operator|=
name|NULL
expr_stmt|;
comment|/* XXX for making sure.  See key_checkrequest(), 		 * Refcnt may be suspicious. */
name|KFREE
argument_list|(
name|sav
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * search SAD.  * OUT:  *	NULL	: not found  *	others	: found, pointer to a SA.  */
end_comment

begin_function
specifier|static
name|struct
name|secashead
modifier|*
name|key_getsah
parameter_list|(
name|saidx
parameter_list|)
name|struct
name|secasindex
modifier|*
name|saidx
decl_stmt|;
block|{
name|struct
name|secashead
modifier|*
name|sah
decl_stmt|;
name|__LIST_FOREACH
argument_list|(
argument|sah
argument_list|,
argument|&sahtree
argument_list|,
argument|chain
argument_list|)
block|{
if|if
condition|(
name|sah
operator|->
name|state
operator|==
name|SADB_SASTATE_DEAD
condition|)
continue|continue;
if|if
condition|(
name|key_cmpsaidx_exactly
argument_list|(
operator|&
name|sah
operator|->
name|saidx
argument_list|,
name|saidx
argument_list|)
condition|)
return|return
operator|(
name|sah
operator|)
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * check not to be duplicated SPI.  * NOTE: this function is too slow due to searching all SAD.  * OUT:  *	NULL	: not found  *	others	: found, pointer to a SA.  */
end_comment

begin_function
specifier|static
name|struct
name|secasvar
modifier|*
name|key_checkspidup
parameter_list|(
name|saidx
parameter_list|,
name|spi
parameter_list|)
name|struct
name|secasindex
modifier|*
name|saidx
decl_stmt|;
name|u_int32_t
name|spi
decl_stmt|;
block|{
name|struct
name|secashead
modifier|*
name|sah
decl_stmt|;
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|;
comment|/* check address family */
if|if
condition|(
name|saidx
operator|->
name|src
operator|.
name|__ss_family
operator|!=
name|saidx
operator|->
name|src
operator|.
name|__ss_family
condition|)
block|{
name|printf
argument_list|(
literal|"key_checkspidup: address family mismatched.\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* check all SAD */
name|__LIST_FOREACH
argument_list|(
argument|sah
argument_list|,
argument|&sahtree
argument_list|,
argument|chain
argument_list|)
block|{
if|if
condition|(
operator|!
name|key_ismyaddr
argument_list|(
name|sah
operator|->
name|saidx
operator|.
name|dst
operator|.
name|__ss_family
argument_list|,
name|_INADDRBYSA
argument_list|(
operator|&
name|sah
operator|->
name|saidx
operator|.
name|dst
argument_list|)
argument_list|)
condition|)
continue|continue;
name|sav
operator|=
name|key_getsavbyspi
argument_list|(
name|sah
argument_list|,
name|spi
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|!=
name|NULL
condition|)
return|return
name|sav
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * search SAD litmited alive SA, protocol, SPI.  * OUT:  *	NULL	: not found  *	others	: found, pointer to a SA.  */
end_comment

begin_function
specifier|static
name|struct
name|secasvar
modifier|*
name|key_getsavbyspi
parameter_list|(
name|sah
parameter_list|,
name|spi
parameter_list|)
name|struct
name|secashead
modifier|*
name|sah
decl_stmt|;
name|u_int32_t
name|spi
decl_stmt|;
block|{
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|;
name|u_int
name|stateidx
decl_stmt|,
name|state
decl_stmt|;
comment|/* search all status */
for|for
control|(
name|stateidx
operator|=
literal|0
init|;
name|stateidx
operator|<
name|_ARRAYLEN
argument_list|(
name|saorder_state_alive
argument_list|)
condition|;
name|stateidx
operator|++
control|)
block|{
name|state
operator|=
name|saorder_state_alive
index|[
name|stateidx
index|]
expr_stmt|;
name|__LIST_FOREACH
argument_list|(
argument|sav
argument_list|,
argument|&sah->savtree[state]
argument_list|,
argument|chain
argument_list|)
block|{
comment|/* sanity check */
if|if
condition|(
name|sav
operator|->
name|state
operator|!=
name|state
condition|)
block|{
name|printf
argument_list|(
literal|"key_getsavbyspi: "
literal|"invalid sav->state "
literal|"(queue: %d SA: %d)\n"
argument_list|,
name|state
argument_list|,
name|sav
operator|->
name|state
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|sav
operator|->
name|spi
operator|==
name|spi
condition|)
return|return
name|sav
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * copy SA values from PF_KEY message except *SPI, SEQ, PID, STATE and TYPE*.  * You must update these if need.  * OUT:	0:	success.  *	1:	failure. set errno to (mhp[0])->sadb_msg_errno.  */
end_comment

begin_function
specifier|static
name|int
name|key_setsaval
parameter_list|(
name|sav
parameter_list|,
name|mhp
parameter_list|)
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|;
name|caddr_t
modifier|*
name|mhp
decl_stmt|;
block|{
name|struct
name|sadb_msg
modifier|*
name|msg0
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* sanity check */
if|if
condition|(
name|mhp
operator|==
name|NULL
operator|||
name|mhp
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_setsaval: NULL pointer is passed.\n"
argument_list|)
expr_stmt|;
name|msg0
operator|=
operator|(
expr|struct
name|sadb_msg
operator|*
operator|)
name|mhp
index|[
literal|0
index|]
expr_stmt|;
comment|/* initialization */
name|sav
operator|->
name|replay
operator|=
name|NULL
expr_stmt|;
name|sav
operator|->
name|key_auth
operator|=
name|NULL
expr_stmt|;
name|sav
operator|->
name|key_enc
operator|=
name|NULL
expr_stmt|;
name|sav
operator|->
name|iv
operator|=
name|NULL
expr_stmt|;
name|sav
operator|->
name|lft_c
operator|=
name|NULL
expr_stmt|;
name|sav
operator|->
name|lft_h
operator|=
name|NULL
expr_stmt|;
name|sav
operator|->
name|lft_s
operator|=
name|NULL
expr_stmt|;
comment|/* SA */
if|if
condition|(
name|mhp
index|[
name|SADB_EXT_SA
index|]
operator|!=
name|NULL
condition|)
block|{
name|struct
name|sadb_sa
modifier|*
name|sa0
init|=
operator|(
expr|struct
name|sadb_sa
operator|*
operator|)
name|mhp
index|[
name|SADB_EXT_SA
index|]
decl_stmt|;
name|sav
operator|->
name|alg_auth
operator|=
name|sa0
operator|->
name|sadb_sa_auth
expr_stmt|;
name|sav
operator|->
name|alg_enc
operator|=
name|sa0
operator|->
name|sadb_sa_encrypt
expr_stmt|;
name|sav
operator|->
name|flags
operator|=
name|sa0
operator|->
name|sadb_sa_flags
expr_stmt|;
comment|/* replay window */
if|if
condition|(
operator|(
name|sa0
operator|->
name|sadb_sa_flags
operator|&
name|SADB_X_EXT_OLD
operator|)
operator|==
literal|0
condition|)
block|{
name|KMALLOC
argument_list|(
name|sav
operator|->
name|replay
argument_list|,
expr|struct
name|secreplay
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|secreplay
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|replay
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"key_setsaval: No more memory.\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|bzero
argument_list|(
name|sav
operator|->
name|replay
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|secreplay
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sav
operator|->
name|replay
operator|->
name|wsize
operator|=
name|sa0
operator|->
name|sadb_sa_replay
operator|)
operator|!=
literal|0
condition|)
block|{
name|KMALLOC
argument_list|(
name|sav
operator|->
name|replay
operator|->
name|bitmap
argument_list|,
name|caddr_t
argument_list|,
name|sav
operator|->
name|replay
operator|->
name|wsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|replay
operator|->
name|bitmap
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"key_setsaval: "
literal|"No more memory.\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|bzero
argument_list|(
name|sav
operator|->
name|replay
operator|->
name|bitmap
argument_list|,
name|sa0
operator|->
name|sadb_sa_replay
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Authentication keys */
if|if
condition|(
name|mhp
index|[
name|SADB_EXT_KEY_AUTH
index|]
operator|!=
name|NULL
condition|)
block|{
name|struct
name|sadb_key
modifier|*
name|key0
decl_stmt|;
name|u_int
name|len
decl_stmt|;
name|key0
operator|=
operator|(
expr|struct
name|sadb_key
operator|*
operator|)
name|mhp
index|[
name|SADB_EXT_KEY_AUTH
index|]
expr_stmt|;
name|len
operator|=
name|PFKEY_UNUNIT64
argument_list|(
name|key0
operator|->
name|sadb_key_len
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_key
argument_list|)
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
switch|switch
condition|(
name|msg0
operator|->
name|sadb_msg_satype
condition|)
block|{
case|case
name|SADB_SATYPE_AH
case|:
case|case
name|SADB_SATYPE_ESP
case|:
if|if
condition|(
name|len
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_key
argument_list|)
operator|&&
name|sav
operator|->
name|alg_auth
operator|!=
name|SADB_AALG_NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
break|break;
case|case
name|SADB_X_SATYPE_IPCOMP
case|:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"key_setsaval: invalid key_auth values.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|KEY_NEWBUF
argument_list|(
name|sav
operator|->
name|key_auth
argument_list|,
expr|struct
name|sadb_key
operator|*
argument_list|,
name|key0
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|key_auth
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"key_setsaval: No more memory.\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* make length shift up for kernel*/
name|sav
operator|->
name|key_auth
operator|->
name|sadb_key_len
operator|=
name|len
expr_stmt|;
block|}
comment|/* Encryption key */
if|if
condition|(
name|mhp
index|[
name|SADB_EXT_KEY_ENCRYPT
index|]
operator|!=
name|NULL
condition|)
block|{
name|struct
name|sadb_key
modifier|*
name|key0
decl_stmt|;
name|u_int
name|len
decl_stmt|;
name|key0
operator|=
operator|(
expr|struct
name|sadb_key
operator|*
operator|)
name|mhp
index|[
name|SADB_EXT_KEY_ENCRYPT
index|]
expr_stmt|;
name|len
operator|=
name|PFKEY_UNUNIT64
argument_list|(
name|key0
operator|->
name|sadb_key_len
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_key
argument_list|)
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
switch|switch
condition|(
name|msg0
operator|->
name|sadb_msg_satype
condition|)
block|{
case|case
name|SADB_SATYPE_ESP
case|:
if|if
condition|(
name|len
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_key
argument_list|)
operator|&&
name|sav
operator|->
name|alg_enc
operator|!=
name|SADB_EALG_NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
break|break;
case|case
name|SADB_SATYPE_AH
case|:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|SADB_X_SATYPE_IPCOMP
case|:
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"key_setsatval: invalid key_enc value.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|KEY_NEWBUF
argument_list|(
name|sav
operator|->
name|key_enc
argument_list|,
expr|struct
name|sadb_key
operator|*
argument_list|,
name|key0
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|key_enc
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"key_setsaval: No more memory.\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* make length shift up for kernel*/
name|sav
operator|->
name|key_enc
operator|->
name|sadb_key_len
operator|=
name|len
expr_stmt|;
block|}
comment|/* set iv */
name|sav
operator|->
name|ivlen
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|msg0
operator|->
name|sadb_msg_satype
condition|)
block|{
case|case
name|SADB_SATYPE_ESP
case|:
ifdef|#
directive|ifdef
name|IPSEC_ESP
block|{
name|struct
name|esp_algorithm
modifier|*
name|algo
decl_stmt|;
name|algo
operator|=
operator|&
name|esp_algorithms
index|[
name|sav
operator|->
name|alg_enc
index|]
expr_stmt|;
if|if
condition|(
name|algo
operator|&&
name|algo
operator|->
name|ivlen
condition|)
name|sav
operator|->
name|ivlen
operator|=
call|(
modifier|*
name|algo
operator|->
name|ivlen
call|)
argument_list|(
name|sav
argument_list|)
expr_stmt|;
name|KMALLOC
argument_list|(
name|sav
operator|->
name|iv
argument_list|,
name|caddr_t
argument_list|,
name|sav
operator|->
name|ivlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|iv
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"key_setsaval: No more memory.\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* initialize ? */
break|break;
block|}
else|#
directive|else
break|break;
endif|#
directive|endif
case|case
name|SADB_SATYPE_AH
case|:
break|break;
default|default:
name|printf
argument_list|(
literal|"key_setsaval: invalid SA type.\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* reset tick */
name|sav
operator|->
name|tick
operator|=
literal|0
expr_stmt|;
comment|/* make lifetime for CURRENT */
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|KMALLOC
argument_list|(
name|sav
operator|->
name|lft_c
argument_list|,
expr|struct
name|sadb_lifetime
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_lifetime
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|lft_c
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"key_setsaval: No more memory.\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|microtime
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
name|sav
operator|->
name|lft_c
operator|->
name|sadb_lifetime_len
operator|=
name|PFKEY_UNIT64
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_lifetime
argument_list|)
argument_list|)
expr_stmt|;
name|sav
operator|->
name|lft_c
operator|->
name|sadb_lifetime_exttype
operator|=
name|SADB_EXT_LIFETIME_CURRENT
expr_stmt|;
name|sav
operator|->
name|lft_c
operator|->
name|sadb_lifetime_allocations
operator|=
literal|0
expr_stmt|;
name|sav
operator|->
name|lft_c
operator|->
name|sadb_lifetime_bytes
operator|=
literal|0
expr_stmt|;
name|sav
operator|->
name|lft_c
operator|->
name|sadb_lifetime_addtime
operator|=
name|tv
operator|.
name|tv_sec
expr_stmt|;
name|sav
operator|->
name|lft_c
operator|->
name|sadb_lifetime_usetime
operator|=
literal|0
expr_stmt|;
block|}
comment|/* lifetimes for HARD and SOFT */
block|{
name|struct
name|sadb_lifetime
modifier|*
name|lft0
decl_stmt|;
name|lft0
operator|=
operator|(
expr|struct
name|sadb_lifetime
operator|*
operator|)
name|mhp
index|[
name|SADB_EXT_LIFETIME_HARD
index|]
expr_stmt|;
if|if
condition|(
name|lft0
operator|!=
name|NULL
condition|)
block|{
name|KEY_NEWBUF
argument_list|(
name|sav
operator|->
name|lft_h
argument_list|,
expr|struct
name|sadb_lifetime
operator|*
argument_list|,
name|lft0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lft0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|lft_h
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"key_setsaval: No more memory.\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* to be initialize ? */
block|}
name|lft0
operator|=
operator|(
expr|struct
name|sadb_lifetime
operator|*
operator|)
name|mhp
index|[
name|SADB_EXT_LIFETIME_SOFT
index|]
expr_stmt|;
if|if
condition|(
name|lft0
operator|!=
name|NULL
condition|)
block|{
name|KEY_NEWBUF
argument_list|(
name|sav
operator|->
name|lft_s
argument_list|,
expr|struct
name|sadb_lifetime
operator|*
argument_list|,
name|lft0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lft0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|lft_s
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"key_setsaval: No more memory.\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* to be initialize ? */
block|}
block|}
name|msg0
operator|->
name|sadb_msg_errno
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
name|err
label|:
comment|/* initialization */
if|if
condition|(
name|sav
operator|->
name|replay
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|sav
operator|->
name|replay
operator|->
name|bitmap
operator|!=
name|NULL
condition|)
name|KFREE
argument_list|(
name|sav
operator|->
name|replay
operator|->
name|bitmap
argument_list|)
expr_stmt|;
name|KFREE
argument_list|(
name|sav
operator|->
name|replay
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sav
operator|->
name|key_auth
operator|!=
name|NULL
condition|)
name|KFREE
argument_list|(
name|sav
operator|->
name|key_auth
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|key_enc
operator|!=
name|NULL
condition|)
name|KFREE
argument_list|(
name|sav
operator|->
name|key_enc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|iv
operator|!=
name|NULL
condition|)
name|KFREE
argument_list|(
name|sav
operator|->
name|iv
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|lft_c
operator|!=
name|NULL
condition|)
name|KFREE
argument_list|(
name|sav
operator|->
name|lft_c
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|lft_h
operator|!=
name|NULL
condition|)
name|KFREE
argument_list|(
name|sav
operator|->
name|lft_h
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|lft_s
operator|!=
name|NULL
condition|)
name|KFREE
argument_list|(
name|sav
operator|->
name|lft_s
argument_list|)
expr_stmt|;
name|msg0
operator|->
name|sadb_msg_errno
operator|=
name|error
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * get message buffer length.  */
end_comment

begin_function
specifier|static
name|u_int
name|key_getmsglen
parameter_list|(
name|sav
parameter_list|)
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|;
block|{
name|int
name|len
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
decl_stmt|;
name|len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_sa
argument_list|)
expr_stmt|;
name|len
operator|+=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_address
argument_list|)
operator|+
name|PFKEY_ALIGN8
argument_list|(
name|_SALENBYAF
argument_list|(
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|src
operator|.
name|__ss_family
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|len
operator|+=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_address
argument_list|)
operator|+
name|PFKEY_ALIGN8
argument_list|(
name|_SALENBYAF
argument_list|(
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|dst
operator|.
name|__ss_family
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|key_auth
operator|!=
name|NULL
condition|)
name|len
operator|+=
name|sav
operator|->
name|key_auth
operator|->
name|sadb_key_len
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|key_enc
operator|!=
name|NULL
condition|)
name|len
operator|+=
name|sav
operator|->
name|key_enc
operator|->
name|sadb_key_len
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|lft_c
operator|!=
name|NULL
condition|)
name|len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_lifetime
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|lft_h
operator|!=
name|NULL
condition|)
name|len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_lifetime
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|lft_s
operator|!=
name|NULL
condition|)
name|len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_lifetime
argument_list|)
expr_stmt|;
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/*  * validation with a secasvar entry, and set SADB_SATYPE_MATURE.  * OUT:	0:	valid  *	other:	errno  */
end_comment

begin_function
specifier|static
name|int
name|key_mature
parameter_list|(
name|sav
parameter_list|)
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|;
block|{
name|int
name|mature
decl_stmt|;
name|int
name|checkmask
init|=
literal|0
decl_stmt|;
comment|/* 2^0: ealg  2^1: aalg  2^2: calg */
name|int
name|mustmask
init|=
literal|0
decl_stmt|;
comment|/* 2^0: ealg  2^1: aalg  2^2: calg */
name|mature
operator|=
literal|0
expr_stmt|;
comment|/* check SPI value */
if|if
condition|(
name|ntohl
argument_list|(
name|sav
operator|->
name|spi
argument_list|)
operator|>=
literal|0
operator|&&
name|ntohl
argument_list|(
name|sav
operator|->
name|spi
argument_list|)
operator|<=
literal|255
condition|)
block|{
name|printf
argument_list|(
literal|"key_mature: illegal range of SPI %d.\n"
argument_list|,
name|sav
operator|->
name|spi
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
comment|/* check satype */
switch|switch
condition|(
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|proto
condition|)
block|{
case|case
name|IPPROTO_ESP
case|:
comment|/* check flags */
if|if
condition|(
operator|(
name|sav
operator|->
name|flags
operator|&
name|SADB_X_EXT_OLD
operator|)
operator|&&
operator|(
name|sav
operator|->
name|flags
operator|&
name|SADB_X_EXT_DERIV
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"key_mature: "
literal|"invalid flag (derived) given to old-esp.\n"
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|checkmask
operator|=
literal|3
expr_stmt|;
name|mustmask
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|IPPROTO_AH
case|:
comment|/* check flags */
if|if
condition|(
name|sav
operator|->
name|flags
operator|&
name|SADB_X_EXT_DERIV
condition|)
block|{
name|printf
argument_list|(
literal|"key_mature: "
literal|"invalid flag (derived) given to AH SA.\n"
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
name|sav
operator|->
name|alg_enc
operator|!=
name|SADB_EALG_NONE
condition|)
block|{
name|printf
argument_list|(
literal|"key_mature: "
literal|"protocol and algorithm mismated.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|checkmask
operator|=
literal|2
expr_stmt|;
name|mustmask
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"key_mature: Invalid satype.\n"
argument_list|)
expr_stmt|;
return|return
name|EPROTONOSUPPORT
return|;
block|}
comment|/* check authentication algorithm */
if|if
condition|(
operator|(
name|checkmask
operator|&
literal|2
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|ah_algorithm
modifier|*
name|algo
decl_stmt|;
name|int
name|keylen
decl_stmt|;
comment|/* XXX: should use algorithm map to check. */
switch|switch
condition|(
name|sav
operator|->
name|alg_auth
condition|)
block|{
case|case
name|SADB_AALG_NONE
case|:
case|case
name|SADB_AALG_MD5HMAC
case|:
case|case
name|SADB_AALG_SHA1HMAC
case|:
case|case
name|SADB_AALG_MD5
case|:
case|case
name|SADB_AALG_SHA
case|:
case|case
name|SADB_AALG_NULL
case|:
break|break;
default|default:
name|printf
argument_list|(
literal|"key_mature: "
literal|"unknown authentication algorithm.\n"
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
comment|/* algorithm-dependent check */
name|algo
operator|=
operator|&
name|ah_algorithms
index|[
name|sav
operator|->
name|alg_auth
index|]
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|key_auth
condition|)
name|keylen
operator|=
name|sav
operator|->
name|key_auth
operator|->
name|sadb_key_bits
expr_stmt|;
else|else
name|keylen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|keylen
operator|<
name|algo
operator|->
name|keymin
operator|||
name|algo
operator|->
name|keymax
operator|<
name|keylen
condition|)
block|{
name|printf
argument_list|(
literal|"key_mature: invalid AH key length %d "
literal|"(%d-%d allowed)\n"
argument_list|,
name|keylen
argument_list|,
name|algo
operator|->
name|keymin
argument_list|,
name|algo
operator|->
name|keymax
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
name|algo
operator|->
name|mature
condition|)
block|{
if|if
condition|(
call|(
modifier|*
name|algo
operator|->
name|mature
call|)
argument_list|(
name|sav
argument_list|)
condition|)
block|{
comment|/* message generated in per-algorithm function*/
return|return
name|EINVAL
return|;
block|}
else|else
name|mature
operator|=
name|SADB_SATYPE_AH
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|mustmask
operator|&
literal|2
operator|)
operator|!=
literal|0
operator|&&
name|mature
operator|!=
name|SADB_SATYPE_AH
condition|)
return|return
name|EINVAL
return|;
block|}
comment|/* check encryption algorithm */
if|if
condition|(
operator|(
name|checkmask
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|IPSEC_ESP
name|struct
name|esp_algorithm
modifier|*
name|algo
decl_stmt|;
name|int
name|keylen
decl_stmt|;
switch|switch
condition|(
name|sav
operator|->
name|alg_enc
condition|)
block|{
case|case
name|SADB_EALG_NONE
case|:
case|case
name|SADB_EALG_DESCBC
case|:
case|case
name|SADB_EALG_3DESCBC
case|:
case|case
name|SADB_EALG_NULL
case|:
case|case
name|SADB_EALG_BLOWFISHCBC
case|:
case|case
name|SADB_EALG_CAST128CBC
case|:
case|case
name|SADB_EALG_RC5CBC
case|:
break|break;
default|default:
name|printf
argument_list|(
literal|"key_mature: unknown encryption algorithm.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* algorithm-dependent check */
name|algo
operator|=
operator|&
name|esp_algorithms
index|[
name|sav
operator|->
name|alg_enc
index|]
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|key_enc
condition|)
name|keylen
operator|=
name|sav
operator|->
name|key_enc
operator|->
name|sadb_key_bits
expr_stmt|;
else|else
name|keylen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|keylen
operator|<
name|algo
operator|->
name|keymin
operator|||
name|algo
operator|->
name|keymax
operator|<
name|keylen
condition|)
block|{
name|printf
argument_list|(
literal|"key_mature: invalid ESP key length %d "
literal|"(%d-%d allowed)\n"
argument_list|,
name|keylen
argument_list|,
name|algo
operator|->
name|keymin
argument_list|,
name|algo
operator|->
name|keymax
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
name|algo
operator|->
name|mature
condition|)
block|{
if|if
condition|(
call|(
modifier|*
name|algo
operator|->
name|mature
call|)
argument_list|(
name|sav
argument_list|)
condition|)
block|{
comment|/* message generated in per-algorithm function*/
return|return
name|EINVAL
return|;
block|}
else|else
name|mature
operator|=
name|SADB_SATYPE_ESP
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|mustmask
operator|&
literal|1
operator|)
operator|!=
literal|0
operator|&&
name|mature
operator|!=
name|SADB_SATYPE_ESP
condition|)
return|return
name|EINVAL
return|;
else|#
directive|else
name|printf
argument_list|(
literal|"key_mature: ESP not supported in this configuration\n"
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
endif|#
directive|endif
block|}
name|key_sa_chgstate
argument_list|(
name|sav
argument_list|,
name|SADB_SASTATE_MATURE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * subroutine for SADB_GET and SADB_DUMP.  * the buf must be allocated sufficent space.  */
end_comment

begin_function
specifier|static
name|u_int
name|key_setdumpsa
parameter_list|(
name|newmsg
parameter_list|,
name|sav
parameter_list|,
name|type
parameter_list|,
name|satype
parameter_list|,
name|seq
parameter_list|,
name|pid
parameter_list|)
name|struct
name|sadb_msg
modifier|*
name|newmsg
decl_stmt|;
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|;
name|u_int8_t
name|type
decl_stmt|,
name|satype
decl_stmt|;
name|u_int32_t
name|seq
decl_stmt|,
name|pid
decl_stmt|;
block|{
name|u_int
name|tlen
decl_stmt|;
name|caddr_t
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|tlen
operator|=
name|key_getmsglen
argument_list|(
name|sav
argument_list|)
expr_stmt|;
name|p
operator|=
name|key_setsadbmsg
argument_list|(
operator|(
name|caddr_t
operator|)
name|newmsg
argument_list|,
name|type
argument_list|,
name|tlen
argument_list|,
name|satype
argument_list|,
name|seq
argument_list|,
name|pid
argument_list|,
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|mode
argument_list|,
name|sav
operator|->
name|refcnt
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|SADB_EXT_MAX
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|i
condition|)
block|{
case|case
name|SADB_EXT_SA
case|:
name|p
operator|=
name|key_setsadbsa
argument_list|(
name|p
argument_list|,
name|sav
argument_list|)
expr_stmt|;
break|break;
case|case
name|SADB_EXT_ADDRESS_SRC
case|:
name|p
operator|=
name|key_setsadbaddr
argument_list|(
name|p
argument_list|,
name|SADB_EXT_ADDRESS_SRC
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|src
argument_list|,
name|_INALENBYAF
argument_list|(
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|src
operator|.
name|__ss_family
argument_list|)
operator|<<
literal|3
argument_list|,
name|IPSEC_ULPROTO_ANY
argument_list|)
expr_stmt|;
break|break;
case|case
name|SADB_EXT_ADDRESS_DST
case|:
name|p
operator|=
name|key_setsadbaddr
argument_list|(
name|p
argument_list|,
name|SADB_EXT_ADDRESS_DST
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|dst
argument_list|,
name|_INALENBYAF
argument_list|(
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|dst
operator|.
name|__ss_family
argument_list|)
operator|<<
literal|3
argument_list|,
name|IPSEC_ULPROTO_ANY
argument_list|)
expr_stmt|;
break|break;
case|case
name|SADB_EXT_KEY_AUTH
case|:
block|{
name|u_int
name|len
decl_stmt|;
if|if
condition|(
name|sav
operator|->
name|key_auth
operator|==
name|NULL
condition|)
break|break;
name|len
operator|=
name|sav
operator|->
name|key_auth
operator|->
name|sadb_key_len
expr_stmt|;
comment|/* real length */
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|sav
operator|->
name|key_auth
argument_list|,
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|sadb_ext
operator|*
operator|)
name|p
operator|)
operator|->
name|sadb_ext_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|p
operator|+=
name|len
expr_stmt|;
block|}
break|break;
case|case
name|SADB_EXT_KEY_ENCRYPT
case|:
block|{
name|u_int
name|len
decl_stmt|;
if|if
condition|(
name|sav
operator|->
name|key_enc
operator|==
name|NULL
condition|)
break|break;
name|len
operator|=
name|sav
operator|->
name|key_enc
operator|->
name|sadb_key_len
expr_stmt|;
comment|/* real length */
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|sav
operator|->
name|key_enc
argument_list|,
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|sadb_ext
operator|*
operator|)
name|p
operator|)
operator|->
name|sadb_ext_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|p
operator|+=
name|len
expr_stmt|;
block|}
break|break;
empty_stmt|;
case|case
name|SADB_EXT_LIFETIME_CURRENT
case|:
if|if
condition|(
name|sav
operator|->
name|lft_c
operator|==
name|NULL
condition|)
break|break;
name|p
operator|=
name|key_setsadbext
argument_list|(
name|p
argument_list|,
operator|(
name|caddr_t
operator|)
name|sav
operator|->
name|lft_c
argument_list|)
expr_stmt|;
break|break;
case|case
name|SADB_EXT_LIFETIME_HARD
case|:
if|if
condition|(
name|sav
operator|->
name|lft_h
operator|==
name|NULL
condition|)
break|break;
name|p
operator|=
name|key_setsadbext
argument_list|(
name|p
argument_list|,
operator|(
name|caddr_t
operator|)
name|sav
operator|->
name|lft_h
argument_list|)
expr_stmt|;
break|break;
case|case
name|SADB_EXT_LIFETIME_SOFT
case|:
if|if
condition|(
name|sav
operator|->
name|lft_s
operator|==
name|NULL
condition|)
break|break;
name|p
operator|=
name|key_setsadbext
argument_list|(
name|p
argument_list|,
operator|(
name|caddr_t
operator|)
name|sav
operator|->
name|lft_s
argument_list|)
expr_stmt|;
break|break;
case|case
name|SADB_EXT_IDENTITY_SRC
case|:
case|case
name|SADB_EXT_IDENTITY_DST
case|:
comment|/* XXX: should we brought from SPD ? */
case|case
name|SADB_EXT_SENSITIVITY
case|:
default|default:
break|break;
block|}
block|}
return|return
name|tlen
return|;
block|}
end_function

begin_comment
comment|/*  * set data into sadb_msg.  * `buf' must has been allocated sufficiently.  */
end_comment

begin_function
specifier|static
name|caddr_t
name|key_setsadbmsg
parameter_list|(
name|buf
parameter_list|,
name|type
parameter_list|,
name|tlen
parameter_list|,
name|satype
parameter_list|,
name|seq
parameter_list|,
name|pid
parameter_list|,
name|reserved1
parameter_list|,
name|reserved2
parameter_list|)
name|caddr_t
name|buf
decl_stmt|;
name|u_int8_t
name|type
decl_stmt|,
name|satype
decl_stmt|;
name|u_int16_t
name|tlen
decl_stmt|;
name|u_int32_t
name|seq
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|u_int8_t
name|reserved1
decl_stmt|;
name|u_int8_t
name|reserved2
decl_stmt|;
block|{
name|struct
name|sadb_msg
modifier|*
name|p
decl_stmt|;
name|u_int
name|len
decl_stmt|;
name|p
operator|=
operator|(
expr|struct
name|sadb_msg
operator|*
operator|)
name|buf
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|p
operator|->
name|sadb_msg_version
operator|=
name|PF_KEY_V2
expr_stmt|;
name|p
operator|->
name|sadb_msg_type
operator|=
name|type
expr_stmt|;
name|p
operator|->
name|sadb_msg_errno
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|sadb_msg_satype
operator|=
name|satype
expr_stmt|;
name|p
operator|->
name|sadb_msg_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|tlen
argument_list|)
expr_stmt|;
name|p
operator|->
name|sadb_msg_mode
operator|=
name|reserved1
expr_stmt|;
name|p
operator|->
name|sadb_msg_reserved
operator|=
name|reserved2
expr_stmt|;
name|p
operator|->
name|sadb_msg_seq
operator|=
name|seq
expr_stmt|;
name|p
operator|->
name|sadb_msg_pid
operator|=
operator|(
name|u_int32_t
operator|)
name|pid
expr_stmt|;
return|return
operator|(
name|buf
operator|+
name|len
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * copy secasvar data into sadb_address.  * `buf' must has been allocated sufficiently.  */
end_comment

begin_function
specifier|static
name|caddr_t
name|key_setsadbsa
parameter_list|(
name|buf
parameter_list|,
name|sav
parameter_list|)
name|caddr_t
name|buf
decl_stmt|;
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|;
block|{
name|struct
name|sadb_sa
modifier|*
name|p
decl_stmt|;
name|u_int
name|len
decl_stmt|;
name|p
operator|=
operator|(
expr|struct
name|sadb_sa
operator|*
operator|)
name|buf
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_sa
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|p
operator|->
name|sadb_sa_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|p
operator|->
name|sadb_sa_exttype
operator|=
name|SADB_EXT_SA
expr_stmt|;
name|p
operator|->
name|sadb_sa_spi
operator|=
name|sav
operator|->
name|spi
expr_stmt|;
name|p
operator|->
name|sadb_sa_replay
operator|=
operator|(
name|sav
operator|->
name|replay
operator|!=
name|NULL
condition|?
name|sav
operator|->
name|replay
operator|->
name|wsize
else|:
literal|0
operator|)
expr_stmt|;
name|p
operator|->
name|sadb_sa_state
operator|=
name|sav
operator|->
name|state
expr_stmt|;
name|p
operator|->
name|sadb_sa_auth
operator|=
name|sav
operator|->
name|alg_auth
expr_stmt|;
name|p
operator|->
name|sadb_sa_encrypt
operator|=
name|sav
operator|->
name|alg_enc
expr_stmt|;
name|p
operator|->
name|sadb_sa_flags
operator|=
name|sav
operator|->
name|flags
expr_stmt|;
return|return
operator|(
name|buf
operator|+
name|len
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * set data into sadb_address.  * `buf' must has been allocated sufficiently.  */
end_comment

begin_function
specifier|static
name|caddr_t
name|key_setsadbaddr
parameter_list|(
name|buf
parameter_list|,
name|exttype
parameter_list|,
name|saddr
parameter_list|,
name|prefixlen
parameter_list|,
name|ul_proto
parameter_list|)
name|caddr_t
name|buf
decl_stmt|;
name|u_int16_t
name|exttype
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|saddr
decl_stmt|;
name|u_int8_t
name|prefixlen
decl_stmt|;
name|u_int16_t
name|ul_proto
decl_stmt|;
block|{
name|struct
name|sadb_address
modifier|*
name|p
decl_stmt|;
name|u_int
name|len
decl_stmt|;
name|p
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
name|buf
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_address
argument_list|)
operator|+
name|PFKEY_ALIGN8
argument_list|(
name|saddr
operator|->
name|sa_len
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|p
operator|->
name|sadb_address_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|p
operator|->
name|sadb_address_exttype
operator|=
name|exttype
expr_stmt|;
name|p
operator|->
name|sadb_address_proto
operator|=
name|ul_proto
expr_stmt|;
name|p
operator|->
name|sadb_address_prefixlen
operator|=
name|prefixlen
expr_stmt|;
name|p
operator|->
name|sadb_address_reserved
operator|=
literal|0
expr_stmt|;
name|bcopy
argument_list|(
name|saddr
argument_list|,
name|p
operator|+
literal|1
argument_list|,
name|saddr
operator|->
name|sa_len
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|+
name|len
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * set data into sadb_ident.  * `buf' must has been allocated sufficiently.  */
end_comment

begin_function
specifier|static
name|caddr_t
name|key_setsadbident
parameter_list|(
name|buf
parameter_list|,
name|exttype
parameter_list|,
name|idtype
parameter_list|,
name|string
parameter_list|,
name|stringlen
parameter_list|,
name|id
parameter_list|)
name|caddr_t
name|buf
decl_stmt|;
name|u_int16_t
name|exttype
decl_stmt|,
name|idtype
decl_stmt|;
name|caddr_t
name|string
decl_stmt|;
name|int
name|stringlen
decl_stmt|;
name|u_int64_t
name|id
decl_stmt|;
block|{
name|struct
name|sadb_ident
modifier|*
name|p
decl_stmt|;
name|u_int
name|len
decl_stmt|;
name|p
operator|=
operator|(
expr|struct
name|sadb_ident
operator|*
operator|)
name|buf
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_ident
argument_list|)
operator|+
name|PFKEY_ALIGN8
argument_list|(
name|stringlen
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|p
operator|->
name|sadb_ident_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|p
operator|->
name|sadb_ident_exttype
operator|=
name|exttype
expr_stmt|;
name|p
operator|->
name|sadb_ident_type
operator|=
name|idtype
expr_stmt|;
name|p
operator|->
name|sadb_ident_reserved
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|sadb_ident_id
operator|=
name|id
expr_stmt|;
name|bcopy
argument_list|(
name|string
argument_list|,
name|p
operator|+
literal|1
argument_list|,
name|stringlen
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|+
name|len
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * copy buffer of any sadb extension type into sadb_ext.  * assume that sadb_ext_len shifted down>> 3.  * i.e. shift length up when setting length of extension.  */
end_comment

begin_function
specifier|static
name|caddr_t
name|key_setsadbext
parameter_list|(
name|p
parameter_list|,
name|ext
parameter_list|)
name|caddr_t
name|p
decl_stmt|,
name|ext
decl_stmt|;
block|{
name|u_int
name|len
decl_stmt|;
name|len
operator|=
name|PFKEY_UNUNIT64
argument_list|(
operator|(
operator|(
expr|struct
name|sadb_ext
operator|*
operator|)
name|ext
operator|)
operator|->
name|sadb_ext_len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|ext
argument_list|,
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|+
name|len
operator|)
return|;
block|}
end_function

begin_comment
comment|/* %%% utilities */
end_comment

begin_comment
comment|/*  * copy a buffer into the new buffer allocated.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|key_newbuf
parameter_list|(
name|src
parameter_list|,
name|len
parameter_list|)
name|void
modifier|*
name|src
decl_stmt|;
name|u_int
name|len
decl_stmt|;
block|{
name|caddr_t
name|new
decl_stmt|;
name|KMALLOC
argument_list|(
name|new
argument_list|,
name|caddr_t
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"key_newbuf: No more memory.\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|src
argument_list|,
name|new
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/* compare my own address  * OUT:	1: true, i.e. my address.  *	0: false  */
end_comment

begin_function
name|int
name|key_ismyaddr
parameter_list|(
name|family
parameter_list|,
name|addr
parameter_list|)
name|u_int
name|family
decl_stmt|;
name|caddr_t
name|addr
decl_stmt|;
block|{
comment|/* sanity check */
if|if
condition|(
name|addr
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_ismyaddr: NULL pointer is passed.\n"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|family
condition|)
block|{
case|case
name|AF_INET
case|:
block|{
name|struct
name|in_ifaddr
modifier|*
name|ia
decl_stmt|;
for|for
control|(
name|ia
operator|=
name|in_ifaddrhead
operator|.
name|tqh_first
init|;
name|ia
condition|;
name|ia
operator|=
name|ia
operator|->
name|ia_link
operator|.
name|tqe_next
control|)
if|if
condition|(
name|bcmp
argument_list|(
name|addr
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ia
operator|->
name|ia_addr
operator|.
name|sin_addr
argument_list|,
name|_INALENBYAF
argument_list|(
name|family
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
block|}
break|break;
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
return|return
name|key_ismyaddr6
argument_list|(
name|addr
argument_list|)
return|;
endif|#
directive|endif
block|}
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_comment
comment|/*  * compare my own address for IPv6.  * 1: ours  * 0: other  * NOTE: derived ip6_input() in KAME. This is necessary to modify more.  */
end_comment

begin_include
include|#
directive|include
file|<netinet6/in6.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/in6_var.h>
end_include

begin_function
specifier|static
name|int
name|key_ismyaddr6
parameter_list|(
name|addr
parameter_list|)
name|caddr_t
name|addr
decl_stmt|;
block|{
name|struct
name|in6_addr
modifier|*
name|a
init|=
operator|(
expr|struct
name|in6_addr
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|in6_ifaddr
modifier|*
name|ia
decl_stmt|;
for|for
control|(
name|ia
operator|=
name|in6_ifaddr
init|;
name|ia
condition|;
name|ia
operator|=
name|ia
operator|->
name|ia_next
control|)
block|{
if|if
condition|(
name|bcmp
argument_list|(
name|addr
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ia
operator|->
name|ia_addr
operator|.
name|sin6_addr
argument_list|,
name|_INALENBYAF
argument_list|(
name|AF_INET6
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
literal|1
return|;
block|}
comment|/* XXX Multicast */
block|{
name|struct
name|in6_multi
modifier|*
name|in6m
init|=
literal|0
decl_stmt|;
name|IN6_LOOKUP_MULTI
argument_list|(
operator|*
operator|(
expr|struct
name|in6_addr
operator|*
operator|)
name|addr
argument_list|,
name|ia
operator|->
name|ia_ifp
argument_list|,
name|in6m
argument_list|)
expr_stmt|;
if|if
condition|(
name|in6m
condition|)
return|return
literal|1
return|;
block|}
block|}
comment|/* loopback, just for safety */
if|if
condition|(
name|IN6_IS_ADDR_LOOPBACK
argument_list|(
name|a
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* XXX anycast */
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*INET6*/
end_comment

begin_comment
comment|/*  * compare two secasindex structure exactly.  * IN:  *	saidx0: source, it can be in SAD.  *	saidx1: object, it can be from SPD.  * OUT:  *	1 : equal  *	0 : not equal  */
end_comment

begin_function
specifier|static
name|int
name|key_cmpsaidx_exactly
parameter_list|(
name|saidx0
parameter_list|,
name|saidx1
parameter_list|)
name|struct
name|secasindex
modifier|*
name|saidx0
decl_stmt|,
decl|*
name|saidx1
decl_stmt|;
end_function

begin_block
block|{
comment|/* sanity */
if|if
condition|(
name|saidx0
operator|==
name|NULL
operator|&&
name|saidx1
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|saidx0
operator|==
name|NULL
operator|||
name|saidx1
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|saidx0
operator|->
name|proto
operator|!=
name|saidx1
operator|->
name|proto
operator|||
name|saidx0
operator|->
name|mode
operator|!=
name|saidx1
operator|->
name|mode
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|bcmp
argument_list|(
operator|&
name|saidx0
operator|->
name|src
argument_list|,
operator|&
name|saidx1
operator|->
name|src
argument_list|,
name|saidx0
operator|->
name|src
operator|.
name|__ss_len
argument_list|)
operator|!=
literal|0
operator|||
name|bcmp
argument_list|(
operator|&
name|saidx0
operator|->
name|dst
argument_list|,
operator|&
name|saidx1
operator|->
name|dst
argument_list|,
name|saidx0
operator|->
name|dst
operator|.
name|__ss_len
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/*  * compare two secasindex structure with consideration mode.  * don't compare port.  * IN:  *	saidx0: source, it is often in SAD.  *	saidx1: object, it is often from SPD.  * OUT:  *	1 : equal  *	0 : not equal  */
end_comment

begin_function
specifier|static
name|int
name|key_cmpsaidx_withmode
parameter_list|(
name|saidx0
parameter_list|,
name|saidx1
parameter_list|)
name|struct
name|secasindex
modifier|*
name|saidx0
decl_stmt|,
decl|*
name|saidx1
decl_stmt|;
end_function

begin_block
block|{
comment|/* sanity */
if|if
condition|(
name|saidx0
operator|==
name|NULL
operator|&&
name|saidx1
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|saidx0
operator|==
name|NULL
operator|||
name|saidx1
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|saidx0
operator|->
name|proto
operator|!=
name|saidx1
operator|->
name|proto
operator|||
name|saidx0
operator|->
name|src
operator|.
name|__ss_family
operator|!=
name|saidx1
operator|->
name|src
operator|.
name|__ss_family
operator|||
name|saidx0
operator|->
name|dst
operator|.
name|__ss_family
operator|!=
name|saidx1
operator|->
name|dst
operator|.
name|__ss_family
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|saidx0
operator|->
name|mode
operator|!=
name|IPSEC_MODE_ANY
operator|&&
name|saidx0
operator|->
name|mode
operator|!=
name|saidx1
operator|->
name|mode
condition|)
return|return
literal|0
return|;
block|{
name|int
name|sa_len
init|=
name|_INALENBYAF
argument_list|(
name|saidx0
operator|->
name|src
operator|.
name|__ss_family
argument_list|)
decl_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
name|_INADDRBYSA
argument_list|(
operator|&
name|saidx0
operator|->
name|src
argument_list|)
argument_list|,
name|_INADDRBYSA
argument_list|(
operator|&
name|saidx1
operator|->
name|src
argument_list|)
argument_list|,
name|sa_len
argument_list|)
operator|||
name|bcmp
argument_list|(
name|_INADDRBYSA
argument_list|(
operator|&
name|saidx0
operator|->
name|dst
argument_list|)
argument_list|,
name|_INADDRBYSA
argument_list|(
operator|&
name|saidx1
operator|->
name|dst
argument_list|)
argument_list|,
name|sa_len
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/*  * compare two secindex structure exactly.  * IN:  *	spidx0: source, it is often in SPD.  *	spidx1: object, it is often from PFKEY message.  * OUT:  *	1 : equal  *	0 : not equal  */
end_comment

begin_function
specifier|static
name|int
name|key_cmpspidx_exactly
parameter_list|(
name|spidx0
parameter_list|,
name|spidx1
parameter_list|)
name|struct
name|secpolicyindex
modifier|*
name|spidx0
decl_stmt|,
decl|*
name|spidx1
decl_stmt|;
end_function

begin_block
block|{
comment|/* sanity */
if|if
condition|(
name|spidx0
operator|==
name|NULL
operator|&&
name|spidx1
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|spidx0
operator|==
name|NULL
operator|||
name|spidx1
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|spidx0
operator|->
name|prefs
operator|!=
name|spidx1
operator|->
name|prefs
operator|||
name|spidx0
operator|->
name|prefd
operator|!=
name|spidx1
operator|->
name|prefd
operator|||
name|spidx0
operator|->
name|ul_proto
operator|!=
name|spidx1
operator|->
name|ul_proto
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|bcmp
argument_list|(
operator|&
name|spidx0
operator|->
name|src
argument_list|,
operator|&
name|spidx1
operator|->
name|src
argument_list|,
name|spidx0
operator|->
name|src
operator|.
name|__ss_len
argument_list|)
operator|!=
literal|0
operator|||
name|bcmp
argument_list|(
operator|&
name|spidx0
operator|->
name|dst
argument_list|,
operator|&
name|spidx1
operator|->
name|dst
argument_list|,
name|spidx0
operator|->
name|dst
operator|.
name|__ss_len
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/*  * compare two secindex structure with mask.  * IN:  *	spidx0: source, it is often in SPD.  *	spidx1: object, it is often from IP header.  * OUT:  *	1 : equal  *	0 : not equal  */
end_comment

begin_function
specifier|static
name|int
name|key_cmpspidx_withmask
parameter_list|(
name|spidx0
parameter_list|,
name|spidx1
parameter_list|)
name|struct
name|secpolicyindex
modifier|*
name|spidx0
decl_stmt|,
decl|*
name|spidx1
decl_stmt|;
end_function

begin_block
block|{
comment|/* sanity */
if|if
condition|(
name|spidx0
operator|==
name|NULL
operator|&&
name|spidx1
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|spidx0
operator|==
name|NULL
operator|||
name|spidx1
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|spidx0
operator|->
name|src
operator|.
name|__ss_family
operator|!=
name|spidx1
operator|->
name|src
operator|.
name|__ss_family
operator|||
name|spidx0
operator|->
name|dst
operator|.
name|__ss_family
operator|!=
name|spidx1
operator|->
name|dst
operator|.
name|__ss_family
condition|)
return|return
literal|0
return|;
comment|/* if spidx.ul_proto == IPSEC_ULPROTO_ANY, ignore. */
if|if
condition|(
name|spidx0
operator|->
name|ul_proto
operator|!=
operator|(
name|u_int16_t
operator|)
name|IPSEC_ULPROTO_ANY
operator|&&
name|spidx0
operator|->
name|ul_proto
operator|!=
name|spidx1
operator|->
name|ul_proto
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|_INPORTBYSA
argument_list|(
operator|&
name|spidx0
operator|->
name|src
argument_list|)
operator|!=
name|IPSEC_PORT_ANY
operator|&&
name|_INPORTBYSA
argument_list|(
operator|&
name|spidx0
operator|->
name|src
argument_list|)
operator|!=
name|_INPORTBYSA
argument_list|(
operator|&
name|spidx1
operator|->
name|src
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|_INPORTBYSA
argument_list|(
operator|&
name|spidx0
operator|->
name|dst
argument_list|)
operator|!=
name|IPSEC_PORT_ANY
operator|&&
name|_INPORTBYSA
argument_list|(
operator|&
name|spidx0
operator|->
name|dst
argument_list|)
operator|!=
name|_INPORTBYSA
argument_list|(
operator|&
name|spidx1
operator|->
name|dst
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|key_bbcmp
argument_list|(
name|_INADDRBYSA
argument_list|(
operator|&
name|spidx0
operator|->
name|src
argument_list|)
argument_list|,
name|_INADDRBYSA
argument_list|(
operator|&
name|spidx1
operator|->
name|src
argument_list|)
argument_list|,
name|spidx0
operator|->
name|prefs
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|key_bbcmp
argument_list|(
name|_INADDRBYSA
argument_list|(
operator|&
name|spidx0
operator|->
name|dst
argument_list|)
argument_list|,
name|_INADDRBYSA
argument_list|(
operator|&
name|spidx1
operator|->
name|dst
argument_list|)
argument_list|,
name|spidx0
operator|->
name|prefd
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* XXX Do we check other field ?  e.g. flowinfo, scope_id. */
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/*  * compare two buffers with mask.  * IN:  *	addr1: source  *	addr2: object  *	bits:  Number of bits to compare  * OUT:  *	1 : equal  *	0 : not equal  */
end_comment

begin_function
specifier|static
name|int
name|key_bbcmp
parameter_list|(
name|p1
parameter_list|,
name|p2
parameter_list|,
name|bits
parameter_list|)
specifier|register
name|caddr_t
name|p1
decl_stmt|,
name|p2
decl_stmt|;
specifier|register
name|u_int
name|bits
decl_stmt|;
block|{
name|u_int8_t
name|mask
decl_stmt|;
comment|/* XXX: This could be considerably faster if we compare a word 	 * at a time, but it is complicated on LSB Endian machines */
comment|/* Handle null pointers */
if|if
condition|(
name|p1
operator|==
name|NULL
operator|||
name|p2
operator|==
name|NULL
condition|)
return|return
operator|(
name|p1
operator|==
name|p2
operator|)
return|;
while|while
condition|(
name|bits
operator|>=
literal|8
condition|)
block|{
if|if
condition|(
operator|*
name|p1
operator|++
operator|!=
operator|*
name|p2
operator|++
condition|)
return|return
literal|0
return|;
name|bits
operator|-=
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|bits
operator|>
literal|0
condition|)
block|{
name|mask
operator|=
operator|~
operator|(
operator|(
literal|1
operator|<<
operator|(
literal|8
operator|-
name|bits
operator|)
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|p1
operator|&
name|mask
operator|)
operator|!=
operator|(
operator|*
name|p2
operator|&
name|mask
operator|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
comment|/* Match! */
block|}
end_function

begin_comment
comment|/*  * time handler.  * scanning SPD and SAD to check status for each entries,  * and do to remove or to expire.  */
end_comment

begin_function
name|void
name|key_timehandler
parameter_list|(
name|void
parameter_list|)
block|{
name|u_int
name|dir
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
comment|/*called from softclock()*/
comment|/* SPD */
block|{
name|struct
name|secpolicy
modifier|*
name|sp
decl_stmt|,
modifier|*
name|nextsp
decl_stmt|;
for|for
control|(
name|dir
operator|=
literal|0
init|;
name|dir
operator|<
name|IPSEC_DIR_MAX
condition|;
name|dir
operator|++
control|)
block|{
for|for
control|(
name|sp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sptree
index|[
name|dir
index|]
argument_list|)
init|;
name|sp
operator|!=
name|NULL
condition|;
name|sp
operator|=
name|nextsp
control|)
block|{
name|nextsp
operator|=
name|LIST_NEXT
argument_list|(
name|sp
argument_list|,
name|chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|state
operator|==
name|IPSEC_SPSTATE_DEAD
condition|)
name|key_freesp
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* SAD */
block|{
name|struct
name|secashead
modifier|*
name|sah
decl_stmt|,
modifier|*
name|nextsah
decl_stmt|;
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|,
modifier|*
name|nextsav
decl_stmt|;
for|for
control|(
name|sah
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sahtree
argument_list|)
init|;
name|sah
operator|!=
name|NULL
condition|;
name|sah
operator|=
name|nextsah
control|)
block|{
name|nextsah
operator|=
name|LIST_NEXT
argument_list|(
name|sah
argument_list|,
name|chain
argument_list|)
expr_stmt|;
comment|/* if sah has been dead, then delete it and process next sah. */
if|if
condition|(
name|sah
operator|->
name|state
operator|==
name|SADB_SASTATE_DEAD
condition|)
block|{
name|key_delsah
argument_list|(
name|sah
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* if LARVAL entry doesn't become MATURE, delete it. */
for|for
control|(
name|sav
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sah
operator|->
name|savtree
index|[
name|SADB_SASTATE_LARVAL
index|]
argument_list|)
init|;
name|sav
operator|!=
name|NULL
condition|;
name|sav
operator|=
name|nextsav
control|)
block|{
name|nextsav
operator|=
name|LIST_NEXT
argument_list|(
name|sav
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|sav
operator|->
name|tick
operator|++
expr_stmt|;
if|if
condition|(
name|key_larval_lifetime
operator|<
name|sav
operator|->
name|tick
condition|)
block|{
name|key_freesav
argument_list|(
name|sav
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * check MATURE entry to start to send expire message 		 * whether or not. 		 */
for|for
control|(
name|sav
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sah
operator|->
name|savtree
index|[
name|SADB_SASTATE_MATURE
index|]
argument_list|)
init|;
name|sav
operator|!=
name|NULL
condition|;
name|sav
operator|=
name|nextsav
control|)
block|{
name|nextsav
operator|=
name|LIST_NEXT
argument_list|(
name|sav
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|sav
operator|->
name|tick
operator|++
expr_stmt|;
comment|/* we don't need to check. */
if|if
condition|(
name|sav
operator|->
name|lft_s
operator|==
name|NULL
condition|)
continue|continue;
comment|/* sanity check */
if|if
condition|(
name|sav
operator|->
name|lft_c
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"key_timehandler: "
literal|"There is no CURRENT time, why?\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* compare SOFT lifetime and tick */
if|if
condition|(
name|sav
operator|->
name|lft_s
operator|->
name|sadb_lifetime_addtime
operator|!=
literal|0
operator|&&
name|sav
operator|->
name|lft_s
operator|->
name|sadb_lifetime_addtime
operator|<
name|sav
operator|->
name|tick
condition|)
block|{
comment|/* 				 * check SA to be used whether or not. 				 * when SA hasn't been used, delete it. 				 */
if|if
condition|(
name|sav
operator|->
name|lft_c
operator|->
name|sadb_lifetime_usetime
operator|==
literal|0
condition|)
block|{
name|key_sa_chgstate
argument_list|(
name|sav
argument_list|,
name|SADB_SASTATE_DEAD
argument_list|)
expr_stmt|;
name|key_freesav
argument_list|(
name|sav
argument_list|)
expr_stmt|;
name|sav
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|key_sa_chgstate
argument_list|(
name|sav
argument_list|,
name|SADB_SASTATE_DYING
argument_list|)
expr_stmt|;
comment|/* 					 * XXX If we keep to send expire 					 * message in the status of 					 * DYING. Do remove below code. 					 */
name|key_expire
argument_list|(
name|sav
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* check SOFT lifetime by bytes */
comment|/* 			 * XXX I don't know the way to delete this SA 			 * when new SA is installed.  Caution when it's 			 * installed too big lifetime by time. 			 */
elseif|else
if|if
condition|(
name|sav
operator|->
name|lft_s
operator|->
name|sadb_lifetime_bytes
operator|!=
literal|0
operator|&&
name|sav
operator|->
name|lft_s
operator|->
name|sadb_lifetime_bytes
operator|<
name|sav
operator|->
name|lft_c
operator|->
name|sadb_lifetime_bytes
condition|)
block|{
name|key_sa_chgstate
argument_list|(
name|sav
argument_list|,
name|SADB_SASTATE_DYING
argument_list|)
expr_stmt|;
comment|/* 				 * XXX If we keep to send expire 				 * message in the status of 				 * DYING. Do remove below code. 				 */
name|key_expire
argument_list|(
name|sav
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* check DYING entry to change status to DEAD. */
for|for
control|(
name|sav
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sah
operator|->
name|savtree
index|[
name|SADB_SASTATE_DYING
index|]
argument_list|)
init|;
name|sav
operator|!=
name|NULL
condition|;
name|sav
operator|=
name|nextsav
control|)
block|{
name|nextsav
operator|=
name|LIST_NEXT
argument_list|(
name|sav
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|sav
operator|->
name|tick
operator|++
expr_stmt|;
comment|/* we don't need to check. */
if|if
condition|(
name|sav
operator|->
name|lft_h
operator|==
name|NULL
condition|)
continue|continue;
comment|/* sanity check */
if|if
condition|(
name|sav
operator|->
name|lft_c
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"key_timehandler: "
literal|"There is no CURRENT time, why?\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* compare HARD lifetime and tick */
if|if
condition|(
name|sav
operator|->
name|lft_h
operator|->
name|sadb_lifetime_addtime
operator|!=
literal|0
operator|&&
name|sav
operator|->
name|lft_h
operator|->
name|sadb_lifetime_addtime
operator|<
name|sav
operator|->
name|tick
condition|)
block|{
name|key_sa_chgstate
argument_list|(
name|sav
argument_list|,
name|SADB_SASTATE_DEAD
argument_list|)
expr_stmt|;
name|key_freesav
argument_list|(
name|sav
argument_list|)
expr_stmt|;
name|sav
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* check HARD lifetime by bytes */
elseif|else
if|if
condition|(
name|sav
operator|->
name|lft_h
operator|->
name|sadb_lifetime_bytes
operator|!=
literal|0
operator|&&
name|sav
operator|->
name|lft_h
operator|->
name|sadb_lifetime_bytes
operator|<
name|sav
operator|->
name|lft_c
operator|->
name|sadb_lifetime_bytes
condition|)
block|{
name|key_sa_chgstate
argument_list|(
name|sav
argument_list|,
name|SADB_SASTATE_DEAD
argument_list|)
expr_stmt|;
name|key_freesav
argument_list|(
name|sav
argument_list|)
expr_stmt|;
name|sav
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* delete entry in DEAD */
for|for
control|(
name|sav
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sah
operator|->
name|savtree
index|[
name|SADB_SASTATE_DEAD
index|]
argument_list|)
init|;
name|sav
operator|!=
name|NULL
condition|;
name|sav
operator|=
name|nextsav
control|)
block|{
name|nextsav
operator|=
name|LIST_NEXT
argument_list|(
name|sav
argument_list|,
name|chain
argument_list|)
expr_stmt|;
comment|/* sanity check */
if|if
condition|(
name|sav
operator|->
name|state
operator|!=
name|SADB_SASTATE_DEAD
condition|)
block|{
name|printf
argument_list|(
literal|"key_timehandler: "
literal|"invalid sav->state "
literal|"(queue: %d SA: %d): "
literal|"kill it anyway\n"
argument_list|,
name|SADB_SASTATE_DEAD
argument_list|,
name|sav
operator|->
name|state
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * do not call key_freesav() here. 			 * sav should already be freed, and sav->refcnt 			 * shows other references to sav 			 * (such as from SPD). 			 */
block|}
block|}
block|}
ifndef|#
directive|ifndef
name|IPSEC_NONBLOCK_ACQUIRE
comment|/* ACQ tree */
block|{
name|struct
name|secacq
modifier|*
name|acq
decl_stmt|,
modifier|*
name|nextacq
decl_stmt|;
for|for
control|(
name|acq
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|acqtree
argument_list|)
init|;
name|acq
operator|!=
name|NULL
condition|;
name|acq
operator|=
name|nextacq
control|)
block|{
name|nextacq
operator|=
name|LIST_NEXT
argument_list|(
name|acq
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|acq
operator|->
name|tick
operator|++
expr_stmt|;
if|if
condition|(
name|key_blockacq_lifetime
operator|<
name|acq
operator|->
name|tick
operator|&&
name|__LIST_CHAINED
argument_list|(
name|acq
argument_list|)
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|acq
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|KFREE
argument_list|(
name|acq
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* initialize random seed */
if|if
condition|(
name|key_tick_init_random
operator|++
operator|>
name|key_int_random
condition|)
block|{
name|key_tick_init_random
operator|=
literal|0
expr_stmt|;
name|key_srandom
argument_list|()
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|IPSEC_DEBUG2
comment|/* do exchange to tick time !! */
operator|(
name|void
operator|)
name|timeout
argument_list|(
operator|(
name|void
operator|*
operator|)
name|key_timehandler
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|,
literal|100
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* IPSEC_DEBUG2 */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * to initialize a seed for random()  */
end_comment

begin_function
name|void
name|key_srandom
parameter_list|()
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|microtime
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
name|srandom
argument_list|(
name|tv
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * map SADB_SATYPE_* to IPPROTO_*.  * if satype == SADB_SATYPE then satype is mapped to ~0.  * OUT:  *	0: invalid satype.  */
end_comment

begin_function
specifier|static
name|u_int16_t
name|key_satype2proto
parameter_list|(
name|satype
parameter_list|)
name|u_int8_t
name|satype
decl_stmt|;
block|{
switch|switch
condition|(
name|satype
condition|)
block|{
case|case
name|SADB_SATYPE_UNSPEC
case|:
return|return
name|IPSEC_PROTO_ANY
return|;
case|case
name|SADB_SATYPE_AH
case|:
return|return
name|IPPROTO_AH
return|;
case|case
name|SADB_SATYPE_ESP
case|:
return|return
name|IPPROTO_ESP
return|;
default|default:
return|return
literal|0
return|;
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/*  * map IPPROTO_* to SADB_SATYPE_*  * OUT:  *	0: invalid protocol type.  */
end_comment

begin_function
specifier|static
name|u_int8_t
name|key_proto2satype
parameter_list|(
name|proto
parameter_list|)
name|u_int16_t
name|proto
decl_stmt|;
block|{
switch|switch
condition|(
name|proto
condition|)
block|{
case|case
name|IPPROTO_AH
case|:
return|return
name|SADB_SATYPE_AH
return|;
case|case
name|IPPROTO_ESP
case|:
return|return
name|SADB_SATYPE_ESP
return|;
default|default:
return|return
literal|0
return|;
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/* %%% PF_KEY */
end_comment

begin_comment
comment|/*  * SADB_GETSPI processing is to receive  *<base, src address, dst address, (SPI range)>  * from the IKMPd, to assign a unique spi value, to hang on the INBOUND  * tree with the status of LARVAL, and send  *<base, SA(*), address(SD)>  * to the IKMPd.  *  * IN:	mhp: pointer to the pointer to each header.  * OUT:	NULL if fail.  *	other if success, return pointer to the message to send.  */
end_comment

begin_function
specifier|static
name|struct
name|sadb_msg
modifier|*
name|key_getspi
parameter_list|(
name|mhp
parameter_list|)
name|caddr_t
modifier|*
name|mhp
decl_stmt|;
block|{
name|struct
name|sadb_msg
modifier|*
name|msg0
decl_stmt|;
name|struct
name|sadb_address
modifier|*
name|src0
decl_stmt|,
modifier|*
name|dst0
decl_stmt|;
name|struct
name|secasindex
name|saidx
decl_stmt|;
name|struct
name|secashead
modifier|*
name|newsah
decl_stmt|;
name|struct
name|secasvar
modifier|*
name|newsav
decl_stmt|;
name|u_int8_t
name|proto
decl_stmt|;
name|u_int32_t
name|spi
decl_stmt|;
comment|/* sanity check */
if|if
condition|(
name|mhp
operator|==
name|NULL
operator|||
name|mhp
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_getspi: NULL pointer is passed.\n"
argument_list|)
expr_stmt|;
name|msg0
operator|=
operator|(
expr|struct
name|sadb_msg
operator|*
operator|)
name|mhp
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|mhp
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
operator|==
name|NULL
operator|||
name|mhp
index|[
name|SADB_EXT_ADDRESS_DST
index|]
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"key_getspi: invalid message is passed.\n"
argument_list|)
expr_stmt|;
name|msg0
operator|->
name|sadb_msg_errno
operator|=
name|EINVAL
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|src0
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
operator|(
name|mhp
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
operator|)
expr_stmt|;
name|dst0
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
operator|(
name|mhp
index|[
name|SADB_EXT_ADDRESS_DST
index|]
operator|)
expr_stmt|;
comment|/* map satype to proto */
if|if
condition|(
operator|(
name|proto
operator|=
name|key_satype2proto
argument_list|(
name|msg0
operator|->
name|sadb_msg_satype
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"key_getspi: invalid satype is passed.\n"
argument_list|)
expr_stmt|;
name|msg0
operator|->
name|sadb_msg_errno
operator|=
name|EINVAL
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|KEY_SETSECASIDX
argument_list|(
name|proto
argument_list|,
name|msg0
operator|->
name|sadb_msg_mode
argument_list|,
name|src0
operator|+
literal|1
argument_list|,
name|dst0
operator|+
literal|1
argument_list|,
operator|&
name|saidx
argument_list|)
expr_stmt|;
comment|/* SPI allocation */
name|spi
operator|=
name|key_do_getnewspi
argument_list|(
operator|(
expr|struct
name|sadb_spirange
operator|*
operator|)
name|mhp
index|[
name|SADB_EXT_SPIRANGE
index|]
argument_list|,
operator|&
name|saidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|spi
operator|==
literal|0
condition|)
block|{
name|msg0
operator|->
name|sadb_msg_errno
operator|=
name|EEXIST
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* get a SA index */
if|if
condition|(
operator|(
name|newsah
operator|=
name|key_getsah
argument_list|(
operator|&
name|saidx
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* create a new SA index */
if|if
condition|(
operator|(
name|newsah
operator|=
name|key_newsah
argument_list|(
operator|&
name|saidx
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"key_getspi: No more memory.\n"
argument_list|)
expr_stmt|;
name|msg0
operator|->
name|sadb_msg_errno
operator|=
name|ENOBUFS
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
comment|/* get a new SA */
if|if
condition|(
operator|(
name|newsav
operator|=
name|key_newsav
argument_list|(
name|mhp
argument_list|,
name|newsah
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msg0
operator|->
name|sadb_msg_errno
operator|=
name|ENOBUFS
expr_stmt|;
comment|/* XXX don't free new SA index allocated in above. */
return|return
name|NULL
return|;
block|}
comment|/* set spi */
name|newsav
operator|->
name|spi
operator|=
name|htonl
argument_list|(
name|spi
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|IPSEC_NONBLOCK_ACQUIRE
comment|/* delete the entry in acqtree */
if|if
condition|(
name|msg0
operator|->
name|sadb_msg_seq
operator|!=
literal|0
condition|)
block|{
name|struct
name|secacq
modifier|*
name|acq
decl_stmt|;
if|if
condition|(
operator|(
name|acq
operator|=
name|key_getacqbyseq
argument_list|(
name|msg0
operator|->
name|sadb_msg_seq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* reset counter in order to deletion by timehander. */
name|acq
operator|->
name|tick
operator|=
name|key_blockacq_lifetime
expr_stmt|;
name|acq
operator|->
name|count
operator|=
literal|0
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|{
name|struct
name|sadb_msg
modifier|*
name|newmsg
decl_stmt|;
name|u_int
name|len
decl_stmt|;
name|caddr_t
name|p
decl_stmt|;
comment|/* create new sadb_msg to reply. */
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_sa
argument_list|)
operator|+
name|PFKEY_EXTLEN
argument_list|(
name|mhp
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
argument_list|)
operator|+
name|PFKEY_EXTLEN
argument_list|(
name|mhp
index|[
name|SADB_EXT_ADDRESS_DST
index|]
argument_list|)
expr_stmt|;
name|KMALLOC
argument_list|(
name|newmsg
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|newmsg
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"key_getspi: No more memory.\n"
argument_list|)
expr_stmt|;
name|msg0
operator|->
name|sadb_msg_errno
operator|=
name|ENOBUFS
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|newmsg
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|mhp
index|[
literal|0
index|]
argument_list|,
operator|(
name|caddr_t
operator|)
name|newmsg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|msg0
argument_list|)
argument_list|)
expr_stmt|;
name|newmsg
operator|->
name|sadb_msg_seq
operator|=
name|newsav
operator|->
name|seq
expr_stmt|;
name|newmsg
operator|->
name|sadb_msg_errno
operator|=
literal|0
expr_stmt|;
name|newmsg
operator|->
name|sadb_msg_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|caddr_t
operator|)
name|newmsg
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|msg0
argument_list|)
expr_stmt|;
block|{
name|struct
name|sadb_sa
modifier|*
name|m_sa
decl_stmt|;
name|m_sa
operator|=
operator|(
expr|struct
name|sadb_sa
operator|*
operator|)
name|p
expr_stmt|;
name|m_sa
operator|->
name|sadb_sa_len
operator|=
name|PFKEY_UNIT64
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_sa
argument_list|)
argument_list|)
expr_stmt|;
name|m_sa
operator|->
name|sadb_sa_exttype
operator|=
name|SADB_EXT_SA
expr_stmt|;
name|m_sa
operator|->
name|sadb_sa_spi
operator|=
name|htonl
argument_list|(
name|spi
argument_list|)
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_sa
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|key_setsadbext
argument_list|(
name|p
argument_list|,
name|mhp
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
argument_list|)
expr_stmt|;
name|p
operator|=
name|key_setsadbext
argument_list|(
name|p
argument_list|,
name|mhp
index|[
name|SADB_EXT_ADDRESS_DST
index|]
argument_list|)
expr_stmt|;
return|return
name|newmsg
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * allocating new SPI  * called by key_getspi().  * OUT:  *	0:	failure.  *	others: success.  */
end_comment

begin_function
specifier|static
name|u_int32_t
name|key_do_getnewspi
parameter_list|(
name|spirange
parameter_list|,
name|saidx
parameter_list|)
name|struct
name|sadb_spirange
modifier|*
name|spirange
decl_stmt|;
name|struct
name|secasindex
modifier|*
name|saidx
decl_stmt|;
block|{
name|u_int32_t
name|newspi
decl_stmt|;
name|u_int32_t
name|min
decl_stmt|,
name|max
decl_stmt|;
name|int
name|count
init|=
name|key_spi_trycnt
decl_stmt|;
comment|/* set spi range to allocate */
if|if
condition|(
name|spirange
operator|!=
name|NULL
condition|)
block|{
name|min
operator|=
name|spirange
operator|->
name|sadb_spirange_min
expr_stmt|;
name|max
operator|=
name|spirange
operator|->
name|sadb_spirange_max
expr_stmt|;
block|}
else|else
block|{
name|min
operator|=
name|key_spi_minval
expr_stmt|;
name|max
operator|=
name|key_spi_maxval
expr_stmt|;
block|}
if|if
condition|(
name|min
operator|==
name|max
condition|)
block|{
if|if
condition|(
name|key_checkspidup
argument_list|(
name|saidx
argument_list|,
name|min
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"key_do_getnewspi: SPI %u exists already.\n"
argument_list|,
name|min
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|count
operator|--
expr_stmt|;
comment|/* taking one cost. */
name|newspi
operator|=
name|min
expr_stmt|;
block|}
else|else
block|{
comment|/* init SPI */
name|newspi
operator|=
literal|0
expr_stmt|;
comment|/* when requesting to allocate spi ranged */
while|while
condition|(
name|count
operator|--
condition|)
block|{
comment|/* generate pseudo-random SPI value ranged. */
name|newspi
operator|=
name|min
operator|+
operator|(
name|random
argument_list|()
operator|%
operator|(
name|max
operator|-
name|min
operator|+
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|key_checkspidup
argument_list|(
name|saidx
argument_list|,
name|newspi
argument_list|)
operator|==
name|NULL
condition|)
break|break;
block|}
if|if
condition|(
name|count
operator|==
literal|0
operator|||
name|newspi
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"key_do_getnewspi: to allocate spi is failed.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/* statistics */
name|keystat
operator|.
name|getspi_count
operator|=
operator|(
name|keystat
operator|.
name|getspi_count
operator|+
name|key_spi_trycnt
operator|-
name|count
operator|)
operator|/
literal|2
expr_stmt|;
return|return
name|newspi
return|;
block|}
end_function

begin_comment
comment|/*  * SADB_UPDATE processing  * receive  *<base, SA, (lifetime(HSC),) address(SD), (address(P),)  *       key(AE), (identity(SD),) (sensitivity)>  * from the ikmpd, and update a secasvar entry whose status is SADB_SASTATE_LARVAL.  * and send  *<base, SA, (lifetime(HSC),) address(SD), (address(P),)  *       (identity(SD),) (sensitivity)>  * to the ikmpd.  *  * IN:	mhp: pointer to the pointer to each header.  * OUT:	NULL if fail.  *	other if success, return pointer to the message to send.  */
end_comment

begin_function
specifier|static
name|struct
name|sadb_msg
modifier|*
name|key_update
parameter_list|(
name|mhp
parameter_list|)
name|caddr_t
modifier|*
name|mhp
decl_stmt|;
block|{
name|struct
name|sadb_msg
modifier|*
name|msg0
decl_stmt|;
name|struct
name|sadb_sa
modifier|*
name|sa0
decl_stmt|;
name|struct
name|sadb_address
modifier|*
name|src0
decl_stmt|,
modifier|*
name|dst0
decl_stmt|;
name|struct
name|secasindex
name|saidx
decl_stmt|;
name|struct
name|secashead
modifier|*
name|sah
decl_stmt|;
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|;
name|u_int16_t
name|proto
decl_stmt|;
comment|/* sanity check */
if|if
condition|(
name|mhp
operator|==
name|NULL
operator|||
name|mhp
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_update: NULL pointer is passed.\n"
argument_list|)
expr_stmt|;
name|msg0
operator|=
operator|(
expr|struct
name|sadb_msg
operator|*
operator|)
name|mhp
index|[
literal|0
index|]
expr_stmt|;
comment|/* map satype to proto */
if|if
condition|(
operator|(
name|proto
operator|=
name|key_satype2proto
argument_list|(
name|msg0
operator|->
name|sadb_msg_satype
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"key_update: invalid satype is passed.\n"
argument_list|)
expr_stmt|;
name|msg0
operator|->
name|sadb_msg_errno
operator|=
name|EINVAL
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|mhp
index|[
name|SADB_EXT_SA
index|]
operator|==
name|NULL
operator|||
name|mhp
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
operator|==
name|NULL
operator|||
name|mhp
index|[
name|SADB_EXT_ADDRESS_DST
index|]
operator|==
name|NULL
operator|||
operator|(
name|msg0
operator|->
name|sadb_msg_satype
operator|==
name|SADB_SATYPE_ESP
operator|&&
name|mhp
index|[
name|SADB_EXT_KEY_ENCRYPT
index|]
operator|==
name|NULL
operator|)
operator|||
operator|(
name|msg0
operator|->
name|sadb_msg_satype
operator|==
name|SADB_SATYPE_AH
operator|&&
name|mhp
index|[
name|SADB_EXT_KEY_AUTH
index|]
operator|==
name|NULL
operator|)
operator|||
operator|(
name|mhp
index|[
name|SADB_EXT_LIFETIME_HARD
index|]
operator|!=
name|NULL
operator|&&
name|mhp
index|[
name|SADB_EXT_LIFETIME_SOFT
index|]
operator|==
name|NULL
operator|)
operator|||
operator|(
name|mhp
index|[
name|SADB_EXT_LIFETIME_HARD
index|]
operator|==
name|NULL
operator|&&
name|mhp
index|[
name|SADB_EXT_LIFETIME_SOFT
index|]
operator|!=
name|NULL
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"key_update: invalid message is passed.\n"
argument_list|)
expr_stmt|;
name|msg0
operator|->
name|sadb_msg_errno
operator|=
name|EINVAL
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|sa0
operator|=
operator|(
expr|struct
name|sadb_sa
operator|*
operator|)
name|mhp
index|[
name|SADB_EXT_SA
index|]
expr_stmt|;
name|src0
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
operator|(
name|mhp
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
operator|)
expr_stmt|;
name|dst0
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
operator|(
name|mhp
index|[
name|SADB_EXT_ADDRESS_DST
index|]
operator|)
expr_stmt|;
name|KEY_SETSECASIDX
argument_list|(
name|proto
argument_list|,
name|msg0
operator|->
name|sadb_msg_mode
argument_list|,
name|src0
operator|+
literal|1
argument_list|,
name|dst0
operator|+
literal|1
argument_list|,
operator|&
name|saidx
argument_list|)
expr_stmt|;
comment|/* get a SA header */
if|if
condition|(
operator|(
name|sah
operator|=
name|key_getsah
argument_list|(
operator|&
name|saidx
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"key_update: no SA index found.\n"
argument_list|)
expr_stmt|;
name|msg0
operator|->
name|sadb_msg_errno
operator|=
name|ENOENT
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* find a SA with sequence number. */
if|if
condition|(
operator|(
name|sav
operator|=
name|key_getsavbyseq
argument_list|(
name|sah
argument_list|,
name|msg0
operator|->
name|sadb_msg_seq
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"key_update: no larval SA with sequence %u exists.\n"
argument_list|,
name|msg0
operator|->
name|sadb_msg_seq
argument_list|)
expr_stmt|;
name|msg0
operator|->
name|sadb_msg_errno
operator|=
name|ENOENT
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* validity check */
if|if
condition|(
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|proto
operator|!=
name|proto
condition|)
block|{
name|printf
argument_list|(
literal|"key_update: protocol mismatched (DB=%u param=%u)\n"
argument_list|,
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|proto
argument_list|,
name|proto
argument_list|)
expr_stmt|;
name|msg0
operator|->
name|sadb_msg_errno
operator|=
name|EINVAL
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|sav
operator|->
name|spi
operator|!=
name|sa0
operator|->
name|sadb_sa_spi
condition|)
block|{
name|printf
argument_list|(
literal|"key_update: SPI mismatched (DB:%u param:%u)\n"
argument_list|,
operator|(
name|u_int32_t
operator|)
name|ntohl
argument_list|(
name|sav
operator|->
name|spi
argument_list|)
argument_list|,
operator|(
name|u_int32_t
operator|)
name|ntohl
argument_list|(
name|sa0
operator|->
name|sadb_sa_spi
argument_list|)
argument_list|)
expr_stmt|;
name|msg0
operator|->
name|sadb_msg_errno
operator|=
name|EINVAL
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|sav
operator|->
name|pid
operator|!=
name|msg0
operator|->
name|sadb_msg_pid
condition|)
block|{
name|printf
argument_list|(
literal|"key_update: pid mismatched (DB:%u param:%u)\n"
argument_list|,
name|sav
operator|->
name|pid
argument_list|,
name|msg0
operator|->
name|sadb_msg_pid
argument_list|)
expr_stmt|;
name|msg0
operator|->
name|sadb_msg_errno
operator|=
name|EINVAL
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* copy sav values */
if|if
condition|(
name|key_setsaval
argument_list|(
name|sav
argument_list|,
name|mhp
argument_list|)
condition|)
block|{
name|key_freesav
argument_list|(
name|sav
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* check SA values to be mature. */
if|if
condition|(
operator|(
name|msg0
operator|->
name|sadb_msg_errno
operator|=
name|key_mature
argument_list|(
name|sav
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|key_freesav
argument_list|(
name|sav
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* 	 * we must call key_freesav() whenever we leave a function context, 	 * as we did not allocated a new sav (we updated existing sav). 	 */
name|key_freesav
argument_list|(
name|sav
argument_list|)
expr_stmt|;
name|sav
operator|=
name|NULL
expr_stmt|;
block|{
name|struct
name|sadb_msg
modifier|*
name|newmsg
decl_stmt|;
comment|/* set msg buf from mhp */
if|if
condition|(
operator|(
name|newmsg
operator|=
name|key_getmsgbuf_x1
argument_list|(
name|mhp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"key_update: No more memory.\n"
argument_list|)
expr_stmt|;
name|msg0
operator|->
name|sadb_msg_errno
operator|=
name|ENOBUFS
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|newmsg
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * search SAD with sequence for a SA which state is SADB_SASTATE_LARVAL.  * only called by key_update().  * OUT:  *	NULL	: not found  *	others	: found, pointer to a SA.  */
end_comment

begin_function
specifier|static
name|struct
name|secasvar
modifier|*
name|key_getsavbyseq
parameter_list|(
name|sah
parameter_list|,
name|seq
parameter_list|)
name|struct
name|secashead
modifier|*
name|sah
decl_stmt|;
name|u_int32_t
name|seq
decl_stmt|;
block|{
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|;
name|u_int
name|state
decl_stmt|;
name|state
operator|=
name|SADB_SASTATE_LARVAL
expr_stmt|;
comment|/* search SAD with sequence number ? */
name|__LIST_FOREACH
argument_list|(
argument|sav
argument_list|,
argument|&sah->savtree[state]
argument_list|,
argument|chain
argument_list|)
block|{
name|KEY_CHKSASTATE
argument_list|(
name|state
argument_list|,
name|sav
operator|->
name|state
argument_list|,
literal|"key_getsabyseq"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|seq
operator|==
name|seq
condition|)
block|{
name|sav
operator|->
name|refcnt
operator|++
expr_stmt|;
name|KEYDEBUG
argument_list|(
name|KEYDEBUG_IPSEC_STAMP
argument_list|,
name|printf
argument_list|(
literal|"DP key_getsavbyseq cause "
literal|"refcnt++:%d SA:%p\n"
argument_list|,
name|sav
operator|->
name|refcnt
argument_list|,
name|sav
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|sav
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * SADB_ADD processing  * add a entry to SA database, when received  *<base, SA, (lifetime(HSC),) address(SD), (address(P),)  *       key(AE), (identity(SD),) (sensitivity)>  * from the ikmpd,  * and send  *<base, SA, (lifetime(HSC),) address(SD), (address(P),)  *       (identity(SD),) (sensitivity)>  * to the ikmpd.  *  * IGNORE identity and sensitivity messages.  *  * IN:	mhp: pointer to the pointer to each header.  * OUT:	NULL if fail.  *	other if success, return pointer to the message to send.  */
end_comment

begin_function
specifier|static
name|struct
name|sadb_msg
modifier|*
name|key_add
parameter_list|(
name|mhp
parameter_list|)
name|caddr_t
modifier|*
name|mhp
decl_stmt|;
block|{
name|struct
name|sadb_msg
modifier|*
name|msg0
decl_stmt|;
name|struct
name|sadb_sa
modifier|*
name|sa0
decl_stmt|;
name|struct
name|sadb_address
modifier|*
name|src0
decl_stmt|,
modifier|*
name|dst0
decl_stmt|;
name|struct
name|secasindex
name|saidx
decl_stmt|;
name|struct
name|secashead
modifier|*
name|newsah
decl_stmt|;
name|struct
name|secasvar
modifier|*
name|newsav
decl_stmt|;
name|u_int16_t
name|proto
decl_stmt|;
comment|/* sanity check */
if|if
condition|(
name|mhp
operator|==
name|NULL
operator|||
name|mhp
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_add: NULL pointer is passed.\n"
argument_list|)
expr_stmt|;
name|msg0
operator|=
operator|(
expr|struct
name|sadb_msg
operator|*
operator|)
name|mhp
index|[
literal|0
index|]
expr_stmt|;
comment|/* map satype to proto */
if|if
condition|(
operator|(
name|proto
operator|=
name|key_satype2proto
argument_list|(
name|msg0
operator|->
name|sadb_msg_satype
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"key_add: invalid satype is passed.\n"
argument_list|)
expr_stmt|;
name|msg0
operator|->
name|sadb_msg_errno
operator|=
name|EINVAL
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|mhp
index|[
name|SADB_EXT_SA
index|]
operator|==
name|NULL
operator|||
name|mhp
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
operator|==
name|NULL
operator|||
name|mhp
index|[
name|SADB_EXT_ADDRESS_DST
index|]
operator|==
name|NULL
operator|||
operator|(
name|msg0
operator|->
name|sadb_msg_satype
operator|==
name|SADB_SATYPE_ESP
operator|&&
name|mhp
index|[
name|SADB_EXT_KEY_ENCRYPT
index|]
operator|==
name|NULL
operator|)
operator|||
operator|(
name|msg0
operator|->
name|sadb_msg_satype
operator|==
name|SADB_SATYPE_AH
operator|&&
name|mhp
index|[
name|SADB_EXT_KEY_AUTH
index|]
operator|==
name|NULL
operator|)
operator|||
operator|(
name|mhp
index|[
name|SADB_EXT_LIFETIME_HARD
index|]
operator|!=
name|NULL
operator|&&
name|mhp
index|[
name|SADB_EXT_LIFETIME_SOFT
index|]
operator|==
name|NULL
operator|)
operator|||
operator|(
name|mhp
index|[
name|SADB_EXT_LIFETIME_HARD
index|]
operator|==
name|NULL
operator|&&
name|mhp
index|[
name|SADB_EXT_LIFETIME_SOFT
index|]
operator|!=
name|NULL
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"key_add: invalid message is passed.\n"
argument_list|)
expr_stmt|;
name|msg0
operator|->
name|sadb_msg_errno
operator|=
name|EINVAL
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|sa0
operator|=
operator|(
expr|struct
name|sadb_sa
operator|*
operator|)
name|mhp
index|[
name|SADB_EXT_SA
index|]
expr_stmt|;
name|src0
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
operator|(
name|mhp
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
operator|)
expr_stmt|;
name|dst0
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
operator|(
name|mhp
index|[
name|SADB_EXT_ADDRESS_DST
index|]
operator|)
expr_stmt|;
name|KEY_SETSECASIDX
argument_list|(
name|proto
argument_list|,
name|msg0
operator|->
name|sadb_msg_mode
argument_list|,
name|src0
operator|+
literal|1
argument_list|,
name|dst0
operator|+
literal|1
argument_list|,
operator|&
name|saidx
argument_list|)
expr_stmt|;
comment|/* get a SA header */
if|if
condition|(
operator|(
name|newsah
operator|=
name|key_getsah
argument_list|(
operator|&
name|saidx
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* create a new SA header */
if|if
condition|(
operator|(
name|newsah
operator|=
name|key_newsah
argument_list|(
operator|&
name|saidx
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"key_add: No more memory.\n"
argument_list|)
expr_stmt|;
name|msg0
operator|->
name|sadb_msg_errno
operator|=
name|ENOBUFS
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
comment|/* create new SA entry. */
comment|/* We can create new SA only if SPI is differenct. */
if|if
condition|(
name|key_getsavbyspi
argument_list|(
name|newsah
argument_list|,
name|sa0
operator|->
name|sadb_sa_spi
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"key_add: SA already exists.\n"
argument_list|)
expr_stmt|;
name|msg0
operator|->
name|sadb_msg_errno
operator|=
name|EEXIST
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|(
name|newsav
operator|=
name|key_newsav
argument_list|(
name|mhp
argument_list|,
name|newsah
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* check SA values to be mature. */
if|if
condition|(
operator|(
name|msg0
operator|->
name|sadb_msg_errno
operator|=
name|key_mature
argument_list|(
name|newsav
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|key_freesav
argument_list|(
name|newsav
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* 	 * don't call key_freesav() here, as we would like to keep the SA 	 * in the database on success. 	 */
block|{
name|struct
name|sadb_msg
modifier|*
name|newmsg
decl_stmt|;
comment|/* set msg buf from mhp */
if|if
condition|(
operator|(
name|newmsg
operator|=
name|key_getmsgbuf_x1
argument_list|(
name|mhp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"key_add: No more memory.\n"
argument_list|)
expr_stmt|;
name|msg0
operator|->
name|sadb_msg_errno
operator|=
name|ENOBUFS
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|newmsg
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|sadb_msg
modifier|*
name|key_getmsgbuf_x1
parameter_list|(
name|mhp
parameter_list|)
name|caddr_t
modifier|*
name|mhp
decl_stmt|;
block|{
name|struct
name|sadb_msg
modifier|*
name|msg0
decl_stmt|;
name|struct
name|sadb_msg
modifier|*
name|newmsg
decl_stmt|;
name|u_int
name|len
decl_stmt|;
name|caddr_t
name|p
decl_stmt|;
comment|/* sanity check */
if|if
condition|(
name|mhp
operator|==
name|NULL
operator|||
name|mhp
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_getmsgbuf_x1: NULL pointer is passed.\n"
argument_list|)
expr_stmt|;
name|msg0
operator|=
operator|(
expr|struct
name|sadb_msg
operator|*
operator|)
name|mhp
index|[
literal|0
index|]
expr_stmt|;
comment|/* create new sadb_msg to reply. */
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_sa
argument_list|)
operator|+
name|PFKEY_EXTLEN
argument_list|(
name|mhp
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
argument_list|)
operator|+
name|PFKEY_EXTLEN
argument_list|(
name|mhp
index|[
name|SADB_EXT_ADDRESS_DST
index|]
argument_list|)
operator|+
operator|(
name|mhp
index|[
name|SADB_EXT_LIFETIME_HARD
index|]
operator|==
name|NULL
condition|?
literal|0
else|:
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_lifetime
argument_list|)
operator|)
operator|+
operator|(
name|mhp
index|[
name|SADB_EXT_LIFETIME_SOFT
index|]
operator|==
name|NULL
condition|?
literal|0
else|:
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_lifetime
argument_list|)
operator|)
expr_stmt|;
name|KMALLOC
argument_list|(
name|newmsg
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|newmsg
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|newmsg
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|mhp
index|[
literal|0
index|]
argument_list|,
operator|(
name|caddr_t
operator|)
name|newmsg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|msg0
argument_list|)
argument_list|)
expr_stmt|;
name|newmsg
operator|->
name|sadb_msg_errno
operator|=
literal|0
expr_stmt|;
name|newmsg
operator|->
name|sadb_msg_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|caddr_t
operator|)
name|newmsg
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|msg0
argument_list|)
expr_stmt|;
name|p
operator|=
name|key_setsadbext
argument_list|(
name|p
argument_list|,
name|mhp
index|[
name|SADB_EXT_SA
index|]
argument_list|)
expr_stmt|;
name|p
operator|=
name|key_setsadbext
argument_list|(
name|p
argument_list|,
name|mhp
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
argument_list|)
expr_stmt|;
name|p
operator|=
name|key_setsadbext
argument_list|(
name|p
argument_list|,
name|mhp
index|[
name|SADB_EXT_ADDRESS_DST
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|mhp
index|[
name|SADB_EXT_LIFETIME_HARD
index|]
operator|!=
name|NULL
condition|)
name|p
operator|=
name|key_setsadbext
argument_list|(
name|p
argument_list|,
name|mhp
index|[
name|SADB_EXT_LIFETIME_HARD
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|mhp
index|[
name|SADB_EXT_LIFETIME_SOFT
index|]
operator|!=
name|NULL
condition|)
name|p
operator|=
name|key_setsadbext
argument_list|(
name|p
argument_list|,
name|mhp
index|[
name|SADB_EXT_LIFETIME_SOFT
index|]
argument_list|)
expr_stmt|;
return|return
name|newmsg
return|;
block|}
end_function

begin_comment
comment|/*  * SADB_DELETE processing  * receive  *<base, SA(*), address(SD)>  * from the ikmpd, and set SADB_SASTATE_DEAD,  * and send,  *<base, SA(*), address(SD)>  * to the ikmpd.  *  * IN:	mhp: pointer to the pointer to each header.  * OUT:	NULL if fail.  *	other if success, return pointer to the message to send.  */
end_comment

begin_function
specifier|static
name|struct
name|sadb_msg
modifier|*
name|key_delete
parameter_list|(
name|mhp
parameter_list|)
name|caddr_t
modifier|*
name|mhp
decl_stmt|;
block|{
name|struct
name|sadb_msg
modifier|*
name|msg0
decl_stmt|;
name|struct
name|sadb_sa
modifier|*
name|sa0
decl_stmt|;
name|struct
name|sadb_address
modifier|*
name|src0
decl_stmt|,
modifier|*
name|dst0
decl_stmt|;
name|struct
name|secasindex
name|saidx
decl_stmt|;
name|struct
name|secashead
modifier|*
name|sah
decl_stmt|;
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|;
name|u_int16_t
name|proto
decl_stmt|;
comment|/* sanity check */
if|if
condition|(
name|mhp
operator|==
name|NULL
operator|||
name|mhp
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_delete: NULL pointer is passed.\n"
argument_list|)
expr_stmt|;
name|msg0
operator|=
operator|(
expr|struct
name|sadb_msg
operator|*
operator|)
name|mhp
index|[
literal|0
index|]
expr_stmt|;
comment|/* map satype to proto */
if|if
condition|(
operator|(
name|proto
operator|=
name|key_satype2proto
argument_list|(
name|msg0
operator|->
name|sadb_msg_satype
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"key_delete: invalid satype is passed.\n"
argument_list|)
expr_stmt|;
name|msg0
operator|->
name|sadb_msg_errno
operator|=
name|EINVAL
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|mhp
index|[
name|SADB_EXT_SA
index|]
operator|==
name|NULL
operator|||
name|mhp
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
operator|==
name|NULL
operator|||
name|mhp
index|[
name|SADB_EXT_ADDRESS_DST
index|]
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"key_delete: invalid message is passed.\n"
argument_list|)
expr_stmt|;
name|msg0
operator|->
name|sadb_msg_errno
operator|=
name|EINVAL
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|sa0
operator|=
operator|(
expr|struct
name|sadb_sa
operator|*
operator|)
name|mhp
index|[
name|SADB_EXT_SA
index|]
expr_stmt|;
name|src0
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
operator|(
name|mhp
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
operator|)
expr_stmt|;
name|dst0
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
operator|(
name|mhp
index|[
name|SADB_EXT_ADDRESS_DST
index|]
operator|)
expr_stmt|;
name|KEY_SETSECASIDX
argument_list|(
name|proto
argument_list|,
name|msg0
operator|->
name|sadb_msg_mode
argument_list|,
name|src0
operator|+
literal|1
argument_list|,
name|dst0
operator|+
literal|1
argument_list|,
operator|&
name|saidx
argument_list|)
expr_stmt|;
comment|/* get a SA header */
if|if
condition|(
operator|(
name|sah
operator|=
name|key_getsah
argument_list|(
operator|&
name|saidx
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"key_delete: no SA found.\n"
argument_list|)
expr_stmt|;
name|msg0
operator|->
name|sadb_msg_errno
operator|=
name|ENOENT
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* get a SA with SPI. */
name|sav
operator|=
name|key_getsavbyspi
argument_list|(
name|sah
argument_list|,
name|sa0
operator|->
name|sadb_sa_spi
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"key_delete: no alive SA found.\n"
argument_list|)
expr_stmt|;
name|msg0
operator|->
name|sadb_msg_errno
operator|=
name|ENOENT
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|key_sa_chgstate
argument_list|(
name|sav
argument_list|,
name|SADB_SASTATE_DEAD
argument_list|)
expr_stmt|;
name|key_freesav
argument_list|(
name|sav
argument_list|)
expr_stmt|;
name|sav
operator|=
name|NULL
expr_stmt|;
block|{
name|struct
name|sadb_msg
modifier|*
name|newmsg
decl_stmt|;
name|u_int
name|len
decl_stmt|;
name|caddr_t
name|p
decl_stmt|;
comment|/* create new sadb_msg to reply. */
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_sa
argument_list|)
operator|+
name|PFKEY_EXTLEN
argument_list|(
name|mhp
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
argument_list|)
operator|+
name|PFKEY_EXTLEN
argument_list|(
name|mhp
index|[
name|SADB_EXT_ADDRESS_DST
index|]
argument_list|)
expr_stmt|;
name|KMALLOC
argument_list|(
name|newmsg
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|newmsg
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"key_delete: No more memory.\n"
argument_list|)
expr_stmt|;
name|msg0
operator|->
name|sadb_msg_errno
operator|=
name|ENOBUFS
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|newmsg
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|mhp
index|[
literal|0
index|]
argument_list|,
operator|(
name|caddr_t
operator|)
name|newmsg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|msg0
argument_list|)
argument_list|)
expr_stmt|;
name|newmsg
operator|->
name|sadb_msg_errno
operator|=
literal|0
expr_stmt|;
name|newmsg
operator|->
name|sadb_msg_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|caddr_t
operator|)
name|newmsg
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|msg0
argument_list|)
expr_stmt|;
name|p
operator|=
name|key_setsadbext
argument_list|(
name|p
argument_list|,
name|mhp
index|[
name|SADB_EXT_SA
index|]
argument_list|)
expr_stmt|;
name|p
operator|=
name|key_setsadbext
argument_list|(
name|p
argument_list|,
name|mhp
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
argument_list|)
expr_stmt|;
name|p
operator|=
name|key_setsadbext
argument_list|(
name|p
argument_list|,
name|mhp
index|[
name|SADB_EXT_ADDRESS_DST
index|]
argument_list|)
expr_stmt|;
return|return
name|newmsg
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * SADB_GET processing  * receive  *<base, SA(*), address(SD)>  * from the ikmpd, and get a SP and a SA to respond,  * and send,  *<base, SA, (lifetime(HSC),) address(SD), (address(P),) key(AE),  *       (identity(SD),) (sensitivity)>  * to the ikmpd.  *  * IN:	mhp: pointer to the pointer to each header.  * OUT:	NULL if fail.  *	other if success, return pointer to the message to send.  */
end_comment

begin_function
specifier|static
name|struct
name|sadb_msg
modifier|*
name|key_get
parameter_list|(
name|mhp
parameter_list|)
name|caddr_t
modifier|*
name|mhp
decl_stmt|;
block|{
name|struct
name|sadb_msg
modifier|*
name|msg0
decl_stmt|;
name|struct
name|sadb_sa
modifier|*
name|sa0
decl_stmt|;
name|struct
name|sadb_address
modifier|*
name|src0
decl_stmt|,
modifier|*
name|dst0
decl_stmt|;
name|struct
name|secasindex
name|saidx
decl_stmt|;
name|struct
name|secashead
modifier|*
name|sah
decl_stmt|;
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|;
name|u_int16_t
name|proto
decl_stmt|;
comment|/* sanity check */
if|if
condition|(
name|mhp
operator|==
name|NULL
operator|||
name|mhp
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_get: NULL pointer is passed.\n"
argument_list|)
expr_stmt|;
name|msg0
operator|=
operator|(
expr|struct
name|sadb_msg
operator|*
operator|)
name|mhp
index|[
literal|0
index|]
expr_stmt|;
comment|/* map satype to proto */
if|if
condition|(
operator|(
name|proto
operator|=
name|key_satype2proto
argument_list|(
name|msg0
operator|->
name|sadb_msg_satype
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"key_get: invalid satype is passed.\n"
argument_list|)
expr_stmt|;
name|msg0
operator|->
name|sadb_msg_errno
operator|=
name|EINVAL
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|mhp
index|[
name|SADB_EXT_SA
index|]
operator|==
name|NULL
operator|||
name|mhp
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
operator|==
name|NULL
operator|||
name|mhp
index|[
name|SADB_EXT_ADDRESS_DST
index|]
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"key_get: invalid message is passed.\n"
argument_list|)
expr_stmt|;
name|msg0
operator|->
name|sadb_msg_errno
operator|=
name|EINVAL
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|sa0
operator|=
operator|(
expr|struct
name|sadb_sa
operator|*
operator|)
name|mhp
index|[
name|SADB_EXT_SA
index|]
expr_stmt|;
name|src0
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
operator|(
name|mhp
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
operator|)
expr_stmt|;
name|dst0
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
operator|(
name|mhp
index|[
name|SADB_EXT_ADDRESS_DST
index|]
operator|)
expr_stmt|;
name|KEY_SETSECASIDX
argument_list|(
name|proto
argument_list|,
name|msg0
operator|->
name|sadb_msg_mode
argument_list|,
name|src0
operator|+
literal|1
argument_list|,
name|dst0
operator|+
literal|1
argument_list|,
operator|&
name|saidx
argument_list|)
expr_stmt|;
comment|/* get a SA header */
if|if
condition|(
operator|(
name|sah
operator|=
name|key_getsah
argument_list|(
operator|&
name|saidx
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"key_get: no SA found.\n"
argument_list|)
expr_stmt|;
name|msg0
operator|->
name|sadb_msg_errno
operator|=
name|ENOENT
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* get a SA with SPI. */
name|sav
operator|=
name|key_getsavbyspi
argument_list|(
name|sah
argument_list|,
name|sa0
operator|->
name|sadb_sa_spi
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"key_get: no SA with state of mature found.\n"
argument_list|)
expr_stmt|;
name|msg0
operator|->
name|sadb_msg_errno
operator|=
name|ENOENT
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|{
name|struct
name|sadb_msg
modifier|*
name|newmsg
decl_stmt|;
name|u_int
name|len
decl_stmt|;
name|u_int8_t
name|satype
decl_stmt|;
comment|/* map proto to satype */
if|if
condition|(
operator|(
name|satype
operator|=
name|key_proto2satype
argument_list|(
name|sah
operator|->
name|saidx
operator|.
name|proto
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"key_get: there was invalid proto in SAD.\n"
argument_list|)
expr_stmt|;
name|msg0
operator|->
name|sadb_msg_errno
operator|=
name|EINVAL
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* calculate a length of message buffer */
name|len
operator|=
name|key_getmsglen
argument_list|(
name|sav
argument_list|)
expr_stmt|;
name|KMALLOC
argument_list|(
name|newmsg
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|newmsg
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"key_get: No more memory.\n"
argument_list|)
expr_stmt|;
name|msg0
operator|->
name|sadb_msg_errno
operator|=
name|ENOBUFS
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* create new sadb_msg to reply. */
operator|(
name|void
operator|)
name|key_setdumpsa
argument_list|(
name|newmsg
argument_list|,
name|sav
argument_list|,
name|SADB_GET
argument_list|,
name|satype
argument_list|,
name|msg0
operator|->
name|sadb_msg_seq
argument_list|,
name|msg0
operator|->
name|sadb_msg_pid
argument_list|)
expr_stmt|;
return|return
name|newmsg
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * SADB_ACQUIRE processing called by key_checkrequest() and key_acquire2().  * send  *<base, SA, address(SD), (address(P)),  *       (identity(SD),) (sensitivity,) proposal>  * to KMD, and expect to receive  *<base> with SADB_ACQUIRE if error occured,  * or  *<base, src address, dst address, (SPI range)> with SADB_GETSPI  * from KMD by PF_KEY.  *  * sensitivity is not supported.  *  * OUT:  *    0     : succeed  *    others: error number  */
end_comment

begin_function
specifier|static
name|int
name|key_acquire
parameter_list|(
name|saidx
parameter_list|,
name|spidx
parameter_list|)
name|struct
name|secasindex
modifier|*
name|saidx
decl_stmt|;
name|struct
name|secpolicyindex
modifier|*
name|spidx
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|IPSEC_NONBLOCK_ACQUIRE
name|struct
name|secacq
modifier|*
name|newacq
decl_stmt|;
endif|#
directive|endif
name|u_int8_t
name|satype
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* sanity check */
if|if
condition|(
name|saidx
operator|==
name|NULL
operator|||
name|spidx
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_acquire: NULL pointer is passed.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|satype
operator|=
name|key_proto2satype
argument_list|(
name|saidx
operator|->
name|proto
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"key_acquire: invalid proto is passed.\n"
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|IPSEC_NONBLOCK_ACQUIRE
comment|/* 	 * We never do anything about acquirng SA.  There is anather 	 * solution that kernel blocks to send SADB_ACQUIRE message until 	 * getting something message from IKEd.  In later case, to be 	 * managed with ACQUIRING list. 	 */
comment|/* get a entry to check whether sending message or not. */
if|if
condition|(
operator|(
name|newacq
operator|=
name|key_getacq
argument_list|(
name|saidx
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|key_blockacq_count
operator|<
name|newacq
operator|->
name|count
condition|)
block|{
comment|/* reset counter and do send message. */
name|newacq
operator|->
name|count
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* increment counter and do nothing. */
name|newacq
operator|->
name|count
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
else|else
block|{
comment|/* make new entry for blocking to send SADB_ACQUIRE. */
if|if
condition|(
operator|(
name|newacq
operator|=
name|key_newacq
argument_list|(
name|saidx
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|ENOBUFS
return|;
comment|/* add to acqtree */
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|acqtree
argument_list|,
name|newacq
argument_list|,
name|chain
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|{
name|struct
name|sadb_msg
modifier|*
name|newmsg
init|=
name|NULL
decl_stmt|;
name|union
name|sadb_x_ident_id
name|id
decl_stmt|;
name|u_int
name|len
decl_stmt|;
name|caddr_t
name|p
decl_stmt|;
comment|/* create new sadb_msg to reply. */
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_address
argument_list|)
operator|+
name|PFKEY_ALIGN8
argument_list|(
name|saidx
operator|->
name|src
operator|.
name|__ss_len
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_address
argument_list|)
operator|+
name|PFKEY_ALIGN8
argument_list|(
name|saidx
operator|->
name|dst
operator|.
name|__ss_len
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_ident
argument_list|)
operator|+
name|PFKEY_ALIGN8
argument_list|(
name|spidx
operator|->
name|src
operator|.
name|__ss_len
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_ident
argument_list|)
operator|+
name|PFKEY_ALIGN8
argument_list|(
name|spidx
operator|->
name|dst
operator|.
name|__ss_len
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_prop
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_comb
argument_list|)
expr_stmt|;
comment|/* XXX to be multiple */
name|KMALLOC
argument_list|(
name|newmsg
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|newmsg
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"key_acquire: No more memory.\n"
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|newmsg
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|newmsg
operator|->
name|sadb_msg_version
operator|=
name|PF_KEY_V2
expr_stmt|;
name|newmsg
operator|->
name|sadb_msg_type
operator|=
name|SADB_ACQUIRE
expr_stmt|;
name|newmsg
operator|->
name|sadb_msg_errno
operator|=
literal|0
expr_stmt|;
name|newmsg
operator|->
name|sadb_msg_satype
operator|=
name|satype
expr_stmt|;
name|newmsg
operator|->
name|sadb_msg_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|len
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|IPSEC_NONBLOCK_ACQUIRE
name|newmsg
operator|->
name|sadb_msg_seq
operator|=
name|newacq
operator|->
name|seq
expr_stmt|;
else|#
directive|else
name|newmsg
operator|->
name|sadb_msg_seq
operator|=
operator|(
name|acq_seq
operator|=
operator|(
name|acq_seq
operator|==
operator|~
literal|0
condition|?
literal|1
else|:
operator|++
name|acq_seq
operator|)
operator|)
expr_stmt|;
endif|#
directive|endif
name|newmsg
operator|->
name|sadb_msg_pid
operator|=
literal|0
expr_stmt|;
name|p
operator|=
operator|(
name|caddr_t
operator|)
name|newmsg
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
expr_stmt|;
comment|/* set sadb_address for saidx's. */
name|p
operator|=
name|key_setsadbaddr
argument_list|(
name|p
argument_list|,
name|SADB_EXT_ADDRESS_SRC
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|saidx
operator|->
name|src
argument_list|,
name|_INALENBYAF
argument_list|(
name|saidx
operator|->
name|src
operator|.
name|__ss_family
argument_list|)
operator|<<
literal|3
argument_list|,
name|IPSEC_ULPROTO_ANY
argument_list|)
expr_stmt|;
name|p
operator|=
name|key_setsadbaddr
argument_list|(
name|p
argument_list|,
name|SADB_EXT_ADDRESS_DST
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|saidx
operator|->
name|dst
argument_list|,
name|_INALENBYAF
argument_list|(
name|saidx
operator|->
name|dst
operator|.
name|__ss_family
argument_list|)
operator|<<
literal|3
argument_list|,
name|IPSEC_ULPROTO_ANY
argument_list|)
expr_stmt|;
comment|/* set sadb_address for spidx's. */
name|id
operator|.
name|sadb_x_ident_id_addr
operator|.
name|prefix
operator|=
name|spidx
operator|->
name|prefs
expr_stmt|;
name|id
operator|.
name|sadb_x_ident_id_addr
operator|.
name|ul_proto
operator|=
name|spidx
operator|->
name|ul_proto
expr_stmt|;
name|p
operator|=
name|key_setsadbident
argument_list|(
name|p
argument_list|,
name|SADB_EXT_IDENTITY_SRC
argument_list|,
name|SADB_X_IDENTTYPE_ADDR
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|spidx
operator|->
name|src
argument_list|,
name|spidx
operator|->
name|src
operator|.
name|__ss_len
argument_list|,
operator|*
operator|(
name|u_int64_t
operator|*
operator|)
operator|&
name|id
argument_list|)
expr_stmt|;
name|id
operator|.
name|sadb_x_ident_id_addr
operator|.
name|prefix
operator|=
name|spidx
operator|->
name|prefd
expr_stmt|;
name|id
operator|.
name|sadb_x_ident_id_addr
operator|.
name|ul_proto
operator|=
name|spidx
operator|->
name|ul_proto
expr_stmt|;
name|p
operator|=
name|key_setsadbident
argument_list|(
name|p
argument_list|,
name|SADB_EXT_IDENTITY_DST
argument_list|,
name|SADB_X_IDENTTYPE_ADDR
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|spidx
operator|->
name|dst
argument_list|,
name|spidx
operator|->
name|dst
operator|.
name|__ss_len
argument_list|,
operator|*
operator|(
name|u_int64_t
operator|*
operator|)
operator|&
name|id
argument_list|)
expr_stmt|;
comment|/* create proposal extension */
comment|/* set combination extension */
comment|/* XXX: to be defined by proposal database */
block|{
name|struct
name|sadb_prop
modifier|*
name|prop
decl_stmt|;
name|struct
name|sadb_comb
modifier|*
name|comb
decl_stmt|;
name|prop
operator|=
operator|(
expr|struct
name|sadb_prop
operator|*
operator|)
name|p
expr_stmt|;
name|prop
operator|->
name|sadb_prop_len
operator|=
name|PFKEY_UNIT64
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|prop
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|comb
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX to be multiple */
name|prop
operator|->
name|sadb_prop_exttype
operator|=
name|SADB_EXT_PROPOSAL
expr_stmt|;
name|prop
operator|->
name|sadb_prop_replay
operator|=
literal|32
expr_stmt|;
comment|/* XXX be variable ? */
name|p
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_prop
argument_list|)
expr_stmt|;
name|comb
operator|=
operator|(
expr|struct
name|sadb_comb
operator|*
operator|)
name|p
expr_stmt|;
name|comb
operator|->
name|sadb_comb_auth
operator|=
name|SADB_AALG_SHA1HMAC
expr_stmt|;
comment|/* XXX ??? */
name|comb
operator|->
name|sadb_comb_encrypt
operator|=
name|SADB_EALG_DESCBC
expr_stmt|;
comment|/* XXX ??? */
name|comb
operator|->
name|sadb_comb_flags
operator|=
literal|0
expr_stmt|;
name|comb
operator|->
name|sadb_comb_auth_minbits
operator|=
literal|8
expr_stmt|;
comment|/* XXX */
name|comb
operator|->
name|sadb_comb_auth_maxbits
operator|=
literal|1024
expr_stmt|;
comment|/* XXX */
name|comb
operator|->
name|sadb_comb_encrypt_minbits
operator|=
literal|64
expr_stmt|;
comment|/* XXX */
name|comb
operator|->
name|sadb_comb_encrypt_maxbits
operator|=
literal|64
expr_stmt|;
comment|/* XXX */
name|comb
operator|->
name|sadb_comb_soft_allocations
operator|=
literal|0
expr_stmt|;
name|comb
operator|->
name|sadb_comb_hard_allocations
operator|=
literal|0
expr_stmt|;
name|comb
operator|->
name|sadb_comb_soft_bytes
operator|=
literal|0
expr_stmt|;
name|comb
operator|->
name|sadb_comb_hard_bytes
operator|=
literal|0
expr_stmt|;
name|comb
operator|->
name|sadb_comb_soft_addtime
operator|=
literal|0
expr_stmt|;
name|comb
operator|->
name|sadb_comb_hard_addtime
operator|=
literal|0
expr_stmt|;
name|comb
operator|->
name|sadb_comb_soft_usetime
operator|=
literal|0
expr_stmt|;
name|comb
operator|->
name|sadb_comb_hard_usetime
operator|=
literal|0
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|comb
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|key_sendall
argument_list|(
name|newmsg
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"key_acquire: key_sendall returned %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|IPSEC_NONBLOCK_ACQUIRE
end_ifndef

begin_function
specifier|static
name|struct
name|secacq
modifier|*
name|key_newacq
parameter_list|(
name|saidx
parameter_list|)
name|struct
name|secasindex
modifier|*
name|saidx
decl_stmt|;
block|{
name|struct
name|secacq
modifier|*
name|newacq
decl_stmt|;
comment|/* get new entry */
name|KMALLOC
argument_list|(
name|newacq
argument_list|,
expr|struct
name|secacq
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|secacq
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newacq
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"key_newacq: No more memory.\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|bzero
argument_list|(
name|newacq
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|newacq
argument_list|)
argument_list|)
expr_stmt|;
comment|/* copy secindex */
name|bcopy
argument_list|(
name|saidx
argument_list|,
operator|&
name|newacq
operator|->
name|saidx
argument_list|,
sizeof|sizeof
argument_list|(
name|newacq
operator|->
name|saidx
argument_list|)
argument_list|)
expr_stmt|;
name|newacq
operator|->
name|seq
operator|=
operator|(
name|acq_seq
operator|==
operator|~
literal|0
condition|?
literal|1
else|:
operator|++
name|acq_seq
operator|)
expr_stmt|;
name|newacq
operator|->
name|tick
operator|=
literal|0
expr_stmt|;
name|newacq
operator|->
name|count
operator|=
literal|0
expr_stmt|;
return|return
name|newacq
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|secacq
modifier|*
name|key_getacq
parameter_list|(
name|saidx
parameter_list|)
name|struct
name|secasindex
modifier|*
name|saidx
decl_stmt|;
block|{
name|struct
name|secacq
modifier|*
name|acq
decl_stmt|;
name|__LIST_FOREACH
argument_list|(
argument|acq
argument_list|,
argument|&acqtree
argument_list|,
argument|chain
argument_list|)
block|{
if|if
condition|(
name|key_cmpsaidx_exactly
argument_list|(
name|saidx
argument_list|,
operator|&
name|acq
operator|->
name|saidx
argument_list|)
condition|)
return|return
name|acq
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|secacq
modifier|*
name|key_getacqbyseq
parameter_list|(
name|seq
parameter_list|)
name|u_int32_t
name|seq
decl_stmt|;
block|{
name|struct
name|secacq
modifier|*
name|acq
decl_stmt|;
name|__LIST_FOREACH
argument_list|(
argument|acq
argument_list|,
argument|&acqtree
argument_list|,
argument|chain
argument_list|)
block|{
if|if
condition|(
name|acq
operator|->
name|seq
operator|==
name|seq
condition|)
return|return
name|acq
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * SADB_ACQUIRE processing,  * in first situation, is receiving  *<base>  * from the ikmpd, and clear sequence of its secasvar entry.  *  * In second situation, is receiving  *<base, address(SD), (address(P),) (identity(SD),) (sensitivity,) proposal>  * from a user land process, and return  *<base, address(SD), (address(P),) (identity(SD),) (sensitivity,) proposal>  * to the socket.  *  * IN:	mhp: pointer to the pointer to each header.  * OUT:	NULL if fail.  *	other if success, return pointer to the message to send.  */
end_comment

begin_function
specifier|static
name|struct
name|sadb_msg
modifier|*
name|key_acquire2
parameter_list|(
name|mhp
parameter_list|)
name|caddr_t
modifier|*
name|mhp
decl_stmt|;
block|{
name|struct
name|sadb_msg
modifier|*
name|msg0
decl_stmt|;
name|struct
name|sadb_address
modifier|*
name|src0
decl_stmt|,
modifier|*
name|dst0
decl_stmt|;
name|struct
name|secasindex
name|saidx
decl_stmt|;
name|struct
name|secashead
modifier|*
name|sah
decl_stmt|;
name|u_int16_t
name|proto
decl_stmt|;
comment|/* sanity check */
if|if
condition|(
name|mhp
operator|==
name|NULL
operator|||
name|mhp
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_acquire2: NULL pointer is passed.\n"
argument_list|)
expr_stmt|;
name|msg0
operator|=
operator|(
expr|struct
name|sadb_msg
operator|*
operator|)
name|mhp
index|[
literal|0
index|]
expr_stmt|;
comment|/* 	 * Error message from KMd. 	 * We assume that if error was occured in IKEd, the length of PFKEY 	 * message is equal to the size of sadb_msg structure. 	 * We return ~0 even if error occured in this function. 	 */
if|if
condition|(
name|msg0
operator|->
name|sadb_msg_len
operator|==
name|PFKEY_UNIT64
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|)
condition|)
block|{
ifndef|#
directive|ifndef
name|IPSEC_NONBLOCK_ACQUIRE
name|struct
name|secacq
modifier|*
name|acq
decl_stmt|;
comment|/* check sequence number */
if|if
condition|(
name|msg0
operator|->
name|sadb_msg_seq
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"key_acquire2: must specify sequence number.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|sadb_msg
operator|*
operator|)
operator|~
literal|0
return|;
block|}
if|if
condition|(
operator|(
name|acq
operator|=
name|key_getacqbyseq
argument_list|(
name|msg0
operator|->
name|sadb_msg_seq
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"key_acquire2: "
literal|"invalid sequence number is passed.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|sadb_msg
operator|*
operator|)
operator|~
literal|0
return|;
block|}
comment|/* reset acq counter in order to deletion by timehander. */
name|acq
operator|->
name|tick
operator|=
name|key_blockacq_lifetime
expr_stmt|;
name|acq
operator|->
name|count
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
expr|struct
name|sadb_msg
operator|*
operator|)
operator|~
literal|0
return|;
comment|/* NOTREACHED */
block|}
comment|/* 	 * This message is from user land. 	 */
comment|/* map satype to proto */
if|if
condition|(
operator|(
name|proto
operator|=
name|key_satype2proto
argument_list|(
name|msg0
operator|->
name|sadb_msg_satype
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"key_acquire2: invalid satype is passed.\n"
argument_list|)
expr_stmt|;
name|msg0
operator|->
name|sadb_msg_errno
operator|=
name|EINVAL
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|mhp
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
operator|==
name|NULL
operator|||
name|mhp
index|[
name|SADB_EXT_ADDRESS_DST
index|]
operator|==
name|NULL
operator|||
name|mhp
index|[
name|SADB_EXT_PROPOSAL
index|]
operator|==
name|NULL
condition|)
block|{
comment|/* error */
name|printf
argument_list|(
literal|"key_acquire2: invalid message is passed.\n"
argument_list|)
expr_stmt|;
name|msg0
operator|->
name|sadb_msg_errno
operator|=
name|EINVAL
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|src0
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
operator|(
name|mhp
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
operator|)
expr_stmt|;
name|dst0
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
operator|(
name|mhp
index|[
name|SADB_EXT_ADDRESS_DST
index|]
operator|)
expr_stmt|;
name|KEY_SETSECASIDX
argument_list|(
name|proto
argument_list|,
name|msg0
operator|->
name|sadb_msg_mode
argument_list|,
name|src0
operator|+
literal|1
argument_list|,
name|dst0
operator|+
literal|1
argument_list|,
operator|&
name|saidx
argument_list|)
expr_stmt|;
comment|/* get a SA index */
if|if
condition|(
operator|(
name|sah
operator|=
name|key_getsah
argument_list|(
operator|&
name|saidx
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"key_acquire2: a SA exists already.\n"
argument_list|)
expr_stmt|;
name|msg0
operator|->
name|sadb_msg_errno
operator|=
name|EEXIST
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|msg0
operator|->
name|sadb_msg_errno
operator|=
name|key_acquire
argument_list|(
operator|&
name|saidx
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg0
operator|->
name|sadb_msg_errno
operator|!=
literal|0
condition|)
block|{
comment|/* XXX What I do ? */
name|printf
argument_list|(
literal|"key_acquire2: error %d returned "
literal|"from key_acquire.\n"
argument_list|,
name|msg0
operator|->
name|sadb_msg_errno
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|{
name|struct
name|sadb_msg
modifier|*
name|newmsg
decl_stmt|;
name|u_int
name|len
decl_stmt|;
comment|/* create new sadb_msg to reply. */
name|len
operator|=
name|PFKEY_UNUNIT64
argument_list|(
name|msg0
operator|->
name|sadb_msg_len
argument_list|)
expr_stmt|;
name|KMALLOC
argument_list|(
name|newmsg
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|newmsg
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"key_acquire2: No more memory.\n"
argument_list|)
expr_stmt|;
name|msg0
operator|->
name|sadb_msg_errno
operator|=
name|ENOBUFS
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|newmsg
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|mhp
index|[
literal|0
index|]
argument_list|,
operator|(
name|caddr_t
operator|)
name|newmsg
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|newmsg
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * SADB_REGISTER processing.  * If SATYPE_UNSPEC has been passed as satype, only return sabd_supported.  * receive  *<base>  * from the ikmpd, and register a socket to send PF_KEY messages,  * and send  *<base, supported>  * to KMD by PF_KEY.  * If socket is detached, must free from regnode.  * OUT:  *    0     : succeed  *    others: error number  */
end_comment

begin_function
specifier|static
name|struct
name|sadb_msg
modifier|*
name|key_register
parameter_list|(
name|mhp
parameter_list|,
name|so
parameter_list|)
name|caddr_t
modifier|*
name|mhp
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
block|{
name|struct
name|sadb_msg
modifier|*
name|msg0
decl_stmt|;
name|struct
name|secreg
modifier|*
name|reg
decl_stmt|,
modifier|*
name|newreg
init|=
literal|0
decl_stmt|;
comment|/* sanity check */
if|if
condition|(
name|mhp
operator|==
name|NULL
operator|||
name|so
operator|==
name|NULL
operator|||
name|mhp
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_register: NULL pointer is passed.\n"
argument_list|)
expr_stmt|;
name|msg0
operator|=
operator|(
expr|struct
name|sadb_msg
operator|*
operator|)
name|mhp
index|[
literal|0
index|]
expr_stmt|;
comment|/* When SATYPE_UNSPEC is specified, only return sabd_supported. */
if|if
condition|(
name|msg0
operator|->
name|sadb_msg_satype
operator|==
name|SADB_SATYPE_UNSPEC
condition|)
goto|goto
name|setmsg
goto|;
comment|/* check whether existing or not */
name|__LIST_FOREACH
argument_list|(
argument|reg
argument_list|,
argument|&regtree[msg0->sadb_msg_satype]
argument_list|,
argument|chain
argument_list|)
block|{
if|if
condition|(
name|reg
operator|->
name|so
operator|==
name|so
condition|)
block|{
name|printf
argument_list|(
literal|"key_register: socket exists already.\n"
argument_list|)
expr_stmt|;
name|msg0
operator|->
name|sadb_msg_errno
operator|=
name|EEXIST
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
comment|/* create regnode */
name|KMALLOC
argument_list|(
name|newreg
argument_list|,
expr|struct
name|secreg
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|secreg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newreg
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"key_register: No more memory.\n"
argument_list|)
expr_stmt|;
name|msg0
operator|->
name|sadb_msg_errno
operator|=
name|ENOBUFS
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|newreg
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|secreg
argument_list|)
argument_list|)
expr_stmt|;
name|newreg
operator|->
name|so
operator|=
name|so
expr_stmt|;
operator|(
operator|(
expr|struct
name|keycb
operator|*
operator|)
name|sotorawcb
argument_list|(
name|so
argument_list|)
operator|)
operator|->
name|kp_registered
operator|++
expr_stmt|;
comment|/* add regnode to regtree. */
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|regtree
index|[
name|msg0
operator|->
name|sadb_msg_satype
index|]
argument_list|,
name|newreg
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|setmsg
label|:
block|{
name|struct
name|sadb_msg
modifier|*
name|newmsg
decl_stmt|;
name|struct
name|sadb_supported
modifier|*
name|sup
decl_stmt|;
name|u_int
name|len
decl_stmt|,
name|alen
decl_stmt|,
name|elen
decl_stmt|;
name|caddr_t
name|p
decl_stmt|;
comment|/* create new sadb_msg to reply. */
name|alen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_supported
argument_list|)
operator|+
operator|(
operator|(
name|SADB_AALG_MAX
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_alg
argument_list|)
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IPSEC_ESP
name|elen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_supported
argument_list|)
operator|+
operator|(
operator|(
name|SADB_EALG_MAX
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_alg
argument_list|)
operator|)
expr_stmt|;
else|#
directive|else
name|elen
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
operator|+
name|alen
operator|+
name|elen
expr_stmt|;
name|KMALLOC
argument_list|(
name|newmsg
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|newmsg
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"key_register: No more memory.\n"
argument_list|)
expr_stmt|;
name|msg0
operator|->
name|sadb_msg_errno
operator|=
name|ENOBUFS
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|newmsg
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|mhp
index|[
literal|0
index|]
argument_list|,
operator|(
name|caddr_t
operator|)
name|newmsg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|msg0
argument_list|)
argument_list|)
expr_stmt|;
name|newmsg
operator|->
name|sadb_msg_errno
operator|=
literal|0
expr_stmt|;
name|newmsg
operator|->
name|sadb_msg_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|caddr_t
operator|)
name|newmsg
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|msg0
argument_list|)
expr_stmt|;
comment|/* for authentication algorithm */
name|sup
operator|=
operator|(
expr|struct
name|sadb_supported
operator|*
operator|)
name|p
expr_stmt|;
name|sup
operator|->
name|sadb_supported_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|alen
argument_list|)
expr_stmt|;
name|sup
operator|->
name|sadb_supported_exttype
operator|=
name|SADB_EXT_SUPPORTED_AUTH
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|sup
argument_list|)
expr_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|struct
name|sadb_alg
modifier|*
name|alg
decl_stmt|;
name|struct
name|ah_algorithm
modifier|*
name|algo
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|SADB_AALG_MAX
condition|;
name|i
operator|++
control|)
block|{
name|algo
operator|=
operator|&
name|ah_algorithms
index|[
name|i
index|]
expr_stmt|;
name|alg
operator|=
operator|(
expr|struct
name|sadb_alg
operator|*
operator|)
name|p
expr_stmt|;
name|alg
operator|->
name|sadb_alg_id
operator|=
name|i
expr_stmt|;
name|alg
operator|->
name|sadb_alg_ivlen
operator|=
literal|0
expr_stmt|;
name|alg
operator|->
name|sadb_alg_minbits
operator|=
name|algo
operator|->
name|keymin
expr_stmt|;
name|alg
operator|->
name|sadb_alg_maxbits
operator|=
name|algo
operator|->
name|keymax
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_alg
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|IPSEC_ESP
comment|/* for encryption algorithm */
name|sup
operator|=
operator|(
expr|struct
name|sadb_supported
operator|*
operator|)
name|p
expr_stmt|;
name|sup
operator|->
name|sadb_supported_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|elen
argument_list|)
expr_stmt|;
name|sup
operator|->
name|sadb_supported_exttype
operator|=
name|SADB_EXT_SUPPORTED_ENCRYPT
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|sup
argument_list|)
expr_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|struct
name|sadb_alg
modifier|*
name|alg
decl_stmt|;
name|struct
name|esp_algorithm
modifier|*
name|algo
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|SADB_EALG_MAX
condition|;
name|i
operator|++
control|)
block|{
name|algo
operator|=
operator|&
name|esp_algorithms
index|[
name|i
index|]
expr_stmt|;
name|alg
operator|=
operator|(
expr|struct
name|sadb_alg
operator|*
operator|)
name|p
expr_stmt|;
name|alg
operator|->
name|sadb_alg_id
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|algo
operator|&&
name|algo
operator|->
name|ivlen
condition|)
block|{
comment|/* 			 * give NULL to get the value preferred by algorithm 			 * XXX SADB_X_EXT_DERIV ? 			 */
name|alg
operator|->
name|sadb_alg_ivlen
operator|=
call|(
modifier|*
name|algo
operator|->
name|ivlen
call|)
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
name|alg
operator|->
name|sadb_alg_ivlen
operator|=
literal|0
expr_stmt|;
name|alg
operator|->
name|sadb_alg_minbits
operator|=
name|algo
operator|->
name|keymin
expr_stmt|;
name|alg
operator|->
name|sadb_alg_maxbits
operator|=
name|algo
operator|->
name|keymax
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_alg
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
return|return
name|newmsg
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * free secreg entry registered.  * XXX: I want to do free a socket marked done SADB_RESIGER to socket.  */
end_comment

begin_function
name|void
name|key_freereg
parameter_list|(
name|so
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
block|{
name|struct
name|secreg
modifier|*
name|reg
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* sanity check */
if|if
condition|(
name|so
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_freereg: NULL pointer is passed.\n"
argument_list|)
expr_stmt|;
comment|/* 	 * check whether existing or not. 	 * check all type of SA, because there is a potential that 	 * one socket is registered to multiple type of SA. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|SADB_SATYPE_MAX
condition|;
name|i
operator|++
control|)
block|{
name|__LIST_FOREACH
argument_list|(
argument|reg
argument_list|,
argument|&regtree[i]
argument_list|,
argument|chain
argument_list|)
block|{
if|if
condition|(
name|reg
operator|->
name|so
operator|==
name|so
operator|&&
name|__LIST_CHAINED
argument_list|(
name|reg
argument_list|)
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|reg
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|KFREE
argument_list|(
name|reg
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * SADB_EXPIRE processing  * send  *<base, SA, lifetime(C and one of HS), address(SD)>  * to KMD by PF_KEY.  * NOTE: We send only soft lifetime extension.  *  * OUT:	0	: succeed  *	others	: error number  */
end_comment

begin_function
specifier|static
name|int
name|key_expire
parameter_list|(
name|sav
parameter_list|)
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|;
block|{
name|int
name|s
decl_stmt|;
name|int
name|satype
decl_stmt|;
comment|/* XXX: Why do we lock ? */
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
comment|/*called from softclock()*/
comment|/* sanity check */
if|if
condition|(
name|sav
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_expire: NULL pointer is passed.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|sah
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_expire: Why was SA index in SA NULL.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|satype
operator|=
name|key_proto2satype
argument_list|(
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|proto
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"key_expire: invalid proto is passed.\n"
argument_list|)
expr_stmt|;
block|{
name|struct
name|sadb_msg
modifier|*
name|newmsg
init|=
name|NULL
decl_stmt|;
name|u_int
name|len
decl_stmt|;
name|caddr_t
name|p
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* create new sadb_msg to reply. */
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_sa
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_lifetime
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_lifetime
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_address
argument_list|)
operator|+
name|PFKEY_ALIGN8
argument_list|(
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|src
operator|.
name|__ss_len
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_address
argument_list|)
operator|+
name|PFKEY_ALIGN8
argument_list|(
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|dst
operator|.
name|__ss_len
argument_list|)
expr_stmt|;
name|KMALLOC
argument_list|(
name|newmsg
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|newmsg
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"key_expire: No more memory.\n"
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|newmsg
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* set msg header */
name|p
operator|=
name|key_setsadbmsg
argument_list|(
operator|(
name|caddr_t
operator|)
name|newmsg
argument_list|,
name|SADB_EXPIRE
argument_list|,
name|len
argument_list|,
name|satype
argument_list|,
name|sav
operator|->
name|seq
argument_list|,
literal|0
argument_list|,
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|mode
argument_list|,
name|sav
operator|->
name|refcnt
argument_list|)
expr_stmt|;
comment|/* create SA extension */
name|p
operator|=
name|key_setsadbsa
argument_list|(
name|p
argument_list|,
name|sav
argument_list|)
expr_stmt|;
comment|/* create lifetime extension */
block|{
name|struct
name|sadb_lifetime
modifier|*
name|m_lt
init|=
operator|(
expr|struct
name|sadb_lifetime
operator|*
operator|)
name|p
decl_stmt|;
name|m_lt
operator|->
name|sadb_lifetime_len
operator|=
name|PFKEY_UNIT64
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_lifetime
argument_list|)
argument_list|)
expr_stmt|;
name|m_lt
operator|->
name|sadb_lifetime_exttype
operator|=
name|SADB_EXT_LIFETIME_CURRENT
expr_stmt|;
name|m_lt
operator|->
name|sadb_lifetime_allocations
operator|=
name|sav
operator|->
name|lft_c
operator|->
name|sadb_lifetime_allocations
expr_stmt|;
name|m_lt
operator|->
name|sadb_lifetime_bytes
operator|=
name|sav
operator|->
name|lft_c
operator|->
name|sadb_lifetime_bytes
expr_stmt|;
name|m_lt
operator|->
name|sadb_lifetime_addtime
operator|=
name|sav
operator|->
name|lft_c
operator|->
name|sadb_lifetime_addtime
expr_stmt|;
name|m_lt
operator|->
name|sadb_lifetime_usetime
operator|=
name|sav
operator|->
name|lft_c
operator|->
name|sadb_lifetime_usetime
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_lifetime
argument_list|)
expr_stmt|;
comment|/* copy SOFT lifetime extension. */
name|bcopy
argument_list|(
name|sav
operator|->
name|lft_s
argument_list|,
name|p
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_lifetime
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_lifetime
argument_list|)
expr_stmt|;
block|}
comment|/* set sadb_address for source */
name|p
operator|=
name|key_setsadbaddr
argument_list|(
name|p
argument_list|,
name|SADB_EXT_ADDRESS_SRC
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|src
argument_list|,
name|_INALENBYAF
argument_list|(
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|src
operator|.
name|__ss_family
argument_list|)
operator|<<
literal|3
argument_list|,
name|IPSEC_ULPROTO_ANY
argument_list|)
expr_stmt|;
comment|/* set sadb_address for destination */
name|p
operator|=
name|key_setsadbaddr
argument_list|(
name|p
argument_list|,
name|SADB_EXT_ADDRESS_DST
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|dst
argument_list|,
name|_INALENBYAF
argument_list|(
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|dst
operator|.
name|__ss_family
argument_list|)
operator|<<
literal|3
argument_list|,
name|IPSEC_ULPROTO_ANY
argument_list|)
expr_stmt|;
name|error
operator|=
name|key_sendall
argument_list|(
name|newmsg
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * SADB_FLUSH processing  * receive  *<base>  * from the ikmpd, and free all entries in secastree.  * and send,  *<base>  * to the ikmpd.  * NOTE: to do is only marking SADB_SASTATE_DEAD.  *  * IN:	mhp: pointer to the pointer to each header.  * OUT:	NULL if fail.  *	other if success, return pointer to the message to send.  */
end_comment

begin_function
specifier|static
name|struct
name|sadb_msg
modifier|*
name|key_flush
parameter_list|(
name|mhp
parameter_list|)
name|caddr_t
modifier|*
name|mhp
decl_stmt|;
block|{
name|struct
name|sadb_msg
modifier|*
name|msg0
decl_stmt|;
name|struct
name|secashead
modifier|*
name|sah
decl_stmt|,
modifier|*
name|nextsah
decl_stmt|;
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|,
modifier|*
name|nextsav
decl_stmt|;
name|u_int16_t
name|proto
decl_stmt|;
name|u_int8_t
name|state
decl_stmt|;
name|u_int
name|stateidx
decl_stmt|;
comment|/* sanity check */
if|if
condition|(
name|mhp
operator|==
name|NULL
operator|||
name|mhp
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_flush: NULL pointer is passed.\n"
argument_list|)
expr_stmt|;
name|msg0
operator|=
operator|(
expr|struct
name|sadb_msg
operator|*
operator|)
name|mhp
index|[
literal|0
index|]
expr_stmt|;
comment|/* map satype to proto */
if|if
condition|(
operator|(
name|proto
operator|=
name|key_satype2proto
argument_list|(
name|msg0
operator|->
name|sadb_msg_satype
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"key_flush: invalid satype is passed.\n"
argument_list|)
expr_stmt|;
name|msg0
operator|->
name|sadb_msg_errno
operator|=
name|EINVAL
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* no SATYPE specified, i.e. flushing all SA. */
for|for
control|(
name|sah
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sahtree
argument_list|)
init|;
name|sah
operator|!=
name|NULL
condition|;
name|sah
operator|=
name|nextsah
control|)
block|{
name|nextsah
operator|=
name|LIST_NEXT
argument_list|(
name|sah
argument_list|,
name|chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg0
operator|->
name|sadb_msg_satype
operator|!=
name|SADB_SATYPE_UNSPEC
operator|&&
name|proto
operator|!=
name|sah
operator|->
name|saidx
operator|.
name|proto
condition|)
continue|continue;
for|for
control|(
name|stateidx
operator|=
literal|0
init|;
name|stateidx
operator|<
name|_ARRAYLEN
argument_list|(
name|saorder_state_alive
argument_list|)
condition|;
name|stateidx
operator|++
control|)
block|{
name|state
operator|=
name|saorder_state_any
index|[
name|stateidx
index|]
expr_stmt|;
for|for
control|(
name|sav
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sah
operator|->
name|savtree
index|[
name|state
index|]
argument_list|)
init|;
name|sav
operator|!=
name|NULL
condition|;
name|sav
operator|=
name|nextsav
control|)
block|{
name|nextsav
operator|=
name|LIST_NEXT
argument_list|(
name|sav
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|key_sa_chgstate
argument_list|(
name|sav
argument_list|,
name|SADB_SASTATE_DEAD
argument_list|)
expr_stmt|;
block|}
block|}
name|sah
operator|->
name|state
operator|=
name|SADB_SASTATE_DEAD
expr_stmt|;
block|}
block|{
name|struct
name|sadb_msg
modifier|*
name|newmsg
decl_stmt|;
name|u_int
name|len
decl_stmt|;
comment|/* create new sadb_msg to reply. */
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
expr_stmt|;
name|KMALLOC
argument_list|(
name|newmsg
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|newmsg
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"key_flush: No more memory.\n"
argument_list|)
expr_stmt|;
name|msg0
operator|->
name|sadb_msg_errno
operator|=
name|ENOBUFS
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|newmsg
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|mhp
index|[
literal|0
index|]
argument_list|,
operator|(
name|caddr_t
operator|)
name|newmsg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|msg0
argument_list|)
argument_list|)
expr_stmt|;
name|newmsg
operator|->
name|sadb_msg_errno
operator|=
literal|0
expr_stmt|;
name|newmsg
operator|->
name|sadb_msg_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|len
argument_list|)
expr_stmt|;
return|return
name|newmsg
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * SADB_DUMP processing  * dump all entries including status of DEAD in SAD.  * receive  *<base>  * from the ikmpd, and dump all secasvar leaves  * and send,  *<base> .....  * to the ikmpd.  *  * IN:	mhp: pointer to the pointer to each header.  * OUT:	error code.  0 on success.  */
end_comment

begin_function
specifier|static
name|int
name|key_dump
parameter_list|(
name|mhp
parameter_list|,
name|so
parameter_list|,
name|target
parameter_list|)
name|caddr_t
modifier|*
name|mhp
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|int
name|target
decl_stmt|;
block|{
name|struct
name|sadb_msg
modifier|*
name|msg0
decl_stmt|;
name|struct
name|secashead
modifier|*
name|sah
decl_stmt|;
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|;
name|u_int16_t
name|proto
decl_stmt|;
name|u_int
name|stateidx
decl_stmt|;
name|u_int8_t
name|satype
decl_stmt|;
name|u_int8_t
name|state
decl_stmt|;
name|int
name|len
decl_stmt|,
name|cnt
decl_stmt|;
name|struct
name|sadb_msg
modifier|*
name|newmsg
decl_stmt|;
comment|/* sanity check */
if|if
condition|(
name|mhp
operator|==
name|NULL
operator|||
name|mhp
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_dump: NULL pointer is passed.\n"
argument_list|)
expr_stmt|;
name|msg0
operator|=
operator|(
expr|struct
name|sadb_msg
operator|*
operator|)
name|mhp
index|[
literal|0
index|]
expr_stmt|;
comment|/* map satype to proto */
if|if
condition|(
operator|(
name|proto
operator|=
name|key_satype2proto
argument_list|(
name|msg0
operator|->
name|sadb_msg_satype
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"key_dump: invalid satype is passed.\n"
argument_list|)
expr_stmt|;
name|msg0
operator|->
name|sadb_msg_errno
operator|=
name|EINVAL
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* count sav entries to be sent to the userland. */
name|cnt
operator|=
literal|0
expr_stmt|;
name|__LIST_FOREACH
argument_list|(
argument|sah
argument_list|,
argument|&sahtree
argument_list|,
argument|chain
argument_list|)
block|{
if|if
condition|(
name|msg0
operator|->
name|sadb_msg_satype
operator|!=
name|SADB_SATYPE_UNSPEC
operator|&&
name|proto
operator|!=
name|sah
operator|->
name|saidx
operator|.
name|proto
condition|)
continue|continue;
for|for
control|(
name|stateidx
operator|=
literal|0
init|;
name|stateidx
operator|<
name|_ARRAYLEN
argument_list|(
name|saorder_state_any
argument_list|)
condition|;
name|stateidx
operator|++
control|)
block|{
name|state
operator|=
name|saorder_state_any
index|[
name|stateidx
index|]
expr_stmt|;
name|__LIST_FOREACH
argument_list|(
argument|sav
argument_list|,
argument|&sah->savtree[state]
argument_list|,
argument|chain
argument_list|)
block|{
name|cnt
operator|++
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|cnt
operator|==
literal|0
condition|)
return|return
name|ENOENT
return|;
comment|/* send this to the userland, one at a time. */
name|newmsg
operator|=
name|NULL
expr_stmt|;
name|__LIST_FOREACH
argument_list|(
argument|sah
argument_list|,
argument|&sahtree
argument_list|,
argument|chain
argument_list|)
block|{
if|if
condition|(
name|msg0
operator|->
name|sadb_msg_satype
operator|!=
name|SADB_SATYPE_UNSPEC
operator|&&
name|proto
operator|!=
name|sah
operator|->
name|saidx
operator|.
name|proto
condition|)
continue|continue;
comment|/* map proto to satype */
if|if
condition|(
operator|(
name|satype
operator|=
name|key_proto2satype
argument_list|(
name|sah
operator|->
name|saidx
operator|.
name|proto
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"key_dump: there was invalid proto in SAD.\n"
argument_list|)
expr_stmt|;
name|msg0
operator|->
name|sadb_msg_errno
operator|=
name|EINVAL
expr_stmt|;
return|return
name|NULL
return|;
block|}
for|for
control|(
name|stateidx
operator|=
literal|0
init|;
name|stateidx
operator|<
name|_ARRAYLEN
argument_list|(
name|saorder_state_any
argument_list|)
condition|;
name|stateidx
operator|++
control|)
block|{
name|state
operator|=
name|saorder_state_any
index|[
name|stateidx
index|]
expr_stmt|;
name|__LIST_FOREACH
argument_list|(
argument|sav
argument_list|,
argument|&sah->savtree[state]
argument_list|,
argument|chain
argument_list|)
block|{
name|len
operator|=
name|key_getmsglen
argument_list|(
name|sav
argument_list|)
expr_stmt|;
name|KMALLOC
argument_list|(
name|newmsg
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|newmsg
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"key_dump: No more memory.\n"
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|newmsg
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|--
name|cnt
expr_stmt|;
operator|(
name|void
operator|)
name|key_setdumpsa
argument_list|(
name|newmsg
argument_list|,
name|sav
argument_list|,
name|SADB_DUMP
argument_list|,
name|satype
argument_list|,
name|cnt
argument_list|,
name|msg0
operator|->
name|sadb_msg_pid
argument_list|)
expr_stmt|;
name|key_sendup
argument_list|(
name|so
argument_list|,
name|newmsg
argument_list|,
name|len
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|KFREE
argument_list|(
name|newmsg
argument_list|)
expr_stmt|;
name|newmsg
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * SADB_X_PROMISC processing  */
end_comment

begin_function
specifier|static
name|void
name|key_promisc
parameter_list|(
name|mhp
parameter_list|,
name|so
parameter_list|)
name|caddr_t
modifier|*
name|mhp
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
block|{
name|struct
name|sadb_msg
modifier|*
name|msg0
decl_stmt|;
name|int
name|olen
decl_stmt|;
comment|/* sanity check */
if|if
condition|(
name|mhp
operator|==
name|NULL
operator|||
name|mhp
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_promisc: NULL pointer is passed.\n"
argument_list|)
expr_stmt|;
name|msg0
operator|=
operator|(
expr|struct
name|sadb_msg
operator|*
operator|)
name|mhp
index|[
literal|0
index|]
expr_stmt|;
name|olen
operator|=
name|PFKEY_UNUNIT64
argument_list|(
name|msg0
operator|->
name|sadb_msg_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|olen
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
condition|)
block|{
return|return;
block|}
elseif|else
if|if
condition|(
name|olen
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
condition|)
block|{
comment|/* enable/disable promisc mode */
name|struct
name|keycb
modifier|*
name|kp
decl_stmt|;
name|int
name|target
init|=
literal|0
decl_stmt|;
name|target
operator|=
name|KEY_SENDUP_ONE
expr_stmt|;
if|if
condition|(
name|so
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|(
name|kp
operator|=
operator|(
expr|struct
name|keycb
operator|*
operator|)
name|sotorawcb
argument_list|(
name|so
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|msg0
operator|->
name|sadb_msg_errno
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|sendorig
goto|;
block|}
name|msg0
operator|->
name|sadb_msg_errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|msg0
operator|->
name|sadb_msg_satype
operator|==
literal|1
operator|||
name|msg0
operator|->
name|sadb_msg_satype
operator|==
literal|0
condition|)
block|{
name|kp
operator|->
name|kp_promisc
operator|=
name|msg0
operator|->
name|sadb_msg_satype
expr_stmt|;
block|}
else|else
block|{
name|msg0
operator|->
name|sadb_msg_errno
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|sendorig
goto|;
block|}
comment|/* send the original message back to everyone */
name|msg0
operator|->
name|sadb_msg_errno
operator|=
literal|0
expr_stmt|;
name|target
operator|=
name|KEY_SENDUP_ALL
expr_stmt|;
name|sendorig
label|:
name|key_sendup
argument_list|(
name|so
argument_list|,
name|msg0
argument_list|,
name|PFKEY_UNUNIT64
argument_list|(
name|msg0
operator|->
name|sadb_msg_len
argument_list|)
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* send packet as is */
name|struct
name|sadb_msg
modifier|*
name|msg
decl_stmt|;
name|int
name|len
decl_stmt|;
name|len
operator|=
name|olen
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
expr_stmt|;
name|KMALLOC
argument_list|(
name|msg
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|==
name|NULL
condition|)
block|{
name|msg0
operator|->
name|sadb_msg_errno
operator|=
name|ENOBUFS
expr_stmt|;
name|key_sendup
argument_list|(
name|so
argument_list|,
name|msg0
argument_list|,
name|PFKEY_UNUNIT64
argument_list|(
name|msg0
operator|->
name|sadb_msg_len
argument_list|)
argument_list|,
name|KEY_SENDUP_ONE
argument_list|)
expr_stmt|;
comment|/*XXX*/
block|}
comment|/* XXX if sadb_msg_seq is specified, send to specific pid */
name|key_sendup
argument_list|(
name|so
argument_list|,
name|msg
argument_list|,
name|len
argument_list|,
name|KEY_SENDUP_ALL
argument_list|)
expr_stmt|;
name|KFREE
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * send message to the socket.  * OUT:  *	0	: success  *	others	: fail  */
end_comment

begin_function
specifier|static
name|int
name|key_sendall
parameter_list|(
name|msg
parameter_list|,
name|len
parameter_list|)
name|struct
name|sadb_msg
modifier|*
name|msg
decl_stmt|;
name|u_int
name|len
decl_stmt|;
block|{
name|struct
name|secreg
modifier|*
name|reg
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* sanity check */
if|if
condition|(
name|msg
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_sendall: NULL pointer is passed.\n"
argument_list|)
expr_stmt|;
comment|/* search table registerd socket to send a message. */
name|__LIST_FOREACH
argument_list|(
argument|reg
argument_list|,
argument|&regtree[msg->sadb_msg_satype]
argument_list|,
argument|chain
argument_list|)
block|{
name|error
operator|=
name|key_sendup
argument_list|(
name|reg
operator|->
name|so
argument_list|,
name|msg
argument_list|,
name|len
argument_list|,
name|KEY_SENDUP_ONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|ENOBUFS
condition|)
name|printf
argument_list|(
literal|"key_sendall: No more memory.\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"key_sendall: key_sendup returned %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|KFREE
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
block|}
name|KFREE
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * parse sadb_msg buffer to process PFKEYv2,  * and create a data to response if needed.  * I think to be dealed with mbuf directly.  * IN:  *     msgp  : pointer to pointer to a received buffer pulluped.  *             This is rewrited to response.  *     so    : pointer to socket.  * OUT:  *    length for buffer to send to user process.  */
end_comment

begin_function
name|int
name|key_parse
parameter_list|(
name|msgp
parameter_list|,
name|so
parameter_list|,
name|targetp
parameter_list|)
name|struct
name|sadb_msg
modifier|*
modifier|*
name|msgp
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|int
modifier|*
name|targetp
decl_stmt|;
block|{
name|struct
name|sadb_msg
modifier|*
name|msg
init|=
operator|*
name|msgp
decl_stmt|,
modifier|*
name|newmsg
init|=
name|NULL
decl_stmt|;
name|caddr_t
name|mhp
index|[
name|SADB_EXT_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|u_int
name|orglen
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* sanity check */
if|if
condition|(
name|msg
operator|==
name|NULL
operator|||
name|so
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_parse: NULL pointer is passed.\n"
argument_list|)
expr_stmt|;
name|KEYDEBUG
argument_list|(
argument|KEYDEBUG_KEY_DUMP
argument_list|,
argument|printf(
literal|"key_parse: passed sadb_msg\n"
argument|); 		kdebug_sadb(msg)
argument_list|)
empty_stmt|;
name|orglen
operator|=
name|PFKEY_UNUNIT64
argument_list|(
name|msg
operator|->
name|sadb_msg_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|targetp
condition|)
operator|*
name|targetp
operator|=
name|KEY_SENDUP_ONE
expr_stmt|;
comment|/* check version */
if|if
condition|(
name|msg
operator|->
name|sadb_msg_version
operator|!=
name|PF_KEY_V2
condition|)
block|{
name|printf
argument_list|(
literal|"key_parse: PF_KEY version %u is mismatched.\n"
argument_list|,
name|msg
operator|->
name|sadb_msg_version
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
comment|/* check type */
if|if
condition|(
name|msg
operator|->
name|sadb_msg_type
operator|>
name|SADB_MAX
condition|)
block|{
name|printf
argument_list|(
literal|"key_parse: invalid type %u is passed.\n"
argument_list|,
name|msg
operator|->
name|sadb_msg_type
argument_list|)
expr_stmt|;
name|msg
operator|->
name|sadb_msg_errno
operator|=
name|EINVAL
expr_stmt|;
return|return
name|orglen
return|;
block|}
comment|/* align message. */
if|if
condition|(
name|key_align
argument_list|(
name|msg
argument_list|,
name|mhp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|msg
operator|->
name|sadb_msg_errno
operator|=
name|EINVAL
expr_stmt|;
return|return
name|orglen
return|;
block|}
comment|/* check SA type */
switch|switch
condition|(
name|msg
operator|->
name|sadb_msg_satype
condition|)
block|{
case|case
name|SADB_SATYPE_UNSPEC
case|:
switch|switch
condition|(
name|msg
operator|->
name|sadb_msg_type
condition|)
block|{
case|case
name|SADB_GETSPI
case|:
case|case
name|SADB_UPDATE
case|:
case|case
name|SADB_ADD
case|:
case|case
name|SADB_DELETE
case|:
case|case
name|SADB_GET
case|:
case|case
name|SADB_ACQUIRE
case|:
case|case
name|SADB_EXPIRE
case|:
name|printf
argument_list|(
literal|"key_parse: must specify satype "
literal|"when msg type=%u.\n"
argument_list|,
name|msg
operator|->
name|sadb_msg_type
argument_list|)
expr_stmt|;
name|msg
operator|->
name|sadb_msg_errno
operator|=
name|EINVAL
expr_stmt|;
return|return
name|orglen
return|;
block|}
break|break;
case|case
name|SADB_SATYPE_AH
case|:
case|case
name|SADB_SATYPE_ESP
case|:
switch|switch
condition|(
name|msg
operator|->
name|sadb_msg_type
condition|)
block|{
case|case
name|SADB_X_SPDADD
case|:
case|case
name|SADB_X_SPDDELETE
case|:
case|case
name|SADB_X_SPDGET
case|:
case|case
name|SADB_X_SPDDUMP
case|:
case|case
name|SADB_X_SPDFLUSH
case|:
name|printf
argument_list|(
literal|"key_parse: illegal satype=%u\n"
argument_list|,
name|msg
operator|->
name|sadb_msg_type
argument_list|)
expr_stmt|;
name|msg
operator|->
name|sadb_msg_errno
operator|=
name|EINVAL
expr_stmt|;
return|return
name|orglen
return|;
block|}
break|break;
case|case
name|SADB_SATYPE_RSVP
case|:
case|case
name|SADB_SATYPE_OSPFV2
case|:
case|case
name|SADB_SATYPE_RIPV2
case|:
case|case
name|SADB_SATYPE_MIP
case|:
name|printf
argument_list|(
literal|"key_parse: type %u isn't supported.\n"
argument_list|,
name|msg
operator|->
name|sadb_msg_satype
argument_list|)
expr_stmt|;
name|msg
operator|->
name|sadb_msg_errno
operator|=
name|EOPNOTSUPP
expr_stmt|;
return|return
name|orglen
return|;
case|case
literal|1
case|:
comment|/* XXX: What does it do ? */
if|if
condition|(
name|msg
operator|->
name|sadb_msg_type
operator|==
name|SADB_X_PROMISC
condition|)
break|break;
comment|/*FALLTHROUGH*/
default|default:
name|printf
argument_list|(
literal|"key_parse: invalid type %u is passed.\n"
argument_list|,
name|msg
operator|->
name|sadb_msg_satype
argument_list|)
expr_stmt|;
name|msg
operator|->
name|sadb_msg_errno
operator|=
name|EINVAL
expr_stmt|;
return|return
name|orglen
return|;
block|}
comment|/* check field of upper layer protocol and address family */
if|if
condition|(
name|mhp
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
operator|!=
name|NULL
operator|&&
name|mhp
index|[
name|SADB_EXT_ADDRESS_DST
index|]
operator|!=
name|NULL
condition|)
block|{
name|struct
name|sadb_address
modifier|*
name|src0
decl_stmt|,
modifier|*
name|dst0
decl_stmt|;
name|u_int
name|prefix
decl_stmt|;
name|src0
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
operator|(
name|mhp
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
operator|)
expr_stmt|;
name|dst0
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
operator|(
name|mhp
index|[
name|SADB_EXT_ADDRESS_DST
index|]
operator|)
expr_stmt|;
comment|/* check upper layer protocol */
if|if
condition|(
name|src0
operator|->
name|sadb_address_proto
operator|!=
name|dst0
operator|->
name|sadb_address_proto
condition|)
block|{
name|printf
argument_list|(
literal|"key_parse: upper layer protocol mismatched.\n"
argument_list|)
expr_stmt|;
name|msg
operator|->
name|sadb_msg_errno
operator|=
name|EINVAL
expr_stmt|;
return|return
name|orglen
return|;
block|}
comment|/* check family */
if|if
condition|(
name|PFKEY_ADDR_SADDR
argument_list|(
name|src0
argument_list|)
operator|->
name|sa_family
operator|!=
name|PFKEY_ADDR_SADDR
argument_list|(
name|dst0
argument_list|)
operator|->
name|sa_family
condition|)
block|{
name|printf
argument_list|(
literal|"key_parse: address family mismatched.\n"
argument_list|)
expr_stmt|;
name|msg
operator|->
name|sadb_msg_errno
operator|=
name|EINVAL
expr_stmt|;
return|return
name|orglen
return|;
block|}
name|prefix
operator|=
name|_INALENBYAF
argument_list|(
name|PFKEY_ADDR_SADDR
argument_list|(
name|src0
argument_list|)
operator|->
name|sa_family
argument_list|)
operator|<<
literal|3
expr_stmt|;
comment|/* check max prefixlen */
if|if
condition|(
name|prefix
operator|<
name|src0
operator|->
name|sadb_address_prefixlen
operator|||
name|prefix
operator|<
name|dst0
operator|->
name|sadb_address_prefixlen
condition|)
block|{
name|printf
argument_list|(
literal|"key_parse: illegal prefixlen.\n"
argument_list|)
expr_stmt|;
name|msg
operator|->
name|sadb_msg_errno
operator|=
name|EINVAL
expr_stmt|;
return|return
name|orglen
return|;
block|}
switch|switch
condition|(
name|PFKEY_ADDR_SADDR
argument_list|(
name|src0
argument_list|)
operator|->
name|sa_family
condition|)
block|{
case|case
name|AF_INET
case|:
case|case
name|AF_INET6
case|:
break|break;
default|default:
name|printf
argument_list|(
literal|"key_parse: invalid address family.\n"
argument_list|)
expr_stmt|;
name|msg
operator|->
name|sadb_msg_errno
operator|=
name|EINVAL
expr_stmt|;
return|return
name|orglen
return|;
block|}
comment|/* 		 * prefixlen == 0 is valid because there can be a case when 		 * all addresses are matched. 		 */
block|}
switch|switch
condition|(
name|msg
operator|->
name|sadb_msg_type
condition|)
block|{
case|case
name|SADB_GETSPI
case|:
if|if
condition|(
operator|(
name|newmsg
operator|=
name|key_getspi
argument_list|(
name|mhp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|orglen
return|;
if|if
condition|(
name|targetp
condition|)
operator|*
name|targetp
operator|=
name|KEY_SENDUP_ALL
expr_stmt|;
break|break;
case|case
name|SADB_UPDATE
case|:
if|if
condition|(
operator|(
name|newmsg
operator|=
name|key_update
argument_list|(
name|mhp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|orglen
return|;
if|if
condition|(
name|targetp
condition|)
operator|*
name|targetp
operator|=
name|KEY_SENDUP_ALL
expr_stmt|;
break|break;
case|case
name|SADB_ADD
case|:
if|if
condition|(
operator|(
name|newmsg
operator|=
name|key_add
argument_list|(
name|mhp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|orglen
return|;
if|if
condition|(
name|targetp
condition|)
operator|*
name|targetp
operator|=
name|KEY_SENDUP_ALL
expr_stmt|;
break|break;
case|case
name|SADB_DELETE
case|:
if|if
condition|(
operator|(
name|newmsg
operator|=
name|key_delete
argument_list|(
name|mhp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|orglen
return|;
if|if
condition|(
name|targetp
condition|)
operator|*
name|targetp
operator|=
name|KEY_SENDUP_ALL
expr_stmt|;
break|break;
case|case
name|SADB_GET
case|:
if|if
condition|(
operator|(
name|newmsg
operator|=
name|key_get
argument_list|(
name|mhp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|orglen
return|;
break|break;
case|case
name|SADB_ACQUIRE
case|:
if|if
condition|(
operator|(
name|newmsg
operator|=
name|key_acquire2
argument_list|(
name|mhp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|orglen
return|;
if|if
condition|(
name|newmsg
operator|==
operator|(
expr|struct
name|sadb_msg
operator|*
operator|)
operator|~
literal|0
condition|)
block|{
comment|/* 			 * It's not need to reply because of the message 			 * that was reporting an error occured from the KMd. 			 */
name|KFREE
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
case|case
name|SADB_REGISTER
case|:
if|if
condition|(
operator|(
name|newmsg
operator|=
name|key_register
argument_list|(
name|mhp
argument_list|,
name|so
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|orglen
return|;
if|if
condition|(
name|targetp
condition|)
operator|*
name|targetp
operator|=
name|KEY_SENDUP_REGISTERED
expr_stmt|;
break|break;
case|case
name|SADB_EXPIRE
case|:
name|printf
argument_list|(
literal|"key_parse: why is SADB_EXPIRE received ?\n"
argument_list|)
expr_stmt|;
name|msg
operator|->
name|sadb_msg_errno
operator|=
name|EINVAL
expr_stmt|;
if|if
condition|(
name|targetp
condition|)
operator|*
name|targetp
operator|=
name|KEY_SENDUP_ALL
expr_stmt|;
return|return
name|orglen
return|;
case|case
name|SADB_FLUSH
case|:
if|if
condition|(
operator|(
name|newmsg
operator|=
name|key_flush
argument_list|(
name|mhp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|orglen
return|;
if|if
condition|(
name|targetp
condition|)
operator|*
name|targetp
operator|=
name|KEY_SENDUP_ALL
expr_stmt|;
break|break;
case|case
name|SADB_DUMP
case|:
comment|/* key_dump will call key_sendup() on her own */
name|error
operator|=
name|key_dump
argument_list|(
name|mhp
argument_list|,
name|so
argument_list|,
name|KEY_SENDUP_ONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|msg
operator|->
name|sadb_msg_errno
operator|=
name|error
expr_stmt|;
return|return
name|orglen
return|;
block|}
else|else
block|{
name|KFREE
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
case|case
name|SADB_X_PROMISC
case|:
comment|/* everything is handled in key_promisc() */
name|key_promisc
argument_list|(
name|mhp
argument_list|,
name|so
argument_list|)
expr_stmt|;
name|KFREE
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/*nothing to reply*/
case|case
name|SADB_X_PCHANGE
case|:
name|printf
argument_list|(
literal|"key_parse: SADB_X_PCHANGE isn't supported.\n"
argument_list|)
expr_stmt|;
name|msg
operator|->
name|sadb_msg_errno
operator|=
name|EINVAL
expr_stmt|;
return|return
name|orglen
return|;
case|case
name|SADB_X_SPDADD
case|:
if|if
condition|(
operator|(
name|newmsg
operator|=
name|key_spdadd
argument_list|(
name|mhp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|orglen
return|;
if|if
condition|(
name|targetp
condition|)
operator|*
name|targetp
operator|=
name|KEY_SENDUP_ALL
expr_stmt|;
break|break;
case|case
name|SADB_X_SPDDELETE
case|:
if|if
condition|(
operator|(
name|newmsg
operator|=
name|key_spddelete
argument_list|(
name|mhp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|orglen
return|;
if|if
condition|(
name|targetp
condition|)
operator|*
name|targetp
operator|=
name|KEY_SENDUP_ALL
expr_stmt|;
break|break;
case|case
name|SADB_X_SPDDUMP
case|:
comment|/* key_spddump will call key_sendup() on her own */
name|error
operator|=
name|key_spddump
argument_list|(
name|mhp
argument_list|,
name|so
argument_list|,
name|KEY_SENDUP_ONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|msg
operator|->
name|sadb_msg_errno
operator|=
name|error
expr_stmt|;
return|return
name|orglen
return|;
block|}
else|else
block|{
name|KFREE
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
case|case
name|SADB_X_SPDFLUSH
case|:
if|if
condition|(
operator|(
name|newmsg
operator|=
name|key_spdflush
argument_list|(
name|mhp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|orglen
return|;
if|if
condition|(
name|targetp
condition|)
operator|*
name|targetp
operator|=
name|KEY_SENDUP_ALL
expr_stmt|;
break|break;
default|default:
name|msg
operator|->
name|sadb_msg_errno
operator|=
name|EOPNOTSUPP
expr_stmt|;
return|return
name|orglen
return|;
block|}
comment|/* switch from old sadb_msg to new one if success. */
name|KFREE
argument_list|(
name|msg
argument_list|)
expr_stmt|;
operator|*
name|msgp
operator|=
name|newmsg
expr_stmt|;
return|return
name|PFKEY_UNUNIT64
argument_list|(
operator|(
operator|*
name|msgp
operator|)
operator|->
name|sadb_msg_len
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * set the pointer to each header into message buffer.  * IN:	msg: pointer to message buffer.  *	mhp: pointer to the buffer allocated like below:  *		caddr_t mhp[SADB_EXT_MAX + 1];  * OUT: 0:  *      EINVAL:  */
end_comment

begin_function
specifier|static
name|int
name|key_align
parameter_list|(
name|msg
parameter_list|,
name|mhp
parameter_list|)
name|struct
name|sadb_msg
modifier|*
name|msg
decl_stmt|;
name|caddr_t
modifier|*
name|mhp
decl_stmt|;
block|{
name|struct
name|sadb_ext
modifier|*
name|ext
decl_stmt|;
name|int
name|tlen
decl_stmt|,
name|extlen
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* sanity check */
if|if
condition|(
name|msg
operator|==
name|NULL
operator|||
name|mhp
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_align: NULL pointer is passed.\n"
argument_list|)
expr_stmt|;
comment|/* initialize */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SADB_EXT_MAX
operator|+
literal|1
condition|;
name|i
operator|++
control|)
name|mhp
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|mhp
index|[
literal|0
index|]
operator|=
operator|(
name|caddr_t
operator|)
name|msg
expr_stmt|;
name|tlen
operator|=
name|PFKEY_UNUNIT64
argument_list|(
name|msg
operator|->
name|sadb_msg_len
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
expr_stmt|;
name|ext
operator|=
operator|(
expr|struct
name|sadb_ext
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|msg
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
operator|)
expr_stmt|;
while|while
condition|(
name|tlen
operator|>
literal|0
condition|)
block|{
comment|/* duplicate check */
comment|/* XXX Are there duplication either KEY_AUTH or KEY_ENCRYPT ?*/
if|if
condition|(
name|mhp
index|[
name|ext
operator|->
name|sadb_ext_type
index|]
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"key_align: duplicate ext_type %u is passed.\n"
argument_list|,
name|ext
operator|->
name|sadb_ext_type
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
comment|/* set pointer */
switch|switch
condition|(
name|ext
operator|->
name|sadb_ext_type
condition|)
block|{
case|case
name|SADB_EXT_SA
case|:
case|case
name|SADB_EXT_LIFETIME_CURRENT
case|:
case|case
name|SADB_EXT_LIFETIME_HARD
case|:
case|case
name|SADB_EXT_LIFETIME_SOFT
case|:
case|case
name|SADB_EXT_ADDRESS_SRC
case|:
case|case
name|SADB_EXT_ADDRESS_DST
case|:
case|case
name|SADB_EXT_ADDRESS_PROXY
case|:
case|case
name|SADB_EXT_KEY_AUTH
case|:
comment|/* must to be chek weak keys. */
case|case
name|SADB_EXT_KEY_ENCRYPT
case|:
comment|/* must to be chek weak keys. */
case|case
name|SADB_EXT_IDENTITY_SRC
case|:
case|case
name|SADB_EXT_IDENTITY_DST
case|:
case|case
name|SADB_EXT_SENSITIVITY
case|:
case|case
name|SADB_EXT_PROPOSAL
case|:
case|case
name|SADB_EXT_SUPPORTED_AUTH
case|:
case|case
name|SADB_EXT_SUPPORTED_ENCRYPT
case|:
case|case
name|SADB_EXT_SPIRANGE
case|:
case|case
name|SADB_X_EXT_POLICY
case|:
name|mhp
index|[
name|ext
operator|->
name|sadb_ext_type
index|]
operator|=
operator|(
name|caddr_t
operator|)
name|ext
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"key_align: invalid ext_type %u is passed.\n"
argument_list|,
name|ext
operator|->
name|sadb_ext_type
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|extlen
operator|=
name|PFKEY_UNUNIT64
argument_list|(
name|ext
operator|->
name|sadb_ext_len
argument_list|)
expr_stmt|;
name|tlen
operator|-=
name|extlen
expr_stmt|;
name|ext
operator|=
operator|(
expr|struct
name|sadb_ext
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ext
operator|+
name|extlen
operator|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|key_init
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|key_cb
argument_list|,
sizeof|sizeof
argument_list|(
name|key_cb
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IPSEC_DIR_MAX
condition|;
name|i
operator|++
control|)
block|{
name|LIST_INIT
argument_list|(
operator|&
name|sptree
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|LIST_INIT
argument_list|(
operator|&
name|sahtree
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|SADB_SATYPE_MAX
condition|;
name|i
operator|++
control|)
block|{
name|LIST_INIT
argument_list|(
operator|&
name|regtree
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|IPSEC_NONBLOCK_ACQUIRE
name|LIST_INIT
argument_list|(
operator|&
name|acqtree
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* system default */
name|ip4_def_policy
operator|.
name|policy
operator|=
name|IPSEC_POLICY_NONE
expr_stmt|;
name|ip4_def_policy
operator|.
name|refcnt
operator|++
expr_stmt|;
comment|/*never reclaim this*/
ifdef|#
directive|ifdef
name|INET6
name|ip6_def_policy
operator|.
name|policy
operator|=
name|IPSEC_POLICY_NONE
expr_stmt|;
name|ip6_def_policy
operator|.
name|refcnt
operator|++
expr_stmt|;
comment|/*never reclaim this*/
endif|#
directive|endif
ifndef|#
directive|ifndef
name|IPSEC_DEBUG2
name|timeout
argument_list|(
operator|(
name|void
operator|*
operator|)
name|key_timehandler
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|,
literal|100
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*IPSEC_DEBUG2*/
comment|/* initialize key statistics */
name|keystat
operator|.
name|getspi_count
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"IPsec: Initialized Security Association Processing.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * XXX: maybe This function is called after INBOUND IPsec processing.  *  * Special check for tunnel-mode packets.  * We must make some checks for consistency between inner and outer IP header.  *  * xxx more checks to be provided  */
end_comment

begin_function
name|int
name|key_checktunnelsanity
parameter_list|(
name|sav
parameter_list|,
name|family
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|)
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|;
name|u_int
name|family
decl_stmt|;
name|caddr_t
name|src
decl_stmt|;
name|caddr_t
name|dst
decl_stmt|;
block|{
comment|/* sanity check */
if|if
condition|(
name|sav
operator|->
name|sah
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"sav->sah == NULL at key_checktunnelsanity"
argument_list|)
expr_stmt|;
comment|/* XXX: check inner IP header */
return|return
literal|1
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_define
define|#
directive|define
name|hostnamelen
value|strlen(hostname)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Get FQDN for the host.  * If the administrator configured hostname (by hostname(1)) without  * domain name, returns nothing.  */
end_comment

begin_comment
unit|static const char * key_getfqdn() { 	int i; 	int hasdot; 	static char fqdn[MAXHOSTNAMELEN + 1];  	if (!hostnamelen) 		return NULL;
comment|/* check if it comes with domain name. */
end_comment

begin_comment
unit|hasdot = 0; 	for (i = 0; i< hostnamelen; i++) { 		if (hostname[i] == '.') 			hasdot++; 	} 	if (!hasdot) 		return NULL;
comment|/* NOTE: hostname may not be NUL-terminated. */
end_comment

begin_comment
unit|bzero(fqdn, sizeof(fqdn)); 	bcopy(hostname, fqdn, hostnamelen); 	fqdn[hostnamelen] = '\0'; 	return fqdn; }
comment|/*  * get username@FQDN for the host/user.  */
end_comment

begin_comment
unit|static const char * key_getuserfqdn() { 	const char *host; 	static char userfqdn[MAXHOSTNAMELEN + MAXLOGNAME + 2]; 	struct proc *p = curproc; 	char *q;  	if (!p || !p->p_pgrp || !p->p_pgrp->pg_session) 		return NULL; 	if (!(host = key_getfqdn())) 		return NULL;
comment|/* NOTE: s_login may not be-NUL terminated. */
end_comment

begin_comment
unit|bzero(userfqdn, sizeof(userfqdn)); 	bcopy(p->p_pgrp->pg_session->s_login, userfqdn, MAXLOGNAME); 	userfqdn[MAXLOGNAME] = '\0';
comment|/* safeguard */
end_comment

begin_endif
unit|q = userfqdn + strlen(userfqdn); 	*q++ = '@'; 	bcopy(host, q, strlen(host)); 	q += strlen(host); 	*q++ = '\0';  	return userfqdn; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* record data transfer on SA, and update timestamps */
end_comment

begin_function
name|void
name|key_sa_recordxfer
parameter_list|(
name|sav
parameter_list|,
name|m
parameter_list|)
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|sav
condition|)
name|panic
argument_list|(
literal|"key_sa_recordxfer called with sav == NULL"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
name|panic
argument_list|(
literal|"key_sa_recordxfer called with m == NULL"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sav
operator|->
name|lft_c
condition|)
return|return;
name|sav
operator|->
name|lft_c
operator|->
name|sadb_lifetime_bytes
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
comment|/* to check bytes lifetime is done in key_timehandler(). */
comment|/* 	 * We use the number of packets as the unit of 	 * sadb_lifetime_allocations.  We increment the variable 	 * whenever {esp,ah}_{in,out}put is called. 	 */
name|sav
operator|->
name|lft_c
operator|->
name|sadb_lifetime_allocations
operator|++
expr_stmt|;
comment|/* XXX check for expires? */
comment|/* 	 * NOTE: We record CURRENT sadb_lifetime_usetime by using wall clock, 	 * in seconds.  HARD and SOFT lifetime are measured by the time 	 * difference (again in seconds) from sadb_lifetime_usetime. 	 * 	 *	usetime 	 *	v     expire   expire 	 * -----+-----+--------+---> t 	 *<--------------> HARD 	 *<-----> SOFT 	 */
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|microtime
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
name|sav
operator|->
name|lft_c
operator|->
name|sadb_lifetime_usetime
operator|=
name|tv
operator|.
name|tv_sec
expr_stmt|;
comment|/* XXX check for expires? */
block|}
return|return;
block|}
end_function

begin_comment
comment|/* dumb version */
end_comment

begin_function
name|void
name|key_sa_routechange
parameter_list|(
name|dst
parameter_list|)
name|struct
name|sockaddr
modifier|*
name|dst
decl_stmt|;
block|{
name|struct
name|secashead
modifier|*
name|sah
decl_stmt|;
name|struct
name|route
modifier|*
name|ro
decl_stmt|;
name|__LIST_FOREACH
argument_list|(
argument|sah
argument_list|,
argument|&sahtree
argument_list|,
argument|chain
argument_list|)
block|{
name|ro
operator|=
operator|&
name|sah
operator|->
name|sa_route
expr_stmt|;
if|if
condition|(
name|ro
operator|->
name|ro_rt
operator|&&
name|dst
operator|->
name|sa_len
operator|==
name|ro
operator|->
name|ro_dst
operator|.
name|sa_len
operator|&&
name|bcmp
argument_list|(
name|dst
argument_list|,
operator|&
name|ro
operator|->
name|ro_dst
argument_list|,
name|dst
operator|->
name|sa_len
argument_list|)
operator|==
literal|0
condition|)
block|{
name|RTFREE
argument_list|(
name|ro
operator|->
name|ro_rt
argument_list|)
expr_stmt|;
name|ro
operator|->
name|ro_rt
operator|=
operator|(
expr|struct
name|rtentry
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|key_sa_chgstate
parameter_list|(
name|sav
parameter_list|,
name|state
parameter_list|)
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|;
name|u_int8_t
name|state
decl_stmt|;
block|{
if|if
condition|(
name|sav
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_sa_chgstate called with sav == NULL"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|state
operator|==
name|state
condition|)
return|return;
if|if
condition|(
name|__LIST_CHAINED
argument_list|(
name|sav
argument_list|)
condition|)
name|LIST_REMOVE
argument_list|(
name|sav
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|sav
operator|->
name|state
operator|=
name|state
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|sav
operator|->
name|sah
operator|->
name|savtree
index|[
name|state
index|]
argument_list|,
name|sav
argument_list|,
name|chain
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

