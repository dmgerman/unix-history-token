begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*----------------------------------------------------------------------   key.c :         Key Management Engine for BSD    Copyright 1995 by Bao Phan,  Randall Atkinson,& Dan McDonald,   All Rights Reserved.  All Rights have been assigned to the US   Naval Research Laboratory (NRL).  The NRL Copyright Notice and   License governs distribution and use of this software.    Patents are pending on this technology.  NRL grants a license   to use this technology at no cost under the terms below with   the additional requirement that software, hardware, and    documentation relating to use of this technology must include   the note that:      	This product includes technology developed at and 	licensed from the Information Technology Division,  	US Naval Research Laboratory.  ----------------------------------------------------------------------*/
end_comment

begin_comment
comment|/*---------------------------------------------------------------------- #	@(#)COPYRIGHT	1.1a (NRL) 17 August 1995  COPYRIGHT NOTICE  All of the documentation and software included in this software distribution from the US Naval Research Laboratory (NRL) are copyrighted by their respective developers.  This software and documentation were developed at NRL by various people.  Those developers have each copyrighted the portions that they developed at NRL and have assigned All Rights for those portions to NRL.  Outside the USA, NRL also has copyright on the software developed at NRL. The affected files all contain specific copyright notices and those notices must be retained in any derived work.  NRL LICENSE  NRL grants permission for redistribution and use in source and binary forms, with or without modification, of the software and documentation created at NRL provided that the following conditions are met:  1. Redistributions of source code must retain the above copyright    notice, this list of conditions and the following disclaimer. 2. Redistributions in binary form must reproduce the above copyright    notice, this list of conditions and the following disclaimer in the    documentation and/or other materials provided with the distribution. 3. All advertising materials mentioning features or use of this software    must display the following acknowledgement:  	This product includes software developed at the Information 	Technology Division, US Naval Research Laboratory.  4. Neither the name of the NRL nor the names of its contributors    may be used to endorse or promote products derived from this software    without specific prior written permission.  THE SOFTWARE PROVIDED BY NRL IS PROVIDED BY NRL AND CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL NRL OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  The views and conclusions contained in the software and documentation are those of the authors and should not be interpreted as representing official policies, either expressed or implied, of the US Naval Research Laboratory (NRL).  ----------------------------------------------------------------------*/
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/domain.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<net/raw_cb.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_include
include|#
directive|include
file|<netinet6/in6.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/in6_var.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INET6 */
end_comment

begin_include
include|#
directive|include
file|<netkey/key.h>
end_include

begin_include
include|#
directive|include
file|<netkey/key_debug.h>
end_include

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_SECA
argument_list|,
literal|"key mgmt"
argument_list|,
literal|"security associations, key management"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|SOCKADDR
value|struct sockaddr
end_define

begin_define
define|#
directive|define
name|KMALLOC
parameter_list|(
name|p
parameter_list|,
name|t
parameter_list|,
name|n
parameter_list|)
value|(p = (t) malloc((unsigned long)(n), M_SECA, M_DONTWAIT))
end_define

begin_define
define|#
directive|define
name|KFREE
parameter_list|(
name|p
parameter_list|)
value|free((caddr_t)p, M_SECA);
end_define

begin_define
define|#
directive|define
name|CRITICAL_DCL
value|int critical_s;
end_define

begin_define
define|#
directive|define
name|CRITICAL_START
value|critical_s = splnet()
end_define

begin_define
define|#
directive|define
name|CRITICAL_END
value|splx(critical_s)
end_define

begin_define
define|#
directive|define
name|TIME_SECONDS
value|time.tv_sec
end_define

begin_define
define|#
directive|define
name|CURRENT_PID
value|curproc->p_pid
end_define

begin_define
define|#
directive|define
name|DEFARGS
parameter_list|(
name|arglist
parameter_list|,
name|args
parameter_list|)
value|arglist args;
end_define

begin_define
define|#
directive|define
name|AND
value|;
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_define
define|#
directive|define
name|MAXHASHKEYLEN
value|(2 * sizeof(int) + 2 * sizeof(struct sockaddr_in6))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|MAXHASHKEYLEN
value|(2 * sizeof(int) + 2 * sizeof(struct sockaddr_in))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *  Not clear whether these values should be   *  tweakable at kernel config time.  */
end_comment

begin_define
define|#
directive|define
name|KEYTBLSIZE
value|61
end_define

begin_define
define|#
directive|define
name|KEYALLOCTBLSIZE
value|61
end_define

begin_define
define|#
directive|define
name|SO2SPITBLSIZE
value|61
end_define

begin_comment
comment|/*  *  These values should be tweakable...  *  perhaps by using sysctl  */
end_comment

begin_define
define|#
directive|define
name|MAXLARVALTIME
value|240;
end_define

begin_comment
comment|/* Lifetime of a larval key table entry */
end_comment

begin_define
define|#
directive|define
name|MAXKEYACQUIRE
value|1;
end_define

begin_comment
comment|/* Max number of key acquire messages sent */
end_comment

begin_comment
comment|/*   per destination address               */
end_comment

begin_define
define|#
directive|define
name|MAXACQUIRETIME
value|15;
end_define

begin_comment
comment|/* Lifetime of acquire message */
end_comment

begin_comment
comment|/*  *  Key engine tables and global variables  */
end_comment

begin_decl_stmt
name|struct
name|key_tblnode
name|keytable
index|[
name|KEYTBLSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|key_allocnode
name|keyalloctbl
index|[
name|KEYALLOCTBLSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|key_so2spinode
name|so2spitbl
index|[
name|SO2SPITBLSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|keyso_cb
name|keyso_cb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|key_tblnode
name|nullkeynode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|key_registry
modifier|*
name|keyregtable
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|key_acquirelist
modifier|*
name|key_acquirelist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
name|maxlarvallifetime
init|=
name|MAXLARVALTIME
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|maxkeyacquire
init|=
name|MAXKEYACQUIRE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
name|maxacquiretime
init|=
name|MAXACQUIRETIME
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|SOCKADDR
name|key_addr
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ROUNDUP
parameter_list|(
name|a
parameter_list|)
define|\
value|((a)> 0 ? (1 + (((a) - 1) | (sizeof(long) - 1))) : sizeof(long))
end_define

begin_define
define|#
directive|define
name|ADVANCE
parameter_list|(
name|x
parameter_list|,
name|n
parameter_list|)
define|\
value|{ x += ROUNDUP(n); }
end_define

begin_decl_stmt
specifier|static
name|int
name|my_addr
name|__P
argument_list|(
operator|(
name|SOCKADDR
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|key_sendup
name|__P
argument_list|(
operator|(
expr|struct
name|socket
operator|*
operator|,
expr|struct
name|key_msghdr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*----------------------------------------------------------------------  * key_secassoc2msghdr():   *      Copy info from a security association into a key message buffer.  *      Assume message buffer is sufficiently large to hold all security  *      association information including src, dst, from, key and iv.  ----------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|key_secassoc2msghdr
parameter_list|(
name|struct
name|key_secassoc
modifier|*
name|secassoc
parameter_list|,
name|struct
name|key_msghdr
modifier|*
name|km
parameter_list|,
name|struct
name|key_msgdata
modifier|*
name|keyinfo
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|DPRINTF
argument_list|(
name|IDL_FINISHED
argument_list|,
operator|(
literal|"Entering key_secassoc2msghdr\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|km
operator|==
literal|0
operator|)
operator|||
operator|(
name|keyinfo
operator|==
literal|0
operator|)
operator|||
operator|(
name|secassoc
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|km
operator|->
name|type
operator|=
name|secassoc
operator|->
name|type
expr_stmt|;
name|km
operator|->
name|state
operator|=
name|secassoc
operator|->
name|state
expr_stmt|;
name|km
operator|->
name|label
operator|=
name|secassoc
operator|->
name|label
expr_stmt|;
name|km
operator|->
name|spi
operator|=
name|secassoc
operator|->
name|spi
expr_stmt|;
name|km
operator|->
name|keylen
operator|=
name|secassoc
operator|->
name|keylen
expr_stmt|;
name|km
operator|->
name|ivlen
operator|=
name|secassoc
operator|->
name|ivlen
expr_stmt|;
name|km
operator|->
name|algorithm
operator|=
name|secassoc
operator|->
name|algorithm
expr_stmt|;
name|km
operator|->
name|lifetype
operator|=
name|secassoc
operator|->
name|lifetype
expr_stmt|;
name|km
operator|->
name|lifetime1
operator|=
name|secassoc
operator|->
name|lifetime1
expr_stmt|;
name|km
operator|->
name|lifetime2
operator|=
name|secassoc
operator|->
name|lifetime2
expr_stmt|;
comment|/*    *  Stuff src/dst/from/key/iv in buffer after    *  the message header.    */
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|km
operator|+
literal|1
operator|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|IDL_FINISHED
argument_list|,
operator|(
literal|"sa2msghdr: 1\n"
operator|)
argument_list|)
expr_stmt|;
name|keyinfo
operator|->
name|src
operator|=
operator|(
name|SOCKADDR
operator|*
operator|)
name|cp
expr_stmt|;
if|if
condition|(
name|secassoc
operator|->
name|src
operator|->
name|sa_len
condition|)
block|{
name|bcopy
argument_list|(
name|secassoc
operator|->
name|src
argument_list|,
name|cp
argument_list|,
name|secassoc
operator|->
name|src
operator|->
name|sa_len
argument_list|)
expr_stmt|;
name|ADVANCE
argument_list|(
name|cp
argument_list|,
name|secassoc
operator|->
name|src
operator|->
name|sa_len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bzero
argument_list|(
name|cp
argument_list|,
name|MAX_SOCKADDR_SZ
argument_list|)
expr_stmt|;
name|ADVANCE
argument_list|(
name|cp
argument_list|,
name|MAX_SOCKADDR_SZ
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
name|IDL_FINISHED
argument_list|,
operator|(
literal|"sa2msghdr: 2\n"
operator|)
argument_list|)
expr_stmt|;
name|keyinfo
operator|->
name|dst
operator|=
operator|(
name|SOCKADDR
operator|*
operator|)
name|cp
expr_stmt|;
if|if
condition|(
name|secassoc
operator|->
name|dst
operator|->
name|sa_len
condition|)
block|{
name|bcopy
argument_list|(
name|secassoc
operator|->
name|dst
argument_list|,
name|cp
argument_list|,
name|secassoc
operator|->
name|dst
operator|->
name|sa_len
argument_list|)
expr_stmt|;
name|ADVANCE
argument_list|(
name|cp
argument_list|,
name|secassoc
operator|->
name|dst
operator|->
name|sa_len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bzero
argument_list|(
name|cp
argument_list|,
name|MAX_SOCKADDR_SZ
argument_list|)
expr_stmt|;
name|ADVANCE
argument_list|(
name|cp
argument_list|,
name|MAX_SOCKADDR_SZ
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
name|IDL_FINISHED
argument_list|,
operator|(
literal|"sa2msghdr: 3\n"
operator|)
argument_list|)
expr_stmt|;
name|keyinfo
operator|->
name|from
operator|=
operator|(
name|SOCKADDR
operator|*
operator|)
name|cp
expr_stmt|;
if|if
condition|(
name|secassoc
operator|->
name|from
operator|->
name|sa_len
condition|)
block|{
name|bcopy
argument_list|(
name|secassoc
operator|->
name|from
argument_list|,
name|cp
argument_list|,
name|secassoc
operator|->
name|from
operator|->
name|sa_len
argument_list|)
expr_stmt|;
name|ADVANCE
argument_list|(
name|cp
argument_list|,
name|secassoc
operator|->
name|from
operator|->
name|sa_len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bzero
argument_list|(
name|cp
argument_list|,
name|MAX_SOCKADDR_SZ
argument_list|)
expr_stmt|;
name|ADVANCE
argument_list|(
name|cp
argument_list|,
name|MAX_SOCKADDR_SZ
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
name|IDL_FINISHED
argument_list|,
operator|(
literal|"sa2msghdr: 4\n"
operator|)
argument_list|)
expr_stmt|;
name|keyinfo
operator|->
name|key
operator|=
name|cp
expr_stmt|;
name|keyinfo
operator|->
name|keylen
operator|=
name|secassoc
operator|->
name|keylen
expr_stmt|;
if|if
condition|(
name|secassoc
operator|->
name|keylen
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|secassoc
operator|->
name|key
operator|)
argument_list|,
name|cp
argument_list|,
name|secassoc
operator|->
name|keylen
argument_list|)
expr_stmt|;
name|ADVANCE
argument_list|(
name|cp
argument_list|,
name|secassoc
operator|->
name|keylen
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
name|IDL_FINISHED
argument_list|,
operator|(
literal|"sa2msghdr: 5\n"
operator|)
argument_list|)
expr_stmt|;
name|keyinfo
operator|->
name|iv
operator|=
name|cp
expr_stmt|;
name|keyinfo
operator|->
name|ivlen
operator|=
name|secassoc
operator|->
name|ivlen
expr_stmt|;
if|if
condition|(
name|secassoc
operator|->
name|ivlen
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|secassoc
operator|->
name|iv
operator|)
argument_list|,
name|cp
argument_list|,
name|secassoc
operator|->
name|ivlen
argument_list|)
expr_stmt|;
name|ADVANCE
argument_list|(
name|cp
argument_list|,
name|secassoc
operator|->
name|ivlen
argument_list|)
expr_stmt|;
block|}
name|DDO
argument_list|(
name|IDL_FINISHED
argument_list|,
name|printf
argument_list|(
literal|"msgbuf(len=%d):\n"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cp
operator|-
operator|(
name|char
operator|*
operator|)
name|km
argument_list|)
argument_list|)
expr_stmt|;
name|DDO
argument_list|(
name|IDL_FINISHED
argument_list|,
name|dump_buf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|km
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cp
operator|-
operator|(
name|char
operator|*
operator|)
name|km
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|IDL_FINISHED
argument_list|,
operator|(
literal|"sa2msghdr: 6\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------  * key_msghdr2secassoc():  *      Copy info from a key message buffer into a key_secassoc   *      structure  ----------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|key_msghdr2secassoc
parameter_list|(
name|struct
name|key_secassoc
modifier|*
name|secassoc
parameter_list|,
name|struct
name|key_msghdr
modifier|*
name|km
parameter_list|,
name|struct
name|key_msgdata
modifier|*
name|keyinfo
parameter_list|)
block|{
name|DPRINTF
argument_list|(
name|IDL_FINISHED
argument_list|,
operator|(
literal|"Entering key_msghdr2secassoc\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|km
operator|==
literal|0
operator|)
operator|||
operator|(
name|keyinfo
operator|==
literal|0
operator|)
operator|||
operator|(
name|secassoc
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|secassoc
operator|->
name|len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|secassoc
argument_list|)
expr_stmt|;
name|secassoc
operator|->
name|type
operator|=
name|km
operator|->
name|type
expr_stmt|;
name|secassoc
operator|->
name|state
operator|=
name|km
operator|->
name|state
expr_stmt|;
name|secassoc
operator|->
name|label
operator|=
name|km
operator|->
name|label
expr_stmt|;
name|secassoc
operator|->
name|spi
operator|=
name|km
operator|->
name|spi
expr_stmt|;
name|secassoc
operator|->
name|keylen
operator|=
name|km
operator|->
name|keylen
expr_stmt|;
name|secassoc
operator|->
name|ivlen
operator|=
name|km
operator|->
name|ivlen
expr_stmt|;
name|secassoc
operator|->
name|algorithm
operator|=
name|km
operator|->
name|algorithm
expr_stmt|;
name|secassoc
operator|->
name|lifetype
operator|=
name|km
operator|->
name|lifetype
expr_stmt|;
name|secassoc
operator|->
name|lifetime1
operator|=
name|km
operator|->
name|lifetime1
expr_stmt|;
name|secassoc
operator|->
name|lifetime2
operator|=
name|km
operator|->
name|lifetime2
expr_stmt|;
if|if
condition|(
name|keyinfo
operator|->
name|src
condition|)
block|{
name|KMALLOC
argument_list|(
name|secassoc
operator|->
name|src
argument_list|,
name|SOCKADDR
operator|*
argument_list|,
name|keyinfo
operator|->
name|src
operator|->
name|sa_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|secassoc
operator|->
name|src
condition|)
block|{
name|DPRINTF
argument_list|(
name|IDL_ERROR
argument_list|,
operator|(
literal|"msghdr2secassoc: can't allocate mem for src\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|keyinfo
operator|->
name|src
argument_list|,
operator|(
name|char
operator|*
operator|)
name|secassoc
operator|->
name|src
argument_list|,
name|keyinfo
operator|->
name|src
operator|->
name|sa_len
argument_list|)
expr_stmt|;
block|}
else|else
name|secassoc
operator|->
name|src
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|keyinfo
operator|->
name|dst
condition|)
block|{
name|KMALLOC
argument_list|(
name|secassoc
operator|->
name|dst
argument_list|,
name|SOCKADDR
operator|*
argument_list|,
name|keyinfo
operator|->
name|dst
operator|->
name|sa_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|secassoc
operator|->
name|dst
condition|)
block|{
name|DPRINTF
argument_list|(
name|IDL_ERROR
argument_list|,
operator|(
literal|"msghdr2secassoc: can't allocate mem for dst\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|keyinfo
operator|->
name|dst
argument_list|,
operator|(
name|char
operator|*
operator|)
name|secassoc
operator|->
name|dst
argument_list|,
name|keyinfo
operator|->
name|dst
operator|->
name|sa_len
argument_list|)
expr_stmt|;
block|}
else|else
name|secassoc
operator|->
name|dst
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|keyinfo
operator|->
name|from
condition|)
block|{
name|KMALLOC
argument_list|(
name|secassoc
operator|->
name|from
argument_list|,
name|SOCKADDR
operator|*
argument_list|,
name|keyinfo
operator|->
name|from
operator|->
name|sa_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|secassoc
operator|->
name|from
condition|)
block|{
name|DPRINTF
argument_list|(
name|IDL_ERROR
argument_list|,
operator|(
literal|"msghdr2secassoc: can't allocate mem for from\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|keyinfo
operator|->
name|from
argument_list|,
operator|(
name|char
operator|*
operator|)
name|secassoc
operator|->
name|from
argument_list|,
name|keyinfo
operator|->
name|from
operator|->
name|sa_len
argument_list|)
expr_stmt|;
block|}
else|else
name|secassoc
operator|->
name|from
operator|=
name|NULL
expr_stmt|;
comment|/*    *  Make copies of key and iv    */
if|if
condition|(
name|secassoc
operator|->
name|ivlen
condition|)
block|{
name|KMALLOC
argument_list|(
name|secassoc
operator|->
name|iv
argument_list|,
name|caddr_t
argument_list|,
name|secassoc
operator|->
name|ivlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|secassoc
operator|->
name|iv
operator|==
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|IDL_ERROR
argument_list|,
operator|(
literal|"msghdr2secassoc: can't allocate mem for iv\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|keyinfo
operator|->
name|iv
argument_list|,
operator|(
name|char
operator|*
operator|)
name|secassoc
operator|->
name|iv
argument_list|,
name|secassoc
operator|->
name|ivlen
argument_list|)
expr_stmt|;
block|}
else|else
name|secassoc
operator|->
name|iv
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|secassoc
operator|->
name|keylen
condition|)
block|{
name|KMALLOC
argument_list|(
name|secassoc
operator|->
name|key
argument_list|,
name|caddr_t
argument_list|,
name|secassoc
operator|->
name|keylen
argument_list|)
expr_stmt|;
if|if
condition|(
name|secassoc
operator|->
name|key
operator|==
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|IDL_ERROR
argument_list|,
operator|(
literal|"msghdr2secassoc: can't allocate mem for key\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|secassoc
operator|->
name|iv
condition|)
name|KFREE
argument_list|(
name|secassoc
operator|->
name|iv
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|keyinfo
operator|->
name|key
argument_list|,
operator|(
name|char
operator|*
operator|)
name|secassoc
operator|->
name|key
argument_list|,
name|secassoc
operator|->
name|keylen
argument_list|)
expr_stmt|;
block|}
else|else
name|secassoc
operator|->
name|key
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------  * addrpart_equal():  *      Determine if the address portion of two sockaddrs are equal.  *      Currently handles only AF_INET and AF_INET6 address families.  ----------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|addrpart_equal
parameter_list|(
name|SOCKADDR
modifier|*
name|sa1
parameter_list|,
name|SOCKADDR
modifier|*
name|sa2
parameter_list|)
block|{
if|if
condition|(
operator|(
name|sa1
operator|->
name|sa_family
operator|!=
name|sa2
operator|->
name|sa_family
operator|)
operator|||
operator|(
name|sa1
operator|->
name|sa_len
operator|!=
name|sa2
operator|->
name|sa_len
operator|)
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|sa1
operator|->
name|sa_family
condition|)
block|{
case|case
name|AF_INET
case|:
return|return
operator|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sa1
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sa2
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
operator|)
return|;
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
return|return
operator|(
name|IN6_ADDR_EQUAL
argument_list|(
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sa1
operator|)
operator|->
name|sin6_addr
argument_list|,
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sa2
operator|)
operator|->
name|sin6_addr
argument_list|)
operator|)
return|;
endif|#
directive|endif
comment|/* INET6 */
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------  * key_inittables():  *      Allocate space and initialize key engine tables  ----------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|key_inittables
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|KMALLOC
argument_list|(
name|keyregtable
argument_list|,
expr|struct
name|key_registry
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|key_registry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|keyregtable
condition|)
return|return
operator|-
literal|1
return|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|keyregtable
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|key_registry
argument_list|)
argument_list|)
expr_stmt|;
name|KMALLOC
argument_list|(
name|key_acquirelist
argument_list|,
expr|struct
name|key_acquirelist
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|key_acquirelist
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|key_acquirelist
condition|)
return|return
operator|-
literal|1
return|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|key_acquirelist
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|key_acquirelist
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|KEYTBLSIZE
condition|;
name|i
operator|++
control|)
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|keytable
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|key_tblnode
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|KEYALLOCTBLSIZE
condition|;
name|i
operator|++
control|)
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|keyalloctbl
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|key_allocnode
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SO2SPITBLSIZE
condition|;
name|i
operator|++
control|)
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|so2spitbl
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|key_so2spinode
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|key_freetables
parameter_list|(
name|void
parameter_list|)
block|{
name|KFREE
argument_list|(
name|keyregtable
argument_list|)
expr_stmt|;
name|keyregtable
operator|=
name|NULL
expr_stmt|;
name|KFREE
argument_list|(
name|key_acquirelist
argument_list|)
expr_stmt|;
name|key_acquirelist
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------  * key_gethashval():  *      Determine keytable hash value.  ----------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|key_gethashval
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|tblsize
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|;
comment|/*     * Todo: Use word size xor and check for alignment    *       and zero pad if necessary.  Need to also pick     *       a good hash function and table size.    */
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|IDL_ERROR
argument_list|,
operator|(
literal|"key_gethashval got bogus len!\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|j
operator|^=
call|(
name|u_int8_t
call|)
argument_list|(
operator|*
operator|(
name|buf
operator|+
name|i
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|j
operator|%
name|tblsize
operator|)
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------  * key_createkey():  *      Create hash key for hash function  *      key is: type+src+dst if keytype = 1  *              type+src+dst+spi if keytype = 0  *      Uses only the address portion of the src and dst sockaddrs to   *      form key.  Currently handles only AF_INET and AF_INET6 sockaddrs  ----------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|key_createkey
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|u_int
name|type
parameter_list|,
name|SOCKADDR
modifier|*
name|src
parameter_list|,
name|SOCKADDR
modifier|*
name|dst
parameter_list|,
name|u_int32_t
name|spi
parameter_list|,
name|u_int
name|keytype
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|DPRINTF
argument_list|(
name|IDL_FINISHED
argument_list|,
operator|(
literal|"Entering key_createkey\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
operator|||
operator|!
name|src
operator|||
operator|!
name|dst
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|cp
operator|=
name|buf
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|type
argument_list|,
name|cp
argument_list|,
sizeof|sizeof
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|type
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INET6
comment|/*    * Assume only IPv4 and IPv6 addresses.    */
define|#
directive|define
name|ADDRPART
parameter_list|(
name|a
parameter_list|)
define|\
value|((a)->sa_family == AF_INET6) ? \     (char *)&(((struct sockaddr_in6 *)(a))->sin6_addr) : \     (char *)&(((struct sockaddr_in *)(a))->sin_addr)
define|#
directive|define
name|ADDRSIZE
parameter_list|(
name|a
parameter_list|)
define|\
value|((a)->sa_family == AF_INET6) ? sizeof(struct in_addr6) : \     sizeof(struct in_addr)
else|#
directive|else
comment|/* INET6 */
define|#
directive|define
name|ADDRPART
parameter_list|(
name|a
parameter_list|)
value|(char *)&(((struct sockaddr_in *)(a))->sin_addr)
define|#
directive|define
name|ADDRSIZE
parameter_list|(
name|a
parameter_list|)
value|sizeof(struct in_addr)
endif|#
directive|endif
comment|/* INET6 */
name|DPRINTF
argument_list|(
name|IDL_FINISHED
argument_list|,
operator|(
literal|"src addr:\n"
operator|)
argument_list|)
expr_stmt|;
name|DDO
argument_list|(
name|IDL_FINISHED
argument_list|,
name|dump_smart_sockaddr
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|IDL_FINISHED
argument_list|,
operator|(
literal|"dst addr:\n"
operator|)
argument_list|)
expr_stmt|;
name|DDO
argument_list|(
name|IDL_FINISHED
argument_list|,
name|dump_smart_sockaddr
argument_list|(
name|dst
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|ADDRPART
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|p
argument_list|,
name|cp
argument_list|,
name|ADDRSIZE
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|ADDRSIZE
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|p
operator|=
name|ADDRPART
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|p
argument_list|,
name|cp
argument_list|,
name|ADDRSIZE
argument_list|(
name|dst
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|ADDRSIZE
argument_list|(
name|dst
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|ADDRPART
undef|#
directive|undef
name|ADDRSIZE
if|if
condition|(
name|keytype
operator|==
literal|0
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|spi
argument_list|,
name|cp
argument_list|,
sizeof|sizeof
argument_list|(
name|spi
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|spi
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
name|IDL_FINISHED
argument_list|,
operator|(
literal|"hash key:\n"
operator|)
argument_list|)
expr_stmt|;
name|DDO
argument_list|(
name|IDL_FINISHED
argument_list|,
name|dump_buf
argument_list|(
name|buf
argument_list|,
name|cp
operator|-
name|buf
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|cp
operator|-
name|buf
operator|)
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------  * key_sosearch():  *      Search the so2spi table for the security association allocated to   *      the socket.  Returns pointer to a struct key_so2spinode which can  *      be used to locate the security association entry in the keytable.  ----------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|struct
name|key_so2spinode
modifier|*
name|key_sosearch
parameter_list|(
name|u_int
name|type
parameter_list|,
name|SOCKADDR
modifier|*
name|src
parameter_list|,
name|SOCKADDR
modifier|*
name|dst
parameter_list|,
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|key_so2spinode
modifier|*
name|np
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|src
operator|&&
name|dst
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
name|IDL_ERROR
argument_list|,
operator|(
literal|"key_sosearch: got null src or dst pointer!\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
for|for
control|(
name|np
operator|=
name|so2spitbl
index|[
operator|(
operator|(
name|u_int32_t
operator|)
name|so
operator|)
operator|%
name|SO2SPITBLSIZE
index|]
operator|.
name|next
init|;
name|np
condition|;
name|np
operator|=
name|np
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|so
operator|==
name|np
operator|->
name|socket
operator|)
operator|&&
operator|(
name|type
operator|==
name|np
operator|->
name|keynode
operator|->
name|secassoc
operator|->
name|type
operator|)
operator|&&
name|addrpart_equal
argument_list|(
name|src
argument_list|,
name|np
operator|->
name|keynode
operator|->
name|secassoc
operator|->
name|src
argument_list|)
operator|&&
name|addrpart_equal
argument_list|(
name|dst
argument_list|,
name|np
operator|->
name|keynode
operator|->
name|secassoc
operator|->
name|dst
argument_list|)
condition|)
return|return
operator|(
name|np
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------  * key_sodelete():  *      Delete entries from the so2spi table.  *        flag = 1  purge all entries  *        flag = 0  delete entries with socket pointer matching socket    ----------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|key_sodelete
parameter_list|(
name|struct
name|socket
modifier|*
name|socket
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|struct
name|key_so2spinode
modifier|*
name|prevnp
decl_stmt|,
modifier|*
name|np
decl_stmt|;
name|CRITICAL_DCL
name|CRITICAL_START
decl_stmt|;
name|DPRINTF
argument_list|(
name|IDL_EVENT
argument_list|,
operator|(
literal|"Entering keysodelete w/so=0x%x flag=%d\n"
operator|,
operator|(
name|unsigned
name|int
operator|)
name|socket
operator|,
name|flag
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SO2SPITBLSIZE
condition|;
name|i
operator|++
control|)
for|for
control|(
name|np
operator|=
name|so2spitbl
index|[
name|i
index|]
operator|.
name|next
init|;
name|np
condition|;
name|np
operator|=
name|np
operator|->
name|next
control|)
block|{
name|KFREE
argument_list|(
name|np
argument_list|)
expr_stmt|;
block|}
name|CRITICAL_END
expr_stmt|;
return|return;
block|}
name|prevnp
operator|=
operator|&
name|so2spitbl
index|[
operator|(
operator|(
name|u_int32_t
operator|)
name|socket
operator|)
operator|%
name|SO2SPITBLSIZE
index|]
expr_stmt|;
for|for
control|(
name|np
operator|=
name|prevnp
operator|->
name|next
init|;
name|np
condition|;
name|np
operator|=
name|np
operator|->
name|next
control|)
block|{
if|if
condition|(
name|np
operator|->
name|socket
operator|==
name|socket
condition|)
block|{
name|struct
name|socketlist
modifier|*
name|socklp
decl_stmt|,
modifier|*
name|prevsocklp
decl_stmt|;
operator|(
name|np
operator|->
name|keynode
operator|->
name|alloc_count
operator|)
operator|--
expr_stmt|;
comment|/*         * If this socket maps to a unique secassoc,        * we go ahead and delete the secassoc, since it        * can no longer be allocated or used by any other         * socket.        */
if|if
condition|(
name|np
operator|->
name|keynode
operator|->
name|secassoc
operator|->
name|state
operator|&
name|K_UNIQUE
condition|)
block|{
if|if
condition|(
name|key_delete
argument_list|(
name|np
operator|->
name|keynode
operator|->
name|secassoc
argument_list|)
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"key_sodelete"
argument_list|)
expr_stmt|;
name|np
operator|=
name|prevnp
expr_stmt|;
continue|continue;
block|}
comment|/*        * We traverse the socketlist and remove the entry        * for this socket        */
name|DPRINTF
argument_list|(
name|IDL_FINISHED
argument_list|,
operator|(
literal|"keysodelete: deleting from socklist..."
operator|)
argument_list|)
expr_stmt|;
name|prevsocklp
operator|=
name|np
operator|->
name|keynode
operator|->
name|solist
expr_stmt|;
for|for
control|(
name|socklp
operator|=
name|prevsocklp
operator|->
name|next
init|;
name|socklp
condition|;
name|socklp
operator|=
name|socklp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|socklp
operator|->
name|socket
operator|==
name|socket
condition|)
block|{
name|prevsocklp
operator|->
name|next
operator|=
name|socklp
operator|->
name|next
expr_stmt|;
name|KFREE
argument_list|(
name|socklp
argument_list|)
expr_stmt|;
break|break;
block|}
name|prevsocklp
operator|=
name|socklp
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
name|IDL_FINISHED
argument_list|,
operator|(
literal|"done\n"
operator|)
argument_list|)
expr_stmt|;
name|prevnp
operator|->
name|next
operator|=
name|np
operator|->
name|next
expr_stmt|;
name|KFREE
argument_list|(
name|np
argument_list|)
expr_stmt|;
name|np
operator|=
name|prevnp
expr_stmt|;
block|}
name|prevnp
operator|=
name|np
expr_stmt|;
block|}
name|CRITICAL_END
expr_stmt|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------  * key_deleteacquire():  *      Delete an entry from the key_acquirelist  ----------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|key_deleteacquire
parameter_list|(
name|u_int
name|type
parameter_list|,
name|SOCKADDR
modifier|*
name|target
parameter_list|)
block|{
name|struct
name|key_acquirelist
modifier|*
name|ap
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|prev
operator|=
name|key_acquirelist
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|key_acquirelist
operator|->
name|next
init|;
name|ap
condition|;
name|ap
operator|=
name|ap
operator|->
name|next
control|)
block|{
if|if
condition|(
name|addrpart_equal
argument_list|(
name|target
argument_list|,
operator|(
name|SOCKADDR
operator|*
operator|)
operator|&
operator|(
name|ap
operator|->
name|target
operator|)
argument_list|)
operator|&&
operator|(
name|type
operator|==
name|ap
operator|->
name|type
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
name|IDL_EVENT
argument_list|,
operator|(
literal|"Deleting entry from acquire list!\n"
operator|)
argument_list|)
expr_stmt|;
name|prev
operator|->
name|next
operator|=
name|ap
operator|->
name|next
expr_stmt|;
name|KFREE
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|ap
operator|=
name|prev
expr_stmt|;
block|}
name|prev
operator|=
name|ap
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------  * key_search():  *      Search the key table for an entry with same type, src addr, dest  *      addr, and spi.  Returns a pointer to struct key_tblnode if found  *      else returns null.  ----------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|struct
name|key_tblnode
modifier|*
name|key_search
parameter_list|(
name|u_int
name|type
parameter_list|,
name|SOCKADDR
modifier|*
name|src
parameter_list|,
name|SOCKADDR
modifier|*
name|dst
parameter_list|,
name|u_int32_t
name|spi
parameter_list|,
name|int
name|indx
parameter_list|,
name|struct
name|key_tblnode
modifier|*
modifier|*
name|prevkeynode
parameter_list|)
block|{
name|struct
name|key_tblnode
modifier|*
name|keynode
decl_stmt|,
modifier|*
name|prevnode
decl_stmt|;
if|if
condition|(
name|indx
operator|>
name|KEYTBLSIZE
operator|||
name|indx
operator|<
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
operator|!
operator|(
operator|&
name|keytable
index|[
name|indx
index|]
operator|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
define|#
directive|define
name|sec_type
value|keynode->secassoc->type
define|#
directive|define
name|sec_spi
value|keynode->secassoc->spi
define|#
directive|define
name|sec_src
value|keynode->secassoc->src
define|#
directive|define
name|sec_dst
value|keynode->secassoc->dst
name|prevnode
operator|=
operator|&
name|keytable
index|[
name|indx
index|]
expr_stmt|;
for|for
control|(
name|keynode
operator|=
name|keytable
index|[
name|indx
index|]
operator|.
name|next
init|;
name|keynode
condition|;
name|keynode
operator|=
name|keynode
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|type
operator|==
name|sec_type
operator|)
operator|&&
operator|(
name|spi
operator|==
name|sec_spi
operator|)
operator|&&
name|addrpart_equal
argument_list|(
name|src
argument_list|,
name|sec_src
argument_list|)
operator|&&
name|addrpart_equal
argument_list|(
name|dst
argument_list|,
name|sec_dst
argument_list|)
condition|)
break|break;
name|prevnode
operator|=
name|keynode
expr_stmt|;
block|}
operator|*
name|prevkeynode
operator|=
name|prevnode
expr_stmt|;
return|return
operator|(
name|keynode
operator|)
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------  * key_addnode():  *      Insert a key_tblnode entry into the key table.  Returns a pointer   *      to the newly created key_tblnode.  ----------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|struct
name|key_tblnode
modifier|*
name|key_addnode
parameter_list|(
name|int
name|indx
parameter_list|,
name|struct
name|key_secassoc
modifier|*
name|secassoc
parameter_list|)
block|{
name|struct
name|key_tblnode
modifier|*
name|keynode
decl_stmt|;
name|DPRINTF
argument_list|(
name|IDL_FINISHED
argument_list|,
operator|(
literal|"Entering key_addnode w/indx=%d secassoc=0x%x\n"
operator|,
name|indx
operator|,
operator|(
name|unsigned
name|int
operator|)
name|secassoc
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|&
name|keytable
index|[
name|indx
index|]
operator|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
operator|!
name|secassoc
condition|)
block|{
name|panic
argument_list|(
literal|"key_addnode: Someone passed in a null secassoc!\n"
argument_list|)
expr_stmt|;
block|}
name|KMALLOC
argument_list|(
name|keynode
argument_list|,
expr|struct
name|key_tblnode
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|key_tblnode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|keynode
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|keynode
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|key_tblnode
argument_list|)
argument_list|)
expr_stmt|;
name|KMALLOC
argument_list|(
name|keynode
operator|->
name|solist
argument_list|,
expr|struct
name|socketlist
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|socketlist
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|keynode
operator|->
name|solist
operator|==
literal|0
condition|)
block|{
name|KFREE
argument_list|(
name|keynode
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|keynode
operator|->
name|solist
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|socketlist
argument_list|)
argument_list|)
expr_stmt|;
name|keynode
operator|->
name|secassoc
operator|=
name|secassoc
expr_stmt|;
name|keynode
operator|->
name|solist
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|keynode
operator|->
name|next
operator|=
name|keytable
index|[
name|indx
index|]
operator|.
name|next
expr_stmt|;
name|keytable
index|[
name|indx
index|]
operator|.
name|next
operator|=
name|keynode
expr_stmt|;
return|return
operator|(
name|keynode
operator|)
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------  * key_add():  *      Add a new security association to the key table.  Caller is  *      responsible for allocating memory for the key_secassoc as    *      well as the buffer space for the key,  iv.  Assumes the security   *      association passed in is well-formed.  ----------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|key_add
parameter_list|(
name|struct
name|key_secassoc
modifier|*
name|secassoc
parameter_list|)
block|{
name|char
name|buf
index|[
name|MAXHASHKEYLEN
index|]
decl_stmt|;
name|int
name|len
decl_stmt|,
name|indx
decl_stmt|;
name|int
name|inbound
init|=
literal|0
decl_stmt|;
name|int
name|outbound
init|=
literal|0
decl_stmt|;
name|struct
name|key_tblnode
modifier|*
name|keynode
decl_stmt|,
modifier|*
name|prevkeynode
decl_stmt|;
name|struct
name|key_allocnode
modifier|*
name|np
init|=
name|NULL
decl_stmt|;
name|CRITICAL_DCL
name|DPRINTF
argument_list|(
name|IDL_FINISHED
argument_list|,
operator|(
literal|"Entering key_add w/secassoc=0x%x\n"
operator|,
operator|(
name|unsigned
name|int
operator|)
name|secassoc
operator|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|secassoc
condition|)
block|{
name|panic
argument_list|(
literal|"key_add: who the hell is passing me a null pointer"
argument_list|)
expr_stmt|;
block|}
comment|/*    * Should we allow a null key to be inserted into the table ?     * or can we use null key to indicate some policy action...    */
if|#
directive|if
literal|0
comment|/*    *  For esp using des-cbc or tripple-des we call     * des_set_odd_parity.    */
block|if (secassoc->key&& (secassoc->type == KEY_TYPE_ESP)&&        ((secassoc->algorithm == IPSEC_ALGTYPE_ESP_DES_CBC) ||        (secassoc->algorithm == IPSEC_ALGTYPE_ESP_3DES)))     des_set_odd_parity(secassoc->key);
endif|#
directive|endif
comment|/* 0 */
comment|/*    *  Check if secassoc with same spi exists before adding    */
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|key_createkey
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|buf
argument_list|,
name|secassoc
operator|->
name|type
argument_list|,
name|secassoc
operator|->
name|src
argument_list|,
name|secassoc
operator|->
name|dst
argument_list|,
name|secassoc
operator|->
name|spi
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|indx
operator|=
name|key_gethashval
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|buf
argument_list|,
name|len
argument_list|,
name|KEYTBLSIZE
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|IDL_FINISHED
argument_list|,
operator|(
literal|"keyadd: keytbl hash position=%d\n"
operator|,
name|indx
operator|)
argument_list|)
expr_stmt|;
name|keynode
operator|=
name|key_search
argument_list|(
name|secassoc
operator|->
name|type
argument_list|,
name|secassoc
operator|->
name|src
argument_list|,
name|secassoc
operator|->
name|dst
argument_list|,
name|secassoc
operator|->
name|spi
argument_list|,
name|indx
argument_list|,
operator|&
name|prevkeynode
argument_list|)
expr_stmt|;
if|if
condition|(
name|keynode
condition|)
block|{
name|DPRINTF
argument_list|(
name|IDL_EVENT
argument_list|,
operator|(
literal|"keyadd: secassoc already exists!\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
name|inbound
operator|=
name|my_addr
argument_list|(
name|secassoc
operator|->
name|dst
argument_list|)
expr_stmt|;
name|outbound
operator|=
name|my_addr
argument_list|(
name|secassoc
operator|->
name|src
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|IDL_FINISHED
argument_list|,
operator|(
literal|"inbound=%d outbound=%d\n"
operator|,
name|inbound
operator|,
name|outbound
operator|)
argument_list|)
expr_stmt|;
comment|/*    * We allocate mem for an allocation entry if needed.    * This is done here instead of in the allocaton code     * segment so that we can easily recover/cleanup from a     * memory allocation error.    */
if|if
condition|(
name|outbound
operator|||
operator|(
operator|!
name|inbound
operator|&&
operator|!
name|outbound
operator|)
condition|)
block|{
name|KMALLOC
argument_list|(
name|np
argument_list|,
expr|struct
name|key_allocnode
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|key_allocnode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|==
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|IDL_ERROR
argument_list|,
operator|(
literal|"keyadd: can't allocate allocnode!\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
name|CRITICAL_START
expr_stmt|;
if|if
condition|(
operator|(
name|keynode
operator|=
name|key_addnode
argument_list|(
name|indx
argument_list|,
name|secassoc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
name|IDL_ERROR
argument_list|,
operator|(
literal|"keyadd: key_addnode failed!\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
condition|)
name|KFREE
argument_list|(
name|np
argument_list|)
expr_stmt|;
name|CRITICAL_END
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|DPRINTF
argument_list|(
name|IDL_GROSS_EVENT
argument_list|,
operator|(
literal|"Added new keynode:\n"
operator|)
argument_list|)
expr_stmt|;
name|DDO
argument_list|(
name|IDL_FINISHED
argument_list|,
name|dump_keytblnode
argument_list|(
name|keynode
argument_list|)
argument_list|)
expr_stmt|;
name|DDO
argument_list|(
name|IDL_FINISHED
argument_list|,
name|dump_secassoc
argument_list|(
name|keynode
operator|->
name|secassoc
argument_list|)
argument_list|)
expr_stmt|;
comment|/*    *  We add an entry to the allocation table for    *  this secassoc if the interfaces are up,     *  the secassoc is outbound.  In the case     *  where the interfaces are not up, we go ahead    * ,  do it anyways.  This wastes an allocation    *  entry if the secassoc later turned out to be    *  inbound when the interfaces are ifconfig up.    */
if|if
condition|(
name|outbound
operator|||
operator|(
operator|!
name|inbound
operator|&&
operator|!
name|outbound
operator|)
condition|)
block|{
name|len
operator|=
name|key_createkey
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|buf
argument_list|,
name|secassoc
operator|->
name|type
argument_list|,
name|secassoc
operator|->
name|src
argument_list|,
name|secassoc
operator|->
name|dst
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|indx
operator|=
name|key_gethashval
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|buf
argument_list|,
name|len
argument_list|,
name|KEYALLOCTBLSIZE
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|IDL_FINISHED
argument_list|,
operator|(
literal|"keyadd: keyalloc hash position=%d\n"
operator|,
name|indx
operator|)
argument_list|)
expr_stmt|;
name|np
operator|->
name|keynode
operator|=
name|keynode
expr_stmt|;
name|np
operator|->
name|next
operator|=
name|keyalloctbl
index|[
name|indx
index|]
operator|.
name|next
expr_stmt|;
name|keyalloctbl
index|[
name|indx
index|]
operator|.
name|next
operator|=
name|np
expr_stmt|;
block|}
if|if
condition|(
name|inbound
condition|)
name|secassoc
operator|->
name|state
operator||=
name|K_INBOUND
expr_stmt|;
if|if
condition|(
name|outbound
condition|)
name|secassoc
operator|->
name|state
operator||=
name|K_OUTBOUND
expr_stmt|;
name|key_deleteacquire
argument_list|(
name|secassoc
operator|->
name|type
argument_list|,
name|secassoc
operator|->
name|dst
argument_list|)
expr_stmt|;
name|CRITICAL_END
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------  * key_get():  *      Get a security association from the key table.  ----------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|key_get
parameter_list|(
name|u_int
name|type
parameter_list|,
name|SOCKADDR
modifier|*
name|src
parameter_list|,
name|SOCKADDR
modifier|*
name|dst
parameter_list|,
name|u_int32_t
name|spi
parameter_list|,
name|struct
name|key_secassoc
modifier|*
modifier|*
name|secassoc
parameter_list|)
block|{
name|char
name|buf
index|[
name|MAXHASHKEYLEN
index|]
decl_stmt|;
name|struct
name|key_tblnode
modifier|*
name|keynode
decl_stmt|,
modifier|*
name|prevkeynode
decl_stmt|;
name|int
name|len
decl_stmt|,
name|indx
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|secassoc
operator|=
name|NULL
expr_stmt|;
name|len
operator|=
name|key_createkey
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|buf
argument_list|,
name|type
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|spi
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|indx
operator|=
name|key_gethashval
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|buf
argument_list|,
name|len
argument_list|,
name|KEYTBLSIZE
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|IDL_FINISHED
argument_list|,
operator|(
literal|"keyget: indx=%d\n"
operator|,
name|indx
operator|)
argument_list|)
expr_stmt|;
name|keynode
operator|=
name|key_search
argument_list|(
name|type
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|spi
argument_list|,
name|indx
argument_list|,
operator|&
name|prevkeynode
argument_list|)
expr_stmt|;
if|if
condition|(
name|keynode
condition|)
block|{
name|DPRINTF
argument_list|(
name|IDL_GROSS_EVENT
argument_list|,
operator|(
literal|"keyget: found it! keynode=0x%x"
operator|,
operator|(
name|unsigned
name|int
operator|)
name|keynode
operator|)
argument_list|)
expr_stmt|;
operator|*
name|secassoc
operator|=
name|keynode
operator|->
name|secassoc
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Not found */
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------  * key_dump():  *      Dump all valid entries in the keytable to a pf_key socket.  Each  *      security associaiton is sent one at a time in a pf_key message.  A  *      message with seqno = 0 signifies the end of the dump transaction.  ----------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|key_dump
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|int
name|len
decl_stmt|,
name|i
decl_stmt|;
name|int
name|seq
init|=
literal|1
decl_stmt|;
name|struct
name|key_msgdata
name|keyinfo
decl_stmt|;
name|struct
name|key_msghdr
modifier|*
name|km
decl_stmt|;
name|struct
name|key_tblnode
modifier|*
name|keynode
decl_stmt|;
comment|/*    * Routine to dump the key table to a routing socket    * Use for debugging only!    */
name|KMALLOC
argument_list|(
name|km
argument_list|,
expr|struct
name|key_msghdr
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|key_msghdr
argument_list|)
operator|+
literal|3
operator|*
name|MAX_SOCKADDR_SZ
operator|+
name|MAX_KEY_SZ
operator|+
name|MAX_IV_SZ
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|km
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|DPRINTF
argument_list|(
name|IDL_FINISHED
argument_list|,
operator|(
literal|"Entering key_dump()"
operator|)
argument_list|)
expr_stmt|;
comment|/*     * We need to speed this up later.  Fortunately, key_dump     * messages are not sent often.    */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|KEYTBLSIZE
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|keynode
operator|=
name|keytable
index|[
name|i
index|]
operator|.
name|next
init|;
name|keynode
condition|;
name|keynode
operator|=
name|keynode
operator|->
name|next
control|)
block|{
comment|/*        * We exclude dead/larval/zombie security associations for now        * but it may be useful to also send these up for debugging purposes        */
if|if
condition|(
name|keynode
operator|->
name|secassoc
operator|->
name|state
operator|&
operator|(
name|K_DEAD
operator||
name|K_LARVAL
operator||
name|K_ZOMBIE
operator|)
condition|)
continue|continue;
name|len
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|key_msghdr
argument_list|)
operator|+
name|ROUNDUP
argument_list|(
name|keynode
operator|->
name|secassoc
operator|->
name|src
operator|->
name|sa_len
argument_list|)
operator|+
name|ROUNDUP
argument_list|(
name|keynode
operator|->
name|secassoc
operator|->
name|dst
operator|->
name|sa_len
argument_list|)
operator|+
name|ROUNDUP
argument_list|(
name|keynode
operator|->
name|secassoc
operator|->
name|from
operator|->
name|sa_len
argument_list|)
operator|+
name|ROUNDUP
argument_list|(
name|keynode
operator|->
name|secassoc
operator|->
name|keylen
argument_list|)
operator|+
name|ROUNDUP
argument_list|(
name|keynode
operator|->
name|secassoc
operator|->
name|ivlen
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|key_secassoc2msghdr
argument_list|(
name|keynode
operator|->
name|secassoc
argument_list|,
name|km
argument_list|,
operator|&
name|keyinfo
argument_list|)
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"key_dump"
argument_list|)
expr_stmt|;
name|km
operator|->
name|key_msglen
operator|=
name|len
expr_stmt|;
name|km
operator|->
name|key_msgvers
operator|=
name|KEY_VERSION
expr_stmt|;
name|km
operator|->
name|key_msgtype
operator|=
name|KEY_DUMP
expr_stmt|;
name|km
operator|->
name|key_pid
operator|=
name|CURRENT_PID
expr_stmt|;
name|km
operator|->
name|key_seq
operator|=
name|seq
operator|++
expr_stmt|;
name|km
operator|->
name|key_errno
operator|=
literal|0
expr_stmt|;
name|key_sendup
argument_list|(
name|so
argument_list|,
name|km
argument_list|)
expr_stmt|;
block|}
block|}
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|km
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|key_msghdr
argument_list|)
argument_list|)
expr_stmt|;
name|km
operator|->
name|key_msglen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|key_msghdr
argument_list|)
expr_stmt|;
name|km
operator|->
name|key_msgvers
operator|=
name|KEY_VERSION
expr_stmt|;
name|km
operator|->
name|key_msgtype
operator|=
name|KEY_DUMP
expr_stmt|;
name|km
operator|->
name|key_pid
operator|=
name|CURRENT_PID
expr_stmt|;
name|km
operator|->
name|key_seq
operator|=
literal|0
expr_stmt|;
name|km
operator|->
name|key_errno
operator|=
literal|0
expr_stmt|;
name|key_sendup
argument_list|(
name|so
argument_list|,
name|km
argument_list|)
expr_stmt|;
name|KFREE
argument_list|(
name|km
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|IDL_FINISHED
argument_list|,
operator|(
literal|"Leaving key_dump()\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------  * key_delete():  *      Delete a security association from the key table.  ----------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|key_delete
parameter_list|(
name|struct
name|key_secassoc
modifier|*
name|secassoc
parameter_list|)
block|{
name|char
name|buf
index|[
name|MAXHASHKEYLEN
index|]
decl_stmt|;
name|int
name|len
decl_stmt|,
name|indx
decl_stmt|;
name|struct
name|key_tblnode
modifier|*
name|keynode
init|=
literal|0
decl_stmt|;
name|struct
name|key_tblnode
modifier|*
name|prevkeynode
init|=
literal|0
decl_stmt|;
name|struct
name|socketlist
modifier|*
name|socklp
decl_stmt|,
modifier|*
name|deadsocklp
decl_stmt|;
name|struct
name|key_so2spinode
modifier|*
name|np
decl_stmt|,
modifier|*
name|prevnp
decl_stmt|;
name|struct
name|key_allocnode
modifier|*
name|ap
decl_stmt|,
modifier|*
name|prevap
decl_stmt|;
name|CRITICAL_DCL
name|DPRINTF
argument_list|(
name|IDL_FINISHED
argument_list|,
operator|(
literal|"Entering key_delete w/secassoc=0x%x\n"
operator|,
operator|(
name|unsigned
name|int
operator|)
name|secassoc
operator|)
argument_list|)
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|key_createkey
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|buf
argument_list|,
name|secassoc
operator|->
name|type
argument_list|,
name|secassoc
operator|->
name|src
argument_list|,
name|secassoc
operator|->
name|dst
argument_list|,
name|secassoc
operator|->
name|spi
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|indx
operator|=
name|key_gethashval
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|buf
argument_list|,
name|len
argument_list|,
name|KEYTBLSIZE
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|IDL_FINISHED
argument_list|,
operator|(
literal|"keydelete: keytbl hash position=%d\n"
operator|,
name|indx
operator|)
argument_list|)
expr_stmt|;
name|keynode
operator|=
name|key_search
argument_list|(
name|secassoc
operator|->
name|type
argument_list|,
name|secassoc
operator|->
name|src
argument_list|,
name|secassoc
operator|->
name|dst
argument_list|,
name|secassoc
operator|->
name|spi
argument_list|,
name|indx
argument_list|,
operator|&
name|prevkeynode
argument_list|)
expr_stmt|;
if|if
condition|(
name|keynode
condition|)
block|{
name|CRITICAL_START
expr_stmt|;
name|DPRINTF
argument_list|(
name|IDL_GROSS_EVENT
argument_list|,
operator|(
literal|"keydelete: found keynode to delete\n"
operator|)
argument_list|)
expr_stmt|;
name|keynode
operator|->
name|secassoc
operator|->
name|state
operator||=
name|K_DEAD
expr_stmt|;
if|if
condition|(
name|keynode
operator|->
name|ref_count
operator|>
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|IDL_EVENT
argument_list|,
operator|(
literal|"keydelete: secassoc still held, marking for deletion only!\n"
operator|)
argument_list|)
expr_stmt|;
name|CRITICAL_END
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|prevkeynode
operator|->
name|next
operator|=
name|keynode
operator|->
name|next
expr_stmt|;
comment|/*      *  Walk the socketlist,  delete the      *  entries mapping sockets to this secassoc      *  from the so2spi table.      */
name|DPRINTF
argument_list|(
name|IDL_FINISHED
argument_list|,
operator|(
literal|"keydelete: deleting socklist..."
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|socklp
operator|=
name|keynode
operator|->
name|solist
operator|->
name|next
init|;
name|socklp
condition|;
control|)
block|{
name|prevnp
operator|=
operator|&
name|so2spitbl
index|[
operator|(
call|(
name|u_int32_t
call|)
argument_list|(
name|socklp
operator|->
name|socket
argument_list|)
operator|)
operator|%
name|SO2SPITBLSIZE
index|]
expr_stmt|;
for|for
control|(
name|np
operator|=
name|prevnp
operator|->
name|next
init|;
name|np
condition|;
name|np
operator|=
name|np
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|np
operator|->
name|socket
operator|==
name|socklp
operator|->
name|socket
operator|)
operator|&&
operator|(
name|np
operator|->
name|keynode
operator|==
name|keynode
operator|)
condition|)
block|{
name|prevnp
operator|->
name|next
operator|=
name|np
operator|->
name|next
expr_stmt|;
name|KFREE
argument_list|(
name|np
argument_list|)
expr_stmt|;
break|break;
block|}
name|prevnp
operator|=
name|np
expr_stmt|;
block|}
name|deadsocklp
operator|=
name|socklp
expr_stmt|;
name|socklp
operator|=
name|socklp
operator|->
name|next
expr_stmt|;
name|KFREE
argument_list|(
name|deadsocklp
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
name|IDL_FINISHED
argument_list|,
operator|(
literal|"done\n"
operator|)
argument_list|)
expr_stmt|;
comment|/*      * If an allocation entry exist for this      * secassoc, delete it.      */
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|key_createkey
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|buf
argument_list|,
name|secassoc
operator|->
name|type
argument_list|,
name|secassoc
operator|->
name|src
argument_list|,
name|secassoc
operator|->
name|dst
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|indx
operator|=
name|key_gethashval
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|buf
argument_list|,
name|len
argument_list|,
name|KEYALLOCTBLSIZE
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|IDL_FINISHED
argument_list|,
operator|(
literal|"keydelete: alloctbl hash position=%d\n"
operator|,
name|indx
operator|)
argument_list|)
expr_stmt|;
name|prevap
operator|=
operator|&
name|keyalloctbl
index|[
name|indx
index|]
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|prevap
operator|->
name|next
init|;
name|ap
condition|;
name|ap
operator|=
name|ap
operator|->
name|next
control|)
block|{
if|if
condition|(
name|ap
operator|->
name|keynode
operator|==
name|keynode
condition|)
block|{
name|prevap
operator|->
name|next
operator|=
name|ap
operator|->
name|next
expr_stmt|;
name|KFREE
argument_list|(
name|ap
argument_list|)
expr_stmt|;
break|break;
block|}
name|prevap
operator|=
name|ap
expr_stmt|;
block|}
if|if
condition|(
name|keynode
operator|->
name|secassoc
operator|->
name|iv
condition|)
name|KFREE
argument_list|(
name|keynode
operator|->
name|secassoc
operator|->
name|iv
argument_list|)
expr_stmt|;
if|if
condition|(
name|keynode
operator|->
name|secassoc
operator|->
name|key
condition|)
name|KFREE
argument_list|(
name|keynode
operator|->
name|secassoc
operator|->
name|key
argument_list|)
expr_stmt|;
name|KFREE
argument_list|(
name|keynode
operator|->
name|secassoc
argument_list|)
expr_stmt|;
if|if
condition|(
name|keynode
operator|->
name|solist
condition|)
name|KFREE
argument_list|(
name|keynode
operator|->
name|solist
argument_list|)
expr_stmt|;
name|KFREE
argument_list|(
name|keynode
argument_list|)
expr_stmt|;
name|CRITICAL_END
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------  * key_flush():  *      Delete all entries from the key table.  ----------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|key_flush
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|key_tblnode
modifier|*
name|keynode
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/*     * This is slow, but simple.    */
name|DPRINTF
argument_list|(
name|IDL_FINISHED
argument_list|,
operator|(
literal|"Flushing key table..."
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|KEYTBLSIZE
condition|;
name|i
operator|++
control|)
block|{
while|while
condition|(
operator|(
name|keynode
operator|=
name|keytable
index|[
name|i
index|]
operator|.
name|next
operator|)
condition|)
if|if
condition|(
name|key_delete
argument_list|(
name|keynode
operator|->
name|secassoc
argument_list|)
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"key_flush"
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
name|IDL_FINISHED
argument_list|,
operator|(
literal|"done\n"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------  * key_getspi():  *      Get a unique spi value for a key management daemon/program.  The   *      spi value, once assigned, cannot be assigned again (as long as the   *      entry with that same spi value remains in the table).  ----------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|key_getspi
parameter_list|(
name|u_int
name|type
parameter_list|,
name|SOCKADDR
modifier|*
name|src
parameter_list|,
name|SOCKADDR
modifier|*
name|dst
parameter_list|,
name|u_int32_t
name|lowval
parameter_list|,
name|u_int32_t
name|highval
parameter_list|,
name|u_int32_t
modifier|*
name|spi
parameter_list|)
block|{
name|struct
name|key_secassoc
modifier|*
name|secassoc
decl_stmt|;
name|struct
name|key_tblnode
modifier|*
name|keynode
decl_stmt|,
modifier|*
name|prevkeynode
decl_stmt|;
name|int
name|count
decl_stmt|,
name|done
decl_stmt|,
name|len
decl_stmt|,
name|indx
decl_stmt|;
name|int
name|maxcount
init|=
literal|1000
decl_stmt|;
name|u_int32_t
name|val
decl_stmt|;
name|char
name|buf
index|[
name|MAXHASHKEYLEN
index|]
decl_stmt|;
name|CRITICAL_DCL
name|DPRINTF
argument_list|(
name|IDL_EVENT
argument_list|,
operator|(
literal|"Entering getspi w/type=%d,low=%u,high=%u\n"
operator|,
name|type
operator|,
name|lowval
operator|,
name|highval
operator|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|src
operator|&&
name|dst
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|(
name|lowval
operator|==
literal|0
operator|)
operator|||
operator|(
name|highval
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|lowval
operator|>
name|highval
condition|)
block|{
name|u_int32_t
name|temp
decl_stmt|;
name|temp
operator|=
name|lowval
expr_stmt|;
name|lowval
operator|=
name|highval
expr_stmt|;
name|highval
operator|=
name|lowval
expr_stmt|;
block|}
name|done
operator|=
name|count
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|count
operator|++
expr_stmt|;
comment|/*       *  This may not be "random enough".      */
name|val
operator|=
name|lowval
operator|+
operator|(
name|random
argument_list|()
operator|%
operator|(
name|highval
operator|-
name|lowval
operator|+
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|lowval
operator|==
name|highval
condition|)
name|count
operator|=
name|maxcount
expr_stmt|;
name|DPRINTF
argument_list|(
name|IDL_FINISHED
argument_list|,
operator|(
literal|"%u "
operator|,
name|val
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
block|{
name|DPRINTF
argument_list|(
name|IDL_FINISHED
argument_list|,
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|key_createkey
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|buf
argument_list|,
name|type
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|indx
operator|=
name|key_gethashval
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|buf
argument_list|,
name|len
argument_list|,
name|KEYTBLSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|key_search
argument_list|(
name|type
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|val
argument_list|,
name|indx
argument_list|,
operator|&
name|prevkeynode
argument_list|)
condition|)
block|{
name|CRITICAL_START
expr_stmt|;
name|KMALLOC
argument_list|(
name|secassoc
argument_list|,
expr|struct
name|key_secassoc
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|key_secassoc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|secassoc
operator|==
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|IDL_ERROR
argument_list|,
operator|(
literal|"key_getspi: can't allocate memory\n"
operator|)
argument_list|)
expr_stmt|;
name|CRITICAL_END
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|secassoc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|secassoc
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|IDL_FINISHED
argument_list|,
operator|(
literal|"getspi: indx=%d\n"
operator|,
name|indx
operator|)
argument_list|)
expr_stmt|;
name|secassoc
operator|->
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|key_secassoc
argument_list|)
expr_stmt|;
name|secassoc
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|secassoc
operator|->
name|spi
operator|=
name|val
expr_stmt|;
name|secassoc
operator|->
name|state
operator||=
name|K_LARVAL
expr_stmt|;
if|if
condition|(
name|my_addr
argument_list|(
name|secassoc
operator|->
name|dst
argument_list|)
condition|)
name|secassoc
operator|->
name|state
operator||=
name|K_INBOUND
expr_stmt|;
if|if
condition|(
name|my_addr
argument_list|(
name|secassoc
operator|->
name|src
argument_list|)
condition|)
name|secassoc
operator|->
name|state
operator||=
name|K_OUTBOUND
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|src
argument_list|,
operator|(
name|char
operator|*
operator|)
name|secassoc
operator|->
name|src
argument_list|,
name|src
operator|->
name|sa_len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dst
argument_list|,
operator|(
name|char
operator|*
operator|)
name|secassoc
operator|->
name|dst
argument_list|,
name|dst
operator|->
name|sa_len
argument_list|)
expr_stmt|;
comment|/* We fill this in with a plausable value now to insure 	   that other routines don't break. These will get 	   overwritten later with the correct values. */
ifdef|#
directive|ifdef
name|INET6
name|secassoc
operator|->
name|from
operator|->
name|sa_family
operator|=
name|AF_INET6
expr_stmt|;
name|secassoc
operator|->
name|from
operator|->
name|sa_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* INET6 */
name|secassoc
operator|->
name|from
operator|->
name|sa_family
operator|=
name|AF_INET
expr_stmt|;
name|secassoc
operator|->
name|from
operator|->
name|sa_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* INET6 */
comment|/*  	 * We need to add code to age these larval key table 	 * entries so they don't linger forever waiting for 	 * a KEY_UPDATE message that may not come for various 	 * reasons.  This is another task that key_reaper can 	 * do once we have it coded. 	 */
name|secassoc
operator|->
name|lifetime1
operator|+=
name|TIME_SECONDS
operator|+
name|maxlarvallifetime
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|keynode
operator|=
name|key_addnode
argument_list|(
name|indx
argument_list|,
name|secassoc
argument_list|)
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
name|IDL_ERROR
argument_list|,
operator|(
literal|"key_getspi: can't add node\n"
operator|)
argument_list|)
expr_stmt|;
name|CRITICAL_END
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|DPRINTF
argument_list|(
name|IDL_FINISHED
argument_list|,
operator|(
literal|"key_getspi: added node 0x%x\n"
operator|,
operator|(
name|unsigned
name|int
operator|)
name|keynode
operator|)
argument_list|)
expr_stmt|;
name|done
operator|++
expr_stmt|;
name|CRITICAL_END
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
operator|(
name|count
operator|<
name|maxcount
operator|)
operator|&&
operator|!
name|done
condition|)
do|;
name|DPRINTF
argument_list|(
name|IDL_EVENT
argument_list|,
operator|(
literal|"getspi returns w/spi=%u,count=%d\n"
operator|,
name|val
operator|,
name|count
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|done
condition|)
block|{
operator|*
name|spi
operator|=
name|val
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
operator|*
name|spi
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|EADDRNOTAVAIL
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------  * key_update():  *      Update a keytable entry that has an spi value assigned but is   *      incomplete (e.g. no key/iv).  ----------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|key_update
parameter_list|(
name|struct
name|key_secassoc
modifier|*
name|secassoc
parameter_list|)
block|{
name|struct
name|key_tblnode
modifier|*
name|keynode
decl_stmt|,
modifier|*
name|prevkeynode
decl_stmt|;
name|struct
name|key_allocnode
modifier|*
name|np
init|=
literal|0
decl_stmt|;
name|u_int8_t
name|newstate
decl_stmt|;
name|int
name|len
decl_stmt|,
name|indx
decl_stmt|,
name|inbound
decl_stmt|,
name|outbound
decl_stmt|;
name|char
name|buf
index|[
name|MAXHASHKEYLEN
index|]
decl_stmt|;
name|CRITICAL_DCL
name|bzero
argument_list|(
operator|&
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
decl_stmt|;
name|len
operator|=
name|key_createkey
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|buf
argument_list|,
name|secassoc
operator|->
name|type
argument_list|,
name|secassoc
operator|->
name|src
argument_list|,
name|secassoc
operator|->
name|dst
argument_list|,
name|secassoc
operator|->
name|spi
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|indx
operator|=
name|key_gethashval
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|buf
argument_list|,
name|len
argument_list|,
name|KEYTBLSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|keynode
operator|=
name|key_search
argument_list|(
name|secassoc
operator|->
name|type
argument_list|,
name|secassoc
operator|->
name|src
argument_list|,
name|secassoc
operator|->
name|dst
argument_list|,
name|secassoc
operator|->
name|spi
argument_list|,
name|indx
argument_list|,
operator|&
name|prevkeynode
argument_list|)
operator|)
condition|)
block|{
return|return
operator|(
name|ESRCH
operator|)
return|;
block|}
if|if
condition|(
name|keynode
operator|->
name|secassoc
operator|->
name|state
operator|&
name|K_DEAD
condition|)
return|return
operator|(
name|ESRCH
operator|)
return|;
comment|/* Should we also restrict updating of only LARVAL entries ? */
name|CRITICAL_START
expr_stmt|;
name|inbound
operator|=
name|my_addr
argument_list|(
name|secassoc
operator|->
name|dst
argument_list|)
expr_stmt|;
name|outbound
operator|=
name|my_addr
argument_list|(
name|secassoc
operator|->
name|src
argument_list|)
expr_stmt|;
name|newstate
operator|=
name|keynode
operator|->
name|secassoc
operator|->
name|state
expr_stmt|;
name|newstate
operator|&=
operator|~
name|K_LARVAL
expr_stmt|;
if|if
condition|(
name|inbound
condition|)
name|newstate
operator||=
name|K_INBOUND
expr_stmt|;
if|if
condition|(
name|outbound
condition|)
name|newstate
operator||=
name|K_OUTBOUND
expr_stmt|;
if|if
condition|(
name|outbound
operator|||
operator|(
operator|!
name|inbound
operator|&&
operator|!
name|outbound
operator|)
condition|)
block|{
name|KMALLOC
argument_list|(
name|np
argument_list|,
expr|struct
name|key_allocnode
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|key_allocnode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|==
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|IDL_ERROR
argument_list|,
operator|(
literal|"keyupdate: can't allocate allocnode!\n"
operator|)
argument_list|)
expr_stmt|;
name|CRITICAL_END
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
block|}
comment|/*    *  Free the old key,  iv if they're there.    */
if|if
condition|(
name|keynode
operator|->
name|secassoc
operator|->
name|key
condition|)
name|KFREE
argument_list|(
name|keynode
operator|->
name|secassoc
operator|->
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|keynode
operator|->
name|secassoc
operator|->
name|iv
condition|)
name|KFREE
argument_list|(
name|keynode
operator|->
name|secassoc
operator|->
name|iv
argument_list|)
expr_stmt|;
comment|/*    *  We now copy the secassoc over. We don't need to copy    *  the key,  iv into new buffers since the calling routine    *  does that already.      */
operator|*
operator|(
name|keynode
operator|->
name|secassoc
operator|)
operator|=
operator|*
name|secassoc
expr_stmt|;
name|keynode
operator|->
name|secassoc
operator|->
name|state
operator|=
name|newstate
expr_stmt|;
comment|/*    * Should we allow a null key to be inserted into the table ?     * or can we use null key to indicate some policy action...    */
if|#
directive|if
literal|0
block|if (keynode->secassoc->key&&        (keynode->secassoc->type == KEY_TYPE_ESP)&&        ((keynode->secassoc->algorithm == IPSEC_ALGTYPE_ESP_DES_CBC) || 	(keynode->secassoc->algorithm == IPSEC_ALGTYPE_ESP_3DES)))       des_set_odd_parity(keynode->secassoc->key);
endif|#
directive|endif
comment|/* 0 */
comment|/*    *  We now add an entry to the allocation table for this     *  updated key table entry.    */
if|if
condition|(
name|outbound
operator|||
operator|(
operator|!
name|inbound
operator|&&
operator|!
name|outbound
operator|)
condition|)
block|{
name|len
operator|=
name|key_createkey
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|buf
argument_list|,
name|secassoc
operator|->
name|type
argument_list|,
name|secassoc
operator|->
name|src
argument_list|,
name|secassoc
operator|->
name|dst
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|indx
operator|=
name|key_gethashval
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|buf
argument_list|,
name|len
argument_list|,
name|KEYALLOCTBLSIZE
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|IDL_FINISHED
argument_list|,
operator|(
literal|"keyupdate: keyalloc hash position=%d\n"
operator|,
name|indx
operator|)
argument_list|)
expr_stmt|;
name|np
operator|->
name|keynode
operator|=
name|keynode
expr_stmt|;
name|np
operator|->
name|next
operator|=
name|keyalloctbl
index|[
name|indx
index|]
operator|.
name|next
expr_stmt|;
name|keyalloctbl
index|[
name|indx
index|]
operator|.
name|next
operator|=
name|np
expr_stmt|;
block|}
name|key_deleteacquire
argument_list|(
name|secassoc
operator|->
name|type
argument_list|,
operator|(
name|SOCKADDR
operator|*
operator|)
operator|&
operator|(
name|secassoc
operator|->
name|dst
operator|)
argument_list|)
expr_stmt|;
name|CRITICAL_END
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------  * key_register():  *      Register a socket as one capable of acquiring security associations  *      for the kernel.  ----------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|key_register
parameter_list|(
name|struct
name|socket
modifier|*
name|socket
parameter_list|,
name|u_int
name|type
parameter_list|)
block|{
name|struct
name|key_registry
modifier|*
name|p
decl_stmt|,
modifier|*
name|new
decl_stmt|;
name|CRITICAL_DCL
name|CRITICAL_START
decl_stmt|;
name|DPRINTF
argument_list|(
name|IDL_EVENT
argument_list|,
operator|(
literal|"Entering key_register w/so=0x%x,type=%d\n"
operator|,
operator|(
name|unsigned
name|int
operator|)
name|socket
operator|,
name|type
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|keyregtable
operator|&&
name|socket
operator|)
condition|)
name|panic
argument_list|(
literal|"key_register"
argument_list|)
expr_stmt|;
comment|/*    * Make sure entry is not already in table    */
for|for
control|(
name|p
operator|=
name|keyregtable
operator|->
name|next
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|p
operator|->
name|type
operator|==
name|type
operator|)
operator|&&
operator|(
name|p
operator|->
name|socket
operator|==
name|socket
operator|)
condition|)
block|{
name|CRITICAL_END
expr_stmt|;
return|return
operator|(
name|EEXIST
operator|)
return|;
block|}
block|}
name|KMALLOC
argument_list|(
name|new
argument_list|,
expr|struct
name|key_registry
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|key_registry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|==
literal|0
condition|)
block|{
name|CRITICAL_END
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|new
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|new
operator|->
name|socket
operator|=
name|socket
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|keyregtable
operator|->
name|next
expr_stmt|;
name|keyregtable
operator|->
name|next
operator|=
name|new
expr_stmt|;
name|CRITICAL_END
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------  * key_unregister():  *      Delete entries from the registry list.  *         allflag = 1 : delete all entries with matching socket  *         allflag = 0 : delete only the entry matching socket,  type  ----------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|key_unregister
parameter_list|(
name|struct
name|socket
modifier|*
name|socket
parameter_list|,
name|u_int
name|type
parameter_list|,
name|int
name|allflag
parameter_list|)
block|{
name|struct
name|key_registry
modifier|*
name|p
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|CRITICAL_DCL
name|CRITICAL_START
decl_stmt|;
name|DPRINTF
argument_list|(
name|IDL_EVENT
argument_list|,
operator|(
literal|"Entering key_unregister w/so=0x%x,type=%d,flag=%d\n"
operator|,
operator|(
name|unsigned
name|int
operator|)
name|socket
operator|,
name|type
operator|,
name|allflag
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|keyregtable
operator|&&
name|socket
operator|)
condition|)
name|panic
argument_list|(
literal|"key_register"
argument_list|)
expr_stmt|;
name|prev
operator|=
name|keyregtable
expr_stmt|;
for|for
control|(
name|p
operator|=
name|keyregtable
operator|->
name|next
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|allflag
operator|&&
operator|(
name|p
operator|->
name|socket
operator|==
name|socket
operator|)
operator|)
operator|||
operator|(
operator|(
name|p
operator|->
name|type
operator|==
name|type
operator|)
operator|&&
operator|(
name|p
operator|->
name|socket
operator|==
name|socket
operator|)
operator|)
condition|)
block|{
name|prev
operator|->
name|next
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|KFREE
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|prev
expr_stmt|;
block|}
name|prev
operator|=
name|p
expr_stmt|;
block|}
name|CRITICAL_END
expr_stmt|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------  * key_acquire():  *      Send a key_acquire message to all registered key mgnt daemons   *      capable of acquire security association of type type.  *  *      Return: 0 if succesfully called key mgnt. daemon(s)  *              -1 if not successfull.  ----------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|key_acquire
parameter_list|(
name|u_int
name|type
parameter_list|,
name|SOCKADDR
modifier|*
name|src
parameter_list|,
name|SOCKADDR
modifier|*
name|dst
parameter_list|)
block|{
name|struct
name|key_registry
modifier|*
name|p
decl_stmt|;
name|struct
name|key_acquirelist
modifier|*
name|ap
decl_stmt|,
modifier|*
name|prevap
decl_stmt|;
name|int
name|success
init|=
literal|0
decl_stmt|,
name|created
init|=
literal|0
decl_stmt|;
name|u_int
name|etype
decl_stmt|;
name|struct
name|key_msghdr
modifier|*
name|km
init|=
name|NULL
decl_stmt|;
name|int
name|len
decl_stmt|;
name|DPRINTF
argument_list|(
name|IDL_EVENT
argument_list|,
operator|(
literal|"Entering key_acquire()\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|keyregtable
operator|||
operator|!
name|src
operator|||
operator|!
name|dst
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/*    * We first check the acquirelist to see if a key_acquire    * message has been sent for this destination.    */
name|etype
operator|=
name|type
expr_stmt|;
name|prevap
operator|=
name|key_acquirelist
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|key_acquirelist
operator|->
name|next
init|;
name|ap
condition|;
name|ap
operator|=
name|ap
operator|->
name|next
control|)
block|{
if|if
condition|(
name|addrpart_equal
argument_list|(
name|dst
argument_list|,
name|ap
operator|->
name|target
argument_list|)
operator|&&
operator|(
name|etype
operator|==
name|ap
operator|->
name|type
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
name|IDL_EVENT
argument_list|,
operator|(
literal|"acquire message previously sent!\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|expiretime
operator|<
name|TIME_SECONDS
condition|)
block|{
name|DPRINTF
argument_list|(
name|IDL_EVENT
argument_list|,
operator|(
literal|"acquire message has expired!\n"
operator|)
argument_list|)
expr_stmt|;
name|ap
operator|->
name|count
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ap
operator|->
name|count
operator|<
name|maxkeyacquire
condition|)
block|{
name|DPRINTF
argument_list|(
name|IDL_EVENT
argument_list|,
operator|(
literal|"max acquire messages not yet exceeded!\n"
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|ap
operator|->
name|expiretime
operator|<
name|TIME_SECONDS
condition|)
block|{
comment|/*        *  Since we're already looking at the list, we may as        *  well delete expired entries as we scan through the list.        *  This should really be done by a function like key_reaper()        *  but until we code key_reaper(), this is a quick,  dirty        *  hack.        */
name|DPRINTF
argument_list|(
name|IDL_EVENT
argument_list|,
operator|(
literal|"found an expired entry...deleting it!\n"
operator|)
argument_list|)
expr_stmt|;
name|prevap
operator|->
name|next
operator|=
name|ap
operator|->
name|next
expr_stmt|;
name|KFREE
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|ap
operator|=
name|prevap
expr_stmt|;
block|}
name|prevap
operator|=
name|ap
expr_stmt|;
block|}
comment|/*    * Scan registry,  send KEY_ACQUIRE message to     * appropriate key management daemons.    */
for|for
control|(
name|p
operator|=
name|keyregtable
operator|->
name|next
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|->
name|type
operator|!=
name|type
condition|)
continue|continue;
if|if
condition|(
operator|!
name|created
condition|)
block|{
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|key_msghdr
argument_list|)
operator|+
name|ROUNDUP
argument_list|(
name|src
operator|->
name|sa_len
argument_list|)
operator|+
name|ROUNDUP
argument_list|(
name|dst
operator|->
name|sa_len
argument_list|)
expr_stmt|;
name|KMALLOC
argument_list|(
name|km
argument_list|,
expr|struct
name|key_msghdr
operator|*
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|km
condition|)
block|{
name|DPRINTF
argument_list|(
name|IDL_ERROR
argument_list|,
operator|(
literal|"key_acquire: no memory\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|DPRINTF
argument_list|(
name|IDL_FINISHED
argument_list|,
operator|(
literal|"key_acquire/created: 1\n"
operator|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|km
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|km
operator|->
name|key_msglen
operator|=
name|len
expr_stmt|;
name|km
operator|->
name|key_msgvers
operator|=
name|KEY_VERSION
expr_stmt|;
name|km
operator|->
name|key_msgtype
operator|=
name|KEY_ACQUIRE
expr_stmt|;
name|km
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|DPRINTF
argument_list|(
name|IDL_FINISHED
argument_list|,
operator|(
literal|"key_acquire/created: 2\n"
operator|)
argument_list|)
expr_stmt|;
comment|/*        * This is inefficient,  slow.        */
comment|/*        * We zero out sin_zero here for AF_INET addresses because        * ip_output() currently does not do it for performance reasons.        */
if|if
condition|(
name|src
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|src
operator|)
operator|->
name|sin_zero
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|src
operator|)
operator|->
name|sin_zero
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|dst
operator|)
operator|->
name|sin_zero
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|dst
operator|)
operator|->
name|sin_zero
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|src
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|km
operator|+
literal|1
operator|)
argument_list|,
name|src
operator|->
name|sa_len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dst
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
call|(
name|int
call|)
argument_list|(
name|km
operator|+
literal|1
argument_list|)
operator|+
name|ROUNDUP
argument_list|(
name|src
operator|->
name|sa_len
argument_list|)
operator|)
argument_list|,
name|dst
operator|->
name|sa_len
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|IDL_FINISHED
argument_list|,
operator|(
literal|"key_acquire/created: 3\n"
operator|)
argument_list|)
expr_stmt|;
name|created
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|key_sendup
argument_list|(
name|p
operator|->
name|socket
argument_list|,
name|km
argument_list|)
condition|)
name|success
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|km
condition|)
name|KFREE
argument_list|(
name|km
argument_list|)
expr_stmt|;
comment|/*    *  Update the acquirelist     */
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
operator|!
name|ap
condition|)
block|{
name|DPRINTF
argument_list|(
name|IDL_EVENT
argument_list|,
operator|(
literal|"Adding new entry in acquirelist\n"
operator|)
argument_list|)
expr_stmt|;
name|KMALLOC
argument_list|(
name|ap
argument_list|,
expr|struct
name|key_acquirelist
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|key_acquirelist
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|==
literal|0
condition|)
return|return
operator|(
name|success
condition|?
literal|0
else|:
operator|-
literal|1
operator|)
return|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ap
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|key_acquirelist
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dst
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ap
operator|->
name|target
argument_list|,
name|dst
operator|->
name|sa_len
argument_list|)
expr_stmt|;
name|ap
operator|->
name|type
operator|=
name|etype
expr_stmt|;
name|ap
operator|->
name|next
operator|=
name|key_acquirelist
operator|->
name|next
expr_stmt|;
name|key_acquirelist
operator|->
name|next
operator|=
name|ap
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
name|IDL_GROSS_EVENT
argument_list|,
operator|(
literal|"Updating acquire counter,  expiration time\n"
operator|)
argument_list|)
expr_stmt|;
name|ap
operator|->
name|count
operator|++
expr_stmt|;
name|ap
operator|->
name|expiretime
operator|=
name|TIME_SECONDS
operator|+
name|maxacquiretime
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
name|IDL_EVENT
argument_list|,
operator|(
literal|"key_acquire: done! success=%d\n"
operator|,
name|success
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|success
condition|?
literal|0
else|:
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------  * key_alloc():  *      Allocate a security association to a socket.  A socket requesting   *      unique keying (per-socket keying) is assigned a security assocation  *      exclusively for its use.  Sockets not requiring unique keying are  *      assigned the first security association which may or may not be  *      used by another socket.  ----------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|key_alloc
parameter_list|(
name|u_int
name|type
parameter_list|,
name|SOCKADDR
modifier|*
name|src
parameter_list|,
name|SOCKADDR
modifier|*
name|dst
parameter_list|,
name|struct
name|socket
modifier|*
name|socket
parameter_list|,
name|u_int
name|unique_key
parameter_list|,
name|struct
name|key_tblnode
modifier|*
modifier|*
name|keynodep
parameter_list|)
block|{
name|struct
name|key_tblnode
modifier|*
name|keynode
decl_stmt|;
name|char
name|buf
index|[
name|MAXHASHKEYLEN
index|]
decl_stmt|;
name|struct
name|key_allocnode
modifier|*
name|np
decl_stmt|,
modifier|*
name|prevnp
decl_stmt|;
name|struct
name|key_so2spinode
modifier|*
name|newnp
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|indx
decl_stmt|;
name|DPRINTF
argument_list|(
name|IDL_FINISHED
argument_list|,
operator|(
literal|"Entering key_alloc w/type=%u!\n"
operator|,
name|type
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|src
operator|&&
name|dst
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
name|IDL_ERROR
argument_list|,
operator|(
literal|"key_alloc: received null src or dst!\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/*    * Search key allocation table    */
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|key_createkey
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|buf
argument_list|,
name|type
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|indx
operator|=
name|key_gethashval
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|buf
argument_list|,
name|len
argument_list|,
name|KEYALLOCTBLSIZE
argument_list|)
expr_stmt|;
define|#
directive|define
name|np_type
value|np->keynode->secassoc->type
define|#
directive|define
name|np_state
value|np->keynode->secassoc->state
define|#
directive|define
name|np_src
value|np->keynode->secassoc->src
define|#
directive|define
name|np_dst
value|np->keynode->secassoc->dst
name|prevnp
operator|=
operator|&
name|keyalloctbl
index|[
name|indx
index|]
expr_stmt|;
for|for
control|(
name|np
operator|=
name|keyalloctbl
index|[
name|indx
index|]
operator|.
name|next
init|;
name|np
condition|;
name|np
operator|=
name|np
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|type
operator|==
name|np_type
operator|)
operator|&&
name|addrpart_equal
argument_list|(
name|src
argument_list|,
name|np_src
argument_list|)
operator|&&
name|addrpart_equal
argument_list|(
name|dst
argument_list|,
name|np_dst
argument_list|)
operator|&&
operator|!
operator|(
name|np_state
operator|&
operator|(
name|K_LARVAL
operator||
name|K_DEAD
operator||
name|K_UNIQUE
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|unique_key
operator|)
condition|)
break|break;
if|if
condition|(
operator|!
operator|(
name|np_state
operator|&
name|K_USED
operator|)
condition|)
break|break;
block|}
name|prevnp
operator|=
name|np
expr_stmt|;
block|}
if|if
condition|(
name|np
condition|)
block|{
name|struct
name|socketlist
modifier|*
name|newsp
decl_stmt|;
name|CRITICAL_DCL
name|CRITICAL_START
decl_stmt|;
name|DPRINTF
argument_list|(
name|IDL_EVENT
argument_list|,
operator|(
literal|"key_alloc: found node to allocate\n"
operator|)
argument_list|)
expr_stmt|;
name|keynode
operator|=
name|np
operator|->
name|keynode
expr_stmt|;
name|KMALLOC
argument_list|(
name|newnp
argument_list|,
expr|struct
name|key_so2spinode
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|key_so2spinode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newnp
operator|==
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|IDL_ERROR
argument_list|,
operator|(
literal|"key_alloc: Can't alloc mem for so2spi node!\n"
operator|)
argument_list|)
expr_stmt|;
name|CRITICAL_END
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|KMALLOC
argument_list|(
name|newsp
argument_list|,
expr|struct
name|socketlist
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|socketlist
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newsp
operator|==
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|IDL_ERROR
argument_list|,
operator|(
literal|"key_alloc: Can't alloc mem for socketlist!\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newnp
condition|)
name|KFREE
argument_list|(
name|newnp
argument_list|)
expr_stmt|;
name|CRITICAL_END
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
comment|/*      * Add a hash entry into the so2spi table to      * map socket to allocated secassoc.      */
name|DPRINTF
argument_list|(
name|IDL_FINISHED
argument_list|,
operator|(
literal|"key_alloc: adding entry to so2spi table..."
operator|)
argument_list|)
expr_stmt|;
name|newnp
operator|->
name|keynode
operator|=
name|keynode
expr_stmt|;
name|newnp
operator|->
name|socket
operator|=
name|socket
expr_stmt|;
name|newnp
operator|->
name|next
operator|=
name|so2spitbl
index|[
operator|(
operator|(
name|u_int32_t
operator|)
name|socket
operator|)
operator|%
name|SO2SPITBLSIZE
index|]
operator|.
name|next
expr_stmt|;
name|so2spitbl
index|[
operator|(
operator|(
name|u_int32_t
operator|)
name|socket
operator|)
operator|%
name|SO2SPITBLSIZE
index|]
operator|.
name|next
operator|=
name|newnp
expr_stmt|;
name|DPRINTF
argument_list|(
name|IDL_FINISHED
argument_list|,
operator|(
literal|"done\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unique_key
condition|)
block|{
comment|/*        * Need to remove the allocation entry        * since the secassoc is now unique,          * can't be allocated to any other socket        */
name|DPRINTF
argument_list|(
name|IDL_EVENT
argument_list|,
operator|(
literal|"key_alloc: making keynode unique..."
operator|)
argument_list|)
expr_stmt|;
name|keynode
operator|->
name|secassoc
operator|->
name|state
operator||=
name|K_UNIQUE
expr_stmt|;
name|prevnp
operator|->
name|next
operator|=
name|np
operator|->
name|next
expr_stmt|;
name|KFREE
argument_list|(
name|np
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|IDL_EVENT
argument_list|,
operator|(
literal|"done\n"
operator|)
argument_list|)
expr_stmt|;
block|}
name|keynode
operator|->
name|secassoc
operator|->
name|state
operator||=
name|K_USED
expr_stmt|;
name|keynode
operator|->
name|secassoc
operator|->
name|state
operator||=
name|K_OUTBOUND
expr_stmt|;
name|keynode
operator|->
name|alloc_count
operator|++
expr_stmt|;
comment|/*      * Add socket to list of socket using secassoc.      */
name|DPRINTF
argument_list|(
name|IDL_FINISHED
argument_list|,
operator|(
literal|"key_alloc: adding so to solist..."
operator|)
argument_list|)
expr_stmt|;
name|newsp
operator|->
name|socket
operator|=
name|socket
expr_stmt|;
name|newsp
operator|->
name|next
operator|=
name|keynode
operator|->
name|solist
operator|->
name|next
expr_stmt|;
name|keynode
operator|->
name|solist
operator|->
name|next
operator|=
name|newsp
expr_stmt|;
name|DPRINTF
argument_list|(
name|IDL_FINISHED
argument_list|,
operator|(
literal|"done\n"
operator|)
argument_list|)
expr_stmt|;
operator|*
name|keynodep
operator|=
name|keynode
expr_stmt|;
name|CRITICAL_END
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|*
name|keynodep
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------  * key_free():  *      Decrement the refcount for a key table entry.  If the entry is   *      marked dead,,  the refcount is zero, we go ahead,  delete it.  ----------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|key_free
parameter_list|(
name|struct
name|key_tblnode
modifier|*
name|keynode
parameter_list|)
block|{
name|DPRINTF
argument_list|(
name|IDL_GROSS_EVENT
argument_list|,
operator|(
literal|"Entering key_free w/keynode=0x%x\n"
operator|,
operator|(
name|unsigned
name|int
operator|)
name|keynode
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|keynode
condition|)
block|{
name|DPRINTF
argument_list|(
name|IDL_ERROR
argument_list|,
operator|(
literal|"Warning: key_free got null pointer\n"
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|keynode
operator|->
name|ref_count
operator|)
operator|--
expr_stmt|;
if|if
condition|(
name|keynode
operator|->
name|ref_count
operator|<
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|IDL_ERROR
argument_list|,
operator|(
literal|"Warning: key_free decremented refcount to %d\n"
operator|,
name|keynode
operator|->
name|ref_count
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|keynode
operator|->
name|secassoc
operator|->
name|state
operator|&
name|K_DEAD
operator|)
operator|&&
operator|(
name|keynode
operator|->
name|ref_count
operator|<=
literal|0
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
name|IDL_GROSS_EVENT
argument_list|,
operator|(
literal|"key_free: calling key_delete\n"
operator|)
argument_list|)
expr_stmt|;
name|key_delete
argument_list|(
name|keynode
operator|->
name|secassoc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------  * getassocbyspi():  *      Get a security association for a given type, src, dst,,  spi.  *  *      Returns: 0 if sucessfull  *               -1 if error/not found  *  *      Caller must convert spi to host order.  Function assumes spi is    *      in host order!  ----------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|getassocbyspi
parameter_list|(
name|u_int
name|type
parameter_list|,
name|SOCKADDR
modifier|*
name|src
parameter_list|,
name|SOCKADDR
modifier|*
name|dst
parameter_list|,
name|u_int32_t
name|spi
parameter_list|,
name|struct
name|key_tblnode
modifier|*
modifier|*
name|keyentry
parameter_list|)
block|{
name|char
name|buf
index|[
name|MAXHASHKEYLEN
index|]
decl_stmt|;
name|int
name|len
decl_stmt|,
name|indx
decl_stmt|;
name|struct
name|key_tblnode
modifier|*
name|keynode
decl_stmt|,
modifier|*
name|prevkeynode
init|=
literal|0
decl_stmt|;
name|DPRINTF
argument_list|(
name|IDL_FINISHED
argument_list|,
operator|(
literal|"Entering getassocbyspi w/type=%u spi=%u\n"
operator|,
name|type
operator|,
name|spi
operator|)
argument_list|)
expr_stmt|;
operator|*
name|keyentry
operator|=
name|NULL
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|key_createkey
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|buf
argument_list|,
name|type
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|spi
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|indx
operator|=
name|key_gethashval
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|buf
argument_list|,
name|len
argument_list|,
name|KEYTBLSIZE
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|IDL_FINISHED
argument_list|,
operator|(
literal|"getassocbyspi: indx=%d\n"
operator|,
name|indx
operator|)
argument_list|)
expr_stmt|;
name|DDO
argument_list|(
argument|IDL_FINISHED
argument_list|,
argument|dump_sockaddr(src);dump_sockaddr(dst)
argument_list|)
empty_stmt|;
name|keynode
operator|=
name|key_search
argument_list|(
name|type
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|spi
argument_list|,
name|indx
argument_list|,
operator|&
name|prevkeynode
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|IDL_FINISHED
argument_list|,
operator|(
literal|"getassocbyspi: keysearch ret=0x%x\n"
operator|,
operator|(
name|unsigned
name|int
operator|)
name|keynode
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|keynode
operator|&&
operator|!
operator|(
name|keynode
operator|->
name|secassoc
operator|->
name|state
operator|&
operator|(
name|K_DEAD
operator||
name|K_LARVAL
operator|)
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
name|IDL_GROSS_EVENT
argument_list|,
operator|(
literal|"getassocbyspi: found secassoc!\n"
operator|)
argument_list|)
expr_stmt|;
operator|(
name|keynode
operator|->
name|ref_count
operator|)
operator|++
expr_stmt|;
name|keynode
operator|->
name|secassoc
operator|->
name|state
operator||=
name|K_USED
expr_stmt|;
operator|*
name|keyentry
operator|=
name|keynode
expr_stmt|;
block|}
else|else
block|{
name|DPRINTF
argument_list|(
name|IDL_EVENT
argument_list|,
operator|(
literal|"getassocbyspi: secassoc not found!\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------  * getassocbysocket():  *      Get a security association for a given type, src, dst,,  socket.  *      If not found, try to allocate one.  *      Returns: 0 if successfull  *              -1 if error condition/secassoc not found (*keyentry = NULL)  *               1 if secassoc temporarily unavailable (*keynetry = NULL)  *                 (e.g., key mgnt. daemon(s) called)  ----------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|getassocbysocket
parameter_list|(
name|u_int
name|type
parameter_list|,
name|SOCKADDR
modifier|*
name|src
parameter_list|,
name|SOCKADDR
modifier|*
name|dst
parameter_list|,
name|struct
name|socket
modifier|*
name|socket
parameter_list|,
name|u_int
name|unique_key
parameter_list|,
name|struct
name|key_tblnode
modifier|*
modifier|*
name|keyentry
parameter_list|)
block|{
name|struct
name|key_tblnode
modifier|*
name|keynode
init|=
literal|0
decl_stmt|;
name|struct
name|key_so2spinode
modifier|*
name|np
decl_stmt|;
name|u_int
name|realtype
decl_stmt|;
name|DPRINTF
argument_list|(
name|IDL_FINISHED
argument_list|,
operator|(
literal|"Entering getassocbysocket w/type=%u so=0x%x\n"
operator|,
name|type
operator|,
operator|(
name|unsigned
name|int
operator|)
name|socket
operator|)
argument_list|)
expr_stmt|;
comment|/*    *  We treat esp-transport mode,  esp-tunnel mode     *  as a single type in the keytable.  This has a side    *  effect that socket using both esp-transport,     *  esp-tunnel will use the same security association    *  for both modes.  Is this a problem?    */
name|realtype
operator|=
name|type
expr_stmt|;
if|if
condition|(
operator|(
name|np
operator|=
name|key_sosearch
argument_list|(
name|type
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|socket
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|np
operator|->
name|keynode
operator|&&
name|np
operator|->
name|keynode
operator|->
name|secassoc
operator|&&
operator|!
operator|(
name|np
operator|->
name|keynode
operator|->
name|secassoc
operator|->
name|state
operator|&
operator|(
name|K_DEAD
operator||
name|K_LARVAL
operator|)
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
name|IDL_FINISHED
argument_list|,
operator|(
literal|"getassocbysocket: found secassoc!\n"
operator|)
argument_list|)
expr_stmt|;
operator|(
name|np
operator|->
name|keynode
operator|->
name|ref_count
operator|)
operator|++
expr_stmt|;
operator|*
name|keyentry
operator|=
name|np
operator|->
name|keynode
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/*    * No secassoc has been allocated to socket,     * so allocate one, if available    */
name|DPRINTF
argument_list|(
name|IDL_GROSS_EVENT
argument_list|,
operator|(
literal|"getassocbyso: can't find it, trying to allocate!\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|key_alloc
argument_list|(
name|realtype
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|socket
argument_list|,
name|unique_key
argument_list|,
operator|&
name|keynode
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|keynode
condition|)
block|{
name|DPRINTF
argument_list|(
name|IDL_GROSS_EVENT
argument_list|,
operator|(
literal|"getassocbyso: key_alloc found secassoc!\n"
operator|)
argument_list|)
expr_stmt|;
name|keynode
operator|->
name|ref_count
operator|++
expr_stmt|;
operator|*
name|keyentry
operator|=
name|keynode
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
comment|/*         * Kick key mgnt. daemon(s)         * (this should be done in ipsec_output_policy() instead or        * selectively called based on a flag value)        */
name|DPRINTF
argument_list|(
name|IDL_FINISHED
argument_list|,
operator|(
literal|"getassocbyso: calling key mgnt daemons!\n"
operator|)
argument_list|)
expr_stmt|;
operator|*
name|keyentry
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|key_acquire
argument_list|(
name|realtype
argument_list|,
name|src
argument_list|,
name|dst
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
operator|*
name|keyentry
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------  * key_xdata():  *      Parse message buffer for src/dst/from/iv/key if parseflag = 0  *      else parse for src/dst only.  ----------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|key_xdata
parameter_list|(
name|struct
name|key_msghdr
modifier|*
name|km
parameter_list|,
name|struct
name|key_msgdata
modifier|*
name|kip
parameter_list|,
name|int
name|parseflag
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cpmax
decl_stmt|;
if|if
condition|(
operator|!
name|km
operator|||
operator|(
name|km
operator|->
name|key_msglen
operator|<=
literal|0
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|cp
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|km
operator|+
literal|1
argument_list|)
expr_stmt|;
name|cpmax
operator|=
operator|(
name|caddr_t
operator|)
name|km
operator|+
name|km
operator|->
name|key_msglen
expr_stmt|;
comment|/*    * Assumes user process passes message with     * correct word alignment.    */
comment|/*     * Need to clean up this code later.      */
comment|/* Grab src addr */
name|kip
operator|->
name|src
operator|=
operator|(
name|SOCKADDR
operator|*
operator|)
name|cp
expr_stmt|;
if|if
condition|(
operator|!
name|kip
operator|->
name|src
operator|->
name|sa_len
condition|)
block|{
name|DPRINTF
argument_list|(
name|IDL_MAJOR_EVENT
argument_list|,
operator|(
literal|"key_xdata couldn't parse src addr\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ADVANCE
argument_list|(
name|cp
argument_list|,
name|kip
operator|->
name|src
operator|->
name|sa_len
argument_list|)
expr_stmt|;
comment|/* Grab dest addr */
name|kip
operator|->
name|dst
operator|=
operator|(
name|SOCKADDR
operator|*
operator|)
name|cp
expr_stmt|;
if|if
condition|(
operator|!
name|kip
operator|->
name|dst
operator|->
name|sa_len
condition|)
block|{
name|DPRINTF
argument_list|(
name|IDL_MAJOR_EVENT
argument_list|,
operator|(
literal|"key_xdata couldn't parse dest addr\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ADVANCE
argument_list|(
name|cp
argument_list|,
name|kip
operator|->
name|dst
operator|->
name|sa_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|parseflag
operator|==
literal|1
condition|)
block|{
name|kip
operator|->
name|from
operator|=
literal|0
expr_stmt|;
name|kip
operator|->
name|key
operator|=
name|kip
operator|->
name|iv
operator|=
literal|0
expr_stmt|;
name|kip
operator|->
name|keylen
operator|=
name|kip
operator|->
name|ivlen
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Grab from addr */
name|kip
operator|->
name|from
operator|=
operator|(
name|SOCKADDR
operator|*
operator|)
name|cp
expr_stmt|;
if|if
condition|(
operator|!
name|kip
operator|->
name|from
operator|->
name|sa_len
condition|)
block|{
name|DPRINTF
argument_list|(
name|IDL_MAJOR_EVENT
argument_list|,
operator|(
literal|"key_xdata couldn't parse from addr\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ADVANCE
argument_list|(
name|cp
argument_list|,
name|kip
operator|->
name|from
operator|->
name|sa_len
argument_list|)
expr_stmt|;
comment|/* Grab key */
if|if
condition|(
operator|(
name|kip
operator|->
name|keylen
operator|=
name|km
operator|->
name|keylen
operator|)
condition|)
block|{
name|kip
operator|->
name|key
operator|=
name|cp
expr_stmt|;
name|ADVANCE
argument_list|(
name|cp
argument_list|,
name|km
operator|->
name|keylen
argument_list|)
expr_stmt|;
block|}
else|else
name|kip
operator|->
name|key
operator|=
literal|0
expr_stmt|;
comment|/* Grab iv */
if|if
condition|(
operator|(
name|kip
operator|->
name|ivlen
operator|=
name|km
operator|->
name|ivlen
operator|)
condition|)
name|kip
operator|->
name|iv
operator|=
name|cp
expr_stmt|;
else|else
name|kip
operator|->
name|iv
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|key_parse
parameter_list|(
name|struct
name|key_msghdr
modifier|*
modifier|*
name|kmp
parameter_list|,
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
modifier|*
name|dstfamily
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|,
name|keyerror
init|=
literal|0
decl_stmt|;
name|struct
name|key_msgdata
name|keyinfo
decl_stmt|;
name|struct
name|key_secassoc
modifier|*
name|secassoc
init|=
name|NULL
decl_stmt|;
name|struct
name|key_msghdr
modifier|*
name|km
init|=
operator|*
name|kmp
decl_stmt|;
name|DPRINTF
argument_list|(
name|IDL_MAJOR_EVENT
argument_list|,
operator|(
literal|"Entering key_parse\n"
operator|)
argument_list|)
expr_stmt|;
define|#
directive|define
name|senderr
parameter_list|(
name|e
parameter_list|)
define|\
value|{ error = (e); goto flush; }
if|if
condition|(
name|km
operator|->
name|key_msgvers
operator|!=
name|KEY_VERSION
condition|)
block|{
name|DPRINTF
argument_list|(
name|IDL_CRITICAL
argument_list|,
operator|(
literal|"keyoutput: Unsupported key message version!\n"
operator|)
argument_list|)
expr_stmt|;
name|senderr
argument_list|(
name|EPROTONOSUPPORT
argument_list|)
expr_stmt|;
block|}
name|km
operator|->
name|key_pid
operator|=
name|CURRENT_PID
expr_stmt|;
name|DDO
argument_list|(
argument|IDL_MAJOR_EVENT
argument_list|,
argument|printf(
literal|"keymsghdr:\n"
argument|); dump_keymsghdr(km)
argument_list|)
empty_stmt|;
comment|/*    * Parse buffer for src addr, dest addr, from addr, key, iv    */
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|keyinfo
argument_list|,
sizeof|sizeof
argument_list|(
name|keyinfo
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|km
operator|->
name|key_msgtype
condition|)
block|{
case|case
name|KEY_ADD
case|:
name|DPRINTF
argument_list|(
name|IDL_MAJOR_EVENT
argument_list|,
operator|(
literal|"key_output got KEY_ADD msg\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|key_xdata
argument_list|(
name|km
argument_list|,
operator|&
name|keyinfo
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|parsefail
goto|;
comment|/*      * Allocate the secassoc structure to insert       * into key table here.      */
name|KMALLOC
argument_list|(
name|secassoc
argument_list|,
expr|struct
name|key_secassoc
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|key_secassoc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|secassoc
operator|==
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|IDL_CRITICAL
argument_list|,
operator|(
literal|"keyoutput: No more memory!\n"
operator|)
argument_list|)
expr_stmt|;
name|senderr
argument_list|(
name|ENOBUFS
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|key_msghdr2secassoc
argument_list|(
name|secassoc
argument_list|,
name|km
argument_list|,
operator|&
name|keyinfo
argument_list|)
operator|<
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|IDL_CRITICAL
argument_list|,
operator|(
literal|"keyoutput: key_msghdr2secassoc failed!\n"
operator|)
argument_list|)
expr_stmt|;
name|KFREE
argument_list|(
name|secassoc
argument_list|)
expr_stmt|;
name|senderr
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
name|IDL_MAJOR_EVENT
argument_list|,
operator|(
literal|"secassoc to add:\n"
operator|)
argument_list|)
expr_stmt|;
name|DDO
argument_list|(
name|IDL_MAJOR_EVENT
argument_list|,
name|dump_secassoc
argument_list|(
name|secassoc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|keyerror
operator|=
name|key_add
argument_list|(
name|secassoc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|IDL_CRITICAL
argument_list|,
operator|(
literal|"keyoutput: key_add failed\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|secassoc
operator|->
name|key
condition|)
name|KFREE
argument_list|(
name|secassoc
operator|->
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|secassoc
operator|->
name|iv
condition|)
name|KFREE
argument_list|(
name|secassoc
operator|->
name|iv
argument_list|)
expr_stmt|;
name|KFREE
argument_list|(
name|secassoc
argument_list|)
expr_stmt|;
if|if
condition|(
name|keyerror
operator|==
operator|-
literal|2
condition|)
block|{
name|senderr
argument_list|(
name|EEXIST
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|senderr
argument_list|(
name|ENOBUFS
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|KEY_DELETE
case|:
name|DPRINTF
argument_list|(
name|IDL_MAJOR_EVENT
argument_list|,
operator|(
literal|"key_output got KEY_DELETE msg\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|key_xdata
argument_list|(
name|km
argument_list|,
operator|&
name|keyinfo
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|parsefail
goto|;
name|KMALLOC
argument_list|(
name|secassoc
argument_list|,
expr|struct
name|key_secassoc
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|key_secassoc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|secassoc
operator|==
literal|0
condition|)
block|{
name|senderr
argument_list|(
name|ENOBUFS
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|key_msghdr2secassoc
argument_list|(
name|secassoc
argument_list|,
name|km
argument_list|,
operator|&
name|keyinfo
argument_list|)
operator|<
literal|0
condition|)
block|{
name|KFREE
argument_list|(
name|secassoc
argument_list|)
expr_stmt|;
name|senderr
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|key_delete
argument_list|(
name|secassoc
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|secassoc
operator|->
name|iv
condition|)
name|KFREE
argument_list|(
name|secassoc
operator|->
name|iv
argument_list|)
expr_stmt|;
if|if
condition|(
name|secassoc
operator|->
name|key
condition|)
name|KFREE
argument_list|(
name|secassoc
operator|->
name|key
argument_list|)
expr_stmt|;
name|KFREE
argument_list|(
name|secassoc
argument_list|)
expr_stmt|;
name|senderr
argument_list|(
name|ESRCH
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|secassoc
operator|->
name|iv
condition|)
name|KFREE
argument_list|(
name|secassoc
operator|->
name|iv
argument_list|)
expr_stmt|;
if|if
condition|(
name|secassoc
operator|->
name|key
condition|)
name|KFREE
argument_list|(
name|secassoc
operator|->
name|key
argument_list|)
expr_stmt|;
name|KFREE
argument_list|(
name|secassoc
argument_list|)
expr_stmt|;
break|break;
case|case
name|KEY_UPDATE
case|:
name|DPRINTF
argument_list|(
name|IDL_EVENT
argument_list|,
operator|(
literal|"key_output got KEY_UPDATE msg\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|key_xdata
argument_list|(
name|km
argument_list|,
operator|&
name|keyinfo
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|parsefail
goto|;
name|KMALLOC
argument_list|(
name|secassoc
argument_list|,
expr|struct
name|key_secassoc
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|key_secassoc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|secassoc
operator|==
literal|0
condition|)
block|{
name|senderr
argument_list|(
name|ENOBUFS
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|key_msghdr2secassoc
argument_list|(
name|secassoc
argument_list|,
name|km
argument_list|,
operator|&
name|keyinfo
argument_list|)
operator|<
literal|0
condition|)
block|{
name|KFREE
argument_list|(
name|secassoc
argument_list|)
expr_stmt|;
name|senderr
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|keyerror
operator|=
name|key_update
argument_list|(
name|secassoc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|IDL_CRITICAL
argument_list|,
operator|(
literal|"Error updating key entry\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|secassoc
operator|->
name|iv
condition|)
name|KFREE
argument_list|(
name|secassoc
operator|->
name|iv
argument_list|)
expr_stmt|;
if|if
condition|(
name|secassoc
operator|->
name|key
condition|)
name|KFREE
argument_list|(
name|secassoc
operator|->
name|key
argument_list|)
expr_stmt|;
name|KFREE
argument_list|(
name|secassoc
argument_list|)
expr_stmt|;
name|senderr
argument_list|(
name|keyerror
argument_list|)
expr_stmt|;
block|}
name|KFREE
argument_list|(
name|secassoc
argument_list|)
expr_stmt|;
break|break;
case|case
name|KEY_GET
case|:
name|DPRINTF
argument_list|(
name|IDL_EVENT
argument_list|,
operator|(
literal|"key_output got KEY_GET msg\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|key_xdata
argument_list|(
name|km
argument_list|,
operator|&
name|keyinfo
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|parsefail
goto|;
if|if
condition|(
name|key_get
argument_list|(
name|km
operator|->
name|type
argument_list|,
operator|(
name|SOCKADDR
operator|*
operator|)
name|keyinfo
operator|.
name|src
argument_list|,
operator|(
name|SOCKADDR
operator|*
operator|)
name|keyinfo
operator|.
name|dst
argument_list|,
name|km
operator|->
name|spi
argument_list|,
operator|&
name|secassoc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|IDL_EVENT
argument_list|,
operator|(
literal|"keyoutput: can't get key\n"
operator|)
argument_list|)
expr_stmt|;
name|senderr
argument_list|(
name|ESRCH
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|secassoc
condition|)
block|{
name|int
name|newlen
decl_stmt|;
name|DPRINTF
argument_list|(
name|IDL_EVENT
argument_list|,
operator|(
literal|"keyoutput: Found secassoc!\n"
operator|)
argument_list|)
expr_stmt|;
name|newlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|key_msghdr
argument_list|)
operator|+
name|ROUNDUP
argument_list|(
name|secassoc
operator|->
name|src
operator|->
name|sa_len
argument_list|)
operator|+
name|ROUNDUP
argument_list|(
name|secassoc
operator|->
name|dst
operator|->
name|sa_len
argument_list|)
operator|+
name|ROUNDUP
argument_list|(
name|secassoc
operator|->
name|from
operator|->
name|sa_len
argument_list|)
operator|+
name|ROUNDUP
argument_list|(
name|secassoc
operator|->
name|keylen
argument_list|)
operator|+
name|ROUNDUP
argument_list|(
name|secassoc
operator|->
name|ivlen
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|IDL_EVENT
argument_list|,
operator|(
literal|"keyoutput: newlen=%d\n"
operator|,
name|newlen
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newlen
operator|>
name|km
operator|->
name|key_msglen
condition|)
block|{
name|struct
name|key_msghdr
modifier|*
name|newkm
decl_stmt|;
name|DPRINTF
argument_list|(
name|IDL_EVENT
argument_list|,
operator|(
literal|"keyoutput: Allocating new buffer!\n"
operator|)
argument_list|)
expr_stmt|;
name|KMALLOC
argument_list|(
name|newkm
argument_list|,
expr|struct
name|key_msghdr
operator|*
argument_list|,
name|newlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|newkm
operator|==
literal|0
condition|)
block|{
name|senderr
argument_list|(
name|ENOBUFS
argument_list|)
expr_stmt|;
block|}
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|km
argument_list|,
operator|(
name|char
operator|*
operator|)
name|newkm
argument_list|,
name|km
operator|->
name|key_msglen
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|IDL_FINISHED
argument_list|,
operator|(
literal|"keyoutput: 1\n"
operator|)
argument_list|)
expr_stmt|;
name|KFREE
argument_list|(
name|km
argument_list|)
expr_stmt|;
operator|*
name|kmp
operator|=
name|km
operator|=
name|newkm
expr_stmt|;
name|DPRINTF
argument_list|(
name|IDL_CRITICAL
argument_list|,
operator|(
literal|"km->key_msglen = %d, newlen = %d\n"
operator|,
name|km
operator|->
name|key_msglen
operator|,
name|newlen
operator|)
argument_list|)
expr_stmt|;
name|km
operator|->
name|key_msglen
operator|=
name|newlen
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
name|IDL_FINISHED
argument_list|,
operator|(
literal|"keyoutput: 2\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|key_secassoc2msghdr
argument_list|(
name|secassoc
argument_list|,
name|km
argument_list|,
operator|&
name|keyinfo
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
name|IDL_CRITICAL
argument_list|,
operator|(
literal|"keyoutput: Can't create msghdr!\n"
operator|)
argument_list|)
expr_stmt|;
name|senderr
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
name|IDL_FINISHED
argument_list|,
operator|(
literal|"keyoutput: 3\n"
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|KEY_GETSPI
case|:
name|DPRINTF
argument_list|(
name|IDL_EVENT
argument_list|,
operator|(
literal|"key_output got KEY_GETSPI msg\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|key_xdata
argument_list|(
name|km
argument_list|,
operator|&
name|keyinfo
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|parsefail
goto|;
if|if
condition|(
operator|(
name|keyerror
operator|=
name|key_getspi
argument_list|(
name|km
operator|->
name|type
argument_list|,
name|keyinfo
operator|.
name|src
argument_list|,
name|keyinfo
operator|.
name|dst
argument_list|,
name|km
operator|->
name|lifetime1
argument_list|,
name|km
operator|->
name|lifetime2
argument_list|,
operator|&
operator|(
name|km
operator|->
name|spi
operator|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|IDL_CRITICAL
argument_list|,
operator|(
literal|"keyoutput: getspi failed error=%d\n"
operator|,
name|keyerror
operator|)
argument_list|)
expr_stmt|;
name|senderr
argument_list|(
name|keyerror
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|KEY_REGISTER
case|:
name|DPRINTF
argument_list|(
name|IDL_EVENT
argument_list|,
operator|(
literal|"key_output got KEY_REGISTER msg\n"
operator|)
argument_list|)
expr_stmt|;
name|key_register
argument_list|(
name|so
argument_list|,
name|km
operator|->
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|KEY_DUMP
case|:
name|DPRINTF
argument_list|(
name|IDL_EVENT
argument_list|,
operator|(
literal|"key_output got KEY_DUMP msg\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|key_dump
argument_list|(
name|so
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
break|break;
case|case
name|KEY_FLUSH
case|:
name|DPRINTF
argument_list|(
name|IDL_EVENT
argument_list|,
operator|(
literal|"key_output got KEY_FLUSH msg\n"
operator|)
argument_list|)
expr_stmt|;
name|key_flush
argument_list|()
expr_stmt|;
break|break;
default|default:
name|DPRINTF
argument_list|(
name|IDL_CRITICAL
argument_list|,
operator|(
literal|"key_output got unsupported msg type=%d\n"
operator|,
name|km
operator|->
name|key_msgtype
operator|)
argument_list|)
expr_stmt|;
name|senderr
argument_list|(
name|EOPNOTSUPP
argument_list|)
expr_stmt|;
block|}
goto|goto
name|flush
goto|;
name|parsefail
label|:
name|keyinfo
operator|.
name|dst
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
name|flush
label|:
if|if
condition|(
name|km
condition|)
name|km
operator|->
name|key_errno
operator|=
name|error
expr_stmt|;
if|if
condition|(
name|dstfamily
condition|)
operator|*
name|dstfamily
operator|=
name|keyinfo
operator|.
name|dst
condition|?
name|keyinfo
operator|.
name|dst
operator|->
name|sa_family
else|:
literal|0
expr_stmt|;
name|DPRINTF
argument_list|(
name|IDL_MAJOR_EVENT
argument_list|,
operator|(
literal|"key_parse exiting with error=%d\n"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Definitions of protocols supported in the KEY domain.  */
end_comment

begin_decl_stmt
name|struct
name|sockaddr
name|key_addr
init|=
block|{
literal|2
block|,
name|PF_KEY
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sockproto
name|key_proto
init|=
block|{
name|PF_KEY
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|KEYREAPERINT
value|120
end_define

begin_define
define|#
directive|define
name|ROUNDUP
parameter_list|(
name|a
parameter_list|)
define|\
value|((a)> 0 ? (1 + (((a) - 1) | (sizeof(long) - 1))) : sizeof(long))
end_define

begin_function
specifier|static
name|int
name|key_sendup
parameter_list|(
name|s
parameter_list|,
name|km
parameter_list|)
name|struct
name|socket
modifier|*
name|s
decl_stmt|;
name|struct
name|key_msghdr
modifier|*
name|km
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_WAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|m_nextpkt
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
literal|0
expr_stmt|;
name|m_copyback
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|km
operator|->
name|key_msglen
argument_list|,
operator|(
name|caddr_t
operator|)
name|km
argument_list|)
expr_stmt|;
if|if
condition|(
name|sbappendaddr
argument_list|(
operator|&
operator|(
name|s
operator|->
name|so_rcv
operator|)
argument_list|,
operator|&
name|key_addr
argument_list|,
name|m
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|sorwakeup
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|notyet
end_ifdef

begin_comment
comment|/*----------------------------------------------------------------------  * key_reaper():  *      Scan key table,  nuke unwanted entries  ----------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|key_reaper
parameter_list|(
name|whocares
parameter_list|)
name|void
modifier|*
name|whocares
decl_stmt|;
block|{
name|DPRINTF
argument_list|(
name|IDL_GROSS_EVENT
argument_list|,
operator|(
literal|"Entering key_reaper()\n"
operator|)
argument_list|)
expr_stmt|;
name|timeout
argument_list|(
name|key_reaper
argument_list|,
name|NULL
argument_list|,
name|KEYREAPERINT
operator|*
name|HZ
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* notyet */
end_comment

begin_comment
comment|/*----------------------------------------------------------------------  * key_init():  *      Init routine for key socket,  key engine  ----------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|key_init
parameter_list|(
name|void
parameter_list|)
block|{
name|DPRINTF
argument_list|(
name|IDL_EVENT
argument_list|,
operator|(
literal|"Called key_init().\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|key_inittables
argument_list|()
condition|)
name|panic
argument_list|(
literal|"key_inittables failed!\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
name|timeout
argument_list|(
name|key_reaper
argument_list|,
name|NULL
argument_list|,
name|HZ
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* notyet */
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|keyso_cb
argument_list|,
sizeof|sizeof
argument_list|(
name|keyso_cb
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------  * my_addr():  *      Determine if an address belongs to one of my configured interfaces.  *      Currently handles only AF_INET,  AF_INET6 addresses.  ----------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|my_addr
parameter_list|(
name|sa
parameter_list|)
name|SOCKADDR
modifier|*
name|sa
decl_stmt|;
block|{
name|struct
name|in6_ifaddr
modifier|*
name|i6a
init|=
literal|0
decl_stmt|;
name|struct
name|in_ifaddr
modifier|*
name|ia
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|sa
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
for|for
control|(
name|i6a
operator|=
name|in6_ifaddr
init|;
name|i6a
condition|;
name|i6a
operator|=
name|i6a
operator|->
name|i6a_next
control|)
block|{
if|if
condition|(
name|IN6_ADDR_EQUAL
argument_list|(
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sa
operator|)
operator|->
name|sin6_addr
argument_list|,
name|i6a
operator|->
name|i6a_addr
operator|.
name|sin6_addr
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
break|break;
endif|#
directive|endif
comment|/* INET6 */
case|case
name|AF_INET
case|:
for|for
control|(
name|ia
operator|=
name|in_ifaddr
init|;
name|ia
condition|;
name|ia
operator|=
name|ia
operator|->
name|ia_next
control|)
block|{
if|if
condition|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sa
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
name|ia
operator|->
name|ia_addr
operator|.
name|sin_addr
operator|.
name|s_addr
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------  * key_output():  *      Process outbound pf_key message.  ----------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|key_output
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|key_msghdr
modifier|*
name|km
init|=
literal|0
decl_stmt|;
name|caddr_t
name|cp
decl_stmt|,
name|cplimit
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|dstfamily
init|=
literal|0
decl_stmt|;
name|DPRINTF
argument_list|(
name|IDL_EVENT
argument_list|,
operator|(
literal|"key_output() got a message len=%d.\n"
operator|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|)
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|senderr
define|#
directive|define
name|senderr
parameter_list|(
name|e
parameter_list|)
define|\
value|{ error = (e); if (km) km->key_errno = error; goto flush; }
if|if
condition|(
name|m
operator|==
literal|0
operator|||
operator|(
operator|(
name|m
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|)
operator|&&
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
name|IDL_CRITICAL
argument_list|,
operator|(
literal|"key_output can't pullup mbuf\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_PKTHDR
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"key_output"
argument_list|)
expr_stmt|;
name|DDO
argument_list|(
name|IDL_FINISHED
argument_list|,
name|dump_mbuf
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|km
argument_list|)
operator|||
name|len
operator|!=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|key_msghdr
operator|*
argument_list|)
operator|->
name|key_msglen
condition|)
block|{
name|DPRINTF
argument_list|(
name|IDL_CRITICAL
argument_list|,
operator|(
literal|"keyout: Invalid length field/length mismatch!\n"
operator|)
argument_list|)
expr_stmt|;
name|senderr
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
block|}
name|KMALLOC
argument_list|(
name|km
argument_list|,
expr|struct
name|key_msghdr
operator|*
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|km
operator|==
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|IDL_CRITICAL
argument_list|,
operator|(
literal|"keyoutput: Can't malloc memory!\n"
operator|)
argument_list|)
expr_stmt|;
name|senderr
argument_list|(
name|ENOBUFS
argument_list|)
expr_stmt|;
block|}
name|m_copydata
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|len
argument_list|,
operator|(
name|caddr_t
operator|)
name|km
argument_list|)
expr_stmt|;
name|km
operator|->
name|key_errno
operator|=
name|error
operator|=
name|key_parse
argument_list|(
operator|&
name|km
argument_list|,
name|so
argument_list|,
operator|&
name|dstfamily
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|IDL_MAJOR_EVENT
argument_list|,
operator|(
literal|"Back from key_parse\n"
operator|)
argument_list|)
expr_stmt|;
name|flush
label|:
name|key_sendup
argument_list|(
name|so
argument_list|,
name|km
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|{     struct rawcb *rp = 0;     struct mbuf *m;      if ((so->so_options& SO_USELOOPBACK) == 0) {       if (keyso_cb.any_count<= 1) { 	if (km) 	  KFREE(km); 	return (error);       }       rp = sotorawcb(so);     }    DPRINTF(IDL_MAJOR_EVENT, ("key_output: foo\n"));     key_proto.sp_protocol = dstfamily;      if (km) {       m = m_devget(km, len, 0, NULL, NULL);       KFREE(km);     }    DPRINTF(IDL_MAJOR_EVENT, ("key_output: bar\n"));     if (rp)       rp->rcb_proto.sp_family = 0;
comment|/* Prevent us from receiving message */
block|raw_input(m,&key_proto,&key_addr,&key_addr);      if (rp)       rp->rcb_proto.sp_family = PF_KEY;   }   DPRINTF(IDL_MAJOR_EVENT, ("key_output: baz\n"));
endif|#
directive|endif
comment|/* 0 */
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------  * key_usrreq():  *      Handles PRU_* for pf_key sockets.  ----------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|key_usrreq
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|req
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|mbuf
modifier|*
name|nam
parameter_list|,
name|struct
name|mbuf
modifier|*
name|control
parameter_list|)
block|{
specifier|register
name|int
name|error
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|rawcb
modifier|*
name|rp
init|=
name|sotorawcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|int
name|s
decl_stmt|;
name|DPRINTF
argument_list|(
name|IDL_EVENT
argument_list|,
operator|(
literal|"Entering key_usrreq, req = %d.\n"
operator|,
name|req
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|==
name|PRU_ATTACH
condition|)
block|{
name|MALLOC
argument_list|(
name|rp
argument_list|,
expr|struct
name|rawcb
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rp
argument_list|)
argument_list|,
name|M_PCB
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_pcb
operator|=
operator|(
name|caddr_t
operator|)
name|rp
condition|)
name|bzero
argument_list|(
name|so
operator|->
name|so_pcb
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rp
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|req
operator|==
name|PRU_DETACH
operator|&&
name|rp
condition|)
block|{
name|int
name|af
init|=
name|rp
operator|->
name|rcb_proto
operator|.
name|sp_protocol
decl_stmt|;
if|if
condition|(
name|af
operator|==
name|AF_INET
condition|)
name|keyso_cb
operator|.
name|ip4_count
operator|--
expr_stmt|;
ifdef|#
directive|ifdef
name|INET6
elseif|else
if|if
condition|(
name|af
operator|==
name|AF_INET6
condition|)
name|keyso_cb
operator|.
name|ip6_count
operator|--
expr_stmt|;
endif|#
directive|endif
comment|/* INET6 */
name|keyso_cb
operator|.
name|any_count
operator|--
expr_stmt|;
block|}
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|error
operator|=
name|raw_usrreq
argument_list|(
name|so
argument_list|,
name|req
argument_list|,
name|m
argument_list|,
name|nam
argument_list|,
name|control
argument_list|)
expr_stmt|;
name|rp
operator|=
name|sotorawcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|==
name|PRU_ATTACH
operator|&&
name|rp
condition|)
block|{
name|int
name|af
init|=
name|rp
operator|->
name|rcb_proto
operator|.
name|sp_protocol
decl_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|rp
argument_list|,
name|M_PCB
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
if|if
condition|(
name|af
operator|==
name|AF_INET
condition|)
name|keyso_cb
operator|.
name|ip4_count
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|INET6
elseif|else
if|if
condition|(
name|af
operator|==
name|AF_INET6
condition|)
name|keyso_cb
operator|.
name|ip6_count
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* INET6 */
name|keyso_cb
operator|.
name|any_count
operator|++
expr_stmt|;
name|rp
operator|->
name|rcb_faddr
operator|=
operator|&
name|key_addr
expr_stmt|;
name|soisconnected
argument_list|(
name|so
argument_list|)
expr_stmt|;
comment|/* Key socket, like routing socket, must be 			    connected. */
comment|/* Possibly set other needed flags/options at creation time in here. */
name|so
operator|->
name|so_options
operator||=
name|SO_USELOOPBACK
expr_stmt|;
comment|/* Like routing socket, we turn this */
comment|/* on by default                     */
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------  * key_cbinit():  *      Control block init routine for key socket  ----------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|key_cbinit
parameter_list|(
name|void
parameter_list|)
block|{
comment|/*   *  This is equivalent to raw_init for the routing socket.    *  The key socket uses the same control block as the routing    *  socket.   */
name|DPRINTF
argument_list|(
name|IDL_EVENT
argument_list|,
operator|(
literal|"Called key_cbinit().\n"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Protoswitch entry for pf_key   */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|domain
name|keydomain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* or at least forward */
end_comment

begin_decl_stmt
name|struct
name|protosw
name|keysw
index|[]
init|=
block|{
block|{
name|SOCK_RAW
block|,
operator|&
name|keydomain
block|,
literal|0
block|,
name|PR_ATOMIC
operator||
name|PR_ADDR
block|,
name|raw_input
block|,
name|key_output
block|,
name|raw_ctlinput
block|,
literal|0
block|,
name|key_usrreq
block|,
name|key_cbinit
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|domain
name|keydomain
init|=
block|{
name|PF_KEY
block|,
literal|"key"
block|,
name|key_init
block|,
literal|0
block|,
literal|0
block|,
name|keysw
block|,
operator|&
name|keysw
index|[
sizeof|sizeof
argument_list|(
name|keysw
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|keysw
index|[
literal|0
index|]
argument_list|)
index|]
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|DOMAIN_SET
argument_list|(
argument|key
argument_list|)
end_macro

end_unit

