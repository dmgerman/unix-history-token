begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$FreeBSD$	*/
end_comment

begin_comment
comment|/*	$KAME: key.c,v 1.191 2001/06/27 10:46:49 sakane Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the project nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * This code is referd to RFC 2367  */
end_comment

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|"opt_ipsec.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/domain.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<net/raw_cb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/in6_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/ip6_var.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INET6 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in_pcb.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_include
include|#
directive|include
file|<netinet6/in6_pcb.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INET6 */
end_comment

begin_include
include|#
directive|include
file|<net/pfkeyv2.h>
end_include

begin_include
include|#
directive|include
file|<netkey/keydb.h>
end_include

begin_include
include|#
directive|include
file|<netkey/key.h>
end_include

begin_include
include|#
directive|include
file|<netkey/keysock.h>
end_include

begin_include
include|#
directive|include
file|<netkey/key_debug.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/ipsec.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_include
include|#
directive|include
file|<netinet6/ipsec6.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netinet6/ah.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_include
include|#
directive|include
file|<netinet6/ah6.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|IPSEC_ESP
end_ifdef

begin_include
include|#
directive|include
file|<netinet6/esp.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_include
include|#
directive|include
file|<netinet6/esp6.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netinet6/ipcomp.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_include
include|#
directive|include
file|<netinet6/ipcomp6.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<machine/stdarg.h>
end_include

begin_comment
comment|/* randomness */
end_comment

begin_include
include|#
directive|include
file|<sys/random.h>
end_include

begin_include
include|#
directive|include
file|<net/net_osdep.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|satosin
end_ifndef

begin_define
define|#
directive|define
name|satosin
parameter_list|(
name|s
parameter_list|)
value|((struct sockaddr_in *)s)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|FULLMASK
value|0xff
end_define

begin_comment
comment|/*  * Note on SA reference counting:  * - SAs that are not in DEAD state will have (total external reference + 1)  *   following value in reference count field.  they cannot be freed and are  *   referenced from SA header.  * - SAs that are in DEAD state will have (total external reference)  *   in reference count field.  they are ready to be freed.  reference from  *   SA header will be removed in key_delsav(), when the reference count  *   field hits 0 (= no external reference other than from SA header.  */
end_comment

begin_decl_stmt
name|u_int32_t
name|key_debug_level
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|key_spi_trycnt
init|=
literal|1000
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int32_t
name|key_spi_minval
init|=
literal|0x100
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int32_t
name|key_spi_maxval
init|=
literal|0x0fffffff
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX */
end_comment

begin_decl_stmt
specifier|static
name|u_int32_t
name|policy_id
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|key_int_random
init|=
literal|60
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*interval to initialize randseed,1(m)*/
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|key_larval_lifetime
init|=
literal|30
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* interval to expire acquiring, 30(s)*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|key_blockacq_count
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* counter for blocking SADB_ACQUIRE.*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|key_blockacq_lifetime
init|=
literal|20
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* lifetime for blocking SADB_ACQUIRE.*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|key_prefered_oldsa
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* prefered old sa rather than new sa.*/
end_comment

begin_decl_stmt
specifier|static
name|u_int32_t
name|acq_seq
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|key_tick_init_random
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|LIST_HEAD
argument_list|(
argument|_sptree
argument_list|,
argument|secpolicy
argument_list|)
name|sptree
index|[
name|IPSEC_DIR_MAX
index|]
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* SPD */
end_comment

begin_expr_stmt
specifier|static
name|LIST_HEAD
argument_list|(
argument|_sahtree
argument_list|,
argument|secashead
argument_list|)
name|sahtree
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* SAD */
end_comment

begin_expr_stmt
specifier|static
name|LIST_HEAD
argument_list|(
argument|_regtree
argument_list|,
argument|secreg
argument_list|)
name|regtree
index|[
name|SADB_SATYPE_MAX
operator|+
literal|1
index|]
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* registed list */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|IPSEC_NONBLOCK_ACQUIRE
end_ifndef

begin_expr_stmt
specifier|static
name|LIST_HEAD
argument_list|(
argument|_acqtree
argument_list|,
argument|secacq
argument_list|)
name|acqtree
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* acquiring list */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
specifier|static
name|LIST_HEAD
argument_list|(
argument|_spacqtree
argument_list|,
argument|secspacq
argument_list|)
name|spacqtree
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* SP acquiring list */
end_comment

begin_decl_stmt
name|struct
name|key_cb
name|key_cb
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* search order for SAs */
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|saorder_state_valid
index|[]
init|=
block|{
name|SADB_SASTATE_DYING
block|,
name|SADB_SASTATE_MATURE
block|,
comment|/* 	 * This order is important because we must select a oldest SA 	 * for outbound processing.  For inbound, This is not important. 	 */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|saorder_state_alive
index|[]
init|=
block|{
comment|/* except DEAD */
name|SADB_SASTATE_MATURE
block|,
name|SADB_SASTATE_DYING
block|,
name|SADB_SASTATE_LARVAL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|saorder_state_any
index|[]
init|=
block|{
name|SADB_SASTATE_MATURE
block|,
name|SADB_SASTATE_DYING
block|,
name|SADB_SASTATE_LARVAL
block|,
name|SADB_SASTATE_DEAD
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|int
name|minsize
index|[]
init|=
block|{
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
block|,
comment|/* SADB_EXT_RESERVED */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_sa
argument_list|)
block|,
comment|/* SADB_EXT_SA */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_lifetime
argument_list|)
block|,
comment|/* SADB_EXT_LIFETIME_CURRENT */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_lifetime
argument_list|)
block|,
comment|/* SADB_EXT_LIFETIME_HARD */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_lifetime
argument_list|)
block|,
comment|/* SADB_EXT_LIFETIME_SOFT */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_address
argument_list|)
block|,
comment|/* SADB_EXT_ADDRESS_SRC */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_address
argument_list|)
block|,
comment|/* SADB_EXT_ADDRESS_DST */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_address
argument_list|)
block|,
comment|/* SADB_EXT_ADDRESS_PROXY */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_key
argument_list|)
block|,
comment|/* SADB_EXT_KEY_AUTH */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_key
argument_list|)
block|,
comment|/* SADB_EXT_KEY_ENCRYPT */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_ident
argument_list|)
block|,
comment|/* SADB_EXT_IDENTITY_SRC */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_ident
argument_list|)
block|,
comment|/* SADB_EXT_IDENTITY_DST */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_sens
argument_list|)
block|,
comment|/* SADB_EXT_SENSITIVITY */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_prop
argument_list|)
block|,
comment|/* SADB_EXT_PROPOSAL */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_supported
argument_list|)
block|,
comment|/* SADB_EXT_SUPPORTED_AUTH */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_supported
argument_list|)
block|,
comment|/* SADB_EXT_SUPPORTED_ENCRYPT */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_spirange
argument_list|)
block|,
comment|/* SADB_EXT_SPIRANGE */
literal|0
block|,
comment|/* SADB_X_EXT_KMPRIVATE */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_x_policy
argument_list|)
block|,
comment|/* SADB_X_EXT_POLICY */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_x_sa2
argument_list|)
block|,
comment|/* SADB_X_SA2 */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|int
name|maxsize
index|[]
init|=
block|{
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
block|,
comment|/* SADB_EXT_RESERVED */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_sa
argument_list|)
block|,
comment|/* SADB_EXT_SA */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_lifetime
argument_list|)
block|,
comment|/* SADB_EXT_LIFETIME_CURRENT */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_lifetime
argument_list|)
block|,
comment|/* SADB_EXT_LIFETIME_HARD */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_lifetime
argument_list|)
block|,
comment|/* SADB_EXT_LIFETIME_SOFT */
literal|0
block|,
comment|/* SADB_EXT_ADDRESS_SRC */
literal|0
block|,
comment|/* SADB_EXT_ADDRESS_DST */
literal|0
block|,
comment|/* SADB_EXT_ADDRESS_PROXY */
literal|0
block|,
comment|/* SADB_EXT_KEY_AUTH */
literal|0
block|,
comment|/* SADB_EXT_KEY_ENCRYPT */
literal|0
block|,
comment|/* SADB_EXT_IDENTITY_SRC */
literal|0
block|,
comment|/* SADB_EXT_IDENTITY_DST */
literal|0
block|,
comment|/* SADB_EXT_SENSITIVITY */
literal|0
block|,
comment|/* SADB_EXT_PROPOSAL */
literal|0
block|,
comment|/* SADB_EXT_SUPPORTED_AUTH */
literal|0
block|,
comment|/* SADB_EXT_SUPPORTED_ENCRYPT */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_spirange
argument_list|)
block|,
comment|/* SADB_EXT_SPIRANGE */
literal|0
block|,
comment|/* SADB_X_EXT_KMPRIVATE */
literal|0
block|,
comment|/* SADB_X_EXT_POLICY */
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_x_sa2
argument_list|)
block|,
comment|/* SADB_X_SA2 */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ipsec_esp_keymin
init|=
literal|256
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ipsec_esp_auth
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ipsec_ah_keymin
init|=
literal|128
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SYSCTL_DECL
end_ifdef

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_net_key
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_key
argument_list|,
name|KEYCTL_DEBUG_LEVEL
argument_list|,
name|debug
argument_list|,
name|CTLFLAG_RW
argument_list|, \
operator|&
name|key_debug_level
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* max count of trial for the decision of spi value */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_key
argument_list|,
name|KEYCTL_SPI_TRY
argument_list|,
name|spi_trycnt
argument_list|,
name|CTLFLAG_RW
argument_list|, \
operator|&
name|key_spi_trycnt
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* minimum spi value to allocate automatically. */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_key
argument_list|,
name|KEYCTL_SPI_MIN_VALUE
argument_list|,
name|spi_minval
argument_list|,
name|CTLFLAG_RW
argument_list|, \
operator|&
name|key_spi_minval
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* maximun spi value to allocate automatically. */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_key
argument_list|,
name|KEYCTL_SPI_MAX_VALUE
argument_list|,
name|spi_maxval
argument_list|,
name|CTLFLAG_RW
argument_list|, \
operator|&
name|key_spi_maxval
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* interval to initialize randseed */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_key
argument_list|,
name|KEYCTL_RANDOM_INT
argument_list|,
name|int_random
argument_list|,
name|CTLFLAG_RW
argument_list|, \
operator|&
name|key_int_random
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* lifetime for larval SA */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_key
argument_list|,
name|KEYCTL_LARVAL_LIFETIME
argument_list|,
name|larval_lifetime
argument_list|,
name|CTLFLAG_RW
argument_list|, \
operator|&
name|key_larval_lifetime
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* counter for blocking to send SADB_ACQUIRE to IKEd */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_key
argument_list|,
name|KEYCTL_BLOCKACQ_COUNT
argument_list|,
name|blockacq_count
argument_list|,
name|CTLFLAG_RW
argument_list|, \
operator|&
name|key_blockacq_count
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* lifetime for blocking to send SADB_ACQUIRE to IKEd */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_key
argument_list|,
name|KEYCTL_BLOCKACQ_LIFETIME
argument_list|,
name|blockacq_lifetime
argument_list|,
name|CTLFLAG_RW
argument_list|, \
operator|&
name|key_blockacq_lifetime
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* ESP auth */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_key
argument_list|,
name|KEYCTL_ESP_AUTH
argument_list|,
name|esp_auth
argument_list|,
name|CTLFLAG_RW
argument_list|, \
operator|&
name|ipsec_esp_auth
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* minimum ESP key length */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_key
argument_list|,
name|KEYCTL_ESP_KEYMIN
argument_list|,
name|esp_keymin
argument_list|,
name|CTLFLAG_RW
argument_list|, \
operator|&
name|ipsec_esp_keymin
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* minimum AH key length */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_key
argument_list|,
name|KEYCTL_AH_KEYMIN
argument_list|,
name|ah_keymin
argument_list|,
name|CTLFLAG_RW
argument_list|, \
operator|&
name|ipsec_ah_keymin
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* perfered old SA rather than new SA */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_key
argument_list|,
name|KEYCTL_PREFERED_OLDSA
argument_list|,
name|prefered_oldsa
argument_list|,
name|CTLFLAG_RW
argument_list|,\
operator|&
name|key_prefered_oldsa
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|LIST_FOREACH
end_ifndef

begin_define
define|#
directive|define
name|LIST_FOREACH
parameter_list|(
name|elm
parameter_list|,
name|head
parameter_list|,
name|field
parameter_list|)
define|\
value|for (elm = LIST_FIRST(head); elm; elm = LIST_NEXT(elm, field))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|__LIST_CHAINED
parameter_list|(
name|elm
parameter_list|)
define|\
value|(!((elm)->chain.le_next == NULL&& (elm)->chain.le_prev == NULL))
end_define

begin_define
define|#
directive|define
name|LIST_INSERT_TAIL
parameter_list|(
name|head
parameter_list|,
name|elm
parameter_list|,
name|type
parameter_list|,
name|field
parameter_list|)
define|\
value|do {\ 	struct type *curelm = LIST_FIRST(head); \ 	if (curelm == NULL) {\ 		LIST_INSERT_HEAD(head, elm, field); \ 	} else { \ 		while (LIST_NEXT(curelm, field)) \ 			curelm = LIST_NEXT(curelm, field);\ 		LIST_INSERT_AFTER(curelm, elm, field);\ 	}\ } while (0)
end_define

begin_define
define|#
directive|define
name|KEY_CHKSASTATE
parameter_list|(
name|head
parameter_list|,
name|sav
parameter_list|,
name|name
parameter_list|)
define|\
value|do { \ 	if ((head) != (sav)) {						\ 		ipseclog((LOG_DEBUG, "%s: state mismatched (TREE=%d SA=%d)\n", \ 			(name), (head), (sav)));			\ 		continue;						\ 	}								\ } while (0)
end_define

begin_define
define|#
directive|define
name|KEY_CHKSPDIR
parameter_list|(
name|head
parameter_list|,
name|sp
parameter_list|,
name|name
parameter_list|)
define|\
value|do { \ 	if ((head) != (sp)) {						\ 		ipseclog((LOG_DEBUG, "%s: direction mismatched (TREE=%d SP=%d), " \ 			"anyway continue.\n",				\ 			(name), (head), (sp)));				\ 	}								\ } while (0)
end_define

begin_if
if|#
directive|if
literal|1
end_if

begin_define
define|#
directive|define
name|KMALLOC
parameter_list|(
name|p
parameter_list|,
name|t
parameter_list|,
name|n
parameter_list|)
define|\
value|((p) = (t) malloc((unsigned long)(n), M_SECA, M_NOWAIT))
end_define

begin_define
define|#
directive|define
name|KFREE
parameter_list|(
name|p
parameter_list|)
define|\
value|free((caddr_t)(p), M_SECA);
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|KMALLOC
parameter_list|(
name|p
parameter_list|,
name|t
parameter_list|,
name|n
parameter_list|)
define|\
value|do { \ 	((p) = (t)malloc((unsigned long)(n), M_SECA, M_NOWAIT));             \ 	printf("%s %d: %p<- KMALLOC(%s, %d)\n",                             \ 		__FILE__, __LINE__, (p), #t, n);                             \ } while (0)
end_define

begin_define
define|#
directive|define
name|KFREE
parameter_list|(
name|p
parameter_list|)
define|\
value|do {                                                                 \ 		printf("%s %d: %p -> KFREE()\n", __FILE__, __LINE__, (p));   \ 		free((caddr_t)(p), M_SECA);                                  \ 	} while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * set parameters into secpolicyindex buffer.  * Must allocate secpolicyindex buffer passed to this function.  */
end_comment

begin_define
define|#
directive|define
name|KEY_SETSECSPIDX
parameter_list|(
name|_dir
parameter_list|,
name|s
parameter_list|,
name|d
parameter_list|,
name|ps
parameter_list|,
name|pd
parameter_list|,
name|ulp
parameter_list|,
name|idx
parameter_list|)
define|\
value|do { \ 	bzero((idx), sizeof(struct secpolicyindex));                             \ 	(idx)->dir = (_dir);                                                 \ 	(idx)->prefs = (ps);                                                 \ 	(idx)->prefd = (pd);                                                 \ 	(idx)->ul_proto = (ulp);                                             \ 	bcopy((s),&(idx)->src, ((struct sockaddr *)(s))->sa_len);           \ 	bcopy((d),&(idx)->dst, ((struct sockaddr *)(d))->sa_len);           \ } while (0)
end_define

begin_comment
comment|/*  * set parameters into secasindex buffer.  * Must allocate secasindex buffer before calling this function.  */
end_comment

begin_define
define|#
directive|define
name|KEY_SETSECASIDX
parameter_list|(
name|p
parameter_list|,
name|m
parameter_list|,
name|r
parameter_list|,
name|s
parameter_list|,
name|d
parameter_list|,
name|idx
parameter_list|)
define|\
value|do { \ 	bzero((idx), sizeof(struct secasindex));                             \ 	(idx)->proto = (p);                                                  \ 	(idx)->mode = (m);                                                   \ 	(idx)->reqid = (r);                                                  \ 	bcopy((s),&(idx)->src, ((struct sockaddr *)(s))->sa_len);           \ 	bcopy((d),&(idx)->dst, ((struct sockaddr *)(d))->sa_len);           \ } while (0)
end_define

begin_comment
comment|/* key statistics */
end_comment

begin_struct
struct|struct
name|_keystat
block|{
name|u_long
name|getspi_count
decl_stmt|;
comment|/* the avarage of count to try to get new SPI */
block|}
name|keystat
struct|;
end_struct

begin_struct
struct|struct
name|sadb_msghdr
block|{
name|struct
name|sadb_msg
modifier|*
name|msg
decl_stmt|;
name|struct
name|sadb_ext
modifier|*
name|ext
index|[
name|SADB_EXT_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|extoff
index|[
name|SADB_EXT_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|extlen
index|[
name|SADB_EXT_MAX
operator|+
literal|1
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|secasvar
modifier|*
name|key_allocsa_policy
name|__P
argument_list|(
operator|(
expr|struct
name|secasindex
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|key_freesp_so
name|__P
argument_list|(
operator|(
expr|struct
name|secpolicy
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|secasvar
modifier|*
name|key_do_allocsa_policy
name|__P
argument_list|(
operator|(
expr|struct
name|secashead
operator|*
operator|,
name|u_int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|key_delsp
name|__P
argument_list|(
operator|(
expr|struct
name|secpolicy
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|secpolicy
modifier|*
name|key_getsp
name|__P
argument_list|(
operator|(
expr|struct
name|secpolicyindex
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|secpolicy
modifier|*
name|key_getspbyid
name|__P
argument_list|(
operator|(
name|u_int32_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int32_t
name|key_newreqid
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mbuf
modifier|*
name|key_gather_mbuf
name|__P
argument_list|(
operator|(
expr|struct
name|mbuf
operator|*
operator|,
specifier|const
expr|struct
name|sadb_msghdr
operator|*
operator|,
name|int
operator|,
name|int
operator|,
operator|...
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|key_spdadd
name|__P
argument_list|(
operator|(
expr|struct
name|socket
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|,
specifier|const
expr|struct
name|sadb_msghdr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int32_t
name|key_getnewspid
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|key_spddelete
name|__P
argument_list|(
operator|(
expr|struct
name|socket
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|,
specifier|const
expr|struct
name|sadb_msghdr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|key_spddelete2
name|__P
argument_list|(
operator|(
expr|struct
name|socket
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|,
specifier|const
expr|struct
name|sadb_msghdr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|key_spdget
name|__P
argument_list|(
operator|(
expr|struct
name|socket
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|,
specifier|const
expr|struct
name|sadb_msghdr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|key_spdflush
name|__P
argument_list|(
operator|(
expr|struct
name|socket
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|,
specifier|const
expr|struct
name|sadb_msghdr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|key_spddump
name|__P
argument_list|(
operator|(
expr|struct
name|socket
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|,
specifier|const
expr|struct
name|sadb_msghdr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mbuf
modifier|*
name|key_setdumpsp
name|__P
argument_list|(
operator|(
expr|struct
name|secpolicy
operator|*
operator|,
name|u_int8_t
operator|,
name|u_int32_t
operator|,
name|u_int32_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|key_getspreqmsglen
name|__P
argument_list|(
operator|(
expr|struct
name|secpolicy
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|key_spdexpire
name|__P
argument_list|(
operator|(
expr|struct
name|secpolicy
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|secashead
modifier|*
name|key_newsah
name|__P
argument_list|(
operator|(
expr|struct
name|secasindex
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|key_delsah
name|__P
argument_list|(
operator|(
expr|struct
name|secashead
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|secasvar
modifier|*
name|key_newsav
name|__P
argument_list|(
operator|(
expr|struct
name|mbuf
operator|*
operator|,
specifier|const
expr|struct
name|sadb_msghdr
operator|*
operator|,
expr|struct
name|secashead
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|key_delsav
name|__P
argument_list|(
operator|(
expr|struct
name|secasvar
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|secashead
modifier|*
name|key_getsah
name|__P
argument_list|(
operator|(
expr|struct
name|secasindex
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|secasvar
modifier|*
name|key_checkspidup
name|__P
argument_list|(
operator|(
expr|struct
name|secasindex
operator|*
operator|,
name|u_int32_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|secasvar
modifier|*
name|key_getsavbyspi
name|__P
argument_list|(
operator|(
expr|struct
name|secashead
operator|*
operator|,
name|u_int32_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|key_setsaval
name|__P
argument_list|(
operator|(
expr|struct
name|secasvar
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|,
specifier|const
expr|struct
name|sadb_msghdr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|key_mature
name|__P
argument_list|(
operator|(
expr|struct
name|secasvar
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mbuf
modifier|*
name|key_setdumpsa
name|__P
argument_list|(
operator|(
expr|struct
name|secasvar
operator|*
operator|,
name|u_int8_t
operator|,
name|u_int8_t
operator|,
name|u_int32_t
operator|,
name|u_int32_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mbuf
modifier|*
name|key_setsadbmsg
name|__P
argument_list|(
operator|(
name|u_int8_t
operator|,
name|u_int16_t
operator|,
name|u_int8_t
operator|,
name|u_int32_t
operator|,
name|pid_t
operator|,
name|u_int16_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mbuf
modifier|*
name|key_setsadbsa
name|__P
argument_list|(
operator|(
expr|struct
name|secasvar
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mbuf
modifier|*
name|key_setsadbaddr
name|__P
argument_list|(
operator|(
name|u_int16_t
operator|,
expr|struct
name|sockaddr
operator|*
operator|,
name|u_int8_t
operator|,
name|u_int16_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static struct mbuf *key_setsadbident __P((u_int16_t, u_int16_t, caddr_t, 	int, u_int64_t));
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|mbuf
modifier|*
name|key_setsadbxsa2
name|__P
argument_list|(
operator|(
name|u_int8_t
operator|,
name|u_int32_t
operator|,
name|u_int32_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mbuf
modifier|*
name|key_setsadbxpolicy
name|__P
argument_list|(
operator|(
name|u_int16_t
operator|,
name|u_int8_t
operator|,
name|u_int32_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
modifier|*
name|key_newbuf
name|__P
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|,
name|u_int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|key_ismyaddr6
name|__P
argument_list|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* flags for key_cmpsaidx() */
end_comment

begin_define
define|#
directive|define
name|CMP_HEAD
value|1
end_define

begin_comment
comment|/* protocol, addresses. */
end_comment

begin_define
define|#
directive|define
name|CMP_MODE_REQID
value|2
end_define

begin_comment
comment|/* additionally HEAD, reqid, mode. */
end_comment

begin_define
define|#
directive|define
name|CMP_REQID
value|3
end_define

begin_comment
comment|/* additionally HEAD, reaid. */
end_comment

begin_define
define|#
directive|define
name|CMP_EXACTLY
value|4
end_define

begin_comment
comment|/* all elements. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|key_cmpsaidx
name|__P
argument_list|(
operator|(
expr|struct
name|secasindex
operator|*
operator|,
expr|struct
name|secasindex
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|key_cmpspidx_exactly
name|__P
argument_list|(
operator|(
expr|struct
name|secpolicyindex
operator|*
operator|,
expr|struct
name|secpolicyindex
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|key_cmpspidx_withmask
name|__P
argument_list|(
operator|(
expr|struct
name|secpolicyindex
operator|*
operator|,
expr|struct
name|secpolicyindex
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|key_sockaddrcmp
name|__P
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|,
expr|struct
name|sockaddr
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|key_bbcmp
name|__P
argument_list|(
operator|(
name|caddr_t
operator|,
name|caddr_t
operator|,
name|u_int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|key_srandom
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int16_t
name|key_satype2proto
name|__P
argument_list|(
operator|(
name|u_int8_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int8_t
name|key_proto2satype
name|__P
argument_list|(
operator|(
name|u_int16_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|key_getspi
name|__P
argument_list|(
operator|(
expr|struct
name|socket
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|,
specifier|const
expr|struct
name|sadb_msghdr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int32_t
name|key_do_getnewspi
name|__P
argument_list|(
operator|(
expr|struct
name|sadb_spirange
operator|*
operator|,
expr|struct
name|secasindex
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|key_update
name|__P
argument_list|(
operator|(
expr|struct
name|socket
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|,
specifier|const
expr|struct
name|sadb_msghdr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|IPSEC_DOSEQCHECK
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|secasvar
modifier|*
name|key_getsavbyseq
name|__P
argument_list|(
operator|(
expr|struct
name|secashead
operator|*
operator|,
name|u_int32_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|key_add
name|__P
argument_list|(
operator|(
expr|struct
name|socket
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|,
specifier|const
expr|struct
name|sadb_msghdr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|key_setident
name|__P
argument_list|(
operator|(
expr|struct
name|secashead
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|,
specifier|const
expr|struct
name|sadb_msghdr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mbuf
modifier|*
name|key_getmsgbuf_x1
name|__P
argument_list|(
operator|(
expr|struct
name|mbuf
operator|*
operator|,
specifier|const
expr|struct
name|sadb_msghdr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|key_delete
name|__P
argument_list|(
operator|(
expr|struct
name|socket
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|,
specifier|const
expr|struct
name|sadb_msghdr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|key_get
name|__P
argument_list|(
operator|(
expr|struct
name|socket
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|,
specifier|const
expr|struct
name|sadb_msghdr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|key_getcomb_setlifetime
name|__P
argument_list|(
operator|(
expr|struct
name|sadb_comb
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|IPSEC_ESP
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|mbuf
modifier|*
name|key_getcomb_esp
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|mbuf
modifier|*
name|key_getcomb_ah
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mbuf
modifier|*
name|key_getcomb_ipcomp
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mbuf
modifier|*
name|key_getprop
name|__P
argument_list|(
operator|(
specifier|const
expr|struct
name|secasindex
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|key_acquire
name|__P
argument_list|(
operator|(
expr|struct
name|secasindex
operator|*
operator|,
expr|struct
name|secpolicy
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|IPSEC_NONBLOCK_ACQUIRE
end_ifndef

begin_decl_stmt
specifier|static
name|struct
name|secacq
modifier|*
name|key_newacq
name|__P
argument_list|(
operator|(
expr|struct
name|secasindex
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|secacq
modifier|*
name|key_getacq
name|__P
argument_list|(
operator|(
expr|struct
name|secasindex
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|secacq
modifier|*
name|key_getacqbyseq
name|__P
argument_list|(
operator|(
name|u_int32_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|secspacq
modifier|*
name|key_newspacq
name|__P
argument_list|(
operator|(
expr|struct
name|secpolicyindex
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|secspacq
modifier|*
name|key_getspacq
name|__P
argument_list|(
operator|(
expr|struct
name|secpolicyindex
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|key_acquire2
name|__P
argument_list|(
operator|(
expr|struct
name|socket
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|,
specifier|const
expr|struct
name|sadb_msghdr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|key_register
name|__P
argument_list|(
operator|(
expr|struct
name|socket
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|,
specifier|const
expr|struct
name|sadb_msghdr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|key_expire
name|__P
argument_list|(
operator|(
expr|struct
name|secasvar
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|key_flush
name|__P
argument_list|(
operator|(
expr|struct
name|socket
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|,
specifier|const
expr|struct
name|sadb_msghdr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|key_dump
name|__P
argument_list|(
operator|(
expr|struct
name|socket
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|,
specifier|const
expr|struct
name|sadb_msghdr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|key_promisc
name|__P
argument_list|(
operator|(
expr|struct
name|socket
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|,
specifier|const
expr|struct
name|sadb_msghdr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|key_senderror
name|__P
argument_list|(
operator|(
expr|struct
name|socket
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|key_validate_ext
name|__P
argument_list|(
operator|(
specifier|const
expr|struct
name|sadb_ext
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|key_align
name|__P
argument_list|(
operator|(
expr|struct
name|mbuf
operator|*
operator|,
expr|struct
name|sadb_msghdr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static const char *key_getfqdn __P((void)); static const char *key_getuserfqdn __P((void));
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|key_sa_chgstate
name|__P
argument_list|(
operator|(
expr|struct
name|secasvar
operator|*
operator|,
name|u_int8_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mbuf
modifier|*
name|key_alloc_mbuf
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* %%% IPsec policy management */
end_comment

begin_comment
comment|/*  * allocating a SP for OUTBOUND or INBOUND packet.  * Must call key_freesp() later.  * OUT:	NULL:	not found  *	others:	found and return the pointer.  */
end_comment

begin_function
name|struct
name|secpolicy
modifier|*
name|key_allocsp
parameter_list|(
name|spidx
parameter_list|,
name|dir
parameter_list|)
name|struct
name|secpolicyindex
modifier|*
name|spidx
decl_stmt|;
name|u_int
name|dir
decl_stmt|;
block|{
name|struct
name|secpolicy
modifier|*
name|sp
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* sanity check */
if|if
condition|(
name|spidx
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_allocsp: NULL pointer is passed.\n"
argument_list|)
expr_stmt|;
comment|/* check direction */
switch|switch
condition|(
name|dir
condition|)
block|{
case|case
name|IPSEC_DIR_INBOUND
case|:
case|case
name|IPSEC_DIR_OUTBOUND
case|:
break|break;
default|default:
name|panic
argument_list|(
literal|"key_allocsp: Invalid direction is passed.\n"
argument_list|)
expr_stmt|;
block|}
comment|/* get a SP entry */
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
comment|/*called from softclock()*/
name|KEYDEBUG
argument_list|(
argument|KEYDEBUG_IPSEC_DATA
argument_list|,
argument|printf(
literal|"*** objects\n"
argument|); 		kdebug_secpolicyindex(spidx)
argument_list|)
empty_stmt|;
name|LIST_FOREACH
argument_list|(
argument|sp
argument_list|,
argument|&sptree[dir]
argument_list|,
argument|chain
argument_list|)
block|{
name|KEYDEBUG
argument_list|(
argument|KEYDEBUG_IPSEC_DATA
argument_list|,
argument|printf(
literal|"*** in SPD\n"
argument|); 			kdebug_secpolicyindex(&sp->spidx)
argument_list|)
empty_stmt|;
if|if
condition|(
name|sp
operator|->
name|state
operator|==
name|IPSEC_SPSTATE_DEAD
condition|)
continue|continue;
if|if
condition|(
name|key_cmpspidx_withmask
argument_list|(
operator|&
name|sp
operator|->
name|spidx
argument_list|,
name|spidx
argument_list|)
condition|)
goto|goto
name|found
goto|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
name|found
label|:
comment|/* sanity check */
name|KEY_CHKSPDIR
argument_list|(
name|sp
operator|->
name|spidx
operator|.
name|dir
argument_list|,
name|dir
argument_list|,
literal|"key_allocsp"
argument_list|)
expr_stmt|;
comment|/* found a SPD entry */
name|microtime
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
name|sp
operator|->
name|lastused
operator|=
name|tv
operator|.
name|tv_sec
expr_stmt|;
name|sp
operator|->
name|refcnt
operator|++
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|KEYDEBUG
argument_list|(
name|KEYDEBUG_IPSEC_STAMP
argument_list|,
name|printf
argument_list|(
literal|"DP key_allocsp cause refcnt++:%d SP:%p\n"
argument_list|,
name|sp
operator|->
name|refcnt
argument_list|,
name|sp
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|sp
return|;
block|}
end_function

begin_comment
comment|/*  * return a policy that matches this particular inbound packet.  * XXX slow  */
end_comment

begin_function
name|struct
name|secpolicy
modifier|*
name|key_gettunnel
parameter_list|(
name|osrc
parameter_list|,
name|odst
parameter_list|,
name|isrc
parameter_list|,
name|idst
parameter_list|)
name|struct
name|sockaddr
modifier|*
name|osrc
decl_stmt|,
decl|*
name|odst
decl_stmt|,
modifier|*
name|isrc
decl_stmt|,
modifier|*
name|idst
decl_stmt|;
end_function

begin_block
block|{
name|struct
name|secpolicy
modifier|*
name|sp
decl_stmt|;
specifier|const
name|int
name|dir
init|=
name|IPSEC_DIR_INBOUND
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|int
name|s
decl_stmt|;
name|struct
name|ipsecrequest
modifier|*
name|r1
decl_stmt|,
modifier|*
name|r2
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|os
decl_stmt|,
modifier|*
name|od
decl_stmt|,
modifier|*
name|is
decl_stmt|,
modifier|*
name|id
decl_stmt|;
name|struct
name|secpolicyindex
name|spidx
decl_stmt|;
if|if
condition|(
name|isrc
operator|->
name|sa_family
operator|!=
name|idst
operator|->
name|sa_family
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_ERR
operator|,
literal|"protocol family mismatched %d != %d\n."
operator|,
name|isrc
operator|->
name|sa_family
operator|,
name|idst
operator|->
name|sa_family
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
comment|/*called from softclock()*/
name|LIST_FOREACH
argument_list|(
argument|sp
argument_list|,
argument|&sptree[dir]
argument_list|,
argument|chain
argument_list|)
block|{
if|if
condition|(
name|sp
operator|->
name|state
operator|==
name|IPSEC_SPSTATE_DEAD
condition|)
continue|continue;
name|r1
operator|=
name|r2
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|p
operator|=
name|sp
operator|->
name|req
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|->
name|saidx
operator|.
name|mode
operator|!=
name|IPSEC_MODE_TUNNEL
condition|)
continue|continue;
name|r1
operator|=
name|r2
expr_stmt|;
name|r2
operator|=
name|p
expr_stmt|;
if|if
condition|(
operator|!
name|r1
condition|)
block|{
comment|/* here we look at address matches only */
name|spidx
operator|=
name|sp
operator|->
name|spidx
expr_stmt|;
if|if
condition|(
name|isrc
operator|->
name|sa_len
operator|>
sizeof|sizeof
argument_list|(
name|spidx
operator|.
name|src
argument_list|)
operator|||
name|idst
operator|->
name|sa_len
operator|>
sizeof|sizeof
argument_list|(
name|spidx
operator|.
name|dst
argument_list|)
condition|)
continue|continue;
name|bcopy
argument_list|(
name|isrc
argument_list|,
operator|&
name|spidx
operator|.
name|src
argument_list|,
name|isrc
operator|->
name|sa_len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|idst
argument_list|,
operator|&
name|spidx
operator|.
name|dst
argument_list|,
name|idst
operator|->
name|sa_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|key_cmpspidx_withmask
argument_list|(
operator|&
name|sp
operator|->
name|spidx
argument_list|,
operator|&
name|spidx
argument_list|)
condition|)
continue|continue;
block|}
else|else
block|{
name|is
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|r1
operator|->
name|saidx
operator|.
name|src
expr_stmt|;
name|id
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|r1
operator|->
name|saidx
operator|.
name|dst
expr_stmt|;
if|if
condition|(
name|key_sockaddrcmp
argument_list|(
name|is
argument_list|,
name|isrc
argument_list|,
literal|0
argument_list|)
operator|||
name|key_sockaddrcmp
argument_list|(
name|id
argument_list|,
name|idst
argument_list|,
literal|0
argument_list|)
condition|)
continue|continue;
block|}
name|os
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|r2
operator|->
name|saidx
operator|.
name|src
expr_stmt|;
name|od
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|r2
operator|->
name|saidx
operator|.
name|dst
expr_stmt|;
if|if
condition|(
name|key_sockaddrcmp
argument_list|(
name|os
argument_list|,
name|osrc
argument_list|,
literal|0
argument_list|)
operator|||
name|key_sockaddrcmp
argument_list|(
name|od
argument_list|,
name|odst
argument_list|,
literal|0
argument_list|)
condition|)
continue|continue;
goto|goto
name|found
goto|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
name|found
label|:
name|microtime
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
name|sp
operator|->
name|lastused
operator|=
name|tv
operator|.
name|tv_sec
expr_stmt|;
name|sp
operator|->
name|refcnt
operator|++
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|sp
return|;
block|}
end_block

begin_comment
comment|/*  * allocating an SA entry for an *OUTBOUND* packet.  * checking each request entries in SP, and acquire an SA if need.  * OUT:	0: there are valid requests.  *	ENOENT: policy may be valid, but SA with REQUIRE is on acquiring.  */
end_comment

begin_function
name|int
name|key_checkrequest
parameter_list|(
name|isr
parameter_list|,
name|saidx
parameter_list|)
name|struct
name|ipsecrequest
modifier|*
name|isr
decl_stmt|;
name|struct
name|secasindex
modifier|*
name|saidx
decl_stmt|;
block|{
name|u_int
name|level
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* sanity check */
if|if
condition|(
name|isr
operator|==
name|NULL
operator|||
name|saidx
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_checkrequest: NULL pointer is passed.\n"
argument_list|)
expr_stmt|;
comment|/* check mode */
switch|switch
condition|(
name|saidx
operator|->
name|mode
condition|)
block|{
case|case
name|IPSEC_MODE_TRANSPORT
case|:
case|case
name|IPSEC_MODE_TUNNEL
case|:
break|break;
case|case
name|IPSEC_MODE_ANY
case|:
default|default:
name|panic
argument_list|(
literal|"key_checkrequest: Invalid policy defined.\n"
argument_list|)
expr_stmt|;
block|}
comment|/* get current level */
name|level
operator|=
name|ipsec_get_reqlevel
argument_list|(
name|isr
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* 	 * We do allocate new SA only if the state of SA in the holder is 	 * SADB_SASTATE_DEAD.  The SA for outbound must be the oldest. 	 */
block|if (isr->sav != NULL) { 		if (isr->sav->sah == NULL) 			panic("key_checkrequest: sah is null.\n"); 		if (isr->sav == (struct secasvar *)LIST_FIRST(&isr->sav->sah->savtree[SADB_SASTATE_DEAD])) { 			KEYDEBUG(KEYDEBUG_IPSEC_STAMP, 				printf("DP checkrequest calls free SA:%p\n", 					isr->sav)); 			key_freesav(isr->sav); 			isr->sav = NULL; 		} 	}
else|#
directive|else
comment|/* 	 * we free any SA stashed in the IPsec request because a different 	 * SA may be involved each time this request is checked, either 	 * because new SAs are being configured, or this request is 	 * associated with an unconnected datagram socket, or this request 	 * is associated with a system default policy. 	 * 	 * The operation may have negative impact to performance.  We may 	 * want to check cached SA carefully, rather than picking new SA 	 * every time. 	 */
if|if
condition|(
name|isr
operator|->
name|sav
operator|!=
name|NULL
condition|)
block|{
name|key_freesav
argument_list|(
name|isr
operator|->
name|sav
argument_list|)
expr_stmt|;
name|isr
operator|->
name|sav
operator|=
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * new SA allocation if no SA found. 	 * key_allocsa_policy should allocate the oldest SA available. 	 * See key_do_allocsa_policy(), and draft-jenkins-ipsec-rekeying-03.txt. 	 */
if|if
condition|(
name|isr
operator|->
name|sav
operator|==
name|NULL
condition|)
name|isr
operator|->
name|sav
operator|=
name|key_allocsa_policy
argument_list|(
name|saidx
argument_list|)
expr_stmt|;
comment|/* When there is SA. */
if|if
condition|(
name|isr
operator|->
name|sav
operator|!=
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* there is no SA */
if|if
condition|(
operator|(
name|error
operator|=
name|key_acquire
argument_list|(
name|saidx
argument_list|,
name|isr
operator|->
name|sp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* XXX What should I do ? */
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_checkrequest: error %d returned "
literal|"from key_acquire.\n"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
return|return
name|level
operator|==
name|IPSEC_LEVEL_REQUIRE
condition|?
name|ENOENT
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * allocating a SA for policy entry from SAD.  * NOTE: searching SAD of aliving state.  * OUT:	NULL:	not found.  *	others:	found and return the pointer.  */
end_comment

begin_function
specifier|static
name|struct
name|secasvar
modifier|*
name|key_allocsa_policy
parameter_list|(
name|saidx
parameter_list|)
name|struct
name|secasindex
modifier|*
name|saidx
decl_stmt|;
block|{
name|struct
name|secashead
modifier|*
name|sah
decl_stmt|;
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|;
name|u_int
name|stateidx
decl_stmt|,
name|state
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|sah
argument_list|,
argument|&sahtree
argument_list|,
argument|chain
argument_list|)
block|{
if|if
condition|(
name|sah
operator|->
name|state
operator|==
name|SADB_SASTATE_DEAD
condition|)
continue|continue;
if|if
condition|(
name|key_cmpsaidx
argument_list|(
operator|&
name|sah
operator|->
name|saidx
argument_list|,
name|saidx
argument_list|,
name|CMP_MODE_REQID
argument_list|)
condition|)
goto|goto
name|found
goto|;
block|}
return|return
name|NULL
return|;
name|found
label|:
comment|/* search valid state */
for|for
control|(
name|stateidx
operator|=
literal|0
init|;
name|stateidx
operator|<
name|_ARRAYLEN
argument_list|(
name|saorder_state_valid
argument_list|)
condition|;
name|stateidx
operator|++
control|)
block|{
name|state
operator|=
name|saorder_state_valid
index|[
name|stateidx
index|]
expr_stmt|;
name|sav
operator|=
name|key_do_allocsa_policy
argument_list|(
name|sah
argument_list|,
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|!=
name|NULL
condition|)
return|return
name|sav
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * searching SAD with direction, protocol, mode and state.  * called by key_allocsa_policy().  * OUT:  *	NULL	: not found  *	others	: found, pointer to a SA.  */
end_comment

begin_function
specifier|static
name|struct
name|secasvar
modifier|*
name|key_do_allocsa_policy
parameter_list|(
name|sah
parameter_list|,
name|state
parameter_list|)
name|struct
name|secashead
modifier|*
name|sah
decl_stmt|;
name|u_int
name|state
decl_stmt|;
block|{
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|,
modifier|*
name|nextsav
decl_stmt|,
modifier|*
name|candidate
decl_stmt|,
modifier|*
name|d
decl_stmt|;
comment|/* initilize */
name|candidate
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|sav
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sah
operator|->
name|savtree
index|[
name|state
index|]
argument_list|)
init|;
name|sav
operator|!=
name|NULL
condition|;
name|sav
operator|=
name|nextsav
control|)
block|{
name|nextsav
operator|=
name|LIST_NEXT
argument_list|(
name|sav
argument_list|,
name|chain
argument_list|)
expr_stmt|;
comment|/* sanity check */
name|KEY_CHKSASTATE
argument_list|(
name|sav
operator|->
name|state
argument_list|,
name|state
argument_list|,
literal|"key_do_allocsa_policy"
argument_list|)
expr_stmt|;
comment|/* initialize */
if|if
condition|(
name|candidate
operator|==
name|NULL
condition|)
block|{
name|candidate
operator|=
name|sav
expr_stmt|;
continue|continue;
block|}
comment|/* Which SA is the better ? */
comment|/* sanity check 2 */
if|if
condition|(
name|candidate
operator|->
name|lft_c
operator|==
name|NULL
operator|||
name|sav
operator|->
name|lft_c
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_do_allocsa_policy: "
literal|"lifetime_current is NULL.\n"
argument_list|)
expr_stmt|;
comment|/* What the best method is to compare ? */
if|if
condition|(
name|key_prefered_oldsa
condition|)
block|{
if|if
condition|(
name|candidate
operator|->
name|lft_c
operator|->
name|sadb_lifetime_addtime
operator|>
name|sav
operator|->
name|lft_c
operator|->
name|sadb_lifetime_addtime
condition|)
block|{
name|candidate
operator|=
name|sav
expr_stmt|;
block|}
continue|continue;
comment|/*NOTREACHED*/
block|}
comment|/* prefered new sa rather than old sa */
if|if
condition|(
name|candidate
operator|->
name|lft_c
operator|->
name|sadb_lifetime_addtime
operator|<
name|sav
operator|->
name|lft_c
operator|->
name|sadb_lifetime_addtime
condition|)
block|{
name|d
operator|=
name|candidate
expr_stmt|;
name|candidate
operator|=
name|sav
expr_stmt|;
block|}
else|else
name|d
operator|=
name|sav
expr_stmt|;
comment|/* 		 * prepared to delete the SA when there is more 		 * suitable candidate and the lifetime of the SA is not 		 * permanent. 		 */
if|if
condition|(
name|d
operator|->
name|lft_c
operator|->
name|sadb_lifetime_addtime
operator|!=
literal|0
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|result
decl_stmt|;
name|key_sa_chgstate
argument_list|(
name|d
argument_list|,
name|SADB_SASTATE_DEAD
argument_list|)
expr_stmt|;
name|key_freesav
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|m
operator|=
name|key_setsadbmsg
argument_list|(
name|SADB_DELETE
argument_list|,
literal|0
argument_list|,
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|proto
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|d
operator|->
name|refcnt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
return|return
name|NULL
return|;
name|result
operator|=
name|m
expr_stmt|;
comment|/* set sadb_address for saidx's. */
name|m
operator|=
name|key_setsadbaddr
argument_list|(
name|SADB_EXT_ADDRESS_SRC
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|d
operator|->
name|sah
operator|->
name|saidx
operator|.
name|src
argument_list|,
name|d
operator|->
name|sah
operator|->
name|saidx
operator|.
name|src
operator|.
name|ss_len
operator|<<
literal|3
argument_list|,
name|IPSEC_ULPROTO_ANY
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
return|return
name|NULL
return|;
name|m_cat
argument_list|(
name|result
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* set sadb_address for saidx's. */
name|m
operator|=
name|key_setsadbaddr
argument_list|(
name|SADB_EXT_ADDRESS_DST
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|d
operator|->
name|sah
operator|->
name|saidx
operator|.
name|src
argument_list|,
name|d
operator|->
name|sah
operator|->
name|saidx
operator|.
name|src
operator|.
name|ss_len
operator|<<
literal|3
argument_list|,
name|IPSEC_ULPROTO_ANY
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
return|return
name|NULL
return|;
name|m_cat
argument_list|(
name|result
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* create SA extension */
name|m
operator|=
name|key_setsadbsa
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
return|return
name|NULL
return|;
name|m_cat
argument_list|(
name|result
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
condition|)
block|{
name|result
operator|=
name|m_pullup
argument_list|(
name|result
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
block|}
name|result
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|m
operator|=
name|result
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
name|result
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|mtod
argument_list|(
name|result
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|)
operator|->
name|sadb_msg_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|result
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|key_sendup_mbuf
argument_list|(
name|NULL
argument_list|,
name|result
argument_list|,
name|KEY_SENDUP_REGISTERED
argument_list|)
condition|)
return|return
name|NULL
return|;
block|}
block|}
if|if
condition|(
name|candidate
condition|)
block|{
name|candidate
operator|->
name|refcnt
operator|++
expr_stmt|;
name|KEYDEBUG
argument_list|(
name|KEYDEBUG_IPSEC_STAMP
argument_list|,
name|printf
argument_list|(
literal|"DP allocsa_policy cause "
literal|"refcnt++:%d SA:%p\n"
argument_list|,
name|candidate
operator|->
name|refcnt
argument_list|,
name|candidate
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|candidate
return|;
block|}
end_function

begin_comment
comment|/*  * allocating a SA entry for a *INBOUND* packet.  * Must call key_freesav() later.  * OUT: positive:	pointer to a sav.  *	NULL:		not found, or error occured.  *  * In the comparison, source address will be ignored for RFC2401 conformance.  * To quote, from section 4.1:  *	A security association is uniquely identified by a triple consisting  *	of a Security Parameter Index (SPI), an IP Destination Address, and a  *	security protocol (AH or ESP) identifier.  * Note that, however, we do need to keep source address in IPsec SA.  * IKE specification and PF_KEY specification do assume that we  * keep source address in IPsec SA.  We see a tricky situation here.  */
end_comment

begin_function
name|struct
name|secasvar
modifier|*
name|key_allocsa
parameter_list|(
name|family
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|,
name|proto
parameter_list|,
name|spi
parameter_list|)
name|u_int
name|family
decl_stmt|,
name|proto
decl_stmt|;
name|caddr_t
name|src
decl_stmt|,
name|dst
decl_stmt|;
name|u_int32_t
name|spi
decl_stmt|;
block|{
name|struct
name|secashead
modifier|*
name|sah
decl_stmt|;
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|;
name|u_int
name|stateidx
decl_stmt|,
name|state
decl_stmt|;
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
name|struct
name|sockaddr_in6
name|sin6
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* sanity check */
if|if
condition|(
name|src
operator|==
name|NULL
operator|||
name|dst
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_allocsa: NULL pointer is passed.\n"
argument_list|)
expr_stmt|;
comment|/* 	 * searching SAD. 	 * XXX: to be checked internal IP header somewhere.  Also when 	 * IPsec tunnel packet is received.  But ESP tunnel mode is 	 * encrypted so we can't check internal IP header. 	 */
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
comment|/*called from softclock()*/
name|LIST_FOREACH
argument_list|(
argument|sah
argument_list|,
argument|&sahtree
argument_list|,
argument|chain
argument_list|)
block|{
comment|/* search valid state */
for|for
control|(
name|stateidx
operator|=
literal|0
init|;
name|stateidx
operator|<
name|_ARRAYLEN
argument_list|(
name|saorder_state_valid
argument_list|)
condition|;
name|stateidx
operator|++
control|)
block|{
name|state
operator|=
name|saorder_state_valid
index|[
name|stateidx
index|]
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|sav
argument_list|,
argument|&sah->savtree[state]
argument_list|,
argument|chain
argument_list|)
block|{
comment|/* sanity check */
name|KEY_CHKSASTATE
argument_list|(
name|sav
operator|->
name|state
argument_list|,
name|state
argument_list|,
literal|"key_allocsav"
argument_list|)
expr_stmt|;
if|if
condition|(
name|proto
operator|!=
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|proto
condition|)
continue|continue;
if|if
condition|(
name|spi
operator|!=
name|sav
operator|->
name|spi
condition|)
continue|continue;
if|if
condition|(
name|family
operator|!=
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|src
operator|.
name|ss_family
operator|||
name|family
operator|!=
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|dst
operator|.
name|ss_family
condition|)
continue|continue;
if|#
directive|if
literal|0
comment|/* don't check src */
comment|/* check src address */
block|switch (family) { 				case AF_INET: 					bzero(&sin, sizeof(sin)); 					sin.sin_family = AF_INET; 					sin.sin_len = sizeof(sin); 					bcopy(src,&sin.sin_addr, 					    sizeof(sin.sin_addr)); 					if (key_sockaddrcmp((struct sockaddr*)&sin, 					    (struct sockaddr *)&sav->sah->saidx.src, 0) != 0) 						continue;  					break; 				case AF_INET6: 					bzero(&sin6, sizeof(sin6)); 					sin6.sin6_family = AF_INET6; 					sin6.sin6_len = sizeof(sin6); 					bcopy(src,&sin6.sin6_addr, 					    sizeof(sin6.sin6_addr)); 					if (IN6_IS_SCOPE_LINKLOCAL(&sin6.sin6_addr)) {
comment|/* kame fake scopeid */
block|sin6.sin6_scope_id = 						    ntohs(sin6.sin6_addr.s6_addr16[1]); 						sin6.sin6_addr.s6_addr16[1] = 0; 					} 					if (key_sockaddrcmp((struct sockaddr*)&sin6, 					    (struct sockaddr *)&sav->sah->saidx.src, 0) != 0) 						continue; 					break; 				default: 					ipseclog((LOG_DEBUG, "key_allocsa: " 					    "unknown address family=%d.\n", 					    family)); 					continue; 				}
endif|#
directive|endif
comment|/* check dst address */
switch|switch
condition|(
name|family
condition|)
block|{
case|case
name|AF_INET
case|:
name|bzero
argument_list|(
operator|&
name|sin
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
argument_list|)
expr_stmt|;
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|dst
argument_list|,
operator|&
name|sin
operator|.
name|sin_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|key_sockaddrcmp
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|dst
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
break|break;
case|case
name|AF_INET6
case|:
name|bzero
argument_list|(
operator|&
name|sin6
argument_list|,
sizeof|sizeof
argument_list|(
name|sin6
argument_list|)
argument_list|)
expr_stmt|;
name|sin6
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|sin6
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
name|sin6
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|dst
argument_list|,
operator|&
name|sin6
operator|.
name|sin6_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|sin6
operator|.
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN6_IS_SCOPE_LINKLOCAL
argument_list|(
operator|&
name|sin6
operator|.
name|sin6_addr
argument_list|)
condition|)
block|{
comment|/* kame fake scopeid */
name|sin6
operator|.
name|sin6_scope_id
operator|=
name|ntohs
argument_list|(
name|sin6
operator|.
name|sin6_addr
operator|.
name|s6_addr16
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|sin6
operator|.
name|sin6_addr
operator|.
name|s6_addr16
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|key_sockaddrcmp
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin6
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|dst
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
break|break;
default|default:
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_allocsa: "
literal|"unknown address family=%d.\n"
operator|,
name|family
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
goto|goto
name|found
goto|;
block|}
block|}
block|}
comment|/* not found */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
name|found
label|:
name|sav
operator|->
name|refcnt
operator|++
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|KEYDEBUG
argument_list|(
name|KEYDEBUG_IPSEC_STAMP
argument_list|,
name|printf
argument_list|(
literal|"DP allocsa cause refcnt++:%d SA:%p\n"
argument_list|,
name|sav
operator|->
name|refcnt
argument_list|,
name|sav
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|sav
return|;
block|}
end_function

begin_comment
comment|/*  * Must be called after calling key_allocsp().  * For both the packet without socket and key_freeso().  */
end_comment

begin_function
name|void
name|key_freesp
parameter_list|(
name|sp
parameter_list|)
name|struct
name|secpolicy
modifier|*
name|sp
decl_stmt|;
block|{
comment|/* sanity check */
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_freesp: NULL pointer is passed.\n"
argument_list|)
expr_stmt|;
name|sp
operator|->
name|refcnt
operator|--
expr_stmt|;
name|KEYDEBUG
argument_list|(
name|KEYDEBUG_IPSEC_STAMP
argument_list|,
name|printf
argument_list|(
literal|"DP freesp cause refcnt--:%d SP:%p\n"
argument_list|,
name|sp
operator|->
name|refcnt
argument_list|,
name|sp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|refcnt
operator|==
literal|0
condition|)
name|key_delsp
argument_list|(
name|sp
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Must be called after calling key_allocsp().  * For the packet with socket.  */
end_comment

begin_function
name|void
name|key_freeso
parameter_list|(
name|so
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
block|{
comment|/* sanity check */
if|if
condition|(
name|so
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_freeso: NULL pointer is passed.\n"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|so
operator|->
name|so_proto
operator|->
name|pr_domain
operator|->
name|dom_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|PF_INET
case|:
block|{
name|struct
name|inpcb
modifier|*
name|pcb
init|=
name|sotoinpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
comment|/* Does it have a PCB ? */
if|if
condition|(
name|pcb
operator|==
name|NULL
condition|)
return|return;
name|key_freesp_so
argument_list|(
operator|&
name|pcb
operator|->
name|inp_sp
operator|->
name|sp_in
argument_list|)
expr_stmt|;
name|key_freesp_so
argument_list|(
operator|&
name|pcb
operator|->
name|inp_sp
operator|->
name|sp_out
argument_list|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|PF_INET6
case|:
block|{
ifdef|#
directive|ifdef
name|HAVE_NRL_INPCB
name|struct
name|inpcb
modifier|*
name|pcb
init|=
name|sotoinpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
comment|/* Does it have a PCB ? */
if|if
condition|(
name|pcb
operator|==
name|NULL
condition|)
return|return;
name|key_freesp_so
argument_list|(
operator|&
name|pcb
operator|->
name|inp_sp
operator|->
name|sp_in
argument_list|)
expr_stmt|;
name|key_freesp_so
argument_list|(
operator|&
name|pcb
operator|->
name|inp_sp
operator|->
name|sp_out
argument_list|)
expr_stmt|;
else|#
directive|else
name|struct
name|in6pcb
modifier|*
name|pcb
init|=
name|sotoin6pcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
comment|/* Does it have a PCB ? */
if|if
condition|(
name|pcb
operator|==
name|NULL
condition|)
return|return;
name|key_freesp_so
argument_list|(
operator|&
name|pcb
operator|->
name|in6p_sp
operator|->
name|sp_in
argument_list|)
expr_stmt|;
name|key_freesp_so
argument_list|(
operator|&
name|pcb
operator|->
name|in6p_sp
operator|->
name|sp_out
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
break|break;
endif|#
directive|endif
comment|/* INET6 */
default|default:
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_freeso: unknown address family=%d.\n"
operator|,
name|so
operator|->
name|so_proto
operator|->
name|pr_domain
operator|->
name|dom_family
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|key_freesp_so
parameter_list|(
name|sp
parameter_list|)
name|struct
name|secpolicy
modifier|*
modifier|*
name|sp
decl_stmt|;
block|{
comment|/* sanity check */
if|if
condition|(
name|sp
operator|==
name|NULL
operator|||
operator|*
name|sp
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_freesp_so: sp == NULL\n"
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
operator|*
name|sp
operator|)
operator|->
name|policy
condition|)
block|{
case|case
name|IPSEC_POLICY_IPSEC
case|:
name|KEYDEBUG
argument_list|(
name|KEYDEBUG_IPSEC_STAMP
argument_list|,
name|printf
argument_list|(
literal|"DP freeso calls free SP:%p\n"
argument_list|,
operator|*
name|sp
argument_list|)
argument_list|)
expr_stmt|;
name|key_freesp
argument_list|(
operator|*
name|sp
argument_list|)
expr_stmt|;
operator|*
name|sp
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|IPSEC_POLICY_ENTRUST
case|:
case|case
name|IPSEC_POLICY_BYPASS
case|:
return|return;
default|default:
name|panic
argument_list|(
literal|"key_freesp_so: Invalid policy found %d"
argument_list|,
operator|(
operator|*
name|sp
operator|)
operator|->
name|policy
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * Must be called after calling key_allocsa().  * This function is called by key_freesp() to free some SA allocated  * for a policy.  */
end_comment

begin_function
name|void
name|key_freesav
parameter_list|(
name|sav
parameter_list|)
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|;
block|{
comment|/* sanity check */
if|if
condition|(
name|sav
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_freesav: NULL pointer is passed.\n"
argument_list|)
expr_stmt|;
name|sav
operator|->
name|refcnt
operator|--
expr_stmt|;
name|KEYDEBUG
argument_list|(
name|KEYDEBUG_IPSEC_STAMP
argument_list|,
name|printf
argument_list|(
literal|"DP freesav cause refcnt--:%d SA:%p SPI %u\n"
argument_list|,
name|sav
operator|->
name|refcnt
argument_list|,
name|sav
argument_list|,
operator|(
name|u_int32_t
operator|)
name|ntohl
argument_list|(
name|sav
operator|->
name|spi
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|refcnt
operator|==
literal|0
condition|)
name|key_delsav
argument_list|(
name|sav
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* %%% SPD management */
end_comment

begin_comment
comment|/*  * free security policy entry.  */
end_comment

begin_function
specifier|static
name|void
name|key_delsp
parameter_list|(
name|sp
parameter_list|)
name|struct
name|secpolicy
modifier|*
name|sp
decl_stmt|;
block|{
name|int
name|s
decl_stmt|;
comment|/* sanity check */
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_delsp: NULL pointer is passed.\n"
argument_list|)
expr_stmt|;
name|sp
operator|->
name|state
operator|=
name|IPSEC_SPSTATE_DEAD
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|refcnt
operator|>
literal|0
condition|)
return|return;
comment|/* can't free */
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
comment|/*called from softclock()*/
comment|/* remove from SP index */
if|if
condition|(
name|__LIST_CHAINED
argument_list|(
name|sp
argument_list|)
condition|)
name|LIST_REMOVE
argument_list|(
name|sp
argument_list|,
name|chain
argument_list|)
expr_stmt|;
block|{
name|struct
name|ipsecrequest
modifier|*
name|isr
init|=
name|sp
operator|->
name|req
decl_stmt|,
modifier|*
name|nextisr
decl_stmt|;
while|while
condition|(
name|isr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|isr
operator|->
name|sav
operator|!=
name|NULL
condition|)
block|{
name|KEYDEBUG
argument_list|(
name|KEYDEBUG_IPSEC_STAMP
argument_list|,
name|printf
argument_list|(
literal|"DP delsp calls free SA:%p\n"
argument_list|,
name|isr
operator|->
name|sav
argument_list|)
argument_list|)
expr_stmt|;
name|key_freesav
argument_list|(
name|isr
operator|->
name|sav
argument_list|)
expr_stmt|;
name|isr
operator|->
name|sav
operator|=
name|NULL
expr_stmt|;
block|}
name|nextisr
operator|=
name|isr
operator|->
name|next
expr_stmt|;
name|KFREE
argument_list|(
name|isr
argument_list|)
expr_stmt|;
name|isr
operator|=
name|nextisr
expr_stmt|;
block|}
block|}
name|keydb_delsecpolicy
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * search SPD  * OUT:	NULL	: not found  *	others	: found, pointer to a SP.  */
end_comment

begin_function
specifier|static
name|struct
name|secpolicy
modifier|*
name|key_getsp
parameter_list|(
name|spidx
parameter_list|)
name|struct
name|secpolicyindex
modifier|*
name|spidx
decl_stmt|;
block|{
name|struct
name|secpolicy
modifier|*
name|sp
decl_stmt|;
comment|/* sanity check */
if|if
condition|(
name|spidx
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_getsp: NULL pointer is passed.\n"
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|sp
argument_list|,
argument|&sptree[spidx->dir]
argument_list|,
argument|chain
argument_list|)
block|{
if|if
condition|(
name|sp
operator|->
name|state
operator|==
name|IPSEC_SPSTATE_DEAD
condition|)
continue|continue;
if|if
condition|(
name|key_cmpspidx_exactly
argument_list|(
name|spidx
argument_list|,
operator|&
name|sp
operator|->
name|spidx
argument_list|)
condition|)
block|{
name|sp
operator|->
name|refcnt
operator|++
expr_stmt|;
return|return
name|sp
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * get SP by index.  * OUT:	NULL	: not found  *	others	: found, pointer to a SP.  */
end_comment

begin_function
specifier|static
name|struct
name|secpolicy
modifier|*
name|key_getspbyid
parameter_list|(
name|id
parameter_list|)
name|u_int32_t
name|id
decl_stmt|;
block|{
name|struct
name|secpolicy
modifier|*
name|sp
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|sp
argument_list|,
argument|&sptree[IPSEC_DIR_INBOUND]
argument_list|,
argument|chain
argument_list|)
block|{
if|if
condition|(
name|sp
operator|->
name|state
operator|==
name|IPSEC_SPSTATE_DEAD
condition|)
continue|continue;
if|if
condition|(
name|sp
operator|->
name|id
operator|==
name|id
condition|)
block|{
name|sp
operator|->
name|refcnt
operator|++
expr_stmt|;
return|return
name|sp
return|;
block|}
block|}
name|LIST_FOREACH
argument_list|(
argument|sp
argument_list|,
argument|&sptree[IPSEC_DIR_OUTBOUND]
argument_list|,
argument|chain
argument_list|)
block|{
if|if
condition|(
name|sp
operator|->
name|state
operator|==
name|IPSEC_SPSTATE_DEAD
condition|)
continue|continue;
if|if
condition|(
name|sp
operator|->
name|id
operator|==
name|id
condition|)
block|{
name|sp
operator|->
name|refcnt
operator|++
expr_stmt|;
return|return
name|sp
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|struct
name|secpolicy
modifier|*
name|key_newsp
parameter_list|()
block|{
name|struct
name|secpolicy
modifier|*
name|newsp
init|=
name|NULL
decl_stmt|;
name|newsp
operator|=
name|keydb_newsecpolicy
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|newsp
condition|)
return|return
name|newsp
return|;
name|newsp
operator|->
name|refcnt
operator|=
literal|1
expr_stmt|;
name|newsp
operator|->
name|req
operator|=
name|NULL
expr_stmt|;
return|return
name|newsp
return|;
block|}
end_function

begin_comment
comment|/*  * create secpolicy structure from sadb_x_policy structure.  * NOTE: `state', `secpolicyindex' in secpolicy structure are not set,  * so must be set properly later.  */
end_comment

begin_function
name|struct
name|secpolicy
modifier|*
name|key_msg2sp
parameter_list|(
name|xpl0
parameter_list|,
name|len
parameter_list|,
name|error
parameter_list|)
name|struct
name|sadb_x_policy
modifier|*
name|xpl0
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
modifier|*
name|error
decl_stmt|;
block|{
name|struct
name|secpolicy
modifier|*
name|newsp
decl_stmt|;
comment|/* sanity check */
if|if
condition|(
name|xpl0
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_msg2sp: NULL pointer was passed.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|xpl0
argument_list|)
condition|)
name|panic
argument_list|(
literal|"key_msg2sp: invalid length.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
name|PFKEY_EXTLEN
argument_list|(
name|xpl0
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_msg2sp: Invalid msg length.\n"
operator|)
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|(
name|newsp
operator|=
name|key_newsp
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
operator|*
name|error
operator|=
name|ENOBUFS
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|newsp
operator|->
name|spidx
operator|.
name|dir
operator|=
name|xpl0
operator|->
name|sadb_x_policy_dir
expr_stmt|;
name|newsp
operator|->
name|policy
operator|=
name|xpl0
operator|->
name|sadb_x_policy_type
expr_stmt|;
comment|/* check policy */
switch|switch
condition|(
name|xpl0
operator|->
name|sadb_x_policy_type
condition|)
block|{
case|case
name|IPSEC_POLICY_DISCARD
case|:
case|case
name|IPSEC_POLICY_NONE
case|:
case|case
name|IPSEC_POLICY_ENTRUST
case|:
case|case
name|IPSEC_POLICY_BYPASS
case|:
name|newsp
operator|->
name|req
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|IPSEC_POLICY_IPSEC
case|:
block|{
name|int
name|tlen
decl_stmt|;
name|struct
name|sadb_x_ipsecrequest
modifier|*
name|xisr
decl_stmt|;
name|struct
name|ipsecrequest
modifier|*
modifier|*
name|p_isr
init|=
operator|&
name|newsp
operator|->
name|req
decl_stmt|;
comment|/* validity check */
if|if
condition|(
name|PFKEY_EXTLEN
argument_list|(
name|xpl0
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|xpl0
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_msg2sp: Invalid msg length.\n"
operator|)
argument_list|)
expr_stmt|;
name|key_freesp
argument_list|(
name|newsp
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|tlen
operator|=
name|PFKEY_EXTLEN
argument_list|(
name|xpl0
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|xpl0
argument_list|)
expr_stmt|;
name|xisr
operator|=
operator|(
expr|struct
name|sadb_x_ipsecrequest
operator|*
operator|)
operator|(
name|xpl0
operator|+
literal|1
operator|)
expr_stmt|;
while|while
condition|(
name|tlen
operator|>
literal|0
condition|)
block|{
comment|/* length check */
if|if
condition|(
name|xisr
operator|->
name|sadb_x_ipsecrequest_len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|xisr
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_msg2sp: "
literal|"invalid ipsecrequest length.\n"
operator|)
argument_list|)
expr_stmt|;
name|key_freesp
argument_list|(
name|newsp
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* allocate request buffer */
name|KMALLOC
argument_list|(
operator|*
name|p_isr
argument_list|,
expr|struct
name|ipsecrequest
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|p_isr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|p_isr
operator|)
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_msg2sp: No more memory.\n"
operator|)
argument_list|)
expr_stmt|;
name|key_freesp
argument_list|(
name|newsp
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|ENOBUFS
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|bzero
argument_list|(
operator|*
name|p_isr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|p_isr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set values */
operator|(
operator|*
name|p_isr
operator|)
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|xisr
operator|->
name|sadb_x_ipsecrequest_proto
condition|)
block|{
case|case
name|IPPROTO_ESP
case|:
case|case
name|IPPROTO_AH
case|:
case|case
name|IPPROTO_IPCOMP
case|:
break|break;
default|default:
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_msg2sp: invalid proto type=%u\n"
operator|,
name|xisr
operator|->
name|sadb_x_ipsecrequest_proto
operator|)
argument_list|)
expr_stmt|;
name|key_freesp
argument_list|(
name|newsp
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EPROTONOSUPPORT
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|(
operator|*
name|p_isr
operator|)
operator|->
name|saidx
operator|.
name|proto
operator|=
name|xisr
operator|->
name|sadb_x_ipsecrequest_proto
expr_stmt|;
switch|switch
condition|(
name|xisr
operator|->
name|sadb_x_ipsecrequest_mode
condition|)
block|{
case|case
name|IPSEC_MODE_TRANSPORT
case|:
case|case
name|IPSEC_MODE_TUNNEL
case|:
break|break;
case|case
name|IPSEC_MODE_ANY
case|:
default|default:
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_msg2sp: invalid mode=%u\n"
operator|,
name|xisr
operator|->
name|sadb_x_ipsecrequest_mode
operator|)
argument_list|)
expr_stmt|;
name|key_freesp
argument_list|(
name|newsp
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|(
operator|*
name|p_isr
operator|)
operator|->
name|saidx
operator|.
name|mode
operator|=
name|xisr
operator|->
name|sadb_x_ipsecrequest_mode
expr_stmt|;
switch|switch
condition|(
name|xisr
operator|->
name|sadb_x_ipsecrequest_level
condition|)
block|{
case|case
name|IPSEC_LEVEL_DEFAULT
case|:
case|case
name|IPSEC_LEVEL_USE
case|:
case|case
name|IPSEC_LEVEL_REQUIRE
case|:
break|break;
case|case
name|IPSEC_LEVEL_UNIQUE
case|:
comment|/* validity check */
comment|/* 				 * If range violation of reqid, kernel will 				 * update it, don't refuse it. 				 */
if|if
condition|(
name|xisr
operator|->
name|sadb_x_ipsecrequest_reqid
operator|>
name|IPSEC_MANUAL_REQID_MAX
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_msg2sp: reqid=%d range "
literal|"violation, updated by kernel.\n"
operator|,
name|xisr
operator|->
name|sadb_x_ipsecrequest_reqid
operator|)
argument_list|)
expr_stmt|;
name|xisr
operator|->
name|sadb_x_ipsecrequest_reqid
operator|=
literal|0
expr_stmt|;
block|}
comment|/* allocate new reqid id if reqid is zero. */
if|if
condition|(
name|xisr
operator|->
name|sadb_x_ipsecrequest_reqid
operator|==
literal|0
condition|)
block|{
name|u_int32_t
name|reqid
decl_stmt|;
if|if
condition|(
operator|(
name|reqid
operator|=
name|key_newreqid
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
name|key_freesp
argument_list|(
name|newsp
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|ENOBUFS
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|(
operator|*
name|p_isr
operator|)
operator|->
name|saidx
operator|.
name|reqid
operator|=
name|reqid
expr_stmt|;
name|xisr
operator|->
name|sadb_x_ipsecrequest_reqid
operator|=
name|reqid
expr_stmt|;
block|}
else|else
block|{
comment|/* set it for manual keying. */
operator|(
operator|*
name|p_isr
operator|)
operator|->
name|saidx
operator|.
name|reqid
operator|=
name|xisr
operator|->
name|sadb_x_ipsecrequest_reqid
expr_stmt|;
block|}
break|break;
default|default:
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_msg2sp: invalid level=%u\n"
operator|,
name|xisr
operator|->
name|sadb_x_ipsecrequest_level
operator|)
argument_list|)
expr_stmt|;
name|key_freesp
argument_list|(
name|newsp
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|(
operator|*
name|p_isr
operator|)
operator|->
name|level
operator|=
name|xisr
operator|->
name|sadb_x_ipsecrequest_level
expr_stmt|;
comment|/* set IP addresses if there */
if|if
condition|(
name|xisr
operator|->
name|sadb_x_ipsecrequest_len
operator|>
sizeof|sizeof
argument_list|(
operator|*
name|xisr
argument_list|)
condition|)
block|{
name|struct
name|sockaddr
modifier|*
name|paddr
decl_stmt|;
name|paddr
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
name|xisr
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* validity check */
if|if
condition|(
name|paddr
operator|->
name|sa_len
operator|>
sizeof|sizeof
argument_list|(
operator|(
operator|*
name|p_isr
operator|)
operator|->
name|saidx
operator|.
name|src
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_msg2sp: invalid request "
literal|"address length.\n"
operator|)
argument_list|)
expr_stmt|;
name|key_freesp
argument_list|(
name|newsp
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|bcopy
argument_list|(
name|paddr
argument_list|,
operator|&
operator|(
operator|*
name|p_isr
operator|)
operator|->
name|saidx
operator|.
name|src
argument_list|,
name|paddr
operator|->
name|sa_len
argument_list|)
expr_stmt|;
name|paddr
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|paddr
operator|+
name|paddr
operator|->
name|sa_len
operator|)
expr_stmt|;
comment|/* validity check */
if|if
condition|(
name|paddr
operator|->
name|sa_len
operator|>
sizeof|sizeof
argument_list|(
operator|(
operator|*
name|p_isr
operator|)
operator|->
name|saidx
operator|.
name|dst
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_msg2sp: invalid request "
literal|"address length.\n"
operator|)
argument_list|)
expr_stmt|;
name|key_freesp
argument_list|(
name|newsp
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|bcopy
argument_list|(
name|paddr
argument_list|,
operator|&
operator|(
operator|*
name|p_isr
operator|)
operator|->
name|saidx
operator|.
name|dst
argument_list|,
name|paddr
operator|->
name|sa_len
argument_list|)
expr_stmt|;
block|}
operator|(
operator|*
name|p_isr
operator|)
operator|->
name|sav
operator|=
name|NULL
expr_stmt|;
operator|(
operator|*
name|p_isr
operator|)
operator|->
name|sp
operator|=
name|newsp
expr_stmt|;
comment|/* initialization for the next. */
name|p_isr
operator|=
operator|&
operator|(
operator|*
name|p_isr
operator|)
operator|->
name|next
expr_stmt|;
name|tlen
operator|-=
name|xisr
operator|->
name|sadb_x_ipsecrequest_len
expr_stmt|;
comment|/* validity check */
if|if
condition|(
name|tlen
operator|<
literal|0
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_msg2sp: becoming tlen< 0.\n"
operator|)
argument_list|)
expr_stmt|;
name|key_freesp
argument_list|(
name|newsp
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|xisr
operator|=
operator|(
expr|struct
name|sadb_x_ipsecrequest
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|xisr
operator|+
name|xisr
operator|->
name|sadb_x_ipsecrequest_len
operator|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_msg2sp: invalid policy type.\n"
operator|)
argument_list|)
expr_stmt|;
name|key_freesp
argument_list|(
name|newsp
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|*
name|error
operator|=
literal|0
expr_stmt|;
return|return
name|newsp
return|;
block|}
end_function

begin_function
specifier|static
name|u_int32_t
name|key_newreqid
parameter_list|()
block|{
specifier|static
name|u_int32_t
name|auto_reqid
init|=
name|IPSEC_MANUAL_REQID_MAX
operator|+
literal|1
decl_stmt|;
name|auto_reqid
operator|=
operator|(
name|auto_reqid
operator|==
operator|~
literal|0
condition|?
name|IPSEC_MANUAL_REQID_MAX
operator|+
literal|1
else|:
name|auto_reqid
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* XXX should be unique check */
return|return
name|auto_reqid
return|;
block|}
end_function

begin_comment
comment|/*  * copy secpolicy struct to sadb_x_policy structure indicated.  */
end_comment

begin_function
name|struct
name|mbuf
modifier|*
name|key_sp2msg
parameter_list|(
name|sp
parameter_list|)
name|struct
name|secpolicy
modifier|*
name|sp
decl_stmt|;
block|{
name|struct
name|sadb_x_policy
modifier|*
name|xpl
decl_stmt|;
name|int
name|tlen
decl_stmt|;
name|caddr_t
name|p
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
comment|/* sanity check. */
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_sp2msg: NULL pointer was passed.\n"
argument_list|)
expr_stmt|;
name|tlen
operator|=
name|key_getspreqmsglen
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|m
operator|=
name|key_alloc_mbuf
argument_list|(
name|tlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
operator|||
name|m
operator|->
name|m_next
condition|)
block|{
comment|/*XXX*/
if|if
condition|(
name|m
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|m
operator|->
name|m_len
operator|=
name|tlen
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
name|xpl
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sadb_x_policy
operator|*
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|xpl
argument_list|,
name|tlen
argument_list|)
expr_stmt|;
name|xpl
operator|->
name|sadb_x_policy_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|tlen
argument_list|)
expr_stmt|;
name|xpl
operator|->
name|sadb_x_policy_exttype
operator|=
name|SADB_X_EXT_POLICY
expr_stmt|;
name|xpl
operator|->
name|sadb_x_policy_type
operator|=
name|sp
operator|->
name|policy
expr_stmt|;
name|xpl
operator|->
name|sadb_x_policy_dir
operator|=
name|sp
operator|->
name|spidx
operator|.
name|dir
expr_stmt|;
name|xpl
operator|->
name|sadb_x_policy_id
operator|=
name|sp
operator|->
name|id
expr_stmt|;
name|p
operator|=
operator|(
name|caddr_t
operator|)
name|xpl
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|xpl
argument_list|)
expr_stmt|;
comment|/* if is the policy for ipsec ? */
if|if
condition|(
name|sp
operator|->
name|policy
operator|==
name|IPSEC_POLICY_IPSEC
condition|)
block|{
name|struct
name|sadb_x_ipsecrequest
modifier|*
name|xisr
decl_stmt|;
name|struct
name|ipsecrequest
modifier|*
name|isr
decl_stmt|;
for|for
control|(
name|isr
operator|=
name|sp
operator|->
name|req
init|;
name|isr
operator|!=
name|NULL
condition|;
name|isr
operator|=
name|isr
operator|->
name|next
control|)
block|{
name|xisr
operator|=
operator|(
expr|struct
name|sadb_x_ipsecrequest
operator|*
operator|)
name|p
expr_stmt|;
name|xisr
operator|->
name|sadb_x_ipsecrequest_proto
operator|=
name|isr
operator|->
name|saidx
operator|.
name|proto
expr_stmt|;
name|xisr
operator|->
name|sadb_x_ipsecrequest_mode
operator|=
name|isr
operator|->
name|saidx
operator|.
name|mode
expr_stmt|;
name|xisr
operator|->
name|sadb_x_ipsecrequest_level
operator|=
name|isr
operator|->
name|level
expr_stmt|;
name|xisr
operator|->
name|sadb_x_ipsecrequest_reqid
operator|=
name|isr
operator|->
name|saidx
operator|.
name|reqid
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|xisr
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|isr
operator|->
name|saidx
operator|.
name|src
argument_list|,
name|p
argument_list|,
name|isr
operator|->
name|saidx
operator|.
name|src
operator|.
name|ss_len
argument_list|)
expr_stmt|;
name|p
operator|+=
name|isr
operator|->
name|saidx
operator|.
name|src
operator|.
name|ss_len
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|isr
operator|->
name|saidx
operator|.
name|dst
argument_list|,
name|p
argument_list|,
name|isr
operator|->
name|saidx
operator|.
name|dst
operator|.
name|ss_len
argument_list|)
expr_stmt|;
name|p
operator|+=
name|isr
operator|->
name|saidx
operator|.
name|src
operator|.
name|ss_len
expr_stmt|;
name|xisr
operator|->
name|sadb_x_ipsecrequest_len
operator|=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|xisr
argument_list|)
operator|+
name|isr
operator|->
name|saidx
operator|.
name|src
operator|.
name|ss_len
operator|+
name|isr
operator|->
name|saidx
operator|.
name|dst
operator|.
name|ss_len
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/* m will not be freed nor modified */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
ifdef|#
directive|ifdef
name|__STDC__
name|key_gather_mbuf
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
specifier|const
name|struct
name|sadb_msghdr
modifier|*
name|mhp
parameter_list|,
name|int
name|ndeep
parameter_list|,
name|int
name|nitem
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
function|key_gather_mbuf
parameter_list|(
name|m
parameter_list|,
name|mhp
parameter_list|,
name|ndeep
parameter_list|,
name|nitem
parameter_list|,
name|va_alist
parameter_list|)
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|const
name|struct
name|sadb_msghdr
modifier|*
name|mhp
decl_stmt|;
name|int
name|ndeep
decl_stmt|;
name|int
name|nitem
decl_stmt|;
function|va_dcl
endif|#
directive|endif
block|{
name|va_list
name|ap
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|result
init|=
name|NULL
decl_stmt|,
modifier|*
name|n
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
operator|||
name|mhp
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"null pointer passed to key_gather"
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|nitem
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitem
condition|;
name|i
operator|++
control|)
block|{
name|idx
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|<
literal|0
operator|||
name|idx
operator|>
name|SADB_EXT_MAX
condition|)
goto|goto
name|fail
goto|;
comment|/* don't attempt to pull empty extension */
if|if
condition|(
name|idx
operator|==
name|SADB_EXT_RESERVED
operator|&&
name|mhp
operator|->
name|msg
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|idx
operator|!=
name|SADB_EXT_RESERVED
operator|&&
operator|(
name|mhp
operator|->
name|ext
index|[
name|idx
index|]
operator|==
name|NULL
operator|||
name|mhp
operator|->
name|extlen
index|[
name|idx
index|]
operator|==
literal|0
operator|)
condition|)
continue|continue;
if|if
condition|(
name|idx
operator|==
name|SADB_EXT_RESERVED
condition|)
block|{
name|len
operator|=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|len
operator|>
name|MHLEN
condition|)
name|panic
argument_list|(
literal|"assumption failed"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|MGETHDR
argument_list|(
name|n
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
goto|goto
name|fail
goto|;
name|n
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
name|n
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
name|m_copydata
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|,
name|mtod
argument_list|(
name|n
argument_list|,
name|caddr_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|<
name|ndeep
condition|)
block|{
name|len
operator|=
name|mhp
operator|->
name|extlen
index|[
name|idx
index|]
expr_stmt|;
name|n
operator|=
name|key_alloc_mbuf
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
operator|||
name|n
operator|->
name|m_next
condition|)
block|{
comment|/*XXX*/
if|if
condition|(
name|n
condition|)
name|m_freem
argument_list|(
name|n
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|m_copydata
argument_list|(
name|m
argument_list|,
name|mhp
operator|->
name|extoff
index|[
name|idx
index|]
argument_list|,
name|mhp
operator|->
name|extlen
index|[
name|idx
index|]
argument_list|,
name|mtod
argument_list|(
name|n
argument_list|,
name|caddr_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|n
operator|=
name|m_copym
argument_list|(
name|m
argument_list|,
name|mhp
operator|->
name|extoff
index|[
name|idx
index|]
argument_list|,
name|mhp
operator|->
name|extlen
index|[
name|idx
index|]
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|result
condition|)
name|m_cat
argument_list|(
name|result
argument_list|,
name|n
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
name|n
expr_stmt|;
block|}
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|result
operator|->
name|m_flags
operator|&
name|M_PKTHDR
operator|)
operator|!=
literal|0
condition|)
block|{
name|result
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
name|result
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|m_next
control|)
name|result
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|n
operator|->
name|m_len
expr_stmt|;
block|}
return|return
name|result
return|;
name|fail
label|:
name|m_freem
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * SADB_X_SPDADD, SADB_X_SPDSETIDX or SADB_X_SPDUPDATE processing  * add a entry to SP database, when received  *<base, address(SD), (lifetime(H),) policy>  * from the user(?).  * Adding to SP database,  * and send  *<base, address(SD), (lifetime(H),) policy>  * to the socket which was send.  *  * SPDADD set a unique policy entry.  * SPDSETIDX like SPDADD without a part of policy requests.  * SPDUPDATE replace a unique policy entry.  *  * m will always be freed.  */
end_comment

begin_function
specifier|static
name|int
name|key_spdadd
parameter_list|(
name|so
parameter_list|,
name|m
parameter_list|,
name|mhp
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|const
name|struct
name|sadb_msghdr
modifier|*
name|mhp
decl_stmt|;
block|{
name|struct
name|sadb_address
modifier|*
name|src0
decl_stmt|,
modifier|*
name|dst0
decl_stmt|;
name|struct
name|sadb_x_policy
modifier|*
name|xpl0
decl_stmt|,
modifier|*
name|xpl
decl_stmt|;
name|struct
name|sadb_lifetime
modifier|*
name|lft
init|=
name|NULL
decl_stmt|;
name|struct
name|secpolicyindex
name|spidx
decl_stmt|;
name|struct
name|secpolicy
modifier|*
name|newsp
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* sanity check */
if|if
condition|(
name|so
operator|==
name|NULL
operator|||
name|m
operator|==
name|NULL
operator|||
name|mhp
operator|==
name|NULL
operator|||
name|mhp
operator|->
name|msg
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_spdadd: NULL pointer is passed.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
operator|==
name|NULL
operator|||
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_DST
index|]
operator|==
name|NULL
operator|||
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_POLICY
index|]
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_spdadd: invalid message is passed.\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|mhp
operator|->
name|extlen
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_address
argument_list|)
operator|||
name|mhp
operator|->
name|extlen
index|[
name|SADB_EXT_ADDRESS_DST
index|]
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_address
argument_list|)
operator|||
name|mhp
operator|->
name|extlen
index|[
name|SADB_X_EXT_POLICY
index|]
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_x_policy
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_spdadd: invalid message is passed.\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_LIFETIME_HARD
index|]
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|mhp
operator|->
name|extlen
index|[
name|SADB_EXT_LIFETIME_HARD
index|]
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_lifetime
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_spdadd: invalid message is passed.\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
name|lft
operator|=
operator|(
expr|struct
name|sadb_lifetime
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_LIFETIME_HARD
index|]
expr_stmt|;
block|}
name|src0
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
expr_stmt|;
name|dst0
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_DST
index|]
expr_stmt|;
name|xpl0
operator|=
operator|(
expr|struct
name|sadb_x_policy
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_POLICY
index|]
expr_stmt|;
comment|/* make secindex */
comment|/* XXX boundary check against sa_len */
name|KEY_SETSECSPIDX
argument_list|(
name|xpl0
operator|->
name|sadb_x_policy_dir
argument_list|,
name|src0
operator|+
literal|1
argument_list|,
name|dst0
operator|+
literal|1
argument_list|,
name|src0
operator|->
name|sadb_address_prefixlen
argument_list|,
name|dst0
operator|->
name|sadb_address_prefixlen
argument_list|,
name|src0
operator|->
name|sadb_address_proto
argument_list|,
operator|&
name|spidx
argument_list|)
expr_stmt|;
comment|/* checking the direciton. */
switch|switch
condition|(
name|xpl0
operator|->
name|sadb_x_policy_dir
condition|)
block|{
case|case
name|IPSEC_DIR_INBOUND
case|:
case|case
name|IPSEC_DIR_OUTBOUND
case|:
break|break;
default|default:
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_spdadd: Invalid SP direction.\n"
operator|)
argument_list|)
expr_stmt|;
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_errno
operator|=
name|EINVAL
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* check policy */
comment|/* key_spdadd() accepts DISCARD, NONE and IPSEC. */
if|if
condition|(
name|xpl0
operator|->
name|sadb_x_policy_type
operator|==
name|IPSEC_POLICY_ENTRUST
operator|||
name|xpl0
operator|->
name|sadb_x_policy_type
operator|==
name|IPSEC_POLICY_BYPASS
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_spdadd: Invalid policy type.\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
comment|/* policy requests are mandatory when action is ipsec. */
if|if
condition|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_type
operator|!=
name|SADB_X_SPDSETIDX
operator|&&
name|xpl0
operator|->
name|sadb_x_policy_type
operator|==
name|IPSEC_POLICY_IPSEC
operator|&&
name|mhp
operator|->
name|extlen
index|[
name|SADB_X_EXT_POLICY
index|]
operator|<=
sizeof|sizeof
argument_list|(
operator|*
name|xpl0
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_spdadd: some policy requests part required.\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
comment|/* 	 * checking there is SP already or not. 	 * SPDUPDATE doesn't depend on whether there is a SP or not. 	 * If the type is either SPDADD or SPDSETIDX AND a SP is found, 	 * then error. 	 */
name|newsp
operator|=
name|key_getsp
argument_list|(
operator|&
name|spidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_type
operator|==
name|SADB_X_SPDUPDATE
condition|)
block|{
if|if
condition|(
name|newsp
condition|)
block|{
name|newsp
operator|->
name|state
operator|=
name|IPSEC_SPSTATE_DEAD
expr_stmt|;
name|key_freesp
argument_list|(
name|newsp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|newsp
operator|!=
name|NULL
condition|)
block|{
name|key_freesp
argument_list|(
name|newsp
argument_list|)
expr_stmt|;
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_spdadd: a SP entry exists already.\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EEXIST
argument_list|)
return|;
block|}
block|}
comment|/* allocation new SP entry */
if|if
condition|(
operator|(
name|newsp
operator|=
name|key_msg2sp
argument_list|(
name|xpl0
argument_list|,
name|PFKEY_EXTLEN
argument_list|(
name|xpl0
argument_list|)
argument_list|,
operator|&
name|error
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|error
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
name|newsp
operator|->
name|id
operator|=
name|key_getnewspid
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
name|keydb_delsecpolicy
argument_list|(
name|newsp
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOBUFS
argument_list|)
return|;
block|}
comment|/* XXX boundary check against sa_len */
name|KEY_SETSECSPIDX
argument_list|(
name|xpl0
operator|->
name|sadb_x_policy_dir
argument_list|,
name|src0
operator|+
literal|1
argument_list|,
name|dst0
operator|+
literal|1
argument_list|,
name|src0
operator|->
name|sadb_address_prefixlen
argument_list|,
name|dst0
operator|->
name|sadb_address_prefixlen
argument_list|,
name|src0
operator|->
name|sadb_address_proto
argument_list|,
operator|&
name|newsp
operator|->
name|spidx
argument_list|)
expr_stmt|;
comment|/* sanity check on addr pair */
if|if
condition|(
operator|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
name|src0
operator|+
literal|1
operator|)
operator|)
operator|->
name|sa_family
operator|!=
operator|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
name|dst0
operator|+
literal|1
operator|)
operator|)
operator|->
name|sa_family
condition|)
block|{
name|keydb_delsecpolicy
argument_list|(
name|newsp
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
name|src0
operator|+
literal|1
operator|)
operator|)
operator|->
name|sa_len
operator|!=
operator|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
name|dst0
operator|+
literal|1
operator|)
operator|)
operator|->
name|sa_len
condition|)
block|{
name|keydb_delsecpolicy
argument_list|(
name|newsp
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
if|#
directive|if
literal|1
if|if
condition|(
name|newsp
operator|->
name|req
operator|&&
name|newsp
operator|->
name|req
operator|->
name|saidx
operator|.
name|src
operator|.
name|ss_family
condition|)
block|{
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
name|sa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
name|src0
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|sa
operator|->
name|sa_family
operator|!=
name|newsp
operator|->
name|req
operator|->
name|saidx
operator|.
name|src
operator|.
name|ss_family
condition|)
block|{
name|keydb_delsecpolicy
argument_list|(
name|newsp
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|newsp
operator|->
name|req
operator|&&
name|newsp
operator|->
name|req
operator|->
name|saidx
operator|.
name|dst
operator|.
name|ss_family
condition|)
block|{
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
name|sa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
name|dst0
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|sa
operator|->
name|sa_family
operator|!=
name|newsp
operator|->
name|req
operator|->
name|saidx
operator|.
name|dst
operator|.
name|ss_family
condition|)
block|{
name|keydb_delsecpolicy
argument_list|(
name|newsp
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
block|}
endif|#
directive|endif
name|microtime
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
name|newsp
operator|->
name|created
operator|=
name|tv
operator|.
name|tv_sec
expr_stmt|;
name|newsp
operator|->
name|lastused
operator|=
name|tv
operator|.
name|tv_sec
expr_stmt|;
name|newsp
operator|->
name|lifetime
operator|=
name|lft
condition|?
name|lft
operator|->
name|sadb_lifetime_addtime
else|:
literal|0
expr_stmt|;
name|newsp
operator|->
name|validtime
operator|=
name|lft
condition|?
name|lft
operator|->
name|sadb_lifetime_usetime
else|:
literal|0
expr_stmt|;
name|newsp
operator|->
name|refcnt
operator|=
literal|1
expr_stmt|;
comment|/* do not reclaim until I say I do */
name|newsp
operator|->
name|state
operator|=
name|IPSEC_SPSTATE_ALIVE
expr_stmt|;
name|LIST_INSERT_TAIL
argument_list|(
operator|&
name|sptree
index|[
name|newsp
operator|->
name|spidx
operator|.
name|dir
index|]
argument_list|,
name|newsp
argument_list|,
name|secpolicy
argument_list|,
name|chain
argument_list|)
expr_stmt|;
comment|/* delete the entry in spacqtree */
if|if
condition|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_type
operator|==
name|SADB_X_SPDUPDATE
condition|)
block|{
name|struct
name|secspacq
modifier|*
name|spacq
decl_stmt|;
if|if
condition|(
operator|(
name|spacq
operator|=
name|key_getspacq
argument_list|(
operator|&
name|spidx
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* reset counter in order to deletion by timehandler. */
name|microtime
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
name|spacq
operator|->
name|created
operator|=
name|tv
operator|.
name|tv_sec
expr_stmt|;
name|spacq
operator|->
name|count
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|{
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|,
modifier|*
name|mpolicy
decl_stmt|;
name|struct
name|sadb_msg
modifier|*
name|newmsg
decl_stmt|;
name|int
name|off
decl_stmt|;
comment|/* create new sadb_msg to reply. */
if|if
condition|(
name|lft
condition|)
block|{
name|n
operator|=
name|key_gather_mbuf
argument_list|(
name|m
argument_list|,
name|mhp
argument_list|,
literal|2
argument_list|,
literal|5
argument_list|,
name|SADB_EXT_RESERVED
argument_list|,
name|SADB_X_EXT_POLICY
argument_list|,
name|SADB_EXT_LIFETIME_HARD
argument_list|,
name|SADB_EXT_ADDRESS_SRC
argument_list|,
name|SADB_EXT_ADDRESS_DST
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|n
operator|=
name|key_gather_mbuf
argument_list|(
name|m
argument_list|,
name|mhp
argument_list|,
literal|2
argument_list|,
literal|4
argument_list|,
name|SADB_EXT_RESERVED
argument_list|,
name|SADB_X_EXT_POLICY
argument_list|,
name|SADB_EXT_ADDRESS_SRC
argument_list|,
name|SADB_EXT_ADDRESS_DST
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|n
condition|)
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOBUFS
argument_list|)
return|;
if|if
condition|(
name|n
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|newmsg
argument_list|)
condition|)
block|{
name|n
operator|=
name|m_pullup
argument_list|(
name|n
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|newmsg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOBUFS
argument_list|)
return|;
block|}
name|newmsg
operator|=
name|mtod
argument_list|(
name|n
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|)
expr_stmt|;
name|newmsg
operator|->
name|sadb_msg_errno
operator|=
literal|0
expr_stmt|;
name|newmsg
operator|->
name|sadb_msg_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|n
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|off
operator|=
literal|0
expr_stmt|;
name|mpolicy
operator|=
name|m_pulldown
argument_list|(
name|n
argument_list|,
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|xpl
argument_list|)
argument_list|,
operator|&
name|off
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpolicy
operator|==
name|NULL
condition|)
block|{
comment|/* n is already freed */
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOBUFS
argument_list|)
return|;
block|}
name|xpl
operator|=
operator|(
expr|struct
name|sadb_x_policy
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|mpolicy
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|off
operator|)
expr_stmt|;
if|if
condition|(
name|xpl
operator|->
name|sadb_x_policy_exttype
operator|!=
name|SADB_X_EXT_POLICY
condition|)
block|{
name|m_freem
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
name|xpl
operator|->
name|sadb_x_policy_id
operator|=
name|newsp
operator|->
name|id
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|key_sendup_mbuf
argument_list|(
name|so
argument_list|,
name|n
argument_list|,
name|KEY_SENDUP_ALL
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * get new policy id.  * OUT:  *	0:	failure.  *	others: success.  */
end_comment

begin_function
specifier|static
name|u_int32_t
name|key_getnewspid
parameter_list|()
block|{
name|u_int32_t
name|newid
init|=
literal|0
decl_stmt|;
name|int
name|count
init|=
name|key_spi_trycnt
decl_stmt|;
comment|/* XXX */
name|struct
name|secpolicy
modifier|*
name|sp
decl_stmt|;
comment|/* when requesting to allocate spi ranged */
while|while
condition|(
name|count
operator|--
condition|)
block|{
name|newid
operator|=
operator|(
name|policy_id
operator|=
operator|(
name|policy_id
operator|==
operator|~
literal|0
condition|?
literal|1
else|:
name|policy_id
operator|+
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|sp
operator|=
name|key_getspbyid
argument_list|(
name|newid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
name|key_freesp
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|==
literal|0
operator|||
name|newid
operator|==
literal|0
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_getnewspid: to allocate policy id is failed.\n"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|newid
return|;
block|}
end_function

begin_comment
comment|/*  * SADB_SPDDELETE processing  * receive  *<base, address(SD), policy(*)>  * from the user(?), and set SADB_SASTATE_DEAD,  * and send,  *<base, address(SD), policy(*)>  * to the ikmpd.  * policy(*) including direction of policy.  *  * m will always be freed.  */
end_comment

begin_function
specifier|static
name|int
name|key_spddelete
parameter_list|(
name|so
parameter_list|,
name|m
parameter_list|,
name|mhp
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|const
name|struct
name|sadb_msghdr
modifier|*
name|mhp
decl_stmt|;
block|{
name|struct
name|sadb_address
modifier|*
name|src0
decl_stmt|,
modifier|*
name|dst0
decl_stmt|;
name|struct
name|sadb_x_policy
modifier|*
name|xpl0
decl_stmt|;
name|struct
name|secpolicyindex
name|spidx
decl_stmt|;
name|struct
name|secpolicy
modifier|*
name|sp
decl_stmt|;
comment|/* sanity check */
if|if
condition|(
name|so
operator|==
name|NULL
operator|||
name|m
operator|==
name|NULL
operator|||
name|mhp
operator|==
name|NULL
operator|||
name|mhp
operator|->
name|msg
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_spddelete: NULL pointer is passed.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
operator|==
name|NULL
operator|||
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_DST
index|]
operator|==
name|NULL
operator|||
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_POLICY
index|]
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_spddelete: invalid message is passed.\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|mhp
operator|->
name|extlen
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_address
argument_list|)
operator|||
name|mhp
operator|->
name|extlen
index|[
name|SADB_EXT_ADDRESS_DST
index|]
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_address
argument_list|)
operator|||
name|mhp
operator|->
name|extlen
index|[
name|SADB_X_EXT_POLICY
index|]
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_x_policy
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_spddelete: invalid message is passed.\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
name|src0
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
expr_stmt|;
name|dst0
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_DST
index|]
expr_stmt|;
name|xpl0
operator|=
operator|(
expr|struct
name|sadb_x_policy
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_POLICY
index|]
expr_stmt|;
comment|/* make secindex */
comment|/* XXX boundary check against sa_len */
name|KEY_SETSECSPIDX
argument_list|(
name|xpl0
operator|->
name|sadb_x_policy_dir
argument_list|,
name|src0
operator|+
literal|1
argument_list|,
name|dst0
operator|+
literal|1
argument_list|,
name|src0
operator|->
name|sadb_address_prefixlen
argument_list|,
name|dst0
operator|->
name|sadb_address_prefixlen
argument_list|,
name|src0
operator|->
name|sadb_address_proto
argument_list|,
operator|&
name|spidx
argument_list|)
expr_stmt|;
comment|/* checking the direciton. */
switch|switch
condition|(
name|xpl0
operator|->
name|sadb_x_policy_dir
condition|)
block|{
case|case
name|IPSEC_DIR_INBOUND
case|:
case|case
name|IPSEC_DIR_OUTBOUND
case|:
break|break;
default|default:
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_spddelete: Invalid SP direction.\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
comment|/* Is there SP in SPD ? */
if|if
condition|(
operator|(
name|sp
operator|=
name|key_getsp
argument_list|(
operator|&
name|spidx
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_spddelete: no SP found.\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
comment|/* save policy id to buffer to be returned. */
name|xpl0
operator|->
name|sadb_x_policy_id
operator|=
name|sp
operator|->
name|id
expr_stmt|;
name|sp
operator|->
name|state
operator|=
name|IPSEC_SPSTATE_DEAD
expr_stmt|;
name|key_freesp
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
name|struct
name|sadb_msg
modifier|*
name|newmsg
decl_stmt|;
comment|/* create new sadb_msg to reply. */
name|n
operator|=
name|key_gather_mbuf
argument_list|(
name|m
argument_list|,
name|mhp
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
name|SADB_EXT_RESERVED
argument_list|,
name|SADB_X_EXT_POLICY
argument_list|,
name|SADB_EXT_ADDRESS_SRC
argument_list|,
name|SADB_EXT_ADDRESS_DST
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOBUFS
argument_list|)
return|;
name|newmsg
operator|=
name|mtod
argument_list|(
name|n
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|)
expr_stmt|;
name|newmsg
operator|->
name|sadb_msg_errno
operator|=
literal|0
expr_stmt|;
name|newmsg
operator|->
name|sadb_msg_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|n
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|key_sendup_mbuf
argument_list|(
name|so
argument_list|,
name|n
argument_list|,
name|KEY_SENDUP_ALL
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * SADB_SPDDELETE2 processing  * receive  *<base, policy(*)>  * from the user(?), and set SADB_SASTATE_DEAD,  * and send,  *<base, policy(*)>  * to the ikmpd.  * policy(*) including direction of policy.  *  * m will always be freed.  */
end_comment

begin_function
specifier|static
name|int
name|key_spddelete2
parameter_list|(
name|so
parameter_list|,
name|m
parameter_list|,
name|mhp
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|const
name|struct
name|sadb_msghdr
modifier|*
name|mhp
decl_stmt|;
block|{
name|u_int32_t
name|id
decl_stmt|;
name|struct
name|secpolicy
modifier|*
name|sp
decl_stmt|;
comment|/* sanity check */
if|if
condition|(
name|so
operator|==
name|NULL
operator|||
name|m
operator|==
name|NULL
operator|||
name|mhp
operator|==
name|NULL
operator|||
name|mhp
operator|->
name|msg
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_spddelete2: NULL pointer is passed.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_POLICY
index|]
operator|==
name|NULL
operator|||
name|mhp
operator|->
name|extlen
index|[
name|SADB_X_EXT_POLICY
index|]
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_x_policy
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_spddelete2: invalid message is passed.\n"
operator|)
argument_list|)
expr_stmt|;
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|id
operator|=
operator|(
operator|(
expr|struct
name|sadb_x_policy
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_POLICY
index|]
operator|)
operator|->
name|sadb_x_policy_id
expr_stmt|;
comment|/* Is there SP in SPD ? */
if|if
condition|(
operator|(
name|sp
operator|=
name|key_getspbyid
argument_list|(
name|id
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_spddelete2: no SP found id:%u.\n"
operator|,
name|id
operator|)
argument_list|)
expr_stmt|;
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
block|}
name|sp
operator|->
name|state
operator|=
name|IPSEC_SPSTATE_DEAD
expr_stmt|;
name|key_freesp
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|,
modifier|*
name|nn
decl_stmt|;
name|struct
name|sadb_msg
modifier|*
name|newmsg
decl_stmt|;
name|int
name|off
decl_stmt|,
name|len
decl_stmt|;
comment|/* create new sadb_msg to reply. */
name|len
operator|=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|MCLBYTES
condition|)
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOBUFS
argument_list|)
return|;
name|MGETHDR
argument_list|(
name|n
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|&&
name|len
operator|>
name|MHLEN
condition|)
block|{
name|MCLGET
argument_list|(
name|n
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|n
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|n
condition|)
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOBUFS
argument_list|)
return|;
name|n
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
name|n
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
name|off
operator|=
literal|0
expr_stmt|;
name|m_copydata
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|,
name|mtod
argument_list|(
name|n
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|off
argument_list|)
expr_stmt|;
name|off
operator|+=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|off
operator|!=
name|len
condition|)
name|panic
argument_list|(
literal|"length inconsistency in key_spddelete2"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|n
operator|->
name|m_next
operator|=
name|m_copym
argument_list|(
name|m
argument_list|,
name|mhp
operator|->
name|extoff
index|[
name|SADB_X_EXT_POLICY
index|]
argument_list|,
name|mhp
operator|->
name|extlen
index|[
name|SADB_X_EXT_POLICY
index|]
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
operator|->
name|m_next
condition|)
block|{
name|m_freem
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOBUFS
argument_list|)
return|;
block|}
name|n
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|nn
operator|=
name|n
init|;
name|nn
condition|;
name|nn
operator|=
name|nn
operator|->
name|m_next
control|)
name|n
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|nn
operator|->
name|m_len
expr_stmt|;
name|newmsg
operator|=
name|mtod
argument_list|(
name|n
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|)
expr_stmt|;
name|newmsg
operator|->
name|sadb_msg_errno
operator|=
literal|0
expr_stmt|;
name|newmsg
operator|->
name|sadb_msg_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|n
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|key_sendup_mbuf
argument_list|(
name|so
argument_list|,
name|n
argument_list|,
name|KEY_SENDUP_ALL
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * SADB_X_GET processing  * receive  *<base, policy(*)>  * from the user(?),  * and send,  *<base, address(SD), policy>  * to the ikmpd.  * policy(*) including direction of policy.  *  * m will always be freed.  */
end_comment

begin_function
specifier|static
name|int
name|key_spdget
parameter_list|(
name|so
parameter_list|,
name|m
parameter_list|,
name|mhp
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|const
name|struct
name|sadb_msghdr
modifier|*
name|mhp
decl_stmt|;
block|{
name|u_int32_t
name|id
decl_stmt|;
name|struct
name|secpolicy
modifier|*
name|sp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
comment|/* sanity check */
if|if
condition|(
name|so
operator|==
name|NULL
operator|||
name|m
operator|==
name|NULL
operator|||
name|mhp
operator|==
name|NULL
operator|||
name|mhp
operator|->
name|msg
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_spdget: NULL pointer is passed.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_POLICY
index|]
operator|==
name|NULL
operator|||
name|mhp
operator|->
name|extlen
index|[
name|SADB_X_EXT_POLICY
index|]
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_x_policy
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_spdget: invalid message is passed.\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
name|id
operator|=
operator|(
operator|(
expr|struct
name|sadb_x_policy
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_POLICY
index|]
operator|)
operator|->
name|sadb_x_policy_id
expr_stmt|;
comment|/* Is there SP in SPD ? */
if|if
condition|(
operator|(
name|sp
operator|=
name|key_getspbyid
argument_list|(
name|id
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_spdget: no SP found id:%u.\n"
operator|,
name|id
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOENT
argument_list|)
return|;
block|}
name|n
operator|=
name|key_setdumpsp
argument_list|(
name|sp
argument_list|,
name|SADB_X_SPDGET
argument_list|,
literal|0
argument_list|,
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|key_sendup_mbuf
argument_list|(
name|so
argument_list|,
name|n
argument_list|,
name|KEY_SENDUP_ONE
argument_list|)
return|;
block|}
else|else
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOBUFS
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * SADB_X_SPDACQUIRE processing.  * Acquire policy and SA(s) for a *OUTBOUND* packet.  * send  *<base, policy(*)>  * to KMD, and expect to receive  *<base> with SADB_X_SPDACQUIRE if error occured,  * or  *<base, policy>  * with SADB_X_SPDUPDATE from KMD by PF_KEY.  * policy(*) is without policy requests.  *  *    0     : succeed  *    others: error number  */
end_comment

begin_function
name|int
name|key_spdacquire
parameter_list|(
name|sp
parameter_list|)
name|struct
name|secpolicy
modifier|*
name|sp
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|result
init|=
name|NULL
decl_stmt|,
modifier|*
name|m
decl_stmt|;
name|struct
name|secspacq
modifier|*
name|newspacq
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* sanity check */
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_spdacquire: NULL pointer is passed.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|req
operator|!=
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_spdacquire: called but there is request.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|policy
operator|!=
name|IPSEC_POLICY_IPSEC
condition|)
name|panic
argument_list|(
literal|"key_spdacquire: policy mismathed. IPsec is expected.\n"
argument_list|)
expr_stmt|;
comment|/* get a entry to check whether sent message or not. */
if|if
condition|(
operator|(
name|newspacq
operator|=
name|key_getspacq
argument_list|(
operator|&
name|sp
operator|->
name|spidx
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|key_blockacq_count
operator|<
name|newspacq
operator|->
name|count
condition|)
block|{
comment|/* reset counter and do send message. */
name|newspacq
operator|->
name|count
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* increment counter and do nothing. */
name|newspacq
operator|->
name|count
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
else|else
block|{
comment|/* make new entry for blocking to send SADB_ACQUIRE. */
if|if
condition|(
operator|(
name|newspacq
operator|=
name|key_newspacq
argument_list|(
operator|&
name|sp
operator|->
name|spidx
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|ENOBUFS
return|;
comment|/* add to acqtree */
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|spacqtree
argument_list|,
name|newspacq
argument_list|,
name|chain
argument_list|)
expr_stmt|;
block|}
comment|/* create new sadb_msg to reply. */
name|m
operator|=
name|key_setsadbmsg
argument_list|(
name|SADB_X_SPDACQUIRE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|result
operator|=
name|m
expr_stmt|;
name|result
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|m
operator|=
name|result
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
name|result
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|mtod
argument_list|(
name|result
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|)
operator|->
name|sadb_msg_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|result
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
return|return
name|key_sendup_mbuf
argument_list|(
name|NULL
argument_list|,
name|m
argument_list|,
name|KEY_SENDUP_REGISTERED
argument_list|)
return|;
name|fail
label|:
if|if
condition|(
name|result
condition|)
name|m_freem
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * SADB_SPDFLUSH processing  * receive  *<base>  * from the user, and free all entries in secpctree.  * and send,  *<base>  * to the user.  * NOTE: what to do is only marking SADB_SASTATE_DEAD.  *  * m will always be freed.  */
end_comment

begin_function
specifier|static
name|int
name|key_spdflush
parameter_list|(
name|so
parameter_list|,
name|m
parameter_list|,
name|mhp
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|const
name|struct
name|sadb_msghdr
modifier|*
name|mhp
decl_stmt|;
block|{
name|struct
name|sadb_msg
modifier|*
name|newmsg
decl_stmt|;
name|struct
name|secpolicy
modifier|*
name|sp
decl_stmt|;
name|u_int
name|dir
decl_stmt|;
comment|/* sanity check */
if|if
condition|(
name|so
operator|==
name|NULL
operator|||
name|m
operator|==
name|NULL
operator|||
name|mhp
operator|==
name|NULL
operator|||
name|mhp
operator|->
name|msg
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_spdflush: NULL pointer is passed.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|!=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|)
condition|)
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
for|for
control|(
name|dir
operator|=
literal|0
init|;
name|dir
operator|<
name|IPSEC_DIR_MAX
condition|;
name|dir
operator|++
control|)
block|{
name|LIST_FOREACH
argument_list|(
argument|sp
argument_list|,
argument|&sptree[dir]
argument_list|,
argument|chain
argument_list|)
block|{
name|sp
operator|->
name|state
operator|=
name|IPSEC_SPSTATE_DEAD
expr_stmt|;
block|}
block|}
if|if
condition|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
operator|>
name|m
operator|->
name|m_len
operator|+
name|M_TRAILINGSPACE
argument_list|(
name|m
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_spdflush: No more memory.\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOBUFS
argument_list|)
return|;
block|}
if|if
condition|(
name|m
operator|->
name|m_next
condition|)
name|m_freem
argument_list|(
name|m
operator|->
name|m_next
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|)
expr_stmt|;
name|newmsg
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|)
expr_stmt|;
name|newmsg
operator|->
name|sadb_msg_errno
operator|=
literal|0
expr_stmt|;
name|newmsg
operator|->
name|sadb_msg_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
return|return
name|key_sendup_mbuf
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|KEY_SENDUP_ALL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * SADB_SPDDUMP processing  * receive  *<base>  * from the user, and dump all SP leaves  * and send,  *<base> .....  * to the ikmpd.  *  * m will always be freed.  */
end_comment

begin_function
specifier|static
name|int
name|key_spddump
parameter_list|(
name|so
parameter_list|,
name|m
parameter_list|,
name|mhp
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|const
name|struct
name|sadb_msghdr
modifier|*
name|mhp
decl_stmt|;
block|{
name|struct
name|secpolicy
modifier|*
name|sp
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|u_int
name|dir
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
comment|/* sanity check */
if|if
condition|(
name|so
operator|==
name|NULL
operator|||
name|m
operator|==
name|NULL
operator|||
name|mhp
operator|==
name|NULL
operator|||
name|mhp
operator|->
name|msg
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_spddump: NULL pointer is passed.\n"
argument_list|)
expr_stmt|;
comment|/* search SPD entry and get buffer size. */
name|cnt
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|dir
operator|=
literal|0
init|;
name|dir
operator|<
name|IPSEC_DIR_MAX
condition|;
name|dir
operator|++
control|)
block|{
name|LIST_FOREACH
argument_list|(
argument|sp
argument_list|,
argument|&sptree[dir]
argument_list|,
argument|chain
argument_list|)
block|{
name|cnt
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cnt
operator|==
literal|0
condition|)
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOENT
argument_list|)
return|;
for|for
control|(
name|dir
operator|=
literal|0
init|;
name|dir
operator|<
name|IPSEC_DIR_MAX
condition|;
name|dir
operator|++
control|)
block|{
name|LIST_FOREACH
argument_list|(
argument|sp
argument_list|,
argument|&sptree[dir]
argument_list|,
argument|chain
argument_list|)
block|{
operator|--
name|cnt
expr_stmt|;
name|n
operator|=
name|key_setdumpsp
argument_list|(
name|sp
argument_list|,
name|SADB_X_SPDDUMP
argument_list|,
name|cnt
argument_list|,
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
condition|)
name|key_sendup_mbuf
argument_list|(
name|so
argument_list|,
name|n
argument_list|,
name|KEY_SENDUP_ONE
argument_list|)
expr_stmt|;
block|}
block|}
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|key_setdumpsp
parameter_list|(
name|sp
parameter_list|,
name|type
parameter_list|,
name|seq
parameter_list|,
name|pid
parameter_list|)
name|struct
name|secpolicy
modifier|*
name|sp
decl_stmt|;
name|u_int8_t
name|type
decl_stmt|;
name|u_int32_t
name|seq
decl_stmt|,
name|pid
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|result
init|=
name|NULL
decl_stmt|,
modifier|*
name|m
decl_stmt|;
name|m
operator|=
name|key_setsadbmsg
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
name|SADB_SATYPE_UNSPEC
argument_list|,
name|seq
argument_list|,
name|pid
argument_list|,
name|sp
operator|->
name|refcnt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
goto|goto
name|fail
goto|;
name|result
operator|=
name|m
expr_stmt|;
name|m
operator|=
name|key_setsadbaddr
argument_list|(
name|SADB_EXT_ADDRESS_SRC
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sp
operator|->
name|spidx
operator|.
name|src
argument_list|,
name|sp
operator|->
name|spidx
operator|.
name|prefs
argument_list|,
name|sp
operator|->
name|spidx
operator|.
name|ul_proto
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
goto|goto
name|fail
goto|;
name|m_cat
argument_list|(
name|result
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|key_setsadbaddr
argument_list|(
name|SADB_EXT_ADDRESS_DST
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sp
operator|->
name|spidx
operator|.
name|dst
argument_list|,
name|sp
operator|->
name|spidx
operator|.
name|prefd
argument_list|,
name|sp
operator|->
name|spidx
operator|.
name|ul_proto
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
goto|goto
name|fail
goto|;
name|m_cat
argument_list|(
name|result
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|key_sp2msg
argument_list|(
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
goto|goto
name|fail
goto|;
name|m_cat
argument_list|(
name|result
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|result
operator|->
name|m_flags
operator|&
name|M_PKTHDR
operator|)
operator|==
literal|0
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|result
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
condition|)
block|{
name|result
operator|=
name|m_pullup
argument_list|(
name|result
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
block|}
name|result
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|m
operator|=
name|result
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
name|result
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|mtod
argument_list|(
name|result
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|)
operator|->
name|sadb_msg_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|result
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
return|return
name|result
return|;
name|fail
label|:
name|m_freem
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * get PFKEY message length for security policy and request.  */
end_comment

begin_function
specifier|static
name|u_int
name|key_getspreqmsglen
parameter_list|(
name|sp
parameter_list|)
name|struct
name|secpolicy
modifier|*
name|sp
decl_stmt|;
block|{
name|u_int
name|tlen
decl_stmt|;
name|tlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_x_policy
argument_list|)
expr_stmt|;
comment|/* if is the policy for ipsec ? */
if|if
condition|(
name|sp
operator|->
name|policy
operator|!=
name|IPSEC_POLICY_IPSEC
condition|)
return|return
name|tlen
return|;
comment|/* get length of ipsec requests */
block|{
name|struct
name|ipsecrequest
modifier|*
name|isr
decl_stmt|;
name|int
name|len
decl_stmt|;
for|for
control|(
name|isr
operator|=
name|sp
operator|->
name|req
init|;
name|isr
operator|!=
name|NULL
condition|;
name|isr
operator|=
name|isr
operator|->
name|next
control|)
block|{
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_x_ipsecrequest
argument_list|)
operator|+
name|isr
operator|->
name|saidx
operator|.
name|src
operator|.
name|ss_len
operator|+
name|isr
operator|->
name|saidx
operator|.
name|dst
operator|.
name|ss_len
expr_stmt|;
name|tlen
operator|+=
name|PFKEY_ALIGN8
argument_list|(
name|len
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|tlen
return|;
block|}
end_function

begin_comment
comment|/*  * SADB_SPDEXPIRE processing  * send  *<base, address(SD), lifetime(CH), policy>  * to KMD by PF_KEY.  *  * OUT:	0	: succeed  *	others	: error number  */
end_comment

begin_function
specifier|static
name|int
name|key_spdexpire
parameter_list|(
name|sp
parameter_list|)
name|struct
name|secpolicy
modifier|*
name|sp
decl_stmt|;
block|{
name|int
name|s
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|result
init|=
name|NULL
decl_stmt|,
modifier|*
name|m
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|error
init|=
operator|-
literal|1
decl_stmt|;
name|struct
name|sadb_lifetime
modifier|*
name|lt
decl_stmt|;
comment|/* XXX: Why do we lock ? */
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
comment|/*called from softclock()*/
comment|/* sanity check */
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_spdexpire: NULL pointer is passed.\n"
argument_list|)
expr_stmt|;
comment|/* set msg header */
name|m
operator|=
name|key_setsadbmsg
argument_list|(
name|SADB_X_SPDEXPIRE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|result
operator|=
name|m
expr_stmt|;
comment|/* create lifetime extension (current and hard) */
name|len
operator|=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|lt
argument_list|)
argument_list|)
operator|*
literal|2
expr_stmt|;
name|m
operator|=
name|key_alloc_mbuf
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
operator|||
name|m
operator|->
name|m_next
condition|)
block|{
comment|/*XXX*/
if|if
condition|(
name|m
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|bzero
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|lt
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sadb_lifetime
operator|*
argument_list|)
expr_stmt|;
name|lt
operator|->
name|sadb_lifetime_len
operator|=
name|PFKEY_UNIT64
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_lifetime
argument_list|)
argument_list|)
expr_stmt|;
name|lt
operator|->
name|sadb_lifetime_exttype
operator|=
name|SADB_EXT_LIFETIME_CURRENT
expr_stmt|;
name|lt
operator|->
name|sadb_lifetime_allocations
operator|=
literal|0
expr_stmt|;
name|lt
operator|->
name|sadb_lifetime_bytes
operator|=
literal|0
expr_stmt|;
name|lt
operator|->
name|sadb_lifetime_addtime
operator|=
name|sp
operator|->
name|created
expr_stmt|;
name|lt
operator|->
name|sadb_lifetime_usetime
operator|=
name|sp
operator|->
name|lastused
expr_stmt|;
name|lt
operator|=
operator|(
expr|struct
name|sadb_lifetime
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|len
operator|/
literal|2
operator|)
expr_stmt|;
name|lt
operator|->
name|sadb_lifetime_len
operator|=
name|PFKEY_UNIT64
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_lifetime
argument_list|)
argument_list|)
expr_stmt|;
name|lt
operator|->
name|sadb_lifetime_exttype
operator|=
name|SADB_EXT_LIFETIME_HARD
expr_stmt|;
name|lt
operator|->
name|sadb_lifetime_allocations
operator|=
literal|0
expr_stmt|;
name|lt
operator|->
name|sadb_lifetime_bytes
operator|=
literal|0
expr_stmt|;
name|lt
operator|->
name|sadb_lifetime_addtime
operator|=
name|sp
operator|->
name|lifetime
expr_stmt|;
name|lt
operator|->
name|sadb_lifetime_usetime
operator|=
name|sp
operator|->
name|validtime
expr_stmt|;
name|m_cat
argument_list|(
name|result
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* set sadb_address for source */
name|m
operator|=
name|key_setsadbaddr
argument_list|(
name|SADB_EXT_ADDRESS_SRC
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sp
operator|->
name|spidx
operator|.
name|src
argument_list|,
name|sp
operator|->
name|spidx
operator|.
name|prefs
argument_list|,
name|sp
operator|->
name|spidx
operator|.
name|ul_proto
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|m_cat
argument_list|(
name|result
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* set sadb_address for destination */
name|m
operator|=
name|key_setsadbaddr
argument_list|(
name|SADB_EXT_ADDRESS_DST
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sp
operator|->
name|spidx
operator|.
name|dst
argument_list|,
name|sp
operator|->
name|spidx
operator|.
name|prefd
argument_list|,
name|sp
operator|->
name|spidx
operator|.
name|ul_proto
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|m_cat
argument_list|(
name|result
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* set secpolicy */
name|m
operator|=
name|key_sp2msg
argument_list|(
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|m_cat
argument_list|(
name|result
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|result
operator|->
name|m_flags
operator|&
name|M_PKTHDR
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|result
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
condition|)
block|{
name|result
operator|=
name|m_pullup
argument_list|(
name|result
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
name|result
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|m
operator|=
name|result
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
name|result
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|mtod
argument_list|(
name|result
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|)
operator|->
name|sadb_msg_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|result
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
return|return
name|key_sendup_mbuf
argument_list|(
name|NULL
argument_list|,
name|result
argument_list|,
name|KEY_SENDUP_REGISTERED
argument_list|)
return|;
name|fail
label|:
if|if
condition|(
name|result
condition|)
name|m_freem
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* %%% SAD management */
end_comment

begin_comment
comment|/*  * allocating a memory for new SA head, and copy from the values of mhp.  * OUT:	NULL	: failure due to the lack of memory.  *	others	: pointer to new SA head.  */
end_comment

begin_function
specifier|static
name|struct
name|secashead
modifier|*
name|key_newsah
parameter_list|(
name|saidx
parameter_list|)
name|struct
name|secasindex
modifier|*
name|saidx
decl_stmt|;
block|{
name|struct
name|secashead
modifier|*
name|newsah
decl_stmt|;
comment|/* sanity check */
if|if
condition|(
name|saidx
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_newsaidx: NULL pointer is passed.\n"
argument_list|)
expr_stmt|;
name|newsah
operator|=
name|keydb_newsecashead
argument_list|()
expr_stmt|;
if|if
condition|(
name|newsah
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|bcopy
argument_list|(
name|saidx
argument_list|,
operator|&
name|newsah
operator|->
name|saidx
argument_list|,
sizeof|sizeof
argument_list|(
name|newsah
operator|->
name|saidx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* add to saidxtree */
name|newsah
operator|->
name|state
operator|=
name|SADB_SASTATE_MATURE
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|sahtree
argument_list|,
name|newsah
argument_list|,
name|chain
argument_list|)
expr_stmt|;
return|return
operator|(
name|newsah
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * delete SA index and all SA registerd.  */
end_comment

begin_function
specifier|static
name|void
name|key_delsah
parameter_list|(
name|sah
parameter_list|)
name|struct
name|secashead
modifier|*
name|sah
decl_stmt|;
block|{
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|,
modifier|*
name|nextsav
decl_stmt|;
name|u_int
name|stateidx
decl_stmt|,
name|state
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|zombie
init|=
literal|0
decl_stmt|;
comment|/* sanity check */
if|if
condition|(
name|sah
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_delsah: NULL pointer is passed.\n"
argument_list|)
expr_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
comment|/*called from softclock()*/
comment|/* searching all SA registerd in the secindex. */
for|for
control|(
name|stateidx
operator|=
literal|0
init|;
name|stateidx
operator|<
name|_ARRAYLEN
argument_list|(
name|saorder_state_any
argument_list|)
condition|;
name|stateidx
operator|++
control|)
block|{
name|state
operator|=
name|saorder_state_any
index|[
name|stateidx
index|]
expr_stmt|;
for|for
control|(
name|sav
operator|=
operator|(
expr|struct
name|secasvar
operator|*
operator|)
name|LIST_FIRST
argument_list|(
operator|&
name|sah
operator|->
name|savtree
index|[
name|state
index|]
argument_list|)
init|;
name|sav
operator|!=
name|NULL
condition|;
name|sav
operator|=
name|nextsav
control|)
block|{
name|nextsav
operator|=
name|LIST_NEXT
argument_list|(
name|sav
argument_list|,
name|chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|refcnt
operator|>
literal|0
condition|)
block|{
comment|/* give up to delete this sa */
name|zombie
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* sanity check */
name|KEY_CHKSASTATE
argument_list|(
name|state
argument_list|,
name|sav
operator|->
name|state
argument_list|,
literal|"key_delsah"
argument_list|)
expr_stmt|;
name|key_freesav
argument_list|(
name|sav
argument_list|)
expr_stmt|;
comment|/* remove back pointer */
name|sav
operator|->
name|sah
operator|=
name|NULL
expr_stmt|;
name|sav
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* don't delete sah only if there are savs. */
if|if
condition|(
name|zombie
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sah
operator|->
name|sa_route
operator|.
name|ro_rt
condition|)
block|{
name|RTFREE
argument_list|(
name|sah
operator|->
name|sa_route
operator|.
name|ro_rt
argument_list|)
expr_stmt|;
name|sah
operator|->
name|sa_route
operator|.
name|ro_rt
operator|=
operator|(
expr|struct
name|rtentry
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
comment|/* remove from tree of SA index */
if|if
condition|(
name|__LIST_CHAINED
argument_list|(
name|sah
argument_list|)
condition|)
name|LIST_REMOVE
argument_list|(
name|sah
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|KFREE
argument_list|(
name|sah
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * allocating a new SA with LARVAL state.  key_add() and key_getspi() call,  * and copy the values of mhp into new buffer.  * When SAD message type is GETSPI:  *	to set sequence number from acq_seq++,  *	to set zero to SPI.  *	not to call key_setsava().  * OUT:	NULL	: fail  *	others	: pointer to new secasvar.  *  * does not modify mbuf.  does not free mbuf on error.  */
end_comment

begin_function
specifier|static
name|struct
name|secasvar
modifier|*
name|key_newsav
parameter_list|(
name|m
parameter_list|,
name|mhp
parameter_list|,
name|sah
parameter_list|,
name|errp
parameter_list|)
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|const
name|struct
name|sadb_msghdr
modifier|*
name|mhp
decl_stmt|;
name|struct
name|secashead
modifier|*
name|sah
decl_stmt|;
name|int
modifier|*
name|errp
decl_stmt|;
block|{
name|struct
name|secasvar
modifier|*
name|newsav
decl_stmt|;
specifier|const
name|struct
name|sadb_sa
modifier|*
name|xsa
decl_stmt|;
comment|/* sanity check */
if|if
condition|(
name|m
operator|==
name|NULL
operator|||
name|mhp
operator|==
name|NULL
operator|||
name|mhp
operator|->
name|msg
operator|==
name|NULL
operator|||
name|sah
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_newsa: NULL pointer is passed.\n"
argument_list|)
expr_stmt|;
name|KMALLOC
argument_list|(
name|newsav
argument_list|,
expr|struct
name|secasvar
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|secasvar
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newsav
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_newsa: No more memory.\n"
operator|)
argument_list|)
expr_stmt|;
operator|*
name|errp
operator|=
name|ENOBUFS
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|newsav
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|secasvar
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_type
condition|)
block|{
case|case
name|SADB_GETSPI
case|:
name|newsav
operator|->
name|spi
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|IPSEC_DOSEQCHECK
comment|/* sync sequence number */
if|if
condition|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_seq
operator|==
literal|0
condition|)
name|newsav
operator|->
name|seq
operator|=
operator|(
name|acq_seq
operator|=
operator|(
name|acq_seq
operator|==
operator|~
literal|0
condition|?
literal|1
else|:
operator|++
name|acq_seq
operator|)
operator|)
expr_stmt|;
else|else
endif|#
directive|endif
name|newsav
operator|->
name|seq
operator|=
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_seq
expr_stmt|;
break|break;
case|case
name|SADB_ADD
case|:
comment|/* sanity check */
if|if
condition|(
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_SA
index|]
operator|==
name|NULL
condition|)
block|{
name|KFREE
argument_list|(
name|newsav
argument_list|)
expr_stmt|;
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_newsa: invalid message is passed.\n"
operator|)
argument_list|)
expr_stmt|;
operator|*
name|errp
operator|=
name|EINVAL
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|xsa
operator|=
operator|(
specifier|const
expr|struct
name|sadb_sa
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_SA
index|]
expr_stmt|;
name|newsav
operator|->
name|spi
operator|=
name|xsa
operator|->
name|sadb_sa_spi
expr_stmt|;
name|newsav
operator|->
name|seq
operator|=
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_seq
expr_stmt|;
break|break;
default|default:
name|KFREE
argument_list|(
name|newsav
argument_list|)
expr_stmt|;
operator|*
name|errp
operator|=
name|EINVAL
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* copy sav values */
if|if
condition|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_type
operator|!=
name|SADB_GETSPI
condition|)
block|{
operator|*
name|errp
operator|=
name|key_setsaval
argument_list|(
name|newsav
argument_list|,
name|m
argument_list|,
name|mhp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|errp
condition|)
block|{
name|KFREE
argument_list|(
name|newsav
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
comment|/* reset created */
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|microtime
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
name|newsav
operator|->
name|created
operator|=
name|tv
operator|.
name|tv_sec
expr_stmt|;
block|}
name|newsav
operator|->
name|pid
operator|=
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_pid
expr_stmt|;
comment|/* add to satree */
name|newsav
operator|->
name|sah
operator|=
name|sah
expr_stmt|;
name|newsav
operator|->
name|refcnt
operator|=
literal|1
expr_stmt|;
name|newsav
operator|->
name|state
operator|=
name|SADB_SASTATE_LARVAL
expr_stmt|;
name|LIST_INSERT_TAIL
argument_list|(
operator|&
name|sah
operator|->
name|savtree
index|[
name|SADB_SASTATE_LARVAL
index|]
argument_list|,
name|newsav
argument_list|,
name|secasvar
argument_list|,
name|chain
argument_list|)
expr_stmt|;
return|return
name|newsav
return|;
block|}
end_function

begin_comment
comment|/*  * free() SA variable entry.  */
end_comment

begin_function
specifier|static
name|void
name|key_delsav
parameter_list|(
name|sav
parameter_list|)
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|;
block|{
comment|/* sanity check */
if|if
condition|(
name|sav
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_delsav: NULL pointer is passed.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|refcnt
operator|>
literal|0
condition|)
return|return;
comment|/* can't free */
comment|/* remove from SA header */
if|if
condition|(
name|__LIST_CHAINED
argument_list|(
name|sav
argument_list|)
condition|)
name|LIST_REMOVE
argument_list|(
name|sav
argument_list|,
name|chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|key_auth
operator|!=
name|NULL
condition|)
block|{
name|bzero
argument_list|(
name|_KEYBUF
argument_list|(
name|sav
operator|->
name|key_auth
argument_list|)
argument_list|,
name|_KEYLEN
argument_list|(
name|sav
operator|->
name|key_auth
argument_list|)
argument_list|)
expr_stmt|;
name|KFREE
argument_list|(
name|sav
operator|->
name|key_auth
argument_list|)
expr_stmt|;
name|sav
operator|->
name|key_auth
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sav
operator|->
name|key_enc
operator|!=
name|NULL
condition|)
block|{
name|bzero
argument_list|(
name|_KEYBUF
argument_list|(
name|sav
operator|->
name|key_enc
argument_list|)
argument_list|,
name|_KEYLEN
argument_list|(
name|sav
operator|->
name|key_enc
argument_list|)
argument_list|)
expr_stmt|;
name|KFREE
argument_list|(
name|sav
operator|->
name|key_enc
argument_list|)
expr_stmt|;
name|sav
operator|->
name|key_enc
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sav
operator|->
name|sched
condition|)
block|{
name|bzero
argument_list|(
name|sav
operator|->
name|sched
argument_list|,
name|sav
operator|->
name|schedlen
argument_list|)
expr_stmt|;
name|KFREE
argument_list|(
name|sav
operator|->
name|sched
argument_list|)
expr_stmt|;
name|sav
operator|->
name|sched
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sav
operator|->
name|replay
operator|!=
name|NULL
condition|)
block|{
name|keydb_delsecreplay
argument_list|(
name|sav
operator|->
name|replay
argument_list|)
expr_stmt|;
name|sav
operator|->
name|replay
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sav
operator|->
name|lft_c
operator|!=
name|NULL
condition|)
block|{
name|KFREE
argument_list|(
name|sav
operator|->
name|lft_c
argument_list|)
expr_stmt|;
name|sav
operator|->
name|lft_c
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sav
operator|->
name|lft_h
operator|!=
name|NULL
condition|)
block|{
name|KFREE
argument_list|(
name|sav
operator|->
name|lft_h
argument_list|)
expr_stmt|;
name|sav
operator|->
name|lft_h
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sav
operator|->
name|lft_s
operator|!=
name|NULL
condition|)
block|{
name|KFREE
argument_list|(
name|sav
operator|->
name|lft_s
argument_list|)
expr_stmt|;
name|sav
operator|->
name|lft_s
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sav
operator|->
name|iv
operator|!=
name|NULL
condition|)
block|{
name|KFREE
argument_list|(
name|sav
operator|->
name|iv
argument_list|)
expr_stmt|;
name|sav
operator|->
name|iv
operator|=
name|NULL
expr_stmt|;
block|}
name|KFREE
argument_list|(
name|sav
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * search SAD.  * OUT:  *	NULL	: not found  *	others	: found, pointer to a SA.  */
end_comment

begin_function
specifier|static
name|struct
name|secashead
modifier|*
name|key_getsah
parameter_list|(
name|saidx
parameter_list|)
name|struct
name|secasindex
modifier|*
name|saidx
decl_stmt|;
block|{
name|struct
name|secashead
modifier|*
name|sah
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|sah
argument_list|,
argument|&sahtree
argument_list|,
argument|chain
argument_list|)
block|{
if|if
condition|(
name|sah
operator|->
name|state
operator|==
name|SADB_SASTATE_DEAD
condition|)
continue|continue;
if|if
condition|(
name|key_cmpsaidx
argument_list|(
operator|&
name|sah
operator|->
name|saidx
argument_list|,
name|saidx
argument_list|,
name|CMP_REQID
argument_list|)
condition|)
return|return
name|sah
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * check not to be duplicated SPI.  * NOTE: this function is too slow due to searching all SAD.  * OUT:  *	NULL	: not found  *	others	: found, pointer to a SA.  */
end_comment

begin_function
specifier|static
name|struct
name|secasvar
modifier|*
name|key_checkspidup
parameter_list|(
name|saidx
parameter_list|,
name|spi
parameter_list|)
name|struct
name|secasindex
modifier|*
name|saidx
decl_stmt|;
name|u_int32_t
name|spi
decl_stmt|;
block|{
name|struct
name|secashead
modifier|*
name|sah
decl_stmt|;
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|;
comment|/* check address family */
if|if
condition|(
name|saidx
operator|->
name|src
operator|.
name|ss_family
operator|!=
name|saidx
operator|->
name|dst
operator|.
name|ss_family
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_checkspidup: address family mismatched.\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* check all SAD */
name|LIST_FOREACH
argument_list|(
argument|sah
argument_list|,
argument|&sahtree
argument_list|,
argument|chain
argument_list|)
block|{
if|if
condition|(
operator|!
name|key_ismyaddr
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sah
operator|->
name|saidx
operator|.
name|dst
argument_list|)
condition|)
continue|continue;
name|sav
operator|=
name|key_getsavbyspi
argument_list|(
name|sah
argument_list|,
name|spi
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|!=
name|NULL
condition|)
return|return
name|sav
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * search SAD litmited alive SA, protocol, SPI.  * OUT:  *	NULL	: not found  *	others	: found, pointer to a SA.  */
end_comment

begin_function
specifier|static
name|struct
name|secasvar
modifier|*
name|key_getsavbyspi
parameter_list|(
name|sah
parameter_list|,
name|spi
parameter_list|)
name|struct
name|secashead
modifier|*
name|sah
decl_stmt|;
name|u_int32_t
name|spi
decl_stmt|;
block|{
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|;
name|u_int
name|stateidx
decl_stmt|,
name|state
decl_stmt|;
comment|/* search all status */
for|for
control|(
name|stateidx
operator|=
literal|0
init|;
name|stateidx
operator|<
name|_ARRAYLEN
argument_list|(
name|saorder_state_alive
argument_list|)
condition|;
name|stateidx
operator|++
control|)
block|{
name|state
operator|=
name|saorder_state_alive
index|[
name|stateidx
index|]
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|sav
argument_list|,
argument|&sah->savtree[state]
argument_list|,
argument|chain
argument_list|)
block|{
comment|/* sanity check */
if|if
condition|(
name|sav
operator|->
name|state
operator|!=
name|state
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_getsavbyspi: "
literal|"invalid sav->state (queue: %d SA: %d)\n"
operator|,
name|state
operator|,
name|sav
operator|->
name|state
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|sav
operator|->
name|spi
operator|==
name|spi
condition|)
return|return
name|sav
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * copy SA values from PF_KEY message except *SPI, SEQ, PID, STATE and TYPE*.  * You must update these if need.  * OUT:	0:	success.  *	!0:	failure.  *  * does not modify mbuf.  does not free mbuf on error.  */
end_comment

begin_function
specifier|static
name|int
name|key_setsaval
parameter_list|(
name|sav
parameter_list|,
name|m
parameter_list|,
name|mhp
parameter_list|)
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|const
name|struct
name|sadb_msghdr
modifier|*
name|mhp
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|IPSEC_ESP
specifier|const
name|struct
name|esp_algorithm
modifier|*
name|algo
decl_stmt|;
endif|#
directive|endif
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
comment|/* sanity check */
if|if
condition|(
name|m
operator|==
name|NULL
operator|||
name|mhp
operator|==
name|NULL
operator|||
name|mhp
operator|->
name|msg
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_setsaval: NULL pointer is passed.\n"
argument_list|)
expr_stmt|;
comment|/* initialization */
name|sav
operator|->
name|replay
operator|=
name|NULL
expr_stmt|;
name|sav
operator|->
name|key_auth
operator|=
name|NULL
expr_stmt|;
name|sav
operator|->
name|key_enc
operator|=
name|NULL
expr_stmt|;
name|sav
operator|->
name|sched
operator|=
name|NULL
expr_stmt|;
name|sav
operator|->
name|schedlen
operator|=
literal|0
expr_stmt|;
name|sav
operator|->
name|iv
operator|=
name|NULL
expr_stmt|;
name|sav
operator|->
name|lft_c
operator|=
name|NULL
expr_stmt|;
name|sav
operator|->
name|lft_h
operator|=
name|NULL
expr_stmt|;
name|sav
operator|->
name|lft_s
operator|=
name|NULL
expr_stmt|;
comment|/* SA */
if|if
condition|(
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_SA
index|]
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|struct
name|sadb_sa
modifier|*
name|sa0
decl_stmt|;
name|sa0
operator|=
operator|(
specifier|const
expr|struct
name|sadb_sa
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_SA
index|]
expr_stmt|;
if|if
condition|(
name|mhp
operator|->
name|extlen
index|[
name|SADB_EXT_SA
index|]
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|sa0
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|sav
operator|->
name|alg_auth
operator|=
name|sa0
operator|->
name|sadb_sa_auth
expr_stmt|;
name|sav
operator|->
name|alg_enc
operator|=
name|sa0
operator|->
name|sadb_sa_encrypt
expr_stmt|;
name|sav
operator|->
name|flags
operator|=
name|sa0
operator|->
name|sadb_sa_flags
expr_stmt|;
comment|/* replay window */
if|if
condition|(
operator|(
name|sa0
operator|->
name|sadb_sa_flags
operator|&
name|SADB_X_EXT_OLD
operator|)
operator|==
literal|0
condition|)
block|{
name|sav
operator|->
name|replay
operator|=
name|keydb_newsecreplay
argument_list|(
name|sa0
operator|->
name|sadb_sa_replay
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|replay
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_setsaval: No more memory.\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
block|}
comment|/* Authentication keys */
if|if
condition|(
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_KEY_AUTH
index|]
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|struct
name|sadb_key
modifier|*
name|key0
decl_stmt|;
name|int
name|len
decl_stmt|;
name|key0
operator|=
operator|(
specifier|const
expr|struct
name|sadb_key
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_KEY_AUTH
index|]
expr_stmt|;
name|len
operator|=
name|mhp
operator|->
name|extlen
index|[
name|SADB_EXT_KEY_AUTH
index|]
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|key0
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
switch|switch
condition|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_satype
condition|)
block|{
case|case
name|SADB_SATYPE_AH
case|:
case|case
name|SADB_SATYPE_ESP
case|:
if|if
condition|(
name|len
operator|==
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_key
argument_list|)
argument_list|)
operator|&&
name|sav
operator|->
name|alg_auth
operator|!=
name|SADB_X_AALG_NULL
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|SADB_X_SATYPE_IPCOMP
case|:
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_setsaval: invalid key_auth values.\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|sav
operator|->
name|key_auth
operator|=
operator|(
expr|struct
name|sadb_key
operator|*
operator|)
name|key_newbuf
argument_list|(
name|key0
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|key_auth
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_setsaval: No more memory.\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
comment|/* Encryption key */
if|if
condition|(
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_KEY_ENCRYPT
index|]
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|struct
name|sadb_key
modifier|*
name|key0
decl_stmt|;
name|int
name|len
decl_stmt|;
name|key0
operator|=
operator|(
specifier|const
expr|struct
name|sadb_key
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_KEY_ENCRYPT
index|]
expr_stmt|;
name|len
operator|=
name|mhp
operator|->
name|extlen
index|[
name|SADB_EXT_KEY_ENCRYPT
index|]
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|key0
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
switch|switch
condition|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_satype
condition|)
block|{
case|case
name|SADB_SATYPE_ESP
case|:
if|if
condition|(
name|len
operator|==
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_key
argument_list|)
argument_list|)
operator|&&
name|sav
operator|->
name|alg_enc
operator|!=
name|SADB_EALG_NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|sav
operator|->
name|key_enc
operator|=
operator|(
expr|struct
name|sadb_key
operator|*
operator|)
name|key_newbuf
argument_list|(
name|key0
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|key_enc
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_setsaval: No more memory.\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
break|break;
case|case
name|SADB_X_SATYPE_IPCOMP
case|:
if|if
condition|(
name|len
operator|!=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_key
argument_list|)
argument_list|)
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
name|sav
operator|->
name|key_enc
operator|=
name|NULL
expr_stmt|;
comment|/*just in case*/
break|break;
case|case
name|SADB_SATYPE_AH
case|:
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_setsatval: invalid key_enc value.\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
comment|/* set iv */
name|sav
operator|->
name|ivlen
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_satype
condition|)
block|{
case|case
name|SADB_SATYPE_ESP
case|:
ifdef|#
directive|ifdef
name|IPSEC_ESP
name|algo
operator|=
name|esp_algorithm_lookup
argument_list|(
name|sav
operator|->
name|alg_enc
argument_list|)
expr_stmt|;
if|if
condition|(
name|algo
operator|&&
name|algo
operator|->
name|ivlen
condition|)
name|sav
operator|->
name|ivlen
operator|=
call|(
modifier|*
name|algo
operator|->
name|ivlen
call|)
argument_list|(
name|algo
argument_list|,
name|sav
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|ivlen
operator|==
literal|0
condition|)
break|break;
name|KMALLOC
argument_list|(
name|sav
operator|->
name|iv
argument_list|,
name|caddr_t
argument_list|,
name|sav
operator|->
name|ivlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|iv
operator|==
literal|0
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_setsaval: No more memory.\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* initialize */
name|key_randomfill
argument_list|(
name|sav
operator|->
name|iv
argument_list|,
name|sav
operator|->
name|ivlen
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|SADB_SATYPE_AH
case|:
case|case
name|SADB_X_SATYPE_IPCOMP
case|:
break|break;
default|default:
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_setsaval: invalid SA type.\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* reset created */
name|microtime
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
name|sav
operator|->
name|created
operator|=
name|tv
operator|.
name|tv_sec
expr_stmt|;
comment|/* make lifetime for CURRENT */
name|KMALLOC
argument_list|(
name|sav
operator|->
name|lft_c
argument_list|,
expr|struct
name|sadb_lifetime
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_lifetime
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|lft_c
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_setsaval: No more memory.\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|microtime
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
name|sav
operator|->
name|lft_c
operator|->
name|sadb_lifetime_len
operator|=
name|PFKEY_UNIT64
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_lifetime
argument_list|)
argument_list|)
expr_stmt|;
name|sav
operator|->
name|lft_c
operator|->
name|sadb_lifetime_exttype
operator|=
name|SADB_EXT_LIFETIME_CURRENT
expr_stmt|;
name|sav
operator|->
name|lft_c
operator|->
name|sadb_lifetime_allocations
operator|=
literal|0
expr_stmt|;
name|sav
operator|->
name|lft_c
operator|->
name|sadb_lifetime_bytes
operator|=
literal|0
expr_stmt|;
name|sav
operator|->
name|lft_c
operator|->
name|sadb_lifetime_addtime
operator|=
name|tv
operator|.
name|tv_sec
expr_stmt|;
name|sav
operator|->
name|lft_c
operator|->
name|sadb_lifetime_usetime
operator|=
literal|0
expr_stmt|;
comment|/* lifetimes for HARD and SOFT */
block|{
specifier|const
name|struct
name|sadb_lifetime
modifier|*
name|lft0
decl_stmt|;
name|lft0
operator|=
operator|(
expr|struct
name|sadb_lifetime
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_LIFETIME_HARD
index|]
expr_stmt|;
if|if
condition|(
name|lft0
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|mhp
operator|->
name|extlen
index|[
name|SADB_EXT_LIFETIME_HARD
index|]
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|lft0
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|sav
operator|->
name|lft_h
operator|=
operator|(
expr|struct
name|sadb_lifetime
operator|*
operator|)
name|key_newbuf
argument_list|(
name|lft0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lft0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|lft_h
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_setsaval: No more memory.\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* to be initialize ? */
block|}
name|lft0
operator|=
operator|(
expr|struct
name|sadb_lifetime
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_LIFETIME_SOFT
index|]
expr_stmt|;
if|if
condition|(
name|lft0
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|mhp
operator|->
name|extlen
index|[
name|SADB_EXT_LIFETIME_SOFT
index|]
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|lft0
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|sav
operator|->
name|lft_s
operator|=
operator|(
expr|struct
name|sadb_lifetime
operator|*
operator|)
name|key_newbuf
argument_list|(
name|lft0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lft0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|lft_s
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_setsaval: No more memory.\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* to be initialize ? */
block|}
block|}
return|return
literal|0
return|;
name|fail
label|:
comment|/* initialization */
if|if
condition|(
name|sav
operator|->
name|replay
operator|!=
name|NULL
condition|)
block|{
name|keydb_delsecreplay
argument_list|(
name|sav
operator|->
name|replay
argument_list|)
expr_stmt|;
name|sav
operator|->
name|replay
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sav
operator|->
name|key_auth
operator|!=
name|NULL
condition|)
block|{
name|KFREE
argument_list|(
name|sav
operator|->
name|key_auth
argument_list|)
expr_stmt|;
name|sav
operator|->
name|key_auth
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sav
operator|->
name|key_enc
operator|!=
name|NULL
condition|)
block|{
name|KFREE
argument_list|(
name|sav
operator|->
name|key_enc
argument_list|)
expr_stmt|;
name|sav
operator|->
name|key_enc
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sav
operator|->
name|sched
condition|)
block|{
name|KFREE
argument_list|(
name|sav
operator|->
name|sched
argument_list|)
expr_stmt|;
name|sav
operator|->
name|sched
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sav
operator|->
name|iv
operator|!=
name|NULL
condition|)
block|{
name|KFREE
argument_list|(
name|sav
operator|->
name|iv
argument_list|)
expr_stmt|;
name|sav
operator|->
name|iv
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sav
operator|->
name|lft_c
operator|!=
name|NULL
condition|)
block|{
name|KFREE
argument_list|(
name|sav
operator|->
name|lft_c
argument_list|)
expr_stmt|;
name|sav
operator|->
name|lft_c
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sav
operator|->
name|lft_h
operator|!=
name|NULL
condition|)
block|{
name|KFREE
argument_list|(
name|sav
operator|->
name|lft_h
argument_list|)
expr_stmt|;
name|sav
operator|->
name|lft_h
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sav
operator|->
name|lft_s
operator|!=
name|NULL
condition|)
block|{
name|KFREE
argument_list|(
name|sav
operator|->
name|lft_s
argument_list|)
expr_stmt|;
name|sav
operator|->
name|lft_s
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * validation with a secasvar entry, and set SADB_SATYPE_MATURE.  * OUT:	0:	valid  *	other:	errno  */
end_comment

begin_function
specifier|static
name|int
name|key_mature
parameter_list|(
name|sav
parameter_list|)
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|;
block|{
name|int
name|mature
decl_stmt|;
name|int
name|checkmask
init|=
literal|0
decl_stmt|;
comment|/* 2^0: ealg  2^1: aalg  2^2: calg */
name|int
name|mustmask
init|=
literal|0
decl_stmt|;
comment|/* 2^0: ealg  2^1: aalg  2^2: calg */
name|mature
operator|=
literal|0
expr_stmt|;
comment|/* check SPI value */
switch|switch
condition|(
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|proto
condition|)
block|{
case|case
name|IPPROTO_ESP
case|:
case|case
name|IPPROTO_AH
case|:
if|if
condition|(
name|ntohl
argument_list|(
name|sav
operator|->
name|spi
argument_list|)
operator|>=
literal|0
operator|&&
name|ntohl
argument_list|(
name|sav
operator|->
name|spi
argument_list|)
operator|<=
literal|255
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_mature: illegal range of SPI %u.\n"
operator|,
operator|(
name|u_int32_t
operator|)
name|ntohl
argument_list|(
name|sav
operator|->
name|spi
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
break|break;
block|}
comment|/* check satype */
switch|switch
condition|(
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|proto
condition|)
block|{
case|case
name|IPPROTO_ESP
case|:
comment|/* check flags */
if|if
condition|(
operator|(
name|sav
operator|->
name|flags
operator|&
name|SADB_X_EXT_OLD
operator|)
operator|&&
operator|(
name|sav
operator|->
name|flags
operator|&
name|SADB_X_EXT_DERIV
operator|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_mature: "
literal|"invalid flag (derived) given to old-esp.\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
name|sav
operator|->
name|alg_auth
operator|==
name|SADB_AALG_NONE
condition|)
name|checkmask
operator|=
literal|1
expr_stmt|;
else|else
name|checkmask
operator|=
literal|3
expr_stmt|;
name|mustmask
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|IPPROTO_AH
case|:
comment|/* check flags */
if|if
condition|(
name|sav
operator|->
name|flags
operator|&
name|SADB_X_EXT_DERIV
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_mature: "
literal|"invalid flag (derived) given to AH SA.\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
name|sav
operator|->
name|alg_enc
operator|!=
name|SADB_EALG_NONE
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_mature: "
literal|"protocol and algorithm mismated.\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|checkmask
operator|=
literal|2
expr_stmt|;
name|mustmask
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|IPPROTO_IPCOMP
case|:
if|if
condition|(
name|sav
operator|->
name|alg_auth
operator|!=
name|SADB_AALG_NONE
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_mature: "
literal|"protocol and algorithm mismated.\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|sav
operator|->
name|flags
operator|&
name|SADB_X_EXT_RAWCPI
operator|)
operator|==
literal|0
operator|&&
name|ntohl
argument_list|(
name|sav
operator|->
name|spi
argument_list|)
operator|>=
literal|0x10000
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_mature: invalid cpi for IPComp.\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|checkmask
operator|=
literal|4
expr_stmt|;
name|mustmask
operator|=
literal|4
expr_stmt|;
break|break;
default|default:
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_mature: Invalid satype.\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|EPROTONOSUPPORT
return|;
block|}
comment|/* check authentication algorithm */
if|if
condition|(
operator|(
name|checkmask
operator|&
literal|2
operator|)
operator|!=
literal|0
condition|)
block|{
specifier|const
name|struct
name|ah_algorithm
modifier|*
name|algo
decl_stmt|;
name|int
name|keylen
decl_stmt|;
name|algo
operator|=
name|ah_algorithm_lookup
argument_list|(
name|sav
operator|->
name|alg_auth
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|algo
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_mature: "
literal|"unknown authentication algorithm.\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
comment|/* algorithm-dependent check */
if|if
condition|(
name|sav
operator|->
name|key_auth
condition|)
name|keylen
operator|=
name|sav
operator|->
name|key_auth
operator|->
name|sadb_key_bits
expr_stmt|;
else|else
name|keylen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|keylen
operator|<
name|algo
operator|->
name|keymin
operator|||
name|algo
operator|->
name|keymax
operator|<
name|keylen
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_mature: invalid AH key length %d "
literal|"(%d-%d allowed)\n"
operator|,
name|keylen
operator|,
name|algo
operator|->
name|keymin
operator|,
name|algo
operator|->
name|keymax
operator|)
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
name|algo
operator|->
name|mature
condition|)
block|{
if|if
condition|(
call|(
modifier|*
name|algo
operator|->
name|mature
call|)
argument_list|(
name|sav
argument_list|)
condition|)
block|{
comment|/* message generated in per-algorithm function*/
return|return
name|EINVAL
return|;
block|}
else|else
name|mature
operator|=
name|SADB_SATYPE_AH
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|mustmask
operator|&
literal|2
operator|)
operator|!=
literal|0
operator|&&
name|mature
operator|!=
name|SADB_SATYPE_AH
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_mature: no satisfy algorithm for AH\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
block|}
comment|/* check encryption algorithm */
if|if
condition|(
operator|(
name|checkmask
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|IPSEC_ESP
specifier|const
name|struct
name|esp_algorithm
modifier|*
name|algo
decl_stmt|;
name|int
name|keylen
decl_stmt|;
name|algo
operator|=
name|esp_algorithm_lookup
argument_list|(
name|sav
operator|->
name|alg_enc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|algo
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_mature: unknown encryption algorithm.\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
comment|/* algorithm-dependent check */
if|if
condition|(
name|sav
operator|->
name|key_enc
condition|)
name|keylen
operator|=
name|sav
operator|->
name|key_enc
operator|->
name|sadb_key_bits
expr_stmt|;
else|else
name|keylen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|keylen
operator|<
name|algo
operator|->
name|keymin
operator|||
name|algo
operator|->
name|keymax
operator|<
name|keylen
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_mature: invalid ESP key length %d "
literal|"(%d-%d allowed)\n"
operator|,
name|keylen
operator|,
name|algo
operator|->
name|keymin
operator|,
name|algo
operator|->
name|keymax
operator|)
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
name|algo
operator|->
name|mature
condition|)
block|{
if|if
condition|(
call|(
modifier|*
name|algo
operator|->
name|mature
call|)
argument_list|(
name|sav
argument_list|)
condition|)
block|{
comment|/* message generated in per-algorithm function*/
return|return
name|EINVAL
return|;
block|}
else|else
name|mature
operator|=
name|SADB_SATYPE_ESP
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|mustmask
operator|&
literal|1
operator|)
operator|!=
literal|0
operator|&&
name|mature
operator|!=
name|SADB_SATYPE_ESP
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_mature: no satisfy algorithm for ESP\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
else|#
directive|else
comment|/*IPSEC_ESP*/
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_mature: ESP not supported in this configuration\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
endif|#
directive|endif
block|}
comment|/* check compression algorithm */
if|if
condition|(
operator|(
name|checkmask
operator|&
literal|4
operator|)
operator|!=
literal|0
condition|)
block|{
specifier|const
name|struct
name|ipcomp_algorithm
modifier|*
name|algo
decl_stmt|;
comment|/* algorithm-dependent check */
name|algo
operator|=
name|ipcomp_algorithm_lookup
argument_list|(
name|sav
operator|->
name|alg_enc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|algo
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_mature: unknown compression algorithm.\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
block|}
name|key_sa_chgstate
argument_list|(
name|sav
argument_list|,
name|SADB_SASTATE_MATURE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * subroutine for SADB_GET and SADB_DUMP.  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|key_setdumpsa
parameter_list|(
name|sav
parameter_list|,
name|type
parameter_list|,
name|satype
parameter_list|,
name|seq
parameter_list|,
name|pid
parameter_list|)
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|;
name|u_int8_t
name|type
decl_stmt|,
name|satype
decl_stmt|;
name|u_int32_t
name|seq
decl_stmt|,
name|pid
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|result
init|=
name|NULL
decl_stmt|,
modifier|*
name|tres
init|=
name|NULL
decl_stmt|,
modifier|*
name|m
decl_stmt|;
name|int
name|l
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|void
modifier|*
name|p
decl_stmt|;
name|int
name|dumporder
index|[]
init|=
block|{
name|SADB_EXT_SA
block|,
name|SADB_X_EXT_SA2
block|,
name|SADB_EXT_LIFETIME_HARD
block|,
name|SADB_EXT_LIFETIME_SOFT
block|,
name|SADB_EXT_LIFETIME_CURRENT
block|,
name|SADB_EXT_ADDRESS_SRC
block|,
name|SADB_EXT_ADDRESS_DST
block|,
name|SADB_EXT_ADDRESS_PROXY
block|,
name|SADB_EXT_KEY_AUTH
block|,
name|SADB_EXT_KEY_ENCRYPT
block|,
name|SADB_EXT_IDENTITY_SRC
block|,
name|SADB_EXT_IDENTITY_DST
block|,
name|SADB_EXT_SENSITIVITY
block|, 	}
decl_stmt|;
name|m
operator|=
name|key_setsadbmsg
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
name|satype
argument_list|,
name|seq
argument_list|,
name|pid
argument_list|,
name|sav
operator|->
name|refcnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
name|result
operator|=
name|m
expr_stmt|;
for|for
control|(
name|i
operator|=
sizeof|sizeof
argument_list|(
name|dumporder
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|dumporder
index|[
literal|0
index|]
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|m
operator|=
name|NULL
expr_stmt|;
name|p
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|dumporder
index|[
name|i
index|]
condition|)
block|{
case|case
name|SADB_EXT_SA
case|:
name|m
operator|=
name|key_setsadbsa
argument_list|(
name|sav
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
goto|goto
name|fail
goto|;
break|break;
case|case
name|SADB_X_EXT_SA2
case|:
name|m
operator|=
name|key_setsadbxsa2
argument_list|(
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|mode
argument_list|,
name|sav
operator|->
name|replay
condition|?
name|sav
operator|->
name|replay
operator|->
name|count
else|:
literal|0
argument_list|,
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|reqid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
goto|goto
name|fail
goto|;
break|break;
case|case
name|SADB_EXT_ADDRESS_SRC
case|:
name|m
operator|=
name|key_setsadbaddr
argument_list|(
name|SADB_EXT_ADDRESS_SRC
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|src
argument_list|,
name|FULLMASK
argument_list|,
name|IPSEC_ULPROTO_ANY
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
goto|goto
name|fail
goto|;
break|break;
case|case
name|SADB_EXT_ADDRESS_DST
case|:
name|m
operator|=
name|key_setsadbaddr
argument_list|(
name|SADB_EXT_ADDRESS_DST
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|dst
argument_list|,
name|FULLMASK
argument_list|,
name|IPSEC_ULPROTO_ANY
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
goto|goto
name|fail
goto|;
break|break;
case|case
name|SADB_EXT_KEY_AUTH
case|:
if|if
condition|(
operator|!
name|sav
operator|->
name|key_auth
condition|)
continue|continue;
name|l
operator|=
name|PFKEY_UNUNIT64
argument_list|(
name|sav
operator|->
name|key_auth
operator|->
name|sadb_key_len
argument_list|)
expr_stmt|;
name|p
operator|=
name|sav
operator|->
name|key_auth
expr_stmt|;
break|break;
case|case
name|SADB_EXT_KEY_ENCRYPT
case|:
if|if
condition|(
operator|!
name|sav
operator|->
name|key_enc
condition|)
continue|continue;
name|l
operator|=
name|PFKEY_UNUNIT64
argument_list|(
name|sav
operator|->
name|key_enc
operator|->
name|sadb_key_len
argument_list|)
expr_stmt|;
name|p
operator|=
name|sav
operator|->
name|key_enc
expr_stmt|;
break|break;
case|case
name|SADB_EXT_LIFETIME_CURRENT
case|:
if|if
condition|(
operator|!
name|sav
operator|->
name|lft_c
condition|)
continue|continue;
name|l
operator|=
name|PFKEY_UNUNIT64
argument_list|(
operator|(
operator|(
expr|struct
name|sadb_ext
operator|*
operator|)
name|sav
operator|->
name|lft_c
operator|)
operator|->
name|sadb_ext_len
argument_list|)
expr_stmt|;
name|p
operator|=
name|sav
operator|->
name|lft_c
expr_stmt|;
break|break;
case|case
name|SADB_EXT_LIFETIME_HARD
case|:
if|if
condition|(
operator|!
name|sav
operator|->
name|lft_h
condition|)
continue|continue;
name|l
operator|=
name|PFKEY_UNUNIT64
argument_list|(
operator|(
operator|(
expr|struct
name|sadb_ext
operator|*
operator|)
name|sav
operator|->
name|lft_h
operator|)
operator|->
name|sadb_ext_len
argument_list|)
expr_stmt|;
name|p
operator|=
name|sav
operator|->
name|lft_h
expr_stmt|;
break|break;
case|case
name|SADB_EXT_LIFETIME_SOFT
case|:
if|if
condition|(
operator|!
name|sav
operator|->
name|lft_s
condition|)
continue|continue;
name|l
operator|=
name|PFKEY_UNUNIT64
argument_list|(
operator|(
operator|(
expr|struct
name|sadb_ext
operator|*
operator|)
name|sav
operator|->
name|lft_s
operator|)
operator|->
name|sadb_ext_len
argument_list|)
expr_stmt|;
name|p
operator|=
name|sav
operator|->
name|lft_s
expr_stmt|;
break|break;
case|case
name|SADB_EXT_ADDRESS_PROXY
case|:
case|case
name|SADB_EXT_IDENTITY_SRC
case|:
case|case
name|SADB_EXT_IDENTITY_DST
case|:
comment|/* XXX: should we brought from SPD ? */
case|case
name|SADB_EXT_SENSITIVITY
case|:
default|default:
continue|continue;
block|}
if|if
condition|(
operator|(
operator|!
name|m
operator|&&
operator|!
name|p
operator|)
operator|||
operator|(
name|m
operator|&&
name|p
operator|)
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|p
operator|&&
name|tres
condition|)
block|{
name|M_PREPEND
argument_list|(
name|tres
argument_list|,
name|l
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tres
condition|)
goto|goto
name|fail
goto|;
name|bcopy
argument_list|(
name|p
argument_list|,
name|mtod
argument_list|(
name|tres
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|l
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|p
condition|)
block|{
name|m
operator|=
name|key_alloc_mbuf
argument_list|(
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
goto|goto
name|fail
goto|;
name|m_copyback
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|l
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tres
condition|)
name|m_cat
argument_list|(
name|m
argument_list|,
name|tres
argument_list|)
expr_stmt|;
name|tres
operator|=
name|m
expr_stmt|;
block|}
name|m_cat
argument_list|(
name|result
argument_list|,
name|tres
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
condition|)
block|{
name|result
operator|=
name|m_pullup
argument_list|(
name|result
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
block|}
name|result
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|m
operator|=
name|result
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
name|result
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|mtod
argument_list|(
name|result
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|)
operator|->
name|sadb_msg_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|result
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
return|return
name|result
return|;
name|fail
label|:
name|m_freem
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|tres
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * set data into sadb_msg.  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|key_setsadbmsg
parameter_list|(
name|type
parameter_list|,
name|tlen
parameter_list|,
name|satype
parameter_list|,
name|seq
parameter_list|,
name|pid
parameter_list|,
name|reserved
parameter_list|)
name|u_int8_t
name|type
decl_stmt|,
name|satype
decl_stmt|;
name|u_int16_t
name|tlen
decl_stmt|;
name|u_int32_t
name|seq
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|u_int16_t
name|reserved
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|sadb_msg
modifier|*
name|p
decl_stmt|;
name|int
name|len
decl_stmt|;
name|len
operator|=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|MCLBYTES
condition|)
return|return
name|NULL
return|;
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|&&
name|len
operator|>
name|MHLEN
condition|)
block|{
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|m
condition|)
return|return
name|NULL
return|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
name|p
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|p
operator|->
name|sadb_msg_version
operator|=
name|PF_KEY_V2
expr_stmt|;
name|p
operator|->
name|sadb_msg_type
operator|=
name|type
expr_stmt|;
name|p
operator|->
name|sadb_msg_errno
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|sadb_msg_satype
operator|=
name|satype
expr_stmt|;
name|p
operator|->
name|sadb_msg_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|tlen
argument_list|)
expr_stmt|;
name|p
operator|->
name|sadb_msg_reserved
operator|=
name|reserved
expr_stmt|;
name|p
operator|->
name|sadb_msg_seq
operator|=
name|seq
expr_stmt|;
name|p
operator|->
name|sadb_msg_pid
operator|=
operator|(
name|u_int32_t
operator|)
name|pid
expr_stmt|;
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/*  * copy secasvar data into sadb_address.  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|key_setsadbsa
parameter_list|(
name|sav
parameter_list|)
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|sadb_sa
modifier|*
name|p
decl_stmt|;
name|int
name|len
decl_stmt|;
name|len
operator|=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_sa
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|=
name|key_alloc_mbuf
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
operator|||
name|m
operator|->
name|m_next
condition|)
block|{
comment|/*XXX*/
if|if
condition|(
name|m
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|p
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sadb_sa
operator|*
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|p
operator|->
name|sadb_sa_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|p
operator|->
name|sadb_sa_exttype
operator|=
name|SADB_EXT_SA
expr_stmt|;
name|p
operator|->
name|sadb_sa_spi
operator|=
name|sav
operator|->
name|spi
expr_stmt|;
name|p
operator|->
name|sadb_sa_replay
operator|=
operator|(
name|sav
operator|->
name|replay
operator|!=
name|NULL
condition|?
name|sav
operator|->
name|replay
operator|->
name|wsize
else|:
literal|0
operator|)
expr_stmt|;
name|p
operator|->
name|sadb_sa_state
operator|=
name|sav
operator|->
name|state
expr_stmt|;
name|p
operator|->
name|sadb_sa_auth
operator|=
name|sav
operator|->
name|alg_auth
expr_stmt|;
name|p
operator|->
name|sadb_sa_encrypt
operator|=
name|sav
operator|->
name|alg_enc
expr_stmt|;
name|p
operator|->
name|sadb_sa_flags
operator|=
name|sav
operator|->
name|flags
expr_stmt|;
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/*  * set data into sadb_address.  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|key_setsadbaddr
parameter_list|(
name|exttype
parameter_list|,
name|saddr
parameter_list|,
name|prefixlen
parameter_list|,
name|ul_proto
parameter_list|)
name|u_int16_t
name|exttype
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|saddr
decl_stmt|;
name|u_int8_t
name|prefixlen
decl_stmt|;
name|u_int16_t
name|ul_proto
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|sadb_address
modifier|*
name|p
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|len
operator|=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_address
argument_list|)
argument_list|)
operator|+
name|PFKEY_ALIGN8
argument_list|(
name|saddr
operator|->
name|sa_len
argument_list|)
expr_stmt|;
name|m
operator|=
name|key_alloc_mbuf
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
operator|||
name|m
operator|->
name|m_next
condition|)
block|{
comment|/*XXX*/
if|if
condition|(
name|m
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|p
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sadb_address
operator|*
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|p
operator|->
name|sadb_address_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|p
operator|->
name|sadb_address_exttype
operator|=
name|exttype
expr_stmt|;
name|p
operator|->
name|sadb_address_proto
operator|=
name|ul_proto
expr_stmt|;
if|if
condition|(
name|prefixlen
operator|==
name|FULLMASK
condition|)
block|{
switch|switch
condition|(
name|saddr
operator|->
name|sa_family
condition|)
block|{
case|case
name|AF_INET
case|:
name|prefixlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
operator|<<
literal|3
expr_stmt|;
break|break;
case|case
name|AF_INET6
case|:
name|prefixlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
operator|<<
literal|3
expr_stmt|;
break|break;
default|default:
empty_stmt|;
comment|/*XXX*/
block|}
block|}
name|p
operator|->
name|sadb_address_prefixlen
operator|=
name|prefixlen
expr_stmt|;
name|p
operator|->
name|sadb_address_reserved
operator|=
literal|0
expr_stmt|;
name|bcopy
argument_list|(
name|saddr
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_address
argument_list|)
argument_list|)
argument_list|,
name|saddr
operator|->
name|sa_len
argument_list|)
expr_stmt|;
return|return
name|m
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*  * set data into sadb_ident.  */
end_comment

begin_comment
unit|static struct mbuf * key_setsadbident(exttype, idtype, string, stringlen, id) 	u_int16_t exttype, idtype; 	caddr_t string; 	int stringlen; 	u_int64_t id; { 	struct mbuf *m; 	struct sadb_ident *p; 	size_t len;  	len = PFKEY_ALIGN8(sizeof(struct sadb_ident)) + PFKEY_ALIGN8(stringlen); 	m = key_alloc_mbuf(len); 	if (!m || m->m_next) {
comment|/*XXX*/
end_comment

begin_endif
unit|if (m) 			m_freem(m); 		return NULL; 	}  	p = mtod(m, struct sadb_ident *);  	bzero(p, len); 	p->sadb_ident_len = PFKEY_UNIT64(len); 	p->sadb_ident_exttype = exttype; 	p->sadb_ident_type = idtype; 	p->sadb_ident_reserved = 0; 	p->sadb_ident_id = id;  	bcopy(string, 	    mtod(m, caddr_t) + PFKEY_ALIGN8(sizeof(struct sadb_ident)), 	    stringlen);  	return m; }
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * set data into sadb_x_sa2.  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|key_setsadbxsa2
parameter_list|(
name|mode
parameter_list|,
name|seq
parameter_list|,
name|reqid
parameter_list|)
name|u_int8_t
name|mode
decl_stmt|;
name|u_int32_t
name|seq
decl_stmt|,
name|reqid
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|sadb_x_sa2
modifier|*
name|p
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|len
operator|=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_x_sa2
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|=
name|key_alloc_mbuf
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
operator|||
name|m
operator|->
name|m_next
condition|)
block|{
comment|/*XXX*/
if|if
condition|(
name|m
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|p
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sadb_x_sa2
operator|*
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|p
operator|->
name|sadb_x_sa2_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|p
operator|->
name|sadb_x_sa2_exttype
operator|=
name|SADB_X_EXT_SA2
expr_stmt|;
name|p
operator|->
name|sadb_x_sa2_mode
operator|=
name|mode
expr_stmt|;
name|p
operator|->
name|sadb_x_sa2_reserved1
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|sadb_x_sa2_reserved2
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|sadb_x_sa2_sequence
operator|=
name|seq
expr_stmt|;
name|p
operator|->
name|sadb_x_sa2_reqid
operator|=
name|reqid
expr_stmt|;
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/*  * set data into sadb_x_policy  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|key_setsadbxpolicy
parameter_list|(
name|type
parameter_list|,
name|dir
parameter_list|,
name|id
parameter_list|)
name|u_int16_t
name|type
decl_stmt|;
name|u_int8_t
name|dir
decl_stmt|;
name|u_int32_t
name|id
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|sadb_x_policy
modifier|*
name|p
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|len
operator|=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_x_policy
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|=
name|key_alloc_mbuf
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
operator|||
name|m
operator|->
name|m_next
condition|)
block|{
comment|/*XXX*/
if|if
condition|(
name|m
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|p
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sadb_x_policy
operator|*
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|p
operator|->
name|sadb_x_policy_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|p
operator|->
name|sadb_x_policy_exttype
operator|=
name|SADB_X_EXT_POLICY
expr_stmt|;
name|p
operator|->
name|sadb_x_policy_type
operator|=
name|type
expr_stmt|;
name|p
operator|->
name|sadb_x_policy_dir
operator|=
name|dir
expr_stmt|;
name|p
operator|->
name|sadb_x_policy_id
operator|=
name|id
expr_stmt|;
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/* %%% utilities */
end_comment

begin_comment
comment|/*  * copy a buffer into the new buffer allocated.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|key_newbuf
parameter_list|(
name|src
parameter_list|,
name|len
parameter_list|)
specifier|const
name|void
modifier|*
name|src
decl_stmt|;
name|u_int
name|len
decl_stmt|;
block|{
name|caddr_t
name|new
decl_stmt|;
name|KMALLOC
argument_list|(
name|new
argument_list|,
name|caddr_t
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_newbuf: No more memory.\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|bcopy
argument_list|(
name|src
argument_list|,
name|new
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/* compare my own address  * OUT:	1: true, i.e. my address.  *	0: false  */
end_comment

begin_function
name|int
name|key_ismyaddr
parameter_list|(
name|sa
parameter_list|)
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|INET
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|struct
name|in_ifaddr
modifier|*
name|ia
decl_stmt|;
endif|#
directive|endif
comment|/* sanity check */
if|if
condition|(
name|sa
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_ismyaddr: NULL pointer is passed.\n"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sa
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sa
expr_stmt|;
for|for
control|(
name|ia
operator|=
name|in_ifaddrhead
operator|.
name|tqh_first
init|;
name|ia
condition|;
name|ia
operator|=
name|ia
operator|->
name|ia_link
operator|.
name|tqe_next
control|)
block|{
if|if
condition|(
name|sin
operator|->
name|sin_family
operator|==
name|ia
operator|->
name|ia_addr
operator|.
name|sin_family
operator|&&
name|sin
operator|->
name|sin_len
operator|==
name|ia
operator|->
name|ia_addr
operator|.
name|sin_len
operator|&&
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
name|ia
operator|->
name|ia_addr
operator|.
name|sin_addr
operator|.
name|s_addr
condition|)
block|{
return|return
literal|1
return|;
block|}
block|}
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
return|return
name|key_ismyaddr6
argument_list|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sa
argument_list|)
return|;
endif|#
directive|endif
block|}
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_comment
comment|/*  * compare my own address for IPv6.  * 1: ours  * 0: other  * NOTE: derived ip6_input() in KAME. This is necessary to modify more.  */
end_comment

begin_include
include|#
directive|include
file|<netinet6/in6_var.h>
end_include

begin_function
specifier|static
name|int
name|key_ismyaddr6
parameter_list|(
name|sin6
parameter_list|)
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
block|{
name|struct
name|in6_ifaddr
modifier|*
name|ia
decl_stmt|;
name|struct
name|in6_multi
modifier|*
name|in6m
decl_stmt|;
for|for
control|(
name|ia
operator|=
name|in6_ifaddr
init|;
name|ia
condition|;
name|ia
operator|=
name|ia
operator|->
name|ia_next
control|)
block|{
if|if
condition|(
name|key_sockaddrcmp
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin6
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ia
operator|->
name|ia_addr
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
comment|/* 		 * XXX Multicast 		 * XXX why do we care about multlicast here while we don't care 		 * about IPv4 multicast?? 		 * XXX scope 		 */
name|in6m
operator|=
name|NULL
expr_stmt|;
name|IN6_LOOKUP_MULTI
argument_list|(
name|sin6
operator|->
name|sin6_addr
argument_list|,
name|ia
operator|->
name|ia_ifp
argument_list|,
name|in6m
argument_list|)
expr_stmt|;
if|if
condition|(
name|in6m
condition|)
return|return
literal|1
return|;
block|}
comment|/* loopback, just for safety */
if|if
condition|(
name|IN6_IS_ADDR_LOOPBACK
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*INET6*/
end_comment

begin_comment
comment|/*  * compare two secasindex structure.  * flag can specify to compare 2 saidxes.  * compare two secasindex structure without both mode and reqid.  * don't compare port.  * IN:    *      saidx0: source, it can be in SAD.  *      saidx1: object.  * OUT:   *      1 : equal  *      0 : not equal  */
end_comment

begin_function
specifier|static
name|int
name|key_cmpsaidx
parameter_list|(
name|saidx0
parameter_list|,
name|saidx1
parameter_list|,
name|flag
parameter_list|)
name|struct
name|secasindex
modifier|*
name|saidx0
decl_stmt|,
decl|*
name|saidx1
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* sanity */
if|if
condition|(
name|saidx0
operator|==
name|NULL
operator|&&
name|saidx1
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|saidx0
operator|==
name|NULL
operator|||
name|saidx1
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|saidx0
operator|->
name|proto
operator|!=
name|saidx1
operator|->
name|proto
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|flag
operator|==
name|CMP_EXACTLY
condition|)
block|{
if|if
condition|(
name|saidx0
operator|->
name|mode
operator|!=
name|saidx1
operator|->
name|mode
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|saidx0
operator|->
name|reqid
operator|!=
name|saidx1
operator|->
name|reqid
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|bcmp
argument_list|(
operator|&
name|saidx0
operator|->
name|src
argument_list|,
operator|&
name|saidx1
operator|->
name|src
argument_list|,
name|saidx0
operator|->
name|src
operator|.
name|ss_len
argument_list|)
operator|!=
literal|0
operator|||
name|bcmp
argument_list|(
operator|&
name|saidx0
operator|->
name|dst
argument_list|,
operator|&
name|saidx1
operator|->
name|dst
argument_list|,
name|saidx0
operator|->
name|dst
operator|.
name|ss_len
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
block|}
else|else
block|{
comment|/* CMP_MODE_REQID, CMP_REQID, CMP_HEAD */
if|if
condition|(
name|flag
operator|==
name|CMP_MODE_REQID
operator|||
name|flag
operator|==
name|CMP_REQID
condition|)
block|{
comment|/* 			 * If reqid of SPD is non-zero, unique SA is required. 			 * The result must be of same reqid in this case. 			 */
if|if
condition|(
name|saidx1
operator|->
name|reqid
operator|!=
literal|0
operator|&&
name|saidx0
operator|->
name|reqid
operator|!=
name|saidx1
operator|->
name|reqid
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|flag
operator|==
name|CMP_MODE_REQID
condition|)
block|{
if|if
condition|(
name|saidx0
operator|->
name|mode
operator|!=
name|IPSEC_MODE_ANY
operator|&&
name|saidx0
operator|->
name|mode
operator|!=
name|saidx1
operator|->
name|mode
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|key_sockaddrcmp
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|saidx0
operator|->
name|src
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|saidx1
operator|->
name|src
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
name|key_sockaddrcmp
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|saidx0
operator|->
name|dst
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|saidx1
operator|->
name|dst
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/*  * compare two secindex structure exactly.  * IN:  *	spidx0: source, it is often in SPD.  *	spidx1: object, it is often from PFKEY message.  * OUT:  *	1 : equal  *	0 : not equal  */
end_comment

begin_function
specifier|static
name|int
name|key_cmpspidx_exactly
parameter_list|(
name|spidx0
parameter_list|,
name|spidx1
parameter_list|)
name|struct
name|secpolicyindex
modifier|*
name|spidx0
decl_stmt|,
decl|*
name|spidx1
decl_stmt|;
end_function

begin_block
block|{
comment|/* sanity */
if|if
condition|(
name|spidx0
operator|==
name|NULL
operator|&&
name|spidx1
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|spidx0
operator|==
name|NULL
operator|||
name|spidx1
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|spidx0
operator|->
name|prefs
operator|!=
name|spidx1
operator|->
name|prefs
operator|||
name|spidx0
operator|->
name|prefd
operator|!=
name|spidx1
operator|->
name|prefd
operator|||
name|spidx0
operator|->
name|ul_proto
operator|!=
name|spidx1
operator|->
name|ul_proto
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|key_sockaddrcmp
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|spidx0
operator|->
name|src
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|spidx1
operator|->
name|src
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
name|key_sockaddrcmp
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|spidx0
operator|->
name|dst
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|spidx1
operator|->
name|dst
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/*  * compare two secindex structure with mask.  * IN:  *	spidx0: source, it is often in SPD.  *	spidx1: object, it is often from IP header.  * OUT:  *	1 : equal  *	0 : not equal  */
end_comment

begin_function
specifier|static
name|int
name|key_cmpspidx_withmask
parameter_list|(
name|spidx0
parameter_list|,
name|spidx1
parameter_list|)
name|struct
name|secpolicyindex
modifier|*
name|spidx0
decl_stmt|,
decl|*
name|spidx1
decl_stmt|;
end_function

begin_block
block|{
comment|/* sanity */
if|if
condition|(
name|spidx0
operator|==
name|NULL
operator|&&
name|spidx1
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|spidx0
operator|==
name|NULL
operator|||
name|spidx1
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|spidx0
operator|->
name|src
operator|.
name|ss_family
operator|!=
name|spidx1
operator|->
name|src
operator|.
name|ss_family
operator|||
name|spidx0
operator|->
name|dst
operator|.
name|ss_family
operator|!=
name|spidx1
operator|->
name|dst
operator|.
name|ss_family
operator|||
name|spidx0
operator|->
name|src
operator|.
name|ss_len
operator|!=
name|spidx1
operator|->
name|src
operator|.
name|ss_len
operator|||
name|spidx0
operator|->
name|dst
operator|.
name|ss_len
operator|!=
name|spidx1
operator|->
name|dst
operator|.
name|ss_len
condition|)
return|return
literal|0
return|;
comment|/* if spidx.ul_proto == IPSEC_ULPROTO_ANY, ignore. */
if|if
condition|(
name|spidx0
operator|->
name|ul_proto
operator|!=
operator|(
name|u_int16_t
operator|)
name|IPSEC_ULPROTO_ANY
operator|&&
name|spidx0
operator|->
name|ul_proto
operator|!=
name|spidx1
operator|->
name|ul_proto
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|spidx0
operator|->
name|src
operator|.
name|ss_family
condition|)
block|{
case|case
name|AF_INET
case|:
if|if
condition|(
name|satosin
argument_list|(
operator|&
name|spidx0
operator|->
name|src
argument_list|)
operator|->
name|sin_port
operator|!=
name|IPSEC_PORT_ANY
operator|&&
name|satosin
argument_list|(
operator|&
name|spidx0
operator|->
name|src
argument_list|)
operator|->
name|sin_port
operator|!=
name|satosin
argument_list|(
operator|&
name|spidx1
operator|->
name|src
argument_list|)
operator|->
name|sin_port
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|key_bbcmp
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|satosin
argument_list|(
operator|&
name|spidx0
operator|->
name|src
argument_list|)
operator|->
name|sin_addr
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|satosin
argument_list|(
operator|&
name|spidx1
operator|->
name|src
argument_list|)
operator|->
name|sin_addr
argument_list|,
name|spidx0
operator|->
name|prefs
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
name|AF_INET6
case|:
if|if
condition|(
name|satosin6
argument_list|(
operator|&
name|spidx0
operator|->
name|src
argument_list|)
operator|->
name|sin6_port
operator|!=
name|IPSEC_PORT_ANY
operator|&&
name|satosin6
argument_list|(
operator|&
name|spidx0
operator|->
name|src
argument_list|)
operator|->
name|sin6_port
operator|!=
name|satosin6
argument_list|(
operator|&
name|spidx1
operator|->
name|src
argument_list|)
operator|->
name|sin6_port
condition|)
return|return
literal|0
return|;
comment|/* 		 * scope_id check. if sin6_scope_id is 0, we regard it 		 * as a wildcard scope, which matches any scope zone ID.  		 */
if|if
condition|(
name|satosin6
argument_list|(
operator|&
name|spidx0
operator|->
name|src
argument_list|)
operator|->
name|sin6_scope_id
operator|&&
name|satosin6
argument_list|(
operator|&
name|spidx1
operator|->
name|src
argument_list|)
operator|->
name|sin6_scope_id
operator|&&
name|satosin6
argument_list|(
operator|&
name|spidx0
operator|->
name|src
argument_list|)
operator|->
name|sin6_scope_id
operator|!=
name|satosin6
argument_list|(
operator|&
name|spidx1
operator|->
name|src
argument_list|)
operator|->
name|sin6_scope_id
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|key_bbcmp
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|satosin6
argument_list|(
operator|&
name|spidx0
operator|->
name|src
argument_list|)
operator|->
name|sin6_addr
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|satosin6
argument_list|(
operator|&
name|spidx1
operator|->
name|src
argument_list|)
operator|->
name|sin6_addr
argument_list|,
name|spidx0
operator|->
name|prefs
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
default|default:
comment|/* XXX */
if|if
condition|(
name|bcmp
argument_list|(
operator|&
name|spidx0
operator|->
name|src
argument_list|,
operator|&
name|spidx1
operator|->
name|src
argument_list|,
name|spidx0
operator|->
name|src
operator|.
name|ss_len
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
break|break;
block|}
switch|switch
condition|(
name|spidx0
operator|->
name|dst
operator|.
name|ss_family
condition|)
block|{
case|case
name|AF_INET
case|:
if|if
condition|(
name|satosin
argument_list|(
operator|&
name|spidx0
operator|->
name|dst
argument_list|)
operator|->
name|sin_port
operator|!=
name|IPSEC_PORT_ANY
operator|&&
name|satosin
argument_list|(
operator|&
name|spidx0
operator|->
name|dst
argument_list|)
operator|->
name|sin_port
operator|!=
name|satosin
argument_list|(
operator|&
name|spidx1
operator|->
name|dst
argument_list|)
operator|->
name|sin_port
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|key_bbcmp
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|satosin
argument_list|(
operator|&
name|spidx0
operator|->
name|dst
argument_list|)
operator|->
name|sin_addr
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|satosin
argument_list|(
operator|&
name|spidx1
operator|->
name|dst
argument_list|)
operator|->
name|sin_addr
argument_list|,
name|spidx0
operator|->
name|prefd
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
name|AF_INET6
case|:
if|if
condition|(
name|satosin6
argument_list|(
operator|&
name|spidx0
operator|->
name|dst
argument_list|)
operator|->
name|sin6_port
operator|!=
name|IPSEC_PORT_ANY
operator|&&
name|satosin6
argument_list|(
operator|&
name|spidx0
operator|->
name|dst
argument_list|)
operator|->
name|sin6_port
operator|!=
name|satosin6
argument_list|(
operator|&
name|spidx1
operator|->
name|dst
argument_list|)
operator|->
name|sin6_port
condition|)
return|return
literal|0
return|;
comment|/* 		 * scope_id check. if sin6_scope_id is 0, we regard it 		 * as a wildcard scope, which matches any scope zone ID.  		 */
if|if
condition|(
name|satosin6
argument_list|(
operator|&
name|spidx0
operator|->
name|src
argument_list|)
operator|->
name|sin6_scope_id
operator|&&
name|satosin6
argument_list|(
operator|&
name|spidx1
operator|->
name|src
argument_list|)
operator|->
name|sin6_scope_id
operator|&&
name|satosin6
argument_list|(
operator|&
name|spidx0
operator|->
name|dst
argument_list|)
operator|->
name|sin6_scope_id
operator|!=
name|satosin6
argument_list|(
operator|&
name|spidx1
operator|->
name|dst
argument_list|)
operator|->
name|sin6_scope_id
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|key_bbcmp
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|satosin6
argument_list|(
operator|&
name|spidx0
operator|->
name|dst
argument_list|)
operator|->
name|sin6_addr
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|satosin6
argument_list|(
operator|&
name|spidx1
operator|->
name|dst
argument_list|)
operator|->
name|sin6_addr
argument_list|,
name|spidx0
operator|->
name|prefd
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
default|default:
comment|/* XXX */
if|if
condition|(
name|bcmp
argument_list|(
operator|&
name|spidx0
operator|->
name|dst
argument_list|,
operator|&
name|spidx1
operator|->
name|dst
argument_list|,
name|spidx0
operator|->
name|dst
operator|.
name|ss_len
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
break|break;
block|}
comment|/* XXX Do we check other field ?  e.g. flowinfo */
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/* returns 0 on match */
end_comment

begin_function
specifier|static
name|int
name|key_sockaddrcmp
parameter_list|(
name|sa1
parameter_list|,
name|sa2
parameter_list|,
name|port
parameter_list|)
name|struct
name|sockaddr
modifier|*
name|sa1
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|sa2
decl_stmt|;
name|int
name|port
decl_stmt|;
block|{
if|if
condition|(
name|sa1
operator|->
name|sa_family
operator|!=
name|sa2
operator|->
name|sa_family
operator|||
name|sa1
operator|->
name|sa_len
operator|!=
name|sa2
operator|->
name|sa_len
condition|)
return|return
literal|1
return|;
switch|switch
condition|(
name|sa1
operator|->
name|sa_family
condition|)
block|{
case|case
name|AF_INET
case|:
if|if
condition|(
name|sa1
operator|->
name|sa_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|satosin
argument_list|(
name|sa1
argument_list|)
operator|->
name|sin_addr
operator|.
name|s_addr
operator|!=
name|satosin
argument_list|(
name|sa2
argument_list|)
operator|->
name|sin_addr
operator|.
name|s_addr
condition|)
block|{
return|return
literal|1
return|;
block|}
if|if
condition|(
name|port
operator|&&
name|satosin
argument_list|(
name|sa1
argument_list|)
operator|->
name|sin_port
operator|!=
name|satosin
argument_list|(
name|sa2
argument_list|)
operator|->
name|sin_port
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|AF_INET6
case|:
if|if
condition|(
name|sa1
operator|->
name|sa_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/*EINVAL*/
if|if
condition|(
name|satosin6
argument_list|(
name|sa1
argument_list|)
operator|->
name|sin6_scope_id
operator|!=
name|satosin6
argument_list|(
name|sa2
argument_list|)
operator|->
name|sin6_scope_id
condition|)
block|{
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|IN6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|satosin6
argument_list|(
name|sa1
argument_list|)
operator|->
name|sin6_addr
argument_list|,
operator|&
name|satosin6
argument_list|(
name|sa2
argument_list|)
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
return|return
literal|1
return|;
block|}
if|if
condition|(
name|port
operator|&&
name|satosin6
argument_list|(
name|sa1
argument_list|)
operator|->
name|sin6_port
operator|!=
name|satosin6
argument_list|(
name|sa2
argument_list|)
operator|->
name|sin6_port
condition|)
block|{
return|return
literal|1
return|;
block|}
default|default:
if|if
condition|(
name|bcmp
argument_list|(
name|sa1
argument_list|,
name|sa2
argument_list|,
name|sa1
operator|->
name|sa_len
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * compare two buffers with mask.  * IN:  *	addr1: source  *	addr2: object  *	bits:  Number of bits to compare  * OUT:  *	1 : equal  *	0 : not equal  */
end_comment

begin_function
specifier|static
name|int
name|key_bbcmp
parameter_list|(
name|p1
parameter_list|,
name|p2
parameter_list|,
name|bits
parameter_list|)
name|caddr_t
name|p1
decl_stmt|,
name|p2
decl_stmt|;
name|u_int
name|bits
decl_stmt|;
block|{
name|u_int8_t
name|mask
decl_stmt|;
comment|/* XXX: This could be considerably faster if we compare a word 	 * at a time, but it is complicated on LSB Endian machines */
comment|/* Handle null pointers */
if|if
condition|(
name|p1
operator|==
name|NULL
operator|||
name|p2
operator|==
name|NULL
condition|)
return|return
operator|(
name|p1
operator|==
name|p2
operator|)
return|;
while|while
condition|(
name|bits
operator|>=
literal|8
condition|)
block|{
if|if
condition|(
operator|*
name|p1
operator|++
operator|!=
operator|*
name|p2
operator|++
condition|)
return|return
literal|0
return|;
name|bits
operator|-=
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|bits
operator|>
literal|0
condition|)
block|{
name|mask
operator|=
operator|~
operator|(
operator|(
literal|1
operator|<<
operator|(
literal|8
operator|-
name|bits
operator|)
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|p1
operator|&
name|mask
operator|)
operator|!=
operator|(
operator|*
name|p2
operator|&
name|mask
operator|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
comment|/* Match! */
block|}
end_function

begin_comment
comment|/*  * time handler.  * scanning SPD and SAD to check status for each entries,  * and do to remove or to expire.  * XXX: year 2038 problem may remain.  */
end_comment

begin_function
name|void
name|key_timehandler
parameter_list|(
name|void
parameter_list|)
block|{
name|u_int
name|dir
decl_stmt|;
name|int
name|s
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|microtime
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
comment|/*called from softclock()*/
comment|/* SPD */
block|{
name|struct
name|secpolicy
modifier|*
name|sp
decl_stmt|,
modifier|*
name|nextsp
decl_stmt|;
for|for
control|(
name|dir
operator|=
literal|0
init|;
name|dir
operator|<
name|IPSEC_DIR_MAX
condition|;
name|dir
operator|++
control|)
block|{
for|for
control|(
name|sp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sptree
index|[
name|dir
index|]
argument_list|)
init|;
name|sp
operator|!=
name|NULL
condition|;
name|sp
operator|=
name|nextsp
control|)
block|{
name|nextsp
operator|=
name|LIST_NEXT
argument_list|(
name|sp
argument_list|,
name|chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|state
operator|==
name|IPSEC_SPSTATE_DEAD
condition|)
block|{
name|key_freesp
argument_list|(
name|sp
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|sp
operator|->
name|lifetime
operator|==
literal|0
operator|&&
name|sp
operator|->
name|validtime
operator|==
literal|0
condition|)
continue|continue;
comment|/* the deletion will occur next time */
if|if
condition|(
operator|(
name|sp
operator|->
name|lifetime
operator|&&
name|tv
operator|.
name|tv_sec
operator|-
name|sp
operator|->
name|created
operator|>
name|sp
operator|->
name|lifetime
operator|)
operator|||
operator|(
name|sp
operator|->
name|validtime
operator|&&
name|tv
operator|.
name|tv_sec
operator|-
name|sp
operator|->
name|lastused
operator|>
name|sp
operator|->
name|validtime
operator|)
condition|)
block|{
name|sp
operator|->
name|state
operator|=
name|IPSEC_SPSTATE_DEAD
expr_stmt|;
name|key_spdexpire
argument_list|(
name|sp
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
block|}
block|}
comment|/* SAD */
block|{
name|struct
name|secashead
modifier|*
name|sah
decl_stmt|,
modifier|*
name|nextsah
decl_stmt|;
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|,
modifier|*
name|nextsav
decl_stmt|;
for|for
control|(
name|sah
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sahtree
argument_list|)
init|;
name|sah
operator|!=
name|NULL
condition|;
name|sah
operator|=
name|nextsah
control|)
block|{
name|nextsah
operator|=
name|LIST_NEXT
argument_list|(
name|sah
argument_list|,
name|chain
argument_list|)
expr_stmt|;
comment|/* if sah has been dead, then delete it and process next sah. */
if|if
condition|(
name|sah
operator|->
name|state
operator|==
name|SADB_SASTATE_DEAD
condition|)
block|{
name|key_delsah
argument_list|(
name|sah
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* if LARVAL entry doesn't become MATURE, delete it. */
for|for
control|(
name|sav
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sah
operator|->
name|savtree
index|[
name|SADB_SASTATE_LARVAL
index|]
argument_list|)
init|;
name|sav
operator|!=
name|NULL
condition|;
name|sav
operator|=
name|nextsav
control|)
block|{
name|nextsav
operator|=
name|LIST_NEXT
argument_list|(
name|sav
argument_list|,
name|chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|tv
operator|.
name|tv_sec
operator|-
name|sav
operator|->
name|created
operator|>
name|key_larval_lifetime
condition|)
block|{
name|key_freesav
argument_list|(
name|sav
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * check MATURE entry to start to send expire message 		 * whether or not. 		 */
for|for
control|(
name|sav
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sah
operator|->
name|savtree
index|[
name|SADB_SASTATE_MATURE
index|]
argument_list|)
init|;
name|sav
operator|!=
name|NULL
condition|;
name|sav
operator|=
name|nextsav
control|)
block|{
name|nextsav
operator|=
name|LIST_NEXT
argument_list|(
name|sav
argument_list|,
name|chain
argument_list|)
expr_stmt|;
comment|/* we don't need to check. */
if|if
condition|(
name|sav
operator|->
name|lft_s
operator|==
name|NULL
condition|)
continue|continue;
comment|/* sanity check */
if|if
condition|(
name|sav
operator|->
name|lft_c
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_timehandler: "
literal|"There is no CURRENT time, why?\n"
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* check SOFT lifetime */
if|if
condition|(
name|sav
operator|->
name|lft_s
operator|->
name|sadb_lifetime_addtime
operator|!=
literal|0
operator|&&
name|tv
operator|.
name|tv_sec
operator|-
name|sav
operator|->
name|created
operator|>
name|sav
operator|->
name|lft_s
operator|->
name|sadb_lifetime_addtime
condition|)
block|{
comment|/* 				 * check SA to be used whether or not. 				 * when SA hasn't been used, delete it. 				 */
if|if
condition|(
name|sav
operator|->
name|lft_c
operator|->
name|sadb_lifetime_usetime
operator|==
literal|0
condition|)
block|{
name|key_sa_chgstate
argument_list|(
name|sav
argument_list|,
name|SADB_SASTATE_DEAD
argument_list|)
expr_stmt|;
name|key_freesav
argument_list|(
name|sav
argument_list|)
expr_stmt|;
name|sav
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|key_sa_chgstate
argument_list|(
name|sav
argument_list|,
name|SADB_SASTATE_DYING
argument_list|)
expr_stmt|;
comment|/* 					 * XXX If we keep to send expire 					 * message in the status of 					 * DYING. Do remove below code. 					 */
name|key_expire
argument_list|(
name|sav
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* check SOFT lifetime by bytes */
comment|/* 			 * XXX I don't know the way to delete this SA 			 * when new SA is installed.  Caution when it's 			 * installed too big lifetime by time. 			 */
elseif|else
if|if
condition|(
name|sav
operator|->
name|lft_s
operator|->
name|sadb_lifetime_bytes
operator|!=
literal|0
operator|&&
name|sav
operator|->
name|lft_s
operator|->
name|sadb_lifetime_bytes
operator|<
name|sav
operator|->
name|lft_c
operator|->
name|sadb_lifetime_bytes
condition|)
block|{
name|key_sa_chgstate
argument_list|(
name|sav
argument_list|,
name|SADB_SASTATE_DYING
argument_list|)
expr_stmt|;
comment|/* 				 * XXX If we keep to send expire 				 * message in the status of 				 * DYING. Do remove below code. 				 */
name|key_expire
argument_list|(
name|sav
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* check DYING entry to change status to DEAD. */
for|for
control|(
name|sav
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sah
operator|->
name|savtree
index|[
name|SADB_SASTATE_DYING
index|]
argument_list|)
init|;
name|sav
operator|!=
name|NULL
condition|;
name|sav
operator|=
name|nextsav
control|)
block|{
name|nextsav
operator|=
name|LIST_NEXT
argument_list|(
name|sav
argument_list|,
name|chain
argument_list|)
expr_stmt|;
comment|/* we don't need to check. */
if|if
condition|(
name|sav
operator|->
name|lft_h
operator|==
name|NULL
condition|)
continue|continue;
comment|/* sanity check */
if|if
condition|(
name|sav
operator|->
name|lft_c
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_timehandler: "
literal|"There is no CURRENT time, why?\n"
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|sav
operator|->
name|lft_h
operator|->
name|sadb_lifetime_addtime
operator|!=
literal|0
operator|&&
name|tv
operator|.
name|tv_sec
operator|-
name|sav
operator|->
name|created
operator|>
name|sav
operator|->
name|lft_h
operator|->
name|sadb_lifetime_addtime
condition|)
block|{
name|key_sa_chgstate
argument_list|(
name|sav
argument_list|,
name|SADB_SASTATE_DEAD
argument_list|)
expr_stmt|;
name|key_freesav
argument_list|(
name|sav
argument_list|)
expr_stmt|;
name|sav
operator|=
name|NULL
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* XXX Should we keep to send expire message until HARD lifetime ? */
if|else if (sav->lft_s != NULL&& sav->lft_s->sadb_lifetime_addtime != 0&& tv.tv_sec - sav->created> sav->lft_s->sadb_lifetime_addtime) {
comment|/* 				 * XXX: should be checked to be 				 * installed the valid SA. 				 */
comment|/* 				 * If there is no SA then sending 				 * expire message. 				 */
if|key_expire(sav); 			}
endif|#
directive|endif
comment|/* check HARD lifetime by bytes */
elseif|else
if|if
condition|(
name|sav
operator|->
name|lft_h
operator|->
name|sadb_lifetime_bytes
operator|!=
literal|0
operator|&&
name|sav
operator|->
name|lft_h
operator|->
name|sadb_lifetime_bytes
operator|<
name|sav
operator|->
name|lft_c
operator|->
name|sadb_lifetime_bytes
condition|)
block|{
name|key_sa_chgstate
argument_list|(
name|sav
argument_list|,
name|SADB_SASTATE_DEAD
argument_list|)
expr_stmt|;
name|key_freesav
argument_list|(
name|sav
argument_list|)
expr_stmt|;
name|sav
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* delete entry in DEAD */
for|for
control|(
name|sav
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sah
operator|->
name|savtree
index|[
name|SADB_SASTATE_DEAD
index|]
argument_list|)
init|;
name|sav
operator|!=
name|NULL
condition|;
name|sav
operator|=
name|nextsav
control|)
block|{
name|nextsav
operator|=
name|LIST_NEXT
argument_list|(
name|sav
argument_list|,
name|chain
argument_list|)
expr_stmt|;
comment|/* sanity check */
if|if
condition|(
name|sav
operator|->
name|state
operator|!=
name|SADB_SASTATE_DEAD
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_timehandler: "
literal|"invalid sav->state "
literal|"(queue: %d SA: %d): "
literal|"kill it anyway\n"
operator|,
name|SADB_SASTATE_DEAD
operator|,
name|sav
operator|->
name|state
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * do not call key_freesav() here. 			 * sav should already be freed, and sav->refcnt 			 * shows other references to sav 			 * (such as from SPD). 			 */
block|}
block|}
block|}
ifndef|#
directive|ifndef
name|IPSEC_NONBLOCK_ACQUIRE
comment|/* ACQ tree */
block|{
name|struct
name|secacq
modifier|*
name|acq
decl_stmt|,
modifier|*
name|nextacq
decl_stmt|;
for|for
control|(
name|acq
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|acqtree
argument_list|)
init|;
name|acq
operator|!=
name|NULL
condition|;
name|acq
operator|=
name|nextacq
control|)
block|{
name|nextacq
operator|=
name|LIST_NEXT
argument_list|(
name|acq
argument_list|,
name|chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|tv
operator|.
name|tv_sec
operator|-
name|acq
operator|->
name|created
operator|>
name|key_blockacq_lifetime
operator|&&
name|__LIST_CHAINED
argument_list|(
name|acq
argument_list|)
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|acq
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|KFREE
argument_list|(
name|acq
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* SP ACQ tree */
block|{
name|struct
name|secspacq
modifier|*
name|acq
decl_stmt|,
modifier|*
name|nextacq
decl_stmt|;
for|for
control|(
name|acq
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|spacqtree
argument_list|)
init|;
name|acq
operator|!=
name|NULL
condition|;
name|acq
operator|=
name|nextacq
control|)
block|{
name|nextacq
operator|=
name|LIST_NEXT
argument_list|(
name|acq
argument_list|,
name|chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|tv
operator|.
name|tv_sec
operator|-
name|acq
operator|->
name|created
operator|>
name|key_blockacq_lifetime
operator|&&
name|__LIST_CHAINED
argument_list|(
name|acq
argument_list|)
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|acq
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|KFREE
argument_list|(
name|acq
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* initialize random seed */
if|if
condition|(
name|key_tick_init_random
operator|++
operator|>
name|key_int_random
condition|)
block|{
name|key_tick_init_random
operator|=
literal|0
expr_stmt|;
name|key_srandom
argument_list|()
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|IPSEC_DEBUG2
comment|/* do exchange to tick time !! */
operator|(
name|void
operator|)
name|timeout
argument_list|(
operator|(
name|void
operator|*
operator|)
name|key_timehandler
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|,
name|hz
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* IPSEC_DEBUG2 */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * to initialize a seed for random()  */
end_comment

begin_function
specifier|static
name|void
name|key_srandom
parameter_list|()
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|microtime
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
name|srandom
argument_list|(
name|tv
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|u_long
name|key_random
parameter_list|()
block|{
name|u_long
name|value
decl_stmt|;
name|key_randomfill
argument_list|(
operator|&
name|value
argument_list|,
sizeof|sizeof
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_function
name|void
name|key_randomfill
parameter_list|(
name|p
parameter_list|,
name|l
parameter_list|)
name|void
modifier|*
name|p
decl_stmt|;
name|size_t
name|l
decl_stmt|;
block|{
name|size_t
name|n
decl_stmt|;
name|u_long
name|v
decl_stmt|;
specifier|static
name|int
name|warn
init|=
literal|1
decl_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
name|n
operator|=
operator|(
name|size_t
operator|)
name|read_random
argument_list|(
name|p
argument_list|,
operator|(
name|u_int
operator|)
name|l
argument_list|)
expr_stmt|;
comment|/* last resort */
while|while
condition|(
name|n
operator|<
name|l
condition|)
block|{
name|v
operator|=
name|random
argument_list|()
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|v
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
name|p
operator|+
name|n
argument_list|,
name|l
operator|-
name|n
operator|<
sizeof|sizeof
argument_list|(
name|v
argument_list|)
condition|?
name|l
operator|-
name|n
else|:
sizeof|sizeof
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|+=
sizeof|sizeof
argument_list|(
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|warn
condition|)
block|{
name|printf
argument_list|(
literal|"WARNING: pseudo-random number generator "
literal|"used for IPsec processing\n"
argument_list|)
expr_stmt|;
name|warn
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * map SADB_SATYPE_* to IPPROTO_*.  * if satype == SADB_SATYPE then satype is mapped to ~0.  * OUT:  *	0: invalid satype.  */
end_comment

begin_function
specifier|static
name|u_int16_t
name|key_satype2proto
parameter_list|(
name|satype
parameter_list|)
name|u_int8_t
name|satype
decl_stmt|;
block|{
switch|switch
condition|(
name|satype
condition|)
block|{
case|case
name|SADB_SATYPE_UNSPEC
case|:
return|return
name|IPSEC_PROTO_ANY
return|;
case|case
name|SADB_SATYPE_AH
case|:
return|return
name|IPPROTO_AH
return|;
case|case
name|SADB_SATYPE_ESP
case|:
return|return
name|IPPROTO_ESP
return|;
case|case
name|SADB_X_SATYPE_IPCOMP
case|:
return|return
name|IPPROTO_IPCOMP
return|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/*  * map IPPROTO_* to SADB_SATYPE_*  * OUT:  *	0: invalid protocol type.  */
end_comment

begin_function
specifier|static
name|u_int8_t
name|key_proto2satype
parameter_list|(
name|proto
parameter_list|)
name|u_int16_t
name|proto
decl_stmt|;
block|{
switch|switch
condition|(
name|proto
condition|)
block|{
case|case
name|IPPROTO_AH
case|:
return|return
name|SADB_SATYPE_AH
return|;
case|case
name|IPPROTO_ESP
case|:
return|return
name|SADB_SATYPE_ESP
return|;
case|case
name|IPPROTO_IPCOMP
case|:
return|return
name|SADB_X_SATYPE_IPCOMP
return|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/* %%% PF_KEY */
end_comment

begin_comment
comment|/*  * SADB_GETSPI processing is to receive  *<base, (SA2), src address, dst address, (SPI range)>  * from the IKMPd, to assign a unique spi value, to hang on the INBOUND  * tree with the status of LARVAL, and send  *<base, SA(*), address(SD)>  * to the IKMPd.  *  * IN:	mhp: pointer to the pointer to each header.  * OUT:	NULL if fail.  *	other if success, return pointer to the message to send.  */
end_comment

begin_function
specifier|static
name|int
name|key_getspi
parameter_list|(
name|so
parameter_list|,
name|m
parameter_list|,
name|mhp
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|const
name|struct
name|sadb_msghdr
modifier|*
name|mhp
decl_stmt|;
block|{
name|struct
name|sadb_address
modifier|*
name|src0
decl_stmt|,
modifier|*
name|dst0
decl_stmt|;
name|struct
name|secasindex
name|saidx
decl_stmt|;
name|struct
name|secashead
modifier|*
name|newsah
decl_stmt|;
name|struct
name|secasvar
modifier|*
name|newsav
decl_stmt|;
name|u_int8_t
name|proto
decl_stmt|;
name|u_int32_t
name|spi
decl_stmt|;
name|u_int8_t
name|mode
decl_stmt|;
name|u_int32_t
name|reqid
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* sanity check */
if|if
condition|(
name|so
operator|==
name|NULL
operator|||
name|m
operator|==
name|NULL
operator|||
name|mhp
operator|==
name|NULL
operator|||
name|mhp
operator|->
name|msg
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_getspi: NULL pointer is passed.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
operator|==
name|NULL
operator|||
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_DST
index|]
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_getspi: invalid message is passed.\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|mhp
operator|->
name|extlen
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_address
argument_list|)
operator|||
name|mhp
operator|->
name|extlen
index|[
name|SADB_EXT_ADDRESS_DST
index|]
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_address
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_getspi: invalid message is passed.\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_SA2
index|]
operator|!=
name|NULL
condition|)
block|{
name|mode
operator|=
operator|(
operator|(
expr|struct
name|sadb_x_sa2
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_SA2
index|]
operator|)
operator|->
name|sadb_x_sa2_mode
expr_stmt|;
name|reqid
operator|=
operator|(
operator|(
expr|struct
name|sadb_x_sa2
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_SA2
index|]
operator|)
operator|->
name|sadb_x_sa2_reqid
expr_stmt|;
block|}
else|else
block|{
name|mode
operator|=
name|IPSEC_MODE_ANY
expr_stmt|;
name|reqid
operator|=
literal|0
expr_stmt|;
block|}
name|src0
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
operator|(
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
operator|)
expr_stmt|;
name|dst0
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
operator|(
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_DST
index|]
operator|)
expr_stmt|;
comment|/* map satype to proto */
if|if
condition|(
operator|(
name|proto
operator|=
name|key_satype2proto
argument_list|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_satype
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_getspi: invalid satype is passed.\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
comment|/* make sure if port number is zero. */
switch|switch
condition|(
operator|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
name|src0
operator|+
literal|1
operator|)
operator|)
operator|->
name|sa_family
condition|)
block|{
case|case
name|AF_INET
case|:
if|if
condition|(
operator|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
name|src0
operator|+
literal|1
operator|)
operator|)
operator|->
name|sa_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
condition|)
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|(
name|src0
operator|+
literal|1
operator|)
operator|)
operator|->
name|sin_port
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|AF_INET6
case|:
if|if
condition|(
operator|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
name|src0
operator|+
literal|1
operator|)
operator|)
operator|->
name|sa_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
condition|)
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|(
name|src0
operator|+
literal|1
operator|)
operator|)
operator|->
name|sin6_port
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
empty_stmt|;
comment|/*???*/
block|}
switch|switch
condition|(
operator|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
name|dst0
operator|+
literal|1
operator|)
operator|)
operator|->
name|sa_family
condition|)
block|{
case|case
name|AF_INET
case|:
if|if
condition|(
operator|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
name|dst0
operator|+
literal|1
operator|)
operator|)
operator|->
name|sa_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
condition|)
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|(
name|dst0
operator|+
literal|1
operator|)
operator|)
operator|->
name|sin_port
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|AF_INET6
case|:
if|if
condition|(
operator|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
name|dst0
operator|+
literal|1
operator|)
operator|)
operator|->
name|sa_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
condition|)
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|(
name|dst0
operator|+
literal|1
operator|)
operator|)
operator|->
name|sin6_port
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
empty_stmt|;
comment|/*???*/
block|}
comment|/* XXX boundary check against sa_len */
name|KEY_SETSECASIDX
argument_list|(
name|proto
argument_list|,
name|mode
argument_list|,
name|reqid
argument_list|,
name|src0
operator|+
literal|1
argument_list|,
name|dst0
operator|+
literal|1
argument_list|,
operator|&
name|saidx
argument_list|)
expr_stmt|;
comment|/* SPI allocation */
name|spi
operator|=
name|key_do_getnewspi
argument_list|(
operator|(
expr|struct
name|sadb_spirange
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_SPIRANGE
index|]
argument_list|,
operator|&
name|saidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|spi
operator|==
literal|0
condition|)
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
comment|/* get a SA index */
if|if
condition|(
operator|(
name|newsah
operator|=
name|key_getsah
argument_list|(
operator|&
name|saidx
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* create a new SA index */
if|if
condition|(
operator|(
name|newsah
operator|=
name|key_newsah
argument_list|(
operator|&
name|saidx
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_getspi: No more memory.\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOBUFS
argument_list|)
return|;
block|}
block|}
comment|/* get a new SA */
comment|/* XXX rewrite */
name|newsav
operator|=
name|key_newsav
argument_list|(
name|m
argument_list|,
name|mhp
argument_list|,
name|newsah
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|newsav
operator|==
name|NULL
condition|)
block|{
comment|/* XXX don't free new SA index allocated in above. */
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|error
argument_list|)
return|;
block|}
comment|/* set spi */
name|newsav
operator|->
name|spi
operator|=
name|htonl
argument_list|(
name|spi
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|IPSEC_NONBLOCK_ACQUIRE
comment|/* delete the entry in acqtree */
if|if
condition|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_seq
operator|!=
literal|0
condition|)
block|{
name|struct
name|secacq
modifier|*
name|acq
decl_stmt|;
if|if
condition|(
operator|(
name|acq
operator|=
name|key_getacqbyseq
argument_list|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_seq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* reset counter in order to deletion by timehandler. */
name|struct
name|timeval
name|tv
decl_stmt|;
name|microtime
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
name|acq
operator|->
name|created
operator|=
name|tv
operator|.
name|tv_sec
expr_stmt|;
name|acq
operator|->
name|count
operator|=
literal|0
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|{
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|,
modifier|*
name|nn
decl_stmt|;
name|struct
name|sadb_sa
modifier|*
name|m_sa
decl_stmt|;
name|struct
name|sadb_msg
modifier|*
name|newmsg
decl_stmt|;
name|int
name|off
decl_stmt|,
name|len
decl_stmt|;
comment|/* create new sadb_msg to reply. */
name|len
operator|=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|)
operator|+
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_sa
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|MCLBYTES
condition|)
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOBUFS
argument_list|)
return|;
name|MGETHDR
argument_list|(
name|n
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|MHLEN
condition|)
block|{
name|MCLGET
argument_list|(
name|n
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|n
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|n
condition|)
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOBUFS
argument_list|)
return|;
name|n
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
name|n
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
name|off
operator|=
literal|0
expr_stmt|;
name|m_copydata
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|,
name|mtod
argument_list|(
name|n
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|off
argument_list|)
expr_stmt|;
name|off
operator|+=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|)
expr_stmt|;
name|m_sa
operator|=
operator|(
expr|struct
name|sadb_sa
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|n
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|off
operator|)
expr_stmt|;
name|m_sa
operator|->
name|sadb_sa_len
operator|=
name|PFKEY_UNIT64
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_sa
argument_list|)
argument_list|)
expr_stmt|;
name|m_sa
operator|->
name|sadb_sa_exttype
operator|=
name|SADB_EXT_SA
expr_stmt|;
name|m_sa
operator|->
name|sadb_sa_spi
operator|=
name|htonl
argument_list|(
name|spi
argument_list|)
expr_stmt|;
name|off
operator|+=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_sa
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|off
operator|!=
name|len
condition|)
name|panic
argument_list|(
literal|"length inconsistency in key_getspi"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|n
operator|->
name|m_next
operator|=
name|key_gather_mbuf
argument_list|(
name|m
argument_list|,
name|mhp
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
name|SADB_EXT_ADDRESS_SRC
argument_list|,
name|SADB_EXT_ADDRESS_DST
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
operator|->
name|m_next
condition|)
block|{
name|m_freem
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOBUFS
argument_list|)
return|;
block|}
if|if
condition|(
name|n
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
condition|)
block|{
name|n
operator|=
name|m_pullup
argument_list|(
name|n
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
return|return
name|key_sendup_mbuf
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|KEY_SENDUP_ONE
argument_list|)
return|;
block|}
name|n
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|nn
operator|=
name|n
init|;
name|nn
condition|;
name|nn
operator|=
name|nn
operator|->
name|m_next
control|)
name|n
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|nn
operator|->
name|m_len
expr_stmt|;
name|newmsg
operator|=
name|mtod
argument_list|(
name|n
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|)
expr_stmt|;
name|newmsg
operator|->
name|sadb_msg_seq
operator|=
name|newsav
operator|->
name|seq
expr_stmt|;
name|newmsg
operator|->
name|sadb_msg_errno
operator|=
literal|0
expr_stmt|;
name|newmsg
operator|->
name|sadb_msg_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|n
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|key_sendup_mbuf
argument_list|(
name|so
argument_list|,
name|n
argument_list|,
name|KEY_SENDUP_ONE
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * allocating new SPI  * called by key_getspi().  * OUT:  *	0:	failure.  *	others: success.  */
end_comment

begin_function
specifier|static
name|u_int32_t
name|key_do_getnewspi
parameter_list|(
name|spirange
parameter_list|,
name|saidx
parameter_list|)
name|struct
name|sadb_spirange
modifier|*
name|spirange
decl_stmt|;
name|struct
name|secasindex
modifier|*
name|saidx
decl_stmt|;
block|{
name|u_int32_t
name|newspi
decl_stmt|;
name|u_int32_t
name|min
decl_stmt|,
name|max
decl_stmt|;
name|int
name|count
init|=
name|key_spi_trycnt
decl_stmt|;
comment|/* set spi range to allocate */
if|if
condition|(
name|spirange
operator|!=
name|NULL
condition|)
block|{
name|min
operator|=
name|spirange
operator|->
name|sadb_spirange_min
expr_stmt|;
name|max
operator|=
name|spirange
operator|->
name|sadb_spirange_max
expr_stmt|;
block|}
else|else
block|{
name|min
operator|=
name|key_spi_minval
expr_stmt|;
name|max
operator|=
name|key_spi_maxval
expr_stmt|;
block|}
comment|/* IPCOMP needs 2-byte SPI */
if|if
condition|(
name|saidx
operator|->
name|proto
operator|==
name|IPPROTO_IPCOMP
condition|)
block|{
name|u_int32_t
name|t
decl_stmt|;
if|if
condition|(
name|min
operator|>=
literal|0x10000
condition|)
name|min
operator|=
literal|0xffff
expr_stmt|;
if|if
condition|(
name|max
operator|>=
literal|0x10000
condition|)
name|max
operator|=
literal|0xffff
expr_stmt|;
if|if
condition|(
name|min
operator|>
name|max
condition|)
block|{
name|t
operator|=
name|min
expr_stmt|;
name|min
operator|=
name|max
expr_stmt|;
name|max
operator|=
name|t
expr_stmt|;
block|}
block|}
if|if
condition|(
name|min
operator|==
name|max
condition|)
block|{
if|if
condition|(
name|key_checkspidup
argument_list|(
name|saidx
argument_list|,
name|min
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_do_getnewspi: SPI %u exists already.\n"
operator|,
name|min
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|count
operator|--
expr_stmt|;
comment|/* taking one cost. */
name|newspi
operator|=
name|min
expr_stmt|;
block|}
else|else
block|{
comment|/* init SPI */
name|newspi
operator|=
literal|0
expr_stmt|;
comment|/* when requesting to allocate spi ranged */
while|while
condition|(
name|count
operator|--
condition|)
block|{
comment|/* generate pseudo-random SPI value ranged. */
name|newspi
operator|=
name|min
operator|+
operator|(
name|key_random
argument_list|()
operator|%
operator|(
name|max
operator|-
name|min
operator|+
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|key_checkspidup
argument_list|(
name|saidx
argument_list|,
name|newspi
argument_list|)
operator|==
name|NULL
condition|)
break|break;
block|}
if|if
condition|(
name|count
operator|==
literal|0
operator|||
name|newspi
operator|==
literal|0
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_do_getnewspi: to allocate spi is failed.\n"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/* statistics */
name|keystat
operator|.
name|getspi_count
operator|=
operator|(
name|keystat
operator|.
name|getspi_count
operator|+
name|key_spi_trycnt
operator|-
name|count
operator|)
operator|/
literal|2
expr_stmt|;
return|return
name|newspi
return|;
block|}
end_function

begin_comment
comment|/*  * SADB_UPDATE processing  * receive  *<base, SA, (SA2), (lifetime(HSC),) address(SD), (address(P),)  *       key(AE), (identity(SD),) (sensitivity)>  * from the ikmpd, and update a secasvar entry whose status is SADB_SASTATE_LARVAL.  * and send  *<base, SA, (SA2), (lifetime(HSC),) address(SD), (address(P),)  *       (identity(SD),) (sensitivity)>  * to the ikmpd.  *  * m will always be freed.  */
end_comment

begin_function
specifier|static
name|int
name|key_update
parameter_list|(
name|so
parameter_list|,
name|m
parameter_list|,
name|mhp
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|const
name|struct
name|sadb_msghdr
modifier|*
name|mhp
decl_stmt|;
block|{
name|struct
name|sadb_sa
modifier|*
name|sa0
decl_stmt|;
name|struct
name|sadb_address
modifier|*
name|src0
decl_stmt|,
modifier|*
name|dst0
decl_stmt|;
name|struct
name|secasindex
name|saidx
decl_stmt|;
name|struct
name|secashead
modifier|*
name|sah
decl_stmt|;
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|;
name|u_int16_t
name|proto
decl_stmt|;
name|u_int8_t
name|mode
decl_stmt|;
name|u_int32_t
name|reqid
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* sanity check */
if|if
condition|(
name|so
operator|==
name|NULL
operator|||
name|m
operator|==
name|NULL
operator|||
name|mhp
operator|==
name|NULL
operator|||
name|mhp
operator|->
name|msg
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_update: NULL pointer is passed.\n"
argument_list|)
expr_stmt|;
comment|/* map satype to proto */
if|if
condition|(
operator|(
name|proto
operator|=
name|key_satype2proto
argument_list|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_satype
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_update: invalid satype is passed.\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_SA
index|]
operator|==
name|NULL
operator|||
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
operator|==
name|NULL
operator|||
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_DST
index|]
operator|==
name|NULL
operator|||
operator|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_satype
operator|==
name|SADB_SATYPE_ESP
operator|&&
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_KEY_ENCRYPT
index|]
operator|==
name|NULL
operator|)
operator|||
operator|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_satype
operator|==
name|SADB_SATYPE_AH
operator|&&
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_KEY_AUTH
index|]
operator|==
name|NULL
operator|)
operator|||
operator|(
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_LIFETIME_HARD
index|]
operator|!=
name|NULL
operator|&&
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_LIFETIME_SOFT
index|]
operator|==
name|NULL
operator|)
operator|||
operator|(
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_LIFETIME_HARD
index|]
operator|==
name|NULL
operator|&&
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_LIFETIME_SOFT
index|]
operator|!=
name|NULL
operator|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_update: invalid message is passed.\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|mhp
operator|->
name|extlen
index|[
name|SADB_EXT_SA
index|]
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_sa
argument_list|)
operator|||
name|mhp
operator|->
name|extlen
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_address
argument_list|)
operator|||
name|mhp
operator|->
name|extlen
index|[
name|SADB_EXT_ADDRESS_DST
index|]
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_address
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_update: invalid message is passed.\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_SA2
index|]
operator|!=
name|NULL
condition|)
block|{
name|mode
operator|=
operator|(
operator|(
expr|struct
name|sadb_x_sa2
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_SA2
index|]
operator|)
operator|->
name|sadb_x_sa2_mode
expr_stmt|;
name|reqid
operator|=
operator|(
operator|(
expr|struct
name|sadb_x_sa2
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_SA2
index|]
operator|)
operator|->
name|sadb_x_sa2_reqid
expr_stmt|;
block|}
else|else
block|{
name|mode
operator|=
name|IPSEC_MODE_ANY
expr_stmt|;
name|reqid
operator|=
literal|0
expr_stmt|;
block|}
comment|/* XXX boundary checking for other extensions */
name|sa0
operator|=
operator|(
expr|struct
name|sadb_sa
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_SA
index|]
expr_stmt|;
name|src0
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
operator|(
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
operator|)
expr_stmt|;
name|dst0
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
operator|(
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_DST
index|]
operator|)
expr_stmt|;
comment|/* XXX boundary check against sa_len */
name|KEY_SETSECASIDX
argument_list|(
name|proto
argument_list|,
name|mode
argument_list|,
name|reqid
argument_list|,
name|src0
operator|+
literal|1
argument_list|,
name|dst0
operator|+
literal|1
argument_list|,
operator|&
name|saidx
argument_list|)
expr_stmt|;
comment|/* get a SA header */
if|if
condition|(
operator|(
name|sah
operator|=
name|key_getsah
argument_list|(
operator|&
name|saidx
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_update: no SA index found.\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOENT
argument_list|)
return|;
block|}
comment|/* set spidx if there */
comment|/* XXX rewrite */
name|error
operator|=
name|key_setident
argument_list|(
name|sah
argument_list|,
name|m
argument_list|,
name|mhp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|error
argument_list|)
return|;
comment|/* find a SA with sequence number. */
ifdef|#
directive|ifdef
name|IPSEC_DOSEQCHECK
if|if
condition|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_seq
operator|!=
literal|0
operator|&&
operator|(
name|sav
operator|=
name|key_getsavbyseq
argument_list|(
name|sah
argument_list|,
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_seq
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_update: no larval SA with sequence %u exists.\n"
operator|,
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_seq
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOENT
argument_list|)
return|;
block|}
else|#
directive|else
if|if
condition|(
operator|(
name|sav
operator|=
name|key_getsavbyspi
argument_list|(
name|sah
argument_list|,
name|sa0
operator|->
name|sadb_sa_spi
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_update: no such a SA found (spi:%u)\n"
operator|,
operator|(
name|u_int32_t
operator|)
name|ntohl
argument_list|(
name|sa0
operator|->
name|sadb_sa_spi
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
endif|#
directive|endif
comment|/* validity check */
if|if
condition|(
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|proto
operator|!=
name|proto
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_update: protocol mismatched (DB=%u param=%u)\n"
operator|,
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|proto
operator|,
name|proto
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
ifdef|#
directive|ifdef
name|IPSEC_DOSEQCHECK
if|if
condition|(
name|sav
operator|->
name|spi
operator|!=
name|sa0
operator|->
name|sadb_sa_spi
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_update: SPI mismatched (DB:%u param:%u)\n"
operator|,
operator|(
name|u_int32_t
operator|)
name|ntohl
argument_list|(
name|sav
operator|->
name|spi
argument_list|)
operator|,
operator|(
name|u_int32_t
operator|)
name|ntohl
argument_list|(
name|sa0
operator|->
name|sadb_sa_spi
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|sav
operator|->
name|pid
operator|!=
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_pid
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_update: pid mismatched (DB:%u param:%u)\n"
operator|,
name|sav
operator|->
name|pid
operator|,
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_pid
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
comment|/* copy sav values */
name|error
operator|=
name|key_setsaval
argument_list|(
name|sav
argument_list|,
name|m
argument_list|,
name|mhp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|key_freesav
argument_list|(
name|sav
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|error
argument_list|)
return|;
block|}
comment|/* check SA values to be mature. */
if|if
condition|(
operator|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_errno
operator|=
name|key_mature
argument_list|(
name|sav
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|key_freesav
argument_list|(
name|sav
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
literal|0
argument_list|)
return|;
block|}
block|{
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
comment|/* set msg buf from mhp */
name|n
operator|=
name|key_getmsgbuf_x1
argument_list|(
name|m
argument_list|,
name|mhp
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_update: No more memory.\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOBUFS
argument_list|)
return|;
block|}
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|key_sendup_mbuf
argument_list|(
name|so
argument_list|,
name|n
argument_list|,
name|KEY_SENDUP_ALL
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * search SAD with sequence for a SA which state is SADB_SASTATE_LARVAL.  * only called by key_update().  * OUT:  *	NULL	: not found  *	others	: found, pointer to a SA.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|IPSEC_DOSEQCHECK
end_ifdef

begin_function
specifier|static
name|struct
name|secasvar
modifier|*
name|key_getsavbyseq
parameter_list|(
name|sah
parameter_list|,
name|seq
parameter_list|)
name|struct
name|secashead
modifier|*
name|sah
decl_stmt|;
name|u_int32_t
name|seq
decl_stmt|;
block|{
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|;
name|u_int
name|state
decl_stmt|;
name|state
operator|=
name|SADB_SASTATE_LARVAL
expr_stmt|;
comment|/* search SAD with sequence number ? */
name|LIST_FOREACH
argument_list|(
argument|sav
argument_list|,
argument|&sah->savtree[state]
argument_list|,
argument|chain
argument_list|)
block|{
name|KEY_CHKSASTATE
argument_list|(
name|state
argument_list|,
name|sav
operator|->
name|state
argument_list|,
literal|"key_getsabyseq"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|seq
operator|==
name|seq
condition|)
block|{
name|sav
operator|->
name|refcnt
operator|++
expr_stmt|;
name|KEYDEBUG
argument_list|(
name|KEYDEBUG_IPSEC_STAMP
argument_list|,
name|printf
argument_list|(
literal|"DP key_getsavbyseq cause "
literal|"refcnt++:%d SA:%p\n"
argument_list|,
name|sav
operator|->
name|refcnt
argument_list|,
name|sav
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|sav
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * SADB_ADD processing  * add a entry to SA database, when received  *<base, SA, (SA2), (lifetime(HSC),) address(SD), (address(P),)  *       key(AE), (identity(SD),) (sensitivity)>  * from the ikmpd,  * and send  *<base, SA, (SA2), (lifetime(HSC),) address(SD), (address(P),)  *       (identity(SD),) (sensitivity)>  * to the ikmpd.  *  * IGNORE identity and sensitivity messages.  *  * m will always be freed.  */
end_comment

begin_function
specifier|static
name|int
name|key_add
parameter_list|(
name|so
parameter_list|,
name|m
parameter_list|,
name|mhp
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|const
name|struct
name|sadb_msghdr
modifier|*
name|mhp
decl_stmt|;
block|{
name|struct
name|sadb_sa
modifier|*
name|sa0
decl_stmt|;
name|struct
name|sadb_address
modifier|*
name|src0
decl_stmt|,
modifier|*
name|dst0
decl_stmt|;
name|struct
name|secasindex
name|saidx
decl_stmt|;
name|struct
name|secashead
modifier|*
name|newsah
decl_stmt|;
name|struct
name|secasvar
modifier|*
name|newsav
decl_stmt|;
name|u_int16_t
name|proto
decl_stmt|;
name|u_int8_t
name|mode
decl_stmt|;
name|u_int32_t
name|reqid
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* sanity check */
if|if
condition|(
name|so
operator|==
name|NULL
operator|||
name|m
operator|==
name|NULL
operator|||
name|mhp
operator|==
name|NULL
operator|||
name|mhp
operator|->
name|msg
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_add: NULL pointer is passed.\n"
argument_list|)
expr_stmt|;
comment|/* map satype to proto */
if|if
condition|(
operator|(
name|proto
operator|=
name|key_satype2proto
argument_list|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_satype
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_add: invalid satype is passed.\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_SA
index|]
operator|==
name|NULL
operator|||
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
operator|==
name|NULL
operator|||
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_DST
index|]
operator|==
name|NULL
operator|||
operator|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_satype
operator|==
name|SADB_SATYPE_ESP
operator|&&
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_KEY_ENCRYPT
index|]
operator|==
name|NULL
operator|)
operator|||
operator|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_satype
operator|==
name|SADB_SATYPE_AH
operator|&&
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_KEY_AUTH
index|]
operator|==
name|NULL
operator|)
operator|||
operator|(
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_LIFETIME_HARD
index|]
operator|!=
name|NULL
operator|&&
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_LIFETIME_SOFT
index|]
operator|==
name|NULL
operator|)
operator|||
operator|(
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_LIFETIME_HARD
index|]
operator|==
name|NULL
operator|&&
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_LIFETIME_SOFT
index|]
operator|!=
name|NULL
operator|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_add: invalid message is passed.\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|mhp
operator|->
name|extlen
index|[
name|SADB_EXT_SA
index|]
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_sa
argument_list|)
operator|||
name|mhp
operator|->
name|extlen
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_address
argument_list|)
operator|||
name|mhp
operator|->
name|extlen
index|[
name|SADB_EXT_ADDRESS_DST
index|]
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_address
argument_list|)
condition|)
block|{
comment|/* XXX need more */
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_add: invalid message is passed.\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_SA2
index|]
operator|!=
name|NULL
condition|)
block|{
name|mode
operator|=
operator|(
operator|(
expr|struct
name|sadb_x_sa2
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_SA2
index|]
operator|)
operator|->
name|sadb_x_sa2_mode
expr_stmt|;
name|reqid
operator|=
operator|(
operator|(
expr|struct
name|sadb_x_sa2
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_X_EXT_SA2
index|]
operator|)
operator|->
name|sadb_x_sa2_reqid
expr_stmt|;
block|}
else|else
block|{
name|mode
operator|=
name|IPSEC_MODE_ANY
expr_stmt|;
name|reqid
operator|=
literal|0
expr_stmt|;
block|}
name|sa0
operator|=
operator|(
expr|struct
name|sadb_sa
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_SA
index|]
expr_stmt|;
name|src0
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
expr_stmt|;
name|dst0
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_DST
index|]
expr_stmt|;
comment|/* XXX boundary check against sa_len */
name|KEY_SETSECASIDX
argument_list|(
name|proto
argument_list|,
name|mode
argument_list|,
name|reqid
argument_list|,
name|src0
operator|+
literal|1
argument_list|,
name|dst0
operator|+
literal|1
argument_list|,
operator|&
name|saidx
argument_list|)
expr_stmt|;
comment|/* get a SA header */
if|if
condition|(
operator|(
name|newsah
operator|=
name|key_getsah
argument_list|(
operator|&
name|saidx
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* create a new SA header */
if|if
condition|(
operator|(
name|newsah
operator|=
name|key_newsah
argument_list|(
operator|&
name|saidx
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_add: No more memory.\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOBUFS
argument_list|)
return|;
block|}
block|}
comment|/* set spidx if there */
comment|/* XXX rewrite */
name|error
operator|=
name|key_setident
argument_list|(
name|newsah
argument_list|,
name|m
argument_list|,
name|mhp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|error
argument_list|)
return|;
block|}
comment|/* create new SA entry. */
comment|/* We can create new SA only if SPI is differenct. */
if|if
condition|(
name|key_getsavbyspi
argument_list|(
name|newsah
argument_list|,
name|sa0
operator|->
name|sadb_sa_spi
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_add: SA already exists.\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EEXIST
argument_list|)
return|;
block|}
name|newsav
operator|=
name|key_newsav
argument_list|(
name|m
argument_list|,
name|mhp
argument_list|,
name|newsah
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|newsav
operator|==
name|NULL
condition|)
block|{
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|error
argument_list|)
return|;
block|}
comment|/* check SA values to be mature. */
if|if
condition|(
operator|(
name|error
operator|=
name|key_mature
argument_list|(
name|newsav
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|key_freesav
argument_list|(
name|newsav
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|error
argument_list|)
return|;
block|}
comment|/* 	 * don't call key_freesav() here, as we would like to keep the SA 	 * in the database on success. 	 */
block|{
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
comment|/* set msg buf from mhp */
name|n
operator|=
name|key_getmsgbuf_x1
argument_list|(
name|m
argument_list|,
name|mhp
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_update: No more memory.\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOBUFS
argument_list|)
return|;
block|}
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|key_sendup_mbuf
argument_list|(
name|so
argument_list|,
name|n
argument_list|,
name|KEY_SENDUP_ALL
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* m is retained */
end_comment

begin_function
specifier|static
name|int
name|key_setident
parameter_list|(
name|sah
parameter_list|,
name|m
parameter_list|,
name|mhp
parameter_list|)
name|struct
name|secashead
modifier|*
name|sah
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|const
name|struct
name|sadb_msghdr
modifier|*
name|mhp
decl_stmt|;
block|{
specifier|const
name|struct
name|sadb_ident
modifier|*
name|idsrc
decl_stmt|,
modifier|*
name|iddst
decl_stmt|;
name|int
name|idsrclen
decl_stmt|,
name|iddstlen
decl_stmt|;
comment|/* sanity check */
if|if
condition|(
name|sah
operator|==
name|NULL
operator|||
name|m
operator|==
name|NULL
operator|||
name|mhp
operator|==
name|NULL
operator|||
name|mhp
operator|->
name|msg
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_setident: NULL pointer is passed.\n"
argument_list|)
expr_stmt|;
comment|/* don't make buffer if not there */
if|if
condition|(
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_IDENTITY_SRC
index|]
operator|==
name|NULL
operator|&&
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_IDENTITY_DST
index|]
operator|==
name|NULL
condition|)
block|{
name|sah
operator|->
name|idents
operator|=
name|NULL
expr_stmt|;
name|sah
operator|->
name|identd
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_IDENTITY_SRC
index|]
operator|==
name|NULL
operator|||
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_IDENTITY_DST
index|]
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_setident: invalid identity.\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|idsrc
operator|=
operator|(
specifier|const
expr|struct
name|sadb_ident
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_IDENTITY_SRC
index|]
expr_stmt|;
name|iddst
operator|=
operator|(
specifier|const
expr|struct
name|sadb_ident
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_IDENTITY_DST
index|]
expr_stmt|;
name|idsrclen
operator|=
name|mhp
operator|->
name|extlen
index|[
name|SADB_EXT_IDENTITY_SRC
index|]
expr_stmt|;
name|iddstlen
operator|=
name|mhp
operator|->
name|extlen
index|[
name|SADB_EXT_IDENTITY_DST
index|]
expr_stmt|;
comment|/* validity check */
if|if
condition|(
name|idsrc
operator|->
name|sadb_ident_type
operator|!=
name|iddst
operator|->
name|sadb_ident_type
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_setident: ident type mismatch.\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
switch|switch
condition|(
name|idsrc
operator|->
name|sadb_ident_type
condition|)
block|{
case|case
name|SADB_IDENTTYPE_PREFIX
case|:
case|case
name|SADB_IDENTTYPE_FQDN
case|:
case|case
name|SADB_IDENTTYPE_USERFQDN
case|:
default|default:
comment|/* XXX do nothing */
name|sah
operator|->
name|idents
operator|=
name|NULL
expr_stmt|;
name|sah
operator|->
name|identd
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* make structure */
name|KMALLOC
argument_list|(
name|sah
operator|->
name|idents
argument_list|,
expr|struct
name|sadb_ident
operator|*
argument_list|,
name|idsrclen
argument_list|)
expr_stmt|;
if|if
condition|(
name|sah
operator|->
name|idents
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_setident: No more memory.\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
name|KMALLOC
argument_list|(
name|sah
operator|->
name|identd
argument_list|,
expr|struct
name|sadb_ident
operator|*
argument_list|,
name|iddstlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|sah
operator|->
name|identd
operator|==
name|NULL
condition|)
block|{
name|KFREE
argument_list|(
name|sah
operator|->
name|idents
argument_list|)
expr_stmt|;
name|sah
operator|->
name|idents
operator|=
name|NULL
expr_stmt|;
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_setident: No more memory.\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
name|bcopy
argument_list|(
name|idsrc
argument_list|,
name|sah
operator|->
name|idents
argument_list|,
name|idsrclen
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|iddst
argument_list|,
name|sah
operator|->
name|identd
argument_list|,
name|iddstlen
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * m will not be freed on return.  * it is caller's responsibility to free the result.   */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|key_getmsgbuf_x1
parameter_list|(
name|m
parameter_list|,
name|mhp
parameter_list|)
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|const
name|struct
name|sadb_msghdr
modifier|*
name|mhp
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
comment|/* sanity check */
if|if
condition|(
name|m
operator|==
name|NULL
operator|||
name|mhp
operator|==
name|NULL
operator|||
name|mhp
operator|->
name|msg
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_getmsgbuf_x1: NULL pointer is passed.\n"
argument_list|)
expr_stmt|;
comment|/* create new sadb_msg to reply. */
name|n
operator|=
name|key_gather_mbuf
argument_list|(
name|m
argument_list|,
name|mhp
argument_list|,
literal|1
argument_list|,
literal|9
argument_list|,
name|SADB_EXT_RESERVED
argument_list|,
name|SADB_EXT_SA
argument_list|,
name|SADB_X_EXT_SA2
argument_list|,
name|SADB_EXT_ADDRESS_SRC
argument_list|,
name|SADB_EXT_ADDRESS_DST
argument_list|,
name|SADB_EXT_LIFETIME_HARD
argument_list|,
name|SADB_EXT_LIFETIME_SOFT
argument_list|,
name|SADB_EXT_IDENTITY_SRC
argument_list|,
name|SADB_EXT_IDENTITY_DST
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|n
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
condition|)
block|{
name|n
operator|=
name|m_pullup
argument_list|(
name|n
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
block|}
name|mtod
argument_list|(
name|n
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|)
operator|->
name|sadb_msg_errno
operator|=
literal|0
expr_stmt|;
name|mtod
argument_list|(
name|n
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|)
operator|->
name|sadb_msg_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|n
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|key_delete_all
name|__P
argument_list|(
operator|(
expr|struct
name|socket
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|,
specifier|const
expr|struct
name|sadb_msghdr
operator|*
operator|,
name|u_int16_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * SADB_DELETE processing  * receive  *<base, SA(*), address(SD)>  * from the ikmpd, and set SADB_SASTATE_DEAD,  * and send,  *<base, SA(*), address(SD)>  * to the ikmpd.  *  * m will always be freed.  */
end_comment

begin_function
specifier|static
name|int
name|key_delete
parameter_list|(
name|so
parameter_list|,
name|m
parameter_list|,
name|mhp
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|const
name|struct
name|sadb_msghdr
modifier|*
name|mhp
decl_stmt|;
block|{
name|struct
name|sadb_sa
modifier|*
name|sa0
decl_stmt|;
name|struct
name|sadb_address
modifier|*
name|src0
decl_stmt|,
modifier|*
name|dst0
decl_stmt|;
name|struct
name|secasindex
name|saidx
decl_stmt|;
name|struct
name|secashead
modifier|*
name|sah
decl_stmt|;
name|struct
name|secasvar
modifier|*
name|sav
init|=
name|NULL
decl_stmt|;
name|u_int16_t
name|proto
decl_stmt|;
comment|/* sanity check */
if|if
condition|(
name|so
operator|==
name|NULL
operator|||
name|m
operator|==
name|NULL
operator|||
name|mhp
operator|==
name|NULL
operator|||
name|mhp
operator|->
name|msg
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_delete: NULL pointer is passed.\n"
argument_list|)
expr_stmt|;
comment|/* map satype to proto */
if|if
condition|(
operator|(
name|proto
operator|=
name|key_satype2proto
argument_list|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_satype
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_delete: invalid satype is passed.\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
operator|==
name|NULL
operator|||
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_DST
index|]
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_delete: invalid message is passed.\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|mhp
operator|->
name|extlen
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_address
argument_list|)
operator|||
name|mhp
operator|->
name|extlen
index|[
name|SADB_EXT_ADDRESS_DST
index|]
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_address
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_delete: invalid message is passed.\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_SA
index|]
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Caller wants us to delete all non-LARVAL SAs 		 * that match the src/dst.  This is used during 		 * IKE INITIAL-CONTACT. 		 */
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_delete: doing delete all.\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_delete_all
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|mhp
argument_list|,
name|proto
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|mhp
operator|->
name|extlen
index|[
name|SADB_EXT_SA
index|]
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_sa
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_delete: invalid message is passed.\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
name|sa0
operator|=
operator|(
expr|struct
name|sadb_sa
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_SA
index|]
expr_stmt|;
name|src0
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
operator|(
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
operator|)
expr_stmt|;
name|dst0
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
operator|(
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_DST
index|]
operator|)
expr_stmt|;
comment|/* XXX boundary check against sa_len */
name|KEY_SETSECASIDX
argument_list|(
name|proto
argument_list|,
name|IPSEC_MODE_ANY
argument_list|,
literal|0
argument_list|,
name|src0
operator|+
literal|1
argument_list|,
name|dst0
operator|+
literal|1
argument_list|,
operator|&
name|saidx
argument_list|)
expr_stmt|;
comment|/* get a SA header */
name|LIST_FOREACH
argument_list|(
argument|sah
argument_list|,
argument|&sahtree
argument_list|,
argument|chain
argument_list|)
block|{
if|if
condition|(
name|sah
operator|->
name|state
operator|==
name|SADB_SASTATE_DEAD
condition|)
continue|continue;
if|if
condition|(
name|key_cmpsaidx
argument_list|(
operator|&
name|sah
operator|->
name|saidx
argument_list|,
operator|&
name|saidx
argument_list|,
name|CMP_HEAD
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* get a SA with SPI. */
name|sav
operator|=
name|key_getsavbyspi
argument_list|(
name|sah
argument_list|,
name|sa0
operator|->
name|sadb_sa_spi
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
condition|)
break|break;
block|}
if|if
condition|(
name|sah
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_delete: no SA found.\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOENT
argument_list|)
return|;
block|}
name|key_sa_chgstate
argument_list|(
name|sav
argument_list|,
name|SADB_SASTATE_DEAD
argument_list|)
expr_stmt|;
name|key_freesav
argument_list|(
name|sav
argument_list|)
expr_stmt|;
name|sav
operator|=
name|NULL
expr_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
name|struct
name|sadb_msg
modifier|*
name|newmsg
decl_stmt|;
comment|/* create new sadb_msg to reply. */
name|n
operator|=
name|key_gather_mbuf
argument_list|(
name|m
argument_list|,
name|mhp
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
name|SADB_EXT_RESERVED
argument_list|,
name|SADB_EXT_SA
argument_list|,
name|SADB_EXT_ADDRESS_SRC
argument_list|,
name|SADB_EXT_ADDRESS_DST
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOBUFS
argument_list|)
return|;
if|if
condition|(
name|n
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
condition|)
block|{
name|n
operator|=
name|m_pullup
argument_list|(
name|n
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOBUFS
argument_list|)
return|;
block|}
name|newmsg
operator|=
name|mtod
argument_list|(
name|n
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|)
expr_stmt|;
name|newmsg
operator|->
name|sadb_msg_errno
operator|=
literal|0
expr_stmt|;
name|newmsg
operator|->
name|sadb_msg_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|n
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|key_sendup_mbuf
argument_list|(
name|so
argument_list|,
name|n
argument_list|,
name|KEY_SENDUP_ALL
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * delete all SAs for src/dst.  Called from key_delete().  */
end_comment

begin_function
specifier|static
name|int
name|key_delete_all
parameter_list|(
name|so
parameter_list|,
name|m
parameter_list|,
name|mhp
parameter_list|,
name|proto
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|const
name|struct
name|sadb_msghdr
modifier|*
name|mhp
decl_stmt|;
name|u_int16_t
name|proto
decl_stmt|;
block|{
name|struct
name|sadb_address
modifier|*
name|src0
decl_stmt|,
modifier|*
name|dst0
decl_stmt|;
name|struct
name|secasindex
name|saidx
decl_stmt|;
name|struct
name|secashead
modifier|*
name|sah
decl_stmt|;
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|,
modifier|*
name|nextsav
decl_stmt|;
name|u_int
name|stateidx
decl_stmt|,
name|state
decl_stmt|;
name|src0
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
operator|(
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
operator|)
expr_stmt|;
name|dst0
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
operator|(
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_DST
index|]
operator|)
expr_stmt|;
comment|/* XXX boundary check against sa_len */
name|KEY_SETSECASIDX
argument_list|(
name|proto
argument_list|,
name|IPSEC_MODE_ANY
argument_list|,
literal|0
argument_list|,
name|src0
operator|+
literal|1
argument_list|,
name|dst0
operator|+
literal|1
argument_list|,
operator|&
name|saidx
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|sah
argument_list|,
argument|&sahtree
argument_list|,
argument|chain
argument_list|)
block|{
if|if
condition|(
name|sah
operator|->
name|state
operator|==
name|SADB_SASTATE_DEAD
condition|)
continue|continue;
if|if
condition|(
name|key_cmpsaidx
argument_list|(
operator|&
name|sah
operator|->
name|saidx
argument_list|,
operator|&
name|saidx
argument_list|,
name|CMP_HEAD
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* Delete all non-LARVAL SAs. */
for|for
control|(
name|stateidx
operator|=
literal|0
init|;
name|stateidx
operator|<
name|_ARRAYLEN
argument_list|(
name|saorder_state_alive
argument_list|)
condition|;
name|stateidx
operator|++
control|)
block|{
name|state
operator|=
name|saorder_state_alive
index|[
name|stateidx
index|]
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|SADB_SASTATE_LARVAL
condition|)
continue|continue;
for|for
control|(
name|sav
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sah
operator|->
name|savtree
index|[
name|state
index|]
argument_list|)
init|;
name|sav
operator|!=
name|NULL
condition|;
name|sav
operator|=
name|nextsav
control|)
block|{
name|nextsav
operator|=
name|LIST_NEXT
argument_list|(
name|sav
argument_list|,
name|chain
argument_list|)
expr_stmt|;
comment|/* sanity check */
if|if
condition|(
name|sav
operator|->
name|state
operator|!=
name|state
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_delete_all: "
literal|"invalid sav->state "
literal|"(queue: %d SA: %d)\n"
operator|,
name|state
operator|,
name|sav
operator|->
name|state
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|key_sa_chgstate
argument_list|(
name|sav
argument_list|,
name|SADB_SASTATE_DEAD
argument_list|)
expr_stmt|;
name|key_freesav
argument_list|(
name|sav
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|{
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
name|struct
name|sadb_msg
modifier|*
name|newmsg
decl_stmt|;
comment|/* create new sadb_msg to reply. */
name|n
operator|=
name|key_gather_mbuf
argument_list|(
name|m
argument_list|,
name|mhp
argument_list|,
literal|1
argument_list|,
literal|3
argument_list|,
name|SADB_EXT_RESERVED
argument_list|,
name|SADB_EXT_ADDRESS_SRC
argument_list|,
name|SADB_EXT_ADDRESS_DST
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOBUFS
argument_list|)
return|;
if|if
condition|(
name|n
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
condition|)
block|{
name|n
operator|=
name|m_pullup
argument_list|(
name|n
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOBUFS
argument_list|)
return|;
block|}
name|newmsg
operator|=
name|mtod
argument_list|(
name|n
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|)
expr_stmt|;
name|newmsg
operator|->
name|sadb_msg_errno
operator|=
literal|0
expr_stmt|;
name|newmsg
operator|->
name|sadb_msg_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|n
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|key_sendup_mbuf
argument_list|(
name|so
argument_list|,
name|n
argument_list|,
name|KEY_SENDUP_ALL
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * SADB_GET processing  * receive  *<base, SA(*), address(SD)>  * from the ikmpd, and get a SP and a SA to respond,  * and send,  *<base, SA, (lifetime(HSC),) address(SD), (address(P),) key(AE),  *       (identity(SD),) (sensitivity)>  * to the ikmpd.  *  * m will always be freed.  */
end_comment

begin_function
specifier|static
name|int
name|key_get
parameter_list|(
name|so
parameter_list|,
name|m
parameter_list|,
name|mhp
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|const
name|struct
name|sadb_msghdr
modifier|*
name|mhp
decl_stmt|;
block|{
name|struct
name|sadb_sa
modifier|*
name|sa0
decl_stmt|;
name|struct
name|sadb_address
modifier|*
name|src0
decl_stmt|,
modifier|*
name|dst0
decl_stmt|;
name|struct
name|secasindex
name|saidx
decl_stmt|;
name|struct
name|secashead
modifier|*
name|sah
decl_stmt|;
name|struct
name|secasvar
modifier|*
name|sav
init|=
name|NULL
decl_stmt|;
name|u_int16_t
name|proto
decl_stmt|;
comment|/* sanity check */
if|if
condition|(
name|so
operator|==
name|NULL
operator|||
name|m
operator|==
name|NULL
operator|||
name|mhp
operator|==
name|NULL
operator|||
name|mhp
operator|->
name|msg
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_get: NULL pointer is passed.\n"
argument_list|)
expr_stmt|;
comment|/* map satype to proto */
if|if
condition|(
operator|(
name|proto
operator|=
name|key_satype2proto
argument_list|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_satype
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_get: invalid satype is passed.\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_SA
index|]
operator|==
name|NULL
operator|||
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
operator|==
name|NULL
operator|||
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_DST
index|]
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_get: invalid message is passed.\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|mhp
operator|->
name|extlen
index|[
name|SADB_EXT_SA
index|]
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_sa
argument_list|)
operator|||
name|mhp
operator|->
name|extlen
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_address
argument_list|)
operator|||
name|mhp
operator|->
name|extlen
index|[
name|SADB_EXT_ADDRESS_DST
index|]
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_address
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_get: invalid message is passed.\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
name|sa0
operator|=
operator|(
expr|struct
name|sadb_sa
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_SA
index|]
expr_stmt|;
name|src0
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
expr_stmt|;
name|dst0
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_DST
index|]
expr_stmt|;
comment|/* XXX boundary check against sa_len */
name|KEY_SETSECASIDX
argument_list|(
name|proto
argument_list|,
name|IPSEC_MODE_ANY
argument_list|,
literal|0
argument_list|,
name|src0
operator|+
literal|1
argument_list|,
name|dst0
operator|+
literal|1
argument_list|,
operator|&
name|saidx
argument_list|)
expr_stmt|;
comment|/* get a SA header */
name|LIST_FOREACH
argument_list|(
argument|sah
argument_list|,
argument|&sahtree
argument_list|,
argument|chain
argument_list|)
block|{
if|if
condition|(
name|sah
operator|->
name|state
operator|==
name|SADB_SASTATE_DEAD
condition|)
continue|continue;
if|if
condition|(
name|key_cmpsaidx
argument_list|(
operator|&
name|sah
operator|->
name|saidx
argument_list|,
operator|&
name|saidx
argument_list|,
name|CMP_HEAD
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* get a SA with SPI. */
name|sav
operator|=
name|key_getsavbyspi
argument_list|(
name|sah
argument_list|,
name|sa0
operator|->
name|sadb_sa_spi
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
condition|)
break|break;
block|}
if|if
condition|(
name|sah
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_get: no SA found.\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOENT
argument_list|)
return|;
block|}
block|{
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
name|u_int8_t
name|satype
decl_stmt|;
comment|/* map proto to satype */
if|if
condition|(
operator|(
name|satype
operator|=
name|key_proto2satype
argument_list|(
name|sah
operator|->
name|saidx
operator|.
name|proto
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_get: there was invalid proto in SAD.\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
comment|/* create new sadb_msg to reply. */
name|n
operator|=
name|key_setdumpsa
argument_list|(
name|sav
argument_list|,
name|SADB_GET
argument_list|,
name|satype
argument_list|,
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_seq
argument_list|,
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_pid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOBUFS
argument_list|)
return|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|key_sendup_mbuf
argument_list|(
name|so
argument_list|,
name|n
argument_list|,
name|KEY_SENDUP_ONE
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* XXX make it sysctl-configurable? */
end_comment

begin_function
specifier|static
name|void
name|key_getcomb_setlifetime
parameter_list|(
name|comb
parameter_list|)
name|struct
name|sadb_comb
modifier|*
name|comb
decl_stmt|;
block|{
name|comb
operator|->
name|sadb_comb_soft_allocations
operator|=
literal|1
expr_stmt|;
name|comb
operator|->
name|sadb_comb_hard_allocations
operator|=
literal|1
expr_stmt|;
name|comb
operator|->
name|sadb_comb_soft_bytes
operator|=
literal|0
expr_stmt|;
name|comb
operator|->
name|sadb_comb_hard_bytes
operator|=
literal|0
expr_stmt|;
name|comb
operator|->
name|sadb_comb_hard_addtime
operator|=
literal|86400
expr_stmt|;
comment|/* 1 day */
name|comb
operator|->
name|sadb_comb_soft_addtime
operator|=
name|comb
operator|->
name|sadb_comb_soft_addtime
operator|*
literal|80
operator|/
literal|100
expr_stmt|;
name|comb
operator|->
name|sadb_comb_soft_usetime
operator|=
literal|28800
expr_stmt|;
comment|/* 8 hours */
name|comb
operator|->
name|sadb_comb_hard_usetime
operator|=
name|comb
operator|->
name|sadb_comb_hard_usetime
operator|*
literal|80
operator|/
literal|100
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|IPSEC_ESP
end_ifdef

begin_comment
comment|/*  * XXX reorder combinations by preference  * XXX no idea if the user wants ESP authentication or not  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|key_getcomb_esp
parameter_list|()
block|{
name|struct
name|sadb_comb
modifier|*
name|comb
decl_stmt|;
specifier|const
name|struct
name|esp_algorithm
modifier|*
name|algo
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|result
init|=
name|NULL
decl_stmt|,
modifier|*
name|m
decl_stmt|,
modifier|*
name|n
decl_stmt|;
name|int
name|encmin
decl_stmt|;
name|int
name|i
decl_stmt|,
name|off
decl_stmt|,
name|o
decl_stmt|;
name|int
name|totlen
decl_stmt|;
specifier|const
name|int
name|l
init|=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_comb
argument_list|)
argument_list|)
decl_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|SADB_EALG_MAX
condition|;
name|i
operator|++
control|)
block|{
name|algo
operator|=
name|esp_algorithm_lookup
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|algo
condition|)
continue|continue;
if|if
condition|(
name|algo
operator|->
name|keymax
operator|<
name|ipsec_esp_keymin
condition|)
continue|continue;
if|if
condition|(
name|algo
operator|->
name|keymin
operator|<
name|ipsec_esp_keymin
condition|)
name|encmin
operator|=
name|ipsec_esp_keymin
expr_stmt|;
else|else
name|encmin
operator|=
name|algo
operator|->
name|keymin
expr_stmt|;
if|if
condition|(
name|ipsec_esp_auth
condition|)
name|m
operator|=
name|key_getcomb_ah
argument_list|()
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|l
operator|>
name|MLEN
condition|)
name|panic
argument_list|(
literal|"assumption failed in key_getcomb_esp"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|MGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
block|{
name|M_ALIGN
argument_list|(
name|m
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|l
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
name|bzero
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|m
condition|)
goto|goto
name|fail
goto|;
name|totlen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
name|m
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|m_next
control|)
name|totlen
operator|+=
name|n
operator|->
name|m_len
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|totlen
operator|%
name|l
condition|)
name|panic
argument_list|(
literal|"assumption failed in key_getcomb_esp"
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|off
operator|=
literal|0
init|;
name|off
operator|<
name|totlen
condition|;
name|off
operator|+=
name|l
control|)
block|{
name|n
operator|=
name|m_pulldown
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
name|l
argument_list|,
operator|&
name|o
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
block|{
comment|/* m is already freed */
goto|goto
name|fail
goto|;
block|}
name|comb
operator|=
operator|(
expr|struct
name|sadb_comb
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|n
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|o
operator|)
expr_stmt|;
name|bzero
argument_list|(
name|comb
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|comb
argument_list|)
argument_list|)
expr_stmt|;
name|key_getcomb_setlifetime
argument_list|(
name|comb
argument_list|)
expr_stmt|;
name|comb
operator|->
name|sadb_comb_encrypt
operator|=
name|i
expr_stmt|;
name|comb
operator|->
name|sadb_comb_encrypt_minbits
operator|=
name|encmin
expr_stmt|;
name|comb
operator|->
name|sadb_comb_encrypt_maxbits
operator|=
name|algo
operator|->
name|keymax
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|result
condition|)
name|result
operator|=
name|m
expr_stmt|;
else|else
name|m_cat
argument_list|(
name|result
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
name|fail
label|:
if|if
condition|(
name|result
condition|)
name|m_freem
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * XXX reorder combinations by preference  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|key_getcomb_ah
parameter_list|()
block|{
name|struct
name|sadb_comb
modifier|*
name|comb
decl_stmt|;
specifier|const
name|struct
name|ah_algorithm
modifier|*
name|algo
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|min
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|const
name|int
name|l
init|=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_comb
argument_list|)
argument_list|)
decl_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|SADB_AALG_MAX
condition|;
name|i
operator|++
control|)
block|{
if|#
directive|if
literal|1
comment|/* we prefer HMAC algorithms, not old algorithms */
if|if
condition|(
name|i
operator|!=
name|SADB_AALG_SHA1HMAC
operator|&&
name|i
operator|!=
name|SADB_AALG_MD5HMAC
condition|)
continue|continue;
endif|#
directive|endif
name|algo
operator|=
name|ah_algorithm_lookup
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|algo
condition|)
continue|continue;
if|if
condition|(
name|algo
operator|->
name|keymax
operator|<
name|ipsec_ah_keymin
condition|)
continue|continue;
if|if
condition|(
name|algo
operator|->
name|keymin
operator|<
name|ipsec_ah_keymin
condition|)
name|min
operator|=
name|ipsec_ah_keymin
expr_stmt|;
else|else
name|min
operator|=
name|algo
operator|->
name|keymin
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|l
operator|>
name|MLEN
condition|)
name|panic
argument_list|(
literal|"assumption failed in key_getcomb_ah"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|MGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
block|{
name|M_ALIGN
argument_list|(
name|m
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|l
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
name|M_PREPEND
argument_list|(
name|m
argument_list|,
name|l
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
return|return
name|NULL
return|;
name|comb
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sadb_comb
operator|*
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|comb
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|comb
argument_list|)
argument_list|)
expr_stmt|;
name|key_getcomb_setlifetime
argument_list|(
name|comb
argument_list|)
expr_stmt|;
name|comb
operator|->
name|sadb_comb_auth
operator|=
name|i
expr_stmt|;
name|comb
operator|->
name|sadb_comb_auth_minbits
operator|=
name|min
expr_stmt|;
name|comb
operator|->
name|sadb_comb_auth_maxbits
operator|=
name|algo
operator|->
name|keymax
expr_stmt|;
block|}
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/*  * not really an official behavior.  discussed in pf_key@inner.net in Sep2000.  * XXX reorder combinations by preference  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|key_getcomb_ipcomp
parameter_list|()
block|{
name|struct
name|sadb_comb
modifier|*
name|comb
decl_stmt|;
specifier|const
name|struct
name|ipcomp_algorithm
modifier|*
name|algo
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|const
name|int
name|l
init|=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_comb
argument_list|)
argument_list|)
decl_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|SADB_X_CALG_MAX
condition|;
name|i
operator|++
control|)
block|{
name|algo
operator|=
name|ipcomp_algorithm_lookup
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|algo
condition|)
continue|continue;
if|if
condition|(
operator|!
name|m
condition|)
block|{
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|l
operator|>
name|MLEN
condition|)
name|panic
argument_list|(
literal|"assumption failed in key_getcomb_ipcomp"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|MGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
block|{
name|M_ALIGN
argument_list|(
name|m
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|l
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
name|M_PREPEND
argument_list|(
name|m
argument_list|,
name|l
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
return|return
name|NULL
return|;
name|comb
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sadb_comb
operator|*
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|comb
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|comb
argument_list|)
argument_list|)
expr_stmt|;
name|key_getcomb_setlifetime
argument_list|(
name|comb
argument_list|)
expr_stmt|;
name|comb
operator|->
name|sadb_comb_encrypt
operator|=
name|i
expr_stmt|;
comment|/* what should we set into sadb_comb_*_{min,max}bits? */
block|}
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/*  * XXX no way to pass mode (transport/tunnel) to userland  * XXX replay checking?  * XXX sysctl interface to ipsec_{ah,esp}_keymin  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|key_getprop
parameter_list|(
name|saidx
parameter_list|)
specifier|const
name|struct
name|secasindex
modifier|*
name|saidx
decl_stmt|;
block|{
name|struct
name|sadb_prop
modifier|*
name|prop
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|n
decl_stmt|;
specifier|const
name|int
name|l
init|=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_prop
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|totlen
decl_stmt|;
switch|switch
condition|(
name|saidx
operator|->
name|proto
condition|)
block|{
ifdef|#
directive|ifdef
name|IPSEC_ESP
case|case
name|IPPROTO_ESP
case|:
name|m
operator|=
name|key_getcomb_esp
argument_list|()
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|IPPROTO_AH
case|:
name|m
operator|=
name|key_getcomb_ah
argument_list|()
expr_stmt|;
break|break;
case|case
name|IPPROTO_IPCOMP
case|:
name|m
operator|=
name|key_getcomb_ipcomp
argument_list|()
expr_stmt|;
break|break;
default|default:
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
name|m
condition|)
return|return
name|NULL
return|;
name|M_PREPEND
argument_list|(
name|m
argument_list|,
name|l
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
return|return
name|NULL
return|;
name|totlen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
name|m
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|m_next
control|)
name|totlen
operator|+=
name|n
operator|->
name|m_len
expr_stmt|;
name|prop
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sadb_prop
operator|*
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|prop
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|prop
argument_list|)
argument_list|)
expr_stmt|;
name|prop
operator|->
name|sadb_prop_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|totlen
argument_list|)
expr_stmt|;
name|prop
operator|->
name|sadb_prop_exttype
operator|=
name|SADB_EXT_PROPOSAL
expr_stmt|;
name|prop
operator|->
name|sadb_prop_replay
operator|=
literal|32
expr_stmt|;
comment|/* XXX */
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/*  * SADB_ACQUIRE processing called by key_checkrequest() and key_acquire2().  * send  *<base, SA, address(SD), (address(P)), x_policy,  *       (identity(SD),) (sensitivity,) proposal>  * to KMD, and expect to receive  *<base> with SADB_ACQUIRE if error occured,  * or  *<base, src address, dst address, (SPI range)> with SADB_GETSPI  * from KMD by PF_KEY.  *  * XXX x_policy is outside of RFC2367 (KAME extension).  * XXX sensitivity is not supported.  * XXX for ipcomp, RFC2367 does not define how to fill in proposal.  * see comment for key_getcomb_ipcomp().  *  * OUT:  *    0     : succeed  *    others: error number  */
end_comment

begin_function
specifier|static
name|int
name|key_acquire
parameter_list|(
name|saidx
parameter_list|,
name|sp
parameter_list|)
name|struct
name|secasindex
modifier|*
name|saidx
decl_stmt|;
name|struct
name|secpolicy
modifier|*
name|sp
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|result
init|=
name|NULL
decl_stmt|,
modifier|*
name|m
decl_stmt|;
ifndef|#
directive|ifndef
name|IPSEC_NONBLOCK_ACQUIRE
name|struct
name|secacq
modifier|*
name|newacq
decl_stmt|;
endif|#
directive|endif
name|u_int8_t
name|satype
decl_stmt|;
name|int
name|error
init|=
operator|-
literal|1
decl_stmt|;
name|u_int32_t
name|seq
decl_stmt|;
comment|/* sanity check */
if|if
condition|(
name|saidx
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_acquire: NULL pointer is passed.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|satype
operator|=
name|key_proto2satype
argument_list|(
name|saidx
operator|->
name|proto
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"key_acquire: invalid proto is passed.\n"
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|IPSEC_NONBLOCK_ACQUIRE
comment|/* 	 * We never do anything about acquirng SA.  There is anather 	 * solution that kernel blocks to send SADB_ACQUIRE message until 	 * getting something message from IKEd.  In later case, to be 	 * managed with ACQUIRING list. 	 */
comment|/* get a entry to check whether sending message or not. */
if|if
condition|(
operator|(
name|newacq
operator|=
name|key_getacq
argument_list|(
name|saidx
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|key_blockacq_count
operator|<
name|newacq
operator|->
name|count
condition|)
block|{
comment|/* reset counter and do send message. */
name|newacq
operator|->
name|count
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* increment counter and do nothing. */
name|newacq
operator|->
name|count
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
else|else
block|{
comment|/* make new entry for blocking to send SADB_ACQUIRE. */
if|if
condition|(
operator|(
name|newacq
operator|=
name|key_newacq
argument_list|(
name|saidx
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|ENOBUFS
return|;
comment|/* add to acqtree */
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|acqtree
argument_list|,
name|newacq
argument_list|,
name|chain
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|IPSEC_NONBLOCK_ACQUIRE
name|seq
operator|=
name|newacq
operator|->
name|seq
expr_stmt|;
else|#
directive|else
name|seq
operator|=
operator|(
name|acq_seq
operator|=
operator|(
name|acq_seq
operator|==
operator|~
literal|0
condition|?
literal|1
else|:
operator|++
name|acq_seq
operator|)
operator|)
expr_stmt|;
endif|#
directive|endif
name|m
operator|=
name|key_setsadbmsg
argument_list|(
name|SADB_ACQUIRE
argument_list|,
literal|0
argument_list|,
name|satype
argument_list|,
name|seq
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|result
operator|=
name|m
expr_stmt|;
comment|/* set sadb_address for saidx's. */
name|m
operator|=
name|key_setsadbaddr
argument_list|(
name|SADB_EXT_ADDRESS_SRC
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|saidx
operator|->
name|src
argument_list|,
name|FULLMASK
argument_list|,
name|IPSEC_ULPROTO_ANY
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|m_cat
argument_list|(
name|result
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|key_setsadbaddr
argument_list|(
name|SADB_EXT_ADDRESS_DST
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|saidx
operator|->
name|dst
argument_list|,
name|FULLMASK
argument_list|,
name|IPSEC_ULPROTO_ANY
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|m_cat
argument_list|(
name|result
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* XXX proxy address (optional) */
comment|/* set sadb_x_policy */
if|if
condition|(
name|sp
condition|)
block|{
name|m
operator|=
name|key_setsadbxpolicy
argument_list|(
name|sp
operator|->
name|policy
argument_list|,
name|sp
operator|->
name|spidx
operator|.
name|dir
argument_list|,
name|sp
operator|->
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|m_cat
argument_list|(
name|result
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
comment|/* XXX identity (optional) */
if|#
directive|if
literal|0
block|if (idexttype&& fqdn) {
comment|/* create identity extension (FQDN) */
block|struct sadb_ident *id; 		int fqdnlen;  		fqdnlen = strlen(fqdn) + 1;
comment|/* +1 for terminating-NUL */
block|id = (struct sadb_ident *)p; 		bzero(id, sizeof(*id) + PFKEY_ALIGN8(fqdnlen)); 		id->sadb_ident_len = PFKEY_UNIT64(sizeof(*id) + PFKEY_ALIGN8(fqdnlen)); 		id->sadb_ident_exttype = idexttype; 		id->sadb_ident_type = SADB_IDENTTYPE_FQDN; 		bcopy(fqdn, id + 1, fqdnlen); 		p += sizeof(struct sadb_ident) + PFKEY_ALIGN8(fqdnlen); 	}  	if (idexttype) {
comment|/* create identity extension (USERFQDN) */
block|struct sadb_ident *id; 		int userfqdnlen;  		if (userfqdn) {
comment|/* +1 for terminating-NUL */
block|userfqdnlen = strlen(userfqdn) + 1; 		} else 			userfqdnlen = 0; 		id = (struct sadb_ident *)p; 		bzero(id, sizeof(*id) + PFKEY_ALIGN8(userfqdnlen)); 		id->sadb_ident_len = PFKEY_UNIT64(sizeof(*id) + PFKEY_ALIGN8(userfqdnlen)); 		id->sadb_ident_exttype = idexttype; 		id->sadb_ident_type = SADB_IDENTTYPE_USERFQDN;
comment|/* XXX is it correct? */
block|if (curproc&& curproc->p_cred) 			id->sadb_ident_id = curproc->p_cred->p_ruid; 		if (userfqdn&& userfqdnlen) 			bcopy(userfqdn, id + 1, userfqdnlen); 		p += sizeof(struct sadb_ident) + PFKEY_ALIGN8(userfqdnlen); 	}
endif|#
directive|endif
comment|/* XXX sensitivity (optional) */
comment|/* create proposal/combination extension */
name|m
operator|=
name|key_getprop
argument_list|(
name|saidx
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* 	 * spec conformant: always attach proposal/combination extension, 	 * the problem is that we have no way to attach it for ipcomp, 	 * due to the way sadb_comb is declared in RFC2367. 	 */
block|if (!m) { 		error = ENOBUFS; 		goto fail; 	} 	m_cat(result, m);
else|#
directive|else
comment|/* 	 * outside of spec; make proposal/combination extension optional. 	 */
if|if
condition|(
name|m
condition|)
name|m_cat
argument_list|(
name|result
argument_list|,
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|result
operator|->
name|m_flags
operator|&
name|M_PKTHDR
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|result
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
condition|)
block|{
name|result
operator|=
name|m_pullup
argument_list|(
name|result
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
name|result
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|m
operator|=
name|result
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
name|result
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|mtod
argument_list|(
name|result
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|)
operator|->
name|sadb_msg_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|result
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
return|return
name|key_sendup_mbuf
argument_list|(
name|NULL
argument_list|,
name|result
argument_list|,
name|KEY_SENDUP_REGISTERED
argument_list|)
return|;
name|fail
label|:
if|if
condition|(
name|result
condition|)
name|m_freem
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|IPSEC_NONBLOCK_ACQUIRE
end_ifndef

begin_function
specifier|static
name|struct
name|secacq
modifier|*
name|key_newacq
parameter_list|(
name|saidx
parameter_list|)
name|struct
name|secasindex
modifier|*
name|saidx
decl_stmt|;
block|{
name|struct
name|secacq
modifier|*
name|newacq
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
comment|/* get new entry */
name|KMALLOC
argument_list|(
name|newacq
argument_list|,
expr|struct
name|secacq
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|secacq
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newacq
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_newacq: No more memory.\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|bzero
argument_list|(
name|newacq
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|newacq
argument_list|)
argument_list|)
expr_stmt|;
comment|/* copy secindex */
name|bcopy
argument_list|(
name|saidx
argument_list|,
operator|&
name|newacq
operator|->
name|saidx
argument_list|,
sizeof|sizeof
argument_list|(
name|newacq
operator|->
name|saidx
argument_list|)
argument_list|)
expr_stmt|;
name|newacq
operator|->
name|seq
operator|=
operator|(
name|acq_seq
operator|==
operator|~
literal|0
condition|?
literal|1
else|:
operator|++
name|acq_seq
operator|)
expr_stmt|;
name|microtime
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
name|newacq
operator|->
name|created
operator|=
name|tv
operator|.
name|tv_sec
expr_stmt|;
name|newacq
operator|->
name|count
operator|=
literal|0
expr_stmt|;
return|return
name|newacq
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|secacq
modifier|*
name|key_getacq
parameter_list|(
name|saidx
parameter_list|)
name|struct
name|secasindex
modifier|*
name|saidx
decl_stmt|;
block|{
name|struct
name|secacq
modifier|*
name|acq
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|acq
argument_list|,
argument|&acqtree
argument_list|,
argument|chain
argument_list|)
block|{
if|if
condition|(
name|key_cmpsaidx
argument_list|(
name|saidx
argument_list|,
operator|&
name|acq
operator|->
name|saidx
argument_list|,
name|CMP_EXACTLY
argument_list|)
condition|)
return|return
name|acq
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|secacq
modifier|*
name|key_getacqbyseq
parameter_list|(
name|seq
parameter_list|)
name|u_int32_t
name|seq
decl_stmt|;
block|{
name|struct
name|secacq
modifier|*
name|acq
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|acq
argument_list|,
argument|&acqtree
argument_list|,
argument|chain
argument_list|)
block|{
if|if
condition|(
name|acq
operator|->
name|seq
operator|==
name|seq
condition|)
return|return
name|acq
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|struct
name|secspacq
modifier|*
name|key_newspacq
parameter_list|(
name|spidx
parameter_list|)
name|struct
name|secpolicyindex
modifier|*
name|spidx
decl_stmt|;
block|{
name|struct
name|secspacq
modifier|*
name|acq
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
comment|/* get new entry */
name|KMALLOC
argument_list|(
name|acq
argument_list|,
expr|struct
name|secspacq
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|secspacq
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|acq
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_newspacq: No more memory.\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|bzero
argument_list|(
name|acq
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|acq
argument_list|)
argument_list|)
expr_stmt|;
comment|/* copy secindex */
name|bcopy
argument_list|(
name|spidx
argument_list|,
operator|&
name|acq
operator|->
name|spidx
argument_list|,
sizeof|sizeof
argument_list|(
name|acq
operator|->
name|spidx
argument_list|)
argument_list|)
expr_stmt|;
name|microtime
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
name|acq
operator|->
name|created
operator|=
name|tv
operator|.
name|tv_sec
expr_stmt|;
name|acq
operator|->
name|count
operator|=
literal|0
expr_stmt|;
return|return
name|acq
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|secspacq
modifier|*
name|key_getspacq
parameter_list|(
name|spidx
parameter_list|)
name|struct
name|secpolicyindex
modifier|*
name|spidx
decl_stmt|;
block|{
name|struct
name|secspacq
modifier|*
name|acq
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|acq
argument_list|,
argument|&spacqtree
argument_list|,
argument|chain
argument_list|)
block|{
if|if
condition|(
name|key_cmpspidx_exactly
argument_list|(
name|spidx
argument_list|,
operator|&
name|acq
operator|->
name|spidx
argument_list|)
condition|)
return|return
name|acq
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * SADB_ACQUIRE processing,  * in first situation, is receiving  *<base>  * from the ikmpd, and clear sequence of its secasvar entry.  *  * In second situation, is receiving  *<base, address(SD), (address(P),) (identity(SD),) (sensitivity,) proposal>  * from a user land process, and return  *<base, address(SD), (address(P),) (identity(SD),) (sensitivity,) proposal>  * to the socket.  *  * m will always be freed.  */
end_comment

begin_function
specifier|static
name|int
name|key_acquire2
parameter_list|(
name|so
parameter_list|,
name|m
parameter_list|,
name|mhp
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|const
name|struct
name|sadb_msghdr
modifier|*
name|mhp
decl_stmt|;
block|{
specifier|const
name|struct
name|sadb_address
modifier|*
name|src0
decl_stmt|,
modifier|*
name|dst0
decl_stmt|;
name|struct
name|secasindex
name|saidx
decl_stmt|;
name|struct
name|secashead
modifier|*
name|sah
decl_stmt|;
name|u_int16_t
name|proto
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* sanity check */
if|if
condition|(
name|so
operator|==
name|NULL
operator|||
name|m
operator|==
name|NULL
operator|||
name|mhp
operator|==
name|NULL
operator|||
name|mhp
operator|->
name|msg
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_acquire2: NULL pointer is passed.\n"
argument_list|)
expr_stmt|;
comment|/* 	 * Error message from KMd. 	 * We assume that if error was occured in IKEd, the length of PFKEY 	 * message is equal to the size of sadb_msg structure. 	 * We do not raise error even if error occured in this function. 	 */
if|if
condition|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_len
operator|==
name|PFKEY_UNIT64
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|)
condition|)
block|{
ifndef|#
directive|ifndef
name|IPSEC_NONBLOCK_ACQUIRE
name|struct
name|secacq
modifier|*
name|acq
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
comment|/* check sequence number */
if|if
condition|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_seq
operator|==
literal|0
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_acquire2: must specify sequence number.\n"
operator|)
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
name|acq
operator|=
name|key_getacqbyseq
argument_list|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_seq
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * the specified larval SA is already gone, or we got 			 * a bogus sequence number.  we can silently ignore it. 			 */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* reset acq counter in order to deletion by timehander. */
name|microtime
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
name|acq
operator|->
name|created
operator|=
name|tv
operator|.
name|tv_sec
expr_stmt|;
name|acq
operator|->
name|count
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * This message is from user land. 	 */
comment|/* map satype to proto */
if|if
condition|(
operator|(
name|proto
operator|=
name|key_satype2proto
argument_list|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_satype
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_acquire2: invalid satype is passed.\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
operator|==
name|NULL
operator|||
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_DST
index|]
operator|==
name|NULL
operator|||
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_PROPOSAL
index|]
operator|==
name|NULL
condition|)
block|{
comment|/* error */
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_acquire2: invalid message is passed.\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|mhp
operator|->
name|extlen
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_address
argument_list|)
operator|||
name|mhp
operator|->
name|extlen
index|[
name|SADB_EXT_ADDRESS_DST
index|]
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_address
argument_list|)
operator|||
name|mhp
operator|->
name|extlen
index|[
name|SADB_EXT_PROPOSAL
index|]
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_prop
argument_list|)
condition|)
block|{
comment|/* error */
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_acquire2: invalid message is passed.\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
name|src0
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
expr_stmt|;
name|dst0
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
name|mhp
operator|->
name|ext
index|[
name|SADB_EXT_ADDRESS_DST
index|]
expr_stmt|;
comment|/* XXX boundary check against sa_len */
name|KEY_SETSECASIDX
argument_list|(
name|proto
argument_list|,
name|IPSEC_MODE_ANY
argument_list|,
literal|0
argument_list|,
name|src0
operator|+
literal|1
argument_list|,
name|dst0
operator|+
literal|1
argument_list|,
operator|&
name|saidx
argument_list|)
expr_stmt|;
comment|/* get a SA index */
name|LIST_FOREACH
argument_list|(
argument|sah
argument_list|,
argument|&sahtree
argument_list|,
argument|chain
argument_list|)
block|{
if|if
condition|(
name|sah
operator|->
name|state
operator|==
name|SADB_SASTATE_DEAD
condition|)
continue|continue;
if|if
condition|(
name|key_cmpsaidx
argument_list|(
operator|&
name|sah
operator|->
name|saidx
argument_list|,
operator|&
name|saidx
argument_list|,
name|CMP_MODE_REQID
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|sah
operator|!=
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_acquire2: a SA exists already.\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EEXIST
argument_list|)
return|;
block|}
name|error
operator|=
name|key_acquire
argument_list|(
operator|&
name|saidx
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_acquire2: error %d returned "
literal|"from key_acquire.\n"
operator|,
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_errno
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|error
argument_list|)
return|;
block|}
return|return
name|key_sendup_mbuf
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|KEY_SENDUP_REGISTERED
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * SADB_REGISTER processing.  * If SATYPE_UNSPEC has been passed as satype, only return sabd_supported.  * receive  *<base>  * from the ikmpd, and register a socket to send PF_KEY messages,  * and send  *<base, supported>  * to KMD by PF_KEY.  * If socket is detached, must free from regnode.  *  * m will always be freed.  */
end_comment

begin_function
specifier|static
name|int
name|key_register
parameter_list|(
name|so
parameter_list|,
name|m
parameter_list|,
name|mhp
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|const
name|struct
name|sadb_msghdr
modifier|*
name|mhp
decl_stmt|;
block|{
name|struct
name|secreg
modifier|*
name|reg
decl_stmt|,
modifier|*
name|newreg
init|=
literal|0
decl_stmt|;
comment|/* sanity check */
if|if
condition|(
name|so
operator|==
name|NULL
operator|||
name|m
operator|==
name|NULL
operator|||
name|mhp
operator|==
name|NULL
operator|||
name|mhp
operator|->
name|msg
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_register: NULL pointer is passed.\n"
argument_list|)
expr_stmt|;
comment|/* check for invalid register message */
if|if
condition|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_satype
operator|>=
sizeof|sizeof
argument_list|(
name|regtree
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|regtree
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
comment|/* When SATYPE_UNSPEC is specified, only return sabd_supported. */
if|if
condition|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_satype
operator|==
name|SADB_SATYPE_UNSPEC
condition|)
goto|goto
name|setmsg
goto|;
comment|/* check whether existing or not */
name|LIST_FOREACH
argument_list|(
argument|reg
argument_list|,
argument|&regtree[mhp->msg->sadb_msg_satype]
argument_list|,
argument|chain
argument_list|)
block|{
if|if
condition|(
name|reg
operator|->
name|so
operator|==
name|so
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_register: socket exists already.\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EEXIST
argument_list|)
return|;
block|}
block|}
comment|/* create regnode */
name|KMALLOC
argument_list|(
name|newreg
argument_list|,
expr|struct
name|secreg
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|newreg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newreg
operator|==
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_register: No more memory.\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOBUFS
argument_list|)
return|;
block|}
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|newreg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|newreg
argument_list|)
argument_list|)
expr_stmt|;
name|newreg
operator|->
name|so
operator|=
name|so
expr_stmt|;
operator|(
operator|(
expr|struct
name|keycb
operator|*
operator|)
name|sotorawcb
argument_list|(
name|so
argument_list|)
operator|)
operator|->
name|kp_registered
operator|++
expr_stmt|;
comment|/* add regnode to regtree. */
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|regtree
index|[
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_satype
index|]
argument_list|,
name|newreg
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|setmsg
label|:
block|{
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
name|struct
name|sadb_msg
modifier|*
name|newmsg
decl_stmt|;
name|struct
name|sadb_supported
modifier|*
name|sup
decl_stmt|;
name|u_int
name|len
decl_stmt|,
name|alen
decl_stmt|,
name|elen
decl_stmt|;
name|int
name|off
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|sadb_alg
modifier|*
name|alg
decl_stmt|;
comment|/* create new sadb_msg to reply. */
name|alen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|SADB_AALG_MAX
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ah_algorithm_lookup
argument_list|(
name|i
argument_list|)
condition|)
name|alen
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_alg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|alen
condition|)
name|alen
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_supported
argument_list|)
expr_stmt|;
name|elen
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|IPSEC_ESP
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|SADB_EALG_MAX
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|esp_algorithm_lookup
argument_list|(
name|i
argument_list|)
condition|)
name|elen
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_alg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|elen
condition|)
name|elen
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_supported
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
operator|+
name|alen
operator|+
name|elen
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|MCLBYTES
condition|)
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOBUFS
argument_list|)
return|;
name|MGETHDR
argument_list|(
name|n
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|MHLEN
condition|)
block|{
name|MCLGET
argument_list|(
name|n
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|n
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|n
condition|)
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOBUFS
argument_list|)
return|;
name|n
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|n
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
name|n
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
name|off
operator|=
literal|0
expr_stmt|;
name|m_copydata
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|,
name|mtod
argument_list|(
name|n
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|off
argument_list|)
expr_stmt|;
name|newmsg
operator|=
name|mtod
argument_list|(
name|n
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|)
expr_stmt|;
name|newmsg
operator|->
name|sadb_msg_errno
operator|=
literal|0
expr_stmt|;
name|newmsg
operator|->
name|sadb_msg_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|off
operator|+=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|)
expr_stmt|;
comment|/* for authentication algorithm */
if|if
condition|(
name|alen
condition|)
block|{
name|sup
operator|=
operator|(
expr|struct
name|sadb_supported
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|n
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|off
operator|)
expr_stmt|;
name|sup
operator|->
name|sadb_supported_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|alen
argument_list|)
expr_stmt|;
name|sup
operator|->
name|sadb_supported_exttype
operator|=
name|SADB_EXT_SUPPORTED_AUTH
expr_stmt|;
name|off
operator|+=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sup
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|SADB_AALG_MAX
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|struct
name|ah_algorithm
modifier|*
name|aalgo
decl_stmt|;
name|aalgo
operator|=
name|ah_algorithm_lookup
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|aalgo
condition|)
continue|continue;
name|alg
operator|=
operator|(
expr|struct
name|sadb_alg
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|n
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|off
operator|)
expr_stmt|;
name|alg
operator|->
name|sadb_alg_id
operator|=
name|i
expr_stmt|;
name|alg
operator|->
name|sadb_alg_ivlen
operator|=
literal|0
expr_stmt|;
name|alg
operator|->
name|sadb_alg_minbits
operator|=
name|aalgo
operator|->
name|keymin
expr_stmt|;
name|alg
operator|->
name|sadb_alg_maxbits
operator|=
name|aalgo
operator|->
name|keymax
expr_stmt|;
name|off
operator|+=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|alg
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|IPSEC_ESP
comment|/* for encryption algorithm */
if|if
condition|(
name|elen
condition|)
block|{
name|sup
operator|=
operator|(
expr|struct
name|sadb_supported
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|n
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|off
operator|)
expr_stmt|;
name|sup
operator|->
name|sadb_supported_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|elen
argument_list|)
expr_stmt|;
name|sup
operator|->
name|sadb_supported_exttype
operator|=
name|SADB_EXT_SUPPORTED_ENCRYPT
expr_stmt|;
name|off
operator|+=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sup
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|SADB_EALG_MAX
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|struct
name|esp_algorithm
modifier|*
name|ealgo
decl_stmt|;
name|ealgo
operator|=
name|esp_algorithm_lookup
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ealgo
condition|)
continue|continue;
name|alg
operator|=
operator|(
expr|struct
name|sadb_alg
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|n
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|off
operator|)
expr_stmt|;
name|alg
operator|->
name|sadb_alg_id
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|ealgo
operator|&&
name|ealgo
operator|->
name|ivlen
condition|)
block|{
comment|/* 				 * give NULL to get the value preferred by 				 * algorithm XXX SADB_X_EXT_DERIV ? 				 */
name|alg
operator|->
name|sadb_alg_ivlen
operator|=
call|(
modifier|*
name|ealgo
operator|->
name|ivlen
call|)
argument_list|(
name|ealgo
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
name|alg
operator|->
name|sadb_alg_ivlen
operator|=
literal|0
expr_stmt|;
name|alg
operator|->
name|sadb_alg_minbits
operator|=
name|ealgo
operator|->
name|keymin
expr_stmt|;
name|alg
operator|->
name|sadb_alg_maxbits
operator|=
name|ealgo
operator|->
name|keymax
expr_stmt|;
name|off
operator|+=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_alg
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DIGAGNOSTIC
if|if
condition|(
name|off
operator|!=
name|len
condition|)
name|panic
argument_list|(
literal|"length assumption failed in key_register"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|key_sendup_mbuf
argument_list|(
name|so
argument_list|,
name|n
argument_list|,
name|KEY_SENDUP_REGISTERED
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * free secreg entry registered.  * XXX: I want to do free a socket marked done SADB_RESIGER to socket.  */
end_comment

begin_function
name|void
name|key_freereg
parameter_list|(
name|so
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
block|{
name|struct
name|secreg
modifier|*
name|reg
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* sanity check */
if|if
condition|(
name|so
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_freereg: NULL pointer is passed.\n"
argument_list|)
expr_stmt|;
comment|/* 	 * check whether existing or not. 	 * check all type of SA, because there is a potential that 	 * one socket is registered to multiple type of SA. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|SADB_SATYPE_MAX
condition|;
name|i
operator|++
control|)
block|{
name|LIST_FOREACH
argument_list|(
argument|reg
argument_list|,
argument|&regtree[i]
argument_list|,
argument|chain
argument_list|)
block|{
if|if
condition|(
name|reg
operator|->
name|so
operator|==
name|so
operator|&&
name|__LIST_CHAINED
argument_list|(
name|reg
argument_list|)
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|reg
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|KFREE
argument_list|(
name|reg
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * SADB_EXPIRE processing  * send  *<base, SA, SA2, lifetime(C and one of HS), address(SD)>  * to KMD by PF_KEY.  * NOTE: We send only soft lifetime extension.  *  * OUT:	0	: succeed  *	others	: error number  */
end_comment

begin_function
specifier|static
name|int
name|key_expire
parameter_list|(
name|sav
parameter_list|)
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|;
block|{
name|int
name|s
decl_stmt|;
name|int
name|satype
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|result
init|=
name|NULL
decl_stmt|,
modifier|*
name|m
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|error
init|=
operator|-
literal|1
decl_stmt|;
name|struct
name|sadb_lifetime
modifier|*
name|lt
decl_stmt|;
comment|/* XXX: Why do we lock ? */
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
comment|/*called from softclock()*/
comment|/* sanity check */
if|if
condition|(
name|sav
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_expire: NULL pointer is passed.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|sah
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_expire: Why was SA index in SA NULL.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|satype
operator|=
name|key_proto2satype
argument_list|(
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|proto
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"key_expire: invalid proto is passed.\n"
argument_list|)
expr_stmt|;
comment|/* set msg header */
name|m
operator|=
name|key_setsadbmsg
argument_list|(
name|SADB_EXPIRE
argument_list|,
literal|0
argument_list|,
name|satype
argument_list|,
name|sav
operator|->
name|seq
argument_list|,
literal|0
argument_list|,
name|sav
operator|->
name|refcnt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|result
operator|=
name|m
expr_stmt|;
comment|/* create SA extension */
name|m
operator|=
name|key_setsadbsa
argument_list|(
name|sav
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|m_cat
argument_list|(
name|result
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* create SA extension */
name|m
operator|=
name|key_setsadbxsa2
argument_list|(
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|mode
argument_list|,
name|sav
operator|->
name|replay
condition|?
name|sav
operator|->
name|replay
operator|->
name|count
else|:
literal|0
argument_list|,
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|reqid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|m_cat
argument_list|(
name|result
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* create lifetime extension (current and soft) */
name|len
operator|=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|lt
argument_list|)
argument_list|)
operator|*
literal|2
expr_stmt|;
name|m
operator|=
name|key_alloc_mbuf
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
operator|||
name|m
operator|->
name|m_next
condition|)
block|{
comment|/*XXX*/
if|if
condition|(
name|m
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|bzero
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|lt
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sadb_lifetime
operator|*
argument_list|)
expr_stmt|;
name|lt
operator|->
name|sadb_lifetime_len
operator|=
name|PFKEY_UNIT64
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_lifetime
argument_list|)
argument_list|)
expr_stmt|;
name|lt
operator|->
name|sadb_lifetime_exttype
operator|=
name|SADB_EXT_LIFETIME_CURRENT
expr_stmt|;
name|lt
operator|->
name|sadb_lifetime_allocations
operator|=
name|sav
operator|->
name|lft_c
operator|->
name|sadb_lifetime_allocations
expr_stmt|;
name|lt
operator|->
name|sadb_lifetime_bytes
operator|=
name|sav
operator|->
name|lft_c
operator|->
name|sadb_lifetime_bytes
expr_stmt|;
name|lt
operator|->
name|sadb_lifetime_addtime
operator|=
name|sav
operator|->
name|lft_c
operator|->
name|sadb_lifetime_addtime
expr_stmt|;
name|lt
operator|->
name|sadb_lifetime_usetime
operator|=
name|sav
operator|->
name|lft_c
operator|->
name|sadb_lifetime_usetime
expr_stmt|;
name|lt
operator|=
operator|(
expr|struct
name|sadb_lifetime
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|len
operator|/
literal|2
operator|)
expr_stmt|;
name|bcopy
argument_list|(
name|sav
operator|->
name|lft_s
argument_list|,
name|lt
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lt
argument_list|)
argument_list|)
expr_stmt|;
name|m_cat
argument_list|(
name|result
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* set sadb_address for source */
name|m
operator|=
name|key_setsadbaddr
argument_list|(
name|SADB_EXT_ADDRESS_SRC
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|src
argument_list|,
name|FULLMASK
argument_list|,
name|IPSEC_ULPROTO_ANY
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|m_cat
argument_list|(
name|result
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* set sadb_address for destination */
name|m
operator|=
name|key_setsadbaddr
argument_list|(
name|SADB_EXT_ADDRESS_DST
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sav
operator|->
name|sah
operator|->
name|saidx
operator|.
name|dst
argument_list|,
name|FULLMASK
argument_list|,
name|IPSEC_ULPROTO_ANY
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|m_cat
argument_list|(
name|result
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|result
operator|->
name|m_flags
operator|&
name|M_PKTHDR
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|result
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
condition|)
block|{
name|result
operator|=
name|m_pullup
argument_list|(
name|result
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
name|result
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|m
operator|=
name|result
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
name|result
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|mtod
argument_list|(
name|result
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|)
operator|->
name|sadb_msg_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|result
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
return|return
name|key_sendup_mbuf
argument_list|(
name|NULL
argument_list|,
name|result
argument_list|,
name|KEY_SENDUP_REGISTERED
argument_list|)
return|;
name|fail
label|:
if|if
condition|(
name|result
condition|)
name|m_freem
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * SADB_FLUSH processing  * receive  *<base>  * from the ikmpd, and free all entries in secastree.  * and send,  *<base>  * to the ikmpd.  * NOTE: to do is only marking SADB_SASTATE_DEAD.  *  * m will always be freed.  */
end_comment

begin_function
specifier|static
name|int
name|key_flush
parameter_list|(
name|so
parameter_list|,
name|m
parameter_list|,
name|mhp
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|const
name|struct
name|sadb_msghdr
modifier|*
name|mhp
decl_stmt|;
block|{
name|struct
name|sadb_msg
modifier|*
name|newmsg
decl_stmt|;
name|struct
name|secashead
modifier|*
name|sah
decl_stmt|,
modifier|*
name|nextsah
decl_stmt|;
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|,
modifier|*
name|nextsav
decl_stmt|;
name|u_int16_t
name|proto
decl_stmt|;
name|u_int8_t
name|state
decl_stmt|;
name|u_int
name|stateidx
decl_stmt|;
comment|/* sanity check */
if|if
condition|(
name|so
operator|==
name|NULL
operator|||
name|mhp
operator|==
name|NULL
operator|||
name|mhp
operator|->
name|msg
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_flush: NULL pointer is passed.\n"
argument_list|)
expr_stmt|;
comment|/* map satype to proto */
if|if
condition|(
operator|(
name|proto
operator|=
name|key_satype2proto
argument_list|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_satype
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_flush: invalid satype is passed.\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
comment|/* no SATYPE specified, i.e. flushing all SA. */
for|for
control|(
name|sah
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sahtree
argument_list|)
init|;
name|sah
operator|!=
name|NULL
condition|;
name|sah
operator|=
name|nextsah
control|)
block|{
name|nextsah
operator|=
name|LIST_NEXT
argument_list|(
name|sah
argument_list|,
name|chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_satype
operator|!=
name|SADB_SATYPE_UNSPEC
operator|&&
name|proto
operator|!=
name|sah
operator|->
name|saidx
operator|.
name|proto
condition|)
continue|continue;
for|for
control|(
name|stateidx
operator|=
literal|0
init|;
name|stateidx
operator|<
name|_ARRAYLEN
argument_list|(
name|saorder_state_alive
argument_list|)
condition|;
name|stateidx
operator|++
control|)
block|{
name|state
operator|=
name|saorder_state_any
index|[
name|stateidx
index|]
expr_stmt|;
for|for
control|(
name|sav
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sah
operator|->
name|savtree
index|[
name|state
index|]
argument_list|)
init|;
name|sav
operator|!=
name|NULL
condition|;
name|sav
operator|=
name|nextsav
control|)
block|{
name|nextsav
operator|=
name|LIST_NEXT
argument_list|(
name|sav
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|key_sa_chgstate
argument_list|(
name|sav
argument_list|,
name|SADB_SASTATE_DEAD
argument_list|)
expr_stmt|;
name|key_freesav
argument_list|(
name|sav
argument_list|)
expr_stmt|;
block|}
block|}
name|sah
operator|->
name|state
operator|=
name|SADB_SASTATE_DEAD
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
operator|||
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
operator|>
name|m
operator|->
name|m_len
operator|+
name|M_TRAILINGSPACE
argument_list|(
name|m
argument_list|)
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_flush: No more memory.\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOBUFS
argument_list|)
return|;
block|}
if|if
condition|(
name|m
operator|->
name|m_next
condition|)
name|m_freem
argument_list|(
name|m
operator|->
name|m_next
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
expr_stmt|;
name|newmsg
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|)
expr_stmt|;
name|newmsg
operator|->
name|sadb_msg_errno
operator|=
literal|0
expr_stmt|;
name|newmsg
operator|->
name|sadb_msg_len
operator|=
name|PFKEY_UNIT64
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
return|return
name|key_sendup_mbuf
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|KEY_SENDUP_ALL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * SADB_DUMP processing  * dump all entries including status of DEAD in SAD.  * receive  *<base>  * from the ikmpd, and dump all secasvar leaves  * and send,  *<base> .....  * to the ikmpd.  *  * m will always be freed.  */
end_comment

begin_function
specifier|static
name|int
name|key_dump
parameter_list|(
name|so
parameter_list|,
name|m
parameter_list|,
name|mhp
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|const
name|struct
name|sadb_msghdr
modifier|*
name|mhp
decl_stmt|;
block|{
name|struct
name|secashead
modifier|*
name|sah
decl_stmt|;
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|;
name|u_int16_t
name|proto
decl_stmt|;
name|u_int
name|stateidx
decl_stmt|;
name|u_int8_t
name|satype
decl_stmt|;
name|u_int8_t
name|state
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|struct
name|sadb_msg
modifier|*
name|newmsg
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
comment|/* sanity check */
if|if
condition|(
name|so
operator|==
name|NULL
operator|||
name|m
operator|==
name|NULL
operator|||
name|mhp
operator|==
name|NULL
operator|||
name|mhp
operator|->
name|msg
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_dump: NULL pointer is passed.\n"
argument_list|)
expr_stmt|;
comment|/* map satype to proto */
if|if
condition|(
operator|(
name|proto
operator|=
name|key_satype2proto
argument_list|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_satype
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_dump: invalid satype is passed.\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
comment|/* count sav entries to be sent to the userland. */
name|cnt
operator|=
literal|0
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|sah
argument_list|,
argument|&sahtree
argument_list|,
argument|chain
argument_list|)
block|{
if|if
condition|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_satype
operator|!=
name|SADB_SATYPE_UNSPEC
operator|&&
name|proto
operator|!=
name|sah
operator|->
name|saidx
operator|.
name|proto
condition|)
continue|continue;
for|for
control|(
name|stateidx
operator|=
literal|0
init|;
name|stateidx
operator|<
name|_ARRAYLEN
argument_list|(
name|saorder_state_any
argument_list|)
condition|;
name|stateidx
operator|++
control|)
block|{
name|state
operator|=
name|saorder_state_any
index|[
name|stateidx
index|]
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|sav
argument_list|,
argument|&sah->savtree[state]
argument_list|,
argument|chain
argument_list|)
block|{
name|cnt
operator|++
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|cnt
operator|==
literal|0
condition|)
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOENT
argument_list|)
return|;
comment|/* send this to the userland, one at a time. */
name|newmsg
operator|=
name|NULL
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|sah
argument_list|,
argument|&sahtree
argument_list|,
argument|chain
argument_list|)
block|{
if|if
condition|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_satype
operator|!=
name|SADB_SATYPE_UNSPEC
operator|&&
name|proto
operator|!=
name|sah
operator|->
name|saidx
operator|.
name|proto
condition|)
continue|continue;
comment|/* map proto to satype */
if|if
condition|(
operator|(
name|satype
operator|=
name|key_proto2satype
argument_list|(
name|sah
operator|->
name|saidx
operator|.
name|proto
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_dump: there was invalid proto in SAD.\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
for|for
control|(
name|stateidx
operator|=
literal|0
init|;
name|stateidx
operator|<
name|_ARRAYLEN
argument_list|(
name|saorder_state_any
argument_list|)
condition|;
name|stateidx
operator|++
control|)
block|{
name|state
operator|=
name|saorder_state_any
index|[
name|stateidx
index|]
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|sav
argument_list|,
argument|&sah->savtree[state]
argument_list|,
argument|chain
argument_list|)
block|{
name|n
operator|=
name|key_setdumpsa
argument_list|(
name|sav
argument_list|,
name|SADB_DUMP
argument_list|,
name|satype
argument_list|,
operator|--
name|cnt
argument_list|,
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_pid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|ENOBUFS
argument_list|)
return|;
name|key_sendup_mbuf
argument_list|(
name|so
argument_list|,
name|n
argument_list|,
name|KEY_SENDUP_ONE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * SADB_X_PROMISC processing  *  * m will always be freed.  */
end_comment

begin_function
specifier|static
name|int
name|key_promisc
parameter_list|(
name|so
parameter_list|,
name|m
parameter_list|,
name|mhp
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|const
name|struct
name|sadb_msghdr
modifier|*
name|mhp
decl_stmt|;
block|{
name|int
name|olen
decl_stmt|;
comment|/* sanity check */
if|if
condition|(
name|so
operator|==
name|NULL
operator|||
name|m
operator|==
name|NULL
operator|||
name|mhp
operator|==
name|NULL
operator|||
name|mhp
operator|->
name|msg
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_promisc: NULL pointer is passed.\n"
argument_list|)
expr_stmt|;
name|olen
operator|=
name|PFKEY_UNUNIT64
argument_list|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|olen
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
condition|)
block|{
if|#
directive|if
literal|1
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
else|#
directive|else
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|olen
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
condition|)
block|{
comment|/* enable/disable promisc mode */
name|struct
name|keycb
modifier|*
name|kp
decl_stmt|;
if|if
condition|(
operator|(
name|kp
operator|=
operator|(
expr|struct
name|keycb
operator|*
operator|)
name|sotorawcb
argument_list|(
name|so
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_errno
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_satype
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|1
case|:
name|kp
operator|->
name|kp_promisc
operator|=
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_satype
expr_stmt|;
break|break;
default|default:
return|return
name|key_senderror
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|EINVAL
argument_list|)
return|;
block|}
comment|/* send the original message back to everyone */
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_errno
operator|=
literal|0
expr_stmt|;
return|return
name|key_sendup_mbuf
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|KEY_SENDUP_ALL
argument_list|)
return|;
block|}
else|else
block|{
comment|/* send packet as is */
name|m_adj
argument_list|(
name|m
argument_list|,
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* TODO: if sadb_msg_seq is specified, send to specific pid */
return|return
name|key_sendup_mbuf
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|KEY_SENDUP_ALL
argument_list|)
return|;
block|}
block|}
end_function

begin_expr_stmt
specifier|static
name|int
argument_list|(
argument|*key_typesw[]
argument_list|)
name|__P
argument_list|(
operator|(
expr|struct
name|socket
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|,
specifier|const
expr|struct
name|sadb_msghdr
operator|*
operator|)
argument_list|)
operator|=
block|{
name|NULL
block|,
comment|/* SADB_RESERVED */
name|key_getspi
block|,
comment|/* SADB_GETSPI */
name|key_update
block|,
comment|/* SADB_UPDATE */
name|key_add
block|,
comment|/* SADB_ADD */
name|key_delete
block|,
comment|/* SADB_DELETE */
name|key_get
block|,
comment|/* SADB_GET */
name|key_acquire2
block|,
comment|/* SADB_ACQUIRE */
name|key_register
block|,
comment|/* SADB_REGISTER */
name|NULL
block|,
comment|/* SADB_EXPIRE */
name|key_flush
block|,
comment|/* SADB_FLUSH */
name|key_dump
block|,
comment|/* SADB_DUMP */
name|key_promisc
block|,
comment|/* SADB_X_PROMISC */
name|NULL
block|,
comment|/* SADB_X_PCHANGE */
name|key_spdadd
block|,
comment|/* SADB_X_SPDUPDATE */
name|key_spdadd
block|,
comment|/* SADB_X_SPDADD */
name|key_spddelete
block|,
comment|/* SADB_X_SPDDELETE */
name|key_spdget
block|,
comment|/* SADB_X_SPDGET */
name|NULL
block|,
comment|/* SADB_X_SPDACQUIRE */
name|key_spddump
block|,
comment|/* SADB_X_SPDDUMP */
name|key_spdflush
block|,
comment|/* SADB_X_SPDFLUSH */
name|key_spdadd
block|,
comment|/* SADB_X_SPDSETIDX */
name|NULL
block|,
comment|/* SADB_X_SPDEXPIRE */
name|key_spddelete2
block|,
comment|/* SADB_X_SPDDELETE2 */
block|}
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * parse sadb_msg buffer to process PFKEYv2,  * and create a data to response if needed.  * I think to be dealed with mbuf directly.  * IN:  *     msgp  : pointer to pointer to a received buffer pulluped.  *             This is rewrited to response.  *     so    : pointer to socket.  * OUT:  *    length for buffer to send to user process.  */
end_comment

begin_function
name|int
name|key_parse
parameter_list|(
name|m
parameter_list|,
name|so
parameter_list|)
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
block|{
name|struct
name|sadb_msg
modifier|*
name|msg
decl_stmt|;
name|struct
name|sadb_msghdr
name|mh
decl_stmt|;
name|u_int
name|orglen
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|target
decl_stmt|;
comment|/* sanity check */
if|if
condition|(
name|m
operator|==
name|NULL
operator|||
name|so
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_parse: NULL pointer is passed.\n"
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/*kdebug_sadb assumes msg in linear buffer*/
block|KEYDEBUG(KEYDEBUG_KEY_DUMP, 		ipseclog((LOG_DEBUG, "key_parse: passed sadb_msg\n")); 		kdebug_sadb(msg));
endif|#
directive|endif
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
condition|)
block|{
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
return|return
name|ENOBUFS
return|;
block|}
name|msg
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|)
expr_stmt|;
name|orglen
operator|=
name|PFKEY_UNUNIT64
argument_list|(
name|msg
operator|->
name|sadb_msg_len
argument_list|)
expr_stmt|;
name|target
operator|=
name|KEY_SENDUP_ONE
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_PKTHDR
operator|)
operator|==
literal|0
operator|||
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|!=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_parse: invalid message length.\n"
operator|)
argument_list|)
expr_stmt|;
name|pfkeystat
operator|.
name|out_invlen
operator|++
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|senderror
goto|;
block|}
if|if
condition|(
name|msg
operator|->
name|sadb_msg_version
operator|!=
name|PF_KEY_V2
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_parse: PF_KEY version %u is mismatched.\n"
operator|,
name|msg
operator|->
name|sadb_msg_version
operator|)
argument_list|)
expr_stmt|;
name|pfkeystat
operator|.
name|out_invver
operator|++
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|senderror
goto|;
block|}
if|if
condition|(
name|msg
operator|->
name|sadb_msg_type
operator|>
name|SADB_MAX
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_parse: invalid type %u is passed.\n"
operator|,
name|msg
operator|->
name|sadb_msg_type
operator|)
argument_list|)
expr_stmt|;
name|pfkeystat
operator|.
name|out_invmsgtype
operator|++
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|senderror
goto|;
block|}
comment|/* for old-fashioned code - should be nuked */
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|>
name|MCLBYTES
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
if|if
condition|(
name|m
operator|->
name|m_next
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
name|MGETHDR
argument_list|(
name|n
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|&&
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|>
name|MHLEN
condition|)
block|{
name|MCLGET
argument_list|(
name|n
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|m_free
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|n
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|n
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
name|m_copydata
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|mtod
argument_list|(
name|n
argument_list|,
name|caddr_t
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|n
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|n
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|n
expr_stmt|;
block|}
comment|/* align the mbuf chain so that extensions are in contiguous region. */
name|error
operator|=
name|key_align
argument_list|(
name|m
argument_list|,
operator|&
name|mh
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
name|m
operator|->
name|m_next
condition|)
block|{
comment|/*XXX*/
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
name|msg
operator|=
name|mh
operator|.
name|msg
expr_stmt|;
comment|/* check SA type */
switch|switch
condition|(
name|msg
operator|->
name|sadb_msg_satype
condition|)
block|{
case|case
name|SADB_SATYPE_UNSPEC
case|:
switch|switch
condition|(
name|msg
operator|->
name|sadb_msg_type
condition|)
block|{
case|case
name|SADB_GETSPI
case|:
case|case
name|SADB_UPDATE
case|:
case|case
name|SADB_ADD
case|:
case|case
name|SADB_DELETE
case|:
case|case
name|SADB_GET
case|:
case|case
name|SADB_ACQUIRE
case|:
case|case
name|SADB_EXPIRE
case|:
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_parse: must specify satype "
literal|"when msg type=%u.\n"
operator|,
name|msg
operator|->
name|sadb_msg_type
operator|)
argument_list|)
expr_stmt|;
name|pfkeystat
operator|.
name|out_invsatype
operator|++
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|senderror
goto|;
block|}
break|break;
case|case
name|SADB_SATYPE_AH
case|:
case|case
name|SADB_SATYPE_ESP
case|:
case|case
name|SADB_X_SATYPE_IPCOMP
case|:
switch|switch
condition|(
name|msg
operator|->
name|sadb_msg_type
condition|)
block|{
case|case
name|SADB_X_SPDADD
case|:
case|case
name|SADB_X_SPDDELETE
case|:
case|case
name|SADB_X_SPDGET
case|:
case|case
name|SADB_X_SPDDUMP
case|:
case|case
name|SADB_X_SPDFLUSH
case|:
case|case
name|SADB_X_SPDSETIDX
case|:
case|case
name|SADB_X_SPDUPDATE
case|:
case|case
name|SADB_X_SPDDELETE2
case|:
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_parse: illegal satype=%u\n"
operator|,
name|msg
operator|->
name|sadb_msg_type
operator|)
argument_list|)
expr_stmt|;
name|pfkeystat
operator|.
name|out_invsatype
operator|++
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|senderror
goto|;
block|}
break|break;
case|case
name|SADB_SATYPE_RSVP
case|:
case|case
name|SADB_SATYPE_OSPFV2
case|:
case|case
name|SADB_SATYPE_RIPV2
case|:
case|case
name|SADB_SATYPE_MIP
case|:
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_parse: type %u isn't supported.\n"
operator|,
name|msg
operator|->
name|sadb_msg_satype
operator|)
argument_list|)
expr_stmt|;
name|pfkeystat
operator|.
name|out_invsatype
operator|++
expr_stmt|;
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
goto|goto
name|senderror
goto|;
case|case
literal|1
case|:
comment|/* XXX: What does it do? */
if|if
condition|(
name|msg
operator|->
name|sadb_msg_type
operator|==
name|SADB_X_PROMISC
condition|)
break|break;
comment|/*FALLTHROUGH*/
default|default:
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_parse: invalid type %u is passed.\n"
operator|,
name|msg
operator|->
name|sadb_msg_satype
operator|)
argument_list|)
expr_stmt|;
name|pfkeystat
operator|.
name|out_invsatype
operator|++
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|senderror
goto|;
block|}
comment|/* check field of upper layer protocol and address family */
if|if
condition|(
name|mh
operator|.
name|ext
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
operator|!=
name|NULL
operator|&&
name|mh
operator|.
name|ext
index|[
name|SADB_EXT_ADDRESS_DST
index|]
operator|!=
name|NULL
condition|)
block|{
name|struct
name|sadb_address
modifier|*
name|src0
decl_stmt|,
modifier|*
name|dst0
decl_stmt|;
name|u_int
name|plen
decl_stmt|;
name|src0
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
operator|(
name|mh
operator|.
name|ext
index|[
name|SADB_EXT_ADDRESS_SRC
index|]
operator|)
expr_stmt|;
name|dst0
operator|=
operator|(
expr|struct
name|sadb_address
operator|*
operator|)
operator|(
name|mh
operator|.
name|ext
index|[
name|SADB_EXT_ADDRESS_DST
index|]
operator|)
expr_stmt|;
comment|/* check upper layer protocol */
if|if
condition|(
name|src0
operator|->
name|sadb_address_proto
operator|!=
name|dst0
operator|->
name|sadb_address_proto
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_parse: upper layer protocol mismatched.\n"
operator|)
argument_list|)
expr_stmt|;
name|pfkeystat
operator|.
name|out_invaddr
operator|++
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|senderror
goto|;
block|}
comment|/* check family */
if|if
condition|(
name|PFKEY_ADDR_SADDR
argument_list|(
name|src0
argument_list|)
operator|->
name|sa_family
operator|!=
name|PFKEY_ADDR_SADDR
argument_list|(
name|dst0
argument_list|)
operator|->
name|sa_family
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_parse: address family mismatched.\n"
operator|)
argument_list|)
expr_stmt|;
name|pfkeystat
operator|.
name|out_invaddr
operator|++
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|senderror
goto|;
block|}
if|if
condition|(
name|PFKEY_ADDR_SADDR
argument_list|(
name|src0
argument_list|)
operator|->
name|sa_len
operator|!=
name|PFKEY_ADDR_SADDR
argument_list|(
name|dst0
argument_list|)
operator|->
name|sa_len
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_parse: address struct size mismatched.\n"
operator|)
argument_list|)
expr_stmt|;
name|pfkeystat
operator|.
name|out_invaddr
operator|++
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|senderror
goto|;
block|}
switch|switch
condition|(
name|PFKEY_ADDR_SADDR
argument_list|(
name|src0
argument_list|)
operator|->
name|sa_family
condition|)
block|{
case|case
name|AF_INET
case|:
if|if
condition|(
name|PFKEY_ADDR_SADDR
argument_list|(
name|src0
argument_list|)
operator|->
name|sa_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
condition|)
block|{
name|pfkeystat
operator|.
name|out_invaddr
operator|++
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|senderror
goto|;
block|}
break|break;
case|case
name|AF_INET6
case|:
if|if
condition|(
name|PFKEY_ADDR_SADDR
argument_list|(
name|src0
argument_list|)
operator|->
name|sa_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
condition|)
block|{
name|pfkeystat
operator|.
name|out_invaddr
operator|++
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|senderror
goto|;
block|}
break|break;
default|default:
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_parse: unsupported address family.\n"
operator|)
argument_list|)
expr_stmt|;
name|pfkeystat
operator|.
name|out_invaddr
operator|++
expr_stmt|;
name|error
operator|=
name|EAFNOSUPPORT
expr_stmt|;
goto|goto
name|senderror
goto|;
block|}
switch|switch
condition|(
name|PFKEY_ADDR_SADDR
argument_list|(
name|src0
argument_list|)
operator|->
name|sa_family
condition|)
block|{
case|case
name|AF_INET
case|:
name|plen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
operator|<<
literal|3
expr_stmt|;
break|break;
case|case
name|AF_INET6
case|:
name|plen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
operator|<<
literal|3
expr_stmt|;
break|break;
default|default:
name|plen
operator|=
literal|0
expr_stmt|;
comment|/*fool gcc*/
break|break;
block|}
comment|/* check max prefix length */
if|if
condition|(
name|src0
operator|->
name|sadb_address_prefixlen
operator|>
name|plen
operator|||
name|dst0
operator|->
name|sadb_address_prefixlen
operator|>
name|plen
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_parse: illegal prefixlen.\n"
operator|)
argument_list|)
expr_stmt|;
name|pfkeystat
operator|.
name|out_invaddr
operator|++
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|senderror
goto|;
block|}
comment|/* 		 * prefixlen == 0 is valid because there can be a case when 		 * all addresses are matched. 		 */
block|}
if|if
condition|(
name|msg
operator|->
name|sadb_msg_type
operator|>=
sizeof|sizeof
argument_list|(
name|key_typesw
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|key_typesw
index|[
literal|0
index|]
argument_list|)
operator|||
name|key_typesw
index|[
name|msg
operator|->
name|sadb_msg_type
index|]
operator|==
name|NULL
condition|)
block|{
name|pfkeystat
operator|.
name|out_invmsgtype
operator|++
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|senderror
goto|;
block|}
return|return
call|(
modifier|*
name|key_typesw
index|[
name|msg
operator|->
name|sadb_msg_type
index|]
call|)
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
operator|&
name|mh
argument_list|)
return|;
name|senderror
label|:
name|msg
operator|->
name|sadb_msg_errno
operator|=
name|error
expr_stmt|;
return|return
name|key_sendup_mbuf
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|target
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|key_senderror
parameter_list|(
name|so
parameter_list|,
name|m
parameter_list|,
name|code
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|code
decl_stmt|;
block|{
name|struct
name|sadb_msg
modifier|*
name|msg
decl_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
condition|)
name|panic
argument_list|(
literal|"invalid mbuf passed to key_senderror"
argument_list|)
expr_stmt|;
name|msg
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|)
expr_stmt|;
name|msg
operator|->
name|sadb_msg_errno
operator|=
name|code
expr_stmt|;
return|return
name|key_sendup_mbuf
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|KEY_SENDUP_ONE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * set the pointer to each header into message buffer.  * m will be freed on error.  * XXX larger-than-MCLBYTES extension?  */
end_comment

begin_function
specifier|static
name|int
name|key_align
parameter_list|(
name|m
parameter_list|,
name|mhp
parameter_list|)
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|sadb_msghdr
modifier|*
name|mhp
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
name|struct
name|sadb_ext
modifier|*
name|ext
decl_stmt|;
name|size_t
name|off
decl_stmt|,
name|end
decl_stmt|;
name|int
name|extlen
decl_stmt|;
name|int
name|toff
decl_stmt|;
comment|/* sanity check */
if|if
condition|(
name|m
operator|==
name|NULL
operator|||
name|mhp
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_align: NULL pointer is passed.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
condition|)
name|panic
argument_list|(
literal|"invalid mbuf passed to key_align"
argument_list|)
expr_stmt|;
comment|/* initialize */
name|bzero
argument_list|(
name|mhp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|mhp
argument_list|)
argument_list|)
expr_stmt|;
name|mhp
operator|->
name|msg
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sadb_msg
operator|*
argument_list|)
expr_stmt|;
name|mhp
operator|->
name|ext
index|[
literal|0
index|]
operator|=
operator|(
expr|struct
name|sadb_ext
operator|*
operator|)
name|mhp
operator|->
name|msg
expr_stmt|;
comment|/*XXX backward compat */
name|end
operator|=
name|PFKEY_UNUNIT64
argument_list|(
name|mhp
operator|->
name|msg
operator|->
name|sadb_msg_len
argument_list|)
expr_stmt|;
name|extlen
operator|=
name|end
expr_stmt|;
comment|/*just in case extlen is not updated*/
for|for
control|(
name|off
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_msg
argument_list|)
init|;
name|off
operator|<
name|end
condition|;
name|off
operator|+=
name|extlen
control|)
block|{
name|n
operator|=
name|m_pulldown
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_ext
argument_list|)
argument_list|,
operator|&
name|toff
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
block|{
comment|/* m is already freed */
return|return
name|ENOBUFS
return|;
block|}
name|ext
operator|=
operator|(
expr|struct
name|sadb_ext
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|n
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|toff
operator|)
expr_stmt|;
comment|/* set pointer */
switch|switch
condition|(
name|ext
operator|->
name|sadb_ext_type
condition|)
block|{
case|case
name|SADB_EXT_SA
case|:
case|case
name|SADB_EXT_ADDRESS_SRC
case|:
case|case
name|SADB_EXT_ADDRESS_DST
case|:
case|case
name|SADB_EXT_ADDRESS_PROXY
case|:
case|case
name|SADB_EXT_LIFETIME_CURRENT
case|:
case|case
name|SADB_EXT_LIFETIME_HARD
case|:
case|case
name|SADB_EXT_LIFETIME_SOFT
case|:
case|case
name|SADB_EXT_KEY_AUTH
case|:
case|case
name|SADB_EXT_KEY_ENCRYPT
case|:
case|case
name|SADB_EXT_IDENTITY_SRC
case|:
case|case
name|SADB_EXT_IDENTITY_DST
case|:
case|case
name|SADB_EXT_SENSITIVITY
case|:
case|case
name|SADB_EXT_PROPOSAL
case|:
case|case
name|SADB_EXT_SUPPORTED_AUTH
case|:
case|case
name|SADB_EXT_SUPPORTED_ENCRYPT
case|:
case|case
name|SADB_EXT_SPIRANGE
case|:
case|case
name|SADB_X_EXT_POLICY
case|:
case|case
name|SADB_X_EXT_SA2
case|:
comment|/* duplicate check */
comment|/* 			 * XXX Are there duplication payloads of either 			 * KEY_AUTH or KEY_ENCRYPT ? 			 */
if|if
condition|(
name|mhp
operator|->
name|ext
index|[
name|ext
operator|->
name|sadb_ext_type
index|]
operator|!=
name|NULL
condition|)
block|{
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_align: duplicate ext_type %u "
literal|"is passed.\n"
operator|,
name|ext
operator|->
name|sadb_ext_type
operator|)
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|pfkeystat
operator|.
name|out_dupext
operator|++
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
break|break;
default|default:
name|ipseclog
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"key_align: invalid ext_type %u is passed.\n"
operator|,
name|ext
operator|->
name|sadb_ext_type
operator|)
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|pfkeystat
operator|.
name|out_invexttype
operator|++
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|extlen
operator|=
name|PFKEY_UNUNIT64
argument_list|(
name|ext
operator|->
name|sadb_ext_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|key_validate_ext
argument_list|(
name|ext
argument_list|,
name|extlen
argument_list|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|pfkeystat
operator|.
name|out_invlen
operator|++
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|n
operator|=
name|m_pulldown
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
name|extlen
argument_list|,
operator|&
name|toff
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
block|{
comment|/* m is already freed */
return|return
name|ENOBUFS
return|;
block|}
name|ext
operator|=
operator|(
expr|struct
name|sadb_ext
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|n
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|toff
operator|)
expr_stmt|;
name|mhp
operator|->
name|ext
index|[
name|ext
operator|->
name|sadb_ext_type
index|]
operator|=
name|ext
expr_stmt|;
name|mhp
operator|->
name|extoff
index|[
name|ext
operator|->
name|sadb_ext_type
index|]
operator|=
name|off
expr_stmt|;
name|mhp
operator|->
name|extlen
index|[
name|ext
operator|->
name|sadb_ext_type
index|]
operator|=
name|extlen
expr_stmt|;
block|}
if|if
condition|(
name|off
operator|!=
name|end
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|pfkeystat
operator|.
name|out_invlen
operator|++
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|key_validate_ext
parameter_list|(
name|ext
parameter_list|,
name|len
parameter_list|)
specifier|const
name|struct
name|sadb_ext
modifier|*
name|ext
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
enum|enum
block|{
name|NONE
block|,
name|ADDR
block|}
name|checktype
init|=
name|NONE
enum|;
name|int
name|baselen
decl_stmt|;
specifier|const
name|int
name|sal
init|=
name|offsetof
argument_list|(
expr|struct
name|sockaddr
argument_list|,
name|sa_len
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|sa
operator|->
name|sa_len
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|!=
name|PFKEY_UNUNIT64
argument_list|(
name|ext
operator|->
name|sadb_ext_len
argument_list|)
condition|)
return|return
name|EINVAL
return|;
comment|/* if it does not match minimum/maximum length, bail */
if|if
condition|(
name|ext
operator|->
name|sadb_ext_type
operator|>=
sizeof|sizeof
argument_list|(
name|minsize
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|minsize
index|[
literal|0
index|]
argument_list|)
operator|||
name|ext
operator|->
name|sadb_ext_type
operator|>=
sizeof|sizeof
argument_list|(
name|maxsize
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|maxsize
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
operator|!
name|minsize
index|[
name|ext
operator|->
name|sadb_ext_type
index|]
operator|||
name|len
operator|<
name|minsize
index|[
name|ext
operator|->
name|sadb_ext_type
index|]
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|maxsize
index|[
name|ext
operator|->
name|sadb_ext_type
index|]
operator|&&
name|len
operator|>
name|maxsize
index|[
name|ext
operator|->
name|sadb_ext_type
index|]
condition|)
return|return
name|EINVAL
return|;
comment|/* more checks based on sadb_ext_type XXX need more */
switch|switch
condition|(
name|ext
operator|->
name|sadb_ext_type
condition|)
block|{
case|case
name|SADB_EXT_ADDRESS_SRC
case|:
case|case
name|SADB_EXT_ADDRESS_DST
case|:
case|case
name|SADB_EXT_ADDRESS_PROXY
case|:
name|baselen
operator|=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_address
argument_list|)
argument_list|)
expr_stmt|;
name|checktype
operator|=
name|ADDR
expr_stmt|;
break|break;
case|case
name|SADB_EXT_IDENTITY_SRC
case|:
case|case
name|SADB_EXT_IDENTITY_DST
case|:
if|if
condition|(
operator|(
operator|(
expr|struct
name|sadb_ident
operator|*
operator|)
name|ext
operator|)
operator|->
name|sadb_ident_type
operator|==
name|SADB_X_IDENTTYPE_ADDR
condition|)
block|{
name|baselen
operator|=
name|PFKEY_ALIGN8
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sadb_ident
argument_list|)
argument_list|)
expr_stmt|;
name|checktype
operator|=
name|ADDR
expr_stmt|;
block|}
else|else
name|checktype
operator|=
name|NONE
expr_stmt|;
break|break;
default|default:
name|checktype
operator|=
name|NONE
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|checktype
condition|)
block|{
case|case
name|NONE
case|:
break|break;
case|case
name|ADDR
case|:
name|sa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ext
operator|+
name|baselen
operator|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|baselen
operator|+
name|sal
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|baselen
operator|+
name|PFKEY_ALIGN8
argument_list|(
name|sa
operator|->
name|sa_len
argument_list|)
operator|!=
name|len
condition|)
return|return
name|EINVAL
return|;
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|key_init
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|key_cb
argument_list|,
sizeof|sizeof
argument_list|(
name|key_cb
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IPSEC_DIR_MAX
condition|;
name|i
operator|++
control|)
block|{
name|LIST_INIT
argument_list|(
operator|&
name|sptree
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|LIST_INIT
argument_list|(
operator|&
name|sahtree
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|SADB_SATYPE_MAX
condition|;
name|i
operator|++
control|)
block|{
name|LIST_INIT
argument_list|(
operator|&
name|regtree
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|IPSEC_NONBLOCK_ACQUIRE
name|LIST_INIT
argument_list|(
operator|&
name|acqtree
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|LIST_INIT
argument_list|(
operator|&
name|spacqtree
argument_list|)
expr_stmt|;
comment|/* system default */
ifdef|#
directive|ifdef
name|INET
name|ip4_def_policy
operator|.
name|policy
operator|=
name|IPSEC_POLICY_NONE
expr_stmt|;
name|ip4_def_policy
operator|.
name|refcnt
operator|++
expr_stmt|;
comment|/*never reclaim this*/
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
name|ip6_def_policy
operator|.
name|policy
operator|=
name|IPSEC_POLICY_NONE
expr_stmt|;
name|ip6_def_policy
operator|.
name|refcnt
operator|++
expr_stmt|;
comment|/*never reclaim this*/
endif|#
directive|endif
ifndef|#
directive|ifndef
name|IPSEC_DEBUG2
name|timeout
argument_list|(
operator|(
name|void
operator|*
operator|)
name|key_timehandler
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|,
name|hz
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*IPSEC_DEBUG2*/
comment|/* initialize key statistics */
name|keystat
operator|.
name|getspi_count
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"IPsec: Initialized Security Association Processing.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * XXX: maybe This function is called after INBOUND IPsec processing.  *  * Special check for tunnel-mode packets.  * We must make some checks for consistency between inner and outer IP header.  *  * xxx more checks to be provided  */
end_comment

begin_function
name|int
name|key_checktunnelsanity
parameter_list|(
name|sav
parameter_list|,
name|family
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|)
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|;
name|u_int
name|family
decl_stmt|;
name|caddr_t
name|src
decl_stmt|;
name|caddr_t
name|dst
decl_stmt|;
block|{
comment|/* sanity check */
if|if
condition|(
name|sav
operator|->
name|sah
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"sav->sah == NULL at key_checktunnelsanity"
argument_list|)
expr_stmt|;
comment|/* XXX: check inner IP header */
return|return
literal|1
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_define
define|#
directive|define
name|hostnamelen
value|strlen(hostname)
end_define

begin_comment
comment|/*  * Get FQDN for the host.  * If the administrator configured hostname (by hostname(1)) without  * domain name, returns nothing.  */
end_comment

begin_comment
unit|static const char * key_getfqdn() { 	int i; 	int hasdot; 	static char fqdn[MAXHOSTNAMELEN + 1];  	if (!hostnamelen) 		return NULL;
comment|/* check if it comes with domain name. */
end_comment

begin_comment
unit|hasdot = 0; 	for (i = 0; i< hostnamelen; i++) { 		if (hostname[i] == '.') 			hasdot++; 	} 	if (!hasdot) 		return NULL;
comment|/* NOTE: hostname may not be NUL-terminated. */
end_comment

begin_comment
unit|bzero(fqdn, sizeof(fqdn)); 	bcopy(hostname, fqdn, hostnamelen); 	fqdn[hostnamelen] = '\0'; 	return fqdn; }
comment|/*  * get username@FQDN for the host/user.  */
end_comment

begin_comment
unit|static const char * key_getuserfqdn() { 	const char *host; 	static char userfqdn[MAXHOSTNAMELEN + MAXLOGNAME + 2]; 	struct proc *p = curproc; 	char *q;  	if (!p || !p->p_pgrp || !p->p_pgrp->pg_session) 		return NULL; 	if (!(host = key_getfqdn())) 		return NULL;
comment|/* NOTE: s_login may not be-NUL terminated. */
end_comment

begin_comment
unit|bzero(userfqdn, sizeof(userfqdn)); 	bcopy(p->p_pgrp->pg_session->s_login, userfqdn, MAXLOGNAME); 	userfqdn[MAXLOGNAME] = '\0';
comment|/* safeguard */
end_comment

begin_endif
unit|q = userfqdn + strlen(userfqdn); 	*q++ = '@'; 	bcopy(host, q, strlen(host)); 	q += strlen(host); 	*q++ = '\0';  	return userfqdn; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* record data transfer on SA, and update timestamps */
end_comment

begin_function
name|void
name|key_sa_recordxfer
parameter_list|(
name|sav
parameter_list|,
name|m
parameter_list|)
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|sav
condition|)
name|panic
argument_list|(
literal|"key_sa_recordxfer called with sav == NULL"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
name|panic
argument_list|(
literal|"key_sa_recordxfer called with m == NULL"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sav
operator|->
name|lft_c
condition|)
return|return;
comment|/* 	 * XXX Currently, there is a difference of bytes size 	 * between inbound and outbound processing. 	 */
name|sav
operator|->
name|lft_c
operator|->
name|sadb_lifetime_bytes
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
comment|/* to check bytes lifetime is done in key_timehandler(). */
comment|/* 	 * We use the number of packets as the unit of 	 * sadb_lifetime_allocations.  We increment the variable 	 * whenever {esp,ah}_{in,out}put is called. 	 */
name|sav
operator|->
name|lft_c
operator|->
name|sadb_lifetime_allocations
operator|++
expr_stmt|;
comment|/* XXX check for expires? */
comment|/* 	 * NOTE: We record CURRENT sadb_lifetime_usetime by using wall clock, 	 * in seconds.  HARD and SOFT lifetime are measured by the time 	 * difference (again in seconds) from sadb_lifetime_usetime. 	 * 	 *	usetime 	 *	v     expire   expire 	 * -----+-----+--------+---> t 	 *<--------------> HARD 	 *<-----> SOFT 	 */
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|microtime
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
name|sav
operator|->
name|lft_c
operator|->
name|sadb_lifetime_usetime
operator|=
name|tv
operator|.
name|tv_sec
expr_stmt|;
comment|/* XXX check for expires? */
block|}
return|return;
block|}
end_function

begin_comment
comment|/* dumb version */
end_comment

begin_function
name|void
name|key_sa_routechange
parameter_list|(
name|dst
parameter_list|)
name|struct
name|sockaddr
modifier|*
name|dst
decl_stmt|;
block|{
name|struct
name|secashead
modifier|*
name|sah
decl_stmt|;
name|struct
name|route
modifier|*
name|ro
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|sah
argument_list|,
argument|&sahtree
argument_list|,
argument|chain
argument_list|)
block|{
name|ro
operator|=
operator|&
name|sah
operator|->
name|sa_route
expr_stmt|;
if|if
condition|(
name|ro
operator|->
name|ro_rt
operator|&&
name|dst
operator|->
name|sa_len
operator|==
name|ro
operator|->
name|ro_dst
operator|.
name|sa_len
operator|&&
name|bcmp
argument_list|(
name|dst
argument_list|,
operator|&
name|ro
operator|->
name|ro_dst
argument_list|,
name|dst
operator|->
name|sa_len
argument_list|)
operator|==
literal|0
condition|)
block|{
name|RTFREE
argument_list|(
name|ro
operator|->
name|ro_rt
argument_list|)
expr_stmt|;
name|ro
operator|->
name|ro_rt
operator|=
operator|(
expr|struct
name|rtentry
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|key_sa_chgstate
parameter_list|(
name|sav
parameter_list|,
name|state
parameter_list|)
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|;
name|u_int8_t
name|state
decl_stmt|;
block|{
if|if
condition|(
name|sav
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"key_sa_chgstate called with sav == NULL"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|state
operator|==
name|state
condition|)
return|return;
if|if
condition|(
name|__LIST_CHAINED
argument_list|(
name|sav
argument_list|)
condition|)
name|LIST_REMOVE
argument_list|(
name|sav
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|sav
operator|->
name|state
operator|=
name|state
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|sav
operator|->
name|sah
operator|->
name|savtree
index|[
name|state
index|]
argument_list|,
name|sav
argument_list|,
name|chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|key_sa_stir_iv
parameter_list|(
name|sav
parameter_list|)
name|struct
name|secasvar
modifier|*
name|sav
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|sav
operator|->
name|iv
condition|)
name|panic
argument_list|(
literal|"key_sa_stir_iv called with sav == NULL"
argument_list|)
expr_stmt|;
name|key_randomfill
argument_list|(
name|sav
operator|->
name|iv
argument_list|,
name|sav
operator|->
name|ivlen
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* XXX too much? */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|key_alloc_mbuf
parameter_list|(
name|l
parameter_list|)
name|int
name|l
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
name|NULL
decl_stmt|,
modifier|*
name|n
decl_stmt|;
name|int
name|len
decl_stmt|,
name|t
decl_stmt|;
name|len
operator|=
name|l
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|MGET
argument_list|(
name|n
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|&&
name|len
operator|>
name|MLEN
condition|)
name|MCLGET
argument_list|(
name|n
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|n
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
name|n
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
name|n
operator|->
name|m_len
operator|=
name|M_TRAILINGSPACE
argument_list|(
name|n
argument_list|)
expr_stmt|;
comment|/* use the bottom of mbuf, hoping we can prepend afterwards */
if|if
condition|(
name|n
operator|->
name|m_len
operator|>
name|len
condition|)
block|{
name|t
operator|=
operator|(
name|n
operator|->
name|m_len
operator|-
name|len
operator|)
operator|&
operator|~
operator|(
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
name|n
operator|->
name|m_data
operator|+=
name|t
expr_stmt|;
name|n
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
block|}
name|len
operator|-=
name|n
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
name|m
condition|)
name|m_cat
argument_list|(
name|m
argument_list|,
name|n
argument_list|)
expr_stmt|;
else|else
name|m
operator|=
name|n
expr_stmt|;
block|}
return|return
name|m
return|;
block|}
end_function

end_unit

