begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright 2015 John Wehle<john@feith.com>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Amlogic aml8726 multiprocessor support.  *  * Some processors require powering on which involves poking registers  * on the aobus and cbus ... it's expected that these locations are set  * in stone.  *  * Locking is not used as these routines should only be called by the BP  * during startup and should complete prior to the APs being released (the  * issue being to ensure that a register such as AML_SOC_CPU_CLK_CNTL_REG  * is not concurrently modified).  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/smp.h>
end_include

begin_include
include|#
directive|include
file|<machine/fdt.h>
end_include

begin_include
include|#
directive|include
file|<machine/intr.h>
end_include

begin_include
include|#
directive|include
file|<dev/fdt/fdt_common.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/ofw_bus.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/ofw_bus_subr.h>
end_include

begin_include
include|#
directive|include
file|<arm/amlogic/aml8726/aml8726_soc.h>
end_include

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|scu_compatible
index|[]
init|=
block|{
literal|"arm,cortex-a5-scu"
block|,
literal|"arm,cortex-a9-scu"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|scu_errata_764369
index|[]
init|=
block|{
literal|"arm,cortex-a9-scu"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|cpucfg_compatible
index|[]
init|=
block|{
literal|"amlogic,aml8726-cpuconfig"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_struct
specifier|static
struct|struct
block|{
name|boolean_t
name|errata_764369
decl_stmt|;
name|u_long
name|scu_size
decl_stmt|;
name|struct
name|resource
name|scu_res
decl_stmt|;
name|u_long
name|cpucfg_size
decl_stmt|;
name|struct
name|resource
name|cpucfg_res
decl_stmt|;
name|struct
name|resource
name|aobus_res
decl_stmt|;
name|struct
name|resource
name|cbus_res
decl_stmt|;
block|}
name|aml8726_smp
struct|;
end_struct

begin_define
define|#
directive|define
name|AML_SCU_CONTROL_REG
value|0
end_define

begin_define
define|#
directive|define
name|AML_SCU_CONTROL_ENABLE
value|1
end_define

begin_define
define|#
directive|define
name|AML_SCU_CONFIG_REG
value|4
end_define

begin_define
define|#
directive|define
name|AML_SCU_CONFIG_NCPU_MASK
value|0x3
end_define

begin_define
define|#
directive|define
name|AML_SCU_CPU_PWR_STATUS_REG
value|8
end_define

begin_define
define|#
directive|define
name|AML_SCU_CPU_PWR_STATUS_CPU3_MASK
value|(3<< 24)
end_define

begin_define
define|#
directive|define
name|AML_SCU_CPU_PWR_STATUS_CPU2_MASK
value|(3<< 16)
end_define

begin_define
define|#
directive|define
name|AML_SCU_CPU_PWR_STATUS_CPU1_MASK
value|(3<< 8)
end_define

begin_define
define|#
directive|define
name|AML_SCU_CPU_PWR_STATUS_CPU0_MASK
value|3
end_define

begin_define
define|#
directive|define
name|AML_SCU_INV_TAGS_REG
value|12
end_define

begin_define
define|#
directive|define
name|AML_SCU_DIAG_CONTROL_REG
value|48
end_define

begin_define
define|#
directive|define
name|AML_SCU_DIAG_CONTROL_DISABLE_MIGBIT
value|1
end_define

begin_define
define|#
directive|define
name|AML_CPUCONF_CONTROL_REG
value|0
end_define

begin_define
define|#
directive|define
name|AML_CPUCONF_CPU1_ADDR_REG
value|4
end_define

begin_define
define|#
directive|define
name|AML_CPUCONF_CPU2_ADDR_REG
value|8
end_define

begin_define
define|#
directive|define
name|AML_CPUCONF_CPU3_ADDR_REG
value|12
end_define

begin_comment
comment|/* aobus */
end_comment

begin_define
define|#
directive|define
name|AML_M8_CPU_PWR_CNTL0_REG
value|0xe0
end_define

begin_define
define|#
directive|define
name|AML_M8B_CPU_PWR_CNTL0_MODE_CPU3_MASK
value|(3<< 22)
end_define

begin_define
define|#
directive|define
name|AML_M8B_CPU_PWR_CNTL0_MODE_CPU2_MASK
value|(3<< 20)
end_define

begin_define
define|#
directive|define
name|AML_M8B_CPU_PWR_CNTL0_MODE_CPU1_MASK
value|(3<< 18)
end_define

begin_define
define|#
directive|define
name|AML_M8_CPU_PWR_CNTL0_ISO_CPU3
value|(1<< 3)
end_define

begin_define
define|#
directive|define
name|AML_M8_CPU_PWR_CNTL0_ISO_CPU2
value|(1<< 2)
end_define

begin_define
define|#
directive|define
name|AML_M8_CPU_PWR_CNTL0_ISO_CPU1
value|(1<< 1)
end_define

begin_define
define|#
directive|define
name|AML_M8_CPU_PWR_CNTL1_REG
value|0xe4
end_define

begin_define
define|#
directive|define
name|AML_M8B_CPU_PWR_CNTL1_PWR_CPU3
value|(1<< 19)
end_define

begin_define
define|#
directive|define
name|AML_M8B_CPU_PWR_CNTL1_PWR_CPU2
value|(1<< 18)
end_define

begin_define
define|#
directive|define
name|AML_M8B_CPU_PWR_CNTL1_PWR_CPU1
value|(1<< 17)
end_define

begin_define
define|#
directive|define
name|AML_M8_CPU_PWR_CNTL1_MODE_CPU3_MASK
value|(3<< 8)
end_define

begin_define
define|#
directive|define
name|AML_M8_CPU_PWR_CNTL1_MODE_CPU2_MASK
value|(3<< 6)
end_define

begin_define
define|#
directive|define
name|AML_M8_CPU_PWR_CNTL1_MODE_CPU1_MASK
value|(3<< 4)
end_define

begin_define
define|#
directive|define
name|AML_M8B_CPU_PWR_MEM_PD0_REG
value|0xf4
end_define

begin_define
define|#
directive|define
name|AML_M8B_CPU_PWR_MEM_PD0_CPU3
value|(0xf<< 20)
end_define

begin_define
define|#
directive|define
name|AML_M8B_CPU_PWR_MEM_PD0_CPU2
value|(0xf<< 24)
end_define

begin_define
define|#
directive|define
name|AML_M8B_CPU_PWR_MEM_PD0_CPU1
value|(0xf<< 28)
end_define

begin_comment
comment|/* cbus */
end_comment

begin_define
define|#
directive|define
name|AML_SOC_CPU_CLK_CNTL_REG
value|0x419c
end_define

begin_define
define|#
directive|define
name|AML_M8_CPU_CLK_CNTL_RESET_CPU3
value|(1<< 27)
end_define

begin_define
define|#
directive|define
name|AML_M8_CPU_CLK_CNTL_RESET_CPU2
value|(1<< 26)
end_define

begin_define
define|#
directive|define
name|AML_M8_CPU_CLK_CNTL_RESET_CPU1
value|(1<< 25)
end_define

begin_define
define|#
directive|define
name|SCU_WRITE_4
parameter_list|(
name|reg
parameter_list|,
name|value
parameter_list|)
value|bus_write_4(&aml8726_smp.scu_res,    \     (reg), (value))
end_define

begin_define
define|#
directive|define
name|SCU_READ_4
parameter_list|(
name|reg
parameter_list|)
value|bus_read_4(&aml8726_smp.scu_res, (reg))
end_define

begin_define
define|#
directive|define
name|SCU_BARRIER
parameter_list|(
name|reg
parameter_list|)
value|bus_barrier(&aml8726_smp.scu_res,    \     (reg), 4, (BUS_SPACE_BARRIER_READ | BUS_SPACE_BARRIER_WRITE))
end_define

begin_define
define|#
directive|define
name|CPUCONF_WRITE_4
parameter_list|(
name|reg
parameter_list|,
name|value
parameter_list|)
value|bus_write_4(&aml8726_smp.cpucfg_res, \     (reg), (value))
end_define

begin_define
define|#
directive|define
name|CPUCONF_READ_4
parameter_list|(
name|reg
parameter_list|)
value|bus_read_4(&aml8726_smp.cpucfg_res,  \     (reg))
end_define

begin_define
define|#
directive|define
name|CPUCONF_BARRIER
parameter_list|(
name|reg
parameter_list|)
value|bus_barrier(&aml8726_smp.cpucfg_res, \     (reg), 4, (BUS_SPACE_BARRIER_READ | BUS_SPACE_BARRIER_WRITE))
end_define

begin_define
define|#
directive|define
name|AOBUS_WRITE_4
parameter_list|(
name|reg
parameter_list|,
name|value
parameter_list|)
value|bus_write_4(&aml8726_smp.aobus_res,  \     (reg), (value))
end_define

begin_define
define|#
directive|define
name|AOBUS_READ_4
parameter_list|(
name|reg
parameter_list|)
value|bus_read_4(&aml8726_smp.aobus_res,   \     (reg))
end_define

begin_define
define|#
directive|define
name|AOBUS_BARRIER
parameter_list|(
name|reg
parameter_list|)
value|bus_barrier(&aml8726_smp.aobus_res,  \     (reg), 4, (BUS_SPACE_BARRIER_READ | BUS_SPACE_BARRIER_WRITE))
end_define

begin_define
define|#
directive|define
name|CBUS_WRITE_4
parameter_list|(
name|reg
parameter_list|,
name|value
parameter_list|)
value|bus_write_4(&aml8726_smp.cbus_res,   \     (reg), (value))
end_define

begin_define
define|#
directive|define
name|CBUS_READ_4
parameter_list|(
name|reg
parameter_list|)
value|bus_read_4(&aml8726_smp.cbus_res,    \     (reg))
end_define

begin_define
define|#
directive|define
name|CBUS_BARRIER
parameter_list|(
name|reg
parameter_list|)
value|bus_barrier(&aml8726_smp.cbus_res,   \     (reg), 4, (BUS_SPACE_BARRIER_READ | BUS_SPACE_BARRIER_WRITE))
end_define

begin_function
specifier|static
name|phandle_t
name|find_node_for_device
parameter_list|(
specifier|const
name|char
modifier|*
name|device
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|compatible
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|phandle_t
name|node
decl_stmt|;
comment|/* 	 * Try to access the node directly i.e. through /aliases/. 	 */
if|if
condition|(
operator|(
name|node
operator|=
name|OF_finddevice
argument_list|(
name|device
argument_list|)
operator|)
operator|!=
literal|0
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|compatible
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|fdt_is_compatible_strict
argument_list|(
name|node
argument_list|,
name|compatible
index|[
name|i
index|]
argument_list|)
condition|)
return|return
name|node
return|;
comment|/* 	 * Find the node the long way. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|compatible
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|node
operator|=
name|OF_finddevice
argument_list|(
literal|"/soc"
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|node
operator|=
name|fdt_find_compatible
argument_list|(
name|node
argument_list|,
name|compatible
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|node
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|alloc_resource_for_node
parameter_list|(
name|phandle_t
name|node
parameter_list|,
name|struct
name|resource
modifier|*
name|res
parameter_list|,
name|u_long
modifier|*
name|size
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|u_long
name|pbase
decl_stmt|,
name|psize
decl_stmt|;
name|u_long
name|start
decl_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|fdt_get_range
argument_list|(
name|OF_parent
argument_list|(
name|node
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|&
name|pbase
argument_list|,
operator|&
name|psize
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|err
operator|=
name|fdt_regsize
argument_list|(
name|node
argument_list|,
operator|&
name|start
argument_list|,
name|size
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|start
operator|+=
name|pbase
expr_stmt|;
name|memset
argument_list|(
name|res
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|res
argument_list|)
argument_list|)
expr_stmt|;
name|res
operator|->
name|r_bustag
operator|=
name|fdtbus_bs_tag
expr_stmt|;
name|err
operator|=
name|bus_space_map
argument_list|(
name|res
operator|->
name|r_bustag
argument_list|,
name|start
argument_list|,
operator|*
name|size
argument_list|,
literal|0
argument_list|,
operator|&
name|res
operator|->
name|r_bushandle
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|power_on_cpu
parameter_list|(
name|int
name|cpu
parameter_list|)
block|{
name|uint32_t
name|scpsr
decl_stmt|;
name|uint32_t
name|value
decl_stmt|;
if|if
condition|(
name|cpu
operator|<=
literal|0
condition|)
return|return;
comment|/* 	 * Power on the CPU if the intricate details are known, otherwise 	 * just hope for the best (it may have already be powered on by 	 * the hardware / firmware). 	 */
switch|switch
condition|(
name|aml8726_soc_hw_rev
condition|)
block|{
case|case
name|AML_SOC_HW_REV_M8
case|:
case|case
name|AML_SOC_HW_REV_M8B
case|:
comment|/* 		 * Set the SCU power status for the CPU to normal mode. 		 */
name|scpsr
operator|=
name|SCU_READ_4
argument_list|(
name|AML_SCU_CPU_PWR_STATUS_REG
argument_list|)
expr_stmt|;
name|scpsr
operator|&=
operator|~
operator|(
name|AML_SCU_CPU_PWR_STATUS_CPU1_MASK
operator|<<
operator|(
operator|(
name|cpu
operator|-
literal|1
operator|)
operator|*
literal|8
operator|)
operator|)
expr_stmt|;
name|SCU_WRITE_4
argument_list|(
name|AML_SCU_CPU_PWR_STATUS_REG
argument_list|,
name|scpsr
argument_list|)
expr_stmt|;
name|SCU_BARRIER
argument_list|(
name|AML_SCU_CPU_PWR_STATUS_REG
argument_list|)
expr_stmt|;
if|if
condition|(
name|aml8726_soc_hw_rev
operator|==
name|AML_SOC_HW_REV_M8B
condition|)
block|{
comment|/* 			 * Reset may cause the current power status from the 			 * actual CPU to be written to the SCU (over-writing 			 * the value  we've just written) so set it to normal 			 * mode as well. 			 */
name|value
operator|=
name|AOBUS_READ_4
argument_list|(
name|AML_M8_CPU_PWR_CNTL0_REG
argument_list|)
expr_stmt|;
name|value
operator|&=
operator|~
operator|(
name|AML_M8B_CPU_PWR_CNTL0_MODE_CPU1_MASK
operator|<<
operator|(
operator|(
name|cpu
operator|-
literal|1
operator|)
operator|*
literal|2
operator|)
operator|)
expr_stmt|;
name|AOBUS_WRITE_4
argument_list|(
name|AML_M8_CPU_PWR_CNTL0_REG
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|AOBUS_BARRIER
argument_list|(
name|AML_M8_CPU_PWR_CNTL0_REG
argument_list|)
expr_stmt|;
block|}
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
comment|/* 		 * Assert reset. 		 */
name|value
operator|=
name|CBUS_READ_4
argument_list|(
name|AML_SOC_CPU_CLK_CNTL_REG
argument_list|)
expr_stmt|;
name|value
operator||=
name|AML_M8_CPU_CLK_CNTL_RESET_CPU1
operator|<<
operator|(
name|cpu
operator|-
literal|1
operator|)
expr_stmt|;
name|CBUS_WRITE_4
argument_list|(
name|AML_SOC_CPU_CLK_CNTL_REG
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|CBUS_BARRIER
argument_list|(
name|AML_SOC_CPU_CLK_CNTL_REG
argument_list|)
expr_stmt|;
if|if
condition|(
name|aml8726_soc_hw_rev
operator|==
name|AML_SOC_HW_REV_M8B
condition|)
block|{
comment|/* 			 * Release RAM pull-down. 			 */
name|value
operator|=
name|AOBUS_READ_4
argument_list|(
name|AML_M8B_CPU_PWR_MEM_PD0_REG
argument_list|)
expr_stmt|;
name|value
operator|&=
operator|~
operator|(
operator|(
name|uint32_t
operator|)
name|AML_M8B_CPU_PWR_MEM_PD0_CPU1
operator|>>
operator|(
operator|(
name|cpu
operator|-
literal|1
operator|)
operator|*
literal|4
operator|)
operator|)
expr_stmt|;
name|AOBUS_WRITE_4
argument_list|(
name|AML_M8B_CPU_PWR_MEM_PD0_REG
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|AOBUS_BARRIER
argument_list|(
name|AML_M8B_CPU_PWR_MEM_PD0_REG
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Power on CPU. 		 */
name|value
operator|=
name|AOBUS_READ_4
argument_list|(
name|AML_M8_CPU_PWR_CNTL1_REG
argument_list|)
expr_stmt|;
name|value
operator|&=
operator|~
operator|(
name|AML_M8_CPU_PWR_CNTL1_MODE_CPU1_MASK
operator|<<
operator|(
operator|(
name|cpu
operator|-
literal|1
operator|)
operator|*
literal|2
operator|)
operator|)
expr_stmt|;
name|AOBUS_WRITE_4
argument_list|(
name|AML_M8_CPU_PWR_CNTL1_REG
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|AOBUS_BARRIER
argument_list|(
name|AML_M8_CPU_PWR_CNTL1_REG
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|aml8726_soc_hw_rev
operator|==
name|AML_SOC_HW_REV_M8B
condition|)
block|{
comment|/* 			 * Wait for power on confirmation. 			 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|value
operator|=
name|AOBUS_READ_4
argument_list|(
name|AML_M8_CPU_PWR_CNTL1_REG
argument_list|)
expr_stmt|;
name|value
operator|&=
name|AML_M8B_CPU_PWR_CNTL1_PWR_CPU1
operator|<<
operator|(
name|cpu
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|value
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * Release peripheral clamp. 		 */
name|value
operator|=
name|AOBUS_READ_4
argument_list|(
name|AML_M8_CPU_PWR_CNTL0_REG
argument_list|)
expr_stmt|;
name|value
operator|&=
operator|~
operator|(
name|AML_M8_CPU_PWR_CNTL0_ISO_CPU1
operator|<<
operator|(
name|cpu
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|AOBUS_WRITE_4
argument_list|(
name|AML_M8_CPU_PWR_CNTL0_REG
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|AOBUS_BARRIER
argument_list|(
name|AML_M8_CPU_PWR_CNTL0_REG
argument_list|)
expr_stmt|;
comment|/* 		 * Release reset. 		 */
name|value
operator|=
name|CBUS_READ_4
argument_list|(
name|AML_SOC_CPU_CLK_CNTL_REG
argument_list|)
expr_stmt|;
name|value
operator|&=
operator|~
operator|(
name|AML_M8_CPU_CLK_CNTL_RESET_CPU1
operator|<<
operator|(
name|cpu
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|CBUS_WRITE_4
argument_list|(
name|AML_SOC_CPU_CLK_CNTL_REG
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|CBUS_BARRIER
argument_list|(
name|AML_SOC_CPU_CLK_CNTL_REG
argument_list|)
expr_stmt|;
if|if
condition|(
name|aml8726_soc_hw_rev
operator|==
name|AML_SOC_HW_REV_M8B
condition|)
block|{
comment|/* 			 * The Amlogic Linux platform code sets the SCU power 			 * status for the CPU again for some reason so we 			 * follow suit (perhaps in case the reset caused 			 * a stale power status from the actual CPU to be 			 * written to the SCU). 			 */
name|SCU_WRITE_4
argument_list|(
name|AML_SCU_CPU_PWR_STATUS_REG
argument_list|,
name|scpsr
argument_list|)
expr_stmt|;
name|SCU_BARRIER
argument_list|(
name|AML_SCU_CPU_PWR_STATUS_REG
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_function
name|void
name|platform_mp_init_secondary
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* 	 * Consider modifying the timer driver to support 	 * per-cpu timers and then enabling the timer for 	 * each AP. 	 */
name|arm_init_secondary_ic
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|platform_mp_setmaxid
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|ncpu
decl_stmt|;
name|phandle_t
name|cpucfg_node
decl_stmt|;
name|phandle_t
name|scu_node
decl_stmt|;
name|uint32_t
name|value
decl_stmt|;
if|if
condition|(
name|mp_ncpus
operator|!=
literal|0
condition|)
return|return;
name|ncpu
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Is the hardware necessary for SMP present? 	 */
if|if
condition|(
operator|(
name|scu_node
operator|=
name|find_node_for_device
argument_list|(
literal|"scu"
argument_list|,
name|scu_compatible
argument_list|)
operator|)
operator|==
literal|0
condition|)
goto|goto
name|moveon
goto|;
if|if
condition|(
operator|(
name|cpucfg_node
operator|=
name|find_node_for_device
argument_list|(
literal|"cpuconfig"
argument_list|,
name|cpucfg_compatible
argument_list|)
operator|)
operator|==
literal|0
condition|)
goto|goto
name|moveon
goto|;
if|if
condition|(
name|alloc_resource_for_node
argument_list|(
name|scu_node
argument_list|,
operator|&
name|aml8726_smp
operator|.
name|scu_res
argument_list|,
operator|&
name|aml8726_smp
operator|.
name|scu_size
argument_list|)
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"Could not allocate resource for SCU"
argument_list|)
expr_stmt|;
if|if
condition|(
name|alloc_resource_for_node
argument_list|(
name|cpucfg_node
argument_list|,
operator|&
name|aml8726_smp
operator|.
name|cpucfg_res
argument_list|,
operator|&
name|aml8726_smp
operator|.
name|cpucfg_size
argument_list|)
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"Could not allocate resource for CPUCONFIG"
argument_list|)
expr_stmt|;
comment|/* 	 * Strictly speaking the aobus and cbus may not be required in 	 * order to start an AP (it depends on the processor), however 	 * always mapping them in simplifies the code. 	 */
name|aml8726_smp
operator|.
name|aobus_res
operator|.
name|r_bustag
operator|=
name|fdtbus_bs_tag
expr_stmt|;
name|err
operator|=
name|bus_space_map
argument_list|(
name|aml8726_smp
operator|.
name|aobus_res
operator|.
name|r_bustag
argument_list|,
name|AML_SOC_AOBUS_BASE_ADDR
argument_list|,
literal|0x100000
argument_list|,
literal|0
argument_list|,
operator|&
name|aml8726_smp
operator|.
name|aobus_res
operator|.
name|r_bushandle
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|panic
argument_list|(
literal|"Could not allocate resource for AOBUS"
argument_list|)
expr_stmt|;
name|aml8726_smp
operator|.
name|cbus_res
operator|.
name|r_bustag
operator|=
name|fdtbus_bs_tag
expr_stmt|;
name|err
operator|=
name|bus_space_map
argument_list|(
name|aml8726_smp
operator|.
name|cbus_res
operator|.
name|r_bustag
argument_list|,
name|AML_SOC_CBUS_BASE_ADDR
argument_list|,
literal|0x100000
argument_list|,
literal|0
argument_list|,
operator|&
name|aml8726_smp
operator|.
name|cbus_res
operator|.
name|r_bushandle
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|panic
argument_list|(
literal|"Could not allocate resource for CBUS"
argument_list|)
expr_stmt|;
name|aml8726_smp
operator|.
name|errata_764369
operator|=
name|false
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|scu_errata_764369
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|fdt_is_compatible_strict
argument_list|(
name|scu_node
argument_list|,
name|scu_errata_764369
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|aml8726_smp
operator|.
name|errata_764369
operator|=
name|true
expr_stmt|;
break|break;
block|}
comment|/* 	 * Read the number of CPUs present. 	 */
name|value
operator|=
name|SCU_READ_4
argument_list|(
name|AML_SCU_CONFIG_REG
argument_list|)
expr_stmt|;
name|ncpu
operator|=
operator|(
name|value
operator|&
name|AML_SCU_CONFIG_NCPU_MASK
operator|)
operator|+
literal|1
expr_stmt|;
name|moveon
label|:
name|mp_ncpus
operator|=
name|ncpu
expr_stmt|;
name|mp_maxid
operator|=
name|ncpu
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|int
name|platform_mp_probe
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|mp_ncpus
operator|==
literal|0
condition|)
name|platform_mp_setmaxid
argument_list|()
expr_stmt|;
return|return
operator|(
name|mp_ncpus
operator|>
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|void
name|platform_mp_start_ap
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|uint32_t
name|reg
decl_stmt|;
name|uint32_t
name|value
decl_stmt|;
name|vm_paddr_t
name|paddr
decl_stmt|;
if|if
condition|(
name|mp_ncpus
operator|<
literal|2
condition|)
return|return;
comment|/* 	 * Invalidate SCU cache tags.  The 0x0000ffff constant invalidates 	 * all ways on all cores 0-3.  Per the ARM docs, it's harmless to 	 * write to the bits for cores that are not present. 	 */
name|SCU_WRITE_4
argument_list|(
name|AML_SCU_INV_TAGS_REG
argument_list|,
literal|0x0000ffff
argument_list|)
expr_stmt|;
if|if
condition|(
name|aml8726_smp
operator|.
name|errata_764369
condition|)
block|{
comment|/* 		 * Erratum ARM/MP: 764369 (problems with cache maintenance). 		 * Setting the "disable-migratory bit" in the undocumented SCU 		 * Diagnostic Control Register helps work around the problem. 		 */
name|value
operator|=
name|SCU_READ_4
argument_list|(
name|AML_SCU_DIAG_CONTROL_REG
argument_list|)
expr_stmt|;
name|value
operator||=
name|AML_SCU_DIAG_CONTROL_DISABLE_MIGBIT
expr_stmt|;
name|SCU_WRITE_4
argument_list|(
name|AML_SCU_DIAG_CONTROL_REG
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Enable the SCU, then clean the cache on this core.  After these 	 * two operations the cache tag ram in the SCU is coherent with 	 * the contents of the cache on this core.  The other cores aren't 	 * running yet so their caches can't contain valid data yet, however 	 * we've initialized their SCU tag ram above, so they will be 	 * coherent from startup. 	 */
name|value
operator|=
name|SCU_READ_4
argument_list|(
name|AML_SCU_CONTROL_REG
argument_list|)
expr_stmt|;
name|value
operator||=
name|AML_SCU_CONTROL_ENABLE
expr_stmt|;
name|SCU_WRITE_4
argument_list|(
name|AML_SCU_CONTROL_REG
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|SCU_BARRIER
argument_list|(
name|AML_SCU_CONTROL_REG
argument_list|)
expr_stmt|;
name|cpu_idcache_wbinv_all
argument_list|()
expr_stmt|;
comment|/* Set the boot address and power on each AP. */
name|paddr
operator|=
name|pmap_kextract
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|mpentry
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|mp_ncpus
condition|;
name|i
operator|++
control|)
block|{
name|reg
operator|=
name|AML_CPUCONF_CPU1_ADDR_REG
operator|+
operator|(
operator|(
name|i
operator|-
literal|1
operator|)
operator|*
literal|4
operator|)
expr_stmt|;
name|CPUCONF_WRITE_4
argument_list|(
name|reg
argument_list|,
name|paddr
argument_list|)
expr_stmt|;
name|CPUCONF_BARRIER
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|power_on_cpu
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Enable the APs. 	 * 	 * The Amlogic Linux platform code sets the lsb for some reason 	 * in addition to the enable bit for each AP so we follow suit 	 * (the lsb may be the enable bit for the BP, though in that case 	 * it should already be set since it's currently running). 	 */
name|value
operator|=
name|CPUCONF_READ_4
argument_list|(
name|AML_CPUCONF_CONTROL_REG
argument_list|)
expr_stmt|;
name|value
operator||=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|mp_ncpus
condition|;
name|i
operator|++
control|)
name|value
operator||=
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
name|CPUCONF_WRITE_4
argument_list|(
name|AML_CPUCONF_CONTROL_REG
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|CPUCONF_BARRIER
argument_list|(
name|AML_CPUCONF_CONTROL_REG
argument_list|)
expr_stmt|;
comment|/* Wakeup the now enabled APs */
name|armv7_sev
argument_list|()
expr_stmt|;
comment|/* 	 * Free the resources which are not needed after startup. 	 */
name|bus_space_unmap
argument_list|(
name|aml8726_smp
operator|.
name|scu_res
operator|.
name|r_bustag
argument_list|,
name|aml8726_smp
operator|.
name|scu_res
operator|.
name|r_bushandle
argument_list|,
name|aml8726_smp
operator|.
name|scu_size
argument_list|)
expr_stmt|;
name|bus_space_unmap
argument_list|(
name|aml8726_smp
operator|.
name|cpucfg_res
operator|.
name|r_bustag
argument_list|,
name|aml8726_smp
operator|.
name|cpucfg_res
operator|.
name|r_bushandle
argument_list|,
name|aml8726_smp
operator|.
name|cpucfg_size
argument_list|)
expr_stmt|;
name|bus_space_unmap
argument_list|(
name|aml8726_smp
operator|.
name|aobus_res
operator|.
name|r_bustag
argument_list|,
name|aml8726_smp
operator|.
name|aobus_res
operator|.
name|r_bushandle
argument_list|,
literal|0x100000
argument_list|)
expr_stmt|;
name|bus_space_unmap
argument_list|(
name|aml8726_smp
operator|.
name|cbus_res
operator|.
name|r_bustag
argument_list|,
name|aml8726_smp
operator|.
name|cbus_res
operator|.
name|r_bushandle
argument_list|,
literal|0x100000
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|aml8726_smp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|aml8726_smp
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|platform_ipi_send
parameter_list|(
name|cpuset_t
name|cpus
parameter_list|,
name|u_int
name|ipi
parameter_list|)
block|{
name|pic_ipi_send
argument_list|(
name|cpus
argument_list|,
name|ipi
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Stub drivers for cosmetic purposes.  */
end_comment

begin_struct
struct|struct
name|aml8726_scu_softc
block|{
name|device_t
name|dev
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|aml8726_scu_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|scu_compatible
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ofw_bus_is_compatible
argument_list|(
name|dev
argument_list|,
name|scu_compatible
index|[
name|i
index|]
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|scu_compatible
index|[
name|i
index|]
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"ARM Snoop Control Unit"
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aml8726_scu_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|aml8726_scu_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aml8726_scu_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|aml8726_scu_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|aml8726_scu_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|aml8726_scu_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|aml8726_scu_detach
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|aml8726_scu_driver
init|=
block|{
literal|"scu"
block|,
name|aml8726_scu_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|aml8726_scu_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|aml8726_scu_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|EARLY_DRIVER_MODULE
argument_list|(
name|scu
argument_list|,
name|simplebus
argument_list|,
name|aml8726_scu_driver
argument_list|,
name|aml8726_scu_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|BUS_PASS_CPU
operator|+
name|BUS_PASS_ORDER_MIDDLE
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|aml8726_cpucfg_softc
block|{
name|device_t
name|dev
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|aml8726_cpucfg_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|cpucfg_compatible
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ofw_bus_is_compatible
argument_list|(
name|dev
argument_list|,
name|cpucfg_compatible
index|[
name|i
index|]
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|cpucfg_compatible
index|[
name|i
index|]
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Amlogic CPU Config"
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aml8726_cpucfg_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|aml8726_cpucfg_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aml8726_cpucfg_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|aml8726_cpucfg_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|aml8726_cpucfg_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|aml8726_cpucfg_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|aml8726_cpucfg_detach
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|aml8726_cpucfg_driver
init|=
block|{
literal|"cpuconfig"
block|,
name|aml8726_cpucfg_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|aml8726_cpucfg_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|aml8726_cpucfg_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|EARLY_DRIVER_MODULE
argument_list|(
name|cpuconfig
argument_list|,
name|simplebus
argument_list|,
name|aml8726_cpucfg_driver
argument_list|,
name|aml8726_cpucfg_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|BUS_PASS_CPU
operator|+
name|BUS_PASS_ORDER_MIDDLE
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

