begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2013 Daisuke Aoyama<aoyama@peach.ne.jp>  * Copyright (c) 2013 Oleksandr Tymoshenko<gonzo@bluezbox.com>  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/openfirm.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/ofw_bus.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/ofw_bus_subr.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|"bcm2835_dma.h"
end_include

begin_include
include|#
directive|include
file|"bcm2835_vcbus.h"
end_include

begin_define
define|#
directive|define
name|MAX_REG
value|9
end_define

begin_comment
comment|/* private flags */
end_comment

begin_define
define|#
directive|define
name|BCM_DMA_CH_USED
value|0x00000001
end_define

begin_define
define|#
directive|define
name|BCM_DMA_CH_FREE
value|0x40000000
end_define

begin_define
define|#
directive|define
name|BCM_DMA_CH_UNMAP
value|0x80000000
end_define

begin_comment
comment|/* Register Map (4.2.1.2) */
end_comment

begin_define
define|#
directive|define
name|BCM_DMA_CS
parameter_list|(
name|n
parameter_list|)
value|(0x100*(n) + 0x00)
end_define

begin_define
define|#
directive|define
name|CS_ACTIVE
value|(1<<  0)
end_define

begin_define
define|#
directive|define
name|CS_END
value|(1<<  1)
end_define

begin_define
define|#
directive|define
name|CS_INT
value|(1<<  2)
end_define

begin_define
define|#
directive|define
name|CS_DREQ
value|(1<<  3)
end_define

begin_define
define|#
directive|define
name|CS_ISPAUSED
value|(1<<  4)
end_define

begin_define
define|#
directive|define
name|CS_ISHELD
value|(1<<  5)
end_define

begin_define
define|#
directive|define
name|CS_ISWAIT
value|(1<<  6)
end_define

begin_define
define|#
directive|define
name|CS_ERR
value|(1<<  8)
end_define

begin_define
define|#
directive|define
name|CS_WAITWRT
value|(1<< 28)
end_define

begin_define
define|#
directive|define
name|CS_DISDBG
value|(1<< 29)
end_define

begin_define
define|#
directive|define
name|CS_ABORT
value|(1<< 30)
end_define

begin_define
define|#
directive|define
name|CS_RESET
value|(1U<< 31)
end_define

begin_define
define|#
directive|define
name|BCM_DMA_CBADDR
parameter_list|(
name|n
parameter_list|)
value|(0x100*(n) + 0x04)
end_define

begin_define
define|#
directive|define
name|BCM_DMA_INFO
parameter_list|(
name|n
parameter_list|)
value|(0x100*(n) + 0x08)
end_define

begin_define
define|#
directive|define
name|INFO_INT_EN
value|(1<< 0)
end_define

begin_define
define|#
directive|define
name|INFO_TDMODE
value|(1<< 1)
end_define

begin_define
define|#
directive|define
name|INFO_WAIT_RESP
value|(1<< 3)
end_define

begin_define
define|#
directive|define
name|INFO_D_INC
value|(1<< 4)
end_define

begin_define
define|#
directive|define
name|INFO_D_WIDTH
value|(1<< 5)
end_define

begin_define
define|#
directive|define
name|INFO_D_DREQ
value|(1<< 6)
end_define

begin_define
define|#
directive|define
name|INFO_S_INC
value|(1<< 8)
end_define

begin_define
define|#
directive|define
name|INFO_S_WIDTH
value|(1<< 9)
end_define

begin_define
define|#
directive|define
name|INFO_S_DREQ
value|(1<< 10)
end_define

begin_define
define|#
directive|define
name|INFO_WAITS_SHIFT
value|(21)
end_define

begin_define
define|#
directive|define
name|INFO_PERMAP_SHIFT
value|(16)
end_define

begin_define
define|#
directive|define
name|INFO_PERMAP_MASK
value|(0x1f<< INFO_PERMAP_SHIFT)
end_define

begin_define
define|#
directive|define
name|BCM_DMA_SRC
parameter_list|(
name|n
parameter_list|)
value|(0x100*(n) + 0x0C)
end_define

begin_define
define|#
directive|define
name|BCM_DMA_DST
parameter_list|(
name|n
parameter_list|)
value|(0x100*(n) + 0x10)
end_define

begin_define
define|#
directive|define
name|BCM_DMA_LEN
parameter_list|(
name|n
parameter_list|)
value|(0x100*(n) + 0x14)
end_define

begin_define
define|#
directive|define
name|BCM_DMA_STRIDE
parameter_list|(
name|n
parameter_list|)
value|(0x100*(n) + 0x18)
end_define

begin_define
define|#
directive|define
name|BCM_DMA_CBNEXT
parameter_list|(
name|n
parameter_list|)
value|(0x100*(n) + 0x1C)
end_define

begin_define
define|#
directive|define
name|BCM_DMA_DEBUG
parameter_list|(
name|n
parameter_list|)
value|(0x100*(n) + 0x20)
end_define

begin_define
define|#
directive|define
name|DEBUG_ERROR_MASK
value|(7)
end_define

begin_define
define|#
directive|define
name|BCM_DMA_INT_STATUS
value|0xfe0
end_define

begin_define
define|#
directive|define
name|BCM_DMA_ENABLE
value|0xff0
end_define

begin_comment
comment|/* relative offset from BCM_VC_DMA0_BASE (p.39) */
end_comment

begin_define
define|#
directive|define
name|BCM_DMA_CH
parameter_list|(
name|n
parameter_list|)
value|(0x100*(n))
end_define

begin_comment
comment|/* channels used by GPU */
end_comment

begin_define
define|#
directive|define
name|BCM_DMA_CH_BULK
value|0
end_define

begin_define
define|#
directive|define
name|BCM_DMA_CH_FAST1
value|2
end_define

begin_define
define|#
directive|define
name|BCM_DMA_CH_FAST2
value|3
end_define

begin_define
define|#
directive|define
name|BCM_DMA_CH_GPU_MASK
value|((1<< BCM_DMA_CH_BULK) |	\ 				 (1<< BCM_DMA_CH_FAST1) |	\ 				 (1<< BCM_DMA_CH_FAST2))
end_define

begin_comment
comment|/* DMA Control Block - 256bit aligned (p.40) */
end_comment

begin_struct
struct|struct
name|bcm_dma_cb
block|{
name|uint32_t
name|info
decl_stmt|;
comment|/* Transfer Information */
name|uint32_t
name|src
decl_stmt|;
comment|/* Source Address */
name|uint32_t
name|dst
decl_stmt|;
comment|/* Destination Address */
name|uint32_t
name|len
decl_stmt|;
comment|/* Transfer Length */
name|uint32_t
name|stride
decl_stmt|;
comment|/* 2D Mode Stride */
name|uint32_t
name|next
decl_stmt|;
comment|/* Next Control Block Address */
name|uint32_t
name|rsvd1
decl_stmt|;
comment|/* Reserved */
name|uint32_t
name|rsvd2
decl_stmt|;
comment|/* Reserved */
block|}
struct|;
end_struct

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function_decl
specifier|static
name|void
name|bcm_dma_cb_dump
parameter_list|(
name|struct
name|bcm_dma_cb
modifier|*
name|cb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bcm_dma_reg_dump
parameter_list|(
name|int
name|ch
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DMA channel private info */
end_comment

begin_struct
struct|struct
name|bcm_dma_ch
block|{
name|int
name|ch
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
name|struct
name|bcm_dma_cb
modifier|*
name|cb
decl_stmt|;
name|uint32_t
name|vc_cb
decl_stmt|;
name|bus_dmamap_t
name|dma_map
decl_stmt|;
name|void
function_decl|(
modifier|*
name|intr_func
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
name|void
modifier|*
name|intr_arg
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|bcm_dma_softc
block|{
name|device_t
name|sc_dev
decl_stmt|;
name|struct
name|mtx
name|sc_mtx
decl_stmt|;
name|struct
name|resource
modifier|*
name|sc_mem
decl_stmt|;
name|struct
name|resource
modifier|*
name|sc_irq
index|[
name|BCM_DMA_CH_MAX
index|]
decl_stmt|;
name|void
modifier|*
name|sc_intrhand
index|[
name|BCM_DMA_CH_MAX
index|]
decl_stmt|;
name|struct
name|bcm_dma_ch
name|sc_dma_ch
index|[
name|BCM_DMA_CH_MAX
index|]
decl_stmt|;
name|bus_dma_tag_t
name|sc_dma_tag
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|bcm_dma_softc
modifier|*
name|bcm_dma_sc
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|bcm_dma_channel_mask
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ofw_compat_data
name|compat_data
index|[]
init|=
block|{
block|{
literal|"broadcom,bcm2835-dma"
block|,
literal|1
block|}
block|,
block|{
literal|"brcm,bcm2835-dma"
block|,
literal|1
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|bcm_dmamap_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|err
parameter_list|)
block|{
name|bus_addr_t
modifier|*
name|addr
decl_stmt|;
if|if
condition|(
name|err
condition|)
return|return;
name|addr
operator|=
operator|(
name|bus_addr_t
operator|*
operator|)
name|arg
expr_stmt|;
operator|*
name|addr
operator|=
name|PHYS_TO_VCBUS
argument_list|(
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bcm_dma_reset
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|ch
parameter_list|)
block|{
name|struct
name|bcm_dma_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|bcm_dma_cb
modifier|*
name|cb
decl_stmt|;
name|uint32_t
name|cs
decl_stmt|;
name|int
name|count
decl_stmt|;
if|if
condition|(
name|ch
operator|<
literal|0
operator|||
name|ch
operator|>=
name|BCM_DMA_CH_MAX
condition|)
return|return;
name|cs
operator|=
name|bus_read_4
argument_list|(
name|sc
operator|->
name|sc_mem
argument_list|,
name|BCM_DMA_CS
argument_list|(
name|ch
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cs
operator|&
name|CS_ACTIVE
condition|)
block|{
comment|/* pause current task */
name|bus_write_4
argument_list|(
name|sc
operator|->
name|sc_mem
argument_list|,
name|BCM_DMA_CS
argument_list|(
name|ch
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|count
operator|=
literal|1000
expr_stmt|;
do|do
block|{
name|cs
operator|=
name|bus_read_4
argument_list|(
name|sc
operator|->
name|sc_mem
argument_list|,
name|BCM_DMA_CS
argument_list|(
name|ch
argument_list|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
operator|(
name|cs
operator|&
name|CS_ISPAUSED
operator|)
operator|&&
operator|(
name|count
operator|--
operator|>
literal|0
operator|)
condition|)
do|;
if|if
condition|(
operator|!
operator|(
name|cs
operator|&
name|CS_ISPAUSED
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Can't abort DMA transfer at channel %d\n"
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
name|bus_write_4
argument_list|(
name|sc
operator|->
name|sc_mem
argument_list|,
name|BCM_DMA_CBNEXT
argument_list|(
name|ch
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Complete everything, clear interrupt */
name|bus_write_4
argument_list|(
name|sc
operator|->
name|sc_mem
argument_list|,
name|BCM_DMA_CS
argument_list|(
name|ch
argument_list|)
argument_list|,
name|CS_ABORT
operator||
name|CS_INT
operator||
name|CS_END
operator||
name|CS_ACTIVE
argument_list|)
expr_stmt|;
block|}
comment|/* clear control blocks */
name|bus_write_4
argument_list|(
name|sc
operator|->
name|sc_mem
argument_list|,
name|BCM_DMA_CBADDR
argument_list|(
name|ch
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bus_write_4
argument_list|(
name|sc
operator|->
name|sc_mem
argument_list|,
name|BCM_DMA_CBNEXT
argument_list|(
name|ch
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Reset control block */
name|cb
operator|=
name|sc
operator|->
name|sc_dma_ch
index|[
name|ch
index|]
operator|.
name|cb
expr_stmt|;
name|bzero
argument_list|(
name|cb
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cb
argument_list|)
argument_list|)
expr_stmt|;
name|cb
operator|->
name|info
operator|=
name|INFO_WAIT_RESP
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|bcm_dma_init
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|bcm_dma_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|uint32_t
name|reg
decl_stmt|;
name|struct
name|bcm_dma_ch
modifier|*
name|ch
decl_stmt|;
name|void
modifier|*
name|cb_virt
decl_stmt|;
name|vm_paddr_t
name|cb_phys
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Only channels set in bcm_dma_channel_mask can be controlled by us. 	 * The others are out of our control as well as the corresponding bits 	 * in both BCM_DMA_ENABLE and BCM_DMA_INT_STATUS global registers. As 	 * these registers are RW ones, there is no safe way how to write only 	 * the bits which can be controlled by us. 	 * 	 * Fortunately, after reset, all channels are enabled in BCM_DMA_ENABLE 	 * register and all statuses are cleared in BCM_DMA_INT_STATUS one. 	 * Not touching these registers is a trade off between correct 	 * initialization which does not count on anything and not messing up 	 * something we have no control over. 	 */
name|reg
operator|=
name|bus_read_4
argument_list|(
name|sc
operator|->
name|sc_mem
argument_list|,
name|BCM_DMA_ENABLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|reg
operator|&
name|bcm_dma_channel_mask
operator|)
operator|!=
name|bcm_dma_channel_mask
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"channels are not enabled\n"
argument_list|)
expr_stmt|;
name|reg
operator|=
name|bus_read_4
argument_list|(
name|sc
operator|->
name|sc_mem
argument_list|,
name|BCM_DMA_INT_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|reg
operator|&
name|bcm_dma_channel_mask
operator|)
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"statuses are not cleared\n"
argument_list|)
expr_stmt|;
comment|/* Allocate DMA chunks control blocks */
comment|/* p.40 of spec - control block should be 32-bit aligned */
name|err
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bcm_dma_cb
argument_list|)
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bcm_dma_cb
argument_list|)
argument_list|,
name|BUS_DMA_ALLOCNOW
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|sc
operator|->
name|sc_dma_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed allocate DMA tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
comment|/* setup initial settings */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BCM_DMA_CH_MAX
condition|;
name|i
operator|++
control|)
block|{
name|ch
operator|=
operator|&
name|sc
operator|->
name|sc_dma_ch
index|[
name|i
index|]
expr_stmt|;
name|bzero
argument_list|(
name|ch
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bcm_dma_ch
argument_list|)
argument_list|)
expr_stmt|;
name|ch
operator|->
name|ch
operator|=
name|i
expr_stmt|;
name|ch
operator|->
name|flags
operator|=
name|BCM_DMA_CH_UNMAP
expr_stmt|;
if|if
condition|(
operator|(
name|bcm_dma_channel_mask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|err
operator|=
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|sc_dma_tag
argument_list|,
operator|&
name|cb_virt
argument_list|,
name|BUS_DMA_WAITOK
operator||
name|BUS_DMA_COHERENT
operator||
name|BUS_DMA_ZERO
argument_list|,
operator|&
name|ch
operator|->
name|dma_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot allocate DMA memory\n"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/*  		 * Least alignment for busdma-allocated stuff is cache  		 * line size, so just make sure nothing stupid happened 		 * and we got properly aligned address 		 */
if|if
condition|(
operator|(
name|uintptr_t
operator|)
name|cb_virt
operator|&
literal|0x1f
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"DMA address is not 32-bytes aligned: %p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|cb_virt
argument_list|)
expr_stmt|;
break|break;
block|}
name|err
operator|=
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|sc_dma_tag
argument_list|,
name|ch
operator|->
name|dma_map
argument_list|,
name|cb_virt
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bcm_dma_cb
argument_list|)
argument_list|,
name|bcm_dmamap_cb
argument_list|,
operator|&
name|cb_phys
argument_list|,
name|BUS_DMA_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot load DMA memory\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|ch
operator|->
name|cb
operator|=
name|cb_virt
expr_stmt|;
name|ch
operator|->
name|vc_cb
operator|=
name|cb_phys
expr_stmt|;
name|ch
operator|->
name|flags
operator|=
name|BCM_DMA_CH_FREE
expr_stmt|;
name|ch
operator|->
name|cb
operator|->
name|info
operator|=
name|INFO_WAIT_RESP
expr_stmt|;
comment|/* reset DMA engine */
name|bus_write_4
argument_list|(
name|sc
operator|->
name|sc_mem
argument_list|,
name|BCM_DMA_CS
argument_list|(
name|i
argument_list|)
argument_list|,
name|CS_RESET
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate DMA channel for further use, returns channel # or  *     BCM_DMA_CH_INVALID  */
end_comment

begin_function
name|int
name|bcm_dma_allocate
parameter_list|(
name|int
name|req_ch
parameter_list|)
block|{
name|struct
name|bcm_dma_softc
modifier|*
name|sc
init|=
name|bcm_dma_sc
decl_stmt|;
name|int
name|ch
init|=
name|BCM_DMA_CH_INVALID
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|req_ch
operator|>=
name|BCM_DMA_CH_MAX
condition|)
return|return
operator|(
name|BCM_DMA_CH_INVALID
operator|)
return|;
comment|/* Auto(req_ch< 0) or CH specified */
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|req_ch
operator|<
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BCM_DMA_CH_MAX
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_dma_ch
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|BCM_DMA_CH_FREE
condition|)
block|{
name|ch
operator|=
name|i
expr_stmt|;
name|sc
operator|->
name|sc_dma_ch
index|[
name|ch
index|]
operator|.
name|flags
operator|&=
operator|~
name|BCM_DMA_CH_FREE
expr_stmt|;
name|sc
operator|->
name|sc_dma_ch
index|[
name|ch
index|]
operator|.
name|flags
operator||=
name|BCM_DMA_CH_USED
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|sc
operator|->
name|sc_dma_ch
index|[
name|req_ch
index|]
operator|.
name|flags
operator|&
name|BCM_DMA_CH_FREE
condition|)
block|{
name|ch
operator|=
name|req_ch
expr_stmt|;
name|sc
operator|->
name|sc_dma_ch
index|[
name|ch
index|]
operator|.
name|flags
operator|&=
operator|~
name|BCM_DMA_CH_FREE
expr_stmt|;
name|sc
operator|->
name|sc_dma_ch
index|[
name|ch
index|]
operator|.
name|flags
operator||=
name|BCM_DMA_CH_USED
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ch
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Frees allocated channel. Returns 0 on success, -1 otherwise  */
end_comment

begin_function
name|int
name|bcm_dma_free
parameter_list|(
name|int
name|ch
parameter_list|)
block|{
name|struct
name|bcm_dma_softc
modifier|*
name|sc
init|=
name|bcm_dma_sc
decl_stmt|;
if|if
condition|(
name|ch
operator|<
literal|0
operator|||
name|ch
operator|>=
name|BCM_DMA_CH_MAX
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dma_ch
index|[
name|ch
index|]
operator|.
name|flags
operator|&
name|BCM_DMA_CH_USED
condition|)
block|{
name|sc
operator|->
name|sc_dma_ch
index|[
name|ch
index|]
operator|.
name|flags
operator||=
name|BCM_DMA_CH_FREE
expr_stmt|;
name|sc
operator|->
name|sc_dma_ch
index|[
name|ch
index|]
operator|.
name|flags
operator|&=
operator|~
name|BCM_DMA_CH_USED
expr_stmt|;
name|sc
operator|->
name|sc_dma_ch
index|[
name|ch
index|]
operator|.
name|intr_func
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_dma_ch
index|[
name|ch
index|]
operator|.
name|intr_arg
operator|=
name|NULL
expr_stmt|;
comment|/* reset DMA engine */
name|bcm_dma_reset
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Assign handler function for channel interrupt  * Returns 0 on success, -1 otherwise  */
end_comment

begin_function
name|int
name|bcm_dma_setup_intr
parameter_list|(
name|int
name|ch
parameter_list|,
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|bcm_dma_softc
modifier|*
name|sc
init|=
name|bcm_dma_sc
decl_stmt|;
name|struct
name|bcm_dma_cb
modifier|*
name|cb
decl_stmt|;
if|if
condition|(
name|ch
operator|<
literal|0
operator|||
name|ch
operator|>=
name|BCM_DMA_CH_MAX
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|sc_dma_ch
index|[
name|ch
index|]
operator|.
name|flags
operator|&
name|BCM_DMA_CH_USED
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|sc
operator|->
name|sc_dma_ch
index|[
name|ch
index|]
operator|.
name|intr_func
operator|=
name|func
expr_stmt|;
name|sc
operator|->
name|sc_dma_ch
index|[
name|ch
index|]
operator|.
name|intr_arg
operator|=
name|arg
expr_stmt|;
name|cb
operator|=
name|sc
operator|->
name|sc_dma_ch
index|[
name|ch
index|]
operator|.
name|cb
expr_stmt|;
name|cb
operator|->
name|info
operator||=
name|INFO_INT_EN
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Setup DMA source parameters  *     ch - channel number  *     dreq - hardware DREQ # or BCM_DMA_DREQ_NONE if  *         source is physical memory  *     inc_addr - BCM_DMA_INC_ADDR if source address  *         should be increased after each access or   *         BCM_DMA_SAME_ADDR if address should remain   *         the same  *     width - size of read operation, BCM_DMA_32BIT  *         for 32bit bursts, BCM_DMA_128BIT for 128 bits  *	    * Returns 0 on success, -1 otherwise  */
end_comment

begin_function
name|int
name|bcm_dma_setup_src
parameter_list|(
name|int
name|ch
parameter_list|,
name|int
name|dreq
parameter_list|,
name|int
name|inc_addr
parameter_list|,
name|int
name|width
parameter_list|)
block|{
name|struct
name|bcm_dma_softc
modifier|*
name|sc
init|=
name|bcm_dma_sc
decl_stmt|;
name|uint32_t
name|info
decl_stmt|;
if|if
condition|(
name|ch
operator|<
literal|0
operator|||
name|ch
operator|>=
name|BCM_DMA_CH_MAX
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|sc_dma_ch
index|[
name|ch
index|]
operator|.
name|flags
operator|&
name|BCM_DMA_CH_USED
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|info
operator|=
name|sc
operator|->
name|sc_dma_ch
index|[
name|ch
index|]
operator|.
name|cb
operator|->
name|info
expr_stmt|;
name|info
operator|&=
operator|~
name|INFO_PERMAP_MASK
expr_stmt|;
name|info
operator||=
operator|(
name|dreq
operator|<<
name|INFO_PERMAP_SHIFT
operator|)
operator|&
name|INFO_PERMAP_MASK
expr_stmt|;
if|if
condition|(
name|dreq
condition|)
name|info
operator||=
name|INFO_S_DREQ
expr_stmt|;
else|else
name|info
operator|&=
operator|~
name|INFO_S_DREQ
expr_stmt|;
if|if
condition|(
name|width
operator|==
name|BCM_DMA_128BIT
condition|)
name|info
operator||=
name|INFO_S_WIDTH
expr_stmt|;
else|else
name|info
operator|&=
operator|~
name|INFO_S_WIDTH
expr_stmt|;
if|if
condition|(
name|inc_addr
operator|==
name|BCM_DMA_INC_ADDR
condition|)
name|info
operator||=
name|INFO_S_INC
expr_stmt|;
else|else
name|info
operator|&=
operator|~
name|INFO_S_INC
expr_stmt|;
name|sc
operator|->
name|sc_dma_ch
index|[
name|ch
index|]
operator|.
name|cb
operator|->
name|info
operator|=
name|info
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Setup DMA destination parameters  *     ch - channel number  *     dreq - hardware DREQ # or BCM_DMA_DREQ_NONE if  *         destination is physical memory  *     inc_addr - BCM_DMA_INC_ADDR if source address  *         should be increased after each access or   *         BCM_DMA_SAME_ADDR if address should remain   *         the same  *     width - size of write operation, BCM_DMA_32BIT  *         for 32bit bursts, BCM_DMA_128BIT for 128 bits  *	    * Returns 0 on success, -1 otherwise  */
end_comment

begin_function
name|int
name|bcm_dma_setup_dst
parameter_list|(
name|int
name|ch
parameter_list|,
name|int
name|dreq
parameter_list|,
name|int
name|inc_addr
parameter_list|,
name|int
name|width
parameter_list|)
block|{
name|struct
name|bcm_dma_softc
modifier|*
name|sc
init|=
name|bcm_dma_sc
decl_stmt|;
name|uint32_t
name|info
decl_stmt|;
if|if
condition|(
name|ch
operator|<
literal|0
operator|||
name|ch
operator|>=
name|BCM_DMA_CH_MAX
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|sc_dma_ch
index|[
name|ch
index|]
operator|.
name|flags
operator|&
name|BCM_DMA_CH_USED
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|info
operator|=
name|sc
operator|->
name|sc_dma_ch
index|[
name|ch
index|]
operator|.
name|cb
operator|->
name|info
expr_stmt|;
name|info
operator|&=
operator|~
name|INFO_PERMAP_MASK
expr_stmt|;
name|info
operator||=
operator|(
name|dreq
operator|<<
name|INFO_PERMAP_SHIFT
operator|)
operator|&
name|INFO_PERMAP_MASK
expr_stmt|;
if|if
condition|(
name|dreq
condition|)
name|info
operator||=
name|INFO_D_DREQ
expr_stmt|;
else|else
name|info
operator|&=
operator|~
name|INFO_D_DREQ
expr_stmt|;
if|if
condition|(
name|width
operator|==
name|BCM_DMA_128BIT
condition|)
name|info
operator||=
name|INFO_D_WIDTH
expr_stmt|;
else|else
name|info
operator|&=
operator|~
name|INFO_D_WIDTH
expr_stmt|;
if|if
condition|(
name|inc_addr
operator|==
name|BCM_DMA_INC_ADDR
condition|)
name|info
operator||=
name|INFO_D_INC
expr_stmt|;
else|else
name|info
operator|&=
operator|~
name|INFO_D_INC
expr_stmt|;
name|sc
operator|->
name|sc_dma_ch
index|[
name|ch
index|]
operator|.
name|cb
operator|->
name|info
operator|=
name|info
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function
name|void
name|bcm_dma_cb_dump
parameter_list|(
name|struct
name|bcm_dma_cb
modifier|*
name|cb
parameter_list|)
block|{
name|printf
argument_list|(
literal|"DMA CB "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"INFO: %8.8x "
argument_list|,
name|cb
operator|->
name|info
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SRC: %8.8x "
argument_list|,
name|cb
operator|->
name|src
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"DST: %8.8x "
argument_list|,
name|cb
operator|->
name|dst
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"LEN: %8.8x "
argument_list|,
name|cb
operator|->
name|len
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"STRIDE: %8.8x "
argument_list|,
name|cb
operator|->
name|stride
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"NEXT: %8.8x "
argument_list|,
name|cb
operator|->
name|next
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"RSVD1: %8.8x "
argument_list|,
name|cb
operator|->
name|rsvd1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"RSVD2: %8.8x "
argument_list|,
name|cb
operator|->
name|rsvd2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bcm_dma_reg_dump
parameter_list|(
name|int
name|ch
parameter_list|)
block|{
name|struct
name|bcm_dma_softc
modifier|*
name|sc
init|=
name|bcm_dma_sc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint32_t
name|reg
decl_stmt|;
if|if
condition|(
name|ch
operator|<
literal|0
operator|||
name|ch
operator|>=
name|BCM_DMA_CH_MAX
condition|)
return|return;
name|printf
argument_list|(
literal|"DMA%d: "
argument_list|,
name|ch
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_REG
condition|;
name|i
operator|++
control|)
block|{
name|reg
operator|=
name|bus_read_4
argument_list|(
name|sc
operator|->
name|sc_mem
argument_list|,
name|BCM_DMA_CH
argument_list|(
name|ch
argument_list|)
operator|+
name|i
operator|*
literal|4
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%8.8x "
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Start DMA transaction  *     ch - channel number  *     src, dst - source and destination address in  *         ARM physical memory address space.   *     len - amount of bytes to be transferred  *	    * Returns 0 on success, -1 otherwise  */
end_comment

begin_function
name|int
name|bcm_dma_start
parameter_list|(
name|int
name|ch
parameter_list|,
name|vm_paddr_t
name|src
parameter_list|,
name|vm_paddr_t
name|dst
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|bcm_dma_softc
modifier|*
name|sc
init|=
name|bcm_dma_sc
decl_stmt|;
name|struct
name|bcm_dma_cb
modifier|*
name|cb
decl_stmt|;
if|if
condition|(
name|ch
operator|<
literal|0
operator|||
name|ch
operator|>=
name|BCM_DMA_CH_MAX
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|sc_dma_ch
index|[
name|ch
index|]
operator|.
name|flags
operator|&
name|BCM_DMA_CH_USED
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|cb
operator|=
name|sc
operator|->
name|sc_dma_ch
index|[
name|ch
index|]
operator|.
name|cb
expr_stmt|;
if|if
condition|(
name|BCM2835_ARM_IS_IO
argument_list|(
name|src
argument_list|)
condition|)
name|cb
operator|->
name|src
operator|=
name|IO_TO_VCBUS
argument_list|(
name|src
argument_list|)
expr_stmt|;
else|else
name|cb
operator|->
name|src
operator|=
name|PHYS_TO_VCBUS
argument_list|(
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|BCM2835_ARM_IS_IO
argument_list|(
name|dst
argument_list|)
condition|)
name|cb
operator|->
name|dst
operator|=
name|IO_TO_VCBUS
argument_list|(
name|dst
argument_list|)
expr_stmt|;
else|else
name|cb
operator|->
name|dst
operator|=
name|PHYS_TO_VCBUS
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|cb
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dma_tag
argument_list|,
name|sc
operator|->
name|sc_dma_ch
index|[
name|ch
index|]
operator|.
name|dma_map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|bus_write_4
argument_list|(
name|sc
operator|->
name|sc_mem
argument_list|,
name|BCM_DMA_CBADDR
argument_list|(
name|ch
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_dma_ch
index|[
name|ch
index|]
operator|.
name|vc_cb
argument_list|)
expr_stmt|;
name|bus_write_4
argument_list|(
name|sc
operator|->
name|sc_mem
argument_list|,
name|BCM_DMA_CS
argument_list|(
name|ch
argument_list|)
argument_list|,
name|CS_ACTIVE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|bcm_dma_cb_dump
argument_list|(
name|sc
operator|->
name|sc_dma_ch
index|[
name|ch
index|]
operator|.
name|cb
argument_list|)
expr_stmt|;
name|bcm_dma_reg_dump
argument_list|(
name|ch
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get length requested for DMA transaction  *     ch - channel number  *	    * Returns size of transaction, 0 if channel is invalid  */
end_comment

begin_function
name|uint32_t
name|bcm_dma_length
parameter_list|(
name|int
name|ch
parameter_list|)
block|{
name|struct
name|bcm_dma_softc
modifier|*
name|sc
init|=
name|bcm_dma_sc
decl_stmt|;
name|struct
name|bcm_dma_cb
modifier|*
name|cb
decl_stmt|;
if|if
condition|(
name|ch
operator|<
literal|0
operator|||
name|ch
operator|>=
name|BCM_DMA_CH_MAX
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|sc_dma_ch
index|[
name|ch
index|]
operator|.
name|flags
operator|&
name|BCM_DMA_CH_USED
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|cb
operator|=
name|sc
operator|->
name|sc_dma_ch
index|[
name|ch
index|]
operator|.
name|cb
expr_stmt|;
return|return
operator|(
name|cb
operator|->
name|len
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bcm_dma_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|bcm_dma_softc
modifier|*
name|sc
init|=
name|bcm_dma_sc
decl_stmt|;
name|struct
name|bcm_dma_ch
modifier|*
name|ch
init|=
operator|(
expr|struct
name|bcm_dma_ch
operator|*
operator|)
name|arg
decl_stmt|;
name|uint32_t
name|cs
decl_stmt|,
name|debug
decl_stmt|;
comment|/* my interrupt? */
name|cs
operator|=
name|bus_read_4
argument_list|(
name|sc
operator|->
name|sc_mem
argument_list|,
name|BCM_DMA_CS
argument_list|(
name|ch
operator|->
name|ch
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|cs
operator|&
operator|(
name|CS_INT
operator||
name|CS_ERR
operator|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unexpected DMA intr CH=%d, CS=%x\n"
argument_list|,
name|ch
operator|->
name|ch
argument_list|,
name|cs
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* running? */
if|if
condition|(
operator|!
operator|(
name|ch
operator|->
name|flags
operator|&
name|BCM_DMA_CH_USED
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unused DMA intr CH=%d, CS=%x\n"
argument_list|,
name|ch
operator|->
name|ch
argument_list|,
name|cs
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|cs
operator|&
name|CS_ERR
condition|)
block|{
name|debug
operator|=
name|bus_read_4
argument_list|(
name|sc
operator|->
name|sc_mem
argument_list|,
name|BCM_DMA_DEBUG
argument_list|(
name|ch
operator|->
name|ch
argument_list|)
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"DMA error %d on CH%d\n"
argument_list|,
name|debug
operator|&
name|DEBUG_ERROR_MASK
argument_list|,
name|ch
operator|->
name|ch
argument_list|)
expr_stmt|;
name|bus_write_4
argument_list|(
name|sc
operator|->
name|sc_mem
argument_list|,
name|BCM_DMA_DEBUG
argument_list|(
name|ch
operator|->
name|ch
argument_list|)
argument_list|,
name|debug
operator|&
name|DEBUG_ERROR_MASK
argument_list|)
expr_stmt|;
name|bcm_dma_reset
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|ch
operator|->
name|ch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cs
operator|&
name|CS_INT
condition|)
block|{
comment|/* acknowledge interrupt */
name|bus_write_4
argument_list|(
name|sc
operator|->
name|sc_mem
argument_list|,
name|BCM_DMA_CS
argument_list|(
name|ch
operator|->
name|ch
argument_list|)
argument_list|,
name|CS_INT
operator||
name|CS_END
argument_list|)
expr_stmt|;
comment|/* Prepare for possible access to len field */
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dma_tag
argument_list|,
name|ch
operator|->
name|dma_map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
comment|/* save callback function and argument */
if|if
condition|(
name|ch
operator|->
name|intr_func
condition|)
name|ch
operator|->
name|intr_func
argument_list|(
name|ch
operator|->
name|ch
argument_list|,
name|ch
operator|->
name|intr_arg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|bcm_dma_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ofw_bus_status_okay
argument_list|(
name|dev
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|ofw_bus_search_compatible
argument_list|(
name|dev
argument_list|,
name|compat_data
argument_list|)
operator|->
name|ocd_data
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"BCM2835 DMA Controller"
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bcm_dma_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|bcm_dma_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|phandle_t
name|node
decl_stmt|;
name|int
name|rid
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|->
name|sc_dev
operator|=
name|dev
expr_stmt|;
if|if
condition|(
name|bcm_dma_sc
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BCM_DMA_CH_MAX
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|sc_irq
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_intrhand
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Get DMA channel mask. */
name|node
operator|=
name|ofw_bus_get_node
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|OF_getencprop
argument_list|(
name|node
argument_list|,
literal|"brcm,dma-channel-mask"
argument_list|,
operator|&
name|bcm_dma_channel_mask
argument_list|,
sizeof|sizeof
argument_list|(
name|bcm_dma_channel_mask
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|OF_getencprop
argument_list|(
name|node
argument_list|,
literal|"broadcom,channels"
argument_list|,
operator|&
name|bcm_dma_channel_mask
argument_list|,
sizeof|sizeof
argument_list|(
name|bcm_dma_channel_mask
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not get channel mask property\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Mask out channels used by GPU. */
name|bcm_dma_channel_mask
operator|&=
operator|~
name|BCM_DMA_CH_GPU_MASK
expr_stmt|;
comment|/* DMA0 - DMA14 */
name|rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_mem
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_mem
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not allocate memory resource\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* IRQ DMA0 - DMA11 XXX NOT USE DMA12(spurious?) */
for|for
control|(
name|rid
operator|=
literal|0
init|;
name|rid
operator|<
name|BCM_DMA_CH_MAX
condition|;
name|rid
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|bcm_dma_channel_mask
operator|&
operator|(
literal|1
operator|<<
name|rid
operator|)
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|sc
operator|->
name|sc_irq
index|[
name|rid
index|]
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_irq
index|[
name|rid
index|]
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot allocate interrupt\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|sc_irq
index|[
name|rid
index|]
argument_list|,
name|INTR_TYPE_MISC
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|bcm_dma_intr
argument_list|,
operator|&
name|sc
operator|->
name|sc_dma_ch
index|[
name|rid
index|]
argument_list|,
operator|&
name|sc
operator|->
name|sc_intrhand
index|[
name|rid
index|]
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot setup interrupt handler\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
literal|"bcmdma"
argument_list|,
literal|"bcmdma"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|bcm_dma_sc
operator|=
name|sc
expr_stmt|;
name|err
operator|=
name|bcm_dma_init
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|fail
goto|;
return|return
operator|(
name|err
operator|)
return|;
name|fail
label|:
if|if
condition|(
name|sc
operator|->
name|sc_mem
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|sc_mem
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BCM_DMA_CH_MAX
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_intrhand
index|[
name|i
index|]
condition|)
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|sc_irq
index|[
name|i
index|]
argument_list|,
name|sc
operator|->
name|sc_intrhand
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_irq
index|[
name|i
index|]
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|sc_irq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|bcm_dma_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|bcm_dma_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|bcm_dma_attach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|bcm_dma_driver
init|=
block|{
literal|"bcm_dma"
block|,
name|bcm_dma_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|bcm_dma_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|bcm_dma_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|bcm_dma
argument_list|,
name|simplebus
argument_list|,
name|bcm_dma_driver
argument_list|,
name|bcm_dma_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|bcm_dma
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

