begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2015 Oleksandr Tymoshenko<gonzo@freebsd.org>  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_KERNEL_OPTION_HEADERS
end_ifdef

begin_include
include|#
directive|include
file|"opt_snd.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/sound/pcm/sound.h>
end_include

begin_include
include|#
directive|include
file|<dev/sound/chip.h>
end_include

begin_include
include|#
directive|include
file|"mixer_if.h"
end_include

begin_include
include|#
directive|include
file|"interface/compat/vchi_bsd.h"
end_include

begin_include
include|#
directive|include
file|"interface/vchi/vchi.h"
end_include

begin_include
include|#
directive|include
file|"interface/vchiq_arm/vchiq.h"
end_include

begin_include
include|#
directive|include
file|"vc_vchi_audioserv_defs.h"
end_include

begin_expr_stmt
name|SND_DECLARE_FILE
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Audio destination */
end_comment

begin_define
define|#
directive|define
name|DEST_AUTO
value|0
end_define

begin_define
define|#
directive|define
name|DEST_HEADPHONES
value|1
end_define

begin_define
define|#
directive|define
name|DEST_HDMI
value|2
end_define

begin_comment
comment|/* Playback state */
end_comment

begin_define
define|#
directive|define
name|PLAYBACK_IDLE
value|0
end_define

begin_define
define|#
directive|define
name|PLAYBACK_PLAYING
value|1
end_define

begin_define
define|#
directive|define
name|PLAYBACK_STOPPING
value|2
end_define

begin_comment
comment|/* Worker thread state */
end_comment

begin_define
define|#
directive|define
name|WORKER_RUNNING
value|0
end_define

begin_define
define|#
directive|define
name|WORKER_STOPPING
value|1
end_define

begin_define
define|#
directive|define
name|WORKER_STOPPED
value|2
end_define

begin_comment
comment|/*  * Worker thread flags, set to 1 in flags_pending  * when driver requests one or another operation  * from worker. Cleared to 0 once worker performs  * the operations.  */
end_comment

begin_define
define|#
directive|define
name|AUDIO_PARAMS
value|(1<< 0)
end_define

begin_define
define|#
directive|define
name|AUDIO_PLAY
value|(1<< 1)
end_define

begin_define
define|#
directive|define
name|AUDIO_STOP
value|(1<< 2)
end_define

begin_define
define|#
directive|define
name|VCHIQ_AUDIO_PACKET_SIZE
value|4000
end_define

begin_define
define|#
directive|define
name|VCHIQ_AUDIO_BUFFER_SIZE
value|10*VCHIQ_AUDIO_PACKET_SIZE
end_define

begin_define
define|#
directive|define
name|VCHIQ_AUDIO_MAX_VOLUME
end_define

begin_comment
comment|/* volume in terms of 0.01dB */
end_comment

begin_define
define|#
directive|define
name|VCHIQ_AUDIO_VOLUME_MIN
value|-10239
end_define

begin_define
define|#
directive|define
name|VCHIQ_AUDIO_VOLUME
parameter_list|(
name|db100
parameter_list|)
value|(uint32_t)(-((db100)<< 8)/100)
end_define

begin_comment
comment|/* dB levels with 5% volume step */
end_comment

begin_decl_stmt
specifier|static
name|int
name|db_levels
index|[]
init|=
block|{
name|VCHIQ_AUDIO_VOLUME_MIN
block|,
operator|-
literal|4605
block|,
operator|-
literal|3794
block|,
operator|-
literal|3218
block|,
operator|-
literal|2772
block|,
operator|-
literal|2407
block|,
operator|-
literal|2099
block|,
operator|-
literal|1832
block|,
operator|-
literal|1597
block|,
operator|-
literal|1386
block|,
operator|-
literal|1195
block|,
operator|-
literal|1021
block|,
operator|-
literal|861
block|,
operator|-
literal|713
block|,
operator|-
literal|575
block|,
operator|-
literal|446
block|,
operator|-
literal|325
block|,
operator|-
literal|210
block|,
operator|-
literal|102
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|bcm2835_audio_playfmt
index|[]
init|=
block|{
name|SND_FORMAT
argument_list|(
name|AFMT_U8
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
block|,
name|SND_FORMAT
argument_list|(
name|AFMT_U8
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
block|,
name|SND_FORMAT
argument_list|(
name|AFMT_S8
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
block|,
name|SND_FORMAT
argument_list|(
name|AFMT_S8
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
block|,
name|SND_FORMAT
argument_list|(
name|AFMT_S16_LE
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
block|,
name|SND_FORMAT
argument_list|(
name|AFMT_S16_LE
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
block|,
name|SND_FORMAT
argument_list|(
name|AFMT_U16_LE
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
block|,
name|SND_FORMAT
argument_list|(
name|AFMT_U16_LE
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pcmchan_caps
name|bcm2835_audio_playcaps
init|=
block|{
literal|8000
block|,
literal|48000
block|,
name|bcm2835_audio_playfmt
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_struct_decl
struct_decl|struct
name|bcm2835_audio_info
struct_decl|;
end_struct_decl

begin_struct
struct|struct
name|bcm2835_audio_chinfo
block|{
name|struct
name|bcm2835_audio_info
modifier|*
name|parent
decl_stmt|;
name|struct
name|pcm_channel
modifier|*
name|channel
decl_stmt|;
name|struct
name|snd_dbuf
modifier|*
name|buffer
decl_stmt|;
name|uint32_t
name|fmt
decl_stmt|,
name|spd
decl_stmt|,
name|blksz
decl_stmt|;
comment|/* Pointer to first unsubmitted sample */
name|uint32_t
name|unsubmittedptr
decl_stmt|;
comment|/* 	 * Number of bytes in "submitted but not played" 	 * pseudo-buffer 	 */
name|int
name|available_space
decl_stmt|;
name|int
name|playback_state
decl_stmt|;
name|uint64_t
name|callbacks
decl_stmt|;
name|uint64_t
name|submitted_samples
decl_stmt|;
name|uint64_t
name|retrieved_samples
decl_stmt|;
name|uint64_t
name|underruns
decl_stmt|;
name|int
name|starved
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|bcm2835_audio_info
block|{
name|device_t
name|dev
decl_stmt|;
name|unsigned
name|int
name|bufsz
decl_stmt|;
name|struct
name|bcm2835_audio_chinfo
name|pch
decl_stmt|;
name|uint32_t
name|dest
decl_stmt|,
name|volume
decl_stmt|;
name|struct
name|intr_config_hook
name|intr_hook
decl_stmt|;
comment|/* VCHI data */
name|VCHI_INSTANCE_T
name|vchi_instance
decl_stmt|;
name|VCHI_CONNECTION_T
modifier|*
name|vchi_connection
decl_stmt|;
name|VCHI_SERVICE_HANDLE_T
name|vchi_handle
decl_stmt|;
name|struct
name|mtx
name|lock
decl_stmt|;
name|struct
name|cv
name|worker_cv
decl_stmt|;
name|uint32_t
name|flags_pending
decl_stmt|;
comment|/* Worker thread state */
name|int
name|worker_state
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|BCM2835_AUDIO_LOCK
parameter_list|(
name|sc
parameter_list|)
value|mtx_lock(&(sc)->lock)
end_define

begin_define
define|#
directive|define
name|BCM2835_AUDIO_LOCKED
parameter_list|(
name|sc
parameter_list|)
value|mtx_assert(&(sc)->lock, MA_OWNED)
end_define

begin_define
define|#
directive|define
name|BCM2835_AUDIO_UNLOCK
parameter_list|(
name|sc
parameter_list|)
value|mtx_unlock(&(sc)->lock)
end_define

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|dest_description
parameter_list|(
name|uint32_t
name|dest
parameter_list|)
block|{
switch|switch
condition|(
name|dest
condition|)
block|{
case|case
name|DEST_AUTO
case|:
return|return
literal|"AUTO"
return|;
break|break;
case|case
name|DEST_HEADPHONES
case|:
return|return
literal|"HEADPHONES"
return|;
break|break;
case|case
name|DEST_HDMI
case|:
return|return
literal|"HDMI"
return|;
break|break;
default|default:
return|return
literal|"UNKNOWN"
return|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bcm2835_worker_update_params
parameter_list|(
name|struct
name|bcm2835_audio_info
modifier|*
name|sc
parameter_list|)
block|{
name|BCM2835_AUDIO_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|flags_pending
operator||=
name|AUDIO_PARAMS
expr_stmt|;
name|cv_signal
argument_list|(
operator|&
name|sc
operator|->
name|worker_cv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bcm2835_worker_play_start
parameter_list|(
name|struct
name|bcm2835_audio_info
modifier|*
name|sc
parameter_list|)
block|{
name|BCM2835_AUDIO_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|flags_pending
operator|&=
operator|~
operator|(
name|AUDIO_STOP
operator|)
expr_stmt|;
name|sc
operator|->
name|flags_pending
operator||=
name|AUDIO_PLAY
expr_stmt|;
name|cv_signal
argument_list|(
operator|&
name|sc
operator|->
name|worker_cv
argument_list|)
expr_stmt|;
name|BCM2835_AUDIO_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bcm2835_worker_play_stop
parameter_list|(
name|struct
name|bcm2835_audio_info
modifier|*
name|sc
parameter_list|)
block|{
name|BCM2835_AUDIO_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|flags_pending
operator|&=
operator|~
operator|(
name|AUDIO_PLAY
operator|)
expr_stmt|;
name|sc
operator|->
name|flags_pending
operator||=
name|AUDIO_STOP
expr_stmt|;
name|cv_signal
argument_list|(
operator|&
name|sc
operator|->
name|worker_cv
argument_list|)
expr_stmt|;
name|BCM2835_AUDIO_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bcm2835_audio_callback
parameter_list|(
name|void
modifier|*
name|param
parameter_list|,
specifier|const
name|VCHI_CALLBACK_REASON_T
name|reason
parameter_list|,
name|void
modifier|*
name|msg_handle
parameter_list|)
block|{
name|struct
name|bcm2835_audio_info
modifier|*
name|sc
init|=
operator|(
expr|struct
name|bcm2835_audio_info
operator|*
operator|)
name|param
decl_stmt|;
name|int32_t
name|status
decl_stmt|;
name|uint32_t
name|msg_len
decl_stmt|;
name|VC_AUDIO_MSG_T
name|m
decl_stmt|;
if|if
condition|(
name|reason
operator|!=
name|VCHI_CALLBACK_MSG_AVAILABLE
condition|)
return|return;
name|status
operator|=
name|vchi_msg_dequeue
argument_list|(
name|sc
operator|->
name|vchi_handle
argument_list|,
operator|&
name|m
argument_list|,
sizeof|sizeof
name|m
argument_list|,
operator|&
name|msg_len
argument_list|,
name|VCHI_FLAGS_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|.
name|type
operator|==
name|VC_AUDIO_MSG_TYPE_RESULT
condition|)
block|{
if|if
condition|(
name|m
operator|.
name|u
operator|.
name|result
operator|.
name|success
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"msg type %08x failed\n"
argument_list|,
name|m
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|m
operator|.
name|type
operator|==
name|VC_AUDIO_MSG_TYPE_COMPLETE
condition|)
block|{
name|struct
name|bcm2835_audio_chinfo
modifier|*
name|ch
init|=
name|m
operator|.
name|u
operator|.
name|complete
operator|.
name|cookie
decl_stmt|;
name|int
name|count
init|=
name|m
operator|.
name|u
operator|.
name|complete
operator|.
name|count
operator|&
literal|0xffff
decl_stmt|;
name|int
name|perr
init|=
operator|(
name|m
operator|.
name|u
operator|.
name|complete
operator|.
name|count
operator|&
operator|(
literal|1U
operator|<<
literal|30
operator|)
operator|)
operator|!=
literal|0
decl_stmt|;
name|ch
operator|->
name|callbacks
operator|++
expr_stmt|;
if|if
condition|(
name|perr
condition|)
name|ch
operator|->
name|underruns
operator|++
expr_stmt|;
name|BCM2835_AUDIO_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|playback_state
operator|!=
name|PLAYBACK_IDLE
condition|)
block|{
comment|/* Prevent LOR */
name|BCM2835_AUDIO_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|chn_intr
argument_list|(
name|sc
operator|->
name|pch
operator|.
name|channel
argument_list|)
expr_stmt|;
name|BCM2835_AUDIO_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* We should check again, state might have changed */
if|if
condition|(
name|ch
operator|->
name|playback_state
operator|!=
name|PLAYBACK_IDLE
condition|)
block|{
if|if
condition|(
operator|!
name|perr
condition|)
block|{
if|if
condition|(
operator|(
name|ch
operator|->
name|available_space
operator|+
name|count
operator|)
operator|>
name|VCHIQ_AUDIO_BUFFER_SIZE
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"inconsistent data in callback:\n"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"available_space == %d, count = %d, perr=%d\n"
argument_list|,
name|ch
operator|->
name|available_space
argument_list|,
name|count
argument_list|,
name|perr
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"retrieved_samples = %lld, submitted_samples = %lld\n"
argument_list|,
name|ch
operator|->
name|retrieved_samples
argument_list|,
name|ch
operator|->
name|submitted_samples
argument_list|)
expr_stmt|;
block|}
name|ch
operator|->
name|available_space
operator|+=
name|count
expr_stmt|;
name|ch
operator|->
name|retrieved_samples
operator|+=
name|count
expr_stmt|;
block|}
if|if
condition|(
name|perr
operator|||
operator|(
name|ch
operator|->
name|available_space
operator|>=
name|VCHIQ_AUDIO_PACKET_SIZE
operator|)
condition|)
name|cv_signal
argument_list|(
operator|&
name|sc
operator|->
name|worker_cv
argument_list|)
expr_stmt|;
block|}
name|BCM2835_AUDIO_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"%s: unknown m.type: %d\n"
argument_list|,
name|__func__
argument_list|,
name|m
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* VCHIQ stuff */
end_comment

begin_function
specifier|static
name|void
name|bcm2835_audio_init
parameter_list|(
name|struct
name|bcm2835_audio_info
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
comment|/* Initialize and create a VCHI connection */
name|status
operator|=
name|vchi_initialise
argument_list|(
operator|&
name|sc
operator|->
name|vchi_instance
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"vchi_initialise failed: %d\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return;
block|}
name|status
operator|=
name|vchi_connect
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|vchi_instance
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"vchi_connect failed: %d\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return;
block|}
name|SERVICE_CREATION_T
name|params
init|=
block|{
name|VCHI_VERSION_EX
argument_list|(
name|VC_AUDIOSERV_VER
argument_list|,
name|VC_AUDIOSERV_MIN_VER
argument_list|)
block|,
name|VC_AUDIO_SERVER_NAME
block|,
comment|/* 4cc service code */
name|sc
operator|->
name|vchi_connection
block|,
comment|/* passed in fn pointers */
literal|0
block|,
comment|/* rx fifo size */
literal|0
block|,
comment|/* tx fifo size */
name|bcm2835_audio_callback
block|,
comment|/* service callback */
name|sc
block|,
comment|/* service callback parameter */
literal|1
block|,
literal|1
block|,
literal|0
comment|/* want crc check on bulk transfers */
block|}
decl_stmt|;
name|status
operator|=
name|vchi_service_open
argument_list|(
name|sc
operator|->
name|vchi_instance
argument_list|,
operator|&
name|params
argument_list|,
operator|&
name|sc
operator|->
name|vchi_handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
name|sc
operator|->
name|vchi_handle
operator|=
name|VCHIQ_SERVICE_HANDLE_INVALID
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bcm2835_audio_release
parameter_list|(
name|struct
name|bcm2835_audio_info
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|success
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|vchi_handle
operator|!=
name|VCHIQ_SERVICE_HANDLE_INVALID
condition|)
block|{
name|success
operator|=
name|vchi_service_close
argument_list|(
name|sc
operator|->
name|vchi_handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"vchi_service_close failed: %d\n"
argument_list|,
name|success
argument_list|)
expr_stmt|;
name|vchi_service_release
argument_list|(
name|sc
operator|->
name|vchi_handle
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vchi_handle
operator|=
name|VCHIQ_SERVICE_HANDLE_INVALID
expr_stmt|;
block|}
name|vchi_disconnect
argument_list|(
name|sc
operator|->
name|vchi_instance
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bcm2835_audio_reset_channel
parameter_list|(
name|struct
name|bcm2835_audio_chinfo
modifier|*
name|ch
parameter_list|)
block|{
name|ch
operator|->
name|available_space
operator|=
name|VCHIQ_AUDIO_BUFFER_SIZE
expr_stmt|;
name|ch
operator|->
name|unsubmittedptr
operator|=
literal|0
expr_stmt|;
name|sndbuf_reset
argument_list|(
name|ch
operator|->
name|buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bcm2835_audio_start
parameter_list|(
name|struct
name|bcm2835_audio_chinfo
modifier|*
name|ch
parameter_list|)
block|{
name|VC_AUDIO_MSG_T
name|m
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|struct
name|bcm2835_audio_info
modifier|*
name|sc
init|=
name|ch
operator|->
name|parent
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|vchi_handle
operator|!=
name|VCHIQ_SERVICE_HANDLE_INVALID
condition|)
block|{
name|m
operator|.
name|type
operator|=
name|VC_AUDIO_MSG_TYPE_START
expr_stmt|;
name|ret
operator|=
name|vchi_msg_queue
argument_list|(
name|sc
operator|->
name|vchi_handle
argument_list|,
operator|&
name|m
argument_list|,
sizeof|sizeof
name|m
argument_list|,
name|VCHI_FLAGS_BLOCK_UNTIL_QUEUED
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"%s: vchi_msg_queue failed (err %d)\n"
argument_list|,
name|__func__
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bcm2835_audio_stop
parameter_list|(
name|struct
name|bcm2835_audio_chinfo
modifier|*
name|ch
parameter_list|)
block|{
name|VC_AUDIO_MSG_T
name|m
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|struct
name|bcm2835_audio_info
modifier|*
name|sc
init|=
name|ch
operator|->
name|parent
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|vchi_handle
operator|!=
name|VCHIQ_SERVICE_HANDLE_INVALID
condition|)
block|{
name|m
operator|.
name|type
operator|=
name|VC_AUDIO_MSG_TYPE_STOP
expr_stmt|;
name|m
operator|.
name|u
operator|.
name|stop
operator|.
name|draining
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|vchi_msg_queue
argument_list|(
name|sc
operator|->
name|vchi_handle
argument_list|,
operator|&
name|m
argument_list|,
sizeof|sizeof
name|m
argument_list|,
name|VCHI_FLAGS_BLOCK_UNTIL_QUEUED
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"%s: vchi_msg_queue failed (err %d)\n"
argument_list|,
name|__func__
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bcm2835_audio_open
parameter_list|(
name|struct
name|bcm2835_audio_info
modifier|*
name|sc
parameter_list|)
block|{
name|VC_AUDIO_MSG_T
name|m
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|vchi_handle
operator|!=
name|VCHIQ_SERVICE_HANDLE_INVALID
condition|)
block|{
name|m
operator|.
name|type
operator|=
name|VC_AUDIO_MSG_TYPE_OPEN
expr_stmt|;
name|ret
operator|=
name|vchi_msg_queue
argument_list|(
name|sc
operator|->
name|vchi_handle
argument_list|,
operator|&
name|m
argument_list|,
sizeof|sizeof
name|m
argument_list|,
name|VCHI_FLAGS_BLOCK_UNTIL_QUEUED
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"%s: vchi_msg_queue failed (err %d)\n"
argument_list|,
name|__func__
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bcm2835_audio_update_controls
parameter_list|(
name|struct
name|bcm2835_audio_info
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|volume
parameter_list|,
name|uint32_t
name|dest
parameter_list|)
block|{
name|VC_AUDIO_MSG_T
name|m
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|db
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|vchi_handle
operator|!=
name|VCHIQ_SERVICE_HANDLE_INVALID
condition|)
block|{
name|m
operator|.
name|type
operator|=
name|VC_AUDIO_MSG_TYPE_CONTROL
expr_stmt|;
name|m
operator|.
name|u
operator|.
name|control
operator|.
name|dest
operator|=
name|dest
expr_stmt|;
if|if
condition|(
name|volume
operator|>
literal|99
condition|)
name|volume
operator|=
literal|99
expr_stmt|;
name|db
operator|=
name|db_levels
index|[
name|volume
operator|/
literal|5
index|]
expr_stmt|;
name|m
operator|.
name|u
operator|.
name|control
operator|.
name|volume
operator|=
name|VCHIQ_AUDIO_VOLUME
argument_list|(
name|db
argument_list|)
expr_stmt|;
name|ret
operator|=
name|vchi_msg_queue
argument_list|(
name|sc
operator|->
name|vchi_handle
argument_list|,
operator|&
name|m
argument_list|,
sizeof|sizeof
name|m
argument_list|,
name|VCHI_FLAGS_BLOCK_UNTIL_QUEUED
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"%s: vchi_msg_queue failed (err %d)\n"
argument_list|,
name|__func__
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bcm2835_audio_update_params
parameter_list|(
name|struct
name|bcm2835_audio_info
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|fmt
parameter_list|,
name|uint32_t
name|speed
parameter_list|)
block|{
name|VC_AUDIO_MSG_T
name|m
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|vchi_handle
operator|!=
name|VCHIQ_SERVICE_HANDLE_INVALID
condition|)
block|{
name|m
operator|.
name|type
operator|=
name|VC_AUDIO_MSG_TYPE_CONFIG
expr_stmt|;
name|m
operator|.
name|u
operator|.
name|config
operator|.
name|channels
operator|=
name|AFMT_CHANNEL
argument_list|(
name|fmt
argument_list|)
expr_stmt|;
name|m
operator|.
name|u
operator|.
name|config
operator|.
name|samplerate
operator|=
name|speed
expr_stmt|;
name|m
operator|.
name|u
operator|.
name|config
operator|.
name|bps
operator|=
name|AFMT_BIT
argument_list|(
name|fmt
argument_list|)
expr_stmt|;
name|ret
operator|=
name|vchi_msg_queue
argument_list|(
name|sc
operator|->
name|vchi_handle
argument_list|,
operator|&
name|m
argument_list|,
sizeof|sizeof
name|m
argument_list|,
name|VCHI_FLAGS_BLOCK_UNTIL_QUEUED
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"%s: vchi_msg_queue failed (err %d)\n"
argument_list|,
name|__func__
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|bool
name|bcm2835_audio_buffer_should_sleep
parameter_list|(
name|struct
name|bcm2835_audio_chinfo
modifier|*
name|ch
parameter_list|)
block|{
if|if
condition|(
name|ch
operator|->
name|playback_state
operator|!=
name|PLAYBACK_PLAYING
condition|)
return|return
operator|(
name|true
operator|)
return|;
comment|/* Not enough data */
if|if
condition|(
name|sndbuf_getready
argument_list|(
name|ch
operator|->
name|buffer
argument_list|)
operator|<
name|VCHIQ_AUDIO_PACKET_SIZE
condition|)
block|{
name|printf
argument_list|(
literal|"starve\n"
argument_list|)
expr_stmt|;
name|ch
operator|->
name|starved
operator|++
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
comment|/* Not enough free space */
if|if
condition|(
name|ch
operator|->
name|available_space
operator|<
name|VCHIQ_AUDIO_PACKET_SIZE
condition|)
block|{
return|return
operator|(
name|true
operator|)
return|;
block|}
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bcm2835_audio_write_samples
parameter_list|(
name|struct
name|bcm2835_audio_chinfo
modifier|*
name|ch
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|uint32_t
name|count
parameter_list|)
block|{
name|struct
name|bcm2835_audio_info
modifier|*
name|sc
init|=
name|ch
operator|->
name|parent
decl_stmt|;
name|VC_AUDIO_MSG_T
name|m
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|vchi_handle
operator|==
name|VCHIQ_SERVICE_HANDLE_INVALID
condition|)
block|{
return|return;
block|}
name|m
operator|.
name|type
operator|=
name|VC_AUDIO_MSG_TYPE_WRITE
expr_stmt|;
name|m
operator|.
name|u
operator|.
name|write
operator|.
name|count
operator|=
name|count
expr_stmt|;
name|m
operator|.
name|u
operator|.
name|write
operator|.
name|max_packet
operator|=
name|VCHIQ_AUDIO_PACKET_SIZE
expr_stmt|;
name|m
operator|.
name|u
operator|.
name|write
operator|.
name|callback
operator|=
name|NULL
expr_stmt|;
name|m
operator|.
name|u
operator|.
name|write
operator|.
name|cookie
operator|=
name|ch
expr_stmt|;
name|m
operator|.
name|u
operator|.
name|write
operator|.
name|silence
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|vchi_msg_queue
argument_list|(
name|sc
operator|->
name|vchi_handle
argument_list|,
operator|&
name|m
argument_list|,
sizeof|sizeof
name|m
argument_list|,
name|VCHI_FLAGS_BLOCK_UNTIL_QUEUED
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"%s: vchi_msg_queue failed (err %d)\n"
argument_list|,
name|__func__
argument_list|,
name|ret
argument_list|)
expr_stmt|;
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|int
name|bytes
init|=
name|MIN
argument_list|(
operator|(
name|int
operator|)
name|m
operator|.
name|u
operator|.
name|write
operator|.
name|max_packet
argument_list|,
operator|(
name|int
operator|)
name|count
argument_list|)
decl_stmt|;
name|ret
operator|=
name|vchi_msg_queue
argument_list|(
name|sc
operator|->
name|vchi_handle
argument_list|,
name|buf
argument_list|,
name|bytes
argument_list|,
name|VCHI_FLAGS_BLOCK_UNTIL_QUEUED
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"%s: vchi_msg_queue failed: %d\n"
argument_list|,
name|__func__
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|buf
operator|+
name|bytes
expr_stmt|;
name|count
operator|-=
name|bytes
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bcm2835_audio_worker
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|bcm2835_audio_info
modifier|*
name|sc
init|=
operator|(
expr|struct
name|bcm2835_audio_info
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|bcm2835_audio_chinfo
modifier|*
name|ch
init|=
operator|&
name|sc
operator|->
name|pch
decl_stmt|;
name|uint32_t
name|speed
decl_stmt|,
name|format
decl_stmt|;
name|uint32_t
name|volume
decl_stmt|,
name|dest
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
name|uint32_t
name|count
decl_stmt|,
name|size
decl_stmt|,
name|readyptr
decl_stmt|;
name|uint8_t
modifier|*
name|buf
decl_stmt|;
name|ch
operator|->
name|playback_state
operator|=
name|PLAYBACK_IDLE
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|worker_state
operator|!=
name|WORKER_RUNNING
condition|)
break|break;
name|BCM2835_AUDIO_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 		 * wait until there are flags set or buffer is ready 		 * to consume more samples 		 */
while|while
condition|(
operator|(
name|sc
operator|->
name|flags_pending
operator|==
literal|0
operator|)
operator|&&
name|bcm2835_audio_buffer_should_sleep
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|cv_wait_sig
argument_list|(
operator|&
name|sc
operator|->
name|worker_cv
argument_list|,
operator|&
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
name|flags
operator|=
name|sc
operator|->
name|flags_pending
expr_stmt|;
comment|/* Clear pending flags */
name|sc
operator|->
name|flags_pending
operator|=
literal|0
expr_stmt|;
name|BCM2835_AUDIO_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Requested to change parameters */
if|if
condition|(
name|flags
operator|&
name|AUDIO_PARAMS
condition|)
block|{
name|BCM2835_AUDIO_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|speed
operator|=
name|ch
operator|->
name|spd
expr_stmt|;
name|format
operator|=
name|ch
operator|->
name|fmt
expr_stmt|;
name|volume
operator|=
name|sc
operator|->
name|volume
expr_stmt|;
name|dest
operator|=
name|sc
operator|->
name|dest
expr_stmt|;
name|BCM2835_AUDIO_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|playback_state
operator|==
name|PLAYBACK_IDLE
condition|)
name|bcm2835_audio_update_params
argument_list|(
name|sc
argument_list|,
name|format
argument_list|,
name|speed
argument_list|)
expr_stmt|;
name|bcm2835_audio_update_controls
argument_list|(
name|sc
argument_list|,
name|volume
argument_list|,
name|dest
argument_list|)
expr_stmt|;
block|}
comment|/* Requested to stop playback */
if|if
condition|(
operator|(
name|flags
operator|&
name|AUDIO_STOP
operator|)
operator|&&
operator|(
name|ch
operator|->
name|playback_state
operator|==
name|PLAYBACK_PLAYING
operator|)
condition|)
block|{
name|bcm2835_audio_stop
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|BCM2835_AUDIO_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bcm2835_audio_reset_channel
argument_list|(
operator|&
name|sc
operator|->
name|pch
argument_list|)
expr_stmt|;
name|ch
operator|->
name|playback_state
operator|=
name|PLAYBACK_IDLE
expr_stmt|;
name|BCM2835_AUDIO_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Requested to start playback */
if|if
condition|(
operator|(
name|flags
operator|&
name|AUDIO_PLAY
operator|)
operator|&&
operator|(
name|ch
operator|->
name|playback_state
operator|==
name|PLAYBACK_IDLE
operator|)
condition|)
block|{
name|BCM2835_AUDIO_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ch
operator|->
name|playback_state
operator|=
name|PLAYBACK_PLAYING
expr_stmt|;
name|BCM2835_AUDIO_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bcm2835_audio_start
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|->
name|playback_state
operator|==
name|PLAYBACK_IDLE
condition|)
continue|continue;
if|if
condition|(
name|sndbuf_getready
argument_list|(
name|ch
operator|->
name|buffer
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|count
operator|=
name|sndbuf_getready
argument_list|(
name|ch
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|size
operator|=
name|sndbuf_getsize
argument_list|(
name|ch
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|readyptr
operator|=
name|sndbuf_getreadyptr
argument_list|(
name|ch
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|BCM2835_AUDIO_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|readyptr
operator|+
name|count
operator|>
name|size
condition|)
name|count
operator|=
name|size
operator|-
name|readyptr
expr_stmt|;
name|count
operator|=
name|min
argument_list|(
name|count
argument_list|,
name|ch
operator|->
name|available_space
argument_list|)
expr_stmt|;
name|count
operator|-=
operator|(
name|count
operator|%
name|VCHIQ_AUDIO_PACKET_SIZE
operator|)
expr_stmt|;
name|BCM2835_AUDIO_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<
name|VCHIQ_AUDIO_PACKET_SIZE
condition|)
continue|continue;
name|buf
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|sndbuf_getbuf
argument_list|(
name|ch
operator|->
name|buffer
argument_list|)
operator|+
name|readyptr
expr_stmt|;
name|bcm2835_audio_write_samples
argument_list|(
name|ch
argument_list|,
name|buf
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|BCM2835_AUDIO_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ch
operator|->
name|unsubmittedptr
operator|=
operator|(
name|ch
operator|->
name|unsubmittedptr
operator|+
name|count
operator|)
operator|%
name|sndbuf_getsize
argument_list|(
name|ch
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|ch
operator|->
name|available_space
operator|-=
name|count
expr_stmt|;
name|ch
operator|->
name|submitted_samples
operator|+=
name|count
expr_stmt|;
name|KASSERT
argument_list|(
name|ch
operator|->
name|available_space
operator|>=
literal|0
argument_list|,
operator|(
literal|"ch->available_space == %d\n"
operator|,
name|ch
operator|->
name|available_space
operator|)
argument_list|)
expr_stmt|;
name|BCM2835_AUDIO_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|BCM2835_AUDIO_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|worker_state
operator|=
name|WORKER_STOPPED
expr_stmt|;
name|cv_signal
argument_list|(
operator|&
name|sc
operator|->
name|worker_cv
argument_list|)
expr_stmt|;
name|BCM2835_AUDIO_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|kproc_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bcm2835_audio_create_worker
parameter_list|(
name|struct
name|bcm2835_audio_info
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|newp
decl_stmt|;
name|sc
operator|->
name|worker_state
operator|=
name|WORKER_RUNNING
expr_stmt|;
if|if
condition|(
name|kproc_create
argument_list|(
name|bcm2835_audio_worker
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sc
argument_list|,
operator|&
name|newp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"bcm2835_audio_worker"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"failed to create bcm2835_audio_worker\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* -------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* channel interface for VCHI audio */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|bcmchan_init
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|devinfo
parameter_list|,
name|struct
name|snd_dbuf
modifier|*
name|b
parameter_list|,
name|struct
name|pcm_channel
modifier|*
name|c
parameter_list|,
name|int
name|dir
parameter_list|)
block|{
name|struct
name|bcm2835_audio_info
modifier|*
name|sc
init|=
name|devinfo
decl_stmt|;
name|struct
name|bcm2835_audio_chinfo
modifier|*
name|ch
init|=
operator|&
name|sc
operator|->
name|pch
decl_stmt|;
name|void
modifier|*
name|buffer
decl_stmt|;
if|if
condition|(
name|dir
operator|==
name|PCMDIR_REC
condition|)
return|return
name|NULL
return|;
name|ch
operator|->
name|parent
operator|=
name|sc
expr_stmt|;
name|ch
operator|->
name|channel
operator|=
name|c
expr_stmt|;
name|ch
operator|->
name|buffer
operator|=
name|b
expr_stmt|;
comment|/* default values */
name|ch
operator|->
name|spd
operator|=
literal|44100
expr_stmt|;
name|ch
operator|->
name|fmt
operator|=
name|SND_FORMAT
argument_list|(
name|AFMT_S16_LE
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ch
operator|->
name|blksz
operator|=
name|VCHIQ_AUDIO_PACKET_SIZE
expr_stmt|;
name|buffer
operator|=
name|malloc
argument_list|(
name|sc
operator|->
name|bufsz
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|sndbuf_setup
argument_list|(
name|ch
operator|->
name|buffer
argument_list|,
name|buffer
argument_list|,
name|sc
operator|->
name|bufsz
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"sndbuf_setup failed\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buffer
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|BCM2835_AUDIO_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bcm2835_worker_update_params
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|BCM2835_AUDIO_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
name|ch
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bcmchan_free
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|bcm2835_audio_chinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|void
modifier|*
name|buffer
decl_stmt|;
name|buffer
operator|=
name|sndbuf_getbuf
argument_list|(
name|ch
operator|->
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
condition|)
name|free
argument_list|(
name|buffer
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bcmchan_setformat
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|uint32_t
name|format
parameter_list|)
block|{
name|struct
name|bcm2835_audio_chinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|struct
name|bcm2835_audio_info
modifier|*
name|sc
init|=
name|ch
operator|->
name|parent
decl_stmt|;
name|BCM2835_AUDIO_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ch
operator|->
name|fmt
operator|=
name|format
expr_stmt|;
name|bcm2835_worker_update_params
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|BCM2835_AUDIO_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|bcmchan_setspeed
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|uint32_t
name|speed
parameter_list|)
block|{
name|struct
name|bcm2835_audio_chinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|struct
name|bcm2835_audio_info
modifier|*
name|sc
init|=
name|ch
operator|->
name|parent
decl_stmt|;
name|BCM2835_AUDIO_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ch
operator|->
name|spd
operator|=
name|speed
expr_stmt|;
name|bcm2835_worker_update_params
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|BCM2835_AUDIO_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
name|ch
operator|->
name|spd
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|bcmchan_setblocksize
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|uint32_t
name|blocksize
parameter_list|)
block|{
name|struct
name|bcm2835_audio_chinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
return|return
name|ch
operator|->
name|blksz
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bcmchan_trigger
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|go
parameter_list|)
block|{
name|struct
name|bcm2835_audio_chinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|struct
name|bcm2835_audio_info
modifier|*
name|sc
init|=
name|ch
operator|->
name|parent
decl_stmt|;
if|if
condition|(
operator|!
name|PCMTRIG_COMMON
argument_list|(
name|go
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
switch|switch
condition|(
name|go
condition|)
block|{
case|case
name|PCMTRIG_START
case|:
comment|/* kickstart data flow */
name|chn_intr
argument_list|(
name|sc
operator|->
name|pch
operator|.
name|channel
argument_list|)
expr_stmt|;
name|ch
operator|->
name|submitted_samples
operator|=
literal|0
expr_stmt|;
name|ch
operator|->
name|retrieved_samples
operator|=
literal|0
expr_stmt|;
name|bcm2835_worker_play_start
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|PCMTRIG_STOP
case|:
case|case
name|PCMTRIG_ABORT
case|:
name|bcm2835_worker_play_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|bcmchan_getptr
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|bcm2835_audio_chinfo
modifier|*
name|ch
init|=
name|data
decl_stmt|;
name|struct
name|bcm2835_audio_info
modifier|*
name|sc
init|=
name|ch
operator|->
name|parent
decl_stmt|;
name|uint32_t
name|ret
decl_stmt|;
name|BCM2835_AUDIO_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ch
operator|->
name|unsubmittedptr
expr_stmt|;
name|BCM2835_AUDIO_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|pcmchan_caps
modifier|*
name|bcmchan_getcaps
parameter_list|(
name|kobj_t
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
return|return
operator|&
name|bcm2835_audio_playcaps
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|kobj_method_t
name|bcmchan_methods
index|[]
init|=
block|{
name|KOBJMETHOD
argument_list|(
name|channel_init
argument_list|,
name|bcmchan_init
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_free
argument_list|,
name|bcmchan_free
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_setformat
argument_list|,
name|bcmchan_setformat
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_setspeed
argument_list|,
name|bcmchan_setspeed
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_setblocksize
argument_list|,
name|bcmchan_setblocksize
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_trigger
argument_list|,
name|bcmchan_trigger
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_getptr
argument_list|,
name|bcmchan_getptr
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|channel_getcaps
argument_list|,
name|bcmchan_getcaps
argument_list|)
block|,
name|KOBJMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|CHANNEL_DECLARE
argument_list|(
name|bcmchan
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/************************************************************/
end_comment

begin_function
specifier|static
name|int
name|bcmmix_init
parameter_list|(
name|struct
name|snd_mixer
modifier|*
name|m
parameter_list|)
block|{
name|mix_setdevs
argument_list|(
name|m
argument_list|,
name|SOUND_MASK_VOLUME
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bcmmix_set
parameter_list|(
name|struct
name|snd_mixer
modifier|*
name|m
parameter_list|,
name|unsigned
name|dev
parameter_list|,
name|unsigned
name|left
parameter_list|,
name|unsigned
name|right
parameter_list|)
block|{
name|struct
name|bcm2835_audio_info
modifier|*
name|sc
init|=
name|mix_getdevinfo
argument_list|(
name|m
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|dev
condition|)
block|{
case|case
name|SOUND_MIXER_VOLUME
case|:
name|BCM2835_AUDIO_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|volume
operator|=
name|left
expr_stmt|;
name|bcm2835_worker_update_params
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|BCM2835_AUDIO_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|left
operator||
operator|(
name|left
operator|<<
literal|8
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|kobj_method_t
name|bcmmixer_methods
index|[]
init|=
block|{
name|KOBJMETHOD
argument_list|(
name|mixer_init
argument_list|,
name|bcmmix_init
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|mixer_set
argument_list|,
name|bcmmix_set
argument_list|)
block|,
name|KOBJMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MIXER_DECLARE
argument_list|(
name|bcmmixer
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|sysctl_bcm2835_audio_dest
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|bcm2835_audio_info
modifier|*
name|sc
init|=
name|arg1
decl_stmt|;
name|int
name|val
decl_stmt|;
name|int
name|err
decl_stmt|;
name|val
operator|=
name|sc
operator|->
name|dest
expr_stmt|;
name|err
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|val
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
comment|/* error || read request */
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
operator|(
name|val
operator|<
literal|0
operator|)
operator|||
operator|(
name|val
operator|>
literal|2
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|BCM2835_AUDIO_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dest
operator|=
name|val
expr_stmt|;
name|bcm2835_worker_update_params
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|BCM2835_AUDIO_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"destination set to %s\n"
argument_list|,
name|dest_description
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vchi_audio_sysctl_init
parameter_list|(
name|struct
name|bcm2835_audio_info
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|tree_node
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|tree
decl_stmt|;
comment|/* 	 * Add system sysctl tree/handlers. 	 */
name|ctx
operator|=
name|device_get_sysctl_ctx
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
name|tree_node
operator|=
name|device_get_sysctl_tree
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
name|tree
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|tree_node
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|tree
argument_list|,
name|OID_AUTO
argument_list|,
literal|"dest"
argument_list|,
name|CTLFLAG_RW
operator||
name|CTLTYPE_UINT
argument_list|,
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
argument_list|,
name|sysctl_bcm2835_audio_dest
argument_list|,
literal|"IU"
argument_list|,
literal|"audio destination, "
literal|"0 - auto, 1 - headphones, 2 - HDMI"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|tree
argument_list|,
name|OID_AUTO
argument_list|,
literal|"callbacks"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|pch
operator|.
name|callbacks
argument_list|,
literal|"callbacks total"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|tree
argument_list|,
name|OID_AUTO
argument_list|,
literal|"submitted"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|pch
operator|.
name|submitted_samples
argument_list|,
literal|"last play submitted samples"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|tree
argument_list|,
name|OID_AUTO
argument_list|,
literal|"retrieved"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|pch
operator|.
name|retrieved_samples
argument_list|,
literal|"last play retrieved samples"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UQUAD
argument_list|(
name|ctx
argument_list|,
name|tree
argument_list|,
name|OID_AUTO
argument_list|,
literal|"underruns"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|pch
operator|.
name|underruns
argument_list|,
literal|"callback underruns"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|tree
argument_list|,
name|OID_AUTO
argument_list|,
literal|"freebuffer"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|pch
operator|.
name|available_space
argument_list|,
name|sc
operator|->
name|pch
operator|.
name|available_space
argument_list|,
literal|"callbacks total"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|tree
argument_list|,
name|OID_AUTO
argument_list|,
literal|"starved"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|pch
operator|.
name|starved
argument_list|,
name|sc
operator|->
name|pch
operator|.
name|starved
argument_list|,
literal|"number of starved conditions"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bcm2835_audio_identify
parameter_list|(
name|driver_t
modifier|*
name|driver
parameter_list|,
name|device_t
name|parent
parameter_list|)
block|{
name|BUS_ADD_CHILD
argument_list|(
name|parent
argument_list|,
literal|0
argument_list|,
literal|"pcm"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|bcm2835_audio_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"VCHIQ audio"
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bcm2835_audio_delayed_init
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|bcm2835_audio_info
modifier|*
name|sc
decl_stmt|;
name|char
name|status
index|[
name|SND_STATUSLEN
index|]
decl_stmt|;
name|sc
operator|=
name|xsc
expr_stmt|;
name|config_intrhook_disestablish
argument_list|(
operator|&
name|sc
operator|->
name|intr_hook
argument_list|)
expr_stmt|;
name|bcm2835_audio_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bcm2835_audio_open
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|volume
operator|=
literal|75
expr_stmt|;
name|sc
operator|->
name|dest
operator|=
name|DEST_AUTO
expr_stmt|;
if|if
condition|(
name|mixer_init
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
operator|&
name|bcmmixer_class
argument_list|,
name|sc
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"mixer_init failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|no
goto|;
block|}
if|if
condition|(
name|pcm_register
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|sc
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"pcm_register failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|no
goto|;
block|}
name|pcm_addchan
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|PCMDIR_PLAY
argument_list|,
operator|&
name|bcmchan_class
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|status
argument_list|,
name|SND_STATUSLEN
argument_list|,
literal|"at VCHIQ"
argument_list|)
expr_stmt|;
name|pcm_setstatus
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|bcm2835_audio_reset_channel
argument_list|(
operator|&
name|sc
operator|->
name|pch
argument_list|)
expr_stmt|;
name|bcm2835_audio_create_worker
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|vchi_audio_sysctl_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|no
label|:
empty_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|bcm2835_audio_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|bcm2835_audio_info
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|sc
operator|->
name|bufsz
operator|=
name|VCHIQ_AUDIO_BUFFER_SIZE
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|lock
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"bcm_audio_lock"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|sc
operator|->
name|worker_cv
argument_list|,
literal|"worker_cv"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vchi_handle
operator|=
name|VCHIQ_SERVICE_HANDLE_INVALID
expr_stmt|;
comment|/* 	 * We need interrupts enabled for VCHI to work properly, 	 * so delay initialization until it happens. 	 */
name|sc
operator|->
name|intr_hook
operator|.
name|ich_func
operator|=
name|bcm2835_audio_delayed_init
expr_stmt|;
name|sc
operator|->
name|intr_hook
operator|.
name|ich_arg
operator|=
name|sc
expr_stmt|;
if|if
condition|(
name|config_intrhook_establish
argument_list|(
operator|&
name|sc
operator|->
name|intr_hook
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|no
goto|;
return|return
literal|0
return|;
name|no
label|:
return|return
name|ENXIO
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bcm2835_audio_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|struct
name|bcm2835_audio_info
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|pcm_getdevinfo
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Stop worker thread */
name|BCM2835_AUDIO_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|worker_state
operator|=
name|WORKER_STOPPING
expr_stmt|;
name|cv_signal
argument_list|(
operator|&
name|sc
operator|->
name|worker_cv
argument_list|)
expr_stmt|;
comment|/* Wait for thread to exit */
while|while
condition|(
name|sc
operator|->
name|worker_state
operator|!=
name|WORKER_STOPPED
condition|)
name|cv_wait_sig
argument_list|(
operator|&
name|sc
operator|->
name|worker_cv
argument_list|,
operator|&
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|BCM2835_AUDIO_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|r
operator|=
name|pcm_unregister
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
return|return
name|r
return|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|lock
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|sc
operator|->
name|worker_cv
argument_list|)
expr_stmt|;
name|bcm2835_audio_release
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|bcm2835_audio_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_identify
argument_list|,
name|bcm2835_audio_identify
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|bcm2835_audio_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|bcm2835_audio_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|bcm2835_audio_detach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|bcm2835_audio_driver
init|=
block|{
literal|"pcm"
block|,
name|bcm2835_audio_methods
block|,
name|PCM_SOFTC_SIZE
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|bcm2835_audio
argument_list|,
name|vchiq
argument_list|,
name|bcm2835_audio_driver
argument_list|,
name|pcm_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|bcm2835_audio
argument_list|,
name|sound
argument_list|,
name|SOUND_MINVER
argument_list|,
name|SOUND_PREFVER
argument_list|,
name|SOUND_MAXVER
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|bcm2835_audio
argument_list|,
name|vchiq
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|bcm2835_audio
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

