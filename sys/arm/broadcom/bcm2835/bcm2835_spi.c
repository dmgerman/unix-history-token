begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2012 Oleksandr Tymoshenko<gonzo@freebsd.org>  * Copyright (c) 2013 Luiz Otavio O Souza<loos@freebsd.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpufunc.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<machine/fdt.h>
end_include

begin_include
include|#
directive|include
file|<machine/frame.h>
end_include

begin_include
include|#
directive|include
file|<machine/intr.h>
end_include

begin_include
include|#
directive|include
file|<dev/fdt/fdt_common.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/ofw_bus.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/ofw_bus_subr.h>
end_include

begin_include
include|#
directive|include
file|<dev/spibus/spi.h>
end_include

begin_include
include|#
directive|include
file|<dev/spibus/spibusvar.h>
end_include

begin_include
include|#
directive|include
file|<arm/broadcom/bcm2835/bcm2835_gpio.h>
end_include

begin_include
include|#
directive|include
file|<arm/broadcom/bcm2835/bcm2835_spireg.h>
end_include

begin_include
include|#
directive|include
file|<arm/broadcom/bcm2835/bcm2835_spivar.h>
end_include

begin_include
include|#
directive|include
file|"spibus_if.h"
end_include

begin_function_decl
specifier|static
name|void
name|bcm_spi_intr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|BCM_SPI_DEBUG
end_ifdef

begin_function
specifier|static
name|void
name|bcm_spi_printr
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|bcm_spi_softc
modifier|*
name|sc
decl_stmt|;
name|uint32_t
name|reg
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|reg
operator|=
name|BCM_SPI_READ
argument_list|(
name|sc
argument_list|,
name|SPI_CS
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"CS=%b\n"
argument_list|,
name|reg
argument_list|,
literal|"\20\1CS0\2CS1\3CPHA\4CPOL\7CSPOL"
literal|"\10TA\11DMAEN\12INTD\13INTR\14ADCS\15REN\16LEN"
literal|"\21DONE\22RXD\23TXD\24RXR\25RXF\26CSPOL0\27CSPOL1"
literal|"\30CSPOL2\31DMA_LEN\32LEN_LONG"
argument_list|)
expr_stmt|;
name|reg
operator|=
name|BCM_SPI_READ
argument_list|(
name|sc
argument_list|,
name|SPI_CLK
argument_list|)
operator|&
name|SPI_CLK_MASK
expr_stmt|;
if|if
condition|(
name|reg
operator|%
literal|2
condition|)
name|reg
operator|--
expr_stmt|;
if|if
condition|(
name|reg
operator|==
literal|0
condition|)
name|reg
operator|=
literal|65536
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"CLK=%uMhz/%d=%luhz\n"
argument_list|,
name|SPI_CORE_CLK
operator|/
literal|1000000
argument_list|,
name|reg
argument_list|,
name|SPI_CORE_CLK
operator|/
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|BCM_SPI_READ
argument_list|(
name|sc
argument_list|,
name|SPI_DLEN
argument_list|)
operator|&
name|SPI_DLEN_MASK
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"DLEN=%d\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|BCM_SPI_READ
argument_list|(
name|sc
argument_list|,
name|SPI_LTOH
argument_list|)
operator|&
name|SPI_LTOH_MASK
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"LTOH=%d\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|BCM_SPI_READ
argument_list|(
name|sc
argument_list|,
name|SPI_DC
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"DC=RPANIC=%#x RDREQ=%#x TPANIC=%#x TDREQ=%#x\n"
argument_list|,
operator|(
name|reg
operator|&
name|SPI_DC_RPANIC_MASK
operator|)
operator|>>
name|SPI_DC_RPANIC_SHIFT
argument_list|,
operator|(
name|reg
operator|&
name|SPI_DC_RDREQ_MASK
operator|)
operator|>>
name|SPI_DC_RDREQ_SHIFT
argument_list|,
operator|(
name|reg
operator|&
name|SPI_DC_TPANIC_MASK
operator|)
operator|>>
name|SPI_DC_TPANIC_SHIFT
argument_list|,
operator|(
name|reg
operator|&
name|SPI_DC_TDREQ_MASK
operator|)
operator|>>
name|SPI_DC_TDREQ_SHIFT
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|bcm_spi_modifyreg
parameter_list|(
name|struct
name|bcm_spi_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|off
parameter_list|,
name|uint32_t
name|mask
parameter_list|,
name|uint32_t
name|value
parameter_list|)
block|{
name|uint32_t
name|reg
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|reg
operator|=
name|BCM_SPI_READ
argument_list|(
name|sc
argument_list|,
name|off
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|mask
expr_stmt|;
name|reg
operator||=
name|value
expr_stmt|;
name|BCM_SPI_WRITE
argument_list|(
name|sc
argument_list|,
name|off
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|bcm_spi_clock_proc
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|bcm_spi_softc
modifier|*
name|sc
decl_stmt|;
name|uint32_t
name|clk
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|bcm_spi_softc
operator|*
operator|)
name|arg1
expr_stmt|;
name|BCM_SPI_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|clk
operator|=
name|BCM_SPI_READ
argument_list|(
name|sc
argument_list|,
name|SPI_CLK
argument_list|)
expr_stmt|;
name|BCM_SPI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|clk
operator|&=
literal|0xffff
expr_stmt|;
if|if
condition|(
name|clk
operator|==
literal|0
condition|)
name|clk
operator|=
literal|65536
expr_stmt|;
name|clk
operator|=
name|SPI_CORE_CLK
operator|/
name|clk
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|clk
argument_list|,
sizeof|sizeof
argument_list|(
name|clk
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|clk
operator|=
name|SPI_CORE_CLK
operator|/
name|clk
expr_stmt|;
if|if
condition|(
name|clk
operator|<=
literal|1
condition|)
name|clk
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|clk
operator|%
literal|2
condition|)
name|clk
operator|--
expr_stmt|;
if|if
condition|(
name|clk
operator|>
literal|0xffff
condition|)
name|clk
operator|=
literal|0
expr_stmt|;
name|BCM_SPI_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|BCM_SPI_WRITE
argument_list|(
name|sc
argument_list|,
name|SPI_CLK
argument_list|,
name|clk
argument_list|)
expr_stmt|;
name|BCM_SPI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bcm_spi_cs_bit_proc
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|,
name|uint32_t
name|bit
parameter_list|)
block|{
name|struct
name|bcm_spi_softc
modifier|*
name|sc
decl_stmt|;
name|uint32_t
name|reg
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|bcm_spi_softc
operator|*
operator|)
name|arg1
expr_stmt|;
name|BCM_SPI_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|reg
operator|=
name|BCM_SPI_READ
argument_list|(
name|sc
argument_list|,
name|SPI_CS
argument_list|)
expr_stmt|;
name|BCM_SPI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|reg
operator|=
operator|(
name|reg
operator|&
name|bit
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|reg
argument_list|,
sizeof|sizeof
argument_list|(
name|reg
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|reg
condition|)
name|reg
operator|=
name|bit
expr_stmt|;
name|BCM_SPI_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bcm_spi_modifyreg
argument_list|(
name|sc
argument_list|,
name|SPI_CS
argument_list|,
name|bit
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|BCM_SPI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bcm_spi_cpol_proc
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
return|return
operator|(
name|bcm_spi_cs_bit_proc
argument_list|(
name|oidp
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|req
argument_list|,
name|SPI_CS_CPOL
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bcm_spi_cpha_proc
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
return|return
operator|(
name|bcm_spi_cs_bit_proc
argument_list|(
name|oidp
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|req
argument_list|,
name|SPI_CS_CPHA
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bcm_spi_cspol0_proc
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
return|return
operator|(
name|bcm_spi_cs_bit_proc
argument_list|(
name|oidp
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|req
argument_list|,
name|SPI_CS_CSPOL0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bcm_spi_cspol1_proc
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
return|return
operator|(
name|bcm_spi_cs_bit_proc
argument_list|(
name|oidp
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|req
argument_list|,
name|SPI_CS_CSPOL1
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bcm_spi_sysctl_init
parameter_list|(
name|struct
name|bcm_spi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|tree_node
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|tree
decl_stmt|;
comment|/* 	 * Add system sysctl tree/handlers. 	 */
name|ctx
operator|=
name|device_get_sysctl_ctx
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
expr_stmt|;
name|tree_node
operator|=
name|device_get_sysctl_tree
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
expr_stmt|;
name|tree
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|tree_node
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|tree
argument_list|,
name|OID_AUTO
argument_list|,
literal|"clock"
argument_list|,
name|CTLFLAG_RW
operator||
name|CTLTYPE_UINT
argument_list|,
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
argument_list|,
name|bcm_spi_clock_proc
argument_list|,
literal|"IU"
argument_list|,
literal|"SPI BUS clock frequency"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|tree
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cpol"
argument_list|,
name|CTLFLAG_RW
operator||
name|CTLTYPE_UINT
argument_list|,
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
argument_list|,
name|bcm_spi_cpol_proc
argument_list|,
literal|"IU"
argument_list|,
literal|"SPI BUS clock polarity"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|tree
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cpha"
argument_list|,
name|CTLFLAG_RW
operator||
name|CTLTYPE_UINT
argument_list|,
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
argument_list|,
name|bcm_spi_cpha_proc
argument_list|,
literal|"IU"
argument_list|,
literal|"SPI BUS clock phase"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|tree
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cspol0"
argument_list|,
name|CTLFLAG_RW
operator||
name|CTLTYPE_UINT
argument_list|,
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
argument_list|,
name|bcm_spi_cspol0_proc
argument_list|,
literal|"IU"
argument_list|,
literal|"SPI BUS chip select 0 polarity"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|tree
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cspol1"
argument_list|,
name|CTLFLAG_RW
operator||
name|CTLTYPE_UINT
argument_list|,
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
argument_list|,
name|bcm_spi_cspol1_proc
argument_list|,
literal|"IU"
argument_list|,
literal|"SPI BUS chip select 1 polarity"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|bcm_spi_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ofw_bus_is_compatible
argument_list|(
name|dev
argument_list|,
literal|"broadcom,bcm2835-spi"
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"BCM2708/2835 SPI controller"
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bcm_spi_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|bcm_spi_softc
modifier|*
name|sc
decl_stmt|;
name|device_t
name|gpio
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rid
decl_stmt|;
if|if
condition|(
name|device_get_unit
argument_list|(
name|dev
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"only one SPI controller supported\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_dev
operator|=
name|dev
expr_stmt|;
comment|/* Configure the GPIO pins to ALT0 function to enable SPI the pins. */
name|gpio
operator|=
name|devclass_get_device
argument_list|(
name|devclass_find
argument_list|(
literal|"gpio"
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gpio
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot find gpio0\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|bcm_spi_pins
argument_list|)
condition|;
name|i
operator|++
control|)
name|bcm_gpio_set_alternate
argument_list|(
name|gpio
argument_list|,
name|bcm_spi_pins
index|[
name|i
index|]
argument_list|,
name|BCM_GPIO_ALT0
argument_list|)
expr_stmt|;
name|rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_mem_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_mem_res
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot allocate memory window\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|sc
operator|->
name|sc_bst
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|sc_mem_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_bsh
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|sc_mem_res
argument_list|)
expr_stmt|;
name|rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_irq_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_irq_res
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|sc_mem_res
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot allocate interrupt\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Hook up our interrupt handler. */
if|if
condition|(
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|sc_irq_res
argument_list|,
name|INTR_TYPE_MISC
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|bcm_spi_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_intrhand
argument_list|)
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|sc_irq_res
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|sc_mem_res
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot setup the interrupt handler\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
literal|"bcm_spi"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
comment|/* Add sysctl nodes. */
name|bcm_spi_sysctl_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BCM_SPI_DEBUG
name|bcm_spi_printr
argument_list|(
name|dev
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Enable the SPI controller.  Clear the rx and tx FIFO. 	 * Defaults to SPI mode 0. 	 */
name|BCM_SPI_WRITE
argument_list|(
name|sc
argument_list|,
name|SPI_CS
argument_list|,
name|SPI_CS_CLEAR_RXFIFO
operator||
name|SPI_CS_CLEAR_TXFIFO
argument_list|)
expr_stmt|;
comment|/* Set the SPI clock to 500Khz. */
name|BCM_SPI_WRITE
argument_list|(
name|sc
argument_list|,
name|SPI_CLK
argument_list|,
name|SPI_CORE_CLK
operator|/
literal|500000
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BCM_SPI_DEBUG
name|bcm_spi_printr
argument_list|(
name|dev
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|device_add_child
argument_list|(
name|dev
argument_list|,
literal|"spibus"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|bus_generic_attach
argument_list|(
name|dev
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bcm_spi_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|bcm_spi_softc
modifier|*
name|sc
decl_stmt|;
name|bus_generic_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_intrhand
condition|)
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|sc_irq_res
argument_list|,
name|sc
operator|->
name|sc_intrhand
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_irq_res
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|sc_irq_res
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_mem_res
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|sc_mem_res
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bcm_spi_fill_fifo
parameter_list|(
name|struct
name|bcm_spi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|spi_command
modifier|*
name|cmd
decl_stmt|;
name|uint32_t
name|cs
decl_stmt|,
name|written
decl_stmt|;
name|uint8_t
modifier|*
name|data
decl_stmt|;
name|cmd
operator|=
name|sc
operator|->
name|sc_cmd
expr_stmt|;
name|cs
operator|=
name|BCM_SPI_READ
argument_list|(
name|sc
argument_list|,
name|SPI_CS
argument_list|)
operator|&
operator|(
name|SPI_CS_TA
operator||
name|SPI_CS_TXD
operator|)
expr_stmt|;
while|while
condition|(
name|sc
operator|->
name|sc_written
operator|<
name|sc
operator|->
name|sc_len
operator|&&
name|cs
operator|==
operator|(
name|SPI_CS_TA
operator||
name|SPI_CS_TXD
operator|)
condition|)
block|{
name|data
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|cmd
operator|->
name|tx_cmd
expr_stmt|;
name|written
operator|=
name|sc
operator|->
name|sc_written
operator|++
expr_stmt|;
if|if
condition|(
name|written
operator|>=
name|cmd
operator|->
name|tx_cmd_sz
condition|)
block|{
name|data
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|cmd
operator|->
name|tx_data
expr_stmt|;
name|written
operator|-=
name|cmd
operator|->
name|tx_cmd_sz
expr_stmt|;
block|}
name|BCM_SPI_WRITE
argument_list|(
name|sc
argument_list|,
name|SPI_FIFO
argument_list|,
name|data
index|[
name|written
index|]
argument_list|)
expr_stmt|;
name|cs
operator|=
name|BCM_SPI_READ
argument_list|(
name|sc
argument_list|,
name|SPI_CS
argument_list|)
operator|&
operator|(
name|SPI_CS_TA
operator||
name|SPI_CS_TXD
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bcm_spi_drain_fifo
parameter_list|(
name|struct
name|bcm_spi_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|spi_command
modifier|*
name|cmd
decl_stmt|;
name|uint32_t
name|cs
decl_stmt|,
name|read
decl_stmt|;
name|uint8_t
modifier|*
name|data
decl_stmt|;
name|cmd
operator|=
name|sc
operator|->
name|sc_cmd
expr_stmt|;
name|cs
operator|=
name|BCM_SPI_READ
argument_list|(
name|sc
argument_list|,
name|SPI_CS
argument_list|)
operator|&
name|SPI_CS_RXD
expr_stmt|;
while|while
condition|(
name|sc
operator|->
name|sc_read
operator|<
name|sc
operator|->
name|sc_len
operator|&&
name|cs
operator|==
name|SPI_CS_RXD
condition|)
block|{
name|data
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|cmd
operator|->
name|rx_cmd
expr_stmt|;
name|read
operator|=
name|sc
operator|->
name|sc_read
operator|++
expr_stmt|;
if|if
condition|(
name|read
operator|>=
name|cmd
operator|->
name|rx_cmd_sz
condition|)
block|{
name|data
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|cmd
operator|->
name|rx_data
expr_stmt|;
name|read
operator|-=
name|cmd
operator|->
name|rx_cmd_sz
expr_stmt|;
block|}
name|data
index|[
name|read
index|]
operator|=
name|BCM_SPI_READ
argument_list|(
name|sc
argument_list|,
name|SPI_FIFO
argument_list|)
operator|&
literal|0xff
expr_stmt|;
name|cs
operator|=
name|BCM_SPI_READ
argument_list|(
name|sc
argument_list|,
name|SPI_CS
argument_list|)
operator|&
name|SPI_CS_RXD
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bcm_spi_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|bcm_spi_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|bcm_spi_softc
operator|*
operator|)
name|arg
expr_stmt|;
name|BCM_SPI_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Filter stray interrupts. */
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|BCM_SPI_BUSY
operator|)
operator|==
literal|0
condition|)
block|{
name|BCM_SPI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* TX - Fill up the FIFO. */
name|bcm_spi_fill_fifo
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* RX - Drain the FIFO. */
name|bcm_spi_drain_fifo
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Check for end of transfer. */
if|if
condition|(
name|sc
operator|->
name|sc_written
operator|==
name|sc
operator|->
name|sc_len
operator|&&
name|sc
operator|->
name|sc_read
operator|==
name|sc
operator|->
name|sc_len
condition|)
block|{
comment|/* Disable interrupts and the SPI engine. */
name|bcm_spi_modifyreg
argument_list|(
name|sc
argument_list|,
name|SPI_CS
argument_list|,
name|SPI_CS_TA
operator||
name|SPI_CS_INTR
operator||
name|SPI_CS_INTD
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
expr_stmt|;
block|}
name|BCM_SPI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|bcm_spi_transfer
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|struct
name|spi_command
modifier|*
name|cmd
parameter_list|)
block|{
name|struct
name|bcm_spi_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|cs
decl_stmt|,
name|err
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|cmd
operator|->
name|tx_cmd_sz
operator|==
name|cmd
operator|->
name|rx_cmd_sz
argument_list|,
operator|(
literal|"TX/RX command sizes should be equal"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|cmd
operator|->
name|tx_data_sz
operator|==
name|cmd
operator|->
name|rx_data_sz
argument_list|,
operator|(
literal|"TX/RX data sizes should be equal"
operator|)
argument_list|)
expr_stmt|;
name|BCM_SPI_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* If the controller is in use wait until it is available. */
while|while
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|BCM_SPI_BUSY
condition|)
name|mtx_sleep
argument_list|(
name|dev
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
literal|0
argument_list|,
literal|"bcm_spi"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Now we have control over SPI controller. */
name|sc
operator|->
name|sc_flags
operator|=
name|BCM_SPI_BUSY
expr_stmt|;
comment|/* Clear the FIFO. */
name|bcm_spi_modifyreg
argument_list|(
name|sc
argument_list|,
name|SPI_CS
argument_list|,
name|SPI_CS_CLEAR_RXFIFO
operator||
name|SPI_CS_CLEAR_TXFIFO
argument_list|,
name|SPI_CS_CLEAR_RXFIFO
operator||
name|SPI_CS_CLEAR_TXFIFO
argument_list|)
expr_stmt|;
comment|/* Get the proper chip select for this child. */
name|spibus_get_cs
argument_list|(
name|child
argument_list|,
operator|&
name|cs
argument_list|)
expr_stmt|;
if|if
condition|(
name|cs
operator|<
literal|0
operator|||
name|cs
operator|>
literal|2
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Invalid chip select %d requested by %s\n"
argument_list|,
name|cs
argument_list|,
name|device_get_nameunit
argument_list|(
name|child
argument_list|)
argument_list|)
expr_stmt|;
name|BCM_SPI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Save a pointer to the SPI command. */
name|sc
operator|->
name|sc_cmd
operator|=
name|cmd
expr_stmt|;
name|sc
operator|->
name|sc_read
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_written
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_len
operator|=
name|cmd
operator|->
name|tx_cmd_sz
operator|+
name|cmd
operator|->
name|tx_data_sz
expr_stmt|;
comment|/* 	 * Set the CS for this transaction, enable interrupts and announce 	 * we're ready to tx.  This will kick off the first interrupt. 	 */
name|bcm_spi_modifyreg
argument_list|(
name|sc
argument_list|,
name|SPI_CS
argument_list|,
name|SPI_CS_MASK
operator||
name|SPI_CS_TA
operator||
name|SPI_CS_INTR
operator||
name|SPI_CS_INTD
argument_list|,
name|cs
operator||
name|SPI_CS_TA
operator||
name|SPI_CS_INTR
operator||
name|SPI_CS_INTD
argument_list|)
expr_stmt|;
comment|/* Wait for the transaction to complete. */
name|err
operator|=
name|mtx_sleep
argument_list|(
name|dev
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
literal|0
argument_list|,
literal|"bcm_spi"
argument_list|,
name|hz
operator|*
literal|2
argument_list|)
expr_stmt|;
comment|/* Make sure the SPI engine and interrupts are disabled. */
name|bcm_spi_modifyreg
argument_list|(
name|sc
argument_list|,
name|SPI_CS
argument_list|,
name|SPI_CS_TA
operator||
name|SPI_CS_INTR
operator||
name|SPI_CS_INTD
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Clear the controller flags. */
name|sc
operator|->
name|sc_flags
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Check for transfer timeout.  The SPI controller doesn't 	 * return errors. 	 */
if|if
condition|(
name|err
operator|==
name|EWOULDBLOCK
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"SPI error\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|EIO
expr_stmt|;
block|}
name|BCM_SPI_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|phandle_t
name|bcm_spi_get_node
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|dev
parameter_list|)
block|{
comment|/* We only have one child, the SPI bus, which needs our own node. */
return|return
operator|(
name|ofw_bus_get_node
argument_list|(
name|bus
argument_list|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|bcm_spi_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|bcm_spi_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|bcm_spi_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|bcm_spi_detach
argument_list|)
block|,
comment|/* SPI interface */
name|DEVMETHOD
argument_list|(
name|spibus_transfer
argument_list|,
name|bcm_spi_transfer
argument_list|)
block|,
comment|/* ofw_bus interface */
name|DEVMETHOD
argument_list|(
name|ofw_bus_get_node
argument_list|,
name|bcm_spi_get_node
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|bcm_spi_devclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|bcm_spi_driver
init|=
block|{
literal|"spi"
block|,
name|bcm_spi_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|bcm_spi_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|bcm2835_spi
argument_list|,
name|simplebus
argument_list|,
name|bcm_spi_driver
argument_list|,
name|bcm_spi_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

