begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2017 Rogiel Sulzbach<rogiel@allogica.com>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/ofw_bus.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/ofw_bus_subr.h>
end_include

begin_include
include|#
directive|include
file|<dev/ahci/ahci.h>
end_include

begin_include
include|#
directive|include
file|<arm/freescale/imx/imx_iomuxreg.h>
end_include

begin_include
include|#
directive|include
file|<arm/freescale/imx/imx_iomuxvar.h>
end_include

begin_include
include|#
directive|include
file|<arm/freescale/imx/imx_ccmvar.h>
end_include

begin_define
define|#
directive|define
name|SATA_TIMER1MS
value|0x000000e0
end_define

begin_define
define|#
directive|define
name|SATA_P0PHYCR
value|0x00000178
end_define

begin_define
define|#
directive|define
name|SATA_P0PHYCR_CR_READ
value|(1<< 19)
end_define

begin_define
define|#
directive|define
name|SATA_P0PHYCR_CR_WRITE
value|(1<< 18)
end_define

begin_define
define|#
directive|define
name|SATA_P0PHYCR_CR_CAP_DATA
value|(1<< 17)
end_define

begin_define
define|#
directive|define
name|SATA_P0PHYCR_CR_CAP_ADDR
value|(1<< 16)
end_define

begin_define
define|#
directive|define
name|SATA_P0PHYCR_CR_DATA_IN
parameter_list|(
name|v
parameter_list|)
value|((v)& 0xffff)
end_define

begin_define
define|#
directive|define
name|SATA_P0PHYSR
value|0x0000017c
end_define

begin_define
define|#
directive|define
name|SATA_P0PHYSR_CR_ACK
value|(1<< 18)
end_define

begin_define
define|#
directive|define
name|SATA_P0PHYSR_CR_DATA_OUT
parameter_list|(
name|v
parameter_list|)
value|((v)& 0xffff)
end_define

begin_comment
comment|/* phy registers */
end_comment

begin_define
define|#
directive|define
name|SATA_PHY_CLOCK_RESET
value|0x7f3f
end_define

begin_define
define|#
directive|define
name|SATA_PHY_CLOCK_RESET_RST
value|(1<< 0)
end_define

begin_define
define|#
directive|define
name|SATA_PHY_LANE0_OUT_STAT
value|0x2003
end_define

begin_define
define|#
directive|define
name|SATA_PHY_LANE0_OUT_STAT_RX_PLL_STATE
value|(1<< 1)
end_define

begin_function
specifier|static
name|int
name|imx6_ahci_phy_ctrl
parameter_list|(
name|struct
name|ahci_controller
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|bitmask
parameter_list|,
name|bool
name|on
parameter_list|)
block|{
name|uint32_t
name|v
decl_stmt|;
name|int
name|timeout
decl_stmt|;
name|bool
name|state
decl_stmt|;
name|v
operator|=
name|ATA_INL
argument_list|(
name|sc
operator|->
name|r_mem
argument_list|,
name|SATA_P0PHYCR
argument_list|)
expr_stmt|;
if|if
condition|(
name|on
condition|)
block|{
name|v
operator||=
name|bitmask
expr_stmt|;
block|}
else|else
block|{
name|v
operator|&=
operator|~
name|bitmask
expr_stmt|;
block|}
name|ATA_OUTL
argument_list|(
name|sc
operator|->
name|r_mem
argument_list|,
name|SATA_P0PHYCR
argument_list|,
name|v
argument_list|)
expr_stmt|;
for|for
control|(
name|timeout
operator|=
literal|5000
init|;
name|timeout
operator|>
literal|0
condition|;
operator|--
name|timeout
control|)
block|{
name|v
operator|=
name|ATA_INL
argument_list|(
name|sc
operator|->
name|r_mem
argument_list|,
name|SATA_P0PHYSR
argument_list|)
expr_stmt|;
name|state
operator|=
operator|(
name|v
operator|&
name|SATA_P0PHYSR_CR_ACK
operator|)
operator|==
name|SATA_P0PHYSR_CR_ACK
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|on
condition|)
block|{
break|break;
block|}
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|timeout
operator|>
literal|0
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|imx6_ahci_phy_addr
parameter_list|(
name|struct
name|ahci_controller
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|sc
operator|->
name|r_mem
argument_list|,
name|SATA_P0PHYCR
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|error
operator|=
name|imx6_ahci_phy_ctrl
argument_list|(
name|sc
argument_list|,
name|SATA_P0PHYCR_CR_CAP_ADDR
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"%s: timeout on SATA_P0PHYCR_CR_CAP_ADDR=1\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|imx6_ahci_phy_ctrl
argument_list|(
name|sc
argument_list|,
name|SATA_P0PHYCR_CR_CAP_ADDR
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"%s: timeout on SATA_P0PHYCR_CR_CAP_ADDR=0\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|imx6_ahci_phy_write
parameter_list|(
name|struct
name|ahci_controller
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
name|uint16_t
name|data
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|imx6_ahci_phy_addr
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"%s: error on imx6_ahci_phy_addr\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|ATA_OUTL
argument_list|(
name|sc
operator|->
name|r_mem
argument_list|,
name|SATA_P0PHYCR
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|error
operator|=
name|imx6_ahci_phy_ctrl
argument_list|(
name|sc
argument_list|,
name|SATA_P0PHYCR_CR_CAP_DATA
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"%s: error on SATA_P0PHYCR_CR_CAP_DATA=1\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|imx6_ahci_phy_ctrl
argument_list|(
name|sc
argument_list|,
name|SATA_P0PHYCR_CR_CAP_DATA
argument_list|,
name|false
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"%s: error on SATA_P0PHYCR_CR_CAP_DATA=0\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|addr
operator|==
name|SATA_PHY_CLOCK_RESET
operator|)
operator|&&
name|data
condition|)
block|{
comment|/* we can't check ACK after RESET */
name|ATA_OUTL
argument_list|(
name|sc
operator|->
name|r_mem
argument_list|,
name|SATA_P0PHYCR
argument_list|,
name|SATA_P0PHYCR_CR_DATA_IN
argument_list|(
name|data
argument_list|)
operator||
name|SATA_P0PHYCR_CR_WRITE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|error
operator|=
name|imx6_ahci_phy_ctrl
argument_list|(
name|sc
argument_list|,
name|SATA_P0PHYCR_CR_WRITE
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"%s: error on SATA_P0PHYCR_CR_WRITE=1\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|imx6_ahci_phy_ctrl
argument_list|(
name|sc
argument_list|,
name|SATA_P0PHYCR_CR_WRITE
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"%s: error on SATA_P0PHYCR_CR_WRITE=0\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|imx6_ahci_phy_read
parameter_list|(
name|struct
name|ahci_controller
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
name|uint16_t
modifier|*
name|val
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|uint32_t
name|v
decl_stmt|;
name|error
operator|=
name|imx6_ahci_phy_addr
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"%s: error on imx6_ahci_phy_addr\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|imx6_ahci_phy_ctrl
argument_list|(
name|sc
argument_list|,
name|SATA_P0PHYCR_CR_READ
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"%s: error on SATA_P0PHYCR_CR_READ=1\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|v
operator|=
name|ATA_INL
argument_list|(
name|sc
operator|->
name|r_mem
argument_list|,
name|SATA_P0PHYSR
argument_list|)
expr_stmt|;
name|error
operator|=
name|imx6_ahci_phy_ctrl
argument_list|(
name|sc
argument_list|,
name|SATA_P0PHYCR_CR_READ
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"%s: error on SATA_P0PHYCR_CR_READ=0\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
operator|*
name|val
operator|=
name|SATA_P0PHYSR_CR_DATA_OUT
argument_list|(
name|v
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|imx6_ahci_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ofw_bus_status_okay
argument_list|(
name|dev
argument_list|)
condition|)
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|ofw_bus_is_compatible
argument_list|(
name|dev
argument_list|,
literal|"fsl,imx6q-ahci"
argument_list|)
condition|)
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"i.MX6 Integrated AHCI controller"
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|imx6_ahci_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ahci_controller
modifier|*
name|ctlr
decl_stmt|;
name|uint16_t
name|pllstat
decl_stmt|;
name|uint32_t
name|v
decl_stmt|;
name|int
name|error
decl_stmt|,
name|timeout
decl_stmt|;
name|ctlr
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Power up the controller and phy. */
name|error
operator|=
name|imx6_ccm_sata_enable
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"error enabling controller and phy\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|ctlr
operator|->
name|vendorid
operator|=
literal|0
expr_stmt|;
name|ctlr
operator|->
name|deviceid
operator|=
literal|0
expr_stmt|;
name|ctlr
operator|->
name|subvendorid
operator|=
literal|0
expr_stmt|;
name|ctlr
operator|->
name|subdeviceid
operator|=
literal|0
expr_stmt|;
name|ctlr
operator|->
name|numirqs
operator|=
literal|1
expr_stmt|;
name|ctlr
operator|->
name|r_rid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ctlr
operator|->
name|r_mem
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|ctlr
operator|->
name|r_rid
argument_list|,
name|RF_ACTIVE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|v
operator|=
name|imx_iomux_gpr_get
argument_list|(
name|IOMUX_GPR13
argument_list|)
expr_stmt|;
comment|/* Clear out existing values; these numbers are bitmasks. */
name|v
operator|&=
operator|~
operator|(
name|IOMUX_GPR13_SATA_PHY_8
argument_list|(
literal|7
argument_list|)
operator||
name|IOMUX_GPR13_SATA_PHY_7
argument_list|(
literal|0x1f
argument_list|)
operator||
name|IOMUX_GPR13_SATA_PHY_6
argument_list|(
literal|7
argument_list|)
operator||
name|IOMUX_GPR13_SATA_SPEED
argument_list|(
literal|1
argument_list|)
operator||
name|IOMUX_GPR13_SATA_PHY_5
argument_list|(
literal|1
argument_list|)
operator||
name|IOMUX_GPR13_SATA_PHY_4
argument_list|(
literal|7
argument_list|)
operator||
name|IOMUX_GPR13_SATA_PHY_3
argument_list|(
literal|0xf
argument_list|)
operator||
name|IOMUX_GPR13_SATA_PHY_2
argument_list|(
literal|0x1f
argument_list|)
operator||
name|IOMUX_GPR13_SATA_PHY_1
argument_list|(
literal|1
argument_list|)
operator||
name|IOMUX_GPR13_SATA_PHY_0
argument_list|(
literal|1
argument_list|)
operator|)
expr_stmt|;
comment|/* setting */
name|v
operator||=
name|IOMUX_GPR13_SATA_PHY_8
argument_list|(
literal|5
argument_list|)
operator||
comment|/* Rx 3.0db */
name|IOMUX_GPR13_SATA_PHY_7
argument_list|(
literal|0x12
argument_list|)
operator||
comment|/* Rx SATA2m */
name|IOMUX_GPR13_SATA_PHY_6
argument_list|(
literal|3
argument_list|)
operator||
comment|/* Rx DPLL mode */
name|IOMUX_GPR13_SATA_SPEED
argument_list|(
literal|1
argument_list|)
operator||
comment|/* 3.0GHz */
name|IOMUX_GPR13_SATA_PHY_5
argument_list|(
literal|0
argument_list|)
operator||
comment|/* SpreadSpectram */
name|IOMUX_GPR13_SATA_PHY_4
argument_list|(
literal|4
argument_list|)
operator||
comment|/* Tx Attenuation 9/16 */
name|IOMUX_GPR13_SATA_PHY_3
argument_list|(
literal|0
argument_list|)
operator||
comment|/* Tx Boost 0db */
name|IOMUX_GPR13_SATA_PHY_2
argument_list|(
literal|0x11
argument_list|)
operator||
comment|/* Tx Level 1.104V */
name|IOMUX_GPR13_SATA_PHY_1
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* PLL clock enable */
name|imx_iomux_gpr_set
argument_list|(
name|IOMUX_GPR13
argument_list|,
name|v
argument_list|)
expr_stmt|;
comment|/* phy reset */
name|error
operator|=
name|imx6_ahci_phy_write
argument_list|(
name|ctlr
argument_list|,
name|SATA_PHY_CLOCK_RESET
argument_list|,
name|SATA_PHY_CLOCK_RESET_RST
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot reset PHY\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
for|for
control|(
name|timeout
operator|=
literal|50
init|;
name|timeout
operator|>
literal|0
condition|;
operator|--
name|timeout
control|)
block|{
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|error
operator|=
name|imx6_ahci_phy_read
argument_list|(
name|ctlr
argument_list|,
name|SATA_PHY_LANE0_OUT_STAT
argument_list|,
operator|&
name|pllstat
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot read LANE0 status\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|pllstat
operator|&
name|SATA_PHY_LANE0_OUT_STAT_RX_PLL_STATE
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|timeout
operator|<=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"time out reading LANE0 status\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ETIMEDOUT
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Support Staggered Spin-up */
name|v
operator|=
name|ATA_INL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_CAP
argument_list|)
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_CAP
argument_list|,
name|v
operator||
name|AHCI_CAP_SSS
argument_list|)
expr_stmt|;
comment|/* Ports Implemented. must set 1 */
name|v
operator|=
name|ATA_INL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_PI
argument_list|)
expr_stmt|;
name|ATA_OUTL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|AHCI_PI
argument_list|,
name|v
operator||
operator|(
literal|1
operator|<<
literal|0
operator|)
argument_list|)
expr_stmt|;
comment|/* set 1ms-timer = AHB clock / 1000 */
name|ATA_OUTL
argument_list|(
name|ctlr
operator|->
name|r_mem
argument_list|,
name|SATA_TIMER1MS
argument_list|,
name|imx_ccm_ahb_hz
argument_list|()
operator|/
literal|1000
argument_list|)
expr_stmt|;
comment|/* 	 * Note: ahci_attach will release ctlr->r_mem on errors automatically 	 */
return|return
operator|(
name|ahci_attach
argument_list|(
name|dev
argument_list|)
operator|)
return|;
name|fail
label|:
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|ctlr
operator|->
name|r_rid
argument_list|,
name|ctlr
operator|->
name|r_mem
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|imx6_ahci_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
return|return
operator|(
name|ahci_detach
argument_list|(
name|dev
argument_list|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|imx6_ahci_ata_methods
index|[]
init|=
block|{
comment|/* device probe, attach and detach methods */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|imx6_ahci_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|imx6_ahci_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|imx6_ahci_detach
argument_list|)
block|,
comment|/* ahci bus methods */
name|DEVMETHOD
argument_list|(
name|bus_print_child
argument_list|,
name|ahci_print_child
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_alloc_resource
argument_list|,
name|ahci_alloc_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_release_resource
argument_list|,
name|ahci_release_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_setup_intr
argument_list|,
name|ahci_setup_intr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_teardown_intr
argument_list|,
name|ahci_teardown_intr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_child_location_str
argument_list|,
name|ahci_child_location_str
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|ahci_ata_driver
init|=
block|{
literal|"ahci"
block|,
name|imx6_ahci_ata_methods
block|,
expr|sizeof
operator|(
expr|struct
name|ahci_controller
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|ahci
argument_list|,
name|simplebus
argument_list|,
name|ahci_ata_driver
argument_list|,
name|ahci_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

