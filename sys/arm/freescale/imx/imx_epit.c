begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2017 Ian Lepore<ian@freebsd.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Driver for imx Enhanced Programmable Interval Timer, a simple free-running  * counter device that can be used as the system timecounter.  On imx5 a second  * instance of the device is used as the system eventtimer.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/timeet.h>
end_include

begin_include
include|#
directive|include
file|<sys/timetc.h>
end_include

begin_include
include|#
directive|include
file|<sys/watchdog.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/intr.h>
end_include

begin_include
include|#
directive|include
file|<machine/machdep.h>
end_include

begin_include
include|#
directive|include
file|<dev/fdt/fdt_common.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/openfirm.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/ofw_bus.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/ofw_bus_subr.h>
end_include

begin_include
include|#
directive|include
file|<arm/freescale/imx/imx_ccmvar.h>
end_include

begin_include
include|#
directive|include
file|<arm/freescale/imx/imx_machdep.h>
end_include

begin_define
define|#
directive|define
name|EPIT_CR
value|0x00
end_define

begin_comment
comment|/* Control register */
end_comment

begin_define
define|#
directive|define
name|EPIT_CR_CLKSRC_SHIFT
value|24
end_define

begin_define
define|#
directive|define
name|EPIT_CR_CLKSRC_OFF
value|0
end_define

begin_define
define|#
directive|define
name|EPIT_CR_CLKSRC_IPG
value|1
end_define

begin_define
define|#
directive|define
name|EPIT_CR_CLKSRC_HFCLK
value|2
end_define

begin_define
define|#
directive|define
name|EPIT_CR_CLKSRC_LFCLK
value|3
end_define

begin_define
define|#
directive|define
name|EPIT_CR_STOPEN
value|(1u<< 21)
end_define

begin_define
define|#
directive|define
name|EPIT_CR_WAITEN
value|(1u<< 19)
end_define

begin_define
define|#
directive|define
name|EPIT_CR_DBGEN
value|(1u<< 18)
end_define

begin_define
define|#
directive|define
name|EPIT_CR_IOVW
value|(1u<< 17)
end_define

begin_define
define|#
directive|define
name|EPIT_CR_SWR
value|(1u<< 16)
end_define

begin_define
define|#
directive|define
name|EPIT_CR_RLD
value|(1u<<  3)
end_define

begin_define
define|#
directive|define
name|EPIT_CR_OCIEN
value|(1u<<  2)
end_define

begin_define
define|#
directive|define
name|EPIT_CR_ENMOD
value|(1u<<  1)
end_define

begin_define
define|#
directive|define
name|EPIT_CR_EN
value|(1u<<  0)
end_define

begin_define
define|#
directive|define
name|EPIT_SR
value|0x04
end_define

begin_comment
comment|/* Status register */
end_comment

begin_define
define|#
directive|define
name|EPIT_SR_OCIF
value|(1u<< 0)
end_define

begin_define
define|#
directive|define
name|EPIT_LR
value|0x08
end_define

begin_comment
comment|/* Load register */
end_comment

begin_define
define|#
directive|define
name|EPIT_CMPR
value|0x0c
end_define

begin_comment
comment|/* Compare register */
end_comment

begin_define
define|#
directive|define
name|EPIT_CNR
value|0x10
end_define

begin_comment
comment|/* Counter register */
end_comment

begin_comment
comment|/*  * Define event timer limits.  *  * In theory our minimum period is 1 tick, because to setup a oneshot we don't  * need a read-modify-write sequence to calculate and set a compare register  * value while the counter is running.  In practice the waveform diagrams in the  * manual make it appear that a setting of 1 might cause it to miss the event,  * so I'm setting the lower limit to 2 ticks.  */
end_comment

begin_define
define|#
directive|define
name|ET_MIN_TICKS
value|2
end_define

begin_define
define|#
directive|define
name|ET_MAX_TICKS
value|0xfffffffe
end_define

begin_function_decl
specifier|static
name|u_int
name|epit_tc_get_timecount
parameter_list|(
name|struct
name|timecounter
modifier|*
name|tc
parameter_list|)
function_decl|;
end_function_decl

begin_struct
struct|struct
name|epit_softc
block|{
name|device_t
name|dev
decl_stmt|;
name|struct
name|resource
modifier|*
name|memres
decl_stmt|;
name|struct
name|resource
modifier|*
name|intres
decl_stmt|;
name|void
modifier|*
name|inthandle
decl_stmt|;
name|uint32_t
name|clkfreq
decl_stmt|;
name|uint32_t
name|ctlreg
decl_stmt|;
name|uint32_t
name|period
decl_stmt|;
name|struct
name|timecounter
name|tc
decl_stmt|;
name|struct
name|eventtimer
name|et
decl_stmt|;
name|bool
name|oneshot
decl_stmt|;
block|}
struct|;
end_struct

begin_ifndef
ifndef|#
directive|ifndef
name|MULTIDELAY
end_ifndef

begin_comment
comment|/* Global softc pointer for use in DELAY(). */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|epit_softc
modifier|*
name|epit_sc
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Probe data.  For some reason, the standard linux dts files don't have  * compatible properties on the epit devices (other properties are missing too,  * like clocks, but we don't care as much about that).  So our probe routine  * uses the name of the node (must contain "epit") and the address of the  * registers as identifying marks.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|uint32_t
name|imx51_epit_ioaddr
index|[
literal|2
index|]
init|=
block|{
literal|0x73fac000
block|,
literal|0x73fb0000
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|uint32_t
name|imx53_epit_ioaddr
index|[
literal|2
index|]
init|=
block|{
literal|0x53fac000
block|,
literal|0x53fb0000
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|uint32_t
name|imx6_epit_ioaddr
index|[
literal|2
index|]
init|=
block|{
literal|0x020d0000
block|,
literal|0x020d4000
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ocd_data is number of units to instantiate on the platform */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ofw_compat_data
name|compat_data
index|[]
init|=
block|{
block|{
literal|"fsl,imx6ul-epit"
block|,
literal|1
block|}
block|,
block|{
literal|"fsl,imx6sx-epit"
block|,
literal|1
block|}
block|,
block|{
literal|"fsl,imx6q-epit"
block|,
literal|1
block|}
block|,
block|{
literal|"fsl,imx6dl-epit"
block|,
literal|1
block|}
block|,
block|{
literal|"fsl,imx53-epit"
block|,
literal|2
block|}
block|,
block|{
literal|"fsl,imx51-epit"
block|,
literal|2
block|}
block|,
block|{
literal|"fsl,imx31-epit"
block|,
literal|2
block|}
block|,
block|{
literal|"fsl,imx27-epit"
block|,
literal|2
block|}
block|,
block|{
literal|"fsl,imx25-epit"
block|,
literal|2
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|inline
name|uint32_t
name|RD4
parameter_list|(
name|struct
name|epit_softc
modifier|*
name|sc
parameter_list|,
name|bus_size_t
name|offset
parameter_list|)
block|{
return|return
operator|(
name|bus_read_4
argument_list|(
name|sc
operator|->
name|memres
argument_list|,
name|offset
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|WR4
parameter_list|(
name|struct
name|epit_softc
modifier|*
name|sc
parameter_list|,
name|bus_size_t
name|offset
parameter_list|,
name|uint32_t
name|value
parameter_list|)
block|{
name|bus_write_4
argument_list|(
name|sc
operator|->
name|memres
argument_list|,
name|offset
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|WR4B
parameter_list|(
name|struct
name|epit_softc
modifier|*
name|sc
parameter_list|,
name|bus_size_t
name|offset
parameter_list|,
name|uint32_t
name|value
parameter_list|)
block|{
name|bus_write_4
argument_list|(
name|sc
operator|->
name|memres
argument_list|,
name|offset
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|bus_barrier
argument_list|(
name|sc
operator|->
name|memres
argument_list|,
name|offset
argument_list|,
literal|4
argument_list|,
name|BUS_SPACE_BARRIER_WRITE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u_int
name|epit_read_counter
parameter_list|(
name|struct
name|epit_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* 	 * Hardware is a downcounter, adjust to look like it counts up for use 	 * with timecounter and DELAY. 	 */
return|return
operator|(
literal|0xffffffff
operator|-
name|RD4
argument_list|(
name|sc
argument_list|,
name|EPIT_CNR
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|epit_do_delay
parameter_list|(
name|int
name|usec
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|epit_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|uint64_t
name|curcnt
decl_stmt|,
name|endcnt
decl_stmt|,
name|startcnt
decl_stmt|,
name|ticks
decl_stmt|;
comment|/* 	 * Calculate the tick count with 64-bit values so that it works for any 	 * clock frequency.  Loop until the hardware count reaches start+ticks. 	 * If the 32-bit hardware count rolls over while we're looping, just 	 * manually do a carry into the high bits after each read; don't worry 	 * that doing this on each loop iteration is inefficient -- we're trying 	 * to waste time here. 	 */
name|ticks
operator|=
literal|1
operator|+
operator|(
operator|(
name|uint64_t
operator|)
name|usec
operator|*
name|sc
operator|->
name|clkfreq
operator|)
operator|/
literal|1000000
expr_stmt|;
name|curcnt
operator|=
name|startcnt
operator|=
name|epit_read_counter
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|endcnt
operator|=
name|startcnt
operator|+
name|ticks
expr_stmt|;
while|while
condition|(
name|curcnt
operator|<
name|endcnt
condition|)
block|{
name|curcnt
operator|=
name|epit_read_counter
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|curcnt
operator|<
name|startcnt
condition|)
name|curcnt
operator|+=
literal|1ULL
operator|<<
literal|32
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|u_int
name|epit_tc_get_timecount
parameter_list|(
name|struct
name|timecounter
modifier|*
name|tc
parameter_list|)
block|{
return|return
operator|(
name|epit_read_counter
argument_list|(
name|tc
operator|->
name|tc_priv
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|epit_tc_attach
parameter_list|(
name|struct
name|epit_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* When the counter hits zero, reload with 0xffffffff.  Start it. */
name|WR4
argument_list|(
name|sc
argument_list|,
name|EPIT_LR
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|EPIT_CR
argument_list|,
name|sc
operator|->
name|ctlreg
operator||
name|EPIT_CR_EN
argument_list|)
expr_stmt|;
comment|/* Register as a timecounter. */
name|sc
operator|->
name|tc
operator|.
name|tc_name
operator|=
literal|"EPIT"
expr_stmt|;
name|sc
operator|->
name|tc
operator|.
name|tc_quality
operator|=
literal|1000
expr_stmt|;
name|sc
operator|->
name|tc
operator|.
name|tc_frequency
operator|=
name|sc
operator|->
name|clkfreq
expr_stmt|;
name|sc
operator|->
name|tc
operator|.
name|tc_counter_mask
operator|=
literal|0xffffffff
expr_stmt|;
name|sc
operator|->
name|tc
operator|.
name|tc_get_timecount
operator|=
name|epit_tc_get_timecount
expr_stmt|;
name|sc
operator|->
name|tc
operator|.
name|tc_priv
operator|=
name|sc
expr_stmt|;
name|tc_init
argument_list|(
operator|&
name|sc
operator|->
name|tc
argument_list|)
expr_stmt|;
comment|/* We are the DELAY() implementation. */
ifdef|#
directive|ifdef
name|MULTIDELAY
name|arm_set_delay
argument_list|(
name|epit_do_delay
argument_list|,
name|sc
argument_list|)
expr_stmt|;
else|#
directive|else
name|epit_sc
operator|=
name|sc
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|epit_et_start
parameter_list|(
name|struct
name|eventtimer
modifier|*
name|et
parameter_list|,
name|sbintime_t
name|first
parameter_list|,
name|sbintime_t
name|period
parameter_list|)
block|{
name|struct
name|epit_softc
modifier|*
name|sc
decl_stmt|;
name|uint32_t
name|ticks
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|epit_softc
operator|*
operator|)
name|et
operator|->
name|et_priv
expr_stmt|;
comment|/* 	 * Disable the timer and clear any pending status.  The timer may be 	 * running or may have just expired if we're called to reschedule the 	 * next event before the previous event time arrives. 	 */
name|WR4
argument_list|(
name|sc
argument_list|,
name|EPIT_CR
argument_list|,
name|sc
operator|->
name|ctlreg
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|EPIT_SR
argument_list|,
name|EPIT_SR_OCIF
argument_list|)
expr_stmt|;
if|if
condition|(
name|period
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|oneshot
operator|=
name|false
expr_stmt|;
name|ticks
operator|=
operator|(
operator|(
name|uint32_t
operator|)
name|et
operator|->
name|et_frequency
operator|*
name|period
operator|)
operator|>>
literal|32
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|first
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|oneshot
operator|=
name|true
expr_stmt|;
name|ticks
operator|=
operator|(
operator|(
name|uint32_t
operator|)
name|et
operator|->
name|et_frequency
operator|*
name|first
operator|)
operator|>>
literal|32
expr_stmt|;
block|}
else|else
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Set the countdown load register and start the timer. */
name|WR4
argument_list|(
name|sc
argument_list|,
name|EPIT_LR
argument_list|,
name|ticks
argument_list|)
expr_stmt|;
name|WR4B
argument_list|(
name|sc
argument_list|,
name|EPIT_CR
argument_list|,
name|sc
operator|->
name|ctlreg
operator||
name|EPIT_CR_EN
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|epit_et_stop
parameter_list|(
name|struct
name|eventtimer
modifier|*
name|et
parameter_list|)
block|{
name|struct
name|epit_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|epit_softc
operator|*
operator|)
name|et
operator|->
name|et_priv
expr_stmt|;
comment|/* Disable the timer and clear any pending status. */
name|WR4
argument_list|(
name|sc
argument_list|,
name|EPIT_CR
argument_list|,
name|sc
operator|->
name|ctlreg
argument_list|)
expr_stmt|;
name|WR4B
argument_list|(
name|sc
argument_list|,
name|EPIT_SR
argument_list|,
name|EPIT_SR_OCIF
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|epit_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|epit_softc
modifier|*
name|sc
decl_stmt|;
name|uint32_t
name|status
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
comment|/* 	 * Disable a one-shot timer until a new event is scheduled so that the 	 * counter doesn't wrap and fire again.  Do this before clearing the 	 * status since a short period would make it fire again really soon. 	 * 	 * Clear interrupt status before invoking event callbacks.  The callback 	 * often sets up a new one-shot timer event and if the interval is short 	 * enough it can fire before we get out of this function.  If we cleared 	 * at the bottom we'd miss the interrupt and hang until the clock wraps. 	 */
if|if
condition|(
name|sc
operator|->
name|oneshot
condition|)
name|WR4
argument_list|(
name|sc
argument_list|,
name|EPIT_CR
argument_list|,
name|sc
operator|->
name|ctlreg
argument_list|)
expr_stmt|;
name|status
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|EPIT_SR
argument_list|)
expr_stmt|;
name|WR4B
argument_list|(
name|sc
argument_list|,
name|EPIT_SR
argument_list|,
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|EPIT_SR_OCIF
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|FILTER_STRAY
operator|)
return|;
if|if
condition|(
name|sc
operator|->
name|et
operator|.
name|et_active
condition|)
name|sc
operator|->
name|et
operator|.
name|et_event_cb
argument_list|(
operator|&
name|sc
operator|->
name|et
argument_list|,
name|sc
operator|->
name|et
operator|.
name|et_arg
argument_list|)
expr_stmt|;
return|return
operator|(
name|FILTER_HANDLED
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|epit_et_attach
parameter_list|(
name|struct
name|epit_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|err
decl_stmt|,
name|rid
decl_stmt|;
name|rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|intres
operator|=
name|bus_alloc_resource_any
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|intres
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"could not allocate interrupt\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|err
operator|=
name|bus_setup_intr
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|intres
argument_list|,
name|INTR_TYPE_CLK
operator||
name|INTR_MPSAFE
argument_list|,
name|epit_intr
argument_list|,
name|NULL
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|inthandle
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"unable to setup the irq handler\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
comment|/* To be an eventtimer, we need interrupts enabled. */
name|sc
operator|->
name|ctlreg
operator||=
name|EPIT_CR_OCIEN
expr_stmt|;
comment|/* Register as an eventtimer. */
name|sc
operator|->
name|et
operator|.
name|et_name
operator|=
literal|"EPIT"
expr_stmt|;
name|sc
operator|->
name|et
operator|.
name|et_flags
operator|=
name|ET_FLAGS_ONESHOT
operator||
name|ET_FLAGS_PERIODIC
expr_stmt|;
name|sc
operator|->
name|et
operator|.
name|et_quality
operator|=
literal|1000
expr_stmt|;
name|sc
operator|->
name|et
operator|.
name|et_frequency
operator|=
name|sc
operator|->
name|clkfreq
expr_stmt|;
name|sc
operator|->
name|et
operator|.
name|et_min_period
operator|=
operator|(
operator|(
name|uint64_t
operator|)
name|ET_MIN_TICKS
operator|<<
literal|32
operator|)
operator|/
name|sc
operator|->
name|clkfreq
expr_stmt|;
name|sc
operator|->
name|et
operator|.
name|et_max_period
operator|=
operator|(
operator|(
name|uint64_t
operator|)
name|ET_MAX_TICKS
operator|<<
literal|32
operator|)
operator|/
name|sc
operator|->
name|clkfreq
expr_stmt|;
name|sc
operator|->
name|et
operator|.
name|et_start
operator|=
name|epit_et_start
expr_stmt|;
name|sc
operator|->
name|et
operator|.
name|et_stop
operator|=
name|epit_et_stop
expr_stmt|;
name|sc
operator|->
name|et
operator|.
name|et_priv
operator|=
name|sc
expr_stmt|;
name|et_register
argument_list|(
operator|&
name|sc
operator|->
name|et
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|epit_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|resource
modifier|*
name|memres
decl_stmt|;
name|rman_res_t
name|ioaddr
decl_stmt|;
name|int
name|num_units
decl_stmt|,
name|rid
decl_stmt|,
name|unit
decl_stmt|;
if|if
condition|(
operator|!
name|ofw_bus_status_okay
argument_list|(
name|dev
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* 	 * The FDT data for imx5 and imx6 EPIT hardware is missing or broken, 	 * but it may get fixed some day, so first just do a normal check.  We 	 * return success if the compatible string matches and we haven't 	 * already instantiated the number of units needed on this platform. 	 */
name|unit
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|num_units
operator|=
name|ofw_bus_search_compatible
argument_list|(
name|dev
argument_list|,
name|compat_data
argument_list|)
operator|->
name|ocd_data
expr_stmt|;
if|if
condition|(
name|unit
operator|<
name|num_units
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"i.MX EPIT timer"
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
comment|/* 	 * No compat string match, but for imx6 all the data we need is in the 	 * node except the compat string, so do our own compatibility check 	 * using the device name of the node and the register block address. 	 */
if|if
condition|(
name|strstr
argument_list|(
name|ofw_bus_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"epit"
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|rid
operator|=
literal|0
expr_stmt|;
name|memres
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_UNMAPPED
argument_list|)
expr_stmt|;
if|if
condition|(
name|memres
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|ioaddr
operator|=
name|rman_get_start
argument_list|(
name|memres
argument_list|)
expr_stmt|;
name|bus_free_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|memres
argument_list|)
expr_stmt|;
if|if
condition|(
name|imx_soc_family
argument_list|()
operator|==
literal|6
condition|)
block|{
if|if
condition|(
name|unit
operator|>
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|ioaddr
operator|!=
name|imx6_epit_ioaddr
index|[
name|unit
index|]
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|unit
operator|>
literal|1
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
switch|switch
condition|(
name|imx_soc_type
argument_list|()
condition|)
block|{
case|case
name|IMXSOC_51
case|:
if|if
condition|(
name|ioaddr
operator|!=
name|imx51_epit_ioaddr
index|[
name|unit
index|]
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
break|break;
case|case
name|IMXSOC_53
case|:
if|if
condition|(
name|ioaddr
operator|!=
name|imx53_epit_ioaddr
index|[
name|unit
index|]
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
break|break;
default|default:
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* 		 * XXX Right now we have no way to handle the fact that the 		 * entire EPIT node is missing, which means no interrupt data. 		 */
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"i.MX EPIT timer"
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|epit_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|epit_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|err
decl_stmt|,
name|rid
decl_stmt|;
name|uint32_t
name|clksrc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|memres
operator|=
name|bus_alloc_resource_any
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|memres
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"could not allocate registers\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* 	 * For now, use ipg (66 MHz).  Some day we should get this from fdt. 	 */
name|clksrc
operator|=
name|EPIT_CR_CLKSRC_IPG
expr_stmt|;
switch|switch
condition|(
name|clksrc
condition|)
block|{
default|default:
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unsupported clock source '%d', using IPG\n"
argument_list|,
name|clksrc
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|EPIT_CR_CLKSRC_IPG
case|:
name|sc
operator|->
name|clkfreq
operator|=
name|imx_ccm_ipg_hz
argument_list|()
expr_stmt|;
break|break;
case|case
name|EPIT_CR_CLKSRC_HFCLK
case|:
name|sc
operator|->
name|clkfreq
operator|=
name|imx_ccm_perclk_hz
argument_list|()
expr_stmt|;
break|break;
case|case
name|EPIT_CR_CLKSRC_LFCLK
case|:
name|sc
operator|->
name|clkfreq
operator|=
literal|32768
expr_stmt|;
break|break;
block|}
comment|/* 	 * Init: stop operations and clear all options, then set up options and 	 * clock source, then do a soft-reset and wait for it to complete. 	 */
name|WR4
argument_list|(
name|sc
argument_list|,
name|EPIT_CR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ctlreg
operator|=
operator|(
name|clksrc
operator|<<
name|EPIT_CR_CLKSRC_SHIFT
operator|)
operator||
comment|/* Use selected clock */
name|EPIT_CR_ENMOD
operator||
comment|/* Reload counter on enable */
name|EPIT_CR_RLD
operator||
comment|/* Reload counter from LR */
name|EPIT_CR_STOPEN
operator||
comment|/* Run in STOP mode */
name|EPIT_CR_WAITEN
operator||
comment|/* Run in WAIT mode */
name|EPIT_CR_DBGEN
expr_stmt|;
comment|/* Run in DEBUG mode */
name|WR4B
argument_list|(
name|sc
argument_list|,
name|EPIT_CR
argument_list|,
name|sc
operator|->
name|ctlreg
operator||
name|EPIT_CR_SWR
argument_list|)
expr_stmt|;
while|while
condition|(
name|RD4
argument_list|(
name|sc
argument_list|,
name|EPIT_CR
argument_list|)
operator|&
name|EPIT_CR_SWR
condition|)
continue|continue;
comment|/* 	 * Unit 0 is the timecounter, 1 (if instantiated) is the eventtimer. 	 */
if|if
condition|(
name|device_get_unit
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
operator|==
literal|0
condition|)
name|err
operator|=
name|epit_tc_attach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|else
name|err
operator|=
name|epit_et_attach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|epit_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|epit_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|epit_attach
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|epit_driver
init|=
block|{
literal|"imx_epit"
block|,
name|epit_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|epit_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|epit_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|EARLY_DRIVER_MODULE
argument_list|(
name|imx_epit
argument_list|,
name|simplebus
argument_list|,
name|epit_driver
argument_list|,
name|epit_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|BUS_PASS_TIMER
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|MULTIDELAY
end_ifndef

begin_comment
comment|/*  * Hand-calibrated delay-loop counter.  This was calibrated on an i.MX6 running  * at 792mhz.  It will delay a bit too long on slower processors -- that's  * better than not delaying long enough.  In practice this is unlikely to get  * used much since the clock driver is one of the first to start up, and once  * we're attached the delay loop switches to using the timer hardware.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|int
name|epit_delay_count
init|=
literal|78
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|DELAY
parameter_list|(
name|int
name|usec
parameter_list|)
block|{
name|uint64_t
name|ticks
decl_stmt|;
comment|/* If the timer hardware is not accessible, just use a loop. */
if|if
condition|(
name|epit_sc
operator|==
name|NULL
condition|)
block|{
while|while
condition|(
name|usec
operator|--
operator|>
literal|0
condition|)
for|for
control|(
name|ticks
operator|=
literal|0
init|;
name|ticks
operator|<
name|epit_delay_count
condition|;
operator|++
name|ticks
control|)
name|cpufunc_nullop
argument_list|()
expr_stmt|;
return|return;
block|}
else|else
block|{
name|epit_do_delay
argument_list|(
name|usec
argument_list|,
name|epit_sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

