begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2013 Ian Lepore<ian@freebsd.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * SDHCI driver glue for Freescale i.MX SoC family.  *  * This supports both eSDHC (earlier SoCs) and uSDHC (more recent SoCs).  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<machine/intr.h>
end_include

begin_include
include|#
directive|include
file|<arm/freescale/imx/imx51_ccmvar.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/ofw_bus.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/ofw_bus_subr.h>
end_include

begin_include
include|#
directive|include
file|<dev/mmc/bridge.h>
end_include

begin_include
include|#
directive|include
file|<dev/mmc/mmcreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/mmc/mmcbrvar.h>
end_include

begin_include
include|#
directive|include
file|<dev/sdhci/sdhci.h>
end_include

begin_include
include|#
directive|include
file|"sdhci_if.h"
end_include

begin_struct
struct|struct
name|imx_sdhci_softc
block|{
name|device_t
name|dev
decl_stmt|;
name|struct
name|resource
modifier|*
name|mem_res
decl_stmt|;
name|struct
name|resource
modifier|*
name|irq_res
decl_stmt|;
name|void
modifier|*
name|intr_cookie
decl_stmt|;
name|struct
name|sdhci_slot
name|slot
decl_stmt|;
name|struct
name|callout
name|r1bfix_callout
decl_stmt|;
name|sbintime_t
name|r1bfix_timeout_at
decl_stmt|;
name|uint32_t
name|baseclk_hz
decl_stmt|;
name|uint32_t
name|sdclockreg_freq_bits
decl_stmt|;
name|uint32_t
name|cmd_and_mode
decl_stmt|;
name|uint32_t
name|r1bfix_intmask
decl_stmt|;
name|uint8_t
name|r1bfix_type
decl_stmt|;
name|uint8_t
name|hwtype
decl_stmt|;
name|boolean_t
name|force_card_present
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|R1BFIX_NONE
value|0
end_define

begin_comment
comment|/* No fix needed at next interrupt. */
end_comment

begin_define
define|#
directive|define
name|R1BFIX_NODATA
value|1
end_define

begin_comment
comment|/* Synthesize DATA_END for R1B w/o data. */
end_comment

begin_define
define|#
directive|define
name|R1BFIX_AC12
value|2
end_define

begin_comment
comment|/* Wait for busy after auto command 12. */
end_comment

begin_define
define|#
directive|define
name|HWTYPE_NONE
value|0
end_define

begin_comment
comment|/* Hardware not recognized/supported. */
end_comment

begin_define
define|#
directive|define
name|HWTYPE_ESDHC
value|1
end_define

begin_comment
comment|/* imx5x and earlier. */
end_comment

begin_define
define|#
directive|define
name|HWTYPE_USDHC
value|2
end_define

begin_comment
comment|/* imx6. */
end_comment

begin_define
define|#
directive|define
name|SDHC_WTMK_LVL
value|0x44
end_define

begin_comment
comment|/* Watermark Level register. */
end_comment

begin_define
define|#
directive|define
name|USDHC_MIX_CONTROL
value|0x48
end_define

begin_comment
comment|/* Mix(ed) Control register. */
end_comment

begin_define
define|#
directive|define
name|SDHC_VEND_SPEC
value|0xC0
end_define

begin_comment
comment|/* Vendor-specific register. */
end_comment

begin_define
define|#
directive|define
name|SDHC_VEND_FRC_SDCLK_ON
value|(1<<  8)
end_define

begin_define
define|#
directive|define
name|SDHC_VEND_IPGEN
value|(1<< 11)
end_define

begin_define
define|#
directive|define
name|SDHC_VEND_HCKEN
value|(1<< 12)
end_define

begin_define
define|#
directive|define
name|SDHC_VEND_PEREN
value|(1<< 13)
end_define

begin_define
define|#
directive|define
name|SDHC_PRES_STATE
value|0x24
end_define

begin_define
define|#
directive|define
name|SDHC_PRES_CIHB
value|(1<<  0)
end_define

begin_define
define|#
directive|define
name|SDHC_PRES_CDIHB
value|(1<<  1)
end_define

begin_define
define|#
directive|define
name|SDHC_PRES_DLA
value|(1<<  2)
end_define

begin_define
define|#
directive|define
name|SDHC_PRES_SDSTB
value|(1<<  3)
end_define

begin_define
define|#
directive|define
name|SDHC_PRES_IPGOFF
value|(1<<  4)
end_define

begin_define
define|#
directive|define
name|SDHC_PRES_HCKOFF
value|(1<<  5)
end_define

begin_define
define|#
directive|define
name|SDHC_PRES_PEROFF
value|(1<<  6)
end_define

begin_define
define|#
directive|define
name|SDHC_PRES_SDOFF
value|(1<<  7)
end_define

begin_define
define|#
directive|define
name|SDHC_PRES_WTA
value|(1<<  8)
end_define

begin_define
define|#
directive|define
name|SDHC_PRES_RTA
value|(1<<  9)
end_define

begin_define
define|#
directive|define
name|SDHC_PRES_BWEN
value|(1<< 10)
end_define

begin_define
define|#
directive|define
name|SDHC_PRES_BREN
value|(1<< 11)
end_define

begin_define
define|#
directive|define
name|SDHC_PRES_RTR
value|(1<< 12)
end_define

begin_define
define|#
directive|define
name|SDHC_PRES_CINST
value|(1<< 16)
end_define

begin_define
define|#
directive|define
name|SDHC_PRES_CDPL
value|(1<< 18)
end_define

begin_define
define|#
directive|define
name|SDHC_PRES_WPSPL
value|(1<< 19)
end_define

begin_define
define|#
directive|define
name|SDHC_PRES_CLSL
value|(1<< 23)
end_define

begin_define
define|#
directive|define
name|SDHC_PRES_DLSL_SHIFT
value|24
end_define

begin_define
define|#
directive|define
name|SDHC_PRES_DLSL_MASK
value|(0xffU<< SDHC_PRES_DLSL_SHIFT)
end_define

begin_define
define|#
directive|define
name|SDHC_PROT_CTRL
value|0x28
end_define

begin_define
define|#
directive|define
name|SDHC_PROT_LED
value|(1<< 0)
end_define

begin_define
define|#
directive|define
name|SDHC_PROT_WIDTH_1BIT
value|(0<< 1)
end_define

begin_define
define|#
directive|define
name|SDHC_PROT_WIDTH_4BIT
value|(1<< 1)
end_define

begin_define
define|#
directive|define
name|SDHC_PROT_WIDTH_8BIT
value|(2<< 1)
end_define

begin_define
define|#
directive|define
name|SDHC_PROT_WIDTH_MASK
value|(3<< 1)
end_define

begin_define
define|#
directive|define
name|SDHC_PROT_D3CD
value|(1<< 3)
end_define

begin_define
define|#
directive|define
name|SDHC_PROT_EMODE_BIG
value|(0<< 4)
end_define

begin_define
define|#
directive|define
name|SDHC_PROT_EMODE_HALF
value|(1<< 4)
end_define

begin_define
define|#
directive|define
name|SDHC_PROT_EMODE_LITTLE
value|(2<< 4)
end_define

begin_define
define|#
directive|define
name|SDHC_PROT_EMODE_MASK
value|(3<< 4)
end_define

begin_define
define|#
directive|define
name|SDHC_PROT_SDMA
value|(0<< 8)
end_define

begin_define
define|#
directive|define
name|SDHC_PROT_ADMA1
value|(1<< 8)
end_define

begin_define
define|#
directive|define
name|SDHC_PROT_ADMA2
value|(2<< 8)
end_define

begin_define
define|#
directive|define
name|SDHC_PROT_ADMA264
value|(3<< 8)
end_define

begin_define
define|#
directive|define
name|SDHC_PROT_DMA_MASK
value|(3<< 8)
end_define

begin_define
define|#
directive|define
name|SDHC_PROT_CDTL
value|(1<< 6)
end_define

begin_define
define|#
directive|define
name|SDHC_PROT_CDSS
value|(1<< 7)
end_define

begin_define
define|#
directive|define
name|SDHC_INT_STATUS
value|0x30
end_define

begin_define
define|#
directive|define
name|SDHC_CLK_IPGEN
value|(1<< 0)
end_define

begin_define
define|#
directive|define
name|SDHC_CLK_HCKEN
value|(1<< 1)
end_define

begin_define
define|#
directive|define
name|SDHC_CLK_PEREN
value|(1<< 2)
end_define

begin_define
define|#
directive|define
name|SDHC_CLK_DIVISOR_MASK
value|0x000000f0
end_define

begin_define
define|#
directive|define
name|SDHC_CLK_DIVISOR_SHIFT
value|4
end_define

begin_define
define|#
directive|define
name|SDHC_CLK_PRESCALE_MASK
value|0x0000ff00
end_define

begin_define
define|#
directive|define
name|SDHC_CLK_PRESCALE_SHIFT
value|8
end_define

begin_decl_stmt
specifier|static
name|struct
name|ofw_compat_data
name|compat_data
index|[]
init|=
block|{
block|{
literal|"fsl,imx6q-usdhc"
block|,
name|HWTYPE_USDHC
block|}
block|,
block|{
literal|"fsl,imx6sl-usdhc"
block|,
name|HWTYPE_USDHC
block|}
block|,
block|{
literal|"fsl,imx53-esdhc"
block|,
name|HWTYPE_ESDHC
block|}
block|,
block|{
literal|"fsl,imx51-esdhc"
block|,
name|HWTYPE_ESDHC
block|}
block|,
block|{
name|NULL
block|,
name|HWTYPE_NONE
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|static
name|void
name|imx_sdhc_set_clock
parameter_list|(
name|struct
name|imx_sdhci_softc
modifier|*
name|sc
parameter_list|,
name|int
name|enable
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|imx_sdhci_r1bfix_func
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
specifier|inline
name|uint32_t
name|RD4
parameter_list|(
name|struct
name|imx_sdhci_softc
modifier|*
name|sc
parameter_list|,
name|bus_size_t
name|off
parameter_list|)
block|{
return|return
operator|(
name|bus_read_4
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|,
name|off
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|WR4
parameter_list|(
name|struct
name|imx_sdhci_softc
modifier|*
name|sc
parameter_list|,
name|bus_size_t
name|off
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
name|bus_write_4
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|,
name|off
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|imx_sdhci_read_1
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|,
name|bus_size_t
name|off
parameter_list|)
block|{
name|struct
name|imx_sdhci_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|uint32_t
name|val32
decl_stmt|,
name|wrk32
decl_stmt|;
comment|/* 	 * Most of the things in the standard host control register are in the 	 * hardware's wider protocol control register, but some of the bits are 	 * moved around. 	 */
if|if
condition|(
name|off
operator|==
name|SDHCI_HOST_CONTROL
condition|)
block|{
name|wrk32
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|SDHC_PROT_CTRL
argument_list|)
expr_stmt|;
name|val32
operator|=
name|wrk32
operator|&
operator|(
name|SDHCI_CTRL_LED
operator||
name|SDHCI_CTRL_CARD_DET
operator||
name|SDHCI_CTRL_FORCE_CARD
operator|)
expr_stmt|;
switch|switch
condition|(
name|wrk32
operator|&
name|SDHC_PROT_WIDTH_MASK
condition|)
block|{
case|case
name|SDHC_PROT_WIDTH_1BIT
case|:
comment|/* Value is already 0. */
break|break;
case|case
name|SDHC_PROT_WIDTH_4BIT
case|:
name|val32
operator||=
name|SDHCI_CTRL_4BITBUS
expr_stmt|;
break|break;
case|case
name|SDHC_PROT_WIDTH_8BIT
case|:
name|val32
operator||=
name|SDHCI_CTRL_8BITBUS
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|wrk32
operator|&
name|SDHC_PROT_DMA_MASK
condition|)
block|{
case|case
name|SDHC_PROT_SDMA
case|:
comment|/* Value is already 0. */
break|break;
case|case
name|SDHC_PROT_ADMA1
case|:
comment|/* This value is deprecated, should never appear. */
break|break;
case|case
name|SDHC_PROT_ADMA2
case|:
name|val32
operator||=
name|SDHCI_CTRL_ADMA2
expr_stmt|;
break|break;
case|case
name|SDHC_PROT_ADMA264
case|:
name|val32
operator||=
name|SDHCI_CTRL_ADMA264
expr_stmt|;
break|break;
block|}
return|return
name|val32
return|;
block|}
comment|/* 	 * XXX can't find the bus power on/off knob.  For now we have to say the 	 * power is always on and always set to the same voltage. 	 */
if|if
condition|(
name|off
operator|==
name|SDHCI_POWER_CONTROL
condition|)
block|{
return|return
operator|(
name|SDHCI_POWER_ON
operator||
name|SDHCI_POWER_300
operator|)
return|;
block|}
return|return
operator|(
operator|(
name|RD4
argument_list|(
name|sc
argument_list|,
name|off
operator|&
operator|~
literal|3
argument_list|)
operator|>>
operator|(
name|off
operator|&
literal|3
operator|)
operator|*
literal|8
operator|)
operator|&
literal|0xff
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint16_t
name|imx_sdhci_read_2
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|,
name|bus_size_t
name|off
parameter_list|)
block|{
name|struct
name|imx_sdhci_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|uint32_t
name|val32
decl_stmt|,
name|wrk32
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|hwtype
operator|==
name|HWTYPE_USDHC
condition|)
block|{
comment|/* 		 * The USDHC hardware has nothing in the version register, but 		 * it's v3 compatible with all our translation code. 		 */
if|if
condition|(
name|off
operator|==
name|SDHCI_HOST_VERSION
condition|)
block|{
return|return
operator|(
name|SDHCI_SPEC_300
operator|<<
name|SDHCI_SPEC_VER_SHIFT
operator|)
return|;
block|}
comment|/* 		 * The USDHC hardware moved the transfer mode bits to the mixed 		 * control register, fetch them from there. 		 */
if|if
condition|(
name|off
operator|==
name|SDHCI_TRANSFER_MODE
condition|)
return|return
operator|(
name|RD4
argument_list|(
name|sc
argument_list|,
name|USDHC_MIX_CONTROL
argument_list|)
operator|&
literal|0x37
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|hwtype
operator|==
name|HWTYPE_ESDHC
condition|)
block|{
comment|/* 		 * The ESDHC hardware has the typical 32-bit combined "command 		 * and mode" register that we have to cache so that command 		 * isn't written until after mode.  On a read, just retrieve the 		 * cached values last written. 		 */
if|if
condition|(
name|off
operator|==
name|SDHCI_TRANSFER_MODE
condition|)
block|{
return|return
operator|(
name|sc
operator|->
name|cmd_and_mode
operator|>>
literal|16
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|off
operator|==
name|SDHCI_COMMAND_FLAGS
condition|)
block|{
return|return
operator|(
name|sc
operator|->
name|cmd_and_mode
operator|&
literal|0x0000ffff
operator|)
return|;
block|}
block|}
comment|/* 	 * This hardware only manages one slot.  Synthesize a slot interrupt 	 * status register... if there are any enabled interrupts active they 	 * must be coming from our one and only slot. 	 */
if|if
condition|(
name|off
operator|==
name|SDHCI_SLOT_INT_STATUS
condition|)
block|{
name|val32
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|SDHCI_INT_STATUS
argument_list|)
expr_stmt|;
name|val32
operator|&=
name|RD4
argument_list|(
name|sc
argument_list|,
name|SDHCI_SIGNAL_ENABLE
argument_list|)
expr_stmt|;
return|return
operator|(
name|val32
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
comment|/* 	 * The clock enable bit is in the vendor register and the clock-stable 	 * bit is in the present state register.  Transcribe them as if they 	 * were in the clock control register where they should be. 	 * XXX Is it important that we distinguish between "internal" and "card" 	 * clocks?  Probably not; transcribe the card clock status to both bits. 	 */
if|if
condition|(
name|off
operator|==
name|SDHCI_CLOCK_CONTROL
condition|)
block|{
name|val32
operator|=
literal|0
expr_stmt|;
name|wrk32
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|SDHC_VEND_SPEC
argument_list|)
expr_stmt|;
if|if
condition|(
name|wrk32
operator|&
name|SDHC_VEND_FRC_SDCLK_ON
condition|)
name|val32
operator||=
name|SDHCI_CLOCK_INT_EN
operator||
name|SDHCI_CLOCK_CARD_EN
expr_stmt|;
name|wrk32
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|SDHC_PRES_STATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|wrk32
operator|&
name|SDHC_PRES_SDSTB
condition|)
name|val32
operator||=
name|SDHCI_CLOCK_INT_STABLE
expr_stmt|;
name|val32
operator||=
name|sc
operator|->
name|sdclockreg_freq_bits
expr_stmt|;
return|return
operator|(
name|val32
operator|)
return|;
block|}
return|return
operator|(
operator|(
name|RD4
argument_list|(
name|sc
argument_list|,
name|off
operator|&
operator|~
literal|3
argument_list|)
operator|>>
operator|(
name|off
operator|&
literal|3
operator|)
operator|*
literal|8
operator|)
operator|&
literal|0xffff
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|imx_sdhci_read_4
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|,
name|bus_size_t
name|off
parameter_list|)
block|{
name|struct
name|imx_sdhci_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|uint32_t
name|val32
decl_stmt|,
name|wrk32
decl_stmt|;
name|val32
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|off
argument_list|)
expr_stmt|;
comment|/* 	 * The hardware leaves the base clock frequency out of the capabilities 	 * register; fill it in.  The timeout clock is the same as the active 	 * output sdclock; we indicate that with a quirk setting so don't 	 * populate the timeout frequency bits. 	 * 	 * XXX Turn off (for now) features the hardware can do but this driver 	 * doesn't yet handle (1.8v, suspend/resume, etc). 	 */
if|if
condition|(
name|off
operator|==
name|SDHCI_CAPABILITIES
condition|)
block|{
name|val32
operator|&=
operator|~
name|SDHCI_CAN_VDD_180
expr_stmt|;
name|val32
operator|&=
operator|~
name|SDHCI_CAN_DO_SUSPEND
expr_stmt|;
name|val32
operator||=
name|SDHCI_CAN_DO_8BITBUS
expr_stmt|;
name|val32
operator||=
operator|(
name|sc
operator|->
name|baseclk_hz
operator|/
literal|1000000
operator|)
operator|<<
name|SDHCI_CLOCK_BASE_SHIFT
expr_stmt|;
return|return
operator|(
name|val32
operator|)
return|;
block|}
comment|/* 	 * The hardware moves bits around in the present state register to make 	 * room for all 8 data line state bits.  To translate, mask out all the 	 * bits which are not in the same position in both registers (this also 	 * masks out some freescale-specific bits in locations defined as 	 * reserved by sdhci), then shift the data line and retune request bits 	 * down to their standard locations. 	 */
if|if
condition|(
name|off
operator|==
name|SDHCI_PRESENT_STATE
condition|)
block|{
name|wrk32
operator|=
name|val32
expr_stmt|;
name|val32
operator|&=
literal|0x000F0F07
expr_stmt|;
name|val32
operator||=
operator|(
name|wrk32
operator|>>
literal|4
operator|)
operator|&
name|SDHCI_STATE_DAT_MASK
expr_stmt|;
name|val32
operator||=
operator|(
name|wrk32
operator|>>
literal|9
operator|)
operator|&
name|SDHCI_RETUNE_REQUEST
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|force_card_present
condition|)
name|val32
operator||=
name|SDHCI_CARD_PRESENT
expr_stmt|;
return|return
operator|(
name|val32
operator|)
return|;
block|}
comment|/* 	 * imx_sdhci_intr() can synthesize a DATA_END interrupt following a 	 * command with an R1B response, mix it into the hardware status. 	 */
if|if
condition|(
name|off
operator|==
name|SDHCI_INT_STATUS
condition|)
block|{
return|return
operator|(
name|val32
operator||
name|sc
operator|->
name|r1bfix_intmask
operator|)
return|;
block|}
return|return
name|val32
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|imx_sdhci_read_multi_4
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|,
name|bus_size_t
name|off
parameter_list|,
name|uint32_t
modifier|*
name|data
parameter_list|,
name|bus_size_t
name|count
parameter_list|)
block|{
name|struct
name|imx_sdhci_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|bus_read_multi_4
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|,
name|off
argument_list|,
name|data
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|imx_sdhci_write_1
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|,
name|bus_size_t
name|off
parameter_list|,
name|uint8_t
name|val
parameter_list|)
block|{
name|struct
name|imx_sdhci_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|uint32_t
name|val32
decl_stmt|;
comment|/* 	 * Most of the things in the standard host control register are in the 	 * hardware's wider protocol control register, but some of the bits are 	 * moved around. 	 */
if|if
condition|(
name|off
operator|==
name|SDHCI_HOST_CONTROL
condition|)
block|{
name|val32
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|SDHC_PROT_CTRL
argument_list|)
expr_stmt|;
name|val32
operator|&=
operator|~
operator|(
name|SDHC_PROT_LED
operator||
name|SDHC_PROT_DMA_MASK
operator||
name|SDHC_PROT_WIDTH_MASK
operator||
name|SDHC_PROT_CDTL
operator||
name|SDHC_PROT_CDSS
operator|)
expr_stmt|;
name|val32
operator||=
operator|(
name|val
operator|&
name|SDHCI_CTRL_LED
operator|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|SDHCI_CTRL_8BITBUS
condition|)
name|val32
operator||=
name|SDHC_PROT_WIDTH_8BIT
expr_stmt|;
else|else
name|val32
operator||=
operator|(
name|val
operator|&
name|SDHCI_CTRL_4BITBUS
operator|)
expr_stmt|;
name|val32
operator||=
operator|(
name|val
operator|&
operator|(
name|SDHCI_CTRL_SDMA
operator||
name|SDHCI_CTRL_ADMA2
operator|)
operator|)
operator|<<
literal|4
expr_stmt|;
name|val32
operator||=
operator|(
name|val
operator|&
operator|(
name|SDHCI_CTRL_CARD_DET
operator||
name|SDHCI_CTRL_FORCE_CARD
operator|)
operator|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|SDHC_PROT_CTRL
argument_list|,
name|val32
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* XXX I can't find the bus power on/off knob; do nothing. */
if|if
condition|(
name|off
operator|==
name|SDHCI_POWER_CONTROL
condition|)
block|{
return|return;
block|}
name|val32
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|off
operator|&
operator|~
literal|3
argument_list|)
expr_stmt|;
name|val32
operator|&=
operator|~
operator|(
literal|0xff
operator|<<
operator|(
name|off
operator|&
literal|3
operator|)
operator|*
literal|8
operator|)
expr_stmt|;
name|val32
operator||=
operator|(
name|val
operator|<<
operator|(
name|off
operator|&
literal|3
operator|)
operator|*
literal|8
operator|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|off
operator|&
operator|~
literal|3
argument_list|,
name|val32
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|imx_sdhci_write_2
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|,
name|bus_size_t
name|off
parameter_list|,
name|uint16_t
name|val
parameter_list|)
block|{
name|struct
name|imx_sdhci_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|uint32_t
name|val32
decl_stmt|;
comment|/* The USDHC hardware moved the transfer mode bits to mixed control. */
if|if
condition|(
name|sc
operator|->
name|hwtype
operator|==
name|HWTYPE_USDHC
condition|)
block|{
if|if
condition|(
name|off
operator|==
name|SDHCI_TRANSFER_MODE
condition|)
block|{
name|val32
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|USDHC_MIX_CONTROL
argument_list|)
expr_stmt|;
name|val32
operator|&=
operator|~
literal|0x3f
expr_stmt|;
name|val32
operator||=
name|val
operator|&
literal|0x37
expr_stmt|;
comment|// XXX acmd23 not supported here (or by sdhci driver)
name|WR4
argument_list|(
name|sc
argument_list|,
name|USDHC_MIX_CONTROL
argument_list|,
name|val32
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * The clock control stuff is complex enough to have its own routine 	 * that can both change speeds and en/disable the clock output. Also, 	 * save the register bits in SDHCI format so that we can play them back 	 * in the read2 routine without complex decoding. 	 */
if|if
condition|(
name|off
operator|==
name|SDHCI_CLOCK_CONTROL
condition|)
block|{
name|sc
operator|->
name|sdclockreg_freq_bits
operator|=
name|val
operator|&
literal|0xffc0
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|SDHCI_CLOCK_CARD_EN
condition|)
block|{
name|imx_sdhc_set_clock
argument_list|(
name|sc
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|imx_sdhc_set_clock
argument_list|(
name|sc
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Figure out whether we need to check the DAT0 line for busy status at 	 * interrupt time.  The controller should be doing this, but for some 	 * reason it doesn't.  There are two cases: 	 *  - R1B response with no data transfer should generate a DATA_END (aka 	 *    TRANSFER_COMPLETE) interrupt after waiting for busy, but if 	 *    there's no data transfer there's no DATA_END interrupt.  This is 	 *    documented; they seem to think it's a feature. 	 *  - R1B response after Auto-CMD12 appears to not work, even though 	 *    there's a control bit for it (bit 3) in the vendor register. 	 * When we're starting a command that needs a manual DAT0 line check at 	 * interrupt time, we leave ourselves a note in r1bfix_type so that we 	 * can do the extra work in imx_sdhci_intr(). 	 */
if|if
condition|(
name|off
operator|==
name|SDHCI_COMMAND_FLAGS
condition|)
block|{
if|if
condition|(
name|val
operator|&
name|SDHCI_CMD_DATA
condition|)
block|{
specifier|const
name|uint32_t
name|MBAUTOCMD
init|=
name|SDHCI_TRNS_ACMD12
operator||
name|SDHCI_TRNS_MULTI
decl_stmt|;
name|val32
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|USDHC_MIX_CONTROL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val32
operator|&
name|MBAUTOCMD
operator|)
operator|==
name|MBAUTOCMD
condition|)
name|sc
operator|->
name|r1bfix_type
operator|=
name|R1BFIX_AC12
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|val
operator|&
name|SDHCI_CMD_RESP_MASK
operator|)
operator|==
name|SDHCI_CMD_RESP_SHORT_BUSY
condition|)
block|{
name|WR4
argument_list|(
name|sc
argument_list|,
name|SDHCI_INT_ENABLE
argument_list|,
name|slot
operator|->
name|intmask
operator||
name|SDHCI_INT_RESPONSE
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|SDHCI_SIGNAL_ENABLE
argument_list|,
name|slot
operator|->
name|intmask
operator||
name|SDHCI_INT_RESPONSE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|r1bfix_type
operator|=
name|R1BFIX_NODATA
expr_stmt|;
block|}
block|}
block|}
name|val32
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|off
operator|&
operator|~
literal|3
argument_list|)
expr_stmt|;
name|val32
operator|&=
operator|~
operator|(
literal|0xffff
operator|<<
operator|(
name|off
operator|&
literal|3
operator|)
operator|*
literal|8
operator|)
expr_stmt|;
name|val32
operator||=
operator|(
operator|(
name|val
operator|&
literal|0xffff
operator|)
operator|<<
operator|(
name|off
operator|&
literal|3
operator|)
operator|*
literal|8
operator|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|off
operator|&
operator|~
literal|3
argument_list|,
name|val32
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|imx_sdhci_write_4
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|,
name|bus_size_t
name|off
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
name|struct
name|imx_sdhci_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
comment|/* Clear synthesized interrupts, then pass the value to the hardware. */
if|if
condition|(
name|off
operator|==
name|SDHCI_INT_STATUS
condition|)
block|{
name|sc
operator|->
name|r1bfix_intmask
operator|&=
operator|~
name|val
expr_stmt|;
block|}
name|WR4
argument_list|(
name|sc
argument_list|,
name|off
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|imx_sdhci_write_multi_4
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|,
name|bus_size_t
name|off
parameter_list|,
name|uint32_t
modifier|*
name|data
parameter_list|,
name|bus_size_t
name|count
parameter_list|)
block|{
name|struct
name|imx_sdhci_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|bus_write_multi_4
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|,
name|off
argument_list|,
name|data
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|imx_sdhc_set_clock
parameter_list|(
name|struct
name|imx_sdhci_softc
modifier|*
name|sc
parameter_list|,
name|int
name|enable
parameter_list|)
block|{
name|uint32_t
name|divisor
decl_stmt|,
name|enable_bits
decl_stmt|,
name|enable_reg
decl_stmt|,
name|freq
decl_stmt|,
name|prescale
decl_stmt|,
name|val32
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|hwtype
operator|==
name|HWTYPE_ESDHC
condition|)
block|{
name|divisor
operator|=
operator|(
name|sc
operator|->
name|sdclockreg_freq_bits
operator|>>
name|SDHCI_DIVIDER_SHIFT
operator|)
operator|&
name|SDHCI_DIVIDER_MASK
expr_stmt|;
name|enable_reg
operator|=
name|SDHCI_CLOCK_CONTROL
expr_stmt|;
name|enable_bits
operator|=
name|SDHC_CLK_IPGEN
operator||
name|SDHC_CLK_HCKEN
operator||
name|SDHC_CLK_PEREN
expr_stmt|;
block|}
else|else
block|{
name|divisor
operator|=
operator|(
name|sc
operator|->
name|sdclockreg_freq_bits
operator|>>
name|SDHCI_DIVIDER_SHIFT
operator|)
operator|&
name|SDHCI_DIVIDER_MASK
expr_stmt|;
name|divisor
operator||=
operator|(
operator|(
name|sc
operator|->
name|sdclockreg_freq_bits
operator|>>
name|SDHCI_DIVIDER_HI_SHIFT
operator|)
operator|&
name|SDHCI_DIVIDER_HI_MASK
operator|)
operator|<<
name|SDHCI_DIVIDER_MASK_LEN
expr_stmt|;
name|enable_reg
operator|=
name|SDHCI_CLOCK_CONTROL
expr_stmt|;
name|enable_bits
operator|=
name|SDHC_VEND_IPGEN
operator||
name|SDHC_VEND_HCKEN
operator||
name|SDHC_VEND_PEREN
expr_stmt|;
block|}
name|WR4
argument_list|(
name|sc
argument_list|,
name|SDHC_VEND_SPEC
argument_list|,
name|RD4
argument_list|(
name|sc
argument_list|,
name|SDHC_VEND_SPEC
argument_list|)
operator|&
operator|~
name|SDHC_VEND_FRC_SDCLK_ON
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|enable_reg
argument_list|,
name|RD4
argument_list|(
name|sc
argument_list|,
name|enable_reg
argument_list|)
operator|&
operator|~
name|enable_bits
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|enable
condition|)
return|return;
if|if
condition|(
name|divisor
operator|==
literal|0
condition|)
name|freq
operator|=
name|sc
operator|->
name|baseclk_hz
expr_stmt|;
else|else
name|freq
operator|=
name|sc
operator|->
name|baseclk_hz
operator|/
operator|(
literal|2
operator|*
name|divisor
operator|)
expr_stmt|;
for|for
control|(
name|prescale
operator|=
literal|2
init|;
name|prescale
operator|<
name|freq
operator|/
name|prescale
operator|/
literal|16
condition|;
control|)
name|prescale
operator|<<=
literal|1
expr_stmt|;
for|for
control|(
name|divisor
operator|=
literal|1
init|;
name|freq
operator|<
name|freq
operator|/
name|prescale
operator|/
name|divisor
condition|;
control|)
operator|++
name|divisor
expr_stmt|;
name|prescale
operator|>>=
literal|1
expr_stmt|;
name|divisor
operator|-=
literal|1
expr_stmt|;
name|val32
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|SDHCI_CLOCK_CONTROL
argument_list|)
expr_stmt|;
name|val32
operator|&=
operator|~
name|SDHC_CLK_DIVISOR_MASK
expr_stmt|;
name|val32
operator||=
name|divisor
operator|<<
name|SDHC_CLK_DIVISOR_SHIFT
expr_stmt|;
name|val32
operator|&=
operator|~
name|SDHC_CLK_PRESCALE_MASK
expr_stmt|;
name|val32
operator||=
name|prescale
operator|<<
name|SDHC_CLK_PRESCALE_SHIFT
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|SDHCI_CLOCK_CONTROL
argument_list|,
name|val32
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|enable_reg
argument_list|,
name|RD4
argument_list|(
name|sc
argument_list|,
name|enable_reg
argument_list|)
operator||
name|enable_bits
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|SDHC_VEND_SPEC
argument_list|,
name|RD4
argument_list|(
name|sc
argument_list|,
name|SDHC_VEND_SPEC
argument_list|)
operator||
name|SDHC_VEND_FRC_SDCLK_ON
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|boolean_t
name|imx_sdhci_r1bfix_is_wait_done
parameter_list|(
name|struct
name|imx_sdhci_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|inhibit
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|slot
operator|.
name|mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* 	 * Check the DAT0 line status using both the DLA (data line active) and 	 * CDIHB (data inhibit) bits in the present state register.  In theory 	 * just DLA should do the trick,  but in practice it takes both.  If the 	 * DAT0 line is still being held and we're not yet beyond the timeout 	 * point, just schedule another callout to check again later. 	 */
name|inhibit
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|SDHC_PRES_STATE
argument_list|)
operator|&
operator|(
name|SDHC_PRES_DLA
operator||
name|SDHC_PRES_CDIHB
operator|)
expr_stmt|;
if|if
condition|(
name|inhibit
operator|&&
name|getsbinuptime
argument_list|()
operator|<
name|sc
operator|->
name|r1bfix_timeout_at
condition|)
block|{
name|callout_reset_sbt
argument_list|(
operator|&
name|sc
operator|->
name|r1bfix_callout
argument_list|,
name|SBT_1MS
argument_list|,
literal|0
argument_list|,
name|imx_sdhci_r1bfix_func
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
comment|/* 	 * If we reach this point with the inhibit bits still set, we've got a 	 * timeout, synthesize a DATA_TIMEOUT interrupt.  Otherwise the DAT0 	 * line has been released, and we synthesize a DATA_END, and if the type 	 * of fix needed was on a command-without-data we also now add in the 	 * original INT_RESPONSE that we suppressed earlier. 	 */
if|if
condition|(
name|inhibit
condition|)
name|sc
operator|->
name|r1bfix_intmask
operator||=
name|SDHCI_INT_DATA_TIMEOUT
expr_stmt|;
else|else
block|{
name|sc
operator|->
name|r1bfix_intmask
operator||=
name|SDHCI_INT_DATA_END
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|r1bfix_type
operator|==
name|R1BFIX_NODATA
condition|)
name|sc
operator|->
name|r1bfix_intmask
operator||=
name|SDHCI_INT_RESPONSE
expr_stmt|;
block|}
name|sc
operator|->
name|r1bfix_type
operator|=
name|R1BFIX_NONE
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|imx_sdhci_r1bfix_func
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|imx_sdhci_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|boolean_t
name|r1bwait_done
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|slot
operator|.
name|mtx
argument_list|)
expr_stmt|;
name|r1bwait_done
operator|=
name|imx_sdhci_r1bfix_is_wait_done
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|slot
operator|.
name|mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|r1bwait_done
condition|)
name|sdhci_generic_intr
argument_list|(
operator|&
name|sc
operator|->
name|slot
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|imx_sdhci_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|imx_sdhci_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|uint32_t
name|intmask
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|slot
operator|.
name|mtx
argument_list|)
expr_stmt|;
comment|/* 	 * Manually check the DAT0 line for R1B response types that the 	 * controller fails to handle properly.  The controller asserts the done 	 * interrupt while the card is still asserting busy with the DAT0 line. 	 * 	 * We check DAT0 immediately because most of the time, especially on a 	 * read, the card will actually be done by time we get here.  If it's 	 * not, then the wait_done routine will schedule a callout to re-check 	 * periodically until it is done.  In that case we clear the interrupt 	 * out of the hardware now so that we can present it later when the DAT0 	 * line is released. 	 * 	 * If we need to wait for the the DAT0 line to be released, we set up a 	 * timeout point 250ms in the future.  This number comes from the SD 	 * spec, which allows a command to take that long.  In the real world, 	 * cards tend to take 10-20ms for a long-running command such as a write 	 * or erase that spans two pages. 	 */
switch|switch
condition|(
name|sc
operator|->
name|r1bfix_type
condition|)
block|{
case|case
name|R1BFIX_NODATA
case|:
name|intmask
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|SDHC_INT_STATUS
argument_list|)
operator|&
name|SDHCI_INT_RESPONSE
expr_stmt|;
break|break;
case|case
name|R1BFIX_AC12
case|:
name|intmask
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|SDHC_INT_STATUS
argument_list|)
operator|&
name|SDHCI_INT_DATA_END
expr_stmt|;
break|break;
default|default:
name|intmask
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|intmask
condition|)
block|{
name|sc
operator|->
name|r1bfix_timeout_at
operator|=
name|getsbinuptime
argument_list|()
operator|+
literal|250
operator|*
name|SBT_1MS
expr_stmt|;
if|if
condition|(
operator|!
name|imx_sdhci_r1bfix_is_wait_done
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|WR4
argument_list|(
name|sc
argument_list|,
name|SDHC_INT_STATUS
argument_list|,
name|intmask
argument_list|)
expr_stmt|;
name|bus_barrier
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|,
name|SDHC_INT_STATUS
argument_list|,
literal|4
argument_list|,
name|BUS_SPACE_BARRIER_WRITE
argument_list|)
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|slot
operator|.
name|mtx
argument_list|)
expr_stmt|;
name|sdhci_generic_intr
argument_list|(
operator|&
name|sc
operator|->
name|slot
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|imx_sdhci_get_ro
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|imx_sdhci_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|imx_sdhci_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|imx_sdhci_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|rid
decl_stmt|,
name|err
decl_stmt|;
name|phandle_t
name|node
decl_stmt|;
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|sc
operator|->
name|hwtype
operator|=
name|ofw_bus_search_compatible
argument_list|(
name|dev
argument_list|,
name|compat_data
argument_list|)
operator|->
name|ocd_data
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|hwtype
operator|==
name|HWTYPE_NONE
condition|)
name|panic
argument_list|(
literal|"Impossible: not compatible in imx_sdhci_attach()"
argument_list|)
expr_stmt|;
name|rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|mem_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|mem_res
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot allocate memory window\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|irq_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|irq_res
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot allocate interrupt\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|,
name|INTR_TYPE_BIO
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|imx_sdhci_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|intr_cookie
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot setup interrupt handler\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|sc
operator|->
name|slot
operator|.
name|quirks
operator||=
name|SDHCI_QUIRK_DATA_TIMEOUT_USES_SDCLK
expr_stmt|;
comment|/* 	 * DMA is not really broken, I just haven't implemented it yet. 	 */
name|sc
operator|->
name|slot
operator|.
name|quirks
operator||=
name|SDHCI_QUIRK_BROKEN_DMA
expr_stmt|;
comment|/* 	 * Set the buffer watermark level to 128 words (512 bytes) for both read 	 * and write.  The hardware has a restriction that when the read or 	 * write ready status is asserted, that means you can read exactly the 	 * number of words set in the watermark register before you have to 	 * re-check the status and potentially wait for more data.  The main 	 * sdhci driver provides no hook for doing status checking on less than 	 * a full block boundary, so we set the watermark level to be a full 	 * block.  Reads and writes where the block size is less than the 	 * watermark size will work correctly too, no need to change the 	 * watermark for different size blocks.  However, 128 is the maximum 	 * allowed for the watermark, so PIO is limitted to 512 byte blocks 	 * (which works fine for SD cards, may be a problem for SDIO some day). 	 * 	 * XXX need named constants for this stuff. 	 */
name|WR4
argument_list|(
name|sc
argument_list|,
name|SDHC_WTMK_LVL
argument_list|,
literal|0x08800880
argument_list|)
expr_stmt|;
comment|/* XXX get imx6 clock frequency from CCM */
if|if
condition|(
name|sc
operator|->
name|hwtype
operator|==
name|HWTYPE_USDHC
condition|)
block|{
name|sc
operator|->
name|baseclk_hz
operator|=
literal|200000000
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|hwtype
operator|==
name|HWTYPE_ESDHC
condition|)
block|{
name|sc
operator|->
name|baseclk_hz
operator|=
name|imx51_get_clock
argument_list|(
name|IMX51CLK_PERCLK_ROOT
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If the slot is flagged with the non-removable property, set our flag 	 * to always force the SDHCI_CARD_PRESENT bit on. 	 * 	 * XXX Workaround for gpio-based card detect... 	 * 	 * We don't have gpio support yet.  If there's a cd-gpios property just 	 * force the SDHCI_CARD_PRESENT bit on for now.  If there isn't really a 	 * card there it will fail to probe at the mmc layer and nothing bad 	 * happens except instantiating an mmcN device for an empty slot. 	 */
name|node
operator|=
name|ofw_bus_get_node
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|OF_hasprop
argument_list|(
name|node
argument_list|,
literal|"non-removable"
argument_list|)
condition|)
name|sc
operator|->
name|force_card_present
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|OF_hasprop
argument_list|(
name|node
argument_list|,
literal|"cd-gpios"
argument_list|)
condition|)
block|{
comment|/* XXX put real gpio hookup here. */
name|sc
operator|->
name|force_card_present
operator|=
name|true
expr_stmt|;
block|}
name|callout_init
argument_list|(
operator|&
name|sc
operator|->
name|r1bfix_callout
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|sdhci_init_slot
argument_list|(
name|dev
argument_list|,
operator|&
name|sc
operator|->
name|slot
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bus_generic_probe
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|bus_generic_attach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sdhci_start_slot
argument_list|(
operator|&
name|sc
operator|->
name|slot
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
if|if
condition|(
name|sc
operator|->
name|intr_cookie
condition|)
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|,
name|sc
operator|->
name|intr_cookie
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|irq_res
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mem_res
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|mem_res
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|imx_sdhci_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ofw_bus_status_okay
argument_list|(
name|dev
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
switch|switch
condition|(
name|ofw_bus_search_compatible
argument_list|(
name|dev
argument_list|,
name|compat_data
argument_list|)
operator|->
name|ocd_data
condition|)
block|{
case|case
name|HWTYPE_ESDHC
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Freescale eSDHC controller"
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
case|case
name|HWTYPE_USDHC
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Freescale uSDHC controller"
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
default|default:
break|break;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|imx_sdhci_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|imx_sdhci_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|imx_sdhci_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|imx_sdhci_detach
argument_list|)
block|,
comment|/* Bus interface */
name|DEVMETHOD
argument_list|(
name|bus_read_ivar
argument_list|,
name|sdhci_generic_read_ivar
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_write_ivar
argument_list|,
name|sdhci_generic_write_ivar
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_print_child
argument_list|,
name|bus_generic_print_child
argument_list|)
block|,
comment|/* MMC bridge interface */
name|DEVMETHOD
argument_list|(
name|mmcbr_update_ios
argument_list|,
name|sdhci_generic_update_ios
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|mmcbr_request
argument_list|,
name|sdhci_generic_request
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|mmcbr_get_ro
argument_list|,
name|imx_sdhci_get_ro
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|mmcbr_acquire_host
argument_list|,
name|sdhci_generic_acquire_host
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|mmcbr_release_host
argument_list|,
name|sdhci_generic_release_host
argument_list|)
block|,
comment|/* SDHCI registers accessors */
name|DEVMETHOD
argument_list|(
name|sdhci_read_1
argument_list|,
name|imx_sdhci_read_1
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|sdhci_read_2
argument_list|,
name|imx_sdhci_read_2
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|sdhci_read_4
argument_list|,
name|imx_sdhci_read_4
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|sdhci_read_multi_4
argument_list|,
name|imx_sdhci_read_multi_4
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|sdhci_write_1
argument_list|,
name|imx_sdhci_write_1
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|sdhci_write_2
argument_list|,
name|imx_sdhci_write_2
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|sdhci_write_4
argument_list|,
name|imx_sdhci_write_4
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|sdhci_write_multi_4
argument_list|,
name|imx_sdhci_write_multi_4
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|imx_sdhci_devclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|imx_sdhci_driver
init|=
block|{
literal|"sdhci_imx"
block|,
name|imx_sdhci_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|imx_sdhci_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|sdhci_imx
argument_list|,
name|simplebus
argument_list|,
name|imx_sdhci_driver
argument_list|,
name|imx_sdhci_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|sdhci_imx
argument_list|,
name|sdhci
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

