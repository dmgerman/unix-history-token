begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2013 Ian Lepore<ian@freebsd.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"opt_platform.h"
end_include

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/reboot.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/devmap.h>
end_include

begin_include
include|#
directive|include
file|<machine/intr.h>
end_include

begin_include
include|#
directive|include
file|<machine/machdep.h>
end_include

begin_include
include|#
directive|include
file|<arm/arm/mpcore_timervar.h>
end_include

begin_include
include|#
directive|include
file|<arm/freescale/imx/imx6_anatopreg.h>
end_include

begin_include
include|#
directive|include
file|<arm/freescale/imx/imx6_anatopvar.h>
end_include

begin_include
include|#
directive|include
file|<arm/freescale/imx/imx_machdep.h>
end_include

begin_include
include|#
directive|include
file|<dev/fdt/fdt_common.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/openfirm.h>
end_include

begin_decl_stmt
name|struct
name|fdt_fixup_entry
name|fdt_fixup_table
index|[]
init|=
block|{
block|{
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|gpio1_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Work around the linux workaround for imx6 erratum 006687, in which some  * ethernet interrupts don't go to the GPC and thus won't wake the system from  * Wait mode. We don't use Wait mode (which halts the GIC, leaving only GPC  * interrupts able to wake the system), so we don't experience the bug at all.  * The linux workaround is to reconfigure GPIO1_6 as the ENET interrupt by  * writing magic values to an undocumented IOMUX register, then letting the gpio  * interrupt driver notify the ethernet driver.  We'll be able to do all that  * (even though we don't need to) once the INTRNG project is committed and the  * imx_gpio driver becomes an interrupt driver.  Until then, this crazy little  * workaround watches for requests to map an interrupt 6 with the interrupt  * controller node referring to gpio1, and it substitutes the proper ffec  * interrupt number.  */
end_comment

begin_function
specifier|static
name|int
name|imx6_decode_fdt
parameter_list|(
name|uint32_t
name|iparent
parameter_list|,
name|uint32_t
modifier|*
name|intr
parameter_list|,
name|int
modifier|*
name|interrupt
parameter_list|,
name|int
modifier|*
name|trig
parameter_list|,
name|int
modifier|*
name|pol
parameter_list|)
block|{
if|if
condition|(
name|fdt32_to_cpu
argument_list|(
name|intr
index|[
literal|0
index|]
argument_list|)
operator|==
literal|6
operator|&&
name|OF_node_from_xref
argument_list|(
name|iparent
argument_list|)
operator|==
name|gpio1_node
condition|)
block|{
operator|*
name|interrupt
operator|=
literal|150
expr_stmt|;
operator|*
name|trig
operator|=
name|INTR_TRIGGER_CONFORM
expr_stmt|;
operator|*
name|pol
operator|=
name|INTR_POLARITY_CONFORM
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|gic_decode_fdt
argument_list|(
name|iparent
argument_list|,
name|intr
argument_list|,
name|interrupt
argument_list|,
name|trig
argument_list|,
name|pol
argument_list|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|fdt_pic_decode_t
name|fdt_pic_table
index|[]
init|=
block|{
operator|&
name|imx6_decode_fdt
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|vm_offset_t
name|initarm_lastaddr
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|arm_devmap_lastaddr
argument_list|()
operator|)
return|;
block|}
end_function

begin_function
name|void
name|initarm_early_init
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Inform the MPCore timer driver that its clock is variable. */
name|arm_tmr_change_frequency
argument_list|(
name|ARM_TMR_FREQUENCY_VARIES
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|initarm_gpio_init
parameter_list|(
name|void
parameter_list|)
block|{  }
end_function

begin_function
name|void
name|initarm_late_init
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Cache the gpio1 node handle for imx6_decode_fdt() workaround code. */
name|gpio1_node
operator|=
name|OF_node_from_xref
argument_list|(
name|OF_finddevice
argument_list|(
literal|"/soc/aips-bus@02000000/gpio@0209c000"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set up static device mappings.  *  * This attempts to cover the most-used devices with 1MB section mappings, which  * is good for performance (uses fewer TLB entries for device access).  *  * ARMMP covers the interrupt controller, MPCore timers, global timer, and the  * L2 cache controller.  Most of the 1MB range is unused reserved space.  *  * AIPS1/AIPS2 cover most of the on-chip devices such as uart, spi, i2c, etc.  *  * Notably not mapped right now are HDMI, GPU, and other devices below ARMMP in  * the memory map.  When we get support for graphics it might make sense to  * static map some of that area.  Be careful with other things in that area such  * as OCRAM that probably shouldn't be mapped as PTE_DEVICE memory.  */
end_comment

begin_function
name|int
name|initarm_devmap_init
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|uint32_t
name|IMX6_ARMMP_PHYS
init|=
literal|0x00a00000
decl_stmt|;
specifier|const
name|uint32_t
name|IMX6_ARMMP_SIZE
init|=
literal|0x00100000
decl_stmt|;
specifier|const
name|uint32_t
name|IMX6_AIPS1_PHYS
init|=
literal|0x02000000
decl_stmt|;
specifier|const
name|uint32_t
name|IMX6_AIPS1_SIZE
init|=
literal|0x00100000
decl_stmt|;
specifier|const
name|uint32_t
name|IMX6_AIPS2_PHYS
init|=
literal|0x02100000
decl_stmt|;
specifier|const
name|uint32_t
name|IMX6_AIPS2_SIZE
init|=
literal|0x00100000
decl_stmt|;
name|arm_devmap_add_entry
argument_list|(
name|IMX6_ARMMP_PHYS
argument_list|,
name|IMX6_ARMMP_SIZE
argument_list|)
expr_stmt|;
name|arm_devmap_add_entry
argument_list|(
name|IMX6_AIPS1_PHYS
argument_list|,
name|IMX6_AIPS1_SIZE
argument_list|)
expr_stmt|;
name|arm_devmap_add_entry
argument_list|(
name|IMX6_AIPS2_PHYS
argument_list|,
name|IMX6_AIPS2_SIZE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|cpu_reset
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|uint32_t
name|IMX6_WDOG_CR_PHYS
init|=
literal|0x020bc000
decl_stmt|;
name|imx_wdog_cpu_reset
argument_list|(
name|IMX6_WDOG_CR_PHYS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Determine what flavor of imx6 we're running on.  *  * This code is based on the way u-boot does it.  Information found on the web  * indicates that Freescale themselves were the original source of this logic,  * including the strange check for number of CPUs in the SCU configuration  * register, which is apparently needed on some revisions of the SOLO.  *  * According to the documentation, there is such a thing as an i.MX6 Dual  * (non-lite flavor).  However, Freescale doesn't seem to have assigned it a  * number or provided any logic to handle it in their detection code.  *  * Note that the ANALOG_DIGPROG and SCU configuration registers are not  * documented in the chip reference manual.  (SCU configuration is mentioned,  * but not mapped out in detail.)  I think the bottom two bits of the scu config  * register may be ncpu-1.  *  * This hasn't been tested yet on a dual[-lite].  *  * On a solo:  *      digprog    = 0x00610001  *      hwsoc      = 0x00000062  *      scu config = 0x00000500  * On a quad:  *      digprog    = 0x00630002  *      hwsoc      = 0x00000063  *      scu config = 0x00005503  */
end_comment

begin_function
name|u_int
name|imx_soc_type
parameter_list|()
block|{
name|uint32_t
name|digprog
decl_stmt|,
name|hwsoc
decl_stmt|;
name|uint32_t
modifier|*
name|pcr
decl_stmt|;
specifier|static
name|u_int
name|soctype
decl_stmt|;
specifier|const
name|vm_offset_t
name|SCU_CONFIG_PHYSADDR
init|=
literal|0x00a00004
decl_stmt|;
define|#
directive|define
name|HWSOC_MX6SL
value|0x60
define|#
directive|define
name|HWSOC_MX6DL
value|0x61
define|#
directive|define
name|HWSOC_MX6SOLO
value|0x62
define|#
directive|define
name|HWSOC_MX6Q
value|0x63
if|if
condition|(
name|soctype
operator|!=
literal|0
condition|)
return|return
operator|(
name|soctype
operator|)
return|;
name|digprog
operator|=
name|imx6_anatop_read_4
argument_list|(
name|IMX6_ANALOG_DIGPROG_SL
argument_list|)
expr_stmt|;
name|hwsoc
operator|=
operator|(
name|digprog
operator|>>
name|IMX6_ANALOG_DIGPROG_SOCTYPE_SHIFT
operator|)
operator|&
name|IMX6_ANALOG_DIGPROG_SOCTYPE_MASK
expr_stmt|;
if|if
condition|(
name|hwsoc
operator|!=
name|HWSOC_MX6SL
condition|)
block|{
name|digprog
operator|=
name|imx6_anatop_read_4
argument_list|(
name|IMX6_ANALOG_DIGPROG
argument_list|)
expr_stmt|;
name|hwsoc
operator|=
operator|(
name|digprog
operator|&
name|IMX6_ANALOG_DIGPROG_SOCTYPE_MASK
operator|)
operator|>>
name|IMX6_ANALOG_DIGPROG_SOCTYPE_SHIFT
expr_stmt|;
comment|/*printf("digprog = 0x%08x\n", digprog);*/
if|if
condition|(
name|hwsoc
operator|==
name|HWSOC_MX6DL
condition|)
block|{
name|pcr
operator|=
name|arm_devmap_ptov
argument_list|(
name|SCU_CONFIG_PHYSADDR
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcr
operator|!=
name|NULL
condition|)
block|{
comment|/*printf("scu config = 0x%08x\n", *pcr);*/
if|if
condition|(
operator|(
operator|*
name|pcr
operator|&
literal|0x03
operator|)
operator|==
literal|0
condition|)
block|{
name|hwsoc
operator|=
name|HWSOC_MX6SOLO
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* printf("hwsoc 0x%08x\n", hwsoc); */
switch|switch
condition|(
name|hwsoc
condition|)
block|{
case|case
name|HWSOC_MX6SL
case|:
name|soctype
operator|=
name|IMXSOC_6SL
expr_stmt|;
break|break;
case|case
name|HWSOC_MX6SOLO
case|:
name|soctype
operator|=
name|IMXSOC_6S
expr_stmt|;
break|break;
case|case
name|HWSOC_MX6DL
case|:
name|soctype
operator|=
name|IMXSOC_6DL
expr_stmt|;
break|break;
case|case
name|HWSOC_MX6Q
case|:
name|soctype
operator|=
name|IMXSOC_6Q
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"imx_soc_type: Don't understand hwsoc 0x%02x, "
literal|"digprog 0x%08x; assuming IMXSOC_6Q\n"
argument_list|,
name|hwsoc
argument_list|,
name|digprog
argument_list|)
expr_stmt|;
name|soctype
operator|=
name|IMXSOC_6Q
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|soctype
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Early putc routine for EARLY_PRINTF support.  To use, add to kernel config:  *   option SOCDEV_PA=0x02000000  *   option SOCDEV_VA=0x02000000  *   option EARLY_PRINTF  * Resist the temptation to change the #if 0 to #ifdef EARLY_PRINTF here. It  * makes sense now, but if multiple SOCs do that it will make early_putc another  * duplicate symbol to be eliminated on the path to a generic kernel.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void  imx6_early_putc(int c) { 	volatile uint32_t * UART_STAT_REG = (uint32_t *)0x02020098; 	volatile uint32_t * UART_TX_REG   = (uint32_t *)0x02020040; 	const uint32_t      UART_TXRDY    = (1<< 3);  	while ((*UART_STAT_REG& UART_TXRDY) == 0) 		continue; 	*UART_TX_REG = c; } early_putc_t *early_putc = imx6_early_putc;
endif|#
directive|endif
end_endif

end_unit

