begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2013 Ian Lepore<ian@freebsd.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"opt_platform.h"
end_include

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/reboot.h>
end_include

begin_include
include|#
directive|include
file|<sys/devmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/intr.h>
end_include

begin_include
include|#
directive|include
file|<machine/machdep.h>
end_include

begin_include
include|#
directive|include
file|<machine/platformvar.h>
end_include

begin_include
include|#
directive|include
file|<arm/arm/mpcore_timervar.h>
end_include

begin_include
include|#
directive|include
file|<arm/freescale/imx/imx6_anatopreg.h>
end_include

begin_include
include|#
directive|include
file|<arm/freescale/imx/imx6_anatopvar.h>
end_include

begin_include
include|#
directive|include
file|<arm/freescale/imx/imx_machdep.h>
end_include

begin_include
include|#
directive|include
file|<dev/fdt/fdt_common.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/openfirm.h>
end_include

begin_include
include|#
directive|include
file|<arm/freescale/imx/imx6_machdep.h>
end_include

begin_include
include|#
directive|include
file|"platform_if.h"
end_include

begin_include
include|#
directive|include
file|"platform_pl310_if.h"
end_include

begin_decl_stmt
specifier|static
name|platform_attach_t
name|imx6_attach
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|platform_devmap_init_t
name|imx6_devmap_init
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|platform_late_init_t
name|imx6_late_init
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|platform_cpu_reset_t
name|imx6_cpu_reset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Fix FDT data related to interrupts.  *  * Driven by the needs of linux and its drivers (as always), the published FDT  * data for imx6 now sets the interrupt parent for most devices to the GPC  * interrupt controller, which is for use when the chip is in deep-sleep mode.  * We don't support deep sleep or have a GPC-PIC driver; we need all interrupts  * to be handled by the GIC.  *  * Luckily, the change to the FDT data was to assign the GPC as the interrupt  * parent for the soc node and letting that get inherited by all other devices  * (except a few that directly name GIC as their interrupt parent).  So we can  * set the world right by just changing the interrupt-parent property of the soc  * node to refer to GIC instead of GPC.  This will get us by until we write our  * own GPC driver (or until linux changes its mind and the FDT data again).  *  * We validate that we have data that looks like we expect before changing it:  *  - SOC node exists and has GPC as its interrupt parent.  *  - GPC node exists and has GIC as its interrupt parent.  *  - GIC node exists and is its own interrupt parent or has no parent.  *  * This applies to all models of imx6.  Luckily all of them have the devices  * involved at the same addresses on the same buses, so we don't need any  * per-soc logic.  We handle this at platform attach time rather than via the  * fdt_fixup_table, because the latter requires matching on the FDT "model"  * property, and this applies to all boards including those not yet invented.  */
end_comment

begin_function
specifier|static
name|void
name|fix_fdt_interrupt_data
parameter_list|(
name|void
parameter_list|)
block|{
name|phandle_t
name|gicipar
decl_stmt|,
name|gicnode
decl_stmt|,
name|gicxref
decl_stmt|;
name|phandle_t
name|gpcipar
decl_stmt|,
name|gpcnode
decl_stmt|,
name|gpcxref
decl_stmt|;
name|phandle_t
name|socipar
decl_stmt|,
name|socnode
decl_stmt|;
name|int
name|result
decl_stmt|;
name|socnode
operator|=
name|OF_finddevice
argument_list|(
literal|"/soc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|socnode
operator|==
operator|-
literal|1
condition|)
return|return;
name|result
operator|=
name|OF_getencprop
argument_list|(
name|socnode
argument_list|,
literal|"interrupt-parent"
argument_list|,
operator|&
name|socipar
argument_list|,
sizeof|sizeof
argument_list|(
name|socipar
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|<=
literal|0
condition|)
return|return;
comment|/* GIC node may be child of soc node, or appear directly at root. */
name|gicnode
operator|=
name|OF_finddevice
argument_list|(
literal|"/soc/interrupt-controller@00a01000"
argument_list|)
expr_stmt|;
if|if
condition|(
name|gicnode
operator|==
operator|-
literal|1
condition|)
block|{
name|gicnode
operator|=
name|OF_finddevice
argument_list|(
literal|"/interrupt-controller@00a01000"
argument_list|)
expr_stmt|;
if|if
condition|(
name|gicnode
operator|==
operator|-
literal|1
condition|)
return|return;
block|}
name|gicxref
operator|=
name|OF_xref_from_node
argument_list|(
name|gicnode
argument_list|)
expr_stmt|;
comment|/* If gic node has no parent, pretend it is its own parent. */
name|result
operator|=
name|OF_getencprop
argument_list|(
name|gicnode
argument_list|,
literal|"interrupt-parent"
argument_list|,
operator|&
name|gicipar
argument_list|,
sizeof|sizeof
argument_list|(
name|gicipar
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|<=
literal|0
condition|)
name|gicipar
operator|=
name|gicxref
expr_stmt|;
name|gpcnode
operator|=
name|OF_finddevice
argument_list|(
literal|"/soc/aips-bus@02000000/gpc@020dc000"
argument_list|)
expr_stmt|;
if|if
condition|(
name|gpcnode
operator|==
operator|-
literal|1
condition|)
return|return;
name|result
operator|=
name|OF_getencprop
argument_list|(
name|gpcnode
argument_list|,
literal|"interrupt-parent"
argument_list|,
operator|&
name|gpcipar
argument_list|,
sizeof|sizeof
argument_list|(
name|gpcipar
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|<=
literal|0
condition|)
return|return;
name|gpcxref
operator|=
name|OF_xref_from_node
argument_list|(
name|gpcnode
argument_list|)
expr_stmt|;
if|if
condition|(
name|socipar
operator|!=
name|gpcxref
operator|||
name|gpcipar
operator|!=
name|gicxref
operator|||
name|gicipar
operator|!=
name|gicxref
condition|)
return|return;
name|gicxref
operator|=
name|cpu_to_fdt32
argument_list|(
name|gicxref
argument_list|)
expr_stmt|;
name|OF_setprop
argument_list|(
name|socnode
argument_list|,
literal|"interrupt-parent"
argument_list|,
operator|&
name|gicxref
argument_list|,
sizeof|sizeof
argument_list|(
name|gicxref
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|imx6_attach
parameter_list|(
name|platform_t
name|plat
parameter_list|)
block|{
comment|/* Fix soc interrupt-parent property. */
name|fix_fdt_interrupt_data
argument_list|()
expr_stmt|;
comment|/* Inform the MPCore timer driver that its clock is variable. */
name|arm_tmr_change_frequency
argument_list|(
name|ARM_TMR_FREQUENCY_VARIES
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|imx6_late_init
parameter_list|(
name|platform_t
name|plat
parameter_list|)
block|{
specifier|const
name|uint32_t
name|IMX6_WDOG_SR_PHYS
init|=
literal|0x020bc004
decl_stmt|;
name|imx_wdog_init_last_reset
argument_list|(
name|IMX6_WDOG_SR_PHYS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set up static device mappings.  *  * This attempts to cover the most-used devices with 1MB section mappings, which  * is good for performance (uses fewer TLB entries for device access).  *  * ARMMP covers the interrupt controller, MPCore timers, global timer, and the  * L2 cache controller.  Most of the 1MB range is unused reserved space.  *  * AIPS1/AIPS2 cover most of the on-chip devices such as uart, spi, i2c, etc.  *  * Notably not mapped right now are HDMI, GPU, and other devices below ARMMP in  * the memory map.  When we get support for graphics it might make sense to  * static map some of that area.  Be careful with other things in that area such  * as OCRAM that probably shouldn't be mapped as VM_MEMATTR_DEVICE memory.  */
end_comment

begin_function
specifier|static
name|int
name|imx6_devmap_init
parameter_list|(
name|platform_t
name|plat
parameter_list|)
block|{
specifier|const
name|uint32_t
name|IMX6_ARMMP_PHYS
init|=
literal|0x00a00000
decl_stmt|;
specifier|const
name|uint32_t
name|IMX6_ARMMP_SIZE
init|=
literal|0x00100000
decl_stmt|;
specifier|const
name|uint32_t
name|IMX6_AIPS1_PHYS
init|=
literal|0x02000000
decl_stmt|;
specifier|const
name|uint32_t
name|IMX6_AIPS1_SIZE
init|=
literal|0x00100000
decl_stmt|;
specifier|const
name|uint32_t
name|IMX6_AIPS2_PHYS
init|=
literal|0x02100000
decl_stmt|;
specifier|const
name|uint32_t
name|IMX6_AIPS2_SIZE
init|=
literal|0x00100000
decl_stmt|;
name|devmap_add_entry
argument_list|(
name|IMX6_ARMMP_PHYS
argument_list|,
name|IMX6_ARMMP_SIZE
argument_list|)
expr_stmt|;
name|devmap_add_entry
argument_list|(
name|IMX6_AIPS1_PHYS
argument_list|,
name|IMX6_AIPS1_SIZE
argument_list|)
expr_stmt|;
name|devmap_add_entry
argument_list|(
name|IMX6_AIPS2_PHYS
argument_list|,
name|IMX6_AIPS2_SIZE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|imx6_cpu_reset
parameter_list|(
name|platform_t
name|plat
parameter_list|)
block|{
specifier|const
name|uint32_t
name|IMX6_WDOG_CR_PHYS
init|=
literal|0x020bc000
decl_stmt|;
name|imx_wdog_cpu_reset
argument_list|(
name|IMX6_WDOG_CR_PHYS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Determine what flavor of imx6 we're running on.  *  * This code is based on the way u-boot does it.  Information found on the web  * indicates that Freescale themselves were the original source of this logic,  * including the strange check for number of CPUs in the SCU configuration  * register, which is apparently needed on some revisions of the SOLO.  *  * According to the documentation, there is such a thing as an i.MX6 Dual  * (non-lite flavor).  However, Freescale doesn't seem to have assigned it a  * number or provided any logic to handle it in their detection code.  *  * Note that the ANALOG_DIGPROG and SCU configuration registers are not  * documented in the chip reference manual.  (SCU configuration is mentioned,  * but not mapped out in detail.)  I think the bottom two bits of the scu config  * register may be ncpu-1.  *  * This hasn't been tested yet on a dual[-lite].  *  * On a solo:  *      digprog    = 0x00610001  *      hwsoc      = 0x00000062  *      scu config = 0x00000500  * On a quad:  *      digprog    = 0x00630002  *      hwsoc      = 0x00000063  *      scu config = 0x00005503  */
end_comment

begin_function
name|u_int
name|imx_soc_type
parameter_list|(
name|void
parameter_list|)
block|{
name|uint32_t
name|digprog
decl_stmt|,
name|hwsoc
decl_stmt|;
name|uint32_t
modifier|*
name|pcr
decl_stmt|;
specifier|static
name|u_int
name|soctype
decl_stmt|;
specifier|const
name|vm_offset_t
name|SCU_CONFIG_PHYSADDR
init|=
literal|0x00a00004
decl_stmt|;
define|#
directive|define
name|HWSOC_MX6SL
value|0x60
define|#
directive|define
name|HWSOC_MX6DL
value|0x61
define|#
directive|define
name|HWSOC_MX6SOLO
value|0x62
define|#
directive|define
name|HWSOC_MX6Q
value|0x63
define|#
directive|define
name|HWSOC_MX6UL
value|0x64
if|if
condition|(
name|soctype
operator|!=
literal|0
condition|)
return|return
operator|(
name|soctype
operator|)
return|;
name|digprog
operator|=
name|imx6_anatop_read_4
argument_list|(
name|IMX6_ANALOG_DIGPROG_SL
argument_list|)
expr_stmt|;
name|hwsoc
operator|=
operator|(
name|digprog
operator|>>
name|IMX6_ANALOG_DIGPROG_SOCTYPE_SHIFT
operator|)
operator|&
name|IMX6_ANALOG_DIGPROG_SOCTYPE_MASK
expr_stmt|;
if|if
condition|(
name|hwsoc
operator|!=
name|HWSOC_MX6SL
condition|)
block|{
name|digprog
operator|=
name|imx6_anatop_read_4
argument_list|(
name|IMX6_ANALOG_DIGPROG
argument_list|)
expr_stmt|;
name|hwsoc
operator|=
operator|(
name|digprog
operator|&
name|IMX6_ANALOG_DIGPROG_SOCTYPE_MASK
operator|)
operator|>>
name|IMX6_ANALOG_DIGPROG_SOCTYPE_SHIFT
expr_stmt|;
comment|/*printf("digprog = 0x%08x\n", digprog);*/
if|if
condition|(
name|hwsoc
operator|==
name|HWSOC_MX6DL
condition|)
block|{
name|pcr
operator|=
name|devmap_ptov
argument_list|(
name|SCU_CONFIG_PHYSADDR
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcr
operator|!=
name|NULL
condition|)
block|{
comment|/*printf("scu config = 0x%08x\n", *pcr);*/
if|if
condition|(
operator|(
operator|*
name|pcr
operator|&
literal|0x03
operator|)
operator|==
literal|0
condition|)
block|{
name|hwsoc
operator|=
name|HWSOC_MX6SOLO
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* printf("hwsoc 0x%08x\n", hwsoc); */
switch|switch
condition|(
name|hwsoc
condition|)
block|{
case|case
name|HWSOC_MX6SL
case|:
name|soctype
operator|=
name|IMXSOC_6SL
expr_stmt|;
break|break;
case|case
name|HWSOC_MX6SOLO
case|:
name|soctype
operator|=
name|IMXSOC_6S
expr_stmt|;
break|break;
case|case
name|HWSOC_MX6DL
case|:
name|soctype
operator|=
name|IMXSOC_6DL
expr_stmt|;
break|break;
case|case
name|HWSOC_MX6Q
case|:
name|soctype
operator|=
name|IMXSOC_6Q
expr_stmt|;
break|break;
case|case
name|HWSOC_MX6UL
case|:
name|soctype
operator|=
name|IMXSOC_6UL
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"imx_soc_type: Don't understand hwsoc 0x%02x, "
literal|"digprog 0x%08x; assuming IMXSOC_6Q\n"
argument_list|,
name|hwsoc
argument_list|,
name|digprog
argument_list|)
expr_stmt|;
name|soctype
operator|=
name|IMXSOC_6Q
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|soctype
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Early putc routine for EARLY_PRINTF support.  To use, add to kernel config:  *   option SOCDEV_PA=0x02000000  *   option SOCDEV_VA=0x02000000  *   option EARLY_PRINTF  * Resist the temptation to change the #if 0 to #ifdef EARLY_PRINTF here. It  * makes sense now, but if multiple SOCs do that it will make early_putc another  * duplicate symbol to be eliminated on the path to a generic kernel.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void  imx6_early_putc(int c) { 	volatile uint32_t * UART_STAT_REG = (uint32_t *)0x02020098; 	volatile uint32_t * UART_TX_REG   = (uint32_t *)0x02020040; 	const uint32_t      UART_TXRDY    = (1<< 3);  	while ((*UART_STAT_REG& UART_TXRDY) == 0) 		continue; 	*UART_TX_REG = c; } early_putc_t *early_putc = imx6_early_putc;
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|platform_method_t
name|imx6_methods
index|[]
init|=
block|{
name|PLATFORMMETHOD
argument_list|(
name|platform_attach
argument_list|,
name|imx6_attach
argument_list|)
block|,
name|PLATFORMMETHOD
argument_list|(
name|platform_devmap_init
argument_list|,
name|imx6_devmap_init
argument_list|)
block|,
name|PLATFORMMETHOD
argument_list|(
name|platform_late_init
argument_list|,
name|imx6_late_init
argument_list|)
block|,
name|PLATFORMMETHOD
argument_list|(
name|platform_cpu_reset
argument_list|,
name|imx6_cpu_reset
argument_list|)
block|,
ifdef|#
directive|ifdef
name|SMP
name|PLATFORMMETHOD
argument_list|(
name|platform_mp_start_ap
argument_list|,
name|imx6_mp_start_ap
argument_list|)
block|,
name|PLATFORMMETHOD
argument_list|(
name|platform_mp_setmaxid
argument_list|,
name|imx6_mp_setmaxid
argument_list|)
block|,
endif|#
directive|endif
name|PLATFORMMETHOD
argument_list|(
name|platform_pl310_init
argument_list|,
name|imx6_pl310_init
argument_list|)
block|,
name|PLATFORMMETHOD_END
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|FDT_PLATFORM_DEF2
argument_list|(
name|imx6
argument_list|,
name|imx6s
argument_list|,
literal|"i.MX6 Solo"
argument_list|,
literal|0
argument_list|,
literal|"fsl,imx6s"
argument_list|,
literal|80
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|FDT_PLATFORM_DEF2
argument_list|(
name|imx6
argument_list|,
name|imx6d
argument_list|,
literal|"i.MX6 Dual"
argument_list|,
literal|0
argument_list|,
literal|"fsl,imx6dl"
argument_list|,
literal|80
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|FDT_PLATFORM_DEF2
argument_list|(
name|imx6
argument_list|,
name|imx6q
argument_list|,
literal|"i.MX6 Quad"
argument_list|,
literal|0
argument_list|,
literal|"fsl,imx6q"
argument_list|,
literal|80
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|FDT_PLATFORM_DEF2
argument_list|(
name|imx6
argument_list|,
name|imx6ul
argument_list|,
literal|"i.MX6 UltraLite"
argument_list|,
literal|0
argument_list|,
literal|"fsl,imx6ul"
argument_list|,
literal|67
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

