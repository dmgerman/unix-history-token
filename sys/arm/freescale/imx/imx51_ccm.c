begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: imx51_ccm.c,v 1.1 2012/04/17 09:33:31 bsh Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright (c) 2010, 2011, 2012  Genetec Corporation.  All rights reserved.  * Written by Hashimoto Kenichi for Genetec Corporation.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY GENETEC CORPORATION ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL GENETEC CORPORATION  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*-  * Copyright (c) 2012, 2013 The FreeBSD Foundation  * All rights reserved.  *  * Portions of this software were developed by Oleksandr Rybalko  * under sponsorship from the FreeBSD Foundation.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1.	Redistributions of source code must retain the above copyright  *	notice, this list of conditions and the following disclaimer.  * 2.	Redistributions in binary form must reproduce the above copyright  *	notice, this list of conditions and the following disclaimer in the  *	documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Clock Controller Module (CCM)  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/intr.h>
end_include

begin_include
include|#
directive|include
file|<dev/fdt/fdt_common.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/openfirm.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/ofw_bus.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/ofw_bus_subr.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/fdt.h>
end_include

begin_include
include|#
directive|include
file|<arm/freescale/imx/imx51_ccmvar.h>
end_include

begin_include
include|#
directive|include
file|<arm/freescale/imx/imx51_ccmreg.h>
end_include

begin_include
include|#
directive|include
file|<arm/freescale/imx/imx51_dpllreg.h>
end_include

begin_include
include|#
directive|include
file|<arm/freescale/imx/imx_ccmvar.h>
end_include

begin_include
include|#
directive|include
file|<arm/freescale/imx/imx_machdep.h>
end_include

begin_define
define|#
directive|define
name|IMXCCMDEBUG
end_define

begin_undef
undef|#
directive|undef
name|IMXCCMDEBUG
end_undef

begin_ifndef
ifndef|#
directive|ifndef
name|IMX51_OSC_FREQ
end_ifndef

begin_define
define|#
directive|define
name|IMX51_OSC_FREQ
value|(24 * 1000 * 1000)
end_define

begin_comment
comment|/* 24MHz */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|IMX51_CKIL_FREQ
end_ifndef

begin_define
define|#
directive|define
name|IMX51_CKIL_FREQ
value|32768
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|imxccm_softc
block|{
name|device_t
name|sc_dev
decl_stmt|;
name|struct
name|resource
modifier|*
name|res
index|[
literal|7
index|]
decl_stmt|;
name|u_int64_t
name|pll_freq
index|[
name|IMX51_N_DPLLS
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|imxccm_softc
modifier|*
name|ccm_softc
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|uint64_t
name|imx51_get_pll_freq
parameter_list|(
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|imxccm_match
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|imxccm_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|imxccm_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|imxccm_match
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|imxccm_attach
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|imxccm_driver
init|=
block|{
literal|"imxccm"
block|,
name|imxccm_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|imxccm_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|imxccm_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|EARLY_DRIVER_MODULE
argument_list|(
name|imxccm
argument_list|,
name|simplebus
argument_list|,
name|imxccm_driver
argument_list|,
name|imxccm_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|BUS_PASS_CPU
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|resource_spec
name|imxccm_spec
index|[]
init|=
block|{
block|{
name|SYS_RES_MEMORY
block|,
literal|0
block|,
name|RF_ACTIVE
block|}
block|,
comment|/* Global registers */
block|{
name|SYS_RES_MEMORY
block|,
literal|1
block|,
name|RF_ACTIVE
block|}
block|,
comment|/* DPLLIP1 */
block|{
name|SYS_RES_MEMORY
block|,
literal|2
block|,
name|RF_ACTIVE
block|}
block|,
comment|/* DPLLIP2 */
block|{
name|SYS_RES_MEMORY
block|,
literal|3
block|,
name|RF_ACTIVE
block|}
block|,
comment|/* DPLLIP3 */
block|{
name|SYS_RES_IRQ
block|,
literal|0
block|,
name|RF_ACTIVE
block|}
block|,
comment|/* 71 */
block|{
name|SYS_RES_IRQ
block|,
literal|1
block|,
name|RF_ACTIVE
block|}
block|,
comment|/* 72 */
block|{
operator|-
literal|1
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|imxccm_match
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ofw_bus_status_okay
argument_list|(
name|dev
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
operator|!
name|ofw_bus_is_compatible
argument_list|(
name|dev
argument_list|,
literal|"fsl,imx51-ccm"
argument_list|)
operator|&&
operator|!
name|ofw_bus_is_compatible
argument_list|(
name|dev
argument_list|,
literal|"fsl,imx53-ccm"
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Freescale Clock Control Module"
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|imxccm_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|imxccm_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_dev
operator|=
name|dev
expr_stmt|;
if|if
condition|(
name|bus_alloc_resources
argument_list|(
name|dev
argument_list|,
name|imxccm_spec
argument_list|,
name|sc
operator|->
name|res
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not allocate resources\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|ccm_softc
operator|=
name|sc
expr_stmt|;
name|imx51_get_pll_freq
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|imx51_get_pll_freq
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|imx51_get_pll_freq
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"PLL1=%lluMHz, PLL2=%lluMHz, PLL3=%lluMHz\n"
argument_list|,
name|sc
operator|->
name|pll_freq
index|[
literal|0
index|]
operator|/
literal|1000000
argument_list|,
name|sc
operator|->
name|pll_freq
index|[
literal|1
index|]
operator|/
literal|1000000
argument_list|,
name|sc
operator|->
name|pll_freq
index|[
literal|2
index|]
operator|/
literal|1000000
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"CPU clock=%d, UART clock=%d\n"
argument_list|,
name|imx51_get_clock
argument_list|(
name|IMX51CLK_ARM_ROOT
argument_list|)
argument_list|,
name|imx51_get_clock
argument_list|(
name|IMX51CLK_UART_CLK_ROOT
argument_list|)
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"mainbus clock=%d, ahb clock=%d ipg clock=%d perclk=%d\n"
argument_list|,
name|imx51_get_clock
argument_list|(
name|IMX51CLK_MAIN_BUS_CLK
argument_list|)
argument_list|,
name|imx51_get_clock
argument_list|(
name|IMX51CLK_AHB_CLK_ROOT
argument_list|)
argument_list|,
name|imx51_get_clock
argument_list|(
name|IMX51CLK_IPG_CLK_ROOT
argument_list|)
argument_list|,
name|imx51_get_clock
argument_list|(
name|IMX51CLK_PERCLK_ROOT
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|u_int
name|imx51_get_clock
parameter_list|(
name|enum
name|imx51_clock
name|clk
parameter_list|)
block|{
name|u_int
name|freq
decl_stmt|;
name|u_int
name|sel
decl_stmt|;
name|uint32_t
name|cacrr
decl_stmt|;
comment|/* ARM clock root register */
name|uint32_t
name|ccsr
decl_stmt|;
name|uint32_t
name|cscdr1
decl_stmt|;
name|uint32_t
name|cscmr1
decl_stmt|;
name|uint32_t
name|cbcdr
decl_stmt|;
name|uint32_t
name|cbcmr
decl_stmt|;
name|uint32_t
name|cdcr
decl_stmt|;
if|if
condition|(
name|ccm_softc
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
switch|switch
condition|(
name|clk
condition|)
block|{
case|case
name|IMX51CLK_PLL1
case|:
case|case
name|IMX51CLK_PLL2
case|:
case|case
name|IMX51CLK_PLL3
case|:
return|return
name|ccm_softc
operator|->
name|pll_freq
index|[
name|clk
operator|-
name|IMX51CLK_PLL1
index|]
return|;
case|case
name|IMX51CLK_PLL1SW
case|:
name|ccsr
operator|=
name|bus_read_4
argument_list|(
name|ccm_softc
operator|->
name|res
index|[
literal|0
index|]
argument_list|,
name|CCMC_CCSR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ccsr
operator|&
name|CCSR_PLL1_SW_CLK_SEL
operator|)
operator|==
literal|0
condition|)
return|return
name|ccm_softc
operator|->
name|pll_freq
index|[
literal|1
operator|-
literal|1
index|]
return|;
comment|/* step clock */
comment|/* FALLTHROUGH */
case|case
name|IMX51CLK_PLL1STEP
case|:
name|ccsr
operator|=
name|bus_read_4
argument_list|(
name|ccm_softc
operator|->
name|res
index|[
literal|0
index|]
argument_list|,
name|CCMC_CCSR
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|ccsr
operator|&
name|CCSR_STEP_SEL_MASK
operator|)
operator|>>
name|CCSR_STEP_SEL_SHIFT
condition|)
block|{
case|case
literal|0
case|:
return|return
name|imx51_get_clock
argument_list|(
name|IMX51CLK_LP_APM
argument_list|)
return|;
case|case
literal|1
case|:
return|return
literal|0
return|;
comment|/* XXX PLL bypass clock */
case|case
literal|2
case|:
return|return
name|ccm_softc
operator|->
name|pll_freq
index|[
literal|2
operator|-
literal|1
index|]
operator|/
operator|(
literal|1
operator|+
operator|(
operator|(
name|ccsr
operator|&
name|CCSR_PLL2_DIV_PODF_MASK
operator|)
operator|>>
name|CCSR_PLL2_DIV_PODF_SHIFT
operator|)
operator|)
return|;
case|case
literal|3
case|:
return|return
name|ccm_softc
operator|->
name|pll_freq
index|[
literal|3
operator|-
literal|1
index|]
operator|/
operator|(
literal|1
operator|+
operator|(
operator|(
name|ccsr
operator|&
name|CCSR_PLL3_DIV_PODF_MASK
operator|)
operator|>>
name|CCSR_PLL3_DIV_PODF_SHIFT
operator|)
operator|)
return|;
block|}
comment|/*NOTREACHED*/
case|case
name|IMX51CLK_PLL2SW
case|:
name|ccsr
operator|=
name|bus_read_4
argument_list|(
name|ccm_softc
operator|->
name|res
index|[
literal|0
index|]
argument_list|,
name|CCMC_CCSR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ccsr
operator|&
name|CCSR_PLL2_SW_CLK_SEL
operator|)
operator|==
literal|0
condition|)
return|return
name|imx51_get_clock
argument_list|(
name|IMX51CLK_PLL2
argument_list|)
return|;
return|return
literal|0
return|;
comment|/* XXX PLL2 bypass clk */
case|case
name|IMX51CLK_PLL3SW
case|:
name|ccsr
operator|=
name|bus_read_4
argument_list|(
name|ccm_softc
operator|->
name|res
index|[
literal|0
index|]
argument_list|,
name|CCMC_CCSR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ccsr
operator|&
name|CCSR_PLL3_SW_CLK_SEL
operator|)
operator|==
literal|0
condition|)
return|return
name|imx51_get_clock
argument_list|(
name|IMX51CLK_PLL3
argument_list|)
return|;
return|return
literal|0
return|;
comment|/* XXX PLL3 bypass clk */
case|case
name|IMX51CLK_LP_APM
case|:
name|ccsr
operator|=
name|bus_read_4
argument_list|(
name|ccm_softc
operator|->
name|res
index|[
literal|0
index|]
argument_list|,
name|CCMC_CCSR
argument_list|)
expr_stmt|;
return|return
operator|(
name|ccsr
operator|&
name|CCSR_LP_APM
operator|)
condition|?
name|imx51_get_clock
argument_list|(
name|IMX51CLK_FPM
argument_list|)
else|:
name|IMX51_OSC_FREQ
return|;
case|case
name|IMX51CLK_ARM_ROOT
case|:
name|freq
operator|=
name|imx51_get_clock
argument_list|(
name|IMX51CLK_PLL1SW
argument_list|)
expr_stmt|;
name|cacrr
operator|=
name|bus_read_4
argument_list|(
name|ccm_softc
operator|->
name|res
index|[
literal|0
index|]
argument_list|,
name|CCMC_CACRR
argument_list|)
expr_stmt|;
return|return
name|freq
operator|/
operator|(
name|cacrr
operator|+
literal|1
operator|)
return|;
comment|/* ... */
case|case
name|IMX51CLK_MAIN_BUS_CLK_SRC
case|:
name|cbcdr
operator|=
name|bus_read_4
argument_list|(
name|ccm_softc
operator|->
name|res
index|[
literal|0
index|]
argument_list|,
name|CCMC_CBCDR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cbcdr
operator|&
name|CBCDR_PERIPH_CLK_SEL
operator|)
operator|==
literal|0
condition|)
name|freq
operator|=
name|imx51_get_clock
argument_list|(
name|IMX51CLK_PLL2SW
argument_list|)
expr_stmt|;
else|else
block|{
name|freq
operator|=
literal|0
expr_stmt|;
name|cbcmr
operator|=
name|bus_read_4
argument_list|(
name|ccm_softc
operator|->
name|res
index|[
literal|0
index|]
argument_list|,
name|CCMC_CBCMR
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|cbcmr
operator|&
name|CBCMR_PERIPH_APM_SEL_MASK
operator|)
operator|>>
name|CBCMR_PERIPH_APM_SEL_SHIFT
condition|)
block|{
case|case
literal|0
case|:
name|freq
operator|=
name|imx51_get_clock
argument_list|(
name|IMX51CLK_PLL1SW
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|freq
operator|=
name|imx51_get_clock
argument_list|(
name|IMX51CLK_PLL3SW
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|freq
operator|=
name|imx51_get_clock
argument_list|(
name|IMX51CLK_LP_APM
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* XXX: error */
break|break;
block|}
block|}
return|return
name|freq
return|;
case|case
name|IMX51CLK_MAIN_BUS_CLK
case|:
name|freq
operator|=
name|imx51_get_clock
argument_list|(
name|IMX51CLK_MAIN_BUS_CLK_SRC
argument_list|)
expr_stmt|;
name|cdcr
operator|=
name|bus_read_4
argument_list|(
name|ccm_softc
operator|->
name|res
index|[
literal|0
index|]
argument_list|,
name|CCMC_CDCR
argument_list|)
expr_stmt|;
return|return
name|freq
operator|/
operator|(
literal|1
operator|+
operator|(
operator|(
name|cdcr
operator|&
name|CDCR_PERIPH_CLK_DVFS_PODF_MASK
operator|)
operator|>>
name|CDCR_PERIPH_CLK_DVFS_PODF_SHIFT
operator|)
operator|)
return|;
case|case
name|IMX51CLK_AHB_CLK_ROOT
case|:
name|freq
operator|=
name|imx51_get_clock
argument_list|(
name|IMX51CLK_MAIN_BUS_CLK
argument_list|)
expr_stmt|;
name|cbcdr
operator|=
name|bus_read_4
argument_list|(
name|ccm_softc
operator|->
name|res
index|[
literal|0
index|]
argument_list|,
name|CCMC_CBCDR
argument_list|)
expr_stmt|;
return|return
name|freq
operator|/
operator|(
literal|1
operator|+
operator|(
operator|(
name|cbcdr
operator|&
name|CBCDR_AHB_PODF_MASK
operator|)
operator|>>
name|CBCDR_AHB_PODF_SHIFT
operator|)
operator|)
return|;
case|case
name|IMX51CLK_IPG_CLK_ROOT
case|:
name|freq
operator|=
name|imx51_get_clock
argument_list|(
name|IMX51CLK_AHB_CLK_ROOT
argument_list|)
expr_stmt|;
name|cbcdr
operator|=
name|bus_read_4
argument_list|(
name|ccm_softc
operator|->
name|res
index|[
literal|0
index|]
argument_list|,
name|CCMC_CBCDR
argument_list|)
expr_stmt|;
return|return
name|freq
operator|/
operator|(
literal|1
operator|+
operator|(
operator|(
name|cbcdr
operator|&
name|CBCDR_IPG_PODF_MASK
operator|)
operator|>>
name|CBCDR_IPG_PODF_SHIFT
operator|)
operator|)
return|;
case|case
name|IMX51CLK_PERCLK_ROOT
case|:
name|cbcmr
operator|=
name|bus_read_4
argument_list|(
name|ccm_softc
operator|->
name|res
index|[
literal|0
index|]
argument_list|,
name|CCMC_CBCMR
argument_list|)
expr_stmt|;
if|if
condition|(
name|cbcmr
operator|&
name|CBCMR_PERCLK_IPG_SEL
condition|)
return|return
name|imx51_get_clock
argument_list|(
name|IMX51CLK_IPG_CLK_ROOT
argument_list|)
return|;
if|if
condition|(
name|cbcmr
operator|&
name|CBCMR_PERCLK_LP_APM_SEL
condition|)
name|freq
operator|=
name|imx51_get_clock
argument_list|(
name|IMX51CLK_LP_APM
argument_list|)
expr_stmt|;
else|else
name|freq
operator|=
name|imx51_get_clock
argument_list|(
name|IMX51CLK_MAIN_BUS_CLK_SRC
argument_list|)
expr_stmt|;
name|cbcdr
operator|=
name|bus_read_4
argument_list|(
name|ccm_softc
operator|->
name|res
index|[
literal|0
index|]
argument_list|,
name|CCMC_CBCDR
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IMXCCMDEBUG
name|printf
argument_list|(
literal|"cbcmr=%x cbcdr=%x\n"
argument_list|,
name|cbcmr
argument_list|,
name|cbcdr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|freq
operator|/=
literal|1
operator|+
operator|(
operator|(
name|cbcdr
operator|&
name|CBCDR_PERCLK_PRED1_MASK
operator|)
operator|>>
name|CBCDR_PERCLK_PRED1_SHIFT
operator|)
expr_stmt|;
name|freq
operator|/=
literal|1
operator|+
operator|(
operator|(
name|cbcdr
operator|&
name|CBCDR_PERCLK_PRED2_MASK
operator|)
operator|>>
name|CBCDR_PERCLK_PRED2_SHIFT
operator|)
expr_stmt|;
name|freq
operator|/=
literal|1
operator|+
operator|(
operator|(
name|cbcdr
operator|&
name|CBCDR_PERCLK_PODF_MASK
operator|)
operator|>>
name|CBCDR_PERCLK_PODF_SHIFT
operator|)
expr_stmt|;
return|return
name|freq
return|;
case|case
name|IMX51CLK_UART_CLK_ROOT
case|:
name|cscdr1
operator|=
name|bus_read_4
argument_list|(
name|ccm_softc
operator|->
name|res
index|[
literal|0
index|]
argument_list|,
name|CCMC_CSCDR1
argument_list|)
expr_stmt|;
name|cscmr1
operator|=
name|bus_read_4
argument_list|(
name|ccm_softc
operator|->
name|res
index|[
literal|0
index|]
argument_list|,
name|CCMC_CSCMR1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IMXCCMDEBUG
name|printf
argument_list|(
literal|"cscdr1=%x cscmr1=%x\n"
argument_list|,
name|cscdr1
argument_list|,
name|cscmr1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sel
operator|=
operator|(
name|cscmr1
operator|&
name|CSCMR1_UART_CLK_SEL_MASK
operator|)
operator|>>
name|CSCMR1_UART_CLK_SEL_SHIFT
expr_stmt|;
name|freq
operator|=
literal|0
expr_stmt|;
comment|/* shut up GCC */
switch|switch
condition|(
name|sel
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|1
case|:
case|case
literal|2
case|:
name|freq
operator|=
name|imx51_get_clock
argument_list|(
name|IMX51CLK_PLL1SW
operator|+
name|sel
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|freq
operator|=
name|imx51_get_clock
argument_list|(
name|IMX51CLK_LP_APM
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|freq
operator|/
operator|(
literal|1
operator|+
operator|(
operator|(
name|cscdr1
operator|&
name|CSCDR1_UART_CLK_PRED_MASK
operator|)
operator|>>
name|CSCDR1_UART_CLK_PRED_SHIFT
operator|)
operator|)
operator|/
operator|(
literal|1
operator|+
operator|(
operator|(
name|cscdr1
operator|&
name|CSCDR1_UART_CLK_PODF_MASK
operator|)
operator|>>
name|CSCDR1_UART_CLK_PODF_SHIFT
operator|)
operator|)
return|;
case|case
name|IMX51CLK_IPU_HSP_CLK_ROOT
case|:
name|freq
operator|=
literal|0
expr_stmt|;
name|cbcmr
operator|=
name|bus_read_4
argument_list|(
name|ccm_softc
operator|->
name|res
index|[
literal|0
index|]
argument_list|,
name|CCMC_CBCMR
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|cbcmr
operator|&
name|CBCMR_IPU_HSP_CLK_SEL_MASK
operator|)
operator|>>
name|CBCMR_IPU_HSP_CLK_SEL_SHIFT
condition|)
block|{
case|case
literal|0
case|:
name|freq
operator|=
name|imx51_get_clock
argument_list|(
name|IMX51CLK_ARM_AXI_A_CLK
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|freq
operator|=
name|imx51_get_clock
argument_list|(
name|IMX51CLK_ARM_AXI_B_CLK
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|freq
operator|=
name|imx51_get_clock
argument_list|(
name|IMX51CLK_EMI_SLOW_CLK_ROOT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|freq
operator|=
name|imx51_get_clock
argument_list|(
name|IMX51CLK_AHB_CLK_ROOT
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|freq
return|;
default|default:
name|device_printf
argument_list|(
name|ccm_softc
operator|->
name|sc_dev
argument_list|,
literal|"clock %d: not supported yet\n"
argument_list|,
name|clk
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|imx51_get_pll_freq
parameter_list|(
name|u_int
name|pll_no
parameter_list|)
block|{
name|uint32_t
name|dp_ctrl
decl_stmt|;
name|uint32_t
name|dp_op
decl_stmt|;
name|uint32_t
name|dp_mfd
decl_stmt|;
name|uint32_t
name|dp_mfn
decl_stmt|;
name|uint32_t
name|mfi
decl_stmt|;
name|int32_t
name|mfn
decl_stmt|;
name|uint32_t
name|mfd
decl_stmt|;
name|uint32_t
name|pdf
decl_stmt|;
name|uint32_t
name|ccr
decl_stmt|;
name|uint64_t
name|freq
init|=
literal|0
decl_stmt|;
name|u_int
name|ref
init|=
literal|0
decl_stmt|;
name|KASSERT
argument_list|(
literal|1
operator|<=
name|pll_no
operator|&&
name|pll_no
operator|<=
name|IMX51_N_DPLLS
argument_list|,
operator|(
literal|"Wrong PLL id"
operator|)
argument_list|)
expr_stmt|;
name|dp_ctrl
operator|=
name|bus_read_4
argument_list|(
name|ccm_softc
operator|->
name|res
index|[
name|pll_no
index|]
argument_list|,
name|DPLL_DP_CTL
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp_ctrl
operator|&
name|DP_CTL_HFSM
condition|)
block|{
name|dp_op
operator|=
name|bus_read_4
argument_list|(
name|ccm_softc
operator|->
name|res
index|[
name|pll_no
index|]
argument_list|,
name|DPLL_DP_HFS_OP
argument_list|)
expr_stmt|;
name|dp_mfd
operator|=
name|bus_read_4
argument_list|(
name|ccm_softc
operator|->
name|res
index|[
name|pll_no
index|]
argument_list|,
name|DPLL_DP_HFS_MFD
argument_list|)
expr_stmt|;
name|dp_mfn
operator|=
name|bus_read_4
argument_list|(
name|ccm_softc
operator|->
name|res
index|[
name|pll_no
index|]
argument_list|,
name|DPLL_DP_HFS_MFN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dp_op
operator|=
name|bus_read_4
argument_list|(
name|ccm_softc
operator|->
name|res
index|[
name|pll_no
index|]
argument_list|,
name|DPLL_DP_OP
argument_list|)
expr_stmt|;
name|dp_mfd
operator|=
name|bus_read_4
argument_list|(
name|ccm_softc
operator|->
name|res
index|[
name|pll_no
index|]
argument_list|,
name|DPLL_DP_MFD
argument_list|)
expr_stmt|;
name|dp_mfn
operator|=
name|bus_read_4
argument_list|(
name|ccm_softc
operator|->
name|res
index|[
name|pll_no
index|]
argument_list|,
name|DPLL_DP_MFN
argument_list|)
expr_stmt|;
block|}
name|pdf
operator|=
name|dp_op
operator|&
name|DP_OP_PDF_MASK
expr_stmt|;
name|mfi
operator|=
name|max
argument_list|(
literal|5
argument_list|,
operator|(
name|dp_op
operator|&
name|DP_OP_MFI_MASK
operator|)
operator|>>
name|DP_OP_MFI_SHIFT
argument_list|)
expr_stmt|;
name|mfd
operator|=
name|dp_mfd
expr_stmt|;
if|if
condition|(
name|dp_mfn
operator|&
literal|0x04000000
condition|)
comment|/* 27bit signed value */
name|mfn
operator|=
call|(
name|uint32_t
call|)
argument_list|(
literal|0xf8000000
operator||
name|dp_mfn
argument_list|)
expr_stmt|;
else|else
name|mfn
operator|=
name|dp_mfn
expr_stmt|;
switch|switch
condition|(
name|dp_ctrl
operator|&
name|DP_CTL_REF_CLK_SEL_MASK
condition|)
block|{
case|case
name|DP_CTL_REF_CLK_SEL_COSC
case|:
comment|/* Internal Oscillator */
comment|/* TODO: get from FDT "fsl,imx-osc" */
name|ref
operator|=
literal|24000000
expr_stmt|;
comment|/* IMX51_OSC_FREQ */
break|break;
case|case
name|DP_CTL_REF_CLK_SEL_FPM
case|:
name|ccr
operator|=
name|bus_read_4
argument_list|(
name|ccm_softc
operator|->
name|res
index|[
literal|0
index|]
argument_list|,
name|CCMC_CCR
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccr
operator|&
name|CCR_FPM_MULT
condition|)
comment|/* TODO: get from FDT "fsl,imx-ckil" */
name|ref
operator|=
literal|32768
operator|*
literal|1024
expr_stmt|;
else|else
comment|/* TODO: get from FDT "fsl,imx-ckil" */
name|ref
operator|=
literal|32768
operator|*
literal|512
expr_stmt|;
break|break;
default|default:
name|ref
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|dp_ctrl
operator|&
name|DP_CTL_REF_CLK_DIV
condition|)
name|ref
operator|/=
literal|2
expr_stmt|;
name|ref
operator|*=
literal|4
expr_stmt|;
name|freq
operator|=
operator|(
name|int64_t
operator|)
name|ref
operator|*
name|mfi
operator|+
operator|(
name|int64_t
operator|)
name|ref
operator|*
name|mfn
operator|/
operator|(
name|mfd
operator|+
literal|1
operator|)
expr_stmt|;
name|freq
operator|/=
name|pdf
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|dp_ctrl
operator|&
name|DP_CTL_DPDCK0_2_EN
operator|)
condition|)
name|freq
operator|/=
literal|2
expr_stmt|;
ifdef|#
directive|ifdef
name|IMXCCMDEBUG
name|printf
argument_list|(
literal|"ref: %dKHz "
argument_list|,
name|ref
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"dp_ctl: %08x "
argument_list|,
name|dp_ctrl
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"pdf: %3d "
argument_list|,
name|pdf
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"mfi: %3d "
argument_list|,
name|mfi
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"mfd: %3d "
argument_list|,
name|mfd
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"mfn: %3d "
argument_list|,
name|mfn
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"pll: %d\n"
argument_list|,
operator|(
name|uint32_t
operator|)
name|freq
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ccm_softc
operator|->
name|pll_freq
index|[
name|pll_no
operator|-
literal|1
index|]
operator|=
name|freq
expr_stmt|;
return|return
operator|(
name|freq
operator|)
return|;
block|}
end_function

begin_function
name|void
name|imx51_clk_gating
parameter_list|(
name|int
name|clk_src
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|int
name|field
decl_stmt|,
name|group
decl_stmt|;
name|uint32_t
name|reg
decl_stmt|;
name|group
operator|=
name|CCMR_CCGR_MODULE
argument_list|(
name|clk_src
argument_list|)
expr_stmt|;
name|field
operator|=
name|clk_src
operator|%
name|CCMR_CCGR_NSOURCE
expr_stmt|;
name|reg
operator|=
name|bus_read_4
argument_list|(
name|ccm_softc
operator|->
name|res
index|[
literal|0
index|]
argument_list|,
name|CCMC_CCGR
argument_list|(
name|group
argument_list|)
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
operator|(
literal|0x03
operator|<<
name|field
operator|*
literal|2
operator|)
expr_stmt|;
name|reg
operator||=
operator|(
name|mode
operator|<<
name|field
operator|*
literal|2
operator|)
expr_stmt|;
name|bus_write_4
argument_list|(
name|ccm_softc
operator|->
name|res
index|[
literal|0
index|]
argument_list|,
name|CCMC_CCGR
argument_list|(
name|group
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|imx51_get_clk_gating
parameter_list|(
name|int
name|clk_src
parameter_list|)
block|{
name|uint32_t
name|reg
decl_stmt|;
name|reg
operator|=
name|bus_read_4
argument_list|(
name|ccm_softc
operator|->
name|res
index|[
literal|0
index|]
argument_list|,
name|CCMC_CCGR
argument_list|(
name|CCMR_CCGR_MODULE
argument_list|(
name|clk_src
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|reg
operator|>>
operator|(
name|clk_src
operator|%
name|CCMR_CCGR_NSOURCE
operator|)
operator|*
literal|2
operator|)
operator|&
literal|0x03
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Code from here down is temporary, in lieu of a SoC-independent clock API.  */
end_comment

begin_function
name|void
name|imx_ccm_usb_enable
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|uint32_t
name|regval
decl_stmt|;
comment|/* 	 * Select PLL2 as the source for the USB clock. 	 * The default is PLL3, but U-boot changes it to PLL2. 	 */
name|regval
operator|=
name|bus_read_4
argument_list|(
name|ccm_softc
operator|->
name|res
index|[
literal|0
index|]
argument_list|,
name|CCMC_CSCMR1
argument_list|)
expr_stmt|;
name|regval
operator|&=
operator|~
name|CSCMR1_USBOH3_CLK_SEL_MASK
expr_stmt|;
name|regval
operator||=
literal|1
operator|<<
name|CSCMR1_USBOH3_CLK_SEL_SHIFT
expr_stmt|;
name|bus_write_4
argument_list|(
name|ccm_softc
operator|->
name|res
index|[
literal|0
index|]
argument_list|,
name|CCMC_CSCMR1
argument_list|,
name|regval
argument_list|)
expr_stmt|;
comment|/* 	 * Set the USB clock pre-divider to div-by-5, post-divider to div-by-2. 	 */
name|regval
operator|=
name|bus_read_4
argument_list|(
name|ccm_softc
operator|->
name|res
index|[
literal|0
index|]
argument_list|,
name|CCMC_CSCDR1
argument_list|)
expr_stmt|;
name|regval
operator|&=
operator|~
name|CSCDR1_USBOH3_CLK_PODF_MASK
expr_stmt|;
name|regval
operator|&=
operator|~
name|CSCDR1_USBOH3_CLK_PRED_MASK
expr_stmt|;
name|regval
operator||=
literal|4
operator|<<
name|CSCDR1_USBOH3_CLK_PRED_SHIFT
expr_stmt|;
name|regval
operator||=
literal|1
operator|<<
name|CSCDR1_USBOH3_CLK_PODF_SHIFT
expr_stmt|;
name|bus_write_4
argument_list|(
name|ccm_softc
operator|->
name|res
index|[
literal|0
index|]
argument_list|,
name|CCMC_CSCDR1
argument_list|,
name|regval
argument_list|)
expr_stmt|;
comment|/* 	 * The same two clocks gates are used on imx51 and imx53. 	 */
name|imx51_clk_gating
argument_list|(
name|CCGR_USBOH3_IPG_AHB_CLK
argument_list|,
name|CCGR_CLK_MODE_ALWAYS
argument_list|)
expr_stmt|;
name|imx51_clk_gating
argument_list|(
name|CCGR_USBOH3_60M_CLK
argument_list|,
name|CCGR_CLK_MODE_ALWAYS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|imx_ccm_usbphy_enable
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|uint32_t
name|regval
decl_stmt|;
comment|/* 	 * Select PLL3 as the source for the USBPHY clock.  U-boot does this  	 * only for imx53, but the bit exists on imx51.  That seems a bit 	 * strange, but we'll go with it until more is known. 	 */
if|if
condition|(
name|imx_soc_type
argument_list|()
operator|==
name|IMXSOC_53
condition|)
block|{
name|regval
operator|=
name|bus_read_4
argument_list|(
name|ccm_softc
operator|->
name|res
index|[
literal|0
index|]
argument_list|,
name|CCMC_CSCMR1
argument_list|)
expr_stmt|;
name|regval
operator||=
literal|1
operator|<<
name|CSCMR1_USBPHY_CLK_SEL_SHIFT
expr_stmt|;
name|bus_write_4
argument_list|(
name|ccm_softc
operator|->
name|res
index|[
literal|0
index|]
argument_list|,
name|CCMC_CSCMR1
argument_list|,
name|regval
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * For the imx51 there's just one phy gate control, enable it. 	 */
if|if
condition|(
name|imx_soc_type
argument_list|()
operator|==
name|IMXSOC_51
condition|)
block|{
name|imx51_clk_gating
argument_list|(
name|CCGR_USB_PHY_CLK
argument_list|,
name|CCGR_CLK_MODE_ALWAYS
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * For imx53 we don't have a full set of clock defines yet, but the 	 * datasheet says: 	 *   gate reg 4, bits 13-12 usb ph2 clock (usb_phy2_clk_enable) 	 *   gate reg 4, bits 11-10 usb ph1 clock (usb_phy1_clk_enable) 	 * 	 * We should use the fdt data for the device to figure out which of 	 * the two we're working on, but for now just turn them both on. 	 */
if|if
condition|(
name|imx_soc_type
argument_list|()
operator|==
name|IMXSOC_53
condition|)
block|{
name|imx51_clk_gating
argument_list|(
name|__CCGR_NUM
argument_list|(
literal|4
argument_list|,
literal|5
argument_list|)
argument_list|,
name|CCGR_CLK_MODE_ALWAYS
argument_list|)
expr_stmt|;
name|imx51_clk_gating
argument_list|(
name|__CCGR_NUM
argument_list|(
literal|4
argument_list|,
literal|6
argument_list|)
argument_list|,
name|CCGR_CLK_MODE_ALWAYS
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_function
name|uint32_t
name|imx_ccm_ipg_hz
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|imx51_get_clock
argument_list|(
name|IMX51CLK_IPG_CLK_ROOT
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|uint32_t
name|imx_ccm_sdhci_hz
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|imx51_get_clock
argument_list|(
name|IMX51CLK_ESDHC1_CLK_ROOT
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|uint32_t
name|imx_ccm_perclk_hz
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|imx51_get_clock
argument_list|(
name|IMX51CLK_PERCLK_ROOT
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|uint32_t
name|imx_ccm_uart_hz
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|imx51_get_clock
argument_list|(
name|IMX51CLK_UART_CLK_ROOT
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|uint32_t
name|imx_ccm_ahb_hz
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|imx51_get_clock
argument_list|(
name|IMX51CLK_AHB_CLK_ROOT
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

