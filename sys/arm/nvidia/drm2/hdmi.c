begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2012 Avionic Design GmbH  *  * Permission is hereby granted, free of charge, to any person obtaining a  * copy of this software and associated documentation files (the "Software"),  * to deal in the Software without restriction, including without limitation  * the rights to use, copy, modify, merge, publish, distribute, sub license,  * and/or sell copies of the Software, and to permit persons to whom the  * Software is furnished to do so, subject to the following conditions:  *  * The above copyright notice and this permission notice (including the  * next paragraph) shall be included in all copies or substantial portions  * of the Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL  * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER  * DEALINGS IN THE SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<arm/nvidia/drm2/hdmi.h>
end_include

begin_define
define|#
directive|define
name|EXPORT_SYMBOL
parameter_list|(
name|x
parameter_list|)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|BIT
end_ifndef

begin_define
define|#
directive|define
name|BIT
parameter_list|(
name|x
parameter_list|)
value|(1U<< (x))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|hdmi_log
parameter_list|(
name|fmt
parameter_list|,
modifier|...
parameter_list|)
value|printf(fmt, ##__VA_ARGS__)
end_define

begin_function
specifier|static
name|uint8_t
name|hdmi_infoframe_checksum
parameter_list|(
name|uint8_t
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|uint8_t
name|csum
init|=
literal|0
decl_stmt|;
name|size_t
name|i
decl_stmt|;
comment|/* compute checksum */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
name|csum
operator|+=
name|ptr
index|[
name|i
index|]
expr_stmt|;
return|return
literal|256
operator|-
name|csum
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hdmi_infoframe_set_checksum
parameter_list|(
name|void
modifier|*
name|buffer
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|uint8_t
modifier|*
name|ptr
init|=
name|buffer
decl_stmt|;
name|ptr
index|[
literal|3
index|]
operator|=
name|hdmi_infoframe_checksum
argument_list|(
name|buffer
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * hdmi_avi_infoframe_init() - initialize an HDMI AVI infoframe  * @frame: HDMI AVI infoframe  *  * Returns 0 on success or a negative error code on failure.  */
end_comment

begin_function
name|int
name|hdmi_avi_infoframe_init
parameter_list|(
name|struct
name|hdmi_avi_infoframe
modifier|*
name|frame
parameter_list|)
block|{
name|memset
argument_list|(
name|frame
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|frame
argument_list|)
argument_list|)
expr_stmt|;
name|frame
operator|->
name|type
operator|=
name|HDMI_INFOFRAME_TYPE_AVI
expr_stmt|;
name|frame
operator|->
name|version
operator|=
literal|2
expr_stmt|;
name|frame
operator|->
name|length
operator|=
name|HDMI_AVI_INFOFRAME_SIZE
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|hdmi_avi_infoframe_init
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/**  * hdmi_avi_infoframe_pack() - write HDMI AVI infoframe to binary buffer  * @frame: HDMI AVI infoframe  * @buffer: destination buffer  * @size: size of buffer  *  * Packs the information contained in the @frame structure into a binary  * representation that can be written into the corresponding controller  * registers. Also computes the checksum as required by section 5.3.5 of  * the HDMI 1.4 specification.  *  * Returns the number of bytes packed into the binary buffer or a negative  * error code on failure.  */
end_comment

begin_function
name|ssize_t
name|hdmi_avi_infoframe_pack
parameter_list|(
name|struct
name|hdmi_avi_infoframe
modifier|*
name|frame
parameter_list|,
name|void
modifier|*
name|buffer
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|uint8_t
modifier|*
name|ptr
init|=
name|buffer
decl_stmt|;
name|size_t
name|length
decl_stmt|;
name|length
operator|=
name|HDMI_INFOFRAME_HEADER_SIZE
operator|+
name|frame
operator|->
name|length
expr_stmt|;
if|if
condition|(
name|size
operator|<
name|length
condition|)
return|return
operator|-
name|ENOSPC
return|;
name|memset
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|ptr
index|[
literal|0
index|]
operator|=
name|frame
operator|->
name|type
expr_stmt|;
name|ptr
index|[
literal|1
index|]
operator|=
name|frame
operator|->
name|version
expr_stmt|;
name|ptr
index|[
literal|2
index|]
operator|=
name|frame
operator|->
name|length
expr_stmt|;
name|ptr
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
comment|/* checksum */
comment|/* start infoframe payload */
name|ptr
operator|+=
name|HDMI_INFOFRAME_HEADER_SIZE
expr_stmt|;
name|ptr
index|[
literal|0
index|]
operator|=
operator|(
operator|(
name|frame
operator|->
name|colorspace
operator|&
literal|0x3
operator|)
operator|<<
literal|5
operator|)
operator||
operator|(
name|frame
operator|->
name|scan_mode
operator|&
literal|0x3
operator|)
expr_stmt|;
comment|/* 	 * Data byte 1, bit 4 has to be set if we provide the active format 	 * aspect ratio 	 */
if|if
condition|(
name|frame
operator|->
name|active_aspect
operator|&
literal|0xf
condition|)
name|ptr
index|[
literal|0
index|]
operator||=
name|BIT
argument_list|(
literal|4
argument_list|)
expr_stmt|;
comment|/* Bit 3 and 2 indicate if we transmit horizontal/vertical bar data */
if|if
condition|(
name|frame
operator|->
name|top_bar
operator|||
name|frame
operator|->
name|bottom_bar
condition|)
name|ptr
index|[
literal|0
index|]
operator||=
name|BIT
argument_list|(
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame
operator|->
name|left_bar
operator|||
name|frame
operator|->
name|right_bar
condition|)
name|ptr
index|[
literal|0
index|]
operator||=
name|BIT
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|ptr
index|[
literal|1
index|]
operator|=
operator|(
operator|(
name|frame
operator|->
name|colorimetry
operator|&
literal|0x3
operator|)
operator|<<
literal|6
operator|)
operator||
operator|(
operator|(
name|frame
operator|->
name|picture_aspect
operator|&
literal|0x3
operator|)
operator|<<
literal|4
operator|)
operator||
operator|(
name|frame
operator|->
name|active_aspect
operator|&
literal|0xf
operator|)
expr_stmt|;
name|ptr
index|[
literal|2
index|]
operator|=
operator|(
operator|(
name|frame
operator|->
name|extended_colorimetry
operator|&
literal|0x7
operator|)
operator|<<
literal|4
operator|)
operator||
operator|(
operator|(
name|frame
operator|->
name|quantization_range
operator|&
literal|0x3
operator|)
operator|<<
literal|2
operator|)
operator||
operator|(
name|frame
operator|->
name|nups
operator|&
literal|0x3
operator|)
expr_stmt|;
if|if
condition|(
name|frame
operator|->
name|itc
condition|)
name|ptr
index|[
literal|2
index|]
operator||=
name|BIT
argument_list|(
literal|7
argument_list|)
expr_stmt|;
name|ptr
index|[
literal|3
index|]
operator|=
name|frame
operator|->
name|video_code
operator|&
literal|0x7f
expr_stmt|;
name|ptr
index|[
literal|4
index|]
operator|=
operator|(
operator|(
name|frame
operator|->
name|ycc_quantization_range
operator|&
literal|0x3
operator|)
operator|<<
literal|6
operator|)
operator||
operator|(
operator|(
name|frame
operator|->
name|content_type
operator|&
literal|0x3
operator|)
operator|<<
literal|4
operator|)
operator||
operator|(
name|frame
operator|->
name|pixel_repeat
operator|&
literal|0xf
operator|)
expr_stmt|;
name|ptr
index|[
literal|5
index|]
operator|=
name|frame
operator|->
name|top_bar
operator|&
literal|0xff
expr_stmt|;
name|ptr
index|[
literal|6
index|]
operator|=
operator|(
name|frame
operator|->
name|top_bar
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|ptr
index|[
literal|7
index|]
operator|=
name|frame
operator|->
name|bottom_bar
operator|&
literal|0xff
expr_stmt|;
name|ptr
index|[
literal|8
index|]
operator|=
operator|(
name|frame
operator|->
name|bottom_bar
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|ptr
index|[
literal|9
index|]
operator|=
name|frame
operator|->
name|left_bar
operator|&
literal|0xff
expr_stmt|;
name|ptr
index|[
literal|10
index|]
operator|=
operator|(
name|frame
operator|->
name|left_bar
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|ptr
index|[
literal|11
index|]
operator|=
name|frame
operator|->
name|right_bar
operator|&
literal|0xff
expr_stmt|;
name|ptr
index|[
literal|12
index|]
operator|=
operator|(
name|frame
operator|->
name|right_bar
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|hdmi_infoframe_set_checksum
argument_list|(
name|buffer
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return
name|length
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|hdmi_avi_infoframe_pack
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/**  * hdmi_spd_infoframe_init() - initialize an HDMI SPD infoframe  * @frame: HDMI SPD infoframe  * @vendor: vendor string  * @product: product string  *  * Returns 0 on success or a negative error code on failure.  */
end_comment

begin_function
name|int
name|hdmi_spd_infoframe_init
parameter_list|(
name|struct
name|hdmi_spd_infoframe
modifier|*
name|frame
parameter_list|,
specifier|const
name|char
modifier|*
name|vendor
parameter_list|,
specifier|const
name|char
modifier|*
name|product
parameter_list|)
block|{
name|memset
argument_list|(
name|frame
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|frame
argument_list|)
argument_list|)
expr_stmt|;
name|frame
operator|->
name|type
operator|=
name|HDMI_INFOFRAME_TYPE_SPD
expr_stmt|;
name|frame
operator|->
name|version
operator|=
literal|1
expr_stmt|;
name|frame
operator|->
name|length
operator|=
name|HDMI_SPD_INFOFRAME_SIZE
expr_stmt|;
name|strncpy
argument_list|(
name|frame
operator|->
name|vendor
argument_list|,
name|vendor
argument_list|,
sizeof|sizeof
argument_list|(
name|frame
operator|->
name|vendor
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|frame
operator|->
name|product
argument_list|,
name|product
argument_list|,
sizeof|sizeof
argument_list|(
name|frame
operator|->
name|product
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|hdmi_spd_infoframe_init
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/**  * hdmi_spd_infoframe_pack() - write HDMI SPD infoframe to binary buffer  * @frame: HDMI SPD infoframe  * @buffer: destination buffer  * @size: size of buffer  *  * Packs the information contained in the @frame structure into a binary  * representation that can be written into the corresponding controller  * registers. Also computes the checksum as required by section 5.3.5 of  * the HDMI 1.4 specification.  *  * Returns the number of bytes packed into the binary buffer or a negative  * error code on failure.  */
end_comment

begin_function
name|ssize_t
name|hdmi_spd_infoframe_pack
parameter_list|(
name|struct
name|hdmi_spd_infoframe
modifier|*
name|frame
parameter_list|,
name|void
modifier|*
name|buffer
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|uint8_t
modifier|*
name|ptr
init|=
name|buffer
decl_stmt|;
name|size_t
name|length
decl_stmt|;
name|length
operator|=
name|HDMI_INFOFRAME_HEADER_SIZE
operator|+
name|frame
operator|->
name|length
expr_stmt|;
if|if
condition|(
name|size
operator|<
name|length
condition|)
return|return
operator|-
name|ENOSPC
return|;
name|memset
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|ptr
index|[
literal|0
index|]
operator|=
name|frame
operator|->
name|type
expr_stmt|;
name|ptr
index|[
literal|1
index|]
operator|=
name|frame
operator|->
name|version
expr_stmt|;
name|ptr
index|[
literal|2
index|]
operator|=
name|frame
operator|->
name|length
expr_stmt|;
name|ptr
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
comment|/* checksum */
comment|/* start infoframe payload */
name|ptr
operator|+=
name|HDMI_INFOFRAME_HEADER_SIZE
expr_stmt|;
name|memcpy
argument_list|(
name|ptr
argument_list|,
name|frame
operator|->
name|vendor
argument_list|,
sizeof|sizeof
argument_list|(
name|frame
operator|->
name|vendor
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ptr
operator|+
literal|8
argument_list|,
name|frame
operator|->
name|product
argument_list|,
sizeof|sizeof
argument_list|(
name|frame
operator|->
name|product
argument_list|)
argument_list|)
expr_stmt|;
name|ptr
index|[
literal|24
index|]
operator|=
name|frame
operator|->
name|sdi
expr_stmt|;
name|hdmi_infoframe_set_checksum
argument_list|(
name|buffer
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return
name|length
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|hdmi_spd_infoframe_pack
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/**  * hdmi_audio_infoframe_init() - initialize an HDMI audio infoframe  * @frame: HDMI audio infoframe  *  * Returns 0 on success or a negative error code on failure.  */
end_comment

begin_function
name|int
name|hdmi_audio_infoframe_init
parameter_list|(
name|struct
name|hdmi_audio_infoframe
modifier|*
name|frame
parameter_list|)
block|{
name|memset
argument_list|(
name|frame
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|frame
argument_list|)
argument_list|)
expr_stmt|;
name|frame
operator|->
name|type
operator|=
name|HDMI_INFOFRAME_TYPE_AUDIO
expr_stmt|;
name|frame
operator|->
name|version
operator|=
literal|1
expr_stmt|;
name|frame
operator|->
name|length
operator|=
name|HDMI_AUDIO_INFOFRAME_SIZE
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|hdmi_audio_infoframe_init
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/**  * hdmi_audio_infoframe_pack() - write HDMI audio infoframe to binary buffer  * @frame: HDMI audio infoframe  * @buffer: destination buffer  * @size: size of buffer  *  * Packs the information contained in the @frame structure into a binary  * representation that can be written into the corresponding controller  * registers. Also computes the checksum as required by section 5.3.5 of  * the HDMI 1.4 specification.  *  * Returns the number of bytes packed into the binary buffer or a negative  * error code on failure.  */
end_comment

begin_function
name|ssize_t
name|hdmi_audio_infoframe_pack
parameter_list|(
name|struct
name|hdmi_audio_infoframe
modifier|*
name|frame
parameter_list|,
name|void
modifier|*
name|buffer
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|unsigned
name|char
name|channels
decl_stmt|;
name|uint8_t
modifier|*
name|ptr
init|=
name|buffer
decl_stmt|;
name|size_t
name|length
decl_stmt|;
name|length
operator|=
name|HDMI_INFOFRAME_HEADER_SIZE
operator|+
name|frame
operator|->
name|length
expr_stmt|;
if|if
condition|(
name|size
operator|<
name|length
condition|)
return|return
operator|-
name|ENOSPC
return|;
name|memset
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame
operator|->
name|channels
operator|>=
literal|2
condition|)
name|channels
operator|=
name|frame
operator|->
name|channels
operator|-
literal|1
expr_stmt|;
else|else
name|channels
operator|=
literal|0
expr_stmt|;
name|ptr
index|[
literal|0
index|]
operator|=
name|frame
operator|->
name|type
expr_stmt|;
name|ptr
index|[
literal|1
index|]
operator|=
name|frame
operator|->
name|version
expr_stmt|;
name|ptr
index|[
literal|2
index|]
operator|=
name|frame
operator|->
name|length
expr_stmt|;
name|ptr
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
comment|/* checksum */
comment|/* start infoframe payload */
name|ptr
operator|+=
name|HDMI_INFOFRAME_HEADER_SIZE
expr_stmt|;
name|ptr
index|[
literal|0
index|]
operator|=
operator|(
operator|(
name|frame
operator|->
name|coding_type
operator|&
literal|0xf
operator|)
operator|<<
literal|4
operator|)
operator||
operator|(
name|channels
operator|&
literal|0x7
operator|)
expr_stmt|;
name|ptr
index|[
literal|1
index|]
operator|=
operator|(
operator|(
name|frame
operator|->
name|sample_frequency
operator|&
literal|0x7
operator|)
operator|<<
literal|2
operator|)
operator||
operator|(
name|frame
operator|->
name|sample_size
operator|&
literal|0x3
operator|)
expr_stmt|;
name|ptr
index|[
literal|2
index|]
operator|=
name|frame
operator|->
name|coding_type_ext
operator|&
literal|0x1f
expr_stmt|;
name|ptr
index|[
literal|3
index|]
operator|=
name|frame
operator|->
name|channel_allocation
expr_stmt|;
name|ptr
index|[
literal|4
index|]
operator|=
operator|(
name|frame
operator|->
name|level_shift_value
operator|&
literal|0xf
operator|)
operator|<<
literal|3
expr_stmt|;
if|if
condition|(
name|frame
operator|->
name|downmix_inhibit
condition|)
name|ptr
index|[
literal|4
index|]
operator||=
name|BIT
argument_list|(
literal|7
argument_list|)
expr_stmt|;
name|hdmi_infoframe_set_checksum
argument_list|(
name|buffer
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return
name|length
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|hdmi_audio_infoframe_pack
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/**  * hdmi_vendor_infoframe_init() - initialize an HDMI vendor infoframe  * @frame: HDMI vendor infoframe  *  * Returns 0 on success or a negative error code on failure.  */
end_comment

begin_function
name|int
name|hdmi_vendor_infoframe_init
parameter_list|(
name|struct
name|hdmi_vendor_infoframe
modifier|*
name|frame
parameter_list|)
block|{
name|memset
argument_list|(
name|frame
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|frame
argument_list|)
argument_list|)
expr_stmt|;
name|frame
operator|->
name|type
operator|=
name|HDMI_INFOFRAME_TYPE_VENDOR
expr_stmt|;
name|frame
operator|->
name|version
operator|=
literal|1
expr_stmt|;
name|frame
operator|->
name|oui
operator|=
name|HDMI_IEEE_OUI
expr_stmt|;
comment|/* 	 * 0 is a valid value for s3d_struct, so we use a special "not set" 	 * value 	 */
name|frame
operator|->
name|s3d_struct
operator|=
name|HDMI_3D_STRUCTURE_INVALID
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|hdmi_vendor_infoframe_init
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/**  * hdmi_vendor_infoframe_pack() - write a HDMI vendor infoframe to binary buffer  * @frame: HDMI infoframe  * @buffer: destination buffer  * @size: size of buffer  *  * Packs the information contained in the @frame structure into a binary  * representation that can be written into the corresponding controller  * registers. Also computes the checksum as required by section 5.3.5 of  * the HDMI 1.4 specification.  *  * Returns the number of bytes packed into the binary buffer or a negative  * error code on failure.  */
end_comment

begin_function
name|ssize_t
name|hdmi_vendor_infoframe_pack
parameter_list|(
name|struct
name|hdmi_vendor_infoframe
modifier|*
name|frame
parameter_list|,
name|void
modifier|*
name|buffer
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|uint8_t
modifier|*
name|ptr
init|=
name|buffer
decl_stmt|;
name|size_t
name|length
decl_stmt|;
comment|/* empty info frame */
if|if
condition|(
name|frame
operator|->
name|vic
operator|==
literal|0
operator|&&
name|frame
operator|->
name|s3d_struct
operator|==
name|HDMI_3D_STRUCTURE_INVALID
condition|)
return|return
operator|-
name|EINVAL
return|;
comment|/* only one of those can be supplied */
if|if
condition|(
name|frame
operator|->
name|vic
operator|!=
literal|0
operator|&&
name|frame
operator|->
name|s3d_struct
operator|!=
name|HDMI_3D_STRUCTURE_INVALID
condition|)
return|return
operator|-
name|EINVAL
return|;
comment|/* for side by side (half) we also need to provide 3D_Ext_Data */
if|if
condition|(
name|frame
operator|->
name|s3d_struct
operator|>=
name|HDMI_3D_STRUCTURE_SIDE_BY_SIDE_HALF
condition|)
name|frame
operator|->
name|length
operator|=
literal|6
expr_stmt|;
else|else
name|frame
operator|->
name|length
operator|=
literal|5
expr_stmt|;
name|length
operator|=
name|HDMI_INFOFRAME_HEADER_SIZE
operator|+
name|frame
operator|->
name|length
expr_stmt|;
if|if
condition|(
name|size
operator|<
name|length
condition|)
return|return
operator|-
name|ENOSPC
return|;
name|memset
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|ptr
index|[
literal|0
index|]
operator|=
name|frame
operator|->
name|type
expr_stmt|;
name|ptr
index|[
literal|1
index|]
operator|=
name|frame
operator|->
name|version
expr_stmt|;
name|ptr
index|[
literal|2
index|]
operator|=
name|frame
operator|->
name|length
expr_stmt|;
name|ptr
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
comment|/* checksum */
comment|/* HDMI OUI */
name|ptr
index|[
literal|4
index|]
operator|=
literal|0x03
expr_stmt|;
name|ptr
index|[
literal|5
index|]
operator|=
literal|0x0c
expr_stmt|;
name|ptr
index|[
literal|6
index|]
operator|=
literal|0x00
expr_stmt|;
if|if
condition|(
name|frame
operator|->
name|vic
condition|)
block|{
name|ptr
index|[
literal|7
index|]
operator|=
literal|0x1
operator|<<
literal|5
expr_stmt|;
comment|/* video format */
name|ptr
index|[
literal|8
index|]
operator|=
name|frame
operator|->
name|vic
expr_stmt|;
block|}
else|else
block|{
name|ptr
index|[
literal|7
index|]
operator|=
literal|0x2
operator|<<
literal|5
expr_stmt|;
comment|/* video format */
name|ptr
index|[
literal|8
index|]
operator|=
operator|(
name|frame
operator|->
name|s3d_struct
operator|&
literal|0xf
operator|)
operator|<<
literal|4
expr_stmt|;
if|if
condition|(
name|frame
operator|->
name|s3d_struct
operator|>=
name|HDMI_3D_STRUCTURE_SIDE_BY_SIDE_HALF
condition|)
name|ptr
index|[
literal|9
index|]
operator|=
operator|(
name|frame
operator|->
name|s3d_ext_data
operator|&
literal|0xf
operator|)
operator|<<
literal|4
expr_stmt|;
block|}
name|hdmi_infoframe_set_checksum
argument_list|(
name|buffer
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return
name|length
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|hdmi_vendor_infoframe_pack
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * hdmi_vendor_any_infoframe_pack() - write a vendor infoframe to binary buffer  */
end_comment

begin_function
specifier|static
name|ssize_t
name|hdmi_vendor_any_infoframe_pack
parameter_list|(
name|union
name|hdmi_vendor_any_infoframe
modifier|*
name|frame
parameter_list|,
name|void
modifier|*
name|buffer
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
comment|/* we only know about HDMI vendor infoframes */
if|if
condition|(
name|frame
operator|->
name|any
operator|.
name|oui
operator|!=
name|HDMI_IEEE_OUI
condition|)
return|return
operator|-
name|EINVAL
return|;
return|return
name|hdmi_vendor_infoframe_pack
argument_list|(
operator|&
name|frame
operator|->
name|hdmi
argument_list|,
name|buffer
argument_list|,
name|size
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * hdmi_infoframe_pack() - write a HDMI infoframe to binary buffer  * @frame: HDMI infoframe  * @buffer: destination buffer  * @size: size of buffer  *  * Packs the information contained in the @frame structure into a binary  * representation that can be written into the corresponding controller  * registers. Also computes the checksum as required by section 5.3.5 of  * the HDMI 1.4 specification.  *  * Returns the number of bytes packed into the binary buffer or a negative  * error code on failure.  */
end_comment

begin_function
name|ssize_t
name|hdmi_infoframe_pack
parameter_list|(
name|union
name|hdmi_infoframe
modifier|*
name|frame
parameter_list|,
name|void
modifier|*
name|buffer
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|ssize_t
name|length
decl_stmt|;
switch|switch
condition|(
name|frame
operator|->
name|any
operator|.
name|type
condition|)
block|{
case|case
name|HDMI_INFOFRAME_TYPE_AVI
case|:
name|length
operator|=
name|hdmi_avi_infoframe_pack
argument_list|(
operator|&
name|frame
operator|->
name|avi
argument_list|,
name|buffer
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
case|case
name|HDMI_INFOFRAME_TYPE_SPD
case|:
name|length
operator|=
name|hdmi_spd_infoframe_pack
argument_list|(
operator|&
name|frame
operator|->
name|spd
argument_list|,
name|buffer
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
case|case
name|HDMI_INFOFRAME_TYPE_AUDIO
case|:
name|length
operator|=
name|hdmi_audio_infoframe_pack
argument_list|(
operator|&
name|frame
operator|->
name|audio
argument_list|,
name|buffer
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
case|case
name|HDMI_INFOFRAME_TYPE_VENDOR
case|:
name|length
operator|=
name|hdmi_vendor_any_infoframe_pack
argument_list|(
operator|&
name|frame
operator|->
name|vendor
argument_list|,
name|buffer
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"Bad infoframe type %d\n"
argument_list|,
name|frame
operator|->
name|any
operator|.
name|type
argument_list|)
expr_stmt|;
name|length
operator|=
operator|-
name|EINVAL
expr_stmt|;
block|}
return|return
name|length
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|hdmi_infoframe_pack
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|hdmi_infoframe_type_get_name
parameter_list|(
name|enum
name|hdmi_infoframe_type
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|<
literal|0x80
operator|||
name|type
operator|>
literal|0x9f
condition|)
return|return
literal|"Invalid"
return|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|HDMI_INFOFRAME_TYPE_VENDOR
case|:
return|return
literal|"Vendor"
return|;
case|case
name|HDMI_INFOFRAME_TYPE_AVI
case|:
return|return
literal|"Auxiliary Video Information (AVI)"
return|;
case|case
name|HDMI_INFOFRAME_TYPE_SPD
case|:
return|return
literal|"Source Product Description (SPD)"
return|;
case|case
name|HDMI_INFOFRAME_TYPE_AUDIO
case|:
return|return
literal|"Audio"
return|;
block|}
return|return
literal|"Reserved"
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hdmi_infoframe_log_header
parameter_list|(
name|struct
name|hdmi_any_infoframe
modifier|*
name|frame
parameter_list|)
block|{
name|hdmi_log
argument_list|(
literal|"HDMI infoframe: %s, version %u, length %u\n"
argument_list|,
name|hdmi_infoframe_type_get_name
argument_list|(
name|frame
operator|->
name|type
argument_list|)
argument_list|,
name|frame
operator|->
name|version
argument_list|,
name|frame
operator|->
name|length
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|hdmi_colorspace_get_name
parameter_list|(
name|enum
name|hdmi_colorspace
name|colorspace
parameter_list|)
block|{
switch|switch
condition|(
name|colorspace
condition|)
block|{
case|case
name|HDMI_COLORSPACE_RGB
case|:
return|return
literal|"RGB"
return|;
case|case
name|HDMI_COLORSPACE_YUV422
case|:
return|return
literal|"YCbCr 4:2:2"
return|;
case|case
name|HDMI_COLORSPACE_YUV444
case|:
return|return
literal|"YCbCr 4:4:4"
return|;
case|case
name|HDMI_COLORSPACE_YUV420
case|:
return|return
literal|"YCbCr 4:2:0"
return|;
case|case
name|HDMI_COLORSPACE_RESERVED4
case|:
return|return
literal|"Reserved (4)"
return|;
case|case
name|HDMI_COLORSPACE_RESERVED5
case|:
return|return
literal|"Reserved (5)"
return|;
case|case
name|HDMI_COLORSPACE_RESERVED6
case|:
return|return
literal|"Reserved (6)"
return|;
case|case
name|HDMI_COLORSPACE_IDO_DEFINED
case|:
return|return
literal|"IDO Defined"
return|;
block|}
return|return
literal|"Invalid"
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|hdmi_scan_mode_get_name
parameter_list|(
name|enum
name|hdmi_scan_mode
name|scan_mode
parameter_list|)
block|{
switch|switch
condition|(
name|scan_mode
condition|)
block|{
case|case
name|HDMI_SCAN_MODE_NONE
case|:
return|return
literal|"No Data"
return|;
case|case
name|HDMI_SCAN_MODE_OVERSCAN
case|:
return|return
literal|"Overscan"
return|;
case|case
name|HDMI_SCAN_MODE_UNDERSCAN
case|:
return|return
literal|"Underscan"
return|;
case|case
name|HDMI_SCAN_MODE_RESERVED
case|:
return|return
literal|"Reserved"
return|;
block|}
return|return
literal|"Invalid"
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|hdmi_colorimetry_get_name
parameter_list|(
name|enum
name|hdmi_colorimetry
name|colorimetry
parameter_list|)
block|{
switch|switch
condition|(
name|colorimetry
condition|)
block|{
case|case
name|HDMI_COLORIMETRY_NONE
case|:
return|return
literal|"No Data"
return|;
case|case
name|HDMI_COLORIMETRY_ITU_601
case|:
return|return
literal|"ITU601"
return|;
case|case
name|HDMI_COLORIMETRY_ITU_709
case|:
return|return
literal|"ITU709"
return|;
case|case
name|HDMI_COLORIMETRY_EXTENDED
case|:
return|return
literal|"Extended"
return|;
block|}
return|return
literal|"Invalid"
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|hdmi_picture_aspect_get_name
parameter_list|(
name|enum
name|hdmi_picture_aspect
name|picture_aspect
parameter_list|)
block|{
switch|switch
condition|(
name|picture_aspect
condition|)
block|{
case|case
name|HDMI_PICTURE_ASPECT_NONE
case|:
return|return
literal|"No Data"
return|;
case|case
name|HDMI_PICTURE_ASPECT_4_3
case|:
return|return
literal|"4:3"
return|;
case|case
name|HDMI_PICTURE_ASPECT_16_9
case|:
return|return
literal|"16:9"
return|;
case|case
name|HDMI_PICTURE_ASPECT_RESERVED
case|:
return|return
literal|"Reserved"
return|;
block|}
return|return
literal|"Invalid"
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|hdmi_active_aspect_get_name
parameter_list|(
name|enum
name|hdmi_active_aspect
name|active_aspect
parameter_list|)
block|{
if|if
condition|(
name|active_aspect
operator|>
literal|0xf
condition|)
return|return
literal|"Invalid"
return|;
switch|switch
condition|(
name|active_aspect
condition|)
block|{
case|case
name|HDMI_ACTIVE_ASPECT_16_9_TOP
case|:
return|return
literal|"16:9 Top"
return|;
case|case
name|HDMI_ACTIVE_ASPECT_14_9_TOP
case|:
return|return
literal|"14:9 Top"
return|;
case|case
name|HDMI_ACTIVE_ASPECT_16_9_CENTER
case|:
return|return
literal|"16:9 Center"
return|;
case|case
name|HDMI_ACTIVE_ASPECT_PICTURE
case|:
return|return
literal|"Same as Picture"
return|;
case|case
name|HDMI_ACTIVE_ASPECT_4_3
case|:
return|return
literal|"4:3"
return|;
case|case
name|HDMI_ACTIVE_ASPECT_16_9
case|:
return|return
literal|"16:9"
return|;
case|case
name|HDMI_ACTIVE_ASPECT_14_9
case|:
return|return
literal|"14:9"
return|;
case|case
name|HDMI_ACTIVE_ASPECT_4_3_SP_14_9
case|:
return|return
literal|"4:3 SP 14:9"
return|;
case|case
name|HDMI_ACTIVE_ASPECT_16_9_SP_14_9
case|:
return|return
literal|"16:9 SP 14:9"
return|;
case|case
name|HDMI_ACTIVE_ASPECT_16_9_SP_4_3
case|:
return|return
literal|"16:9 SP 4:3"
return|;
block|}
return|return
literal|"Reserved"
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|hdmi_extended_colorimetry_get_name
parameter_list|(
name|enum
name|hdmi_extended_colorimetry
name|ext_col
parameter_list|)
block|{
switch|switch
condition|(
name|ext_col
condition|)
block|{
case|case
name|HDMI_EXTENDED_COLORIMETRY_XV_YCC_601
case|:
return|return
literal|"xvYCC 601"
return|;
case|case
name|HDMI_EXTENDED_COLORIMETRY_XV_YCC_709
case|:
return|return
literal|"xvYCC 709"
return|;
case|case
name|HDMI_EXTENDED_COLORIMETRY_S_YCC_601
case|:
return|return
literal|"sYCC 601"
return|;
case|case
name|HDMI_EXTENDED_COLORIMETRY_ADOBE_YCC_601
case|:
return|return
literal|"Adobe YCC 601"
return|;
case|case
name|HDMI_EXTENDED_COLORIMETRY_ADOBE_RGB
case|:
return|return
literal|"Adobe RGB"
return|;
case|case
name|HDMI_EXTENDED_COLORIMETRY_BT2020_CONST_LUM
case|:
return|return
literal|"BT.2020 Constant Luminance"
return|;
case|case
name|HDMI_EXTENDED_COLORIMETRY_BT2020
case|:
return|return
literal|"BT.2020"
return|;
case|case
name|HDMI_EXTENDED_COLORIMETRY_RESERVED
case|:
return|return
literal|"Reserved"
return|;
block|}
return|return
literal|"Invalid"
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|hdmi_quantization_range_get_name
parameter_list|(
name|enum
name|hdmi_quantization_range
name|qrange
parameter_list|)
block|{
switch|switch
condition|(
name|qrange
condition|)
block|{
case|case
name|HDMI_QUANTIZATION_RANGE_DEFAULT
case|:
return|return
literal|"Default"
return|;
case|case
name|HDMI_QUANTIZATION_RANGE_LIMITED
case|:
return|return
literal|"Limited"
return|;
case|case
name|HDMI_QUANTIZATION_RANGE_FULL
case|:
return|return
literal|"Full"
return|;
case|case
name|HDMI_QUANTIZATION_RANGE_RESERVED
case|:
return|return
literal|"Reserved"
return|;
block|}
return|return
literal|"Invalid"
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|hdmi_nups_get_name
parameter_list|(
name|enum
name|hdmi_nups
name|nups
parameter_list|)
block|{
switch|switch
condition|(
name|nups
condition|)
block|{
case|case
name|HDMI_NUPS_UNKNOWN
case|:
return|return
literal|"Unknown Non-uniform Scaling"
return|;
case|case
name|HDMI_NUPS_HORIZONTAL
case|:
return|return
literal|"Horizontally Scaled"
return|;
case|case
name|HDMI_NUPS_VERTICAL
case|:
return|return
literal|"Vertically Scaled"
return|;
case|case
name|HDMI_NUPS_BOTH
case|:
return|return
literal|"Horizontally and Vertically Scaled"
return|;
block|}
return|return
literal|"Invalid"
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|hdmi_ycc_quantization_range_get_name
parameter_list|(
name|enum
name|hdmi_ycc_quantization_range
name|qrange
parameter_list|)
block|{
switch|switch
condition|(
name|qrange
condition|)
block|{
case|case
name|HDMI_YCC_QUANTIZATION_RANGE_LIMITED
case|:
return|return
literal|"Limited"
return|;
case|case
name|HDMI_YCC_QUANTIZATION_RANGE_FULL
case|:
return|return
literal|"Full"
return|;
block|}
return|return
literal|"Invalid"
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|hdmi_content_type_get_name
parameter_list|(
name|enum
name|hdmi_content_type
name|content_type
parameter_list|)
block|{
switch|switch
condition|(
name|content_type
condition|)
block|{
case|case
name|HDMI_CONTENT_TYPE_GRAPHICS
case|:
return|return
literal|"Graphics"
return|;
case|case
name|HDMI_CONTENT_TYPE_PHOTO
case|:
return|return
literal|"Photo"
return|;
case|case
name|HDMI_CONTENT_TYPE_CINEMA
case|:
return|return
literal|"Cinema"
return|;
case|case
name|HDMI_CONTENT_TYPE_GAME
case|:
return|return
literal|"Game"
return|;
block|}
return|return
literal|"Invalid"
return|;
block|}
end_function

begin_comment
comment|/**  * hdmi_avi_infoframe_log() - log info of HDMI AVI infoframe  * @level: logging level  * @dev: device  * @frame: HDMI AVI infoframe  */
end_comment

begin_function
specifier|static
name|void
name|hdmi_avi_infoframe_log
parameter_list|(
name|struct
name|hdmi_avi_infoframe
modifier|*
name|frame
parameter_list|)
block|{
name|hdmi_infoframe_log_header
argument_list|(
operator|(
expr|struct
name|hdmi_any_infoframe
operator|*
operator|)
name|frame
argument_list|)
expr_stmt|;
name|hdmi_log
argument_list|(
literal|"    colorspace: %s\n"
argument_list|,
name|hdmi_colorspace_get_name
argument_list|(
name|frame
operator|->
name|colorspace
argument_list|)
argument_list|)
expr_stmt|;
name|hdmi_log
argument_list|(
literal|"    scan mode: %s\n"
argument_list|,
name|hdmi_scan_mode_get_name
argument_list|(
name|frame
operator|->
name|scan_mode
argument_list|)
argument_list|)
expr_stmt|;
name|hdmi_log
argument_list|(
literal|"    colorimetry: %s\n"
argument_list|,
name|hdmi_colorimetry_get_name
argument_list|(
name|frame
operator|->
name|colorimetry
argument_list|)
argument_list|)
expr_stmt|;
name|hdmi_log
argument_list|(
literal|"    picture aspect: %s\n"
argument_list|,
name|hdmi_picture_aspect_get_name
argument_list|(
name|frame
operator|->
name|picture_aspect
argument_list|)
argument_list|)
expr_stmt|;
name|hdmi_log
argument_list|(
literal|"    active aspect: %s\n"
argument_list|,
name|hdmi_active_aspect_get_name
argument_list|(
name|frame
operator|->
name|active_aspect
argument_list|)
argument_list|)
expr_stmt|;
name|hdmi_log
argument_list|(
literal|"    itc: %s\n"
argument_list|,
name|frame
operator|->
name|itc
condition|?
literal|"IT Content"
else|:
literal|"No Data"
argument_list|)
expr_stmt|;
name|hdmi_log
argument_list|(
literal|"    extended colorimetry: %s\n"
argument_list|,
name|hdmi_extended_colorimetry_get_name
argument_list|(
name|frame
operator|->
name|extended_colorimetry
argument_list|)
argument_list|)
expr_stmt|;
name|hdmi_log
argument_list|(
literal|"    quantization range: %s\n"
argument_list|,
name|hdmi_quantization_range_get_name
argument_list|(
name|frame
operator|->
name|quantization_range
argument_list|)
argument_list|)
expr_stmt|;
name|hdmi_log
argument_list|(
literal|"    nups: %s\n"
argument_list|,
name|hdmi_nups_get_name
argument_list|(
name|frame
operator|->
name|nups
argument_list|)
argument_list|)
expr_stmt|;
name|hdmi_log
argument_list|(
literal|"    video code: %u\n"
argument_list|,
name|frame
operator|->
name|video_code
argument_list|)
expr_stmt|;
name|hdmi_log
argument_list|(
literal|"    ycc quantization range: %s\n"
argument_list|,
name|hdmi_ycc_quantization_range_get_name
argument_list|(
name|frame
operator|->
name|ycc_quantization_range
argument_list|)
argument_list|)
expr_stmt|;
name|hdmi_log
argument_list|(
literal|"    hdmi content type: %s\n"
argument_list|,
name|hdmi_content_type_get_name
argument_list|(
name|frame
operator|->
name|content_type
argument_list|)
argument_list|)
expr_stmt|;
name|hdmi_log
argument_list|(
literal|"    pixel repeat: %u\n"
argument_list|,
name|frame
operator|->
name|pixel_repeat
argument_list|)
expr_stmt|;
name|hdmi_log
argument_list|(
literal|"    bar top %u, bottom %u, left %u, right %u\n"
argument_list|,
name|frame
operator|->
name|top_bar
argument_list|,
name|frame
operator|->
name|bottom_bar
argument_list|,
name|frame
operator|->
name|left_bar
argument_list|,
name|frame
operator|->
name|right_bar
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|hdmi_spd_sdi_get_name
parameter_list|(
name|enum
name|hdmi_spd_sdi
name|sdi
parameter_list|)
block|{
empty_stmt|;
switch|switch
condition|(
name|sdi
condition|)
block|{
case|case
name|HDMI_SPD_SDI_UNKNOWN
case|:
return|return
literal|"Unknown"
return|;
case|case
name|HDMI_SPD_SDI_DSTB
case|:
return|return
literal|"Digital STB"
return|;
case|case
name|HDMI_SPD_SDI_DVDP
case|:
return|return
literal|"DVD Player"
return|;
case|case
name|HDMI_SPD_SDI_DVHS
case|:
return|return
literal|"D-VHS"
return|;
case|case
name|HDMI_SPD_SDI_HDDVR
case|:
return|return
literal|"HDD Videorecorder"
return|;
case|case
name|HDMI_SPD_SDI_DVC
case|:
return|return
literal|"DVC"
return|;
case|case
name|HDMI_SPD_SDI_DSC
case|:
return|return
literal|"DSC"
return|;
case|case
name|HDMI_SPD_SDI_VCD
case|:
return|return
literal|"Video CD"
return|;
case|case
name|HDMI_SPD_SDI_GAME
case|:
return|return
literal|"Game"
return|;
case|case
name|HDMI_SPD_SDI_PC
case|:
return|return
literal|"PC General"
return|;
case|case
name|HDMI_SPD_SDI_BD
case|:
return|return
literal|"Blu-Ray Disc (BD)"
return|;
case|case
name|HDMI_SPD_SDI_SACD
case|:
return|return
literal|"Super Audio CD"
return|;
case|case
name|HDMI_SPD_SDI_HDDVD
case|:
return|return
literal|"HD DVD"
return|;
case|case
name|HDMI_SPD_SDI_PMP
case|:
return|return
literal|"PMP"
return|;
block|}
return|return
literal|"Reserved"
return|;
block|}
end_function

begin_comment
comment|/**  * hdmi_spd_infoframe_log() - log info of HDMI SPD infoframe  * @level: logging level  * @dev: device  * @frame: HDMI SPD infoframe  */
end_comment

begin_function
specifier|static
name|void
name|hdmi_spd_infoframe_log
parameter_list|(
name|struct
name|hdmi_spd_infoframe
modifier|*
name|frame
parameter_list|)
block|{
name|uint8_t
name|buf
index|[
literal|17
index|]
decl_stmt|;
name|hdmi_infoframe_log_header
argument_list|(
operator|(
expr|struct
name|hdmi_any_infoframe
operator|*
operator|)
name|frame
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|buf
argument_list|,
name|frame
operator|->
name|vendor
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|hdmi_log
argument_list|(
literal|"    vendor: %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|buf
argument_list|,
name|frame
operator|->
name|product
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|hdmi_log
argument_list|(
literal|"    product: %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|hdmi_log
argument_list|(
literal|"    source device information: %s (0x%x)\n"
argument_list|,
name|hdmi_spd_sdi_get_name
argument_list|(
name|frame
operator|->
name|sdi
argument_list|)
argument_list|,
name|frame
operator|->
name|sdi
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|hdmi_audio_coding_type_get_name
parameter_list|(
name|enum
name|hdmi_audio_coding_type
name|coding_type
parameter_list|)
block|{
switch|switch
condition|(
name|coding_type
condition|)
block|{
case|case
name|HDMI_AUDIO_CODING_TYPE_STREAM
case|:
return|return
literal|"Refer to Stream Header"
return|;
case|case
name|HDMI_AUDIO_CODING_TYPE_PCM
case|:
return|return
literal|"PCM"
return|;
case|case
name|HDMI_AUDIO_CODING_TYPE_AC3
case|:
return|return
literal|"AC-3"
return|;
case|case
name|HDMI_AUDIO_CODING_TYPE_MPEG1
case|:
return|return
literal|"MPEG1"
return|;
case|case
name|HDMI_AUDIO_CODING_TYPE_MP3
case|:
return|return
literal|"MP3"
return|;
case|case
name|HDMI_AUDIO_CODING_TYPE_MPEG2
case|:
return|return
literal|"MPEG2"
return|;
case|case
name|HDMI_AUDIO_CODING_TYPE_AAC_LC
case|:
return|return
literal|"AAC"
return|;
case|case
name|HDMI_AUDIO_CODING_TYPE_DTS
case|:
return|return
literal|"DTS"
return|;
case|case
name|HDMI_AUDIO_CODING_TYPE_ATRAC
case|:
return|return
literal|"ATRAC"
return|;
case|case
name|HDMI_AUDIO_CODING_TYPE_DSD
case|:
return|return
literal|"One Bit Audio"
return|;
case|case
name|HDMI_AUDIO_CODING_TYPE_EAC3
case|:
return|return
literal|"Dolby Digital +"
return|;
case|case
name|HDMI_AUDIO_CODING_TYPE_DTS_HD
case|:
return|return
literal|"DTS-HD"
return|;
case|case
name|HDMI_AUDIO_CODING_TYPE_MLP
case|:
return|return
literal|"MAT (MLP)"
return|;
case|case
name|HDMI_AUDIO_CODING_TYPE_DST
case|:
return|return
literal|"DST"
return|;
case|case
name|HDMI_AUDIO_CODING_TYPE_WMA_PRO
case|:
return|return
literal|"WMA PRO"
return|;
case|case
name|HDMI_AUDIO_CODING_TYPE_CXT
case|:
return|return
literal|"Refer to CXT"
return|;
block|}
return|return
literal|"Invalid"
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|hdmi_audio_sample_size_get_name
parameter_list|(
name|enum
name|hdmi_audio_sample_size
name|sample_size
parameter_list|)
block|{
switch|switch
condition|(
name|sample_size
condition|)
block|{
case|case
name|HDMI_AUDIO_SAMPLE_SIZE_STREAM
case|:
return|return
literal|"Refer to Stream Header"
return|;
case|case
name|HDMI_AUDIO_SAMPLE_SIZE_16
case|:
return|return
literal|"16 bit"
return|;
case|case
name|HDMI_AUDIO_SAMPLE_SIZE_20
case|:
return|return
literal|"20 bit"
return|;
case|case
name|HDMI_AUDIO_SAMPLE_SIZE_24
case|:
return|return
literal|"24 bit"
return|;
block|}
return|return
literal|"Invalid"
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|hdmi_audio_sample_frequency_get_name
parameter_list|(
name|enum
name|hdmi_audio_sample_frequency
name|freq
parameter_list|)
block|{
switch|switch
condition|(
name|freq
condition|)
block|{
case|case
name|HDMI_AUDIO_SAMPLE_FREQUENCY_STREAM
case|:
return|return
literal|"Refer to Stream Header"
return|;
case|case
name|HDMI_AUDIO_SAMPLE_FREQUENCY_32000
case|:
return|return
literal|"32 kHz"
return|;
case|case
name|HDMI_AUDIO_SAMPLE_FREQUENCY_44100
case|:
return|return
literal|"44.1 kHz (CD)"
return|;
case|case
name|HDMI_AUDIO_SAMPLE_FREQUENCY_48000
case|:
return|return
literal|"48 kHz"
return|;
case|case
name|HDMI_AUDIO_SAMPLE_FREQUENCY_88200
case|:
return|return
literal|"88.2 kHz"
return|;
case|case
name|HDMI_AUDIO_SAMPLE_FREQUENCY_96000
case|:
return|return
literal|"96 kHz"
return|;
case|case
name|HDMI_AUDIO_SAMPLE_FREQUENCY_176400
case|:
return|return
literal|"176.4 kHz"
return|;
case|case
name|HDMI_AUDIO_SAMPLE_FREQUENCY_192000
case|:
return|return
literal|"192 kHz"
return|;
block|}
return|return
literal|"Invalid"
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|hdmi_audio_coding_type_ext_get_name
parameter_list|(
name|enum
name|hdmi_audio_coding_type_ext
name|ctx
parameter_list|)
block|{
switch|switch
condition|(
name|ctx
condition|)
block|{
case|case
name|HDMI_AUDIO_CODING_TYPE_EXT_CT
case|:
return|return
literal|"Refer to CT"
return|;
case|case
name|HDMI_AUDIO_CODING_TYPE_EXT_HE_AAC
case|:
return|return
literal|"HE AAC"
return|;
case|case
name|HDMI_AUDIO_CODING_TYPE_EXT_HE_AAC_V2
case|:
return|return
literal|"HE AAC v2"
return|;
case|case
name|HDMI_AUDIO_CODING_TYPE_EXT_MPEG_SURROUND
case|:
return|return
literal|"MPEG SURROUND"
return|;
case|case
name|HDMI_AUDIO_CODING_TYPE_EXT_MPEG4_HE_AAC
case|:
return|return
literal|"MPEG-4 HE AAC"
return|;
case|case
name|HDMI_AUDIO_CODING_TYPE_EXT_MPEG4_HE_AAC_V2
case|:
return|return
literal|"MPEG-4 HE AAC v2"
return|;
case|case
name|HDMI_AUDIO_CODING_TYPE_EXT_MPEG4_AAC_LC
case|:
return|return
literal|"MPEG-4 AAC LC"
return|;
case|case
name|HDMI_AUDIO_CODING_TYPE_EXT_DRA
case|:
return|return
literal|"DRA"
return|;
case|case
name|HDMI_AUDIO_CODING_TYPE_EXT_MPEG4_HE_AAC_SURROUND
case|:
return|return
literal|"MPEG-4 HE AAC + MPEG Surround"
return|;
case|case
name|HDMI_AUDIO_CODING_TYPE_EXT_MPEG4_AAC_LC_SURROUND
case|:
return|return
literal|"MPEG-4 AAC LC + MPEG Surround"
return|;
block|}
return|return
literal|"Reserved"
return|;
block|}
end_function

begin_comment
comment|/**  * hdmi_audio_infoframe_log() - log info of HDMI AUDIO infoframe  * @level: logging level  * @dev: device  * @frame: HDMI AUDIO infoframe  */
end_comment

begin_function
specifier|static
name|void
name|hdmi_audio_infoframe_log
parameter_list|(
name|struct
name|hdmi_audio_infoframe
modifier|*
name|frame
parameter_list|)
block|{
name|hdmi_infoframe_log_header
argument_list|(
operator|(
expr|struct
name|hdmi_any_infoframe
operator|*
operator|)
name|frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame
operator|->
name|channels
condition|)
name|hdmi_log
argument_list|(
literal|"    channels: %u\n"
argument_list|,
name|frame
operator|->
name|channels
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|hdmi_log
argument_list|(
literal|"    channels: Refer to stream header\n"
argument_list|)
expr_stmt|;
name|hdmi_log
argument_list|(
literal|"    coding type: %s\n"
argument_list|,
name|hdmi_audio_coding_type_get_name
argument_list|(
name|frame
operator|->
name|coding_type
argument_list|)
argument_list|)
expr_stmt|;
name|hdmi_log
argument_list|(
literal|"    sample size: %s\n"
argument_list|,
name|hdmi_audio_sample_size_get_name
argument_list|(
name|frame
operator|->
name|sample_size
argument_list|)
argument_list|)
expr_stmt|;
name|hdmi_log
argument_list|(
literal|"    sample frequency: %s\n"
argument_list|,
name|hdmi_audio_sample_frequency_get_name
argument_list|(
name|frame
operator|->
name|sample_frequency
argument_list|)
argument_list|)
expr_stmt|;
name|hdmi_log
argument_list|(
literal|"    coding type ext: %s\n"
argument_list|,
name|hdmi_audio_coding_type_ext_get_name
argument_list|(
name|frame
operator|->
name|coding_type_ext
argument_list|)
argument_list|)
expr_stmt|;
name|hdmi_log
argument_list|(
literal|"    channel allocation: 0x%x\n"
argument_list|,
name|frame
operator|->
name|channel_allocation
argument_list|)
expr_stmt|;
name|hdmi_log
argument_list|(
literal|"    level shift value: %u dB\n"
argument_list|,
name|frame
operator|->
name|level_shift_value
argument_list|)
expr_stmt|;
name|hdmi_log
argument_list|(
literal|"    downmix inhibit: %s\n"
argument_list|,
name|frame
operator|->
name|downmix_inhibit
condition|?
literal|"Yes"
else|:
literal|"No"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|hdmi_3d_structure_get_name
parameter_list|(
name|enum
name|hdmi_3d_structure
name|s3d_struct
parameter_list|)
block|{
if|if
condition|(
name|s3d_struct
operator|<
literal|0
operator|||
name|s3d_struct
operator|>
literal|0xf
condition|)
return|return
literal|"Invalid"
return|;
switch|switch
condition|(
name|s3d_struct
condition|)
block|{
case|case
name|HDMI_3D_STRUCTURE_FRAME_PACKING
case|:
return|return
literal|"Frame Packing"
return|;
case|case
name|HDMI_3D_STRUCTURE_FIELD_ALTERNATIVE
case|:
return|return
literal|"Field Alternative"
return|;
case|case
name|HDMI_3D_STRUCTURE_LINE_ALTERNATIVE
case|:
return|return
literal|"Line Alternative"
return|;
case|case
name|HDMI_3D_STRUCTURE_SIDE_BY_SIDE_FULL
case|:
return|return
literal|"Side-by-side (Full)"
return|;
case|case
name|HDMI_3D_STRUCTURE_L_DEPTH
case|:
return|return
literal|"L + Depth"
return|;
case|case
name|HDMI_3D_STRUCTURE_L_DEPTH_GFX_GFX_DEPTH
case|:
return|return
literal|"L + Depth + Graphics + Graphics-depth"
return|;
case|case
name|HDMI_3D_STRUCTURE_TOP_AND_BOTTOM
case|:
return|return
literal|"Top-and-Bottom"
return|;
case|case
name|HDMI_3D_STRUCTURE_SIDE_BY_SIDE_HALF
case|:
return|return
literal|"Side-by-side (Half)"
return|;
default|default:
break|break;
block|}
return|return
literal|"Reserved"
return|;
block|}
end_function

begin_comment
comment|/**  * hdmi_vendor_infoframe_log() - log info of HDMI VENDOR infoframe  * @level: logging level  * @dev: device  * @frame: HDMI VENDOR infoframe  */
end_comment

begin_function
specifier|static
name|void
name|hdmi_vendor_any_infoframe_log
parameter_list|(
name|union
name|hdmi_vendor_any_infoframe
modifier|*
name|frame
parameter_list|)
block|{
name|struct
name|hdmi_vendor_infoframe
modifier|*
name|hvf
init|=
operator|&
name|frame
operator|->
name|hdmi
decl_stmt|;
name|hdmi_infoframe_log_header
argument_list|(
operator|(
expr|struct
name|hdmi_any_infoframe
operator|*
operator|)
name|frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame
operator|->
name|any
operator|.
name|oui
operator|!=
name|HDMI_IEEE_OUI
condition|)
block|{
name|hdmi_log
argument_list|(
literal|"    not a HDMI vendor infoframe\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|hvf
operator|->
name|vic
operator|==
literal|0
operator|&&
name|hvf
operator|->
name|s3d_struct
operator|==
name|HDMI_3D_STRUCTURE_INVALID
condition|)
block|{
name|hdmi_log
argument_list|(
literal|"    empty frame\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|hvf
operator|->
name|vic
condition|)
name|hdmi_log
argument_list|(
literal|"    HDMI VIC: %u\n"
argument_list|,
name|hvf
operator|->
name|vic
argument_list|)
expr_stmt|;
if|if
condition|(
name|hvf
operator|->
name|s3d_struct
operator|!=
name|HDMI_3D_STRUCTURE_INVALID
condition|)
block|{
name|hdmi_log
argument_list|(
literal|"    3D structure: %s\n"
argument_list|,
name|hdmi_3d_structure_get_name
argument_list|(
name|hvf
operator|->
name|s3d_struct
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hvf
operator|->
name|s3d_struct
operator|>=
name|HDMI_3D_STRUCTURE_SIDE_BY_SIDE_HALF
condition|)
name|hdmi_log
argument_list|(
literal|"    3D extension data: %d\n"
argument_list|,
name|hvf
operator|->
name|s3d_ext_data
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * hdmi_infoframe_log() - log info of HDMI infoframe  * @level: logging level  * @dev: device  * @frame: HDMI infoframe  */
end_comment

begin_function
name|void
name|hdmi_infoframe_log
parameter_list|(
name|union
name|hdmi_infoframe
modifier|*
name|frame
parameter_list|)
block|{
switch|switch
condition|(
name|frame
operator|->
name|any
operator|.
name|type
condition|)
block|{
case|case
name|HDMI_INFOFRAME_TYPE_AVI
case|:
name|hdmi_avi_infoframe_log
argument_list|(
operator|&
name|frame
operator|->
name|avi
argument_list|)
expr_stmt|;
break|break;
case|case
name|HDMI_INFOFRAME_TYPE_SPD
case|:
name|hdmi_spd_infoframe_log
argument_list|(
operator|&
name|frame
operator|->
name|spd
argument_list|)
expr_stmt|;
break|break;
case|case
name|HDMI_INFOFRAME_TYPE_AUDIO
case|:
name|hdmi_audio_infoframe_log
argument_list|(
operator|&
name|frame
operator|->
name|audio
argument_list|)
expr_stmt|;
break|break;
case|case
name|HDMI_INFOFRAME_TYPE_VENDOR
case|:
name|hdmi_vendor_any_infoframe_log
argument_list|(
operator|&
name|frame
operator|->
name|vendor
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|hdmi_infoframe_log
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/**  * hdmi_avi_infoframe_unpack() - unpack binary buffer to a HDMI AVI infoframe  * @buffer: source buffer  * @frame: HDMI AVI infoframe  *  * Unpacks the information contained in binary @buffer into a structured  * @frame of the HDMI Auxiliary Video (AVI) information frame.  * Also verifies the checksum as required by section 5.3.5 of the HDMI 1.4  * specification.  *  * Returns 0 on success or a negative error code on failure.  */
end_comment

begin_function
specifier|static
name|int
name|hdmi_avi_infoframe_unpack
parameter_list|(
name|struct
name|hdmi_avi_infoframe
modifier|*
name|frame
parameter_list|,
name|void
modifier|*
name|buffer
parameter_list|)
block|{
name|uint8_t
modifier|*
name|ptr
init|=
name|buffer
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|ptr
index|[
literal|0
index|]
operator|!=
name|HDMI_INFOFRAME_TYPE_AVI
operator|||
name|ptr
index|[
literal|1
index|]
operator|!=
literal|2
operator|||
name|ptr
index|[
literal|2
index|]
operator|!=
name|HDMI_AVI_INFOFRAME_SIZE
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
name|hdmi_infoframe_checksum
argument_list|(
name|buffer
argument_list|,
name|HDMI_INFOFRAME_SIZE
argument_list|(
name|AVI
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|-
name|EINVAL
return|;
name|ret
operator|=
name|hdmi_avi_infoframe_init
argument_list|(
name|frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|ptr
operator|+=
name|HDMI_INFOFRAME_HEADER_SIZE
expr_stmt|;
name|frame
operator|->
name|colorspace
operator|=
operator|(
name|ptr
index|[
literal|0
index|]
operator|>>
literal|5
operator|)
operator|&
literal|0x3
expr_stmt|;
if|if
condition|(
name|ptr
index|[
literal|0
index|]
operator|&
literal|0x10
condition|)
name|frame
operator|->
name|active_aspect
operator|=
name|ptr
index|[
literal|1
index|]
operator|&
literal|0xf
expr_stmt|;
if|if
condition|(
name|ptr
index|[
literal|0
index|]
operator|&
literal|0x8
condition|)
block|{
name|frame
operator|->
name|top_bar
operator|=
operator|(
name|ptr
index|[
literal|5
index|]
operator|<<
literal|8
operator|)
operator|+
name|ptr
index|[
literal|6
index|]
expr_stmt|;
name|frame
operator|->
name|bottom_bar
operator|=
operator|(
name|ptr
index|[
literal|7
index|]
operator|<<
literal|8
operator|)
operator|+
name|ptr
index|[
literal|8
index|]
expr_stmt|;
block|}
if|if
condition|(
name|ptr
index|[
literal|0
index|]
operator|&
literal|0x4
condition|)
block|{
name|frame
operator|->
name|left_bar
operator|=
operator|(
name|ptr
index|[
literal|9
index|]
operator|<<
literal|8
operator|)
operator|+
name|ptr
index|[
literal|10
index|]
expr_stmt|;
name|frame
operator|->
name|right_bar
operator|=
operator|(
name|ptr
index|[
literal|11
index|]
operator|<<
literal|8
operator|)
operator|+
name|ptr
index|[
literal|12
index|]
expr_stmt|;
block|}
name|frame
operator|->
name|scan_mode
operator|=
name|ptr
index|[
literal|0
index|]
operator|&
literal|0x3
expr_stmt|;
name|frame
operator|->
name|colorimetry
operator|=
operator|(
name|ptr
index|[
literal|1
index|]
operator|>>
literal|6
operator|)
operator|&
literal|0x3
expr_stmt|;
name|frame
operator|->
name|picture_aspect
operator|=
operator|(
name|ptr
index|[
literal|1
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0x3
expr_stmt|;
name|frame
operator|->
name|active_aspect
operator|=
name|ptr
index|[
literal|1
index|]
operator|&
literal|0xf
expr_stmt|;
name|frame
operator|->
name|itc
operator|=
name|ptr
index|[
literal|2
index|]
operator|&
literal|0x80
condition|?
name|true
else|:
name|false
expr_stmt|;
name|frame
operator|->
name|extended_colorimetry
operator|=
operator|(
name|ptr
index|[
literal|2
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0x7
expr_stmt|;
name|frame
operator|->
name|quantization_range
operator|=
operator|(
name|ptr
index|[
literal|2
index|]
operator|>>
literal|2
operator|)
operator|&
literal|0x3
expr_stmt|;
name|frame
operator|->
name|nups
operator|=
name|ptr
index|[
literal|2
index|]
operator|&
literal|0x3
expr_stmt|;
name|frame
operator|->
name|video_code
operator|=
name|ptr
index|[
literal|3
index|]
operator|&
literal|0x7f
expr_stmt|;
name|frame
operator|->
name|ycc_quantization_range
operator|=
operator|(
name|ptr
index|[
literal|4
index|]
operator|>>
literal|6
operator|)
operator|&
literal|0x3
expr_stmt|;
name|frame
operator|->
name|content_type
operator|=
operator|(
name|ptr
index|[
literal|4
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0x3
expr_stmt|;
name|frame
operator|->
name|pixel_repeat
operator|=
name|ptr
index|[
literal|4
index|]
operator|&
literal|0xf
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * hdmi_spd_infoframe_unpack() - unpack binary buffer to a HDMI SPD infoframe  * @buffer: source buffer  * @frame: HDMI SPD infoframe  *  * Unpacks the information contained in binary @buffer into a structured  * @frame of the HDMI Source Product Description (SPD) information frame.  * Also verifies the checksum as required by section 5.3.5 of the HDMI 1.4  * specification.  *  * Returns 0 on success or a negative error code on failure.  */
end_comment

begin_function
specifier|static
name|int
name|hdmi_spd_infoframe_unpack
parameter_list|(
name|struct
name|hdmi_spd_infoframe
modifier|*
name|frame
parameter_list|,
name|void
modifier|*
name|buffer
parameter_list|)
block|{
name|uint8_t
modifier|*
name|ptr
init|=
name|buffer
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|ptr
index|[
literal|0
index|]
operator|!=
name|HDMI_INFOFRAME_TYPE_SPD
operator|||
name|ptr
index|[
literal|1
index|]
operator|!=
literal|1
operator|||
name|ptr
index|[
literal|2
index|]
operator|!=
name|HDMI_SPD_INFOFRAME_SIZE
condition|)
block|{
return|return
operator|-
name|EINVAL
return|;
block|}
if|if
condition|(
name|hdmi_infoframe_checksum
argument_list|(
name|buffer
argument_list|,
name|HDMI_INFOFRAME_SIZE
argument_list|(
name|SPD
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|-
name|EINVAL
return|;
name|ptr
operator|+=
name|HDMI_INFOFRAME_HEADER_SIZE
expr_stmt|;
name|ret
operator|=
name|hdmi_spd_infoframe_init
argument_list|(
name|frame
argument_list|,
name|ptr
argument_list|,
name|ptr
operator|+
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|frame
operator|->
name|sdi
operator|=
name|ptr
index|[
literal|24
index|]
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * hdmi_audio_infoframe_unpack() - unpack binary buffer to a HDMI AUDIO infoframe  * @buffer: source buffer  * @frame: HDMI Audio infoframe  *  * Unpacks the information contained in binary @buffer into a structured  * @frame of the HDMI Audio information frame.  * Also verifies the checksum as required by section 5.3.5 of the HDMI 1.4  * specification.  *  * Returns 0 on success or a negative error code on failure.  */
end_comment

begin_function
specifier|static
name|int
name|hdmi_audio_infoframe_unpack
parameter_list|(
name|struct
name|hdmi_audio_infoframe
modifier|*
name|frame
parameter_list|,
name|void
modifier|*
name|buffer
parameter_list|)
block|{
name|uint8_t
modifier|*
name|ptr
init|=
name|buffer
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|ptr
index|[
literal|0
index|]
operator|!=
name|HDMI_INFOFRAME_TYPE_AUDIO
operator|||
name|ptr
index|[
literal|1
index|]
operator|!=
literal|1
operator|||
name|ptr
index|[
literal|2
index|]
operator|!=
name|HDMI_AUDIO_INFOFRAME_SIZE
condition|)
block|{
return|return
operator|-
name|EINVAL
return|;
block|}
if|if
condition|(
name|hdmi_infoframe_checksum
argument_list|(
name|buffer
argument_list|,
name|HDMI_INFOFRAME_SIZE
argument_list|(
name|AUDIO
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|-
name|EINVAL
return|;
name|ret
operator|=
name|hdmi_audio_infoframe_init
argument_list|(
name|frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|ptr
operator|+=
name|HDMI_INFOFRAME_HEADER_SIZE
expr_stmt|;
name|frame
operator|->
name|channels
operator|=
name|ptr
index|[
literal|0
index|]
operator|&
literal|0x7
expr_stmt|;
name|frame
operator|->
name|coding_type
operator|=
operator|(
name|ptr
index|[
literal|0
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0xf
expr_stmt|;
name|frame
operator|->
name|sample_size
operator|=
name|ptr
index|[
literal|1
index|]
operator|&
literal|0x3
expr_stmt|;
name|frame
operator|->
name|sample_frequency
operator|=
operator|(
name|ptr
index|[
literal|1
index|]
operator|>>
literal|2
operator|)
operator|&
literal|0x7
expr_stmt|;
name|frame
operator|->
name|coding_type_ext
operator|=
name|ptr
index|[
literal|2
index|]
operator|&
literal|0x1f
expr_stmt|;
name|frame
operator|->
name|channel_allocation
operator|=
name|ptr
index|[
literal|3
index|]
expr_stmt|;
name|frame
operator|->
name|level_shift_value
operator|=
operator|(
name|ptr
index|[
literal|4
index|]
operator|>>
literal|3
operator|)
operator|&
literal|0xf
expr_stmt|;
name|frame
operator|->
name|downmix_inhibit
operator|=
name|ptr
index|[
literal|4
index|]
operator|&
literal|0x80
condition|?
name|true
else|:
name|false
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * hdmi_vendor_infoframe_unpack() - unpack binary buffer to a HDMI vendor infoframe  * @buffer: source buffer  * @frame: HDMI Vendor infoframe  *  * Unpacks the information contained in binary @buffer into a structured  * @frame of the HDMI Vendor information frame.  * Also verifies the checksum as required by section 5.3.5 of the HDMI 1.4  * specification.  *  * Returns 0 on success or a negative error code on failure.  */
end_comment

begin_function
specifier|static
name|int
name|hdmi_vendor_any_infoframe_unpack
parameter_list|(
name|union
name|hdmi_vendor_any_infoframe
modifier|*
name|frame
parameter_list|,
name|void
modifier|*
name|buffer
parameter_list|)
block|{
name|uint8_t
modifier|*
name|ptr
init|=
name|buffer
decl_stmt|;
name|size_t
name|length
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|uint8_t
name|hdmi_video_format
decl_stmt|;
name|struct
name|hdmi_vendor_infoframe
modifier|*
name|hvf
init|=
operator|&
name|frame
operator|->
name|hdmi
decl_stmt|;
if|if
condition|(
name|ptr
index|[
literal|0
index|]
operator|!=
name|HDMI_INFOFRAME_TYPE_VENDOR
operator|||
name|ptr
index|[
literal|1
index|]
operator|!=
literal|1
operator|||
operator|(
name|ptr
index|[
literal|2
index|]
operator|!=
literal|5
operator|&&
name|ptr
index|[
literal|2
index|]
operator|!=
literal|6
operator|)
condition|)
return|return
operator|-
name|EINVAL
return|;
name|length
operator|=
name|ptr
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|hdmi_infoframe_checksum
argument_list|(
name|buffer
argument_list|,
name|HDMI_INFOFRAME_HEADER_SIZE
operator|+
name|length
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|-
name|EINVAL
return|;
name|ptr
operator|+=
name|HDMI_INFOFRAME_HEADER_SIZE
expr_stmt|;
comment|/* HDMI OUI */
if|if
condition|(
operator|(
name|ptr
index|[
literal|0
index|]
operator|!=
literal|0x03
operator|)
operator|||
operator|(
name|ptr
index|[
literal|1
index|]
operator|!=
literal|0x0c
operator|)
operator|||
operator|(
name|ptr
index|[
literal|2
index|]
operator|!=
literal|0x00
operator|)
condition|)
return|return
operator|-
name|EINVAL
return|;
name|hdmi_video_format
operator|=
name|ptr
index|[
literal|3
index|]
operator|>>
literal|5
expr_stmt|;
if|if
condition|(
name|hdmi_video_format
operator|>
literal|0x2
condition|)
return|return
operator|-
name|EINVAL
return|;
name|ret
operator|=
name|hdmi_vendor_infoframe_init
argument_list|(
name|hvf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|hvf
operator|->
name|length
operator|=
name|length
expr_stmt|;
if|if
condition|(
name|hdmi_video_format
operator|==
literal|0x1
condition|)
block|{
name|hvf
operator|->
name|vic
operator|=
name|ptr
index|[
literal|4
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hdmi_video_format
operator|==
literal|0x2
condition|)
block|{
name|hvf
operator|->
name|s3d_struct
operator|=
name|ptr
index|[
literal|4
index|]
operator|>>
literal|4
expr_stmt|;
if|if
condition|(
name|hvf
operator|->
name|s3d_struct
operator|>=
name|HDMI_3D_STRUCTURE_SIDE_BY_SIDE_HALF
condition|)
block|{
if|if
condition|(
name|length
operator|==
literal|6
condition|)
name|hvf
operator|->
name|s3d_ext_data
operator|=
name|ptr
index|[
literal|5
index|]
operator|>>
literal|4
expr_stmt|;
else|else
return|return
operator|-
name|EINVAL
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * hdmi_infoframe_unpack() - unpack binary buffer to a HDMI infoframe  * @buffer: source buffer  * @frame: HDMI infoframe  *  * Unpacks the information contained in binary buffer @buffer into a structured  * @frame of a HDMI infoframe.  * Also verifies the checksum as required by section 5.3.5 of the HDMI 1.4  * specification.  *  * Returns 0 on success or a negative error code on failure.  */
end_comment

begin_function
name|int
name|hdmi_infoframe_unpack
parameter_list|(
name|union
name|hdmi_infoframe
modifier|*
name|frame
parameter_list|,
name|void
modifier|*
name|buffer
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|uint8_t
modifier|*
name|ptr
init|=
name|buffer
decl_stmt|;
switch|switch
condition|(
name|ptr
index|[
literal|0
index|]
condition|)
block|{
case|case
name|HDMI_INFOFRAME_TYPE_AVI
case|:
name|ret
operator|=
name|hdmi_avi_infoframe_unpack
argument_list|(
operator|&
name|frame
operator|->
name|avi
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
break|break;
case|case
name|HDMI_INFOFRAME_TYPE_SPD
case|:
name|ret
operator|=
name|hdmi_spd_infoframe_unpack
argument_list|(
operator|&
name|frame
operator|->
name|spd
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
break|break;
case|case
name|HDMI_INFOFRAME_TYPE_AUDIO
case|:
name|ret
operator|=
name|hdmi_audio_infoframe_unpack
argument_list|(
operator|&
name|frame
operator|->
name|audio
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
break|break;
case|case
name|HDMI_INFOFRAME_TYPE_VENDOR
case|:
name|ret
operator|=
name|hdmi_vendor_any_infoframe_unpack
argument_list|(
operator|&
name|frame
operator|->
name|vendor
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|hdmi_infoframe_unpack
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

