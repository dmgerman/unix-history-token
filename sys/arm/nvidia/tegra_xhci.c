begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2016 Michal Meloun<mmel@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * XHCI driver for Tegra SoCs.  */
end_comment

begin_include
include|#
directive|include
file|"opt_bus.h"
end_include

begin_include
include|#
directive|include
file|"opt_platform.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/clock.h>
end_include

begin_include
include|#
directive|include
file|<sys/condvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/firmware.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<dev/extres/clk/clk.h>
end_include

begin_include
include|#
directive|include
file|<dev/extres/hwreset/hwreset.h>
end_include

begin_include
include|#
directive|include
file|<dev/extres/phy/phy.h>
end_include

begin_include
include|#
directive|include
file|<dev/extres/regulator/regulator.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/ofw_bus.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/ofw_bus_subr.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_busdma.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_process.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_controller.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_bus.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/controller/xhci.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/controller/xhcireg.h>
end_include

begin_include
include|#
directive|include
file|<arm/nvidia/tegra_pmc.h>
end_include

begin_include
include|#
directive|include
file|"usbdevs.h"
end_include

begin_comment
comment|/* FPCI address space */
end_comment

begin_define
define|#
directive|define
name|T_XUSB_CFG_0
value|0x000
end_define

begin_define
define|#
directive|define
name|T_XUSB_CFG_1
value|0x004
end_define

begin_define
define|#
directive|define
name|CFG_1_BUS_MASTER
value|(1<< 2)
end_define

begin_define
define|#
directive|define
name|CFG_1_MEMORY_SPACE
value|(1<< 1)
end_define

begin_define
define|#
directive|define
name|CFG_1_IO_SPACE
value|(1<< 0)
end_define

begin_define
define|#
directive|define
name|T_XUSB_CFG_2
value|0x008
end_define

begin_define
define|#
directive|define
name|T_XUSB_CFG_3
value|0x00C
end_define

begin_define
define|#
directive|define
name|T_XUSB_CFG_4
value|0x010
end_define

begin_define
define|#
directive|define
name|CFG_4_BASE_ADDRESS
parameter_list|(
name|x
parameter_list|)
value|(((x)& 0x1FFFF)<< 15)
end_define

begin_define
define|#
directive|define
name|T_XUSB_CFG_5
value|0x014
end_define

begin_define
define|#
directive|define
name|T_XUSB_CFG_ARU_MAILBOX_CMD
value|0x0E4
end_define

begin_define
define|#
directive|define
name|ARU_MAILBOX_CMD_INT_EN
value|(1U<< 31)
end_define

begin_define
define|#
directive|define
name|ARU_MAILBOX_CMD_DEST_XHCI
value|(1<< 30)
end_define

begin_define
define|#
directive|define
name|ARU_MAILBOX_CMD_DEST_SMI
value|(1<< 29)
end_define

begin_define
define|#
directive|define
name|ARU_MAILBOX_CMD_DEST_PME
value|(1<< 28)
end_define

begin_define
define|#
directive|define
name|ARU_MAILBOX_CMD_DEST_FALC
value|(1<< 27)
end_define

begin_define
define|#
directive|define
name|T_XUSB_CFG_ARU_MAILBOX_DATA_IN
value|0x0E8
end_define

begin_define
define|#
directive|define
name|ARU_MAILBOX_DATA_IN_DATA
parameter_list|(
name|x
parameter_list|)
value|(((x)& 0xFFFFFF)<<  0)
end_define

begin_define
define|#
directive|define
name|ARU_MAILBOX_DATA_IN_TYPE
parameter_list|(
name|x
parameter_list|)
value|(((x)& 0x0000FF)<< 24)
end_define

begin_define
define|#
directive|define
name|T_XUSB_CFG_ARU_MAILBOX_DATA_OUT
value|0x0EC
end_define

begin_define
define|#
directive|define
name|ARU_MAILBOX_DATA_OUT_DATA
parameter_list|(
name|x
parameter_list|)
value|(((x)>>  0)& 0xFFFFFF)
end_define

begin_define
define|#
directive|define
name|ARU_MAILBOX_DATA_OUT_TYPE
parameter_list|(
name|x
parameter_list|)
value|(((x)>> 24)& 0x0000FF)
end_define

begin_define
define|#
directive|define
name|T_XUSB_CFG_ARU_MAILBOX_OWNER
value|0x0F0
end_define

begin_define
define|#
directive|define
name|ARU_MAILBOX_OWNER_SW
value|2
end_define

begin_define
define|#
directive|define
name|ARU_MAILBOX_OWNER_FW
value|1
end_define

begin_define
define|#
directive|define
name|ARU_MAILBOX_OWNER_NONE
value|0
end_define

begin_define
define|#
directive|define
name|XUSB_CFG_ARU_C11_CSBRANGE
value|0x41C
end_define

begin_comment
comment|/* ! UNDOCUMENTED ! */
end_comment

begin_define
define|#
directive|define
name|ARU_C11_CSBRANGE_PAGE
parameter_list|(
name|x
parameter_list|)
value|((x)>> 9)
end_define

begin_define
define|#
directive|define
name|ARU_C11_CSBRANGE_ADDR
parameter_list|(
name|x
parameter_list|)
value|(0x800 + ((x)& 0x1FF))
end_define

begin_define
define|#
directive|define
name|XUSB_CFG_ARU_SMI_INTR
value|0x428
end_define

begin_comment
comment|/* ! UNDOCUMENTED ! */
end_comment

begin_define
define|#
directive|define
name|ARU_SMI_INTR_EN
value|(1<< 3)
end_define

begin_define
define|#
directive|define
name|ARU_SMI_INTR_FW_HANG
value|(1<< 1)
end_define

begin_define
define|#
directive|define
name|XUSB_CFG_ARU_RST
value|0x42C
end_define

begin_comment
comment|/* ! UNDOCUMENTED ! */
end_comment

begin_define
define|#
directive|define
name|ARU_RST_RESET
value|(1<< 0)
end_define

begin_define
define|#
directive|define
name|XUSB_HOST_CONFIGURATION
value|0x180
end_define

begin_define
define|#
directive|define
name|CONFIGURATION_CLKEN_OVERRIDE
value|(1U<< 31)
end_define

begin_define
define|#
directive|define
name|CONFIGURATION_PW_NO_DEVSEL_ERR_CYA
value|(1<< 19)
end_define

begin_define
define|#
directive|define
name|CONFIGURATION_INITIATOR_READ_IDLE
value|(1<< 18)
end_define

begin_define
define|#
directive|define
name|CONFIGURATION_INITIATOR_WRITE_IDLE
value|(1<< 17)
end_define

begin_define
define|#
directive|define
name|CONFIGURATION_WDATA_LEAD_CYA
value|(1<< 15)
end_define

begin_define
define|#
directive|define
name|CONFIGURATION_WR_INTRLV_CYA
value|(1<< 14)
end_define

begin_define
define|#
directive|define
name|CONFIGURATION_TARGET_READ_IDLE
value|(1<< 11)
end_define

begin_define
define|#
directive|define
name|CONFIGURATION_TARGET_WRITE_IDLE
value|(1<< 10)
end_define

begin_define
define|#
directive|define
name|CONFIGURATION_MSI_VEC_EMPTY
value|(1<<  9)
end_define

begin_define
define|#
directive|define
name|CONFIGURATION_UFPCI_MSIAW
value|(1<<  7)
end_define

begin_define
define|#
directive|define
name|CONFIGURATION_UFPCI_PWPASSPW
value|(1<<  6)
end_define

begin_define
define|#
directive|define
name|CONFIGURATION_UFPCI_PASSPW
value|(1<<  5)
end_define

begin_define
define|#
directive|define
name|CONFIGURATION_UFPCI_PWPASSNPW
value|(1<<  4)
end_define

begin_define
define|#
directive|define
name|CONFIGURATION_DFPCI_PWPASSNPW
value|(1<<  3)
end_define

begin_define
define|#
directive|define
name|CONFIGURATION_DFPCI_RSPPASSPW
value|(1<<  2)
end_define

begin_define
define|#
directive|define
name|CONFIGURATION_DFPCI_PASSPW
value|(1<<  1)
end_define

begin_define
define|#
directive|define
name|CONFIGURATION_EN_FPCI
value|(1<<  0)
end_define

begin_comment
comment|/* IPFS address space */
end_comment

begin_define
define|#
directive|define
name|XUSB_HOST_FPCI_ERROR_MASKS
value|0x184
end_define

begin_define
define|#
directive|define
name|FPCI_ERROR_MASTER_ABORT
value|(1<<  2)
end_define

begin_define
define|#
directive|define
name|FPCI_ERRORI_DATA_ERROR
value|(1<<  1)
end_define

begin_define
define|#
directive|define
name|FPCI_ERROR_TARGET_ABORT
value|(1<<  0)
end_define

begin_define
define|#
directive|define
name|XUSB_HOST_INTR_MASK
value|0x188
end_define

begin_define
define|#
directive|define
name|INTR_IP_INT_MASK
value|(1<< 16)
end_define

begin_define
define|#
directive|define
name|INTR_MSI_MASK
value|(1<<  8)
end_define

begin_define
define|#
directive|define
name|INTR_INT_MASK
value|(1<<  0)
end_define

begin_define
define|#
directive|define
name|XUSB_HOST_CLKGATE_HYSTERESIS
value|0x1BC
end_define

begin_comment
comment|/* CSB Falcon CPU */
end_comment

begin_define
define|#
directive|define
name|XUSB_FALCON_CPUCTL
value|0x100
end_define

begin_define
define|#
directive|define
name|CPUCTL_STOPPED
value|(1<< 5)
end_define

begin_define
define|#
directive|define
name|CPUCTL_HALTED
value|(1<< 4)
end_define

begin_define
define|#
directive|define
name|CPUCTL_HRESET
value|(1<< 3)
end_define

begin_define
define|#
directive|define
name|CPUCTL_SRESET
value|(1<< 2)
end_define

begin_define
define|#
directive|define
name|CPUCTL_STARTCPU
value|(1<< 1)
end_define

begin_define
define|#
directive|define
name|CPUCTL_IINVAL
value|(1<< 0)
end_define

begin_define
define|#
directive|define
name|XUSB_FALCON_BOOTVEC
value|0x104
end_define

begin_define
define|#
directive|define
name|XUSB_FALCON_DMACTL
value|0x10C
end_define

begin_define
define|#
directive|define
name|XUSB_FALCON_IMFILLRNG1
value|0x154
end_define

begin_define
define|#
directive|define
name|IMFILLRNG1_TAG_HI
parameter_list|(
name|x
parameter_list|)
value|(((x)& 0xFFF)<< 16)
end_define

begin_define
define|#
directive|define
name|IMFILLRNG1_TAG_LO
parameter_list|(
name|x
parameter_list|)
value|(((x)& 0xFFF)<<  0)
end_define

begin_define
define|#
directive|define
name|XUSB_FALCON_IMFILLCTL
value|0x158
end_define

begin_comment
comment|/* CSB mempool */
end_comment

begin_define
define|#
directive|define
name|XUSB_CSB_MEMPOOL_APMAP
value|0x10181C
end_define

begin_define
define|#
directive|define
name|APMAP_BOOTPATH
value|(1U<< 31)
end_define

begin_define
define|#
directive|define
name|XUSB_CSB_MEMPOOL_ILOAD_ATTR
value|0x101A00
end_define

begin_define
define|#
directive|define
name|XUSB_CSB_MEMPOOL_ILOAD_BASE_LO
value|0x101A04
end_define

begin_define
define|#
directive|define
name|XUSB_CSB_MEMPOOL_ILOAD_BASE_HI
value|0x101A08
end_define

begin_define
define|#
directive|define
name|XUSB_CSB_MEMPOOL_L2IMEMOP_SIZE
value|0x101A10
end_define

begin_define
define|#
directive|define
name|L2IMEMOP_SIZE_OFFSET
parameter_list|(
name|x
parameter_list|)
value|(((x)& 0x3FF)<<  8)
end_define

begin_define
define|#
directive|define
name|L2IMEMOP_SIZE_SIZE
parameter_list|(
name|x
parameter_list|)
value|(((x)& 0x0FF)<< 24)
end_define

begin_define
define|#
directive|define
name|XUSB_CSB_MEMPOOL_L2IMEMOP_TRIG
value|0x101A14
end_define

begin_define
define|#
directive|define
name|L2IMEMOP_INVALIDATE_ALL
value|(0x40<< 24)
end_define

begin_define
define|#
directive|define
name|L2IMEMOP_LOAD_LOCKED_RESULT
value|(0x11<< 24)
end_define

begin_define
define|#
directive|define
name|XUSB_CSB_MEMPOOL_L2IMEMOP_RESULT
value|0x101A18
end_define

begin_define
define|#
directive|define
name|L2IMEMOP_RESULT_VLD
value|(1U<< 31)
end_define

begin_define
define|#
directive|define
name|XUSB_CSB_IMEM_BLOCK_SIZE
value|256
end_define

begin_define
define|#
directive|define
name|TEGRA_XHCI_SS_HIGH_SPEED
value|120000000
end_define

begin_define
define|#
directive|define
name|TEGRA_XHCI_SS_LOW_SPEED
value|12000000
end_define

begin_comment
comment|/* MBOX commands. */
end_comment

begin_define
define|#
directive|define
name|MBOX_CMD_MSG_ENABLED
value|1
end_define

begin_define
define|#
directive|define
name|MBOX_CMD_INC_FALC_CLOCK
value|2
end_define

begin_define
define|#
directive|define
name|MBOX_CMD_DEC_FALC_CLOCK
value|3
end_define

begin_define
define|#
directive|define
name|MBOX_CMD_INC_SSPI_CLOCK
value|4
end_define

begin_define
define|#
directive|define
name|MBOX_CMD_DEC_SSPI_CLOCK
value|5
end_define

begin_define
define|#
directive|define
name|MBOX_CMD_SET_BW
value|6
end_define

begin_define
define|#
directive|define
name|MBOX_CMD_SET_SS_PWR_GATING
value|7
end_define

begin_define
define|#
directive|define
name|MBOX_CMD_SET_SS_PWR_UNGATING
value|8
end_define

begin_define
define|#
directive|define
name|MBOX_CMD_SAVE_DFE_CTLE_CTX
value|9
end_define

begin_define
define|#
directive|define
name|MBOX_CMD_AIRPLANE_MODE_ENABLED
value|10
end_define

begin_define
define|#
directive|define
name|MBOX_CMD_AIRPLANE_MODE_DISABLED
value|11
end_define

begin_define
define|#
directive|define
name|MBOX_CMD_START_HSIC_IDLE
value|12
end_define

begin_define
define|#
directive|define
name|MBOX_CMD_STOP_HSIC_IDLE
value|13
end_define

begin_define
define|#
directive|define
name|MBOX_CMD_DBC_WAKE_STACK
value|14
end_define

begin_define
define|#
directive|define
name|MBOX_CMD_HSIC_PRETEND_CONNECT
value|15
end_define

begin_define
define|#
directive|define
name|MBOX_CMD_RESET_SSPI
value|16
end_define

begin_define
define|#
directive|define
name|MBOX_CMD_DISABLE_SS_LFPS_DETECTION
value|17
end_define

begin_define
define|#
directive|define
name|MBOX_CMD_ENABLE_SS_LFPS_DETECTION
value|18
end_define

begin_comment
comment|/* MBOX responses. */
end_comment

begin_define
define|#
directive|define
name|MBOX_CMD_ACK
value|(0x80 + 0)
end_define

begin_define
define|#
directive|define
name|MBOX_CMD_NAK
value|(0x80 + 1)
end_define

begin_define
define|#
directive|define
name|IPFS_WR4
parameter_list|(
name|_sc
parameter_list|,
name|_r
parameter_list|,
name|_v
parameter_list|)
value|bus_write_4((_sc)->mem_res_ipfs, (_r), (_v))
end_define

begin_define
define|#
directive|define
name|IPFS_RD4
parameter_list|(
name|_sc
parameter_list|,
name|_r
parameter_list|)
value|bus_read_4((_sc)->mem_res_ipfs, (_r))
end_define

begin_define
define|#
directive|define
name|FPCI_WR4
parameter_list|(
name|_sc
parameter_list|,
name|_r
parameter_list|,
name|_v
parameter_list|)
value|bus_write_4((_sc)->mem_res_fpci, (_r), (_v))
end_define

begin_define
define|#
directive|define
name|FPCI_RD4
parameter_list|(
name|_sc
parameter_list|,
name|_r
parameter_list|)
value|bus_read_4((_sc)->mem_res_fpci, (_r))
end_define

begin_define
define|#
directive|define
name|LOCK
parameter_list|(
name|_sc
parameter_list|)
value|mtx_lock(&(_sc)->mtx)
end_define

begin_define
define|#
directive|define
name|UNLOCK
parameter_list|(
name|_sc
parameter_list|)
value|mtx_unlock(&(_sc)->mtx)
end_define

begin_define
define|#
directive|define
name|SLEEP
parameter_list|(
name|_sc
parameter_list|,
name|timeout
parameter_list|)
define|\
value|mtx_sleep(sc,&sc->mtx, 0, "tegra_xhci", timeout);
end_define

begin_define
define|#
directive|define
name|LOCK_INIT
parameter_list|(
name|_sc
parameter_list|)
define|\
value|mtx_init(&_sc->mtx, device_get_nameunit(_sc->dev), "tegra_xhci", MTX_DEF)
end_define

begin_define
define|#
directive|define
name|LOCK_DESTROY
parameter_list|(
name|_sc
parameter_list|)
value|mtx_destroy(&_sc->mtx)
end_define

begin_define
define|#
directive|define
name|ASSERT_LOCKED
parameter_list|(
name|_sc
parameter_list|)
value|mtx_assert(&_sc->mtx, MA_OWNED)
end_define

begin_define
define|#
directive|define
name|ASSERT_UNLOCKED
parameter_list|(
name|_sc
parameter_list|)
value|mtx_assert(&_sc->mtx, MA_NOTOWNED)
end_define

begin_struct
struct|struct
name|tegra_xusb_fw_hdr
block|{
name|uint32_t
name|boot_loadaddr_in_imem
decl_stmt|;
name|uint32_t
name|boot_codedfi_offset
decl_stmt|;
name|uint32_t
name|boot_codetag
decl_stmt|;
name|uint32_t
name|boot_codesize
decl_stmt|;
name|uint32_t
name|phys_memaddr
decl_stmt|;
name|uint16_t
name|reqphys_memsize
decl_stmt|;
name|uint16_t
name|alloc_phys_memsize
decl_stmt|;
name|uint32_t
name|rodata_img_offset
decl_stmt|;
name|uint32_t
name|rodata_section_start
decl_stmt|;
name|uint32_t
name|rodata_section_end
decl_stmt|;
name|uint32_t
name|main_fnaddr
decl_stmt|;
name|uint32_t
name|fwimg_cksum
decl_stmt|;
name|uint32_t
name|fwimg_created_time
decl_stmt|;
name|uint32_t
name|imem_resident_start
decl_stmt|;
name|uint32_t
name|imem_resident_end
decl_stmt|;
name|uint32_t
name|idirect_start
decl_stmt|;
name|uint32_t
name|idirect_end
decl_stmt|;
name|uint32_t
name|l2_imem_start
decl_stmt|;
name|uint32_t
name|l2_imem_end
decl_stmt|;
name|uint32_t
name|version_id
decl_stmt|;
name|uint8_t
name|init_ddirect
decl_stmt|;
name|uint8_t
name|reserved
index|[
literal|3
index|]
decl_stmt|;
name|uint32_t
name|phys_addr_log_buffer
decl_stmt|;
name|uint32_t
name|total_log_entries
decl_stmt|;
name|uint32_t
name|dequeue_ptr
decl_stmt|;
name|uint32_t
name|dummy
index|[
literal|2
index|]
decl_stmt|;
name|uint32_t
name|fwimg_len
decl_stmt|;
name|uint8_t
name|magic
index|[
literal|8
index|]
decl_stmt|;
name|uint32_t
name|ss_low_power_entry_timeout
decl_stmt|;
name|uint8_t
name|num_hsic_port
decl_stmt|;
name|uint8_t
name|ss_portmap
decl_stmt|;
name|uint8_t
name|build
decl_stmt|;
name|uint8_t
name|padding
index|[
literal|137
index|]
decl_stmt|;
comment|/* Pad to 256 bytes */
block|}
struct|;
end_struct

begin_comment
comment|/* Compatible devices. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ofw_compat_data
name|compat_data
index|[]
init|=
block|{
block|{
literal|"nvidia,tegra124-xusb"
block|,
literal|1
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|tegra_xhci_softc
block|{
name|struct
name|xhci_softc
name|xhci_softc
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
name|struct
name|mtx
name|mtx
decl_stmt|;
name|struct
name|resource
modifier|*
name|mem_res_fpci
decl_stmt|;
name|struct
name|resource
modifier|*
name|mem_res_ipfs
decl_stmt|;
name|struct
name|resource
modifier|*
name|irq_res_mbox
decl_stmt|;
name|void
modifier|*
name|irq_hdl_mbox
decl_stmt|;
name|clk_t
name|clk_xusb_host
decl_stmt|;
name|clk_t
name|clk_xusb_gate
decl_stmt|;
name|clk_t
name|clk_xusb_falcon_src
decl_stmt|;
name|clk_t
name|clk_xusb_ss
decl_stmt|;
name|clk_t
name|clk_xusb_hs_src
decl_stmt|;
name|clk_t
name|clk_xusb_fs_src
decl_stmt|;
name|hwreset_t
name|hwreset_xusb_host
decl_stmt|;
name|hwreset_t
name|hwreset_xusb_ss
decl_stmt|;
name|regulator_t
name|supply_avddio_pex
decl_stmt|;
name|regulator_t
name|supply_dvddio_pex
decl_stmt|;
name|regulator_t
name|supply_avdd_usb
decl_stmt|;
name|regulator_t
name|supply_avdd_pll_utmip
decl_stmt|;
name|regulator_t
name|supply_avdd_pll_erefe
decl_stmt|;
name|regulator_t
name|supply_avdd_usb_ss_pll
decl_stmt|;
name|regulator_t
name|supply_hvdd_usb_ss
decl_stmt|;
name|regulator_t
name|supply_hvdd_usb_ss_pll_e
decl_stmt|;
name|phy_t
name|phy_usb2_0
decl_stmt|;
name|phy_t
name|phy_usb2_1
decl_stmt|;
name|phy_t
name|phy_usb2_2
decl_stmt|;
name|phy_t
name|phy_usb3_0
decl_stmt|;
name|struct
name|intr_config_hook
name|irq_hook
decl_stmt|;
name|bool
name|xhci_inited
decl_stmt|;
name|char
modifier|*
name|fw_name
decl_stmt|;
name|vm_offset_t
name|fw_vaddr
decl_stmt|;
name|vm_size_t
name|fw_size
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|uint32_t
name|CSB_RD4
parameter_list|(
name|struct
name|tegra_xhci_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|)
block|{
name|FPCI_WR4
argument_list|(
name|sc
argument_list|,
name|XUSB_CFG_ARU_C11_CSBRANGE
argument_list|,
name|ARU_C11_CSBRANGE_PAGE
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|FPCI_RD4
argument_list|(
name|sc
argument_list|,
name|ARU_C11_CSBRANGE_ADDR
argument_list|(
name|addr
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|CSB_WR4
parameter_list|(
name|struct
name|tegra_xhci_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
name|FPCI_WR4
argument_list|(
name|sc
argument_list|,
name|XUSB_CFG_ARU_C11_CSBRANGE
argument_list|,
name|ARU_C11_CSBRANGE_PAGE
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|FPCI_WR4
argument_list|(
name|sc
argument_list|,
name|ARU_C11_CSBRANGE_ADDR
argument_list|(
name|addr
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_fdt_resources
parameter_list|(
name|struct
name|tegra_xhci_softc
modifier|*
name|sc
parameter_list|,
name|phandle_t
name|node
parameter_list|)
block|{
name|int
name|rv
decl_stmt|;
name|rv
operator|=
name|regulator_get_by_ofw_property
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|0
argument_list|,
literal|"avddio-pex-supply"
argument_list|,
operator|&
name|sc
operator|->
name|supply_avddio_pex
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot get 'avddio-pex' regulator\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|rv
operator|=
name|regulator_get_by_ofw_property
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|0
argument_list|,
literal|"dvddio-pex-supply"
argument_list|,
operator|&
name|sc
operator|->
name|supply_dvddio_pex
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot get 'dvddio-pex' regulator\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|rv
operator|=
name|regulator_get_by_ofw_property
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|0
argument_list|,
literal|"avdd-usb-supply"
argument_list|,
operator|&
name|sc
operator|->
name|supply_avdd_usb
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot get 'avdd-usb' regulator\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|rv
operator|=
name|regulator_get_by_ofw_property
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|0
argument_list|,
literal|"avdd-pll-utmip-supply"
argument_list|,
operator|&
name|sc
operator|->
name|supply_avdd_pll_utmip
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot get 'avdd-pll-utmip' regulator\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|rv
operator|=
name|regulator_get_by_ofw_property
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|0
argument_list|,
literal|"avdd-pll-erefe-supply"
argument_list|,
operator|&
name|sc
operator|->
name|supply_avdd_pll_erefe
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot get 'avdd-pll-erefe' regulator\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|rv
operator|=
name|regulator_get_by_ofw_property
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|0
argument_list|,
literal|"avdd-usb-ss-pll-supply"
argument_list|,
operator|&
name|sc
operator|->
name|supply_avdd_usb_ss_pll
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot get 'avdd-usb-ss-pll' regulator\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|rv
operator|=
name|regulator_get_by_ofw_property
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|0
argument_list|,
literal|"hvdd-usb-ss-supply"
argument_list|,
operator|&
name|sc
operator|->
name|supply_hvdd_usb_ss
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot get 'hvdd-usb-ss' regulator\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|rv
operator|=
name|regulator_get_by_ofw_property
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|0
argument_list|,
literal|"hvdd-usb-ss-pll-e-supply"
argument_list|,
operator|&
name|sc
operator|->
name|supply_hvdd_usb_ss_pll_e
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot get 'hvdd-usb-ss-pll-e' regulator\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|rv
operator|=
name|hwreset_get_by_ofw_name
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|0
argument_list|,
literal|"xusb_host"
argument_list|,
operator|&
name|sc
operator|->
name|hwreset_xusb_host
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot get 'xusb_host' reset\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|rv
operator|=
name|hwreset_get_by_ofw_name
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|0
argument_list|,
literal|"xusb_ss"
argument_list|,
operator|&
name|sc
operator|->
name|hwreset_xusb_ss
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot get 'xusb_ss' reset\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|rv
operator|=
name|phy_get_by_ofw_name
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|0
argument_list|,
literal|"usb2-0"
argument_list|,
operator|&
name|sc
operator|->
name|phy_usb2_0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot get 'usb2-0' phy\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|rv
operator|=
name|phy_get_by_ofw_name
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|0
argument_list|,
literal|"usb2-1"
argument_list|,
operator|&
name|sc
operator|->
name|phy_usb2_1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot get 'usb2-1' phy\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|rv
operator|=
name|phy_get_by_ofw_name
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|0
argument_list|,
literal|"usb2-2"
argument_list|,
operator|&
name|sc
operator|->
name|phy_usb2_2
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot get 'usb2-2' phy\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|rv
operator|=
name|phy_get_by_ofw_name
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|0
argument_list|,
literal|"usb3-0"
argument_list|,
operator|&
name|sc
operator|->
name|phy_usb3_0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot get 'usb3-0' phy\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|rv
operator|=
name|clk_get_by_ofw_name
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|0
argument_list|,
literal|"xusb_host"
argument_list|,
operator|&
name|sc
operator|->
name|clk_xusb_host
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot get 'xusb_host' clock\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|rv
operator|=
name|clk_get_by_ofw_name
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|0
argument_list|,
literal|"xusb_falcon_src"
argument_list|,
operator|&
name|sc
operator|->
name|clk_xusb_falcon_src
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot get 'xusb_falcon_src' clock\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|rv
operator|=
name|clk_get_by_ofw_name
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|0
argument_list|,
literal|"xusb_ss"
argument_list|,
operator|&
name|sc
operator|->
name|clk_xusb_ss
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot get 'xusb_ss' clock\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|rv
operator|=
name|clk_get_by_ofw_name
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|0
argument_list|,
literal|"xusb_hs_src"
argument_list|,
operator|&
name|sc
operator|->
name|clk_xusb_hs_src
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot get 'xusb_hs_src' clock\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|rv
operator|=
name|clk_get_by_ofw_name
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|0
argument_list|,
literal|"xusb_fs_src"
argument_list|,
operator|&
name|sc
operator|->
name|clk_xusb_fs_src
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot get 'xusb_fs_src' clock\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|rv
operator|=
name|clk_get_by_ofw_index_prop
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|0
argument_list|,
literal|"freebsd,clock-xusb-gate"
argument_list|,
literal|0
argument_list|,
operator|&
name|sc
operator|->
name|clk_xusb_gate
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot get 'xusb_gate' clock\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|enable_fdt_resources
parameter_list|(
name|struct
name|tegra_xhci_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|rv
decl_stmt|;
name|rv
operator|=
name|hwreset_assert
argument_list|(
name|sc
operator|->
name|hwreset_xusb_host
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot reset 'xusb_host' reset\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
name|rv
operator|=
name|hwreset_assert
argument_list|(
name|sc
operator|->
name|hwreset_xusb_ss
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot reset 'xusb_ss' reset\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
name|rv
operator|=
name|regulator_enable
argument_list|(
name|sc
operator|->
name|supply_avddio_pex
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot enable 'avddio_pex' regulator\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
name|rv
operator|=
name|regulator_enable
argument_list|(
name|sc
operator|->
name|supply_dvddio_pex
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot enable 'dvddio_pex' regulator\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
name|rv
operator|=
name|regulator_enable
argument_list|(
name|sc
operator|->
name|supply_avdd_usb
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot enable 'avdd_usb' regulator\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
name|rv
operator|=
name|regulator_enable
argument_list|(
name|sc
operator|->
name|supply_avdd_pll_utmip
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot enable 'avdd_pll_utmip-5v' regulator\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
name|rv
operator|=
name|regulator_enable
argument_list|(
name|sc
operator|->
name|supply_avdd_pll_erefe
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot enable 'avdd_pll_erefe' regulator\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
name|rv
operator|=
name|regulator_enable
argument_list|(
name|sc
operator|->
name|supply_avdd_usb_ss_pll
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot enable 'avdd_usb_ss_pll' regulator\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
name|rv
operator|=
name|regulator_enable
argument_list|(
name|sc
operator|->
name|supply_hvdd_usb_ss
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot enable 'hvdd_usb_ss' regulator\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
name|rv
operator|=
name|regulator_enable
argument_list|(
name|sc
operator|->
name|supply_hvdd_usb_ss_pll_e
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot enable 'hvdd_usb_ss_pll_e' regulator\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
comment|/* Power off XUSB host and XUSB SS domains. */
name|rv
operator|=
name|tegra_powergate_power_off
argument_list|(
name|TEGRA_POWERGATE_XUSBA
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot powerdown  'xusba' domain\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
name|rv
operator|=
name|tegra_powergate_power_off
argument_list|(
name|TEGRA_POWERGATE_XUSBC
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot powerdown  'xusbc' domain\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
comment|/* Setup XUSB ss_src clock first */
name|clk_set_freq
argument_list|(
name|sc
operator|->
name|clk_xusb_ss
argument_list|,
name|TEGRA_XHCI_SS_HIGH_SPEED
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
return|return
operator|(
name|rv
operator|)
return|;
comment|/* The XUSB gate clock must be enabled before XUSBA can be powered. */
name|rv
operator|=
name|clk_enable
argument_list|(
name|sc
operator|->
name|clk_xusb_gate
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot enable 'xusb_gate' clock\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
comment|/* Power on XUSB host and XUSB SS domains. */
name|rv
operator|=
name|tegra_powergate_sequence_power_up
argument_list|(
name|TEGRA_POWERGATE_XUSBC
argument_list|,
name|sc
operator|->
name|clk_xusb_host
argument_list|,
name|sc
operator|->
name|hwreset_xusb_host
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot powerup 'xusbc' domain\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
name|rv
operator|=
name|tegra_powergate_sequence_power_up
argument_list|(
name|TEGRA_POWERGATE_XUSBA
argument_list|,
name|sc
operator|->
name|clk_xusb_ss
argument_list|,
name|sc
operator|->
name|hwreset_xusb_ss
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot powerup 'xusba' domain\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
comment|/* Enable rest of clocks */
name|rv
operator|=
name|clk_enable
argument_list|(
name|sc
operator|->
name|clk_xusb_falcon_src
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot enable 'xusb_falcon_src' clock\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
name|rv
operator|=
name|clk_enable
argument_list|(
name|sc
operator|->
name|clk_xusb_fs_src
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot enable 'xusb_fs_src' clock\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
name|rv
operator|=
name|clk_enable
argument_list|(
name|sc
operator|->
name|clk_xusb_hs_src
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot enable 'xusb_hs_src' clock\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
name|rv
operator|=
name|phy_enable
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|phy_usb2_0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot enable USB2_0 phy\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
name|rv
operator|=
name|phy_enable
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|phy_usb2_1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot enable USB2_1 phy\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
name|rv
operator|=
name|phy_enable
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|phy_usb2_2
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot enable USB2_2 phy\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
name|rv
operator|=
name|phy_enable
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|phy_usb3_0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot enable USB3_0 phy\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Respond by ACK/NAK back to FW */
end_comment

begin_function
specifier|static
name|void
name|mbox_send_ack
parameter_list|(
name|struct
name|tegra_xhci_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|cmd
parameter_list|,
name|uint32_t
name|data
parameter_list|)
block|{
name|uint32_t
name|reg
decl_stmt|;
name|reg
operator|=
name|ARU_MAILBOX_DATA_IN_TYPE
argument_list|(
name|cmd
argument_list|)
operator||
name|ARU_MAILBOX_DATA_IN_DATA
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|FPCI_WR4
argument_list|(
name|sc
argument_list|,
name|T_XUSB_CFG_ARU_MAILBOX_DATA_IN
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|FPCI_RD4
argument_list|(
name|sc
argument_list|,
name|T_XUSB_CFG_ARU_MAILBOX_CMD
argument_list|)
expr_stmt|;
name|reg
operator||=
name|ARU_MAILBOX_CMD_DEST_FALC
operator||
name|ARU_MAILBOX_CMD_INT_EN
expr_stmt|;
name|FPCI_WR4
argument_list|(
name|sc
argument_list|,
name|T_XUSB_CFG_ARU_MAILBOX_CMD
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Sent command to FW */
end_comment

begin_function
specifier|static
name|int
name|mbox_send_cmd
parameter_list|(
name|struct
name|tegra_xhci_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|cmd
parameter_list|,
name|uint32_t
name|data
parameter_list|)
block|{
name|uint32_t
name|reg
decl_stmt|;
name|int
name|i
decl_stmt|;
name|reg
operator|=
name|FPCI_RD4
argument_list|(
name|sc
argument_list|,
name|T_XUSB_CFG_ARU_MAILBOX_OWNER
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
name|ARU_MAILBOX_OWNER_NONE
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"CPU mailbox is busy: 0x%08X\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
comment|/* XXX Is this right? Retry loop? Wait before send? */
name|FPCI_WR4
argument_list|(
name|sc
argument_list|,
name|T_XUSB_CFG_ARU_MAILBOX_OWNER
argument_list|,
name|ARU_MAILBOX_OWNER_SW
argument_list|)
expr_stmt|;
name|reg
operator|=
name|FPCI_RD4
argument_list|(
name|sc
argument_list|,
name|T_XUSB_CFG_ARU_MAILBOX_OWNER
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
name|ARU_MAILBOX_OWNER_SW
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot acquire CPU mailbox: 0x%08X\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|reg
operator|=
name|ARU_MAILBOX_DATA_IN_TYPE
argument_list|(
name|cmd
argument_list|)
operator||
name|ARU_MAILBOX_DATA_IN_DATA
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|FPCI_WR4
argument_list|(
name|sc
argument_list|,
name|T_XUSB_CFG_ARU_MAILBOX_DATA_IN
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|FPCI_RD4
argument_list|(
name|sc
argument_list|,
name|T_XUSB_CFG_ARU_MAILBOX_CMD
argument_list|)
expr_stmt|;
name|reg
operator||=
name|ARU_MAILBOX_CMD_DEST_FALC
operator||
name|ARU_MAILBOX_CMD_INT_EN
expr_stmt|;
name|FPCI_WR4
argument_list|(
name|sc
argument_list|,
name|T_XUSB_CFG_ARU_MAILBOX_CMD
argument_list|,
name|reg
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|250
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|reg
operator|=
name|FPCI_RD4
argument_list|(
name|sc
argument_list|,
name|T_XUSB_CFG_ARU_MAILBOX_OWNER
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|==
name|ARU_MAILBOX_OWNER_NONE
condition|)
break|break;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Command response timeout: 0x%08X\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|process_msg
parameter_list|(
name|struct
name|tegra_xhci_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|req_cmd
parameter_list|,
name|uint32_t
name|req_data
parameter_list|,
name|uint32_t
modifier|*
name|resp_cmd
parameter_list|,
name|uint32_t
modifier|*
name|resp_data
parameter_list|)
block|{
name|uint64_t
name|freq
decl_stmt|;
name|int
name|rv
decl_stmt|;
comment|/* In most cases, data are echoed back. */
operator|*
name|resp_data
operator|=
name|req_data
expr_stmt|;
switch|switch
condition|(
name|req_cmd
condition|)
block|{
case|case
name|MBOX_CMD_INC_FALC_CLOCK
case|:
case|case
name|MBOX_CMD_DEC_FALC_CLOCK
case|:
name|rv
operator|=
name|clk_set_freq
argument_list|(
name|sc
operator|->
name|clk_xusb_falcon_src
argument_list|,
name|req_data
operator|*
literal|1000ULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
literal|0
condition|)
block|{
name|rv
operator|=
name|clk_get_freq
argument_list|(
name|sc
operator|->
name|clk_xusb_falcon_src
argument_list|,
operator|&
name|freq
argument_list|)
expr_stmt|;
operator|*
name|resp_data
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|freq
operator|/
literal|1000
argument_list|)
expr_stmt|;
block|}
operator|*
name|resp_cmd
operator|=
name|rv
operator|==
literal|0
condition|?
name|MBOX_CMD_ACK
else|:
name|MBOX_CMD_NAK
expr_stmt|;
break|break;
case|case
name|MBOX_CMD_INC_SSPI_CLOCK
case|:
case|case
name|MBOX_CMD_DEC_SSPI_CLOCK
case|:
name|rv
operator|=
name|clk_set_freq
argument_list|(
name|sc
operator|->
name|clk_xusb_ss
argument_list|,
name|req_data
operator|*
literal|1000ULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
literal|0
condition|)
block|{
name|rv
operator|=
name|clk_get_freq
argument_list|(
name|sc
operator|->
name|clk_xusb_ss
argument_list|,
operator|&
name|freq
argument_list|)
expr_stmt|;
operator|*
name|resp_data
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|freq
operator|/
literal|1000
argument_list|)
expr_stmt|;
block|}
operator|*
name|resp_cmd
operator|=
name|rv
operator|==
literal|0
condition|?
name|MBOX_CMD_ACK
else|:
name|MBOX_CMD_NAK
expr_stmt|;
break|break;
case|case
name|MBOX_CMD_SET_BW
case|:
comment|/* No respense is expected. */
operator|*
name|resp_cmd
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|MBOX_CMD_SET_SS_PWR_GATING
case|:
case|case
name|MBOX_CMD_SET_SS_PWR_UNGATING
case|:
operator|*
name|resp_cmd
operator|=
name|MBOX_CMD_NAK
expr_stmt|;
break|break;
case|case
name|MBOX_CMD_SAVE_DFE_CTLE_CTX
case|:
comment|/* Not implemented yet. */
operator|*
name|resp_cmd
operator|=
name|MBOX_CMD_ACK
expr_stmt|;
break|break;
case|case
name|MBOX_CMD_START_HSIC_IDLE
case|:
case|case
name|MBOX_CMD_STOP_HSIC_IDLE
case|:
comment|/* Not implemented yet. */
operator|*
name|resp_cmd
operator|=
name|MBOX_CMD_NAK
expr_stmt|;
break|break;
case|case
name|MBOX_CMD_DISABLE_SS_LFPS_DETECTION
case|:
case|case
name|MBOX_CMD_ENABLE_SS_LFPS_DETECTION
case|:
comment|/* Not implemented yet. */
operator|*
name|resp_cmd
operator|=
name|MBOX_CMD_NAK
expr_stmt|;
break|break;
case|case
name|MBOX_CMD_AIRPLANE_MODE_ENABLED
case|:
case|case
name|MBOX_CMD_AIRPLANE_MODE_DISABLED
case|:
case|case
name|MBOX_CMD_DBC_WAKE_STACK
case|:
case|case
name|MBOX_CMD_HSIC_PRETEND_CONNECT
case|:
case|case
name|MBOX_CMD_RESET_SSPI
case|:
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Received unused/unexpected command: %u\n"
argument_list|,
name|req_cmd
argument_list|)
expr_stmt|;
operator|*
name|resp_cmd
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Received unknown command: %u\n"
argument_list|,
name|req_cmd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|intr_mbox
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|tegra_xhci_softc
modifier|*
name|sc
decl_stmt|;
name|uint32_t
name|reg
decl_stmt|,
name|msg
decl_stmt|,
name|resp_cmd
decl_stmt|,
name|resp_data
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|tegra_xhci_softc
operator|*
operator|)
name|arg
expr_stmt|;
comment|/* Clear interrupt first */
name|reg
operator|=
name|FPCI_RD4
argument_list|(
name|sc
argument_list|,
name|XUSB_CFG_ARU_SMI_INTR
argument_list|)
expr_stmt|;
name|FPCI_WR4
argument_list|(
name|sc
argument_list|,
name|XUSB_CFG_ARU_SMI_INTR
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|&
name|ARU_SMI_INTR_FW_HANG
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"XUSB CPU firmware hang!!! CPUCTL: 0x%08X\n"
argument_list|,
name|CSB_RD4
argument_list|(
name|sc
argument_list|,
name|XUSB_FALCON_CPUCTL
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|msg
operator|=
name|FPCI_RD4
argument_list|(
name|sc
argument_list|,
name|T_XUSB_CFG_ARU_MAILBOX_DATA_OUT
argument_list|)
expr_stmt|;
name|resp_cmd
operator|=
literal|0
expr_stmt|;
name|process_msg
argument_list|(
name|sc
argument_list|,
name|ARU_MAILBOX_DATA_OUT_TYPE
argument_list|(
name|msg
argument_list|)
argument_list|,
name|ARU_MAILBOX_DATA_OUT_DATA
argument_list|(
name|msg
argument_list|)
argument_list|,
operator|&
name|resp_cmd
argument_list|,
operator|&
name|resp_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp_cmd
operator|!=
literal|0
condition|)
name|mbox_send_ack
argument_list|(
name|sc
argument_list|,
name|resp_cmd
argument_list|,
name|resp_data
argument_list|)
expr_stmt|;
else|else
name|FPCI_WR4
argument_list|(
name|sc
argument_list|,
name|T_XUSB_CFG_ARU_MAILBOX_OWNER
argument_list|,
name|ARU_MAILBOX_OWNER_NONE
argument_list|)
expr_stmt|;
name|reg
operator|=
name|FPCI_RD4
argument_list|(
name|sc
argument_list|,
name|T_XUSB_CFG_ARU_MAILBOX_CMD
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|ARU_MAILBOX_CMD_DEST_SMI
expr_stmt|;
name|FPCI_WR4
argument_list|(
name|sc
argument_list|,
name|T_XUSB_CFG_ARU_MAILBOX_CMD
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|load_fw
parameter_list|(
name|struct
name|tegra_xhci_softc
modifier|*
name|sc
parameter_list|)
block|{
specifier|const
name|struct
name|firmware
modifier|*
name|fw
decl_stmt|;
specifier|const
name|struct
name|tegra_xusb_fw_hdr
modifier|*
name|fw_hdr
decl_stmt|;
name|vm_paddr_t
name|fw_paddr
decl_stmt|,
name|fw_base
decl_stmt|;
name|vm_offset_t
name|fw_vaddr
decl_stmt|;
name|vm_size_t
name|fw_size
decl_stmt|;
name|uint32_t
name|code_tags
decl_stmt|,
name|code_size
decl_stmt|;
name|struct
name|clocktime
name|fw_clock
decl_stmt|;
name|struct
name|timespec
name|fw_timespec
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Reset ARU */
name|FPCI_WR4
argument_list|(
name|sc
argument_list|,
name|XUSB_CFG_ARU_RST
argument_list|,
name|ARU_RST_RESET
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|3000
argument_list|)
expr_stmt|;
comment|/* Check if FALCON already runs */
if|if
condition|(
name|CSB_RD4
argument_list|(
name|sc
argument_list|,
name|XUSB_CSB_MEMPOOL_ILOAD_BASE_LO
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"XUSB CPU is already loaded, CPUCTL: 0x%08X\n"
argument_list|,
name|CSB_RD4
argument_list|(
name|sc
argument_list|,
name|XUSB_FALCON_CPUCTL
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|fw
operator|=
name|firmware_get
argument_list|(
name|sc
operator|->
name|fw_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|fw
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot read xusb firmware\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
comment|/* Allocate uncached memory and copy firmware into. */
name|fw_hdr
operator|=
operator|(
specifier|const
expr|struct
name|tegra_xusb_fw_hdr
operator|*
operator|)
name|fw
operator|->
name|data
expr_stmt|;
name|fw_size
operator|=
name|fw_hdr
operator|->
name|fwimg_len
expr_stmt|;
name|fw_vaddr
operator|=
name|kmem_alloc_contig
argument_list|(
name|kernel_arena
argument_list|,
name|fw_size
argument_list|,
name|M_WAITOK
argument_list|,
literal|0
argument_list|,
operator|-
literal|1UL
argument_list|,
name|PAGE_SIZE
argument_list|,
literal|0
argument_list|,
name|VM_MEMATTR_UNCACHEABLE
argument_list|)
expr_stmt|;
name|fw_paddr
operator|=
name|vtophys
argument_list|(
name|fw_vaddr
argument_list|)
expr_stmt|;
name|fw_hdr
operator|=
operator|(
specifier|const
expr|struct
name|tegra_xusb_fw_hdr
operator|*
operator|)
name|fw_vaddr
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|void
operator|*
operator|)
name|fw_vaddr
argument_list|,
name|fw
operator|->
name|data
argument_list|,
name|fw_size
argument_list|)
expr_stmt|;
name|firmware_put
argument_list|(
name|fw
argument_list|,
name|FIRMWARE_UNLOAD
argument_list|)
expr_stmt|;
name|sc
operator|->
name|fw_vaddr
operator|=
name|fw_vaddr
expr_stmt|;
name|sc
operator|->
name|fw_size
operator|=
name|fw_size
expr_stmt|;
comment|/* Setup firmware physical address and size. */
name|fw_base
operator|=
name|fw_paddr
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|fw_hdr
argument_list|)
expr_stmt|;
name|CSB_WR4
argument_list|(
name|sc
argument_list|,
name|XUSB_CSB_MEMPOOL_ILOAD_ATTR
argument_list|,
name|fw_size
argument_list|)
expr_stmt|;
name|CSB_WR4
argument_list|(
name|sc
argument_list|,
name|XUSB_CSB_MEMPOOL_ILOAD_BASE_LO
argument_list|,
name|fw_base
operator|&
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
name|CSB_WR4
argument_list|(
name|sc
argument_list|,
name|XUSB_CSB_MEMPOOL_ILOAD_BASE_HI
argument_list|,
operator|(
name|uint64_t
operator|)
name|fw_base
operator|>>
literal|32
argument_list|)
expr_stmt|;
name|CSB_WR4
argument_list|(
name|sc
argument_list|,
name|XUSB_CSB_MEMPOOL_APMAP
argument_list|,
name|APMAP_BOOTPATH
argument_list|)
expr_stmt|;
comment|/* Invalidate full L2IMEM context. */
name|CSB_WR4
argument_list|(
name|sc
argument_list|,
name|XUSB_CSB_MEMPOOL_L2IMEMOP_TRIG
argument_list|,
name|L2IMEMOP_INVALIDATE_ALL
argument_list|)
expr_stmt|;
comment|/* Program load of L2IMEM by boot code. */
name|code_tags
operator|=
name|howmany
argument_list|(
name|fw_hdr
operator|->
name|boot_codetag
argument_list|,
name|XUSB_CSB_IMEM_BLOCK_SIZE
argument_list|)
expr_stmt|;
name|code_size
operator|=
name|howmany
argument_list|(
name|fw_hdr
operator|->
name|boot_codesize
argument_list|,
name|XUSB_CSB_IMEM_BLOCK_SIZE
argument_list|)
expr_stmt|;
name|CSB_WR4
argument_list|(
name|sc
argument_list|,
name|XUSB_CSB_MEMPOOL_L2IMEMOP_SIZE
argument_list|,
name|L2IMEMOP_SIZE_OFFSET
argument_list|(
name|code_tags
argument_list|)
operator||
name|L2IMEMOP_SIZE_SIZE
argument_list|(
name|code_size
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Execute L2IMEM boot code fetch. */
name|CSB_WR4
argument_list|(
name|sc
argument_list|,
name|XUSB_CSB_MEMPOOL_L2IMEMOP_TRIG
argument_list|,
name|L2IMEMOP_LOAD_LOCKED_RESULT
argument_list|)
expr_stmt|;
comment|/* Program FALCON auto-fill range and block count */
name|CSB_WR4
argument_list|(
name|sc
argument_list|,
name|XUSB_FALCON_IMFILLCTL
argument_list|,
name|code_size
argument_list|)
expr_stmt|;
name|CSB_WR4
argument_list|(
name|sc
argument_list|,
name|XUSB_FALCON_IMFILLRNG1
argument_list|,
name|IMFILLRNG1_TAG_LO
argument_list|(
name|code_tags
argument_list|)
operator||
name|IMFILLRNG1_TAG_HI
argument_list|(
name|code_tags
operator|+
name|code_size
argument_list|)
argument_list|)
expr_stmt|;
name|CSB_WR4
argument_list|(
name|sc
argument_list|,
name|XUSB_FALCON_DMACTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Wait for CPU */
for|for
control|(
name|i
operator|=
literal|500
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|CSB_RD4
argument_list|(
name|sc
argument_list|,
name|XUSB_CSB_MEMPOOL_L2IMEMOP_RESULT
argument_list|)
operator|&
name|L2IMEMOP_RESULT_VLD
condition|)
break|break;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Timedout while wating for DMA, "
literal|"state: 0x%08X\n"
argument_list|,
name|CSB_RD4
argument_list|(
name|sc
argument_list|,
name|XUSB_CSB_MEMPOOL_L2IMEMOP_RESULT
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
block|}
comment|/* Boot FALCON cpu */
name|CSB_WR4
argument_list|(
name|sc
argument_list|,
name|XUSB_FALCON_BOOTVEC
argument_list|,
name|fw_hdr
operator|->
name|boot_codetag
argument_list|)
expr_stmt|;
name|CSB_WR4
argument_list|(
name|sc
argument_list|,
name|XUSB_FALCON_CPUCTL
argument_list|,
name|CPUCTL_STARTCPU
argument_list|)
expr_stmt|;
comment|/* Wait for CPU */
for|for
control|(
name|i
operator|=
literal|50
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|CSB_RD4
argument_list|(
name|sc
argument_list|,
name|XUSB_FALCON_CPUCTL
argument_list|)
operator|==
name|CPUCTL_STOPPED
condition|)
break|break;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Timedout while wating for FALCON cpu, "
literal|"state: 0x%08X\n"
argument_list|,
name|CSB_RD4
argument_list|(
name|sc
argument_list|,
name|XUSB_FALCON_CPUCTL
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
block|}
name|fw_timespec
operator|.
name|tv_sec
operator|=
name|fw_hdr
operator|->
name|fwimg_created_time
expr_stmt|;
name|fw_timespec
operator|.
name|tv_nsec
operator|=
literal|0
expr_stmt|;
name|clock_ts_to_ct
argument_list|(
operator|&
name|fw_timespec
argument_list|,
operator|&
name|fw_clock
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|" Falcon firmware version: %02X.%02X.%04X,"
literal|" (%d/%d/%d %d:%02d:%02d UTC)\n"
argument_list|,
operator|(
name|fw_hdr
operator|->
name|version_id
operator|>>
literal|24
operator|)
operator|&
literal|0xFF
argument_list|,
operator|(
name|fw_hdr
operator|->
name|version_id
operator|>>
literal|15
operator|)
operator|&
literal|0xFF
argument_list|,
name|fw_hdr
operator|->
name|version_id
operator|&
literal|0xFFFF
argument_list|,
name|fw_clock
operator|.
name|day
argument_list|,
name|fw_clock
operator|.
name|mon
argument_list|,
name|fw_clock
operator|.
name|year
argument_list|,
name|fw_clock
operator|.
name|hour
argument_list|,
name|fw_clock
operator|.
name|min
argument_list|,
name|fw_clock
operator|.
name|sec
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|init_hw
parameter_list|(
name|struct
name|tegra_xhci_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|rv
decl_stmt|;
name|uint32_t
name|reg
decl_stmt|;
name|rman_res_t
name|base_addr
decl_stmt|;
name|base_addr
operator|=
name|rman_get_start
argument_list|(
name|sc
operator|->
name|xhci_softc
operator|.
name|sc_io_res
argument_list|)
expr_stmt|;
comment|/* Enable FPCI access */
name|reg
operator|=
name|IPFS_RD4
argument_list|(
name|sc
argument_list|,
name|XUSB_HOST_CONFIGURATION
argument_list|)
expr_stmt|;
name|reg
operator||=
name|CONFIGURATION_EN_FPCI
expr_stmt|;
name|IPFS_WR4
argument_list|(
name|sc
argument_list|,
name|XUSB_HOST_CONFIGURATION
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|IPFS_RD4
argument_list|(
name|sc
argument_list|,
name|XUSB_HOST_CONFIGURATION
argument_list|)
expr_stmt|;
comment|/* Program bar for XHCI base address */
name|reg
operator|=
name|FPCI_RD4
argument_list|(
name|sc
argument_list|,
name|T_XUSB_CFG_4
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|CFG_4_BASE_ADDRESS
argument_list|(
operator|~
literal|0
argument_list|)
expr_stmt|;
name|reg
operator||=
name|CFG_4_BASE_ADDRESS
argument_list|(
operator|(
name|uint32_t
operator|)
name|base_addr
operator|>>
literal|15
argument_list|)
expr_stmt|;
name|FPCI_WR4
argument_list|(
name|sc
argument_list|,
name|T_XUSB_CFG_4
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|FPCI_WR4
argument_list|(
name|sc
argument_list|,
name|T_XUSB_CFG_5
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
call|(
name|uint64_t
call|)
argument_list|(
name|base_addr
argument_list|)
operator|>>
literal|32
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Enable bus master */
name|reg
operator|=
name|FPCI_RD4
argument_list|(
name|sc
argument_list|,
name|T_XUSB_CFG_1
argument_list|)
expr_stmt|;
name|reg
operator||=
name|CFG_1_IO_SPACE
expr_stmt|;
name|reg
operator||=
name|CFG_1_MEMORY_SPACE
expr_stmt|;
name|reg
operator||=
name|CFG_1_BUS_MASTER
expr_stmt|;
name|FPCI_WR4
argument_list|(
name|sc
argument_list|,
name|T_XUSB_CFG_1
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Enable Interrupts */
name|reg
operator|=
name|IPFS_RD4
argument_list|(
name|sc
argument_list|,
name|XUSB_HOST_INTR_MASK
argument_list|)
expr_stmt|;
name|reg
operator||=
name|INTR_IP_INT_MASK
expr_stmt|;
name|IPFS_WR4
argument_list|(
name|sc
argument_list|,
name|XUSB_HOST_INTR_MASK
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Set hysteresis */
name|IPFS_WR4
argument_list|(
name|sc
argument_list|,
name|XUSB_HOST_CLKGATE_HYSTERESIS
argument_list|,
literal|128
argument_list|)
expr_stmt|;
name|rv
operator|=
name|load_fw
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
return|return
name|rv
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tegra_xhci_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ofw_bus_status_okay
argument_list|(
name|dev
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|ofw_bus_search_compatible
argument_list|(
name|dev
argument_list|,
name|compat_data
argument_list|)
operator|->
name|ocd_data
operator|!=
literal|0
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Nvidia Tegra XHCI controller"
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tegra_xhci_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|tegra_xhci_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|xhci_softc
modifier|*
name|xsc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|xsc
operator|=
operator|&
name|sc
operator|->
name|xhci_softc
expr_stmt|;
comment|/* during module unload there are lots of children leftover */
name|device_delete_children
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|xhci_inited
condition|)
block|{
name|usb_callout_drain
argument_list|(
operator|&
name|xsc
operator|->
name|sc_callout
argument_list|)
expr_stmt|;
name|xhci_halt_controller
argument_list|(
name|xsc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|xsc
operator|->
name|sc_irq_res
operator|&&
name|xsc
operator|->
name|sc_intr_hdl
condition|)
block|{
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|xsc
operator|->
name|sc_irq_res
argument_list|,
name|xsc
operator|->
name|sc_intr_hdl
argument_list|)
expr_stmt|;
name|xsc
operator|->
name|sc_intr_hdl
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|xsc
operator|->
name|sc_irq_res
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|rman_get_rid
argument_list|(
name|xsc
operator|->
name|sc_irq_res
argument_list|)
argument_list|,
name|xsc
operator|->
name|sc_irq_res
argument_list|)
expr_stmt|;
name|xsc
operator|->
name|sc_irq_res
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|xsc
operator|->
name|sc_io_res
operator|!=
name|NULL
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|rman_get_rid
argument_list|(
name|xsc
operator|->
name|sc_io_res
argument_list|)
argument_list|,
name|xsc
operator|->
name|sc_io_res
argument_list|)
expr_stmt|;
name|xsc
operator|->
name|sc_io_res
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|xhci_inited
condition|)
name|xhci_uninit
argument_list|(
name|xsc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|irq_hdl_mbox
operator|!=
name|NULL
condition|)
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq_res_mbox
argument_list|,
name|sc
operator|->
name|irq_hdl_mbox
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|fw_vaddr
operator|!=
literal|0
condition|)
name|kmem_free
argument_list|(
name|kernel_arena
argument_list|,
name|sc
operator|->
name|fw_vaddr
argument_list|,
name|sc
operator|->
name|fw_size
argument_list|)
expr_stmt|;
name|LOCK_DESTROY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tegra_xhci_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|tegra_xhci_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|xhci_softc
modifier|*
name|xsc
decl_stmt|;
name|int
name|rv
decl_stmt|,
name|rid
decl_stmt|;
name|phandle_t
name|node
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|sc
operator|->
name|fw_name
operator|=
literal|"tegra124_xusb_fw"
expr_stmt|;
name|node
operator|=
name|ofw_bus_get_node
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|xsc
operator|=
operator|&
name|sc
operator|->
name|xhci_softc
expr_stmt|;
name|LOCK_INIT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|rv
operator|=
name|get_fdt_resources
argument_list|(
name|sc
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
name|rv
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|rv
operator|=
name|enable_fdt_resources
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
name|rv
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* Allocate resources. */
name|rid
operator|=
literal|0
expr_stmt|;
name|xsc
operator|->
name|sc_io_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|xsc
operator|->
name|sc_io_res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Could not allocate HCD memory resources\n"
argument_list|)
expr_stmt|;
name|rv
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|rid
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|mem_res_fpci
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mem_res_fpci
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Could not allocate FPCI memory resources\n"
argument_list|)
expr_stmt|;
name|rv
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|rid
operator|=
literal|2
expr_stmt|;
name|sc
operator|->
name|mem_res_ipfs
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mem_res_ipfs
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Could not allocate IPFS memory resources\n"
argument_list|)
expr_stmt|;
name|rv
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|rid
operator|=
literal|0
expr_stmt|;
name|xsc
operator|->
name|sc_irq_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|xsc
operator|->
name|sc_irq_res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Could not allocate HCD IRQ resources\n"
argument_list|)
expr_stmt|;
name|rv
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|rid
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|irq_res_mbox
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|irq_res_mbox
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Could not allocate MBOX IRQ resources\n"
argument_list|)
expr_stmt|;
name|rv
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|rv
operator|=
name|init_hw
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Could not initialize  XUSB hardware\n"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* Wakeup and enable firmaware */
name|rv
operator|=
name|mbox_send_cmd
argument_list|(
name|sc
argument_list|,
name|MBOX_CMD_MSG_ENABLED
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Could not enable XUSB firmware\n"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* Fill data for XHCI driver. */
name|xsc
operator|->
name|sc_bus
operator|.
name|parent
operator|=
name|dev
expr_stmt|;
name|xsc
operator|->
name|sc_bus
operator|.
name|devices
operator|=
name|xsc
operator|->
name|sc_devices
expr_stmt|;
name|xsc
operator|->
name|sc_bus
operator|.
name|devices_max
operator|=
name|XHCI_MAX_DEVICES
expr_stmt|;
name|xsc
operator|->
name|sc_io_tag
operator|=
name|rman_get_bustag
argument_list|(
name|xsc
operator|->
name|sc_io_res
argument_list|)
expr_stmt|;
name|xsc
operator|->
name|sc_io_hdl
operator|=
name|rman_get_bushandle
argument_list|(
name|xsc
operator|->
name|sc_io_res
argument_list|)
expr_stmt|;
name|xsc
operator|->
name|sc_io_size
operator|=
name|rman_get_size
argument_list|(
name|xsc
operator|->
name|sc_io_res
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|xsc
operator|->
name|sc_vendor
argument_list|,
literal|"Nvidia"
argument_list|,
sizeof|sizeof
argument_list|(
name|xsc
operator|->
name|sc_vendor
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Add USB bus device. */
name|xsc
operator|->
name|sc_bus
operator|.
name|bdev
operator|=
name|device_add_child
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"usbus"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|xsc
operator|->
name|sc_bus
operator|.
name|bdev
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Could not add USB device\n"
argument_list|)
expr_stmt|;
name|rv
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|device_set_ivars
argument_list|(
name|xsc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|,
operator|&
name|xsc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
name|device_set_desc
argument_list|(
name|xsc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|,
literal|"Nvidia USB 3.0 controller"
argument_list|)
expr_stmt|;
name|rv
operator|=
name|xhci_init
argument_list|(
name|xsc
argument_list|,
name|sc
operator|->
name|dev
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"USB init failed: %d\n"
argument_list|,
name|rv
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|sc
operator|->
name|xhci_inited
operator|=
name|true
expr_stmt|;
name|rv
operator|=
name|xhci_start_controller
argument_list|(
name|xsc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Could not start XHCI controller: %d\n"
argument_list|,
name|rv
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|rv
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq_res_mbox
argument_list|,
name|INTR_TYPE_MISC
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|intr_mbox
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|irq_hdl_mbox
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Could not setup error IRQ: %d\n"
argument_list|,
name|rv
argument_list|)
expr_stmt|;
name|xsc
operator|->
name|sc_intr_hdl
operator|=
name|NULL
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|rv
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|xsc
operator|->
name|sc_irq_res
argument_list|,
name|INTR_TYPE_BIO
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
operator|(
name|driver_intr_t
operator|*
operator|)
name|xhci_interrupt
argument_list|,
name|xsc
argument_list|,
operator|&
name|xsc
operator|->
name|sc_intr_hdl
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Could not setup error IRQ: %d\n"
argument_list|,
name|rv
argument_list|)
expr_stmt|;
name|xsc
operator|->
name|sc_intr_hdl
operator|=
name|NULL
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* Probe the bus. */
name|rv
operator|=
name|device_probe_and_attach
argument_list|(
name|xsc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Could not initialize USB: %d\n"
argument_list|,
name|rv
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|error
label|:
name|panic
argument_list|(
literal|"XXXXX"
argument_list|)
expr_stmt|;
name|tegra_xhci_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|xhci_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|tegra_xhci_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|tegra_xhci_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|tegra_xhci_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|bus_generic_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|bus_generic_resume
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|bus_generic_shutdown
argument_list|)
block|,
comment|/* Bus interface */
name|DEVMETHOD
argument_list|(
name|bus_print_child
argument_list|,
name|bus_generic_print_child
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|xhci_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|DEFINE_CLASS_0
argument_list|(
name|xhci
argument_list|,
name|xhci_driver
argument_list|,
name|xhci_methods
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tegra_xhci_softc
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|tegra_xhci
argument_list|,
name|simplebus
argument_list|,
name|xhci_driver
argument_list|,
name|xhci_devclass
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|tegra_xhci
argument_list|,
name|usb
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

