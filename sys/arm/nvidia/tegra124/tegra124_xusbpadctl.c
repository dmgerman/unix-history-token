begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2016 Michal Meloun<mmel@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/fdt.h>
end_include

begin_include
include|#
directive|include
file|<dev/extres/hwreset/hwreset.h>
end_include

begin_include
include|#
directive|include
file|<dev/extres/phy/phy.h>
end_include

begin_include
include|#
directive|include
file|<dev/extres/regulator/regulator.h>
end_include

begin_include
include|#
directive|include
file|<dev/fdt/fdt_common.h>
end_include

begin_include
include|#
directive|include
file|<dev/fdt/fdt_pinctrl.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/openfirm.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/ofw_bus.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/ofw_bus_subr.h>
end_include

begin_include
include|#
directive|include
file|<arm/nvidia/tegra_efuse.h>
end_include

begin_include
include|#
directive|include
file|<gnu/dts/include/dt-bindings/pinctrl/pinctrl-tegra-xusb.h>
end_include

begin_include
include|#
directive|include
file|"phy_if.h"
end_include

begin_comment
comment|/* FUSE calibration data. */
end_comment

begin_define
define|#
directive|define
name|FUSE_XUSB_CALIB
value|0x0F0
end_define

begin_define
define|#
directive|define
name|FUSE_XUSB_CALIB_HS_CURR_LEVEL_123
parameter_list|(
name|x
parameter_list|)
value|(((x)>> 15)& 0x3F);
end_define

begin_define
define|#
directive|define
name|FUSE_XUSB_CALIB_HS_IREF_CAP
parameter_list|(
name|x
parameter_list|)
value|(((x)>> 13)& 0x03);
end_define

begin_define
define|#
directive|define
name|FUSE_XUSB_CALIB_HS_SQUELCH_LEVEL
parameter_list|(
name|x
parameter_list|)
value|(((x)>> 11)& 0x03);
end_define

begin_define
define|#
directive|define
name|FUSE_XUSB_CALIB_HS_TERM_RANGE_ADJ
parameter_list|(
name|x
parameter_list|)
value|(((x)>>  7)& 0x0F);
end_define

begin_define
define|#
directive|define
name|FUSE_XUSB_CALIB_HS_CURR_LEVEL_0
parameter_list|(
name|x
parameter_list|)
value|(((x)>>  0)& 0x3F);
end_define

begin_comment
comment|/* Registers. */
end_comment

begin_define
define|#
directive|define
name|XUSB_PADCTL_USB2_PAD_MUX
value|0x004
end_define

begin_define
define|#
directive|define
name|XUSB_PADCTL_USB2_PORT_CAP
value|0x008
end_define

begin_define
define|#
directive|define
name|USB2_PORT_CAP_ULPI_PORT_INTERNAL
value|(1<< 25)
end_define

begin_define
define|#
directive|define
name|USB2_PORT_CAP_ULPI_PORT_CAP
value|(1<< 24)
end_define

begin_define
define|#
directive|define
name|USB2_PORT_CAP_PORT_REVERSE_ID
parameter_list|(
name|p
parameter_list|)
value|(1<< (3 + (p) * 4))
end_define

begin_define
define|#
directive|define
name|USB2_PORT_CAP_PORT_INTERNAL
parameter_list|(
name|p
parameter_list|)
value|(1<< (2 + (p) * 4))
end_define

begin_define
define|#
directive|define
name|USB2_PORT_CAP_PORT_CAP
parameter_list|(
name|p
parameter_list|,
name|x
parameter_list|)
value|(((x)& 3)<< ((p) * 4))
end_define

begin_define
define|#
directive|define
name|USB2_PORT_CAP_PORT_CAP_OTG
value|0x3
end_define

begin_define
define|#
directive|define
name|USB2_PORT_CAP_PORT_CAP_DEVICE
value|0x2
end_define

begin_define
define|#
directive|define
name|USB2_PORT_CAP_PORT_CAP_HOST
value|0x1
end_define

begin_define
define|#
directive|define
name|USB2_PORT_CAP_PORT_CAP_DISABLED
value|0x0
end_define

begin_define
define|#
directive|define
name|XUSB_PADCTL_SS_PORT_MAP
value|0x014
end_define

begin_define
define|#
directive|define
name|SS_PORT_MAP_PORT_INTERNAL
parameter_list|(
name|p
parameter_list|)
value|(1<< (3 + (p) * 4))
end_define

begin_define
define|#
directive|define
name|SS_PORT_MAP_PORT_MAP
parameter_list|(
name|p
parameter_list|,
name|x
parameter_list|)
value|(((x)& 7)<< ((p) * 4))
end_define

begin_define
define|#
directive|define
name|XUSB_PADCTL_ELPG_PROGRAM
value|0x01C
end_define

begin_define
define|#
directive|define
name|ELPG_PROGRAM_AUX_MUX_LP0_VCORE_DOWN
value|(1<< 26)
end_define

begin_define
define|#
directive|define
name|ELPG_PROGRAM_AUX_MUX_LP0_CLAMP_EN_EARLY
value|(1<< 25)
end_define

begin_define
define|#
directive|define
name|ELPG_PROGRAM_AUX_MUX_LP0_CLAMP_EN
value|(1<< 24)
end_define

begin_define
define|#
directive|define
name|ELPG_PROGRAM_SSP_ELPG_VCORE_DOWN
parameter_list|(
name|x
parameter_list|)
value|(1<< (18 + (x) * 4))
end_define

begin_define
define|#
directive|define
name|ELPG_PROGRAM_SSP_ELPG_CLAMP_EN_EARLY
parameter_list|(
name|x
parameter_list|)
value|(1<< (17 + (x) * 4))
end_define

begin_define
define|#
directive|define
name|ELPG_PROGRAM_SSP_ELPG_CLAMP_EN
parameter_list|(
name|x
parameter_list|)
value|(1<< (16 + (x) * 4))
end_define

begin_define
define|#
directive|define
name|XUSB_PADCTL_IOPHY_PLL_P0_CTL1
value|0x040
end_define

begin_define
define|#
directive|define
name|IOPHY_PLL_P0_CTL1_PLL0_LOCKDET
value|(1<< 19)
end_define

begin_define
define|#
directive|define
name|IOPHY_PLL_P0_CTL1_REFCLK_SEL
parameter_list|(
name|x
parameter_list|)
value|(((x)& 0xF)<< 12)
end_define

begin_define
define|#
directive|define
name|IOPHY_PLL_P0_CTL1_PLL_RST
value|(1<< 1)
end_define

begin_define
define|#
directive|define
name|XUSB_PADCTL_IOPHY_PLL_P0_CTL2
value|0x044
end_define

begin_define
define|#
directive|define
name|IOPHY_PLL_P0_CTL2_REFCLKBUF_EN
value|(1<< 6)
end_define

begin_define
define|#
directive|define
name|IOPHY_PLL_P0_CTL2_TXCLKREF_EN
value|(1<< 5)
end_define

begin_define
define|#
directive|define
name|IOPHY_PLL_P0_CTL2_TXCLKREF_SEL
value|(1<< 4)
end_define

begin_define
define|#
directive|define
name|XUSB_PADCTL_IOPHY_USB3_PAD_CTL2
parameter_list|(
name|x
parameter_list|)
value|(0x058 + (x) * 4)
end_define

begin_define
define|#
directive|define
name|IOPHY_USB3_PAD_CTL2_CDR_CNTL
parameter_list|(
name|x
parameter_list|)
value|(((x)& 0x00FF)<<  4)
end_define

begin_define
define|#
directive|define
name|IOPHY_USB3_PAD_CTL2_RX_EQ
parameter_list|(
name|x
parameter_list|)
value|(((x)& 0xFFFF)<<  8)
end_define

begin_define
define|#
directive|define
name|IOPHY_USB3_PAD_CTL2_RX_WANDER
parameter_list|(
name|x
parameter_list|)
value|(((x)& 0x000F)<<  4)
end_define

begin_define
define|#
directive|define
name|IOPHY_USB3_PAD_CTL2_RX_TERM_CNTL
parameter_list|(
name|x
parameter_list|)
value|(((x)& 0x0003)<<  2)
end_define

begin_define
define|#
directive|define
name|IOPHY_USB3_PAD_CTL2_TX_TERM_CNTL
parameter_list|(
name|x
parameter_list|)
value|(((x)& 0x0003)<<  0)
end_define

begin_define
define|#
directive|define
name|XUSB_PADCTL_IOPHY_USB3_PAD_CTL4
parameter_list|(
name|x
parameter_list|)
value|(0x068 + (x) * 4)
end_define

begin_define
define|#
directive|define
name|XUSB_PADCTL_USB2_OTG_PAD_CTL0
parameter_list|(
name|x
parameter_list|)
value|(0x0A0 + (x) * 4)
end_define

begin_define
define|#
directive|define
name|USB2_OTG_PAD_CTL0_LSBIAS_SEL
value|(1<< 23)
end_define

begin_define
define|#
directive|define
name|USB2_OTG_PAD_CTL0_DISCON_DETECT_METHOD
value|(1<< 22)
end_define

begin_define
define|#
directive|define
name|USB2_OTG_PAD_CTL0_PD_ZI
value|(1<< 21)
end_define

begin_define
define|#
directive|define
name|USB2_OTG_PAD_CTL0_PD2
value|(1<< 20)
end_define

begin_define
define|#
directive|define
name|USB2_OTG_PAD_CTL0_PD
value|(1<< 19)
end_define

begin_define
define|#
directive|define
name|USB2_OTG_PAD_CTL0_TERM_EN
value|(1<< 18)
end_define

begin_define
define|#
directive|define
name|USB2_OTG_PAD_CTL0_LS_LS_FSLEW
parameter_list|(
name|x
parameter_list|)
value|(((x)& 0x03)<< 16)
end_define

begin_define
define|#
directive|define
name|USB2_OTG_PAD_CTL0_LS_RSLEW
parameter_list|(
name|x
parameter_list|)
value|(((x)& 0x03)<< 14)
end_define

begin_define
define|#
directive|define
name|USB2_OTG_PAD_CTL0_FS_SLEW
parameter_list|(
name|x
parameter_list|)
value|(((x)& 0x03)<< 12)
end_define

begin_define
define|#
directive|define
name|USB2_OTG_PAD_CTL0_HS_SLEW
parameter_list|(
name|x
parameter_list|)
value|(((x)& 0x3F)<<  6)
end_define

begin_define
define|#
directive|define
name|USB2_OTG_PAD_CTL0_HS_CURR_LEVEL
parameter_list|(
name|x
parameter_list|)
value|(((x)& 0x3F)<<  0)
end_define

begin_define
define|#
directive|define
name|XUSB_PADCTL_USB2_OTG_PAD_CTL1
parameter_list|(
name|x
parameter_list|)
value|(0x0AC + (x) * 4)
end_define

begin_define
define|#
directive|define
name|USB2_OTG_PAD_CTL1_RPU_RANGE_ADJ
parameter_list|(
name|x
parameter_list|)
value|(((x)& 0x3)<< 11)
end_define

begin_define
define|#
directive|define
name|USB2_OTG_PAD_CTL1_HS_IREF_CAP
parameter_list|(
name|x
parameter_list|)
value|(((x)& 0x3)<<  9)
end_define

begin_define
define|#
directive|define
name|USB2_OTG_PAD_CTL1_SPARE
parameter_list|(
name|x
parameter_list|)
value|(((x)& 0x3)<<  7)
end_define

begin_define
define|#
directive|define
name|USB2_OTG_PAD_CTL1_TERM_RANGE_ADJ
parameter_list|(
name|x
parameter_list|)
value|(((x)& 0xF)<<  3)
end_define

begin_define
define|#
directive|define
name|USB2_OTG_PAD_CTL1_PD_DR
value|(1<<  2)
end_define

begin_define
define|#
directive|define
name|USB2_OTG_PAD_CTL1_PD_DISC_FORCE_POWERUP
value|(1<<  1)
end_define

begin_define
define|#
directive|define
name|USB2_OTG_PAD_CTL1_PD_CHRP_FORCE_POWERUP
value|(1<<  0)
end_define

begin_define
define|#
directive|define
name|XUSB_PADCTL_USB2_BIAS_PAD_CTL0
value|0x0B8
end_define

begin_define
define|#
directive|define
name|USB2_BIAS_PAD_CTL0_ADJRPU
parameter_list|(
name|x
parameter_list|)
value|(((x)& 0x7)<< 14)
end_define

begin_define
define|#
directive|define
name|USB2_BIAS_PAD_CTL0_PD_TRK
value|(1<< 13)
end_define

begin_define
define|#
directive|define
name|USB2_BIAS_PAD_CTL0_PD
value|(1<< 12)
end_define

begin_define
define|#
directive|define
name|USB2_BIAS_PAD_CTL0_TERM_OFFSETL
parameter_list|(
name|x
parameter_list|)
value|(((x)& 0x3)<<  9)
end_define

begin_define
define|#
directive|define
name|USB2_BIAS_PAD_CTL0_VBUS_LEVEL
parameter_list|(
name|x
parameter_list|)
value|(((x)& 0x3)<<  7)
end_define

begin_define
define|#
directive|define
name|USB2_BIAS_PAD_CTL0_HS_CHIRP_LEVEL
parameter_list|(
name|x
parameter_list|)
value|(((x)& 0x3)<<  5)
end_define

begin_define
define|#
directive|define
name|USB2_BIAS_PAD_CTL0_HS_DISCON_LEVEL
parameter_list|(
name|x
parameter_list|)
value|(((x)& 0x7)<<  2)
end_define

begin_define
define|#
directive|define
name|USB2_BIAS_PAD_CTL0_HS_SQUELCH_LEVEL
parameter_list|(
name|x
parameter_list|)
value|(((x)& 0x3)<<  0)
end_define

begin_define
define|#
directive|define
name|XUSB_PADCTL_HSIC_PAD0_CTL0
value|0x0C8
end_define

begin_define
define|#
directive|define
name|HSIC_PAD0_CTL0_HSIC_OPT
parameter_list|(
name|x
parameter_list|)
value|(((x)& 0xF)<< 16)
end_define

begin_define
define|#
directive|define
name|HSIC_PAD0_CTL0_TX_SLEWN
parameter_list|(
name|x
parameter_list|)
value|(((x)& 0xF)<< 12)
end_define

begin_define
define|#
directive|define
name|HSIC_PAD0_CTL0_TX_SLEWP
parameter_list|(
name|x
parameter_list|)
value|(((x)& 0xF)<<  8)
end_define

begin_define
define|#
directive|define
name|HSIC_PAD0_CTL0_TX_RTUNEN
parameter_list|(
name|x
parameter_list|)
value|(((x)& 0xF)<<  4)
end_define

begin_define
define|#
directive|define
name|HSIC_PAD0_CTL0_TX_RTUNEP
parameter_list|(
name|x
parameter_list|)
value|(((x)& 0xF)<<  0)
end_define

begin_define
define|#
directive|define
name|XUSB_PADCTL_USB3_PAD_MUX
value|0x134
end_define

begin_define
define|#
directive|define
name|USB3_PAD_MUX_PCIE_IDDQ_DISABLE
parameter_list|(
name|x
parameter_list|)
value|(1<< (1 + (x)))
end_define

begin_define
define|#
directive|define
name|USB3_PAD_MUX_SATA_IDDQ_DISABLE
value|(1<< 6)
end_define

begin_define
define|#
directive|define
name|XUSB_PADCTL_IOPHY_PLL_S0_CTL1
value|0x138
end_define

begin_define
define|#
directive|define
name|IOPHY_PLL_S0_CTL1_PLL1_LOCKDET
value|(1<< 27)
end_define

begin_define
define|#
directive|define
name|IOPHY_PLL_S0_CTL1_PLL1_MODE
value|(1<< 24)
end_define

begin_define
define|#
directive|define
name|IOPHY_PLL_S0_CTL1_PLL_PWR_OVRD
value|(1<< 3)
end_define

begin_define
define|#
directive|define
name|IOPHY_PLL_S0_CTL1_PLL_RST_L
value|(1<< 1)
end_define

begin_define
define|#
directive|define
name|IOPHY_PLL_S0_CTL1_PLL_IDDQ
value|(1<< 0)
end_define

begin_define
define|#
directive|define
name|XUSB_PADCTL_IOPHY_PLL_S0_CTL2
value|0x13C
end_define

begin_define
define|#
directive|define
name|XUSB_PADCTL_IOPHY_PLL_S0_CTL3
value|0x140
end_define

begin_define
define|#
directive|define
name|XUSB_PADCTL_IOPHY_PLL_S0_CTL4
value|0x144
end_define

begin_define
define|#
directive|define
name|XUSB_PADCTL_IOPHY_MISC_PAD_S0_CTL1
value|0x148
end_define

begin_define
define|#
directive|define
name|IOPHY_MISC_PAD_S0_CTL1_IDDQ_OVRD
value|(1<< 1)
end_define

begin_define
define|#
directive|define
name|IOPHY_MISC_PAD_S0_CTL1_IDDQ
value|(1<< 0)
end_define

begin_define
define|#
directive|define
name|XUSB_PADCTL_IOPHY_MISC_PAD_S0_CTL2
value|0x14C
end_define

begin_define
define|#
directive|define
name|XUSB_PADCTL_IOPHY_MISC_PAD_S0_CTL3
value|0x150
end_define

begin_define
define|#
directive|define
name|XUSB_PADCTL_IOPHY_MISC_PAD_S0_CTL4
value|0x154
end_define

begin_define
define|#
directive|define
name|XUSB_PADCTL_IOPHY_MISC_PAD_S0_CTL5
value|0x158
end_define

begin_define
define|#
directive|define
name|XUSB_PADCTL_IOPHY_MISC_PAD_S0_CTL6
value|0x15C
end_define

begin_define
define|#
directive|define
name|WR4
parameter_list|(
name|_sc
parameter_list|,
name|_r
parameter_list|,
name|_v
parameter_list|)
value|bus_write_4((_sc)->mem_res, (_r), (_v))
end_define

begin_define
define|#
directive|define
name|RD4
parameter_list|(
name|_sc
parameter_list|,
name|_r
parameter_list|)
value|bus_read_4((_sc)->mem_res, (_r))
end_define

begin_struct
struct|struct
name|padctl_softc
block|{
name|device_t
name|dev
decl_stmt|;
name|struct
name|resource
modifier|*
name|mem_res
decl_stmt|;
name|hwreset_t
name|rst
decl_stmt|;
name|int
name|phy_ena_cnt
decl_stmt|;
comment|/* Fuses calibration data */
name|uint32_t
name|hs_curr_level_0
decl_stmt|;
name|uint32_t
name|hs_curr_level_123
decl_stmt|;
name|uint32_t
name|hs_iref_cap
decl_stmt|;
name|uint32_t
name|hs_term_range_adj
decl_stmt|;
name|uint32_t
name|hs_squelch_level
decl_stmt|;
name|uint32_t
name|hs_curr_level_offset
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|ofw_compat_data
name|compat_data
index|[]
init|=
block|{
block|{
literal|"nvidia,tegra124-xusb-padctl"
block|,
literal|1
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Ports. */
end_comment

begin_enum
enum|enum
name|padctl_port_type
block|{
name|PADCTL_PORT_USB2
block|,
name|PADCTL_PORT_ULPI
block|,
name|PADCTL_PORT_HSIC
block|,
name|PADCTL_PORT_USB3
block|, }
enum|;
end_enum

begin_struct_decl
struct_decl|struct
name|padctl_lane
struct_decl|;
end_struct_decl

begin_struct
struct|struct
name|padctl_port
block|{
name|enum
name|padctl_port_type
name|type
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|base_name
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|int
function_decl|(
modifier|*
name|init
function_decl|)
parameter_list|(
name|struct
name|padctl_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|padctl_port
modifier|*
name|port
parameter_list|)
function_decl|;
comment|/* Runtime data. */
name|phandle_t
name|xref
decl_stmt|;
name|bool
name|enabled
decl_stmt|;
name|regulator_t
name|supply_vbus
decl_stmt|;
comment|/* USB2, USB3 */
name|bool
name|internal
decl_stmt|;
comment|/* ULPI, USB2, USB3 */
name|uint32_t
name|companion
decl_stmt|;
comment|/* USB3 */
name|struct
name|padctl_lane
modifier|*
name|lane
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|usb3_port_init
parameter_list|(
name|struct
name|padctl_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|padctl_port
modifier|*
name|port
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|PORT
parameter_list|(
name|t
parameter_list|,
name|n
parameter_list|,
name|p
parameter_list|,
name|i
parameter_list|)
value|{						\ 	.type = t,							\ 	.name = n "-" #p,						\ 	.base_name = n,							\ 	.idx = p,							\ 	.init = i,							\ }
end_define

begin_decl_stmt
specifier|static
name|struct
name|padctl_port
name|ports_tbl
index|[]
init|=
block|{
name|PORT
argument_list|(
name|PADCTL_PORT_USB2
argument_list|,
literal|"usb2"
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
block|,
name|PORT
argument_list|(
name|PADCTL_PORT_USB2
argument_list|,
literal|"usb2"
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
block|,
name|PORT
argument_list|(
name|PADCTL_PORT_USB2
argument_list|,
literal|"usb2"
argument_list|,
literal|2
argument_list|,
name|NULL
argument_list|)
block|,
name|PORT
argument_list|(
name|PADCTL_PORT_ULPI
argument_list|,
literal|"ulpi"
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
block|,
name|PORT
argument_list|(
name|PADCTL_PORT_HSIC
argument_list|,
literal|"hsic"
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
block|,
name|PORT
argument_list|(
name|PADCTL_PORT_HSIC
argument_list|,
literal|"hsic"
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
block|,
name|PORT
argument_list|(
name|PADCTL_PORT_USB3
argument_list|,
literal|"usb3"
argument_list|,
literal|0
argument_list|,
name|usb3_port_init
argument_list|)
block|,
name|PORT
argument_list|(
name|PADCTL_PORT_USB3
argument_list|,
literal|"usb3"
argument_list|,
literal|1
argument_list|,
name|usb3_port_init
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pads - a group of lannes. */
end_comment

begin_enum
enum|enum
name|padctl_pad_type
block|{
name|PADCTL_PAD_USB2
block|,
name|PADCTL_PAD_ULPI
block|,
name|PADCTL_PAD_HSIC
block|,
name|PADCTL_PAD_PCIE
block|,
name|PADCTL_PAD_SATA
block|, }
enum|;
end_enum

begin_struct_decl
struct_decl|struct
name|padctl_lane
struct_decl|;
end_struct_decl

begin_struct
struct|struct
name|padctl_pad
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|enum
name|padctl_pad_type
name|type
decl_stmt|;
name|int
function_decl|(
modifier|*
name|powerup
function_decl|)
parameter_list|(
name|struct
name|padctl_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|padctl_lane
modifier|*
name|lane
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|powerdown
function_decl|)
parameter_list|(
name|struct
name|padctl_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|padctl_lane
modifier|*
name|lane
parameter_list|)
function_decl|;
comment|/* Runtime data. */
name|bool
name|enabled
decl_stmt|;
name|struct
name|padctl_lane
modifier|*
name|lanes
index|[
literal|8
index|]
decl_stmt|;
comment|/* Safe maximum value. */
name|int
name|nlanes
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|usb2_powerup
parameter_list|(
name|struct
name|padctl_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|padctl_lane
modifier|*
name|lane
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|usb2_powerdown
parameter_list|(
name|struct
name|padctl_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|padctl_lane
modifier|*
name|lane
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pcie_powerup
parameter_list|(
name|struct
name|padctl_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|padctl_lane
modifier|*
name|lane
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pcie_powerdown
parameter_list|(
name|struct
name|padctl_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|padctl_lane
modifier|*
name|lane
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sata_powerup
parameter_list|(
name|struct
name|padctl_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|padctl_lane
modifier|*
name|lane
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sata_powerdown
parameter_list|(
name|struct
name|padctl_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|padctl_lane
modifier|*
name|lane
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|PAD
parameter_list|(
name|n
parameter_list|,
name|t
parameter_list|,
name|u
parameter_list|,
name|d
parameter_list|)
value|{						\ 	.name = n,							\ 	.type = t,							\ 	.powerup = u,							\ 	.powerdown = d,							\ }
end_define

begin_decl_stmt
specifier|static
name|struct
name|padctl_pad
name|pads_tbl
index|[]
init|=
block|{
name|PAD
argument_list|(
literal|"usb2"
argument_list|,
name|PADCTL_PAD_USB2
argument_list|,
name|usb2_powerup
argument_list|,
name|usb2_powerdown
argument_list|)
block|,
name|PAD
argument_list|(
literal|"ulpi"
argument_list|,
name|PADCTL_PAD_ULPI
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
block|,
name|PAD
argument_list|(
literal|"hsic"
argument_list|,
name|PADCTL_PAD_HSIC
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
block|,
name|PAD
argument_list|(
literal|"pcie"
argument_list|,
name|PADCTL_PAD_PCIE
argument_list|,
name|pcie_powerup
argument_list|,
name|pcie_powerdown
argument_list|)
block|,
name|PAD
argument_list|(
literal|"sata"
argument_list|,
name|PADCTL_PAD_SATA
argument_list|,
name|sata_powerup
argument_list|,
name|sata_powerdown
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Lanes. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|otg_mux
index|[]
init|=
block|{
literal|"snps"
block|,
literal|"xusb"
block|,
literal|"uart"
block|,
literal|"rsvd"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|usb_mux
index|[]
init|=
block|{
literal|"snps"
block|,
literal|"xusb"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|pci_mux
index|[]
init|=
block|{
literal|"pcie"
block|,
literal|"usb3-ss"
block|,
literal|"sata"
block|,
literal|"rsvd"
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|padctl_lane
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|bus_size_t
name|reg
decl_stmt|;
name|uint32_t
name|shift
decl_stmt|;
name|uint32_t
name|mask
decl_stmt|;
name|char
modifier|*
modifier|*
name|mux
decl_stmt|;
name|int
name|nmux
decl_stmt|;
comment|/* Runtime data. */
name|bool
name|enabled
decl_stmt|;
name|phandle_t
name|xref
decl_stmt|;
name|struct
name|padctl_pad
modifier|*
name|pad
decl_stmt|;
name|struct
name|padctl_port
modifier|*
name|port
decl_stmt|;
name|int
name|mux_idx
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|LANE
parameter_list|(
name|n
parameter_list|,
name|p
parameter_list|,
name|r
parameter_list|,
name|s
parameter_list|,
name|m
parameter_list|,
name|mx
parameter_list|)
value|{					\ 	.name = n "-" #p,						\ 	.idx = p,							\ 	.reg = r,							\ 	.shift = s,							\ 	.mask = m,							\ 	.mux = mx,							\ 	.nmux = nitems(mx),						\ }
end_define

begin_decl_stmt
specifier|static
name|struct
name|padctl_lane
name|lanes_tbl
index|[]
init|=
block|{
name|LANE
argument_list|(
literal|"usb2"
argument_list|,
literal|0
argument_list|,
name|XUSB_PADCTL_USB2_PAD_MUX
argument_list|,
literal|0
argument_list|,
literal|0x3
argument_list|,
name|otg_mux
argument_list|)
block|,
name|LANE
argument_list|(
literal|"usb2"
argument_list|,
literal|1
argument_list|,
name|XUSB_PADCTL_USB2_PAD_MUX
argument_list|,
literal|2
argument_list|,
literal|0x3
argument_list|,
name|otg_mux
argument_list|)
block|,
name|LANE
argument_list|(
literal|"usb2"
argument_list|,
literal|2
argument_list|,
name|XUSB_PADCTL_USB2_PAD_MUX
argument_list|,
literal|4
argument_list|,
literal|0x3
argument_list|,
name|otg_mux
argument_list|)
block|,
name|LANE
argument_list|(
literal|"ulpi"
argument_list|,
literal|0
argument_list|,
name|XUSB_PADCTL_USB2_PAD_MUX
argument_list|,
literal|12
argument_list|,
literal|0x1
argument_list|,
name|usb_mux
argument_list|)
block|,
name|LANE
argument_list|(
literal|"hsic"
argument_list|,
literal|0
argument_list|,
name|XUSB_PADCTL_USB2_PAD_MUX
argument_list|,
literal|14
argument_list|,
literal|0x1
argument_list|,
name|usb_mux
argument_list|)
block|,
name|LANE
argument_list|(
literal|"hsic"
argument_list|,
literal|1
argument_list|,
name|XUSB_PADCTL_USB2_PAD_MUX
argument_list|,
literal|15
argument_list|,
literal|0x1
argument_list|,
name|usb_mux
argument_list|)
block|,
name|LANE
argument_list|(
literal|"pcie"
argument_list|,
literal|0
argument_list|,
name|XUSB_PADCTL_USB3_PAD_MUX
argument_list|,
literal|16
argument_list|,
literal|0x3
argument_list|,
name|pci_mux
argument_list|)
block|,
name|LANE
argument_list|(
literal|"pcie"
argument_list|,
literal|1
argument_list|,
name|XUSB_PADCTL_USB3_PAD_MUX
argument_list|,
literal|18
argument_list|,
literal|0x3
argument_list|,
name|pci_mux
argument_list|)
block|,
name|LANE
argument_list|(
literal|"pcie"
argument_list|,
literal|2
argument_list|,
name|XUSB_PADCTL_USB3_PAD_MUX
argument_list|,
literal|20
argument_list|,
literal|0x3
argument_list|,
name|pci_mux
argument_list|)
block|,
name|LANE
argument_list|(
literal|"pcie"
argument_list|,
literal|3
argument_list|,
name|XUSB_PADCTL_USB3_PAD_MUX
argument_list|,
literal|22
argument_list|,
literal|0x3
argument_list|,
name|pci_mux
argument_list|)
block|,
name|LANE
argument_list|(
literal|"pcie"
argument_list|,
literal|4
argument_list|,
name|XUSB_PADCTL_USB3_PAD_MUX
argument_list|,
literal|24
argument_list|,
literal|0x3
argument_list|,
name|pci_mux
argument_list|)
block|,
name|LANE
argument_list|(
literal|"sata"
argument_list|,
literal|0
argument_list|,
name|XUSB_PADCTL_USB3_PAD_MUX
argument_list|,
literal|26
argument_list|,
literal|0x3
argument_list|,
name|pci_mux
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Define all possible mappings for USB3 port lanes */
end_comment

begin_struct
struct|struct
name|padctl_lane_map
block|{
name|int
name|port_idx
decl_stmt|;
name|enum
name|padctl_pad_type
name|pad_type
decl_stmt|;
name|int
name|lane_idx
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|LANE_MAP
parameter_list|(
name|pi
parameter_list|,
name|pt
parameter_list|,
name|li
parameter_list|)
value|{						\ 	.port_idx = pi,							\ 	.pad_type = pt,							\ 	.lane_idx = li,							\ }
end_define

begin_decl_stmt
specifier|static
name|struct
name|padctl_lane_map
name|lane_map_tbl
index|[]
init|=
block|{
name|LANE_MAP
argument_list|(
literal|0
argument_list|,
name|PADCTL_PAD_PCIE
argument_list|,
literal|0
argument_list|)
block|,
comment|/* port USB3-0 -> lane PCIE-0 */
name|LANE_MAP
argument_list|(
literal|1
argument_list|,
name|PADCTL_PAD_PCIE
argument_list|,
literal|1
argument_list|)
block|,
comment|/* port USB3-1 -> lane PCIE-1 */
comment|/* -- or -- */
name|LANE_MAP
argument_list|(
literal|1
argument_list|,
name|PADCTL_PAD_SATA
argument_list|,
literal|0
argument_list|)
block|,
comment|/* port USB3-1 -> lane SATA-0 */
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|struct
name|padctl_port
modifier|*
name|search_lane_port
parameter_list|(
name|struct
name|padctl_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|padctl_lane
modifier|*
name|lane
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* -------------------------------------------------------------------------  *  *   PHY functions  */
end_comment

begin_function
specifier|static
name|int
name|usb3_port_init
parameter_list|(
name|struct
name|padctl_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|padctl_port
modifier|*
name|port
parameter_list|)
block|{
name|uint32_t
name|reg
decl_stmt|;
name|reg
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|XUSB_PADCTL_SS_PORT_MAP
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
operator|->
name|internal
condition|)
name|reg
operator|&=
operator|~
name|SS_PORT_MAP_PORT_INTERNAL
argument_list|(
name|port
operator|->
name|idx
argument_list|)
expr_stmt|;
else|else
name|reg
operator||=
name|SS_PORT_MAP_PORT_INTERNAL
argument_list|(
name|port
operator|->
name|idx
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|SS_PORT_MAP_PORT_MAP
argument_list|(
name|port
operator|->
name|idx
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
name|reg
operator||=
name|SS_PORT_MAP_PORT_MAP
argument_list|(
name|port
operator|->
name|idx
argument_list|,
name|port
operator|->
name|companion
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|XUSB_PADCTL_SS_PORT_MAP
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|XUSB_PADCTL_IOPHY_USB3_PAD_CTL2
argument_list|(
name|port
operator|->
name|idx
argument_list|)
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|IOPHY_USB3_PAD_CTL2_CDR_CNTL
argument_list|(
operator|~
literal|0
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|IOPHY_USB3_PAD_CTL2_RX_EQ
argument_list|(
operator|~
literal|0
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|IOPHY_USB3_PAD_CTL2_RX_WANDER
argument_list|(
operator|~
literal|0
argument_list|)
expr_stmt|;
name|reg
operator||=
name|IOPHY_USB3_PAD_CTL2_CDR_CNTL
argument_list|(
literal|0x24
argument_list|)
expr_stmt|;
name|reg
operator||=
name|IOPHY_USB3_PAD_CTL2_RX_EQ
argument_list|(
literal|0xF070
argument_list|)
expr_stmt|;
name|reg
operator||=
name|IOPHY_USB3_PAD_CTL2_RX_WANDER
argument_list|(
literal|0xF
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|XUSB_PADCTL_IOPHY_USB3_PAD_CTL2
argument_list|(
name|port
operator|->
name|idx
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|XUSB_PADCTL_IOPHY_USB3_PAD_CTL4
argument_list|(
name|port
operator|->
name|idx
argument_list|)
argument_list|,
literal|0x002008EE
argument_list|)
expr_stmt|;
name|reg
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|XUSB_PADCTL_ELPG_PROGRAM
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|ELPG_PROGRAM_SSP_ELPG_VCORE_DOWN
argument_list|(
name|port
operator|->
name|idx
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|XUSB_PADCTL_ELPG_PROGRAM
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|reg
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|XUSB_PADCTL_ELPG_PROGRAM
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|ELPG_PROGRAM_SSP_ELPG_CLAMP_EN_EARLY
argument_list|(
name|port
operator|->
name|idx
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|XUSB_PADCTL_ELPG_PROGRAM
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|reg
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|XUSB_PADCTL_ELPG_PROGRAM
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|ELPG_PROGRAM_SSP_ELPG_CLAMP_EN
argument_list|(
name|port
operator|->
name|idx
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|XUSB_PADCTL_ELPG_PROGRAM
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pcie_powerup
parameter_list|(
name|struct
name|padctl_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|padctl_lane
modifier|*
name|lane
parameter_list|)
block|{
name|uint32_t
name|reg
decl_stmt|;
name|int
name|i
decl_stmt|;
name|reg
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|XUSB_PADCTL_IOPHY_PLL_P0_CTL1
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|IOPHY_PLL_P0_CTL1_REFCLK_SEL
argument_list|(
operator|~
literal|0
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|XUSB_PADCTL_IOPHY_PLL_P0_CTL1
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|reg
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|XUSB_PADCTL_IOPHY_PLL_P0_CTL2
argument_list|)
expr_stmt|;
name|reg
operator||=
name|IOPHY_PLL_P0_CTL2_REFCLKBUF_EN
expr_stmt|;
name|reg
operator||=
name|IOPHY_PLL_P0_CTL2_TXCLKREF_EN
expr_stmt|;
name|reg
operator||=
name|IOPHY_PLL_P0_CTL2_TXCLKREF_SEL
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|XUSB_PADCTL_IOPHY_PLL_P0_CTL2
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|reg
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|XUSB_PADCTL_IOPHY_PLL_P0_CTL1
argument_list|)
expr_stmt|;
name|reg
operator||=
name|IOPHY_PLL_P0_CTL1_PLL_RST
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|XUSB_PADCTL_IOPHY_PLL_P0_CTL1
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|100
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|reg
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|XUSB_PADCTL_IOPHY_PLL_P0_CTL1
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|&
name|IOPHY_PLL_P0_CTL1_PLL0_LOCKDET
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Failed to power up PCIe phy\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
block|}
name|reg
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|XUSB_PADCTL_USB3_PAD_MUX
argument_list|)
expr_stmt|;
name|reg
operator||=
name|USB3_PAD_MUX_PCIE_IDDQ_DISABLE
argument_list|(
name|lane
operator|->
name|idx
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|XUSB_PADCTL_USB3_PAD_MUX
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pcie_powerdown
parameter_list|(
name|struct
name|padctl_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|padctl_lane
modifier|*
name|lane
parameter_list|)
block|{
name|uint32_t
name|reg
decl_stmt|;
name|reg
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|XUSB_PADCTL_USB3_PAD_MUX
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|USB3_PAD_MUX_PCIE_IDDQ_DISABLE
argument_list|(
name|lane
operator|->
name|idx
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|XUSB_PADCTL_USB3_PAD_MUX
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|XUSB_PADCTL_IOPHY_PLL_P0_CTL1
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|IOPHY_PLL_P0_CTL1_PLL_RST
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|XUSB_PADCTL_IOPHY_PLL_P0_CTL1
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sata_powerup
parameter_list|(
name|struct
name|padctl_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|padctl_lane
modifier|*
name|lane
parameter_list|)
block|{
name|uint32_t
name|reg
decl_stmt|;
name|int
name|i
decl_stmt|;
name|reg
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|XUSB_PADCTL_IOPHY_MISC_PAD_S0_CTL1
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|IOPHY_MISC_PAD_S0_CTL1_IDDQ_OVRD
expr_stmt|;
name|reg
operator|&=
operator|~
name|IOPHY_MISC_PAD_S0_CTL1_IDDQ
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|XUSB_PADCTL_IOPHY_MISC_PAD_S0_CTL1
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|XUSB_PADCTL_IOPHY_PLL_S0_CTL1
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|IOPHY_PLL_S0_CTL1_PLL_PWR_OVRD
expr_stmt|;
name|reg
operator|&=
operator|~
name|IOPHY_PLL_S0_CTL1_PLL_IDDQ
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|XUSB_PADCTL_IOPHY_PLL_S0_CTL1
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|XUSB_PADCTL_IOPHY_PLL_S0_CTL1
argument_list|)
expr_stmt|;
name|reg
operator||=
name|IOPHY_PLL_S0_CTL1_PLL1_MODE
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|XUSB_PADCTL_IOPHY_PLL_S0_CTL1
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|XUSB_PADCTL_IOPHY_PLL_S0_CTL1
argument_list|)
expr_stmt|;
name|reg
operator||=
name|IOPHY_PLL_S0_CTL1_PLL_RST_L
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|XUSB_PADCTL_IOPHY_PLL_S0_CTL1
argument_list|,
name|reg
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|100
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|reg
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|XUSB_PADCTL_IOPHY_PLL_S0_CTL1
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|&
name|IOPHY_PLL_S0_CTL1_PLL1_LOCKDET
condition|)
break|break;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Failed to power up SATA phy\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
block|}
name|reg
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|XUSB_PADCTL_USB3_PAD_MUX
argument_list|)
expr_stmt|;
name|reg
operator||=
name|IOPHY_PLL_S0_CTL1_PLL_RST_L
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|XUSB_PADCTL_USB3_PAD_MUX
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|XUSB_PADCTL_USB3_PAD_MUX
argument_list|)
expr_stmt|;
name|reg
operator||=
name|USB3_PAD_MUX_SATA_IDDQ_DISABLE
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|XUSB_PADCTL_USB3_PAD_MUX
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sata_powerdown
parameter_list|(
name|struct
name|padctl_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|padctl_lane
modifier|*
name|lane
parameter_list|)
block|{
name|uint32_t
name|reg
decl_stmt|;
name|reg
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|XUSB_PADCTL_USB3_PAD_MUX
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|USB3_PAD_MUX_SATA_IDDQ_DISABLE
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|XUSB_PADCTL_USB3_PAD_MUX
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|XUSB_PADCTL_IOPHY_PLL_S0_CTL1
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|IOPHY_PLL_S0_CTL1_PLL_RST_L
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|XUSB_PADCTL_IOPHY_PLL_S0_CTL1
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|reg
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|XUSB_PADCTL_IOPHY_PLL_S0_CTL1
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|IOPHY_PLL_S0_CTL1_PLL1_MODE
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|XUSB_PADCTL_IOPHY_PLL_S0_CTL1
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|reg
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|XUSB_PADCTL_IOPHY_PLL_S0_CTL1
argument_list|)
expr_stmt|;
name|reg
operator||=
name|IOPHY_PLL_S0_CTL1_PLL_PWR_OVRD
expr_stmt|;
name|reg
operator||=
name|IOPHY_PLL_S0_CTL1_PLL_IDDQ
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|XUSB_PADCTL_IOPHY_PLL_S0_CTL1
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|reg
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|XUSB_PADCTL_IOPHY_MISC_PAD_S0_CTL1
argument_list|)
expr_stmt|;
name|reg
operator||=
name|IOPHY_MISC_PAD_S0_CTL1_IDDQ_OVRD
expr_stmt|;
name|reg
operator||=
name|IOPHY_MISC_PAD_S0_CTL1_IDDQ
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|XUSB_PADCTL_IOPHY_MISC_PAD_S0_CTL1
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|usb2_powerup
parameter_list|(
name|struct
name|padctl_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|padctl_lane
modifier|*
name|lane
parameter_list|)
block|{
name|uint32_t
name|reg
decl_stmt|;
name|struct
name|padctl_port
modifier|*
name|port
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|port
operator|=
name|search_lane_port
argument_list|(
name|sc
argument_list|,
name|lane
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot find port for lane: %s\n"
argument_list|,
name|lane
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|reg
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|XUSB_PADCTL_USB2_BIAS_PAD_CTL0
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|USB2_BIAS_PAD_CTL0_HS_SQUELCH_LEVEL
argument_list|(
operator|~
literal|0
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|USB2_BIAS_PAD_CTL0_HS_DISCON_LEVEL
argument_list|(
operator|~
literal|0
argument_list|)
expr_stmt|;
name|reg
operator||=
name|USB2_BIAS_PAD_CTL0_HS_SQUELCH_LEVEL
argument_list|(
name|sc
operator|->
name|hs_squelch_level
argument_list|)
expr_stmt|;
name|reg
operator||=
name|USB2_BIAS_PAD_CTL0_HS_DISCON_LEVEL
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|XUSB_PADCTL_USB2_BIAS_PAD_CTL0
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|XUSB_PADCTL_USB2_PORT_CAP
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|USB2_PORT_CAP_PORT_CAP
argument_list|(
name|lane
operator|->
name|idx
argument_list|,
operator|~
literal|0
argument_list|)
expr_stmt|;
name|reg
operator||=
name|USB2_PORT_CAP_PORT_CAP
argument_list|(
name|lane
operator|->
name|idx
argument_list|,
name|USB2_PORT_CAP_PORT_CAP_HOST
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|XUSB_PADCTL_USB2_PORT_CAP
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|XUSB_PADCTL_USB2_OTG_PAD_CTL0
argument_list|(
name|lane
operator|->
name|idx
argument_list|)
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|USB2_OTG_PAD_CTL0_HS_CURR_LEVEL
argument_list|(
operator|~
literal|0
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|USB2_OTG_PAD_CTL0_HS_SLEW
argument_list|(
operator|~
literal|0
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|USB2_OTG_PAD_CTL0_LS_RSLEW
argument_list|(
operator|~
literal|0
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|USB2_OTG_PAD_CTL0_PD
expr_stmt|;
name|reg
operator|&=
operator|~
name|USB2_OTG_PAD_CTL0_PD2
expr_stmt|;
name|reg
operator|&=
operator|~
name|USB2_OTG_PAD_CTL0_PD_ZI
expr_stmt|;
name|reg
operator||=
name|USB2_OTG_PAD_CTL0_HS_SLEW
argument_list|(
literal|14
argument_list|)
expr_stmt|;
if|if
condition|(
name|lane
operator|->
name|idx
operator|==
literal|0
condition|)
block|{
name|reg
operator||=
name|USB2_OTG_PAD_CTL0_HS_CURR_LEVEL
argument_list|(
name|sc
operator|->
name|hs_curr_level_0
argument_list|)
expr_stmt|;
name|reg
operator||=
name|USB2_OTG_PAD_CTL0_LS_RSLEW
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|reg
operator||=
name|USB2_OTG_PAD_CTL0_HS_CURR_LEVEL
argument_list|(
name|sc
operator|->
name|hs_curr_level_123
argument_list|)
expr_stmt|;
name|reg
operator||=
name|USB2_OTG_PAD_CTL0_LS_RSLEW
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|WR4
argument_list|(
name|sc
argument_list|,
name|XUSB_PADCTL_USB2_OTG_PAD_CTL0
argument_list|(
name|lane
operator|->
name|idx
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|XUSB_PADCTL_USB2_OTG_PAD_CTL1
argument_list|(
name|lane
operator|->
name|idx
argument_list|)
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|USB2_OTG_PAD_CTL1_TERM_RANGE_ADJ
argument_list|(
operator|~
literal|0
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|USB2_OTG_PAD_CTL1_HS_IREF_CAP
argument_list|(
operator|~
literal|0
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|USB2_OTG_PAD_CTL1_PD_DR
expr_stmt|;
name|reg
operator|&=
operator|~
name|USB2_OTG_PAD_CTL1_PD_DISC_FORCE_POWERUP
expr_stmt|;
name|reg
operator|&=
operator|~
name|USB2_OTG_PAD_CTL1_PD_CHRP_FORCE_POWERUP
expr_stmt|;
name|reg
operator||=
name|USB2_OTG_PAD_CTL1_TERM_RANGE_ADJ
argument_list|(
name|sc
operator|->
name|hs_term_range_adj
argument_list|)
expr_stmt|;
name|reg
operator||=
name|USB2_OTG_PAD_CTL1_HS_IREF_CAP
argument_list|(
name|sc
operator|->
name|hs_iref_cap
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|XUSB_PADCTL_USB2_OTG_PAD_CTL1
argument_list|(
name|lane
operator|->
name|idx
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
operator|!=
name|NULL
operator|&&
name|port
operator|->
name|supply_vbus
operator|!=
name|NULL
condition|)
block|{
name|rv
operator|=
name|regulator_enable
argument_list|(
name|port
operator|->
name|supply_vbus
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot enable vbus regulator\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
block|}
name|reg
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|XUSB_PADCTL_USB2_BIAS_PAD_CTL0
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|USB2_BIAS_PAD_CTL0_PD
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|XUSB_PADCTL_USB2_BIAS_PAD_CTL0
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|usb2_powerdown
parameter_list|(
name|struct
name|padctl_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|padctl_lane
modifier|*
name|lane
parameter_list|)
block|{
name|uint32_t
name|reg
decl_stmt|;
name|struct
name|padctl_port
modifier|*
name|port
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|port
operator|=
name|search_lane_port
argument_list|(
name|sc
argument_list|,
name|lane
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot find port for lane: %s\n"
argument_list|,
name|lane
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|reg
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|XUSB_PADCTL_USB2_BIAS_PAD_CTL0
argument_list|)
expr_stmt|;
name|reg
operator||=
name|USB2_BIAS_PAD_CTL0_PD
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|XUSB_PADCTL_USB2_BIAS_PAD_CTL0
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
operator|!=
name|NULL
operator|&&
name|port
operator|->
name|supply_vbus
operator|!=
name|NULL
condition|)
block|{
name|rv
operator|=
name|regulator_enable
argument_list|(
name|port
operator|->
name|supply_vbus
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot disable vbus regulator\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|phy_powerup
parameter_list|(
name|struct
name|padctl_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|reg
decl_stmt|;
name|reg
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|XUSB_PADCTL_ELPG_PROGRAM
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|ELPG_PROGRAM_AUX_MUX_LP0_VCORE_DOWN
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|XUSB_PADCTL_ELPG_PROGRAM
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|reg
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|XUSB_PADCTL_ELPG_PROGRAM
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|ELPG_PROGRAM_AUX_MUX_LP0_CLAMP_EN
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|XUSB_PADCTL_ELPG_PROGRAM
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|reg
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|XUSB_PADCTL_ELPG_PROGRAM
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|ELPG_PROGRAM_AUX_MUX_LP0_CLAMP_EN_EARLY
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|XUSB_PADCTL_ELPG_PROGRAM
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|phy_powerdown
parameter_list|(
name|struct
name|padctl_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|reg
decl_stmt|;
name|reg
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|XUSB_PADCTL_ELPG_PROGRAM
argument_list|)
expr_stmt|;
name|reg
operator||=
name|ELPG_PROGRAM_AUX_MUX_LP0_CLAMP_EN_EARLY
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|XUSB_PADCTL_ELPG_PROGRAM
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|reg
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|XUSB_PADCTL_ELPG_PROGRAM
argument_list|)
expr_stmt|;
name|reg
operator||=
name|ELPG_PROGRAM_AUX_MUX_LP0_CLAMP_EN
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|XUSB_PADCTL_ELPG_PROGRAM
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|reg
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|XUSB_PADCTL_ELPG_PROGRAM
argument_list|)
expr_stmt|;
name|reg
operator||=
name|ELPG_PROGRAM_AUX_MUX_LP0_VCORE_DOWN
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|XUSB_PADCTL_ELPG_PROGRAM
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xusbpadctl_phy_enable
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|intptr_t
name|id
parameter_list|,
name|bool
name|enable
parameter_list|)
block|{
name|struct
name|padctl_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|padctl_lane
modifier|*
name|lane
decl_stmt|;
name|struct
name|padctl_pad
modifier|*
name|pad
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|<
literal|0
operator|||
name|id
operator|>=
name|nitems
argument_list|(
name|lanes_tbl
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unknown phy: %d\n"
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|lane
operator|=
name|lanes_tbl
operator|+
name|id
expr_stmt|;
if|if
condition|(
operator|!
name|lane
operator|->
name|enabled
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Lane is not enabled/configured: %s\n"
argument_list|,
name|lane
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|pad
operator|=
name|lane
operator|->
name|pad
expr_stmt|;
if|if
condition|(
name|enable
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|phy_ena_cnt
operator|==
literal|0
condition|)
block|{
name|rv
operator|=
name|phy_powerup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
return|return
operator|(
name|rv
operator|)
return|;
block|}
name|sc
operator|->
name|phy_ena_cnt
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|enable
condition|)
name|rv
operator|=
name|pad
operator|->
name|powerup
argument_list|(
name|sc
argument_list|,
name|lane
argument_list|)
expr_stmt|;
else|else
name|rv
operator|=
name|pad
operator|->
name|powerdown
argument_list|(
name|sc
argument_list|,
name|lane
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
return|return
operator|(
name|rv
operator|)
return|;
if|if
condition|(
operator|!
name|enable
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|phy_ena_cnt
operator|==
literal|1
condition|)
block|{
name|rv
operator|=
name|phy_powerdown
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
return|return
operator|(
name|rv
operator|)
return|;
block|}
name|sc
operator|->
name|phy_ena_cnt
operator|--
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xusbpadctl_phy_map
parameter_list|(
name|device_t
name|provider
parameter_list|,
name|phandle_t
name|xref
parameter_list|,
name|int
name|ncells
parameter_list|,
name|pcell_t
modifier|*
name|cells
parameter_list|,
name|intptr_t
modifier|*
name|id
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|ncells
operator|!=
literal|0
condition|)
return|return
operator|(
name|ERANGE
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|lanes_tbl
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|lanes_tbl
index|[
name|i
index|]
operator|.
name|xref
operator|==
name|xref
condition|)
block|{
operator|*
name|id
operator|=
name|i
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/* -------------------------------------------------------------------------  *  *   FDT processing  */
end_comment

begin_function
specifier|static
name|struct
name|padctl_port
modifier|*
name|search_port
parameter_list|(
name|struct
name|padctl_softc
modifier|*
name|sc
parameter_list|,
name|char
modifier|*
name|port_name
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|ports_tbl
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|port_name
argument_list|,
name|ports_tbl
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
operator|&
name|ports_tbl
index|[
name|i
index|]
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|padctl_port
modifier|*
name|search_lane_port
parameter_list|(
name|struct
name|padctl_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|padctl_lane
modifier|*
name|lane
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|ports_tbl
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|ports_tbl
index|[
name|i
index|]
operator|.
name|enabled
condition|)
continue|continue;
if|if
condition|(
name|ports_tbl
index|[
name|i
index|]
operator|.
name|lane
operator|==
name|lane
condition|)
return|return
operator|(
name|ports_tbl
operator|+
name|i
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|padctl_lane
modifier|*
name|search_lane
parameter_list|(
name|struct
name|padctl_softc
modifier|*
name|sc
parameter_list|,
name|char
modifier|*
name|lane_name
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|lanes_tbl
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|lane_name
argument_list|,
name|lanes_tbl
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|lanes_tbl
operator|+
name|i
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|padctl_lane
modifier|*
name|search_pad_lane
parameter_list|(
name|struct
name|padctl_softc
modifier|*
name|sc
parameter_list|,
name|enum
name|padctl_pad_type
name|type
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|lanes_tbl
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|lanes_tbl
index|[
name|i
index|]
operator|.
name|enabled
condition|)
continue|continue;
if|if
condition|(
name|type
operator|==
name|lanes_tbl
index|[
name|i
index|]
operator|.
name|pad
operator|->
name|type
operator|&&
name|idx
operator|==
name|lanes_tbl
index|[
name|i
index|]
operator|.
name|idx
condition|)
return|return
operator|(
name|lanes_tbl
operator|+
name|i
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|padctl_lane
modifier|*
name|search_usb3_pad_lane
parameter_list|(
name|struct
name|padctl_softc
modifier|*
name|sc
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|padctl_lane
modifier|*
name|lane
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|lane
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|lane_map_tbl
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|idx
operator|!=
name|lane_map_tbl
index|[
name|i
index|]
operator|.
name|port_idx
condition|)
continue|continue;
name|tmp
operator|=
name|search_pad_lane
argument_list|(
name|sc
argument_list|,
name|lane_map_tbl
index|[
name|i
index|]
operator|.
name|pad_type
argument_list|,
name|lane_map_tbl
index|[
name|i
index|]
operator|.
name|lane_idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|tmp
operator|->
name|mux
index|[
name|tmp
operator|->
name|mux_idx
index|]
argument_list|,
literal|"usb3-ss"
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|lane
operator|!=
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Duplicated mappings found for"
literal|" lanes: %s and %s\n"
argument_list|,
name|lane
operator|->
name|name
argument_list|,
name|tmp
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|lane
operator|=
name|tmp
expr_stmt|;
block|}
return|return
operator|(
name|lane
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|padctl_pad
modifier|*
name|search_pad
parameter_list|(
name|struct
name|padctl_softc
modifier|*
name|sc
parameter_list|,
name|char
modifier|*
name|pad_name
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|pads_tbl
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|pad_name
argument_list|,
name|pads_tbl
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|pads_tbl
operator|+
name|i
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|search_mux
parameter_list|(
name|struct
name|padctl_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|padctl_lane
modifier|*
name|lane
parameter_list|,
name|char
modifier|*
name|fnc_name
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lane
operator|->
name|nmux
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|fnc_name
argument_list|,
name|lane
operator|->
name|mux
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|i
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|config_lane
parameter_list|(
name|struct
name|padctl_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|padctl_lane
modifier|*
name|lane
parameter_list|)
block|{
name|uint32_t
name|reg
decl_stmt|;
name|reg
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|lane
operator|->
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
operator|(
name|lane
operator|->
name|mask
operator|<<
name|lane
operator|->
name|shift
operator|)
expr_stmt|;
name|reg
operator||=
operator|(
name|lane
operator|->
name|mux_idx
operator|&
name|lane
operator|->
name|mask
operator|)
operator|<<
name|lane
operator|->
name|shift
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|lane
operator|->
name|reg
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|process_lane
parameter_list|(
name|struct
name|padctl_softc
modifier|*
name|sc
parameter_list|,
name|phandle_t
name|node
parameter_list|,
name|struct
name|padctl_pad
modifier|*
name|pad
parameter_list|)
block|{
name|struct
name|padctl_lane
modifier|*
name|lane
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|function
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|name
operator|=
name|NULL
expr_stmt|;
name|function
operator|=
name|NULL
expr_stmt|;
name|rv
operator|=
name|OF_getprop_alloc
argument_list|(
name|node
argument_list|,
literal|"name"
argument_list|,
literal|1
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|<=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot read lane name.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|lane
operator|=
name|search_lane
argument_list|(
name|sc
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|lane
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Unknown lane: %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|rv
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|end
goto|;
block|}
comment|/* Read function (mux) settings. */
name|rv
operator|=
name|OF_getprop_alloc
argument_list|(
name|node
argument_list|,
literal|"nvidia,function"
argument_list|,
literal|1
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|function
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|<=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot read lane function.\n"
argument_list|)
expr_stmt|;
name|rv
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|end
goto|;
block|}
name|lane
operator|->
name|mux_idx
operator|=
name|search_mux
argument_list|(
name|sc
argument_list|,
name|lane
argument_list|,
name|function
argument_list|)
expr_stmt|;
if|if
condition|(
name|lane
operator|->
name|mux_idx
operator|==
operator|~
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Unknown function %s for lane %s\n"
argument_list|,
name|function
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|rv
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|end
goto|;
block|}
name|rv
operator|=
name|config_lane
argument_list|(
name|sc
argument_list|,
name|lane
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot configure lane: %s: %d\n"
argument_list|,
name|name
argument_list|,
name|rv
argument_list|)
expr_stmt|;
name|rv
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|end
goto|;
block|}
name|lane
operator|->
name|xref
operator|=
name|OF_xref_from_node
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|lane
operator|->
name|pad
operator|=
name|pad
expr_stmt|;
name|lane
operator|->
name|enabled
operator|=
name|true
expr_stmt|;
name|pad
operator|->
name|lanes
index|[
name|pad
operator|->
name|nlanes
operator|++
index|]
operator|=
name|lane
expr_stmt|;
name|rv
operator|=
literal|0
expr_stmt|;
name|end
label|:
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
name|OF_prop_free
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|function
operator|!=
name|NULL
condition|)
name|OF_prop_free
argument_list|(
name|function
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|process_pad
parameter_list|(
name|struct
name|padctl_softc
modifier|*
name|sc
parameter_list|,
name|phandle_t
name|node
parameter_list|)
block|{
name|phandle_t
name|xref
decl_stmt|;
name|struct
name|padctl_pad
modifier|*
name|pad
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|name
operator|=
name|NULL
expr_stmt|;
name|rv
operator|=
name|OF_getprop_alloc
argument_list|(
name|node
argument_list|,
literal|"name"
argument_list|,
literal|1
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|<=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot read pad name.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|pad
operator|=
name|search_pad
argument_list|(
name|sc
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|pad
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Unknown pad: %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|rv
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|end
goto|;
block|}
comment|/* Read and process associated lanes. */
name|node
operator|=
name|ofw_bus_find_child
argument_list|(
name|node
argument_list|,
literal|"lanes"
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|<=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot find regulators subnode\n"
argument_list|)
expr_stmt|;
name|rv
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|end
goto|;
block|}
for|for
control|(
name|node
operator|=
name|OF_child
argument_list|(
name|node
argument_list|)
init|;
name|node
operator|!=
literal|0
condition|;
name|node
operator|=
name|OF_peer
argument_list|(
name|node
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|fdt_is_enabled
argument_list|(
name|node
argument_list|)
condition|)
continue|continue;
name|rv
operator|=
name|process_lane
argument_list|(
name|sc
argument_list|,
name|node
argument_list|,
name|pad
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
goto|goto
name|end
goto|;
name|xref
operator|=
name|OF_xref_from_node
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|OF_device_register_xref
argument_list|(
name|xref
argument_list|,
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
block|}
name|pad
operator|->
name|enabled
operator|=
name|true
expr_stmt|;
name|rv
operator|=
literal|0
expr_stmt|;
name|end
label|:
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
name|OF_prop_free
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|process_port
parameter_list|(
name|struct
name|padctl_softc
modifier|*
name|sc
parameter_list|,
name|phandle_t
name|node
parameter_list|)
block|{
name|struct
name|padctl_port
modifier|*
name|port
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|name
operator|=
name|NULL
expr_stmt|;
name|rv
operator|=
name|OF_getprop_alloc
argument_list|(
name|node
argument_list|,
literal|"name"
argument_list|,
literal|1
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|<=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot read port name.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|port
operator|=
name|search_port
argument_list|(
name|sc
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Unknown port: %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|rv
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|end
goto|;
block|}
if|if
condition|(
name|port
operator|->
name|type
operator|==
name|PADCTL_PORT_USB3
condition|)
block|{
name|rv
operator|=
name|OF_getencprop
argument_list|(
name|node
argument_list|,
literal|"nvidia,usb2-companion"
argument_list|,
operator|&
operator|(
name|port
operator|->
name|companion
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|port
operator|->
name|companion
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|<=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Missing 'nvidia,usb2-companion' property "
literal|"for port: %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|rv
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|end
goto|;
block|}
block|}
if|if
condition|(
name|OF_hasprop
argument_list|(
name|node
argument_list|,
literal|"vbus-supply"
argument_list|)
condition|)
block|{
name|rv
operator|=
name|regulator_get_by_ofw_property
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|0
argument_list|,
literal|"vbus-supply"
argument_list|,
operator|&
name|port
operator|->
name|supply_vbus
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|<=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot get 'vbus-supply' regulator "
literal|"for port: %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|rv
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|end
goto|;
block|}
block|}
if|if
condition|(
name|OF_hasprop
argument_list|(
name|node
argument_list|,
literal|"nvidia,internal"
argument_list|)
condition|)
name|port
operator|->
name|internal
operator|=
name|true
expr_stmt|;
comment|/* Find assigned lane */
if|if
condition|(
name|port
operator|->
name|lane
operator|==
name|NULL
condition|)
block|{
switch|switch
condition|(
name|port
operator|->
name|type
condition|)
block|{
comment|/* Routing is fixed for USB2, ULPI AND HSIC. */
case|case
name|PADCTL_PORT_USB2
case|:
name|port
operator|->
name|lane
operator|=
name|search_pad_lane
argument_list|(
name|sc
argument_list|,
name|PADCTL_PAD_USB2
argument_list|,
name|port
operator|->
name|idx
argument_list|)
expr_stmt|;
break|break;
case|case
name|PADCTL_PORT_ULPI
case|:
name|port
operator|->
name|lane
operator|=
name|search_pad_lane
argument_list|(
name|sc
argument_list|,
name|PADCTL_PAD_ULPI
argument_list|,
name|port
operator|->
name|idx
argument_list|)
expr_stmt|;
break|break;
case|case
name|PADCTL_PORT_HSIC
case|:
name|port
operator|->
name|lane
operator|=
name|search_pad_lane
argument_list|(
name|sc
argument_list|,
name|PADCTL_PAD_HSIC
argument_list|,
name|port
operator|->
name|idx
argument_list|)
expr_stmt|;
break|break;
case|case
name|PADCTL_PORT_USB3
case|:
name|port
operator|->
name|lane
operator|=
name|search_usb3_pad_lane
argument_list|(
name|sc
argument_list|,
name|port
operator|->
name|idx
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|port
operator|->
name|lane
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot find lane for port: %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|rv
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|end
goto|;
block|}
name|port
operator|->
name|enabled
operator|=
name|true
expr_stmt|;
name|rv
operator|=
literal|0
expr_stmt|;
name|end
label|:
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
name|OF_prop_free
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|parse_fdt
parameter_list|(
name|struct
name|padctl_softc
modifier|*
name|sc
parameter_list|,
name|phandle_t
name|base_node
parameter_list|)
block|{
name|phandle_t
name|node
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|rv
operator|=
literal|0
expr_stmt|;
name|node
operator|=
name|ofw_bus_find_child
argument_list|(
name|base_node
argument_list|,
literal|"pads"
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|<=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot find pads subnode.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
for|for
control|(
name|node
operator|=
name|OF_child
argument_list|(
name|node
argument_list|)
init|;
name|node
operator|!=
literal|0
condition|;
name|node
operator|=
name|OF_peer
argument_list|(
name|node
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|fdt_is_enabled
argument_list|(
name|node
argument_list|)
condition|)
continue|continue;
name|rv
operator|=
name|process_pad
argument_list|(
name|sc
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
return|return
operator|(
name|rv
operator|)
return|;
block|}
name|node
operator|=
name|ofw_bus_find_child
argument_list|(
name|base_node
argument_list|,
literal|"ports"
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|<=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot find ports subnode.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
for|for
control|(
name|node
operator|=
name|OF_child
argument_list|(
name|node
argument_list|)
init|;
name|node
operator|!=
literal|0
condition|;
name|node
operator|=
name|OF_peer
argument_list|(
name|node
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|fdt_is_enabled
argument_list|(
name|node
argument_list|)
condition|)
continue|continue;
name|rv
operator|=
name|process_port
argument_list|(
name|sc
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
return|return
operator|(
name|rv
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|load_calibration
parameter_list|(
name|struct
name|padctl_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|reg
decl_stmt|;
comment|/* All XUSB pad calibrations are packed into single dword.*/
name|reg
operator|=
name|tegra_fuse_read_4
argument_list|(
name|FUSE_XUSB_CALIB
argument_list|)
expr_stmt|;
name|sc
operator|->
name|hs_curr_level_0
operator|=
name|FUSE_XUSB_CALIB_HS_CURR_LEVEL_0
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|sc
operator|->
name|hs_curr_level_123
operator|=
name|FUSE_XUSB_CALIB_HS_CURR_LEVEL_123
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|sc
operator|->
name|hs_iref_cap
operator|=
name|FUSE_XUSB_CALIB_HS_IREF_CAP
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|sc
operator|->
name|hs_squelch_level
operator|=
name|FUSE_XUSB_CALIB_HS_SQUELCH_LEVEL
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|sc
operator|->
name|hs_term_range_adj
operator|=
name|FUSE_XUSB_CALIB_HS_TERM_RANGE_ADJ
argument_list|(
name|reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* -------------------------------------------------------------------------  *  *   BUS functions  */
end_comment

begin_function
specifier|static
name|int
name|xusbpadctl_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ofw_bus_status_okay
argument_list|(
name|dev
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
operator|!
name|ofw_bus_search_compatible
argument_list|(
name|dev
argument_list|,
name|compat_data
argument_list|)
operator|->
name|ocd_data
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Tegra XUSB phy"
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xusbpadctl_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
comment|/* This device is always present. */
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xusbpadctl_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|padctl_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rid
decl_stmt|,
name|rv
decl_stmt|;
name|struct
name|padctl_port
modifier|*
name|port
decl_stmt|;
name|phandle_t
name|node
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|node
operator|=
name|ofw_bus_get_node
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|mem_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mem_res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Cannot allocate memory resources\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|rv
operator|=
name|hwreset_get_by_ofw_name
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
literal|"padctl"
argument_list|,
operator|&
name|sc
operator|->
name|rst
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Cannot get 'padctl' reset: %d\n"
argument_list|,
name|rv
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
name|rv
operator|=
name|hwreset_deassert
argument_list|(
name|sc
operator|->
name|rst
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Cannot unreset 'padctl' reset: %d\n"
argument_list|,
name|rv
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
name|load_calibration
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|rv
operator|=
name|parse_fdt
argument_list|(
name|sc
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Cannot parse fdt configuration: %d\n"
argument_list|,
name|rv
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|ports_tbl
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|port
operator|=
name|ports_tbl
operator|+
name|i
expr_stmt|;
if|if
condition|(
operator|!
name|port
operator|->
name|enabled
condition|)
continue|continue;
if|if
condition|(
name|port
operator|->
name|init
operator|==
name|NULL
condition|)
continue|continue;
name|rv
operator|=
name|port
operator|->
name|init
argument_list|(
name|sc
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Cannot init port '%s'\n"
argument_list|,
name|port
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|tegra_xusbpadctl_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|xusbpadctl_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|xusbpadctl_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|xusbpadctl_detach
argument_list|)
block|,
comment|/* phy interface */
name|DEVMETHOD
argument_list|(
name|phy_enable
argument_list|,
name|xusbpadctl_phy_enable
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|phy_map
argument_list|,
name|xusbpadctl_phy_map
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|tegra_xusbpadctl_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|DEFINE_CLASS_0
argument_list|(
name|xusbpadctl
argument_list|,
name|tegra_xusbpadctl_driver
argument_list|,
name|tegra_xusbpadctl_methods
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|padctl_softc
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|EARLY_DRIVER_MODULE
argument_list|(
name|tegra_xusbpadctl
argument_list|,
name|simplebus
argument_list|,
name|tegra_xusbpadctl_driver
argument_list|,
name|tegra_xusbpadctl_devclass
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|73
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

