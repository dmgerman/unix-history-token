begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2016 Michal Meloun<mmel@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<dev/extres/clk/clk.h>
end_include

begin_include
include|#
directive|include
file|<gnu/dts/include/dt-bindings/clock/tegra124-car.h>
end_include

begin_include
include|#
directive|include
file|"tegra124_car.h"
end_include

begin_comment
comment|/* #define TEGRA_PLL_DEBUG */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TEGRA_PLL_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|dprintf
parameter_list|(
modifier|...
parameter_list|)
value|printf(__VA_ARGS__)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|dprintf
parameter_list|(
modifier|...
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* All PLLs. */
end_comment

begin_enum
enum|enum
name|pll_type
block|{
name|PLL_M
block|,
name|PLL_X
block|,
name|PLL_C
block|,
name|PLL_C2
block|,
name|PLL_C3
block|,
name|PLL_C4
block|,
name|PLL_P
block|,
name|PLL_A
block|,
name|PLL_U
block|,
name|PLL_D
block|,
name|PLL_D2
block|,
name|PLL_DP
block|,
name|PLL_E
block|,
name|PLL_REFE
block|}
enum|;
end_enum

begin_comment
comment|/* Common base register bits. */
end_comment

begin_define
define|#
directive|define
name|PLL_BASE_BYPASS
value|(1U<< 31)
end_define

begin_define
define|#
directive|define
name|PLL_BASE_ENABLE
value|(1<< 30)
end_define

begin_define
define|#
directive|define
name|PLL_BASE_REFDISABLE
value|(1<< 29)
end_define

begin_define
define|#
directive|define
name|PLL_BASE_LOCK
value|(1<< 27)
end_define

begin_define
define|#
directive|define
name|PLL_BASE_DIVM_SHIFT
value|0
end_define

begin_define
define|#
directive|define
name|PLL_BASE_DIVN_SHIFT
value|8
end_define

begin_define
define|#
directive|define
name|PLLRE_MISC_LOCK
value|(1<< 24)
end_define

begin_define
define|#
directive|define
name|PLL_MISC_LOCK_ENABLE
value|(1<< 18)
end_define

begin_define
define|#
directive|define
name|PLLC_MISC_LOCK_ENABLE
value|(1<< 24)
end_define

begin_define
define|#
directive|define
name|PLLDU_MISC_LOCK_ENABLE
value|(1<< 22)
end_define

begin_define
define|#
directive|define
name|PLLRE_MISC_LOCK_ENABLE
value|(1<< 30)
end_define

begin_define
define|#
directive|define
name|PLLSS_MISC_LOCK_ENABLE
value|(1<< 30)
end_define

begin_define
define|#
directive|define
name|PLLC_IDDQ_BIT
value|26
end_define

begin_define
define|#
directive|define
name|PLLX_IDDQ_BIT
value|3
end_define

begin_define
define|#
directive|define
name|PLLRE_IDDQ_BIT
value|16
end_define

begin_define
define|#
directive|define
name|PLLSS_IDDQ_BIT
value|19
end_define

begin_define
define|#
directive|define
name|PLL_LOCK_TIMEOUT
value|5000
end_define

begin_comment
comment|/* Post divider<-> register value mapping. */
end_comment

begin_struct
struct|struct
name|pdiv_table
block|{
name|uint32_t
name|divider
decl_stmt|;
comment|/* real divider */
name|uint32_t
name|value
decl_stmt|;
comment|/* register value */
block|}
struct|;
end_struct

begin_comment
comment|/* Bits definition of M, N and P fields. */
end_comment

begin_struct
struct|struct
name|mnp_bits
block|{
name|uint32_t
name|m_width
decl_stmt|;
name|uint32_t
name|n_width
decl_stmt|;
name|uint32_t
name|p_width
decl_stmt|;
name|uint32_t
name|p_shift
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|clk_pll_def
block|{
name|struct
name|clknode_init_def
name|clkdef
decl_stmt|;
name|enum
name|pll_type
name|type
decl_stmt|;
name|uint32_t
name|base_reg
decl_stmt|;
name|uint32_t
name|misc_reg
decl_stmt|;
name|uint32_t
name|lock_mask
decl_stmt|;
name|uint32_t
name|lock_enable
decl_stmt|;
name|uint32_t
name|iddq_reg
decl_stmt|;
name|uint32_t
name|iddq_mask
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
name|struct
name|pdiv_table
modifier|*
name|pdiv_table
decl_stmt|;
name|struct
name|mnp_bits
name|mnp_bits
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|PLL
parameter_list|(
name|_id
parameter_list|,
name|cname
parameter_list|,
name|pname
parameter_list|)
define|\
value|.clkdef.id = _id,					\ 	.clkdef.name = cname,					\ 	.clkdef.parent_names = (const char *[]){pname},		\ 	.clkdef.parent_cnt = 1,				\ 	.clkdef.flags = CLK_NODE_STATIC_STRINGS
end_define

begin_comment
comment|/* Tegra K1 PLLs  PLLM: Clock source for EMC 2x clock  PLLX: Clock source for the fast CPU cluster and the shadow CPU  PLLC: Clock source for general use  PLLC2: Clock source for engine scaling  PLLC3: Clock source for engine scaling  PLLC4: Clock source for ISP/VI units  PLLP: Clock source for most peripherals  PLLA: Audio clock sources: (11.2896 MHz, 12.288 MHz, 24.576 MHz)  PLLU: Clock source for USB PHY, provides 12/60/480 MHz  PLLD: Clock sources for the DSI and display subsystem  PLLD2: Clock sources for the DSI and display subsystem  refPLLe:  PLLE: generate the 100 MHz reference clock for USB 3.0 (spread spectrum)  PLLDP: Clock source for eDP/LVDS (spread spectrum)   DFLLCPU: DFLL clock source for the fast CPU cluster  GPCPLL: Clock source for the GPU */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|pdiv_table
name|pllm_map
index|[]
init|=
block|{
block|{
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|2
block|,
literal|1
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pdiv_table
name|pllxc_map
index|[]
init|=
block|{
block|{
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|2
block|,
literal|1
block|}
block|,
block|{
literal|3
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|4
block|}
block|,
block|{
literal|6
block|,
literal|5
block|}
block|,
block|{
literal|8
block|,
literal|6
block|}
block|,
block|{
literal|10
block|,
literal|7
block|}
block|,
block|{
literal|12
block|,
literal|8
block|}
block|,
block|{
literal|16
block|,
literal|9
block|}
block|,
block|{
literal|12
block|,
literal|10
block|}
block|,
block|{
literal|16
block|,
literal|11
block|}
block|,
block|{
literal|20
block|,
literal|12
block|}
block|,
block|{
literal|24
block|,
literal|13
block|}
block|,
block|{
literal|32
block|,
literal|14
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pdiv_table
name|pllc_map
index|[]
init|=
block|{
block|{
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|2
block|,
literal|1
block|}
block|,
block|{
literal|3
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|3
block|}
block|,
block|{
literal|6
block|,
literal|4
block|}
block|,
block|{
literal|8
block|,
literal|5
block|}
block|,
block|{
literal|12
block|,
literal|6
block|}
block|,
block|{
literal|16
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pdiv_table
name|pll12g_ssd_esd_map
index|[]
init|=
block|{
block|{
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|2
block|,
literal|1
block|}
block|,
block|{
literal|3
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|4
block|}
block|,
block|{
literal|6
block|,
literal|5
block|}
block|,
block|{
literal|8
block|,
literal|6
block|}
block|,
block|{
literal|10
block|,
literal|7
block|}
block|,
block|{
literal|12
block|,
literal|8
block|}
block|,
block|{
literal|16
block|,
literal|9
block|}
block|,
block|{
literal|12
block|,
literal|10
block|}
block|,
block|{
literal|16
block|,
literal|11
block|}
block|,
block|{
literal|20
block|,
literal|12
block|}
block|,
block|{
literal|24
block|,
literal|13
block|}
block|,
block|{
literal|32
block|,
literal|14
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pdiv_table
name|pllu_map
index|[]
init|=
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|2
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pdiv_table
name|pllrefe_map
index|[]
init|=
block|{
block|{
literal|1
block|,
literal|0
block|}
block|,
block|{
literal|2
block|,
literal|1
block|}
block|,
block|{
literal|3
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|4
block|}
block|,
block|{
literal|6
block|,
literal|5
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|clk_pll_def
name|pll_clks
index|[]
init|=
block|{
comment|/* PLLM: 880 MHz Clock source for EMC 2x clock */
block|{
name|PLL
argument_list|(
name|TEGRA124_CLK_PLL_M
argument_list|,
literal|"pllM_out0"
argument_list|,
literal|"osc_div_clk"
argument_list|)
block|,
operator|.
name|type
operator|=
name|PLL_M
block|,
operator|.
name|base_reg
operator|=
name|PLLM_BASE
block|,
operator|.
name|misc_reg
operator|=
name|PLLM_MISC
block|,
operator|.
name|lock_mask
operator|=
name|PLL_BASE_LOCK
block|,
operator|.
name|lock_enable
operator|=
name|PLL_MISC_LOCK_ENABLE
block|,
operator|.
name|pdiv_table
operator|=
name|pllm_map
block|,
operator|.
name|mnp_bits
operator|=
block|{
literal|8
block|,
literal|8
block|,
literal|1
block|,
literal|20
block|}
block|, 	}
block|,
comment|/* PLLX: 1GHz Clock source for the fast CPU cluster and the shadow CPU */
block|{
name|PLL
argument_list|(
name|TEGRA124_CLK_PLL_X
argument_list|,
literal|"pllX_out"
argument_list|,
literal|"osc_div_clk"
argument_list|)
block|,
operator|.
name|type
operator|=
name|PLL_X
block|,
operator|.
name|base_reg
operator|=
name|PLLX_BASE
block|,
operator|.
name|misc_reg
operator|=
name|PLLX_MISC
block|,
operator|.
name|lock_mask
operator|=
name|PLL_BASE_LOCK
block|,
operator|.
name|lock_enable
operator|=
name|PLL_MISC_LOCK_ENABLE
block|,
operator|.
name|iddq_reg
operator|=
name|PLLX_MISC3
block|,
operator|.
name|iddq_mask
operator|=
literal|1
operator|<<
name|PLLX_IDDQ_BIT
block|,
operator|.
name|pdiv_table
operator|=
name|pllxc_map
block|,
operator|.
name|mnp_bits
operator|=
block|{
literal|8
block|,
literal|8
block|,
literal|4
block|,
literal|20
block|}
block|, 	}
block|,
comment|/* PLLC: 600 MHz Clock source for general use */
block|{
name|PLL
argument_list|(
name|TEGRA124_CLK_PLL_C
argument_list|,
literal|"pllC_out0"
argument_list|,
literal|"osc_div_clk"
argument_list|)
block|,
operator|.
name|type
operator|=
name|PLL_C
block|,
operator|.
name|base_reg
operator|=
name|PLLC_BASE
block|,
operator|.
name|misc_reg
operator|=
name|PLLC_MISC
block|,
operator|.
name|lock_mask
operator|=
name|PLL_BASE_LOCK
block|,
operator|.
name|lock_enable
operator|=
name|PLLC_MISC_LOCK_ENABLE
block|,
operator|.
name|iddq_reg
operator|=
name|PLLC_MISC
block|,
operator|.
name|iddq_mask
operator|=
literal|1
operator|<<
name|PLLC_IDDQ_BIT
block|,
operator|.
name|pdiv_table
operator|=
name|pllc_map
block|,
operator|.
name|mnp_bits
operator|=
block|{
literal|8
block|,
literal|8
block|,
literal|4
block|,
literal|20
block|}
block|, 	}
block|,
comment|/* PLLC2: 600 MHz Clock source for engine scaling */
block|{
name|PLL
argument_list|(
name|TEGRA124_CLK_PLL_C2
argument_list|,
literal|"pllC2_out0"
argument_list|,
literal|"osc_div_clk"
argument_list|)
block|,
operator|.
name|type
operator|=
name|PLL_C2
block|,
operator|.
name|base_reg
operator|=
name|PLLC2_BASE
block|,
operator|.
name|misc_reg
operator|=
name|PLLC2_MISC
block|,
operator|.
name|lock_mask
operator|=
name|PLL_BASE_LOCK
block|,
operator|.
name|lock_enable
operator|=
name|PLL_MISC_LOCK_ENABLE
block|,
operator|.
name|pdiv_table
operator|=
name|pllc_map
block|,
operator|.
name|mnp_bits
operator|=
block|{
literal|2
block|,
literal|8
block|,
literal|3
block|,
literal|20
block|}
block|, 	}
block|,
comment|/* PLLC3: 600 MHz Clock source for engine scaling */
block|{
name|PLL
argument_list|(
name|TEGRA124_CLK_PLL_C3
argument_list|,
literal|"pllC3_out0"
argument_list|,
literal|"osc_div_clk"
argument_list|)
block|,
operator|.
name|type
operator|=
name|PLL_C3
block|,
operator|.
name|base_reg
operator|=
name|PLLC3_BASE
block|,
operator|.
name|misc_reg
operator|=
name|PLLC3_MISC
block|,
operator|.
name|lock_mask
operator|=
name|PLL_BASE_LOCK
block|,
operator|.
name|lock_enable
operator|=
name|PLL_MISC_LOCK_ENABLE
block|,
operator|.
name|pdiv_table
operator|=
name|pllc_map
block|,
operator|.
name|mnp_bits
operator|=
block|{
literal|2
block|,
literal|8
block|,
literal|3
block|,
literal|20
block|}
block|, 	}
block|,
comment|/* PLLC4: 600 MHz Clock source for ISP/VI units */
block|{
name|PLL
argument_list|(
name|TEGRA124_CLK_PLL_C4
argument_list|,
literal|"pllC4_out0"
argument_list|,
literal|"pllC4_src"
argument_list|)
block|,
operator|.
name|type
operator|=
name|PLL_C4
block|,
operator|.
name|base_reg
operator|=
name|PLLC4_BASE
block|,
operator|.
name|misc_reg
operator|=
name|PLLC4_MISC
block|,
operator|.
name|lock_mask
operator|=
name|PLL_BASE_LOCK
block|,
operator|.
name|lock_enable
operator|=
name|PLLSS_MISC_LOCK_ENABLE
block|,
operator|.
name|iddq_reg
operator|=
name|PLLC4_BASE
block|,
operator|.
name|iddq_mask
operator|=
literal|1
operator|<<
name|PLLSS_IDDQ_BIT
block|,
operator|.
name|pdiv_table
operator|=
name|pll12g_ssd_esd_map
block|,
operator|.
name|mnp_bits
operator|=
block|{
literal|8
block|,
literal|8
block|,
literal|4
block|,
literal|20
block|}
block|, 	}
block|,
comment|/* PLLP: 408 MHz Clock source for most peripherals */
block|{
name|PLL
argument_list|(
name|TEGRA124_CLK_PLL_P
argument_list|,
literal|"pllP_out0"
argument_list|,
literal|"osc_div_clk"
argument_list|)
block|,
operator|.
name|type
operator|=
name|PLL_P
block|,
operator|.
name|base_reg
operator|=
name|PLLP_BASE
block|,
operator|.
name|misc_reg
operator|=
name|PLLP_MISC
block|,
operator|.
name|lock_mask
operator|=
name|PLL_BASE_LOCK
block|,
operator|.
name|lock_enable
operator|=
name|PLL_MISC_LOCK_ENABLE
block|,
operator|.
name|mnp_bits
operator|=
block|{
literal|5
block|,
literal|10
block|,
literal|3
block|,
literal|20
block|}
block|, 	}
block|,
comment|/* PLLA: Audio clock sources: (11.2896 MHz, 12.288 MHz, 24.576 MHz) */
block|{
name|PLL
argument_list|(
name|TEGRA124_CLK_PLL_A
argument_list|,
literal|"pllA_out"
argument_list|,
literal|"pllP_out1"
argument_list|)
block|,
operator|.
name|type
operator|=
name|PLL_A
block|,
operator|.
name|base_reg
operator|=
name|PLLA_BASE
block|,
operator|.
name|misc_reg
operator|=
name|PLLA_MISC
block|,
operator|.
name|lock_mask
operator|=
name|PLL_BASE_LOCK
block|,
operator|.
name|lock_enable
operator|=
name|PLL_MISC_LOCK_ENABLE
block|,
operator|.
name|mnp_bits
operator|=
block|{
literal|5
block|,
literal|10
block|,
literal|3
block|,
literal|20
block|}
block|, 	}
block|,
comment|/* PLLU: 480 MHz Clock source for USB PHY, provides 12/60/480 MHz */
block|{
name|PLL
argument_list|(
name|TEGRA124_CLK_PLL_U
argument_list|,
literal|"pllU_out"
argument_list|,
literal|"osc_div_clk"
argument_list|)
block|,
operator|.
name|type
operator|=
name|PLL_U
block|,
operator|.
name|base_reg
operator|=
name|PLLU_BASE
block|,
operator|.
name|misc_reg
operator|=
name|PLLU_MISC
block|,
operator|.
name|lock_mask
operator|=
name|PLL_BASE_LOCK
block|,
operator|.
name|lock_enable
operator|=
name|PLLDU_MISC_LOCK_ENABLE
block|,
operator|.
name|pdiv_table
operator|=
name|pllu_map
block|,
operator|.
name|mnp_bits
operator|=
block|{
literal|5
block|,
literal|10
block|,
literal|1
block|,
literal|20
block|}
block|, 	}
block|,
comment|/* PLLD: 600 MHz Clock sources for the DSI and display subsystem */
block|{
name|PLL
argument_list|(
name|TEGRA124_CLK_PLL_D
argument_list|,
literal|"pllD_out"
argument_list|,
literal|"osc_div_clk"
argument_list|)
block|,
operator|.
name|type
operator|=
name|PLL_D
block|,
operator|.
name|base_reg
operator|=
name|PLLD_BASE
block|,
operator|.
name|misc_reg
operator|=
name|PLLD_MISC
block|,
operator|.
name|lock_mask
operator|=
name|PLL_BASE_LOCK
block|,
operator|.
name|lock_enable
operator|=
name|PLL_MISC_LOCK_ENABLE
block|,
operator|.
name|mnp_bits
operator|=
block|{
literal|5
block|,
literal|11
block|,
literal|3
block|,
literal|20
block|}
block|, 	}
block|,
comment|/* PLLD2: 600 MHz Clock sources for the DSI and display subsystem */
block|{
name|PLL
argument_list|(
name|TEGRA124_CLK_PLL_D2
argument_list|,
literal|"pllD2_out"
argument_list|,
literal|"pllD2_src"
argument_list|)
block|,
operator|.
name|type
operator|=
name|PLL_D2
block|,
operator|.
name|base_reg
operator|=
name|PLLD2_BASE
block|,
operator|.
name|misc_reg
operator|=
name|PLLD2_MISC
block|,
operator|.
name|lock_mask
operator|=
name|PLL_BASE_LOCK
block|,
operator|.
name|lock_enable
operator|=
name|PLLSS_MISC_LOCK_ENABLE
block|,
operator|.
name|iddq_reg
operator|=
name|PLLD2_BASE
block|,
operator|.
name|iddq_mask
operator|=
literal|1
operator|<<
name|PLLSS_IDDQ_BIT
block|,
operator|.
name|pdiv_table
operator|=
name|pll12g_ssd_esd_map
block|,
operator|.
name|mnp_bits
operator|=
block|{
literal|8
block|,
literal|8
block|,
literal|4
block|,
literal|20
block|}
block|, 	}
block|,
comment|/* refPLLe:  */
block|{
name|PLL
argument_list|(
literal|0
argument_list|,
literal|"pllREFE_out"
argument_list|,
literal|"osc_div_clk"
argument_list|)
block|,
operator|.
name|type
operator|=
name|PLL_REFE
block|,
operator|.
name|base_reg
operator|=
name|PLLRE_BASE
block|,
operator|.
name|misc_reg
operator|=
name|PLLRE_MISC
block|,
operator|.
name|lock_mask
operator|=
name|PLLRE_MISC_LOCK
block|,
operator|.
name|lock_enable
operator|=
name|PLLRE_MISC_LOCK_ENABLE
block|,
operator|.
name|iddq_reg
operator|=
name|PLLRE_MISC
block|,
operator|.
name|iddq_mask
operator|=
literal|1
operator|<<
name|PLLRE_IDDQ_BIT
block|,
operator|.
name|pdiv_table
operator|=
name|pllrefe_map
block|,
operator|.
name|mnp_bits
operator|=
block|{
literal|8
block|,
literal|8
block|,
literal|4
block|,
literal|16
block|}
block|, 	}
block|,
comment|/* PLLE: generate the 100 MHz reference clock for USB 3.0 (spread spectrum) */
block|{
name|PLL
argument_list|(
name|TEGRA124_CLK_PLL_E
argument_list|,
literal|"pllE_out0"
argument_list|,
literal|"pllE_src"
argument_list|)
block|,
operator|.
name|type
operator|=
name|PLL_E
block|,
operator|.
name|base_reg
operator|=
name|PLLE_BASE
block|,
operator|.
name|misc_reg
operator|=
name|PLLE_MISC
block|,
operator|.
name|lock_mask
operator|=
name|PLLE_MISC_LOCK
block|,
operator|.
name|lock_enable
operator|=
name|PLLE_MISC_LOCK_ENABLE
block|,
operator|.
name|mnp_bits
operator|=
block|{
literal|8
block|,
literal|8
block|,
literal|4
block|,
literal|24
block|}
block|, 	}
block|,
comment|/* PLLDP: 600 MHz Clock source for eDP/LVDS (spread spectrum) */
block|{
name|PLL
argument_list|(
literal|0
argument_list|,
literal|"pllDP_out0"
argument_list|,
literal|"pllDP_src"
argument_list|)
block|,
operator|.
name|type
operator|=
name|PLL_DP
block|,
operator|.
name|base_reg
operator|=
name|PLLDP_BASE
block|,
operator|.
name|misc_reg
operator|=
name|PLLDP_MISC
block|,
operator|.
name|lock_mask
operator|=
name|PLL_BASE_LOCK
block|,
operator|.
name|lock_enable
operator|=
name|PLLSS_MISC_LOCK_ENABLE
block|,
operator|.
name|iddq_reg
operator|=
name|PLLDP_BASE
block|,
operator|.
name|iddq_mask
operator|=
literal|1
operator|<<
name|PLLSS_IDDQ_BIT
block|,
operator|.
name|pdiv_table
operator|=
name|pll12g_ssd_esd_map
block|,
operator|.
name|mnp_bits
operator|=
block|{
literal|8
block|,
literal|8
block|,
literal|4
block|,
literal|20
block|}
block|, 	}
block|, }
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|tegra124_pll_init
parameter_list|(
name|struct
name|clknode
modifier|*
name|clk
parameter_list|,
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tegra124_pll_set_gate
parameter_list|(
name|struct
name|clknode
modifier|*
name|clk
parameter_list|,
name|bool
name|enable
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tegra124_pll_recalc
parameter_list|(
name|struct
name|clknode
modifier|*
name|clk
parameter_list|,
name|uint64_t
modifier|*
name|freq
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tegra124_pll_set_freq
parameter_list|(
name|struct
name|clknode
modifier|*
name|clknode
parameter_list|,
name|uint64_t
name|fin
parameter_list|,
name|uint64_t
modifier|*
name|fout
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
modifier|*
name|stop
parameter_list|)
function_decl|;
end_function_decl

begin_struct
struct|struct
name|pll_sc
block|{
name|device_t
name|clkdev
decl_stmt|;
name|enum
name|pll_type
name|type
decl_stmt|;
name|uint32_t
name|base_reg
decl_stmt|;
name|uint32_t
name|misc_reg
decl_stmt|;
name|uint32_t
name|lock_mask
decl_stmt|;
name|uint32_t
name|lock_enable
decl_stmt|;
name|uint32_t
name|iddq_reg
decl_stmt|;
name|uint32_t
name|iddq_mask
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
name|struct
name|pdiv_table
modifier|*
name|pdiv_table
decl_stmt|;
name|struct
name|mnp_bits
name|mnp_bits
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|clknode_method_t
name|tegra124_pll_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|CLKNODEMETHOD
argument_list|(
name|clknode_init
argument_list|,
name|tegra124_pll_init
argument_list|)
block|,
name|CLKNODEMETHOD
argument_list|(
name|clknode_set_gate
argument_list|,
name|tegra124_pll_set_gate
argument_list|)
block|,
name|CLKNODEMETHOD
argument_list|(
name|clknode_recalc_freq
argument_list|,
name|tegra124_pll_recalc
argument_list|)
block|,
name|CLKNODEMETHOD
argument_list|(
name|clknode_set_freq
argument_list|,
name|tegra124_pll_set_freq
argument_list|)
block|,
name|CLKNODEMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DEFINE_CLASS_1
argument_list|(
name|tegra124_pll
argument_list|,
name|tegra124_pll_class
argument_list|,
name|tegra124_pll_methods
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pll_sc
argument_list|)
argument_list|,
name|clknode_class
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|pll_enable
parameter_list|(
name|struct
name|pll_sc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|reg
decl_stmt|;
name|RD4
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|base_reg
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|type
operator|!=
name|PLL_E
condition|)
name|reg
operator|&=
operator|~
name|PLL_BASE_BYPASS
expr_stmt|;
name|reg
operator||=
name|PLL_BASE_ENABLE
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|base_reg
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pll_disable
parameter_list|(
name|struct
name|pll_sc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|reg
decl_stmt|;
name|RD4
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|base_reg
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|type
operator|!=
name|PLL_E
condition|)
name|reg
operator||=
name|PLL_BASE_BYPASS
expr_stmt|;
name|reg
operator|&=
operator|~
name|PLL_BASE_ENABLE
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|base_reg
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|pdiv_to_reg
parameter_list|(
name|struct
name|pll_sc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|p_div
parameter_list|)
block|{
name|struct
name|pdiv_table
modifier|*
name|tbl
decl_stmt|;
name|tbl
operator|=
name|sc
operator|->
name|pdiv_table
expr_stmt|;
if|if
condition|(
name|tbl
operator|==
name|NULL
condition|)
return|return
operator|(
name|ffs
argument_list|(
name|p_div
argument_list|)
operator|-
literal|1
operator|)
return|;
while|while
condition|(
name|tbl
operator|->
name|divider
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|p_div
operator|<=
name|tbl
operator|->
name|divider
condition|)
return|return
operator|(
name|tbl
operator|->
name|value
operator|)
return|;
name|tbl
operator|++
expr_stmt|;
block|}
return|return
operator|(
literal|0xFFFFFFFF
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|reg_to_pdiv
parameter_list|(
name|struct
name|pll_sc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|reg
parameter_list|)
block|{
name|struct
name|pdiv_table
modifier|*
name|tbl
decl_stmt|;
name|tbl
operator|=
name|sc
operator|->
name|pdiv_table
expr_stmt|;
if|if
condition|(
name|tbl
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|<<
name|reg
operator|)
return|;
while|while
condition|(
name|tbl
operator|->
name|divider
condition|)
block|{
if|if
condition|(
name|reg
operator|==
name|tbl
operator|->
name|value
condition|)
return|return
operator|(
name|tbl
operator|->
name|divider
operator|)
return|;
name|tbl
operator|++
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|get_masked
parameter_list|(
name|uint32_t
name|val
parameter_list|,
name|uint32_t
name|shift
parameter_list|,
name|uint32_t
name|width
parameter_list|)
block|{
return|return
operator|(
operator|(
name|val
operator|>>
name|shift
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
name|width
operator|)
operator|-
literal|1
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|set_masked
parameter_list|(
name|uint32_t
name|val
parameter_list|,
name|uint32_t
name|v
parameter_list|,
name|uint32_t
name|shift
parameter_list|,
name|uint32_t
name|width
parameter_list|)
block|{
name|val
operator|&=
operator|~
operator|(
operator|(
operator|(
literal|1
operator|<<
name|width
operator|)
operator|-
literal|1
operator|)
operator|<<
name|shift
operator|)
expr_stmt|;
name|val
operator||=
operator|(
name|v
operator|&
operator|(
operator|(
literal|1
operator|<<
name|width
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
name|shift
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|get_divisors
parameter_list|(
name|struct
name|pll_sc
modifier|*
name|sc
parameter_list|,
name|uint32_t
modifier|*
name|m
parameter_list|,
name|uint32_t
modifier|*
name|n
parameter_list|,
name|uint32_t
modifier|*
name|p
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|;
name|struct
name|mnp_bits
modifier|*
name|mnp_bits
decl_stmt|;
name|mnp_bits
operator|=
operator|&
name|sc
operator|->
name|mnp_bits
expr_stmt|;
name|RD4
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|base_reg
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
operator|*
name|m
operator|=
name|get_masked
argument_list|(
name|val
argument_list|,
name|PLL_BASE_DIVM_SHIFT
argument_list|,
name|mnp_bits
operator|->
name|m_width
argument_list|)
expr_stmt|;
operator|*
name|n
operator|=
name|get_masked
argument_list|(
name|val
argument_list|,
name|PLL_BASE_DIVN_SHIFT
argument_list|,
name|mnp_bits
operator|->
name|n_width
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|get_masked
argument_list|(
name|val
argument_list|,
name|mnp_bits
operator|->
name|p_shift
argument_list|,
name|mnp_bits
operator|->
name|p_width
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|set_divisors
parameter_list|(
name|struct
name|pll_sc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|val
parameter_list|,
name|uint32_t
name|m
parameter_list|,
name|uint32_t
name|n
parameter_list|,
name|uint32_t
name|p
parameter_list|)
block|{
name|struct
name|mnp_bits
modifier|*
name|mnp_bits
decl_stmt|;
name|mnp_bits
operator|=
operator|&
name|sc
operator|->
name|mnp_bits
expr_stmt|;
name|val
operator|=
name|set_masked
argument_list|(
name|val
argument_list|,
name|m
argument_list|,
name|PLL_BASE_DIVM_SHIFT
argument_list|,
name|mnp_bits
operator|->
name|m_width
argument_list|)
expr_stmt|;
name|val
operator|=
name|set_masked
argument_list|(
name|val
argument_list|,
name|n
argument_list|,
name|PLL_BASE_DIVN_SHIFT
argument_list|,
name|mnp_bits
operator|->
name|n_width
argument_list|)
expr_stmt|;
name|val
operator|=
name|set_masked
argument_list|(
name|val
argument_list|,
name|p
argument_list|,
name|mnp_bits
operator|->
name|p_shift
argument_list|,
name|mnp_bits
operator|->
name|p_width
argument_list|)
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|is_locked
parameter_list|(
name|struct
name|pll_sc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|reg
decl_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|type
condition|)
block|{
case|case
name|PLL_REFE
case|:
name|RD4
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|misc_reg
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|&=
name|PLLRE_MISC_LOCK
expr_stmt|;
break|break;
case|case
name|PLL_E
case|:
name|RD4
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|misc_reg
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|&=
name|PLLE_MISC_LOCK
expr_stmt|;
break|break;
default|default:
name|RD4
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|base_reg
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|&=
name|PLL_BASE_LOCK
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|reg
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wait_for_lock
parameter_list|(
name|struct
name|pll_sc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|PLL_LOCK_TIMEOUT
operator|/
literal|10
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|is_locked
argument_list|(
name|sc
argument_list|)
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"PLL lock timeout\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|plle_enable
parameter_list|(
name|struct
name|pll_sc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|reg
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|struct
name|mnp_bits
modifier|*
name|mnp_bits
decl_stmt|;
name|uint32_t
name|pll_m
init|=
literal|1
decl_stmt|;
name|uint32_t
name|pll_n
init|=
literal|200
decl_stmt|;
name|uint32_t
name|pll_p
init|=
literal|13
decl_stmt|;
name|uint32_t
name|pll_cml
init|=
literal|13
decl_stmt|;
name|mnp_bits
operator|=
operator|&
name|sc
operator|->
name|mnp_bits
expr_stmt|;
comment|/* Disable lock override. */
name|RD4
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|base_reg
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|PLLE_BASE_LOCK_OVERRIDE
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|base_reg
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|RD4
argument_list|(
name|sc
argument_list|,
name|PLLE_AUX
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|reg
operator||=
name|PLLE_AUX_ENABLE_SWCTL
expr_stmt|;
name|reg
operator|&=
operator|~
name|PLLE_AUX_SEQ_ENABLE
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|PLLE_AUX
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|RD4
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|misc_reg
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|reg
operator||=
name|PLLE_MISC_LOCK_ENABLE
expr_stmt|;
name|reg
operator||=
name|PLLE_MISC_IDDQ_SWCTL
expr_stmt|;
name|reg
operator|&=
operator|~
name|PLLE_MISC_IDDQ_OVERRIDE_VALUE
expr_stmt|;
name|reg
operator||=
name|PLLE_MISC_PTS
expr_stmt|;
name|reg
operator||=
name|PLLE_MISC_VREG_BG_CTRL_MASK
expr_stmt|;
name|reg
operator||=
name|PLLE_MISC_VREG_CTRL_MASK
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|misc_reg
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|RD4
argument_list|(
name|sc
argument_list|,
name|PLLE_SS_CNTL
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|reg
operator||=
name|PLLE_SS_CNTL_DISABLE
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|PLLE_SS_CNTL
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|RD4
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|base_reg
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|set_divisors
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|,
name|pll_m
argument_list|,
name|pll_n
argument_list|,
name|pll_p
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
operator|(
name|PLLE_BASE_DIVCML_MASK
operator|<<
name|PLLE_BASE_DIVCML_SHIFT
operator|)
expr_stmt|;
name|reg
operator||=
name|pll_cml
operator|<<
name|PLLE_BASE_DIVCML_SHIFT
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|base_reg
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|pll_enable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|rv
operator|=
name|wait_for_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
return|return
operator|(
name|rv
operator|)
return|;
name|RD4
argument_list|(
name|sc
argument_list|,
name|PLLE_SS_CNTL
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|PLLE_SS_CNTL_SSCCENTER
expr_stmt|;
name|reg
operator|&=
operator|~
name|PLLE_SS_CNTL_SSCINVERT
expr_stmt|;
name|reg
operator|&=
operator|~
name|PLLE_SS_CNTL_COEFFICIENTS_MASK
expr_stmt|;
name|reg
operator||=
name|PLLE_SS_CNTL_COEFFICIENTS_VAL
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|PLLE_SS_CNTL
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|PLLE_SS_CNTL_SSCBYP
expr_stmt|;
name|reg
operator|&=
operator|~
name|PLLE_SS_CNTL_BYPASS_SS
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|PLLE_SS_CNTL
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|PLLE_SS_CNTL_INTERP_RESET
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|PLLE_SS_CNTL
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* HW control of brick pll. */
name|RD4
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|misc_reg
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|PLLE_MISC_IDDQ_SWCTL
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|misc_reg
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|RD4
argument_list|(
name|sc
argument_list|,
name|PLLE_AUX
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|reg
operator||=
name|PLLE_AUX_USE_LOCKDET
expr_stmt|;
name|reg
operator||=
name|PLLE_AUX_SEQ_START_STATE
expr_stmt|;
name|reg
operator|&=
operator|~
name|PLLE_AUX_ENABLE_SWCTL
expr_stmt|;
name|reg
operator|&=
operator|~
name|PLLE_AUX_SS_SWCTL
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|PLLE_AUX
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg
operator||=
name|PLLE_AUX_SEQ_START_STATE
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|reg
operator||=
name|PLLE_AUX_SEQ_ENABLE
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|PLLE_AUX
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|RD4
argument_list|(
name|sc
argument_list|,
name|XUSBIO_PLL_CFG0
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|reg
operator||=
name|XUSBIO_PLL_CFG0_PADPLL_USE_LOCKDET
expr_stmt|;
name|reg
operator||=
name|XUSBIO_PLL_CFG0_SEQ_START_STATE
expr_stmt|;
name|reg
operator|&=
operator|~
name|XUSBIO_PLL_CFG0_CLK_ENABLE_SWCTL
expr_stmt|;
name|reg
operator|&=
operator|~
name|XUSBIO_PLL_CFG0_PADPLL_RESET_SWCTL
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|XUSBIO_PLL_CFG0
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|reg
operator||=
name|XUSBIO_PLL_CFG0_SEQ_ENABLE
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|XUSBIO_PLL_CFG0
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Enable HW control and unreset SATA PLL. */
name|RD4
argument_list|(
name|sc
argument_list|,
name|SATA_PLL_CFG0
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|SATA_PLL_CFG0_PADPLL_RESET_SWCTL
expr_stmt|;
name|reg
operator|&=
operator|~
name|SATA_PLL_CFG0_PADPLL_RESET_OVERRIDE_VALUE
expr_stmt|;
name|reg
operator||=
name|SATA_PLL_CFG0_PADPLL_USE_LOCKDET
expr_stmt|;
name|reg
operator|&=
operator|~
name|SATA_PLL_CFG0_SEQ_IN_SWCTL
expr_stmt|;
name|reg
operator|&=
operator|~
name|SATA_PLL_CFG0_SEQ_RESET_INPUT_VALUE
expr_stmt|;
name|reg
operator|&=
operator|~
name|SATA_PLL_CFG0_SEQ_LANE_PD_INPUT_VALUE
expr_stmt|;
name|reg
operator|&=
operator|~
name|SATA_PLL_CFG0_SEQ_PADPLL_PD_INPUT_VALUE
expr_stmt|;
name|reg
operator|&=
operator|~
name|SATA_PLL_CFG0_SEQ_ENABLE
expr_stmt|;
name|reg
operator||=
name|SATA_PLL_CFG0_SEQ_START_STATE
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|SATA_PLL_CFG0
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|reg
operator||=
name|SATA_PLL_CFG0_SEQ_ENABLE
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|SATA_PLL_CFG0
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Enable HW control of PCIe PLL. */
name|RD4
argument_list|(
name|sc
argument_list|,
name|PCIE_PLL_CFG0
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|reg
operator||=
name|PCIE_PLL_CFG0_SEQ_ENABLE
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|PCIE_PLL_CFG0
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tegra124_pll_set_gate
parameter_list|(
name|struct
name|clknode
modifier|*
name|clknode
parameter_list|,
name|bool
name|enable
parameter_list|)
block|{
name|int
name|rv
decl_stmt|;
name|struct
name|pll_sc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|clknode_get_softc
argument_list|(
name|clknode
argument_list|)
expr_stmt|;
if|if
condition|(
name|enable
operator|==
literal|0
condition|)
block|{
name|rv
operator|=
name|pll_disable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|type
operator|==
name|PLL_E
condition|)
name|rv
operator|=
name|plle_enable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|else
name|rv
operator|=
name|pll_enable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pll_set_std
parameter_list|(
name|struct
name|pll_sc
modifier|*
name|sc
parameter_list|,
name|uint64_t
name|fin
parameter_list|,
name|uint64_t
modifier|*
name|fout
parameter_list|,
name|int
name|flags
parameter_list|,
name|uint32_t
name|m
parameter_list|,
name|uint32_t
name|n
parameter_list|,
name|uint32_t
name|p
parameter_list|)
block|{
name|uint32_t
name|reg
decl_stmt|;
name|struct
name|mnp_bits
modifier|*
name|mnp_bits
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|mnp_bits
operator|=
operator|&
name|sc
operator|->
name|mnp_bits
expr_stmt|;
if|if
condition|(
name|m
operator|>=
operator|(
literal|1
operator|<<
name|mnp_bits
operator|->
name|m_width
operator|)
condition|)
return|return
operator|(
name|ERANGE
operator|)
return|;
if|if
condition|(
name|n
operator|>=
operator|(
literal|1
operator|<<
name|mnp_bits
operator|->
name|n_width
operator|)
condition|)
return|return
operator|(
name|ERANGE
operator|)
return|;
if|if
condition|(
name|pdiv_to_reg
argument_list|(
name|sc
argument_list|,
name|p
argument_list|)
operator|>=
operator|(
literal|1
operator|<<
name|mnp_bits
operator|->
name|p_width
operator|)
condition|)
return|return
operator|(
name|ERANGE
operator|)
return|;
if|if
condition|(
name|flags
operator|&
name|CLK_SET_DRYRUN
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|flags
operator|&
operator|(
name|CLK_SET_ROUND_UP
operator||
name|CLK_SET_ROUND_DOWN
operator|)
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|*
name|fout
operator|!=
operator|(
operator|(
operator|(
name|fin
operator|/
name|m
operator|)
operator|*
name|n
operator|)
operator|/
name|p
operator|)
operator|)
condition|)
return|return
operator|(
name|ERANGE
operator|)
return|;
operator|*
name|fout
operator|=
operator|(
operator|(
name|fin
operator|/
name|m
operator|)
operator|*
name|n
operator|)
operator|/
name|p
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|pll_disable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* take pll out of IDDQ */
if|if
condition|(
name|sc
operator|->
name|iddq_reg
operator|!=
literal|0
condition|)
name|MD4
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|iddq_reg
argument_list|,
name|sc
operator|->
name|iddq_mask
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|RD4
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|base_reg
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|set_masked
argument_list|(
name|reg
argument_list|,
name|m
argument_list|,
name|PLL_BASE_DIVM_SHIFT
argument_list|,
name|mnp_bits
operator|->
name|m_width
argument_list|)
expr_stmt|;
name|reg
operator|=
name|set_masked
argument_list|(
name|reg
argument_list|,
name|n
argument_list|,
name|PLL_BASE_DIVN_SHIFT
argument_list|,
name|mnp_bits
operator|->
name|n_width
argument_list|)
expr_stmt|;
name|reg
operator|=
name|set_masked
argument_list|(
name|reg
argument_list|,
name|pdiv_to_reg
argument_list|(
name|sc
argument_list|,
name|p
argument_list|)
argument_list|,
name|mnp_bits
operator|->
name|p_shift
argument_list|,
name|mnp_bits
operator|->
name|p_width
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|base_reg
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Enable PLL. */
name|RD4
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|base_reg
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|reg
operator||=
name|PLL_BASE_ENABLE
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|base_reg
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Enable lock detection. */
name|RD4
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|misc_reg
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|reg
operator||=
name|sc
operator|->
name|lock_enable
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|misc_reg
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|rv
operator|=
name|wait_for_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
comment|/* Disable PLL */
name|RD4
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|base_reg
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|PLL_BASE_ENABLE
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|base_reg
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
name|RD4
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|misc_reg
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|pll_enable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
operator|*
name|fout
operator|=
operator|(
operator|(
name|fin
operator|/
name|m
operator|)
operator|*
name|n
operator|)
operator|/
name|p
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|plla_set_freq
parameter_list|(
name|struct
name|pll_sc
modifier|*
name|sc
parameter_list|,
name|uint64_t
name|fin
parameter_list|,
name|uint64_t
modifier|*
name|fout
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|uint32_t
name|m
decl_stmt|,
name|n
decl_stmt|,
name|p
decl_stmt|;
name|p
operator|=
literal|1
expr_stmt|;
name|m
operator|=
literal|5
expr_stmt|;
name|n
operator|=
operator|(
operator|*
name|fout
operator|*
name|p
operator|*
name|m
operator|+
name|fin
operator|/
literal|2
operator|)
operator|/
name|fin
expr_stmt|;
name|dprintf
argument_list|(
literal|"%s: m: %d, n: %d, p: %d\n"
argument_list|,
name|__func__
argument_list|,
name|m
argument_list|,
name|n
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|pll_set_std
argument_list|(
name|sc
argument_list|,
name|fin
argument_list|,
name|fout
argument_list|,
name|flags
argument_list|,
name|m
argument_list|,
name|n
argument_list|,
name|p
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pllc_set_freq
parameter_list|(
name|struct
name|pll_sc
modifier|*
name|sc
parameter_list|,
name|uint64_t
name|fin
parameter_list|,
name|uint64_t
modifier|*
name|fout
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|uint32_t
name|m
decl_stmt|,
name|n
decl_stmt|,
name|p
decl_stmt|;
name|p
operator|=
literal|2
expr_stmt|;
name|m
operator|=
literal|1
expr_stmt|;
name|n
operator|=
operator|(
operator|*
name|fout
operator|*
name|p
operator|*
name|m
operator|+
name|fin
operator|/
literal|2
operator|)
operator|/
name|fin
expr_stmt|;
name|dprintf
argument_list|(
literal|"%s: m: %d, n: %d, p: %d\n"
argument_list|,
name|__func__
argument_list|,
name|m
argument_list|,
name|n
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|pll_set_std
argument_list|(
name|sc
argument_list|,
name|fin
argument_list|,
name|fout
argument_list|,
name|flags
argument_list|,
name|m
argument_list|,
name|n
argument_list|,
name|p
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|plld2_set_freq
parameter_list|(
name|struct
name|pll_sc
modifier|*
name|sc
parameter_list|,
name|uint64_t
name|fin
parameter_list|,
name|uint64_t
modifier|*
name|fout
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|uint32_t
name|m
decl_stmt|,
name|n
decl_stmt|,
name|p
decl_stmt|;
name|p
operator|=
literal|2
expr_stmt|;
name|m
operator|=
literal|1
expr_stmt|;
name|n
operator|=
operator|(
operator|*
name|fout
operator|*
name|p
operator|*
name|m
operator|+
name|fin
operator|/
literal|2
operator|)
operator|/
name|fin
expr_stmt|;
name|dprintf
argument_list|(
literal|"%s: m: %d, n: %d, p: %d\n"
argument_list|,
name|__func__
argument_list|,
name|m
argument_list|,
name|n
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|pll_set_std
argument_list|(
name|sc
argument_list|,
name|fin
argument_list|,
name|fout
argument_list|,
name|flags
argument_list|,
name|m
argument_list|,
name|n
argument_list|,
name|p
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pllrefe_set_freq
parameter_list|(
name|struct
name|pll_sc
modifier|*
name|sc
parameter_list|,
name|uint64_t
name|fin
parameter_list|,
name|uint64_t
modifier|*
name|fout
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|uint32_t
name|m
decl_stmt|,
name|n
decl_stmt|,
name|p
decl_stmt|;
name|m
operator|=
literal|1
expr_stmt|;
name|p
operator|=
literal|1
expr_stmt|;
name|n
operator|=
operator|*
name|fout
operator|*
name|p
operator|*
name|m
operator|/
name|fin
expr_stmt|;
name|dprintf
argument_list|(
literal|"%s: m: %d, n: %d, p: %d\n"
argument_list|,
name|__func__
argument_list|,
name|m
argument_list|,
name|n
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|pll_set_std
argument_list|(
name|sc
argument_list|,
name|fin
argument_list|,
name|fout
argument_list|,
name|flags
argument_list|,
name|m
argument_list|,
name|n
argument_list|,
name|p
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pllx_set_freq
parameter_list|(
name|struct
name|pll_sc
modifier|*
name|sc
parameter_list|,
name|uint64_t
name|fin
parameter_list|,
name|uint64_t
modifier|*
name|fout
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|uint32_t
name|reg
decl_stmt|;
name|uint32_t
name|m
decl_stmt|,
name|n
decl_stmt|,
name|p
decl_stmt|;
name|struct
name|mnp_bits
modifier|*
name|mnp_bits
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|mnp_bits
operator|=
operator|&
name|sc
operator|->
name|mnp_bits
expr_stmt|;
name|p
operator|=
literal|1
expr_stmt|;
name|m
operator|=
literal|1
expr_stmt|;
name|n
operator|=
operator|(
operator|*
name|fout
operator|*
name|p
operator|*
name|m
operator|+
name|fin
operator|/
literal|2
operator|)
operator|/
name|fin
expr_stmt|;
name|dprintf
argument_list|(
literal|"%s: m: %d, n: %d, p: %d\n"
argument_list|,
name|__func__
argument_list|,
name|m
argument_list|,
name|n
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|>=
operator|(
literal|1
operator|<<
name|mnp_bits
operator|->
name|m_width
operator|)
condition|)
return|return
operator|(
name|ERANGE
operator|)
return|;
if|if
condition|(
name|n
operator|>=
operator|(
literal|1
operator|<<
name|mnp_bits
operator|->
name|n_width
operator|)
condition|)
return|return
operator|(
name|ERANGE
operator|)
return|;
if|if
condition|(
name|pdiv_to_reg
argument_list|(
name|sc
argument_list|,
name|p
argument_list|)
operator|>=
operator|(
literal|1
operator|<<
name|mnp_bits
operator|->
name|p_width
operator|)
condition|)
return|return
operator|(
name|ERANGE
operator|)
return|;
if|if
condition|(
name|flags
operator|&
name|CLK_SET_DRYRUN
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|flags
operator|&
operator|(
name|CLK_SET_ROUND_UP
operator||
name|CLK_SET_ROUND_DOWN
operator|)
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|*
name|fout
operator|!=
operator|(
operator|(
operator|(
name|fin
operator|/
name|m
operator|)
operator|*
name|n
operator|)
operator|/
name|p
operator|)
operator|)
condition|)
return|return
operator|(
name|ERANGE
operator|)
return|;
operator|*
name|fout
operator|=
operator|(
operator|(
name|fin
operator|/
name|m
operator|)
operator|*
name|n
operator|)
operator|/
name|p
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* PLLX doesn't have bypass, disable it first. */
name|RD4
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|base_reg
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|PLL_BASE_ENABLE
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|base_reg
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Set PLL. */
name|RD4
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|base_reg
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|set_masked
argument_list|(
name|reg
argument_list|,
name|m
argument_list|,
name|PLL_BASE_DIVM_SHIFT
argument_list|,
name|mnp_bits
operator|->
name|m_width
argument_list|)
expr_stmt|;
name|reg
operator|=
name|set_masked
argument_list|(
name|reg
argument_list|,
name|n
argument_list|,
name|PLL_BASE_DIVN_SHIFT
argument_list|,
name|mnp_bits
operator|->
name|n_width
argument_list|)
expr_stmt|;
name|reg
operator|=
name|set_masked
argument_list|(
name|reg
argument_list|,
name|pdiv_to_reg
argument_list|(
name|sc
argument_list|,
name|p
argument_list|)
argument_list|,
name|mnp_bits
operator|->
name|p_shift
argument_list|,
name|mnp_bits
operator|->
name|p_width
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|base_reg
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|RD4
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|base_reg
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* Enable lock detection. */
name|RD4
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|misc_reg
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|reg
operator||=
name|sc
operator|->
name|lock_enable
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|misc_reg
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Enable PLL. */
name|RD4
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|base_reg
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|reg
operator||=
name|PLL_BASE_ENABLE
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|base_reg
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|rv
operator|=
name|wait_for_lock
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
comment|/* Disable PLL */
name|RD4
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|base_reg
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|PLL_BASE_ENABLE
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|base_reg
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
name|RD4
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|misc_reg
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
operator|*
name|fout
operator|=
operator|(
operator|(
name|fin
operator|/
name|m
operator|)
operator|*
name|n
operator|)
operator|/
name|p
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tegra124_pll_set_freq
parameter_list|(
name|struct
name|clknode
modifier|*
name|clknode
parameter_list|,
name|uint64_t
name|fin
parameter_list|,
name|uint64_t
modifier|*
name|fout
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
modifier|*
name|stop
parameter_list|)
block|{
operator|*
name|stop
operator|=
literal|1
expr_stmt|;
name|int
name|rv
decl_stmt|;
name|struct
name|pll_sc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|clknode_get_softc
argument_list|(
name|clknode
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|"%s: Requested freq: %llu, input freq: %llu\n"
argument_list|,
name|__func__
argument_list|,
operator|*
name|fout
argument_list|,
name|fin
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|type
condition|)
block|{
case|case
name|PLL_A
case|:
name|rv
operator|=
name|plla_set_freq
argument_list|(
name|sc
argument_list|,
name|fin
argument_list|,
name|fout
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|PLL_C
case|:
name|rv
operator|=
name|pllc_set_freq
argument_list|(
name|sc
argument_list|,
name|fin
argument_list|,
name|fout
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|PLL_D2
case|:
name|rv
operator|=
name|plld2_set_freq
argument_list|(
name|sc
argument_list|,
name|fin
argument_list|,
name|fout
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|PLL_REFE
case|:
name|rv
operator|=
name|pllrefe_set_freq
argument_list|(
name|sc
argument_list|,
name|fin
argument_list|,
name|fout
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|PLL_X
case|:
name|rv
operator|=
name|pllx_set_freq
argument_list|(
name|sc
argument_list|,
name|fin
argument_list|,
name|fout
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|PLL_U
case|:
if|if
condition|(
operator|*
name|fout
operator|==
literal|480000000
condition|)
comment|/* PLLU is fixed to 480 MHz */
name|rv
operator|=
literal|0
expr_stmt|;
else|else
name|rv
operator|=
name|ERANGE
expr_stmt|;
break|break;
default|default:
name|rv
operator|=
name|ENXIO
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tegra124_pll_init
parameter_list|(
name|struct
name|clknode
modifier|*
name|clk
parameter_list|,
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|pll_sc
modifier|*
name|sc
decl_stmt|;
name|uint32_t
name|reg
decl_stmt|;
name|sc
operator|=
name|clknode_get_softc
argument_list|(
name|clk
argument_list|)
expr_stmt|;
comment|/* If PLL is enabled, enable lock detect too. */
name|RD4
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|base_reg
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|&
name|PLL_BASE_ENABLE
condition|)
block|{
name|RD4
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|misc_reg
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|reg
operator||=
name|sc
operator|->
name|lock_enable
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|misc_reg
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|type
operator|==
name|PLL_REFE
condition|)
block|{
name|RD4
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|misc_reg
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
operator|(
literal|1
operator|<<
literal|29
operator|)
expr_stmt|;
comment|/* Diasble lock override */
name|WR4
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|misc_reg
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
name|clknode_init_parent_idx
argument_list|(
name|clk
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tegra124_pll_recalc
parameter_list|(
name|struct
name|clknode
modifier|*
name|clk
parameter_list|,
name|uint64_t
modifier|*
name|freq
parameter_list|)
block|{
name|struct
name|pll_sc
modifier|*
name|sc
decl_stmt|;
name|uint32_t
name|m
decl_stmt|,
name|n
decl_stmt|,
name|p
decl_stmt|,
name|pr
decl_stmt|;
name|uint32_t
name|reg
decl_stmt|,
name|misc_reg
decl_stmt|;
name|int
name|locked
decl_stmt|;
name|sc
operator|=
name|clknode_get_softc
argument_list|(
name|clk
argument_list|)
expr_stmt|;
name|RD4
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|base_reg
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|RD4
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|misc_reg
argument_list|,
operator|&
name|misc_reg
argument_list|)
expr_stmt|;
name|get_divisors
argument_list|(
name|sc
argument_list|,
operator|&
name|m
argument_list|,
operator|&
name|n
argument_list|,
operator|&
name|pr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|type
operator|!=
name|PLL_E
condition|)
name|p
operator|=
name|reg_to_pdiv
argument_list|(
name|sc
argument_list|,
name|pr
argument_list|)
expr_stmt|;
else|else
name|p
operator|=
literal|2
operator|*
operator|(
name|pr
operator|-
literal|1
operator|)
expr_stmt|;
name|locked
operator|=
name|is_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|"%s: %s (0x%08x, 0x%08x) - m: %d, n: %d, p: %d (%d): "
literal|"e: %d, r: %d, o: %d - %s\n"
argument_list|,
name|__func__
argument_list|,
name|clknode_get_name
argument_list|(
name|clk
argument_list|)
argument_list|,
name|reg
argument_list|,
name|misc_reg
argument_list|,
name|m
argument_list|,
name|n
argument_list|,
name|p
argument_list|,
name|pr
argument_list|,
operator|(
name|reg
operator|>>
literal|30
operator|)
operator|&
literal|1
argument_list|,
operator|(
name|reg
operator|>>
literal|29
operator|)
operator|&
literal|1
argument_list|,
operator|(
name|reg
operator|>>
literal|28
operator|)
operator|&
literal|1
argument_list|,
name|locked
condition|?
literal|"locked"
else|:
literal|"unlocked"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|==
literal|0
operator|)
operator|||
operator|(
name|n
operator|==
literal|0
operator|)
operator|||
operator|(
name|p
operator|==
literal|0
operator|)
condition|)
block|{
operator|*
name|freq
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
operator|*
name|freq
operator|=
operator|(
operator|(
operator|*
name|freq
operator|/
name|m
operator|)
operator|*
name|n
operator|)
operator|/
name|p
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pll_register
parameter_list|(
name|struct
name|clkdom
modifier|*
name|clkdom
parameter_list|,
name|struct
name|clk_pll_def
modifier|*
name|clkdef
parameter_list|)
block|{
name|struct
name|clknode
modifier|*
name|clk
decl_stmt|;
name|struct
name|pll_sc
modifier|*
name|sc
decl_stmt|;
name|clk
operator|=
name|clknode_create
argument_list|(
name|clkdom
argument_list|,
operator|&
name|tegra124_pll_class
argument_list|,
operator|&
name|clkdef
operator|->
name|clkdef
argument_list|)
expr_stmt|;
if|if
condition|(
name|clk
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|sc
operator|=
name|clknode_get_softc
argument_list|(
name|clk
argument_list|)
expr_stmt|;
name|sc
operator|->
name|clkdev
operator|=
name|clknode_get_device
argument_list|(
name|clk
argument_list|)
expr_stmt|;
name|sc
operator|->
name|type
operator|=
name|clkdef
operator|->
name|type
expr_stmt|;
name|sc
operator|->
name|base_reg
operator|=
name|clkdef
operator|->
name|base_reg
expr_stmt|;
name|sc
operator|->
name|misc_reg
operator|=
name|clkdef
operator|->
name|misc_reg
expr_stmt|;
name|sc
operator|->
name|lock_mask
operator|=
name|clkdef
operator|->
name|lock_mask
expr_stmt|;
name|sc
operator|->
name|lock_enable
operator|=
name|clkdef
operator|->
name|lock_enable
expr_stmt|;
name|sc
operator|->
name|iddq_reg
operator|=
name|clkdef
operator|->
name|iddq_reg
expr_stmt|;
name|sc
operator|->
name|iddq_mask
operator|=
name|clkdef
operator|->
name|iddq_mask
expr_stmt|;
name|sc
operator|->
name|flags
operator|=
name|clkdef
operator|->
name|flags
expr_stmt|;
name|sc
operator|->
name|pdiv_table
operator|=
name|clkdef
operator|->
name|pdiv_table
expr_stmt|;
name|sc
operator|->
name|mnp_bits
operator|=
name|clkdef
operator|->
name|mnp_bits
expr_stmt|;
name|clknode_register
argument_list|(
name|clkdom
argument_list|,
name|clk
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|config_utmi_pll
parameter_list|(
name|struct
name|tegra124_car_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|reg
decl_stmt|;
comment|/* 	 * XXX Simplified UTMIP settings for 12MHz base clock. 	 */
define|#
directive|define
name|ENABLE_DELAY_COUNT
value|0x02
define|#
directive|define
name|STABLE_COUNT
value|0x2F
define|#
directive|define
name|ACTIVE_DELAY_COUNT
value|0x04
define|#
directive|define
name|XTAL_FREQ_COUNT
value|0x76
name|CLKDEV_READ_4
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|UTMIP_PLL_CFG2
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|UTMIP_PLL_CFG2_STABLE_COUNT
argument_list|(
operator|~
literal|0
argument_list|)
expr_stmt|;
name|reg
operator||=
name|UTMIP_PLL_CFG2_STABLE_COUNT
argument_list|(
name|STABLE_COUNT
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|UTMIP_PLL_CFG2_ACTIVE_DLY_COUNT
argument_list|(
operator|~
literal|0
argument_list|)
expr_stmt|;
name|reg
operator||=
name|UTMIP_PLL_CFG2_ACTIVE_DLY_COUNT
argument_list|(
name|ACTIVE_DELAY_COUNT
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|UTMIP_PLL_CFG2_FORCE_PD_SAMP_A_POWERDOWN
expr_stmt|;
name|reg
operator|&=
operator|~
name|UTMIP_PLL_CFG2_FORCE_PD_SAMP_B_POWERDOWN
expr_stmt|;
name|reg
operator|&=
operator|~
name|UTMIP_PLL_CFG2_FORCE_PD_SAMP_C_POWERDOWN
expr_stmt|;
name|CLKDEV_WRITE_4
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|UTMIP_PLL_CFG2
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|CLKDEV_READ_4
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|UTMIP_PLL_CFG1
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|UTMIP_PLL_CFG1_ENABLE_DLY_COUNT
argument_list|(
operator|~
literal|0
argument_list|)
expr_stmt|;
name|reg
operator||=
name|UTMIP_PLL_CFG1_ENABLE_DLY_COUNT
argument_list|(
name|ENABLE_DELAY_COUNT
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|UTMIP_PLL_CFG1_XTAL_FREQ_COUNT
argument_list|(
operator|~
literal|0
argument_list|)
expr_stmt|;
name|reg
operator||=
name|UTMIP_PLL_CFG1_XTAL_FREQ_COUNT
argument_list|(
name|XTAL_FREQ_COUNT
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|UTMIP_PLL_CFG1_FORCE_PLL_ENABLE_POWERDOWN
expr_stmt|;
name|reg
operator|&=
operator|~
name|UTMIP_PLL_CFG1_FORCE_PLL_ACTIVE_POWERDOWN
expr_stmt|;
name|reg
operator|&=
operator|~
name|UTMIP_PLL_CFG1_FORCE_PLLU_POWERUP
expr_stmt|;
name|reg
operator|&=
operator|~
name|UTMIP_PLL_CFG1_FORCE_PLLU_POWERDOWN
expr_stmt|;
name|CLKDEV_WRITE_4
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|UTMIP_PLL_CFG1
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Prepare UTMIP requencer. */
name|CLKDEV_READ_4
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|UTMIPLL_HW_PWRDN_CFG0
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|reg
operator||=
name|UTMIPLL_HW_PWRDN_CFG0_USE_LOCKDET
expr_stmt|;
name|reg
operator|&=
operator|~
name|UTMIPLL_HW_PWRDN_CFG0_CLK_ENABLE_SWCTL
expr_stmt|;
name|reg
operator||=
name|UTMIPLL_HW_PWRDN_CFG0_SEQ_START_STATE
expr_stmt|;
name|CLKDEV_WRITE_4
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|UTMIPLL_HW_PWRDN_CFG0
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Powerup UTMIP. */
name|CLKDEV_READ_4
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|UTMIP_PLL_CFG1
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|UTMIP_PLL_CFG1_FORCE_PLL_ENABLE_POWERUP
expr_stmt|;
name|reg
operator|&=
operator|~
name|UTMIP_PLL_CFG1_FORCE_PLL_ENABLE_POWERDOWN
expr_stmt|;
name|CLKDEV_WRITE_4
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|UTMIP_PLL_CFG1
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* SW override for UTMIPLL */
name|CLKDEV_READ_4
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|UTMIPLL_HW_PWRDN_CFG0
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|reg
operator||=
name|UTMIPLL_HW_PWRDN_CFG0_IDDQ_SWCTL
expr_stmt|;
name|reg
operator|&=
operator|~
name|UTMIPLL_HW_PWRDN_CFG0_IDDQ_OVERRIDE
expr_stmt|;
name|CLKDEV_WRITE_4
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|UTMIPLL_HW_PWRDN_CFG0
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* HW control of UTMIPLL. */
name|CLKDEV_READ_4
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|UTMIPLL_HW_PWRDN_CFG0
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|reg
operator||=
name|UTMIPLL_HW_PWRDN_CFG0_SEQ_ENABLE
expr_stmt|;
name|CLKDEV_WRITE_4
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|UTMIPLL_HW_PWRDN_CFG0
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|tegra124_init_plls
parameter_list|(
name|struct
name|tegra124_car_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|rv
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|pll_clks
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rv
operator|=
name|pll_register
argument_list|(
name|sc
operator|->
name|clkdom
argument_list|,
name|pll_clks
operator|+
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"pll_register failed"
argument_list|)
expr_stmt|;
block|}
name|config_utmi_pll
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

