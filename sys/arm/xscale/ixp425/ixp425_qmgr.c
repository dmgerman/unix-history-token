begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2006 Sam Leffler, Errno Consulting  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    similar to the "NO WARRANTY" disclaimer below ("Disclaimer") and any  *    redistribution must be conditioned upon including a substantially  *    similar Disclaimer requirement for further binary redistribution.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTIBILITY  * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL  * THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY,  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER  * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_comment
comment|/*-  * Copyright (c) 2001-2005, Intel Corporation.  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the Intel Corporation nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *   *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS IS''  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE. */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Intel XScale Queue Manager support.  *  * Each IXP4XXX device has a hardware block that implements a priority  * queue manager that is shared between the XScale cpu and the backend  * devices (such as the NPE).  Queues are accessed by reading/writing  * special memory locations.  The queue contents are mapped into a shared  * SRAM region with entries managed in a circular buffer.  The XScale  * processor can receive interrupts based on queue contents (a condition  * code determines when interrupts should be delivered).  *  * The code here basically replaces the qmgr class in the Intel Access  * Library (IAL).  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpufunc.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<machine/intr.h>
end_include

begin_include
include|#
directive|include
file|<arm/xscale/ixp425/ixp425reg.h>
end_include

begin_include
include|#
directive|include
file|<arm/xscale/ixp425/ixp425var.h>
end_include

begin_include
include|#
directive|include
file|<arm/xscale/ixp425/ixp425_qmgr.h>
end_include

begin_comment
comment|/*  * State per AQM hw queue.  * This structure holds q configuration and dispatch state.  */
end_comment

begin_struct
struct|struct
name|qmgrInfo
block|{
name|int
name|qSizeInWords
decl_stmt|;
comment|/* queue size in words */
name|uint32_t
name|qOflowStatBitMask
decl_stmt|;
comment|/* overflow status mask */
name|int
name|qWriteCount
decl_stmt|;
comment|/* queue write count */
name|bus_size_t
name|qAccRegAddr
decl_stmt|;
comment|/* access register */
name|bus_size_t
name|qUOStatRegAddr
decl_stmt|;
comment|/* status register */
name|bus_size_t
name|qConfigRegAddr
decl_stmt|;
comment|/* config register */
name|int
name|qSizeInEntries
decl_stmt|;
comment|/* queue size in entries */
name|uint32_t
name|qUflowStatBitMask
decl_stmt|;
comment|/* underflow status mask */
name|int
name|qReadCount
decl_stmt|;
comment|/* queue read count */
comment|/* XXX union */
name|uint32_t
name|qStatRegAddr
decl_stmt|;
name|uint32_t
name|qStatBitsOffset
decl_stmt|;
name|uint32_t
name|qStat0BitMask
decl_stmt|;
name|uint32_t
name|qStat1BitMask
decl_stmt|;
name|uint32_t
name|intRegCheckMask
decl_stmt|;
comment|/* interrupt reg check mask */
name|void
function_decl|(
modifier|*
name|cb
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
comment|/* callback function */
name|void
modifier|*
name|cbarg
decl_stmt|;
comment|/* callback argument */
name|int
name|priority
decl_stmt|;
comment|/* dispatch priority */
if|#
directive|if
literal|0
comment|/* NB: needed only for A0 parts */
block|u_int		statusWordOffset;
comment|/* status word offset */
block|uint32_t	statusMask;
comment|/* status mask */
block|uint32_t	statusCheckValue;
comment|/* status check value */
endif|#
directive|endif
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ixpqmgr_softc
block|{
name|device_t
name|sc_dev
decl_stmt|;
name|bus_space_tag_t
name|sc_iot
decl_stmt|;
name|bus_space_handle_t
name|sc_ioh
decl_stmt|;
name|struct
name|resource
modifier|*
name|sc_irq1
decl_stmt|;
comment|/* IRQ resource */
name|void
modifier|*
name|sc_ih1
decl_stmt|;
comment|/* interrupt handler */
name|int
name|sc_rid1
decl_stmt|;
comment|/* resource id for irq */
name|struct
name|resource
modifier|*
name|sc_irq2
decl_stmt|;
name|void
modifier|*
name|sc_ih2
decl_stmt|;
name|int
name|sc_rid2
decl_stmt|;
name|struct
name|qmgrInfo
name|qinfo
index|[
name|IX_QMGR_MAX_NUM_QUEUES
index|]
decl_stmt|;
comment|/* 	 * This array contains a list of queue identifiers ordered by 	 * priority. The table is split logically between queue 	 * identifiers 0-31 and 32-63.  To optimize lookups bit masks 	 * are kept for the first-32 and last-32 q's.  When the 	 * table needs to be rebuilt mark rebuildTable and it'll 	 * happen after the next interrupt. 	 */
name|int
name|priorityTable
index|[
name|IX_QMGR_MAX_NUM_QUEUES
index|]
decl_stmt|;
name|uint32_t
name|lowPriorityTableFirstHalfMask
decl_stmt|;
name|uint32_t
name|uppPriorityTableFirstHalfMask
decl_stmt|;
name|int
name|rebuildTable
decl_stmt|;
comment|/* rebuild priorityTable */
name|uint32_t
name|aqmFreeSramAddress
decl_stmt|;
comment|/* SRAM free space */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|qmgr_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|qmgr
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|qmgr_debug
argument_list|,
literal|0
argument_list|,
literal|"IXP4XX Q-Manager debug msgs"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"debug.qmgr"
argument_list|,
operator|&
name|qmgr_debug
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|dev
parameter_list|,
name|fmt
parameter_list|,
modifier|...
parameter_list|)
value|do {					\ 	if (qmgr_debug) printf(fmt, __VA_ARGS__);			\ } while (0)
end_define

begin_define
define|#
directive|define
name|DPRINTFn
parameter_list|(
name|n
parameter_list|,
name|dev
parameter_list|,
name|fmt
parameter_list|,
modifier|...
parameter_list|)
value|do {					\ 	if (qmgr_debug>= n) printf(fmt, __VA_ARGS__);			\ } while (0)
end_define

begin_decl_stmt
specifier|static
name|struct
name|ixpqmgr_softc
modifier|*
name|ixpqmgr_sc
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|ixpqmgr_rebuild
parameter_list|(
name|struct
name|ixpqmgr_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixpqmgr_intr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aqm_int_enable
parameter_list|(
name|struct
name|ixpqmgr_softc
modifier|*
name|sc
parameter_list|,
name|int
name|qId
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aqm_int_disable
parameter_list|(
name|struct
name|ixpqmgr_softc
modifier|*
name|sc
parameter_list|,
name|int
name|qId
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aqm_qcfg
parameter_list|(
name|struct
name|ixpqmgr_softc
modifier|*
name|sc
parameter_list|,
name|int
name|qId
parameter_list|,
name|u_int
name|ne
parameter_list|,
name|u_int
name|nf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aqm_srcsel_write
parameter_list|(
name|struct
name|ixpqmgr_softc
modifier|*
name|sc
parameter_list|,
name|int
name|qId
parameter_list|,
name|int
name|sourceId
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aqm_reset
parameter_list|(
name|struct
name|ixpqmgr_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|dummyCallback
parameter_list|(
name|int
name|qId
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
comment|/* XXX complain */
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|aqm_reg_read
parameter_list|(
name|struct
name|ixpqmgr_softc
modifier|*
name|sc
parameter_list|,
name|bus_size_t
name|off
parameter_list|)
block|{
name|DPRINTFn
argument_list|(
literal|9
argument_list|,
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s(0x%x)\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|int
operator|)
name|off
argument_list|)
expr_stmt|;
return|return
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|sc_iot
argument_list|,
name|sc
operator|->
name|sc_ioh
argument_list|,
name|off
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|aqm_reg_write
parameter_list|(
name|struct
name|ixpqmgr_softc
modifier|*
name|sc
parameter_list|,
name|bus_size_t
name|off
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
name|DPRINTFn
argument_list|(
literal|9
argument_list|,
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s(0x%x, 0x%x)\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|int
operator|)
name|off
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|sc
operator|->
name|sc_iot
argument_list|,
name|sc
operator|->
name|sc_ioh
argument_list|,
name|off
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ixpqmgr_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"IXP4XX Q-Manager"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ixpqmgr_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ixpqmgr_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ixp425_softc
modifier|*
name|sa
init|=
name|device_get_softc
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|err
decl_stmt|;
name|ixpqmgr_sc
operator|=
name|sc
expr_stmt|;
name|sc
operator|->
name|sc_dev
operator|=
name|dev
expr_stmt|;
name|sc
operator|->
name|sc_iot
operator|=
name|sa
operator|->
name|sc_iot
expr_stmt|;
if|if
condition|(
name|bus_space_map
argument_list|(
name|sc
operator|->
name|sc_iot
argument_list|,
name|IXP425_QMGR_HWBASE
argument_list|,
name|IXP425_QMGR_SIZE
argument_list|,
literal|0
argument_list|,
operator|&
name|sc
operator|->
name|sc_ioh
argument_list|)
condition|)
name|panic
argument_list|(
literal|"%s: Cannot map registers"
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* NB: we only use the lower 32 q's */
comment|/* Set up QMGR interrupts */
name|sc
operator|->
name|sc_rid1
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_irq1
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|sc
operator|->
name|sc_rid1
argument_list|,
name|IXP425_INT_QUE1_32
argument_list|,
name|IXP425_INT_QUE1_32
argument_list|,
literal|1
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rid2
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_irq2
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|sc
operator|->
name|sc_rid2
argument_list|,
name|IXP425_INT_QUE33_64
argument_list|,
name|IXP425_INT_QUE33_64
argument_list|,
literal|1
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_irq1
operator|==
name|NULL
operator|||
name|sc
operator|->
name|sc_irq2
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"Unable to allocate the qmgr irqs.\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|sc_irq1
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|ixpqmgr_intr
argument_list|,
name|NULL
argument_list|,
operator|&
name|sc
operator|->
name|sc_ih1
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to set up qmgr irq=%d\n"
argument_list|,
name|IXP425_INT_QUE1_32
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|err
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|sc_irq2
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|ixpqmgr_intr
argument_list|,
name|NULL
argument_list|,
operator|&
name|sc
operator|->
name|sc_ih2
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to set up qmgr irq=%d\n"
argument_list|,
name|IXP425_INT_QUE33_64
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* NB: softc is pre-zero'd */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IX_QMGR_MAX_NUM_QUEUES
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|qmgrInfo
modifier|*
name|qi
init|=
operator|&
name|sc
operator|->
name|qinfo
index|[
name|i
index|]
decl_stmt|;
name|qi
operator|->
name|cb
operator|=
name|dummyCallback
expr_stmt|;
name|qi
operator|->
name|priority
operator|=
name|IX_QMGR_Q_PRIORITY_0
expr_stmt|;
comment|/* default priority */
comment|/*  	     * There are two interrupt registers, 32 bits each. One 	     * for the lower queues(0-31) and one for the upper 	     * queues(32-63). Therefore need to mod by 32 i.e the 	     * min upper queue identifier. 	     */
name|qi
operator|->
name|intRegCheckMask
operator|=
operator|(
literal|1
operator|<<
operator|(
name|i
operator|%
operator|(
name|IX_QMGR_MIN_QUEUPP_QID
operator|)
operator|)
operator|)
expr_stmt|;
comment|/* 	     * Register addresses and bit masks are calculated and 	     * stored here to optimize QRead, QWrite and QStatusGet 	     * functions. 	     */
comment|/* AQM Queue access reg addresses, per queue */
name|qi
operator|->
name|qAccRegAddr
operator|=
name|IX_QMGR_Q_ACCESS_ADDR_GET
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|qi
operator|->
name|qAccRegAddr
operator|=
name|IX_QMGR_Q_ACCESS_ADDR_GET
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|qi
operator|->
name|qConfigRegAddr
operator|=
name|IX_QMGR_Q_CONFIG_ADDR_GET
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|/* AQM Queue lower-group (0-31), only */
if|if
condition|(
name|i
operator|<
name|IX_QMGR_MIN_QUEUPP_QID
condition|)
block|{
comment|/* AQM Q underflow/overflow status reg address, per queue */
name|qi
operator|->
name|qUOStatRegAddr
operator|=
name|IX_QMGR_QUEUOSTAT0_OFFSET
operator|+
operator|(
operator|(
name|i
operator|/
name|IX_QMGR_QUEUOSTAT_NUM_QUE_PER_WORD
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
expr_stmt|;
comment|/* AQM Q underflow status bit masks for status reg per queue */
name|qi
operator|->
name|qUflowStatBitMask
operator|=
operator|(
name|IX_QMGR_UNDERFLOW_BIT_OFFSET
operator|+
literal|1
operator|)
operator|<<
operator|(
operator|(
name|i
operator|&
operator|(
name|IX_QMGR_QUEUOSTAT_NUM_QUE_PER_WORD
operator|-
literal|1
operator|)
operator|)
operator|*
operator|(
literal|32
operator|/
name|IX_QMGR_QUEUOSTAT_NUM_QUE_PER_WORD
operator|)
operator|)
expr_stmt|;
comment|/* AQM Q overflow status bit masks for status reg, per queue */
name|qi
operator|->
name|qOflowStatBitMask
operator|=
operator|(
name|IX_QMGR_OVERFLOW_BIT_OFFSET
operator|+
literal|1
operator|)
operator|<<
operator|(
operator|(
name|i
operator|&
operator|(
name|IX_QMGR_QUEUOSTAT_NUM_QUE_PER_WORD
operator|-
literal|1
operator|)
operator|)
operator|*
operator|(
literal|32
operator|/
name|IX_QMGR_QUEUOSTAT_NUM_QUE_PER_WORD
operator|)
operator|)
expr_stmt|;
comment|/* AQM Q lower-group (0-31) status reg addresses, per queue */
name|qi
operator|->
name|qStatRegAddr
operator|=
name|IX_QMGR_QUELOWSTAT0_OFFSET
operator|+
operator|(
operator|(
name|i
operator|/
name|IX_QMGR_QUELOWSTAT_NUM_QUE_PER_WORD
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
expr_stmt|;
comment|/* AQM Q lower-group (0-31) status register bit offset */
name|qi
operator|->
name|qStatBitsOffset
operator|=
operator|(
name|i
operator|&
operator|(
name|IX_QMGR_QUELOWSTAT_NUM_QUE_PER_WORD
operator|-
literal|1
operator|)
operator|)
operator|*
operator|(
literal|32
operator|/
name|IX_QMGR_QUELOWSTAT_NUM_QUE_PER_WORD
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* AQM Q upper-group (32-63), only */
name|qi
operator|->
name|qUOStatRegAddr
operator|=
literal|0
expr_stmt|;
comment|/* XXX */
comment|/* AQM Q upper-group (32-63) Nearly Empty status reg bitmasks */
name|qi
operator|->
name|qStat0BitMask
operator|=
operator|(
literal|1
operator|<<
operator|(
name|i
operator|-
name|IX_QMGR_MIN_QUEUPP_QID
operator|)
operator|)
expr_stmt|;
comment|/* AQM Q upper-group (32-63) Full status register bitmasks */
name|qi
operator|->
name|qStat1BitMask
operator|=
operator|(
literal|1
operator|<<
operator|(
name|i
operator|-
name|IX_QMGR_MIN_QUEUPP_QID
operator|)
operator|)
expr_stmt|;
block|}
block|}
name|sc
operator|->
name|aqmFreeSramAddress
operator|=
literal|0x100
expr_stmt|;
comment|/* Q buffer space starts at 0x2100 */
name|ixpqmgr_rebuild
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* build inital priority table */
name|aqm_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* reset h/w */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ixpqmgr_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ixpqmgr_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|aqm_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* disable interrupts */
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|sc_irq1
argument_list|,
name|sc
operator|->
name|sc_ih1
argument_list|)
expr_stmt|;
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|sc_irq2
argument_list|,
name|sc
operator|->
name|sc_ih2
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|sc_rid1
argument_list|,
name|sc
operator|->
name|sc_irq1
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|sc_rid2
argument_list|,
name|sc
operator|->
name|sc_irq2
argument_list|)
expr_stmt|;
name|bus_space_unmap
argument_list|(
name|sc
operator|->
name|sc_iot
argument_list|,
name|sc
operator|->
name|sc_ioh
argument_list|,
name|IXP425_QMGR_SIZE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ixpqmgr_qconfig
parameter_list|(
name|int
name|qId
parameter_list|,
name|int
name|qEntries
parameter_list|,
name|int
name|ne
parameter_list|,
name|int
name|nf
parameter_list|,
name|int
name|srcSel
parameter_list|,
name|qconfig_hand_t
modifier|*
name|cb
parameter_list|,
name|void
modifier|*
name|cbarg
parameter_list|)
block|{
name|struct
name|ixpqmgr_softc
modifier|*
name|sc
init|=
name|ixpqmgr_sc
decl_stmt|;
name|struct
name|qmgrInfo
modifier|*
name|qi
init|=
operator|&
name|sc
operator|->
name|qinfo
index|[
name|qId
index|]
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s(%u, %u, %u, %u, %u, %p, %p)\n"
argument_list|,
name|__func__
argument_list|,
name|qId
argument_list|,
name|qEntries
argument_list|,
name|ne
argument_list|,
name|nf
argument_list|,
name|srcSel
argument_list|,
name|cb
argument_list|,
name|cbarg
argument_list|)
expr_stmt|;
comment|/* NB: entry size is always 1 */
name|qi
operator|->
name|qSizeInWords
operator|=
name|qEntries
expr_stmt|;
name|qi
operator|->
name|qReadCount
operator|=
literal|0
expr_stmt|;
name|qi
operator|->
name|qWriteCount
operator|=
literal|0
expr_stmt|;
name|qi
operator|->
name|qSizeInEntries
operator|=
name|qEntries
expr_stmt|;
comment|/* XXX kept for code clarity */
if|if
condition|(
name|cb
operator|==
name|NULL
condition|)
block|{
comment|/* Reset to dummy callback */
name|qi
operator|->
name|cb
operator|=
name|dummyCallback
expr_stmt|;
name|qi
operator|->
name|cbarg
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|qi
operator|->
name|cb
operator|=
name|cb
expr_stmt|;
name|qi
operator|->
name|cbarg
operator|=
name|cbarg
expr_stmt|;
block|}
comment|/* Write the config register; NB must be AFTER qinfo setup */
name|aqm_qcfg
argument_list|(
name|sc
argument_list|,
name|qId
argument_list|,
name|ne
argument_list|,
name|nf
argument_list|)
expr_stmt|;
comment|/* 	 * Account for space just allocated to queue. 	 */
name|sc
operator|->
name|aqmFreeSramAddress
operator|+=
operator|(
name|qi
operator|->
name|qSizeInWords
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
expr_stmt|;
comment|/* Set the interrupt source if this queue is in the range 0-31 */
if|if
condition|(
name|qId
operator|<
name|IX_QMGR_MIN_QUEUPP_QID
condition|)
name|aqm_srcsel_write
argument_list|(
name|sc
argument_list|,
name|qId
argument_list|,
name|srcSel
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|!=
name|NULL
condition|)
comment|/* Enable the interrupt */
name|aqm_int_enable
argument_list|(
name|sc
argument_list|,
name|qId
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rebuildTable
operator|=
name|TRUE
expr_stmt|;
return|return
literal|0
return|;
comment|/* XXX */
block|}
end_function

begin_function
name|int
name|ixpqmgr_qwrite
parameter_list|(
name|int
name|qId
parameter_list|,
name|uint32_t
name|entry
parameter_list|)
block|{
name|struct
name|ixpqmgr_softc
modifier|*
name|sc
init|=
name|ixpqmgr_sc
decl_stmt|;
name|struct
name|qmgrInfo
modifier|*
name|qi
init|=
operator|&
name|sc
operator|->
name|qinfo
index|[
name|qId
index|]
decl_stmt|;
name|DPRINTFn
argument_list|(
literal|3
argument_list|,
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s(%u, 0x%x) writeCount %u size %u\n"
argument_list|,
name|__func__
argument_list|,
name|qId
argument_list|,
name|entry
argument_list|,
name|qi
operator|->
name|qWriteCount
argument_list|,
name|qi
operator|->
name|qSizeInEntries
argument_list|)
expr_stmt|;
comment|/* write the entry */
name|aqm_reg_write
argument_list|(
name|sc
argument_list|,
name|qi
operator|->
name|qAccRegAddr
argument_list|,
name|entry
argument_list|)
expr_stmt|;
comment|/* NB: overflow is available for lower queues only */
if|if
condition|(
name|qId
operator|<
name|IX_QMGR_MIN_QUEUPP_QID
condition|)
block|{
name|int
name|qSize
init|=
name|qi
operator|->
name|qSizeInEntries
decl_stmt|;
comment|/* 	     * Increment the current number of entries in the queue 	     * and check for overflow . 	     */
if|if
condition|(
name|qi
operator|->
name|qWriteCount
operator|++
operator|==
name|qSize
condition|)
block|{
comment|/* check for overflow */
name|uint32_t
name|status
init|=
name|aqm_reg_read
argument_list|(
name|sc
argument_list|,
name|qi
operator|->
name|qUOStatRegAddr
argument_list|)
decl_stmt|;
name|int
name|qPtrs
decl_stmt|;
comment|/* 		 * Read the status twice because the status may  		 * not be immediately ready after the write operation 		 */
if|if
condition|(
operator|(
name|status
operator|&
name|qi
operator|->
name|qOflowStatBitMask
operator|)
operator|||
operator|(
operator|(
name|status
operator|=
name|aqm_reg_read
argument_list|(
name|sc
argument_list|,
name|qi
operator|->
name|qUOStatRegAddr
argument_list|)
operator|)
operator|&
name|qi
operator|->
name|qOflowStatBitMask
operator|)
condition|)
block|{
comment|/* 		     * The queue is full, clear the overflow status bit if set. 		     */
name|aqm_reg_write
argument_list|(
name|sc
argument_list|,
name|qi
operator|->
name|qUOStatRegAddr
argument_list|,
name|status
operator|&
operator|~
name|qi
operator|->
name|qOflowStatBitMask
argument_list|)
expr_stmt|;
name|qi
operator|->
name|qWriteCount
operator|=
name|qSize
expr_stmt|;
name|DPRINTFn
argument_list|(
literal|5
argument_list|,
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s(%u, 0x%x) Q full, overflow status cleared\n"
argument_list|,
name|__func__
argument_list|,
name|qId
argument_list|,
name|entry
argument_list|)
expr_stmt|;
return|return
name|ENOSPC
return|;
block|}
comment|/* 		 * No overflow occured : someone is draining the queue 		 * and the current counter needs to be 		 * updated from the current number of entries in the queue 		 */
comment|/* calculate number of words in q */
name|qPtrs
operator|=
name|aqm_reg_read
argument_list|(
name|sc
argument_list|,
name|qi
operator|->
name|qConfigRegAddr
argument_list|)
expr_stmt|;
name|DPRINTFn
argument_list|(
literal|2
argument_list|,
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s(%u, 0x%x) Q full, no overflow status, qConfig 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|qId
argument_list|,
name|entry
argument_list|,
name|qPtrs
argument_list|)
expr_stmt|;
name|qPtrs
operator|=
operator|(
name|qPtrs
operator|-
operator|(
name|qPtrs
operator|>>
literal|7
operator|)
operator|)
operator|&
literal|0x7f
expr_stmt|;
if|if
condition|(
name|qPtrs
operator|==
literal|0
condition|)
block|{
comment|/* 		     * The queue may be full at the time of the  		     * snapshot. Next access will check  		     * the overflow status again. 		     */
name|qi
operator|->
name|qWriteCount
operator|=
name|qSize
expr_stmt|;
block|}
else|else
block|{
comment|/* convert the number of words to a number of entries */
name|qi
operator|->
name|qWriteCount
operator|=
name|qPtrs
operator|&
operator|(
name|qSize
operator|-
literal|1
operator|)
expr_stmt|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|ixpqmgr_qread
parameter_list|(
name|int
name|qId
parameter_list|,
name|uint32_t
modifier|*
name|entry
parameter_list|)
block|{
name|struct
name|ixpqmgr_softc
modifier|*
name|sc
init|=
name|ixpqmgr_sc
decl_stmt|;
name|struct
name|qmgrInfo
modifier|*
name|qi
init|=
operator|&
name|sc
operator|->
name|qinfo
index|[
name|qId
index|]
decl_stmt|;
name|bus_size_t
name|off
init|=
name|qi
operator|->
name|qAccRegAddr
decl_stmt|;
operator|*
name|entry
operator|=
name|aqm_reg_read
argument_list|(
name|sc
argument_list|,
name|off
argument_list|)
expr_stmt|;
comment|/* 	 * Reset the current read count : next access to the read function  	 * will force a underflow status check. 	 */
name|qi
operator|->
name|qReadCount
operator|=
literal|0
expr_stmt|;
comment|/* Check if underflow occurred on the read */
if|if
condition|(
operator|*
name|entry
operator|==
literal|0
operator|&&
name|qId
operator|<
name|IX_QMGR_MIN_QUEUPP_QID
condition|)
block|{
comment|/* get the queue status */
name|uint32_t
name|status
init|=
name|aqm_reg_read
argument_list|(
name|sc
argument_list|,
name|qi
operator|->
name|qUOStatRegAddr
argument_list|)
decl_stmt|;
if|if
condition|(
name|status
operator|&
name|qi
operator|->
name|qUflowStatBitMask
condition|)
block|{
comment|/* clear underflow status */
name|aqm_reg_write
argument_list|(
name|sc
argument_list|,
name|qi
operator|->
name|qUOStatRegAddr
argument_list|,
name|status
operator|&
operator|~
name|qi
operator|->
name|qUflowStatBitMask
argument_list|)
expr_stmt|;
return|return
name|ENOSPC
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|ixpqmgr_qreadm
parameter_list|(
name|int
name|qId
parameter_list|,
name|uint32_t
name|n
parameter_list|,
name|uint32_t
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|ixpqmgr_softc
modifier|*
name|sc
init|=
name|ixpqmgr_sc
decl_stmt|;
name|struct
name|qmgrInfo
modifier|*
name|qi
init|=
operator|&
name|sc
operator|->
name|qinfo
index|[
name|qId
index|]
decl_stmt|;
name|uint32_t
name|entry
decl_stmt|;
name|bus_size_t
name|off
init|=
name|qi
operator|->
name|qAccRegAddr
decl_stmt|;
name|entry
operator|=
name|aqm_reg_read
argument_list|(
name|sc
argument_list|,
name|off
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|n
condition|)
block|{
if|if
condition|(
name|entry
operator|==
literal|0
condition|)
block|{
comment|/* if we read a NULL entry, stop. We have underflowed */
break|break;
block|}
operator|*
name|p
operator|++
operator|=
name|entry
expr_stmt|;
comment|/* store */
name|entry
operator|=
name|aqm_reg_read
argument_list|(
name|sc
argument_list|,
name|off
argument_list|)
expr_stmt|;
block|}
operator|*
name|p
operator|=
name|entry
expr_stmt|;
comment|/* 	 * Reset the current read count : next access to the read function  	 * will force a underflow status check. 	 */
name|qi
operator|->
name|qReadCount
operator|=
literal|0
expr_stmt|;
comment|/* Check if underflow occurred on the read */
if|if
condition|(
name|entry
operator|==
literal|0
operator|&&
name|qId
operator|<
name|IX_QMGR_MIN_QUEUPP_QID
condition|)
block|{
comment|/* get the queue status */
name|uint32_t
name|status
init|=
name|aqm_reg_read
argument_list|(
name|sc
argument_list|,
name|qi
operator|->
name|qUOStatRegAddr
argument_list|)
decl_stmt|;
if|if
condition|(
name|status
operator|&
name|qi
operator|->
name|qUflowStatBitMask
condition|)
block|{
comment|/* clear underflow status */
name|aqm_reg_write
argument_list|(
name|sc
argument_list|,
name|qi
operator|->
name|qUOStatRegAddr
argument_list|,
name|status
operator|&
operator|~
name|qi
operator|->
name|qUflowStatBitMask
argument_list|)
expr_stmt|;
return|return
name|ENOSPC
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|uint32_t
name|ixpqmgr_getqstatus
parameter_list|(
name|int
name|qId
parameter_list|)
block|{
define|#
directive|define
name|QLOWSTATMASK
define|\
value|((1<< (32 / IX_QMGR_QUELOWSTAT_NUM_QUE_PER_WORD)) - 1)
name|struct
name|ixpqmgr_softc
modifier|*
name|sc
init|=
name|ixpqmgr_sc
decl_stmt|;
specifier|const
name|struct
name|qmgrInfo
modifier|*
name|qi
init|=
operator|&
name|sc
operator|->
name|qinfo
index|[
name|qId
index|]
decl_stmt|;
name|uint32_t
name|status
decl_stmt|;
if|if
condition|(
name|qId
operator|<
name|IX_QMGR_MIN_QUEUPP_QID
condition|)
block|{
comment|/* read the status of a queue in the range 0-31 */
name|status
operator|=
name|aqm_reg_read
argument_list|(
name|sc
argument_list|,
name|qi
operator|->
name|qStatRegAddr
argument_list|)
expr_stmt|;
comment|/* mask out the status bits relevant only to this queue */
name|status
operator|=
operator|(
name|status
operator|>>
name|qi
operator|->
name|qStatBitsOffset
operator|)
operator|&
name|QLOWSTATMASK
expr_stmt|;
block|}
else|else
block|{
comment|/* read status of a queue in the range 32-63 */
name|status
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|aqm_reg_read
argument_list|(
name|sc
argument_list|,
name|IX_QMGR_QUEUPPSTAT0_OFFSET
argument_list|)
operator|&
name|qi
operator|->
name|qStat0BitMask
condition|)
name|status
operator||=
name|IX_QMGR_Q_STATUS_NE_BIT_MASK
expr_stmt|;
comment|/* nearly empty */
if|if
condition|(
name|aqm_reg_read
argument_list|(
name|sc
argument_list|,
name|IX_QMGR_QUEUPPSTAT1_OFFSET
argument_list|)
operator|&
name|qi
operator|->
name|qStat1BitMask
condition|)
name|status
operator||=
name|IX_QMGR_Q_STATUS_F_BIT_MASK
expr_stmt|;
comment|/* full */
block|}
return|return
name|status
return|;
undef|#
directive|undef
name|QLOWSTATMASK
block|}
end_function

begin_function
name|uint32_t
name|ixpqmgr_getqconfig
parameter_list|(
name|int
name|qId
parameter_list|)
block|{
name|struct
name|ixpqmgr_softc
modifier|*
name|sc
init|=
name|ixpqmgr_sc
decl_stmt|;
return|return
name|aqm_reg_read
argument_list|(
name|sc
argument_list|,
name|IX_QMGR_Q_CONFIG_ADDR_GET
argument_list|(
name|qId
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|ixpqmgr_dump
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|ixpqmgr_softc
modifier|*
name|sc
init|=
name|ixpqmgr_sc
decl_stmt|;
name|int
name|i
decl_stmt|,
name|a
decl_stmt|;
comment|/* status registers */
name|printf
argument_list|(
literal|"0x%04x: %08x %08x %08x %08x\n"
argument_list|,
literal|0x400
argument_list|,
name|aqm_reg_read
argument_list|(
name|sc
argument_list|,
literal|0x400
argument_list|)
argument_list|,
name|aqm_reg_read
argument_list|(
name|sc
argument_list|,
literal|0x400
operator|+
literal|4
argument_list|)
argument_list|,
name|aqm_reg_read
argument_list|(
name|sc
argument_list|,
literal|0x400
operator|+
literal|8
argument_list|)
argument_list|,
name|aqm_reg_read
argument_list|(
name|sc
argument_list|,
literal|0x400
operator|+
literal|12
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"0x%04x: %08x %08x %08x %08x\n"
argument_list|,
literal|0x410
argument_list|,
name|aqm_reg_read
argument_list|(
name|sc
argument_list|,
literal|0x410
argument_list|)
argument_list|,
name|aqm_reg_read
argument_list|(
name|sc
argument_list|,
literal|0x410
operator|+
literal|4
argument_list|)
argument_list|,
name|aqm_reg_read
argument_list|(
name|sc
argument_list|,
literal|0x410
operator|+
literal|8
argument_list|)
argument_list|,
name|aqm_reg_read
argument_list|(
name|sc
argument_list|,
literal|0x410
operator|+
literal|12
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"0x%04x: %08x %08x %08x %08x\n"
argument_list|,
literal|0x420
argument_list|,
name|aqm_reg_read
argument_list|(
name|sc
argument_list|,
literal|0x420
argument_list|)
argument_list|,
name|aqm_reg_read
argument_list|(
name|sc
argument_list|,
literal|0x420
operator|+
literal|4
argument_list|)
argument_list|,
name|aqm_reg_read
argument_list|(
name|sc
argument_list|,
literal|0x420
operator|+
literal|8
argument_list|)
argument_list|,
name|aqm_reg_read
argument_list|(
name|sc
argument_list|,
literal|0x420
operator|+
literal|12
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"0x%04x: %08x %08x %08x %08x\n"
argument_list|,
literal|0x430
argument_list|,
name|aqm_reg_read
argument_list|(
name|sc
argument_list|,
literal|0x430
argument_list|)
argument_list|,
name|aqm_reg_read
argument_list|(
name|sc
argument_list|,
literal|0x430
operator|+
literal|4
argument_list|)
argument_list|,
name|aqm_reg_read
argument_list|(
name|sc
argument_list|,
literal|0x430
operator|+
literal|8
argument_list|)
argument_list|,
name|aqm_reg_read
argument_list|(
name|sc
argument_list|,
literal|0x430
operator|+
literal|12
argument_list|)
argument_list|)
expr_stmt|;
comment|/* q configuration registers */
for|for
control|(
name|a
operator|=
literal|0x2000
init|;
name|a
operator|<
literal|0x20ff
condition|;
name|a
operator|+=
literal|32
control|)
name|printf
argument_list|(
literal|"0x%04x: %08x %08x %08x %08x %08x %08x %08x %08x\n"
argument_list|,
name|a
argument_list|,
name|aqm_reg_read
argument_list|(
name|sc
argument_list|,
name|a
argument_list|)
argument_list|,
name|aqm_reg_read
argument_list|(
name|sc
argument_list|,
name|a
operator|+
literal|4
argument_list|)
argument_list|,
name|aqm_reg_read
argument_list|(
name|sc
argument_list|,
name|a
operator|+
literal|8
argument_list|)
argument_list|,
name|aqm_reg_read
argument_list|(
name|sc
argument_list|,
name|a
operator|+
literal|12
argument_list|)
argument_list|,
name|aqm_reg_read
argument_list|(
name|sc
argument_list|,
name|a
operator|+
literal|16
argument_list|)
argument_list|,
name|aqm_reg_read
argument_list|(
name|sc
argument_list|,
name|a
operator|+
literal|20
argument_list|)
argument_list|,
name|aqm_reg_read
argument_list|(
name|sc
argument_list|,
name|a
operator|+
literal|24
argument_list|)
argument_list|,
name|aqm_reg_read
argument_list|(
name|sc
argument_list|,
name|a
operator|+
literal|28
argument_list|)
argument_list|)
expr_stmt|;
comment|/* allocated SRAM */
for|for
control|(
name|i
operator|=
literal|0x100
init|;
name|i
operator|<
name|sc
operator|->
name|aqmFreeSramAddress
condition|;
name|i
operator|+=
literal|32
control|)
block|{
name|a
operator|=
literal|0x2000
operator|+
name|i
expr_stmt|;
name|printf
argument_list|(
literal|"0x%04x: %08x %08x %08x %08x %08x %08x %08x %08x\n"
argument_list|,
name|a
argument_list|,
name|aqm_reg_read
argument_list|(
name|sc
argument_list|,
name|a
argument_list|)
argument_list|,
name|aqm_reg_read
argument_list|(
name|sc
argument_list|,
name|a
operator|+
literal|4
argument_list|)
argument_list|,
name|aqm_reg_read
argument_list|(
name|sc
argument_list|,
name|a
operator|+
literal|8
argument_list|)
argument_list|,
name|aqm_reg_read
argument_list|(
name|sc
argument_list|,
name|a
operator|+
literal|12
argument_list|)
argument_list|,
name|aqm_reg_read
argument_list|(
name|sc
argument_list|,
name|a
operator|+
literal|16
argument_list|)
argument_list|,
name|aqm_reg_read
argument_list|(
name|sc
argument_list|,
name|a
operator|+
literal|20
argument_list|)
argument_list|,
name|aqm_reg_read
argument_list|(
name|sc
argument_list|,
name|a
operator|+
literal|24
argument_list|)
argument_list|,
name|aqm_reg_read
argument_list|(
name|sc
argument_list|,
name|a
operator|+
literal|28
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"Q[%2d] config 0x%08x status 0x%02x  "
literal|"Q[%2d] config 0x%08x status 0x%02x\n"
argument_list|,
name|i
argument_list|,
name|ixpqmgr_getqconfig
argument_list|(
name|i
argument_list|)
argument_list|,
name|ixpqmgr_getqstatus
argument_list|(
name|i
argument_list|)
argument_list|,
name|i
operator|+
literal|16
argument_list|,
name|ixpqmgr_getqconfig
argument_list|(
name|i
operator|+
literal|16
argument_list|)
argument_list|,
name|ixpqmgr_getqstatus
argument_list|(
name|i
operator|+
literal|16
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ixpqmgr_notify_enable
parameter_list|(
name|int
name|qId
parameter_list|,
name|int
name|srcSel
parameter_list|)
block|{
name|struct
name|ixpqmgr_softc
modifier|*
name|sc
init|=
name|ixpqmgr_sc
decl_stmt|;
if|#
directive|if
literal|0
comment|/* Calculate the checkMask and checkValue for this q */
block|aqm_calc_statuscheck(sc, qId, srcSel);
endif|#
directive|endif
comment|/* Set the interrupt source if this queue is in the range 0-31 */
if|if
condition|(
name|qId
operator|<
name|IX_QMGR_MIN_QUEUPP_QID
condition|)
name|aqm_srcsel_write
argument_list|(
name|sc
argument_list|,
name|qId
argument_list|,
name|srcSel
argument_list|)
expr_stmt|;
comment|/* Enable the interrupt */
name|aqm_int_enable
argument_list|(
name|sc
argument_list|,
name|qId
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ixpqmgr_notify_disable
parameter_list|(
name|int
name|qId
parameter_list|)
block|{
name|struct
name|ixpqmgr_softc
modifier|*
name|sc
init|=
name|ixpqmgr_sc
decl_stmt|;
name|aqm_int_disable
argument_list|(
name|sc
argument_list|,
name|qId
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Rebuild the priority table used by the dispatcher.  */
end_comment

begin_function
specifier|static
name|void
name|ixpqmgr_rebuild
parameter_list|(
name|struct
name|ixpqmgr_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|q
decl_stmt|,
name|pri
decl_stmt|;
name|int
name|lowQuePriorityTableIndex
decl_stmt|,
name|uppQuePriorityTableIndex
decl_stmt|;
name|struct
name|qmgrInfo
modifier|*
name|qi
decl_stmt|;
name|sc
operator|->
name|lowPriorityTableFirstHalfMask
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|uppPriorityTableFirstHalfMask
operator|=
literal|0
expr_stmt|;
name|lowQuePriorityTableIndex
operator|=
literal|0
expr_stmt|;
name|uppQuePriorityTableIndex
operator|=
literal|32
expr_stmt|;
for|for
control|(
name|pri
operator|=
literal|0
init|;
name|pri
operator|<
name|IX_QMGR_NUM_PRIORITY_LEVELS
condition|;
name|pri
operator|++
control|)
block|{
comment|/* low priority q's */
for|for
control|(
name|q
operator|=
literal|0
init|;
name|q
operator|<
name|IX_QMGR_MIN_QUEUPP_QID
condition|;
name|q
operator|++
control|)
block|{
name|qi
operator|=
operator|&
name|sc
operator|->
name|qinfo
index|[
name|q
index|]
expr_stmt|;
if|if
condition|(
name|qi
operator|->
name|priority
operator|==
name|pri
condition|)
block|{
comment|/* 		     * Build the priority table bitmask which match the 		     * queues of the first half of the priority table. 		     */
if|if
condition|(
name|lowQuePriorityTableIndex
operator|<
literal|16
condition|)
block|{
name|sc
operator|->
name|lowPriorityTableFirstHalfMask
operator||=
name|qi
operator|->
name|intRegCheckMask
expr_stmt|;
block|}
name|sc
operator|->
name|priorityTable
index|[
name|lowQuePriorityTableIndex
operator|++
index|]
operator|=
name|q
expr_stmt|;
block|}
block|}
comment|/* high priority q's */
for|for
control|(
init|;
name|q
operator|<
name|IX_QMGR_MAX_NUM_QUEUES
condition|;
name|q
operator|++
control|)
block|{
name|qi
operator|=
operator|&
name|sc
operator|->
name|qinfo
index|[
name|q
index|]
expr_stmt|;
if|if
condition|(
name|qi
operator|->
name|priority
operator|==
name|pri
condition|)
block|{
comment|/* 		     * Build the priority table bitmask which match the 		     * queues of the first half of the priority table . 		     */
if|if
condition|(
name|uppQuePriorityTableIndex
operator|<
literal|48
condition|)
block|{
name|sc
operator|->
name|uppPriorityTableFirstHalfMask
operator||=
name|qi
operator|->
name|intRegCheckMask
expr_stmt|;
block|}
name|sc
operator|->
name|priorityTable
index|[
name|uppQuePriorityTableIndex
operator|++
index|]
operator|=
name|q
expr_stmt|;
block|}
block|}
block|}
name|sc
operator|->
name|rebuildTable
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Count the number of leading zero bits in a word,  * and return the same value than the CLZ instruction.  * Note this is similar to the standard ffs function but  * it counts zero's from the MSB instead of the LSB.  *  * word (in)    return value (out)  * 0x80000000   0  * 0x40000000   1  * ,,,          ,,,  * 0x00000002   30  * 0x00000001   31  * 0x00000000   32  *  * The C version of this function is used as a replacement   * for system not providing the equivalent of the CLZ   * assembly language instruction.  *  * Note that this version is big-endian  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|_lzcount
parameter_list|(
name|uint32_t
name|word
parameter_list|)
block|{
name|unsigned
name|int
name|lzcount
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|word
operator|==
literal|0
condition|)
return|return
literal|32
return|;
while|while
condition|(
operator|(
name|word
operator|&
literal|0x80000000
operator|)
operator|==
literal|0
condition|)
block|{
name|word
operator|<<=
literal|1
expr_stmt|;
name|lzcount
operator|++
expr_stmt|;
block|}
return|return
name|lzcount
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixpqmgr_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ixpqmgr_softc
modifier|*
name|sc
init|=
name|ixpqmgr_sc
decl_stmt|;
name|uint32_t
name|intRegVal
decl_stmt|;
comment|/* Interrupt reg val */
name|struct
name|qmgrInfo
modifier|*
name|qi
decl_stmt|;
name|int
name|priorityTableIndex
decl_stmt|;
comment|/* Priority table index */
name|int
name|qIndex
decl_stmt|;
comment|/* Current queue being processed */
comment|/* Read the interrupt register */
name|intRegVal
operator|=
name|aqm_reg_read
argument_list|(
name|sc
argument_list|,
name|IX_QMGR_QINTREG0_OFFSET
argument_list|)
expr_stmt|;
comment|/* Write back to clear interrupt */
name|aqm_reg_write
argument_list|(
name|sc
argument_list|,
name|IX_QMGR_QINTREG0_OFFSET
argument_list|,
name|intRegVal
argument_list|)
expr_stmt|;
name|DPRINTFn
argument_list|(
literal|5
argument_list|,
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: ISR0 0x%x ISR1 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|intRegVal
argument_list|,
name|aqm_reg_read
argument_list|(
name|sc
argument_list|,
name|IX_QMGR_QINTREG1_OFFSET
argument_list|)
argument_list|)
expr_stmt|;
comment|/* No queue has interrupt register set */
if|if
condition|(
name|intRegVal
operator|!=
literal|0
condition|)
block|{
comment|/* get the first queue Id from the interrupt register value */
name|qIndex
operator|=
operator|(
literal|32
operator|-
literal|1
operator|)
operator|-
name|_lzcount
argument_list|(
name|intRegVal
argument_list|)
expr_stmt|;
name|DPRINTFn
argument_list|(
literal|2
argument_list|,
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: ISR0 0x%x qIndex %u\n"
argument_list|,
name|__func__
argument_list|,
name|intRegVal
argument_list|,
name|qIndex
argument_list|)
expr_stmt|;
comment|/* 		 * Optimize for single callback case. 		 */
name|qi
operator|=
operator|&
name|sc
operator|->
name|qinfo
index|[
name|qIndex
index|]
expr_stmt|;
if|if
condition|(
name|intRegVal
operator|==
name|qi
operator|->
name|intRegCheckMask
condition|)
block|{
comment|/* 		     * Only 1 queue event triggered a notification. 		     * Call the callback function for this queue 		     */
name|qi
operator|->
name|cb
argument_list|(
name|qIndex
argument_list|,
name|qi
operator|->
name|cbarg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		      * The event is triggered by more than 1 queue, 		      * the queue search will start from the beginning 		      * or the middle of the priority table. 		      * 		      * The search will end when all the bits of the interrupt 		      * register are cleared. There is no need to maintain 		      * a seperate value and test it at each iteration. 		      */
if|if
condition|(
name|intRegVal
operator|&
name|sc
operator|->
name|lowPriorityTableFirstHalfMask
condition|)
block|{
name|priorityTableIndex
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|priorityTableIndex
operator|=
literal|16
expr_stmt|;
block|}
comment|/* 		      * Iterate over the priority table until all the bits 		      * of the interrupt register are cleared. 		      */
do|do
block|{
name|qIndex
operator|=
name|sc
operator|->
name|priorityTable
index|[
name|priorityTableIndex
operator|++
index|]
expr_stmt|;
name|qi
operator|=
operator|&
name|sc
operator|->
name|qinfo
index|[
name|qIndex
index|]
expr_stmt|;
comment|/* If this queue caused this interrupt to be raised */
if|if
condition|(
name|intRegVal
operator|&
name|qi
operator|->
name|intRegCheckMask
condition|)
block|{
comment|/* Call the callback function for this queue */
name|qi
operator|->
name|cb
argument_list|(
name|qIndex
argument_list|,
name|qi
operator|->
name|cbarg
argument_list|)
expr_stmt|;
comment|/* Clear the interrupt register bit */
name|intRegVal
operator|&=
operator|~
name|qi
operator|->
name|intRegCheckMask
expr_stmt|;
block|}
block|}
do|while
condition|(
name|intRegVal
condition|)
do|;
block|}
block|}
comment|/* Rebuild the priority table if needed */
if|if
condition|(
name|sc
operator|->
name|rebuildTable
condition|)
name|ixpqmgr_rebuild
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*  * Generate the parameters used to check if a Q's status matches  * the specified source select.  We calculate which status word  * to check (statusWordOffset), the value to check the status  * against (statusCheckValue) and the mask (statusMask) to mask  * out all but the bits to check in the status word.  */
end_comment

begin_comment
unit|static void aqm_calc_statuscheck(int qId, IxQMgrSourceId srcSel) { 	struct qmgrInfo *qi =&qinfo[qId]; 	uint32_t shiftVal;         	if (qId< IX_QMGR_MIN_QUEUPP_QID) { 	    switch (srcSel) { 	    case IX_QMGR_Q_SOURCE_ID_E: 		qi->statusCheckValue = IX_QMGR_Q_STATUS_E_BIT_MASK; 		qi->statusMask = IX_QMGR_Q_STATUS_E_BIT_MASK; 		break; 	    case IX_QMGR_Q_SOURCE_ID_NE: 		qi->statusCheckValue = IX_QMGR_Q_STATUS_NE_BIT_MASK; 		qi->statusMask = IX_QMGR_Q_STATUS_NE_BIT_MASK; 		break; 	    case IX_QMGR_Q_SOURCE_ID_NF: 		qi->statusCheckValue = IX_QMGR_Q_STATUS_NF_BIT_MASK; 		qi->statusMask = IX_QMGR_Q_STATUS_NF_BIT_MASK; 		break; 	    case IX_QMGR_Q_SOURCE_ID_F: 		qi->statusCheckValue = IX_QMGR_Q_STATUS_F_BIT_MASK; 		qi->statusMask = IX_QMGR_Q_STATUS_F_BIT_MASK; 		break; 	    case IX_QMGR_Q_SOURCE_ID_NOT_E: 		qi->statusCheckValue = 0; 		qi->statusMask = IX_QMGR_Q_STATUS_E_BIT_MASK; 		break; 	    case IX_QMGR_Q_SOURCE_ID_NOT_NE: 		qi->statusCheckValue = 0; 		qi->statusMask = IX_QMGR_Q_STATUS_NE_BIT_MASK; 		break; 	    case IX_QMGR_Q_SOURCE_ID_NOT_NF: 		qi->statusCheckValue = 0; 		qi->statusMask = IX_QMGR_Q_STATUS_NF_BIT_MASK; 		break; 	    case IX_QMGR_Q_SOURCE_ID_NOT_F: 		qi->statusCheckValue = 0; 		qi->statusMask = IX_QMGR_Q_STATUS_F_BIT_MASK; 		break; 	    default:
comment|/* Should never hit */
end_comment

begin_comment
unit|IX_OSAL_ASSERT(0); 		break; 	    }
comment|/* One nibble of status per queue so need to shift the 	     * check value and mask out to the correct position. 	     */
end_comment

begin_comment
unit|shiftVal = (qId % IX_QMGR_QUELOWSTAT_NUM_QUE_PER_WORD) *  		IX_QMGR_QUELOWSTAT_BITS_PER_Q;
comment|/* Calculate the which status word to check from the qId, 	     * 8 Qs status per word 	     */
end_comment

begin_comment
unit|qi->statusWordOffset = qId / IX_QMGR_QUELOWSTAT_NUM_QUE_PER_WORD;  	    qi->statusCheckValue<<= shiftVal; 	    qi->statusMask<<= shiftVal; 	} else {
comment|/* One status word */
end_comment

begin_comment
unit|qi->statusWordOffset = 0;
comment|/* Single bits per queue and int source bit hardwired  NE, 	     * Qs start at 32. 	     */
end_comment

begin_endif
unit|qi->statusMask = 1<< (qId - IX_QMGR_MIN_QUEUPP_QID); 	    qi->statusCheckValue = qi->statusMask; 	} }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|aqm_int_enable
parameter_list|(
name|struct
name|ixpqmgr_softc
modifier|*
name|sc
parameter_list|,
name|int
name|qId
parameter_list|)
block|{
name|bus_size_t
name|reg
decl_stmt|;
name|uint32_t
name|v
decl_stmt|;
if|if
condition|(
name|qId
operator|<
name|IX_QMGR_MIN_QUEUPP_QID
condition|)
name|reg
operator|=
name|IX_QMGR_QUEIEREG0_OFFSET
expr_stmt|;
else|else
name|reg
operator|=
name|IX_QMGR_QUEIEREG1_OFFSET
expr_stmt|;
name|v
operator|=
name|aqm_reg_read
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|aqm_reg_write
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|,
name|v
operator||
operator|(
literal|1
operator|<<
operator|(
name|qId
operator|%
name|IX_QMGR_MIN_QUEUPP_QID
operator|)
operator|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s(%u) 0x%lx: 0x%x => 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|qId
argument_list|,
name|reg
argument_list|,
name|v
argument_list|,
name|aqm_reg_read
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|aqm_int_disable
parameter_list|(
name|struct
name|ixpqmgr_softc
modifier|*
name|sc
parameter_list|,
name|int
name|qId
parameter_list|)
block|{
name|bus_size_t
name|reg
decl_stmt|;
name|uint32_t
name|v
decl_stmt|;
if|if
condition|(
name|qId
operator|<
name|IX_QMGR_MIN_QUEUPP_QID
condition|)
name|reg
operator|=
name|IX_QMGR_QUEIEREG0_OFFSET
expr_stmt|;
else|else
name|reg
operator|=
name|IX_QMGR_QUEIEREG1_OFFSET
expr_stmt|;
name|v
operator|=
name|aqm_reg_read
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|aqm_reg_write
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|,
name|v
operator|&
operator|~
operator|(
literal|1
operator|<<
operator|(
name|qId
operator|%
name|IX_QMGR_MIN_QUEUPP_QID
operator|)
operator|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s(%u) 0x%lx: 0x%x => 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|qId
argument_list|,
name|reg
argument_list|,
name|v
argument_list|,
name|aqm_reg_read
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|log2
parameter_list|(
name|unsigned
name|n
parameter_list|)
block|{
name|unsigned
name|count
decl_stmt|;
comment|/* 	 * N.B. this function will return 0 if supplied 0. 	 */
for|for
control|(
name|count
operator|=
literal|0
init|;
name|n
operator|/
literal|2
condition|;
name|count
operator|++
control|)
name|n
operator|/=
literal|2
expr_stmt|;
return|return
name|count
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|unsigned
name|toAqmEntrySize
parameter_list|(
name|int
name|entrySize
parameter_list|)
block|{
comment|/* entrySize  1("00"),2("01"),4("10") */
return|return
name|log2
argument_list|(
name|entrySize
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|unsigned
name|toAqmBufferSize
parameter_list|(
name|unsigned
name|bufferSizeInWords
parameter_list|)
block|{
comment|/* bufferSize 16("00"),32("01),64("10"),128("11") */
return|return
name|log2
argument_list|(
name|bufferSizeInWords
operator|/
name|IX_QMGR_MIN_BUFFER_SIZE
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|unsigned
name|toAqmWatermark
parameter_list|(
name|int
name|watermark
parameter_list|)
block|{
comment|/* 	 * Watermarks 0("000"),1("001"),2("010"),4("011"), 	 * 8("100"),16("101"),32("110"),64("111") 	 */
return|return
name|log2
argument_list|(
literal|2
operator|*
name|watermark
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|aqm_qcfg
parameter_list|(
name|struct
name|ixpqmgr_softc
modifier|*
name|sc
parameter_list|,
name|int
name|qId
parameter_list|,
name|u_int
name|ne
parameter_list|,
name|u_int
name|nf
parameter_list|)
block|{
specifier|const
name|struct
name|qmgrInfo
modifier|*
name|qi
init|=
operator|&
name|sc
operator|->
name|qinfo
index|[
name|qId
index|]
decl_stmt|;
name|uint32_t
name|qCfg
decl_stmt|;
name|uint32_t
name|baseAddress
decl_stmt|;
comment|/* Build config register */
name|qCfg
operator|=
operator|(
operator|(
name|toAqmEntrySize
argument_list|(
literal|1
argument_list|)
operator|&
name|IX_QMGR_ENTRY_SIZE_MASK
operator|)
operator|<<
name|IX_QMGR_Q_CONFIG_ESIZE_OFFSET
operator|)
operator||
operator|(
operator|(
name|toAqmBufferSize
argument_list|(
name|qi
operator|->
name|qSizeInWords
argument_list|)
operator|&
name|IX_QMGR_SIZE_MASK
operator|)
operator|<<
name|IX_QMGR_Q_CONFIG_BSIZE_OFFSET
operator|)
expr_stmt|;
comment|/* baseAddress, calculated relative to start address */
name|baseAddress
operator|=
name|sc
operator|->
name|aqmFreeSramAddress
expr_stmt|;
comment|/* base address must be word-aligned */
name|KASSERT
argument_list|(
operator|(
name|baseAddress
operator|%
name|IX_QMGR_BASE_ADDR_16_WORD_ALIGN
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"address not word-aligned"
operator|)
argument_list|)
expr_stmt|;
comment|/* Now convert to a 16 word pointer as required by QUECONFIG register */
name|baseAddress
operator|>>=
name|IX_QMGR_BASE_ADDR_16_WORD_SHIFT
expr_stmt|;
name|qCfg
operator||=
name|baseAddress
operator|<<
name|IX_QMGR_Q_CONFIG_BADDR_OFFSET
expr_stmt|;
comment|/* set watermarks */
name|qCfg
operator||=
operator|(
name|toAqmWatermark
argument_list|(
name|ne
argument_list|)
operator|<<
name|IX_QMGR_Q_CONFIG_NE_OFFSET
operator|)
operator||
operator|(
name|toAqmWatermark
argument_list|(
name|nf
argument_list|)
operator|<<
name|IX_QMGR_Q_CONFIG_NF_OFFSET
operator|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s(%u, %u, %u) 0x%x => 0x%x @ 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|qId
argument_list|,
name|ne
argument_list|,
name|nf
argument_list|,
name|aqm_reg_read
argument_list|(
name|sc
argument_list|,
name|IX_QMGR_Q_CONFIG_ADDR_GET
argument_list|(
name|qId
argument_list|)
argument_list|)
argument_list|,
name|qCfg
argument_list|,
name|IX_QMGR_Q_CONFIG_ADDR_GET
argument_list|(
name|qId
argument_list|)
argument_list|)
expr_stmt|;
name|aqm_reg_write
argument_list|(
name|sc
argument_list|,
name|IX_QMGR_Q_CONFIG_ADDR_GET
argument_list|(
name|qId
argument_list|)
argument_list|,
name|qCfg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|aqm_srcsel_write
parameter_list|(
name|struct
name|ixpqmgr_softc
modifier|*
name|sc
parameter_list|,
name|int
name|qId
parameter_list|,
name|int
name|sourceId
parameter_list|)
block|{
name|bus_size_t
name|off
decl_stmt|;
name|uint32_t
name|v
decl_stmt|;
comment|/* 	 * Calculate the register offset; multiple queues split across registers 	 */
name|off
operator|=
name|IX_QMGR_INT0SRCSELREG0_OFFSET
operator|+
operator|(
operator|(
name|qId
operator|/
name|IX_QMGR_INTSRC_NUM_QUE_PER_WORD
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
expr_stmt|;
name|v
operator|=
name|aqm_reg_read
argument_list|(
name|sc
argument_list|,
name|off
argument_list|)
expr_stmt|;
if|if
condition|(
name|off
operator|==
name|IX_QMGR_INT0SRCSELREG0_OFFSET
operator|&&
name|qId
operator|==
literal|0
condition|)
block|{
comment|/* Queue 0 at INT0SRCSELREG should not corrupt the value bit-3  */
name|v
operator||=
literal|0x7
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|uint32_t
name|bpq
init|=
literal|32
operator|/
name|IX_QMGR_INTSRC_NUM_QUE_PER_WORD
decl_stmt|;
name|uint32_t
name|mask
decl_stmt|;
name|int
name|qshift
decl_stmt|;
name|qshift
operator|=
operator|(
name|qId
operator|&
operator|(
name|IX_QMGR_INTSRC_NUM_QUE_PER_WORD
operator|-
literal|1
operator|)
operator|)
operator|*
name|bpq
expr_stmt|;
name|mask
operator|=
operator|(
operator|(
literal|1
operator|<<
name|bpq
operator|)
operator|-
literal|1
operator|)
operator|<<
name|qshift
expr_stmt|;
comment|/* q's status mask */
comment|/* merge sourceId */
name|v
operator|=
operator|(
name|v
operator|&
operator|~
name|mask
operator|)
operator||
operator|(
operator|(
name|sourceId
operator|<<
name|qshift
operator|)
operator|&
name|mask
operator|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s(%u, %u) 0x%x => 0x%x @ 0x%lx\n"
argument_list|,
name|__func__
argument_list|,
name|qId
argument_list|,
name|sourceId
argument_list|,
name|aqm_reg_read
argument_list|(
name|sc
argument_list|,
name|off
argument_list|)
argument_list|,
name|v
argument_list|,
name|off
argument_list|)
expr_stmt|;
name|aqm_reg_write
argument_list|(
name|sc
argument_list|,
name|off
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reset AQM registers to default values.  */
end_comment

begin_function
specifier|static
name|void
name|aqm_reset
parameter_list|(
name|struct
name|ixpqmgr_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Reset queues 0..31 status registers 0..3 */
name|aqm_reg_write
argument_list|(
name|sc
argument_list|,
name|IX_QMGR_QUELOWSTAT0_OFFSET
argument_list|,
name|IX_QMGR_QUELOWSTAT_RESET_VALUE
argument_list|)
expr_stmt|;
name|aqm_reg_write
argument_list|(
name|sc
argument_list|,
name|IX_QMGR_QUELOWSTAT1_OFFSET
argument_list|,
name|IX_QMGR_QUELOWSTAT_RESET_VALUE
argument_list|)
expr_stmt|;
name|aqm_reg_write
argument_list|(
name|sc
argument_list|,
name|IX_QMGR_QUELOWSTAT2_OFFSET
argument_list|,
name|IX_QMGR_QUELOWSTAT_RESET_VALUE
argument_list|)
expr_stmt|;
name|aqm_reg_write
argument_list|(
name|sc
argument_list|,
name|IX_QMGR_QUELOWSTAT3_OFFSET
argument_list|,
name|IX_QMGR_QUELOWSTAT_RESET_VALUE
argument_list|)
expr_stmt|;
comment|/* Reset underflow/overflow status registers 0..1 */
name|aqm_reg_write
argument_list|(
name|sc
argument_list|,
name|IX_QMGR_QUEUOSTAT0_OFFSET
argument_list|,
name|IX_QMGR_QUEUOSTAT_RESET_VALUE
argument_list|)
expr_stmt|;
name|aqm_reg_write
argument_list|(
name|sc
argument_list|,
name|IX_QMGR_QUEUOSTAT1_OFFSET
argument_list|,
name|IX_QMGR_QUEUOSTAT_RESET_VALUE
argument_list|)
expr_stmt|;
comment|/* Reset queues 32..63 nearly empty status registers */
name|aqm_reg_write
argument_list|(
name|sc
argument_list|,
name|IX_QMGR_QUEUPPSTAT0_OFFSET
argument_list|,
name|IX_QMGR_QUEUPPSTAT0_RESET_VALUE
argument_list|)
expr_stmt|;
comment|/* Reset queues 32..63 full status registers */
name|aqm_reg_write
argument_list|(
name|sc
argument_list|,
name|IX_QMGR_QUEUPPSTAT1_OFFSET
argument_list|,
name|IX_QMGR_QUEUPPSTAT1_RESET_VALUE
argument_list|)
expr_stmt|;
comment|/* Reset int0 status flag source select registers 0..3 */
name|aqm_reg_write
argument_list|(
name|sc
argument_list|,
name|IX_QMGR_INT0SRCSELREG0_OFFSET
argument_list|,
name|IX_QMGR_INT0SRCSELREG_RESET_VALUE
argument_list|)
expr_stmt|;
name|aqm_reg_write
argument_list|(
name|sc
argument_list|,
name|IX_QMGR_INT0SRCSELREG1_OFFSET
argument_list|,
name|IX_QMGR_INT0SRCSELREG_RESET_VALUE
argument_list|)
expr_stmt|;
name|aqm_reg_write
argument_list|(
name|sc
argument_list|,
name|IX_QMGR_INT0SRCSELREG2_OFFSET
argument_list|,
name|IX_QMGR_INT0SRCSELREG_RESET_VALUE
argument_list|)
expr_stmt|;
name|aqm_reg_write
argument_list|(
name|sc
argument_list|,
name|IX_QMGR_INT0SRCSELREG3_OFFSET
argument_list|,
name|IX_QMGR_INT0SRCSELREG_RESET_VALUE
argument_list|)
expr_stmt|;
comment|/* Reset queue interrupt enable register 0..1 */
name|aqm_reg_write
argument_list|(
name|sc
argument_list|,
name|IX_QMGR_QUEIEREG0_OFFSET
argument_list|,
name|IX_QMGR_QUEIEREG_RESET_VALUE
argument_list|)
expr_stmt|;
name|aqm_reg_write
argument_list|(
name|sc
argument_list|,
name|IX_QMGR_QUEIEREG1_OFFSET
argument_list|,
name|IX_QMGR_QUEIEREG_RESET_VALUE
argument_list|)
expr_stmt|;
comment|/* Reset queue interrupt register 0..1 */
name|aqm_reg_write
argument_list|(
name|sc
argument_list|,
name|IX_QMGR_QINTREG0_OFFSET
argument_list|,
name|IX_QMGR_QINTREG_RESET_VALUE
argument_list|)
expr_stmt|;
name|aqm_reg_write
argument_list|(
name|sc
argument_list|,
name|IX_QMGR_QINTREG1_OFFSET
argument_list|,
name|IX_QMGR_QINTREG_RESET_VALUE
argument_list|)
expr_stmt|;
comment|/* Reset queue configuration words 0..63 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IX_QMGR_MAX_NUM_QUEUES
condition|;
name|i
operator|++
control|)
name|aqm_reg_write
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|qinfo
index|[
name|i
index|]
operator|.
name|qConfigRegAddr
argument_list|,
name|IX_QMGR_QUECONFIG_RESET_VALUE
argument_list|)
expr_stmt|;
comment|/* XXX zero SRAM to simplify debugging */
for|for
control|(
name|i
operator|=
name|IX_QMGR_QUEBUFFER_SPACE_OFFSET
init|;
name|i
operator|<
name|IX_QMGR_AQM_SRAM_SIZE_IN_BYTES
condition|;
name|i
operator|+=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
control|)
name|aqm_reg_write
argument_list|(
name|sc
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|ixpqmgr_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|ixpqmgr_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|ixpqmgr_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|ixpqmgr_detach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|ixpqmgr_driver
init|=
block|{
literal|"ixpqmgr"
block|,
name|ixpqmgr_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ixpqmgr_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|ixpqmgr_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|ixpqmgr
argument_list|,
name|ixp
argument_list|,
name|ixpqmgr_driver
argument_list|,
name|ixpqmgr_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

