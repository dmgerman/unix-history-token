begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * SPDX-License-Identifier: BSD-3-Clause  *  * Copyright (c) 2006-2008 Sam Leffler, Errno Consulting  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    similar to the "NO WARRANTY" disclaimer below ("Disclaimer") and any  *    redistribution must be conditioned upon including a substantially  *    similar Disclaimer requirement for further binary redistribution.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTIBILITY  * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL  * THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY,  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER  * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_comment
comment|/*-  * Copyright (c) 2001-2005, Intel Corporation.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the Intel Corporation nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS IS''  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE. */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Intel XScale Network Processing Engine (NPE) support.  *  * Each NPE has an ixpnpeX device associated with it that is  * attached at boot.  Depending on the microcode loaded into  * an NPE there may be an Ethernet interface (npeX) or some  * other network interface (e.g. for ATM).  This file has support  * for loading microcode images and the associated NPE CPU  * manipulations (start, stop, reset).  *  * The code here basically replaces the npeDl and npeMh classes  * in the Intel Access Library (IAL).  *  * NB: Microcode images are loaded with firmware(9).  To  *     include microcode in a static kernel include the  *     ixpnpe_fw device.  Otherwise the firmware will be  *     automatically loaded from the filesystem.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker.h>
end_include

begin_include
include|#
directive|include
file|<sys/firmware.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<machine/intr.h>
end_include

begin_include
include|#
directive|include
file|<arm/xscale/ixp425/ixp425reg.h>
end_include

begin_include
include|#
directive|include
file|<arm/xscale/ixp425/ixp425var.h>
end_include

begin_include
include|#
directive|include
file|<arm/xscale/ixp425/ixp425_npereg.h>
end_include

begin_include
include|#
directive|include
file|<arm/xscale/ixp425/ixp425_npevar.h>
end_include

begin_struct
struct|struct
name|ixpnpe_softc
block|{
name|device_t
name|sc_dev
decl_stmt|;
name|bus_space_tag_t
name|sc_iot
decl_stmt|;
name|bus_space_handle_t
name|sc_ioh
decl_stmt|;
name|bus_size_t
name|sc_size
decl_stmt|;
comment|/* size of mapped register window */
name|struct
name|resource
modifier|*
name|sc_irq
decl_stmt|;
comment|/* IRQ resource */
name|void
modifier|*
name|sc_ih
decl_stmt|;
comment|/* interrupt handler */
name|struct
name|mtx
name|sc_mtx
decl_stmt|;
comment|/* mailbox lock */
name|uint32_t
name|sc_msg
index|[
literal|2
index|]
decl_stmt|;
comment|/* reply msg collected in ixpnpe_intr */
name|int
name|sc_msgwaiting
decl_stmt|;
comment|/* sc_msg holds valid data */
name|int
name|sc_npeid
decl_stmt|;
name|int
name|sc_nrefs
decl_stmt|;
comment|/* # of references */
name|int
name|validImage
decl_stmt|;
comment|/* valid ucode image loaded */
name|int
name|started
decl_stmt|;
comment|/* NPE is started */
name|uint8_t
name|functionalityId
decl_stmt|;
comment|/* ucode functionality ID */
name|int
name|insMemSize
decl_stmt|;
comment|/* size of instruction memory */
name|int
name|dataMemSize
decl_stmt|;
comment|/* size of data memory */
name|uint32_t
name|savedExecCount
decl_stmt|;
name|uint32_t
name|savedEcsDbgCtxtReg2
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|ixpnpe_softc
modifier|*
name|npes
index|[
name|NPE_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|IX_NPEDL_NPEIMAGE_FIELD_MASK
value|0xff
end_define

begin_comment
comment|/* used to read download map from version in microcode image */
end_comment

begin_define
define|#
directive|define
name|IX_NPEDL_BLOCK_TYPE_INSTRUCTION
value|0x00000000
end_define

begin_define
define|#
directive|define
name|IX_NPEDL_BLOCK_TYPE_DATA
value|0x00000001
end_define

begin_define
define|#
directive|define
name|IX_NPEDL_BLOCK_TYPE_STATE
value|0x00000002
end_define

begin_define
define|#
directive|define
name|IX_NPEDL_END_OF_DOWNLOAD_MAP
value|0x0000000F
end_define

begin_comment
comment|/*  * masks used to extract address info from State information context  * register addresses as read from microcode image  */
end_comment

begin_define
define|#
directive|define
name|IX_NPEDL_MASK_STATE_ADDR_CTXT_REG
value|0x0000000F
end_define

begin_define
define|#
directive|define
name|IX_NPEDL_MASK_STATE_ADDR_CTXT_NUM
value|0x000000F0
end_define

begin_comment
comment|/* LSB offset of Context Number field in State-Info Context Address */
end_comment

begin_define
define|#
directive|define
name|IX_NPEDL_OFFSET_STATE_ADDR_CTXT_NUM
value|4
end_define

begin_comment
comment|/* size (in words) of single State Information entry (ctxt reg address|data) */
end_comment

begin_define
define|#
directive|define
name|IX_NPEDL_STATE_INFO_ENTRY_SIZE
value|2
end_define

begin_typedef
typedef|typedef
struct|struct
block|{
name|uint32_t
name|type
decl_stmt|;
name|uint32_t
name|offset
decl_stmt|;
block|}
name|IxNpeDlNpeMgrDownloadMapBlockEntry
typedef|;
end_typedef

begin_typedef
typedef|typedef
union|union
block|{
name|IxNpeDlNpeMgrDownloadMapBlockEntry
name|block
decl_stmt|;
name|uint32_t
name|eodmMarker
decl_stmt|;
block|}
name|IxNpeDlNpeMgrDownloadMapEntry
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
comment|/* 1st entry in the download map (there may be more than one) */
name|IxNpeDlNpeMgrDownloadMapEntry
name|entry
index|[
literal|1
index|]
decl_stmt|;
block|}
name|IxNpeDlNpeMgrDownloadMap
typedef|;
end_typedef

begin_comment
comment|/* used to access an instruction or data block in a microcode image */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|uint32_t
name|npeMemAddress
decl_stmt|;
name|uint32_t
name|size
decl_stmt|;
name|uint32_t
name|data
index|[
literal|1
index|]
decl_stmt|;
block|}
name|IxNpeDlNpeMgrCodeBlock
typedef|;
end_typedef

begin_comment
comment|/* used to access each Context Reg entry state-information block */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|uint32_t
name|addressInfo
decl_stmt|;
name|uint32_t
name|value
decl_stmt|;
block|}
name|IxNpeDlNpeMgrStateInfoCtxtRegEntry
typedef|;
end_typedef

begin_comment
comment|/* used to access a state-information block in a microcode image */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|uint32_t
name|size
decl_stmt|;
name|IxNpeDlNpeMgrStateInfoCtxtRegEntry
name|ctxtRegEntry
index|[
literal|1
index|]
decl_stmt|;
block|}
name|IxNpeDlNpeMgrStateInfoBlock
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|int
name|npe_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|ixp425npe
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|npe_debug
argument_list|,
literal|0
argument_list|,
literal|"IXP4XX NPE debug msgs"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|dev
parameter_list|,
name|fmt
parameter_list|,
modifier|...
parameter_list|)
value|do {					\ 	if (npe_debug) device_printf(dev, fmt, __VA_ARGS__);		\ } while (0)
end_define

begin_define
define|#
directive|define
name|DPRINTFn
parameter_list|(
name|n
parameter_list|,
name|dev
parameter_list|,
name|fmt
parameter_list|,
modifier|...
parameter_list|)
value|do {					\ 	if (npe_debug>= n) printf(fmt, __VA_ARGS__);			\ } while (0)
end_define

begin_function_decl
specifier|static
name|int
name|npe_checkbits
parameter_list|(
name|struct
name|ixpnpe_softc
modifier|*
parameter_list|,
name|uint32_t
name|reg
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|npe_isstopped
parameter_list|(
name|struct
name|ixpnpe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|npe_load_ins
parameter_list|(
name|struct
name|ixpnpe_softc
modifier|*
parameter_list|,
specifier|const
name|IxNpeDlNpeMgrCodeBlock
modifier|*
name|bp
parameter_list|,
name|int
name|verify
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|npe_load_data
parameter_list|(
name|struct
name|ixpnpe_softc
modifier|*
parameter_list|,
specifier|const
name|IxNpeDlNpeMgrCodeBlock
modifier|*
name|bp
parameter_list|,
name|int
name|verify
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|npe_load_stateinfo
parameter_list|(
name|struct
name|ixpnpe_softc
modifier|*
parameter_list|,
specifier|const
name|IxNpeDlNpeMgrStateInfoBlock
modifier|*
name|bp
parameter_list|,
name|int
name|verify
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|npe_load_image
parameter_list|(
name|struct
name|ixpnpe_softc
modifier|*
parameter_list|,
specifier|const
name|uint32_t
modifier|*
name|imageCodePtr
parameter_list|,
name|int
name|verify
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|npe_cpu_reset
parameter_list|(
name|struct
name|ixpnpe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|npe_cpu_start
parameter_list|(
name|struct
name|ixpnpe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|npe_cpu_stop
parameter_list|(
name|struct
name|ixpnpe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|npe_cmd_issue_write
parameter_list|(
name|struct
name|ixpnpe_softc
modifier|*
parameter_list|,
name|uint32_t
name|cmd
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
name|uint32_t
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|npe_cmd_issue_read
parameter_list|(
name|struct
name|ixpnpe_softc
modifier|*
parameter_list|,
name|uint32_t
name|cmd
parameter_list|,
name|uint32_t
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|npe_ins_write
parameter_list|(
name|struct
name|ixpnpe_softc
modifier|*
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
name|uint32_t
name|data
parameter_list|,
name|int
name|verify
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|npe_data_write
parameter_list|(
name|struct
name|ixpnpe_softc
modifier|*
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
name|uint32_t
name|data
parameter_list|,
name|int
name|verify
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|npe_ecs_reg_write
parameter_list|(
name|struct
name|ixpnpe_softc
modifier|*
parameter_list|,
name|uint32_t
name|reg
parameter_list|,
name|uint32_t
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|npe_ecs_reg_read
parameter_list|(
name|struct
name|ixpnpe_softc
modifier|*
parameter_list|,
name|uint32_t
name|reg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|npe_issue_cmd
parameter_list|(
name|struct
name|ixpnpe_softc
modifier|*
parameter_list|,
name|uint32_t
name|command
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|npe_cpu_step_save
parameter_list|(
name|struct
name|ixpnpe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|npe_cpu_step
parameter_list|(
name|struct
name|ixpnpe_softc
modifier|*
parameter_list|,
name|uint32_t
name|npeInstruction
parameter_list|,
name|uint32_t
name|ctxtNum
parameter_list|,
name|uint32_t
name|ldur
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|npe_cpu_step_restore
parameter_list|(
name|struct
name|ixpnpe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|npe_logical_reg_read
parameter_list|(
name|struct
name|ixpnpe_softc
modifier|*
parameter_list|,
name|uint32_t
name|regAddr
parameter_list|,
name|uint32_t
name|regSize
parameter_list|,
name|uint32_t
name|ctxtNum
parameter_list|,
name|uint32_t
modifier|*
name|regVal
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|npe_logical_reg_write
parameter_list|(
name|struct
name|ixpnpe_softc
modifier|*
parameter_list|,
name|uint32_t
name|regAddr
parameter_list|,
name|uint32_t
name|regVal
parameter_list|,
name|uint32_t
name|regSize
parameter_list|,
name|uint32_t
name|ctxtNum
parameter_list|,
name|int
name|verify
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|npe_physical_reg_write
parameter_list|(
name|struct
name|ixpnpe_softc
modifier|*
parameter_list|,
name|uint32_t
name|regAddr
parameter_list|,
name|uint32_t
name|regValue
parameter_list|,
name|int
name|verify
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|npe_ctx_reg_write
parameter_list|(
name|struct
name|ixpnpe_softc
modifier|*
parameter_list|,
name|uint32_t
name|ctxtNum
parameter_list|,
name|uint32_t
name|ctxtReg
parameter_list|,
name|uint32_t
name|ctxtRegVal
parameter_list|,
name|int
name|verify
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ixpnpe_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|uint32_t
name|npe_reg_read
parameter_list|(
name|struct
name|ixpnpe_softc
modifier|*
name|sc
parameter_list|,
name|bus_size_t
name|off
parameter_list|)
block|{
name|uint32_t
name|v
init|=
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|sc_iot
argument_list|,
name|sc
operator|->
name|sc_ioh
argument_list|,
name|off
argument_list|)
decl_stmt|;
name|DPRINTFn
argument_list|(
literal|9
argument_list|,
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s(0x%lx) => 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|off
argument_list|,
name|v
argument_list|)
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|npe_reg_write
parameter_list|(
name|struct
name|ixpnpe_softc
modifier|*
name|sc
parameter_list|,
name|bus_size_t
name|off
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
name|DPRINTFn
argument_list|(
literal|9
argument_list|,
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s(0x%lx, 0x%x)\n"
argument_list|,
name|__func__
argument_list|,
name|off
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|sc
operator|->
name|sc_iot
argument_list|,
name|sc
operator|->
name|sc_ioh
argument_list|,
name|off
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|ixpnpe_softc
modifier|*
name|ixpnpe_attach
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|npeid
parameter_list|)
block|{
struct|struct
name|npeconfig
block|{
name|uint32_t
name|base
decl_stmt|;
name|uint32_t
name|size
decl_stmt|;
name|int
name|irq
decl_stmt|;
name|uint32_t
name|ins_memsize
decl_stmt|;
name|uint32_t
name|data_memsize
decl_stmt|;
block|}
struct|;
specifier|static
specifier|const
name|struct
name|npeconfig
name|npeconfigs
index|[
name|NPE_MAX
index|]
init|=
block|{
index|[
name|NPE_A
index|]
operator|=
block|{
operator|.
name|base
operator|=
name|IXP425_NPE_A_HWBASE
block|,
operator|.
name|size
operator|=
name|IXP425_NPE_A_SIZE
block|,
operator|.
name|irq
operator|=
name|IXP425_INT_NPE_A
block|,
operator|.
name|ins_memsize
operator|=
name|IX_NPEDL_INS_MEMSIZE_WORDS_NPEA
block|,
operator|.
name|data_memsize
operator|=
name|IX_NPEDL_DATA_MEMSIZE_WORDS_NPEA
block|}
block|,
index|[
name|NPE_B
index|]
operator|=
block|{
operator|.
name|base
operator|=
name|IXP425_NPE_B_HWBASE
block|,
operator|.
name|size
operator|=
name|IXP425_NPE_B_SIZE
block|,
operator|.
name|irq
operator|=
name|IXP425_INT_NPE_B
block|,
operator|.
name|ins_memsize
operator|=
name|IX_NPEDL_INS_MEMSIZE_WORDS_NPEB
block|,
operator|.
name|data_memsize
operator|=
name|IX_NPEDL_DATA_MEMSIZE_WORDS_NPEB
block|}
block|,
index|[
name|NPE_C
index|]
operator|=
block|{
operator|.
name|base
operator|=
name|IXP425_NPE_C_HWBASE
block|,
operator|.
name|size
operator|=
name|IXP425_NPE_C_SIZE
block|,
operator|.
name|irq
operator|=
name|IXP425_INT_NPE_C
block|,
operator|.
name|ins_memsize
operator|=
name|IX_NPEDL_INS_MEMSIZE_WORDS_NPEC
block|,
operator|.
name|data_memsize
operator|=
name|IX_NPEDL_DATA_MEMSIZE_WORDS_NPEC
block|}
block|, 	}
decl_stmt|;
name|struct
name|ixp425_softc
modifier|*
name|sa
init|=
name|device_get_softc
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|ixpnpe_softc
modifier|*
name|sc
decl_stmt|;
specifier|const
name|struct
name|npeconfig
modifier|*
name|config
decl_stmt|;
name|int
name|rid
decl_stmt|;
if|if
condition|(
name|npeid
operator|>=
name|NPE_MAX
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: bad npeid %d\n"
argument_list|,
name|__func__
argument_list|,
name|npeid
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|sc
operator|=
name|npes
index|[
name|npeid
index|]
expr_stmt|;
if|if
condition|(
name|sc
operator|!=
name|NULL
condition|)
block|{
name|sc
operator|->
name|sc_nrefs
operator|++
expr_stmt|;
return|return
name|sc
return|;
block|}
name|config
operator|=
operator|&
name|npeconfigs
index|[
name|npeid
index|]
expr_stmt|;
comment|/* XXX M_BUS */
name|sc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ixpnpe_softc
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_dev
operator|=
name|dev
expr_stmt|;
name|sc
operator|->
name|sc_iot
operator|=
name|sa
operator|->
name|sc_iot
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"npe driver"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_npeid
operator|=
name|npeid
expr_stmt|;
name|sc
operator|->
name|sc_nrefs
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_size
operator|=
name|config
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|cpu_is_ixp42x
argument_list|()
condition|)
block|{
comment|/* NB: instruction/data memory sizes are NPE-dependent */
name|sc
operator|->
name|insMemSize
operator|=
name|config
operator|->
name|ins_memsize
expr_stmt|;
name|sc
operator|->
name|dataMemSize
operator|=
name|config
operator|->
name|data_memsize
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|insMemSize
operator|=
name|IXP46X_NPEDL_INS_MEMSIZE_WORDS
expr_stmt|;
name|sc
operator|->
name|dataMemSize
operator|=
name|IXP46X_NPEDL_DATA_MEMSIZE_WORDS
expr_stmt|;
block|}
if|if
condition|(
name|bus_space_map
argument_list|(
name|sc
operator|->
name|sc_iot
argument_list|,
name|config
operator|->
name|base
argument_list|,
name|sc
operator|->
name|sc_size
argument_list|,
literal|0
argument_list|,
operator|&
name|sc
operator|->
name|sc_ioh
argument_list|)
condition|)
name|panic
argument_list|(
literal|"%s: Cannot map registers"
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Setup IRQ and handler for NPE message support. 	 */
name|rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_irq
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|config
operator|->
name|irq
argument_list|,
name|config
operator|->
name|irq
argument_list|,
literal|1
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_irq
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"%s: Unable to allocate irq %u"
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|config
operator|->
name|irq
argument_list|)
expr_stmt|;
comment|/* XXX could be a source of entropy */
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|sc_irq
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|ixpnpe_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_ih
argument_list|)
expr_stmt|;
comment|/* 	 * Enable output fifo interrupts (NB: must also set OFIFO Write Enable) 	 */
name|npe_reg_write
argument_list|(
name|sc
argument_list|,
name|IX_NPECTL
argument_list|,
name|npe_reg_read
argument_list|(
name|sc
argument_list|,
name|IX_NPECTL
argument_list|)
operator||
operator|(
name|IX_NPECTL_OFE
operator||
name|IX_NPECTL_OFWE
operator|)
argument_list|)
expr_stmt|;
name|npes
index|[
name|npeid
index|]
operator|=
name|sc
expr_stmt|;
return|return
name|sc
return|;
block|}
end_function

begin_function
name|void
name|ixpnpe_detach
parameter_list|(
name|struct
name|ixpnpe_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
operator|--
name|sc
operator|->
name|sc_nrefs
operator|==
literal|0
condition|)
block|{
name|npes
index|[
name|sc
operator|->
name|sc_npeid
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* disable output fifo interrupts */
name|npe_reg_write
argument_list|(
name|sc
argument_list|,
name|IX_NPECTL
argument_list|,
name|npe_reg_read
argument_list|(
name|sc
argument_list|,
name|IX_NPECTL
argument_list|)
operator|&
operator|~
operator|(
name|IX_NPECTL_OFE
operator||
name|IX_NPECTL_OFWE
operator|)
argument_list|)
expr_stmt|;
name|bus_teardown_intr
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|sc
operator|->
name|sc_irq
argument_list|,
name|sc
operator|->
name|sc_ih
argument_list|)
expr_stmt|;
name|bus_space_unmap
argument_list|(
name|sc
operator|->
name|sc_iot
argument_list|,
name|sc
operator|->
name|sc_ioh
argument_list|,
name|sc
operator|->
name|sc_size
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|ixpnpe_stopandreset
parameter_list|(
name|struct
name|ixpnpe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
name|error
operator|=
name|npe_cpu_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* stop NPE */
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|npe_cpu_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* reset it */
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|sc
operator|->
name|started
operator|=
literal|0
expr_stmt|;
comment|/* mark stopped */
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ixpnpe_start_locked
parameter_list|(
name|struct
name|ixpnpe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|started
condition|)
block|{
name|error
operator|=
name|npe_cpu_start
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|sc
operator|->
name|started
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|error
operator|=
literal|0
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|ixpnpe_start
parameter_list|(
name|struct
name|ixpnpe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ixpnpe_start_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ixpnpe_stop
parameter_list|(
name|struct
name|ixpnpe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
name|error
operator|=
name|npe_cpu_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|sc
operator|->
name|started
operator|=
literal|0
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Indicates the start of an NPE Image, in new NPE Image Library format.  * 2 consecutive occurrences indicates the end of the NPE Image Library  */
end_comment

begin_define
define|#
directive|define
name|NPE_IMAGE_MARKER
value|0xfeedf00d
end_define

begin_comment
comment|/*  * NPE Image Header definition, used in new NPE Image Library format  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|uint32_t
name|marker
decl_stmt|;
name|uint32_t
name|id
decl_stmt|;
name|uint32_t
name|size
decl_stmt|;
block|}
name|IxNpeDlImageMgrImageHeader
typedef|;
end_typedef

begin_function
specifier|static
name|int
name|npe_findimage
parameter_list|(
name|struct
name|ixpnpe_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|uint32_t
modifier|*
name|imageLibrary
parameter_list|,
name|uint32_t
name|imageId
parameter_list|,
specifier|const
name|uint32_t
modifier|*
modifier|*
name|imagePtr
parameter_list|,
name|uint32_t
modifier|*
name|imageSize
parameter_list|)
block|{
specifier|const
name|IxNpeDlImageMgrImageHeader
modifier|*
name|image
decl_stmt|;
name|uint32_t
name|offset
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|imageLibrary
index|[
name|offset
index|]
operator|==
name|NPE_IMAGE_MARKER
condition|)
block|{
name|image
operator|=
operator|(
specifier|const
name|IxNpeDlImageMgrImageHeader
operator|*
operator|)
operator|&
name|imageLibrary
index|[
name|offset
index|]
expr_stmt|;
name|offset
operator|+=
sizeof|sizeof
argument_list|(
name|IxNpeDlImageMgrImageHeader
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: off %u mark 0x%x id 0x%x size %u\n"
argument_list|,
name|__func__
argument_list|,
name|offset
argument_list|,
name|image
operator|->
name|marker
argument_list|,
name|image
operator|->
name|id
argument_list|,
name|image
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|image
operator|->
name|id
operator|==
name|imageId
condition|)
block|{
operator|*
name|imagePtr
operator|=
name|imageLibrary
operator|+
name|offset
expr_stmt|;
operator|*
name|imageSize
operator|=
name|image
operator|->
name|size
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 2 consecutive NPE_IMAGE_MARKER's indicates end of library */
if|if
condition|(
name|image
operator|->
name|id
operator|==
name|NPE_IMAGE_MARKER
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"imageId 0x%08x not found in "
literal|"image library header\n"
argument_list|,
name|imageId
argument_list|)
expr_stmt|;
comment|/* reached end of library, image not found */
return|return
name|ESRCH
return|;
block|}
name|offset
operator|+=
name|image
operator|->
name|size
expr_stmt|;
block|}
return|return
name|ESRCH
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ixpnpe_load_firmware
parameter_list|(
name|struct
name|ixpnpe_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
name|imageName
parameter_list|,
name|uint32_t
name|imageId
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|devname
index|[
literal|4
index|]
init|=
block|{
literal|"IXP425"
block|,
literal|"IXP435/IXP465"
block|,
literal|"DeviceID#2"
block|,
literal|"DeviceID#3"
block|}
decl_stmt|;
name|uint32_t
name|imageSize
decl_stmt|;
specifier|const
name|uint32_t
modifier|*
name|imageCodePtr
decl_stmt|;
specifier|const
name|struct
name|firmware
modifier|*
name|fw
decl_stmt|;
name|int
name|error
decl_stmt|;
name|DPRINTF
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"load %s, imageId 0x%08x\n"
argument_list|,
name|imageName
argument_list|,
name|imageId
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|IxFeatureCtrlDeviceId devid = IX_NPEDL_DEVICEID_FROM_IMAGEID_GET(imageId);
comment|/* 	 * Checking if image being loaded is meant for device that is running. 	 * Image is forward compatible. i.e Image built for IXP42X should run 	 * on IXP46X but not vice versa. 	 */
block|if (devid> (ixFeatureCtrlDeviceRead()& IX_FEATURE_CTRL_DEVICE_TYPE_MASK)) 	    return EINVAL;
endif|#
directive|endif
name|error
operator|=
name|ixpnpe_stopandreset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* stop and reset the NPE */
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|fw
operator|=
name|firmware_get
argument_list|(
name|imageName
argument_list|)
expr_stmt|;
if|if
condition|(
name|fw
operator|==
name|NULL
condition|)
return|return
name|ENOENT
return|;
comment|/* Locate desired image in files w/ combined images */
name|error
operator|=
name|npe_findimage
argument_list|(
name|sc
argument_list|,
name|fw
operator|->
name|data
argument_list|,
name|imageId
argument_list|,
operator|&
name|imageCodePtr
argument_list|,
operator|&
name|imageSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"load fw image %s.NPE-%c Func 0x%x Rev %u.%u\n"
argument_list|,
name|devname
index|[
name|NPEIMAGE_DEVID
argument_list|(
name|imageId
argument_list|)
index|]
argument_list|,
literal|'A'
operator|+
name|NPEIMAGE_NPEID
argument_list|(
name|imageId
argument_list|)
argument_list|,
name|NPEIMAGE_FUNCID
argument_list|(
name|imageId
argument_list|)
argument_list|,
name|NPEIMAGE_MAJOR
argument_list|(
name|imageId
argument_list|)
argument_list|,
name|NPEIMAGE_MINOR
argument_list|(
name|imageId
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * If download was successful, store image Id in list of 	 * currently loaded images. If a critical error occurred 	 * during download, record that the NPE has an invalid image 	 */
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
name|error
operator|=
name|npe_load_image
argument_list|(
name|sc
argument_list|,
name|imageCodePtr
argument_list|,
literal|1
comment|/*VERIFY*/
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|validImage
operator|=
literal|1
expr_stmt|;
name|error
operator|=
name|ixpnpe_start_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|validImage
operator|=
literal|0
expr_stmt|;
block|}
name|sc
operator|->
name|functionalityId
operator|=
name|IX_NPEDL_FUNCTIONID_FROM_IMAGEID_GET
argument_list|(
name|imageId
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
name|done
label|:
name|firmware_put
argument_list|(
name|fw
argument_list|,
name|FIRMWARE_UNLOAD
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|override_imageid
parameter_list|(
name|device_t
name|dev
parameter_list|,
specifier|const
name|char
modifier|*
name|resname
parameter_list|,
name|uint32_t
modifier|*
name|val
parameter_list|)
block|{
name|int
name|unit
init|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|resval
decl_stmt|;
if|if
condition|(
name|resource_int_value
argument_list|(
literal|"npe"
argument_list|,
name|unit
argument_list|,
name|resname
argument_list|,
operator|&
name|resval
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* XXX validate */
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"using npe.%d.%s=0x%x override\n"
argument_list|,
name|unit
argument_list|,
name|resname
argument_list|,
name|resval
argument_list|)
expr_stmt|;
operator|*
name|val
operator|=
name|resval
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|ixpnpe_init
parameter_list|(
name|struct
name|ixpnpe_softc
modifier|*
name|sc
parameter_list|)
block|{
specifier|static
specifier|const
name|uint32_t
name|npeconfig
index|[
name|NPE_MAX
index|]
init|=
block|{
index|[
name|NPE_A
index|]
operator|=
name|IXP425_NPE_A_IMAGEID
block|,
index|[
name|NPE_B
index|]
operator|=
name|IXP425_NPE_B_IMAGEID
block|,
index|[
name|NPE_C
index|]
operator|=
name|IXP425_NPE_C_IMAGEID
block|, 	}
decl_stmt|;
name|uint32_t
name|imageid
decl_stmt|,
name|msg
index|[
literal|2
index|]
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|started
condition|)
return|return
literal|0
return|;
comment|/* 	 * Load NPE firmware and start it running.  We assume 	 * that minor version bumps remain compatible so probe 	 * the firmware image starting with the expected version 	 * and then bump the minor version up to the max. 	 */
if|if
condition|(
operator|!
name|override_imageid
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"imageid"
argument_list|,
operator|&
name|imageid
argument_list|)
condition|)
name|imageid
operator|=
name|npeconfig
index|[
name|sc
operator|->
name|sc_npeid
index|]
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|error
operator|=
name|ixpnpe_load_firmware
argument_list|(
name|sc
argument_list|,
literal|"npe_fw"
argument_list|,
name|imageid
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
break|break;
comment|/* 		 * ESRCH is returned when the requested image 		 * is not present 		 */
if|if
condition|(
name|error
operator|!=
name|ESRCH
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"cannot init NPE (error %d)\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* bump the minor version up to the max possible */
if|if
condition|(
name|NPEIMAGE_MINOR
argument_list|(
name|imageid
argument_list|)
operator|==
literal|0xff
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"cannot locate firmware "
literal|"(imageid 0x%08x)\n"
argument_list|,
name|imageid
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|imageid
operator|++
expr_stmt|;
block|}
comment|/* NB: firmware should respond with a status msg */
if|if
condition|(
name|ixpnpe_recvmsg_sync
argument_list|(
name|sc
argument_list|,
name|msg
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"firmware did not respond as expected\n"
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|ixpnpe_getfunctionality
parameter_list|(
name|struct
name|ixpnpe_softc
modifier|*
name|sc
parameter_list|)
block|{
return|return
operator|(
name|sc
operator|->
name|validImage
condition|?
name|sc
operator|->
name|functionalityId
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|npe_checkbits
parameter_list|(
name|struct
name|ixpnpe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|reg
parameter_list|,
name|uint32_t
name|expectedBitsSet
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|;
name|val
operator|=
name|npe_reg_read
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|DPRINTFn
argument_list|(
literal|5
argument_list|,
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s(0x%x, 0x%x) => 0x%x (%u)\n"
argument_list|,
name|__func__
argument_list|,
name|reg
argument_list|,
name|expectedBitsSet
argument_list|,
name|val
argument_list|,
operator|(
name|val
operator|&
name|expectedBitsSet
operator|)
operator|==
name|expectedBitsSet
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|val
operator|&
name|expectedBitsSet
operator|)
operator|==
name|expectedBitsSet
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|npe_isstopped
parameter_list|(
name|struct
name|ixpnpe_softc
modifier|*
name|sc
parameter_list|)
block|{
return|return
name|npe_checkbits
argument_list|(
name|sc
argument_list|,
name|IX_NPEDL_REG_OFFSET_EXCTL
argument_list|,
name|IX_NPEDL_EXCTL_STATUS_STOP
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|npe_load_ins
parameter_list|(
name|struct
name|ixpnpe_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|IxNpeDlNpeMgrCodeBlock
modifier|*
name|bp
parameter_list|,
name|int
name|verify
parameter_list|)
block|{
name|uint32_t
name|npeMemAddress
decl_stmt|;
name|int
name|i
decl_stmt|,
name|blockSize
decl_stmt|;
name|npeMemAddress
operator|=
name|bp
operator|->
name|npeMemAddress
expr_stmt|;
name|blockSize
operator|=
name|bp
operator|->
name|size
expr_stmt|;
comment|/* NB: instruction/data count */
if|if
condition|(
name|npeMemAddress
operator|+
name|blockSize
operator|>
name|sc
operator|->
name|insMemSize
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Block size %u too big for NPE memory\n"
argument_list|,
name|blockSize
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
comment|/* XXX */
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|blockSize
condition|;
name|i
operator|++
operator|,
name|npeMemAddress
operator|++
control|)
block|{
if|if
condition|(
name|npe_ins_write
argument_list|(
name|sc
argument_list|,
name|npeMemAddress
argument_list|,
name|bp
operator|->
name|data
index|[
name|i
index|]
argument_list|,
name|verify
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"NPE instruction write failed"
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|npe_load_data
parameter_list|(
name|struct
name|ixpnpe_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|IxNpeDlNpeMgrCodeBlock
modifier|*
name|bp
parameter_list|,
name|int
name|verify
parameter_list|)
block|{
name|uint32_t
name|npeMemAddress
decl_stmt|;
name|int
name|i
decl_stmt|,
name|blockSize
decl_stmt|;
name|npeMemAddress
operator|=
name|bp
operator|->
name|npeMemAddress
expr_stmt|;
name|blockSize
operator|=
name|bp
operator|->
name|size
expr_stmt|;
comment|/* NB: instruction/data count */
if|if
condition|(
name|npeMemAddress
operator|+
name|blockSize
operator|>
name|sc
operator|->
name|dataMemSize
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Block size %u too big for NPE memory\n"
argument_list|,
name|blockSize
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|blockSize
condition|;
name|i
operator|++
operator|,
name|npeMemAddress
operator|++
control|)
block|{
if|if
condition|(
name|npe_data_write
argument_list|(
name|sc
argument_list|,
name|npeMemAddress
argument_list|,
name|bp
operator|->
name|data
index|[
name|i
index|]
argument_list|,
name|verify
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"NPE data write failed\n"
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|npe_load_stateinfo
parameter_list|(
name|struct
name|ixpnpe_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|IxNpeDlNpeMgrStateInfoBlock
modifier|*
name|bp
parameter_list|,
name|int
name|verify
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|nentries
decl_stmt|,
name|error
decl_stmt|;
name|npe_cpu_step_save
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* for each state-info context register entry in block */
name|nentries
operator|=
name|bp
operator|->
name|size
operator|/
name|IX_NPEDL_STATE_INFO_ENTRY_SIZE
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nentries
condition|;
name|i
operator|++
control|)
block|{
comment|/* each state-info entry is 2 words (address, value) */
name|uint32_t
name|regVal
init|=
name|bp
operator|->
name|ctxtRegEntry
index|[
name|i
index|]
operator|.
name|value
decl_stmt|;
name|uint32_t
name|addrInfo
init|=
name|bp
operator|->
name|ctxtRegEntry
index|[
name|i
index|]
operator|.
name|addressInfo
decl_stmt|;
name|uint32_t
name|reg
init|=
operator|(
name|addrInfo
operator|&
name|IX_NPEDL_MASK_STATE_ADDR_CTXT_REG
operator|)
decl_stmt|;
name|uint32_t
name|cNum
init|=
operator|(
name|addrInfo
operator|&
name|IX_NPEDL_MASK_STATE_ADDR_CTXT_NUM
operator|)
operator|>>
name|IX_NPEDL_OFFSET_STATE_ADDR_CTXT_NUM
decl_stmt|;
comment|/* error-check Context Register No. and Context Number values */
if|if
condition|(
operator|!
operator|(
literal|0
operator|<=
name|reg
operator|&&
name|reg
operator|<
name|IX_NPEDL_CTXT_REG_MAX
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"invalid Context Register %u\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
operator|(
literal|0
operator|<=
name|cNum
operator|&&
name|cNum
operator|<
name|IX_NPEDL_CTXT_NUM_MAX
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"invalid Context Number %u\n"
argument_list|,
name|cNum
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* NOTE that there is no STEVT register for Context 0 */
if|if
condition|(
name|cNum
operator|==
literal|0
operator|&&
name|reg
operator|==
name|IX_NPEDL_CTXT_REG_STEVT
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"no STEVT for Context 0\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|npe_ctx_reg_write
argument_list|(
name|sc
argument_list|,
name|cNum
argument_list|,
name|reg
argument_list|,
name|regVal
argument_list|,
name|verify
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"write of state-info to NPE failed\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
break|break;
block|}
block|}
name|npe_cpu_step_restore
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|npe_load_image
parameter_list|(
name|struct
name|ixpnpe_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|uint32_t
modifier|*
name|imageCodePtr
parameter_list|,
name|int
name|verify
parameter_list|)
block|{
define|#
directive|define
name|EOM
parameter_list|(
name|marker
parameter_list|)
value|((marker) == IX_NPEDL_END_OF_DOWNLOAD_MAP)
specifier|const
name|IxNpeDlNpeMgrDownloadMap
modifier|*
name|downloadMap
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
if|if
condition|(
operator|!
name|npe_isstopped
argument_list|(
name|sc
argument_list|)
condition|)
block|{
comment|/* verify NPE is stopped */
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"cannot load image, NPE not stopped\n"
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
comment|/* 	 * Read Download Map, checking each block type and calling 	 * appropriate function to perform download 	 */
name|error
operator|=
literal|0
expr_stmt|;
name|downloadMap
operator|=
operator|(
specifier|const
name|IxNpeDlNpeMgrDownloadMap
operator|*
operator|)
name|imageCodePtr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|!
name|EOM
argument_list|(
name|downloadMap
operator|->
name|entry
index|[
name|i
index|]
operator|.
name|eodmMarker
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
comment|/* calculate pointer to block to be downloaded */
specifier|const
name|uint32_t
modifier|*
name|bp
init|=
name|imageCodePtr
operator|+
name|downloadMap
operator|->
name|entry
index|[
name|i
index|]
operator|.
name|block
operator|.
name|offset
decl_stmt|;
switch|switch
condition|(
name|downloadMap
operator|->
name|entry
index|[
name|i
index|]
operator|.
name|block
operator|.
name|type
condition|)
block|{
case|case
name|IX_NPEDL_BLOCK_TYPE_INSTRUCTION
case|:
name|error
operator|=
name|npe_load_ins
argument_list|(
name|sc
argument_list|,
operator|(
specifier|const
name|IxNpeDlNpeMgrCodeBlock
operator|*
operator|)
name|bp
argument_list|,
name|verify
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: inst, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
break|break;
case|case
name|IX_NPEDL_BLOCK_TYPE_DATA
case|:
name|error
operator|=
name|npe_load_data
argument_list|(
name|sc
argument_list|,
operator|(
specifier|const
name|IxNpeDlNpeMgrCodeBlock
operator|*
operator|)
name|bp
argument_list|,
name|verify
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: data, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
break|break;
case|case
name|IX_NPEDL_BLOCK_TYPE_STATE
case|:
name|error
operator|=
name|npe_load_stateinfo
argument_list|(
name|sc
argument_list|,
operator|(
specifier|const
name|IxNpeDlNpeMgrStateInfoBlock
operator|*
operator|)
name|bp
argument_list|,
name|verify
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: state, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unknown block type 0x%x in download map\n"
argument_list|,
name|downloadMap
operator|->
name|entry
index|[
name|i
index|]
operator|.
name|block
operator|.
name|type
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
comment|/* XXX */
break|break;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
block|}
return|return
name|error
return|;
undef|#
directive|undef
name|EOM
block|}
end_function

begin_comment
comment|/* contains Reset values for Context Store Registers  */
end_comment

begin_struct
specifier|static
specifier|const
struct|struct
block|{
name|uint32_t
name|regAddr
decl_stmt|;
name|uint32_t
name|regResetVal
decl_stmt|;
block|}
name|ixNpeDlEcsRegResetValues
index|[]
init|=
block|{
block|{
name|IX_NPEDL_ECS_BG_CTXT_REG_0
block|,
name|IX_NPEDL_ECS_BG_CTXT_REG_0_RESET
block|}
block|,
block|{
name|IX_NPEDL_ECS_BG_CTXT_REG_1
block|,
name|IX_NPEDL_ECS_BG_CTXT_REG_1_RESET
block|}
block|,
block|{
name|IX_NPEDL_ECS_BG_CTXT_REG_2
block|,
name|IX_NPEDL_ECS_BG_CTXT_REG_2_RESET
block|}
block|,
block|{
name|IX_NPEDL_ECS_PRI_1_CTXT_REG_0
block|,
name|IX_NPEDL_ECS_PRI_1_CTXT_REG_0_RESET
block|}
block|,
block|{
name|IX_NPEDL_ECS_PRI_1_CTXT_REG_1
block|,
name|IX_NPEDL_ECS_PRI_1_CTXT_REG_1_RESET
block|}
block|,
block|{
name|IX_NPEDL_ECS_PRI_1_CTXT_REG_2
block|,
name|IX_NPEDL_ECS_PRI_1_CTXT_REG_2_RESET
block|}
block|,
block|{
name|IX_NPEDL_ECS_PRI_2_CTXT_REG_0
block|,
name|IX_NPEDL_ECS_PRI_2_CTXT_REG_0_RESET
block|}
block|,
block|{
name|IX_NPEDL_ECS_PRI_2_CTXT_REG_1
block|,
name|IX_NPEDL_ECS_PRI_2_CTXT_REG_1_RESET
block|}
block|,
block|{
name|IX_NPEDL_ECS_PRI_2_CTXT_REG_2
block|,
name|IX_NPEDL_ECS_PRI_2_CTXT_REG_2_RESET
block|}
block|,
block|{
name|IX_NPEDL_ECS_DBG_CTXT_REG_0
block|,
name|IX_NPEDL_ECS_DBG_CTXT_REG_0_RESET
block|}
block|,
block|{
name|IX_NPEDL_ECS_DBG_CTXT_REG_1
block|,
name|IX_NPEDL_ECS_DBG_CTXT_REG_1_RESET
block|}
block|,
block|{
name|IX_NPEDL_ECS_DBG_CTXT_REG_2
block|,
name|IX_NPEDL_ECS_DBG_CTXT_REG_2_RESET
block|}
block|,
block|{
name|IX_NPEDL_ECS_INSTRUCT_REG
block|,
name|IX_NPEDL_ECS_INSTRUCT_REG_RESET
block|}
block|}
struct|;
end_struct

begin_comment
comment|/* contains Reset values for Context Store Registers  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|uint32_t
name|ixNpeDlCtxtRegResetValues
index|[]
init|=
block|{
name|IX_NPEDL_CTXT_REG_RESET_STEVT
block|,
name|IX_NPEDL_CTXT_REG_RESET_STARTPC
block|,
name|IX_NPEDL_CTXT_REG_RESET_REGMAP
block|,
name|IX_NPEDL_CTXT_REG_RESET_CINDEX
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|IX_NPEDL_PARITY_BIT_MASK
value|0x3F00FFFF
end_define

begin_define
define|#
directive|define
name|IX_NPEDL_CONFIG_CTRL_REG_MASK
value|0x3F3FFFFF
end_define

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*  * Reset the NPE and its coprocessor using the  * fuse bits in the feature control register.  */
end_comment

begin_comment
unit|static void npe_reset(int npeid) { 	uint32_t mask = EXP_FCTRL_NPEA<< npeid; 	uint32_t v;  	v = ixp4xx_read_feature_bits(); 	ixp4xx_write_feature_bits(v&~ mask);
comment|/* un-fuse and un-reset the NPE& coprocessor */
end_comment

begin_endif
unit|ixp4xx_write_feature_bits(v | mask); }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|npe_cpu_reset
parameter_list|(
name|struct
name|ixpnpe_softc
modifier|*
name|sc
parameter_list|)
block|{
define|#
directive|define
name|N
parameter_list|(
name|a
parameter_list|)
value|(sizeof(a) / sizeof(a[0]))
name|uint32_t
name|ctxtReg
decl_stmt|;
comment|/* identifies Context Store reg (0-3) */
name|uint32_t
name|regAddr
decl_stmt|;
name|uint32_t
name|regVal
decl_stmt|;
name|uint32_t
name|ixNpeConfigCtrlRegVal
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
comment|/* pre-store the NPE Config Control Register Value */
name|ixNpeConfigCtrlRegVal
operator|=
name|npe_reg_read
argument_list|(
name|sc
argument_list|,
name|IX_NPEDL_REG_OFFSET_CTL
argument_list|)
expr_stmt|;
name|ixNpeConfigCtrlRegVal
operator||=
literal|0x3F000000
expr_stmt|;
comment|/* disable the parity interrupt */
name|npe_reg_write
argument_list|(
name|sc
argument_list|,
name|IX_NPEDL_REG_OFFSET_CTL
argument_list|,
operator|(
name|ixNpeConfigCtrlRegVal
operator|&
name|IX_NPEDL_PARITY_BIT_MASK
operator|)
argument_list|)
expr_stmt|;
name|DPRINTFn
argument_list|(
literal|2
argument_list|,
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: dis parity int, CTL => 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|ixNpeConfigCtrlRegVal
operator|&
name|IX_NPEDL_PARITY_BIT_MASK
argument_list|)
expr_stmt|;
name|npe_cpu_step_save
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Clear the FIFOs. 	 */
while|while
condition|(
name|npe_checkbits
argument_list|(
name|sc
argument_list|,
name|IX_NPEDL_REG_OFFSET_WFIFO
argument_list|,
name|IX_NPEDL_MASK_WFIFO_VALID
argument_list|)
condition|)
block|{
comment|/* read from the Watch-point FIFO until empty */
operator|(
name|void
operator|)
name|npe_reg_read
argument_list|(
name|sc
argument_list|,
name|IX_NPEDL_REG_OFFSET_WFIFO
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|npe_checkbits
argument_list|(
name|sc
argument_list|,
name|IX_NPEDL_REG_OFFSET_STAT
argument_list|,
name|IX_NPEDL_MASK_STAT_OFNE
argument_list|)
condition|)
block|{
comment|/* read from the outFIFO until empty */
operator|(
name|void
operator|)
name|npe_reg_read
argument_list|(
name|sc
argument_list|,
name|IX_NPEDL_REG_OFFSET_FIFO
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|npe_checkbits
argument_list|(
name|sc
argument_list|,
name|IX_NPEDL_REG_OFFSET_STAT
argument_list|,
name|IX_NPEDL_MASK_STAT_IFNE
argument_list|)
condition|)
block|{
comment|/* 		 * Step execution of the NPE instruction to read inFIFO using 		 * the Debug Executing Context stack. 		 */
name|error
operator|=
name|npe_cpu_step
argument_list|(
name|sc
argument_list|,
name|IX_NPEDL_INSTR_RD_FIFO
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: cannot step (1), error %u\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|npe_cpu_step_restore
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
block|}
comment|/* 	 * Reset the mailbox reg 	 */
comment|/* ...from XScale side */
name|npe_reg_write
argument_list|(
name|sc
argument_list|,
name|IX_NPEDL_REG_OFFSET_MBST
argument_list|,
name|IX_NPEDL_REG_RESET_MBST
argument_list|)
expr_stmt|;
comment|/* ...from NPE side */
name|error
operator|=
name|npe_cpu_step
argument_list|(
name|sc
argument_list|,
name|IX_NPEDL_INSTR_RESET_MBOX
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: cannot step (2), error %u\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|npe_cpu_step_restore
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* 	 * Reset the physical registers in the NPE register file: 	 * Note: no need to save/restore REGMAP for Context 0 here 	 * since all Context Store regs are reset in subsequent code. 	 */
for|for
control|(
name|regAddr
operator|=
literal|0
init|;
name|regAddr
operator|<
name|IX_NPEDL_TOTAL_NUM_PHYS_REG
operator|&&
name|error
operator|==
literal|0
condition|;
name|regAddr
operator|++
control|)
block|{
comment|/* for each physical register in the NPE reg file, write 0 : */
name|error
operator|=
name|npe_physical_reg_write
argument_list|(
name|sc
argument_list|,
name|regAddr
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: cannot write phy reg,"
literal|"error %u\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|npe_cpu_step_restore
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
name|error
return|;
comment|/* abort reset */
block|}
block|}
comment|/* 	 * Reset the context store: 	 */
for|for
control|(
name|i
operator|=
name|IX_NPEDL_CTXT_NUM_MIN
init|;
name|i
operator|<=
name|IX_NPEDL_CTXT_NUM_MAX
condition|;
name|i
operator|++
control|)
block|{
comment|/* set each context's Context Store registers to reset values */
for|for
control|(
name|ctxtReg
operator|=
literal|0
init|;
name|ctxtReg
operator|<
name|IX_NPEDL_CTXT_REG_MAX
condition|;
name|ctxtReg
operator|++
control|)
block|{
comment|/* NOTE that there is no STEVT register for Context 0 */
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
name|ctxtReg
operator|==
name|IX_NPEDL_CTXT_REG_STEVT
condition|)
continue|continue;
name|regVal
operator|=
name|ixNpeDlCtxtRegResetValues
index|[
name|ctxtReg
index|]
expr_stmt|;
name|error
operator|=
name|npe_ctx_reg_write
argument_list|(
name|sc
argument_list|,
name|i
argument_list|,
name|ctxtReg
argument_list|,
name|regVal
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: cannot write ctx reg,"
literal|"error %u\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|npe_cpu_step_restore
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
name|error
return|;
comment|/* abort reset */
block|}
block|}
block|}
name|npe_cpu_step_restore
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* write Reset values to Execution Context Stack registers */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N
argument_list|(
name|ixNpeDlEcsRegResetValues
argument_list|)
condition|;
name|i
operator|++
control|)
name|npe_ecs_reg_write
argument_list|(
name|sc
argument_list|,
name|ixNpeDlEcsRegResetValues
index|[
name|i
index|]
operator|.
name|regAddr
argument_list|,
name|ixNpeDlEcsRegResetValues
index|[
name|i
index|]
operator|.
name|regResetVal
argument_list|)
expr_stmt|;
comment|/* clear the profile counter */
name|npe_issue_cmd
argument_list|(
name|sc
argument_list|,
name|IX_NPEDL_EXCTL_CMD_CLR_PROFILE_CNT
argument_list|)
expr_stmt|;
comment|/* clear registers EXCT, AP0, AP1, AP2 and AP3 */
for|for
control|(
name|regAddr
operator|=
name|IX_NPEDL_REG_OFFSET_EXCT
init|;
name|regAddr
operator|<=
name|IX_NPEDL_REG_OFFSET_AP3
condition|;
name|regAddr
operator|+=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
control|)
name|npe_reg_write
argument_list|(
name|sc
argument_list|,
name|regAddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Reset the Watch-count register */
name|npe_reg_write
argument_list|(
name|sc
argument_list|,
name|IX_NPEDL_REG_OFFSET_WC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* 	 * WR IXA00055043 - Remove IMEM Parity Introduced by NPE Reset Operation 	 * XXX Removed because it breaks IXP435 operation; e.g. on Gateworks 	 * XXX 2358 boards reseting NPE-A after NPE-C is running causes both 	 * XXX npe's to stop working 	 */
block|npe_reset(sc->sc_npeid);
endif|#
directive|endif
comment|/* 	 * Call NpeMgr function to stop the NPE again after the Feature Control 	 * has unfused and Un-Reset the NPE and its associated Coprocessors. 	 */
name|error
operator|=
name|npe_cpu_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* restore NPE configuration bus Control Register - Parity Settings  */
name|npe_reg_write
argument_list|(
name|sc
argument_list|,
name|IX_NPEDL_REG_OFFSET_CTL
argument_list|,
operator|(
name|ixNpeConfigCtrlRegVal
operator|&
name|IX_NPEDL_CONFIG_CTRL_REG_MASK
operator|)
argument_list|)
expr_stmt|;
name|DPRINTFn
argument_list|(
literal|2
argument_list|,
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: restore CTL => 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|npe_reg_read
argument_list|(
name|sc
argument_list|,
name|IX_NPEDL_REG_OFFSET_CTL
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error
return|;
undef|#
directive|undef
name|N
block|}
end_function

begin_function
specifier|static
name|int
name|npe_cpu_start
parameter_list|(
name|struct
name|ixpnpe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|ecsRegVal
decl_stmt|;
comment|/* 	 * Ensure only Background Context Stack Level is Active by turning off 	 * the Active bit in each of the other Executing Context Stack levels. 	 */
name|ecsRegVal
operator|=
name|npe_ecs_reg_read
argument_list|(
name|sc
argument_list|,
name|IX_NPEDL_ECS_PRI_1_CTXT_REG_0
argument_list|)
expr_stmt|;
name|ecsRegVal
operator|&=
operator|~
name|IX_NPEDL_MASK_ECS_REG_0_ACTIVE
expr_stmt|;
name|npe_ecs_reg_write
argument_list|(
name|sc
argument_list|,
name|IX_NPEDL_ECS_PRI_1_CTXT_REG_0
argument_list|,
name|ecsRegVal
argument_list|)
expr_stmt|;
name|ecsRegVal
operator|=
name|npe_ecs_reg_read
argument_list|(
name|sc
argument_list|,
name|IX_NPEDL_ECS_PRI_2_CTXT_REG_0
argument_list|)
expr_stmt|;
name|ecsRegVal
operator|&=
operator|~
name|IX_NPEDL_MASK_ECS_REG_0_ACTIVE
expr_stmt|;
name|npe_ecs_reg_write
argument_list|(
name|sc
argument_list|,
name|IX_NPEDL_ECS_PRI_2_CTXT_REG_0
argument_list|,
name|ecsRegVal
argument_list|)
expr_stmt|;
name|ecsRegVal
operator|=
name|npe_ecs_reg_read
argument_list|(
name|sc
argument_list|,
name|IX_NPEDL_ECS_DBG_CTXT_REG_0
argument_list|)
expr_stmt|;
name|ecsRegVal
operator|&=
operator|~
name|IX_NPEDL_MASK_ECS_REG_0_ACTIVE
expr_stmt|;
name|npe_ecs_reg_write
argument_list|(
name|sc
argument_list|,
name|IX_NPEDL_ECS_DBG_CTXT_REG_0
argument_list|,
name|ecsRegVal
argument_list|)
expr_stmt|;
comment|/* clear the pipeline */
name|npe_issue_cmd
argument_list|(
name|sc
argument_list|,
name|IX_NPEDL_EXCTL_CMD_NPE_CLR_PIPE
argument_list|)
expr_stmt|;
comment|/* start NPE execution by issuing cmd through EXCTL register on NPE */
name|npe_issue_cmd
argument_list|(
name|sc
argument_list|,
name|IX_NPEDL_EXCTL_CMD_NPE_START
argument_list|)
expr_stmt|;
comment|/* 	 * Check execution status of NPE to verify operation was successful. 	 */
return|return
name|npe_checkbits
argument_list|(
name|sc
argument_list|,
name|IX_NPEDL_REG_OFFSET_EXCTL
argument_list|,
name|IX_NPEDL_EXCTL_STATUS_RUN
argument_list|)
condition|?
literal|0
else|:
name|EIO
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|npe_cpu_stop
parameter_list|(
name|struct
name|ixpnpe_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* stop NPE execution by issuing cmd through EXCTL register on NPE */
name|npe_issue_cmd
argument_list|(
name|sc
argument_list|,
name|IX_NPEDL_EXCTL_CMD_NPE_STOP
argument_list|)
expr_stmt|;
comment|/* verify that NPE Stop was successful */
return|return
name|npe_checkbits
argument_list|(
name|sc
argument_list|,
name|IX_NPEDL_REG_OFFSET_EXCTL
argument_list|,
name|IX_NPEDL_EXCTL_STATUS_STOP
argument_list|)
condition|?
literal|0
else|:
name|EIO
return|;
block|}
end_function

begin_define
define|#
directive|define
name|IX_NPEDL_REG_SIZE_BYTE
value|8
end_define

begin_define
define|#
directive|define
name|IX_NPEDL_REG_SIZE_SHORT
value|16
end_define

begin_define
define|#
directive|define
name|IX_NPEDL_REG_SIZE_WORD
value|32
end_define

begin_comment
comment|/*  * Introduce extra read cycles after issuing read command to NPE  * so that we read the register after the NPE has updated it  * This is to overcome race condition between XScale and NPE  */
end_comment

begin_define
define|#
directive|define
name|IX_NPEDL_DELAY_READ_CYCLES
value|2
end_define

begin_comment
comment|/*  * To mask top three MSBs of 32bit word to download into NPE IMEM  */
end_comment

begin_define
define|#
directive|define
name|IX_NPEDL_MASK_UNUSED_IMEM_BITS
value|0x1FFFFFFF;
end_define

begin_function
specifier|static
name|void
name|npe_cmd_issue_write
parameter_list|(
name|struct
name|ixpnpe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|cmd
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
name|uint32_t
name|data
parameter_list|)
block|{
name|npe_reg_write
argument_list|(
name|sc
argument_list|,
name|IX_NPEDL_REG_OFFSET_EXDATA
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|npe_reg_write
argument_list|(
name|sc
argument_list|,
name|IX_NPEDL_REG_OFFSET_EXAD
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|npe_reg_write
argument_list|(
name|sc
argument_list|,
name|IX_NPEDL_REG_OFFSET_EXCTL
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|npe_cmd_issue_read
parameter_list|(
name|struct
name|ixpnpe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|cmd
parameter_list|,
name|uint32_t
name|addr
parameter_list|)
block|{
name|uint32_t
name|data
decl_stmt|;
name|int
name|i
decl_stmt|;
name|npe_reg_write
argument_list|(
name|sc
argument_list|,
name|IX_NPEDL_REG_OFFSET_EXAD
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|npe_reg_write
argument_list|(
name|sc
argument_list|,
name|IX_NPEDL_REG_OFFSET_EXCTL
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|IX_NPEDL_DELAY_READ_CYCLES
condition|;
name|i
operator|++
control|)
name|data
operator|=
name|npe_reg_read
argument_list|(
name|sc
argument_list|,
name|IX_NPEDL_REG_OFFSET_EXDATA
argument_list|)
expr_stmt|;
return|return
name|data
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|npe_ins_write
parameter_list|(
name|struct
name|ixpnpe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
name|uint32_t
name|data
parameter_list|,
name|int
name|verify
parameter_list|)
block|{
name|DPRINTFn
argument_list|(
literal|4
argument_list|,
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s(0x%x, 0x%x)\n"
argument_list|,
name|__func__
argument_list|,
name|addr
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|npe_cmd_issue_write
argument_list|(
name|sc
argument_list|,
name|IX_NPEDL_EXCTL_CMD_WR_INS_MEM
argument_list|,
name|addr
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|verify
condition|)
block|{
name|uint32_t
name|rdata
decl_stmt|;
comment|/* 		 * Write invalid data to this reg, so we can see if we're 		 * reading the EXDATA register too early. 		 */
name|npe_reg_write
argument_list|(
name|sc
argument_list|,
name|IX_NPEDL_REG_OFFSET_EXDATA
argument_list|,
operator|~
name|data
argument_list|)
expr_stmt|;
comment|/* 		 * Disabled since top 3 MSB are not used for Azusa 		 * hardware Refer WR:IXA00053900 		 */
name|data
operator|&=
name|IX_NPEDL_MASK_UNUSED_IMEM_BITS
expr_stmt|;
name|rdata
operator|=
name|npe_cmd_issue_read
argument_list|(
name|sc
argument_list|,
name|IX_NPEDL_EXCTL_CMD_RD_INS_MEM
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|rdata
operator|&=
name|IX_NPEDL_MASK_UNUSED_IMEM_BITS
expr_stmt|;
if|if
condition|(
name|data
operator|!=
name|rdata
condition|)
return|return
name|EIO
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|npe_data_write
parameter_list|(
name|struct
name|ixpnpe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|addr
parameter_list|,
name|uint32_t
name|data
parameter_list|,
name|int
name|verify
parameter_list|)
block|{
name|DPRINTFn
argument_list|(
literal|4
argument_list|,
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s(0x%x, 0x%x)\n"
argument_list|,
name|__func__
argument_list|,
name|addr
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|npe_cmd_issue_write
argument_list|(
name|sc
argument_list|,
name|IX_NPEDL_EXCTL_CMD_WR_DATA_MEM
argument_list|,
name|addr
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|verify
condition|)
block|{
comment|/* 		 * Write invalid data to this reg, so we can see if we're 		 * reading the EXDATA register too early. 		 */
name|npe_reg_write
argument_list|(
name|sc
argument_list|,
name|IX_NPEDL_REG_OFFSET_EXDATA
argument_list|,
operator|~
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|!=
name|npe_cmd_issue_read
argument_list|(
name|sc
argument_list|,
name|IX_NPEDL_EXCTL_CMD_RD_DATA_MEM
argument_list|,
name|addr
argument_list|)
condition|)
return|return
name|EIO
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|npe_ecs_reg_write
parameter_list|(
name|struct
name|ixpnpe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|reg
parameter_list|,
name|uint32_t
name|data
parameter_list|)
block|{
name|npe_cmd_issue_write
argument_list|(
name|sc
argument_list|,
name|IX_NPEDL_EXCTL_CMD_WR_ECS_REG
argument_list|,
name|reg
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|npe_ecs_reg_read
parameter_list|(
name|struct
name|ixpnpe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|reg
parameter_list|)
block|{
return|return
name|npe_cmd_issue_read
argument_list|(
name|sc
argument_list|,
name|IX_NPEDL_EXCTL_CMD_RD_ECS_REG
argument_list|,
name|reg
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|npe_issue_cmd
parameter_list|(
name|struct
name|ixpnpe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|command
parameter_list|)
block|{
name|npe_reg_write
argument_list|(
name|sc
argument_list|,
name|IX_NPEDL_REG_OFFSET_EXCTL
argument_list|,
name|command
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|npe_cpu_step_save
parameter_list|(
name|struct
name|ixpnpe_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* turn off the halt bit by clearing Execution Count register. */
comment|/* save reg contents 1st and restore later */
name|sc
operator|->
name|savedExecCount
operator|=
name|npe_reg_read
argument_list|(
name|sc
argument_list|,
name|IX_NPEDL_REG_OFFSET_EXCT
argument_list|)
expr_stmt|;
name|npe_reg_write
argument_list|(
name|sc
argument_list|,
name|IX_NPEDL_REG_OFFSET_EXCT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* ensure that IF and IE are on (temporarily), so that we don't end up 	 * stepping forever */
name|sc
operator|->
name|savedEcsDbgCtxtReg2
operator|=
name|npe_ecs_reg_read
argument_list|(
name|sc
argument_list|,
name|IX_NPEDL_ECS_DBG_CTXT_REG_2
argument_list|)
expr_stmt|;
name|npe_ecs_reg_write
argument_list|(
name|sc
argument_list|,
name|IX_NPEDL_ECS_DBG_CTXT_REG_2
argument_list|,
operator|(
name|sc
operator|->
name|savedEcsDbgCtxtReg2
operator||
name|IX_NPEDL_MASK_ECS_DBG_REG_2_IF
operator||
name|IX_NPEDL_MASK_ECS_DBG_REG_2_IE
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|npe_cpu_step
parameter_list|(
name|struct
name|ixpnpe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|npeInstruction
parameter_list|,
name|uint32_t
name|ctxtNum
parameter_list|,
name|uint32_t
name|ldur
parameter_list|)
block|{
define|#
directive|define
name|IX_NPE_DL_MAX_NUM_OF_RETRIES
value|1000000
name|uint32_t
name|ecsDbgRegVal
decl_stmt|;
name|uint32_t
name|oldWatchcount
decl_stmt|,
name|newWatchcount
decl_stmt|;
name|int
name|tries
decl_stmt|;
comment|/* set the Active bit, and the LDUR, in the debug level */
name|ecsDbgRegVal
operator|=
name|IX_NPEDL_MASK_ECS_REG_0_ACTIVE
operator||
operator|(
name|ldur
operator|<<
name|IX_NPEDL_OFFSET_ECS_REG_0_LDUR
operator|)
expr_stmt|;
name|npe_ecs_reg_write
argument_list|(
name|sc
argument_list|,
name|IX_NPEDL_ECS_DBG_CTXT_REG_0
argument_list|,
name|ecsDbgRegVal
argument_list|)
expr_stmt|;
comment|/* 	 * Set CCTXT at ECS DEBUG L3 to specify in which context to execute the 	 * instruction, and set SELCTXT at ECS DEBUG Level to specify which 	 * context store to access. 	 * Debug ECS Level Reg 1 has form  0x000n000n, where n = context number 	 */
name|ecsDbgRegVal
operator|=
operator|(
name|ctxtNum
operator|<<
name|IX_NPEDL_OFFSET_ECS_REG_1_CCTXT
operator|)
operator||
operator|(
name|ctxtNum
operator|<<
name|IX_NPEDL_OFFSET_ECS_REG_1_SELCTXT
operator|)
expr_stmt|;
name|npe_ecs_reg_write
argument_list|(
name|sc
argument_list|,
name|IX_NPEDL_ECS_DBG_CTXT_REG_1
argument_list|,
name|ecsDbgRegVal
argument_list|)
expr_stmt|;
comment|/* clear the pipeline */
name|npe_issue_cmd
argument_list|(
name|sc
argument_list|,
name|IX_NPEDL_EXCTL_CMD_NPE_CLR_PIPE
argument_list|)
expr_stmt|;
comment|/* load NPE instruction into the instruction register */
name|npe_ecs_reg_write
argument_list|(
name|sc
argument_list|,
name|IX_NPEDL_ECS_INSTRUCT_REG
argument_list|,
name|npeInstruction
argument_list|)
expr_stmt|;
comment|/* need this value later to wait for completion of NPE execution step */
name|oldWatchcount
operator|=
name|npe_reg_read
argument_list|(
name|sc
argument_list|,
name|IX_NPEDL_REG_OFFSET_WC
argument_list|)
expr_stmt|;
comment|/* issue a Step One command via the Execution Control register */
name|npe_issue_cmd
argument_list|(
name|sc
argument_list|,
name|IX_NPEDL_EXCTL_CMD_NPE_STEP
argument_list|)
expr_stmt|;
comment|/* 	 * Force the XScale to wait until the NPE has finished execution step 	 * NOTE that this delay will be very small, just long enough to allow a 	 * single NPE instruction to complete execution; if instruction 	 * execution is not completed before timeout retries, exit the while 	 * loop. 	 */
name|newWatchcount
operator|=
name|npe_reg_read
argument_list|(
name|sc
argument_list|,
name|IX_NPEDL_REG_OFFSET_WC
argument_list|)
expr_stmt|;
for|for
control|(
name|tries
operator|=
literal|0
init|;
name|tries
operator|<
name|IX_NPE_DL_MAX_NUM_OF_RETRIES
operator|&&
name|newWatchcount
operator|==
name|oldWatchcount
condition|;
name|tries
operator|++
control|)
block|{
comment|/* Watch Count register incr's when NPE completes an inst */
name|newWatchcount
operator|=
name|npe_reg_read
argument_list|(
name|sc
argument_list|,
name|IX_NPEDL_REG_OFFSET_WC
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|tries
operator|<
name|IX_NPE_DL_MAX_NUM_OF_RETRIES
operator|)
condition|?
literal|0
else|:
name|EIO
return|;
undef|#
directive|undef
name|IX_NPE_DL_MAX_NUM_OF_RETRIES
block|}
end_function

begin_function
specifier|static
name|void
name|npe_cpu_step_restore
parameter_list|(
name|struct
name|ixpnpe_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* clear active bit in debug level */
name|npe_ecs_reg_write
argument_list|(
name|sc
argument_list|,
name|IX_NPEDL_ECS_DBG_CTXT_REG_0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* clear the pipeline */
name|npe_issue_cmd
argument_list|(
name|sc
argument_list|,
name|IX_NPEDL_EXCTL_CMD_NPE_CLR_PIPE
argument_list|)
expr_stmt|;
comment|/* restore Execution Count register contents. */
name|npe_reg_write
argument_list|(
name|sc
argument_list|,
name|IX_NPEDL_REG_OFFSET_EXCT
argument_list|,
name|sc
operator|->
name|savedExecCount
argument_list|)
expr_stmt|;
comment|/* restore IF and IE bits to original values */
name|npe_ecs_reg_write
argument_list|(
name|sc
argument_list|,
name|IX_NPEDL_ECS_DBG_CTXT_REG_2
argument_list|,
name|sc
operator|->
name|savedEcsDbgCtxtReg2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|npe_logical_reg_read
parameter_list|(
name|struct
name|ixpnpe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|regAddr
parameter_list|,
name|uint32_t
name|regSize
parameter_list|,
name|uint32_t
name|ctxtNum
parameter_list|,
name|uint32_t
modifier|*
name|regVal
parameter_list|)
block|{
name|uint32_t
name|npeInstruction
decl_stmt|,
name|mask
decl_stmt|;
name|int
name|error
decl_stmt|;
switch|switch
condition|(
name|regSize
condition|)
block|{
case|case
name|IX_NPEDL_REG_SIZE_BYTE
case|:
name|npeInstruction
operator|=
name|IX_NPEDL_INSTR_RD_REG_BYTE
expr_stmt|;
name|mask
operator|=
literal|0xff
expr_stmt|;
break|break;
case|case
name|IX_NPEDL_REG_SIZE_SHORT
case|:
name|npeInstruction
operator|=
name|IX_NPEDL_INSTR_RD_REG_SHORT
expr_stmt|;
name|mask
operator|=
literal|0xffff
expr_stmt|;
break|break;
case|case
name|IX_NPEDL_REG_SIZE_WORD
case|:
name|npeInstruction
operator|=
name|IX_NPEDL_INSTR_RD_REG_WORD
expr_stmt|;
name|mask
operator|=
literal|0xffffffff
expr_stmt|;
break|break;
default|default:
return|return
name|EINVAL
return|;
block|}
comment|/* make regAddr be the SRC and DEST operands (e.g. movX d0, d0) */
name|npeInstruction
operator||=
operator|(
name|regAddr
operator|<<
name|IX_NPEDL_OFFSET_INSTR_SRC
operator|)
operator||
operator|(
name|regAddr
operator|<<
name|IX_NPEDL_OFFSET_INSTR_DEST
operator|)
expr_stmt|;
comment|/* step execution of NPE inst using Debug Executing Context stack */
name|error
operator|=
name|npe_cpu_step
argument_list|(
name|sc
argument_list|,
name|npeInstruction
argument_list|,
name|ctxtNum
argument_list|,
name|IX_NPEDL_RD_INSTR_LDUR
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s(0x%x, %u, %u), cannot step, error %d\n"
argument_list|,
name|__func__
argument_list|,
name|regAddr
argument_list|,
name|regSize
argument_list|,
name|ctxtNum
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* read value of register from Execution Data register */
operator|*
name|regVal
operator|=
name|npe_reg_read
argument_list|(
name|sc
argument_list|,
name|IX_NPEDL_REG_OFFSET_EXDATA
argument_list|)
expr_stmt|;
comment|/* align value from left to right */
operator|*
name|regVal
operator|=
operator|(
operator|*
name|regVal
operator|>>
operator|(
name|IX_NPEDL_REG_SIZE_WORD
operator|-
name|regSize
operator|)
operator|)
operator|&
name|mask
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|npe_logical_reg_write
parameter_list|(
name|struct
name|ixpnpe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|regAddr
parameter_list|,
name|uint32_t
name|regVal
parameter_list|,
name|uint32_t
name|regSize
parameter_list|,
name|uint32_t
name|ctxtNum
parameter_list|,
name|int
name|verify
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|DPRINTFn
argument_list|(
literal|4
argument_list|,
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s(0x%x, 0x%x, %u, %u)\n"
argument_list|,
name|__func__
argument_list|,
name|regAddr
argument_list|,
name|regVal
argument_list|,
name|regSize
argument_list|,
name|ctxtNum
argument_list|)
expr_stmt|;
if|if
condition|(
name|regSize
operator|==
name|IX_NPEDL_REG_SIZE_WORD
condition|)
block|{
comment|/* 		 * NPE register addressing is left-to-right: e.g. |d0|d1|d2|d3| 		 * Write upper half-word (short) to |d0|d1| 		 */
name|error
operator|=
name|npe_logical_reg_write
argument_list|(
name|sc
argument_list|,
name|regAddr
argument_list|,
name|regVal
operator|>>
name|IX_NPEDL_REG_SIZE_SHORT
argument_list|,
name|IX_NPEDL_REG_SIZE_SHORT
argument_list|,
name|ctxtNum
argument_list|,
name|verify
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
comment|/* Write lower half-word (short) to |d2|d3| */
name|error
operator|=
name|npe_logical_reg_write
argument_list|(
name|sc
argument_list|,
name|regAddr
operator|+
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
argument_list|,
name|regVal
operator|&
literal|0xffff
argument_list|,
name|IX_NPEDL_REG_SIZE_SHORT
argument_list|,
name|ctxtNum
argument_list|,
name|verify
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|uint32_t
name|npeInstruction
decl_stmt|;
switch|switch
condition|(
name|regSize
condition|)
block|{
case|case
name|IX_NPEDL_REG_SIZE_BYTE
case|:
name|npeInstruction
operator|=
name|IX_NPEDL_INSTR_WR_REG_BYTE
expr_stmt|;
name|regVal
operator|&=
literal|0xff
expr_stmt|;
break|break;
case|case
name|IX_NPEDL_REG_SIZE_SHORT
case|:
name|npeInstruction
operator|=
name|IX_NPEDL_INSTR_WR_REG_SHORT
expr_stmt|;
name|regVal
operator|&=
literal|0xffff
expr_stmt|;
break|break;
default|default:
return|return
name|EINVAL
return|;
block|}
comment|/* fill dest operand field of inst with dest reg addr */
name|npeInstruction
operator||=
operator|(
name|regAddr
operator|<<
name|IX_NPEDL_OFFSET_INSTR_DEST
operator|)
expr_stmt|;
comment|/* fill src operand field of inst with least-sig 5 bits of val*/
name|npeInstruction
operator||=
operator|(
operator|(
name|regVal
operator|&
name|IX_NPEDL_MASK_IMMED_INSTR_SRC_DATA
operator|)
operator|<<
name|IX_NPEDL_OFFSET_INSTR_SRC
operator|)
expr_stmt|;
comment|/* fill coprocessor field of inst with most-sig 11 bits of val*/
name|npeInstruction
operator||=
operator|(
operator|(
name|regVal
operator|&
name|IX_NPEDL_MASK_IMMED_INSTR_COPROC_DATA
operator|)
operator|<<
name|IX_NPEDL_DISPLACE_IMMED_INSTR_COPROC_DATA
operator|)
expr_stmt|;
comment|/* step execution of NPE instruction using Debug ECS */
name|error
operator|=
name|npe_cpu_step
argument_list|(
name|sc
argument_list|,
name|npeInstruction
argument_list|,
name|ctxtNum
argument_list|,
name|IX_NPEDL_WR_INSTR_LDUR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s(0x%x, 0x%x, %u, %u), error %u "
literal|"writing reg\n"
argument_list|,
name|__func__
argument_list|,
name|regAddr
argument_list|,
name|regVal
argument_list|,
name|regSize
argument_list|,
name|ctxtNum
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
if|if
condition|(
name|verify
condition|)
block|{
name|uint32_t
name|retRegVal
decl_stmt|;
name|error
operator|=
name|npe_logical_reg_read
argument_list|(
name|sc
argument_list|,
name|regAddr
argument_list|,
name|regSize
argument_list|,
name|ctxtNum
argument_list|,
operator|&
name|retRegVal
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|regVal
operator|!=
name|retRegVal
condition|)
name|error
operator|=
name|EIO
expr_stmt|;
comment|/* XXX ambiguous */
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * There are 32 physical registers used in an NPE.  These are  * treated as 16 pairs of 32-bit registers.  To write one of the pair,  * write the pair number (0-16) to the REGMAP for Context 0.  Then write  * the value to register  0 or 4 in the regfile, depending on which  * register of the pair is to be written  */
end_comment

begin_function
specifier|static
name|int
name|npe_physical_reg_write
parameter_list|(
name|struct
name|ixpnpe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|regAddr
parameter_list|,
name|uint32_t
name|regValue
parameter_list|,
name|int
name|verify
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
comment|/* 	 * Set REGMAP for context 0 to (regAddr>> 1) to choose which pair 	 * (0-16) of physical registers to write . 	 */
name|error
operator|=
name|npe_logical_reg_write
argument_list|(
name|sc
argument_list|,
name|IX_NPEDL_CTXT_REG_ADDR_REGMAP
argument_list|,
operator|(
name|regAddr
operator|>>
name|IX_NPEDL_OFFSET_PHYS_REG_ADDR_REGMAP
operator|)
argument_list|,
name|IX_NPEDL_REG_SIZE_SHORT
argument_list|,
literal|0
argument_list|,
name|verify
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
comment|/* regAddr = 0 or 4  */
name|regAddr
operator|=
operator|(
name|regAddr
operator|&
name|IX_NPEDL_MASK_PHYS_REG_ADDR_LOGICAL_ADDR
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|error
operator|=
name|npe_logical_reg_write
argument_list|(
name|sc
argument_list|,
name|regAddr
argument_list|,
name|regValue
argument_list|,
name|IX_NPEDL_REG_SIZE_WORD
argument_list|,
literal|0
argument_list|,
name|verify
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|npe_ctx_reg_write
parameter_list|(
name|struct
name|ixpnpe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|ctxtNum
parameter_list|,
name|uint32_t
name|ctxtReg
parameter_list|,
name|uint32_t
name|ctxtRegVal
parameter_list|,
name|int
name|verify
parameter_list|)
block|{
name|DPRINTFn
argument_list|(
literal|4
argument_list|,
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s(%u, %u, %u)\n"
argument_list|,
name|__func__
argument_list|,
name|ctxtNum
argument_list|,
name|ctxtReg
argument_list|,
name|ctxtRegVal
argument_list|)
expr_stmt|;
comment|/* 	 * Context 0 has no STARTPC. Instead, this value is used to set 	 * NextPC for Background ECS, to set where NPE starts executing code 	 */
if|if
condition|(
name|ctxtNum
operator|==
literal|0
operator|&&
name|ctxtReg
operator|==
name|IX_NPEDL_CTXT_REG_STARTPC
condition|)
block|{
comment|/* read BG_CTXT_REG_0, update NEXTPC bits,& write back to reg*/
name|uint32_t
name|v
init|=
name|npe_ecs_reg_read
argument_list|(
name|sc
argument_list|,
name|IX_NPEDL_ECS_BG_CTXT_REG_0
argument_list|)
decl_stmt|;
name|v
operator|&=
operator|~
name|IX_NPEDL_MASK_ECS_REG_0_NEXTPC
expr_stmt|;
name|v
operator||=
operator|(
name|ctxtRegVal
operator|<<
name|IX_NPEDL_OFFSET_ECS_REG_0_NEXTPC
operator|)
operator|&
name|IX_NPEDL_MASK_ECS_REG_0_NEXTPC
expr_stmt|;
name|npe_ecs_reg_write
argument_list|(
name|sc
argument_list|,
name|IX_NPEDL_ECS_BG_CTXT_REG_0
argument_list|,
name|v
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
specifier|static
specifier|const
struct|struct
block|{
name|uint32_t
name|regAddress
decl_stmt|;
name|uint32_t
name|regSize
decl_stmt|;
block|}
name|regAccInfo
index|[
name|IX_NPEDL_CTXT_REG_MAX
index|]
init|=
block|{
block|{
name|IX_NPEDL_CTXT_REG_ADDR_STEVT
block|,
name|IX_NPEDL_REG_SIZE_BYTE
block|}
block|,
block|{
name|IX_NPEDL_CTXT_REG_ADDR_STARTPC
block|,
name|IX_NPEDL_REG_SIZE_SHORT
block|}
block|,
block|{
name|IX_NPEDL_CTXT_REG_ADDR_REGMAP
block|,
name|IX_NPEDL_REG_SIZE_SHORT
block|}
block|,
block|{
name|IX_NPEDL_CTXT_REG_ADDR_CINDEX
block|,
name|IX_NPEDL_REG_SIZE_BYTE
block|}
block|}
struct|;
return|return
name|npe_logical_reg_write
argument_list|(
name|sc
argument_list|,
name|regAccInfo
index|[
name|ctxtReg
index|]
operator|.
name|regAddress
argument_list|,
name|ctxtRegVal
argument_list|,
name|regAccInfo
index|[
name|ctxtReg
index|]
operator|.
name|regSize
argument_list|,
name|ctxtNum
argument_list|,
name|verify
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * NPE Mailbox support.  */
end_comment

begin_define
define|#
directive|define
name|IX_NPEMH_MAXTRIES
value|100000
end_define

begin_function
specifier|static
name|int
name|ofifo_wait
parameter_list|(
name|struct
name|ixpnpe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IX_NPEMH_MAXTRIES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|npe_reg_read
argument_list|(
name|sc
argument_list|,
name|IX_NPESTAT
argument_list|)
operator|&
name|IX_NPESTAT_OFNE
condition|)
return|return
literal|1
return|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: timeout, last status 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|npe_reg_read
argument_list|(
name|sc
argument_list|,
name|IX_NPESTAT
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|getmsg
parameter_list|(
name|struct
name|ixpnpe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|msg
index|[
literal|2
index|]
parameter_list|)
block|{
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ofifo_wait
argument_list|(
name|sc
argument_list|)
condition|)
return|return
name|EAGAIN
return|;
name|msg
index|[
literal|0
index|]
operator|=
name|npe_reg_read
argument_list|(
name|sc
argument_list|,
name|IX_NPEFIFO
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: msg0 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|msg
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ofifo_wait
argument_list|(
name|sc
argument_list|)
condition|)
return|return
name|EAGAIN
return|;
name|msg
index|[
literal|1
index|]
operator|=
name|npe_reg_read
argument_list|(
name|sc
argument_list|,
name|IX_NPEFIFO
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: msg1 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|msg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ixpnpe_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ixpnpe_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|uint32_t
name|status
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
name|status
operator|=
name|npe_reg_read
argument_list|(
name|sc
argument_list|,
name|IX_NPESTAT
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: status 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|IX_NPESTAT_OFINT
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* NB: should not happen */
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: status 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|status
argument_list|)
expr_stmt|;
comment|/* XXX must silence interrupt? */
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * A message is waiting in the output FIFO, copy it so 	 * the interrupt will be silenced. 	 */
if|if
condition|(
name|getmsg
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_msg
argument_list|)
operator|==
literal|0
condition|)
name|sc
operator|->
name|sc_msgwaiting
operator|=
literal|1
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ififo_wait
parameter_list|(
name|struct
name|ixpnpe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IX_NPEMH_MAXTRIES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|npe_reg_read
argument_list|(
name|sc
argument_list|,
name|IX_NPESTAT
argument_list|)
operator|&
name|IX_NPESTAT_IFNF
condition|)
return|return
literal|1
return|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: timeout, last status 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|npe_reg_read
argument_list|(
name|sc
argument_list|,
name|IX_NPESTAT
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|putmsg
parameter_list|(
name|struct
name|ixpnpe_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|uint32_t
name|msg
index|[
literal|2
index|]
parameter_list|)
block|{
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: msg 0x%x:0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|msg
index|[
literal|0
index|]
argument_list|,
name|msg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ififo_wait
argument_list|(
name|sc
argument_list|)
condition|)
return|return
name|EIO
return|;
name|npe_reg_write
argument_list|(
name|sc
argument_list|,
name|IX_NPEFIFO
argument_list|,
name|msg
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ififo_wait
argument_list|(
name|sc
argument_list|)
condition|)
return|return
name|EIO
return|;
name|npe_reg_write
argument_list|(
name|sc
argument_list|,
name|IX_NPEFIFO
argument_list|,
name|msg
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Send a msg to the NPE and wait for a reply.  We spin as  * we may be called early with interrupts not properly setup.  */
end_comment

begin_function
name|int
name|ixpnpe_sendandrecvmsg_sync
parameter_list|(
name|struct
name|ixpnpe_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|uint32_t
name|send
index|[
literal|2
index|]
parameter_list|,
name|uint32_t
name|recv
index|[
literal|2
index|]
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
name|error
operator|=
name|putmsg
argument_list|(
name|sc
argument_list|,
name|send
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|getmsg
argument_list|(
name|sc
argument_list|,
name|recv
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Send a msg to the NPE w/o waiting for a reply.  */
end_comment

begin_function
name|int
name|ixpnpe_sendmsg_async
parameter_list|(
name|struct
name|ixpnpe_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|uint32_t
name|msg
index|[
literal|2
index|]
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
name|error
operator|=
name|putmsg
argument_list|(
name|sc
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|recvmsg_locked
parameter_list|(
name|struct
name|ixpnpe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|msg
index|[
literal|2
index|]
parameter_list|)
block|{
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s: msgwaiting %d\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|sc_msgwaiting
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_msgwaiting
condition|)
block|{
name|msg
index|[
literal|0
index|]
operator|=
name|sc
operator|->
name|sc_msg
index|[
literal|0
index|]
expr_stmt|;
name|msg
index|[
literal|1
index|]
operator|=
name|sc
operator|->
name|sc_msg
index|[
literal|1
index|]
expr_stmt|;
name|sc
operator|->
name|sc_msgwaiting
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|EAGAIN
return|;
block|}
end_function

begin_comment
comment|/*  * Receive any msg previously received from the NPE. If nothing  * is available we return EAGAIN and the caller is required to  * do a synchronous receive or try again later.  */
end_comment

begin_function
name|int
name|ixpnpe_recvmsg_async
parameter_list|(
name|struct
name|ixpnpe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|msg
index|[
literal|2
index|]
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
name|error
operator|=
name|recvmsg_locked
argument_list|(
name|sc
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Receive a msg from the NPE.  If one was received asynchronously  * then it's returned; otherwise we poll synchronously.  */
end_comment

begin_function
name|int
name|ixpnpe_recvmsg_sync
parameter_list|(
name|struct
name|ixpnpe_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|msg
index|[
literal|2
index|]
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
name|error
operator|=
name|recvmsg_locked
argument_list|(
name|sc
argument_list|,
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EAGAIN
condition|)
name|error
operator|=
name|getmsg
argument_list|(
name|sc
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

end_unit

