begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2006 Sam Leffler, Errno Consulting  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    similar to the "NO WARRANTY" disclaimer below ("Disclaimer") and any  *    redistribution must be conditioned upon including a substantially  *    similar Disclaimer requirement for further binary redistribution.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTIBILITY  * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL  * THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY,  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER  * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Compact Flash Support for the Avila Gateworks XScale boards.  * The CF slot is operated in "True IDE" mode. Registers are on  * the Expansion Bus connected to CS1 and CS2. Interrupts are  * tied to GPIO pin 12.  No DMA, just PIO.  *  * The ADI Pronghorn Metro is very similar. It use CS3 and CS4 and  * GPIO pin 0 for interrupts.  *  * See also http://www.intel.com/design/network/applnots/302456.htm.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpufunc.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<machine/intr.h>
end_include

begin_include
include|#
directive|include
file|<arm/xscale/ixp425/ixp425reg.h>
end_include

begin_include
include|#
directive|include
file|<arm/xscale/ixp425/ixp425var.h>
end_include

begin_include
include|#
directive|include
file|<sys/ata.h>
end_include

begin_include
include|#
directive|include
file|<sys/sema.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<dev/ata/ata-all.h>
end_include

begin_include
include|#
directive|include
file|<ata_if.h>
end_include

begin_define
define|#
directive|define
name|AVILA_IDE_CTRL
value|0x06
end_define

begin_struct
struct|struct
name|ata_config
block|{
specifier|const
name|char
modifier|*
name|desc
decl_stmt|;
comment|/* description for probe */
name|uint8_t
name|gpin
decl_stmt|;
comment|/* GPIO pin */
name|uint8_t
name|irq
decl_stmt|;
comment|/* IRQ */
name|uint32_t
name|base16
decl_stmt|;
comment|/* CS base addr for 16-bit */
name|uint32_t
name|size16
decl_stmt|;
comment|/* CS size for 16-bit */
name|uint32_t
name|off16
decl_stmt|;
comment|/* CS offset for 16-bit */
name|uint32_t
name|basealt
decl_stmt|;
comment|/* CS base addr for alt */
name|uint32_t
name|sizealt
decl_stmt|;
comment|/* CS size for alt */
name|uint32_t
name|offalt
decl_stmt|;
comment|/* CS offset for alt */
block|}
struct|;
end_struct

begin_function
specifier|static
specifier|const
name|struct
name|ata_config
modifier|*
name|ata_getconfig
parameter_list|(
name|struct
name|ixp425_softc
modifier|*
name|sa
parameter_list|)
block|{
specifier|static
specifier|const
name|struct
name|ata_config
name|configs
index|[]
init|=
block|{
block|{
operator|.
name|desc
operator|=
literal|"Gateworks Avila IDE/CF Controller"
block|,
operator|.
name|gpin
operator|=
literal|12
block|,
operator|.
name|irq
operator|=
name|IXP425_INT_GPIO_12
block|,
operator|.
name|base16
operator|=
name|IXP425_EXP_BUS_CS1_HWBASE
block|,
operator|.
name|size16
operator|=
name|IXP425_EXP_BUS_CS1_SIZE
block|,
operator|.
name|off16
operator|=
name|EXP_TIMING_CS1_OFFSET
block|,
operator|.
name|basealt
operator|=
name|IXP425_EXP_BUS_CS2_HWBASE
block|,
operator|.
name|sizealt
operator|=
name|IXP425_EXP_BUS_CS2_SIZE
block|,
operator|.
name|offalt
operator|=
name|EXP_TIMING_CS2_OFFSET
block|, 		}
block|,
block|{
operator|.
name|desc
operator|=
literal|"Gateworks Cambria IDE/CF Controller"
block|,
operator|.
name|gpin
operator|=
literal|12
block|,
operator|.
name|irq
operator|=
name|IXP425_INT_GPIO_12
block|,
operator|.
name|base16
operator|=
name|CAMBRIA_CFSEL0_HWBASE
block|,
operator|.
name|size16
operator|=
name|CAMBRIA_CFSEL0_SIZE
block|,
operator|.
name|off16
operator|=
name|EXP_TIMING_CS3_OFFSET
block|,
operator|.
name|basealt
operator|=
name|CAMBRIA_CFSEL1_HWBASE
block|,
operator|.
name|sizealt
operator|=
name|CAMBRIA_CFSEL1_SIZE
block|,
operator|.
name|offalt
operator|=
name|EXP_TIMING_CS4_OFFSET
block|, 		}
block|,
block|{
operator|.
name|desc
operator|=
literal|"ADI Pronghorn Metro IDE/CF Controller"
block|,
operator|.
name|gpin
operator|=
literal|0
block|,
operator|.
name|irq
operator|=
name|IXP425_INT_GPIO_0
block|,
operator|.
name|base16
operator|=
name|IXP425_EXP_BUS_CS3_HWBASE
block|,
operator|.
name|size16
operator|=
name|IXP425_EXP_BUS_CS3_SIZE
block|,
operator|.
name|off16
operator|=
name|EXP_TIMING_CS3_OFFSET
block|,
operator|.
name|basealt
operator|=
name|IXP425_EXP_BUS_CS4_HWBASE
block|,
operator|.
name|sizealt
operator|=
name|IXP425_EXP_BUS_CS4_SIZE
block|,
operator|.
name|offalt
operator|=
name|EXP_TIMING_CS4_OFFSET
block|, 		}
block|, 	}
decl_stmt|;
comment|/* XXX honor hint? (but then no multi-board support) */
comment|/* XXX total hack */
if|if
condition|(
name|cpu_is_ixp43x
argument_list|()
condition|)
return|return
operator|&
name|configs
index|[
literal|1
index|]
return|;
comment|/* Cambria */
if|if
condition|(
name|EXP_BUS_READ_4
argument_list|(
name|sa
argument_list|,
name|EXP_TIMING_CS2_OFFSET
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|&
name|configs
index|[
literal|0
index|]
return|;
comment|/* Avila */
return|return
operator|&
name|configs
index|[
literal|2
index|]
return|;
comment|/* Pronghorn */
block|}
end_function

begin_struct
struct|struct
name|ata_avila_softc
block|{
name|device_t
name|sc_dev
decl_stmt|;
name|bus_space_tag_t
name|sc_iot
decl_stmt|;
name|bus_space_handle_t
name|sc_exp_ioh
decl_stmt|;
comment|/* Exp Bus config registers */
name|bus_space_handle_t
name|sc_ioh
decl_stmt|;
comment|/* CS1/3 data registers */
name|bus_space_handle_t
name|sc_alt_ioh
decl_stmt|;
comment|/* CS2/4 data registers */
name|struct
name|bus_space
name|sc_expbus_tag
decl_stmt|;
name|struct
name|resource
name|sc_ata
decl_stmt|;
comment|/* hand-crafted for ATA */
name|struct
name|resource
name|sc_alt_ata
decl_stmt|;
comment|/* hand-crafted for ATA */
name|u_int32_t
name|sc_16bit_off
decl_stmt|;
comment|/* EXP_TIMING_CSx_OFFSET */
name|int
name|sc_rid
decl_stmt|;
comment|/* rid for IRQ */
name|struct
name|resource
modifier|*
name|sc_irq
decl_stmt|;
comment|/* IRQ resource */
name|void
modifier|*
name|sc_ih
decl_stmt|;
comment|/* interrupt handler */
struct|struct
block|{
name|void
function_decl|(
modifier|*
name|cb
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
name|void
modifier|*
name|arg
decl_stmt|;
block|}
name|sc_intr
index|[
literal|1
index|]
struct|;
comment|/* NB: 1/channel */
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|ata_avila_intr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|bs_protos
argument_list|(
name|ata
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|void
name|ata_bs_rm_2_s
parameter_list|(
name|bus_space_tag_t
name|tag
parameter_list|,
name|bus_space_handle_t
parameter_list|,
name|bus_size_t
parameter_list|,
name|u_int16_t
modifier|*
parameter_list|,
name|bus_size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ata_bs_wm_2_s
parameter_list|(
name|bus_space_tag_t
name|tag
parameter_list|,
name|bus_space_handle_t
parameter_list|,
name|bus_size_t
parameter_list|,
specifier|const
name|u_int16_t
modifier|*
parameter_list|,
name|bus_size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|ata_avila_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ixp425_softc
modifier|*
name|sa
init|=
name|device_get_softc
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|struct
name|ata_config
modifier|*
name|config
decl_stmt|;
name|config
operator|=
name|ata_getconfig
argument_list|(
name|sa
argument_list|)
expr_stmt|;
if|if
condition|(
name|config
operator|!=
name|NULL
condition|)
block|{
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
name|config
operator|->
name|desc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|ENXIO
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ata_avila_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ata_avila_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ixp425_softc
modifier|*
name|sa
init|=
name|device_get_softc
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|struct
name|ata_config
modifier|*
name|config
decl_stmt|;
name|config
operator|=
name|ata_getconfig
argument_list|(
name|sa
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|config
operator|!=
name|NULL
argument_list|,
operator|(
literal|"no board config"
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_dev
operator|=
name|dev
expr_stmt|;
comment|/* NB: borrow from parent */
name|sc
operator|->
name|sc_iot
operator|=
name|sa
operator|->
name|sc_iot
expr_stmt|;
name|sc
operator|->
name|sc_exp_ioh
operator|=
name|sa
operator|->
name|sc_exp_ioh
expr_stmt|;
if|if
condition|(
name|bus_space_map
argument_list|(
name|sc
operator|->
name|sc_iot
argument_list|,
name|config
operator|->
name|base16
argument_list|,
name|config
operator|->
name|size16
argument_list|,
literal|0
argument_list|,
operator|&
name|sc
operator|->
name|sc_ioh
argument_list|)
condition|)
name|panic
argument_list|(
literal|"%s: cannot map 16-bit window (0x%x/0x%x)"
argument_list|,
name|__func__
argument_list|,
name|config
operator|->
name|base16
argument_list|,
name|config
operator|->
name|size16
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus_space_map
argument_list|(
name|sc
operator|->
name|sc_iot
argument_list|,
name|config
operator|->
name|basealt
argument_list|,
name|config
operator|->
name|sizealt
argument_list|,
literal|0
argument_list|,
operator|&
name|sc
operator|->
name|sc_alt_ioh
argument_list|)
condition|)
name|panic
argument_list|(
literal|"%s: cannot map alt window (0x%x/0x%x)"
argument_list|,
name|__func__
argument_list|,
name|config
operator|->
name|basealt
argument_list|,
name|config
operator|->
name|sizealt
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_16bit_off
operator|=
name|config
operator|->
name|off16
expr_stmt|;
if|if
condition|(
name|config
operator|->
name|base16
operator|!=
name|CAMBRIA_CFSEL0_HWBASE
condition|)
block|{
comment|/* 		 * Craft special resource for ATA bus space ops 		 * that go through the expansion bus and require 		 * special hackery to ena/dis 16-bit operations. 		 * 		 * XXX probably should just make this generic for 		 * accessing the expansion bus. 		 */
name|sc
operator|->
name|sc_expbus_tag
operator|.
name|bs_privdata
operator|=
name|sc
expr_stmt|;
comment|/* NB: backpointer */
comment|/* read single */
name|sc
operator|->
name|sc_expbus_tag
operator|.
name|bs_r_1
operator|=
name|ata_bs_r_1
expr_stmt|;
name|sc
operator|->
name|sc_expbus_tag
operator|.
name|bs_r_2
operator|=
name|ata_bs_r_2
expr_stmt|;
comment|/* read multiple */
name|sc
operator|->
name|sc_expbus_tag
operator|.
name|bs_rm_2
operator|=
name|ata_bs_rm_2
expr_stmt|;
name|sc
operator|->
name|sc_expbus_tag
operator|.
name|bs_rm_2_s
operator|=
name|ata_bs_rm_2_s
expr_stmt|;
comment|/* write (single) */
name|sc
operator|->
name|sc_expbus_tag
operator|.
name|bs_w_1
operator|=
name|ata_bs_w_1
expr_stmt|;
name|sc
operator|->
name|sc_expbus_tag
operator|.
name|bs_w_2
operator|=
name|ata_bs_w_2
expr_stmt|;
comment|/* write multiple */
name|sc
operator|->
name|sc_expbus_tag
operator|.
name|bs_wm_2
operator|=
name|ata_bs_wm_2
expr_stmt|;
name|sc
operator|->
name|sc_expbus_tag
operator|.
name|bs_wm_2_s
operator|=
name|ata_bs_wm_2_s
expr_stmt|;
name|rman_set_bustag
argument_list|(
operator|&
name|sc
operator|->
name|sc_ata
argument_list|,
operator|&
name|sc
operator|->
name|sc_expbus_tag
argument_list|)
expr_stmt|;
name|rman_set_bustag
argument_list|(
operator|&
name|sc
operator|->
name|sc_alt_ata
argument_list|,
operator|&
name|sc
operator|->
name|sc_expbus_tag
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * On Cambria use the shared CS3 expansion bus tag 		 * that handles interlock for sharing access with the 		 * optional UART's. 		 */
name|rman_set_bustag
argument_list|(
operator|&
name|sc
operator|->
name|sc_ata
argument_list|,
operator|&
name|cambria_exp_bs_tag
argument_list|)
expr_stmt|;
name|rman_set_bustag
argument_list|(
operator|&
name|sc
operator|->
name|sc_alt_ata
argument_list|,
operator|&
name|cambria_exp_bs_tag
argument_list|)
expr_stmt|;
block|}
name|rman_set_bushandle
argument_list|(
operator|&
name|sc
operator|->
name|sc_ata
argument_list|,
name|sc
operator|->
name|sc_ioh
argument_list|)
expr_stmt|;
name|rman_set_bushandle
argument_list|(
operator|&
name|sc
operator|->
name|sc_alt_ata
argument_list|,
name|sc
operator|->
name|sc_alt_ioh
argument_list|)
expr_stmt|;
name|ixp425_set_gpio
argument_list|(
name|sa
argument_list|,
name|config
operator|->
name|gpin
argument_list|,
name|GPIO_TYPE_EDG_RISING
argument_list|)
expr_stmt|;
comment|/* configure CS1/3 window, leaving timing unchanged */
name|EXP_BUS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_16bit_off
argument_list|,
name|EXP_BUS_READ_4
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_16bit_off
argument_list|)
operator||
name|EXP_BYTE_EN
operator||
name|EXP_WR_EN
operator||
name|EXP_BYTE_RD16
operator||
name|EXP_CS_EN
argument_list|)
expr_stmt|;
comment|/* configure CS2/4 window, leaving timing unchanged */
name|EXP_BUS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|config
operator|->
name|offalt
argument_list|,
name|EXP_BUS_READ_4
argument_list|(
name|sc
argument_list|,
name|config
operator|->
name|offalt
argument_list|)
operator||
name|EXP_BYTE_EN
operator||
name|EXP_WR_EN
operator||
name|EXP_BYTE_RD16
operator||
name|EXP_CS_EN
argument_list|)
expr_stmt|;
comment|/* setup interrupt */
name|sc
operator|->
name|sc_irq
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|sc
operator|->
name|sc_rid
argument_list|,
name|config
operator|->
name|irq
argument_list|,
name|config
operator|->
name|irq
argument_list|,
literal|1
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_irq
condition|)
name|panic
argument_list|(
literal|"Unable to allocate irq %u.\n"
argument_list|,
name|config
operator|->
name|irq
argument_list|)
expr_stmt|;
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|sc_irq
argument_list|,
name|INTR_TYPE_BIO
operator||
name|INTR_MPSAFE
operator||
name|INTR_ENTROPY
argument_list|,
name|NULL
argument_list|,
name|ata_avila_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_ih
argument_list|)
expr_stmt|;
comment|/* attach channel on this controller */
name|device_add_child
argument_list|(
name|dev
argument_list|,
literal|"ata"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|bus_generic_attach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ata_avila_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ata_avila_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
comment|/* XXX quiesce gpio? */
comment|/* detach& delete all children */
name|device_delete_children
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|sc_irq
argument_list|,
name|sc
operator|->
name|sc_ih
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|sc_rid
argument_list|,
name|sc
operator|->
name|sc_irq
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ata_avila_intr
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|ata_avila_softc
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_intr
index|[
literal|0
index|]
operator|.
name|cb
operator|!=
name|NULL
condition|)
name|sc
operator|->
name|sc_intr
index|[
literal|0
index|]
operator|.
name|cb
argument_list|(
name|sc
operator|->
name|sc_intr
index|[
literal|0
index|]
operator|.
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|resource
modifier|*
name|ata_avila_alloc_resource
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
modifier|*
name|rid
parameter_list|,
name|u_long
name|start
parameter_list|,
name|u_long
name|end
parameter_list|,
name|u_long
name|count
parameter_list|,
name|u_int
name|flags
parameter_list|)
block|{
name|struct
name|ata_avila_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|KASSERT
argument_list|(
name|type
operator|==
name|SYS_RES_IRQ
operator|&&
operator|*
name|rid
operator|==
name|ATA_IRQ_RID
argument_list|,
operator|(
literal|"type %u rid %u start %lu end %lu count %lu flags %u"
operator|,
name|type
operator|,
operator|*
name|rid
operator|,
name|start
operator|,
name|end
operator|,
name|count
operator|,
name|flags
operator|)
argument_list|)
expr_stmt|;
comment|/* doesn't matter what we return so reuse the real thing */
return|return
name|sc
operator|->
name|sc_irq
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ata_avila_release_resource
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|struct
name|resource
modifier|*
name|r
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|type
operator|==
name|SYS_RES_IRQ
operator|&&
name|rid
operator|==
name|ATA_IRQ_RID
argument_list|,
operator|(
literal|"type %u rid %u"
operator|,
name|type
operator|,
name|rid
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ata_avila_setup_intr
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|struct
name|resource
modifier|*
name|irq
parameter_list|,
name|int
name|flags
parameter_list|,
name|driver_filter_t
modifier|*
name|filt
parameter_list|,
name|driver_intr_t
modifier|*
name|function
parameter_list|,
name|void
modifier|*
name|argument
parameter_list|,
name|void
modifier|*
modifier|*
name|cookiep
parameter_list|)
block|{
name|struct
name|ata_avila_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|unit
init|=
operator|(
operator|(
expr|struct
name|ata_channel
operator|*
operator|)
name|device_get_softc
argument_list|(
name|child
argument_list|)
operator|)
operator|->
name|unit
decl_stmt|;
name|KASSERT
argument_list|(
name|unit
operator|==
literal|0
argument_list|,
operator|(
literal|"unit %d"
operator|,
name|unit
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_intr
index|[
name|unit
index|]
operator|.
name|cb
operator|=
name|function
expr_stmt|;
name|sc
operator|->
name|sc_intr
index|[
name|unit
index|]
operator|.
name|arg
operator|=
name|argument
expr_stmt|;
operator|*
name|cookiep
operator|=
name|sc
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ata_avila_teardown_intr
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|struct
name|resource
modifier|*
name|irq
parameter_list|,
name|void
modifier|*
name|cookie
parameter_list|)
block|{
name|struct
name|ata_avila_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|unit
init|=
operator|(
operator|(
expr|struct
name|ata_channel
operator|*
operator|)
name|device_get_softc
argument_list|(
name|child
argument_list|)
operator|)
operator|->
name|unit
decl_stmt|;
name|KASSERT
argument_list|(
name|unit
operator|==
literal|0
argument_list|,
operator|(
literal|"unit %d"
operator|,
name|unit
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_intr
index|[
name|unit
index|]
operator|.
name|cb
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_intr
index|[
name|unit
index|]
operator|.
name|arg
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Bus space accessors for CF-IDE PIO operations.  */
end_comment

begin_comment
comment|/*  * Enable/disable 16-bit ops on the expansion bus.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|enable_16
parameter_list|(
name|struct
name|ata_avila_softc
modifier|*
name|sc
parameter_list|)
block|{
name|EXP_BUS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_16bit_off
argument_list|,
name|EXP_BUS_READ_4
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_16bit_off
argument_list|)
operator|&
operator|~
name|EXP_BYTE_EN
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* XXX? */
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|disable_16
parameter_list|(
name|struct
name|ata_avila_softc
modifier|*
name|sc
parameter_list|)
block|{
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* XXX? */
name|EXP_BUS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_16bit_off
argument_list|,
name|EXP_BUS_READ_4
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_16bit_off
argument_list|)
operator||
name|EXP_BYTE_EN
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|uint8_t
name|ata_bs_r_1
parameter_list|(
name|bus_space_tag_t
name|tag
parameter_list|,
name|bus_space_handle_t
name|h
parameter_list|,
name|bus_size_t
name|o
parameter_list|)
block|{
name|struct
name|ata_avila_softc
modifier|*
name|sc
init|=
name|tag
operator|->
name|bs_privdata
decl_stmt|;
return|return
name|bus_space_read_1
argument_list|(
name|sc
operator|->
name|sc_iot
argument_list|,
name|h
argument_list|,
name|o
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|ata_bs_w_1
parameter_list|(
name|bus_space_tag_t
name|tag
parameter_list|,
name|bus_space_handle_t
name|h
parameter_list|,
name|bus_size_t
name|o
parameter_list|,
name|u_int8_t
name|v
parameter_list|)
block|{
name|struct
name|ata_avila_softc
modifier|*
name|sc
init|=
name|tag
operator|->
name|bs_privdata
decl_stmt|;
name|bus_space_write_1
argument_list|(
name|sc
operator|->
name|sc_iot
argument_list|,
name|h
argument_list|,
name|o
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|uint16_t
name|ata_bs_r_2
parameter_list|(
name|bus_space_tag_t
name|tag
parameter_list|,
name|bus_space_handle_t
name|h
parameter_list|,
name|bus_size_t
name|o
parameter_list|)
block|{
name|struct
name|ata_avila_softc
modifier|*
name|sc
init|=
name|tag
operator|->
name|bs_privdata
decl_stmt|;
name|uint16_t
name|v
decl_stmt|;
name|enable_16
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|v
operator|=
name|bus_space_read_2
argument_list|(
name|sc
operator|->
name|sc_iot
argument_list|,
name|h
argument_list|,
name|o
argument_list|)
expr_stmt|;
name|disable_16
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_function
name|void
name|ata_bs_w_2
parameter_list|(
name|bus_space_tag_t
name|tag
parameter_list|,
name|bus_space_handle_t
name|h
parameter_list|,
name|bus_size_t
name|o
parameter_list|,
name|uint16_t
name|v
parameter_list|)
block|{
name|struct
name|ata_avila_softc
modifier|*
name|sc
init|=
name|tag
operator|->
name|bs_privdata
decl_stmt|;
name|enable_16
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bus_space_write_2
argument_list|(
name|sc
operator|->
name|sc_iot
argument_list|,
name|h
argument_list|,
name|o
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|disable_16
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ata_bs_rm_2
parameter_list|(
name|bus_space_tag_t
name|tag
parameter_list|,
name|bus_space_handle_t
name|h
parameter_list|,
name|bus_size_t
name|o
parameter_list|,
name|u_int16_t
modifier|*
name|d
parameter_list|,
name|bus_size_t
name|c
parameter_list|)
block|{
name|struct
name|ata_avila_softc
modifier|*
name|sc
init|=
name|tag
operator|->
name|bs_privdata
decl_stmt|;
name|enable_16
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bus_space_read_multi_2
argument_list|(
name|sc
operator|->
name|sc_iot
argument_list|,
name|h
argument_list|,
name|o
argument_list|,
name|d
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|disable_16
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ata_bs_wm_2
parameter_list|(
name|bus_space_tag_t
name|tag
parameter_list|,
name|bus_space_handle_t
name|h
parameter_list|,
name|bus_size_t
name|o
parameter_list|,
specifier|const
name|u_int16_t
modifier|*
name|d
parameter_list|,
name|bus_size_t
name|c
parameter_list|)
block|{
name|struct
name|ata_avila_softc
modifier|*
name|sc
init|=
name|tag
operator|->
name|bs_privdata
decl_stmt|;
name|enable_16
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bus_space_write_multi_2
argument_list|(
name|sc
operator|->
name|sc_iot
argument_list|,
name|h
argument_list|,
name|o
argument_list|,
name|d
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|disable_16
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* XXX workaround ata driver by (incorrectly) byte swapping stream cases */
end_comment

begin_function
name|void
name|ata_bs_rm_2_s
parameter_list|(
name|bus_space_tag_t
name|tag
parameter_list|,
name|bus_space_handle_t
name|h
parameter_list|,
name|bus_size_t
name|o
parameter_list|,
name|u_int16_t
modifier|*
name|d
parameter_list|,
name|bus_size_t
name|c
parameter_list|)
block|{
name|struct
name|ata_avila_softc
modifier|*
name|sc
init|=
name|tag
operator|->
name|bs_privdata
decl_stmt|;
name|uint16_t
name|v
decl_stmt|;
name|bus_size_t
name|i
decl_stmt|;
name|enable_16
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|c
condition|;
name|i
operator|++
control|)
block|{
name|v
operator|=
name|bus_space_read_2
argument_list|(
name|sc
operator|->
name|sc_iot
argument_list|,
name|h
argument_list|,
name|o
argument_list|)
expr_stmt|;
name|d
index|[
name|i
index|]
operator|=
name|bswap16
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|bus_space_read_multi_stream_2
argument_list|(
name|sc
operator|->
name|sc_iot
argument_list|,
name|h
argument_list|,
name|o
argument_list|,
name|d
argument_list|,
name|c
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|disable_16
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ata_bs_wm_2_s
parameter_list|(
name|bus_space_tag_t
name|tag
parameter_list|,
name|bus_space_handle_t
name|h
parameter_list|,
name|bus_size_t
name|o
parameter_list|,
specifier|const
name|u_int16_t
modifier|*
name|d
parameter_list|,
name|bus_size_t
name|c
parameter_list|)
block|{
name|struct
name|ata_avila_softc
modifier|*
name|sc
init|=
name|tag
operator|->
name|bs_privdata
decl_stmt|;
name|bus_size_t
name|i
decl_stmt|;
name|enable_16
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|c
condition|;
name|i
operator|++
control|)
name|bus_space_write_2
argument_list|(
name|sc
operator|->
name|sc_iot
argument_list|,
name|h
argument_list|,
name|o
argument_list|,
name|bswap16
argument_list|(
name|d
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|bus_space_write_multi_stream_2
argument_list|(
name|sc
operator|->
name|sc_iot
argument_list|,
name|h
argument_list|,
name|o
argument_list|,
name|d
argument_list|,
name|c
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|disable_16
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|ata_avila_methods
index|[]
init|=
block|{
comment|/* device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|ata_avila_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|ata_avila_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|ata_avila_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|bus_generic_shutdown
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|bus_generic_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|bus_generic_resume
argument_list|)
block|,
comment|/* bus methods */
name|DEVMETHOD
argument_list|(
name|bus_alloc_resource
argument_list|,
name|ata_avila_alloc_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_release_resource
argument_list|,
name|ata_avila_release_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_activate_resource
argument_list|,
name|bus_generic_activate_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_deactivate_resource
argument_list|,
name|bus_generic_deactivate_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_setup_intr
argument_list|,
name|ata_avila_setup_intr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_teardown_intr
argument_list|,
name|ata_avila_teardown_intr
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|devclass_t
name|ata_avila_devclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|ata_avila_driver
init|=
block|{
literal|"ata_avila"
block|,
name|ata_avila_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ata_avila_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|ata_avila
argument_list|,
name|ixp
argument_list|,
name|ata_avila_driver
argument_list|,
name|ata_avila_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|ata_avila
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|ata_avila
argument_list|,
name|ata
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|avila_channel_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ata_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|ch
operator|->
name|unit
operator|=
literal|0
expr_stmt|;
name|ch
operator|->
name|flags
operator||=
name|ATA_USE_16BIT
operator||
name|ATA_NO_SLAVE
expr_stmt|;
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
literal|"ATA channel 0"
argument_list|)
expr_stmt|;
return|return
name|ata_probe
argument_list|(
name|dev
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|avila_channel_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ata_avila_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|ata_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ATA_MAX_RES
condition|;
name|i
operator|++
control|)
name|ch
operator|->
name|r_io
index|[
name|i
index|]
operator|.
name|res
operator|=
operator|&
name|sc
operator|->
name|sc_ata
expr_stmt|;
name|ch
operator|->
name|r_io
index|[
name|ATA_DATA
index|]
operator|.
name|offset
operator|=
name|ATA_DATA
expr_stmt|;
name|ch
operator|->
name|r_io
index|[
name|ATA_FEATURE
index|]
operator|.
name|offset
operator|=
name|ATA_FEATURE
expr_stmt|;
name|ch
operator|->
name|r_io
index|[
name|ATA_COUNT
index|]
operator|.
name|offset
operator|=
name|ATA_COUNT
expr_stmt|;
name|ch
operator|->
name|r_io
index|[
name|ATA_SECTOR
index|]
operator|.
name|offset
operator|=
name|ATA_SECTOR
expr_stmt|;
name|ch
operator|->
name|r_io
index|[
name|ATA_CYL_LSB
index|]
operator|.
name|offset
operator|=
name|ATA_CYL_LSB
expr_stmt|;
name|ch
operator|->
name|r_io
index|[
name|ATA_CYL_MSB
index|]
operator|.
name|offset
operator|=
name|ATA_CYL_MSB
expr_stmt|;
name|ch
operator|->
name|r_io
index|[
name|ATA_DRIVE
index|]
operator|.
name|offset
operator|=
name|ATA_DRIVE
expr_stmt|;
name|ch
operator|->
name|r_io
index|[
name|ATA_COMMAND
index|]
operator|.
name|offset
operator|=
name|ATA_COMMAND
expr_stmt|;
name|ch
operator|->
name|r_io
index|[
name|ATA_ERROR
index|]
operator|.
name|offset
operator|=
name|ATA_FEATURE
expr_stmt|;
comment|/* NB: should be used only for ATAPI devices */
name|ch
operator|->
name|r_io
index|[
name|ATA_IREASON
index|]
operator|.
name|offset
operator|=
name|ATA_COUNT
expr_stmt|;
name|ch
operator|->
name|r_io
index|[
name|ATA_STATUS
index|]
operator|.
name|offset
operator|=
name|ATA_COMMAND
expr_stmt|;
comment|/* NB: the control and alt status registers are special */
name|ch
operator|->
name|r_io
index|[
name|ATA_ALTSTAT
index|]
operator|.
name|res
operator|=
operator|&
name|sc
operator|->
name|sc_alt_ata
expr_stmt|;
name|ch
operator|->
name|r_io
index|[
name|ATA_ALTSTAT
index|]
operator|.
name|offset
operator|=
name|AVILA_IDE_CTRL
expr_stmt|;
name|ch
operator|->
name|r_io
index|[
name|ATA_CONTROL
index|]
operator|.
name|res
operator|=
operator|&
name|sc
operator|->
name|sc_alt_ata
expr_stmt|;
name|ch
operator|->
name|r_io
index|[
name|ATA_CONTROL
index|]
operator|.
name|offset
operator|=
name|AVILA_IDE_CTRL
expr_stmt|;
comment|/* NB: by convention this points at the base of registers */
name|ch
operator|->
name|r_io
index|[
name|ATA_IDX_ADDR
index|]
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|ata_generic_hw
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|ata_attach
argument_list|(
name|dev
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|avila_channel_methods
index|[]
init|=
block|{
comment|/* device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|avila_channel_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|avila_channel_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|ata_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|bus_generic_shutdown
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|ata_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|ata_resume
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|driver_t
name|avila_channel_driver
init|=
block|{
literal|"ata"
block|,
name|avila_channel_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ata_channel
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|ata
argument_list|,
name|ata_avila
argument_list|,
name|avila_channel_driver
argument_list|,
name|ata_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

