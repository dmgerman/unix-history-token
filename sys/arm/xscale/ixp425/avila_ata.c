begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2006 Sam Leffler, Errno Consulting  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    similar to the "NO WARRANTY" disclaimer below ("Disclaimer") and any  *    redistribution must be conditioned upon including a substantially  *    similar Disclaimer requirement for further binary redistribution.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTIBILITY  * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL  * THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY,  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER  * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Compact Flash Support for the Avila Gateworks XScale boards.  * There are 1 or 2 optional CF slots operated in "True IDE" mode.  * Registers are on the Expansion Bus connected to CS1.  Interrupts  * are tied to GPIO pin 12.  No DMA, just PIO.  *  * See also http://www.intel.com/design/network/applnots/302456.htm.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpufunc.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<machine/intr.h>
end_include

begin_include
include|#
directive|include
file|<arm/xscale/ixp425/ixp425reg.h>
end_include

begin_include
include|#
directive|include
file|<arm/xscale/ixp425/ixp425var.h>
end_include

begin_include
include|#
directive|include
file|<sys/ata.h>
end_include

begin_include
include|#
directive|include
file|<sys/sema.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<dev/ata/ata-all.h>
end_include

begin_include
include|#
directive|include
file|<ata_if.h>
end_include

begin_define
define|#
directive|define
name|AVILA_IDE_GPIN
value|12
end_define

begin_comment
comment|/* GPIO pin # */
end_comment

begin_define
define|#
directive|define
name|AVILA_IDE_IRQ
value|IXP425_INT_GPIO_12
end_define

begin_define
define|#
directive|define
name|AVILA_IDE_CTRL
value|0x1e
end_define

begin_comment
comment|/* control register */
end_comment

begin_struct
struct|struct
name|ata_avila_softc
block|{
name|device_t
name|sc_dev
decl_stmt|;
name|bus_space_tag_t
name|sc_iot
decl_stmt|;
name|bus_space_handle_t
name|sc_exp_ioh
decl_stmt|;
comment|/* Exp Bus config registers */
name|bus_space_handle_t
name|sc_ioh
decl_stmt|;
comment|/* CS1 data registers */
name|struct
name|bus_space
name|sc_expbus_tag
decl_stmt|;
name|struct
name|resource
name|sc_ata
decl_stmt|;
comment|/* hand-crafted for ATA */
name|int
name|sc_rid
decl_stmt|;
comment|/* rid for IRQ */
name|struct
name|resource
modifier|*
name|sc_irq
decl_stmt|;
comment|/* IRQ resource */
name|void
modifier|*
name|sc_ih
decl_stmt|;
comment|/* interrupt handler */
struct|struct
block|{
name|void
function_decl|(
modifier|*
name|cb
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
name|void
modifier|*
name|arg
decl_stmt|;
block|}
name|sc_intr
index|[
literal|1
index|]
struct|;
comment|/* NB: 1/channel */
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|ata_avila_intr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|bs_protos
argument_list|(
name|ata
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|void
name|ata_bs_rm_2_s
parameter_list|(
name|void
modifier|*
parameter_list|,
name|bus_space_handle_t
parameter_list|,
name|bus_size_t
parameter_list|,
name|u_int16_t
modifier|*
parameter_list|,
name|bus_size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ata_bs_wm_2_s
parameter_list|(
name|void
modifier|*
parameter_list|,
name|bus_space_handle_t
parameter_list|,
name|bus_size_t
parameter_list|,
specifier|const
name|u_int16_t
modifier|*
parameter_list|,
name|bus_size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|ata_avila_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
comment|/* XXX any way to check? */
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
literal|"Gateworks Avila IDE/CF Controller"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ata_avila_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ata_avila_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ixp425_softc
modifier|*
name|sa
init|=
name|device_get_softc
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
decl_stmt|;
name|sc
operator|->
name|sc_dev
operator|=
name|dev
expr_stmt|;
comment|/* NB: borrow from parent */
name|sc
operator|->
name|sc_iot
operator|=
name|sa
operator|->
name|sc_iot
expr_stmt|;
name|sc
operator|->
name|sc_exp_ioh
operator|=
name|sa
operator|->
name|sc_exp_ioh
expr_stmt|;
if|if
condition|(
name|bus_space_map
argument_list|(
name|sc
operator|->
name|sc_iot
argument_list|,
name|IXP425_EXP_BUS_CS1_HWBASE
argument_list|,
name|IXP425_EXP_BUS_CS1_SIZE
argument_list|,
literal|0
argument_list|,
operator|&
name|sc
operator|->
name|sc_ioh
argument_list|)
condition|)
name|panic
argument_list|(
literal|"%s: unable to map Expansion Bus CS1 window"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* 	 * Craft special resource for ATA bus space ops 	 * that go through the expansion bus and require 	 * special hackery to ena/dis 16-bit operations. 	 * 	 * XXX probably should just make this generic for 	 * accessing the expansion bus. 	 */
name|sc
operator|->
name|sc_expbus_tag
operator|.
name|bs_cookie
operator|=
name|sc
expr_stmt|;
comment|/* NB: backpointer */
comment|/* read single */
name|sc
operator|->
name|sc_expbus_tag
operator|.
name|bs_r_1
operator|=
name|ata_bs_r_1
operator|,
name|sc
operator|->
name|sc_expbus_tag
operator|.
name|bs_r_2
operator|=
name|ata_bs_r_2
operator|,
comment|/* read multiple */
name|sc
operator|->
name|sc_expbus_tag
operator|.
name|bs_rm_2
operator|=
name|ata_bs_rm_2
operator|,
name|sc
operator|->
name|sc_expbus_tag
operator|.
name|bs_rm_2_s
operator|=
name|ata_bs_rm_2_s
operator|,
comment|/* write (single) */
name|sc
operator|->
name|sc_expbus_tag
operator|.
name|bs_w_1
operator|=
name|ata_bs_w_1
operator|,
name|sc
operator|->
name|sc_expbus_tag
operator|.
name|bs_w_2
operator|=
name|ata_bs_w_2
operator|,
comment|/* write multiple */
name|sc
operator|->
name|sc_expbus_tag
operator|.
name|bs_wm_2
operator|=
name|ata_bs_wm_2
operator|,
name|sc
operator|->
name|sc_expbus_tag
operator|.
name|bs_wm_2_s
operator|=
name|ata_bs_wm_2_s
operator|,
name|rman_set_bustag
argument_list|(
operator|&
name|sc
operator|->
name|sc_ata
argument_list|,
operator|&
name|sc
operator|->
name|sc_expbus_tag
argument_list|)
expr_stmt|;
name|rman_set_bushandle
argument_list|(
operator|&
name|sc
operator|->
name|sc_ata
argument_list|,
name|sc
operator|->
name|sc_ioh
argument_list|)
expr_stmt|;
name|GPIO_CONF_WRITE_4
argument_list|(
name|sa
argument_list|,
name|IXP425_GPIO_GPOER
argument_list|,
name|GPIO_CONF_READ_4
argument_list|(
name|sa
argument_list|,
name|IXP425_GPIO_GPOER
argument_list|)
operator||
operator|(
literal|1
operator|<<
name|AVILA_IDE_GPIN
operator|)
argument_list|)
expr_stmt|;
comment|/* interrupt is active low */
name|GPIO_CONF_WRITE_4
argument_list|(
name|sa
argument_list|,
name|GPIO_TYPE_REG
argument_list|(
name|AVILA_IDE_GPIN
argument_list|)
argument_list|,
name|GPIO_CONF_READ_4
argument_list|(
name|sa
argument_list|,
name|GPIO_TYPE_REG
argument_list|(
name|AVILA_IDE_GPIN
argument_list|)
operator||
name|GPIO_TYPE
argument_list|(
name|AVILA_IDE_GPIN
argument_list|,
name|GPIO_TYPE_ACT_LOW
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* clear ISR */
name|GPIO_CONF_WRITE_4
argument_list|(
name|sa
argument_list|,
name|IXP425_GPIO_GPISR
argument_list|,
operator|(
literal|1
operator|<<
name|AVILA_IDE_GPIN
operator|)
argument_list|)
expr_stmt|;
comment|/* configure CS1 window, leaving timing unchanged */
name|EXP_BUS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|EXP_TIMING_CS1_OFFSET
argument_list|,
name|EXP_BUS_READ_4
argument_list|(
name|sc
argument_list|,
name|EXP_TIMING_CS1_OFFSET
argument_list|)
operator||
name|EXP_BYTE_EN
operator||
name|EXP_WR_EN
operator||
name|EXP_BYTE_RD16
operator||
name|EXP_CS_EN
argument_list|)
expr_stmt|;
comment|/* setup interrupt */
name|sc
operator|->
name|sc_irq
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|sc
operator|->
name|sc_rid
argument_list|,
name|AVILA_IDE_IRQ
argument_list|,
name|AVILA_IDE_IRQ
argument_list|,
literal|1
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_irq
condition|)
name|panic
argument_list|(
literal|"Unable to allocate irq %u.\n"
argument_list|,
name|AVILA_IDE_IRQ
argument_list|)
expr_stmt|;
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|sc_irq
argument_list|,
name|INTR_TYPE_BIO
operator||
name|INTR_MPSAFE
operator||
name|INTR_ENTROPY
argument_list|,
name|NULL
argument_list|,
name|ata_avila_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_ih
argument_list|)
expr_stmt|;
comment|/* attach channel on this controller */
name|device_add_child
argument_list|(
name|dev
argument_list|,
literal|"ata"
argument_list|,
name|devclass_find_free_unit
argument_list|(
name|ata_devclass
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|bus_generic_attach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ata_avila_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ata_avila_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|device_t
modifier|*
name|children
decl_stmt|;
name|int
name|nc
decl_stmt|;
comment|/* XXX quiesce gpio? */
comment|/* detach& delete all children */
if|if
condition|(
name|device_get_children
argument_list|(
name|dev
argument_list|,
operator|&
name|children
argument_list|,
operator|&
name|nc
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nc
operator|>
literal|0
condition|)
name|device_delete_child
argument_list|(
name|dev
argument_list|,
name|children
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|children
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|sc_irq
argument_list|,
name|sc
operator|->
name|sc_ih
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|sc_rid
argument_list|,
name|sc
operator|->
name|sc_irq
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ata_avila_intr
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|ata_avila_softc
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_intr
index|[
literal|0
index|]
operator|.
name|cb
operator|!=
name|NULL
condition|)
name|sc
operator|->
name|sc_intr
index|[
literal|0
index|]
operator|.
name|cb
argument_list|(
name|sc
operator|->
name|sc_intr
index|[
literal|0
index|]
operator|.
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|resource
modifier|*
name|ata_avila_alloc_resource
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
modifier|*
name|rid
parameter_list|,
name|u_long
name|start
parameter_list|,
name|u_long
name|end
parameter_list|,
name|u_long
name|count
parameter_list|,
name|u_int
name|flags
parameter_list|)
block|{
name|struct
name|ata_avila_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|KASSERT
argument_list|(
name|type
operator|==
name|SYS_RES_IRQ
operator|&&
operator|*
name|rid
operator|==
name|ATA_IRQ_RID
argument_list|,
operator|(
literal|"type %u rid %u start %lu end %lu count %lu flags %u"
operator|,
name|type
operator|,
operator|*
name|rid
operator|,
name|start
operator|,
name|end
operator|,
name|count
operator|,
name|flags
operator|)
argument_list|)
expr_stmt|;
comment|/* doesn't matter what we return so reuse the real thing */
return|return
name|sc
operator|->
name|sc_irq
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ata_avila_release_resource
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|struct
name|resource
modifier|*
name|r
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|type
operator|==
name|SYS_RES_IRQ
operator|&&
name|rid
operator|==
name|ATA_IRQ_RID
argument_list|,
operator|(
literal|"type %u rid %u"
operator|,
name|type
operator|,
name|rid
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ata_avila_setup_intr
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|struct
name|resource
modifier|*
name|irq
parameter_list|,
name|int
name|flags
parameter_list|,
name|driver_filter_t
modifier|*
name|filt
parameter_list|,
name|driver_intr_t
modifier|*
name|function
parameter_list|,
name|void
modifier|*
name|argument
parameter_list|,
name|void
modifier|*
modifier|*
name|cookiep
parameter_list|)
block|{
name|struct
name|ata_avila_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|unit
init|=
operator|(
operator|(
expr|struct
name|ata_channel
operator|*
operator|)
name|device_get_softc
argument_list|(
name|child
argument_list|)
operator|)
operator|->
name|unit
decl_stmt|;
name|KASSERT
argument_list|(
name|unit
operator|==
literal|0
argument_list|,
operator|(
literal|"unit %d"
operator|,
name|unit
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_intr
index|[
name|unit
index|]
operator|.
name|cb
operator|=
name|function
expr_stmt|;
name|sc
operator|->
name|sc_intr
index|[
name|unit
index|]
operator|.
name|arg
operator|=
name|argument
expr_stmt|;
operator|*
name|cookiep
operator|=
name|sc
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ata_avila_teardown_intr
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|struct
name|resource
modifier|*
name|irq
parameter_list|,
name|void
modifier|*
name|cookie
parameter_list|)
block|{
name|struct
name|ata_avila_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|unit
init|=
operator|(
operator|(
expr|struct
name|ata_channel
operator|*
operator|)
name|device_get_softc
argument_list|(
name|child
argument_list|)
operator|)
operator|->
name|unit
decl_stmt|;
name|KASSERT
argument_list|(
name|unit
operator|==
literal|0
argument_list|,
operator|(
literal|"unit %d"
operator|,
name|unit
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_intr
index|[
name|unit
index|]
operator|.
name|cb
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_intr
index|[
name|unit
index|]
operator|.
name|arg
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Bus space accessors for CF-IDE PIO operations.  */
end_comment

begin_comment
comment|/*  * Enable/disable 16-bit ops on the expansion bus.  */
end_comment

begin_function
specifier|static
name|void
name|__inline
name|enable_16
parameter_list|(
name|struct
name|ata_avila_softc
modifier|*
name|sc
parameter_list|)
block|{
name|EXP_BUS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|EXP_TIMING_CS1_OFFSET
argument_list|,
name|EXP_BUS_READ_4
argument_list|(
name|sc
argument_list|,
name|EXP_TIMING_CS1_OFFSET
argument_list|)
operator|&
operator|~
name|EXP_BYTE_EN
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* XXX? */
block|}
end_function

begin_function
specifier|static
name|void
name|__inline
name|disable_16
parameter_list|(
name|struct
name|ata_avila_softc
modifier|*
name|sc
parameter_list|)
block|{
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* XXX? */
name|EXP_BUS_WRITE_4
argument_list|(
name|sc
argument_list|,
name|EXP_TIMING_CS1_OFFSET
argument_list|,
name|EXP_BUS_READ_4
argument_list|(
name|sc
argument_list|,
name|EXP_TIMING_CS1_OFFSET
argument_list|)
operator||
name|EXP_BYTE_EN
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|uint8_t
name|ata_bs_r_1
parameter_list|(
name|void
modifier|*
name|t
parameter_list|,
name|bus_space_handle_t
name|h
parameter_list|,
name|bus_size_t
name|o
parameter_list|)
block|{
name|struct
name|ata_avila_softc
modifier|*
name|sc
init|=
name|t
decl_stmt|;
return|return
name|bus_space_read_1
argument_list|(
name|sc
operator|->
name|sc_iot
argument_list|,
name|h
argument_list|,
name|o
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|ata_bs_w_1
parameter_list|(
name|void
modifier|*
name|t
parameter_list|,
name|bus_space_handle_t
name|h
parameter_list|,
name|bus_size_t
name|o
parameter_list|,
name|u_int8_t
name|v
parameter_list|)
block|{
name|struct
name|ata_avila_softc
modifier|*
name|sc
init|=
name|t
decl_stmt|;
name|bus_space_write_1
argument_list|(
name|sc
operator|->
name|sc_iot
argument_list|,
name|h
argument_list|,
name|o
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|uint16_t
name|ata_bs_r_2
parameter_list|(
name|void
modifier|*
name|t
parameter_list|,
name|bus_space_handle_t
name|h
parameter_list|,
name|bus_size_t
name|o
parameter_list|)
block|{
name|struct
name|ata_avila_softc
modifier|*
name|sc
init|=
name|t
decl_stmt|;
name|uint16_t
name|v
decl_stmt|;
name|enable_16
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|v
operator|=
name|bus_space_read_2
argument_list|(
name|sc
operator|->
name|sc_iot
argument_list|,
name|h
argument_list|,
name|o
argument_list|)
expr_stmt|;
name|disable_16
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_function
name|void
name|ata_bs_w_2
parameter_list|(
name|void
modifier|*
name|t
parameter_list|,
name|bus_space_handle_t
name|h
parameter_list|,
name|bus_size_t
name|o
parameter_list|,
name|uint16_t
name|v
parameter_list|)
block|{
name|struct
name|ata_avila_softc
modifier|*
name|sc
init|=
name|t
decl_stmt|;
name|enable_16
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bus_space_write_2
argument_list|(
name|sc
operator|->
name|sc_iot
argument_list|,
name|h
argument_list|,
name|o
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|disable_16
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ata_bs_rm_2
parameter_list|(
name|void
modifier|*
name|t
parameter_list|,
name|bus_space_handle_t
name|h
parameter_list|,
name|bus_size_t
name|o
parameter_list|,
name|u_int16_t
modifier|*
name|d
parameter_list|,
name|bus_size_t
name|c
parameter_list|)
block|{
name|struct
name|ata_avila_softc
modifier|*
name|sc
init|=
name|t
decl_stmt|;
name|enable_16
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bus_space_read_multi_2
argument_list|(
name|sc
operator|->
name|sc_iot
argument_list|,
name|h
argument_list|,
name|o
argument_list|,
name|d
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|disable_16
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ata_bs_wm_2
parameter_list|(
name|void
modifier|*
name|t
parameter_list|,
name|bus_space_handle_t
name|h
parameter_list|,
name|bus_size_t
name|o
parameter_list|,
specifier|const
name|u_int16_t
modifier|*
name|d
parameter_list|,
name|bus_size_t
name|c
parameter_list|)
block|{
name|struct
name|ata_avila_softc
modifier|*
name|sc
init|=
name|t
decl_stmt|;
name|enable_16
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bus_space_write_multi_2
argument_list|(
name|sc
operator|->
name|sc_iot
argument_list|,
name|h
argument_list|,
name|o
argument_list|,
name|d
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|disable_16
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* XXX workaround ata driver by (incorrectly) byte swapping stream cases */
end_comment

begin_function
name|void
name|ata_bs_rm_2_s
parameter_list|(
name|void
modifier|*
name|t
parameter_list|,
name|bus_space_handle_t
name|h
parameter_list|,
name|bus_size_t
name|o
parameter_list|,
name|u_int16_t
modifier|*
name|d
parameter_list|,
name|bus_size_t
name|c
parameter_list|)
block|{
name|struct
name|ata_avila_softc
modifier|*
name|sc
init|=
name|t
decl_stmt|;
name|uint16_t
name|v
decl_stmt|;
name|bus_size_t
name|i
decl_stmt|;
name|enable_16
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|c
condition|;
name|i
operator|++
control|)
block|{
name|v
operator|=
name|bus_space_read_2
argument_list|(
name|sc
operator|->
name|sc_iot
argument_list|,
name|h
argument_list|,
name|o
argument_list|)
expr_stmt|;
name|d
index|[
name|i
index|]
operator|=
name|bswap16
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|bus_space_read_multi_stream_2
argument_list|(
name|sc
operator|->
name|sc_iot
argument_list|,
name|h
argument_list|,
name|o
argument_list|,
name|d
argument_list|,
name|c
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|disable_16
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ata_bs_wm_2_s
parameter_list|(
name|void
modifier|*
name|t
parameter_list|,
name|bus_space_handle_t
name|h
parameter_list|,
name|bus_size_t
name|o
parameter_list|,
specifier|const
name|u_int16_t
modifier|*
name|d
parameter_list|,
name|bus_size_t
name|c
parameter_list|)
block|{
name|struct
name|ata_avila_softc
modifier|*
name|sc
init|=
name|t
decl_stmt|;
name|bus_size_t
name|i
decl_stmt|;
name|enable_16
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|c
condition|;
name|i
operator|++
control|)
name|bus_space_write_2
argument_list|(
name|sc
operator|->
name|sc_iot
argument_list|,
name|h
argument_list|,
name|o
argument_list|,
name|bswap16
argument_list|(
name|d
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|bus_space_write_multi_stream_2
argument_list|(
name|sc
operator|->
name|sc_iot
argument_list|,
name|h
argument_list|,
name|o
argument_list|,
name|d
argument_list|,
name|c
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|disable_16
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|ata_avila_methods
index|[]
init|=
block|{
comment|/* device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|ata_avila_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|ata_avila_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|ata_avila_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|bus_generic_shutdown
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|bus_generic_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|bus_generic_resume
argument_list|)
block|,
comment|/* bus methods */
name|DEVMETHOD
argument_list|(
name|bus_alloc_resource
argument_list|,
name|ata_avila_alloc_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_release_resource
argument_list|,
name|ata_avila_release_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_activate_resource
argument_list|,
name|bus_generic_activate_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_deactivate_resource
argument_list|,
name|bus_generic_deactivate_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_setup_intr
argument_list|,
name|ata_avila_setup_intr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_teardown_intr
argument_list|,
name|ata_avila_teardown_intr
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|devclass_t
name|ata_avila_devclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|ata_avila_driver
init|=
block|{
literal|"ata_avila"
block|,
name|ata_avila_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ata_avila_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|ata_avila
argument_list|,
name|ixp
argument_list|,
name|ata_avila_driver
argument_list|,
name|ata_avila_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|ata_avila
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|ata_avila
argument_list|,
name|ata
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|avila_channel_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ata_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|ch
operator|->
name|unit
operator|=
literal|0
expr_stmt|;
name|ch
operator|->
name|flags
operator||=
name|ATA_USE_16BIT
operator||
name|ATA_NO_SLAVE
expr_stmt|;
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
literal|"ATA channel 0"
argument_list|)
expr_stmt|;
return|return
name|ata_probe
argument_list|(
name|dev
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|avila_channel_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ata_avila_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|ata_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ATA_MAX_RES
condition|;
name|i
operator|++
control|)
name|ch
operator|->
name|r_io
index|[
name|i
index|]
operator|.
name|res
operator|=
operator|&
name|sc
operator|->
name|sc_ata
expr_stmt|;
name|ch
operator|->
name|r_io
index|[
name|ATA_DATA
index|]
operator|.
name|offset
operator|=
name|ATA_DATA
expr_stmt|;
name|ch
operator|->
name|r_io
index|[
name|ATA_FEATURE
index|]
operator|.
name|offset
operator|=
name|ATA_FEATURE
expr_stmt|;
name|ch
operator|->
name|r_io
index|[
name|ATA_COUNT
index|]
operator|.
name|offset
operator|=
name|ATA_COUNT
expr_stmt|;
name|ch
operator|->
name|r_io
index|[
name|ATA_SECTOR
index|]
operator|.
name|offset
operator|=
name|ATA_SECTOR
expr_stmt|;
name|ch
operator|->
name|r_io
index|[
name|ATA_CYL_LSB
index|]
operator|.
name|offset
operator|=
name|ATA_CYL_LSB
expr_stmt|;
name|ch
operator|->
name|r_io
index|[
name|ATA_CYL_MSB
index|]
operator|.
name|offset
operator|=
name|ATA_CYL_MSB
expr_stmt|;
name|ch
operator|->
name|r_io
index|[
name|ATA_DRIVE
index|]
operator|.
name|offset
operator|=
name|ATA_DRIVE
expr_stmt|;
name|ch
operator|->
name|r_io
index|[
name|ATA_COMMAND
index|]
operator|.
name|offset
operator|=
name|ATA_COMMAND
expr_stmt|;
name|ch
operator|->
name|r_io
index|[
name|ATA_ERROR
index|]
operator|.
name|offset
operator|=
name|ATA_FEATURE
expr_stmt|;
comment|/* NB: should be used only for ATAPI devices */
name|ch
operator|->
name|r_io
index|[
name|ATA_IREASON
index|]
operator|.
name|offset
operator|=
name|ATA_COUNT
expr_stmt|;
name|ch
operator|->
name|r_io
index|[
name|ATA_STATUS
index|]
operator|.
name|offset
operator|=
name|ATA_COMMAND
expr_stmt|;
comment|/* alias this; required by ata_generic_status */
name|ch
operator|->
name|r_io
index|[
name|ATA_ALTSTAT
index|]
operator|.
name|offset
operator|=
name|ch
operator|->
name|r_io
index|[
name|ATA_STATUS
index|]
operator|.
name|offset
expr_stmt|;
comment|/* NB: the control register is special */
name|ch
operator|->
name|r_io
index|[
name|ATA_CONTROL
index|]
operator|.
name|offset
operator|=
name|AVILA_IDE_CTRL
expr_stmt|;
comment|/* NB: by convention this points at the base of registers */
name|ch
operator|->
name|r_io
index|[
name|ATA_IDX_ADDR
index|]
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|ata_generic_hw
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|ata_attach
argument_list|(
name|dev
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* XXX override ata_generic_reset to handle non-standard status */
end_comment

begin_function
specifier|static
name|void
name|avila_channel_reset
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ata_channel
modifier|*
name|ch
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u_int8_t
name|ostat0
init|=
literal|0
decl_stmt|,
name|stat0
init|=
literal|0
decl_stmt|;
name|u_int8_t
name|err
init|=
literal|0
decl_stmt|,
name|lsb
init|=
literal|0
decl_stmt|,
name|msb
init|=
literal|0
decl_stmt|;
name|int
name|mask
init|=
literal|0
decl_stmt|,
name|timeout
decl_stmt|;
comment|/* do we have any signs of ATA/ATAPI HW being present ? */
name|ATA_IDX_OUTB
argument_list|(
name|ch
argument_list|,
name|ATA_DRIVE
argument_list|,
name|ATA_D_IBM
operator||
name|ATA_D_LBA
operator||
name|ATA_MASTER
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|ostat0
operator|=
name|ATA_IDX_INB
argument_list|(
name|ch
argument_list|,
name|ATA_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ostat0
operator|&
literal|0xf8
operator|)
operator|!=
literal|0xf8
operator|&&
name|ostat0
operator|!=
literal|0xa5
condition|)
block|{
name|stat0
operator|=
name|ATA_S_BUSY
expr_stmt|;
name|mask
operator||=
literal|0x01
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: reset tp1 mask=%02x ostat0=%02x\n"
argument_list|,
name|__func__
argument_list|,
name|mask
argument_list|,
name|ostat0
argument_list|)
expr_stmt|;
comment|/* if nothing showed up there is no need to get any further */
comment|/* XXX SOS is that too strong?, we just might loose devices here */
name|ch
operator|->
name|devices
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|mask
condition|)
return|return;
comment|/* reset (both) devices on this channel */
name|ATA_IDX_OUTB
argument_list|(
name|ch
argument_list|,
name|ATA_DRIVE
argument_list|,
name|ATA_D_IBM
operator||
name|ATA_D_LBA
operator||
name|ATA_MASTER
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|ATA_IDX_OUTB
argument_list|(
name|ch
argument_list|,
name|ATA_CONTROL
argument_list|,
name|ATA_A_IDS
operator||
name|ATA_A_RESET
argument_list|)
expr_stmt|;
name|ata_udelay
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
name|ATA_IDX_OUTB
argument_list|(
name|ch
argument_list|,
name|ATA_CONTROL
argument_list|,
name|ATA_A_IDS
argument_list|)
expr_stmt|;
name|ata_udelay
argument_list|(
literal|100000
argument_list|)
expr_stmt|;
name|ATA_IDX_INB
argument_list|(
name|ch
argument_list|,
name|ATA_ERROR
argument_list|)
expr_stmt|;
comment|/* wait for BUSY to go inactive */
for|for
control|(
name|timeout
operator|=
literal|0
init|;
name|timeout
operator|<
literal|310
condition|;
name|timeout
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|mask
operator|&
literal|0x01
operator|)
operator|&&
operator|(
name|stat0
operator|&
name|ATA_S_BUSY
operator|)
condition|)
block|{
name|ATA_IDX_OUTB
argument_list|(
name|ch
argument_list|,
name|ATA_DRIVE
argument_list|,
name|ATA_D_IBM
operator||
name|ATA_MASTER
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|err
operator|=
name|ATA_IDX_INB
argument_list|(
name|ch
argument_list|,
name|ATA_ERROR
argument_list|)
expr_stmt|;
name|lsb
operator|=
name|ATA_IDX_INB
argument_list|(
name|ch
argument_list|,
name|ATA_CYL_LSB
argument_list|)
expr_stmt|;
name|msb
operator|=
name|ATA_IDX_INB
argument_list|(
name|ch
argument_list|,
name|ATA_CYL_MSB
argument_list|)
expr_stmt|;
name|stat0
operator|=
name|ATA_IDX_INB
argument_list|(
name|ch
argument_list|,
name|ATA_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: stat0=0x%02x err=0x%02x lsb=0x%02x "
literal|"msb=0x%02x\n"
argument_list|,
name|__func__
argument_list|,
name|stat0
argument_list|,
name|err
argument_list|,
name|lsb
argument_list|,
name|msb
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat0
operator|==
name|err
operator|&&
name|lsb
operator|==
name|err
operator|&&
name|msb
operator|==
name|err
operator|&&
name|timeout
operator|>
operator|(
name|stat0
operator|&
name|ATA_S_BUSY
condition|?
literal|100
else|:
literal|10
operator|)
condition|)
name|mask
operator|&=
operator|~
literal|0x01
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|stat0
operator|&
name|ATA_S_BUSY
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|err
operator|&
literal|0x7f
operator|)
operator|==
name|ATA_E_ILI
operator|||
name|err
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|lsb
operator|==
name|ATAPI_MAGIC_LSB
operator|&&
name|msb
operator|==
name|ATAPI_MAGIC_MSB
condition|)
block|{
name|ch
operator|->
name|devices
operator||=
name|ATA_ATAPI_MASTER
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|stat0
operator|&
name|ATA_S_READY
condition|)
block|{
name|ch
operator|->
name|devices
operator||=
name|ATA_ATA_MASTER
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|stat0
operator|&
literal|0x0f
operator|)
operator|&&
name|err
operator|==
name|lsb
operator|&&
name|err
operator|==
name|msb
condition|)
block|{
name|stat0
operator||=
name|ATA_S_BUSY
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|mask
operator|==
literal|0x00
condition|)
comment|/* nothing to wait for */
break|break;
comment|/* wait for master */
if|if
condition|(
operator|!
operator|(
name|stat0
operator|&
name|ATA_S_BUSY
operator|)
operator|||
operator|(
name|stat0
operator|==
literal|0xff
operator|&&
name|timeout
operator|>
literal|10
operator|)
condition|)
break|break;
name|ata_udelay
argument_list|(
literal|100000
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: reset tp2 stat0=%02x devices=0x%b\n"
argument_list|,
name|__func__
argument_list|,
name|stat0
argument_list|,
name|ch
operator|->
name|devices
argument_list|,
literal|"\20\4ATAPI_SLAVE\3ATAPI_MASTER\2ATA_SLAVE\1ATA_MASTER"
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|avila_channel_methods
index|[]
init|=
block|{
comment|/* device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|avila_channel_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|avila_channel_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|ata_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|bus_generic_shutdown
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|ata_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|ata_resume
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|ata_reset
argument_list|,
name|avila_channel_reset
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|driver_t
name|avila_channel_driver
init|=
block|{
literal|"ata"
block|,
name|avila_channel_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ata_channel
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|ata
argument_list|,
name|ata_avila
argument_list|,
name|avila_channel_driver
argument_list|,
name|ata_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

