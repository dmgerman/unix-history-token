begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: i80321_mainbus.c,v 1.13 2003/12/17 22:03:24 abs Exp $	*/
end_comment

begin_comment
comment|/*-  * Copyright (c) 2001, 2002 Wasabi Systems, Inc.  * All rights reserved.  *  * Written by Jason R. Thorpe for Wasabi Systems, Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed for the NetBSD Project by  *	Wasabi Systems, Inc.  * 4. The name of Wasabi Systems, Inc. may not be used to endorse  *    or promote products derived from this software without specific prior  *    written permission.  *  * THIS SOFTWARE IS PROVIDED BY WASABI SYSTEMS, INC. ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL WASABI SYSTEMS, INC  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * IQ80321 front-end for the i80321 I/O Processor.  We take care  * of setting up the i80321 memory map, PCI interrupt routing, etc.,  * which are all specific to the board the i80321 is wired up to.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|_ARM32_BUS_DMA_PRIVATE
end_define

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/intr.h>
end_include

begin_include
include|#
directive|include
file|<arm/xscale/i80321/i80321reg.h>
end_include

begin_include
include|#
directive|include
file|<arm/xscale/i80321/i80321var.h>
end_include

begin_include
include|#
directive|include
file|<arm/xscale/i80321/iq80321reg.h>
end_include

begin_include
include|#
directive|include
file|<arm/xscale/i80321/iq80321var.h>
end_include

begin_include
include|#
directive|include
file|<arm/xscale/i80321/i80321_intr.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_function_decl
name|int
name|iq80321_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|iq80321_identify
parameter_list|(
name|driver_t
modifier|*
parameter_list|,
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iq80321_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|iq80321_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Intel 80321"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|iq80321_identify
parameter_list|(
name|driver_t
modifier|*
name|driver
parameter_list|,
name|device_t
name|parent
parameter_list|)
block|{
name|BUS_ADD_CHILD
argument_list|(
name|parent
argument_list|,
literal|0
argument_list|,
literal|"iq"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|arm32_dma_range
name|i80321_dr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dma_range_init
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|struct
name|arm32_dma_range
modifier|*
name|bus_dma_get_range
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|dma_range_init
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
operator|&
name|i80321_dr
operator|)
return|;
block|}
end_function

begin_function
name|int
name|bus_dma_get_range_nb
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|dma_range_init
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|PCI_MAPREG_MEM_PREFETCHABLE_MASK
value|0x00000008
end_define

begin_define
define|#
directive|define
name|PCI_MAPREG_MEM_TYPE_64BIT
value|0x00000004
end_define

begin_function
name|int
name|iq80321_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|i80321_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|b0u
decl_stmt|,
name|b0l
decl_stmt|,
name|b1u
decl_stmt|,
name|b1l
decl_stmt|;
name|vm_paddr_t
name|memstart
init|=
literal|0
decl_stmt|;
name|vm_size_t
name|memsize
init|=
literal|0
decl_stmt|;
name|int
name|busno
decl_stmt|;
comment|/* 	 * Fill in the space tag for the i80321's own devices, 	 * and hand-craft the space handle for it (the device 	 * was mapped during early bootstrap). 	 */
name|i80321_bs_init
argument_list|(
operator|&
name|i80321_bs_tag
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_st
operator|=
operator|&
name|i80321_bs_tag
expr_stmt|;
name|sc
operator|->
name|sc_sh
operator|=
name|IQ80321_80321_VBASE
expr_stmt|;
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|sc
operator|->
name|sc_is_host
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Slice off a subregion for the Memory Controller -- we need it 	 * here in order read the memory size. 	 */
if|if
condition|(
name|bus_space_subregion
argument_list|(
name|sc
operator|->
name|sc_st
argument_list|,
name|sc
operator|->
name|sc_sh
argument_list|,
name|VERDE_MCU_BASE
argument_list|,
name|VERDE_MCU_SIZE
argument_list|,
operator|&
name|sc
operator|->
name|sc_mcu_sh
argument_list|)
condition|)
name|panic
argument_list|(
literal|"%s: unable to subregion MCU registers"
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus_space_subregion
argument_list|(
name|sc
operator|->
name|sc_st
argument_list|,
name|sc
operator|->
name|sc_sh
argument_list|,
name|VERDE_ATU_BASE
argument_list|,
name|VERDE_ATU_SIZE
argument_list|,
operator|&
name|sc
operator|->
name|sc_atu_sh
argument_list|)
condition|)
name|panic
argument_list|(
literal|"%s: unable to subregion ATU registers"
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * We have mapped the the PCI I/O windows in the early 	 * bootstrap phase. 	 */
name|sc
operator|->
name|sc_iow_vaddr
operator|=
name|IQ80321_IOW_VBASE
expr_stmt|;
comment|/* 	 * Check the configuration of the ATU to see if another BIOS 	 * has configured us.  If a PC BIOS didn't configure us, then: 	 * 	IQ80321: BAR0 00000000.0000000c BAR1 is 00000000.8000000c. 	 * 	IQ31244: BAR0 00000000.00000004 BAR1 is 00000000.0000000c. 	 * If a BIOS has configured us, at least one of those should be 	 * different.  This is pretty fragile, but it's not clear what 	 * would work better. 	 */
name|b0l
operator|=
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|sc_st
argument_list|,
name|sc
operator|->
name|sc_atu_sh
argument_list|,
name|PCIR_BARS
operator|+
literal|0x0
argument_list|)
expr_stmt|;
name|b0u
operator|=
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|sc_st
argument_list|,
name|sc
operator|->
name|sc_atu_sh
argument_list|,
name|PCIR_BARS
operator|+
literal|0x4
argument_list|)
expr_stmt|;
name|b1l
operator|=
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|sc_st
argument_list|,
name|sc
operator|->
name|sc_atu_sh
argument_list|,
name|PCIR_BARS
operator|+
literal|0x8
argument_list|)
expr_stmt|;
name|b1u
operator|=
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|sc_st
argument_list|,
name|sc
operator|->
name|sc_atu_sh
argument_list|,
name|PCIR_BARS
operator|+
literal|0xc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE_INIT_ARM
name|printf
argument_list|(
literal|"i80321: BAR0 = %08x.%08x BAR1 = %08x.%08x\n"
argument_list|,
name|b0l
argument_list|,
name|b0u
argument_list|,
name|b1l
argument_list|,
name|b1u
argument_list|)
expr_stmt|;
endif|#
directive|endif
define|#
directive|define
name|PCI_MAPREG_MEM_ADDR_MASK
value|0xfffffff0
name|b0l
operator|&=
name|PCI_MAPREG_MEM_ADDR_MASK
expr_stmt|;
name|b0u
operator|&=
name|PCI_MAPREG_MEM_ADDR_MASK
expr_stmt|;
name|b1l
operator|&=
name|PCI_MAPREG_MEM_ADDR_MASK
expr_stmt|;
name|b1u
operator|&=
name|PCI_MAPREG_MEM_ADDR_MASK
expr_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE_INIT_ARM
name|printf
argument_list|(
literal|"i80219: BAR0 = %08x.%08x BAR1 = %08x.%08x\n"
argument_list|,
name|b0l
argument_list|,
name|b0u
argument_list|,
name|b1l
argument_list|,
name|b1u
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|b0u
operator|!=
name|b1u
operator|)
operator|||
operator|(
name|b0l
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|b1l
operator|&
operator|~
literal|0x80000000U
operator|)
operator|!=
literal|0
operator|)
condition|)
name|sc
operator|->
name|sc_is_host
operator|=
literal|0
expr_stmt|;
else|else
name|sc
operator|->
name|sc_is_host
operator|=
literal|1
expr_stmt|;
comment|/* FIXME: i force it's */
ifdef|#
directive|ifdef
name|CPU_XSCALE_80219
name|sc
operator|->
name|sc_is_host
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|i80321_sdram_bounds
argument_list|(
name|sc
operator|->
name|sc_st
argument_list|,
name|sc
operator|->
name|sc_mcu_sh
argument_list|,
operator|&
name|memstart
argument_list|,
operator|&
name|memsize
argument_list|)
expr_stmt|;
comment|/* 	 * We set up the Inbound Windows as follows: 	 * 	 *	0	Access to i80321 PMMRs 	 * 	 *	1	Reserve space for private devices 	 * 	 *	2	RAM access 	 * 	 *	3	Unused. 	 * 	 * This chunk needs to be customized for each IOP321 application. 	 */
if|#
directive|if
literal|0
block|sc->sc_iwin[0].iwin_base_lo = VERDE_PMMR_BASE; 	sc->sc_iwin[0].iwin_base_hi = 0; 	sc->sc_iwin[0].iwin_xlate = VERDE_PMMR_BASE; 	sc->sc_iwin[0].iwin_size = VERDE_PMMR_SIZE;
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|sc_is_host
condition|)
block|{
comment|/* Map PCI:Local 1:1. */
name|sc
operator|->
name|sc_iwin
index|[
literal|1
index|]
operator|.
name|iwin_base_lo
operator|=
name|VERDE_OUT_XLATE_MEM_WIN0_BASE
operator||
name|PCI_MAPREG_MEM_PREFETCHABLE_MASK
operator||
name|PCI_MAPREG_MEM_TYPE_64BIT
expr_stmt|;
name|sc
operator|->
name|sc_iwin
index|[
literal|1
index|]
operator|.
name|iwin_base_hi
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|sc_iwin
index|[
literal|1
index|]
operator|.
name|iwin_base_lo
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_iwin
index|[
literal|1
index|]
operator|.
name|iwin_base_hi
operator|=
literal|0
expr_stmt|;
block|}
name|sc
operator|->
name|sc_iwin
index|[
literal|1
index|]
operator|.
name|iwin_xlate
operator|=
name|VERDE_OUT_XLATE_MEM_WIN0_BASE
expr_stmt|;
name|sc
operator|->
name|sc_iwin
index|[
literal|1
index|]
operator|.
name|iwin_size
operator|=
name|VERDE_OUT_XLATE_MEM_WIN_SIZE
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_is_host
condition|)
block|{
name|sc
operator|->
name|sc_iwin
index|[
literal|2
index|]
operator|.
name|iwin_base_lo
operator|=
name|memstart
operator||
name|PCI_MAPREG_MEM_PREFETCHABLE_MASK
operator||
name|PCI_MAPREG_MEM_TYPE_64BIT
expr_stmt|;
name|sc
operator|->
name|sc_iwin
index|[
literal|2
index|]
operator|.
name|iwin_base_hi
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|sc_iwin
index|[
literal|2
index|]
operator|.
name|iwin_base_lo
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_iwin
index|[
literal|2
index|]
operator|.
name|iwin_base_hi
operator|=
literal|0
expr_stmt|;
block|}
name|sc
operator|->
name|sc_iwin
index|[
literal|2
index|]
operator|.
name|iwin_xlate
operator|=
name|memstart
expr_stmt|;
name|sc
operator|->
name|sc_iwin
index|[
literal|2
index|]
operator|.
name|iwin_size
operator|=
name|memsize
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_is_host
condition|)
block|{
name|sc
operator|->
name|sc_iwin
index|[
literal|3
index|]
operator|.
name|iwin_base_lo
operator|=
literal|0
operator||
name|PCI_MAPREG_MEM_PREFETCHABLE_MASK
operator||
name|PCI_MAPREG_MEM_TYPE_64BIT
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|sc_iwin
index|[
literal|3
index|]
operator|.
name|iwin_base_lo
operator|=
literal|0
expr_stmt|;
block|}
name|sc
operator|->
name|sc_iwin
index|[
literal|3
index|]
operator|.
name|iwin_base_hi
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_iwin
index|[
literal|3
index|]
operator|.
name|iwin_xlate
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_iwin
index|[
literal|3
index|]
operator|.
name|iwin_size
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE_INIT_ARM
name|printf
argument_list|(
literal|"i80321: Reserve space for private devices (Inbound Window 1) \n hi:0x%08x lo:0x%08x xlate:0x%08x size:0x%08x\n"
argument_list|,
name|sc
operator|->
name|sc_iwin
index|[
literal|1
index|]
operator|.
name|iwin_base_hi
argument_list|,
name|sc
operator|->
name|sc_iwin
index|[
literal|1
index|]
operator|.
name|iwin_base_lo
argument_list|,
name|sc
operator|->
name|sc_iwin
index|[
literal|1
index|]
operator|.
name|iwin_xlate
argument_list|,
name|sc
operator|->
name|sc_iwin
index|[
literal|1
index|]
operator|.
name|iwin_size
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"i80321: RAM access (Inbound Window 2) \n hi:0x%08x lo:0x%08x xlate:0x%08x size:0x%08x\n"
argument_list|,
name|sc
operator|->
name|sc_iwin
index|[
literal|2
index|]
operator|.
name|iwin_base_hi
argument_list|,
name|sc
operator|->
name|sc_iwin
index|[
literal|2
index|]
operator|.
name|iwin_base_lo
argument_list|,
name|sc
operator|->
name|sc_iwin
index|[
literal|2
index|]
operator|.
name|iwin_xlate
argument_list|,
name|sc
operator|->
name|sc_iwin
index|[
literal|2
index|]
operator|.
name|iwin_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * We set up the Outbound Windows as follows: 	 * 	 *	0	Access to private PCI space. 	 * 	 *	1	Unused. 	 */
define|#
directive|define
name|PCI_MAPREG_MEM_ADDR
parameter_list|(
name|x
parameter_list|)
value|((x)& 0xfffffff0)
name|sc
operator|->
name|sc_owin
index|[
literal|0
index|]
operator|.
name|owin_xlate_lo
operator|=
name|PCI_MAPREG_MEM_ADDR
argument_list|(
name|sc
operator|->
name|sc_iwin
index|[
literal|1
index|]
operator|.
name|iwin_base_lo
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_owin
index|[
literal|0
index|]
operator|.
name|owin_xlate_hi
operator|=
name|sc
operator|->
name|sc_iwin
index|[
literal|1
index|]
operator|.
name|iwin_base_hi
expr_stmt|;
comment|/* 	 * Set the Secondary Outbound I/O window to map 	 * to PCI address 0 for all 64K of the I/O space. 	 */
name|sc
operator|->
name|sc_ioout_xlate
operator|=
literal|0
expr_stmt|;
name|i80321_attach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|i80321_dr
operator|.
name|dr_sysbase
operator|=
name|sc
operator|->
name|sc_iwin
index|[
literal|2
index|]
operator|.
name|iwin_xlate
expr_stmt|;
name|i80321_dr
operator|.
name|dr_busbase
operator|=
name|PCI_MAPREG_MEM_ADDR
argument_list|(
name|sc
operator|->
name|sc_iwin
index|[
literal|2
index|]
operator|.
name|iwin_base_lo
argument_list|)
expr_stmt|;
name|i80321_dr
operator|.
name|dr_len
operator|=
name|sc
operator|->
name|sc_iwin
index|[
literal|2
index|]
operator|.
name|iwin_size
expr_stmt|;
name|dma_range_init
operator|=
literal|1
expr_stmt|;
name|busno
operator|=
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|sc_st
argument_list|,
name|sc
operator|->
name|sc_atu_sh
argument_list|,
name|ATU_PCIXSR
argument_list|)
expr_stmt|;
name|busno
operator|=
name|PCIXSR_BUSNO
argument_list|(
name|busno
argument_list|)
expr_stmt|;
if|if
condition|(
name|busno
operator|==
literal|0xff
condition|)
name|busno
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_irq_rman
operator|.
name|rm_type
operator|=
name|RMAN_ARRAY
expr_stmt|;
name|sc
operator|->
name|sc_irq_rman
operator|.
name|rm_descr
operator|=
literal|"i80321 IRQs"
expr_stmt|;
if|if
condition|(
name|rman_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_irq_rman
argument_list|)
operator|!=
literal|0
operator|||
name|rman_manage_region
argument_list|(
operator|&
name|sc
operator|->
name|sc_irq_rman
argument_list|,
literal|0
argument_list|,
literal|25
argument_list|)
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"i80321_attach: failed to set up IRQ rman"
argument_list|)
expr_stmt|;
name|device_add_child
argument_list|(
name|dev
argument_list|,
literal|"obio"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|device_add_child
argument_list|(
name|dev
argument_list|,
literal|"itimer"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|device_add_child
argument_list|(
name|dev
argument_list|,
literal|"iopwdog"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|CPU_XSCALE_80219
name|device_add_child
argument_list|(
name|dev
argument_list|,
literal|"iqseg"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|device_add_child
argument_list|(
name|dev
argument_list|,
literal|"pcib"
argument_list|,
name|busno
argument_list|)
expr_stmt|;
name|device_add_child
argument_list|(
name|dev
argument_list|,
literal|"i80321_dma"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|device_add_child
argument_list|(
name|dev
argument_list|,
literal|"i80321_dma"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|CPU_XSCALE_80219
name|device_add_child
argument_list|(
name|dev
argument_list|,
literal|"i80321_aau"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bus_generic_probe
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|bus_generic_attach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|arm_mask_irq
parameter_list|(
name|uintptr_t
name|nb
parameter_list|)
block|{
name|intr_enabled
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|nb
operator|)
expr_stmt|;
name|i80321_set_intrmask
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arm_unmask_irq
parameter_list|(
name|uintptr_t
name|nb
parameter_list|)
block|{
name|intr_enabled
operator||=
operator|(
literal|1
operator|<<
name|nb
operator|)
expr_stmt|;
name|i80321_set_intrmask
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cpu_reset
parameter_list|()
block|{
operator|(
name|void
operator|)
name|disable_interrupts
argument_list|(
name|I32_bit
operator||
name|F32_bit
argument_list|)
expr_stmt|;
operator|*
operator|(
name|__volatile
name|uint32_t
operator|*
operator|)
operator|(
name|IQ80321_80321_VBASE
operator|+
name|VERDE_ATU_BASE
operator|+
name|ATU_PCSR
operator|)
operator|=
name|PCSR_RIB
operator||
name|PCSR_RPB
expr_stmt|;
name|printf
argument_list|(
literal|"Reset failed!\n"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
empty_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|resource
modifier|*
name|iq80321_alloc_resource
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
modifier|*
name|rid
parameter_list|,
name|u_long
name|start
parameter_list|,
name|u_long
name|end
parameter_list|,
name|u_long
name|count
parameter_list|,
name|u_int
name|flags
parameter_list|)
block|{
name|struct
name|i80321_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|resource
modifier|*
name|rv
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|SYS_RES_IRQ
condition|)
block|{
name|rv
operator|=
name|rman_reserve_resource
argument_list|(
operator|&
name|sc
operator|->
name|sc_irq_rman
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
argument_list|,
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|NULL
condition|)
name|rman_set_rid
argument_list|(
name|rv
argument_list|,
operator|*
name|rid
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iq80321_setup_intr
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|struct
name|resource
modifier|*
name|ires
parameter_list|,
name|int
name|flags
parameter_list|,
name|driver_filter_t
modifier|*
name|filt
parameter_list|,
name|driver_intr_t
modifier|*
name|intr
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|void
modifier|*
modifier|*
name|cookiep
parameter_list|)
block|{
name|BUS_SETUP_INTR
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|child
argument_list|,
name|ires
argument_list|,
name|flags
argument_list|,
name|filt
argument_list|,
name|intr
argument_list|,
name|arg
argument_list|,
name|cookiep
argument_list|)
expr_stmt|;
name|intr_enabled
operator||=
literal|1
operator|<<
name|rman_get_start
argument_list|(
name|ires
argument_list|)
expr_stmt|;
name|i80321_set_intrmask
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iq80321_teardown_intr
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|struct
name|resource
modifier|*
name|res
parameter_list|,
name|void
modifier|*
name|cookie
parameter_list|)
block|{
return|return
operator|(
name|BUS_TEARDOWN_INTR
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|child
argument_list|,
name|res
argument_list|,
name|cookie
argument_list|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|iq80321_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|iq80321_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|iq80321_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_identify
argument_list|,
name|iq80321_identify
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_alloc_resource
argument_list|,
name|iq80321_alloc_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_setup_intr
argument_list|,
name|iq80321_setup_intr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_teardown_intr
argument_list|,
name|iq80321_teardown_intr
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|iq80321_driver
init|=
block|{
literal|"iq"
block|,
name|iq80321_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|i80321_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|iq80321_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|iq
argument_list|,
name|nexus
argument_list|,
name|iq80321_driver
argument_list|,
name|iq80321_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

