begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: i80321.c,v 1.15 2003/10/06 16:06:05 thorpej Exp $	*/
end_comment

begin_comment
comment|/*-  * Copyright (c) 2002 Wasabi Systems, Inc.  * All rights reserved.  *  * Written by Jason R. Thorpe for Wasabi Systems, Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed for the NetBSD Project by  *	Wasabi Systems, Inc.  * 4. The name of Wasabi Systems, Inc. may not be used to endorse  *    or promote products derived from this software without specific prior  *    written permission.  *  * THIS SOFTWARE IS PROVIDED BY WASABI SYSTEMS, INC. ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL WASABI SYSTEMS, INC  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Autoconfiguration support for the Intel i80321 I/O Processor.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_define
define|#
directive|define
name|_ARM32_BUS_DMA_PRIVATE
end_define

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/intr.h>
end_include

begin_include
include|#
directive|include
file|<arm/xscale/i80321/i80321reg.h>
end_include

begin_include
include|#
directive|include
file|<arm/xscale/i80321/i80321var.h>
end_include

begin_include
include|#
directive|include
file|<arm/xscale/i80321/i80321_intr.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_decl_stmt
specifier|volatile
name|uint32_t
name|intr_enabled
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint32_t
name|intr_steer
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Statically-allocated bus_space stucture used to access the  * i80321's own registers.  */
end_comment

begin_decl_stmt
name|struct
name|bus_space
name|i80321_bs_tag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * There can be only one i80321, so we keep a global pointer to  * the softc, so board-specific code can use features of the  * i80321 without having to have a handle on the softc itself.  */
end_comment

begin_decl_stmt
name|struct
name|i80321_softc
modifier|*
name|i80321_softc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Built-in devices. */
end_comment

begin_struct
specifier|static
specifier|const
struct|struct
name|iopxs_device
block|{
specifier|const
name|char
modifier|*
name|id_name
decl_stmt|;
name|bus_addr_t
name|id_offset
decl_stmt|;
name|bus_size_t
name|id_size
decl_stmt|;
block|}
name|iopxs_devices
index|[]
init|=
block|{
block|{
literal|"iopaau"
block|,
name|VERDE_AAU_BASE
block|,
name|VERDE_AAU_SIZE
block|}
block|,
comment|/*	{ "iopdma",	VERDE_DMA_BASE0,	VERDE_DMA_CHSIZE },	*/
comment|/*	{ "iopdma",	VERDE_DMA_BASE1,	VERDE_DMA_CHSIZE },	*/
block|{
literal|"iopiic"
block|,
name|VERDE_I2C_BASE0
block|,
name|VERDE_I2C_CHSIZE
block|}
block|,
block|{
literal|"iopiic"
block|,
name|VERDE_I2C_BASE1
block|,
name|VERDE_I2C_CHSIZE
block|}
block|,
comment|/*	{ "iopssp",	VERDE_SSP_BASE,		VERDE_SSP_SIZE },	*/
block|{
literal|"iopmu"
block|,
name|VERDE_MU_BASE
block|,
name|VERDE_MU_SIZE
block|}
block|,
block|{
literal|"iopwdog"
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|PCI_MAPREG_MEM_ADDR
parameter_list|(
name|x
parameter_list|)
value|((x)& 0xfffffff0)
end_define

begin_comment
comment|/*  * i80321_attach:  *  *	Board-independent attach routine for the i80321.  */
end_comment

begin_function
name|void
name|i80321_attach
parameter_list|(
name|struct
name|i80321_softc
modifier|*
name|sc
parameter_list|)
block|{
name|i80321_softc
operator|=
name|sc
expr_stmt|;
name|uint32_t
name|preg
decl_stmt|;
comment|/* We expect the Memory Controller to be already sliced off. */
comment|/* 	 * Program the Inbound windows. 	 */
name|bus_space_write_4
argument_list|(
name|sc
operator|->
name|sc_st
argument_list|,
name|sc
operator|->
name|sc_atu_sh
argument_list|,
name|ATU_IALR0
argument_list|,
operator|(
literal|0xffffffff
operator|-
operator|(
name|sc
operator|->
name|sc_iwin
index|[
literal|0
index|]
operator|.
name|iwin_size
operator|-
literal|1
operator|)
operator|)
operator|&
literal|0xffffffc0
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|sc
operator|->
name|sc_st
argument_list|,
name|sc
operator|->
name|sc_atu_sh
argument_list|,
name|ATU_IATVR0
argument_list|,
name|sc
operator|->
name|sc_iwin
index|[
literal|0
index|]
operator|.
name|iwin_xlate
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_is_host
condition|)
block|{
name|bus_space_write_4
argument_list|(
name|sc
operator|->
name|sc_st
argument_list|,
name|sc
operator|->
name|sc_atu_sh
argument_list|,
name|PCIR_BARS
argument_list|,
name|sc
operator|->
name|sc_iwin
index|[
literal|0
index|]
operator|.
name|iwin_base_lo
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|sc
operator|->
name|sc_st
argument_list|,
name|sc
operator|->
name|sc_atu_sh
argument_list|,
name|PCIR_BARS
operator|+
literal|0x04
argument_list|,
name|sc
operator|->
name|sc_iwin
index|[
literal|0
index|]
operator|.
name|iwin_base_hi
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|sc_iwin
index|[
literal|0
index|]
operator|.
name|iwin_base_lo
operator|=
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|sc_st
argument_list|,
name|sc
operator|->
name|sc_atu_sh
argument_list|,
name|PCIR_BARS
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_iwin
index|[
literal|0
index|]
operator|.
name|iwin_base_hi
operator|=
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|sc_st
argument_list|,
name|sc
operator|->
name|sc_atu_sh
argument_list|,
name|PCIR_BARS
operator|+
literal|0x04
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_iwin
index|[
literal|0
index|]
operator|.
name|iwin_base_lo
operator|=
name|PCI_MAPREG_MEM_ADDR
argument_list|(
name|sc
operator|->
name|sc_iwin
index|[
literal|0
index|]
operator|.
name|iwin_base_lo
argument_list|)
expr_stmt|;
block|}
name|bus_space_write_4
argument_list|(
name|sc
operator|->
name|sc_st
argument_list|,
name|sc
operator|->
name|sc_atu_sh
argument_list|,
name|ATU_IALR1
argument_list|,
operator|(
literal|0xffffffff
operator|-
operator|(
name|sc
operator|->
name|sc_iwin
index|[
literal|1
index|]
operator|.
name|iwin_size
operator|-
literal|1
operator|)
operator|)
operator|&
literal|0xffffffc0
argument_list|)
expr_stmt|;
comment|/* no xlate for window 1 */
if|if
condition|(
name|sc
operator|->
name|sc_is_host
condition|)
block|{
name|bus_space_write_4
argument_list|(
name|sc
operator|->
name|sc_st
argument_list|,
name|sc
operator|->
name|sc_atu_sh
argument_list|,
name|PCIR_BARS
operator|+
literal|0x08
argument_list|,
name|sc
operator|->
name|sc_iwin
index|[
literal|1
index|]
operator|.
name|iwin_base_lo
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|sc
operator|->
name|sc_st
argument_list|,
name|sc
operator|->
name|sc_atu_sh
argument_list|,
name|PCIR_BARS
operator|+
literal|0x0c
argument_list|,
name|sc
operator|->
name|sc_iwin
index|[
literal|1
index|]
operator|.
name|iwin_base_hi
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|sc_iwin
index|[
literal|1
index|]
operator|.
name|iwin_base_lo
operator|=
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|sc_st
argument_list|,
name|sc
operator|->
name|sc_atu_sh
argument_list|,
name|PCIR_BARS
operator|+
literal|0x08
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_iwin
index|[
literal|1
index|]
operator|.
name|iwin_base_hi
operator|=
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|sc_st
argument_list|,
name|sc
operator|->
name|sc_atu_sh
argument_list|,
name|PCIR_BARS
operator|+
literal|0x0c
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_iwin
index|[
literal|1
index|]
operator|.
name|iwin_base_lo
operator|=
name|PCI_MAPREG_MEM_ADDR
argument_list|(
name|sc
operator|->
name|sc_iwin
index|[
literal|1
index|]
operator|.
name|iwin_base_lo
argument_list|)
expr_stmt|;
block|}
name|bus_space_write_4
argument_list|(
name|sc
operator|->
name|sc_st
argument_list|,
name|sc
operator|->
name|sc_atu_sh
argument_list|,
name|ATU_IALR2
argument_list|,
operator|(
literal|0xffffffff
operator|-
operator|(
name|sc
operator|->
name|sc_iwin
index|[
literal|2
index|]
operator|.
name|iwin_size
operator|-
literal|1
operator|)
operator|)
operator|&
literal|0xffffffc0
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|sc
operator|->
name|sc_st
argument_list|,
name|sc
operator|->
name|sc_atu_sh
argument_list|,
name|ATU_IATVR2
argument_list|,
name|sc
operator|->
name|sc_iwin
index|[
literal|2
index|]
operator|.
name|iwin_xlate
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_is_host
condition|)
block|{
name|bus_space_write_4
argument_list|(
name|sc
operator|->
name|sc_st
argument_list|,
name|sc
operator|->
name|sc_atu_sh
argument_list|,
name|PCIR_BARS
operator|+
literal|0x10
argument_list|,
name|sc
operator|->
name|sc_iwin
index|[
literal|2
index|]
operator|.
name|iwin_base_lo
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|sc
operator|->
name|sc_st
argument_list|,
name|sc
operator|->
name|sc_atu_sh
argument_list|,
name|PCIR_BARS
operator|+
literal|0x14
argument_list|,
name|sc
operator|->
name|sc_iwin
index|[
literal|2
index|]
operator|.
name|iwin_base_hi
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|sc_iwin
index|[
literal|2
index|]
operator|.
name|iwin_base_lo
operator|=
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|sc_st
argument_list|,
name|sc
operator|->
name|sc_atu_sh
argument_list|,
name|PCIR_BARS
operator|+
literal|0x10
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_iwin
index|[
literal|2
index|]
operator|.
name|iwin_base_hi
operator|=
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|sc_st
argument_list|,
name|sc
operator|->
name|sc_atu_sh
argument_list|,
name|PCIR_BARS
operator|+
literal|0x14
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_iwin
index|[
literal|2
index|]
operator|.
name|iwin_base_lo
operator|=
name|PCI_MAPREG_MEM_ADDR
argument_list|(
name|sc
operator|->
name|sc_iwin
index|[
literal|2
index|]
operator|.
name|iwin_base_lo
argument_list|)
expr_stmt|;
block|}
name|bus_space_write_4
argument_list|(
name|sc
operator|->
name|sc_st
argument_list|,
name|sc
operator|->
name|sc_atu_sh
argument_list|,
name|ATU_IALR3
argument_list|,
operator|(
literal|0xffffffff
operator|-
operator|(
name|sc
operator|->
name|sc_iwin
index|[
literal|3
index|]
operator|.
name|iwin_size
operator|-
literal|1
operator|)
operator|)
operator|&
literal|0xffffffc0
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|sc
operator|->
name|sc_st
argument_list|,
name|sc
operator|->
name|sc_atu_sh
argument_list|,
name|ATU_IATVR3
argument_list|,
name|sc
operator|->
name|sc_iwin
index|[
literal|3
index|]
operator|.
name|iwin_xlate
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_is_host
condition|)
block|{
name|bus_space_write_4
argument_list|(
name|sc
operator|->
name|sc_st
argument_list|,
name|sc
operator|->
name|sc_atu_sh
argument_list|,
name|ATU_IABAR3
argument_list|,
name|sc
operator|->
name|sc_iwin
index|[
literal|3
index|]
operator|.
name|iwin_base_lo
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|sc
operator|->
name|sc_st
argument_list|,
name|sc
operator|->
name|sc_atu_sh
argument_list|,
name|ATU_IAUBAR3
argument_list|,
name|sc
operator|->
name|sc_iwin
index|[
literal|3
index|]
operator|.
name|iwin_base_hi
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|sc_iwin
index|[
literal|3
index|]
operator|.
name|iwin_base_lo
operator|=
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|sc_st
argument_list|,
name|sc
operator|->
name|sc_atu_sh
argument_list|,
name|ATU_IABAR3
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_iwin
index|[
literal|3
index|]
operator|.
name|iwin_base_hi
operator|=
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|sc_st
argument_list|,
name|sc
operator|->
name|sc_atu_sh
argument_list|,
name|ATU_IAUBAR3
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_iwin
index|[
literal|3
index|]
operator|.
name|iwin_base_lo
operator|=
name|PCI_MAPREG_MEM_ADDR
argument_list|(
name|sc
operator|->
name|sc_iwin
index|[
literal|3
index|]
operator|.
name|iwin_base_lo
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Mask (disable) the ATU interrupt sources. 	 * XXX May want to revisit this if we encounter 	 * XXX an application that wants it. 	 */
name|bus_space_write_4
argument_list|(
name|sc
operator|->
name|sc_st
argument_list|,
name|sc
operator|->
name|sc_atu_sh
argument_list|,
name|ATU_ATUIMR
argument_list|,
name|ATUIMR_IMW1BU
operator||
name|ATUIMR_ISCEM
operator||
name|ATUIMR_RSCEM
operator||
name|ATUIMR_PST
operator||
name|ATUIMR_DPE
operator||
name|ATUIMR_P_SERR_ASRT
operator||
name|ATUIMR_PMA
operator||
name|ATUIMR_PTAM
operator||
name|ATUIMR_PTAT
operator||
name|ATUIMR_PMPE
argument_list|)
expr_stmt|;
comment|/* 	 * Program the outbound windows. 	 */
name|bus_space_write_4
argument_list|(
name|sc
operator|->
name|sc_st
argument_list|,
name|sc
operator|->
name|sc_atu_sh
argument_list|,
name|ATU_OIOWTVR
argument_list|,
name|sc
operator|->
name|sc_ioout_xlate
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_is_host
condition|)
block|{
name|sc
operator|->
name|sc_owin
index|[
literal|0
index|]
operator|.
name|owin_xlate_lo
operator|=
name|sc
operator|->
name|sc_iwin
index|[
literal|1
index|]
operator|.
name|iwin_base_lo
expr_stmt|;
name|sc
operator|->
name|sc_owin
index|[
literal|0
index|]
operator|.
name|owin_xlate_hi
operator|=
name|sc
operator|->
name|sc_iwin
index|[
literal|1
index|]
operator|.
name|iwin_base_hi
expr_stmt|;
block|}
name|bus_space_write_4
argument_list|(
name|sc
operator|->
name|sc_st
argument_list|,
name|sc
operator|->
name|sc_atu_sh
argument_list|,
name|ATU_OMWTVR0
argument_list|,
name|sc
operator|->
name|sc_owin
index|[
literal|0
index|]
operator|.
name|owin_xlate_lo
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|sc
operator|->
name|sc_st
argument_list|,
name|sc
operator|->
name|sc_atu_sh
argument_list|,
name|ATU_OUMWTVR0
argument_list|,
name|sc
operator|->
name|sc_owin
index|[
literal|0
index|]
operator|.
name|owin_xlate_hi
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|sc
operator|->
name|sc_st
argument_list|,
name|sc
operator|->
name|sc_atu_sh
argument_list|,
name|ATU_OMWTVR1
argument_list|,
name|sc
operator|->
name|sc_owin
index|[
literal|1
index|]
operator|.
name|owin_xlate_lo
argument_list|)
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|sc
operator|->
name|sc_st
argument_list|,
name|sc
operator|->
name|sc_atu_sh
argument_list|,
name|ATU_OUMWTVR1
argument_list|,
name|sc
operator|->
name|sc_owin
index|[
literal|1
index|]
operator|.
name|owin_xlate_hi
argument_list|)
expr_stmt|;
comment|/* 	 * Set up the ATU configuration register.  All we do 	 * right now is enable Outbound Windows. 	 */
name|bus_space_write_4
argument_list|(
name|sc
operator|->
name|sc_st
argument_list|,
name|sc
operator|->
name|sc_atu_sh
argument_list|,
name|ATU_ATUCR
argument_list|,
name|ATUCR_OUT_EN
argument_list|)
expr_stmt|;
comment|/* 	 * Enable bus mastering, memory access, SERR, and parity 	 * checking on the ATU. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_is_host
condition|)
block|{
name|preg
operator|=
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|sc_st
argument_list|,
name|sc
operator|->
name|sc_atu_sh
argument_list|,
name|PCIR_COMMAND
argument_list|)
expr_stmt|;
name|preg
operator||=
name|PCIM_CMD_MEMEN
operator||
name|PCIM_CMD_BUSMASTEREN
operator||
name|PCIM_CMD_PERRESPEN
operator||
name|PCIM_CMD_SERRESPEN
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|sc
operator|->
name|sc_st
argument_list|,
name|sc
operator|->
name|sc_atu_sh
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|preg
argument_list|)
expr_stmt|;
name|preg
operator|=
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|sc_st
argument_list|,
name|sc
operator|->
name|sc_atu_sh
argument_list|,
name|PCIR_COMMAND
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize the bus space tags. */
name|i80321_io_bs_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_pci_iot
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|i80321_mem_bs_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_pci_memt
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|intr_enabled
operator|=
literal|0
expr_stmt|;
name|i80321_set_intrmask
argument_list|()
expr_stmt|;
name|i80321_set_intrsteer
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|uint32_t
name|i80321_iintsrc_read
parameter_list|(
name|void
parameter_list|)
block|{
name|uint32_t
name|iintsrc
decl_stmt|;
asm|__asm __volatile("mrc p6, 0, %0, c8, c0, 0"
block|:
literal|"=r"
operator|(
name|iintsrc
operator|)
block|)
function|;
end_function

begin_comment
comment|/* 	 * The IINTSRC register shows bits that are active even 	 * if they are masked in INTCTL, so we have to mask them 	 * off with the interrupts we consider enabled. 	 */
end_comment

begin_return
return|return
operator|(
name|iintsrc
operator|&
name|intr_enabled
operator|)
return|;
end_return

begin_macro
unit|}  int
name|arm_get_next_irq
argument_list|()
end_macro

begin_block
block|{
name|int
name|irq
decl_stmt|;
if|if
condition|(
operator|(
name|irq
operator|=
name|i80321_iintsrc_read
argument_list|()
operator|)
condition|)
return|return
operator|(
name|ffs
argument_list|(
name|irq
argument_list|)
operator|-
literal|1
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

end_unit

