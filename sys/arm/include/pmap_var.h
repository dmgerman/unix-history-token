begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright 2014 Svatopluk Kraus<onwahe@gmail.com>  * Copyright 2014 Michal Meloun<meloun@miracle.cz>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_MACHINE_PMAP_VAR_H_
end_ifndef

begin_define
define|#
directive|define
name|_MACHINE_PMAP_VAR_H_
end_define

begin_include
include|#
directive|include
file|<machine/cpu-v6.h>
end_include

begin_comment
comment|/*  *  Various PMAP defines, exports, and inline functions  *  definitions also usable in other MD code.  */
end_comment

begin_comment
comment|/*  A number of pages in L1 page table. */
end_comment

begin_define
define|#
directive|define
name|NPG_IN_PT1
value|(NB_IN_PT1 / PAGE_SIZE)
end_define

begin_comment
comment|/*  A number of L2 page tables in a page. */
end_comment

begin_define
define|#
directive|define
name|NPT2_IN_PG
value|(PAGE_SIZE / NB_IN_PT2)
end_define

begin_comment
comment|/*  A number of L2 page table entries in a page. */
end_comment

begin_define
define|#
directive|define
name|NPTE2_IN_PG
value|(NPT2_IN_PG * NPTE2_IN_PT2)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_comment
comment|/*  *  A L2 page tables page contains NPT2_IN_PG L2 page tables. Masking of  *  pte1_idx by PT2PG_MASK gives us an index to associated L2 page table  *  in a page. The PT2PG_SHIFT definition depends on NPT2_IN_PG strictly.  *  I.e., (1<< PT2PG_SHIFT) == NPT2_IN_PG must be fulfilled.  */
end_comment

begin_define
define|#
directive|define
name|PT2PG_SHIFT
value|2
end_define

begin_define
define|#
directive|define
name|PT2PG_MASK
value|((1<< PT2PG_SHIFT) - 1)
end_define

begin_comment
comment|/*  *  A PT2TAB holds all allocated L2 page table pages in a pmap.  *  Right shifting of virtual address by PT2TAB_SHIFT gives us an index  *  to L2 page table page in PT2TAB which holds the address mapping.  */
end_comment

begin_define
define|#
directive|define
name|PT2TAB_ENTRIES
value|(NPTE1_IN_PT1 / NPT2_IN_PG)
end_define

begin_define
define|#
directive|define
name|PT2TAB_SHIFT
value|(PTE1_SHIFT + PT2PG_SHIFT)
end_define

begin_comment
comment|/*  *  All allocated L2 page table pages in a pmap are mapped into PT2MAP space.  *  An virtual address right shifting by PT2MAP_SHIFT gives us an index to PTE2  *  which maps the address.  */
end_comment

begin_define
define|#
directive|define
name|PT2MAP_SIZE
value|(NPTE1_IN_PT1 * NB_IN_PT2)
end_define

begin_define
define|#
directive|define
name|PT2MAP_SHIFT
value|PTE2_SHIFT
end_define

begin_decl_stmt
specifier|extern
name|pt1_entry_t
modifier|*
name|kern_pt1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|pt2_entry_t
modifier|*
name|kern_pt2tab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|pt2_entry_t
modifier|*
name|PT2MAP
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *  Virtual interface for L1 page table management.  */
end_comment

begin_function
specifier|static
name|__inline
name|u_int
name|pte1_index
parameter_list|(
name|vm_offset_t
name|va
parameter_list|)
block|{
return|return
operator|(
name|va
operator|>>
name|PTE1_SHIFT
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|pt1_entry_t
modifier|*
name|pte1_ptr
parameter_list|(
name|pt1_entry_t
modifier|*
name|pt1
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
return|return
operator|(
name|pt1
operator|+
name|pte1_index
argument_list|(
name|va
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|vm_offset_t
name|pte1_trunc
parameter_list|(
name|vm_offset_t
name|va
parameter_list|)
block|{
return|return
operator|(
name|va
operator|&
name|PTE1_FRAME
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|vm_offset_t
name|pte1_roundup
parameter_list|(
name|vm_offset_t
name|va
parameter_list|)
block|{
return|return
operator|(
operator|(
name|va
operator|+
name|PTE1_OFFSET
operator|)
operator|&
name|PTE1_FRAME
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  Virtual interface for L1 page table entries management.  *  *  XXX: Some of the following functions now with a synchronization barrier  *  are called in a loop, so it could be useful to have two versions of them.  *  One with the barrier and one without the barrier. In this case, pure  *  barrier pte1_sync() should be implemented as well.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|pte1_sync
parameter_list|(
name|pt1_entry_t
modifier|*
name|pte1p
parameter_list|)
block|{
name|dsb
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|PMAP_PTE_NOCACHE
if|if
condition|(
operator|!
name|cpuinfo
operator|.
name|coherent_walk
condition|)
name|dcache_wb_pou
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|pte1p
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pte1p
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|pte1_sync_range
parameter_list|(
name|pt1_entry_t
modifier|*
name|pte1p
parameter_list|,
name|vm_size_t
name|size
parameter_list|)
block|{
name|dsb
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|PMAP_PTE_NOCACHE
if|if
condition|(
operator|!
name|cpuinfo
operator|.
name|coherent_walk
condition|)
name|dcache_wb_pou
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|pte1p
argument_list|,
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|pte1_store
parameter_list|(
name|pt1_entry_t
modifier|*
name|pte1p
parameter_list|,
name|pt1_entry_t
name|pte1
parameter_list|)
block|{
name|atomic_store_rel_int
argument_list|(
name|pte1p
argument_list|,
name|pte1
argument_list|)
expr_stmt|;
name|pte1_sync
argument_list|(
name|pte1p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|pte1_clear
parameter_list|(
name|pt1_entry_t
modifier|*
name|pte1p
parameter_list|)
block|{
name|pte1_store
argument_list|(
name|pte1p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|pte1_clear_bit
parameter_list|(
name|pt1_entry_t
modifier|*
name|pte1p
parameter_list|,
name|uint32_t
name|bit
parameter_list|)
block|{
name|atomic_clear_int
argument_list|(
name|pte1p
argument_list|,
name|bit
argument_list|)
expr_stmt|;
name|pte1_sync
argument_list|(
name|pte1p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|boolean_t
name|pte1_cmpset
parameter_list|(
name|pt1_entry_t
modifier|*
name|pte1p
parameter_list|,
name|pt1_entry_t
name|opte1
parameter_list|,
name|pt1_entry_t
name|npte1
parameter_list|)
block|{
name|boolean_t
name|ret
decl_stmt|;
name|ret
operator|=
name|atomic_cmpset_int
argument_list|(
name|pte1p
argument_list|,
name|opte1
argument_list|,
name|npte1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|pte1_sync
argument_list|(
name|pte1p
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|boolean_t
name|pte1_is_link
parameter_list|(
name|pt1_entry_t
name|pte1
parameter_list|)
block|{
return|return
operator|(
operator|(
name|pte1
operator|&
name|L1_TYPE_MASK
operator|)
operator|==
name|L1_TYPE_C
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|pte1_is_section
parameter_list|(
name|pt1_entry_t
name|pte1
parameter_list|)
block|{
return|return
operator|(
operator|(
name|pte1
operator|&
name|L1_TYPE_MASK
operator|)
operator|==
name|L1_TYPE_S
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|boolean_t
name|pte1_is_dirty
parameter_list|(
name|pt1_entry_t
name|pte1
parameter_list|)
block|{
return|return
operator|(
operator|(
name|pte1
operator|&
operator|(
name|PTE1_NM
operator||
name|PTE1_RO
operator|)
operator|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|boolean_t
name|pte1_is_global
parameter_list|(
name|pt1_entry_t
name|pte1
parameter_list|)
block|{
return|return
operator|(
operator|(
name|pte1
operator|&
name|PTE1_NG
operator|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|boolean_t
name|pte1_is_valid
parameter_list|(
name|pt1_entry_t
name|pte1
parameter_list|)
block|{
name|int
name|l1_type
decl_stmt|;
name|l1_type
operator|=
name|pte1
operator|&
name|L1_TYPE_MASK
expr_stmt|;
return|return
operator|(
operator|(
name|l1_type
operator|==
name|L1_TYPE_C
operator|)
operator|||
operator|(
name|l1_type
operator|==
name|L1_TYPE_S
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|boolean_t
name|pte1_is_wired
parameter_list|(
name|pt1_entry_t
name|pte1
parameter_list|)
block|{
return|return
operator|(
name|pte1
operator|&
name|PTE1_W
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|pt1_entry_t
name|pte1_load
parameter_list|(
name|pt1_entry_t
modifier|*
name|pte1p
parameter_list|)
block|{
name|pt1_entry_t
name|pte1
decl_stmt|;
name|pte1
operator|=
operator|*
name|pte1p
expr_stmt|;
return|return
operator|(
name|pte1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|pt1_entry_t
name|pte1_load_clear
parameter_list|(
name|pt1_entry_t
modifier|*
name|pte1p
parameter_list|)
block|{
name|pt1_entry_t
name|opte1
decl_stmt|;
name|opte1
operator|=
name|atomic_readandclear_int
argument_list|(
name|pte1p
argument_list|)
expr_stmt|;
name|pte1_sync
argument_list|(
name|pte1p
argument_list|)
expr_stmt|;
return|return
operator|(
name|opte1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|pte1_set_bit
parameter_list|(
name|pt1_entry_t
modifier|*
name|pte1p
parameter_list|,
name|uint32_t
name|bit
parameter_list|)
block|{
name|atomic_set_int
argument_list|(
name|pte1p
argument_list|,
name|bit
argument_list|)
expr_stmt|;
name|pte1_sync
argument_list|(
name|pte1p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|vm_paddr_t
name|pte1_pa
parameter_list|(
name|pt1_entry_t
name|pte1
parameter_list|)
block|{
return|return
operator|(
call|(
name|vm_paddr_t
call|)
argument_list|(
name|pte1
operator|&
name|PTE1_FRAME
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|vm_paddr_t
name|pte1_link_pa
parameter_list|(
name|pt1_entry_t
name|pte1
parameter_list|)
block|{
return|return
operator|(
call|(
name|vm_paddr_t
call|)
argument_list|(
name|pte1
operator|&
name|L1_C_ADDR_MASK
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  Virtual interface for L2 page table entries management.  *  *  XXX: Some of the following functions now with a synchronization barrier  *  are called in a loop, so it could be useful to have two versions of them.  *  One with the barrier and one without the barrier.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|pte2_sync
parameter_list|(
name|pt2_entry_t
modifier|*
name|pte2p
parameter_list|)
block|{
name|dsb
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|PMAP_PTE_NOCACHE
if|if
condition|(
operator|!
name|cpuinfo
operator|.
name|coherent_walk
condition|)
name|dcache_wb_pou
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|pte2p
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pte2p
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|pte2_sync_range
parameter_list|(
name|pt2_entry_t
modifier|*
name|pte2p
parameter_list|,
name|vm_size_t
name|size
parameter_list|)
block|{
name|dsb
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|PMAP_PTE_NOCACHE
if|if
condition|(
operator|!
name|cpuinfo
operator|.
name|coherent_walk
condition|)
name|dcache_wb_pou
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|pte2p
argument_list|,
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|pte2_store
parameter_list|(
name|pt2_entry_t
modifier|*
name|pte2p
parameter_list|,
name|pt2_entry_t
name|pte2
parameter_list|)
block|{
name|atomic_store_rel_int
argument_list|(
name|pte2p
argument_list|,
name|pte2
argument_list|)
expr_stmt|;
name|pte2_sync
argument_list|(
name|pte2p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|pte2_clear
parameter_list|(
name|pt2_entry_t
modifier|*
name|pte2p
parameter_list|)
block|{
name|pte2_store
argument_list|(
name|pte2p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|pte2_clear_bit
parameter_list|(
name|pt2_entry_t
modifier|*
name|pte2p
parameter_list|,
name|uint32_t
name|bit
parameter_list|)
block|{
name|atomic_clear_int
argument_list|(
name|pte2p
argument_list|,
name|bit
argument_list|)
expr_stmt|;
name|pte2_sync
argument_list|(
name|pte2p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|boolean_t
name|pte2_cmpset
parameter_list|(
name|pt2_entry_t
modifier|*
name|pte2p
parameter_list|,
name|pt2_entry_t
name|opte2
parameter_list|,
name|pt2_entry_t
name|npte2
parameter_list|)
block|{
name|boolean_t
name|ret
decl_stmt|;
name|ret
operator|=
name|atomic_cmpset_int
argument_list|(
name|pte2p
argument_list|,
name|opte2
argument_list|,
name|npte2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|pte2_sync
argument_list|(
name|pte2p
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|boolean_t
name|pte2_is_dirty
parameter_list|(
name|pt2_entry_t
name|pte2
parameter_list|)
block|{
return|return
operator|(
operator|(
name|pte2
operator|&
operator|(
name|PTE2_NM
operator||
name|PTE2_RO
operator|)
operator|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|boolean_t
name|pte2_is_global
parameter_list|(
name|pt2_entry_t
name|pte2
parameter_list|)
block|{
return|return
operator|(
operator|(
name|pte2
operator|&
name|PTE2_NG
operator|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|boolean_t
name|pte2_is_valid
parameter_list|(
name|pt2_entry_t
name|pte2
parameter_list|)
block|{
return|return
operator|(
name|pte2
operator|&
name|PTE2_V
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|boolean_t
name|pte2_is_wired
parameter_list|(
name|pt2_entry_t
name|pte2
parameter_list|)
block|{
return|return
operator|(
name|pte2
operator|&
name|PTE2_W
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|pt2_entry_t
name|pte2_load
parameter_list|(
name|pt2_entry_t
modifier|*
name|pte2p
parameter_list|)
block|{
name|pt2_entry_t
name|pte2
decl_stmt|;
name|pte2
operator|=
operator|*
name|pte2p
expr_stmt|;
return|return
operator|(
name|pte2
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|pt2_entry_t
name|pte2_load_clear
parameter_list|(
name|pt2_entry_t
modifier|*
name|pte2p
parameter_list|)
block|{
name|pt2_entry_t
name|opte2
decl_stmt|;
name|opte2
operator|=
name|atomic_readandclear_int
argument_list|(
name|pte2p
argument_list|)
expr_stmt|;
name|pte2_sync
argument_list|(
name|pte2p
argument_list|)
expr_stmt|;
return|return
operator|(
name|opte2
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|pte2_set_bit
parameter_list|(
name|pt2_entry_t
modifier|*
name|pte2p
parameter_list|,
name|uint32_t
name|bit
parameter_list|)
block|{
name|atomic_set_int
argument_list|(
name|pte2p
argument_list|,
name|bit
argument_list|)
expr_stmt|;
name|pte2_sync
argument_list|(
name|pte2p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|pte2_set_wired
parameter_list|(
name|pt2_entry_t
modifier|*
name|pte2p
parameter_list|,
name|boolean_t
name|wired
parameter_list|)
block|{
comment|/* 	 * Wired bit is transparent for page table walk, 	 * so pte2_sync() is not needed. 	 */
if|if
condition|(
name|wired
condition|)
name|atomic_set_int
argument_list|(
name|pte2p
argument_list|,
name|PTE2_W
argument_list|)
expr_stmt|;
else|else
name|atomic_clear_int
argument_list|(
name|pte2p
argument_list|,
name|PTE2_W
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|vm_paddr_t
name|pte2_pa
parameter_list|(
name|pt2_entry_t
name|pte2
parameter_list|)
block|{
return|return
operator|(
call|(
name|vm_paddr_t
call|)
argument_list|(
name|pte2
operator|&
name|PTE2_FRAME
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|u_int
name|pte2_attr
parameter_list|(
name|pt2_entry_t
name|pte2
parameter_list|)
block|{
return|return
operator|(
call|(
name|u_int
call|)
argument_list|(
name|pte2
operator|&
name|PTE2_ATTR_MASK
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  Virtual interface for L2 page tables mapping management.  */
end_comment

begin_function
specifier|static
name|__inline
name|u_int
name|pt2tab_index
parameter_list|(
name|vm_offset_t
name|va
parameter_list|)
block|{
return|return
operator|(
name|va
operator|>>
name|PT2TAB_SHIFT
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|pt2_entry_t
modifier|*
name|pt2tab_entry
parameter_list|(
name|pt2_entry_t
modifier|*
name|pt2tab
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
return|return
operator|(
name|pt2tab
operator|+
name|pt2tab_index
argument_list|(
name|va
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|pt2tab_store
parameter_list|(
name|pt2_entry_t
modifier|*
name|pte2p
parameter_list|,
name|pt2_entry_t
name|pte2
parameter_list|)
block|{
name|pte2_store
argument_list|(
name|pte2p
argument_list|,
name|pte2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|pt2_entry_t
name|pt2tab_load
parameter_list|(
name|pt2_entry_t
modifier|*
name|pte2p
parameter_list|)
block|{
return|return
operator|(
name|pte2_load
argument_list|(
name|pte2p
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|pt2_entry_t
name|pt2tab_load_clear
parameter_list|(
name|pt2_entry_t
modifier|*
name|pte2p
parameter_list|)
block|{
return|return
operator|(
name|pte2_load_clear
argument_list|(
name|pte2p
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|u_int
name|pt2map_index
parameter_list|(
name|vm_offset_t
name|va
parameter_list|)
block|{
return|return
operator|(
name|va
operator|>>
name|PT2MAP_SHIFT
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|pt2_entry_t
modifier|*
name|pt2map_entry
parameter_list|(
name|vm_offset_t
name|va
parameter_list|)
block|{
return|return
operator|(
name|PT2MAP
operator|+
name|pt2map_index
argument_list|(
name|va
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  Virtual interface for pmap structure& kernel shortcuts.  */
end_comment

begin_function
specifier|static
name|__inline
name|pt1_entry_t
modifier|*
name|pmap_pte1
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
return|return
operator|(
name|pte1_ptr
argument_list|(
name|pmap
operator|->
name|pm_pt1
argument_list|,
name|va
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|pt1_entry_t
modifier|*
name|kern_pte1
parameter_list|(
name|vm_offset_t
name|va
parameter_list|)
block|{
return|return
operator|(
name|pte1_ptr
argument_list|(
name|kern_pt1
argument_list|,
name|va
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|pt2_entry_t
modifier|*
name|pmap_pt2tab_entry
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
return|return
operator|(
name|pt2tab_entry
argument_list|(
name|pmap
operator|->
name|pm_pt2tab
argument_list|,
name|va
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|pt2_entry_t
modifier|*
name|kern_pt2tab_entry
parameter_list|(
name|vm_offset_t
name|va
parameter_list|)
block|{
return|return
operator|(
name|pt2tab_entry
argument_list|(
name|kern_pt2tab
argument_list|,
name|va
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|vm_page_t
name|pmap_pt2_page
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|pt2_entry_t
name|pte2
decl_stmt|;
name|pte2
operator|=
name|pte2_load
argument_list|(
name|pmap_pt2tab_entry
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|PHYS_TO_VM_PAGE
argument_list|(
name|pte2
operator|&
name|PTE2_FRAME
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|vm_page_t
name|kern_pt2_page
parameter_list|(
name|vm_offset_t
name|va
parameter_list|)
block|{
name|pt2_entry_t
name|pte2
decl_stmt|;
name|pte2
operator|=
name|pte2_load
argument_list|(
name|kern_pt2tab_entry
argument_list|(
name|va
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|PHYS_TO_VM_PAGE
argument_list|(
name|pte2
operator|&
name|PTE2_FRAME
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _KERNEL */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !_MACHINE_PMAP_VAR_H_ */
end_comment

end_unit

