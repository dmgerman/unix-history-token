begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2016 Jared McNeill<jmcneill@invisible.ca>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,  * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED  * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * Allwinner Gigabit Ethernet MAC (EMAC) controller  */
end_comment

begin_include
include|#
directive|include
file|"opt_device_polling.h"
end_include

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/gpio.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/ofw_bus.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/ofw_bus_subr.h>
end_include

begin_include
include|#
directive|include
file|<arm/allwinner/if_awgreg.h>
end_include

begin_include
include|#
directive|include
file|<arm/allwinner/aw_sid.h>
end_include

begin_include
include|#
directive|include
file|<dev/mii/mii.h>
end_include

begin_include
include|#
directive|include
file|<dev/mii/miivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/extres/clk/clk.h>
end_include

begin_include
include|#
directive|include
file|<dev/extres/hwreset/hwreset.h>
end_include

begin_include
include|#
directive|include
file|<dev/extres/regulator/regulator.h>
end_include

begin_include
include|#
directive|include
file|"miibus_if.h"
end_include

begin_include
include|#
directive|include
file|"gpio_if.h"
end_include

begin_define
define|#
directive|define
name|RD4
parameter_list|(
name|sc
parameter_list|,
name|reg
parameter_list|)
value|bus_read_4((sc)->res[_RES_EMAC], (reg))
end_define

begin_define
define|#
directive|define
name|WR4
parameter_list|(
name|sc
parameter_list|,
name|reg
parameter_list|,
name|val
parameter_list|)
value|bus_write_4((sc)->res[_RES_EMAC], (reg), (val))
end_define

begin_define
define|#
directive|define
name|AWG_LOCK
parameter_list|(
name|sc
parameter_list|)
value|mtx_lock(&(sc)->mtx)
end_define

begin_define
define|#
directive|define
name|AWG_UNLOCK
parameter_list|(
name|sc
parameter_list|)
value|mtx_unlock(&(sc)->mtx);
end_define

begin_define
define|#
directive|define
name|AWG_ASSERT_LOCKED
parameter_list|(
name|sc
parameter_list|)
value|mtx_assert(&(sc)->mtx, MA_OWNED)
end_define

begin_define
define|#
directive|define
name|AWG_ASSERT_UNLOCKED
parameter_list|(
name|sc
parameter_list|)
value|mtx_assert(&(sc)->mtx, MA_NOTOWNED)
end_define

begin_define
define|#
directive|define
name|DESC_ALIGN
value|4
end_define

begin_define
define|#
directive|define
name|TX_DESC_COUNT
value|1024
end_define

begin_define
define|#
directive|define
name|TX_DESC_SIZE
value|(sizeof(struct emac_desc) * TX_DESC_COUNT)
end_define

begin_define
define|#
directive|define
name|RX_DESC_COUNT
value|256
end_define

begin_define
define|#
directive|define
name|RX_DESC_SIZE
value|(sizeof(struct emac_desc) * RX_DESC_COUNT)
end_define

begin_define
define|#
directive|define
name|DESC_OFF
parameter_list|(
name|n
parameter_list|)
value|((n) * sizeof(struct emac_desc))
end_define

begin_define
define|#
directive|define
name|TX_NEXT
parameter_list|(
name|n
parameter_list|)
value|(((n) + 1)& (TX_DESC_COUNT - 1))
end_define

begin_define
define|#
directive|define
name|TX_SKIP
parameter_list|(
name|n
parameter_list|,
name|o
parameter_list|)
value|(((n) + (o))& (TX_DESC_COUNT - 1))
end_define

begin_define
define|#
directive|define
name|RX_NEXT
parameter_list|(
name|n
parameter_list|)
value|(((n) + 1)& (RX_DESC_COUNT - 1))
end_define

begin_define
define|#
directive|define
name|TX_MAX_SEGS
value|10
end_define

begin_define
define|#
directive|define
name|SOFT_RST_RETRY
value|1000
end_define

begin_define
define|#
directive|define
name|MII_BUSY_RETRY
value|1000
end_define

begin_define
define|#
directive|define
name|MDIO_FREQ
value|2500000
end_define

begin_define
define|#
directive|define
name|BURST_LEN_DEFAULT
value|8
end_define

begin_define
define|#
directive|define
name|RX_TX_PRI_DEFAULT
value|0
end_define

begin_define
define|#
directive|define
name|PAUSE_TIME_DEFAULT
value|0x400
end_define

begin_define
define|#
directive|define
name|TX_INTERVAL_DEFAULT
value|64
end_define

begin_define
define|#
directive|define
name|RX_BATCH_DEFAULT
value|64
end_define

begin_comment
comment|/* syscon EMAC clock register */
end_comment

begin_define
define|#
directive|define
name|EMAC_CLK_EPHY_ADDR
value|(0x1f<< 20)
end_define

begin_comment
comment|/* H3 */
end_comment

begin_define
define|#
directive|define
name|EMAC_CLK_EPHY_ADDR_SHIFT
value|20
end_define

begin_define
define|#
directive|define
name|EMAC_CLK_EPHY_LED_POL
value|(1<< 17)
end_define

begin_comment
comment|/* H3 */
end_comment

begin_define
define|#
directive|define
name|EMAC_CLK_EPHY_SHUTDOWN
value|(1<< 16)
end_define

begin_comment
comment|/* H3 */
end_comment

begin_define
define|#
directive|define
name|EMAC_CLK_EPHY_SELECT
value|(1<< 15)
end_define

begin_comment
comment|/* H3 */
end_comment

begin_define
define|#
directive|define
name|EMAC_CLK_RMII_EN
value|(1<< 13)
end_define

begin_define
define|#
directive|define
name|EMAC_CLK_ETXDC
value|(0x7<< 10)
end_define

begin_define
define|#
directive|define
name|EMAC_CLK_ETXDC_SHIFT
value|10
end_define

begin_define
define|#
directive|define
name|EMAC_CLK_ERXDC
value|(0x1f<< 5)
end_define

begin_define
define|#
directive|define
name|EMAC_CLK_ERXDC_SHIFT
value|5
end_define

begin_define
define|#
directive|define
name|EMAC_CLK_PIT
value|(0x1<< 2)
end_define

begin_define
define|#
directive|define
name|EMAC_CLK_PIT_MII
value|(0<< 2)
end_define

begin_define
define|#
directive|define
name|EMAC_CLK_PIT_RGMII
value|(1<< 2)
end_define

begin_define
define|#
directive|define
name|EMAC_CLK_SRC
value|(0x3<< 0)
end_define

begin_define
define|#
directive|define
name|EMAC_CLK_SRC_MII
value|(0<< 0)
end_define

begin_define
define|#
directive|define
name|EMAC_CLK_SRC_EXT_RGMII
value|(1<< 0)
end_define

begin_define
define|#
directive|define
name|EMAC_CLK_SRC_RGMII
value|(2<< 0)
end_define

begin_comment
comment|/* Burst length of RX and TX DMA transfers */
end_comment

begin_decl_stmt
specifier|static
name|int
name|awg_burst_len
init|=
name|BURST_LEN_DEFAULT
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.awg.burst_len"
argument_list|,
operator|&
name|awg_burst_len
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* RX / TX DMA priority. If 1, RX DMA has priority over TX DMA. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|awg_rx_tx_pri
init|=
name|RX_TX_PRI_DEFAULT
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.awg.rx_tx_pri"
argument_list|,
operator|&
name|awg_rx_tx_pri
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Pause time field in the transmitted control frame */
end_comment

begin_decl_stmt
specifier|static
name|int
name|awg_pause_time
init|=
name|PAUSE_TIME_DEFAULT
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.awg.pause_time"
argument_list|,
operator|&
name|awg_pause_time
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Request a TX interrupt every<n> descriptors */
end_comment

begin_decl_stmt
specifier|static
name|int
name|awg_tx_interval
init|=
name|TX_INTERVAL_DEFAULT
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.awg.tx_interval"
argument_list|,
operator|&
name|awg_tx_interval
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Maximum number of mbufs to send to if_input */
end_comment

begin_decl_stmt
specifier|static
name|int
name|awg_rx_batch
init|=
name|RX_BATCH_DEFAULT
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.awg.rx_batch"
argument_list|,
operator|&
name|awg_rx_batch
argument_list|)
expr_stmt|;
end_expr_stmt

begin_enum
enum|enum
name|awg_type
block|{
name|EMAC_A83T
init|=
literal|1
block|,
name|EMAC_H3
block|,
name|EMAC_A64
block|, }
enum|;
end_enum

begin_decl_stmt
specifier|static
name|struct
name|ofw_compat_data
name|compat_data
index|[]
init|=
block|{
block|{
literal|"allwinner,sun8i-a83t-emac"
block|,
name|EMAC_A83T
block|}
block|,
block|{
literal|"allwinner,sun8i-h3-emac"
block|,
name|EMAC_H3
block|}
block|,
block|{
literal|"allwinner,sun50i-a64-emac"
block|,
name|EMAC_A64
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|awg_bufmap
block|{
name|bus_dmamap_t
name|map
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mbuf
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|awg_txring
block|{
name|bus_dma_tag_t
name|desc_tag
decl_stmt|;
name|bus_dmamap_t
name|desc_map
decl_stmt|;
name|struct
name|emac_desc
modifier|*
name|desc_ring
decl_stmt|;
name|bus_addr_t
name|desc_ring_paddr
decl_stmt|;
name|bus_dma_tag_t
name|buf_tag
decl_stmt|;
name|struct
name|awg_bufmap
name|buf_map
index|[
name|TX_DESC_COUNT
index|]
decl_stmt|;
name|u_int
name|cur
decl_stmt|,
name|next
decl_stmt|,
name|queued
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|awg_rxring
block|{
name|bus_dma_tag_t
name|desc_tag
decl_stmt|;
name|bus_dmamap_t
name|desc_map
decl_stmt|;
name|struct
name|emac_desc
modifier|*
name|desc_ring
decl_stmt|;
name|bus_addr_t
name|desc_ring_paddr
decl_stmt|;
name|bus_dma_tag_t
name|buf_tag
decl_stmt|;
name|struct
name|awg_bufmap
name|buf_map
index|[
name|RX_DESC_COUNT
index|]
decl_stmt|;
name|u_int
name|cur
decl_stmt|;
block|}
struct|;
end_struct

begin_enum
enum|enum
block|{
name|_RES_EMAC
block|,
name|_RES_IRQ
block|,
name|_RES_SYSCON
block|,
name|_RES_NITEMS
block|}
enum|;
end_enum

begin_struct
struct|struct
name|awg_softc
block|{
name|struct
name|resource
modifier|*
name|res
index|[
name|_RES_NITEMS
index|]
decl_stmt|;
name|struct
name|mtx
name|mtx
decl_stmt|;
name|if_t
name|ifp
decl_stmt|;
name|device_t
name|miibus
decl_stmt|;
name|struct
name|callout
name|stat_ch
decl_stmt|;
name|struct
name|task
name|link_task
decl_stmt|;
name|void
modifier|*
name|ih
decl_stmt|;
name|u_int
name|mdc_div_ratio_m
decl_stmt|;
name|int
name|link
decl_stmt|;
name|int
name|if_flags
decl_stmt|;
name|enum
name|awg_type
name|type
decl_stmt|;
name|struct
name|awg_txring
name|tx
decl_stmt|;
name|struct
name|awg_rxring
name|rx
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|resource_spec
name|awg_spec
index|[]
init|=
block|{
block|{
name|SYS_RES_MEMORY
block|,
literal|0
block|,
name|RF_ACTIVE
block|}
block|,
block|{
name|SYS_RES_IRQ
block|,
literal|0
block|,
name|RF_ACTIVE
block|}
block|,
block|{
name|SYS_RES_MEMORY
block|,
literal|1
block|,
name|RF_ACTIVE
operator||
name|RF_OPTIONAL
block|}
block|,
block|{
operator|-
literal|1
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|awg_miibus_readreg
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|phy
parameter_list|,
name|int
name|reg
parameter_list|)
block|{
name|struct
name|awg_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|retry
decl_stmt|,
name|val
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|EMAC_MII_CMD
argument_list|,
operator|(
name|sc
operator|->
name|mdc_div_ratio_m
operator|<<
name|MDC_DIV_RATIO_M_SHIFT
operator|)
operator||
operator|(
name|phy
operator|<<
name|PHY_ADDR_SHIFT
operator|)
operator||
operator|(
name|reg
operator|<<
name|PHY_REG_ADDR_SHIFT
operator|)
operator||
name|MII_BUSY
argument_list|)
expr_stmt|;
for|for
control|(
name|retry
operator|=
name|MII_BUSY_RETRY
init|;
name|retry
operator|>
literal|0
condition|;
name|retry
operator|--
control|)
block|{
if|if
condition|(
operator|(
name|RD4
argument_list|(
name|sc
argument_list|,
name|EMAC_MII_CMD
argument_list|)
operator|&
name|MII_BUSY
operator|)
operator|==
literal|0
condition|)
block|{
name|val
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|EMAC_MII_DATA
argument_list|)
expr_stmt|;
break|break;
block|}
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|retry
operator|==
literal|0
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"phy read timeout, phy=%d reg=%d\n"
argument_list|,
name|phy
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|awg_miibus_writereg
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|phy
parameter_list|,
name|int
name|reg
parameter_list|,
name|int
name|val
parameter_list|)
block|{
name|struct
name|awg_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|retry
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|EMAC_MII_DATA
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|EMAC_MII_CMD
argument_list|,
operator|(
name|sc
operator|->
name|mdc_div_ratio_m
operator|<<
name|MDC_DIV_RATIO_M_SHIFT
operator|)
operator||
operator|(
name|phy
operator|<<
name|PHY_ADDR_SHIFT
operator|)
operator||
operator|(
name|reg
operator|<<
name|PHY_REG_ADDR_SHIFT
operator|)
operator||
name|MII_WR
operator||
name|MII_BUSY
argument_list|)
expr_stmt|;
for|for
control|(
name|retry
operator|=
name|MII_BUSY_RETRY
init|;
name|retry
operator|>
literal|0
condition|;
name|retry
operator|--
control|)
block|{
if|if
condition|(
operator|(
name|RD4
argument_list|(
name|sc
argument_list|,
name|EMAC_MII_CMD
argument_list|)
operator|&
name|MII_BUSY
operator|)
operator|==
literal|0
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|retry
operator|==
literal|0
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"phy write timeout, phy=%d reg=%d\n"
argument_list|,
name|phy
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|awg_update_link_locked
parameter_list|(
name|struct
name|awg_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|AWG_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|if_getdrvflags
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
return|return;
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|miibus
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mii
operator|->
name|mii_media_status
operator|&
operator|(
name|IFM_ACTIVE
operator||
name|IFM_AVALID
operator|)
operator|)
operator|==
operator|(
name|IFM_ACTIVE
operator||
name|IFM_AVALID
operator|)
condition|)
block|{
switch|switch
condition|(
name|IFM_SUBTYPE
argument_list|(
name|mii
operator|->
name|mii_media_active
argument_list|)
condition|)
block|{
case|case
name|IFM_1000_T
case|:
case|case
name|IFM_1000_SX
case|:
case|case
name|IFM_100_TX
case|:
case|case
name|IFM_10_T
case|:
name|sc
operator|->
name|link
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|sc
operator|->
name|link
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
else|else
name|sc
operator|->
name|link
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|link
operator|==
literal|0
condition|)
return|return;
name|val
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|EMAC_BASIC_CTL_0
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
operator|(
name|BASIC_CTL_SPEED
operator||
name|BASIC_CTL_DUPLEX
operator|)
expr_stmt|;
if|if
condition|(
name|IFM_SUBTYPE
argument_list|(
name|mii
operator|->
name|mii_media_active
argument_list|)
operator|==
name|IFM_1000_T
operator|||
name|IFM_SUBTYPE
argument_list|(
name|mii
operator|->
name|mii_media_active
argument_list|)
operator|==
name|IFM_1000_SX
condition|)
name|val
operator||=
name|BASIC_CTL_SPEED_1000
operator|<<
name|BASIC_CTL_SPEED_SHIFT
expr_stmt|;
elseif|else
if|if
condition|(
name|IFM_SUBTYPE
argument_list|(
name|mii
operator|->
name|mii_media_active
argument_list|)
operator|==
name|IFM_100_TX
condition|)
name|val
operator||=
name|BASIC_CTL_SPEED_100
operator|<<
name|BASIC_CTL_SPEED_SHIFT
expr_stmt|;
else|else
name|val
operator||=
name|BASIC_CTL_SPEED_10
operator|<<
name|BASIC_CTL_SPEED_SHIFT
expr_stmt|;
if|if
condition|(
operator|(
name|IFM_OPTIONS
argument_list|(
name|mii
operator|->
name|mii_media_active
argument_list|)
operator|&
name|IFM_FDX
operator|)
operator|!=
literal|0
condition|)
name|val
operator||=
name|BASIC_CTL_DUPLEX
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|EMAC_BASIC_CTL_0
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|EMAC_RX_CTL_0
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
name|RX_FLOW_CTL_EN
expr_stmt|;
if|if
condition|(
operator|(
name|IFM_OPTIONS
argument_list|(
name|mii
operator|->
name|mii_media_active
argument_list|)
operator|&
name|IFM_ETH_RXPAUSE
operator|)
operator|!=
literal|0
condition|)
name|val
operator||=
name|RX_FLOW_CTL_EN
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|EMAC_RX_CTL_0
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|EMAC_TX_FLOW_CTL
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
operator|(
name|PAUSE_TIME
operator||
name|TX_FLOW_CTL_EN
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|IFM_OPTIONS
argument_list|(
name|mii
operator|->
name|mii_media_active
argument_list|)
operator|&
name|IFM_ETH_TXPAUSE
operator|)
operator|!=
literal|0
condition|)
name|val
operator||=
name|TX_FLOW_CTL_EN
expr_stmt|;
if|if
condition|(
operator|(
name|IFM_OPTIONS
argument_list|(
name|mii
operator|->
name|mii_media_active
argument_list|)
operator|&
name|IFM_FDX
operator|)
operator|!=
literal|0
condition|)
name|val
operator||=
name|awg_pause_time
operator|<<
name|PAUSE_TIME_SHIFT
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|EMAC_TX_FLOW_CTL
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|awg_link_task
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|awg_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|AWG_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|awg_update_link_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|AWG_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|awg_miibus_statchg
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|awg_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|taskqueue_swi
argument_list|,
operator|&
name|sc
operator|->
name|link_task
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|awg_media_status
parameter_list|(
name|if_t
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
block|{
name|struct
name|awg_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|sc
operator|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|miibus
argument_list|)
expr_stmt|;
name|AWG_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mii_pollstat
argument_list|(
name|mii
argument_list|)
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator|=
name|mii
operator|->
name|mii_media_active
expr_stmt|;
name|ifmr
operator|->
name|ifm_status
operator|=
name|mii
operator|->
name|mii_media_status
expr_stmt|;
name|AWG_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|awg_media_change
parameter_list|(
name|if_t
name|ifp
parameter_list|)
block|{
name|struct
name|awg_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|miibus
argument_list|)
expr_stmt|;
name|AWG_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|mii_mediachg
argument_list|(
name|mii
argument_list|)
expr_stmt|;
name|AWG_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|awg_setup_txdesc
parameter_list|(
name|struct
name|awg_softc
modifier|*
name|sc
parameter_list|,
name|int
name|index
parameter_list|,
name|int
name|flags
parameter_list|,
name|bus_addr_t
name|paddr
parameter_list|,
name|u_int
name|len
parameter_list|)
block|{
name|uint32_t
name|status
decl_stmt|,
name|size
decl_stmt|;
if|if
condition|(
name|paddr
operator|==
literal|0
operator|||
name|len
operator|==
literal|0
condition|)
block|{
name|status
operator|=
literal|0
expr_stmt|;
name|size
operator|=
literal|0
expr_stmt|;
operator|--
name|sc
operator|->
name|tx
operator|.
name|queued
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|TX_DESC_CTL
expr_stmt|;
name|size
operator|=
name|flags
operator||
name|len
expr_stmt|;
if|if
condition|(
operator|(
name|index
operator|&
operator|(
name|awg_tx_interval
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
name|size
operator||=
name|TX_INT_CTL
expr_stmt|;
operator|++
name|sc
operator|->
name|tx
operator|.
name|queued
expr_stmt|;
block|}
name|sc
operator|->
name|tx
operator|.
name|desc_ring
index|[
name|index
index|]
operator|.
name|addr
operator|=
name|htole32
argument_list|(
operator|(
name|uint32_t
operator|)
name|paddr
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tx
operator|.
name|desc_ring
index|[
name|index
index|]
operator|.
name|size
operator|=
name|htole32
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tx
operator|.
name|desc_ring
index|[
name|index
index|]
operator|.
name|status
operator|=
name|htole32
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|awg_setup_txbuf
parameter_list|(
name|struct
name|awg_softc
modifier|*
name|sc
parameter_list|,
name|int
name|index
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
parameter_list|)
block|{
name|bus_dma_segment_t
name|segs
index|[
name|TX_MAX_SEGS
index|]
decl_stmt|;
name|int
name|error
decl_stmt|,
name|nsegs
decl_stmt|,
name|cur
decl_stmt|,
name|i
decl_stmt|,
name|flags
decl_stmt|;
name|u_int
name|csum_flags
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|m
operator|=
operator|*
name|mp
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|sc
operator|->
name|tx
operator|.
name|buf_tag
argument_list|,
name|sc
operator|->
name|tx
operator|.
name|buf_map
index|[
name|index
index|]
operator|.
name|map
argument_list|,
name|m
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EFBIG
condition|)
block|{
name|m
operator|=
name|m_collapse
argument_list|(
name|m
argument_list|,
name|M_NOWAIT
argument_list|,
name|TX_MAX_SEGS
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|*
name|mp
operator|=
name|m
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|sc
operator|->
name|tx
operator|.
name|buf_tag
argument_list|,
name|sc
operator|->
name|tx
operator|.
name|buf_map
index|[
name|index
index|]
operator|.
name|map
argument_list|,
name|m
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|tx
operator|.
name|buf_tag
argument_list|,
name|sc
operator|->
name|tx
operator|.
name|buf_map
index|[
name|index
index|]
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|flags
operator|=
name|TX_FIR_DESC
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_IP
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
operator|(
name|CSUM_TCP
operator||
name|CSUM_UDP
operator|)
operator|)
operator|!=
literal|0
condition|)
name|csum_flags
operator|=
name|TX_CHECKSUM_CTL_FULL
expr_stmt|;
else|else
name|csum_flags
operator|=
name|TX_CHECKSUM_CTL_IP
expr_stmt|;
name|flags
operator||=
operator|(
name|csum_flags
operator|<<
name|TX_CHECKSUM_CTL_SHIFT
operator|)
expr_stmt|;
block|}
for|for
control|(
name|cur
operator|=
name|index
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsegs
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|tx
operator|.
name|buf_map
index|[
name|cur
index|]
operator|.
name|mbuf
operator|=
operator|(
name|i
operator|==
literal|0
condition|?
name|m
else|:
name|NULL
operator|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|nsegs
operator|-
literal|1
condition|)
name|flags
operator||=
name|TX_LAST_DESC
expr_stmt|;
name|awg_setup_txdesc
argument_list|(
name|sc
argument_list|,
name|cur
argument_list|,
name|flags
argument_list|,
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
argument_list|,
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
argument_list|)
expr_stmt|;
name|flags
operator|&=
operator|~
name|TX_FIR_DESC
expr_stmt|;
name|cur
operator|=
name|TX_NEXT
argument_list|(
name|cur
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|nsegs
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|awg_setup_rxdesc
parameter_list|(
name|struct
name|awg_softc
modifier|*
name|sc
parameter_list|,
name|int
name|index
parameter_list|,
name|bus_addr_t
name|paddr
parameter_list|)
block|{
name|uint32_t
name|status
decl_stmt|,
name|size
decl_stmt|;
name|status
operator|=
name|RX_DESC_CTL
expr_stmt|;
name|size
operator|=
name|MCLBYTES
operator|-
literal|1
expr_stmt|;
name|sc
operator|->
name|rx
operator|.
name|desc_ring
index|[
name|index
index|]
operator|.
name|addr
operator|=
name|htole32
argument_list|(
operator|(
name|uint32_t
operator|)
name|paddr
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rx
operator|.
name|desc_ring
index|[
name|index
index|]
operator|.
name|size
operator|=
name|htole32
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rx
operator|.
name|desc_ring
index|[
name|index
index|]
operator|.
name|next
operator|=
name|htole32
argument_list|(
name|sc
operator|->
name|rx
operator|.
name|desc_ring_paddr
operator|+
name|DESC_OFF
argument_list|(
name|RX_NEXT
argument_list|(
name|index
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rx
operator|.
name|desc_ring
index|[
name|index
index|]
operator|.
name|status
operator|=
name|htole32
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|awg_setup_rxbuf
parameter_list|(
name|struct
name|awg_softc
modifier|*
name|sc
parameter_list|,
name|int
name|index
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|bus_dma_segment_t
name|seg
decl_stmt|;
name|int
name|error
decl_stmt|,
name|nsegs
decl_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
name|ETHER_ALIGN
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|sc
operator|->
name|rx
operator|.
name|buf_tag
argument_list|,
name|sc
operator|->
name|rx
operator|.
name|buf_map
index|[
name|index
index|]
operator|.
name|map
argument_list|,
name|m
argument_list|,
operator|&
name|seg
argument_list|,
operator|&
name|nsegs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|rx
operator|.
name|buf_tag
argument_list|,
name|sc
operator|->
name|rx
operator|.
name|buf_map
index|[
name|index
index|]
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
name|sc
operator|->
name|rx
operator|.
name|buf_map
index|[
name|index
index|]
operator|.
name|mbuf
operator|=
name|m
expr_stmt|;
name|awg_setup_rxdesc
argument_list|(
name|sc
argument_list|,
name|index
argument_list|,
name|seg
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|awg_alloc_mbufcl
parameter_list|(
name|struct
name|awg_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|m
operator|=
name|m_getcl
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_ext
operator|.
name|ext_size
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|awg_start_locked
parameter_list|(
name|struct
name|awg_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|if_t
name|ifp
decl_stmt|;
name|int
name|cnt
decl_stmt|,
name|nsegs
decl_stmt|;
name|AWG_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|link
condition|)
return|return;
name|ifp
operator|=
name|sc
operator|->
name|ifp
expr_stmt|;
if|if
condition|(
operator|(
name|if_getdrvflags
argument_list|(
name|ifp
argument_list|)
operator|&
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
operator|)
operator|!=
name|IFF_DRV_RUNNING
condition|)
return|return;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
condition|;
name|cnt
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|tx
operator|.
name|queued
operator|>=
name|TX_DESC_COUNT
operator|-
name|TX_MAX_SEGS
condition|)
block|{
name|if_setdrvflagbits
argument_list|(
name|ifp
argument_list|,
name|IFF_DRV_OACTIVE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
name|m
operator|=
name|if_dequeue
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
name|nsegs
operator|=
name|awg_setup_txbuf
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|tx
operator|.
name|cur
argument_list|,
operator|&
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsegs
operator|==
literal|0
condition|)
block|{
name|if_sendq_prepend
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
break|break;
block|}
name|if_bpfmtap
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tx
operator|.
name|cur
operator|=
name|TX_SKIP
argument_list|(
name|sc
operator|->
name|tx
operator|.
name|cur
argument_list|,
name|nsegs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cnt
operator|!=
literal|0
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|tx
operator|.
name|desc_tag
argument_list|,
name|sc
operator|->
name|tx
operator|.
name|desc_map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* Start and run TX DMA */
name|val
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|EMAC_TX_CTL_1
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|EMAC_TX_CTL_1
argument_list|,
name|val
operator||
name|TX_DMA_START
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|awg_start
parameter_list|(
name|if_t
name|ifp
parameter_list|)
block|{
name|struct
name|awg_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|AWG_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|awg_start_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|AWG_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|awg_tick
parameter_list|(
name|void
modifier|*
name|softc
parameter_list|)
block|{
name|struct
name|awg_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|if_t
name|ifp
decl_stmt|;
name|int
name|link
decl_stmt|;
name|sc
operator|=
name|softc
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|ifp
expr_stmt|;
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|miibus
argument_list|)
expr_stmt|;
name|AWG_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|if_getdrvflags
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
return|return;
name|link
operator|=
name|sc
operator|->
name|link
expr_stmt|;
name|mii_tick
argument_list|(
name|mii
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|link
operator|&&
operator|!
name|link
condition|)
name|awg_start_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|stat_ch
argument_list|,
name|hz
argument_list|,
name|awg_tick
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Bit Reversal - http://aggregate.org/MAGIC/#Bit%20Reversal */
end_comment

begin_function
specifier|static
name|uint32_t
name|bitrev32
parameter_list|(
name|uint32_t
name|x
parameter_list|)
block|{
name|x
operator|=
operator|(
operator|(
operator|(
name|x
operator|&
literal|0xaaaaaaaa
operator|)
operator|>>
literal|1
operator|)
operator||
operator|(
operator|(
name|x
operator|&
literal|0x55555555
operator|)
operator|<<
literal|1
operator|)
operator|)
expr_stmt|;
name|x
operator|=
operator|(
operator|(
operator|(
name|x
operator|&
literal|0xcccccccc
operator|)
operator|>>
literal|2
operator|)
operator||
operator|(
operator|(
name|x
operator|&
literal|0x33333333
operator|)
operator|<<
literal|2
operator|)
operator|)
expr_stmt|;
name|x
operator|=
operator|(
operator|(
operator|(
name|x
operator|&
literal|0xf0f0f0f0
operator|)
operator|>>
literal|4
operator|)
operator||
operator|(
operator|(
name|x
operator|&
literal|0x0f0f0f0f
operator|)
operator|<<
literal|4
operator|)
operator|)
expr_stmt|;
name|x
operator|=
operator|(
operator|(
operator|(
name|x
operator|&
literal|0xff00ff00
operator|)
operator|>>
literal|8
operator|)
operator||
operator|(
operator|(
name|x
operator|&
literal|0x00ff00ff
operator|)
operator|<<
literal|8
operator|)
operator|)
expr_stmt|;
return|return
operator|(
name|x
operator|>>
literal|16
operator|)
operator||
operator|(
name|x
operator|<<
literal|16
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|awg_setup_rxfilter
parameter_list|(
name|struct
name|awg_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|,
name|crc
decl_stmt|,
name|hashreg
decl_stmt|,
name|hashbit
decl_stmt|,
name|hash
index|[
literal|2
index|]
decl_stmt|,
name|machi
decl_stmt|,
name|maclo
decl_stmt|;
name|int
name|mc_count
decl_stmt|,
name|mcnt
decl_stmt|,
name|i
decl_stmt|;
name|uint8_t
modifier|*
name|eaddr
decl_stmt|,
modifier|*
name|mta
decl_stmt|;
name|if_t
name|ifp
decl_stmt|;
name|AWG_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|ifp
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
name|hash
index|[
literal|0
index|]
operator|=
name|hash
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|mc_count
operator|=
name|if_multiaddr_count
argument_list|(
name|ifp
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|if_getflags
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFF_PROMISC
condition|)
name|val
operator||=
name|DIS_ADDR_FILTER
expr_stmt|;
elseif|else
if|if
condition|(
name|if_getflags
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFF_ALLMULTI
condition|)
block|{
name|val
operator||=
name|RX_ALL_MULTICAST
expr_stmt|;
name|hash
index|[
literal|0
index|]
operator|=
name|hash
index|[
literal|1
index|]
operator|=
operator|~
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mc_count
operator|>
literal|0
condition|)
block|{
name|val
operator||=
name|HASH_MULTICAST
expr_stmt|;
name|mta
operator|=
name|malloc
argument_list|(
expr|sizeof
operator|(
name|unsigned
name|char
operator|)
operator|*
name|ETHER_ADDR_LEN
operator|*
name|mc_count
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mta
operator|==
name|NULL
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"failed to allocate temporary multicast list\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|if_multiaddr_array
argument_list|(
name|ifp
argument_list|,
name|mta
argument_list|,
operator|&
name|mcnt
argument_list|,
name|mc_count
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mcnt
condition|;
name|i
operator|++
control|)
block|{
name|crc
operator|=
name|ether_crc32_le
argument_list|(
name|mta
operator|+
operator|(
name|i
operator|*
name|ETHER_ADDR_LEN
operator|)
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
operator|&
literal|0x7f
expr_stmt|;
name|crc
operator|=
name|bitrev32
argument_list|(
operator|~
name|crc
argument_list|)
operator|>>
literal|26
expr_stmt|;
name|hashreg
operator|=
operator|(
name|crc
operator|>>
literal|5
operator|)
expr_stmt|;
name|hashbit
operator|=
operator|(
name|crc
operator|&
literal|0x1f
operator|)
expr_stmt|;
name|hash
index|[
name|hashreg
index|]
operator||=
operator|(
literal|1
operator|<<
name|hashbit
operator|)
expr_stmt|;
block|}
name|free
argument_list|(
name|mta
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
comment|/* Write our unicast address */
name|eaddr
operator|=
name|IF_LLADDR
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|machi
operator|=
operator|(
name|eaddr
index|[
literal|5
index|]
operator|<<
literal|8
operator|)
operator||
name|eaddr
index|[
literal|4
index|]
expr_stmt|;
name|maclo
operator|=
operator|(
name|eaddr
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|eaddr
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|eaddr
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|eaddr
index|[
literal|0
index|]
operator|<<
literal|0
operator|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|EMAC_ADDR_HIGH
argument_list|(
literal|0
argument_list|)
argument_list|,
name|machi
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|EMAC_ADDR_LOW
argument_list|(
literal|0
argument_list|)
argument_list|,
name|maclo
argument_list|)
expr_stmt|;
comment|/* Multicast hash filters */
name|WR4
argument_list|(
name|sc
argument_list|,
name|EMAC_RX_HASH_0
argument_list|,
name|hash
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|EMAC_RX_HASH_1
argument_list|,
name|hash
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* RX frame filter config */
name|WR4
argument_list|(
name|sc
argument_list|,
name|EMAC_RX_FRM_FLT
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|awg_enable_intr
parameter_list|(
name|struct
name|awg_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* Enable interrupts */
name|WR4
argument_list|(
name|sc
argument_list|,
name|EMAC_INT_EN
argument_list|,
name|RX_INT_EN
operator||
name|TX_INT_EN
operator||
name|TX_BUF_UA_INT_EN
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|awg_disable_intr
parameter_list|(
name|struct
name|awg_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* Disable interrupts */
name|WR4
argument_list|(
name|sc
argument_list|,
name|EMAC_INT_EN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|awg_init_locked
parameter_list|(
name|struct
name|awg_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|if_t
name|ifp
decl_stmt|;
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|miibus
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|ifp
expr_stmt|;
name|AWG_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|if_getdrvflags
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFF_DRV_RUNNING
condition|)
return|return;
name|awg_setup_rxfilter
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Configure DMA burst length and priorities */
name|val
operator|=
name|awg_burst_len
operator|<<
name|BASIC_CTL_BURST_LEN_SHIFT
expr_stmt|;
if|if
condition|(
name|awg_rx_tx_pri
condition|)
name|val
operator||=
name|BASIC_CTL_RX_TX_PRI
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|EMAC_BASIC_CTL_1
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* Enable interrupts */
ifdef|#
directive|ifdef
name|DEVICE_POLLING
if|if
condition|(
operator|(
name|if_getcapenable
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFCAP_POLLING
operator|)
operator|==
literal|0
condition|)
name|awg_enable_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|else
name|awg_disable_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|#
directive|else
name|awg_enable_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Enable transmit DMA */
name|val
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|EMAC_TX_CTL_1
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|EMAC_TX_CTL_1
argument_list|,
name|val
operator||
name|TX_DMA_EN
operator||
name|TX_MD
operator||
name|TX_NEXT_FRAME
argument_list|)
expr_stmt|;
comment|/* Enable receive DMA */
name|val
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|EMAC_RX_CTL_1
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|EMAC_RX_CTL_1
argument_list|,
name|val
operator||
name|RX_DMA_EN
operator||
name|RX_MD
argument_list|)
expr_stmt|;
comment|/* Enable transmitter */
name|val
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|EMAC_TX_CTL_0
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|EMAC_TX_CTL_0
argument_list|,
name|val
operator||
name|TX_EN
argument_list|)
expr_stmt|;
comment|/* Enable receiver */
name|val
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|EMAC_RX_CTL_0
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|EMAC_RX_CTL_0
argument_list|,
name|val
operator||
name|RX_EN
operator||
name|CHECK_CRC
argument_list|)
expr_stmt|;
name|if_setdrvflagbits
argument_list|(
name|ifp
argument_list|,
name|IFF_DRV_RUNNING
argument_list|,
name|IFF_DRV_OACTIVE
argument_list|)
expr_stmt|;
name|mii_mediachg
argument_list|(
name|mii
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|stat_ch
argument_list|,
name|hz
argument_list|,
name|awg_tick
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|awg_init
parameter_list|(
name|void
modifier|*
name|softc
parameter_list|)
block|{
name|struct
name|awg_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|softc
expr_stmt|;
name|AWG_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|awg_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|AWG_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|awg_stop
parameter_list|(
name|struct
name|awg_softc
modifier|*
name|sc
parameter_list|)
block|{
name|if_t
name|ifp
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|AWG_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|ifp
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|stat_ch
argument_list|)
expr_stmt|;
comment|/* Stop transmit DMA and flush data in the TX FIFO */
name|val
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|EMAC_TX_CTL_1
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
name|TX_DMA_EN
expr_stmt|;
name|val
operator||=
name|FLUSH_TX_FIFO
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|EMAC_TX_CTL_1
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* Disable transmitter */
name|val
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|EMAC_TX_CTL_0
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|EMAC_TX_CTL_0
argument_list|,
name|val
operator|&
operator|~
name|TX_EN
argument_list|)
expr_stmt|;
comment|/* Disable receiver */
name|val
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|EMAC_RX_CTL_0
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|EMAC_RX_CTL_0
argument_list|,
name|val
operator|&
operator|~
name|RX_EN
argument_list|)
expr_stmt|;
comment|/* Disable interrupts */
name|awg_disable_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Disable transmit DMA */
name|val
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|EMAC_TX_CTL_1
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|EMAC_TX_CTL_1
argument_list|,
name|val
operator|&
operator|~
name|TX_DMA_EN
argument_list|)
expr_stmt|;
comment|/* Disable receive DMA */
name|val
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|EMAC_RX_CTL_1
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|EMAC_RX_CTL_1
argument_list|,
name|val
operator|&
operator|~
name|RX_DMA_EN
argument_list|)
expr_stmt|;
name|sc
operator|->
name|link
operator|=
literal|0
expr_stmt|;
name|if_setdrvflagbits
argument_list|(
name|ifp
argument_list|,
literal|0
argument_list|,
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|awg_rxintr
parameter_list|(
name|struct
name|awg_softc
modifier|*
name|sc
parameter_list|)
block|{
name|if_t
name|ifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|m0
decl_stmt|,
modifier|*
name|mh
decl_stmt|,
modifier|*
name|mt
decl_stmt|;
name|int
name|error
decl_stmt|,
name|index
decl_stmt|,
name|len
decl_stmt|,
name|cnt
decl_stmt|,
name|npkt
decl_stmt|;
name|uint32_t
name|status
decl_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|ifp
expr_stmt|;
name|mh
operator|=
name|mt
operator|=
name|NULL
expr_stmt|;
name|cnt
operator|=
literal|0
expr_stmt|;
name|npkt
operator|=
literal|0
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|rx
operator|.
name|desc_tag
argument_list|,
name|sc
operator|->
name|rx
operator|.
name|desc_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
for|for
control|(
name|index
operator|=
name|sc
operator|->
name|rx
operator|.
name|cur
init|;
condition|;
name|index
operator|=
name|RX_NEXT
argument_list|(
name|index
argument_list|)
control|)
block|{
name|status
operator|=
name|le32toh
argument_list|(
name|sc
operator|->
name|rx
operator|.
name|desc_ring
index|[
name|index
index|]
operator|.
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|RX_DESC_CTL
operator|)
operator|!=
literal|0
condition|)
break|break;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|rx
operator|.
name|buf_tag
argument_list|,
name|sc
operator|->
name|rx
operator|.
name|buf_map
index|[
name|index
index|]
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|rx
operator|.
name|buf_tag
argument_list|,
name|sc
operator|->
name|rx
operator|.
name|buf_map
index|[
name|index
index|]
operator|.
name|map
argument_list|)
expr_stmt|;
name|len
operator|=
operator|(
name|status
operator|&
name|RX_FRM_LEN
operator|)
operator|>>
name|RX_FRM_LEN_SHIFT
expr_stmt|;
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
block|{
name|m
operator|=
name|sc
operator|->
name|rx
operator|.
name|buf_map
index|[
name|index
index|]
operator|.
name|mbuf
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_IPACKETS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|if_getcapenable
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFCAP_RXCSUM
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|status
operator|&
name|RX_FRM_TYPE
operator|)
operator|!=
literal|0
condition|)
block|{
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|=
name|CSUM_IP_CHECKED
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|RX_HEADER_ERR
operator|)
operator|==
literal|0
condition|)
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
name|CSUM_IP_VALID
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|RX_PAYLOAD_ERR
operator|)
operator|==
literal|0
condition|)
block|{
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
literal|0xffff
expr_stmt|;
block|}
block|}
name|m
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|mh
operator|==
name|NULL
condition|)
name|mh
operator|=
name|m
expr_stmt|;
else|else
name|mt
operator|->
name|m_nextpkt
operator|=
name|m
expr_stmt|;
name|mt
operator|=
name|m
expr_stmt|;
operator|++
name|cnt
expr_stmt|;
operator|++
name|npkt
expr_stmt|;
if|if
condition|(
name|cnt
operator|==
name|awg_rx_batch
condition|)
block|{
name|AWG_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|if_input
argument_list|(
name|ifp
argument_list|,
name|mh
argument_list|)
expr_stmt|;
name|AWG_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mh
operator|=
name|mt
operator|=
name|NULL
expr_stmt|;
name|cnt
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|m0
operator|=
name|awg_alloc_mbufcl
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|awg_setup_rxbuf
argument_list|(
name|sc
argument_list|,
name|index
argument_list|,
name|m0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
comment|/* XXX hole in RX ring */
block|}
block|}
else|else
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_IQDROPS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|index
operator|!=
name|sc
operator|->
name|rx
operator|.
name|cur
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|rx
operator|.
name|desc_tag
argument_list|,
name|sc
operator|->
name|rx
operator|.
name|desc_map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mh
operator|!=
name|NULL
condition|)
block|{
name|AWG_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|if_input
argument_list|(
name|ifp
argument_list|,
name|mh
argument_list|)
expr_stmt|;
name|AWG_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|rx
operator|.
name|cur
operator|=
name|index
expr_stmt|;
return|return
operator|(
name|npkt
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|awg_txintr
parameter_list|(
name|struct
name|awg_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|awg_bufmap
modifier|*
name|bmap
decl_stmt|;
name|struct
name|emac_desc
modifier|*
name|desc
decl_stmt|;
name|uint32_t
name|status
decl_stmt|;
name|if_t
name|ifp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|AWG_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|tx
operator|.
name|desc_tag
argument_list|,
name|sc
operator|->
name|tx
operator|.
name|desc_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|ifp
expr_stmt|;
for|for
control|(
name|i
operator|=
name|sc
operator|->
name|tx
operator|.
name|next
init|;
name|sc
operator|->
name|tx
operator|.
name|queued
operator|>
literal|0
condition|;
name|i
operator|=
name|TX_NEXT
argument_list|(
name|i
argument_list|)
control|)
block|{
name|desc
operator|=
operator|&
name|sc
operator|->
name|tx
operator|.
name|desc_ring
index|[
name|i
index|]
expr_stmt|;
name|status
operator|=
name|le32toh
argument_list|(
name|desc
operator|->
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|TX_DESC_CTL
operator|)
operator|!=
literal|0
condition|)
break|break;
name|bmap
operator|=
operator|&
name|sc
operator|->
name|tx
operator|.
name|buf_map
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|bmap
operator|->
name|mbuf
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|tx
operator|.
name|buf_tag
argument_list|,
name|bmap
operator|->
name|map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|tx
operator|.
name|buf_tag
argument_list|,
name|bmap
operator|->
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|bmap
operator|->
name|mbuf
argument_list|)
expr_stmt|;
name|bmap
operator|->
name|mbuf
operator|=
name|NULL
expr_stmt|;
block|}
name|awg_setup_txdesc
argument_list|(
name|sc
argument_list|,
name|i
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|if_setdrvflagbits
argument_list|(
name|ifp
argument_list|,
literal|0
argument_list|,
name|IFF_DRV_OACTIVE
argument_list|)
expr_stmt|;
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_OPACKETS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|tx
operator|.
name|next
operator|=
name|i
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|tx
operator|.
name|desc_tag
argument_list|,
name|sc
operator|->
name|tx
operator|.
name|desc_map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|awg_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|awg_softc
modifier|*
name|sc
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|AWG_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|val
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|EMAC_INT_STA
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|EMAC_INT_STA
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|RX_INT
condition|)
name|awg_rxintr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
operator|(
name|TX_INT
operator||
name|TX_BUF_UA_INT
operator|)
condition|)
block|{
name|awg_txintr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|if_sendq_empty
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
condition|)
name|awg_start_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|AWG_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEVICE_POLLING
end_ifdef

begin_function
specifier|static
name|int
name|awg_poll
parameter_list|(
name|if_t
name|ifp
parameter_list|,
name|enum
name|poll_cmd
name|cmd
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|struct
name|awg_softc
modifier|*
name|sc
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|int
name|rx_npkts
decl_stmt|;
name|sc
operator|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|rx_npkts
operator|=
literal|0
expr_stmt|;
name|AWG_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|if_getdrvflags
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
name|AWG_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|rx_npkts
operator|=
name|awg_rxintr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|awg_txintr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|if_sendq_empty
argument_list|(
name|ifp
argument_list|)
condition|)
name|awg_start_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|POLL_AND_CHECK_STATUS
condition|)
block|{
name|val
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|EMAC_INT_STA
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
name|WR4
argument_list|(
name|sc
argument_list|,
name|EMAC_INT_STA
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
name|AWG_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rx_npkts
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|awg_ioctl
parameter_list|(
name|if_t
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|awg_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
decl_stmt|;
name|int
name|flags
decl_stmt|,
name|mask
decl_stmt|,
name|error
decl_stmt|;
name|sc
operator|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|miibus
argument_list|)
expr_stmt|;
name|ifr
operator|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFFLAGS
case|:
name|AWG_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|if_getflags
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
name|if_getdrvflags
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|flags
operator|=
name|if_getflags
argument_list|(
name|ifp
argument_list|)
operator|^
name|sc
operator|->
name|if_flags
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|IFF_PROMISC
operator||
name|IFF_ALLMULTI
operator|)
operator|)
operator|!=
literal|0
condition|)
name|awg_setup_rxfilter
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
name|awg_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|if_getdrvflags
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFF_DRV_RUNNING
condition|)
name|awg_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|if_flags
operator|=
name|if_getflags
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|AWG_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
if|if
condition|(
name|if_getdrvflags
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|AWG_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|awg_setup_rxfilter
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|AWG_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCSIFMEDIA
case|:
case|case
name|SIOCGIFMEDIA
case|:
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|mii
operator|->
name|mii_media
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFCAP
case|:
name|mask
operator|=
name|ifr
operator|->
name|ifr_reqcap
operator|^
name|if_getcapenable
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVICE_POLLING
if|if
condition|(
name|mask
operator|&
name|IFCAP_POLLING
condition|)
block|{
if|if
condition|(
operator|(
name|ifr
operator|->
name|ifr_reqcap
operator|&
name|IFCAP_POLLING
operator|)
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|ether_poll_register
argument_list|(
name|awg_poll
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
name|AWG_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|awg_disable_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|if_setcapenablebit
argument_list|(
name|ifp
argument_list|,
name|IFCAP_POLLING
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|AWG_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|ether_poll_deregister
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|AWG_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|awg_enable_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|if_setcapenablebit
argument_list|(
name|ifp
argument_list|,
literal|0
argument_list|,
name|IFCAP_POLLING
argument_list|)
expr_stmt|;
name|AWG_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|mask
operator|&
name|IFCAP_VLAN_MTU
condition|)
name|if_togglecapenable
argument_list|(
name|ifp
argument_list|,
name|IFCAP_VLAN_MTU
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_RXCSUM
condition|)
name|if_togglecapenable
argument_list|(
name|ifp
argument_list|,
name|IFCAP_RXCSUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_TXCSUM
condition|)
name|if_togglecapenable
argument_list|(
name|ifp
argument_list|,
name|IFCAP_TXCSUM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|if_getcapenable
argument_list|(
name|ifp
argument_list|)
operator|&
operator|(
name|IFCAP_RXCSUM
operator||
name|IFCAP_TXCSUM
operator|)
operator|)
operator|!=
literal|0
condition|)
name|if_sethwassistbits
argument_list|(
name|ifp
argument_list|,
name|CSUM_IP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|if_sethwassistbits
argument_list|(
name|ifp
argument_list|,
literal|0
argument_list|,
name|CSUM_IP
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|awg_setup_phy
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|awg_softc
modifier|*
name|sc
decl_stmt|;
name|clk_t
name|clk_tx
decl_stmt|,
name|clk_tx_parent
decl_stmt|;
specifier|const
name|char
modifier|*
name|tx_parent_name
decl_stmt|;
name|char
modifier|*
name|phy_type
decl_stmt|;
name|phandle_t
name|node
decl_stmt|;
name|uint32_t
name|reg
decl_stmt|,
name|tx_delay
decl_stmt|,
name|rx_delay
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|node
operator|=
name|ofw_bus_get_node
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|OF_getprop_alloc
argument_list|(
name|node
argument_list|,
literal|"phy-mode"
argument_list|,
literal|1
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|phy_type
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"PHY type: %s, conf mode: %s\n"
argument_list|,
name|phy_type
argument_list|,
name|sc
operator|->
name|res
index|[
name|_RES_SYSCON
index|]
operator|!=
name|NULL
condition|?
literal|"reg"
else|:
literal|"clk"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|res
index|[
name|_RES_SYSCON
index|]
operator|!=
name|NULL
condition|)
block|{
name|reg
operator|=
name|bus_read_4
argument_list|(
name|sc
operator|->
name|res
index|[
name|_RES_SYSCON
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
operator|(
name|EMAC_CLK_PIT
operator||
name|EMAC_CLK_SRC
operator||
name|EMAC_CLK_RMII_EN
operator|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|phy_type
argument_list|,
literal|"rgmii"
argument_list|)
operator|==
literal|0
condition|)
name|reg
operator||=
name|EMAC_CLK_PIT_RGMII
operator||
name|EMAC_CLK_SRC_RGMII
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|phy_type
argument_list|,
literal|"rmii"
argument_list|)
operator|==
literal|0
condition|)
name|reg
operator||=
name|EMAC_CLK_RMII_EN
expr_stmt|;
else|else
name|reg
operator||=
name|EMAC_CLK_PIT_MII
operator||
name|EMAC_CLK_SRC_MII
expr_stmt|;
if|if
condition|(
name|OF_getencprop
argument_list|(
name|node
argument_list|,
literal|"tx-delay"
argument_list|,
operator|&
name|tx_delay
argument_list|,
sizeof|sizeof
argument_list|(
name|tx_delay
argument_list|)
argument_list|)
operator|>
literal|0
condition|)
block|{
name|reg
operator|&=
operator|~
name|EMAC_CLK_ETXDC
expr_stmt|;
name|reg
operator||=
operator|(
name|tx_delay
operator|<<
name|EMAC_CLK_ETXDC_SHIFT
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|OF_getencprop
argument_list|(
name|node
argument_list|,
literal|"rx-delay"
argument_list|,
operator|&
name|rx_delay
argument_list|,
sizeof|sizeof
argument_list|(
name|rx_delay
argument_list|)
argument_list|)
operator|>
literal|0
condition|)
block|{
name|reg
operator|&=
operator|~
name|EMAC_CLK_ERXDC
expr_stmt|;
name|reg
operator||=
operator|(
name|rx_delay
operator|<<
name|EMAC_CLK_ERXDC_SHIFT
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|type
operator|==
name|EMAC_H3
condition|)
block|{
if|if
condition|(
name|OF_hasprop
argument_list|(
name|node
argument_list|,
literal|"allwinner,use-internal-phy"
argument_list|)
condition|)
block|{
name|reg
operator||=
name|EMAC_CLK_EPHY_SELECT
expr_stmt|;
name|reg
operator|&=
operator|~
name|EMAC_CLK_EPHY_SHUTDOWN
expr_stmt|;
if|if
condition|(
name|OF_hasprop
argument_list|(
name|node
argument_list|,
literal|"allwinner,leds-active-low"
argument_list|)
condition|)
name|reg
operator||=
name|EMAC_CLK_EPHY_LED_POL
expr_stmt|;
else|else
name|reg
operator|&=
operator|~
name|EMAC_CLK_EPHY_LED_POL
expr_stmt|;
comment|/* Set internal PHY addr to 1 */
name|reg
operator|&=
operator|~
name|EMAC_CLK_EPHY_ADDR
expr_stmt|;
name|reg
operator||=
operator|(
literal|1
operator|<<
name|EMAC_CLK_EPHY_ADDR_SHIFT
operator|)
expr_stmt|;
block|}
else|else
block|{
name|reg
operator|&=
operator|~
name|EMAC_CLK_EPHY_SELECT
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"EMAC clock: 0x%08x\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|bus_write_4
argument_list|(
name|sc
operator|->
name|res
index|[
name|_RES_SYSCON
index|]
argument_list|,
literal|0
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|phy_type
argument_list|,
literal|"rgmii"
argument_list|)
operator|==
literal|0
condition|)
name|tx_parent_name
operator|=
literal|"emac_int_tx"
expr_stmt|;
else|else
name|tx_parent_name
operator|=
literal|"mii_phy_tx"
expr_stmt|;
comment|/* Get the TX clock */
name|error
operator|=
name|clk_get_by_ofw_name
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
literal|"tx"
argument_list|,
operator|&
name|clk_tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot get tx clock\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Find the desired parent clock based on phy-mode property */
name|error
operator|=
name|clk_get_by_name
argument_list|(
name|dev
argument_list|,
name|tx_parent_name
argument_list|,
operator|&
name|clk_tx_parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot get clock '%s'\n"
argument_list|,
name|tx_parent_name
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Set TX clock parent */
name|error
operator|=
name|clk_set_parent_by_clk
argument_list|(
name|clk_tx
argument_list|,
name|clk_tx_parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot set tx clock parent\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Enable TX clock */
name|error
operator|=
name|clk_enable
argument_list|(
name|clk_tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot enable tx clock\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
name|error
operator|=
literal|0
expr_stmt|;
name|fail
label|:
name|OF_prop_free
argument_list|(
name|phy_type
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|awg_setup_extres
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|awg_softc
modifier|*
name|sc
decl_stmt|;
name|hwreset_t
name|rst_ahb
decl_stmt|,
name|rst_ephy
decl_stmt|;
name|clk_t
name|clk_ahb
decl_stmt|,
name|clk_ephy
decl_stmt|;
name|regulator_t
name|reg
decl_stmt|;
name|phandle_t
name|node
decl_stmt|;
name|uint64_t
name|freq
decl_stmt|;
name|int
name|error
decl_stmt|,
name|div
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|node
operator|=
name|ofw_bus_get_node
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|rst_ahb
operator|=
name|rst_ephy
operator|=
name|NULL
expr_stmt|;
name|clk_ahb
operator|=
name|clk_ephy
operator|=
name|NULL
expr_stmt|;
name|reg
operator|=
name|NULL
expr_stmt|;
comment|/* Get AHB clock and reset resources */
name|error
operator|=
name|hwreset_get_by_ofw_name
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
literal|"ahb"
argument_list|,
operator|&
name|rst_ahb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot get ahb reset\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|hwreset_get_by_ofw_name
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
literal|"ephy"
argument_list|,
operator|&
name|rst_ephy
argument_list|)
operator|!=
literal|0
condition|)
name|rst_ephy
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|clk_get_by_ofw_name
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
literal|"ahb"
argument_list|,
operator|&
name|clk_ahb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot get ahb clock\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|clk_get_by_ofw_name
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
literal|"ephy"
argument_list|,
operator|&
name|clk_ephy
argument_list|)
operator|!=
literal|0
condition|)
name|clk_ephy
operator|=
name|NULL
expr_stmt|;
comment|/* Configure PHY for MII or RGMII mode */
if|if
condition|(
name|awg_setup_phy
argument_list|(
name|dev
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
comment|/* Enable clocks */
name|error
operator|=
name|clk_enable
argument_list|(
name|clk_ahb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot enable ahb clock\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|clk_ephy
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|clk_enable
argument_list|(
name|clk_ephy
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot enable ephy clock\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
comment|/* De-assert reset */
name|error
operator|=
name|hwreset_deassert
argument_list|(
name|rst_ahb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot de-assert ahb reset\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|rst_ephy
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|hwreset_deassert
argument_list|(
name|rst_ephy
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot de-assert ephy reset\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
comment|/* Enable PHY regulator if applicable */
if|if
condition|(
name|regulator_get_by_ofw_property
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
literal|"phy-supply"
argument_list|,
operator|&
name|reg
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|regulator_enable
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot enable PHY regulator\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
comment|/* Determine MDC clock divide ratio based on AHB clock */
name|error
operator|=
name|clk_get_freq
argument_list|(
name|clk_ahb
argument_list|,
operator|&
name|freq
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot get AHB clock frequency\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|div
operator|=
name|freq
operator|/
name|MDIO_FREQ
expr_stmt|;
if|if
condition|(
name|div
operator|<=
literal|16
condition|)
name|sc
operator|->
name|mdc_div_ratio_m
operator|=
name|MDC_DIV_RATIO_M_16
expr_stmt|;
elseif|else
if|if
condition|(
name|div
operator|<=
literal|32
condition|)
name|sc
operator|->
name|mdc_div_ratio_m
operator|=
name|MDC_DIV_RATIO_M_32
expr_stmt|;
elseif|else
if|if
condition|(
name|div
operator|<=
literal|64
condition|)
name|sc
operator|->
name|mdc_div_ratio_m
operator|=
name|MDC_DIV_RATIO_M_64
expr_stmt|;
elseif|else
if|if
condition|(
name|div
operator|<=
literal|128
condition|)
name|sc
operator|->
name|mdc_div_ratio_m
operator|=
name|MDC_DIV_RATIO_M_128
expr_stmt|;
else|else
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot determine MDC clock divide ratio\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"AHB frequency %ju Hz, MDC div: 0x%x\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|freq
argument_list|,
name|sc
operator|->
name|mdc_div_ratio_m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
if|if
condition|(
name|reg
operator|!=
name|NULL
condition|)
name|regulator_release
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|clk_ephy
operator|!=
name|NULL
condition|)
name|clk_release
argument_list|(
name|clk_ephy
argument_list|)
expr_stmt|;
if|if
condition|(
name|clk_ahb
operator|!=
name|NULL
condition|)
name|clk_release
argument_list|(
name|clk_ahb
argument_list|)
expr_stmt|;
if|if
condition|(
name|rst_ephy
operator|!=
name|NULL
condition|)
name|hwreset_release
argument_list|(
name|rst_ephy
argument_list|)
expr_stmt|;
if|if
condition|(
name|rst_ahb
operator|!=
name|NULL
condition|)
name|hwreset_release
argument_list|(
name|rst_ahb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|awg_get_eaddr
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|uint8_t
modifier|*
name|eaddr
parameter_list|)
block|{
name|struct
name|awg_softc
modifier|*
name|sc
decl_stmt|;
name|uint32_t
name|maclo
decl_stmt|,
name|machi
decl_stmt|,
name|rnd
decl_stmt|;
name|u_char
name|rootkey
index|[
literal|16
index|]
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|machi
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|EMAC_ADDR_HIGH
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|&
literal|0xffff
expr_stmt|;
name|maclo
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|EMAC_ADDR_LOW
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|maclo
operator|==
literal|0xffffffff
operator|&&
name|machi
operator|==
literal|0xffff
condition|)
block|{
comment|/* MAC address in hardware is invalid, create one */
if|if
condition|(
name|aw_sid_get_rootkey
argument_list|(
name|rootkey
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|rootkey
index|[
literal|3
index|]
operator||
name|rootkey
index|[
literal|12
index|]
operator||
name|rootkey
index|[
literal|13
index|]
operator||
name|rootkey
index|[
literal|14
index|]
operator||
name|rootkey
index|[
literal|15
index|]
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* MAC address is derived from the root key in SID */
name|maclo
operator|=
operator|(
name|rootkey
index|[
literal|13
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|rootkey
index|[
literal|12
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|rootkey
index|[
literal|3
index|]
operator|<<
literal|8
operator|)
operator||
literal|0x02
expr_stmt|;
name|machi
operator|=
operator|(
name|rootkey
index|[
literal|15
index|]
operator|<<
literal|8
operator|)
operator||
name|rootkey
index|[
literal|14
index|]
expr_stmt|;
block|}
else|else
block|{
comment|/* Create one */
name|rnd
operator|=
name|arc4random
argument_list|()
expr_stmt|;
name|maclo
operator|=
literal|0x00f2
operator||
operator|(
name|rnd
operator|&
literal|0xffff0000
operator|)
expr_stmt|;
name|machi
operator|=
name|rnd
operator|&
literal|0xffff
expr_stmt|;
block|}
block|}
name|eaddr
index|[
literal|0
index|]
operator|=
name|maclo
operator|&
literal|0xff
expr_stmt|;
name|eaddr
index|[
literal|1
index|]
operator|=
operator|(
name|maclo
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|eaddr
index|[
literal|2
index|]
operator|=
operator|(
name|maclo
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|eaddr
index|[
literal|3
index|]
operator|=
operator|(
name|maclo
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
name|eaddr
index|[
literal|4
index|]
operator|=
name|machi
operator|&
literal|0xff
expr_stmt|;
name|eaddr
index|[
literal|5
index|]
operator|=
operator|(
name|machi
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|AWG_DEBUG
end_ifdef

begin_function
specifier|static
name|void
name|awg_dump_regs
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
specifier|static
specifier|const
struct|struct
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|u_int
name|reg
decl_stmt|;
block|}
name|regs
index|[]
init|=
block|{
block|{
literal|"BASIC_CTL_0"
block|,
name|EMAC_BASIC_CTL_0
block|}
block|,
block|{
literal|"BASIC_CTL_1"
block|,
name|EMAC_BASIC_CTL_1
block|}
block|,
block|{
literal|"INT_STA"
block|,
name|EMAC_INT_STA
block|}
block|,
block|{
literal|"INT_EN"
block|,
name|EMAC_INT_EN
block|}
block|,
block|{
literal|"TX_CTL_0"
block|,
name|EMAC_TX_CTL_0
block|}
block|,
block|{
literal|"TX_CTL_1"
block|,
name|EMAC_TX_CTL_1
block|}
block|,
block|{
literal|"TX_FLOW_CTL"
block|,
name|EMAC_TX_FLOW_CTL
block|}
block|,
block|{
literal|"TX_DMA_LIST"
block|,
name|EMAC_TX_DMA_LIST
block|}
block|,
block|{
literal|"RX_CTL_0"
block|,
name|EMAC_RX_CTL_0
block|}
block|,
block|{
literal|"RX_CTL_1"
block|,
name|EMAC_RX_CTL_1
block|}
block|,
block|{
literal|"RX_DMA_LIST"
block|,
name|EMAC_RX_DMA_LIST
block|}
block|,
block|{
literal|"RX_FRM_FLT"
block|,
name|EMAC_RX_FRM_FLT
block|}
block|,
block|{
literal|"RX_HASH_0"
block|,
name|EMAC_RX_HASH_0
block|}
block|,
block|{
literal|"RX_HASH_1"
block|,
name|EMAC_RX_HASH_1
block|}
block|,
block|{
literal|"MII_CMD"
block|,
name|EMAC_MII_CMD
block|}
block|,
block|{
literal|"ADDR_HIGH0"
block|,
name|EMAC_ADDR_HIGH
argument_list|(
literal|0
argument_list|)
block|}
block|,
block|{
literal|"ADDR_LOW0"
block|,
name|EMAC_ADDR_LOW
argument_list|(
literal|0
argument_list|)
block|}
block|,
block|{
literal|"TX_DMA_STA"
block|,
name|EMAC_TX_DMA_STA
block|}
block|,
block|{
literal|"TX_DMA_CUR_DESC"
block|,
name|EMAC_TX_DMA_CUR_DESC
block|}
block|,
block|{
literal|"TX_DMA_CUR_BUF"
block|,
name|EMAC_TX_DMA_CUR_BUF
block|}
block|,
block|{
literal|"RX_DMA_STA"
block|,
name|EMAC_RX_DMA_STA
block|}
block|,
block|{
literal|"RX_DMA_CUR_DESC"
block|,
name|EMAC_RX_DMA_CUR_DESC
block|}
block|,
block|{
literal|"RX_DMA_CUR_BUF"
block|,
name|EMAC_RX_DMA_CUR_BUF
block|}
block|,
block|{
literal|"RGMII_STA"
block|,
name|EMAC_RGMII_STA
block|}
block|, 	}
struct|;
name|struct
name|awg_softc
modifier|*
name|sc
decl_stmt|;
name|unsigned
name|int
name|n
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|nitems
argument_list|(
name|regs
argument_list|)
condition|;
name|n
operator|++
control|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"  %-20s %08x\n"
argument_list|,
name|regs
index|[
name|n
index|]
operator|.
name|name
argument_list|,
name|RD4
argument_list|(
name|sc
argument_list|,
name|regs
index|[
name|n
index|]
operator|.
name|reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|GPIO_ACTIVE_LOW
value|1
end_define

begin_function
specifier|static
name|int
name|awg_phy_reset
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|pcell_t
name|gpio_prop
index|[
literal|4
index|]
decl_stmt|,
name|delay_prop
index|[
literal|3
index|]
decl_stmt|;
name|phandle_t
name|node
decl_stmt|,
name|gpio_node
decl_stmt|;
name|device_t
name|gpio
decl_stmt|;
name|uint32_t
name|pin
decl_stmt|,
name|flags
decl_stmt|;
name|uint32_t
name|pin_value
decl_stmt|;
name|node
operator|=
name|ofw_bus_get_node
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|OF_getencprop
argument_list|(
name|node
argument_list|,
literal|"allwinner,reset-gpio"
argument_list|,
name|gpio_prop
argument_list|,
sizeof|sizeof
argument_list|(
name|gpio_prop
argument_list|)
argument_list|)
operator|<=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|OF_getencprop
argument_list|(
name|node
argument_list|,
literal|"allwinner,reset-delays-us"
argument_list|,
name|delay_prop
argument_list|,
sizeof|sizeof
argument_list|(
name|delay_prop
argument_list|)
argument_list|)
operator|<=
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|gpio_node
operator|=
name|OF_node_from_xref
argument_list|(
name|gpio_prop
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|gpio
operator|=
name|OF_device_from_xref
argument_list|(
name|gpio_prop
index|[
literal|0
index|]
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|GPIO_MAP_GPIOS
argument_list|(
name|gpio
argument_list|,
name|node
argument_list|,
name|gpio_node
argument_list|,
name|nitems
argument_list|(
name|gpio_prop
argument_list|)
operator|-
literal|1
argument_list|,
name|gpio_prop
operator|+
literal|1
argument_list|,
operator|&
name|pin
argument_list|,
operator|&
name|flags
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|pin_value
operator|=
name|GPIO_PIN_LOW
expr_stmt|;
if|if
condition|(
name|OF_hasprop
argument_list|(
name|node
argument_list|,
literal|"allwinner,reset-active-low"
argument_list|)
condition|)
name|pin_value
operator|=
name|GPIO_PIN_HIGH
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|GPIO_ACTIVE_LOW
condition|)
name|pin_value
operator|=
operator|!
name|pin_value
expr_stmt|;
name|GPIO_PIN_SETFLAGS
argument_list|(
name|gpio
argument_list|,
name|pin
argument_list|,
name|GPIO_PIN_OUTPUT
argument_list|)
expr_stmt|;
name|GPIO_PIN_SET
argument_list|(
name|gpio
argument_list|,
name|pin
argument_list|,
name|pin_value
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|delay_prop
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|GPIO_PIN_SET
argument_list|(
name|gpio
argument_list|,
name|pin
argument_list|,
operator|!
name|pin_value
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|delay_prop
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|GPIO_PIN_SET
argument_list|(
name|gpio
argument_list|,
name|pin
argument_list|,
name|pin_value
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|delay_prop
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|awg_reset
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|awg_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|retry
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Reset PHY if necessary */
if|if
condition|(
name|awg_phy_reset
argument_list|(
name|dev
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to reset PHY\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Soft reset all registers and logic */
name|WR4
argument_list|(
name|sc
argument_list|,
name|EMAC_BASIC_CTL_1
argument_list|,
name|BASIC_CTL_SOFT_RST
argument_list|)
expr_stmt|;
comment|/* Wait for soft reset bit to self-clear */
for|for
control|(
name|retry
operator|=
name|SOFT_RST_RETRY
init|;
name|retry
operator|>
literal|0
condition|;
name|retry
operator|--
control|)
block|{
if|if
condition|(
operator|(
name|RD4
argument_list|(
name|sc
argument_list|,
name|EMAC_BASIC_CTL_1
argument_list|)
operator|&
name|BASIC_CTL_SOFT_RST
operator|)
operator|==
literal|0
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|retry
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"soft reset timed out\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AWG_DEBUG
name|awg_dump_regs
argument_list|(
name|dev
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|awg_dmamap_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return;
operator|*
operator|(
name|bus_addr_t
operator|*
operator|)
name|arg
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|awg_setup_dma
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|awg_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Setup TX ring */
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|dev
argument_list|)
argument_list|,
comment|/* Parent tag */
name|DESC_ALIGN
argument_list|,
literal|0
argument_list|,
comment|/* alignment, boundary */
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|TX_DESC_SIZE
argument_list|,
literal|1
argument_list|,
comment|/* maxsize, nsegs */
name|TX_DESC_SIZE
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc
operator|->
name|tx
operator|.
name|desc_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot create TX descriptor ring tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|tx
operator|.
name|desc_tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|tx
operator|.
name|desc_ring
argument_list|,
name|BUS_DMA_COHERENT
operator||
name|BUS_DMA_WAITOK
operator||
name|BUS_DMA_ZERO
argument_list|,
operator|&
name|sc
operator|->
name|tx
operator|.
name|desc_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot allocate TX descriptor ring\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|tx
operator|.
name|desc_tag
argument_list|,
name|sc
operator|->
name|tx
operator|.
name|desc_map
argument_list|,
name|sc
operator|->
name|tx
operator|.
name|desc_ring
argument_list|,
name|TX_DESC_SIZE
argument_list|,
name|awg_dmamap_cb
argument_list|,
operator|&
name|sc
operator|->
name|tx
operator|.
name|desc_ring_paddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot load TX descriptor ring\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TX_DESC_COUNT
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|tx
operator|.
name|desc_ring
index|[
name|i
index|]
operator|.
name|next
operator|=
name|htole32
argument_list|(
name|sc
operator|->
name|tx
operator|.
name|desc_ring_paddr
operator|+
name|DESC_OFF
argument_list|(
name|TX_NEXT
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|dev
argument_list|)
argument_list|,
comment|/* Parent tag */
literal|1
argument_list|,
literal|0
argument_list|,
comment|/* alignment, boundary */
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|MCLBYTES
argument_list|,
name|TX_MAX_SEGS
argument_list|,
comment|/* maxsize, nsegs */
name|MCLBYTES
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc
operator|->
name|tx
operator|.
name|buf_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot create TX buffer tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|sc
operator|->
name|tx
operator|.
name|queued
operator|=
name|TX_DESC_COUNT
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TX_DESC_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|tx
operator|.
name|buf_tag
argument_list|,
literal|0
argument_list|,
operator|&
name|sc
operator|->
name|tx
operator|.
name|buf_map
index|[
name|i
index|]
operator|.
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot create TX buffer map\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|awg_setup_txdesc
argument_list|(
name|sc
argument_list|,
name|i
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Setup RX ring */
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|dev
argument_list|)
argument_list|,
comment|/* Parent tag */
name|DESC_ALIGN
argument_list|,
literal|0
argument_list|,
comment|/* alignment, boundary */
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|RX_DESC_SIZE
argument_list|,
literal|1
argument_list|,
comment|/* maxsize, nsegs */
name|RX_DESC_SIZE
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc
operator|->
name|rx
operator|.
name|desc_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot create RX descriptor ring tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|rx
operator|.
name|desc_tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|rx
operator|.
name|desc_ring
argument_list|,
name|BUS_DMA_COHERENT
operator||
name|BUS_DMA_WAITOK
operator||
name|BUS_DMA_ZERO
argument_list|,
operator|&
name|sc
operator|->
name|rx
operator|.
name|desc_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot allocate RX descriptor ring\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|rx
operator|.
name|desc_tag
argument_list|,
name|sc
operator|->
name|rx
operator|.
name|desc_map
argument_list|,
name|sc
operator|->
name|rx
operator|.
name|desc_ring
argument_list|,
name|RX_DESC_SIZE
argument_list|,
name|awg_dmamap_cb
argument_list|,
operator|&
name|sc
operator|->
name|rx
operator|.
name|desc_ring_paddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot load RX descriptor ring\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|dev
argument_list|)
argument_list|,
comment|/* Parent tag */
literal|1
argument_list|,
literal|0
argument_list|,
comment|/* alignment, boundary */
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|MCLBYTES
argument_list|,
literal|1
argument_list|,
comment|/* maxsize, nsegs */
name|MCLBYTES
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc
operator|->
name|rx
operator|.
name|buf_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot create RX buffer tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RX_DESC_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|rx
operator|.
name|buf_tag
argument_list|,
literal|0
argument_list|,
operator|&
name|sc
operator|->
name|rx
operator|.
name|buf_map
index|[
name|i
index|]
operator|.
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot create RX buffer map\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|m
operator|=
name|awg_alloc_mbufcl
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot allocate RX mbuf\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|error
operator|=
name|awg_setup_rxbuf
argument_list|(
name|sc
argument_list|,
name|i
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot create RX buffer\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|rx
operator|.
name|desc_tag
argument_list|,
name|sc
operator|->
name|rx
operator|.
name|desc_map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* Write transmit and receive descriptor base address registers */
name|WR4
argument_list|(
name|sc
argument_list|,
name|EMAC_TX_DMA_LIST
argument_list|,
name|sc
operator|->
name|tx
operator|.
name|desc_ring_paddr
argument_list|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|EMAC_RX_DMA_LIST
argument_list|,
name|sc
operator|->
name|rx
operator|.
name|desc_ring_paddr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|awg_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ofw_bus_status_okay
argument_list|(
name|dev
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|ofw_bus_search_compatible
argument_list|(
name|dev
argument_list|,
name|compat_data
argument_list|)
operator|->
name|ocd_data
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Allwinner Gigabit Ethernet"
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|awg_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|uint8_t
name|eaddr
index|[
name|ETHER_ADDR_LEN
index|]
decl_stmt|;
name|struct
name|awg_softc
modifier|*
name|sc
decl_stmt|;
name|phandle_t
name|node
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|type
operator|=
name|ofw_bus_search_compatible
argument_list|(
name|dev
argument_list|,
name|compat_data
argument_list|)
operator|->
name|ocd_data
expr_stmt|;
name|node
operator|=
name|ofw_bus_get_node
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus_alloc_resources
argument_list|(
name|dev
argument_list|,
name|awg_spec
argument_list|,
name|sc
operator|->
name|res
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot allocate resources for device\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|MTX_NETWORK_LOCK
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|sc
operator|->
name|stat_ch
argument_list|,
operator|&
name|sc
operator|->
name|mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|link_task
argument_list|,
literal|0
argument_list|,
name|awg_link_task
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* Setup clocks and regulators */
name|error
operator|=
name|awg_setup_extres
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Read MAC address before resetting the chip */
name|awg_get_eaddr
argument_list|(
name|dev
argument_list|,
name|eaddr
argument_list|)
expr_stmt|;
comment|/* Soft reset EMAC core */
name|error
operator|=
name|awg_reset
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Setup DMA descriptors */
name|error
operator|=
name|awg_setup_dma
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Install interrupt handler */
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|res
index|[
name|_RES_IRQ
index|]
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|awg_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|ih
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot setup interrupt handler\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Setup ethernet interface */
name|sc
operator|->
name|ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
name|if_setsoftc
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|if_initname
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|if_setflags
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
argument_list|)
expr_stmt|;
name|if_setstartfn
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
name|awg_start
argument_list|)
expr_stmt|;
name|if_setioctlfn
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
name|awg_ioctl
argument_list|)
expr_stmt|;
name|if_setinitfn
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
name|awg_init
argument_list|)
expr_stmt|;
name|if_setsendqlen
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
name|TX_DESC_COUNT
operator|-
literal|1
argument_list|)
expr_stmt|;
name|if_setsendqready
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|if_sethwassist
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
name|CSUM_IP
operator||
name|CSUM_UDP
operator||
name|CSUM_TCP
argument_list|)
expr_stmt|;
name|if_setcapabilities
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
name|IFCAP_VLAN_MTU
operator||
name|IFCAP_HWCSUM
argument_list|)
expr_stmt|;
name|if_setcapenable
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
name|if_getcapabilities
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVICE_POLLING
name|if_setcapabilitiesbit
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
name|IFCAP_POLLING
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Attach MII driver */
name|error
operator|=
name|mii_attach
argument_list|(
name|dev
argument_list|,
operator|&
name|sc
operator|->
name|miibus
argument_list|,
name|sc
operator|->
name|ifp
argument_list|,
name|awg_media_change
argument_list|,
name|awg_media_status
argument_list|,
name|BMSR_DEFCAPMASK
argument_list|,
name|MII_PHY_ANY
argument_list|,
name|MII_OFFSET_ANY
argument_list|,
name|MIIF_DOPAUSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot attach PHY\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Attach ethernet interface */
name|ether_ifattach
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
name|eaddr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|awg_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|awg_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|awg_attach
argument_list|)
block|,
comment|/* MII interface */
name|DEVMETHOD
argument_list|(
name|miibus_readreg
argument_list|,
name|awg_miibus_readreg
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|miibus_writereg
argument_list|,
name|awg_miibus_writereg
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|miibus_statchg
argument_list|,
name|awg_miibus_statchg
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|awg_driver
init|=
block|{
literal|"awg"
block|,
name|awg_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|awg_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|awg_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|awg
argument_list|,
name|simplebus
argument_list|,
name|awg_driver
argument_list|,
name|awg_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|miibus
argument_list|,
name|awg
argument_list|,
name|miibus_driver
argument_list|,
name|miibus_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|awg
argument_list|,
name|ether
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|awg
argument_list|,
name|miibus
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

