begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2016 Ganbold Tsagaankhuu<ganbold@freebsd.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Allwinner Consumer IR controller  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/openfirm.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/ofw_bus.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/ofw_bus_subr.h>
end_include

begin_include
include|#
directive|include
file|<dev/extres/clk/clk.h>
end_include

begin_include
include|#
directive|include
file|<dev/extres/hwreset/hwreset.h>
end_include

begin_include
include|#
directive|include
file|<dev/evdev/input.h>
end_include

begin_include
include|#
directive|include
file|<dev/evdev/evdev.h>
end_include

begin_define
define|#
directive|define
name|READ
parameter_list|(
name|_sc
parameter_list|,
name|_r
parameter_list|)
value|bus_read_4((_sc)->res[0], (_r))
end_define

begin_define
define|#
directive|define
name|WRITE
parameter_list|(
name|_sc
parameter_list|,
name|_r
parameter_list|,
name|_v
parameter_list|)
value|bus_write_4((_sc)->res[0], (_r), (_v))
end_define

begin_comment
comment|/* IR Control */
end_comment

begin_define
define|#
directive|define
name|AW_IR_CTL
value|0x00
end_define

begin_comment
comment|/* Global Enable */
end_comment

begin_define
define|#
directive|define
name|AW_IR_CTL_GEN
value|(1<< 0)
end_define

begin_comment
comment|/* RX enable */
end_comment

begin_define
define|#
directive|define
name|AW_IR_CTL_RXEN
value|(1<< 1)
end_define

begin_comment
comment|/* CIR mode enable */
end_comment

begin_define
define|#
directive|define
name|AW_IR_CTL_MD
value|(1<< 4) | (1<< 5)
end_define

begin_comment
comment|/* RX Config Reg */
end_comment

begin_define
define|#
directive|define
name|AW_IR_RXCTL
value|0x10
end_define

begin_comment
comment|/* Pulse Polarity Invert flag */
end_comment

begin_define
define|#
directive|define
name|AW_IR_RXCTL_RPPI
value|(1<< 2)
end_define

begin_comment
comment|/* RX Data */
end_comment

begin_define
define|#
directive|define
name|AW_IR_RXFIFO
value|0x20
end_define

begin_comment
comment|/* RX Interrupt Control */
end_comment

begin_define
define|#
directive|define
name|AW_IR_RXINT
value|0x2C
end_define

begin_comment
comment|/* RX FIFO Overflow */
end_comment

begin_define
define|#
directive|define
name|AW_IR_RXINT_ROI_EN
value|(1<< 0)
end_define

begin_comment
comment|/* RX Packet End */
end_comment

begin_define
define|#
directive|define
name|AW_IR_RXINT_RPEI_EN
value|(1<< 1)
end_define

begin_comment
comment|/* RX FIFO Data Available */
end_comment

begin_define
define|#
directive|define
name|AW_IR_RXINT_RAI_EN
value|(1<< 4)
end_define

begin_comment
comment|/* RX FIFO available byte level */
end_comment

begin_define
define|#
directive|define
name|AW_IR_RXINT_RAL
parameter_list|(
name|val
parameter_list|)
value|((val)<< 8)
end_define

begin_comment
comment|/* RX Interrupt Status Reg */
end_comment

begin_define
define|#
directive|define
name|AW_IR_RXSTA
value|0x30
end_define

begin_comment
comment|/* RX FIFO Get Available Counter */
end_comment

begin_define
define|#
directive|define
name|AW_IR_RXSTA_COUNTER
parameter_list|(
name|val
parameter_list|)
value|(((val)>> 8)& (sc->fifo_size * 2 - 1))
end_define

begin_comment
comment|/* Clear all interrupt status */
end_comment

begin_define
define|#
directive|define
name|AW_IR_RXSTA_CLEARALL
value|0xff
end_define

begin_comment
comment|/* IR Sample Configure Reg */
end_comment

begin_define
define|#
directive|define
name|AW_IR_CIR
value|0x34
end_define

begin_comment
comment|/*  * Frequency sample: 23437.5Hz (Cycle: 42.7us)  * Pulse of NEC Remote> 560us  */
end_comment

begin_comment
comment|/* Filter Threshold = 8 * 42.7 = ~341us< 500us */
end_comment

begin_define
define|#
directive|define
name|AW_IR_RXFILT_VAL
value|(((8)& 0x3f)<< 2)
end_define

begin_comment
comment|/* Idle Threshold = (2 + 1) * 128 * 42.7 = ~16.4ms> 9ms */
end_comment

begin_define
define|#
directive|define
name|AW_IR_RXIDLE_VAL
value|(((2)& 0xff)<< 8)
end_define

begin_comment
comment|/* Bit 15 - value (pulse/space) */
end_comment

begin_define
define|#
directive|define
name|VAL_MASK
value|0x80
end_define

begin_comment
comment|/* Bits 0:14 - sample duration  */
end_comment

begin_define
define|#
directive|define
name|PERIOD_MASK
value|0x7f
end_define

begin_comment
comment|/* Clock rate for IR0 or IR1 clock in CIR mode */
end_comment

begin_define
define|#
directive|define
name|AW_IR_BASE_CLK
value|3000000
end_define

begin_comment
comment|/* Frequency sample 3MHz/64 = 46875Hz (21.3us) */
end_comment

begin_define
define|#
directive|define
name|AW_IR_SAMPLE_64
value|(0<< 0)
end_define

begin_comment
comment|/* Frequency sample 3MHz/128 = 23437.5Hz (42.7us) */
end_comment

begin_define
define|#
directive|define
name|AW_IR_SAMPLE_128
value|(1<< 0)
end_define

begin_define
define|#
directive|define
name|AW_IR_ERROR_CODE
value|0xffffffff
end_define

begin_define
define|#
directive|define
name|AW_IR_REPEAT_CODE
value|0x0
end_define

begin_comment
comment|/* 80 * 42.7 = ~3.4ms, Lead1(4.5ms)> AW_IR_L1_MIN */
end_comment

begin_define
define|#
directive|define
name|AW_IR_L1_MIN
value|80
end_define

begin_comment
comment|/* 40 * 42.7 = ~1.7ms, Lead0(4.5ms) Lead0R(2.25ms)> AW_IR_L0_MIN */
end_comment

begin_define
define|#
directive|define
name|AW_IR_L0_MIN
value|40
end_define

begin_comment
comment|/* 26 * 42.7 = ~1109us ~= 561 * 2, Pulse< AW_IR_PMAX */
end_comment

begin_define
define|#
directive|define
name|AW_IR_PMAX
value|26
end_define

begin_comment
comment|/* 26 * 42.7 = ~1109us ~= 561 * 2, D1> AW_IR_DMID, D0<= AW_IR_DMID */
end_comment

begin_define
define|#
directive|define
name|AW_IR_DMID
value|26
end_define

begin_comment
comment|/* 53 * 42.7 = ~2263us ~= 561 * 4, D< AW_IR_DMAX */
end_comment

begin_define
define|#
directive|define
name|AW_IR_DMAX
value|53
end_define

begin_comment
comment|/* Active Thresholds */
end_comment

begin_define
define|#
directive|define
name|AW_IR_ACTIVE_T
value|((0& 0xff)<< 16)
end_define

begin_define
define|#
directive|define
name|AW_IR_ACTIVE_T_C
value|((1& 0xff)<< 23)
end_define

begin_comment
comment|/* Code masks */
end_comment

begin_define
define|#
directive|define
name|CODE_MASK
value|0x00ff00ff
end_define

begin_define
define|#
directive|define
name|INV_CODE_MASK
value|0xff00ff00
end_define

begin_define
define|#
directive|define
name|VALID_CODE_MASK
value|0x00ff0000
end_define

begin_define
define|#
directive|define
name|A10_IR
value|1
end_define

begin_define
define|#
directive|define
name|A13_IR
value|2
end_define

begin_define
define|#
directive|define
name|AW_IR_RAW_BUF_SIZE
value|128
end_define

begin_struct
struct|struct
name|aw_ir_softc
block|{
name|device_t
name|dev
decl_stmt|;
name|struct
name|resource
modifier|*
name|res
index|[
literal|2
index|]
decl_stmt|;
name|void
modifier|*
name|intrhand
decl_stmt|;
name|int
name|fifo_size
decl_stmt|;
name|int
name|dcnt
decl_stmt|;
comment|/* Packet Count */
name|unsigned
name|char
name|buf
index|[
name|AW_IR_RAW_BUF_SIZE
index|]
decl_stmt|;
name|struct
name|evdev_dev
modifier|*
name|sc_evdev
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|resource_spec
name|aw_ir_spec
index|[]
init|=
block|{
block|{
name|SYS_RES_MEMORY
block|,
literal|0
block|,
name|RF_ACTIVE
block|}
block|,
block|{
name|SYS_RES_IRQ
block|,
literal|0
block|,
name|RF_ACTIVE
operator||
name|RF_SHAREABLE
block|}
block|,
block|{
operator|-
literal|1
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ofw_compat_data
name|compat_data
index|[]
init|=
block|{
block|{
literal|"allwinner,sun4i-a10-ir"
block|,
name|A10_IR
block|}
block|,
block|{
literal|"allwinner,sun5i-a13-ir"
block|,
name|A13_IR
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|aw_ir_buf_reset
parameter_list|(
name|struct
name|aw_ir_softc
modifier|*
name|sc
parameter_list|)
block|{
name|sc
operator|->
name|dcnt
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|aw_ir_buf_write
parameter_list|(
name|struct
name|aw_ir_softc
modifier|*
name|sc
parameter_list|,
name|unsigned
name|char
name|data
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|dcnt
operator|<
name|AW_IR_RAW_BUF_SIZE
condition|)
name|sc
operator|->
name|buf
index|[
name|sc
operator|->
name|dcnt
operator|++
index|]
operator|=
name|data
expr_stmt|;
elseif|else
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"IR RX Buffer Full!\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|aw_ir_buf_full
parameter_list|(
name|struct
name|aw_ir_softc
modifier|*
name|sc
parameter_list|)
block|{
return|return
operator|(
name|sc
operator|->
name|dcnt
operator|>=
name|AW_IR_RAW_BUF_SIZE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|char
name|aw_ir_read_data
parameter_list|(
name|struct
name|aw_ir_softc
modifier|*
name|sc
parameter_list|)
block|{
return|return
call|(
name|unsigned
name|char
call|)
argument_list|(
name|READ
argument_list|(
name|sc
argument_list|,
name|AW_IR_RXFIFO
argument_list|)
operator|&
literal|0xff
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|long
name|aw_ir_decode_packets
parameter_list|(
name|struct
name|aw_ir_softc
modifier|*
name|sc
parameter_list|)
block|{
name|unsigned
name|long
name|len
decl_stmt|,
name|code
decl_stmt|;
name|unsigned
name|char
name|val
decl_stmt|,
name|last
decl_stmt|;
name|unsigned
name|int
name|active_delay
decl_stmt|;
name|int
name|i
decl_stmt|,
name|bitcount
decl_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"sc->dcnt = %d\n"
argument_list|,
name|sc
operator|->
name|dcnt
argument_list|)
expr_stmt|;
comment|/* Find Lead 1 (bit separator) */
name|active_delay
operator|=
operator|(
name|AW_IR_ACTIVE_T
operator|+
literal|1
operator|)
operator|*
operator|(
name|AW_IR_ACTIVE_T_C
condition|?
literal|128
else|:
literal|1
operator|)
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
name|len
operator|+=
operator|(
name|active_delay
operator|>>
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Initial len: %ld\n"
argument_list|,
name|len
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|dcnt
condition|;
name|i
operator|++
control|)
block|{
name|val
operator|=
name|sc
operator|->
name|buf
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|VAL_MASK
condition|)
name|len
operator|+=
name|val
operator|&
name|PERIOD_MASK
expr_stmt|;
else|else
block|{
if|if
condition|(
name|len
operator|>
name|AW_IR_L1_MIN
condition|)
break|break;
name|len
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"len = %ld\n"
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
name|VAL_MASK
operator|)
operator|||
operator|(
name|len
operator|<=
name|AW_IR_L1_MIN
operator|)
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Bit separator error\n"
argument_list|)
expr_stmt|;
goto|goto
name|error_code
goto|;
block|}
comment|/* Find Lead 0 (bit length) */
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|sc
operator|->
name|dcnt
condition|;
name|i
operator|++
control|)
block|{
name|val
operator|=
name|sc
operator|->
name|buf
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|VAL_MASK
condition|)
block|{
if|if
condition|(
name|len
operator|>
name|AW_IR_L0_MIN
condition|)
break|break;
name|len
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|len
operator|+=
name|val
operator|&
name|PERIOD_MASK
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|!
operator|(
name|val
operator|&
name|VAL_MASK
operator|)
operator|)
operator|||
operator|(
name|len
operator|<=
name|AW_IR_L0_MIN
operator|)
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Bit length error\n"
argument_list|)
expr_stmt|;
goto|goto
name|error_code
goto|;
block|}
comment|/* Start decoding */
name|code
operator|=
literal|0
expr_stmt|;
name|bitcount
operator|=
literal|0
expr_stmt|;
name|last
operator|=
literal|1
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|sc
operator|->
name|dcnt
condition|;
name|i
operator|++
control|)
block|{
name|val
operator|=
name|sc
operator|->
name|buf
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|last
condition|)
block|{
if|if
condition|(
name|val
operator|&
name|VAL_MASK
condition|)
name|len
operator|+=
name|val
operator|&
name|PERIOD_MASK
expr_stmt|;
else|else
block|{
if|if
condition|(
name|len
operator|>
name|AW_IR_PMAX
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Pulse error\n"
argument_list|)
expr_stmt|;
goto|goto
name|error_code
goto|;
block|}
name|last
operator|=
literal|0
expr_stmt|;
name|len
operator|=
name|val
operator|&
name|PERIOD_MASK
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|val
operator|&
name|VAL_MASK
condition|)
block|{
if|if
condition|(
name|len
operator|>
name|AW_IR_DMAX
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Distant error\n"
argument_list|)
expr_stmt|;
goto|goto
name|error_code
goto|;
block|}
else|else
block|{
if|if
condition|(
name|len
operator|>
name|AW_IR_DMID
condition|)
block|{
comment|/* Decode */
name|code
operator||=
literal|1
operator|<<
name|bitcount
expr_stmt|;
block|}
name|bitcount
operator|++
expr_stmt|;
if|if
condition|(
name|bitcount
operator|==
literal|32
condition|)
break|break;
comment|/* Finish decoding */
block|}
name|last
operator|=
literal|1
expr_stmt|;
name|len
operator|=
name|val
operator|&
name|PERIOD_MASK
expr_stmt|;
block|}
else|else
name|len
operator|+=
name|val
operator|&
name|PERIOD_MASK
expr_stmt|;
block|}
block|}
return|return
operator|(
name|code
operator|)
return|;
name|error_code
label|:
return|return
operator|(
name|AW_IR_ERROR_CODE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aw_ir_validate_code
parameter_list|(
name|unsigned
name|long
name|code
parameter_list|)
block|{
name|unsigned
name|long
name|v1
decl_stmt|,
name|v2
decl_stmt|;
comment|/* Don't check address */
name|v1
operator|=
name|code
operator|&
name|CODE_MASK
expr_stmt|;
name|v2
operator|=
operator|(
name|code
operator|&
name|INV_CODE_MASK
operator|)
operator|>>
literal|8
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|v1
operator|^
name|v2
operator|)
operator|&
name|VALID_CODE_MASK
operator|)
operator|==
name|VALID_CODE_MASK
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* valid */
else|else
return|return
operator|(
literal|1
operator|)
return|;
comment|/* invalid */
block|}
end_function

begin_function
specifier|static
name|void
name|aw_ir_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|aw_ir_softc
modifier|*
name|sc
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|int
name|i
decl_stmt|,
name|dcnt
decl_stmt|;
name|unsigned
name|long
name|ir_code
decl_stmt|;
name|int
name|stat
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|aw_ir_softc
operator|*
operator|)
name|arg
expr_stmt|;
comment|/* Read RX interrupt status */
name|val
operator|=
name|READ
argument_list|(
name|sc
argument_list|,
name|AW_IR_RXSTA
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"RX interrupt status: %x\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* Clean all pending interrupt statuses */
name|WRITE
argument_list|(
name|sc
argument_list|,
name|AW_IR_RXSTA
argument_list|,
name|val
operator||
name|AW_IR_RXSTA_CLEARALL
argument_list|)
expr_stmt|;
comment|/* When Rx FIFO Data available or Packet end */
if|if
condition|(
name|val
operator|&
operator|(
name|AW_IR_RXINT_RAI_EN
operator||
name|AW_IR_RXINT_RPEI_EN
operator|)
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"RX FIFO Data available or Packet end\n"
argument_list|)
expr_stmt|;
comment|/* Get available message count in RX FIFO */
name|dcnt
operator|=
name|AW_IR_RXSTA_COUNTER
argument_list|(
name|val
argument_list|)
expr_stmt|;
comment|/* Read FIFO */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dcnt
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|aw_ir_buf_full
argument_list|(
name|sc
argument_list|)
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"raw buffer full\n"
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
name|aw_ir_buf_write
argument_list|(
name|sc
argument_list|,
name|aw_ir_read_data
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|val
operator|&
name|AW_IR_RXINT_RPEI_EN
condition|)
block|{
comment|/* RX Packet end */
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"RX Packet end\n"
argument_list|)
expr_stmt|;
name|ir_code
operator|=
name|aw_ir_decode_packets
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|stat
operator|=
name|aw_ir_validate_code
argument_list|(
name|ir_code
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|==
literal|0
condition|)
block|{
name|evdev_push_event
argument_list|(
name|sc
operator|->
name|sc_evdev
argument_list|,
name|EV_MSC
argument_list|,
name|MSC_SCAN
argument_list|,
name|ir_code
argument_list|)
expr_stmt|;
name|evdev_sync
argument_list|(
name|sc
operator|->
name|sc_evdev
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Final IR code: %lx\n"
argument_list|,
name|ir_code
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"IR code status: %d\n"
argument_list|,
name|stat
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|dcnt
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|&
name|AW_IR_RXINT_ROI_EN
condition|)
block|{
comment|/* RX FIFO overflow */
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"RX FIFO overflow\n"
argument_list|)
expr_stmt|;
comment|/* Flush raw buffer */
name|aw_ir_buf_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|aw_ir_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ofw_bus_status_okay
argument_list|(
name|dev
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|ofw_bus_search_compatible
argument_list|(
name|dev
argument_list|,
name|compat_data
argument_list|)
operator|->
name|ocd_data
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Allwinner CIR controller"
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|aw_ir_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|aw_ir_softc
modifier|*
name|sc
decl_stmt|;
name|hwreset_t
name|rst_apb
decl_stmt|;
name|clk_t
name|clk_ir
decl_stmt|,
name|clk_gate
decl_stmt|;
name|int
name|err
decl_stmt|;
name|uint32_t
name|val
init|=
literal|0
decl_stmt|;
name|clk_ir
operator|=
name|clk_gate
operator|=
name|NULL
expr_stmt|;
name|rst_apb
operator|=
name|NULL
expr_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
if|if
condition|(
name|bus_alloc_resources
argument_list|(
name|dev
argument_list|,
name|aw_ir_spec
argument_list|,
name|sc
operator|->
name|res
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not allocate memory resource\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
switch|switch
condition|(
name|ofw_bus_search_compatible
argument_list|(
name|dev
argument_list|,
name|compat_data
argument_list|)
operator|->
name|ocd_data
condition|)
block|{
case|case
name|A10_IR
case|:
name|sc
operator|->
name|fifo_size
operator|=
literal|16
expr_stmt|;
break|break;
case|case
name|A13_IR
case|:
name|sc
operator|->
name|fifo_size
operator|=
literal|64
expr_stmt|;
break|break;
block|}
comment|/* De-assert reset */
if|if
condition|(
name|hwreset_get_by_ofw_idx
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|rst_apb
argument_list|)
operator|==
literal|0
condition|)
block|{
name|err
operator|=
name|hwreset_deassert
argument_list|(
name|rst_apb
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot de-assert reset\n"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
comment|/* Reset buffer */
name|aw_ir_buf_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Get clocks and enable them */
name|err
operator|=
name|clk_get_by_ofw_name
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
literal|"apb"
argument_list|,
operator|&
name|clk_gate
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Cannot get gate clock\n"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|err
operator|=
name|clk_get_by_ofw_name
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
literal|"ir"
argument_list|,
operator|&
name|clk_ir
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Cannot get IR clock\n"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* Set clock rate */
name|err
operator|=
name|clk_set_freq
argument_list|(
name|clk_ir
argument_list|,
name|AW_IR_BASE_CLK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot set IR clock rate\n"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* Enable clocks */
name|err
operator|=
name|clk_enable
argument_list|(
name|clk_gate
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Cannot enable clk gate\n"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|err
operator|=
name|clk_enable
argument_list|(
name|clk_ir
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Cannot enable IR clock\n"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|res
index|[
literal|1
index|]
argument_list|,
name|INTR_TYPE_MISC
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|aw_ir_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|intrhand
argument_list|)
condition|)
block|{
name|bus_release_resources
argument_list|(
name|dev
argument_list|,
name|aw_ir_spec
argument_list|,
name|sc
operator|->
name|res
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot setup interrupt handler\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Enable CIR Mode */
name|WRITE
argument_list|(
name|sc
argument_list|,
name|AW_IR_CTL
argument_list|,
name|AW_IR_CTL_MD
argument_list|)
expr_stmt|;
comment|/* 	 * Set clock sample, filter, idle thresholds. 	 * Frequency sample = 3MHz/128 = 23437.5Hz (42.7us) 	 */
name|val
operator|=
name|AW_IR_SAMPLE_128
expr_stmt|;
name|val
operator||=
operator|(
name|AW_IR_RXFILT_VAL
operator||
name|AW_IR_RXIDLE_VAL
operator|)
expr_stmt|;
name|val
operator||=
operator|(
name|AW_IR_ACTIVE_T
operator||
name|AW_IR_ACTIVE_T_C
operator|)
expr_stmt|;
name|WRITE
argument_list|(
name|sc
argument_list|,
name|AW_IR_CIR
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* Invert Input Signal */
name|WRITE
argument_list|(
name|sc
argument_list|,
name|AW_IR_RXCTL
argument_list|,
name|AW_IR_RXCTL_RPPI
argument_list|)
expr_stmt|;
comment|/* Clear All RX Interrupt Status */
name|WRITE
argument_list|(
name|sc
argument_list|,
name|AW_IR_RXSTA
argument_list|,
name|AW_IR_RXSTA_CLEARALL
argument_list|)
expr_stmt|;
comment|/* 	 * Enable RX interrupt in case of overflow, packet end 	 * and FIFO available. 	 * RX FIFO Threshold = FIFO size / 2 	 */
name|WRITE
argument_list|(
name|sc
argument_list|,
name|AW_IR_RXINT
argument_list|,
name|AW_IR_RXINT_ROI_EN
operator||
name|AW_IR_RXINT_RPEI_EN
operator||
name|AW_IR_RXINT_RAI_EN
operator||
name|AW_IR_RXINT_RAL
argument_list|(
operator|(
name|sc
operator|->
name|fifo_size
operator|>>
literal|1
operator|)
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Enable IR Module */
name|val
operator|=
name|READ
argument_list|(
name|sc
argument_list|,
name|AW_IR_CTL
argument_list|)
expr_stmt|;
name|WRITE
argument_list|(
name|sc
argument_list|,
name|AW_IR_CTL
argument_list|,
name|val
operator||
name|AW_IR_CTL_GEN
operator||
name|AW_IR_CTL_RXEN
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_evdev
operator|=
name|evdev_alloc
argument_list|()
expr_stmt|;
name|evdev_set_name
argument_list|(
name|sc
operator|->
name|sc_evdev
argument_list|,
name|device_get_desc
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|evdev_set_phys
argument_list|(
name|sc
operator|->
name|sc_evdev
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|evdev_set_id
argument_list|(
name|sc
operator|->
name|sc_evdev
argument_list|,
name|BUS_HOST
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|evdev_support_event
argument_list|(
name|sc
operator|->
name|sc_evdev
argument_list|,
name|EV_SYN
argument_list|)
expr_stmt|;
name|evdev_support_event
argument_list|(
name|sc
operator|->
name|sc_evdev
argument_list|,
name|EV_MSC
argument_list|)
expr_stmt|;
name|evdev_support_msc
argument_list|(
name|sc
operator|->
name|sc_evdev
argument_list|,
name|MSC_SCAN
argument_list|)
expr_stmt|;
name|err
operator|=
name|evdev_register
argument_list|(
name|sc
operator|->
name|sc_evdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to register evdev: error=%d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|error
label|:
if|if
condition|(
name|clk_gate
operator|!=
name|NULL
condition|)
name|clk_release
argument_list|(
name|clk_gate
argument_list|)
expr_stmt|;
if|if
condition|(
name|clk_ir
operator|!=
name|NULL
condition|)
name|clk_release
argument_list|(
name|clk_ir
argument_list|)
expr_stmt|;
if|if
condition|(
name|rst_apb
operator|!=
name|NULL
condition|)
name|hwreset_release
argument_list|(
name|rst_apb
argument_list|)
expr_stmt|;
name|evdev_free
argument_list|(
name|sc
operator|->
name|sc_evdev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_evdev
operator|=
name|NULL
expr_stmt|;
comment|/* Avoid double free */
name|bus_release_resources
argument_list|(
name|dev
argument_list|,
name|aw_ir_spec
argument_list|,
name|sc
operator|->
name|res
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|aw_ir_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|aw_ir_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|aw_ir_attach
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|aw_ir_driver
init|=
block|{
literal|"aw_ir"
block|,
name|aw_ir_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|aw_ir_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|aw_ir_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|aw_ir
argument_list|,
name|simplebus
argument_list|,
name|aw_ir_driver
argument_list|,
name|aw_ir_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|aw_ir
argument_list|,
name|evdev
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

