begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2013 Ian Lepore<ian@freebsd.org>  * Copyright (c) 2011 Ben Gray<ben.r.gray@gmail.com>.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/gpio.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<machine/intr.h>
end_include

begin_include
include|#
directive|include
file|<dev/fdt/fdt_common.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/ofw_bus.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/ofw_bus_subr.h>
end_include

begin_include
include|#
directive|include
file|<dev/mmc/bridge.h>
end_include

begin_include
include|#
directive|include
file|<dev/mmc/mmcreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/mmc/mmcbrvar.h>
end_include

begin_include
include|#
directive|include
file|<dev/sdhci/sdhci.h>
end_include

begin_include
include|#
directive|include
file|"sdhci_if.h"
end_include

begin_include
include|#
directive|include
file|<arm/ti/ti_cpuid.h>
end_include

begin_include
include|#
directive|include
file|<arm/ti/ti_prcm.h>
end_include

begin_include
include|#
directive|include
file|"gpio_if.h"
end_include

begin_struct
struct|struct
name|ti_sdhci_softc
block|{
name|device_t
name|dev
decl_stmt|;
name|device_t
name|gpio_dev
decl_stmt|;
name|struct
name|resource
modifier|*
name|mem_res
decl_stmt|;
name|struct
name|resource
modifier|*
name|irq_res
decl_stmt|;
name|void
modifier|*
name|intr_cookie
decl_stmt|;
name|struct
name|sdhci_slot
name|slot
decl_stmt|;
name|uint32_t
name|mmchs_device_id
decl_stmt|;
name|uint32_t
name|mmchs_reg_off
decl_stmt|;
name|uint32_t
name|sdhci_reg_off
decl_stmt|;
name|uint32_t
name|baseclk_hz
decl_stmt|;
name|uint32_t
name|wp_gpio_pin
decl_stmt|;
name|uint32_t
name|cmd_and_mode
decl_stmt|;
name|uint32_t
name|sdhci_clkdiv
decl_stmt|;
name|boolean_t
name|disable_highspeed
decl_stmt|;
name|boolean_t
name|force_card_present
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Table of supported FDT compat strings.  *  * Note that "ti,mmchs" is our own invention, and should be phased out in favor  * of the documented names.  *  * Note that vendor Beaglebone dtsi files use "ti,omap3-hsmmc" for the am335x.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ofw_compat_data
name|compat_data
index|[]
init|=
block|{
block|{
literal|"ti,omap3-hsmmc"
block|,
literal|1
block|}
block|,
block|{
literal|"ti,omap4-hsmmc"
block|,
literal|1
block|}
block|,
block|{
literal|"ti,mmchs"
block|,
literal|1
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The MMCHS hardware has a few control and status registers at the beginning of  * the device's memory map, followed by the standard sdhci register block.  * Different SoCs have the register blocks at different offsets from the  * beginning of the device.  Define some constants to map out the registers we  * access, and the various per-SoC offsets.  The SDHCI_REG_OFFSET is how far  * beyond the MMCHS block the SDHCI block is found; it's the same on all SoCs.  */
end_comment

begin_define
define|#
directive|define
name|OMAP3_MMCHS_REG_OFFSET
value|0x000
end_define

begin_define
define|#
directive|define
name|OMAP4_MMCHS_REG_OFFSET
value|0x100
end_define

begin_define
define|#
directive|define
name|AM335X_MMCHS_REG_OFFSET
value|0x100
end_define

begin_define
define|#
directive|define
name|SDHCI_REG_OFFSET
value|0x100
end_define

begin_define
define|#
directive|define
name|MMCHS_SYSCONFIG
value|0x010
end_define

begin_define
define|#
directive|define
name|MMCHS_SYSCONFIG_RESET
value|(1<< 1)
end_define

begin_define
define|#
directive|define
name|MMCHS_SYSSTATUS
value|0x014
end_define

begin_define
define|#
directive|define
name|MMCHS_SYSSTATUS_RESETDONE
value|(1<< 0)
end_define

begin_define
define|#
directive|define
name|MMCHS_CON
value|0x02C
end_define

begin_define
define|#
directive|define
name|MMCHS_CON_DW8
value|(1<< 5)
end_define

begin_define
define|#
directive|define
name|MMCHS_CON_DVAL_8_4MS
value|(3<< 9)
end_define

begin_define
define|#
directive|define
name|MMCHS_CON_OD
value|(1<< 0)
end_define

begin_define
define|#
directive|define
name|MMCHS_SYSCTL
value|0x12C
end_define

begin_define
define|#
directive|define
name|MMCHS_SYSCTL_CLKD_MASK
value|0x3FF
end_define

begin_define
define|#
directive|define
name|MMCHS_SYSCTL_CLKD_SHIFT
value|6
end_define

begin_define
define|#
directive|define
name|MMCHS_SD_CAPA
value|0x140
end_define

begin_define
define|#
directive|define
name|MMCHS_SD_CAPA_VS18
value|(1<< 26)
end_define

begin_define
define|#
directive|define
name|MMCHS_SD_CAPA_VS30
value|(1<< 25)
end_define

begin_define
define|#
directive|define
name|MMCHS_SD_CAPA_VS33
value|(1<< 24)
end_define

begin_function
specifier|static
specifier|inline
name|uint32_t
name|ti_mmchs_read_4
parameter_list|(
name|struct
name|ti_sdhci_softc
modifier|*
name|sc
parameter_list|,
name|bus_size_t
name|off
parameter_list|)
block|{
return|return
operator|(
name|bus_read_4
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|,
name|off
operator|+
name|sc
operator|->
name|mmchs_reg_off
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|ti_mmchs_write_4
parameter_list|(
name|struct
name|ti_sdhci_softc
modifier|*
name|sc
parameter_list|,
name|bus_size_t
name|off
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
name|bus_write_4
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|,
name|off
operator|+
name|sc
operator|->
name|mmchs_reg_off
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint32_t
name|RD4
parameter_list|(
name|struct
name|ti_sdhci_softc
modifier|*
name|sc
parameter_list|,
name|bus_size_t
name|off
parameter_list|)
block|{
return|return
operator|(
name|bus_read_4
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|,
name|off
operator|+
name|sc
operator|->
name|sdhci_reg_off
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|WR4
parameter_list|(
name|struct
name|ti_sdhci_softc
modifier|*
name|sc
parameter_list|,
name|bus_size_t
name|off
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
name|bus_write_4
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|,
name|off
operator|+
name|sc
operator|->
name|sdhci_reg_off
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|ti_sdhci_read_1
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|,
name|bus_size_t
name|off
parameter_list|)
block|{
name|struct
name|ti_sdhci_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
name|RD4
argument_list|(
name|sc
argument_list|,
name|off
operator|&
operator|~
literal|3
argument_list|)
operator|>>
operator|(
name|off
operator|&
literal|3
operator|)
operator|*
literal|8
operator|)
operator|&
literal|0xff
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint16_t
name|ti_sdhci_read_2
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|,
name|bus_size_t
name|off
parameter_list|)
block|{
name|struct
name|ti_sdhci_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|uint32_t
name|clkdiv
decl_stmt|,
name|val32
decl_stmt|;
comment|/* 	 * The MMCHS hardware has a non-standard interpretation of the sdclock 	 * divisor bits.  It uses the same bit positions as SDHCI 3.0 (15..6) 	 * but doesn't split them into low:high fields.  Instead they're a 	 * single number in the range 0..1023 and the number is exactly the 	 * clock divisor (with 0 and 1 both meaning divide by 1).  The SDHCI 	 * driver code expects a v2.0 or v3.0 divisor.  The shifting and masking 	 * here extracts the MMCHS representation from the hardware word, cleans 	 * those bits out, applies the 2N adjustment, and plugs the result into 	 * the bit positions for the 2.0 or 3.0 divisor in the returned register 	 * value. The ti_sdhci_write_2() routine performs the opposite 	 * transformation when the SDHCI driver writes to the register. 	 */
if|if
condition|(
name|off
operator|==
name|SDHCI_CLOCK_CONTROL
condition|)
block|{
name|val32
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|SDHCI_CLOCK_CONTROL
argument_list|)
expr_stmt|;
name|clkdiv
operator|=
operator|(
operator|(
name|val32
operator|>>
name|MMCHS_SYSCTL_CLKD_SHIFT
operator|)
operator|&
name|MMCHS_SYSCTL_CLKD_MASK
operator|)
operator|/
literal|2
expr_stmt|;
name|val32
operator|&=
operator|~
operator|(
name|MMCHS_SYSCTL_CLKD_MASK
operator|<<
name|MMCHS_SYSCTL_CLKD_SHIFT
operator|)
expr_stmt|;
name|val32
operator||=
operator|(
name|clkdiv
operator|&
name|SDHCI_DIVIDER_MASK
operator|)
operator|<<
name|SDHCI_DIVIDER_SHIFT
expr_stmt|;
if|if
condition|(
name|slot
operator|->
name|version
operator|>=
name|SDHCI_SPEC_300
condition|)
name|val32
operator||=
operator|(
operator|(
name|clkdiv
operator|>>
name|SDHCI_DIVIDER_MASK_LEN
operator|)
operator|&
name|SDHCI_DIVIDER_HI_MASK
operator|)
operator|<<
name|SDHCI_DIVIDER_HI_SHIFT
expr_stmt|;
return|return
operator|(
name|val32
operator|&
literal|0xffff
operator|)
return|;
block|}
comment|/* 	 * Standard 32-bit handling of command and transfer mode. 	 */
if|if
condition|(
name|off
operator|==
name|SDHCI_TRANSFER_MODE
condition|)
block|{
return|return
operator|(
name|sc
operator|->
name|cmd_and_mode
operator|>>
literal|16
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|off
operator|==
name|SDHCI_COMMAND_FLAGS
condition|)
block|{
return|return
operator|(
name|sc
operator|->
name|cmd_and_mode
operator|&
literal|0x0000ffff
operator|)
return|;
block|}
return|return
operator|(
operator|(
name|RD4
argument_list|(
name|sc
argument_list|,
name|off
operator|&
operator|~
literal|3
argument_list|)
operator|>>
operator|(
name|off
operator|&
literal|3
operator|)
operator|*
literal|8
operator|)
operator|&
literal|0xffff
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|ti_sdhci_read_4
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|,
name|bus_size_t
name|off
parameter_list|)
block|{
name|struct
name|ti_sdhci_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|uint32_t
name|val32
decl_stmt|;
name|val32
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|off
argument_list|)
expr_stmt|;
comment|/* 	 * If we need to disallow highspeed mode due to the OMAP4 erratum, strip 	 * that flag from the returned capabilities. 	 */
if|if
condition|(
name|off
operator|==
name|SDHCI_CAPABILITIES
operator|&&
name|sc
operator|->
name|disable_highspeed
condition|)
name|val32
operator|&=
operator|~
name|SDHCI_CAN_DO_HISPD
expr_stmt|;
comment|/* 	 * Force the card-present state if necessary. 	 */
if|if
condition|(
name|off
operator|==
name|SDHCI_PRESENT_STATE
operator|&&
name|sc
operator|->
name|force_card_present
condition|)
name|val32
operator||=
name|SDHCI_CARD_PRESENT
expr_stmt|;
return|return
operator|(
name|val32
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ti_sdhci_read_multi_4
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|,
name|bus_size_t
name|off
parameter_list|,
name|uint32_t
modifier|*
name|data
parameter_list|,
name|bus_size_t
name|count
parameter_list|)
block|{
name|struct
name|ti_sdhci_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|bus_read_multi_4
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|,
name|off
operator|+
name|sc
operator|->
name|sdhci_reg_off
argument_list|,
name|data
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ti_sdhci_write_1
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|,
name|bus_size_t
name|off
parameter_list|,
name|uint8_t
name|val
parameter_list|)
block|{
name|struct
name|ti_sdhci_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|uint32_t
name|val32
decl_stmt|;
name|val32
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|off
operator|&
operator|~
literal|3
argument_list|)
expr_stmt|;
name|val32
operator|&=
operator|~
operator|(
literal|0xff
operator|<<
operator|(
name|off
operator|&
literal|3
operator|)
operator|*
literal|8
operator|)
expr_stmt|;
name|val32
operator||=
operator|(
name|val
operator|<<
operator|(
name|off
operator|&
literal|3
operator|)
operator|*
literal|8
operator|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|off
operator|&
operator|~
literal|3
argument_list|,
name|val32
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ti_sdhci_write_2
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|,
name|bus_size_t
name|off
parameter_list|,
name|uint16_t
name|val
parameter_list|)
block|{
name|struct
name|ti_sdhci_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|uint32_t
name|clkdiv
decl_stmt|,
name|val32
decl_stmt|;
comment|/* 	 * Translate between the hardware and SDHCI 2.0 or 3.0 representations 	 * of the clock divisor.  See the comments in ti_sdhci_read_2() for 	 * details. 	 */
if|if
condition|(
name|off
operator|==
name|SDHCI_CLOCK_CONTROL
condition|)
block|{
name|clkdiv
operator|=
operator|(
name|val
operator|>>
name|SDHCI_DIVIDER_SHIFT
operator|)
operator|&
name|SDHCI_DIVIDER_MASK
expr_stmt|;
if|if
condition|(
name|slot
operator|->
name|version
operator|>=
name|SDHCI_SPEC_300
condition|)
name|clkdiv
operator||=
operator|(
operator|(
name|val
operator|>>
name|SDHCI_DIVIDER_HI_SHIFT
operator|)
operator|&
name|SDHCI_DIVIDER_HI_MASK
operator|)
operator|<<
name|SDHCI_DIVIDER_MASK_LEN
expr_stmt|;
name|clkdiv
operator|*=
literal|2
expr_stmt|;
if|if
condition|(
name|clkdiv
operator|>
name|MMCHS_SYSCTL_CLKD_MASK
condition|)
name|clkdiv
operator|=
name|MMCHS_SYSCTL_CLKD_MASK
expr_stmt|;
name|val32
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|SDHCI_CLOCK_CONTROL
argument_list|)
expr_stmt|;
name|val32
operator|&=
literal|0xffff0000
expr_stmt|;
name|val32
operator||=
name|val
operator|&
operator|~
operator|(
name|MMCHS_SYSCTL_CLKD_MASK
operator|<<
name|MMCHS_SYSCTL_CLKD_SHIFT
operator|)
expr_stmt|;
name|val32
operator||=
name|clkdiv
operator|<<
name|MMCHS_SYSCTL_CLKD_SHIFT
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|SDHCI_CLOCK_CONTROL
argument_list|,
name|val32
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Standard 32-bit handling of command and transfer mode. 	 */
if|if
condition|(
name|off
operator|==
name|SDHCI_TRANSFER_MODE
condition|)
block|{
name|sc
operator|->
name|cmd_and_mode
operator|=
operator|(
name|sc
operator|->
name|cmd_and_mode
operator|&
literal|0xffff0000
operator|)
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|val
operator|&
literal|0x0000ffff
operator|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|off
operator|==
name|SDHCI_COMMAND_FLAGS
condition|)
block|{
name|sc
operator|->
name|cmd_and_mode
operator|=
operator|(
name|sc
operator|->
name|cmd_and_mode
operator|&
literal|0x0000ffff
operator|)
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|val
operator|<<
literal|16
operator|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|SDHCI_TRANSFER_MODE
argument_list|,
name|sc
operator|->
name|cmd_and_mode
argument_list|)
expr_stmt|;
return|return;
block|}
name|val32
operator|=
name|RD4
argument_list|(
name|sc
argument_list|,
name|off
operator|&
operator|~
literal|3
argument_list|)
expr_stmt|;
name|val32
operator|&=
operator|~
operator|(
literal|0xffff
operator|<<
operator|(
name|off
operator|&
literal|3
operator|)
operator|*
literal|8
operator|)
expr_stmt|;
name|val32
operator||=
operator|(
operator|(
name|val
operator|&
literal|0xffff
operator|)
operator|<<
operator|(
name|off
operator|&
literal|3
operator|)
operator|*
literal|8
operator|)
expr_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|off
operator|&
operator|~
literal|3
argument_list|,
name|val32
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ti_sdhci_write_4
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|,
name|bus_size_t
name|off
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
name|struct
name|ti_sdhci_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|WR4
argument_list|(
name|sc
argument_list|,
name|off
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ti_sdhci_write_multi_4
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|sdhci_slot
modifier|*
name|slot
parameter_list|,
name|bus_size_t
name|off
parameter_list|,
name|uint32_t
modifier|*
name|data
parameter_list|,
name|bus_size_t
name|count
parameter_list|)
block|{
name|struct
name|ti_sdhci_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|bus_write_multi_4
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|,
name|off
operator|+
name|sc
operator|->
name|sdhci_reg_off
argument_list|,
name|data
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ti_sdhci_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ti_sdhci_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|sdhci_generic_intr
argument_list|(
operator|&
name|sc
operator|->
name|slot
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ti_sdhci_update_ios
parameter_list|(
name|device_t
name|brdev
parameter_list|,
name|device_t
name|reqdev
parameter_list|)
block|{
name|struct
name|ti_sdhci_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|brdev
argument_list|)
decl_stmt|;
name|struct
name|sdhci_slot
modifier|*
name|slot
decl_stmt|;
name|struct
name|mmc_ios
modifier|*
name|ios
decl_stmt|;
name|uint32_t
name|val32
decl_stmt|,
name|newval32
decl_stmt|;
name|slot
operator|=
name|device_get_ivars
argument_list|(
name|reqdev
argument_list|)
expr_stmt|;
name|ios
operator|=
operator|&
name|slot
operator|->
name|host
operator|.
name|ios
expr_stmt|;
comment|/* 	 * There is an 8-bit-bus bit in the MMCHS control register which, when 	 * set, overrides the 1 vs 4 bit setting in the standard SDHCI 	 * registers.  Set that bit first according to whether an 8-bit bus is 	 * requested, then let the standard driver handle everything else. 	 */
name|val32
operator|=
name|ti_mmchs_read_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_CON
argument_list|)
expr_stmt|;
name|newval32
operator|=
name|val32
expr_stmt|;
if|if
condition|(
name|ios
operator|->
name|bus_width
operator|==
name|bus_width_8
condition|)
name|newval32
operator||=
name|MMCHS_CON_DW8
expr_stmt|;
else|else
name|newval32
operator|&=
operator|~
name|MMCHS_CON_DW8
expr_stmt|;
if|if
condition|(
name|ios
operator|->
name|bus_mode
operator|==
name|opendrain
condition|)
name|newval32
operator||=
name|MMCHS_CON_OD
expr_stmt|;
else|else
comment|/* if (ios->bus_mode == pushpull) */
name|newval32
operator|&=
operator|~
name|MMCHS_CON_OD
expr_stmt|;
if|if
condition|(
name|newval32
operator|!=
name|val32
condition|)
name|ti_mmchs_write_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_CON
argument_list|,
name|newval32
argument_list|)
expr_stmt|;
return|return
operator|(
name|sdhci_generic_update_ios
argument_list|(
name|brdev
argument_list|,
name|reqdev
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ti_sdhci_get_ro
parameter_list|(
name|device_t
name|brdev
parameter_list|,
name|device_t
name|reqdev
parameter_list|)
block|{
name|struct
name|ti_sdhci_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|brdev
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|readonly
init|=
literal|0
decl_stmt|;
comment|/* If a gpio pin is configured, read it. */
if|if
condition|(
name|sc
operator|->
name|gpio_dev
operator|!=
name|NULL
condition|)
block|{
name|GPIO_PIN_GET
argument_list|(
name|sc
operator|->
name|gpio_dev
argument_list|,
name|sc
operator|->
name|wp_gpio_pin
argument_list|,
operator|&
name|readonly
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|readonly
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ti_sdhci_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ti_sdhci_hw_init
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ti_sdhci_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|clk_ident_t
name|clk
decl_stmt|;
name|uint32_t
name|regval
decl_stmt|;
name|unsigned
name|long
name|timeout
decl_stmt|;
comment|/* Enable the controller and interface/functional clocks */
name|clk
operator|=
name|MMC0_CLK
operator|+
name|sc
operator|->
name|mmchs_device_id
expr_stmt|;
if|if
condition|(
name|ti_prcm_clk_enable
argument_list|(
name|clk
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Error: failed to enable MMC clock\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Get the frequency of the source clock */
if|if
condition|(
name|ti_prcm_clk_get_source_freq
argument_list|(
name|clk
argument_list|,
operator|&
name|sc
operator|->
name|baseclk_hz
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Error: failed to get source clock freq\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Issue a softreset to the controller */
name|ti_mmchs_write_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_SYSCONFIG
argument_list|,
name|MMCHS_SYSCONFIG_RESET
argument_list|)
expr_stmt|;
name|timeout
operator|=
literal|1000
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|ti_mmchs_read_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_SYSSTATUS
argument_list|)
operator|&
name|MMCHS_SYSSTATUS_RESETDONE
operator|)
condition|)
block|{
if|if
condition|(
operator|--
name|timeout
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Error: Controller reset operation timed out\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Reset the command and data state machines and also other aspects of 	 * the controller such as bus clock and power. 	 * 	 * If we read the software reset register too fast after writing it we 	 * can get back a zero that means the reset hasn't started yet rather 	 * than that the reset is complete. Per TI recommendations, work around 	 * it by reading until we see the reset bit asserted, then read until 	 * it's clear. We also set the SDHCI_QUIRK_WAITFOR_RESET_ASSERTED quirk 	 * so that the main sdhci driver uses this same logic in its resets. 	 */
name|ti_sdhci_write_1
argument_list|(
name|dev
argument_list|,
name|NULL
argument_list|,
name|SDHCI_SOFTWARE_RESET
argument_list|,
name|SDHCI_RESET_ALL
argument_list|)
expr_stmt|;
name|timeout
operator|=
literal|10000
expr_stmt|;
while|while
condition|(
operator|(
name|ti_sdhci_read_1
argument_list|(
name|dev
argument_list|,
name|NULL
argument_list|,
name|SDHCI_SOFTWARE_RESET
argument_list|)
operator|&
name|SDHCI_RESET_ALL
operator|)
operator|!=
name|SDHCI_RESET_ALL
condition|)
block|{
if|if
condition|(
operator|--
name|timeout
operator|==
literal|0
condition|)
block|{
break|break;
block|}
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|timeout
operator|=
literal|10000
expr_stmt|;
while|while
condition|(
operator|(
name|ti_sdhci_read_1
argument_list|(
name|dev
argument_list|,
name|NULL
argument_list|,
name|SDHCI_SOFTWARE_RESET
argument_list|)
operator|&
name|SDHCI_RESET_ALL
operator|)
condition|)
block|{
if|if
condition|(
operator|--
name|timeout
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Error: Software reset operation timed out\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * The attach() routine has examined fdt data and set flags in 	 * slot.host.caps to reflect what voltages we can handle.  Set those 	 * values in the CAPA register.  The manual says that these values can 	 * only be set once, "before initialization" whatever that means, and 	 * that they survive a reset.  So maybe doing this will be a no-op if 	 * u-boot has already initialized the hardware. 	 */
name|regval
operator|=
name|ti_mmchs_read_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_SD_CAPA
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|slot
operator|.
name|host
operator|.
name|caps
operator|&
name|MMC_OCR_LOW_VOLTAGE
condition|)
name|regval
operator||=
name|MMCHS_SD_CAPA_VS18
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|slot
operator|.
name|host
operator|.
name|caps
operator|&
operator|(
name|MMC_OCR_290_300
operator||
name|MMC_OCR_300_310
operator|)
condition|)
name|regval
operator||=
name|MMCHS_SD_CAPA_VS30
expr_stmt|;
name|ti_mmchs_write_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_SD_CAPA
argument_list|,
name|regval
argument_list|)
expr_stmt|;
comment|/* Set initial host configuration (1-bit, std speed, pwr off). */
name|ti_sdhci_write_1
argument_list|(
name|dev
argument_list|,
name|NULL
argument_list|,
name|SDHCI_HOST_CONTROL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ti_sdhci_write_1
argument_list|(
name|dev
argument_list|,
name|NULL
argument_list|,
name|SDHCI_POWER_CONTROL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set the initial controller configuration. */
name|ti_mmchs_write_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_CON
argument_list|,
name|MMCHS_CON_DVAL_8_4MS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ti_sdhci_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ti_sdhci_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|rid
decl_stmt|,
name|err
decl_stmt|;
name|pcell_t
name|prop
decl_stmt|;
name|phandle_t
name|node
decl_stmt|;
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
comment|/* 	 * Get the MMCHS device id from FDT.  If it's not there use the newbus 	 * unit number (which will work as long as the devices are in order and 	 * none are skipped in the fdt).  Note that this is a property we made 	 * up and added in freebsd, it doesn't exist in the published bindings. 	 */
name|node
operator|=
name|ofw_bus_get_node
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|OF_getprop
argument_list|(
name|node
argument_list|,
literal|"mmchs-device-id"
argument_list|,
operator|&
name|prop
argument_list|,
sizeof|sizeof
argument_list|(
name|prop
argument_list|)
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
name|sc
operator|->
name|mmchs_device_id
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"missing mmchs-device-id attribute in FDT, "
literal|"using unit number (%d)"
argument_list|,
name|sc
operator|->
name|mmchs_device_id
argument_list|)
expr_stmt|;
block|}
else|else
name|sc
operator|->
name|mmchs_device_id
operator|=
name|fdt32_to_cpu
argument_list|(
name|prop
argument_list|)
expr_stmt|;
comment|/* 	 * The hardware can inherently do dual-voltage (1p8v, 3p0v) on the first 	 * device, and only 1p8v on other devices unless an external transceiver 	 * is used.  The only way we could know about a transceiver is fdt data. 	 * Note that we have to do this before calling ti_sdhci_hw_init() so 	 * that it can set the right values in the CAPA register, which can only 	 * be done once and never reset. 	 */
name|sc
operator|->
name|slot
operator|.
name|host
operator|.
name|caps
operator||=
name|MMC_OCR_LOW_VOLTAGE
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mmchs_device_id
operator|==
literal|0
operator|||
name|OF_hasprop
argument_list|(
name|node
argument_list|,
literal|"ti,dual-volt"
argument_list|)
condition|)
block|{
name|sc
operator|->
name|slot
operator|.
name|host
operator|.
name|caps
operator||=
name|MMC_OCR_290_300
operator||
name|MMC_OCR_300_310
expr_stmt|;
block|}
comment|/* 	 * See if we've got a GPIO-based write detect pin.  This is not the 	 * standard documented property for this, we added it in freebsd. 	 */
if|if
condition|(
operator|(
name|OF_getprop
argument_list|(
name|node
argument_list|,
literal|"mmchs-wp-gpio-pin"
argument_list|,
operator|&
name|prop
argument_list|,
sizeof|sizeof
argument_list|(
name|prop
argument_list|)
argument_list|)
operator|)
operator|<=
literal|0
condition|)
name|sc
operator|->
name|wp_gpio_pin
operator|=
literal|0xffffffff
expr_stmt|;
else|else
name|sc
operator|->
name|wp_gpio_pin
operator|=
name|fdt32_to_cpu
argument_list|(
name|prop
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|wp_gpio_pin
operator|!=
literal|0xffffffff
condition|)
block|{
name|sc
operator|->
name|gpio_dev
operator|=
name|devclass_get_device
argument_list|(
name|devclass_find
argument_list|(
literal|"gpio"
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|gpio_dev
operator|==
name|NULL
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Error: No GPIO device, "
literal|"Write Protect pin will not function\n"
argument_list|)
expr_stmt|;
else|else
name|GPIO_PIN_SETFLAGS
argument_list|(
name|sc
operator|->
name|gpio_dev
argument_list|,
name|sc
operator|->
name|wp_gpio_pin
argument_list|,
name|GPIO_PIN_INPUT
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Set the offset from the device's memory start to the MMCHS registers. 	 * Also for OMAP4 disable high speed mode due to erratum ID i626. 	 */
if|if
condition|(
name|ti_chip
argument_list|()
operator|==
name|CHIP_OMAP_3
condition|)
name|sc
operator|->
name|mmchs_reg_off
operator|=
name|OMAP3_MMCHS_REG_OFFSET
expr_stmt|;
elseif|else
if|if
condition|(
name|ti_chip
argument_list|()
operator|==
name|CHIP_OMAP_4
condition|)
block|{
name|sc
operator|->
name|mmchs_reg_off
operator|=
name|OMAP4_MMCHS_REG_OFFSET
expr_stmt|;
name|sc
operator|->
name|disable_highspeed
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ti_chip
argument_list|()
operator|==
name|CHIP_AM335X
condition|)
name|sc
operator|->
name|mmchs_reg_off
operator|=
name|AM335X_MMCHS_REG_OFFSET
expr_stmt|;
else|else
name|panic
argument_list|(
literal|"Unknown OMAP device\n"
argument_list|)
expr_stmt|;
comment|/* 	 * The standard SDHCI registers are at a fixed offset (the same on all 	 * SoCs) beyond the MMCHS registers. 	 */
name|sc
operator|->
name|sdhci_reg_off
operator|=
name|sc
operator|->
name|mmchs_reg_off
operator|+
name|SDHCI_REG_OFFSET
expr_stmt|;
comment|/* Resource setup. */
name|rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|mem_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|mem_res
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot allocate memory window\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|irq_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|irq_res
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot allocate interrupt\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|,
name|INTR_TYPE_BIO
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|ti_sdhci_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|intr_cookie
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot setup interrupt handler\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Initialise the MMCHS hardware. */
name|ti_sdhci_hw_init
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* 	 * The capabilities register can only express base clock frequencies in 	 * the range of 0-63MHz for a v2.0 controller.  Since our clock runs 	 * faster than that, the hardware sets the frequency to zero in the 	 * register.  When the register contains zero, the sdhci driver expects 	 * slot.max_clk to already have the right value in it. 	 */
name|sc
operator|->
name|slot
operator|.
name|max_clk
operator|=
name|sc
operator|->
name|baseclk_hz
expr_stmt|;
comment|/* 	 * The MMCHS timeout counter is based on the output sdclock.  Tell the 	 * sdhci driver to recalculate the timeout clock whenever the output 	 * sdclock frequency changes. 	 */
name|sc
operator|->
name|slot
operator|.
name|quirks
operator||=
name|SDHCI_QUIRK_DATA_TIMEOUT_USES_SDCLK
expr_stmt|;
comment|/* 	 * The MMCHS hardware shifts the 136-bit response data (in violation of 	 * the spec), so tell the sdhci driver not to do the same in software. 	 */
name|sc
operator|->
name|slot
operator|.
name|quirks
operator||=
name|SDHCI_QUIRK_DONT_SHIFT_RESPONSE
expr_stmt|;
comment|/* 	 * Reset bits are broken, have to wait to see the bits asserted 	 * before waiting to see them de-asserted. 	 */
name|sc
operator|->
name|slot
operator|.
name|quirks
operator||=
name|SDHCI_QUIRK_WAITFOR_RESET_ASSERTED
expr_stmt|;
comment|/* 	 * The controller waits for busy responses. 	 */
name|sc
operator|->
name|slot
operator|.
name|quirks
operator||=
name|SDHCI_QUIRK_WAIT_WHILE_BUSY
expr_stmt|;
comment|/* 	 * DMA is not really broken, I just haven't implemented it yet. 	 */
name|sc
operator|->
name|slot
operator|.
name|quirks
operator||=
name|SDHCI_QUIRK_BROKEN_DMA
expr_stmt|;
comment|/* 	 *  Set up the hardware and go.  Note that this sets many of the 	 *  slot.host.* fields, so we have to do this before overriding any of 	 *  those values based on fdt data, below. 	 */
name|sdhci_init_slot
argument_list|(
name|dev
argument_list|,
operator|&
name|sc
operator|->
name|slot
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * The SDHCI controller doesn't realize it, but we can support 8-bit 	 * even though we're not a v3.0 controller.  If there's an fdt bus-width 	 * property, honor it. 	 */
if|if
condition|(
name|OF_getencprop
argument_list|(
name|node
argument_list|,
literal|"bus-width"
argument_list|,
operator|&
name|prop
argument_list|,
sizeof|sizeof
argument_list|(
name|prop
argument_list|)
argument_list|)
operator|>
literal|0
condition|)
block|{
name|sc
operator|->
name|slot
operator|.
name|host
operator|.
name|caps
operator|&=
operator|~
operator|(
name|MMC_CAP_4_BIT_DATA
operator||
name|MMC_CAP_8_BIT_DATA
operator|)
expr_stmt|;
switch|switch
condition|(
name|prop
condition|)
block|{
case|case
literal|8
case|:
name|sc
operator|->
name|slot
operator|.
name|host
operator|.
name|caps
operator||=
name|MMC_CAP_8_BIT_DATA
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|4
case|:
name|sc
operator|->
name|slot
operator|.
name|host
operator|.
name|caps
operator||=
name|MMC_CAP_4_BIT_DATA
expr_stmt|;
break|break;
case|case
literal|1
case|:
break|break;
default|default:
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Bad bus-width value %u\n"
argument_list|,
name|prop
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* 	 * If the slot is flagged with the non-removable property, set our flag 	 * to always force the SDHCI_CARD_PRESENT bit on. 	 */
name|node
operator|=
name|ofw_bus_get_node
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|OF_hasprop
argument_list|(
name|node
argument_list|,
literal|"non-removable"
argument_list|)
condition|)
name|sc
operator|->
name|force_card_present
operator|=
name|true
expr_stmt|;
name|bus_generic_probe
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|bus_generic_attach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sdhci_start_slot
argument_list|(
operator|&
name|sc
operator|->
name|slot
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
if|if
condition|(
name|sc
operator|->
name|intr_cookie
condition|)
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|,
name|sc
operator|->
name|intr_cookie
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|irq_res
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mem_res
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|mem_res
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ti_sdhci_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ofw_bus_status_okay
argument_list|(
name|dev
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|ofw_bus_search_compatible
argument_list|(
name|dev
argument_list|,
name|compat_data
argument_list|)
operator|->
name|ocd_data
operator|!=
literal|0
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"TI MMCHS (SDHCI 2.0)"
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|ti_sdhci_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|ti_sdhci_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|ti_sdhci_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|ti_sdhci_detach
argument_list|)
block|,
comment|/* Bus interface */
name|DEVMETHOD
argument_list|(
name|bus_read_ivar
argument_list|,
name|sdhci_generic_read_ivar
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_write_ivar
argument_list|,
name|sdhci_generic_write_ivar
argument_list|)
block|,
comment|/* MMC bridge interface */
name|DEVMETHOD
argument_list|(
name|mmcbr_update_ios
argument_list|,
name|ti_sdhci_update_ios
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|mmcbr_request
argument_list|,
name|sdhci_generic_request
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|mmcbr_get_ro
argument_list|,
name|ti_sdhci_get_ro
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|mmcbr_acquire_host
argument_list|,
name|sdhci_generic_acquire_host
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|mmcbr_release_host
argument_list|,
name|sdhci_generic_release_host
argument_list|)
block|,
comment|/* SDHCI registers accessors */
name|DEVMETHOD
argument_list|(
name|sdhci_read_1
argument_list|,
name|ti_sdhci_read_1
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|sdhci_read_2
argument_list|,
name|ti_sdhci_read_2
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|sdhci_read_4
argument_list|,
name|ti_sdhci_read_4
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|sdhci_read_multi_4
argument_list|,
name|ti_sdhci_read_multi_4
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|sdhci_write_1
argument_list|,
name|ti_sdhci_write_1
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|sdhci_write_2
argument_list|,
name|ti_sdhci_write_2
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|sdhci_write_4
argument_list|,
name|ti_sdhci_write_4
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|sdhci_write_multi_4
argument_list|,
name|ti_sdhci_write_multi_4
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|ti_sdhci_devclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|ti_sdhci_driver
init|=
block|{
literal|"sdhci_ti"
block|,
name|ti_sdhci_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ti_sdhci_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|sdhci_ti
argument_list|,
name|simplebus
argument_list|,
name|ti_sdhci_driver
argument_list|,
name|ti_sdhci_devclass
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|sdhci_ti
argument_list|,
name|sdhci
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MMC_DECLARE_BRIDGE
argument_list|(
name|sdhci_ti
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

