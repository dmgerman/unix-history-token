begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2012  *	Ben Gray<bgray@freebsd.org>.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Texas Instruments TWL4030/TWL5030/TWL60x0/TPS659x0 Power Management.  *  * This driver covers the external clocks, allows for enabling&  * disabling their output.  *  *  *  * FLATTENED DEVICE TREE (FDT)  * Startup override settings can be specified in the FDT, if they are they  * should be under the twl parent device and take the following form:  *  *    external-clocks = "name1", "state1",  *                      "name2", "state2",  *                      etc;  *  * Each override should be a pair, the first entry is the name of the clock  * the second is the state to set, possible strings are either "on" or "off".  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpufunc.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<machine/intr.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/openfirm.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/ofw_bus.h>
end_include

begin_include
include|#
directive|include
file|"twl.h"
end_include

begin_include
include|#
directive|include
file|"twl_clks.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|twl_clks_debug
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Power Groups bits for the 4030 and 6030 devices  */
end_comment

begin_define
define|#
directive|define
name|TWL4030_P3_GRP
value|0x80
end_define

begin_comment
comment|/* Peripherals, power group */
end_comment

begin_define
define|#
directive|define
name|TWL4030_P2_GRP
value|0x40
end_define

begin_comment
comment|/* Modem power group */
end_comment

begin_define
define|#
directive|define
name|TWL4030_P1_GRP
value|0x20
end_define

begin_comment
comment|/* Application power group (FreeBSD control) */
end_comment

begin_define
define|#
directive|define
name|TWL6030_P3_GRP
value|0x04
end_define

begin_comment
comment|/* Modem power group */
end_comment

begin_define
define|#
directive|define
name|TWL6030_P2_GRP
value|0x02
end_define

begin_comment
comment|/* Connectivity power group */
end_comment

begin_define
define|#
directive|define
name|TWL6030_P1_GRP
value|0x01
end_define

begin_comment
comment|/* Application power group (FreeBSD control) */
end_comment

begin_comment
comment|/*  * Register offsets within a clk regulator register set  */
end_comment

begin_define
define|#
directive|define
name|TWL_CLKS_GRP
value|0x00
end_define

begin_comment
comment|/* Regulator GRP register */
end_comment

begin_define
define|#
directive|define
name|TWL_CLKS_STATE
value|0x02
end_define

begin_comment
comment|/* TWL6030 only */
end_comment

begin_comment
comment|/**  *  Support voltage regulators for the different IC's  */
end_comment

begin_struct
struct|struct
name|twl_clock
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|uint8_t
name|subdev
decl_stmt|;
name|uint8_t
name|regbase
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|twl_clock
name|twl4030_clocks
index|[]
init|=
block|{
block|{
literal|"32kclkout"
block|,
literal|0
block|,
literal|0x8e
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0x00
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|twl_clock
name|twl6030_clocks
index|[]
init|=
block|{
block|{
literal|"clk32kg"
block|,
literal|0
block|,
literal|0xbc
block|}
block|,
block|{
literal|"clk32kao"
block|,
literal|0
block|,
literal|0xb9
block|}
block|,
block|{
literal|"clk32kaudio"
block|,
literal|0
block|,
literal|0xbf
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0x00
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|TWL_CLKS_MAX_NAMELEN
value|32
end_define

begin_struct
struct|struct
name|twl_clk_entry
block|{
name|LIST_ENTRY
argument_list|(
argument|twl_clk_entry
argument_list|)
name|link
expr_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|oid
decl_stmt|;
name|char
name|name
index|[
name|TWL_CLKS_MAX_NAMELEN
index|]
decl_stmt|;
name|uint8_t
name|sub_dev
decl_stmt|;
comment|/* the sub-device number for the clock */
name|uint8_t
name|reg_off
decl_stmt|;
comment|/* register base address of the clock */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|twl_clks_softc
block|{
name|device_t
name|sc_dev
decl_stmt|;
comment|/* twl_clk device */
name|device_t
name|sc_pdev
decl_stmt|;
comment|/* parent device (twl) */
name|struct
name|sx
name|sc_sx
decl_stmt|;
comment|/* internal locking */
name|struct
name|intr_config_hook
name|sc_init_hook
decl_stmt|;
name|LIST_HEAD
argument_list|(
argument|twl_clk_list
argument_list|,
argument|twl_clk_entry
argument_list|)
name|sc_clks_list
expr_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/**  *	Macros for driver shared locking  */
end_comment

begin_define
define|#
directive|define
name|TWL_CLKS_XLOCK
parameter_list|(
name|_sc
parameter_list|)
value|sx_xlock(&(_sc)->sc_sx)
end_define

begin_define
define|#
directive|define
name|TWL_CLKS_XUNLOCK
parameter_list|(
name|_sc
parameter_list|)
value|sx_xunlock(&(_sc)->sc_sx)
end_define

begin_define
define|#
directive|define
name|TWL_CLKS_SLOCK
parameter_list|(
name|_sc
parameter_list|)
value|sx_slock(&(_sc)->sc_sx)
end_define

begin_define
define|#
directive|define
name|TWL_CLKS_SUNLOCK
parameter_list|(
name|_sc
parameter_list|)
value|sx_sunlock(&(_sc)->sc_sx)
end_define

begin_define
define|#
directive|define
name|TWL_CLKS_LOCK_INIT
parameter_list|(
name|_sc
parameter_list|)
value|sx_init(&(_sc)->sc_sx, "twl_clks")
end_define

begin_define
define|#
directive|define
name|TWL_CLKS_LOCK_DESTROY
parameter_list|(
name|_sc
parameter_list|)
value|sx_destroy(&(_sc)->sc_sx);
end_define

begin_define
define|#
directive|define
name|TWL_CLKS_ASSERT_LOCKED
parameter_list|(
name|_sc
parameter_list|)
value|sx_assert(&(_sc)->sc_sx, SA_LOCKED);
end_define

begin_define
define|#
directive|define
name|TWL_CLKS_LOCK_UPGRADE
parameter_list|(
name|_sc
parameter_list|)
define|\
value|do {                                         \ 		while (!sx_try_upgrade(&(_sc)->sc_sx))   \ 			pause("twl_clks_ex", (hz / 100));    \ 	} while(0)
end_define

begin_define
define|#
directive|define
name|TWL_CLKS_LOCK_DOWNGRADE
parameter_list|(
name|_sc
parameter_list|)
value|sx_downgrade(&(_sc)->sc_sx);
end_define

begin_comment
comment|/**  *	twl_clks_read_1 - read single register from the TWL device  *	twl_clks_write_1 - writes a single register in the TWL device  *	@sc: device context  *	@clk: the clock device we're reading from / writing to  *	@off: offset within the clock's register set  *	@val: the value to write or a pointer to a variable to store the result  *  *	RETURNS:  *	Zero on success or an error code on failure.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|twl_clks_read_1
parameter_list|(
name|struct
name|twl_clks_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|twl_clk_entry
modifier|*
name|clk
parameter_list|,
name|uint8_t
name|off
parameter_list|,
name|uint8_t
modifier|*
name|val
parameter_list|)
block|{
return|return
operator|(
name|twl_read
argument_list|(
name|sc
operator|->
name|sc_pdev
argument_list|,
name|clk
operator|->
name|sub_dev
argument_list|,
name|clk
operator|->
name|reg_off
operator|+
name|off
argument_list|,
name|val
argument_list|,
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|twl_clks_write_1
parameter_list|(
name|struct
name|twl_clks_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|twl_clk_entry
modifier|*
name|clk
parameter_list|,
name|uint8_t
name|off
parameter_list|,
name|uint8_t
name|val
parameter_list|)
block|{
return|return
operator|(
name|twl_write
argument_list|(
name|sc
operator|->
name|sc_pdev
argument_list|,
name|clk
operator|->
name|sub_dev
argument_list|,
name|clk
operator|->
name|reg_off
operator|+
name|off
argument_list|,
operator|&
name|val
argument_list|,
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	twl_clks_is_enabled - determines if a clock is enabled  *	@dev: TWL CLK device  *	@name: the name of the clock  *	@enabled: upon return will contain the 'enabled' state  *  *	LOCKING:  *	Internally the function takes and releases the TWL lock.  *  *	RETURNS:  *	Zero on success or a negative error code on failure.  */
end_comment

begin_function
name|int
name|twl_clks_is_enabled
parameter_list|(
name|device_t
name|dev
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
modifier|*
name|enabled
parameter_list|)
block|{
name|struct
name|twl_clks_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|twl_clk_entry
modifier|*
name|clk
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
name|int
name|err
decl_stmt|;
name|uint8_t
name|grp
decl_stmt|,
name|state
decl_stmt|;
name|TWL_CLKS_SLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|clk
argument_list|,
argument|&sc->sc_clks_list
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|clk
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|TWL_CLKS_SUNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|twl_is_4030
argument_list|(
name|sc
operator|->
name|sc_pdev
argument_list|)
condition|)
block|{
name|err
operator|=
name|twl_clks_read_1
argument_list|(
name|sc
argument_list|,
name|clk
argument_list|,
name|TWL_CLKS_GRP
argument_list|,
operator|&
name|grp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
operator|*
name|enabled
operator|=
operator|(
name|grp
operator|&
name|TWL4030_P1_GRP
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|twl_is_6030
argument_list|(
name|sc
operator|->
name|sc_pdev
argument_list|)
operator|||
name|twl_is_6025
argument_list|(
name|sc
operator|->
name|sc_pdev
argument_list|)
condition|)
block|{
name|TWL_CLKS_LOCK_UPGRADE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Check the clock is in the application group */
if|if
condition|(
name|twl_is_6030
argument_list|(
name|sc
operator|->
name|sc_pdev
argument_list|)
condition|)
block|{
name|err
operator|=
name|twl_clks_read_1
argument_list|(
name|sc
argument_list|,
name|clk
argument_list|,
name|TWL_CLKS_GRP
argument_list|,
operator|&
name|grp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|TWL_CLKS_LOCK_DOWNGRADE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
operator|!
operator|(
name|grp
operator|&
name|TWL6030_P1_GRP
operator|)
condition|)
block|{
name|TWL_CLKS_LOCK_DOWNGRADE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
operator|*
name|enabled
operator|=
literal|0
expr_stmt|;
comment|/* disabled */
goto|goto
name|done
goto|;
block|}
block|}
comment|/* Read the application mode state and verify it's ON */
name|err
operator|=
name|twl_clks_read_1
argument_list|(
name|sc
argument_list|,
name|clk
argument_list|,
name|TWL_CLKS_STATE
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
operator|*
name|enabled
operator|=
operator|(
operator|(
name|state
operator|&
literal|0x0C
operator|)
operator|==
literal|0x04
operator|)
expr_stmt|;
name|TWL_CLKS_LOCK_DOWNGRADE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|EINVAL
expr_stmt|;
block|}
name|done
label|:
name|TWL_CLKS_SUNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	twl_clks_set_state - enables/disables a clock output  *	@sc: device context  *	@clk: the clock entry to enable/disable  *	@enable: non-zero the clock is enabled, zero the clock is disabled  *  *	LOCKING:  *	The TWL CLK lock must be held before this function is called.  *  *	RETURNS:  *	Zero on success or an error code on failure.  */
end_comment

begin_function
specifier|static
name|int
name|twl_clks_set_state
parameter_list|(
name|struct
name|twl_clks_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|twl_clk_entry
modifier|*
name|clk
parameter_list|,
name|int
name|enable
parameter_list|)
block|{
name|int
name|xlocked
decl_stmt|;
name|int
name|err
decl_stmt|;
name|uint8_t
name|grp
decl_stmt|;
name|TWL_CLKS_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Upgrade the lock to exclusive because about to perform read-mod-write */
name|xlocked
operator|=
name|sx_xlocked
argument_list|(
operator|&
name|sc
operator|->
name|sc_sx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xlocked
condition|)
name|TWL_CLKS_LOCK_UPGRADE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|err
operator|=
name|twl_clks_read_1
argument_list|(
name|sc
argument_list|,
name|clk
argument_list|,
name|TWL_CLKS_GRP
argument_list|,
operator|&
name|grp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|twl_is_4030
argument_list|(
name|sc
operator|->
name|sc_pdev
argument_list|)
condition|)
block|{
comment|/* On the TWL4030 we just need to ensure the clock is in the right 		 * power domain, don't need to turn on explicitly like TWL6030. 		 */
if|if
condition|(
name|enable
condition|)
name|grp
operator||=
name|TWL4030_P1_GRP
expr_stmt|;
else|else
name|grp
operator|&=
operator|~
operator|(
name|TWL4030_P1_GRP
operator||
name|TWL4030_P2_GRP
operator||
name|TWL4030_P3_GRP
operator|)
expr_stmt|;
name|err
operator|=
name|twl_clks_write_1
argument_list|(
name|sc
argument_list|,
name|clk
argument_list|,
name|TWL_CLKS_GRP
argument_list|,
name|grp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|twl_is_6030
argument_list|(
name|sc
operator|->
name|sc_pdev
argument_list|)
operator|||
name|twl_is_6025
argument_list|(
name|sc
operator|->
name|sc_pdev
argument_list|)
condition|)
block|{
comment|/* Make sure the clock belongs to at least the APP power group */
if|if
condition|(
name|twl_is_6030
argument_list|(
name|sc
operator|->
name|sc_pdev
argument_list|)
operator|&&
operator|!
operator|(
name|grp
operator|&
name|TWL6030_P1_GRP
operator|)
condition|)
block|{
name|grp
operator||=
name|TWL6030_P1_GRP
expr_stmt|;
name|err
operator|=
name|twl_clks_write_1
argument_list|(
name|sc
argument_list|,
name|clk
argument_list|,
name|TWL_CLKS_GRP
argument_list|,
name|grp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|done
goto|;
block|}
comment|/* On TWL6030 we need to make sure we disable power for all groups */
if|if
condition|(
name|twl_is_6030
argument_list|(
name|sc
operator|->
name|sc_pdev
argument_list|)
condition|)
name|grp
operator|=
name|TWL6030_P1_GRP
operator||
name|TWL6030_P2_GRP
operator||
name|TWL6030_P3_GRP
expr_stmt|;
else|else
name|grp
operator|=
literal|0x00
expr_stmt|;
comment|/* Set the state of the clock */
if|if
condition|(
name|enable
condition|)
name|err
operator|=
name|twl_clks_write_1
argument_list|(
name|sc
argument_list|,
name|clk
argument_list|,
name|TWL_CLKS_STATE
argument_list|,
operator|(
name|grp
operator|<<
literal|5
operator|)
operator||
literal|0x01
argument_list|)
expr_stmt|;
else|else
name|err
operator|=
name|twl_clks_write_1
argument_list|(
name|sc
argument_list|,
name|clk
argument_list|,
name|TWL_CLKS_STATE
argument_list|,
operator|(
name|grp
operator|<<
literal|5
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|EINVAL
expr_stmt|;
block|}
name|done
label|:
if|if
condition|(
operator|!
name|xlocked
condition|)
name|TWL_CLKS_LOCK_DOWNGRADE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|twl_clks_debug
operator|>
literal|1
operator|)
operator|&&
operator|!
name|err
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s : %sabled\n"
argument_list|,
name|clk
operator|->
name|name
argument_list|,
name|enable
condition|?
literal|"en"
else|:
literal|"dis"
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	twl_clks_disable - disables a clock output  *	@dev: TWL clk device *	@name: the name of the clock  *  *	LOCKING:  *	Internally the function takes and releases the TWL lock.  *  *	RETURNS: *	Zero on success or an error code on failure.  */
end_comment

begin_function
name|int
name|twl_clks_disable
parameter_list|(
name|device_t
name|dev
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|twl_clks_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|twl_clk_entry
modifier|*
name|clk
decl_stmt|;
name|int
name|err
init|=
name|EINVAL
decl_stmt|;
name|TWL_CLKS_SLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|clk
argument_list|,
argument|&sc->sc_clks_list
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|clk
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|err
operator|=
name|twl_clks_set_state
argument_list|(
name|sc
argument_list|,
name|clk
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|TWL_CLKS_SUNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	twl_clks_enable - enables a clock output  *	@dev: TWL clk device  *	@name: the name of the clock  *  *	LOCKING:  *	Internally the function takes and releases the TWL CLKS lock.  *  *	RETURNS:  *	Zero on success or an error code on failure.  */
end_comment

begin_function
name|int
name|twl_clks_enable
parameter_list|(
name|device_t
name|dev
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|twl_clks_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|twl_clk_entry
modifier|*
name|clk
decl_stmt|;
name|int
name|err
init|=
name|EINVAL
decl_stmt|;
name|TWL_CLKS_SLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|clk
argument_list|,
argument|&sc->sc_clks_list
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|clk
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|err
operator|=
name|twl_clks_set_state
argument_list|(
name|sc
argument_list|,
name|clk
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|TWL_CLKS_SUNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	twl_clks_sysctl_clock - reads the state of the clock  *	@SYSCTL_HANDLER_ARGS: arguments for the callback  *  *	Returns the clock status; disabled is zero and enabled is non-zero.  *  *	LOCKING:  *	It's expected the TWL lock is held while this function is called.  *  *	RETURNS:  *	EIO if device is not present, otherwise 0 is returned.  */
end_comment

begin_function
specifier|static
name|int
name|twl_clks_sysctl_clock
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|twl_clks_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|twl_clks_softc
operator|*
operator|)
name|arg1
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|enabled
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|twl_clks_is_enabled
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|oidp
operator|->
name|oid_name
argument_list|,
operator|&
name|enabled
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|err
return|;
return|return
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|enabled
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	twl_clks_add_clock - adds single clock sysctls for the device  *	@sc: device soft context  *	@name: the name of the regulator  *	@nsub: the number of the subdevice  *	@regbase: the base address of the clocks registers  *  *	Adds a single clock to the device and also a sysctl interface for   *	querying it's status.  *  *	LOCKING:  *	It's expected the exclusive lock is held while this function is called.  *  *	RETURNS:  *	Pointer to the new clock entry on success, otherwise NULL on failure.  */
end_comment

begin_function
specifier|static
name|struct
name|twl_clk_entry
modifier|*
name|twl_clks_add_clock
parameter_list|(
name|struct
name|twl_clks_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint8_t
name|nsub
parameter_list|,
name|uint8_t
name|regbase
parameter_list|)
block|{
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
init|=
name|device_get_sysctl_ctx
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|tree
init|=
name|device_get_sysctl_tree
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
decl_stmt|;
name|struct
name|twl_clk_entry
modifier|*
name|new
decl_stmt|;
name|TWL_CLKS_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|new
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|twl_clk_entry
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|strncpy
argument_list|(
name|new
operator|->
name|name
argument_list|,
name|name
argument_list|,
name|TWL_CLKS_MAX_NAMELEN
argument_list|)
expr_stmt|;
name|new
operator|->
name|name
index|[
name|TWL_CLKS_MAX_NAMELEN
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|new
operator|->
name|sub_dev
operator|=
name|nsub
expr_stmt|;
name|new
operator|->
name|reg_off
operator|=
name|regbase
expr_stmt|;
comment|/* Add a sysctl entry for the clock */
name|new
operator|->
name|oid
operator|=
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
name|name
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|twl_clks_sysctl_clock
argument_list|,
literal|"I"
argument_list|,
literal|"external clock"
argument_list|)
expr_stmt|;
comment|/* Finally add the regulator to list of supported regulators */
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_clks_list
argument_list|,
name|new
argument_list|,
name|link
argument_list|)
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	twl_clks_add_clocks - populates the internal list of clocks  *	@sc: device soft context  *	@chip: the name of the chip used in the hints  *	@clks the list of clocks supported by the device  *  *	Loops over the list of clocks and adds them to the device context. Also  *	scans the FDT to determine if there are any clocks that should be  *	enabled/disabled automatically.  *  *	LOCKING:  *	Internally takes the exclusive lock while adding the clocks to the  *	device context.  *  *	RETURNS:  *	Always returns 0.  */
end_comment

begin_function
specifier|static
name|int
name|twl_clks_add_clocks
parameter_list|(
name|struct
name|twl_clks_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|twl_clock
modifier|*
name|clks
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
specifier|const
name|struct
name|twl_clock
modifier|*
name|walker
decl_stmt|;
name|struct
name|twl_clk_entry
modifier|*
name|entry
decl_stmt|;
name|phandle_t
name|child
decl_stmt|;
name|char
name|rnames
index|[
literal|256
index|]
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|state
decl_stmt|;
name|int
name|len
init|=
literal|0
decl_stmt|,
name|prop_len
decl_stmt|;
name|int
name|enable
decl_stmt|;
name|TWL_CLKS_XLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Add the regulators from the list */
name|walker
operator|=
operator|&
name|clks
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
name|walker
operator|->
name|name
operator|!=
name|NULL
condition|)
block|{
comment|/* Add the regulator to the list */
name|entry
operator|=
name|twl_clks_add_clock
argument_list|(
name|sc
argument_list|,
name|walker
operator|->
name|name
argument_list|,
name|walker
operator|->
name|subdev
argument_list|,
name|walker
operator|->
name|regbase
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
continue|continue;
name|walker
operator|++
expr_stmt|;
block|}
comment|/* Check for any FDT settings that need to be applied */
name|child
operator|=
name|ofw_bus_get_node
argument_list|(
name|sc
operator|->
name|sc_pdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
condition|)
block|{
name|prop_len
operator|=
name|OF_getprop
argument_list|(
name|child
argument_list|,
literal|"external-clocks"
argument_list|,
name|rnames
argument_list|,
sizeof|sizeof
argument_list|(
name|rnames
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|<
name|prop_len
condition|)
block|{
name|name
operator|=
name|rnames
operator|+
name|len
expr_stmt|;
name|len
operator|+=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|>=
name|prop_len
operator|)
operator|||
operator|(
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
condition|)
break|break;
name|state
operator|=
name|rnames
operator|+
name|len
expr_stmt|;
name|len
operator|+=
name|strlen
argument_list|(
name|state
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|state
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
break|break;
name|enable
operator|=
operator|!
name|strncmp
argument_list|(
name|state
argument_list|,
literal|"on"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|entry
argument_list|,
argument|&sc->sc_clks_list
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|entry
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|twl_clks_set_state
argument_list|(
name|sc
argument_list|,
name|entry
argument_list|,
name|enable
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
name|TWL_CLKS_XUNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|twl_clks_debug
condition|)
block|{
name|LIST_FOREACH
argument_list|(
argument|entry
argument_list|,
argument|&sc->sc_clks_list
argument_list|,
argument|link
argument_list|)
block|{
name|err
operator|=
name|twl_clks_is_enabled
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|entry
operator|->
name|name
argument_list|,
operator|&
name|enable
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s : %s\n"
argument_list|,
name|entry
operator|->
name|name
argument_list|,
name|enable
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	twl_clks_init - initialises the list of clocks  *	@dev: the twl_clks device  *  *	This function is called as an intrhook once interrupts have been enabled,  *	this is done so that the driver has the option to enable/disable a clock  *	based on settings providied in the FDT.  *  *	LOCKING:  *	May takes the exclusive lock in the function.  */
end_comment

begin_function
specifier|static
name|void
name|twl_clks_init
parameter_list|(
name|void
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|twl_clks_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
operator|(
name|device_t
operator|)
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|twl_is_4030
argument_list|(
name|sc
operator|->
name|sc_pdev
argument_list|)
condition|)
name|twl_clks_add_clocks
argument_list|(
name|sc
argument_list|,
name|twl4030_clocks
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|twl_is_6030
argument_list|(
name|sc
operator|->
name|sc_pdev
argument_list|)
operator|||
name|twl_is_6025
argument_list|(
name|sc
operator|->
name|sc_pdev
argument_list|)
condition|)
name|twl_clks_add_clocks
argument_list|(
name|sc
argument_list|,
name|twl6030_clocks
argument_list|)
expr_stmt|;
name|config_intrhook_disestablish
argument_list|(
operator|&
name|sc
operator|->
name|sc_init_hook
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|twl_clks_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
if|if
condition|(
name|twl_is_4030
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
condition|)
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"TI TWL4030 PMIC External Clocks"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|twl_is_6025
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
operator|||
name|twl_is_6030
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
condition|)
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"TI TWL6025/TWL6030 PMIC External Clocks"
argument_list|)
expr_stmt|;
else|else
return|return
operator|(
name|ENXIO
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|twl_clks_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|twl_clks_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_dev
operator|=
name|dev
expr_stmt|;
name|sc
operator|->
name|sc_pdev
operator|=
name|device_get_parent
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|TWL_CLKS_LOCK_INIT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_clks_list
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_init_hook
operator|.
name|ich_func
operator|=
name|twl_clks_init
expr_stmt|;
name|sc
operator|->
name|sc_init_hook
operator|.
name|ich_arg
operator|=
name|dev
expr_stmt|;
if|if
condition|(
name|config_intrhook_establish
argument_list|(
operator|&
name|sc
operator|->
name|sc_init_hook
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|twl_clks_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|twl_clks_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|twl_clk_entry
modifier|*
name|clk
decl_stmt|;
name|struct
name|twl_clk_entry
modifier|*
name|tmp
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|TWL_CLKS_XLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|clk
argument_list|,
argument|&sc->sc_clks_list
argument_list|,
argument|link
argument_list|,
argument|tmp
argument_list|)
block|{
name|LIST_REMOVE
argument_list|(
name|clk
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|sysctl_remove_oid
argument_list|(
name|clk
operator|->
name|oid
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|clk
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
name|TWL_CLKS_XUNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|TWL_CLKS_LOCK_DESTROY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|twl_clks_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|twl_clks_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|twl_clks_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|twl_clks_detach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|twl_clks_driver
init|=
block|{
literal|"twl_clks"
block|,
name|twl_clks_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|twl_clks_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|twl_clks_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|twl_clks
argument_list|,
name|twl
argument_list|,
name|twl_clks_driver
argument_list|,
name|twl_clks_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|twl_clks
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

