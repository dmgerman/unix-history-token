begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2011  *	Ben Gray<ben.r.gray@gmail.com>.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Texas Instruments TWL4030/TWL5030/TWL60x0/TPS659x0 Power Management.  *  * This driver covers the voltages regulators (LDO), allows for enabling&  * disabling the voltage output and adjusting the voltage level.  *  * Voltage regulators can belong to different power groups, in this driver we  * put the regulators under our control in the "Application power group".  *  *  * FLATTENED DEVICE TREE (FDT)  * Startup override settings can be specified in the FDT, if they are they  * should be under the twl parent device and take the following form:  *  *    voltage-regulators = "name1", "millivolts1",  *                         "name2", "millivolts2";  *  * Each override should be a pair, the first entry is the name of the regulator  * the second is the voltage (in millivolts) to set for the given regulator.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpufunc.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<machine/intr.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/openfirm.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/ofw_bus.h>
end_include

begin_include
include|#
directive|include
file|"twl.h"
end_include

begin_include
include|#
directive|include
file|"twl_vreg.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|twl_vreg_debug
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Power Groups bits for the 4030 and 6030 devices  */
end_comment

begin_define
define|#
directive|define
name|TWL4030_P3_GRP
value|0x80
end_define

begin_comment
comment|/* Peripherals, power group */
end_comment

begin_define
define|#
directive|define
name|TWL4030_P2_GRP
value|0x40
end_define

begin_comment
comment|/* Modem power group */
end_comment

begin_define
define|#
directive|define
name|TWL4030_P1_GRP
value|0x20
end_define

begin_comment
comment|/* Application power group (FreeBSD control) */
end_comment

begin_define
define|#
directive|define
name|TWL6030_P3_GRP
value|0x04
end_define

begin_comment
comment|/* Modem power group */
end_comment

begin_define
define|#
directive|define
name|TWL6030_P2_GRP
value|0x02
end_define

begin_comment
comment|/* Connectivity power group */
end_comment

begin_define
define|#
directive|define
name|TWL6030_P1_GRP
value|0x01
end_define

begin_comment
comment|/* Application power group (FreeBSD control) */
end_comment

begin_comment
comment|/*  * Register offsets within a LDO regulator register set  */
end_comment

begin_define
define|#
directive|define
name|TWL_VREG_GRP
value|0x00
end_define

begin_comment
comment|/* Regulator GRP register */
end_comment

begin_define
define|#
directive|define
name|TWL_VREG_STATE
value|0x02
end_define

begin_define
define|#
directive|define
name|TWL_VREG_VSEL
value|0x03
end_define

begin_comment
comment|/* Voltage select register */
end_comment

begin_define
define|#
directive|define
name|UNDF
value|0xFFFF
end_define

begin_decl_stmt
specifier|static
specifier|const
name|uint16_t
name|twl6030_voltages
index|[]
init|=
block|{
literal|0000
block|,
literal|1000
block|,
literal|1100
block|,
literal|1200
block|,
literal|1300
block|,
literal|1400
block|,
literal|1500
block|,
literal|1600
block|,
literal|1700
block|,
literal|1800
block|,
literal|1900
block|,
literal|2000
block|,
literal|2100
block|,
literal|2200
block|,
literal|2300
block|,
literal|2400
block|,
literal|2500
block|,
literal|2600
block|,
literal|2700
block|,
literal|2800
block|,
literal|2900
block|,
literal|3000
block|,
literal|3100
block|,
literal|3200
block|,
literal|3300
block|,
name|UNDF
block|,
name|UNDF
block|,
name|UNDF
block|,
name|UNDF
block|,
name|UNDF
block|,
name|UNDF
block|,
literal|2750
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|uint16_t
name|twl4030_vaux1_voltages
index|[]
init|=
block|{
literal|1500
block|,
literal|1800
block|,
literal|2500
block|,
literal|2800
block|,
literal|3000
block|,
literal|3000
block|,
literal|3000
block|,
literal|3000
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|uint16_t
name|twl4030_vaux2_voltages
index|[]
init|=
block|{
literal|1700
block|,
literal|1700
block|,
literal|1900
block|,
literal|1300
block|,
literal|1500
block|,
literal|1800
block|,
literal|2000
block|,
literal|2500
block|,
literal|2100
block|,
literal|2800
block|,
literal|2200
block|,
literal|2300
block|,
literal|2400
block|,
literal|2400
block|,
literal|2400
block|,
literal|2400
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|uint16_t
name|twl4030_vaux3_voltages
index|[]
init|=
block|{
literal|1500
block|,
literal|1800
block|,
literal|2500
block|,
literal|2800
block|,
literal|3000
block|,
literal|3000
block|,
literal|3000
block|,
literal|3000
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|uint16_t
name|twl4030_vaux4_voltages
index|[]
init|=
block|{
literal|700
block|,
literal|1000
block|,
literal|1200
block|,
literal|1300
block|,
literal|1500
block|,
literal|1800
block|,
literal|1850
block|,
literal|2500
block|,
literal|2600
block|,
literal|2800
block|,
literal|2850
block|,
literal|3000
block|,
literal|3150
block|,
literal|3150
block|,
literal|3150
block|,
literal|3150
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|uint16_t
name|twl4030_vmmc1_voltages
index|[]
init|=
block|{
literal|1850
block|,
literal|2850
block|,
literal|3000
block|,
literal|3150
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|uint16_t
name|twl4030_vmmc2_voltages
index|[]
init|=
block|{
literal|1000
block|,
literal|1000
block|,
literal|1200
block|,
literal|1300
block|,
literal|1500
block|,
literal|1800
block|,
literal|1850
block|,
literal|2500
block|,
literal|2600
block|,
literal|2800
block|,
literal|2850
block|,
literal|3000
block|,
literal|3150
block|,
literal|3150
block|,
literal|3150
block|,
literal|3150
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|uint16_t
name|twl4030_vpll1_voltages
index|[]
init|=
block|{
literal|1000
block|,
literal|1200
block|,
literal|1300
block|,
literal|1800
block|,
literal|2800
block|,
literal|3000
block|,
literal|3000
block|,
literal|3000
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|uint16_t
name|twl4030_vpll2_voltages
index|[]
init|=
block|{
literal|700
block|,
literal|1000
block|,
literal|1200
block|,
literal|1300
block|,
literal|1500
block|,
literal|1800
block|,
literal|1850
block|,
literal|2500
block|,
literal|2600
block|,
literal|2800
block|,
literal|2850
block|,
literal|3000
block|,
literal|3150
block|,
literal|3150
block|,
literal|3150
block|,
literal|3150
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|uint16_t
name|twl4030_vsim_voltages
index|[]
init|=
block|{
literal|1000
block|,
literal|1200
block|,
literal|1300
block|,
literal|1800
block|,
literal|2800
block|,
literal|3000
block|,
literal|3000
block|,
literal|3000
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|uint16_t
name|twl4030_vdac_voltages
index|[]
init|=
block|{
literal|1200
block|,
literal|1300
block|,
literal|1800
block|,
literal|1800
block|}
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* vdd1, vdd2, vdio, not currently used. */
end_comment

begin_endif
unit|static const uint16_t twl4030_vdd1_voltages[] = { 	800, 1450 }; static const uint16_t twl4030_vdd2_voltages[] = { 	800, 1450, 1500 }; static const uint16_t twl4030_vio_voltages[] = { 	1800, 1850 };
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|uint16_t
name|twl4030_vintana2_voltages
index|[]
init|=
block|{
literal|2500
block|,
literal|2750
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**  *  Support voltage regulators for the different IC's  */
end_comment

begin_struct
struct|struct
name|twl_regulator
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|uint8_t
name|subdev
decl_stmt|;
name|uint8_t
name|regbase
decl_stmt|;
name|uint16_t
name|fixedvoltage
decl_stmt|;
specifier|const
name|uint16_t
modifier|*
name|voltages
decl_stmt|;
name|uint32_t
name|num_voltages
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|TWL_REGULATOR_ADJUSTABLE
parameter_list|(
name|name
parameter_list|,
name|subdev
parameter_list|,
name|reg
parameter_list|,
name|voltages
parameter_list|)
define|\
value|{ name, subdev, reg, 0, voltages, (sizeof(voltages)/sizeof(voltages[0])) }
end_define

begin_define
define|#
directive|define
name|TWL_REGULATOR_FIXED
parameter_list|(
name|name
parameter_list|,
name|subdev
parameter_list|,
name|reg
parameter_list|,
name|voltage
parameter_list|)
define|\
value|{ name, subdev, reg, voltage, NULL, 0 }
end_define

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|twl_regulator
name|twl4030_regulators
index|[]
init|=
block|{
name|TWL_REGULATOR_ADJUSTABLE
argument_list|(
literal|"vaux1"
argument_list|,
literal|0
argument_list|,
literal|0x17
argument_list|,
name|twl4030_vaux1_voltages
argument_list|)
block|,
name|TWL_REGULATOR_ADJUSTABLE
argument_list|(
literal|"vaux2"
argument_list|,
literal|0
argument_list|,
literal|0x1B
argument_list|,
name|twl4030_vaux2_voltages
argument_list|)
block|,
name|TWL_REGULATOR_ADJUSTABLE
argument_list|(
literal|"vaux3"
argument_list|,
literal|0
argument_list|,
literal|0x1F
argument_list|,
name|twl4030_vaux3_voltages
argument_list|)
block|,
name|TWL_REGULATOR_ADJUSTABLE
argument_list|(
literal|"vaux4"
argument_list|,
literal|0
argument_list|,
literal|0x23
argument_list|,
name|twl4030_vaux4_voltages
argument_list|)
block|,
name|TWL_REGULATOR_ADJUSTABLE
argument_list|(
literal|"vmmc1"
argument_list|,
literal|0
argument_list|,
literal|0x27
argument_list|,
name|twl4030_vmmc1_voltages
argument_list|)
block|,
name|TWL_REGULATOR_ADJUSTABLE
argument_list|(
literal|"vmmc2"
argument_list|,
literal|0
argument_list|,
literal|0x2B
argument_list|,
name|twl4030_vmmc2_voltages
argument_list|)
block|,
name|TWL_REGULATOR_ADJUSTABLE
argument_list|(
literal|"vpll1"
argument_list|,
literal|0
argument_list|,
literal|0x2F
argument_list|,
name|twl4030_vpll1_voltages
argument_list|)
block|,
name|TWL_REGULATOR_ADJUSTABLE
argument_list|(
literal|"vpll2"
argument_list|,
literal|0
argument_list|,
literal|0x33
argument_list|,
name|twl4030_vpll2_voltages
argument_list|)
block|,
name|TWL_REGULATOR_ADJUSTABLE
argument_list|(
literal|"vsim"
argument_list|,
literal|0
argument_list|,
literal|0x37
argument_list|,
name|twl4030_vsim_voltages
argument_list|)
block|,
name|TWL_REGULATOR_ADJUSTABLE
argument_list|(
literal|"vdac"
argument_list|,
literal|0
argument_list|,
literal|0x3B
argument_list|,
name|twl4030_vdac_voltages
argument_list|)
block|,
name|TWL_REGULATOR_ADJUSTABLE
argument_list|(
literal|"vintana2"
argument_list|,
literal|0
argument_list|,
literal|0x43
argument_list|,
name|twl4030_vintana2_voltages
argument_list|)
block|,
name|TWL_REGULATOR_FIXED
argument_list|(
literal|"vintana1"
argument_list|,
literal|0
argument_list|,
literal|0x3F
argument_list|,
literal|1500
argument_list|)
block|,
name|TWL_REGULATOR_FIXED
argument_list|(
literal|"vintdig"
argument_list|,
literal|0
argument_list|,
literal|0x47
argument_list|,
literal|1500
argument_list|)
block|,
name|TWL_REGULATOR_FIXED
argument_list|(
literal|"vusb1v5"
argument_list|,
literal|0
argument_list|,
literal|0x71
argument_list|,
literal|1500
argument_list|)
block|,
name|TWL_REGULATOR_FIXED
argument_list|(
literal|"vusb1v8"
argument_list|,
literal|0
argument_list|,
literal|0x74
argument_list|,
literal|1800
argument_list|)
block|,
name|TWL_REGULATOR_FIXED
argument_list|(
literal|"vusb3v1"
argument_list|,
literal|0
argument_list|,
literal|0x77
argument_list|,
literal|3100
argument_list|)
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0x00
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|twl_regulator
name|twl6030_regulators
index|[]
init|=
block|{
name|TWL_REGULATOR_ADJUSTABLE
argument_list|(
literal|"vaux1"
argument_list|,
literal|0
argument_list|,
literal|0x84
argument_list|,
name|twl6030_voltages
argument_list|)
block|,
name|TWL_REGULATOR_ADJUSTABLE
argument_list|(
literal|"vaux2"
argument_list|,
literal|0
argument_list|,
literal|0x89
argument_list|,
name|twl6030_voltages
argument_list|)
block|,
name|TWL_REGULATOR_ADJUSTABLE
argument_list|(
literal|"vaux3"
argument_list|,
literal|0
argument_list|,
literal|0x8C
argument_list|,
name|twl6030_voltages
argument_list|)
block|,
name|TWL_REGULATOR_ADJUSTABLE
argument_list|(
literal|"vmmc"
argument_list|,
literal|0
argument_list|,
literal|0x98
argument_list|,
name|twl6030_voltages
argument_list|)
block|,
name|TWL_REGULATOR_ADJUSTABLE
argument_list|(
literal|"vpp"
argument_list|,
literal|0
argument_list|,
literal|0x9C
argument_list|,
name|twl6030_voltages
argument_list|)
block|,
name|TWL_REGULATOR_ADJUSTABLE
argument_list|(
literal|"vusim"
argument_list|,
literal|0
argument_list|,
literal|0xA4
argument_list|,
name|twl6030_voltages
argument_list|)
block|,
name|TWL_REGULATOR_FIXED
argument_list|(
literal|"vmem"
argument_list|,
literal|0
argument_list|,
literal|0x64
argument_list|,
literal|1800
argument_list|)
block|,
name|TWL_REGULATOR_FIXED
argument_list|(
literal|"vusb"
argument_list|,
literal|0
argument_list|,
literal|0xA0
argument_list|,
literal|3300
argument_list|)
block|,
name|TWL_REGULATOR_FIXED
argument_list|(
literal|"v1v8"
argument_list|,
literal|0
argument_list|,
literal|0x46
argument_list|,
literal|1800
argument_list|)
block|,
name|TWL_REGULATOR_FIXED
argument_list|(
literal|"v2v1"
argument_list|,
literal|0
argument_list|,
literal|0x4C
argument_list|,
literal|2100
argument_list|)
block|,
name|TWL_REGULATOR_FIXED
argument_list|(
literal|"v1v29"
argument_list|,
literal|0
argument_list|,
literal|0x40
argument_list|,
literal|1290
argument_list|)
block|,
name|TWL_REGULATOR_FIXED
argument_list|(
literal|"vcxio"
argument_list|,
literal|0
argument_list|,
literal|0x90
argument_list|,
literal|1800
argument_list|)
block|,
name|TWL_REGULATOR_FIXED
argument_list|(
literal|"vdac"
argument_list|,
literal|0
argument_list|,
literal|0x94
argument_list|,
literal|1800
argument_list|)
block|,
name|TWL_REGULATOR_FIXED
argument_list|(
literal|"vana"
argument_list|,
literal|0
argument_list|,
literal|0x80
argument_list|,
literal|2100
argument_list|)
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0x00
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|TWL_VREG_MAX_NAMELEN
value|32
end_define

begin_struct
struct|struct
name|twl_regulator_entry
block|{
name|LIST_ENTRY
argument_list|(
argument|twl_regulator_entry
argument_list|)
name|entries
expr_stmt|;
name|char
name|name
index|[
name|TWL_VREG_MAX_NAMELEN
index|]
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|oid
decl_stmt|;
name|uint8_t
name|sub_dev
decl_stmt|;
comment|/* TWL sub-device group */
name|uint8_t
name|reg_off
decl_stmt|;
comment|/* base register offset for the LDO */
name|uint16_t
name|fixed_voltage
decl_stmt|;
comment|/* the (milli)voltage if LDO is fixed */
specifier|const
name|uint16_t
modifier|*
name|supp_voltages
decl_stmt|;
comment|/* pointer to an array of possible voltages */
name|uint32_t
name|num_supp_voltages
decl_stmt|;
comment|/* the number of supplied voltages */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|twl_vreg_softc
block|{
name|device_t
name|sc_dev
decl_stmt|;
name|device_t
name|sc_pdev
decl_stmt|;
name|struct
name|sx
name|sc_sx
decl_stmt|;
name|struct
name|intr_config_hook
name|sc_init_hook
decl_stmt|;
name|LIST_HEAD
argument_list|(
argument|twl_regulator_list
argument_list|,
argument|twl_regulator_entry
argument_list|)
name|sc_vreg_list
expr_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|TWL_VREG_XLOCK
parameter_list|(
name|_sc
parameter_list|)
value|sx_xlock(&(_sc)->sc_sx)
end_define

begin_define
define|#
directive|define
name|TWL_VREG_XUNLOCK
parameter_list|(
name|_sc
parameter_list|)
value|sx_xunlock(&(_sc)->sc_sx)
end_define

begin_define
define|#
directive|define
name|TWL_VREG_SLOCK
parameter_list|(
name|_sc
parameter_list|)
value|sx_slock(&(_sc)->sc_sx)
end_define

begin_define
define|#
directive|define
name|TWL_VREG_SUNLOCK
parameter_list|(
name|_sc
parameter_list|)
value|sx_sunlock(&(_sc)->sc_sx)
end_define

begin_define
define|#
directive|define
name|TWL_VREG_LOCK_INIT
parameter_list|(
name|_sc
parameter_list|)
value|sx_init(&(_sc)->sc_sx, "twl_vreg")
end_define

begin_define
define|#
directive|define
name|TWL_VREG_LOCK_DESTROY
parameter_list|(
name|_sc
parameter_list|)
value|sx_destroy(&(_sc)->sc_sx);
end_define

begin_define
define|#
directive|define
name|TWL_VREG_ASSERT_LOCKED
parameter_list|(
name|_sc
parameter_list|)
value|sx_assert(&(_sc)->sc_sx, SA_LOCKED);
end_define

begin_define
define|#
directive|define
name|TWL_VREG_LOCK_UPGRADE
parameter_list|(
name|_sc
parameter_list|)
define|\
value|do {                                         \ 		while (!sx_try_upgrade(&(_sc)->sc_sx))   \ 			pause("twl_vreg_ex", (hz / 100));    \ 	} while(0)
end_define

begin_define
define|#
directive|define
name|TWL_VREG_LOCK_DOWNGRADE
parameter_list|(
name|_sc
parameter_list|)
value|sx_downgrade(&(_sc)->sc_sx);
end_define

begin_comment
comment|/**  *	twl_vreg_read_1 - read single register from the TWL device  *	twl_vreg_write_1 - write a single register in the TWL device  *	@sc: device context  *	@clk: the clock device we're reading from / writing to  *	@off: offset within the clock's register set  *	@val: the value to write or a pointer to a variable to store the result  *  *	RETURNS:  *	Zero on success or an error code on failure.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|twl_vreg_read_1
parameter_list|(
name|struct
name|twl_vreg_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|twl_regulator_entry
modifier|*
name|regulator
parameter_list|,
name|uint8_t
name|off
parameter_list|,
name|uint8_t
modifier|*
name|val
parameter_list|)
block|{
return|return
operator|(
name|twl_read
argument_list|(
name|sc
operator|->
name|sc_pdev
argument_list|,
name|regulator
operator|->
name|sub_dev
argument_list|,
name|regulator
operator|->
name|reg_off
operator|+
name|off
argument_list|,
name|val
argument_list|,
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|twl_vreg_write_1
parameter_list|(
name|struct
name|twl_vreg_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|twl_regulator_entry
modifier|*
name|regulator
parameter_list|,
name|uint8_t
name|off
parameter_list|,
name|uint8_t
name|val
parameter_list|)
block|{
return|return
operator|(
name|twl_write
argument_list|(
name|sc
operator|->
name|sc_pdev
argument_list|,
name|regulator
operator|->
name|sub_dev
argument_list|,
name|regulator
operator|->
name|reg_off
operator|+
name|off
argument_list|,
operator|&
name|val
argument_list|,
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	twl_millivolt_to_vsel - gets the vsel bit value to write into the register  *	                        for a desired voltage and regulator  *	@sc: the device soft context  *	@regulator: pointer to the regulator device  *	@millivolts: the millivolts to find the bit value for  *	@vsel: upon return will contain the corresponding register value  *  *	Accepts a (milli)voltage value and tries to find the closest match to the  *	actual supported voltages for the given regulator.  If a match is found  *	within 100mv of the target, @vsel is written with the match and 0 is  *	returned. If no voltage match is found the function returns an non-zero  *	value.  *  *	RETURNS:  *	Zero on success or an error code on failure.  */
end_comment

begin_function
specifier|static
name|int
name|twl_vreg_millivolt_to_vsel
parameter_list|(
name|struct
name|twl_vreg_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|twl_regulator_entry
modifier|*
name|regulator
parameter_list|,
name|int
name|millivolts
parameter_list|,
name|uint8_t
modifier|*
name|vsel
parameter_list|)
block|{
name|int
name|delta
decl_stmt|,
name|smallest_delta
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|closest_idx
decl_stmt|;
name|TWL_VREG_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|regulator
operator|->
name|supp_voltages
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Loop over the support voltages and try and find the closest match */
name|closest_idx
operator|=
literal|0
expr_stmt|;
name|smallest_delta
operator|=
literal|0x7fffffff
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|regulator
operator|->
name|num_supp_voltages
condition|;
name|i
operator|++
control|)
block|{
comment|/* Ignore undefined values */
if|if
condition|(
name|regulator
operator|->
name|supp_voltages
index|[
name|i
index|]
operator|==
name|UNDF
condition|)
continue|continue;
comment|/* Calculate the difference */
name|delta
operator|=
name|millivolts
operator|-
operator|(
name|int
operator|)
name|regulator
operator|->
name|supp_voltages
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|abs
argument_list|(
name|delta
argument_list|)
operator|<
name|smallest_delta
condition|)
block|{
name|smallest_delta
operator|=
name|abs
argument_list|(
name|delta
argument_list|)
expr_stmt|;
name|closest_idx
operator|=
name|i
expr_stmt|;
block|}
block|}
comment|/* Check we got a voltage that was within 100mv of the actual target, this 	 * is just a value I picked out of thin air. 	 */
if|if
condition|(
operator|(
name|smallest_delta
operator|>
literal|100
operator|)
operator|&&
operator|(
name|closest_idx
operator|<
literal|0x100
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
operator|*
name|vsel
operator|=
name|closest_idx
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	twl_vreg_is_regulator_enabled - returns the enabled status of the regulator  *	@sc: the device soft context  *	@regulator: pointer to the regulator device  *	@enabled: stores the enabled status, zero disabled, non-zero enabled  *  *	LOCKING:  *	On entry expects the TWL VREG lock to be held. Will upgrade the lock to  *	exclusive if not already but, if so, it will be downgraded again before  *	returning.  *  *	RETURNS:  *	Zero on success or an error code on failure.  */
end_comment

begin_function
specifier|static
name|int
name|twl_vreg_is_regulator_enabled
parameter_list|(
name|struct
name|twl_vreg_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|twl_regulator_entry
modifier|*
name|regulator
parameter_list|,
name|int
modifier|*
name|enabled
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|uint8_t
name|grp
decl_stmt|;
name|uint8_t
name|state
decl_stmt|;
name|int
name|xlocked
decl_stmt|;
if|if
condition|(
name|enabled
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|TWL_VREG_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|xlocked
operator|=
name|sx_xlocked
argument_list|(
operator|&
name|sc
operator|->
name|sc_sx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xlocked
condition|)
name|TWL_VREG_LOCK_UPGRADE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* The status reading is different for the different devices */
if|if
condition|(
name|twl_is_4030
argument_list|(
name|sc
operator|->
name|sc_pdev
argument_list|)
condition|)
block|{
name|err
operator|=
name|twl_vreg_read_1
argument_list|(
name|sc
argument_list|,
name|regulator
argument_list|,
name|TWL_VREG_GRP
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|done
goto|;
operator|*
name|enabled
operator|=
operator|(
name|state
operator|&
name|TWL4030_P1_GRP
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|twl_is_6030
argument_list|(
name|sc
operator|->
name|sc_pdev
argument_list|)
operator|||
name|twl_is_6025
argument_list|(
name|sc
operator|->
name|sc_pdev
argument_list|)
condition|)
block|{
comment|/* Check the regulator is in the application group */
if|if
condition|(
name|twl_is_6030
argument_list|(
name|sc
operator|->
name|sc_pdev
argument_list|)
condition|)
block|{
name|err
operator|=
name|twl_vreg_read_1
argument_list|(
name|sc
argument_list|,
name|regulator
argument_list|,
name|TWL_VREG_GRP
argument_list|,
operator|&
name|grp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
operator|!
operator|(
name|grp
operator|&
name|TWL6030_P1_GRP
operator|)
condition|)
block|{
operator|*
name|enabled
operator|=
literal|0
expr_stmt|;
comment|/* disabled */
goto|goto
name|done
goto|;
block|}
block|}
comment|/* Read the application mode state and verify it's ON */
name|err
operator|=
name|twl_vreg_read_1
argument_list|(
name|sc
argument_list|,
name|regulator
argument_list|,
name|TWL_VREG_STATE
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|done
goto|;
operator|*
name|enabled
operator|=
operator|(
operator|(
name|state
operator|&
literal|0x0C
operator|)
operator|==
literal|0x04
operator|)
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|EINVAL
expr_stmt|;
block|}
name|done
label|:
if|if
condition|(
operator|!
name|xlocked
condition|)
name|TWL_VREG_LOCK_DOWNGRADE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	twl_vreg_disable_regulator - disables a voltage regulator  *	@sc: the device soft context  *	@regulator: pointer to the regulator device  *  *	Disables the regulator which will stop the output drivers.  *  *	LOCKING:  *	On entry expects the TWL VREG lock to be held. Will upgrade the lock to  *	exclusive if not already but, if so, it will be downgraded again before  *	returning.  *  *	RETURNS:  *	Zero on success or a positive error code on failure.  */
end_comment

begin_function
specifier|static
name|int
name|twl_vreg_disable_regulator
parameter_list|(
name|struct
name|twl_vreg_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|twl_regulator_entry
modifier|*
name|regulator
parameter_list|)
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
name|uint8_t
name|grp
decl_stmt|;
name|int
name|xlocked
decl_stmt|;
name|TWL_VREG_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|xlocked
operator|=
name|sx_xlocked
argument_list|(
operator|&
name|sc
operator|->
name|sc_sx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xlocked
condition|)
name|TWL_VREG_LOCK_UPGRADE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|twl_is_4030
argument_list|(
name|sc
operator|->
name|sc_pdev
argument_list|)
condition|)
block|{
comment|/* Read the regulator CFG_GRP register */
name|err
operator|=
name|twl_vreg_read_1
argument_list|(
name|sc
argument_list|,
name|regulator
argument_list|,
name|TWL_VREG_GRP
argument_list|,
operator|&
name|grp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|done
goto|;
comment|/* On the TWL4030 we just need to remove the regulator from all the 		 * power groups. 		 */
name|grp
operator|&=
operator|~
operator|(
name|TWL4030_P1_GRP
operator||
name|TWL4030_P2_GRP
operator||
name|TWL4030_P3_GRP
operator|)
expr_stmt|;
name|err
operator|=
name|twl_vreg_write_1
argument_list|(
name|sc
argument_list|,
name|regulator
argument_list|,
name|TWL_VREG_GRP
argument_list|,
name|grp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|twl_is_6030
argument_list|(
name|sc
operator|->
name|sc_pdev
argument_list|)
operator|||
name|twl_is_6025
argument_list|(
name|sc
operator|->
name|sc_pdev
argument_list|)
condition|)
block|{
comment|/* On TWL6030 we need to make sure we disable power for all groups */
if|if
condition|(
name|twl_is_6030
argument_list|(
name|sc
operator|->
name|sc_pdev
argument_list|)
condition|)
name|grp
operator|=
name|TWL6030_P1_GRP
operator||
name|TWL6030_P2_GRP
operator||
name|TWL6030_P3_GRP
expr_stmt|;
else|else
name|grp
operator|=
literal|0x00
expr_stmt|;
comment|/* Write the resource state to "OFF" */
name|err
operator|=
name|twl_vreg_write_1
argument_list|(
name|sc
argument_list|,
name|regulator
argument_list|,
name|TWL_VREG_STATE
argument_list|,
operator|(
name|grp
operator|<<
literal|5
operator|)
argument_list|)
expr_stmt|;
block|}
name|done
label|:
if|if
condition|(
operator|!
name|xlocked
condition|)
name|TWL_VREG_LOCK_DOWNGRADE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	twl_vreg_enable_regulator - enables the voltage regulator  *	@sc: the device soft context  *	@regulator: pointer to the regulator device  *  *	Enables the regulator which will enable the voltage out at the currently  *	set voltage.  Set the voltage before calling this function to avoid  *	driving the voltage too high/low by mistake.  *  *	LOCKING:  *	On entry expects the TWL VREG lock to be held. Will upgrade the lock to  *	exclusive if not already but, if so, it will be downgraded again before  *	returning.  *  *	RETURNS:  *	Zero on success or a positive error code on failure.  */
end_comment

begin_function
specifier|static
name|int
name|twl_vreg_enable_regulator
parameter_list|(
name|struct
name|twl_vreg_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|twl_regulator_entry
modifier|*
name|regulator
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|uint8_t
name|grp
decl_stmt|;
name|int
name|xlocked
decl_stmt|;
name|TWL_VREG_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|xlocked
operator|=
name|sx_xlocked
argument_list|(
operator|&
name|sc
operator|->
name|sc_sx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xlocked
condition|)
name|TWL_VREG_LOCK_UPGRADE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|err
operator|=
name|twl_vreg_read_1
argument_list|(
name|sc
argument_list|,
name|regulator
argument_list|,
name|TWL_VREG_GRP
argument_list|,
operator|&
name|grp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|done
goto|;
comment|/* Enable the regulator by ensuring it's in the application power group 	 * and is in the "on" state. 	 */
if|if
condition|(
name|twl_is_4030
argument_list|(
name|sc
operator|->
name|sc_pdev
argument_list|)
condition|)
block|{
comment|/* On the TWL4030 we just need to ensure the regulator is in the right 		 * power domain, don't need to turn on explicitly like TWL6030. 		 */
name|grp
operator||=
name|TWL4030_P1_GRP
expr_stmt|;
name|err
operator|=
name|twl_vreg_write_1
argument_list|(
name|sc
argument_list|,
name|regulator
argument_list|,
name|TWL_VREG_GRP
argument_list|,
name|grp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|twl_is_6030
argument_list|(
name|sc
operator|->
name|sc_pdev
argument_list|)
operator|||
name|twl_is_6025
argument_list|(
name|sc
operator|->
name|sc_pdev
argument_list|)
condition|)
block|{
if|if
condition|(
name|twl_is_6030
argument_list|(
name|sc
operator|->
name|sc_pdev
argument_list|)
operator|&&
operator|!
operator|(
name|grp
operator|&
name|TWL6030_P1_GRP
operator|)
condition|)
block|{
name|grp
operator||=
name|TWL6030_P1_GRP
expr_stmt|;
name|err
operator|=
name|twl_vreg_write_1
argument_list|(
name|sc
argument_list|,
name|regulator
argument_list|,
name|TWL_VREG_GRP
argument_list|,
name|grp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|done
goto|;
block|}
comment|/* Write the resource state to "ON" */
name|err
operator|=
name|twl_vreg_write_1
argument_list|(
name|sc
argument_list|,
name|regulator
argument_list|,
name|TWL_VREG_STATE
argument_list|,
operator|(
name|grp
operator|<<
literal|5
operator|)
operator||
literal|0x01
argument_list|)
expr_stmt|;
block|}
name|done
label|:
if|if
condition|(
operator|!
name|xlocked
condition|)
name|TWL_VREG_LOCK_DOWNGRADE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	twl_vreg_write_regulator_voltage - sets the voltage level on a regulator  *	@sc: the device soft context  *	@regulator: pointer to the regulator structure  *	@millivolts: the voltage to set  *  *	Sets the voltage output on a given regulator, if the regulator is not  *	enabled, it will be enabled.  *  *	LOCKING:  *	On entry expects the TWL VREG lock to be held, may upgrade the lock to  *	exclusive but if so it will be downgraded once again before returning.  *  *	RETURNS:  *	Zero on success or an error code on failure.  */
end_comment

begin_function
specifier|static
name|int
name|twl_vreg_write_regulator_voltage
parameter_list|(
name|struct
name|twl_vreg_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|twl_regulator_entry
modifier|*
name|regulator
parameter_list|,
name|int
name|millivolts
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|uint8_t
name|vsel
decl_stmt|;
name|int
name|xlocked
decl_stmt|;
name|TWL_VREG_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* If millivolts is zero then we simply disable the output */
if|if
condition|(
name|millivolts
operator|==
literal|0
condition|)
return|return
operator|(
name|twl_vreg_disable_regulator
argument_list|(
name|sc
argument_list|,
name|regulator
argument_list|)
operator|)
return|;
comment|/* If the regulator has a fixed voltage then check the setting matches 	 * and simply enable. 	 */
if|if
condition|(
name|regulator
operator|->
name|supp_voltages
operator|==
name|NULL
operator|||
name|regulator
operator|->
name|num_supp_voltages
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|millivolts
operator|!=
name|regulator
operator|->
name|fixed_voltage
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
return|return
operator|(
name|twl_vreg_enable_regulator
argument_list|(
name|sc
argument_list|,
name|regulator
argument_list|)
operator|)
return|;
block|}
comment|/* Get the VSEL value for the given voltage */
name|err
operator|=
name|twl_vreg_millivolt_to_vsel
argument_list|(
name|sc
argument_list|,
name|regulator
argument_list|,
name|millivolts
argument_list|,
operator|&
name|vsel
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* Need to upgrade because writing the voltage and enabling should be atomic */
name|xlocked
operator|=
name|sx_xlocked
argument_list|(
operator|&
name|sc
operator|->
name|sc_sx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xlocked
condition|)
name|TWL_VREG_LOCK_UPGRADE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Set voltage and enable (atomically) */
name|err
operator|=
name|twl_vreg_write_1
argument_list|(
name|sc
argument_list|,
name|regulator
argument_list|,
name|TWL_VREG_VSEL
argument_list|,
operator|(
name|vsel
operator|&
literal|0x1f
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
block|{
name|err
operator|=
name|twl_vreg_enable_regulator
argument_list|(
name|sc
argument_list|,
name|regulator
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|xlocked
condition|)
name|TWL_VREG_LOCK_DOWNGRADE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|twl_vreg_debug
operator|>
literal|1
operator|)
operator|&&
operator|!
name|err
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s : setting voltage to %dmV (vsel: 0x%x)\n"
argument_list|,
name|regulator
operator|->
name|name
argument_list|,
name|millivolts
argument_list|,
name|vsel
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	twl_vreg_read_regulator_voltage - reads the voltage on a given regulator  *	@sc: the device soft context  *	@regulator: pointer to the regulator structure  *	@millivolts: upon return will contain the voltage on the regulator  *  *	LOCKING:  *	On entry expects the TWL VREG lock to be held. It will upgrade the lock to  *	exclusive if not already, but if so, it will be downgraded again before  *	returning.  *  *	RETURNS:  *	Zero on success, or otherwise an error code.  */
end_comment

begin_function
specifier|static
name|int
name|twl_vreg_read_regulator_voltage
parameter_list|(
name|struct
name|twl_vreg_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|twl_regulator_entry
modifier|*
name|regulator
parameter_list|,
name|int
modifier|*
name|millivolts
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|int
name|en
init|=
literal|0
decl_stmt|;
name|int
name|xlocked
decl_stmt|;
name|uint8_t
name|vsel
decl_stmt|;
name|TWL_VREG_ASSERT_LOCKED
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Need to upgrade the lock because checking enabled state and voltage 	 * should be atomic. 	 */
name|xlocked
operator|=
name|sx_xlocked
argument_list|(
operator|&
name|sc
operator|->
name|sc_sx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xlocked
condition|)
name|TWL_VREG_LOCK_UPGRADE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Check if the regulator is currently enabled */
name|err
operator|=
name|twl_vreg_is_regulator_enabled
argument_list|(
name|sc
argument_list|,
name|regulator
argument_list|,
operator|&
name|en
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|done
goto|;
operator|*
name|millivolts
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|en
condition|)
goto|goto
name|done
goto|;
comment|/* Not all voltages are adjustable */
if|if
condition|(
name|regulator
operator|->
name|supp_voltages
operator|==
name|NULL
operator|||
operator|!
name|regulator
operator|->
name|num_supp_voltages
condition|)
block|{
operator|*
name|millivolts
operator|=
name|regulator
operator|->
name|fixed_voltage
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* For variable voltages read the voltage register */
name|err
operator|=
name|twl_vreg_read_1
argument_list|(
name|sc
argument_list|,
name|regulator
argument_list|,
name|TWL_VREG_VSEL
argument_list|,
operator|&
name|vsel
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|done
goto|;
name|vsel
operator|&=
operator|(
name|regulator
operator|->
name|num_supp_voltages
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|regulator
operator|->
name|supp_voltages
index|[
name|vsel
index|]
operator|==
name|UNDF
condition|)
block|{
name|err
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
operator|*
name|millivolts
operator|=
name|regulator
operator|->
name|supp_voltages
index|[
name|vsel
index|]
expr_stmt|;
name|done
label|:
if|if
condition|(
operator|!
name|xlocked
condition|)
name|TWL_VREG_LOCK_DOWNGRADE
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|twl_vreg_debug
operator|>
literal|1
operator|)
operator|&&
operator|!
name|err
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s : reading voltage is %dmV (vsel: 0x%x)\n"
argument_list|,
name|regulator
operator|->
name|name
argument_list|,
operator|*
name|millivolts
argument_list|,
name|vsel
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	twl_vreg_get_voltage - public interface to read the voltage on a regulator  *	@dev: TWL VREG device  *	@name: the name of the regulator to read the voltage of  *	@millivolts: pointer to an integer that upon return will contain the mV  *  *	If the regulator is disabled the function will set the @millivolts to zero.  *  *	LOCKING:  *	Internally the function takes and releases the TWL VREG lock.  *  *	RETURNS:  *	Zero on success or a negative error code on failure.  */
end_comment

begin_function
name|int
name|twl_vreg_get_voltage
parameter_list|(
name|device_t
name|dev
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
modifier|*
name|millivolts
parameter_list|)
block|{
name|struct
name|twl_vreg_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|twl_regulator_entry
modifier|*
name|regulator
decl_stmt|;
name|int
name|err
init|=
name|EINVAL
decl_stmt|;
if|if
condition|(
name|millivolts
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|TWL_VREG_SLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|regulator
argument_list|,
argument|&sc->sc_vreg_list
argument_list|,
argument|entries
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|regulator
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|err
operator|=
name|twl_vreg_read_regulator_voltage
argument_list|(
name|sc
argument_list|,
name|regulator
argument_list|,
name|millivolts
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|TWL_VREG_SUNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	twl_vreg_set_voltage - public interface to write the voltage on a regulator  *	@dev: TWL VREG device  *	@name: the name of the regulator to read the voltage of  *	@millivolts: the voltage to set in millivolts  *  *	Sets the output voltage on a given regulator. If the regulator is a fixed  *	voltage reg then the @millivolts value should match the fixed voltage. If  *	a variable regulator then the @millivolt value must fit within the max/min  *	range of the given regulator.  *  *	LOCKING:  *	Internally the function takes and releases the TWL VREG lock.  *  *	RETURNS:  *	Zero on success or a negative error code on failure.  */
end_comment

begin_function
name|int
name|twl_vreg_set_voltage
parameter_list|(
name|device_t
name|dev
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|millivolts
parameter_list|)
block|{
name|struct
name|twl_vreg_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|twl_regulator_entry
modifier|*
name|regulator
decl_stmt|;
name|int
name|err
init|=
name|EINVAL
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|TWL_VREG_SLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|regulator
argument_list|,
argument|&sc->sc_vreg_list
argument_list|,
argument|entries
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|regulator
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|err
operator|=
name|twl_vreg_write_regulator_voltage
argument_list|(
name|sc
argument_list|,
name|regulator
argument_list|,
name|millivolts
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|TWL_VREG_SUNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	twl_sysctl_voltage - reads or writes the voltage for a regulator  *	@SYSCTL_HANDLER_ARGS: arguments for the callback  *  *	Callback for the sysctl entry for the regulator, simply used to return  *	the voltage on a particular regulator.  *  *	LOCKING:  *	Takes the TWL_VREG shared lock internally.  *  *	RETURNS:  *	Zero on success or an error code on failure.  */
end_comment

begin_function
specifier|static
name|int
name|twl_vreg_sysctl_voltage
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|twl_vreg_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|twl_vreg_softc
operator|*
operator|)
name|arg1
decl_stmt|;
name|struct
name|twl_regulator_entry
modifier|*
name|regulator
decl_stmt|;
name|int
name|voltage
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
name|TWL_VREG_SLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Find the regulator with the matching name */
name|LIST_FOREACH
argument_list|(
argument|regulator
argument_list|,
argument|&sc->sc_vreg_list
argument_list|,
argument|entries
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|regulator
operator|->
name|name
argument_list|,
name|oidp
operator|->
name|oid_name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|/* Sanity check that we found the regulator */
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|TWL_VREG_SUNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|twl_vreg_read_regulator_voltage
argument_list|(
name|sc
argument_list|,
name|regulator
argument_list|,
operator|&
name|voltage
argument_list|)
expr_stmt|;
name|TWL_VREG_SUNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|voltage
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  *	twl_add_regulator - adds single voltage regulator sysctls for the device  *	@sc: device soft context  *	@name: the name of the regulator  *	@nsub: the number of the subdevice  *	@regbase: the base address of the voltage regulator registers  *	@fixed_voltage: if a fixed voltage regulator this defines it's voltage  *	@voltages: if a variable voltage regulator, an array of possible voltages  *	@num_voltages: the number of entries @voltages  *  *	Adds a voltage regulator to the device and also a sysctl interface for the  *	regulator.  *  *	LOCKING:  *	The TWL_VEG exclusive lock must be held while this function is called.  *  *	RETURNS:  *	Pointer to the new regulator entry on success, otherwise on failure NULL.  */
end_comment

begin_function
specifier|static
name|struct
name|twl_regulator_entry
modifier|*
name|twl_vreg_add_regulator
parameter_list|(
name|struct
name|twl_vreg_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint8_t
name|nsub
parameter_list|,
name|uint8_t
name|regbase
parameter_list|,
name|uint16_t
name|fixed_voltage
parameter_list|,
specifier|const
name|uint16_t
modifier|*
name|voltages
parameter_list|,
name|uint32_t
name|num_voltages
parameter_list|)
block|{
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
init|=
name|device_get_sysctl_ctx
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|tree
init|=
name|device_get_sysctl_tree
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
decl_stmt|;
name|struct
name|twl_regulator_entry
modifier|*
name|new
decl_stmt|;
name|new
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|twl_regulator_entry
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|strncpy
argument_list|(
name|new
operator|->
name|name
argument_list|,
name|name
argument_list|,
name|TWL_VREG_MAX_NAMELEN
argument_list|)
expr_stmt|;
name|new
operator|->
name|name
index|[
name|TWL_VREG_MAX_NAMELEN
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|new
operator|->
name|sub_dev
operator|=
name|nsub
expr_stmt|;
name|new
operator|->
name|reg_off
operator|=
name|regbase
expr_stmt|;
name|new
operator|->
name|fixed_voltage
operator|=
name|fixed_voltage
expr_stmt|;
name|new
operator|->
name|supp_voltages
operator|=
name|voltages
expr_stmt|;
name|new
operator|->
name|num_supp_voltages
operator|=
name|num_voltages
expr_stmt|;
comment|/* Add a sysctl entry for the voltage */
name|new
operator|->
name|oid
operator|=
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
name|name
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|twl_vreg_sysctl_voltage
argument_list|,
literal|"I"
argument_list|,
literal|"voltage regulator"
argument_list|)
expr_stmt|;
comment|/* Finally add the regulator to list of supported regulators */
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_vreg_list
argument_list|,
name|new
argument_list|,
name|entries
argument_list|)
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	twl_vreg_add_regulators - adds any voltage regulators to the device  *	@sc: device soft context  *	@chip: the name of the chip used in the hints  *	@regulators: the list of possible voltage regulators  *  *	Loops over the list of regulators and matches up with the FDT values,  *	adjusting the actual voltage based on the supplied values.  *  *	LOCKING:  *	The TWL_VEG exclusive lock must be held while this function is called.  *  *	RETURNS:  *	Always returns 0.  */
end_comment

begin_function
specifier|static
name|int
name|twl_vreg_add_regulators
parameter_list|(
name|struct
name|twl_vreg_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|struct
name|twl_regulator
modifier|*
name|regulators
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|int
name|millivolts
decl_stmt|;
specifier|const
name|struct
name|twl_regulator
modifier|*
name|walker
decl_stmt|;
name|struct
name|twl_regulator_entry
modifier|*
name|entry
decl_stmt|;
name|phandle_t
name|child
decl_stmt|;
name|char
name|rnames
index|[
literal|256
index|]
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|voltage
decl_stmt|;
name|int
name|len
init|=
literal|0
decl_stmt|,
name|prop_len
decl_stmt|;
comment|/* Add the regulators from the list */
name|walker
operator|=
operator|&
name|regulators
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
name|walker
operator|->
name|name
operator|!=
name|NULL
condition|)
block|{
comment|/* Add the regulator to the list */
name|entry
operator|=
name|twl_vreg_add_regulator
argument_list|(
name|sc
argument_list|,
name|walker
operator|->
name|name
argument_list|,
name|walker
operator|->
name|subdev
argument_list|,
name|walker
operator|->
name|regbase
argument_list|,
name|walker
operator|->
name|fixedvoltage
argument_list|,
name|walker
operator|->
name|voltages
argument_list|,
name|walker
operator|->
name|num_voltages
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
continue|continue;
name|walker
operator|++
expr_stmt|;
block|}
comment|/* Check if the FDT is telling us to set any voltages */
name|child
operator|=
name|ofw_bus_get_node
argument_list|(
name|sc
operator|->
name|sc_pdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
condition|)
block|{
name|prop_len
operator|=
name|OF_getprop
argument_list|(
name|child
argument_list|,
literal|"voltage-regulators"
argument_list|,
name|rnames
argument_list|,
sizeof|sizeof
argument_list|(
name|rnames
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|<
name|prop_len
condition|)
block|{
name|name
operator|=
name|rnames
operator|+
name|len
expr_stmt|;
name|len
operator|+=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|>=
name|prop_len
operator|)
operator|||
operator|(
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
condition|)
break|break;
name|voltage
operator|=
name|rnames
operator|+
name|len
expr_stmt|;
name|len
operator|+=
name|strlen
argument_list|(
name|voltage
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|voltage
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
break|break;
name|millivolts
operator|=
name|strtoul
argument_list|(
name|voltage
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|entry
argument_list|,
argument|&sc->sc_vreg_list
argument_list|,
argument|entries
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|entry
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|twl_vreg_write_regulator_voltage
argument_list|(
name|sc
argument_list|,
name|entry
argument_list|,
name|millivolts
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
if|if
condition|(
name|twl_vreg_debug
condition|)
block|{
name|LIST_FOREACH
argument_list|(
argument|entry
argument_list|,
argument|&sc->sc_vreg_list
argument_list|,
argument|entries
argument_list|)
block|{
name|err
operator|=
name|twl_vreg_read_regulator_voltage
argument_list|(
name|sc
argument_list|,
name|entry
argument_list|,
operator|&
name|millivolts
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s : %d mV\n"
argument_list|,
name|entry
operator|->
name|name
argument_list|,
name|millivolts
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	twl_vreg_init - initialises the list of regulators  *	@dev: the twl_vreg device  *  *	This function is called as an intrhook once interrupts have been enabled,  *	this is done so that the driver has the option to enable/disable or set  *	the voltage level based on settings providied in the FDT.  *  *	LOCKING:  *	Takes the exclusive lock in the function.  */
end_comment

begin_function
specifier|static
name|void
name|twl_vreg_init
parameter_list|(
name|void
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|twl_vreg_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
operator|(
name|device_t
operator|)
name|dev
argument_list|)
expr_stmt|;
name|TWL_VREG_XLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|twl_is_4030
argument_list|(
name|sc
operator|->
name|sc_pdev
argument_list|)
condition|)
name|twl_vreg_add_regulators
argument_list|(
name|sc
argument_list|,
name|twl4030_regulators
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|twl_is_6030
argument_list|(
name|sc
operator|->
name|sc_pdev
argument_list|)
operator|||
name|twl_is_6025
argument_list|(
name|sc
operator|->
name|sc_pdev
argument_list|)
condition|)
name|twl_vreg_add_regulators
argument_list|(
name|sc
argument_list|,
name|twl6030_regulators
argument_list|)
expr_stmt|;
name|TWL_VREG_XUNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|config_intrhook_disestablish
argument_list|(
operator|&
name|sc
operator|->
name|sc_init_hook
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|twl_vreg_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
if|if
condition|(
name|twl_is_4030
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
condition|)
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"TI TWL4030 PMIC Voltage Regulators"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|twl_is_6025
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
operator|||
name|twl_is_6030
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
condition|)
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"TI TWL6025/TWL6030 PMIC Voltage Regulators"
argument_list|)
expr_stmt|;
else|else
return|return
operator|(
name|ENXIO
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|twl_vreg_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|twl_vreg_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_dev
operator|=
name|dev
expr_stmt|;
name|sc
operator|->
name|sc_pdev
operator|=
name|device_get_parent
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|TWL_VREG_LOCK_INIT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_vreg_list
argument_list|)
expr_stmt|;
comment|/* We have to wait until interrupts are enabled. I2C read and write 	 * only works if the interrupts are available. 	 */
name|sc
operator|->
name|sc_init_hook
operator|.
name|ich_func
operator|=
name|twl_vreg_init
expr_stmt|;
name|sc
operator|->
name|sc_init_hook
operator|.
name|ich_arg
operator|=
name|dev
expr_stmt|;
if|if
condition|(
name|config_intrhook_establish
argument_list|(
operator|&
name|sc
operator|->
name|sc_init_hook
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|twl_vreg_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|twl_vreg_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|twl_regulator_entry
modifier|*
name|regulator
decl_stmt|;
name|struct
name|twl_regulator_entry
modifier|*
name|tmp
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Take the lock and free all the added regulators */
name|TWL_VREG_XLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|regulator
argument_list|,
argument|&sc->sc_vreg_list
argument_list|,
argument|entries
argument_list|,
argument|tmp
argument_list|)
block|{
name|LIST_REMOVE
argument_list|(
name|regulator
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|sysctl_remove_oid
argument_list|(
name|regulator
operator|->
name|oid
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|regulator
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
name|TWL_VREG_XUNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|TWL_VREG_LOCK_DESTROY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|twl_vreg_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|twl_vreg_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|twl_vreg_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|twl_vreg_detach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|twl_vreg_driver
init|=
block|{
literal|"twl_vreg"
block|,
name|twl_vreg_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|twl_vreg_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|twl_vreg_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|twl_vreg
argument_list|,
name|twl
argument_list|,
name|twl_vreg_driver
argument_list|,
name|twl_vreg_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|twl_vreg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

