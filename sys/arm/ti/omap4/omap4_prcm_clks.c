begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2011  *	Ben Gray<ben.r.gray@gmail.com>.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the company nor the name of the author may be used to  *    endorse or promote products derived from this software without specific  *    prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY BEN GRAY ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL BEN GRAY BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;  * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpufunc.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<machine/intr.h>
end_include

begin_include
include|#
directive|include
file|<arm/arm/mpcore_timervar.h>
end_include

begin_include
include|#
directive|include
file|<arm/ti/tivar.h>
end_include

begin_include
include|#
directive|include
file|<arm/ti/ti_prcm.h>
end_include

begin_include
include|#
directive|include
file|<arm/ti/omap4/omap4_reg.h>
end_include

begin_include
include|#
directive|include
file|<dev/fdt/fdt_common.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/openfirm.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/ofw_bus.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/ofw_bus_subr.h>
end_include

begin_comment
comment|/*  *	This file defines the clock configuration for the OMAP4xxx series of  *	devices.  *  *	How This is Suppose to Work  *	===========================  *	- There is a top level omap_prcm module that defines all OMAP SoC drivers  *	should use to enable/disable the system clocks regardless of the version  *	of OMAP device they are running on.  This top level PRCM module is just  *	a thin shim to chip specific functions that perform the donkey work of  *	configuring the clock - this file is the 'donkey' for OMAP44xx devices.  *  *	- The key bit in this file is the omap_clk_devmap array, it's  *	used by the omap_prcm driver to determine what clocks are valid and which  *	functions to call to manipulate them.  *  *	- In essence you just need to define some callbacks for each of the  *	clocks and then you're done.  *  *	- The other thing that is worth noting is that when the omap_prcm device  *	is registered you typically pass in some memory ranges which are the  *	SYS_MEMORY resources.  These resources are in turn allocated using   *	bus_allocate_resources(...) and the resource handles are passed to all  *	individual clock callback handlers.   *  *  *  *	OMAP4 devices are different from the previous OMAP3 devices in that there  *	is no longer a separate functional and interface clock for each module,  *	instead there is typically an interface clock that spans many modules.  */
end_comment

begin_define
define|#
directive|define
name|FREQ_96MHZ
value|96000000
end_define

begin_define
define|#
directive|define
name|FREQ_64MHZ
value|64000000
end_define

begin_define
define|#
directive|define
name|FREQ_48MHZ
value|48000000
end_define

begin_define
define|#
directive|define
name|FREQ_32KHZ
value|32000
end_define

begin_comment
comment|/**  *	We need three memory regions to cover all the clock configuration registers.  *	  *	   PRM Instance -  0x4A30 6000 : 0x4A30 8000  *	   CM1 Instance -  0x4A00 4000 : 0x4A00 5000  *	   CM2 Instance -  0x4A00 8000 : 0x4A00 A000  *  */
end_comment

begin_define
define|#
directive|define
name|PRM_INSTANCE_MEM_REGION
value|0
end_define

begin_define
define|#
directive|define
name|CM1_INSTANCE_MEM_REGION
value|1
end_define

begin_define
define|#
directive|define
name|CM2_INSTANCE_MEM_REGION
value|2
end_define

begin_comment
comment|/**  *	Address offsets from the PRM memory region to the top level clock control  *	registers.  */
end_comment

begin_define
define|#
directive|define
name|CKGEN_PRM_OFFSET
value|0x00000100UL
end_define

begin_define
define|#
directive|define
name|MPU_PRM_OFFSET
value|0x00000300UL
end_define

begin_define
define|#
directive|define
name|DSP_PRM_OFFSET
value|0x00000400UL
end_define

begin_define
define|#
directive|define
name|ABE_PRM_OFFSET
value|0x00000500UL
end_define

begin_define
define|#
directive|define
name|ALWAYS_ON_PRM_OFFSET
value|0x00000600UL
end_define

begin_define
define|#
directive|define
name|CORE_PRM_OFFSET
value|0x00000700UL
end_define

begin_define
define|#
directive|define
name|IVAHD_PRM_OFFSET
value|0x00000F00UL
end_define

begin_define
define|#
directive|define
name|CAM_PRM_OFFSET
value|0x00001000UL
end_define

begin_define
define|#
directive|define
name|DSS_PRM_OFFSET
value|0x00001100UL
end_define

begin_define
define|#
directive|define
name|SGX_PRM_OFFSET
value|0x00001200UL
end_define

begin_define
define|#
directive|define
name|L3INIT_PRM_OFFSET
value|0x00001300UL
end_define

begin_define
define|#
directive|define
name|L4PER_PRM_OFFSET
value|0x00001400UL
end_define

begin_define
define|#
directive|define
name|WKUP_PRM_OFFSET
value|0x00001700UL
end_define

begin_define
define|#
directive|define
name|WKUP_CM_OFFSET
value|0x00001800UL
end_define

begin_define
define|#
directive|define
name|EMU_PRM_OFFSET
value|0x00001900UL
end_define

begin_define
define|#
directive|define
name|EMU_CM_OFFSET
value|0x00001A00UL
end_define

begin_define
define|#
directive|define
name|DEVICE_PRM_OFFSET
value|0x00001B00UL
end_define

begin_define
define|#
directive|define
name|INSTR_PRM_OFFSET
value|0x00001F00UL
end_define

begin_define
define|#
directive|define
name|CM_ABE_DSS_SYS_CLKSEL_OFFSET
value|(CKGEN_PRM_OFFSET + 0x0000UL)
end_define

begin_define
define|#
directive|define
name|CM_L4_WKUP_CLKSELL_OFFSET
value|(CKGEN_PRM_OFFSET + 0x0008UL)
end_define

begin_define
define|#
directive|define
name|CM_ABE_PLL_REF_CLKSEL_OFFSET
value|(CKGEN_PRM_OFFSET + 0x000CUL)
end_define

begin_define
define|#
directive|define
name|CM_SYS_CLKSEL_OFFSET
value|(CKGEN_PRM_OFFSET + 0x0010UL)
end_define

begin_comment
comment|/**  *	Address offsets from the CM1 memory region to the top level clock control  *	registers.  */
end_comment

begin_define
define|#
directive|define
name|CKGEN_CM1_OFFSET
value|0x00000100UL
end_define

begin_define
define|#
directive|define
name|MPU_CM1_OFFSET
value|0x00000300UL
end_define

begin_define
define|#
directive|define
name|DSP_CM1_OFFSET
value|0x00000400UL
end_define

begin_define
define|#
directive|define
name|ABE_CM1_OFFSET
value|0x00000500UL
end_define

begin_define
define|#
directive|define
name|RESTORE_CM1_OFFSET
value|0x00000E00UL
end_define

begin_define
define|#
directive|define
name|INSTR_CM1_OFFSET
value|0x00000F00UL
end_define

begin_define
define|#
directive|define
name|CM_CLKSEL_DPLL_MPU
value|(CKGEN_CM1_OFFSET + 0x006CUL)
end_define

begin_comment
comment|/**  *	Address offsets from the CM2 memory region to the top level clock control  *	registers.  */
end_comment

begin_define
define|#
directive|define
name|INTRCONN_SOCKET_CM2_OFFSET
value|0x00000000UL
end_define

begin_define
define|#
directive|define
name|CKGEN_CM2_OFFSET
value|0x00000100UL
end_define

begin_define
define|#
directive|define
name|ALWAYS_ON_CM2_OFFSET
value|0x00000600UL
end_define

begin_define
define|#
directive|define
name|CORE_CM2_OFFSET
value|0x00000700UL
end_define

begin_define
define|#
directive|define
name|IVAHD_CM2_OFFSET
value|0x00000F00UL
end_define

begin_define
define|#
directive|define
name|CAM_CM2_OFFSET
value|0x00001000UL
end_define

begin_define
define|#
directive|define
name|DSS_CM2_OFFSET
value|0x00001100UL
end_define

begin_define
define|#
directive|define
name|SGX_CM2_OFFSET
value|0x00001200UL
end_define

begin_define
define|#
directive|define
name|L3INIT_CM2_OFFSET
value|0x00001300UL
end_define

begin_define
define|#
directive|define
name|L4PER_CM2_OFFSET
value|0x00001400UL
end_define

begin_define
define|#
directive|define
name|RESTORE_CM2_OFFSET
value|0x00001E00UL
end_define

begin_define
define|#
directive|define
name|INSTR_CM2_OFFSET
value|0x00001F00UL
end_define

begin_define
define|#
directive|define
name|CLKCTRL_MODULEMODE_MASK
value|0x00000003UL
end_define

begin_define
define|#
directive|define
name|CLKCTRL_MODULEMODE_DISABLE
value|0x00000000UL
end_define

begin_define
define|#
directive|define
name|CLKCTRL_MODULEMODE_AUTO
value|0x00000001UL
end_define

begin_define
define|#
directive|define
name|CLKCTRL_MODULEMODE_ENABLE
value|0x00000001UL
end_define

begin_define
define|#
directive|define
name|CLKCTRL_IDLEST_MASK
value|0x00030000UL
end_define

begin_define
define|#
directive|define
name|CLKCTRL_IDLEST_ENABLED
value|0x00000000UL
end_define

begin_define
define|#
directive|define
name|CLKCTRL_IDLEST_WAKING
value|0x00010000UL
end_define

begin_define
define|#
directive|define
name|CLKCTRL_IDLEST_IDLE
value|0x00020000UL
end_define

begin_define
define|#
directive|define
name|CLKCTRL_IDLEST_DISABLED
value|0x00030000UL
end_define

begin_decl_stmt
specifier|static
name|struct
name|resource_spec
name|omap4_scm_res_spec
index|[]
init|=
block|{
block|{
name|SYS_RES_MEMORY
block|,
literal|0
block|,
name|RF_ACTIVE
block|}
block|,
comment|/* Control memory window */
block|{
name|SYS_RES_MEMORY
block|,
literal|1
block|,
name|RF_ACTIVE
block|}
block|,
comment|/* Control memory window */
block|{
name|SYS_RES_MEMORY
block|,
literal|2
block|,
name|RF_ACTIVE
block|}
block|,
comment|/* Control memory window */
block|{
operator|-
literal|1
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|omap4_prcm_softc
block|{
name|struct
name|resource
modifier|*
name|sc_res
index|[
literal|3
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|omap4_prcm_softc
modifier|*
name|omap4_prcm_sc
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|omap4_clk_generic_activate
parameter_list|(
name|struct
name|ti_clock_dev
modifier|*
name|clkdev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|omap4_clk_generic_deactivate
parameter_list|(
name|struct
name|ti_clock_dev
modifier|*
name|clkdev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|omap4_clk_generic_accessible
parameter_list|(
name|struct
name|ti_clock_dev
modifier|*
name|clkdev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|omap4_clk_generic_set_source
parameter_list|(
name|struct
name|ti_clock_dev
modifier|*
name|clkdev
parameter_list|,
name|clk_src_t
name|clksrc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|omap4_clk_generic_get_source_freq
parameter_list|(
name|struct
name|ti_clock_dev
modifier|*
name|clkdev
parameter_list|,
name|unsigned
name|int
modifier|*
name|freq
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|omap4_clk_gptimer_set_source
parameter_list|(
name|struct
name|ti_clock_dev
modifier|*
name|clkdev
parameter_list|,
name|clk_src_t
name|clksrc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|omap4_clk_gptimer_get_source_freq
parameter_list|(
name|struct
name|ti_clock_dev
modifier|*
name|clkdev
parameter_list|,
name|unsigned
name|int
modifier|*
name|freq
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|omap4_clk_hsmmc_set_source
parameter_list|(
name|struct
name|ti_clock_dev
modifier|*
name|clkdev
parameter_list|,
name|clk_src_t
name|clksrc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|omap4_clk_hsmmc_get_source_freq
parameter_list|(
name|struct
name|ti_clock_dev
modifier|*
name|clkdev
parameter_list|,
name|unsigned
name|int
modifier|*
name|freq
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|omap4_clk_hsusbhost_set_source
parameter_list|(
name|struct
name|ti_clock_dev
modifier|*
name|clkdev
parameter_list|,
name|clk_src_t
name|clksrc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|omap4_clk_hsusbhost_activate
parameter_list|(
name|struct
name|ti_clock_dev
modifier|*
name|clkdev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|omap4_clk_hsusbhost_deactivate
parameter_list|(
name|struct
name|ti_clock_dev
modifier|*
name|clkdev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|omap4_clk_hsusbhost_accessible
parameter_list|(
name|struct
name|ti_clock_dev
modifier|*
name|clkdev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|omap4_clk_get_sysclk_freq
parameter_list|(
name|struct
name|ti_clock_dev
modifier|*
name|clkdev
parameter_list|,
name|unsigned
name|int
modifier|*
name|freq
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|omap4_clk_get_arm_fclk_freq
parameter_list|(
name|struct
name|ti_clock_dev
modifier|*
name|clkdev
parameter_list|,
name|unsigned
name|int
modifier|*
name|freq
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  *	omap_clk_devmap - Array of clock devices available on OMAP4xxx devices  *  *	This map only defines which clocks are valid and the callback functions  *	for clock activate, deactivate, etc.  It is used by the top level omap_prcm  *	driver.  *  *	The actual details of the clocks (config registers, bit fields, sources,  *	etc) are in the private g_omap3_clk_details array below.  *  */
end_comment

begin_define
define|#
directive|define
name|OMAP4_GENERIC_CLOCK_DEV
parameter_list|(
name|i
parameter_list|)
define|\
value|{	.id = (i), \ 		.clk_activate = omap4_clk_generic_activate, \ 		.clk_deactivate = omap4_clk_generic_deactivate, \ 		.clk_set_source = omap4_clk_generic_set_source, \ 		.clk_accessible = omap4_clk_generic_accessible, \ 		.clk_get_source_freq = omap4_clk_generic_get_source_freq \ 	}
end_define

begin_define
define|#
directive|define
name|OMAP4_GPTIMER_CLOCK_DEV
parameter_list|(
name|i
parameter_list|)
define|\
value|{	.id = (i), \ 		.clk_activate = omap4_clk_generic_activate, \ 		.clk_deactivate = omap4_clk_generic_deactivate, \ 		.clk_set_source = omap4_clk_gptimer_set_source, \ 		.clk_accessible = omap4_clk_generic_accessible, \ 		.clk_get_source_freq = omap4_clk_gptimer_get_source_freq \ 	}
end_define

begin_define
define|#
directive|define
name|OMAP4_HSMMC_CLOCK_DEV
parameter_list|(
name|i
parameter_list|)
define|\
value|{	.id = (i), \ 		.clk_activate = omap4_clk_generic_activate, \ 		.clk_deactivate = omap4_clk_generic_deactivate, \ 		.clk_set_source = omap4_clk_hsmmc_set_source, \ 		.clk_accessible = omap4_clk_generic_accessible, \ 		.clk_get_source_freq = omap4_clk_hsmmc_get_source_freq \ 	}
end_define

begin_define
define|#
directive|define
name|OMAP4_HSUSBHOST_CLOCK_DEV
parameter_list|(
name|i
parameter_list|)
define|\
value|{	.id = (i), \ 		.clk_activate = omap4_clk_hsusbhost_activate, \ 		.clk_deactivate = omap4_clk_hsusbhost_deactivate, \ 		.clk_set_source = omap4_clk_hsusbhost_set_source, \ 		.clk_accessible = omap4_clk_hsusbhost_accessible, \ 		.clk_get_source_freq = NULL \ 	}
end_define

begin_decl_stmt
name|struct
name|ti_clock_dev
name|ti_clk_devmap
index|[]
init|=
block|{
comment|/* System clocks */
block|{
operator|.
name|id
operator|=
name|SYS_CLK
block|,
operator|.
name|clk_activate
operator|=
name|NULL
block|,
operator|.
name|clk_deactivate
operator|=
name|NULL
block|,
operator|.
name|clk_set_source
operator|=
name|NULL
block|,
operator|.
name|clk_accessible
operator|=
name|NULL
block|,
operator|.
name|clk_get_source_freq
operator|=
name|omap4_clk_get_sysclk_freq
block|, 	}
block|,
comment|/* MPU (ARM) core clocks */
block|{
operator|.
name|id
operator|=
name|MPU_CLK
block|,
operator|.
name|clk_activate
operator|=
name|NULL
block|,
operator|.
name|clk_deactivate
operator|=
name|NULL
block|,
operator|.
name|clk_set_source
operator|=
name|NULL
block|,
operator|.
name|clk_accessible
operator|=
name|NULL
block|,
operator|.
name|clk_get_source_freq
operator|=
name|omap4_clk_get_arm_fclk_freq
block|, 	}
block|,
comment|/* UART device clocks */
name|OMAP4_GENERIC_CLOCK_DEV
argument_list|(
name|UART1_CLK
argument_list|)
block|,
name|OMAP4_GENERIC_CLOCK_DEV
argument_list|(
name|UART2_CLK
argument_list|)
block|,
name|OMAP4_GENERIC_CLOCK_DEV
argument_list|(
name|UART3_CLK
argument_list|)
block|,
name|OMAP4_GENERIC_CLOCK_DEV
argument_list|(
name|UART4_CLK
argument_list|)
block|,
comment|/* Timer device source clocks */
name|OMAP4_GPTIMER_CLOCK_DEV
argument_list|(
name|GPTIMER1_CLK
argument_list|)
block|,
name|OMAP4_GPTIMER_CLOCK_DEV
argument_list|(
name|GPTIMER2_CLK
argument_list|)
block|,
name|OMAP4_GPTIMER_CLOCK_DEV
argument_list|(
name|GPTIMER3_CLK
argument_list|)
block|,
name|OMAP4_GPTIMER_CLOCK_DEV
argument_list|(
name|GPTIMER4_CLK
argument_list|)
block|,
name|OMAP4_GPTIMER_CLOCK_DEV
argument_list|(
name|GPTIMER5_CLK
argument_list|)
block|,
name|OMAP4_GPTIMER_CLOCK_DEV
argument_list|(
name|GPTIMER6_CLK
argument_list|)
block|,
name|OMAP4_GPTIMER_CLOCK_DEV
argument_list|(
name|GPTIMER7_CLK
argument_list|)
block|,
name|OMAP4_GPTIMER_CLOCK_DEV
argument_list|(
name|GPTIMER8_CLK
argument_list|)
block|,
name|OMAP4_GPTIMER_CLOCK_DEV
argument_list|(
name|GPTIMER9_CLK
argument_list|)
block|,
name|OMAP4_GPTIMER_CLOCK_DEV
argument_list|(
name|GPTIMER10_CLK
argument_list|)
block|,
name|OMAP4_GPTIMER_CLOCK_DEV
argument_list|(
name|GPTIMER11_CLK
argument_list|)
block|,
comment|/* MMC device clocks (MMC1 and MMC2 can have different input clocks) */
name|OMAP4_HSMMC_CLOCK_DEV
argument_list|(
name|MMC1_CLK
argument_list|)
block|,
name|OMAP4_HSMMC_CLOCK_DEV
argument_list|(
name|MMC2_CLK
argument_list|)
block|,
name|OMAP4_GENERIC_CLOCK_DEV
argument_list|(
name|MMC3_CLK
argument_list|)
block|,
name|OMAP4_GENERIC_CLOCK_DEV
argument_list|(
name|MMC4_CLK
argument_list|)
block|,
name|OMAP4_GENERIC_CLOCK_DEV
argument_list|(
name|MMC5_CLK
argument_list|)
block|,
comment|/* USB HS (high speed TLL, EHCI and OHCI) */
name|OMAP4_HSUSBHOST_CLOCK_DEV
argument_list|(
name|USBTLL_CLK
argument_list|)
block|,
name|OMAP4_HSUSBHOST_CLOCK_DEV
argument_list|(
name|USBHSHOST_CLK
argument_list|)
block|,
name|OMAP4_HSUSBHOST_CLOCK_DEV
argument_list|(
name|USBFSHOST_CLK
argument_list|)
block|,
name|OMAP4_HSUSBHOST_CLOCK_DEV
argument_list|(
name|USBP1_PHY_CLK
argument_list|)
block|,
name|OMAP4_HSUSBHOST_CLOCK_DEV
argument_list|(
name|USBP2_PHY_CLK
argument_list|)
block|,
name|OMAP4_HSUSBHOST_CLOCK_DEV
argument_list|(
name|USBP1_UTMI_CLK
argument_list|)
block|,
name|OMAP4_HSUSBHOST_CLOCK_DEV
argument_list|(
name|USBP2_UTMI_CLK
argument_list|)
block|,
name|OMAP4_HSUSBHOST_CLOCK_DEV
argument_list|(
name|USBP1_HSIC_CLK
argument_list|)
block|,
name|OMAP4_HSUSBHOST_CLOCK_DEV
argument_list|(
name|USBP2_HSIC_CLK
argument_list|)
block|,
comment|/* GPIO */
name|OMAP4_GENERIC_CLOCK_DEV
argument_list|(
name|GPIO1_CLK
argument_list|)
block|,
name|OMAP4_GENERIC_CLOCK_DEV
argument_list|(
name|GPIO2_CLK
argument_list|)
block|,
name|OMAP4_GENERIC_CLOCK_DEV
argument_list|(
name|GPIO3_CLK
argument_list|)
block|,
name|OMAP4_GENERIC_CLOCK_DEV
argument_list|(
name|GPIO4_CLK
argument_list|)
block|,
name|OMAP4_GENERIC_CLOCK_DEV
argument_list|(
name|GPIO5_CLK
argument_list|)
block|,
name|OMAP4_GENERIC_CLOCK_DEV
argument_list|(
name|GPIO6_CLK
argument_list|)
block|,
comment|/* sDMA */
name|OMAP4_GENERIC_CLOCK_DEV
argument_list|(
name|SDMA_CLK
argument_list|)
block|,
comment|/* I2C */
name|OMAP4_GENERIC_CLOCK_DEV
argument_list|(
name|I2C1_CLK
argument_list|)
block|,
name|OMAP4_GENERIC_CLOCK_DEV
argument_list|(
name|I2C2_CLK
argument_list|)
block|,
name|OMAP4_GENERIC_CLOCK_DEV
argument_list|(
name|I2C3_CLK
argument_list|)
block|,
name|OMAP4_GENERIC_CLOCK_DEV
argument_list|(
name|I2C4_CLK
argument_list|)
block|,
block|{
name|INVALID_CLK_IDENT
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**  *	omap4_clk_details - Stores details for all the different clocks supported  *  *	Whenever an operation on a clock is being performed (activated, deactivated,  *	etc) this array is looked up to find the correct register and bit(s) we  *	should be modifying.  *  */
end_comment

begin_struct
struct|struct
name|omap4_clk_details
block|{
name|clk_ident_t
name|id
decl_stmt|;
name|uint32_t
name|mem_region
decl_stmt|;
name|uint32_t
name|clksel_reg
decl_stmt|;
name|int32_t
name|src_freq
decl_stmt|;
name|uint32_t
name|enable_mode
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|OMAP4_GENERIC_CLOCK_DETAILS
parameter_list|(
name|i
parameter_list|,
name|f
parameter_list|,
name|m
parameter_list|,
name|r
parameter_list|,
name|e
parameter_list|)
define|\
value|{	.id = (i), \ 		.mem_region = (m), \ 		.clksel_reg = (r), \ 		.src_freq = (f), \ 		.enable_mode = (e), \ 	}
end_define

begin_decl_stmt
specifier|static
name|struct
name|omap4_clk_details
name|g_omap4_clk_details
index|[]
init|=
block|{
comment|/* UART */
name|OMAP4_GENERIC_CLOCK_DETAILS
argument_list|(
name|UART1_CLK
argument_list|,
name|FREQ_48MHZ
argument_list|,
name|CM2_INSTANCE_MEM_REGION
argument_list|,
operator|(
name|L4PER_CM2_OFFSET
operator|+
literal|0x0140
operator|)
argument_list|,
name|CLKCTRL_MODULEMODE_ENABLE
argument_list|)
block|,
name|OMAP4_GENERIC_CLOCK_DETAILS
argument_list|(
name|UART2_CLK
argument_list|,
name|FREQ_48MHZ
argument_list|,
name|CM2_INSTANCE_MEM_REGION
argument_list|,
operator|(
name|L4PER_CM2_OFFSET
operator|+
literal|0x0148
operator|)
argument_list|,
name|CLKCTRL_MODULEMODE_ENABLE
argument_list|)
block|,
name|OMAP4_GENERIC_CLOCK_DETAILS
argument_list|(
name|UART3_CLK
argument_list|,
name|FREQ_48MHZ
argument_list|,
name|CM2_INSTANCE_MEM_REGION
argument_list|,
operator|(
name|L4PER_CM2_OFFSET
operator|+
literal|0x0140
operator|)
argument_list|,
name|CLKCTRL_MODULEMODE_ENABLE
argument_list|)
block|,
name|OMAP4_GENERIC_CLOCK_DETAILS
argument_list|(
name|UART4_CLK
argument_list|,
name|FREQ_48MHZ
argument_list|,
name|CM2_INSTANCE_MEM_REGION
argument_list|,
operator|(
name|L4PER_CM2_OFFSET
operator|+
literal|0x0148
operator|)
argument_list|,
name|CLKCTRL_MODULEMODE_ENABLE
argument_list|)
block|,
comment|/* General purpose timers */
name|OMAP4_GENERIC_CLOCK_DETAILS
argument_list|(
name|GPTIMER1_CLK
argument_list|,
operator|-
literal|1
argument_list|,
name|PRM_INSTANCE_MEM_REGION
argument_list|,
operator|(
name|WKUP_CM_OFFSET
operator|+
literal|0x040
operator|)
argument_list|,
name|CLKCTRL_MODULEMODE_ENABLE
argument_list|)
block|,
name|OMAP4_GENERIC_CLOCK_DETAILS
argument_list|(
name|GPTIMER2_CLK
argument_list|,
operator|-
literal|1
argument_list|,
name|CM2_INSTANCE_MEM_REGION
argument_list|,
operator|(
name|L4PER_CM2_OFFSET
operator|+
literal|0x038
operator|)
argument_list|,
name|CLKCTRL_MODULEMODE_ENABLE
argument_list|)
block|,
name|OMAP4_GENERIC_CLOCK_DETAILS
argument_list|(
name|GPTIMER3_CLK
argument_list|,
operator|-
literal|1
argument_list|,
name|CM2_INSTANCE_MEM_REGION
argument_list|,
operator|(
name|L4PER_CM2_OFFSET
operator|+
literal|0x040
operator|)
argument_list|,
name|CLKCTRL_MODULEMODE_ENABLE
argument_list|)
block|,
name|OMAP4_GENERIC_CLOCK_DETAILS
argument_list|(
name|GPTIMER4_CLK
argument_list|,
operator|-
literal|1
argument_list|,
name|CM2_INSTANCE_MEM_REGION
argument_list|,
operator|(
name|L4PER_CM2_OFFSET
operator|+
literal|0x048
operator|)
argument_list|,
name|CLKCTRL_MODULEMODE_ENABLE
argument_list|)
block|,
name|OMAP4_GENERIC_CLOCK_DETAILS
argument_list|(
name|GPTIMER5_CLK
argument_list|,
operator|-
literal|1
argument_list|,
name|CM1_INSTANCE_MEM_REGION
argument_list|,
operator|(
name|ABE_CM1_OFFSET
operator|+
literal|0x068
operator|)
argument_list|,
name|CLKCTRL_MODULEMODE_ENABLE
argument_list|)
block|,
name|OMAP4_GENERIC_CLOCK_DETAILS
argument_list|(
name|GPTIMER6_CLK
argument_list|,
operator|-
literal|1
argument_list|,
name|CM1_INSTANCE_MEM_REGION
argument_list|,
operator|(
name|ABE_CM1_OFFSET
operator|+
literal|0x070
operator|)
argument_list|,
name|CLKCTRL_MODULEMODE_ENABLE
argument_list|)
block|,
name|OMAP4_GENERIC_CLOCK_DETAILS
argument_list|(
name|GPTIMER7_CLK
argument_list|,
operator|-
literal|1
argument_list|,
name|CM1_INSTANCE_MEM_REGION
argument_list|,
operator|(
name|ABE_CM1_OFFSET
operator|+
literal|0x078
operator|)
argument_list|,
name|CLKCTRL_MODULEMODE_ENABLE
argument_list|)
block|,
name|OMAP4_GENERIC_CLOCK_DETAILS
argument_list|(
name|GPTIMER8_CLK
argument_list|,
operator|-
literal|1
argument_list|,
name|CM1_INSTANCE_MEM_REGION
argument_list|,
operator|(
name|ABE_CM1_OFFSET
operator|+
literal|0x080
operator|)
argument_list|,
name|CLKCTRL_MODULEMODE_ENABLE
argument_list|)
block|,
name|OMAP4_GENERIC_CLOCK_DETAILS
argument_list|(
name|GPTIMER9_CLK
argument_list|,
operator|-
literal|1
argument_list|,
name|CM2_INSTANCE_MEM_REGION
argument_list|,
operator|(
name|L4PER_CM2_OFFSET
operator|+
literal|0x050
operator|)
argument_list|,
name|CLKCTRL_MODULEMODE_ENABLE
argument_list|)
block|,
name|OMAP4_GENERIC_CLOCK_DETAILS
argument_list|(
name|GPTIMER10_CLK
argument_list|,
operator|-
literal|1
argument_list|,
name|CM2_INSTANCE_MEM_REGION
argument_list|,
operator|(
name|L4PER_CM2_OFFSET
operator|+
literal|0x028
operator|)
argument_list|,
name|CLKCTRL_MODULEMODE_ENABLE
argument_list|)
block|,
name|OMAP4_GENERIC_CLOCK_DETAILS
argument_list|(
name|GPTIMER11_CLK
argument_list|,
operator|-
literal|1
argument_list|,
name|CM2_INSTANCE_MEM_REGION
argument_list|,
operator|(
name|L4PER_CM2_OFFSET
operator|+
literal|0x030
operator|)
argument_list|,
name|CLKCTRL_MODULEMODE_ENABLE
argument_list|)
block|,
comment|/* HSMMC (MMC1 and MMC2 can have different input clocks) */
name|OMAP4_GENERIC_CLOCK_DETAILS
argument_list|(
name|MMC1_CLK
argument_list|,
operator|-
literal|1
argument_list|,
name|CM2_INSTANCE_MEM_REGION
argument_list|,
operator|(
name|L3INIT_CM2_OFFSET
operator|+
literal|0x028
operator|)
argument_list|,
comment|/*CLKCTRL_MODULEMODE_ENABLE*/
literal|2
argument_list|)
block|,
name|OMAP4_GENERIC_CLOCK_DETAILS
argument_list|(
name|MMC2_CLK
argument_list|,
operator|-
literal|1
argument_list|,
name|CM2_INSTANCE_MEM_REGION
argument_list|,
operator|(
name|L3INIT_CM2_OFFSET
operator|+
literal|0x030
operator|)
argument_list|,
comment|/*CLKCTRL_MODULEMODE_ENABLE*/
literal|2
argument_list|)
block|,
name|OMAP4_GENERIC_CLOCK_DETAILS
argument_list|(
name|MMC3_CLK
argument_list|,
name|FREQ_48MHZ
argument_list|,
name|CM2_INSTANCE_MEM_REGION
argument_list|,
operator|(
name|L4PER_CM2_OFFSET
operator|+
literal|0x120
operator|)
argument_list|,
comment|/*CLKCTRL_MODULEMODE_ENABLE*/
literal|2
argument_list|)
block|,
name|OMAP4_GENERIC_CLOCK_DETAILS
argument_list|(
name|MMC4_CLK
argument_list|,
name|FREQ_48MHZ
argument_list|,
name|CM2_INSTANCE_MEM_REGION
argument_list|,
operator|(
name|L4PER_CM2_OFFSET
operator|+
literal|0x128
operator|)
argument_list|,
comment|/*CLKCTRL_MODULEMODE_ENABLE*/
literal|2
argument_list|)
block|,
name|OMAP4_GENERIC_CLOCK_DETAILS
argument_list|(
name|MMC5_CLK
argument_list|,
name|FREQ_48MHZ
argument_list|,
name|CM2_INSTANCE_MEM_REGION
argument_list|,
operator|(
name|L4PER_CM2_OFFSET
operator|+
literal|0x160
operator|)
argument_list|,
comment|/*CLKCTRL_MODULEMODE_ENABLE*/
literal|1
argument_list|)
block|,
comment|/* GPIO modules */
name|OMAP4_GENERIC_CLOCK_DETAILS
argument_list|(
name|GPIO1_CLK
argument_list|,
operator|-
literal|1
argument_list|,
name|PRM_INSTANCE_MEM_REGION
argument_list|,
operator|(
name|WKUP_CM_OFFSET
operator|+
literal|0x038
operator|)
argument_list|,
name|CLKCTRL_MODULEMODE_AUTO
argument_list|)
block|,
name|OMAP4_GENERIC_CLOCK_DETAILS
argument_list|(
name|GPIO2_CLK
argument_list|,
operator|-
literal|1
argument_list|,
name|CM2_INSTANCE_MEM_REGION
argument_list|,
operator|(
name|L4PER_CM2_OFFSET
operator|+
literal|0x060
operator|)
argument_list|,
name|CLKCTRL_MODULEMODE_AUTO
argument_list|)
block|,
name|OMAP4_GENERIC_CLOCK_DETAILS
argument_list|(
name|GPIO3_CLK
argument_list|,
operator|-
literal|1
argument_list|,
name|CM2_INSTANCE_MEM_REGION
argument_list|,
operator|(
name|L4PER_CM2_OFFSET
operator|+
literal|0x068
operator|)
argument_list|,
name|CLKCTRL_MODULEMODE_AUTO
argument_list|)
block|,
name|OMAP4_GENERIC_CLOCK_DETAILS
argument_list|(
name|GPIO4_CLK
argument_list|,
operator|-
literal|1
argument_list|,
name|CM2_INSTANCE_MEM_REGION
argument_list|,
operator|(
name|L4PER_CM2_OFFSET
operator|+
literal|0x070
operator|)
argument_list|,
name|CLKCTRL_MODULEMODE_AUTO
argument_list|)
block|,
name|OMAP4_GENERIC_CLOCK_DETAILS
argument_list|(
name|GPIO5_CLK
argument_list|,
operator|-
literal|1
argument_list|,
name|CM2_INSTANCE_MEM_REGION
argument_list|,
operator|(
name|L4PER_CM2_OFFSET
operator|+
literal|0x078
operator|)
argument_list|,
name|CLKCTRL_MODULEMODE_AUTO
argument_list|)
block|,
name|OMAP4_GENERIC_CLOCK_DETAILS
argument_list|(
name|GPIO6_CLK
argument_list|,
operator|-
literal|1
argument_list|,
name|CM2_INSTANCE_MEM_REGION
argument_list|,
operator|(
name|L4PER_CM2_OFFSET
operator|+
literal|0x080
operator|)
argument_list|,
name|CLKCTRL_MODULEMODE_AUTO
argument_list|)
block|,
comment|/* sDMA block */
name|OMAP4_GENERIC_CLOCK_DETAILS
argument_list|(
name|SDMA_CLK
argument_list|,
operator|-
literal|1
argument_list|,
name|CM2_INSTANCE_MEM_REGION
argument_list|,
operator|(
name|CORE_CM2_OFFSET
operator|+
literal|0x300
operator|)
argument_list|,
name|CLKCTRL_MODULEMODE_AUTO
argument_list|)
block|,
comment|/* I2C modules */
name|OMAP4_GENERIC_CLOCK_DETAILS
argument_list|(
name|I2C1_CLK
argument_list|,
operator|-
literal|1
argument_list|,
name|CM2_INSTANCE_MEM_REGION
argument_list|,
operator|(
name|L4PER_CM2_OFFSET
operator|+
literal|0x0A0
operator|)
argument_list|,
name|CLKCTRL_MODULEMODE_ENABLE
argument_list|)
block|,
name|OMAP4_GENERIC_CLOCK_DETAILS
argument_list|(
name|I2C2_CLK
argument_list|,
operator|-
literal|1
argument_list|,
name|CM2_INSTANCE_MEM_REGION
argument_list|,
operator|(
name|L4PER_CM2_OFFSET
operator|+
literal|0x0A8
operator|)
argument_list|,
name|CLKCTRL_MODULEMODE_ENABLE
argument_list|)
block|,
name|OMAP4_GENERIC_CLOCK_DETAILS
argument_list|(
name|I2C3_CLK
argument_list|,
operator|-
literal|1
argument_list|,
name|CM2_INSTANCE_MEM_REGION
argument_list|,
operator|(
name|L4PER_CM2_OFFSET
operator|+
literal|0x0B0
operator|)
argument_list|,
name|CLKCTRL_MODULEMODE_ENABLE
argument_list|)
block|,
name|OMAP4_GENERIC_CLOCK_DETAILS
argument_list|(
name|I2C4_CLK
argument_list|,
operator|-
literal|1
argument_list|,
name|CM2_INSTANCE_MEM_REGION
argument_list|,
operator|(
name|L4PER_CM2_OFFSET
operator|+
literal|0x0B8
operator|)
argument_list|,
name|CLKCTRL_MODULEMODE_ENABLE
argument_list|)
block|,
block|{
name|INVALID_CLK_IDENT
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**  *	MAX_MODULE_ENABLE_WAIT - the number of loops to wait for the module to come  *	alive.  *  */
end_comment

begin_define
define|#
directive|define
name|MAX_MODULE_ENABLE_WAIT
value|100
end_define

begin_comment
comment|/**  *	ARRAY_SIZE - Macro to return the number of elements in a static const array.  *  */
end_comment

begin_define
define|#
directive|define
name|ARRAY_SIZE
parameter_list|(
name|x
parameter_list|)
value|(sizeof(x)/sizeof(x[0]))
end_define

begin_comment
comment|/**  *	omap4_clk_details - writes a 32-bit value to one of the timer registers  *	@timer: Timer device context  *	@off: The offset of a register from the timer register address range  *	@val: The value to write into the register  *  *  *	RETURNS:  *	nothing  */
end_comment

begin_function
specifier|static
name|struct
name|omap4_clk_details
modifier|*
name|omap4_clk_details
parameter_list|(
name|clk_ident_t
name|id
parameter_list|)
block|{
name|struct
name|omap4_clk_details
modifier|*
name|walker
decl_stmt|;
for|for
control|(
name|walker
operator|=
name|g_omap4_clk_details
init|;
name|walker
operator|->
name|id
operator|!=
name|INVALID_CLK_IDENT
condition|;
name|walker
operator|++
control|)
block|{
if|if
condition|(
name|id
operator|==
name|walker
operator|->
name|id
condition|)
return|return
operator|(
name|walker
operator|)
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/**  *	omap4_clk_generic_activate - checks if a module is accessible  *	@module: identifier for the module to check, see omap3_prcm.h for a list  *	         of possible modules.  *	         Example: OMAP3_MODULE_MMC1  *	  *	  *  *	LOCKING:  *	Inherits the locks from the omap_prcm driver, no internal locking.  *  *	RETURNS:  *	Returns 0 on success or a positive error code on failure.  */
end_comment

begin_function
specifier|static
name|int
name|omap4_clk_generic_activate
parameter_list|(
name|struct
name|ti_clock_dev
modifier|*
name|clkdev
parameter_list|)
block|{
name|struct
name|omap4_prcm_softc
modifier|*
name|sc
init|=
name|omap4_prcm_sc
decl_stmt|;
name|struct
name|omap4_clk_details
modifier|*
name|clk_details
decl_stmt|;
name|struct
name|resource
modifier|*
name|clk_mem_res
decl_stmt|;
name|uint32_t
name|clksel
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
name|ENXIO
return|;
name|clk_details
operator|=
name|omap4_clk_details
argument_list|(
name|clkdev
operator|->
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|clk_details
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|clk_mem_res
operator|=
name|sc
operator|->
name|sc_res
index|[
name|clk_details
operator|->
name|mem_region
index|]
expr_stmt|;
if|if
condition|(
name|clk_mem_res
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* All the 'generic' clocks have a CLKCTRL register which is more or less 	 * generic - the have at least two fielda called MODULEMODE and IDLEST. 	 */
name|clksel
operator|=
name|bus_read_4
argument_list|(
name|clk_mem_res
argument_list|,
name|clk_details
operator|->
name|clksel_reg
argument_list|)
expr_stmt|;
name|clksel
operator|&=
operator|~
name|CLKCTRL_MODULEMODE_MASK
expr_stmt|;
name|clksel
operator||=
name|clk_details
operator|->
name|enable_mode
expr_stmt|;
name|bus_write_4
argument_list|(
name|clk_mem_res
argument_list|,
name|clk_details
operator|->
name|clksel_reg
argument_list|,
name|clksel
argument_list|)
expr_stmt|;
comment|/* Now poll on the IDLEST register to tell us if the module has come up. 	 * TODO: We need to take into account the parent clocks. 	 */
comment|/* Try MAX_MODULE_ENABLE_WAIT number of times to check if enabled */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_MODULE_ENABLE_WAIT
condition|;
name|i
operator|++
control|)
block|{
name|clksel
operator|=
name|bus_read_4
argument_list|(
name|clk_mem_res
argument_list|,
name|clk_details
operator|->
name|clksel_reg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|clksel
operator|&
name|CLKCTRL_IDLEST_MASK
operator|)
operator|==
name|CLKCTRL_IDLEST_ENABLED
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
comment|/* Check the enabled state */
if|if
condition|(
operator|(
name|clksel
operator|&
name|CLKCTRL_IDLEST_MASK
operator|)
operator|!=
name|CLKCTRL_IDLEST_ENABLED
condition|)
block|{
name|printf
argument_list|(
literal|"Error: failed to enable module with clock %d\n"
argument_list|,
name|clkdev
operator|->
name|id
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Error: 0x%08x => 0x%08x\n"
argument_list|,
name|clk_details
operator|->
name|clksel_reg
argument_list|,
name|clksel
argument_list|)
expr_stmt|;
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	omap4_clk_generic_deactivate - checks if a module is accessible  *	@module: identifier for the module to check, see omap3_prcm.h for a list  *	         of possible modules.  *	         Example: OMAP3_MODULE_MMC1  *	  *	  *  *	LOCKING:  *	Inherits the locks from the omap_prcm driver, no internal locking.  *  *	RETURNS:  *	Returns 0 on success or a positive error code on failure.  */
end_comment

begin_function
specifier|static
name|int
name|omap4_clk_generic_deactivate
parameter_list|(
name|struct
name|ti_clock_dev
modifier|*
name|clkdev
parameter_list|)
block|{
name|struct
name|omap4_prcm_softc
modifier|*
name|sc
init|=
name|omap4_prcm_sc
decl_stmt|;
name|struct
name|omap4_clk_details
modifier|*
name|clk_details
decl_stmt|;
name|struct
name|resource
modifier|*
name|clk_mem_res
decl_stmt|;
name|uint32_t
name|clksel
decl_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
name|ENXIO
return|;
name|clk_details
operator|=
name|omap4_clk_details
argument_list|(
name|clkdev
operator|->
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|clk_details
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|clk_mem_res
operator|=
name|sc
operator|->
name|sc_res
index|[
name|clk_details
operator|->
name|mem_region
index|]
expr_stmt|;
if|if
condition|(
name|clk_mem_res
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* All the 'generic' clocks have a CLKCTRL register which is more or less 	 * generic - the have at least two fielda called MODULEMODE and IDLEST. 	 */
name|clksel
operator|=
name|bus_read_4
argument_list|(
name|clk_mem_res
argument_list|,
name|clk_details
operator|->
name|clksel_reg
argument_list|)
expr_stmt|;
name|clksel
operator|&=
operator|~
name|CLKCTRL_MODULEMODE_MASK
expr_stmt|;
name|clksel
operator||=
name|CLKCTRL_MODULEMODE_DISABLE
expr_stmt|;
name|bus_write_4
argument_list|(
name|clk_mem_res
argument_list|,
name|clk_details
operator|->
name|clksel_reg
argument_list|,
name|clksel
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	omap4_clk_generic_set_source - checks if a module is accessible  *	@module: identifier for the module to check, see omap3_prcm.h for a list  *	         of possible modules.  *	         Example: OMAP3_MODULE_MMC1  *	  *	  *  *	LOCKING:  *	Inherits the locks from the omap_prcm driver, no internal locking.  *  *	RETURNS:  *	Returns 0 on success or a positive error code on failure.  */
end_comment

begin_function
specifier|static
name|int
name|omap4_clk_generic_set_source
parameter_list|(
name|struct
name|ti_clock_dev
modifier|*
name|clkdev
parameter_list|,
name|clk_src_t
name|clksrc
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	omap4_clk_generic_accessible - checks if a module is accessible  *	@module: identifier for the module to check, see omap3_prcm.h for a list  *	         of possible modules.  *	         Example: OMAP3_MODULE_MMC1  *	  *	  *  *	LOCKING:  *	Inherits the locks from the omap_prcm driver, no internal locking.  *  *	RETURNS:  *	Returns 0 on success or a negative error code on failure.  */
end_comment

begin_function
specifier|static
name|int
name|omap4_clk_generic_accessible
parameter_list|(
name|struct
name|ti_clock_dev
modifier|*
name|clkdev
parameter_list|)
block|{
name|struct
name|omap4_prcm_softc
modifier|*
name|sc
init|=
name|omap4_prcm_sc
decl_stmt|;
name|struct
name|omap4_clk_details
modifier|*
name|clk_details
decl_stmt|;
name|struct
name|resource
modifier|*
name|clk_mem_res
decl_stmt|;
name|uint32_t
name|clksel
decl_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
name|ENXIO
return|;
name|clk_details
operator|=
name|omap4_clk_details
argument_list|(
name|clkdev
operator|->
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|clk_details
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|clk_mem_res
operator|=
name|sc
operator|->
name|sc_res
index|[
name|clk_details
operator|->
name|mem_region
index|]
expr_stmt|;
if|if
condition|(
name|clk_mem_res
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|clksel
operator|=
name|bus_read_4
argument_list|(
name|clk_mem_res
argument_list|,
name|clk_details
operator|->
name|clksel_reg
argument_list|)
expr_stmt|;
comment|/* Check the enabled state */
if|if
condition|(
operator|(
name|clksel
operator|&
name|CLKCTRL_IDLEST_MASK
operator|)
operator|!=
name|CLKCTRL_IDLEST_ENABLED
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	omap4_clk_generic_get_source_freq - checks if a module is accessible  *	@module: identifier for the module to check, see omap3_prcm.h for a list  *	         of possible modules.  *	         Example: OMAP3_MODULE_MMC1  *	  *	  *  *	LOCKING:  *	Inherits the locks from the omap_prcm driver, no internal locking.  *  *	RETURNS:  *	Returns 0 on success or a negative error code on failure.  */
end_comment

begin_function
specifier|static
name|int
name|omap4_clk_generic_get_source_freq
parameter_list|(
name|struct
name|ti_clock_dev
modifier|*
name|clkdev
parameter_list|,
name|unsigned
name|int
modifier|*
name|freq
parameter_list|)
block|{
name|struct
name|omap4_clk_details
modifier|*
name|clk_details
init|=
name|omap4_clk_details
argument_list|(
name|clkdev
operator|->
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|clk_details
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* Simply return the stored frequency */
if|if
condition|(
name|freq
condition|)
operator|*
name|freq
operator|=
operator|(
name|unsigned
name|int
operator|)
name|clk_details
operator|->
name|src_freq
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	omap4_clk_gptimer_set_source - checks if a module is accessible  *	@module: identifier for the module to check, see omap3_prcm.h for a list  *	         of possible modules.  *	         Example: OMAP3_MODULE_MMC1  *	  *	  *  *	LOCKING:  *	Inherits the locks from the omap_prcm driver, no internal locking.  *  *	RETURNS:  *	Returns 0 on success or a negative error code on failure.  */
end_comment

begin_function
specifier|static
name|int
name|omap4_clk_gptimer_set_source
parameter_list|(
name|struct
name|ti_clock_dev
modifier|*
name|clkdev
parameter_list|,
name|clk_src_t
name|clksrc
parameter_list|)
block|{
name|struct
name|omap4_prcm_softc
modifier|*
name|sc
init|=
name|omap4_prcm_sc
decl_stmt|;
name|struct
name|omap4_clk_details
modifier|*
name|clk_details
decl_stmt|;
name|struct
name|resource
modifier|*
name|clk_mem_res
decl_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
name|ENXIO
return|;
name|clk_details
operator|=
name|omap4_clk_details
argument_list|(
name|clkdev
operator|->
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|clk_details
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|clk_mem_res
operator|=
name|sc
operator|->
name|sc_res
index|[
name|clk_details
operator|->
name|mem_region
index|]
expr_stmt|;
if|if
condition|(
name|clk_mem_res
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* TODO: Implement */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	omap4_clk_gptimer_get_source_freq - checks if a module is accessible  *	@module: identifier for the module to check, see omap3_prcm.h for a list  *	         of possible modules.  *	         Example: OMAP3_MODULE_MMC1  *	  *	  *  *	LOCKING:  *	Inherits the locks from the omap_prcm driver, no internal locking.  *  *	RETURNS:  *	Returns 0 on success or a negative error code on failure.  */
end_comment

begin_function
specifier|static
name|int
name|omap4_clk_gptimer_get_source_freq
parameter_list|(
name|struct
name|ti_clock_dev
modifier|*
name|clkdev
parameter_list|,
name|unsigned
name|int
modifier|*
name|freq
parameter_list|)
block|{
name|struct
name|omap4_prcm_softc
modifier|*
name|sc
init|=
name|omap4_prcm_sc
decl_stmt|;
name|struct
name|omap4_clk_details
modifier|*
name|clk_details
decl_stmt|;
name|struct
name|resource
modifier|*
name|clk_mem_res
decl_stmt|;
name|uint32_t
name|clksel
decl_stmt|;
name|unsigned
name|int
name|src_freq
decl_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
name|ENXIO
return|;
name|clk_details
operator|=
name|omap4_clk_details
argument_list|(
name|clkdev
operator|->
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|clk_details
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|clk_mem_res
operator|=
name|sc
operator|->
name|sc_res
index|[
name|clk_details
operator|->
name|mem_region
index|]
expr_stmt|;
if|if
condition|(
name|clk_mem_res
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Need to read the CLKSEL field to determine the clock source */
name|clksel
operator|=
name|bus_read_4
argument_list|(
name|clk_mem_res
argument_list|,
name|clk_details
operator|->
name|clksel_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|clksel
operator|&
operator|(
literal|0x1UL
operator|<<
literal|24
operator|)
condition|)
name|src_freq
operator|=
name|FREQ_32KHZ
expr_stmt|;
else|else
name|omap4_clk_get_sysclk_freq
argument_list|(
name|NULL
argument_list|,
operator|&
name|src_freq
argument_list|)
expr_stmt|;
comment|/* Return the frequency */
if|if
condition|(
name|freq
condition|)
operator|*
name|freq
operator|=
name|src_freq
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	omap4_clk_hsmmc_set_source - sets the source clock (freq)  *	@clkdev: pointer to the clockdev structure (id field will contain clock id)  *	  *	The MMC 1 and 2 clocks can be source from either a 64MHz or 96MHz clock.  *  *	LOCKING:  *	Inherits the locks from the omap_prcm driver, no internal locking.  *  *	RETURNS:  *	Returns 0 on success or a negative error code on failure.  */
end_comment

begin_function
specifier|static
name|int
name|omap4_clk_hsmmc_set_source
parameter_list|(
name|struct
name|ti_clock_dev
modifier|*
name|clkdev
parameter_list|,
name|clk_src_t
name|clksrc
parameter_list|)
block|{
name|struct
name|omap4_prcm_softc
modifier|*
name|sc
init|=
name|omap4_prcm_sc
decl_stmt|;
name|struct
name|omap4_clk_details
modifier|*
name|clk_details
decl_stmt|;
name|struct
name|resource
modifier|*
name|clk_mem_res
decl_stmt|;
name|uint32_t
name|clksel
decl_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
name|ENXIO
return|;
name|clk_details
operator|=
name|omap4_clk_details
argument_list|(
name|clkdev
operator|->
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|clk_details
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|clk_mem_res
operator|=
name|sc
operator|->
name|sc_res
index|[
name|clk_details
operator|->
name|mem_region
index|]
expr_stmt|;
if|if
condition|(
name|clk_mem_res
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* For MMC modules 3, 4& 5 you can't change the freq, it's always 48MHz */
if|if
condition|(
operator|(
name|clkdev
operator|->
name|id
operator|==
name|MMC3_CLK
operator|)
operator|||
operator|(
name|clkdev
operator|->
name|id
operator|==
name|MMC4_CLK
operator|)
operator|||
operator|(
name|clkdev
operator|->
name|id
operator|==
name|MMC5_CLK
operator|)
condition|)
block|{
if|if
condition|(
name|clksrc
operator|!=
name|F48MHZ_CLK
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
return|return
literal|0
return|;
block|}
name|clksel
operator|=
name|bus_read_4
argument_list|(
name|clk_mem_res
argument_list|,
name|clk_details
operator|->
name|clksel_reg
argument_list|)
expr_stmt|;
comment|/* Bit 24 is set if 96MHz clock or cleared for 64MHz clock */
if|if
condition|(
name|clksrc
operator|==
name|F64MHZ_CLK
condition|)
name|clksel
operator|&=
operator|~
operator|(
literal|0x1UL
operator|<<
literal|24
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|clksrc
operator|==
name|F96MHZ_CLK
condition|)
name|clksel
operator||=
operator|(
literal|0x1UL
operator|<<
literal|24
operator|)
expr_stmt|;
else|else
return|return
operator|(
name|EINVAL
operator|)
return|;
name|bus_write_4
argument_list|(
name|clk_mem_res
argument_list|,
name|clk_details
operator|->
name|clksel_reg
argument_list|,
name|clksel
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	omap4_clk_hsmmc_get_source_freq - checks if a module is accessible  *	@clkdev: pointer to the clockdev structure (id field will contain clock id)  *	  *	  *  *	LOCKING:  *	Inherits the locks from the omap_prcm driver, no internal locking.  *  *	RETURNS:  *	Returns 0 on success or a negative error code on failure.  */
end_comment

begin_function
specifier|static
name|int
name|omap4_clk_hsmmc_get_source_freq
parameter_list|(
name|struct
name|ti_clock_dev
modifier|*
name|clkdev
parameter_list|,
name|unsigned
name|int
modifier|*
name|freq
parameter_list|)
block|{
name|struct
name|omap4_prcm_softc
modifier|*
name|sc
init|=
name|omap4_prcm_sc
decl_stmt|;
name|struct
name|omap4_clk_details
modifier|*
name|clk_details
decl_stmt|;
name|struct
name|resource
modifier|*
name|clk_mem_res
decl_stmt|;
name|uint32_t
name|clksel
decl_stmt|;
name|unsigned
name|int
name|src_freq
decl_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
name|ENXIO
return|;
name|clk_details
operator|=
name|omap4_clk_details
argument_list|(
name|clkdev
operator|->
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|clk_details
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|clk_mem_res
operator|=
name|sc
operator|->
name|sc_res
index|[
name|clk_details
operator|->
name|mem_region
index|]
expr_stmt|;
if|if
condition|(
name|clk_mem_res
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
switch|switch
condition|(
name|clkdev
operator|->
name|id
condition|)
block|{
case|case
name|MMC1_CLK
case|:
case|case
name|MMC2_CLK
case|:
comment|/* Need to read the CLKSEL field to determine the clock source */
name|clksel
operator|=
name|bus_read_4
argument_list|(
name|clk_mem_res
argument_list|,
name|clk_details
operator|->
name|clksel_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|clksel
operator|&
operator|(
literal|0x1UL
operator|<<
literal|24
operator|)
condition|)
name|src_freq
operator|=
name|FREQ_96MHZ
expr_stmt|;
else|else
name|src_freq
operator|=
name|FREQ_64MHZ
expr_stmt|;
break|break;
case|case
name|MMC3_CLK
case|:
case|case
name|MMC4_CLK
case|:
case|case
name|MMC5_CLK
case|:
name|src_freq
operator|=
name|FREQ_48MHZ
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Return the frequency */
if|if
condition|(
name|freq
condition|)
operator|*
name|freq
operator|=
name|src_freq
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	omap4_clk_get_sysclk_freq - gets the sysclk frequency  *	@sc: pointer to the clk module/device context  *  *	Read the clocking information from the power-control/boot-strap registers,  *  and stored in two global variables.  *  *	RETURNS:  *	nothing, values are saved in global variables  */
end_comment

begin_function
specifier|static
name|int
name|omap4_clk_get_sysclk_freq
parameter_list|(
name|struct
name|ti_clock_dev
modifier|*
name|clkdev
parameter_list|,
name|unsigned
name|int
modifier|*
name|freq
parameter_list|)
block|{
name|uint32_t
name|clksel
decl_stmt|;
name|uint32_t
name|sysclk
decl_stmt|;
name|struct
name|omap4_prcm_softc
modifier|*
name|sc
init|=
name|omap4_prcm_sc
decl_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
name|ENXIO
return|;
comment|/* Read the input clock freq from the configuration register (CM_SYS_CLKSEL) */
name|clksel
operator|=
name|bus_read_4
argument_list|(
name|sc
operator|->
name|sc_res
index|[
name|PRM_INSTANCE_MEM_REGION
index|]
argument_list|,
name|CM_SYS_CLKSEL_OFFSET
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|clksel
operator|&
literal|0x7
condition|)
block|{
case|case
literal|0x1
case|:
comment|/* 12Mhz */
name|sysclk
operator|=
literal|12000000
expr_stmt|;
break|break;
case|case
literal|0x3
case|:
comment|/* 16.8Mhz */
name|sysclk
operator|=
literal|16800000
expr_stmt|;
break|break;
case|case
literal|0x4
case|:
comment|/* 19.2Mhz */
name|sysclk
operator|=
literal|19200000
expr_stmt|;
break|break;
case|case
literal|0x5
case|:
comment|/* 26Mhz */
name|sysclk
operator|=
literal|26000000
expr_stmt|;
break|break;
case|case
literal|0x7
case|:
comment|/* 38.4Mhz */
name|sysclk
operator|=
literal|38400000
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"%s: Invalid clock freq"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
comment|/* Return the value */
if|if
condition|(
name|freq
condition|)
operator|*
name|freq
operator|=
name|sysclk
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	omap4_clk_get_arm_fclk_freq - gets the MPU clock frequency  *	@clkdev: ignored  *	@freq: pointer which upon return will contain the freq in hz  *	@mem_res: array of allocated memory resources  *  *	Reads the frequency setting information registers and returns the value  *	in the freq variable.  *  *	RETURNS:  *	returns 0 on success, a positive error code on failure.  */
end_comment

begin_function
specifier|static
name|int
name|omap4_clk_get_arm_fclk_freq
parameter_list|(
name|struct
name|ti_clock_dev
modifier|*
name|clkdev
parameter_list|,
name|unsigned
name|int
modifier|*
name|freq
parameter_list|)
block|{
name|uint32_t
name|clksel
decl_stmt|;
name|uint32_t
name|pll_mult
decl_stmt|,
name|pll_div
decl_stmt|;
name|uint32_t
name|mpuclk
decl_stmt|,
name|sysclk
decl_stmt|;
name|struct
name|omap4_prcm_softc
modifier|*
name|sc
init|=
name|omap4_prcm_sc
decl_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
name|ENXIO
return|;
comment|/* Read the clksel register which contains the DPLL multiple and divide 	 * values.  These are applied to the sysclk. 	 */
name|clksel
operator|=
name|bus_read_4
argument_list|(
name|sc
operator|->
name|sc_res
index|[
name|CM1_INSTANCE_MEM_REGION
index|]
argument_list|,
name|CM_CLKSEL_DPLL_MPU
argument_list|)
expr_stmt|;
name|pll_mult
operator|=
operator|(
operator|(
name|clksel
operator|>>
literal|8
operator|)
operator|&
literal|0x7ff
operator|)
expr_stmt|;
name|pll_div
operator|=
operator|(
name|clksel
operator|&
literal|0x7f
operator|)
operator|+
literal|1
expr_stmt|;
comment|/* Get the system clock freq */
name|omap4_clk_get_sysclk_freq
argument_list|(
name|NULL
argument_list|,
operator|&
name|sysclk
argument_list|)
expr_stmt|;
comment|/* Calculate the MPU freq */
name|mpuclk
operator|=
operator|(
operator|(
name|uint64_t
operator|)
name|sysclk
operator|*
name|pll_mult
operator|)
operator|/
name|pll_div
expr_stmt|;
comment|/* Return the value */
if|if
condition|(
name|freq
condition|)
operator|*
name|freq
operator|=
name|mpuclk
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	omap4_clk_hsusbhost_activate - activates the USB clocks for the given module  *	@clkdev: pointer to the clock device structure.  *	@mem_res: array of memory resources allocated by the top level PRCM driver.  *	  *	The USB clocking setup seems to be a bit more tricky than the other modules,  *	to start with the clocking diagram for the HS host module shows 13 different  *	clocks.  So to try and make it easier to follow the clocking activation  *	and deactivation is handled in it's own set of callbacks.  *  *	LOCKING:  *	Inherits the locks from the omap_prcm driver, no internal locking.  *  *	RETURNS:  *	Returns 0 on success or a positive error code on failure.  */
end_comment

begin_struct
struct|struct
name|dpll_param
block|{
name|unsigned
name|int
name|m
decl_stmt|;
name|unsigned
name|int
name|n
decl_stmt|;
name|unsigned
name|int
name|m2
decl_stmt|;
name|unsigned
name|int
name|m3
decl_stmt|;
name|unsigned
name|int
name|m4
decl_stmt|;
name|unsigned
name|int
name|m5
decl_stmt|;
name|unsigned
name|int
name|m6
decl_stmt|;
name|unsigned
name|int
name|m7
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* USB parameters */
end_comment

begin_decl_stmt
name|struct
name|dpll_param
name|usb_dpll_param
index|[
literal|7
index|]
init|=
block|{
comment|/* 12M values */
block|{
literal|0x0
block|,
literal|0x0
block|,
literal|0x0
block|,
literal|0x0
block|,
literal|0x0
block|,
literal|0x0
block|,
literal|0x0
block|,
literal|0x0
block|}
block|,
comment|/* 13M values */
block|{
literal|0x0
block|,
literal|0x0
block|,
literal|0x0
block|,
literal|0x0
block|,
literal|0x0
block|,
literal|0x0
block|,
literal|0x0
block|,
literal|0x0
block|}
block|,
comment|/* 16.8M values */
block|{
literal|0x0
block|,
literal|0x0
block|,
literal|0x0
block|,
literal|0x0
block|,
literal|0x0
block|,
literal|0x0
block|,
literal|0x0
block|,
literal|0x0
block|}
block|,
comment|/* 19.2M values */
block|{
literal|0x0
block|,
literal|0x0
block|,
literal|0x0
block|,
literal|0x0
block|,
literal|0x0
block|,
literal|0x0
block|,
literal|0x0
block|,
literal|0x0
block|}
block|,
comment|/* 26M values */
block|{
literal|0x0
block|,
literal|0x0
block|,
literal|0x0
block|,
literal|0x0
block|,
literal|0x0
block|,
literal|0x0
block|,
literal|0x0
block|,
literal|0x0
block|}
block|,
comment|/* 27M values */
block|{
literal|0x0
block|,
literal|0x0
block|,
literal|0x0
block|,
literal|0x0
block|,
literal|0x0
block|,
literal|0x0
block|,
literal|0x0
block|,
literal|0x0
block|}
block|,
comment|/* 38.4M values */
ifdef|#
directive|ifdef
name|CONFIG_OMAP4_SDC
block|{
literal|0x32
block|,
literal|0x1
block|,
literal|0x2
block|,
literal|0x0
block|,
literal|0x0
block|,
literal|0x0
block|,
literal|0x0
block|,
literal|0x0
block|}
block|,
else|#
directive|else
block|{
literal|0x32
block|,
literal|0x1
block|,
literal|0x2
block|,
literal|0x0
block|,
literal|0x0
block|,
literal|0x0
block|,
literal|0x0
block|,
literal|0x0
block|}
block|,
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|omap4_clk_hsusbhost_activate
parameter_list|(
name|struct
name|ti_clock_dev
modifier|*
name|clkdev
parameter_list|)
block|{
name|struct
name|omap4_prcm_softc
modifier|*
name|sc
init|=
name|omap4_prcm_sc
decl_stmt|;
name|struct
name|resource
modifier|*
name|clk_mem_res
decl_stmt|;
name|uint32_t
name|clksel_reg_off
decl_stmt|;
name|uint32_t
name|clksel
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
name|ENXIO
return|;
switch|switch
condition|(
name|clkdev
operator|->
name|id
condition|)
block|{
case|case
name|USBTLL_CLK
case|:
comment|/* For the USBTLL module we need to enable the following clocks: 		 *  - INIT_L4_ICLK  (will be enabled by bootloader) 		 *  - TLL_CH0_FCLK 		 *  - TLL_CH1_FCLK 		 */
comment|/* We need the CM_L3INIT_HSUSBTLL_CLKCTRL register in CM2 register set */
name|clk_mem_res
operator|=
name|sc
operator|->
name|sc_res
index|[
name|CM2_INSTANCE_MEM_REGION
index|]
expr_stmt|;
name|clksel_reg_off
operator|=
name|L3INIT_CM2_OFFSET
operator|+
literal|0x68
expr_stmt|;
comment|/* Enable the module and also enable the optional func clocks for 		 * channels 0& 1 (is this needed ?) 		 */
name|clksel
operator|=
name|bus_read_4
argument_list|(
name|clk_mem_res
argument_list|,
name|clksel_reg_off
argument_list|)
expr_stmt|;
name|clksel
operator|&=
operator|~
name|CLKCTRL_MODULEMODE_MASK
expr_stmt|;
name|clksel
operator||=
name|CLKCTRL_MODULEMODE_ENABLE
expr_stmt|;
name|clksel
operator||=
operator|(
literal|0x1
operator|<<
literal|8
operator|)
expr_stmt|;
comment|/* USB-HOST optional clock: USB_CH0_CLK */
name|clksel
operator||=
operator|(
literal|0x1
operator|<<
literal|9
operator|)
expr_stmt|;
comment|/* USB-HOST optional clock: USB_CH1_CLK */
break|break;
case|case
name|USBHSHOST_CLK
case|:
case|case
name|USBP1_PHY_CLK
case|:
case|case
name|USBP2_PHY_CLK
case|:
case|case
name|USBP1_UTMI_CLK
case|:
case|case
name|USBP2_UTMI_CLK
case|:
case|case
name|USBP1_HSIC_CLK
case|:
case|case
name|USBP2_HSIC_CLK
case|:
comment|/* For the USB HS HOST module we need to enable the following clocks: 		 *  - INIT_L4_ICLK     (will be enabled by bootloader) 		 *  - INIT_L3_ICLK     (will be enabled by bootloader) 		 *  - INIT_48MC_FCLK 		 *  - UTMI_ROOT_GFCLK  (UTMI only, create a new clock for that ?) 		 *  - UTMI_P1_FCLK     (UTMI only, create a new clock for that ?) 		 *  - UTMI_P2_FCLK     (UTMI only, create a new clock for that ?) 		 *  - HSIC_P1_60       (HSIC only, create a new clock for that ?) 		 *  - HSIC_P1_480      (HSIC only, create a new clock for that ?) 		 *  - HSIC_P2_60       (HSIC only, create a new clock for that ?) 		 *  - HSIC_P2_480      (HSIC only, create a new clock for that ?) 		 */
comment|/* We need the CM_L3INIT_HSUSBHOST_CLKCTRL register in CM2 register set */
name|clk_mem_res
operator|=
name|sc
operator|->
name|sc_res
index|[
name|CM2_INSTANCE_MEM_REGION
index|]
expr_stmt|;
name|clksel_reg_off
operator|=
name|L3INIT_CM2_OFFSET
operator|+
literal|0x58
expr_stmt|;
name|clksel
operator|=
name|bus_read_4
argument_list|(
name|clk_mem_res
argument_list|,
name|clksel_reg_off
argument_list|)
expr_stmt|;
comment|/* Enable the module and also enable the optional func clocks */
if|if
condition|(
name|clkdev
operator|->
name|id
operator|==
name|USBHSHOST_CLK
condition|)
block|{
name|clksel
operator|&=
operator|~
name|CLKCTRL_MODULEMODE_MASK
expr_stmt|;
name|clksel
operator||=
comment|/*CLKCTRL_MODULEMODE_ENABLE*/
literal|2
expr_stmt|;
name|clksel
operator||=
operator|(
literal|0x1
operator|<<
literal|15
operator|)
expr_stmt|;
comment|/* USB-HOST clock control: FUNC48MCLK */
block|}
elseif|else
if|if
condition|(
name|clkdev
operator|->
name|id
operator|==
name|USBP1_UTMI_CLK
condition|)
name|clksel
operator||=
operator|(
literal|0x1
operator|<<
literal|8
operator|)
expr_stmt|;
comment|/* UTMI_P1_CLK */
elseif|else
if|if
condition|(
name|clkdev
operator|->
name|id
operator|==
name|USBP2_UTMI_CLK
condition|)
name|clksel
operator||=
operator|(
literal|0x1
operator|<<
literal|9
operator|)
expr_stmt|;
comment|/* UTMI_P2_CLK */
elseif|else
if|if
condition|(
name|clkdev
operator|->
name|id
operator|==
name|USBP1_HSIC_CLK
condition|)
name|clksel
operator||=
operator|(
literal|0x5
operator|<<
literal|11
operator|)
expr_stmt|;
comment|/* HSIC60M_P1_CLK + HSIC480M_P1_CLK */
elseif|else
if|if
condition|(
name|clkdev
operator|->
name|id
operator|==
name|USBP2_HSIC_CLK
condition|)
name|clksel
operator||=
operator|(
literal|0x5
operator|<<
literal|12
operator|)
expr_stmt|;
comment|/* HSIC60M_P2_CLK + HSIC480M_P2_CLK */
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|bus_write_4
argument_list|(
name|clk_mem_res
argument_list|,
name|clksel_reg_off
argument_list|,
name|clksel
argument_list|)
expr_stmt|;
comment|/* Try MAX_MODULE_ENABLE_WAIT number of times to check if enabled */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_MODULE_ENABLE_WAIT
condition|;
name|i
operator|++
control|)
block|{
name|clksel
operator|=
name|bus_read_4
argument_list|(
name|clk_mem_res
argument_list|,
name|clksel_reg_off
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|clksel
operator|&
name|CLKCTRL_IDLEST_MASK
operator|)
operator|==
name|CLKCTRL_IDLEST_ENABLED
condition|)
break|break;
block|}
comment|/* Check the enabled state */
if|if
condition|(
operator|(
name|clksel
operator|&
name|CLKCTRL_IDLEST_MASK
operator|)
operator|!=
name|CLKCTRL_IDLEST_ENABLED
condition|)
block|{
name|printf
argument_list|(
literal|"Error: HERE failed to enable module with clock %d\n"
argument_list|,
name|clkdev
operator|->
name|id
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Error: 0x%08x => 0x%08x\n"
argument_list|,
name|clksel_reg_off
argument_list|,
name|clksel
argument_list|)
expr_stmt|;
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	omap4_clk_generic_deactivate - checks if a module is accessible  *	@clkdev: pointer to the clock device structure.  *	@mem_res: array of memory resources allocated by the top level PRCM driver.  *	  *	  *  *	LOCKING:  *	Inherits the locks from the omap_prcm driver, no internal locking.  *  *	RETURNS:  *	Returns 0 on success or a positive error code on failure.  */
end_comment

begin_function
specifier|static
name|int
name|omap4_clk_hsusbhost_deactivate
parameter_list|(
name|struct
name|ti_clock_dev
modifier|*
name|clkdev
parameter_list|)
block|{
name|struct
name|omap4_prcm_softc
modifier|*
name|sc
init|=
name|omap4_prcm_sc
decl_stmt|;
name|struct
name|resource
modifier|*
name|clk_mem_res
decl_stmt|;
name|uint32_t
name|clksel_reg_off
decl_stmt|;
name|uint32_t
name|clksel
decl_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
name|ENXIO
return|;
switch|switch
condition|(
name|clkdev
operator|->
name|id
condition|)
block|{
case|case
name|USBTLL_CLK
case|:
comment|/* We need the CM_L3INIT_HSUSBTLL_CLKCTRL register in CM2 register set */
name|clk_mem_res
operator|=
name|sc
operator|->
name|sc_res
index|[
name|CM2_INSTANCE_MEM_REGION
index|]
expr_stmt|;
name|clksel_reg_off
operator|=
name|L3INIT_CM2_OFFSET
operator|+
literal|0x68
expr_stmt|;
name|clksel
operator|=
name|bus_read_4
argument_list|(
name|clk_mem_res
argument_list|,
name|clksel_reg_off
argument_list|)
expr_stmt|;
name|clksel
operator|&=
operator|~
name|CLKCTRL_MODULEMODE_MASK
expr_stmt|;
name|clksel
operator||=
name|CLKCTRL_MODULEMODE_DISABLE
expr_stmt|;
break|break;
case|case
name|USBHSHOST_CLK
case|:
case|case
name|USBP1_PHY_CLK
case|:
case|case
name|USBP2_PHY_CLK
case|:
case|case
name|USBP1_UTMI_CLK
case|:
case|case
name|USBP2_UTMI_CLK
case|:
case|case
name|USBP1_HSIC_CLK
case|:
case|case
name|USBP2_HSIC_CLK
case|:
comment|/* For the USB HS HOST module we need to enable the following clocks: 		 *  - INIT_L4_ICLK     (will be enabled by bootloader) 		 *  - INIT_L3_ICLK     (will be enabled by bootloader) 		 *  - INIT_48MC_FCLK 		 *  - UTMI_ROOT_GFCLK  (UTMI only, create a new clock for that ?) 		 *  - UTMI_P1_FCLK     (UTMI only, create a new clock for that ?) 		 *  - UTMI_P2_FCLK     (UTMI only, create a new clock for that ?) 		 *  - HSIC_P1_60       (HSIC only, create a new clock for that ?) 		 *  - HSIC_P1_480      (HSIC only, create a new clock for that ?) 		 *  - HSIC_P2_60       (HSIC only, create a new clock for that ?) 		 *  - HSIC_P2_480      (HSIC only, create a new clock for that ?) 		 */
comment|/* We need the CM_L3INIT_HSUSBHOST_CLKCTRL register in CM2 register set */
name|clk_mem_res
operator|=
name|sc
operator|->
name|sc_res
index|[
name|CM2_INSTANCE_MEM_REGION
index|]
expr_stmt|;
name|clksel_reg_off
operator|=
name|L3INIT_CM2_OFFSET
operator|+
literal|0x58
expr_stmt|;
name|clksel
operator|=
name|bus_read_4
argument_list|(
name|clk_mem_res
argument_list|,
name|clksel_reg_off
argument_list|)
expr_stmt|;
comment|/* Enable the module and also enable the optional func clocks */
if|if
condition|(
name|clkdev
operator|->
name|id
operator|==
name|USBHSHOST_CLK
condition|)
block|{
name|clksel
operator|&=
operator|~
name|CLKCTRL_MODULEMODE_MASK
expr_stmt|;
name|clksel
operator||=
name|CLKCTRL_MODULEMODE_DISABLE
expr_stmt|;
name|clksel
operator|&=
operator|~
operator|(
literal|0x1
operator|<<
literal|15
operator|)
expr_stmt|;
comment|/* USB-HOST clock control: FUNC48MCLK */
block|}
elseif|else
if|if
condition|(
name|clkdev
operator|->
name|id
operator|==
name|USBP1_UTMI_CLK
condition|)
name|clksel
operator|&=
operator|~
operator|(
literal|0x1
operator|<<
literal|8
operator|)
expr_stmt|;
comment|/* UTMI_P1_CLK */
elseif|else
if|if
condition|(
name|clkdev
operator|->
name|id
operator|==
name|USBP2_UTMI_CLK
condition|)
name|clksel
operator|&=
operator|~
operator|(
literal|0x1
operator|<<
literal|9
operator|)
expr_stmt|;
comment|/* UTMI_P2_CLK */
elseif|else
if|if
condition|(
name|clkdev
operator|->
name|id
operator|==
name|USBP1_HSIC_CLK
condition|)
name|clksel
operator|&=
operator|~
operator|(
literal|0x5
operator|<<
literal|11
operator|)
expr_stmt|;
comment|/* HSIC60M_P1_CLK + HSIC480M_P1_CLK */
elseif|else
if|if
condition|(
name|clkdev
operator|->
name|id
operator|==
name|USBP2_HSIC_CLK
condition|)
name|clksel
operator|&=
operator|~
operator|(
literal|0x5
operator|<<
literal|12
operator|)
expr_stmt|;
comment|/* HSIC60M_P2_CLK + HSIC480M_P2_CLK */
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|bus_write_4
argument_list|(
name|clk_mem_res
argument_list|,
name|clksel_reg_off
argument_list|,
name|clksel
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	omap4_clk_hsusbhost_accessible - checks if a module is accessible  *	@clkdev: pointer to the clock device structure.  *	@mem_res: array of memory resources allocated by the top level PRCM driver.  *	  *	  *  *	LOCKING:  *	Inherits the locks from the omap_prcm driver, no internal locking.  *  *	RETURNS:  *	Returns 0 if module is not enable, 1 if module is enabled or a negative  *	error code on failure.  */
end_comment

begin_function
specifier|static
name|int
name|omap4_clk_hsusbhost_accessible
parameter_list|(
name|struct
name|ti_clock_dev
modifier|*
name|clkdev
parameter_list|)
block|{
name|struct
name|omap4_prcm_softc
modifier|*
name|sc
init|=
name|omap4_prcm_sc
decl_stmt|;
name|struct
name|resource
modifier|*
name|clk_mem_res
decl_stmt|;
name|uint32_t
name|clksel_reg_off
decl_stmt|;
name|uint32_t
name|clksel
decl_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
name|ENXIO
return|;
if|if
condition|(
name|clkdev
operator|->
name|id
operator|==
name|USBTLL_CLK
condition|)
block|{
comment|/* We need the CM_L3INIT_HSUSBTLL_CLKCTRL register in CM2 register set */
name|clk_mem_res
operator|=
name|sc
operator|->
name|sc_res
index|[
name|CM2_INSTANCE_MEM_REGION
index|]
expr_stmt|;
name|clksel_reg_off
operator|=
name|L3INIT_CM2_OFFSET
operator|+
literal|0x68
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|clkdev
operator|->
name|id
operator|==
name|USBHSHOST_CLK
condition|)
block|{
comment|/* We need the CM_L3INIT_HSUSBHOST_CLKCTRL register in CM2 register set */
name|clk_mem_res
operator|=
name|sc
operator|->
name|sc_res
index|[
name|CM2_INSTANCE_MEM_REGION
index|]
expr_stmt|;
name|clksel_reg_off
operator|=
name|L3INIT_CM2_OFFSET
operator|+
literal|0x58
expr_stmt|;
block|}
else|else
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|clksel
operator|=
name|bus_read_4
argument_list|(
name|clk_mem_res
argument_list|,
name|clksel_reg_off
argument_list|)
expr_stmt|;
comment|/* Check the enabled state */
if|if
condition|(
operator|(
name|clksel
operator|&
name|CLKCTRL_IDLEST_MASK
operator|)
operator|!=
name|CLKCTRL_IDLEST_ENABLED
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	omap4_clk_hsusbhost_set_source - sets the source clocks  *	@clkdev: pointer to the clock device structure.  *	@clksrc: the clock source ID for the given clock.  *	@mem_res: array of memory resources allocated by the top level PRCM driver.  *	  *	  *  *	LOCKING:  *	Inherits the locks from the omap_prcm driver, no internal locking.  *  *	RETURNS:  *	Returns 0 if sucessful otherwise a negative error code on failure.  */
end_comment

begin_function
specifier|static
name|int
name|omap4_clk_hsusbhost_set_source
parameter_list|(
name|struct
name|ti_clock_dev
modifier|*
name|clkdev
parameter_list|,
name|clk_src_t
name|clksrc
parameter_list|)
block|{
name|struct
name|omap4_prcm_softc
modifier|*
name|sc
init|=
name|omap4_prcm_sc
decl_stmt|;
name|struct
name|resource
modifier|*
name|clk_mem_res
decl_stmt|;
name|uint32_t
name|clksel_reg_off
decl_stmt|;
name|uint32_t
name|clksel
decl_stmt|;
name|unsigned
name|int
name|bit
decl_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
name|ENXIO
return|;
if|if
condition|(
name|clkdev
operator|->
name|id
operator|==
name|USBP1_PHY_CLK
condition|)
name|bit
operator|=
literal|24
expr_stmt|;
elseif|else
if|if
condition|(
name|clkdev
operator|->
name|id
operator|!=
name|USBP2_PHY_CLK
condition|)
name|bit
operator|=
literal|25
expr_stmt|;
else|else
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* We need the CM_L3INIT_HSUSBHOST_CLKCTRL register in CM2 register set */
name|clk_mem_res
operator|=
name|sc
operator|->
name|sc_res
index|[
name|CM2_INSTANCE_MEM_REGION
index|]
expr_stmt|;
name|clksel_reg_off
operator|=
name|L3INIT_CM2_OFFSET
operator|+
literal|0x58
expr_stmt|;
name|clksel
operator|=
name|bus_read_4
argument_list|(
name|clk_mem_res
argument_list|,
name|clksel_reg_off
argument_list|)
expr_stmt|;
comment|/* Set the clock source to either external or internal */
if|if
condition|(
name|clksrc
operator|==
name|EXT_CLK
condition|)
name|clksel
operator||=
operator|(
literal|0x1
operator|<<
name|bit
operator|)
expr_stmt|;
else|else
name|clksel
operator|&=
operator|~
operator|(
literal|0x1
operator|<<
name|bit
operator|)
expr_stmt|;
name|bus_write_4
argument_list|(
name|clk_mem_res
argument_list|,
name|clksel_reg_off
argument_list|,
name|clksel
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|PRM_RSTCTRL
value|0x1b00
end_define

begin_define
define|#
directive|define
name|PRM_RSTCTRL_RESET
value|0x2
end_define

begin_function
specifier|static
name|void
name|omap4_prcm_reset
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|omap4_prcm_softc
modifier|*
name|sc
init|=
name|omap4_prcm_sc
decl_stmt|;
name|bus_write_4
argument_list|(
name|sc
operator|->
name|sc_res
index|[
literal|0
index|]
argument_list|,
name|PRM_RSTCTRL
argument_list|,
name|bus_read_4
argument_list|(
name|sc
operator|->
name|sc_res
index|[
literal|0
index|]
argument_list|,
name|PRM_RSTCTRL
argument_list|)
operator||
name|PRM_RSTCTRL_RESET
argument_list|)
expr_stmt|;
name|bus_read_4
argument_list|(
name|sc
operator|->
name|sc_res
index|[
literal|0
index|]
argument_list|,
name|PRM_RSTCTRL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	omap4_prcm_probe - probe function for the driver  *	@dev: prcm device handle  *  *	Simply sets the name of the driver module.  *  *	LOCKING:  *	None  *  *	RETURNS:  *	Always returns 0  */
end_comment

begin_function
specifier|static
name|int
name|omap4_prcm_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ofw_bus_status_okay
argument_list|(
name|dev
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
operator|!
name|ofw_bus_is_compatible
argument_list|(
name|dev
argument_list|,
literal|"ti,omap4_prcm"
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"TI OMAP Power, Reset and Clock Management"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	omap_prcm_attach - attach function for the driver  *	@dev: prcm device handle  *  *	Allocates and sets up the driver context, this simply entails creating a  *	bus mappings for the PRCM register set.  *  *	LOCKING:  *	None  *  *	RETURNS:  *	Always returns 0  */
end_comment

begin_decl_stmt
specifier|extern
name|uint32_t
name|platform_arm_tmr_freq
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|omap4_prcm_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|omap4_prcm_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|freq
decl_stmt|;
if|if
condition|(
name|bus_alloc_resources
argument_list|(
name|dev
argument_list|,
name|omap4_scm_res_spec
argument_list|,
name|sc
operator|->
name|sc_res
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not allocate resources\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|omap4_prcm_sc
operator|=
name|sc
expr_stmt|;
name|ti_cpu_reset
operator|=
name|omap4_prcm_reset
expr_stmt|;
name|omap4_clk_get_arm_fclk_freq
argument_list|(
name|NULL
argument_list|,
operator|&
name|freq
argument_list|)
expr_stmt|;
name|arm_tmr_change_frequency
argument_list|(
name|freq
operator|/
literal|2
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|omap4_prcm_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|omap4_prcm_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|omap4_prcm_attach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|omap4_prcm_driver
init|=
block|{
literal|"omap4_prcm"
block|,
name|omap4_prcm_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|omap4_prcm_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|omap4_prcm_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|EARLY_DRIVER_MODULE
argument_list|(
name|omap4_prcm
argument_list|,
name|simplebus
argument_list|,
name|omap4_prcm_driver
argument_list|,
name|omap4_prcm_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|BUS_PASS_TIMER
operator|+
name|BUS_PASS_ORDER_EARLY
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|omap4_prcm
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

