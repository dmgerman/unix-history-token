begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2011  *	Ben Gray<ben.r.gray@gmail.com>.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/**  * Driver for the MMC/SD/SDIO module on the TI OMAP series of SoCs.  *  * This driver is heavily based on the SD/MMC driver for the AT91 (at91_mci.c).  *  * It's important to realise that the MMC state machine is already in the kernel  * and this driver only exposes the specific interfaces of the controller.  *  * This driver is still very much a work in progress, I've verified that basic  * sector reading can be performed. But I've yet to test it with a file system  * or even writing.  In addition I've only tested the driver with an SD card,  * I've no idea if MMC cards work.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/timetc.h>
end_include

begin_include
include|#
directive|include
file|<sys/gpio.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpufunc.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<machine/frame.h>
end_include

begin_include
include|#
directive|include
file|<machine/intr.h>
end_include

begin_include
include|#
directive|include
file|<dev/mmc/bridge.h>
end_include

begin_include
include|#
directive|include
file|<dev/mmc/mmcreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/mmc/mmcbrvar.h>
end_include

begin_include
include|#
directive|include
file|<dev/fdt/fdt_common.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/openfirm.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/ofw_bus.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/ofw_bus_subr.h>
end_include

begin_include
include|#
directive|include
file|"gpio_if.h"
end_include

begin_include
include|#
directive|include
file|"mmcbr_if.h"
end_include

begin_include
include|#
directive|include
file|"mmcbus_if.h"
end_include

begin_include
include|#
directive|include
file|<arm/ti/ti_sdma.h>
end_include

begin_include
include|#
directive|include
file|<arm/ti/ti_edma3.h>
end_include

begin_include
include|#
directive|include
file|<arm/ti/ti_mmchs.h>
end_include

begin_include
include|#
directive|include
file|<arm/ti/ti_cpuid.h>
end_include

begin_include
include|#
directive|include
file|<arm/ti/ti_prcm.h>
end_include

begin_include
include|#
directive|include
file|<arm/ti/twl/twl.h>
end_include

begin_include
include|#
directive|include
file|<arm/ti/twl/twl_vreg.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
define|#
directive|define
name|ti_mmchs_dbg
parameter_list|(
name|sc
parameter_list|,
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
define|\
value|device_printf((sc)->sc_dev, fmt, ## args);
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ti_mmchs_dbg
parameter_list|(
name|sc
parameter_list|,
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  *	Structure that stores the driver context  */
end_comment

begin_struct
struct|struct
name|ti_mmchs_softc
block|{
name|device_t
name|sc_dev
decl_stmt|;
name|uint32_t
name|device_id
decl_stmt|;
name|struct
name|resource
modifier|*
name|sc_irq_res
decl_stmt|;
name|struct
name|resource
modifier|*
name|sc_mem_res
decl_stmt|;
name|void
modifier|*
name|sc_irq_h
decl_stmt|;
name|bus_dma_tag_t
name|sc_dmatag
decl_stmt|;
name|bus_dmamap_t
name|sc_dmamap
decl_stmt|;
name|int
name|sc_dmamapped
decl_stmt|;
name|unsigned
name|int
name|sc_dmach_rd
decl_stmt|;
name|unsigned
name|int
name|sc_dmach_wr
decl_stmt|;
name|int
name|dma_rx_trig
decl_stmt|;
name|int
name|dma_tx_trig
decl_stmt|;
name|device_t
name|sc_gpio_dev
decl_stmt|;
name|int
name|sc_wp_gpio_pin
decl_stmt|;
comment|/* GPIO pin for MMC write protect */
name|device_t
name|sc_vreg_dev
decl_stmt|;
specifier|const
name|char
modifier|*
name|sc_vreg_name
decl_stmt|;
name|struct
name|mtx
name|sc_mtx
decl_stmt|;
name|struct
name|mmc_host
name|host
decl_stmt|;
name|struct
name|mmc_request
modifier|*
name|req
decl_stmt|;
name|struct
name|mmc_command
modifier|*
name|curcmd
decl_stmt|;
name|int
name|flags
decl_stmt|;
define|#
directive|define
name|CMD_STARTED
value|1
define|#
directive|define
name|STOP_STARTED
value|2
name|int
name|bus_busy
decl_stmt|;
comment|/* TODO: Needed ? */
name|void
modifier|*
name|sc_cmd_data_vaddr
decl_stmt|;
name|int
name|sc_cmd_data_len
decl_stmt|;
comment|/* The offset applied to each of the register base addresses, OMAP4 	 * register sets are offset 0x100 from the OMAP3 series. 	 */
name|unsigned
name|long
name|sc_reg_off
decl_stmt|;
comment|/* The physical address of the MMCHS_DATA register, used for the DMA xfers */
name|unsigned
name|long
name|sc_data_reg_paddr
decl_stmt|;
comment|/* The reference clock frequency */
name|unsigned
name|int
name|sc_ref_freq
decl_stmt|;
name|enum
name|mmc_power_mode
name|sc_cur_power_mode
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/**  *	Macros for driver mutex locking  */
end_comment

begin_define
define|#
directive|define
name|TI_MMCHS_LOCK
parameter_list|(
name|_sc
parameter_list|)
value|mtx_lock(&(_sc)->sc_mtx)
end_define

begin_define
define|#
directive|define
name|TI_MMCHS_UNLOCK
parameter_list|(
name|_sc
parameter_list|)
value|mtx_unlock(&(_sc)->sc_mtx)
end_define

begin_define
define|#
directive|define
name|TI_MMCHS_LOCK_INIT
parameter_list|(
name|_sc
parameter_list|)
define|\
value|mtx_init(&_sc->sc_mtx, device_get_nameunit(_sc->sc_dev), \ 	         "ti_mmchs", MTX_DEF)
end_define

begin_define
define|#
directive|define
name|TI_MMCHS_LOCK_DESTROY
parameter_list|(
name|_sc
parameter_list|)
value|mtx_destroy(&_sc->sc_mtx);
end_define

begin_define
define|#
directive|define
name|TI_MMCHS_ASSERT_LOCKED
parameter_list|(
name|_sc
parameter_list|)
value|mtx_assert(&_sc->sc_mtx, MA_OWNED);
end_define

begin_define
define|#
directive|define
name|TI_MMCHS_ASSERT_UNLOCKED
parameter_list|(
name|_sc
parameter_list|)
value|mtx_assert(&_sc->sc_mtx, MA_NOTOWNED);
end_define

begin_function_decl
specifier|static
name|void
name|ti_mmchs_start
parameter_list|(
name|struct
name|ti_mmchs_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  *	ti_mmchs_read_4 - reads a 32-bit value from a register  *	ti_mmchs_write_4 - writes a 32-bit value to a register  *	@sc: pointer to the driver context  *	@off: register offset to read from  *	@val: the value to write into the register  *  *	LOCKING:  *	None  *  *	RETURNS:  *	The 32-bit value read from the register  */
end_comment

begin_function
specifier|static
specifier|inline
name|uint32_t
name|ti_mmchs_read_4
parameter_list|(
name|struct
name|ti_mmchs_softc
modifier|*
name|sc
parameter_list|,
name|bus_size_t
name|off
parameter_list|)
block|{
return|return
name|bus_read_4
argument_list|(
name|sc
operator|->
name|sc_mem_res
argument_list|,
operator|(
name|sc
operator|->
name|sc_reg_off
operator|+
name|off
operator|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|ti_mmchs_write_4
parameter_list|(
name|struct
name|ti_mmchs_softc
modifier|*
name|sc
parameter_list|,
name|bus_size_t
name|off
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
name|bus_write_4
argument_list|(
name|sc
operator|->
name|sc_mem_res
argument_list|,
operator|(
name|sc
operator|->
name|sc_reg_off
operator|+
name|off
operator|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	ti_mmchs_reset_controller -  *	@arg: caller supplied arg  *	@segs: array of segments (although in our case should only be one)  *	@nsegs: number of segments (in our case should be 1)  *	@error:  *  *  *  */
end_comment

begin_function
specifier|static
name|void
name|ti_mmchs_reset_controller
parameter_list|(
name|struct
name|ti_mmchs_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|bit
parameter_list|)
block|{
name|unsigned
name|long
name|attempts
decl_stmt|;
name|uint32_t
name|sysctl
decl_stmt|;
name|ti_mmchs_dbg
argument_list|(
name|sc
argument_list|,
literal|"reseting controller - bit 0x%08x\n"
argument_list|,
name|bit
argument_list|)
expr_stmt|;
name|sysctl
operator|=
name|ti_mmchs_read_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_SYSCTL
argument_list|)
expr_stmt|;
name|ti_mmchs_write_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_SYSCTL
argument_list|,
name|sysctl
operator||
name|bit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ti_chip
argument_list|()
operator|==
name|CHIP_OMAP_4
operator|)
operator|&&
operator|(
name|ti_revision
argument_list|()
operator|>
name|OMAP4430_REV_ES1_0
operator|)
condition|)
block|{
comment|/* OMAP4 ES2 and greater has an updated reset logic. 		 * Monitor a 0->1 transition first 		 */
name|attempts
operator|=
literal|10000
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|ti_mmchs_read_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_SYSCTL
argument_list|)
operator|&
name|bit
operator|)
operator|&&
operator|(
name|attempts
operator|--
operator|>
literal|0
operator|)
condition|)
continue|continue;
block|}
name|attempts
operator|=
literal|10000
expr_stmt|;
while|while
condition|(
operator|(
name|ti_mmchs_read_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_SYSCTL
argument_list|)
operator|&
name|bit
operator|)
operator|&&
operator|(
name|attempts
operator|--
operator|>
literal|0
operator|)
condition|)
continue|continue;
if|if
condition|(
name|ti_mmchs_read_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_SYSCTL
argument_list|)
operator|&
name|bit
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Error - Timeout waiting on controller reset\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	ti_mmchs_getaddr - called by the DMA function to simply return the phys addr  *	@arg: caller supplied arg  *	@segs: array of segments (although in our case should only be one)  *	@nsegs: number of segments (in our case should be 1)  *	@error:  *  *	This function is called by bus_dmamap_load() after it has compiled an array  *	of segments, each segment is a phsyical chunk of memory. However in our case  *	we should only have one segment, because we don't (yet?) support DMA scatter  *	gather. To ensure we only have one segment, the DMA tag was created by  *	bus_dma_tag_create() (called from ti_mmchs_attach) with nsegments set to 1.  *  */
end_comment

begin_function
specifier|static
name|void
name|ti_mmchs_getaddr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
block|{
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return;
operator|*
operator|(
name|bus_addr_t
operator|*
operator|)
name|arg
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|SOC_TI_AM335X
end_ifndef

begin_comment
comment|/**  *	ti_mmchs_dma_intr - interrupt handler for DMA events triggered by the controller  *	@ch: the dma channel number  *	@status: bit field of the status bytes  *	@data: callback data, in this case a pointer to the controller struct  *  *  *	LOCKING:  *	Called from interrupt context  *  */
end_comment

begin_function
specifier|static
name|void
name|ti_mmchs_dma_intr
parameter_list|(
name|unsigned
name|int
name|ch
parameter_list|,
name|uint32_t
name|status
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
comment|/* Ignore for now ... we don't need this interrupt as we already have the 	 * interrupt from the MMC controller. 	 */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  *	ti_mmchs_intr_xfer_compl - called if a 'transfer complete' IRQ was received  *	@sc: pointer to the driver context  *	@cmd: the command that was sent previously  *  *	This function is simply responsible for syncing up the DMA buffer.  *  *	LOCKING:  *	Called from interrupt context  *  *	RETURNS:  *	Return value indicates if the transaction is complete, not done = 0, done != 0  */
end_comment

begin_function
specifier|static
name|int
name|ti_mmchs_intr_xfer_compl
parameter_list|(
name|struct
name|ti_mmchs_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mmc_command
modifier|*
name|cmd
parameter_list|)
block|{
name|uint32_t
name|cmd_reg
decl_stmt|;
comment|/* Read command register to test whether this command was a read or write. */
name|cmd_reg
operator|=
name|ti_mmchs_read_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_CMD
argument_list|)
expr_stmt|;
comment|/* Sync-up the DMA buffer so the caller can access the new memory */
if|if
condition|(
name|cmd_reg
operator|&
name|MMCHS_CMD_DDIR
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmatag
argument_list|,
name|sc
operator|->
name|sc_dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_dmatag
argument_list|,
name|sc
operator|->
name|sc_dmamap
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmatag
argument_list|,
name|sc
operator|->
name|sc_dmamap
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_dmatag
argument_list|,
name|sc
operator|->
name|sc_dmamap
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_dmamapped
operator|--
expr_stmt|;
comment|/* Debugging dump of the data received */
if|#
directive|if
literal|0
block|{ 		int i; 		uint8_t *p = (uint8_t*) sc->sc_cmd_data_vaddr; 		for (i=0; i<sc->sc_cmd_data_len; i++) { 			if ((i % 16) == 0) 				printf("\n0x%04x : ", i); 			printf("%02X ", *p++); 		} 		printf("\n"); 	}
endif|#
directive|endif
comment|/* We are done, transfer complete */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  *	ti_mmchs_intr_cmd_compl - called if a 'command complete' IRQ was received  *	@sc: pointer to the driver context  *	@cmd: the command that was sent previously  *  *  *	LOCKING:  *	Called from interrupt context  *  *	RETURNS:  *	Return value indicates if the transaction is complete, not done = 0, done != 0  */
end_comment

begin_function
specifier|static
name|int
name|ti_mmchs_intr_cmd_compl
parameter_list|(
name|struct
name|ti_mmchs_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mmc_command
modifier|*
name|cmd
parameter_list|)
block|{
name|uint32_t
name|cmd_reg
decl_stmt|;
comment|/* Copy the response into the request struct ... if a response was 	 * expected */
if|if
condition|(
name|cmd
operator|!=
name|NULL
operator|&&
operator|(
name|cmd
operator|->
name|flags
operator|&
name|MMC_RSP_PRESENT
operator|)
condition|)
block|{
if|if
condition|(
name|cmd
operator|->
name|flags
operator|&
name|MMC_RSP_136
condition|)
block|{
name|cmd
operator|->
name|resp
index|[
literal|3
index|]
operator|=
name|ti_mmchs_read_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_RSP10
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|resp
index|[
literal|2
index|]
operator|=
name|ti_mmchs_read_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_RSP32
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|resp
index|[
literal|1
index|]
operator|=
name|ti_mmchs_read_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_RSP54
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|resp
index|[
literal|0
index|]
operator|=
name|ti_mmchs_read_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_RSP76
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cmd
operator|->
name|resp
index|[
literal|0
index|]
operator|=
name|ti_mmchs_read_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_RSP10
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Check if the command was expecting some data transfer, if not 	 * we are done. */
name|cmd_reg
operator|=
name|ti_mmchs_read_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_CMD
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|cmd_reg
operator|&
name|MMCHS_CMD_DP
operator|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	ti_mmchs_intr_error - handles error interrupts  *	@sc: pointer to the driver context  *	@cmd: the command that was sent previously  *	@stat_reg: the value that was in the status register  *  *  *	LOCKING:  *	Called from interrupt context  *  *	RETURNS:  *	Return value indicates if the transaction is complete, not done = 0, done != 0  */
end_comment

begin_function
specifier|static
name|int
name|ti_mmchs_intr_error
parameter_list|(
name|struct
name|ti_mmchs_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mmc_command
modifier|*
name|cmd
parameter_list|,
name|uint32_t
name|stat_reg
parameter_list|)
block|{
name|ti_mmchs_dbg
argument_list|(
name|sc
argument_list|,
literal|"error in xfer - stat 0x%08x\n"
argument_list|,
name|stat_reg
argument_list|)
expr_stmt|;
comment|/* Ignore CRC errors on CMD2 and ACMD47, per relevant standards */
if|if
condition|(
operator|(
name|stat_reg
operator|&
name|MMCHS_STAT_CCRC
operator|)
operator|&&
operator|(
name|cmd
operator|->
name|opcode
operator|==
name|MMC_SEND_OP_COND
operator|||
name|cmd
operator|->
name|opcode
operator|==
name|ACMD_SD_SEND_OP_COND
operator|)
condition|)
name|cmd
operator|->
name|error
operator|=
name|MMC_ERR_NONE
expr_stmt|;
elseif|else
if|if
condition|(
name|stat_reg
operator|&
operator|(
name|MMCHS_STAT_CTO
operator||
name|MMCHS_STAT_DTO
operator|)
condition|)
name|cmd
operator|->
name|error
operator|=
name|MMC_ERR_TIMEOUT
expr_stmt|;
elseif|else
if|if
condition|(
name|stat_reg
operator|&
operator|(
name|MMCHS_STAT_CCRC
operator||
name|MMCHS_STAT_DCRC
operator|)
condition|)
name|cmd
operator|->
name|error
operator|=
name|MMC_ERR_BADCRC
expr_stmt|;
else|else
name|cmd
operator|->
name|error
operator|=
name|MMC_ERR_FAILED
expr_stmt|;
comment|/* If a dma transaction we should also stop the dma transfer */
if|if
condition|(
name|ti_mmchs_read_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_CMD
argument_list|)
operator|&
name|MMCHS_CMD_DE
condition|)
block|{
comment|/* Abort the DMA transfer (DDIR bit tells direction) */
if|if
condition|(
name|ti_mmchs_read_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_CMD
argument_list|)
operator|&
name|MMCHS_CMD_DDIR
condition|)
ifdef|#
directive|ifdef
name|SOC_TI_AM335X
name|printf
argument_list|(
literal|"%s: DMA unimplemented\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
else|#
directive|else
name|ti_sdma_stop_xfer
argument_list|(
name|sc
operator|->
name|sc_dmach_rd
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|else
ifdef|#
directive|ifdef
name|SOC_TI_AM335X
name|printf
argument_list|(
literal|"%s: DMA unimplemented\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
else|#
directive|else
name|ti_sdma_stop_xfer
argument_list|(
name|sc
operator|->
name|sc_dmach_wr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If an error occure abort the DMA operation and free the dma map */
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_dmamapped
operator|>
literal|0
operator|)
operator|&&
operator|(
name|cmd
operator|->
name|error
operator|!=
name|MMC_ERR_NONE
operator|)
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_dmatag
argument_list|,
name|sc
operator|->
name|sc_dmamap
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_dmamapped
operator|--
expr_stmt|;
block|}
block|}
comment|/* Command error occured? ... if so issue a soft reset for the cmd fsm */
if|if
condition|(
name|stat_reg
operator|&
operator|(
name|MMCHS_STAT_CCRC
operator||
name|MMCHS_STAT_CTO
operator|)
condition|)
block|{
name|ti_mmchs_reset_controller
argument_list|(
name|sc
argument_list|,
name|MMCHS_SYSCTL_SRC
argument_list|)
expr_stmt|;
block|}
comment|/* Data error occured? ... if so issue a soft reset for the data line */
if|if
condition|(
name|stat_reg
operator|&
operator|(
name|MMCHS_STAT_DEB
operator||
name|MMCHS_STAT_DCRC
operator||
name|MMCHS_STAT_DTO
operator|)
condition|)
block|{
name|ti_mmchs_reset_controller
argument_list|(
name|sc
argument_list|,
name|MMCHS_SYSCTL_SRD
argument_list|)
expr_stmt|;
block|}
comment|/* On any error the command is cancelled ... so we are done */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  *	ti_mmchs_intr - interrupt handler for MMC/SD/SDIO controller  *	@arg: pointer to the driver context  *  *	Interrupt handler for the MMC/SD/SDIO controller, responsible for handling  *	the IRQ and clearing the status flags.  *  *	LOCKING:  *	Called from interrupt context  *  *	RETURNS:  *	nothing  */
end_comment

begin_function
specifier|static
name|void
name|ti_mmchs_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ti_mmchs_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|ti_mmchs_softc
operator|*
operator|)
name|arg
decl_stmt|;
name|uint32_t
name|stat_reg
decl_stmt|;
name|int
name|done
init|=
literal|0
decl_stmt|;
name|TI_MMCHS_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|stat_reg
operator|=
name|ti_mmchs_read_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_STAT
argument_list|)
operator|&
operator|(
name|ti_mmchs_read_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_IE
argument_list|)
operator||
name|MMCHS_STAT_ERRI
operator|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|curcmd
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Error: current cmd NULL, already done?\n"
argument_list|)
expr_stmt|;
name|ti_mmchs_write_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_STAT
argument_list|,
name|stat_reg
argument_list|)
expr_stmt|;
name|TI_MMCHS_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|stat_reg
operator|&
name|MMCHS_STAT_ERRI
condition|)
block|{
comment|/* An error has been tripped in the status register */
name|done
operator|=
name|ti_mmchs_intr_error
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|curcmd
argument_list|,
name|stat_reg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* NOTE: This implementation could be a bit inefficent, I don't think 		 * it is necessary to handle both the 'command complete' and 'transfer 		 * complete' for data transfers ... presumably just transfer complete 		 * is enough. 		 */
comment|/* No error */
name|sc
operator|->
name|curcmd
operator|->
name|error
operator|=
name|MMC_ERR_NONE
expr_stmt|;
comment|/* Check if the command completed */
if|if
condition|(
name|stat_reg
operator|&
name|MMCHS_STAT_CC
condition|)
block|{
name|done
operator|=
name|ti_mmchs_intr_cmd_compl
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|curcmd
argument_list|)
expr_stmt|;
block|}
comment|/* Check if the transfer has completed */
if|if
condition|(
name|stat_reg
operator|&
name|MMCHS_STAT_TC
condition|)
block|{
name|done
operator|=
name|ti_mmchs_intr_xfer_compl
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|curcmd
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Clear all the interrupt status bits by writing the value back */
name|ti_mmchs_write_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_STAT
argument_list|,
name|stat_reg
argument_list|)
expr_stmt|;
comment|/* This may mark the command as done if there is no stop request */
comment|/* TODO: This is a bit ugly, needs fix-up */
if|if
condition|(
name|done
condition|)
block|{
name|ti_mmchs_start
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|TI_MMCHS_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SOC_TI_AM335X
end_ifdef

begin_function
specifier|static
name|void
name|ti_mmchs_edma3_rx_xfer_setup
parameter_list|(
name|struct
name|ti_mmchs_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|src_paddr
parameter_list|,
name|uint32_t
name|dst_paddr
parameter_list|,
name|uint16_t
name|blk_size
parameter_list|,
name|uint16_t
name|num_blks
parameter_list|)
block|{
name|struct
name|ti_edma3cc_param_set
name|ps
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|ps
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ti_edma3cc_param_set
argument_list|)
argument_list|)
expr_stmt|;
name|ps
operator|.
name|src
operator|=
name|src_paddr
expr_stmt|;
name|ps
operator|.
name|dst
operator|=
name|dst_paddr
expr_stmt|;
name|ps
operator|.
name|dstbidx
operator|=
literal|4
expr_stmt|;
name|ps
operator|.
name|dstcidx
operator|=
name|blk_size
expr_stmt|;
name|ps
operator|.
name|acnt
operator|=
literal|4
expr_stmt|;
name|ps
operator|.
name|bcnt
operator|=
name|blk_size
operator|/
literal|4
expr_stmt|;
name|ps
operator|.
name|ccnt
operator|=
name|num_blks
expr_stmt|;
name|ps
operator|.
name|link
operator|=
literal|0xffff
expr_stmt|;
name|ps
operator|.
name|opt
operator|.
name|tcc
operator|=
name|sc
operator|->
name|dma_rx_trig
expr_stmt|;
name|ps
operator|.
name|opt
operator|.
name|tcinten
operator|=
literal|1
expr_stmt|;
name|ps
operator|.
name|opt
operator|.
name|fwid
operator|=
literal|2
expr_stmt|;
comment|/* fifo width is 32 */
name|ps
operator|.
name|opt
operator|.
name|sam
operator|=
literal|1
expr_stmt|;
name|ps
operator|.
name|opt
operator|.
name|syncdim
operator|=
literal|1
expr_stmt|;
name|ti_edma3_param_write
argument_list|(
name|sc
operator|->
name|dma_rx_trig
argument_list|,
operator|&
name|ps
argument_list|)
expr_stmt|;
name|ti_edma3_enable_transfer_event
argument_list|(
name|sc
operator|->
name|dma_rx_trig
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ti_mmchs_edma3_tx_xfer_setup
parameter_list|(
name|struct
name|ti_mmchs_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|src_paddr
parameter_list|,
name|uint32_t
name|dst_paddr
parameter_list|,
name|uint16_t
name|blk_size
parameter_list|,
name|uint16_t
name|num_blks
parameter_list|)
block|{
name|struct
name|ti_edma3cc_param_set
name|ps
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|ps
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ti_edma3cc_param_set
argument_list|)
argument_list|)
expr_stmt|;
name|ps
operator|.
name|src
operator|=
name|src_paddr
expr_stmt|;
name|ps
operator|.
name|dst
operator|=
name|dst_paddr
expr_stmt|;
name|ps
operator|.
name|srccidx
operator|=
name|blk_size
expr_stmt|;
name|ps
operator|.
name|bcnt
operator|=
name|blk_size
operator|/
literal|4
expr_stmt|;
name|ps
operator|.
name|ccnt
operator|=
name|num_blks
expr_stmt|;
name|ps
operator|.
name|srcbidx
operator|=
literal|4
expr_stmt|;
name|ps
operator|.
name|acnt
operator|=
literal|0x4
expr_stmt|;
name|ps
operator|.
name|link
operator|=
literal|0xffff
expr_stmt|;
name|ps
operator|.
name|opt
operator|.
name|tcc
operator|=
name|sc
operator|->
name|dma_tx_trig
expr_stmt|;
name|ps
operator|.
name|opt
operator|.
name|tcinten
operator|=
literal|1
expr_stmt|;
name|ps
operator|.
name|opt
operator|.
name|fwid
operator|=
literal|2
expr_stmt|;
comment|/* fifo width is 32 */
name|ps
operator|.
name|opt
operator|.
name|dam
operator|=
literal|1
expr_stmt|;
name|ps
operator|.
name|opt
operator|.
name|syncdim
operator|=
literal|1
expr_stmt|;
name|ti_edma3_param_write
argument_list|(
name|sc
operator|->
name|dma_tx_trig
argument_list|,
operator|&
name|ps
argument_list|)
expr_stmt|;
name|ti_edma3_enable_transfer_event
argument_list|(
name|sc
operator|->
name|dma_tx_trig
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  *	ti_mmchs_start_cmd - starts the given command  *	@sc: pointer to the driver context  *	@cmd: the command to start  *  *	The call tree for this function is  *		- ti_mmchs_start_cmd  *			- ti_mmchs_start  *				- ti_mmchs_request  *  *	LOCKING:  *	Caller should be holding the OMAP_MMC lock.  *  *	RETURNS:  *	nothing  */
end_comment

begin_function
specifier|static
name|void
name|ti_mmchs_start_cmd
parameter_list|(
name|struct
name|ti_mmchs_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mmc_command
modifier|*
name|cmd
parameter_list|)
block|{
name|uint32_t
name|cmd_reg
decl_stmt|,
name|con_reg
decl_stmt|,
name|ise_reg
decl_stmt|;
name|struct
name|mmc_data
modifier|*
name|data
decl_stmt|;
name|struct
name|mmc_request
modifier|*
name|req
decl_stmt|;
name|void
modifier|*
name|vaddr
decl_stmt|;
name|bus_addr_t
name|paddr
decl_stmt|;
ifndef|#
directive|ifndef
name|SOC_TI_AM335X
name|uint32_t
name|pktsize
decl_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|curcmd
operator|=
name|cmd
expr_stmt|;
name|data
operator|=
name|cmd
operator|->
name|data
expr_stmt|;
name|req
operator|=
name|cmd
operator|->
name|mrq
expr_stmt|;
comment|/* Ensure the STR and MIT bits are cleared, these are only used for special 	 * command types. 	 */
name|con_reg
operator|=
name|ti_mmchs_read_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_CON
argument_list|)
expr_stmt|;
name|con_reg
operator|&=
operator|~
operator|(
name|MMCHS_CON_STR
operator||
name|MMCHS_CON_MIT
operator|)
expr_stmt|;
comment|/* Load the command into bits 29:24 of the CMD register */
name|cmd_reg
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|cmd
operator|->
name|opcode
operator|&
literal|0x3F
argument_list|)
operator|<<
literal|24
expr_stmt|;
comment|/* Set the default set of interrupts */
name|ise_reg
operator|=
operator|(
name|MMCHS_STAT_CERR
operator||
name|MMCHS_STAT_CTO
operator||
name|MMCHS_STAT_CC
operator||
name|MMCHS_STAT_CEB
operator|)
expr_stmt|;
comment|/* Enable CRC checking if requested */
if|if
condition|(
name|cmd
operator|->
name|flags
operator|&
name|MMC_RSP_CRC
condition|)
name|ise_reg
operator||=
name|MMCHS_STAT_CCRC
expr_stmt|;
comment|/* Enable reply index checking if the response supports it */
if|if
condition|(
name|cmd
operator|->
name|flags
operator|&
name|MMC_RSP_OPCODE
condition|)
name|ise_reg
operator||=
name|MMCHS_STAT_CIE
expr_stmt|;
comment|/* Set the expected response length */
if|if
condition|(
name|MMC_RSP
argument_list|(
name|cmd
operator|->
name|flags
argument_list|)
operator|==
name|MMC_RSP_NONE
condition|)
block|{
name|cmd_reg
operator||=
name|MMCHS_CMD_RSP_TYPE_NO
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cmd
operator|->
name|flags
operator|&
name|MMC_RSP_136
condition|)
name|cmd_reg
operator||=
name|MMCHS_CMD_RSP_TYPE_136
expr_stmt|;
elseif|else
if|if
condition|(
name|cmd
operator|->
name|flags
operator|&
name|MMC_RSP_BUSY
condition|)
name|cmd_reg
operator||=
name|MMCHS_CMD_RSP_TYPE_48_BSY
expr_stmt|;
else|else
name|cmd_reg
operator||=
name|MMCHS_CMD_RSP_TYPE_48
expr_stmt|;
comment|/* Enable command index/crc checks if necessary expected */
if|if
condition|(
name|cmd
operator|->
name|flags
operator|&
name|MMC_RSP_CRC
condition|)
name|cmd_reg
operator||=
name|MMCHS_CMD_CCCE
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|flags
operator|&
name|MMC_RSP_OPCODE
condition|)
name|cmd_reg
operator||=
name|MMCHS_CMD_CICE
expr_stmt|;
block|}
comment|/* Set the bits for the special commands CMD12 (MMC_STOP_TRANSMISSION) and 	 * CMD52 (SD_IO_RW_DIRECT) */
if|if
condition|(
name|cmd
operator|->
name|opcode
operator|==
name|MMC_STOP_TRANSMISSION
condition|)
name|cmd_reg
operator||=
name|MMCHS_CMD_CMD_TYPE_IO_ABORT
expr_stmt|;
comment|/* Check if there is any data to write */
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
block|{
comment|/* Clear the block count */
name|ti_mmchs_write_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_BLK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* The no data case is fairly simple */
name|ti_mmchs_write_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_CON
argument_list|,
name|con_reg
argument_list|)
expr_stmt|;
name|ti_mmchs_write_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_IE
argument_list|,
name|ise_reg
argument_list|)
expr_stmt|;
name|ti_mmchs_write_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_ISE
argument_list|,
name|ise_reg
argument_list|)
expr_stmt|;
name|ti_mmchs_write_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_ARG
argument_list|,
name|cmd
operator|->
name|arg
argument_list|)
expr_stmt|;
name|ti_mmchs_write_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_CMD
argument_list|,
name|cmd_reg
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Indicate that data is present */
name|cmd_reg
operator||=
name|MMCHS_CMD_DP
operator||
name|MMCHS_CMD_MSBS
operator||
name|MMCHS_CMD_BCE
expr_stmt|;
comment|/* Indicate a read operation */
if|if
condition|(
name|data
operator|->
name|flags
operator|&
name|MMC_DATA_READ
condition|)
name|cmd_reg
operator||=
name|MMCHS_CMD_DDIR
expr_stmt|;
comment|/* Streaming mode */
if|if
condition|(
name|data
operator|->
name|flags
operator|&
name|MMC_DATA_STREAM
condition|)
block|{
name|con_reg
operator||=
name|MMCHS_CON_STR
expr_stmt|;
block|}
comment|/* Multi-block mode */
if|if
condition|(
name|data
operator|->
name|flags
operator|&
name|MMC_DATA_MULTI
condition|)
block|{
name|cmd_reg
operator||=
name|MMCHS_CMD_MSBS
expr_stmt|;
block|}
comment|/* Enable extra interrupt sources for the transfer */
name|ise_reg
operator||=
operator|(
name|MMCHS_STAT_TC
operator||
name|MMCHS_STAT_DTO
operator||
name|MMCHS_STAT_DEB
operator||
name|MMCHS_STAT_CEB
operator|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|flags
operator|&
name|MMC_RSP_CRC
condition|)
name|ise_reg
operator||=
name|MMCHS_STAT_DCRC
expr_stmt|;
comment|/* Enable the DMA transfer bit */
name|cmd_reg
operator||=
name|MMCHS_CMD_DE
expr_stmt|;
comment|/* Set the block size and block count */
name|ti_mmchs_write_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_BLK
argument_list|,
operator|(
literal|1
operator|<<
literal|16
operator|)
operator||
name|data
operator|->
name|len
argument_list|)
expr_stmt|;
comment|/* Setup the DMA stuff */
if|if
condition|(
name|data
operator|->
name|flags
operator|&
operator|(
name|MMC_DATA_READ
operator||
name|MMC_DATA_WRITE
operator|)
condition|)
block|{
name|vaddr
operator|=
name|data
operator|->
name|data
expr_stmt|;
name|data
operator|->
name|xfer_len
operator|=
literal|0
expr_stmt|;
comment|/* Map the buffer buf into bus space using the dmamap map. */
if|if
condition|(
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|sc_dmatag
argument_list|,
name|sc
operator|->
name|sc_dmamap
argument_list|,
name|vaddr
argument_list|,
name|data
operator|->
name|len
argument_list|,
name|ti_mmchs_getaddr
argument_list|,
operator|&
name|paddr
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|req
operator|->
name|cmd
operator|->
name|flags
operator|&
name|STOP_STARTED
condition|)
name|req
operator|->
name|stop
operator|->
name|error
operator|=
name|MMC_ERR_NO_MEMORY
expr_stmt|;
else|else
name|req
operator|->
name|cmd
operator|->
name|error
operator|=
name|MMC_ERR_NO_MEMORY
expr_stmt|;
name|sc
operator|->
name|req
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|curcmd
operator|=
name|NULL
expr_stmt|;
name|req
operator|->
name|done
argument_list|(
name|req
argument_list|)
expr_stmt|;
return|return;
block|}
ifndef|#
directive|ifndef
name|SOC_TI_AM335X
comment|/* Calculate the packet size, the max packet size is 512 bytes 		 * (or 128 32-bit elements). 		 */
name|pktsize
operator|=
name|min
argument_list|(
operator|(
name|data
operator|->
name|len
operator|/
literal|4
operator|)
argument_list|,
operator|(
literal|512
operator|/
literal|4
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Sync the DMA buffer and setup the DMA controller */
if|if
condition|(
name|data
operator|->
name|flags
operator|&
name|MMC_DATA_READ
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmatag
argument_list|,
name|sc
operator|->
name|sc_dmamap
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SOC_TI_AM335X
name|ti_mmchs_edma3_rx_xfer_setup
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_data_reg_paddr
argument_list|,
name|paddr
argument_list|,
name|data
operator|->
name|len
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|ti_sdma_start_xfer_packet
argument_list|(
name|sc
operator|->
name|sc_dmach_rd
argument_list|,
name|sc
operator|->
name|sc_data_reg_paddr
argument_list|,
name|paddr
argument_list|,
literal|1
argument_list|,
operator|(
name|data
operator|->
name|len
operator|/
literal|4
operator|)
argument_list|,
name|pktsize
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmatag
argument_list|,
name|sc
operator|->
name|sc_dmamap
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SOC_TI_AM335X
name|ti_mmchs_edma3_tx_xfer_setup
argument_list|(
name|sc
argument_list|,
name|paddr
argument_list|,
name|sc
operator|->
name|sc_data_reg_paddr
argument_list|,
name|data
operator|->
name|len
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|ti_sdma_start_xfer_packet
argument_list|(
name|sc
operator|->
name|sc_dmach_wr
argument_list|,
name|paddr
argument_list|,
name|sc
operator|->
name|sc_data_reg_paddr
argument_list|,
literal|1
argument_list|,
operator|(
name|data
operator|->
name|len
operator|/
literal|4
operator|)
argument_list|,
name|pktsize
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Increase the mapped count */
name|sc
operator|->
name|sc_dmamapped
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_cmd_data_vaddr
operator|=
name|vaddr
expr_stmt|;
name|sc
operator|->
name|sc_cmd_data_len
operator|=
name|data
operator|->
name|len
expr_stmt|;
block|}
comment|/* Finally kick off the command */
name|ti_mmchs_write_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_CON
argument_list|,
name|con_reg
argument_list|)
expr_stmt|;
name|ti_mmchs_write_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_IE
argument_list|,
name|ise_reg
argument_list|)
expr_stmt|;
name|ti_mmchs_write_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_ISE
argument_list|,
name|ise_reg
argument_list|)
expr_stmt|;
name|ti_mmchs_write_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_ARG
argument_list|,
name|cmd
operator|->
name|arg
argument_list|)
expr_stmt|;
name|ti_mmchs_write_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_CMD
argument_list|,
name|cmd_reg
argument_list|)
expr_stmt|;
comment|/* and we're done */
block|}
end_function

begin_comment
comment|/**  *	ti_mmchs_start - starts a request stored in the driver context  *	@sc: pointer to the driver context  *  *	This function is called by ti_mmchs_request() in response to a read/write  *	request from the MMC core module.  *  *	LOCKING:  *	Caller should be holding the OMAP_MMC lock.  *  *	RETURNS:  *	nothing  */
end_comment

begin_function
specifier|static
name|void
name|ti_mmchs_start
parameter_list|(
name|struct
name|ti_mmchs_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mmc_request
modifier|*
name|req
decl_stmt|;
comment|/* Sanity check we have a request */
name|req
operator|=
name|sc
operator|->
name|req
expr_stmt|;
if|if
condition|(
name|req
operator|==
name|NULL
condition|)
return|return;
comment|/* assert locked */
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|flags
operator|&
name|CMD_STARTED
operator|)
condition|)
block|{
name|sc
operator|->
name|flags
operator||=
name|CMD_STARTED
expr_stmt|;
name|ti_mmchs_start_cmd
argument_list|(
name|sc
argument_list|,
name|req
operator|->
name|cmd
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|flags
operator|&
name|STOP_STARTED
operator|)
operator|&&
name|req
operator|->
name|stop
condition|)
block|{
name|sc
operator|->
name|flags
operator||=
name|STOP_STARTED
expr_stmt|;
name|ti_mmchs_start_cmd
argument_list|(
name|sc
argument_list|,
name|req
operator|->
name|stop
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* We must be done -- bad idea to do this while locked? */
name|sc
operator|->
name|req
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|curcmd
operator|=
name|NULL
expr_stmt|;
name|req
operator|->
name|done
argument_list|(
name|req
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	ti_mmchs_request - entry point for all read/write/cmd requests  *	@brdev: mmc bridge device handle  *	@reqdev: the device doing the requesting ?  *	@req: the action requested  *  *	LOCKING:  *	None, internally takes the OMAP_MMC lock.  *  *	RETURNS:  *	0 on success  *	EBUSY if the driver is already performing a request  */
end_comment

begin_function
specifier|static
name|int
name|ti_mmchs_request
parameter_list|(
name|device_t
name|brdev
parameter_list|,
name|device_t
name|reqdev
parameter_list|,
name|struct
name|mmc_request
modifier|*
name|req
parameter_list|)
block|{
name|struct
name|ti_mmchs_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|brdev
argument_list|)
decl_stmt|;
name|TI_MMCHS_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * XXX do we want to be able to queue up multiple commands? 	 * XXX sounds like a good idea, but all protocols are sync, so 	 * XXX maybe the idea is naive... 	 */
if|if
condition|(
name|sc
operator|->
name|req
operator|!=
name|NULL
condition|)
block|{
name|TI_MMCHS_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
comment|/* Store the request and start the command */
name|sc
operator|->
name|req
operator|=
name|req
expr_stmt|;
name|sc
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|ti_mmchs_start
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|TI_MMCHS_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	ti_mmchs_get_ro - returns the status of the read-only setting  *	@brdev: mmc bridge device handle  *	@reqdev: device doing the request  *  *	This function is relies on hint'ed values to determine which GPIO is used  *	to determine if the write protect is enabled. On the BeagleBoard the pin  *	is GPIO_23.  *  *	LOCKING:  *	-  *  *	RETURNS:  *	0 if not read-only  *	1 if read only  */
end_comment

begin_function
specifier|static
name|int
name|ti_mmchs_get_ro
parameter_list|(
name|device_t
name|brdev
parameter_list|,
name|device_t
name|reqdev
parameter_list|)
block|{
name|struct
name|ti_mmchs_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|brdev
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|readonly
init|=
literal|0
decl_stmt|;
name|TI_MMCHS_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_wp_gpio_pin
operator|!=
operator|-
literal|1
operator|)
operator|&&
operator|(
name|sc
operator|->
name|sc_gpio_dev
operator|!=
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
name|GPIO_PIN_GET
argument_list|(
name|sc
operator|->
name|sc_gpio_dev
argument_list|,
name|sc
operator|->
name|sc_wp_gpio_pin
argument_list|,
operator|&
name|readonly
argument_list|)
operator|!=
literal|0
condition|)
name|readonly
operator|=
literal|0
expr_stmt|;
else|else
name|readonly
operator|=
operator|(
name|readonly
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
block|}
name|TI_MMCHS_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|readonly
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	ti_mmchs_send_init_stream - sets bus/controller settings  *	@brdev: mmc bridge device handle  *	@reqdev: device doing the request  *  *	Send init stream sequence to card before sending IDLE command  *  *	LOCKING:  *  *  *	RETURNS:  *	0 if function succeeded  */
end_comment

begin_function
specifier|static
name|void
name|ti_mmchs_send_init_stream
parameter_list|(
name|struct
name|ti_mmchs_softc
modifier|*
name|sc
parameter_list|)
block|{
name|unsigned
name|long
name|timeout
decl_stmt|;
name|uint32_t
name|ie
decl_stmt|,
name|ise
decl_stmt|,
name|con
decl_stmt|;
name|ti_mmchs_dbg
argument_list|(
name|sc
argument_list|,
literal|"Performing init sequence\n"
argument_list|)
expr_stmt|;
comment|/* Prior to issuing any command, the MMCHS controller has to execute a 	 * special INIT procedure. The MMCHS controller has to generate a clock 	 * during 1ms. During the INIT procedure, the MMCHS controller generates 80 	 * clock periods. In order to keep the 1ms gap, the MMCHS controller should 	 * be configured to generate a clock whose frequency is smaller or equal to 	 * 80 KHz. If the MMCHS controller divider bitfield width doesn't allow to 	 * choose big values, the MMCHS controller driver should perform the INIT 	 * procedure twice or three times. Twice is generally enough. 	 * 	 * The INIt procedure is executed by setting MMCHS1.MMCHS_CON[1] INIT 	 * bitfield to 1 and by sending a dummy command, writing 0x00000000 in 	 * MMCHS1.MMCHS_CMD register. 	 */
comment|/* Disable interrupt status events but enable interrupt generation. 	 * This doesn't seem right to me, but if the interrupt generation is not 	 * enabled the CC bit doesn't seem to be set in the STAT register. 	 */
comment|/* Enable interrupt generation */
name|ie
operator|=
name|ti_mmchs_read_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_IE
argument_list|)
expr_stmt|;
name|ti_mmchs_write_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_IE
argument_list|,
literal|0x307F0033
argument_list|)
expr_stmt|;
comment|/* Disable generation of status events (stops interrupt triggering) */
name|ise
operator|=
name|ti_mmchs_read_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_ISE
argument_list|)
expr_stmt|;
name|ti_mmchs_write_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_ISE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set the initialise stream bit */
name|con
operator|=
name|ti_mmchs_read_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_CON
argument_list|)
expr_stmt|;
name|con
operator||=
name|MMCHS_CON_INIT
expr_stmt|;
name|ti_mmchs_write_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_CON
argument_list|,
name|con
argument_list|)
expr_stmt|;
comment|/* Write a dummy command 0x00 */
name|ti_mmchs_write_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_CMD
argument_list|,
literal|0x00000000
argument_list|)
expr_stmt|;
comment|/* Loop waiting for the command to finish */
name|timeout
operator|=
name|hz
expr_stmt|;
do|do
block|{
name|pause
argument_list|(
literal|"MMCINIT"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|timeout
operator|--
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Error: first stream init timed out\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
operator|!
operator|(
name|ti_mmchs_read_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_STAT
argument_list|)
operator|&
name|MMCHS_STAT_CC
operator|)
condition|)
do|;
comment|/* Clear the command complete status bit */
name|ti_mmchs_write_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_STAT
argument_list|,
name|MMCHS_STAT_CC
argument_list|)
expr_stmt|;
comment|/* Write another dummy command 0x00 */
name|ti_mmchs_write_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_CMD
argument_list|,
literal|0x00000000
argument_list|)
expr_stmt|;
comment|/* Loop waiting for the second command to finish */
name|timeout
operator|=
name|hz
expr_stmt|;
do|do
block|{
name|pause
argument_list|(
literal|"MMCINIT"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|timeout
operator|--
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Error: second stream init timed out\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
operator|!
operator|(
name|ti_mmchs_read_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_STAT
argument_list|)
operator|&
name|MMCHS_STAT_CC
operator|)
condition|)
do|;
comment|/* Clear the stream init bit */
name|con
operator|&=
operator|~
name|MMCHS_CON_INIT
expr_stmt|;
name|ti_mmchs_write_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_CON
argument_list|,
name|con
argument_list|)
expr_stmt|;
comment|/* Clear the status register, then restore the IE and ISE registers */
name|ti_mmchs_write_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_STAT
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|ti_mmchs_read_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_STAT
argument_list|)
expr_stmt|;
name|ti_mmchs_write_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_ISE
argument_list|,
name|ise
argument_list|)
expr_stmt|;
name|ti_mmchs_write_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_IE
argument_list|,
name|ie
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	ti_mmchs_update_ios - sets bus/controller settings  *	@brdev: mmc bridge device handle  *	@reqdev: device doing the request  *  *	Called to set the bus and controller settings that need to be applied to  *	the actual HW.  Currently this function just sets the bus width and the  *	clock speed.  *  *	LOCKING:  *  *  *	RETURNS:  *	0 if function succeeded  */
end_comment

begin_function
specifier|static
name|int
name|ti_mmchs_update_ios
parameter_list|(
name|device_t
name|brdev
parameter_list|,
name|device_t
name|reqdev
parameter_list|)
block|{
name|struct
name|ti_mmchs_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mmc_host
modifier|*
name|host
decl_stmt|;
name|struct
name|mmc_ios
modifier|*
name|ios
decl_stmt|;
name|uint32_t
name|clkdiv
decl_stmt|;
name|uint32_t
name|hctl_reg
decl_stmt|;
name|uint32_t
name|con_reg
decl_stmt|;
name|uint32_t
name|sysctl_reg
decl_stmt|;
ifndef|#
directive|ifndef
name|SOC_TI_AM335X
name|uint16_t
name|mv
decl_stmt|;
endif|#
directive|endif
name|unsigned
name|long
name|timeout
decl_stmt|;
name|int
name|do_card_init
init|=
literal|0
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|brdev
argument_list|)
expr_stmt|;
name|host
operator|=
operator|&
name|sc
operator|->
name|host
expr_stmt|;
name|ios
operator|=
operator|&
name|host
operator|->
name|ios
expr_stmt|;
comment|/* Read the initial values of the registers */
name|hctl_reg
operator|=
name|ti_mmchs_read_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_HCTL
argument_list|)
expr_stmt|;
name|con_reg
operator|=
name|ti_mmchs_read_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_CON
argument_list|)
expr_stmt|;
comment|/* Set the bus width */
switch|switch
condition|(
name|ios
operator|->
name|bus_width
condition|)
block|{
case|case
name|bus_width_1
case|:
name|hctl_reg
operator|&=
operator|~
name|MMCHS_HCTL_DTW
expr_stmt|;
name|con_reg
operator|&=
operator|~
name|MMCHS_CON_DW8
expr_stmt|;
break|break;
case|case
name|bus_width_4
case|:
name|hctl_reg
operator||=
name|MMCHS_HCTL_DTW
expr_stmt|;
name|con_reg
operator|&=
operator|~
name|MMCHS_CON_DW8
expr_stmt|;
break|break;
case|case
name|bus_width_8
case|:
name|con_reg
operator||=
name|MMCHS_CON_DW8
expr_stmt|;
break|break;
block|}
comment|/* Finally write all these settings back to the registers */
name|ti_mmchs_write_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_HCTL
argument_list|,
name|hctl_reg
argument_list|)
expr_stmt|;
name|ti_mmchs_write_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_CON
argument_list|,
name|con_reg
argument_list|)
expr_stmt|;
comment|/* Check if we need to change the external voltage regulator */
if|if
condition|(
name|sc
operator|->
name|sc_cur_power_mode
operator|!=
name|ios
operator|->
name|power_mode
condition|)
block|{
if|if
condition|(
name|ios
operator|->
name|power_mode
operator|==
name|power_up
condition|)
block|{
comment|/* Set the power level */
name|hctl_reg
operator|=
name|ti_mmchs_read_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_HCTL
argument_list|)
expr_stmt|;
name|hctl_reg
operator|&=
operator|~
operator|(
name|MMCHS_HCTL_SDVS_MASK
operator||
name|MMCHS_HCTL_SDBP
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|ios
operator|->
name|vdd
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|ios
operator|->
name|vdd
operator|>=
name|vdd_240
operator|)
condition|)
block|{
ifndef|#
directive|ifndef
name|SOC_TI_AM335X
name|mv
operator|=
literal|3000
expr_stmt|;
endif|#
directive|endif
name|hctl_reg
operator||=
name|MMCHS_HCTL_SDVS_V30
expr_stmt|;
block|}
else|else
block|{
ifndef|#
directive|ifndef
name|SOC_TI_AM335X
name|mv
operator|=
literal|1800
expr_stmt|;
endif|#
directive|endif
name|hctl_reg
operator||=
name|MMCHS_HCTL_SDVS_V18
expr_stmt|;
block|}
name|ti_mmchs_write_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_HCTL
argument_list|,
name|hctl_reg
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SOC_TI_AM335X
name|printf
argument_list|(
literal|"%s: TWL unimplemented\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Set the desired voltage on the regulator */
if|if
condition|(
name|sc
operator|->
name|sc_vreg_dev
operator|&&
name|sc
operator|->
name|sc_vreg_name
condition|)
name|twl_vreg_set_voltage
argument_list|(
name|sc
operator|->
name|sc_vreg_dev
argument_list|,
name|sc
operator|->
name|sc_vreg_name
argument_list|,
name|mv
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Enable the bus power */
name|ti_mmchs_write_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_HCTL
argument_list|,
operator|(
name|hctl_reg
operator||
name|MMCHS_HCTL_SDBP
operator|)
argument_list|)
expr_stmt|;
name|timeout
operator|=
name|hz
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|ti_mmchs_read_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_HCTL
argument_list|)
operator|&
name|MMCHS_HCTL_SDBP
operator|)
condition|)
block|{
if|if
condition|(
name|timeout
operator|--
operator|==
literal|0
condition|)
break|break;
name|pause
argument_list|(
literal|"MMC_PWRON"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ios
operator|->
name|power_mode
operator|==
name|power_off
condition|)
block|{
comment|/* Disable the bus power */
name|hctl_reg
operator|=
name|ti_mmchs_read_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_HCTL
argument_list|)
expr_stmt|;
name|ti_mmchs_write_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_HCTL
argument_list|,
operator|(
name|hctl_reg
operator|&
operator|~
name|MMCHS_HCTL_SDBP
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SOC_TI_AM335X
name|printf
argument_list|(
literal|"%s: TWL unimplemented\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Turn the power off on the voltage regulator */
if|if
condition|(
name|sc
operator|->
name|sc_vreg_dev
operator|&&
name|sc
operator|->
name|sc_vreg_name
condition|)
name|twl_vreg_set_voltage
argument_list|(
name|sc
operator|->
name|sc_vreg_dev
argument_list|,
name|sc
operator|->
name|sc_vreg_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|ios
operator|->
name|power_mode
operator|==
name|power_on
condition|)
block|{
comment|/* Force a card re-initialisation sequence */
name|do_card_init
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Save the new power state */
name|sc
operator|->
name|sc_cur_power_mode
operator|=
name|ios
operator|->
name|power_mode
expr_stmt|;
block|}
comment|/* need the MMCHS_SYSCTL register */
name|sysctl_reg
operator|=
name|ti_mmchs_read_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_SYSCTL
argument_list|)
expr_stmt|;
comment|/* Just in case this hasn't been setup before, set the timeout to the default */
name|sysctl_reg
operator|&=
operator|~
name|MMCHS_SYSCTL_DTO_MASK
expr_stmt|;
name|sysctl_reg
operator||=
name|MMCHS_SYSCTL_DTO
argument_list|(
literal|0xe
argument_list|)
expr_stmt|;
comment|/* Disable the clock output while configuring the new clock */
name|sysctl_reg
operator|&=
operator|~
operator|(
name|MMCHS_SYSCTL_ICE
operator||
name|MMCHS_SYSCTL_CEN
operator|)
expr_stmt|;
name|ti_mmchs_write_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_SYSCTL
argument_list|,
name|sysctl_reg
argument_list|)
expr_stmt|;
comment|/* bus mode? */
if|if
condition|(
name|ios
operator|->
name|clock
operator|==
literal|0
condition|)
block|{
name|clkdiv
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|clkdiv
operator|=
name|sc
operator|->
name|sc_ref_freq
operator|/
name|ios
operator|->
name|clock
expr_stmt|;
if|if
condition|(
name|clkdiv
operator|<
literal|1
condition|)
name|clkdiv
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_ref_freq
operator|/
name|clkdiv
operator|)
operator|>
name|ios
operator|->
name|clock
condition|)
name|clkdiv
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|clkdiv
operator|>
literal|250
condition|)
name|clkdiv
operator|=
literal|250
expr_stmt|;
block|}
comment|/* Set the new clock divider */
name|sysctl_reg
operator|&=
operator|~
name|MMCHS_SYSCTL_CLKD_MASK
expr_stmt|;
name|sysctl_reg
operator||=
name|MMCHS_SYSCTL_CLKD
argument_list|(
name|clkdiv
argument_list|)
expr_stmt|;
comment|/* Write the new settings ... */
name|ti_mmchs_write_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_SYSCTL
argument_list|,
name|sysctl_reg
argument_list|)
expr_stmt|;
comment|/* ... write the internal clock enable bit ... */
name|ti_mmchs_write_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_SYSCTL
argument_list|,
name|sysctl_reg
operator||
name|MMCHS_SYSCTL_ICE
argument_list|)
expr_stmt|;
comment|/* ... wait for the clock to stablise ... */
while|while
condition|(
operator|(
operator|(
name|sysctl_reg
operator|=
name|ti_mmchs_read_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_SYSCTL
argument_list|)
operator|)
operator|&
name|MMCHS_SYSCTL_ICS
operator|)
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
comment|/* ... then enable */
name|sysctl_reg
operator||=
name|MMCHS_SYSCTL_CEN
expr_stmt|;
name|ti_mmchs_write_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_SYSCTL
argument_list|,
name|sysctl_reg
argument_list|)
expr_stmt|;
comment|/* If the power state has changed to 'power_on' then run the init sequence*/
if|if
condition|(
name|do_card_init
condition|)
block|{
name|ti_mmchs_send_init_stream
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* Set the bus mode (opendrain or normal) */
name|con_reg
operator|=
name|ti_mmchs_read_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_CON
argument_list|)
expr_stmt|;
if|if
condition|(
name|ios
operator|->
name|bus_mode
operator|==
name|opendrain
condition|)
name|con_reg
operator||=
name|MMCHS_CON_OD
expr_stmt|;
else|else
name|con_reg
operator|&=
operator|~
name|MMCHS_CON_OD
expr_stmt|;
name|ti_mmchs_write_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_CON
argument_list|,
name|con_reg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	ti_mmchs_acquire_host -  *	@brdev: mmc bridge device handle  *	@reqdev: device doing the request  *  *	TODO: Is this function needed ?  *  *	LOCKING:  *	none  *  *	RETURNS:  *	0 function succeeded  *  */
end_comment

begin_function
specifier|static
name|int
name|ti_mmchs_acquire_host
parameter_list|(
name|device_t
name|brdev
parameter_list|,
name|device_t
name|reqdev
parameter_list|)
block|{
name|struct
name|ti_mmchs_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|brdev
argument_list|)
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|TI_MMCHS_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
while|while
condition|(
name|sc
operator|->
name|bus_busy
condition|)
block|{
name|msleep
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
name|PZERO
argument_list|,
literal|"mmc"
argument_list|,
name|hz
operator|/
literal|5
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|bus_busy
operator|++
expr_stmt|;
name|TI_MMCHS_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	ti_mmchs_release_host -  *	@brdev: mmc bridge device handle  *	@reqdev: device doing the request  *  *	TODO: Is this function needed ?  *  *	LOCKING:  *	none  *  *	RETURNS:  *	0 function succeeded  *  */
end_comment

begin_function
specifier|static
name|int
name|ti_mmchs_release_host
parameter_list|(
name|device_t
name|brdev
parameter_list|,
name|device_t
name|reqdev
parameter_list|)
block|{
name|struct
name|ti_mmchs_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|brdev
argument_list|)
decl_stmt|;
name|TI_MMCHS_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|bus_busy
operator|--
expr_stmt|;
name|wakeup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|TI_MMCHS_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	ti_mmchs_read_ivar - returns driver conf variables  *	@bus:  *	@child:  *	@which: The variable to get the result for  *	@result: Upon return will store the variable value  *  *  *  *	LOCKING:  *	None, caller must hold locks  *  *	RETURNS:  *	0 on success  *	EINVAL if the variable requested is invalid  */
end_comment

begin_function
specifier|static
name|int
name|ti_mmchs_read_ivar
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|which
parameter_list|,
name|uintptr_t
modifier|*
name|result
parameter_list|)
block|{
name|struct
name|ti_mmchs_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|bus
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|which
condition|)
block|{
case|case
name|MMCBR_IVAR_BUS_MODE
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|result
operator|=
name|sc
operator|->
name|host
operator|.
name|ios
operator|.
name|bus_mode
expr_stmt|;
break|break;
case|case
name|MMCBR_IVAR_BUS_WIDTH
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|result
operator|=
name|sc
operator|->
name|host
operator|.
name|ios
operator|.
name|bus_width
expr_stmt|;
break|break;
case|case
name|MMCBR_IVAR_CHIP_SELECT
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|result
operator|=
name|sc
operator|->
name|host
operator|.
name|ios
operator|.
name|chip_select
expr_stmt|;
break|break;
case|case
name|MMCBR_IVAR_CLOCK
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|result
operator|=
name|sc
operator|->
name|host
operator|.
name|ios
operator|.
name|clock
expr_stmt|;
break|break;
case|case
name|MMCBR_IVAR_F_MIN
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|result
operator|=
name|sc
operator|->
name|host
operator|.
name|f_min
expr_stmt|;
break|break;
case|case
name|MMCBR_IVAR_F_MAX
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|result
operator|=
name|sc
operator|->
name|host
operator|.
name|f_max
expr_stmt|;
break|break;
case|case
name|MMCBR_IVAR_HOST_OCR
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|result
operator|=
name|sc
operator|->
name|host
operator|.
name|host_ocr
expr_stmt|;
break|break;
case|case
name|MMCBR_IVAR_MODE
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|result
operator|=
name|sc
operator|->
name|host
operator|.
name|mode
expr_stmt|;
break|break;
case|case
name|MMCBR_IVAR_OCR
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|result
operator|=
name|sc
operator|->
name|host
operator|.
name|ocr
expr_stmt|;
break|break;
case|case
name|MMCBR_IVAR_POWER_MODE
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|result
operator|=
name|sc
operator|->
name|host
operator|.
name|ios
operator|.
name|power_mode
expr_stmt|;
break|break;
case|case
name|MMCBR_IVAR_VDD
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|result
operator|=
name|sc
operator|->
name|host
operator|.
name|ios
operator|.
name|vdd
expr_stmt|;
break|break;
case|case
name|MMCBR_IVAR_CAPS
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|result
operator|=
name|sc
operator|->
name|host
operator|.
name|caps
expr_stmt|;
break|break;
case|case
name|MMCBR_IVAR_MAX_DATA
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|result
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	ti_mmchs_write_ivar - writes a driver conf variables  *	@bus:  *	@child:  *	@which: The variable to set  *	@value: The value to write into the variable  *  *  *  *	LOCKING:  *	None, caller must hold locks  *  *	RETURNS:  *	0 on success  *	EINVAL if the variable requested is invalid  */
end_comment

begin_function
specifier|static
name|int
name|ti_mmchs_write_ivar
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|which
parameter_list|,
name|uintptr_t
name|value
parameter_list|)
block|{
name|struct
name|ti_mmchs_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|bus
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|which
condition|)
block|{
case|case
name|MMCBR_IVAR_BUS_MODE
case|:
name|sc
operator|->
name|host
operator|.
name|ios
operator|.
name|bus_mode
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|MMCBR_IVAR_BUS_WIDTH
case|:
name|sc
operator|->
name|host
operator|.
name|ios
operator|.
name|bus_width
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|MMCBR_IVAR_CHIP_SELECT
case|:
name|sc
operator|->
name|host
operator|.
name|ios
operator|.
name|chip_select
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|MMCBR_IVAR_CLOCK
case|:
name|sc
operator|->
name|host
operator|.
name|ios
operator|.
name|clock
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|MMCBR_IVAR_MODE
case|:
name|sc
operator|->
name|host
operator|.
name|mode
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|MMCBR_IVAR_OCR
case|:
name|sc
operator|->
name|host
operator|.
name|ocr
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|MMCBR_IVAR_POWER_MODE
case|:
name|sc
operator|->
name|host
operator|.
name|ios
operator|.
name|power_mode
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|MMCBR_IVAR_VDD
case|:
name|sc
operator|->
name|host
operator|.
name|ios
operator|.
name|vdd
operator|=
name|value
expr_stmt|;
break|break;
comment|/* These are read-only */
case|case
name|MMCBR_IVAR_CAPS
case|:
case|case
name|MMCBR_IVAR_HOST_OCR
case|:
case|case
name|MMCBR_IVAR_F_MIN
case|:
case|case
name|MMCBR_IVAR_F_MAX
case|:
case|case
name|MMCBR_IVAR_MAX_DATA
case|:
return|return
operator|(
name|EINVAL
operator|)
return|;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	ti_mmchs_hw_init - initialises the MMC/SD/SIO controller  *	@dev: mmc device handle  *  *	Called by the driver attach function during driver initialisation. This  *	function is responsibly to setup the controller ready for transactions.  *  *	LOCKING:  *	No locking, assumed to only be called during initialisation.  *  *	RETURNS:  *	nothing  */
end_comment

begin_function
specifier|static
name|void
name|ti_mmchs_hw_init
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ti_mmchs_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|clk_ident_t
name|clk
decl_stmt|;
name|unsigned
name|long
name|timeout
decl_stmt|;
name|uint32_t
name|sysctl
decl_stmt|;
name|uint32_t
name|capa
decl_stmt|;
name|uint32_t
name|con
decl_stmt|;
comment|/* 1: Enable the controller and interface/functional clocks */
name|clk
operator|=
name|MMC0_CLK
operator|+
name|sc
operator|->
name|device_id
expr_stmt|;
if|if
condition|(
name|ti_prcm_clk_enable
argument_list|(
name|clk
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Error: failed to enable MMC clock\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 1a: Get the frequency of the source clock */
if|if
condition|(
name|ti_prcm_clk_get_source_freq
argument_list|(
name|clk
argument_list|,
operator|&
name|sc
operator|->
name|sc_ref_freq
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Error: failed to get source clock freq\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 2: Issue a softreset to the controller */
name|ti_mmchs_write_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_SYSCONFIG
argument_list|,
literal|0x0002
argument_list|)
expr_stmt|;
name|timeout
operator|=
literal|100
expr_stmt|;
while|while
condition|(
operator|(
name|ti_mmchs_read_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_SYSSTATUS
argument_list|)
operator|&
literal|0x01
operator|)
operator|==
literal|0x0
condition|)
block|{
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|timeout
operator|--
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Error: reset operation timed out\n"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 3: Reset both the command and data state machines */
name|sysctl
operator|=
name|ti_mmchs_read_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_SYSCTL
argument_list|)
expr_stmt|;
name|ti_mmchs_write_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_SYSCTL
argument_list|,
name|sysctl
operator||
name|MMCHS_SYSCTL_SRA
argument_list|)
expr_stmt|;
name|timeout
operator|=
literal|100
expr_stmt|;
while|while
condition|(
operator|(
name|ti_mmchs_read_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_SYSCTL
argument_list|)
operator|&
name|MMCHS_SYSCTL_SRA
operator|)
operator|!=
literal|0x0
condition|)
block|{
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|timeout
operator|--
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Error: reset operation timed out\n"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 4: Set initial host configuration (1-bit mode, pwroff) and capabilities */
name|ti_mmchs_write_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_HCTL
argument_list|,
name|MMCHS_HCTL_SDVS_V30
argument_list|)
expr_stmt|;
name|capa
operator|=
name|ti_mmchs_read_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_CAPA
argument_list|)
expr_stmt|;
name|ti_mmchs_write_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_CAPA
argument_list|,
name|capa
operator||
name|MMCHS_CAPA_VS30
operator||
name|MMCHS_CAPA_VS18
argument_list|)
expr_stmt|;
comment|/* 5: Set the initial bus configuration 	 *       0  CTPL_MMC_SD      : Control Power for DAT1 line 	 *       0  WPP_ACTIVE_HIGH  : Write protect polarity 	 *       0  CDP_ACTIVE_HIGH  : Card detect polarity 	 *       0  CTO_ENABLED      : MMC interrupt command 	 *       0  DW8_DISABLED     : 8-bit mode MMC select 	 *       0  MODE_FUNC        : Mode select 	 *       0  STREAM_DISABLED  : Stream command 	 *       0  HR_DISABLED      : Broadcast host response 	 *       0  INIT_DISABLED    : Send initialization stream 	 *       0  OD_DISABLED      : No Open Drain 	 */
name|con
operator|=
name|ti_mmchs_read_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_CON
argument_list|)
operator|&
name|MMCHS_CON_DVAL_MASK
expr_stmt|;
name|ti_mmchs_write_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_CON
argument_list|,
name|con
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	ti_mmchs_fini - shutdown the MMC/SD/SIO controller  *	@dev: mmc device handle  *  *	Responsible for shutting done the MMC controller, this function may be  *	called as part of a reset sequence.  *  *	LOCKING:  *	No locking, assumed to be called during tear-down/reset.  *  *	RETURNS:  *	nothing  */
end_comment

begin_function
specifier|static
name|void
name|ti_mmchs_hw_fini
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ti_mmchs_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
comment|/* Disable all interrupts */
name|ti_mmchs_write_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_ISE
argument_list|,
literal|0x00000000
argument_list|)
expr_stmt|;
name|ti_mmchs_write_4
argument_list|(
name|sc
argument_list|,
name|MMCHS_IE
argument_list|,
literal|0x00000000
argument_list|)
expr_stmt|;
comment|/* Disable the functional and interface clocks */
name|ti_prcm_clk_disable
argument_list|(
name|MMC0_CLK
operator|+
name|sc
operator|->
name|device_id
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	ti_mmchs_init_dma_channels - initalise the DMA channels  *	@sc: driver soft context  *  *	Attempts to activate an RX and TX DMA channel for the MMC device.  *  *	LOCKING:  *	No locking, assumed to be called during tear-down/reset.  *  *	RETURNS:  *	0 on success, a negative error code on failure.  */
end_comment

begin_function
specifier|static
name|int
name|ti_mmchs_init_dma_channels
parameter_list|(
name|struct
name|ti_mmchs_softc
modifier|*
name|sc
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SOC_TI_AM335X
switch|switch
condition|(
name|sc
operator|->
name|device_id
condition|)
block|{
case|case
literal|0
case|:
name|sc
operator|->
name|dma_tx_trig
operator|=
name|TI_EDMA3_EVENT_SDTXEVT0
expr_stmt|;
name|sc
operator|->
name|dma_rx_trig
operator|=
name|TI_EDMA3_EVENT_SDRXEVT0
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|sc
operator|->
name|dma_tx_trig
operator|=
name|TI_EDMA3_EVENT_SDTXEVT1
expr_stmt|;
name|sc
operator|->
name|dma_rx_trig
operator|=
name|TI_EDMA3_EVENT_SDRXEVT1
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
define|#
directive|define
name|EVTQNUM
value|0
comment|/* TODO EDMA3 have 3 queues, so we need some queue allocation call */
name|ti_edma3_init
argument_list|(
name|EVTQNUM
argument_list|)
expr_stmt|;
name|ti_edma3_request_dma_ch
argument_list|(
name|sc
operator|->
name|dma_tx_trig
argument_list|,
name|sc
operator|->
name|dma_tx_trig
argument_list|,
name|EVTQNUM
argument_list|)
expr_stmt|;
name|ti_edma3_request_dma_ch
argument_list|(
name|sc
operator|->
name|dma_rx_trig
argument_list|,
name|sc
operator|->
name|dma_rx_trig
argument_list|,
name|EVTQNUM
argument_list|)
expr_stmt|;
else|#
directive|else
name|int
name|err
decl_stmt|;
name|uint32_t
name|rev
decl_stmt|;
comment|/* Get the current chip revision */
name|rev
operator|=
name|ti_revision
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|OMAP_REV_DEVICE
argument_list|(
name|rev
argument_list|)
operator|!=
name|OMAP4430_DEV
operator|)
operator|&&
operator|(
name|sc
operator|->
name|device_id
operator|>
literal|3
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Get the DMA MMC triggers */
switch|switch
condition|(
name|sc
operator|->
name|device_id
condition|)
block|{
case|case
literal|1
case|:
name|sc
operator|->
name|dma_tx_trig
operator|=
literal|60
expr_stmt|;
name|sc
operator|->
name|dma_rx_trig
operator|=
literal|61
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|sc
operator|->
name|dma_tx_trig
operator|=
literal|46
expr_stmt|;
name|sc
operator|->
name|dma_rx_trig
operator|=
literal|47
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|sc
operator|->
name|dma_tx_trig
operator|=
literal|76
expr_stmt|;
name|sc
operator|->
name|dma_rx_trig
operator|=
literal|77
expr_stmt|;
break|break;
comment|/* The following are OMAP4 only */
case|case
literal|4
case|:
name|sc
operator|->
name|dma_tx_trig
operator|=
literal|56
expr_stmt|;
name|sc
operator|->
name|dma_rx_trig
operator|=
literal|57
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|sc
operator|->
name|dma_tx_trig
operator|=
literal|58
expr_stmt|;
name|sc
operator|->
name|dma_rx_trig
operator|=
literal|59
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Activate a RX channel from the OMAP DMA driver */
name|err
operator|=
name|ti_sdma_activate_channel
argument_list|(
operator|&
name|sc
operator|->
name|sc_dmach_rd
argument_list|,
name|ti_mmchs_dma_intr
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* Setup the RX channel for MMC data transfers */
name|ti_sdma_set_xfer_burst
argument_list|(
name|sc
operator|->
name|sc_dmach_rd
argument_list|,
name|TI_SDMA_BURST_NONE
argument_list|,
name|TI_SDMA_BURST_64
argument_list|)
expr_stmt|;
name|ti_sdma_set_xfer_data_type
argument_list|(
name|sc
operator|->
name|sc_dmach_rd
argument_list|,
name|TI_SDMA_DATA_32BITS_SCALAR
argument_list|)
expr_stmt|;
name|ti_sdma_sync_params
argument_list|(
name|sc
operator|->
name|sc_dmach_rd
argument_list|,
name|sc
operator|->
name|dma_rx_trig
argument_list|,
name|TI_SDMA_SYNC_PACKET
operator||
name|TI_SDMA_SYNC_TRIG_ON_SRC
argument_list|)
expr_stmt|;
name|ti_sdma_set_addr_mode
argument_list|(
name|sc
operator|->
name|sc_dmach_rd
argument_list|,
name|TI_SDMA_ADDR_CONSTANT
argument_list|,
name|TI_SDMA_ADDR_POST_INCREMENT
argument_list|)
expr_stmt|;
comment|/* Activate and configure the TX DMA channel */
name|err
operator|=
name|ti_sdma_activate_channel
argument_list|(
operator|&
name|sc
operator|->
name|sc_dmach_wr
argument_list|,
name|ti_mmchs_dma_intr
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* Setup the TX channel for MMC data transfers */
name|ti_sdma_set_xfer_burst
argument_list|(
name|sc
operator|->
name|sc_dmach_wr
argument_list|,
name|TI_SDMA_BURST_64
argument_list|,
name|TI_SDMA_BURST_NONE
argument_list|)
expr_stmt|;
name|ti_sdma_set_xfer_data_type
argument_list|(
name|sc
operator|->
name|sc_dmach_wr
argument_list|,
name|TI_SDMA_DATA_32BITS_SCALAR
argument_list|)
expr_stmt|;
name|ti_sdma_sync_params
argument_list|(
name|sc
operator|->
name|sc_dmach_wr
argument_list|,
name|sc
operator|->
name|dma_tx_trig
argument_list|,
name|TI_SDMA_SYNC_PACKET
operator||
name|TI_SDMA_SYNC_TRIG_ON_DST
argument_list|)
expr_stmt|;
name|ti_sdma_set_addr_mode
argument_list|(
name|sc
operator|->
name|sc_dmach_wr
argument_list|,
name|TI_SDMA_ADDR_POST_INCREMENT
argument_list|,
name|TI_SDMA_ADDR_CONSTANT
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	ti_mmchs_deactivate - deactivates the driver  *	@dev: mmc device handle  *  *	Unmaps the register set and releases the IRQ resource.  *  *	LOCKING:  *	None required  *  *	RETURNS:  *	nothing  */
end_comment

begin_function
specifier|static
name|void
name|ti_mmchs_deactivate
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ti_mmchs_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
comment|/* Remove the IRQ handler */
if|if
condition|(
name|sc
operator|->
name|sc_irq_h
operator|!=
name|NULL
condition|)
block|{
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|sc_irq_res
argument_list|,
name|sc
operator|->
name|sc_irq_h
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_irq_h
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Do the generic detach */
name|bus_generic_detach
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SOC_TI_AM335X
name|printf
argument_list|(
literal|"%s: DMA unimplemented\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Deactivate the DMA channels */
name|ti_sdma_deactivate_channel
argument_list|(
name|sc
operator|->
name|sc_dmach_rd
argument_list|)
expr_stmt|;
name|ti_sdma_deactivate_channel
argument_list|(
name|sc
operator|->
name|sc_dmach_wr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Unmap the MMC controller registers */
if|if
condition|(
name|sc
operator|->
name|sc_mem_res
operator|!=
literal|0
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|rman_get_rid
argument_list|(
name|sc
operator|->
name|sc_irq_res
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_mem_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_mem_res
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Release the IRQ resource */
if|if
condition|(
name|sc
operator|->
name|sc_irq_res
operator|!=
name|NULL
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|rman_get_rid
argument_list|(
name|sc
operator|->
name|sc_irq_res
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_irq_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_irq_res
operator|=
name|NULL
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/**  *	ti_mmchs_activate - activates the driver  *	@dev: mmc device handle  *  *	Maps in the register set and requests an IRQ handler for the MMC controller.  *  *	LOCKING:  *	None required  *  *	RETURNS:  *	0 on sucess  *	ENOMEM if failed to map register set  */
end_comment

begin_function
specifier|static
name|int
name|ti_mmchs_activate
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ti_mmchs_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|addr
decl_stmt|;
name|int
name|rid
decl_stmt|;
name|int
name|err
decl_stmt|;
comment|/* Get the memory resource for the register mapping */
name|rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_mem_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_mem_res
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"%s: Cannot map registers"
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Allocate an IRQ resource for the MMC controller */
name|rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_irq_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
operator||
name|RF_SHAREABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_irq_res
operator|==
name|NULL
condition|)
goto|goto
name|errout
goto|;
comment|/* Allocate DMA tags and maps */
name|err
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|MAXPHYS
argument_list|,
literal|1
argument_list|,
name|MAXPHYS
argument_list|,
name|BUS_DMA_ALLOCNOW
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|sc
operator|->
name|sc_dmatag
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
goto|goto
name|errout
goto|;
name|err
operator|=
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|sc_dmatag
argument_list|,
literal|0
argument_list|,
operator|&
name|sc
operator|->
name|sc_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
goto|goto
name|errout
goto|;
comment|/* Initialise the DMA channels to be used by the controller */
name|err
operator|=
name|ti_mmchs_init_dma_channels
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
goto|goto
name|errout
goto|;
comment|/* Set the register offset */
if|if
condition|(
name|ti_chip
argument_list|()
operator|==
name|CHIP_OMAP_3
condition|)
name|sc
operator|->
name|sc_reg_off
operator|=
name|OMAP3_MMCHS_REG_OFFSET
expr_stmt|;
elseif|else
if|if
condition|(
name|ti_chip
argument_list|()
operator|==
name|CHIP_OMAP_4
condition|)
name|sc
operator|->
name|sc_reg_off
operator|=
name|OMAP4_MMCHS_REG_OFFSET
expr_stmt|;
elseif|else
if|if
condition|(
name|ti_chip
argument_list|()
operator|==
name|CHIP_AM335X
condition|)
name|sc
operator|->
name|sc_reg_off
operator|=
name|AM335X_MMCHS_REG_OFFSET
expr_stmt|;
else|else
name|panic
argument_list|(
literal|"Unknown OMAP device\n"
argument_list|)
expr_stmt|;
comment|/* Get the physical address of the MMC data register, needed for DMA */
name|addr
operator|=
name|vtophys
argument_list|(
name|rman_get_start
argument_list|(
name|sc
operator|->
name|sc_mem_res
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_data_reg_paddr
operator|=
name|addr
operator|+
name|sc
operator|->
name|sc_reg_off
operator|+
name|MMCHS_DATA
expr_stmt|;
comment|/* Set the initial power state to off */
name|sc
operator|->
name|sc_cur_power_mode
operator|=
name|power_off
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|errout
label|:
name|ti_mmchs_deactivate
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	ti_mmchs_probe - probe function for the driver  *	@dev: mmc device handle  *  *  *  *	RETURNS:  *	always returns 0  */
end_comment

begin_function
specifier|static
name|int
name|ti_mmchs_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ofw_bus_is_compatible
argument_list|(
name|dev
argument_list|,
literal|"ti,mmchs"
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"TI MMC/SD/SDIO High Speed Interface"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	ti_mmchs_attach - attach function for the driver  *	@dev: mmc device handle  *  *	Driver initialisation, sets-up the bus mappings, DMA mapping/channels and  *	the actual controller by calling ti_mmchs_init().  *  *	RETURNS:  *	Returns 0 on success or a negative error code.  */
end_comment

begin_function
specifier|static
name|int
name|ti_mmchs_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|ti_mmchs_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|unit
init|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|phandle_t
name|node
decl_stmt|;
name|pcell_t
name|did
decl_stmt|;
name|int
name|err
decl_stmt|;
comment|/* Save the device and bus tag */
name|sc
operator|->
name|sc_dev
operator|=
name|dev
expr_stmt|;
comment|/* Get the mmchs device id from FDT */
name|node
operator|=
name|ofw_bus_get_node
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|OF_getprop
argument_list|(
name|node
argument_list|,
literal|"mmchs-device-id"
argument_list|,
operator|&
name|did
argument_list|,
sizeof|sizeof
argument_list|(
name|did
argument_list|)
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"missing mmchs-device-id attribute in FDT\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|sc
operator|->
name|device_id
operator|=
name|fdt32_to_cpu
argument_list|(
name|did
argument_list|)
expr_stmt|;
comment|/* Initiate the mtex lock */
name|TI_MMCHS_LOCK_INIT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Indicate the DMA channels haven't yet been allocated */
name|sc
operator|->
name|sc_dmach_rd
operator|=
operator|(
name|unsigned
name|int
operator|)
operator|-
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_dmach_wr
operator|=
operator|(
name|unsigned
name|int
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* Get the hint'ed write detect pin */
comment|/* TODO: take this from FDT */
if|if
condition|(
name|resource_int_value
argument_list|(
literal|"ti_mmchs"
argument_list|,
name|unit
argument_list|,
literal|"wp_gpio"
argument_list|,
operator|&
name|sc
operator|->
name|sc_wp_gpio_pin
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_wp_gpio_pin
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Get the GPIO device, we need this for the write protect pin */
name|sc
operator|->
name|sc_gpio_dev
operator|=
name|devclass_get_device
argument_list|(
name|devclass_find
argument_list|(
literal|"gpio"
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_gpio_dev
operator|==
name|NULL
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Error: failed to get the GPIO device\n"
argument_list|)
expr_stmt|;
else|else
name|GPIO_PIN_SETFLAGS
argument_list|(
name|sc
operator|->
name|sc_gpio_dev
argument_list|,
name|sc
operator|->
name|sc_wp_gpio_pin
argument_list|,
name|GPIO_PIN_INPUT
argument_list|)
expr_stmt|;
block|}
comment|/* Get the TWL voltage regulator device, we need this to for setting the 	 * voltage of the bus on certain OMAP platforms. 	 */
name|sc
operator|->
name|sc_vreg_name
operator|=
name|NULL
expr_stmt|;
comment|/* TODO: add voltage regulator knob to FDT */
ifdef|#
directive|ifdef
name|notyet
name|sc
operator|->
name|sc_vreg_dev
operator|=
name|devclass_get_device
argument_list|(
name|devclass_find
argument_list|(
literal|"twl_vreg"
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_vreg_dev
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Error: failed to get the votlage regulator"
literal|" device\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_vreg_name
operator|=
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Activate the device */
name|err
operator|=
name|ti_mmchs_activate
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
comment|/* Initialise the controller */
name|ti_mmchs_hw_init
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Activate the interrupt and attach a handler */
name|err
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|sc_irq_res
argument_list|,
name|INTR_TYPE_MISC
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|ti_mmchs_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_irq_h
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* Add host details */
name|sc
operator|->
name|host
operator|.
name|f_min
operator|=
name|sc
operator|->
name|sc_ref_freq
operator|/
literal|1023
expr_stmt|;
name|sc
operator|->
name|host
operator|.
name|f_max
operator|=
name|sc
operator|->
name|sc_ref_freq
expr_stmt|;
name|sc
operator|->
name|host
operator|.
name|host_ocr
operator|=
name|MMC_OCR_290_300
operator||
name|MMC_OCR_300_310
expr_stmt|;
name|sc
operator|->
name|host
operator|.
name|caps
operator|=
name|MMC_CAP_4_BIT_DATA
operator||
name|MMC_CAP_8_BIT_DATA
expr_stmt|;
name|device_add_child
argument_list|(
name|dev
argument_list|,
literal|"mmc"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|device_set_ivars
argument_list|(
name|dev
argument_list|,
operator|&
name|sc
operator|->
name|host
argument_list|)
expr_stmt|;
name|err
operator|=
name|bus_generic_attach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|err
condition|)
block|{
name|TI_MMCHS_LOCK_DESTROY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ti_mmchs_deactivate
argument_list|(
name|dev
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SOC_TI_AM335X
name|printf
argument_list|(
literal|"%s: DMA unimplemented\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|sc
operator|->
name|sc_dmach_rd
operator|!=
operator|(
name|unsigned
name|int
operator|)
operator|-
literal|1
condition|)
name|ti_sdma_deactivate_channel
argument_list|(
name|sc
operator|->
name|sc_dmach_rd
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dmach_wr
operator|!=
operator|(
name|unsigned
name|int
operator|)
operator|-
literal|1
condition|)
name|ti_sdma_deactivate_channel
argument_list|(
name|sc
operator|->
name|sc_dmach_wr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	ti_mmchs_detach - dettach function for the driver  *	@dev: mmc device handle  *  *	Shutdowns the controll and release resources allocated by the driver.  *  *	RETURNS:  *	Always returns 0.  */
end_comment

begin_function
specifier|static
name|int
name|ti_mmchs_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|SOC_TI_AM335X
name|struct
name|ti_mmchs_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|ti_mmchs_hw_fini
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ti_mmchs_deactivate
argument_list|(
name|dev
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SOC_TI_AM335X
name|printf
argument_list|(
literal|"%s: DMA unimplemented\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
else|#
directive|else
name|ti_sdma_deactivate_channel
argument_list|(
name|sc
operator|->
name|sc_dmach_wr
argument_list|)
expr_stmt|;
name|ti_sdma_deactivate_channel
argument_list|(
name|sc
operator|->
name|sc_dmach_rd
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|ti_mmchs_methods
index|[]
init|=
block|{
comment|/* device_if */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|ti_mmchs_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|ti_mmchs_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|ti_mmchs_detach
argument_list|)
block|,
comment|/* Bus interface */
name|DEVMETHOD
argument_list|(
name|bus_read_ivar
argument_list|,
name|ti_mmchs_read_ivar
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_write_ivar
argument_list|,
name|ti_mmchs_write_ivar
argument_list|)
block|,
comment|/* mmcbr_if - MMC state machine callbacks */
name|DEVMETHOD
argument_list|(
name|mmcbr_update_ios
argument_list|,
name|ti_mmchs_update_ios
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|mmcbr_request
argument_list|,
name|ti_mmchs_request
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|mmcbr_get_ro
argument_list|,
name|ti_mmchs_get_ro
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|mmcbr_acquire_host
argument_list|,
name|ti_mmchs_acquire_host
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|mmcbr_release_host
argument_list|,
name|ti_mmchs_release_host
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|ti_mmchs_driver
init|=
block|{
literal|"ti_mmchs"
block|,
name|ti_mmchs_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ti_mmchs_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|ti_mmchs_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|ti_mmchs
argument_list|,
name|simplebus
argument_list|,
name|ti_mmchs_driver
argument_list|,
name|ti_mmchs_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|ti_mmchs
argument_list|,
name|ti_prcm
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SOC_TI_AM335X
end_ifdef

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|ti_mmchs
argument_list|,
name|ti_edma
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|ti_mmchs
argument_list|,
name|ti_sdma
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|ti_mmchs
argument_list|,
name|ti_gpio
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* FIXME: MODULE_DEPEND(ti_mmchs, twl_vreg, 1, 1, 1); */
end_comment

end_unit

