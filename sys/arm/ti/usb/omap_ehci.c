begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2011  *	Ben Gray<ben.r.gray@gmail.com>.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/condvar.h>
end_include

begin_include
include|#
directive|include
file|<dev/fdt/simplebus.h>
end_include

begin_include
include|#
directive|include
file|<dev/fdt/fdt_common.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/ofw_bus_subr.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_core.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_busdma.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_process.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_util.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_controller.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_bus.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/controller/ehci.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/controller/ehcireg.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<arm/ti/ti_prcm.h>
end_include

begin_include
include|#
directive|include
file|<arm/ti/usb/omap_usb.h>
end_include

begin_include
include|#
directive|include
file|<arm/ti/omap4/pandaboard/pandaboard.h>
end_include

begin_comment
comment|/* EHCI */
end_comment

begin_define
define|#
directive|define
name|OMAP_USBHOST_HCCAPBASE
value|0x0000
end_define

begin_define
define|#
directive|define
name|OMAP_USBHOST_HCSPARAMS
value|0x0004
end_define

begin_define
define|#
directive|define
name|OMAP_USBHOST_HCCPARAMS
value|0x0008
end_define

begin_define
define|#
directive|define
name|OMAP_USBHOST_USBCMD
value|0x0010
end_define

begin_define
define|#
directive|define
name|OMAP_USBHOST_USBSTS
value|0x0014
end_define

begin_define
define|#
directive|define
name|OMAP_USBHOST_USBINTR
value|0x0018
end_define

begin_define
define|#
directive|define
name|OMAP_USBHOST_FRINDEX
value|0x001C
end_define

begin_define
define|#
directive|define
name|OMAP_USBHOST_CTRLDSSEGMENT
value|0x0020
end_define

begin_define
define|#
directive|define
name|OMAP_USBHOST_PERIODICLISTBASE
value|0x0024
end_define

begin_define
define|#
directive|define
name|OMAP_USBHOST_ASYNCLISTADDR
value|0x0028
end_define

begin_define
define|#
directive|define
name|OMAP_USBHOST_CONFIGFLAG
value|0x0050
end_define

begin_define
define|#
directive|define
name|OMAP_USBHOST_PORTSC
parameter_list|(
name|i
parameter_list|)
value|(0x0054 + (0x04 * (i)))
end_define

begin_define
define|#
directive|define
name|OMAP_USBHOST_INSNREG00
value|0x0090
end_define

begin_define
define|#
directive|define
name|OMAP_USBHOST_INSNREG01
value|0x0094
end_define

begin_define
define|#
directive|define
name|OMAP_USBHOST_INSNREG02
value|0x0098
end_define

begin_define
define|#
directive|define
name|OMAP_USBHOST_INSNREG03
value|0x009C
end_define

begin_define
define|#
directive|define
name|OMAP_USBHOST_INSNREG04
value|0x00A0
end_define

begin_define
define|#
directive|define
name|OMAP_USBHOST_INSNREG05_UTMI
value|0x00A4
end_define

begin_define
define|#
directive|define
name|OMAP_USBHOST_INSNREG05_ULPI
value|0x00A4
end_define

begin_define
define|#
directive|define
name|OMAP_USBHOST_INSNREG06
value|0x00A8
end_define

begin_define
define|#
directive|define
name|OMAP_USBHOST_INSNREG07
value|0x00AC
end_define

begin_define
define|#
directive|define
name|OMAP_USBHOST_INSNREG08
value|0x00B0
end_define

begin_define
define|#
directive|define
name|OMAP_USBHOST_INSNREG04_DISABLE_UNSUSPEND
value|(1<< 5)
end_define

begin_define
define|#
directive|define
name|OMAP_USBHOST_INSNREG05_ULPI_CONTROL_SHIFT
value|31
end_define

begin_define
define|#
directive|define
name|OMAP_USBHOST_INSNREG05_ULPI_PORTSEL_SHIFT
value|24
end_define

begin_define
define|#
directive|define
name|OMAP_USBHOST_INSNREG05_ULPI_OPSEL_SHIFT
value|22
end_define

begin_define
define|#
directive|define
name|OMAP_USBHOST_INSNREG05_ULPI_REGADD_SHIFT
value|16
end_define

begin_define
define|#
directive|define
name|OMAP_USBHOST_INSNREG05_ULPI_EXTREGADD_SHIFT
value|8
end_define

begin_define
define|#
directive|define
name|OMAP_USBHOST_INSNREG05_ULPI_WRDATA_SHIFT
value|0
end_define

begin_define
define|#
directive|define
name|ULPI_FUNC_CTRL_RESET
value|(1<< 5)
end_define

begin_comment
comment|/*-------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/*  * Macros for Set and Clear  * See ULPI 1.1 specification to find the registers with Set and Clear offsets  */
end_comment

begin_define
define|#
directive|define
name|ULPI_SET
parameter_list|(
name|a
parameter_list|)
value|(a + 1)
end_define

begin_define
define|#
directive|define
name|ULPI_CLR
parameter_list|(
name|a
parameter_list|)
value|(a + 2)
end_define

begin_comment
comment|/*-------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/*  * Register Map  */
end_comment

begin_define
define|#
directive|define
name|ULPI_VENDOR_ID_LOW
value|0x00
end_define

begin_define
define|#
directive|define
name|ULPI_VENDOR_ID_HIGH
value|0x01
end_define

begin_define
define|#
directive|define
name|ULPI_PRODUCT_ID_LOW
value|0x02
end_define

begin_define
define|#
directive|define
name|ULPI_PRODUCT_ID_HIGH
value|0x03
end_define

begin_define
define|#
directive|define
name|ULPI_FUNC_CTRL
value|0x04
end_define

begin_define
define|#
directive|define
name|ULPI_IFC_CTRL
value|0x07
end_define

begin_define
define|#
directive|define
name|ULPI_OTG_CTRL
value|0x0a
end_define

begin_define
define|#
directive|define
name|ULPI_USB_INT_EN_RISE
value|0x0d
end_define

begin_define
define|#
directive|define
name|ULPI_USB_INT_EN_FALL
value|0x10
end_define

begin_define
define|#
directive|define
name|ULPI_USB_INT_STS
value|0x13
end_define

begin_define
define|#
directive|define
name|ULPI_USB_INT_LATCH
value|0x14
end_define

begin_define
define|#
directive|define
name|ULPI_DEBUG
value|0x15
end_define

begin_define
define|#
directive|define
name|ULPI_SCRATCH
value|0x16
end_define

begin_define
define|#
directive|define
name|OMAP_EHCI_HC_DEVSTR
value|"TI OMAP USB 2.0 controller"
end_define

begin_struct
struct|struct
name|omap_ehci_softc
block|{
name|ehci_softc_t
name|base
decl_stmt|;
comment|/* storage for EHCI code */
name|device_t
name|sc_dev
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|device_attach_t
name|omap_ehci_attach
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_detach_t
name|omap_ehci_detach
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**  *	omap_ehci_read_4 - read a 32-bit value from the EHCI registers  *	omap_ehci_write_4 - write a 32-bit value from the EHCI registers  *	@sc: omap ehci device context  *	@off: byte offset within the register set to read from  *	@val: the value to write into the register  *	  *  *	LOCKING:  *	None  *  *	RETURNS:  *	nothing in case of write function, if read function returns the value read.  */
end_comment

begin_function
specifier|static
specifier|inline
name|uint32_t
name|omap_ehci_read_4
parameter_list|(
name|struct
name|omap_ehci_softc
modifier|*
name|sc
parameter_list|,
name|bus_size_t
name|off
parameter_list|)
block|{
return|return
operator|(
name|bus_read_4
argument_list|(
name|sc
operator|->
name|base
operator|.
name|sc_io_res
argument_list|,
name|off
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|omap_ehci_write_4
parameter_list|(
name|struct
name|omap_ehci_softc
modifier|*
name|sc
parameter_list|,
name|bus_size_t
name|off
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
name|bus_write_4
argument_list|(
name|sc
operator|->
name|base
operator|.
name|sc_io_res
argument_list|,
name|off
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  *	omap_ehci_soft_phy_reset - resets the phy using the reset command  *	@isc: omap ehci device context  *	@port: port to send the reset over  *	  *  *	LOCKING:  *	none  *  *	RETURNS:  *	nothing  */
end_comment

begin_function
specifier|static
name|void
name|omap_ehci_soft_phy_reset
parameter_list|(
name|struct
name|omap_ehci_softc
modifier|*
name|isc
parameter_list|,
name|unsigned
name|int
name|port
parameter_list|)
block|{
name|unsigned
name|long
name|timeout
init|=
operator|(
name|hz
operator|<
literal|10
operator|)
condition|?
literal|1
else|:
operator|(
operator|(
literal|100
operator|*
name|hz
operator|)
operator|/
literal|1000
operator|)
decl_stmt|;
name|uint32_t
name|reg
decl_stmt|;
name|reg
operator|=
name|ULPI_FUNC_CTRL_RESET
comment|/* FUNCTION_CTRL_SET register */
operator||
operator|(
name|ULPI_SET
argument_list|(
name|ULPI_FUNC_CTRL
argument_list|)
operator|<<
name|OMAP_USBHOST_INSNREG05_ULPI_REGADD_SHIFT
operator|)
comment|/* Write */
operator||
operator|(
literal|2
operator|<<
name|OMAP_USBHOST_INSNREG05_ULPI_OPSEL_SHIFT
operator|)
comment|/* PORTn */
operator||
operator|(
operator|(
name|port
operator|+
literal|1
operator|)
operator|<<
name|OMAP_USBHOST_INSNREG05_ULPI_PORTSEL_SHIFT
operator|)
comment|/* start ULPI access*/
operator||
operator|(
literal|1
operator|<<
name|OMAP_USBHOST_INSNREG05_ULPI_CONTROL_SHIFT
operator|)
expr_stmt|;
name|omap_ehci_write_4
argument_list|(
name|isc
argument_list|,
name|OMAP_USBHOST_INSNREG05_ULPI
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Wait for ULPI access completion */
while|while
condition|(
operator|(
name|omap_ehci_read_4
argument_list|(
name|isc
argument_list|,
name|OMAP_USBHOST_INSNREG05_ULPI
argument_list|)
operator|&
operator|(
literal|1
operator|<<
name|OMAP_USBHOST_INSNREG05_ULPI_CONTROL_SHIFT
operator|)
operator|)
condition|)
block|{
comment|/* Sleep for a tick */
name|pause
argument_list|(
literal|"USBPHY_RESET"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|timeout
operator|--
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|isc
operator|->
name|sc_dev
argument_list|,
literal|"PHY reset operation timed out\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  *	omap_ehci_init - initialises the USB host EHCI controller  *	@isc: omap ehci device context  *  *	This initialisation routine is quite heavily based on the work done by the  *	OMAP Linux team (for which I thank them very much).  The init sequence is  *	almost identical, diverging only for the FreeBSD specifics.  *  *	LOCKING:  *	none  *  *	RETURNS:  *	0 on success, a negative error code on failure.  */
end_comment

begin_function
specifier|static
name|int
name|omap_ehci_init
parameter_list|(
name|struct
name|omap_ehci_softc
modifier|*
name|isc
parameter_list|)
block|{
name|uint32_t
name|reg
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|device_t
name|uhh_dev
decl_stmt|;
name|uhh_dev
operator|=
name|device_get_parent
argument_list|(
name|isc
operator|->
name|sc_dev
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|isc
operator|->
name|sc_dev
argument_list|,
literal|"Starting TI EHCI USB Controller\n"
argument_list|)
expr_stmt|;
comment|/* Set the interrupt threshold control, it controls the maximum rate at 	 * which the host controller issues interrupts.  We set it to 1 microframe 	 * at startup - the default is 8 mircoframes (equates to 1ms). 	 */
name|reg
operator|=
name|omap_ehci_read_4
argument_list|(
name|isc
argument_list|,
name|OMAP_USBHOST_USBCMD
argument_list|)
expr_stmt|;
name|reg
operator|&=
literal|0xff00ffff
expr_stmt|;
name|reg
operator||=
operator|(
literal|1
operator|<<
literal|16
operator|)
expr_stmt|;
name|omap_ehci_write_4
argument_list|(
name|isc
argument_list|,
name|OMAP_USBHOST_USBCMD
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Soft reset the PHY using PHY reset command over ULPI */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|OMAP_HS_USB_PORTS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|omap_usb_port_mode
argument_list|(
name|uhh_dev
argument_list|,
name|i
argument_list|)
operator|==
name|EHCI_HCD_OMAP_MODE_PHY
condition|)
name|omap_ehci_soft_phy_reset
argument_list|(
name|isc
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	omap_ehci_probe - starts the given command  *	@dev:   *	  *	Effectively boilerplate EHCI resume code.  *  *	LOCKING:  *	Caller should be holding the OMAP3_MMC lock.  *  *	RETURNS:  *	EH_HANDLED or EH_NOT_HANDLED  */
end_comment

begin_function
specifier|static
name|int
name|omap_ehci_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ofw_bus_status_okay
argument_list|(
name|dev
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
operator|!
name|ofw_bus_is_compatible
argument_list|(
name|dev
argument_list|,
literal|"ti,ehci-omap"
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
name|OMAP_EHCI_HC_DEVSTR
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	omap_ehci_attach - driver entry point, sets up the ECHI controller/driver  *	@dev: the new device handle  *	  *	Sets up bus spaces, interrupt handles, etc for the EHCI controller.  It also  *	parses the resource hints and calls omap_ehci_init() to initialise the  *	H/W.  *  *	LOCKING:  *	none  *  *	RETURNS:  *	0 on success or a positive error code on failure.  */
end_comment

begin_function
specifier|static
name|int
name|omap_ehci_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|omap_ehci_softc
modifier|*
name|isc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|ehci_softc_t
modifier|*
name|sc
init|=
operator|&
name|isc
operator|->
name|base
decl_stmt|;
ifdef|#
directive|ifdef
name|SOC_OMAP4
name|phandle_t
name|root
decl_stmt|;
endif|#
directive|endif
name|int
name|err
decl_stmt|;
name|int
name|rid
decl_stmt|;
ifdef|#
directive|ifdef
name|SOC_OMAP4
comment|/*  	 * If we're running a Pandaboard, run Pandaboard-specific  	 * init code. 	 */
name|root
operator|=
name|OF_finddevice
argument_list|(
literal|"/"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ofw_bus_node_is_compatible
argument_list|(
name|root
argument_list|,
literal|"ti,omap4-panda"
argument_list|)
condition|)
name|pandaboard_usb_hub_init
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* initialise some bus fields */
name|sc
operator|->
name|sc_bus
operator|.
name|parent
operator|=
name|dev
expr_stmt|;
name|sc
operator|->
name|sc_bus
operator|.
name|devices
operator|=
name|sc
operator|->
name|sc_devices
expr_stmt|;
name|sc
operator|->
name|sc_bus
operator|.
name|devices_max
operator|=
name|EHCI_MAX_DEVICES
expr_stmt|;
name|sc
operator|->
name|sc_bus
operator|.
name|dma_bits
operator|=
literal|32
expr_stmt|;
name|sprintf
argument_list|(
name|sc
operator|->
name|sc_vendor
argument_list|,
literal|"Texas Instruments"
argument_list|)
expr_stmt|;
comment|/* save the device */
name|isc
operator|->
name|sc_dev
operator|=
name|dev
expr_stmt|;
comment|/* get all DMA memory */
if|if
condition|(
name|usb_bus_mem_alloc_all
argument_list|(
operator|&
name|sc
operator|->
name|sc_bus
argument_list|,
name|USB_GET_DMA_TAG
argument_list|(
name|dev
argument_list|)
argument_list|,
operator|&
name|ehci_iterate_hw_softc
argument_list|)
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* Allocate resource for the EHCI register set */
name|rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_io_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_io_res
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Error: Could not map EHCI memory\n"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* Request an interrupt resource */
name|rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_irq_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_irq_res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Error: could not allocate irq\n"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* Add this device as a child of the USBus device */
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
operator|=
name|device_add_child
argument_list|(
name|dev
argument_list|,
literal|"usbus"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Error: could not add USB device\n"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|device_set_ivars
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|,
operator|&
name|sc
operator|->
name|sc_bus
argument_list|)
expr_stmt|;
name|device_set_desc
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|,
name|OMAP_EHCI_HC_DEVSTR
argument_list|)
expr_stmt|;
comment|/* Initialise the ECHI registers */
name|err
operator|=
name|omap_ehci_init
argument_list|(
name|isc
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Error: could not setup OMAP EHCI, %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* Set the tag and size of the register set in the EHCI context */
name|sc
operator|->
name|sc_io_hdl
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|sc_io_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_io_tag
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|sc_io_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_io_size
operator|=
name|rman_get_size
argument_list|(
name|sc
operator|->
name|sc_io_res
argument_list|)
expr_stmt|;
comment|/* Setup the interrupt */
name|err
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|sc_irq_res
argument_list|,
name|INTR_TYPE_BIO
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
operator|(
name|driver_intr_t
operator|*
operator|)
name|ehci_interrupt
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_intr_hdl
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Error: could not setup irq, %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_intr_hdl
operator|=
name|NULL
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* Finally we are ready to kick off the ECHI host controller */
name|err
operator|=
name|ehci_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|err
operator|=
name|device_probe_and_attach
argument_list|(
name|sc
operator|->
name|sc_bus
operator|.
name|bdev
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Error: USB init failed err=%d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|error
label|:
name|omap_ehci_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  *	omap_ehci_detach - detach the device and cleanup the driver  *	@dev: device handle  *	  *	Clean-up routine where everything initialised in omap_ehci_attach is  *	freed and cleaned up.  This function calls omap_ehci_fini() to shutdown  *	the on-chip module.  *  *	LOCKING:  *	none  *  *	RETURNS:  *	Always returns 0 (success).  */
end_comment

begin_function
specifier|static
name|int
name|omap_ehci_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|omap_ehci_softc
modifier|*
name|isc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|ehci_softc_t
modifier|*
name|sc
init|=
operator|&
name|isc
operator|->
name|base
decl_stmt|;
name|int
name|err
decl_stmt|;
comment|/* during module unload there are lots of children leftover */
name|device_delete_children
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* 	 * disable interrupts that might have been switched on in ehci_init 	 */
if|if
condition|(
name|sc
operator|->
name|sc_io_res
condition|)
block|{
name|EWRITE4
argument_list|(
name|sc
argument_list|,
name|EHCI_USBINTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_irq_res
operator|&&
name|sc
operator|->
name|sc_intr_hdl
condition|)
block|{
comment|/* 		 * only call ehci_detach() after ehci_init() 		 */
name|ehci_detach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|err
operator|=
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|sc_irq_res
argument_list|,
name|sc
operator|->
name|sc_intr_hdl
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Error: could not tear down irq, %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_intr_hdl
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Free the resources stored in the base EHCI handler */
if|if
condition|(
name|sc
operator|->
name|sc_irq_res
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|sc_irq_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_irq_res
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_io_res
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|sc_io_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_io_res
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|ehci_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|omap_ehci_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|omap_ehci_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|omap_ehci_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|bus_generic_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|bus_generic_resume
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|bus_generic_shutdown
argument_list|)
block|,
comment|/* Bus interface */
name|DEVMETHOD
argument_list|(
name|bus_print_child
argument_list|,
name|bus_generic_print_child
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|ehci_driver
init|=
block|{
literal|"ehci"
block|,
name|ehci_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|omap_ehci_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|ehci_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|ehci
argument_list|,
name|omap_uhh
argument_list|,
name|ehci_driver
argument_list|,
name|ehci_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

