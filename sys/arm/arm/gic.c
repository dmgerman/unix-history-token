begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2011 The FreeBSD Foundation  * All rights reserved.  *  * Developed by Damjan Marion<damjan.marion@gmail.com>  *  * Based on OMAP4 GIC code by Ben Gray  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the company nor the name of the author may be used to  *    endorse or promote products derived from this software without specific  *    prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_platform.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/pcpu.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/cpuset.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INTRNG
end_ifdef

begin_include
include|#
directive|include
file|<sys/sched.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/intr.h>
end_include

begin_include
include|#
directive|include
file|<machine/smp.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|FDT
end_ifdef

begin_include
include|#
directive|include
file|<dev/fdt/fdt_intr.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/ofw_bus_subr.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<arm/arm/gic.h>
end_include

begin_include
include|#
directive|include
file|<arm/arm/gic_common.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INTRNG
end_ifdef

begin_include
include|#
directive|include
file|"pic_if.h"
end_include

begin_include
include|#
directive|include
file|"msi_if.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* We are using GICv2 register naming */
end_comment

begin_comment
comment|/* Distributor Registers */
end_comment

begin_comment
comment|/* CPU Registers */
end_comment

begin_define
define|#
directive|define
name|GICC_CTLR
value|0x0000
end_define

begin_comment
comment|/* v1 ICCICR */
end_comment

begin_define
define|#
directive|define
name|GICC_PMR
value|0x0004
end_define

begin_comment
comment|/* v1 ICCPMR */
end_comment

begin_define
define|#
directive|define
name|GICC_BPR
value|0x0008
end_define

begin_comment
comment|/* v1 ICCBPR */
end_comment

begin_define
define|#
directive|define
name|GICC_IAR
value|0x000C
end_define

begin_comment
comment|/* v1 ICCIAR */
end_comment

begin_define
define|#
directive|define
name|GICC_EOIR
value|0x0010
end_define

begin_comment
comment|/* v1 ICCEOIR */
end_comment

begin_define
define|#
directive|define
name|GICC_RPR
value|0x0014
end_define

begin_comment
comment|/* v1 ICCRPR */
end_comment

begin_define
define|#
directive|define
name|GICC_HPPIR
value|0x0018
end_define

begin_comment
comment|/* v1 ICCHPIR */
end_comment

begin_define
define|#
directive|define
name|GICC_ABPR
value|0x001C
end_define

begin_comment
comment|/* v1 ICCABPR */
end_comment

begin_define
define|#
directive|define
name|GICC_IIDR
value|0x00FC
end_define

begin_comment
comment|/* v1 ICCIIDR*/
end_comment

begin_comment
comment|/* TYPER Registers */
end_comment

begin_define
define|#
directive|define
name|GICD_TYPER_SECURITYEXT
value|0x400
end_define

begin_define
define|#
directive|define
name|GIC_SUPPORT_SECEXT
parameter_list|(
name|_sc
parameter_list|)
define|\
value|((_sc->typer& GICD_TYPER_SECURITYEXT) == GICD_TYPER_SECURITYEXT)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|GIC_DEFAULT_ICFGR_INIT
end_ifndef

begin_define
define|#
directive|define
name|GIC_DEFAULT_ICFGR_INIT
value|0x00000000
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|INTRNG
end_ifdef

begin_struct
struct|struct
name|gic_irqsrc
block|{
name|struct
name|intr_irqsrc
name|gi_isrc
decl_stmt|;
name|uint32_t
name|gi_irq
decl_stmt|;
name|enum
name|intr_polarity
name|gi_pol
decl_stmt|;
name|enum
name|intr_trigger
name|gi_trig
decl_stmt|;
define|#
directive|define
name|GI_FLAG_EARLY_EOI
value|(1<< 0)
define|#
directive|define
name|GI_FLAG_MSI
value|(1<< 1)
comment|/* This interrupt source should only */
comment|/* be used for MSI/MSI-X interrupts */
define|#
directive|define
name|GI_FLAG_MSI_USED
value|(1<< 2)
comment|/* This irq is already allocated */
comment|/* for a MSI/MSI-X interrupt */
name|u_int
name|gi_flags
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|u_int
name|gic_irq_cpu
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|arm_gic_bind_intr
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|intr_irqsrc
modifier|*
name|isrc
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|SMP
end_ifdef

begin_decl_stmt
specifier|static
name|u_int
name|sgi_to_ipi
index|[
name|GIC_LAST_SGI
operator|-
name|GIC_FIRST_SGI
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|sgi_first_unused
init|=
name|GIC_FIRST_SGI
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|GIC_INTR_ISRC
parameter_list|(
name|sc
parameter_list|,
name|irq
parameter_list|)
value|(&sc->gic_irqs[irq].gi_isrc)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !INTRNG */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ofw_compat_data
name|compat_data
index|[]
init|=
block|{
block|{
literal|"arm,gic"
block|,
name|true
block|}
block|,
comment|/* Non-standard, used in FreeBSD dts. */
block|{
literal|"arm,gic-400"
block|,
name|true
block|}
block|,
block|{
literal|"arm,cortex-a15-gic"
block|,
name|true
block|}
block|,
block|{
literal|"arm,cortex-a9-gic"
block|,
name|true
block|}
block|,
block|{
literal|"arm,cortex-a7-gic"
block|,
name|true
block|}
block|,
block|{
literal|"arm,arm11mp-gic"
block|,
name|true
block|}
block|,
block|{
literal|"brcm,brahma-b15-gic"
block|,
name|true
block|}
block|,
block|{
literal|"qcom,msm-qgic2"
block|,
name|true
block|}
block|,
block|{
name|NULL
block|,
name|false
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|resource_spec
name|arm_gic_spec
index|[]
init|=
block|{
block|{
name|SYS_RES_MEMORY
block|,
literal|0
block|,
name|RF_ACTIVE
block|}
block|,
comment|/* Distributor registers */
block|{
name|SYS_RES_MEMORY
block|,
literal|1
block|,
name|RF_ACTIVE
block|}
block|,
comment|/* CPU Interrupt Intf. registers */
ifdef|#
directive|ifdef
name|INTRNG
block|{
name|SYS_RES_IRQ
block|,
literal|0
block|,
name|RF_ACTIVE
operator||
name|RF_OPTIONAL
block|}
block|,
comment|/* Parent interrupt */
endif|#
directive|endif
block|{
operator|-
literal|1
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|arm_gic_map
index|[
name|MAXCPU
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|arm_gic_softc
modifier|*
name|gic_sc
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|gic_c_read_4
parameter_list|(
name|_sc
parameter_list|,
name|_reg
parameter_list|)
define|\
value|bus_space_read_4((_sc)->gic_c_bst, (_sc)->gic_c_bsh, (_reg))
end_define

begin_define
define|#
directive|define
name|gic_c_write_4
parameter_list|(
name|_sc
parameter_list|,
name|_reg
parameter_list|,
name|_val
parameter_list|)
define|\
value|bus_space_write_4((_sc)->gic_c_bst, (_sc)->gic_c_bsh, (_reg), (_val))
end_define

begin_define
define|#
directive|define
name|gic_d_read_4
parameter_list|(
name|_sc
parameter_list|,
name|_reg
parameter_list|)
define|\
value|bus_space_read_4((_sc)->gic_d_bst, (_sc)->gic_d_bsh, (_reg))
end_define

begin_define
define|#
directive|define
name|gic_d_write_1
parameter_list|(
name|_sc
parameter_list|,
name|_reg
parameter_list|,
name|_val
parameter_list|)
define|\
value|bus_space_write_1((_sc)->gic_d_bst, (_sc)->gic_d_bsh, (_reg), (_val))
end_define

begin_define
define|#
directive|define
name|gic_d_write_4
parameter_list|(
name|_sc
parameter_list|,
name|_reg
parameter_list|,
name|_val
parameter_list|)
define|\
value|bus_space_write_4((_sc)->gic_d_bst, (_sc)->gic_d_bsh, (_reg), (_val))
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|INTRNG
end_ifndef

begin_function_decl
specifier|static
name|int
name|gic_config_irq
parameter_list|(
name|int
name|irq
parameter_list|,
name|enum
name|intr_trigger
name|trig
parameter_list|,
name|enum
name|intr_polarity
name|pol
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gic_post_filter
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|INTRNG
end_ifdef

begin_function
specifier|static
specifier|inline
name|void
name|gic_irq_unmask
parameter_list|(
name|struct
name|arm_gic_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|irq
parameter_list|)
block|{
name|gic_d_write_4
argument_list|(
name|sc
argument_list|,
name|GICD_ISENABLER
argument_list|(
name|irq
argument_list|)
argument_list|,
name|GICD_I_MASK
argument_list|(
name|irq
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|gic_irq_mask
parameter_list|(
name|struct
name|arm_gic_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|irq
parameter_list|)
block|{
name|gic_d_write_4
argument_list|(
name|sc
argument_list|,
name|GICD_ICENABLER
argument_list|(
name|irq
argument_list|)
argument_list|,
name|GICD_I_MASK
argument_list|(
name|irq
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|uint8_t
name|gic_cpu_mask
parameter_list|(
name|struct
name|arm_gic_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|mask
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Read the current cpuid mask by reading ITARGETSR{0..7} */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|mask
operator|=
name|gic_d_read_4
argument_list|(
name|sc
argument_list|,
name|GICD_ITARGETSR
argument_list|(
literal|4
operator|*
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|!=
literal|0
condition|)
break|break;
block|}
comment|/* No mask found, assume we are on CPU interface 0 */
if|if
condition|(
name|mask
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Collect the mask in the lower byte */
name|mask
operator||=
name|mask
operator|>>
literal|16
expr_stmt|;
name|mask
operator||=
name|mask
operator|>>
literal|8
expr_stmt|;
return|return
operator|(
name|mask
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SMP
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|INTRNG
end_ifdef

begin_function
specifier|static
name|void
name|arm_gic_init_secondary
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|arm_gic_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u_int
name|irq
decl_stmt|,
name|cpu
decl_stmt|;
comment|/* Set the mask so we can find this CPU to send it IPIs */
name|cpu
operator|=
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
expr_stmt|;
name|arm_gic_map
index|[
name|cpu
index|]
operator|=
name|gic_cpu_mask
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|irq
operator|=
literal|0
init|;
name|irq
operator|<
name|sc
operator|->
name|nirqs
condition|;
name|irq
operator|+=
literal|4
control|)
name|gic_d_write_4
argument_list|(
name|sc
argument_list|,
name|GICD_IPRIORITYR
argument_list|(
name|irq
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set all the interrupts to be in Group 0 (secure) */
for|for
control|(
name|irq
operator|=
literal|0
init|;
name|GIC_SUPPORT_SECEXT
argument_list|(
name|sc
argument_list|)
operator|&&
name|irq
operator|<
name|sc
operator|->
name|nirqs
condition|;
name|irq
operator|+=
literal|32
control|)
block|{
name|gic_d_write_4
argument_list|(
name|sc
argument_list|,
name|GICD_IGROUPR
argument_list|(
name|irq
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Enable CPU interface */
name|gic_c_write_4
argument_list|(
name|sc
argument_list|,
name|GICC_CTLR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Set priority mask register. */
name|gic_c_write_4
argument_list|(
name|sc
argument_list|,
name|GICC_PMR
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* Enable interrupt distribution */
name|gic_d_write_4
argument_list|(
name|sc
argument_list|,
name|GICD_CTLR
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
comment|/* Unmask attached SGI interrupts. */
for|for
control|(
name|irq
operator|=
name|GIC_FIRST_SGI
init|;
name|irq
operator|<=
name|GIC_LAST_SGI
condition|;
name|irq
operator|++
control|)
if|if
condition|(
name|intr_isrc_init_on_cpu
argument_list|(
name|GIC_INTR_ISRC
argument_list|(
name|sc
argument_list|,
name|irq
argument_list|)
argument_list|,
name|cpu
argument_list|)
condition|)
name|gic_irq_unmask
argument_list|(
name|sc
argument_list|,
name|irq
argument_list|)
expr_stmt|;
comment|/* Unmask attached PPI interrupts. */
for|for
control|(
name|irq
operator|=
name|GIC_FIRST_PPI
init|;
name|irq
operator|<=
name|GIC_LAST_PPI
condition|;
name|irq
operator|++
control|)
if|if
condition|(
name|intr_isrc_init_on_cpu
argument_list|(
name|GIC_INTR_ISRC
argument_list|(
name|sc
argument_list|,
name|irq
argument_list|)
argument_list|,
name|cpu
argument_list|)
condition|)
name|gic_irq_unmask
argument_list|(
name|sc
argument_list|,
name|irq
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|void
name|arm_gic_init_secondary
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|arm_gic_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Set the mask so we can find this CPU to send it IPIs */
name|arm_gic_map
index|[
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
index|]
operator|=
name|gic_cpu_mask
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|nirqs
condition|;
name|i
operator|+=
literal|4
control|)
name|gic_d_write_4
argument_list|(
name|sc
argument_list|,
name|GICD_IPRIORITYR
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set all the interrupts to be in Group 0 (secure) */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|GIC_SUPPORT_SECEXT
argument_list|(
name|sc
argument_list|)
operator|&&
name|i
operator|<
name|sc
operator|->
name|nirqs
condition|;
name|i
operator|+=
literal|32
control|)
block|{
name|gic_d_write_4
argument_list|(
name|sc
argument_list|,
name|GICD_IGROUPR
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Enable CPU interface */
name|gic_c_write_4
argument_list|(
name|sc
argument_list|,
name|GICC_CTLR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Set priority mask register. */
name|gic_c_write_4
argument_list|(
name|sc
argument_list|,
name|GICC_PMR
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* Enable interrupt distribution */
name|gic_d_write_4
argument_list|(
name|sc
argument_list|,
name|GICD_CTLR
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
comment|/* 	 * Activate the timer interrupts: virtual, secure, and non-secure. 	 */
name|gic_d_write_4
argument_list|(
name|sc
argument_list|,
name|GICD_ISENABLER
argument_list|(
literal|27
argument_list|)
argument_list|,
name|GICD_I_MASK
argument_list|(
literal|27
argument_list|)
argument_list|)
expr_stmt|;
name|gic_d_write_4
argument_list|(
name|sc
argument_list|,
name|GICD_ISENABLER
argument_list|(
literal|29
argument_list|)
argument_list|,
name|GICD_I_MASK
argument_list|(
literal|29
argument_list|)
argument_list|)
expr_stmt|;
name|gic_d_write_4
argument_list|(
name|sc
argument_list|,
name|GICD_ISENABLER
argument_list|(
literal|30
argument_list|)
argument_list|,
name|GICD_I_MASK
argument_list|(
literal|30
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INTRNG */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SMP */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|INTRNG
end_ifndef

begin_function
name|int
name|gic_decode_fdt
parameter_list|(
name|phandle_t
name|iparent
parameter_list|,
name|pcell_t
modifier|*
name|intr
parameter_list|,
name|int
modifier|*
name|interrupt
parameter_list|,
name|int
modifier|*
name|trig
parameter_list|,
name|int
modifier|*
name|pol
parameter_list|)
block|{
specifier|static
name|u_int
name|num_intr_cells
decl_stmt|;
specifier|static
name|phandle_t
name|self
decl_stmt|;
name|struct
name|ofw_compat_data
modifier|*
name|ocd
decl_stmt|;
if|if
condition|(
name|self
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|ocd
operator|=
name|compat_data
init|;
name|ocd
operator|->
name|ocd_str
operator|!=
name|NULL
condition|;
name|ocd
operator|++
control|)
block|{
if|if
condition|(
name|ofw_bus_node_is_compatible
argument_list|(
name|iparent
argument_list|,
name|ocd
operator|->
name|ocd_str
argument_list|)
condition|)
block|{
name|self
operator|=
name|iparent
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|self
operator|!=
name|iparent
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|num_intr_cells
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|OF_searchencprop
argument_list|(
name|OF_node_from_xref
argument_list|(
name|iparent
argument_list|)
argument_list|,
literal|"#interrupt-cells"
argument_list|,
operator|&
name|num_intr_cells
argument_list|,
sizeof|sizeof
argument_list|(
name|num_intr_cells
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|num_intr_cells
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|num_intr_cells
operator|==
literal|1
condition|)
block|{
operator|*
name|interrupt
operator|=
name|fdt32_to_cpu
argument_list|(
name|intr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
operator|*
name|trig
operator|=
name|INTR_TRIGGER_CONFORM
expr_stmt|;
operator|*
name|pol
operator|=
name|INTR_POLARITY_CONFORM
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|fdt32_to_cpu
argument_list|(
name|intr
index|[
literal|0
index|]
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|interrupt
operator|=
name|fdt32_to_cpu
argument_list|(
name|intr
index|[
literal|1
index|]
argument_list|)
operator|+
name|GIC_FIRST_SPI
expr_stmt|;
else|else
operator|*
name|interrupt
operator|=
name|fdt32_to_cpu
argument_list|(
name|intr
index|[
literal|1
index|]
argument_list|)
operator|+
name|GIC_FIRST_PPI
expr_stmt|;
comment|/* 		 * In intr[2], bits[3:0] are trigger type and level flags. 		 *   1 = low-to-high edge triggered 		 *   2 = high-to-low edge triggered 		 *   4 = active high level-sensitive 		 *   8 = active low level-sensitive 		 * The hardware only supports active-high-level or rising-edge 		 * for SPIs 		 */
if|if
condition|(
operator|*
name|interrupt
operator|>=
name|GIC_FIRST_SPI
operator|&&
name|fdt32_to_cpu
argument_list|(
name|intr
index|[
literal|2
index|]
argument_list|)
operator|&
literal|0x0a
condition|)
block|{
name|printf
argument_list|(
literal|"unsupported trigger/polarity configuration "
literal|"0x%02x\n"
argument_list|,
name|fdt32_to_cpu
argument_list|(
name|intr
index|[
literal|2
index|]
argument_list|)
operator|&
literal|0x0f
argument_list|)
expr_stmt|;
block|}
operator|*
name|pol
operator|=
name|INTR_POLARITY_CONFORM
expr_stmt|;
if|if
condition|(
name|fdt32_to_cpu
argument_list|(
name|intr
index|[
literal|2
index|]
argument_list|)
operator|&
literal|0x03
condition|)
operator|*
name|trig
operator|=
name|INTR_TRIGGER_EDGE
expr_stmt|;
else|else
operator|*
name|trig
operator|=
name|INTR_TRIGGER_LEVEL
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|INTRNG
end_ifdef

begin_function
specifier|static
name|int
name|arm_gic_register_isrcs
parameter_list|(
name|struct
name|arm_gic_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|num
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|uint32_t
name|irq
decl_stmt|;
name|struct
name|gic_irqsrc
modifier|*
name|irqs
decl_stmt|;
name|struct
name|intr_irqsrc
modifier|*
name|isrc
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|irqs
operator|=
name|malloc
argument_list|(
name|num
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|gic_irqsrc
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|name
operator|=
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|gic_dev
argument_list|)
expr_stmt|;
for|for
control|(
name|irq
operator|=
literal|0
init|;
name|irq
operator|<
name|num
condition|;
name|irq
operator|++
control|)
block|{
name|irqs
index|[
name|irq
index|]
operator|.
name|gi_irq
operator|=
name|irq
expr_stmt|;
name|irqs
index|[
name|irq
index|]
operator|.
name|gi_pol
operator|=
name|INTR_POLARITY_CONFORM
expr_stmt|;
name|irqs
index|[
name|irq
index|]
operator|.
name|gi_trig
operator|=
name|INTR_TRIGGER_CONFORM
expr_stmt|;
name|isrc
operator|=
operator|&
name|irqs
index|[
name|irq
index|]
operator|.
name|gi_isrc
expr_stmt|;
if|if
condition|(
name|irq
operator|<=
name|GIC_LAST_SGI
condition|)
block|{
name|error
operator|=
name|intr_isrc_register
argument_list|(
name|isrc
argument_list|,
name|sc
operator|->
name|gic_dev
argument_list|,
name|INTR_ISRCF_IPI
argument_list|,
literal|"%s,i%u"
argument_list|,
name|name
argument_list|,
name|irq
operator|-
name|GIC_FIRST_SGI
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|irq
operator|<=
name|GIC_LAST_PPI
condition|)
block|{
name|error
operator|=
name|intr_isrc_register
argument_list|(
name|isrc
argument_list|,
name|sc
operator|->
name|gic_dev
argument_list|,
name|INTR_ISRCF_PPI
argument_list|,
literal|"%s,p%u"
argument_list|,
name|name
argument_list|,
name|irq
operator|-
name|GIC_FIRST_PPI
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|intr_isrc_register
argument_list|(
name|isrc
argument_list|,
name|sc
operator|->
name|gic_dev
argument_list|,
literal|0
argument_list|,
literal|"%s,s%u"
argument_list|,
name|name
argument_list|,
name|irq
operator|-
name|GIC_FIRST_SPI
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
comment|/* XXX call intr_isrc_deregister() */
name|free
argument_list|(
name|irqs
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
name|sc
operator|->
name|gic_irqs
operator|=
name|irqs
expr_stmt|;
name|sc
operator|->
name|nirqs
operator|=
name|num
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|arm_gic_reserve_msi_range
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int
name|start
parameter_list|,
name|u_int
name|count
parameter_list|)
block|{
name|struct
name|arm_gic_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|start
operator|+
name|count
operator|)
operator|<
name|sc
operator|->
name|nirqs
argument_list|,
operator|(
literal|"%s: Trying to allocate too many MSI IRQs: %d + %d> %d"
operator|,
name|__func__
operator|,
name|start
operator|,
name|count
operator|,
name|sc
operator|->
name|nirqs
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|KASSERT
argument_list|(
name|sc
operator|->
name|gic_irqs
index|[
name|start
operator|+
name|i
index|]
operator|.
name|gi_isrc
operator|.
name|isrc_handlers
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: MSI interrupt %d already has a handler"
operator|,
name|__func__
operator|,
name|count
operator|+
name|i
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|gic_irqs
index|[
name|start
operator|+
name|i
index|]
operator|.
name|gi_pol
operator|==
name|INTR_POLARITY_CONFORM
argument_list|,
operator|(
literal|"%s: MSI interrupt %d already has a polarity"
operator|,
name|__func__
operator|,
name|count
operator|+
name|i
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|gic_irqs
index|[
name|start
operator|+
name|i
index|]
operator|.
name|gi_trig
operator|==
name|INTR_TRIGGER_CONFORM
argument_list|,
operator|(
literal|"%s: MSI interrupt %d already has a trigger"
operator|,
name|__func__
operator|,
name|count
operator|+
name|i
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|gic_irqs
index|[
name|start
operator|+
name|i
index|]
operator|.
name|gi_pol
operator|=
name|INTR_POLARITY_HIGH
expr_stmt|;
name|sc
operator|->
name|gic_irqs
index|[
name|start
operator|+
name|i
index|]
operator|.
name|gi_trig
operator|=
name|INTR_TRIGGER_EDGE
expr_stmt|;
name|sc
operator|->
name|gic_irqs
index|[
name|start
operator|+
name|i
index|]
operator|.
name|gi_flags
operator||=
name|GI_FLAG_MSI
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|arm_gic_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|arm_gic_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint32_t
name|icciidr
decl_stmt|,
name|mask
decl_stmt|,
name|nirqs
decl_stmt|;
if|if
condition|(
name|gic_sc
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus_alloc_resources
argument_list|(
name|dev
argument_list|,
name|arm_gic_spec
argument_list|,
name|sc
operator|->
name|gic_res
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not allocate resources\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|sc
operator|->
name|gic_dev
operator|=
name|dev
expr_stmt|;
name|gic_sc
operator|=
name|sc
expr_stmt|;
comment|/* Initialize mutex */
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|mutex
argument_list|,
literal|"GIC lock"
argument_list|,
literal|""
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
comment|/* Distributor Interface */
name|sc
operator|->
name|gic_d_bst
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|gic_res
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|gic_d_bsh
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|gic_res
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* CPU Interface */
name|sc
operator|->
name|gic_c_bst
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|gic_res
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|gic_c_bsh
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|gic_res
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* Disable interrupt forwarding to the CPU interface */
name|gic_d_write_4
argument_list|(
name|sc
argument_list|,
name|GICD_CTLR
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* Get the number of interrupts */
name|sc
operator|->
name|typer
operator|=
name|gic_d_read_4
argument_list|(
name|sc
argument_list|,
name|GICD_TYPER
argument_list|)
expr_stmt|;
name|nirqs
operator|=
name|GICD_TYPER_I_NUM
argument_list|(
name|sc
operator|->
name|typer
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INTRNG
if|if
condition|(
name|arm_gic_register_isrcs
argument_list|(
name|sc
argument_list|,
name|nirqs
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not register irqs\n"
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
else|#
directive|else
name|sc
operator|->
name|nirqs
operator|=
name|nirqs
expr_stmt|;
comment|/* Set up function pointers */
name|arm_post_filter
operator|=
name|gic_post_filter
expr_stmt|;
name|arm_config_irq
operator|=
name|gic_config_irq
expr_stmt|;
endif|#
directive|endif
name|icciidr
operator|=
name|gic_c_read_4
argument_list|(
name|sc
argument_list|,
name|GICC_IIDR
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"pn 0x%x, arch 0x%x, rev 0x%x, implementer 0x%x irqs %u\n"
argument_list|,
name|GICD_IIDR_PROD
argument_list|(
name|icciidr
argument_list|)
argument_list|,
name|GICD_IIDR_VAR
argument_list|(
name|icciidr
argument_list|)
argument_list|,
name|GICD_IIDR_REV
argument_list|(
name|icciidr
argument_list|)
argument_list|,
name|GICD_IIDR_IMPL
argument_list|(
name|icciidr
argument_list|)
argument_list|,
name|sc
operator|->
name|nirqs
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INTRNG
name|sc
operator|->
name|gic_iidr
operator|=
name|icciidr
expr_stmt|;
endif|#
directive|endif
comment|/* Set all global interrupts to be level triggered, active low. */
for|for
control|(
name|i
operator|=
literal|32
init|;
name|i
operator|<
name|sc
operator|->
name|nirqs
condition|;
name|i
operator|+=
literal|16
control|)
block|{
name|gic_d_write_4
argument_list|(
name|sc
argument_list|,
name|GICD_ICFGR
argument_list|(
name|i
argument_list|)
argument_list|,
name|GIC_DEFAULT_ICFGR_INIT
argument_list|)
expr_stmt|;
block|}
comment|/* Disable all interrupts. */
for|for
control|(
name|i
operator|=
literal|32
init|;
name|i
operator|<
name|sc
operator|->
name|nirqs
condition|;
name|i
operator|+=
literal|32
control|)
block|{
name|gic_d_write_4
argument_list|(
name|sc
argument_list|,
name|GICD_ICENABLER
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
block|}
comment|/* Find the current cpu mask */
name|mask
operator|=
name|gic_cpu_mask
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Set the mask so we can find this CPU to send it IPIs */
name|arm_gic_map
index|[
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
index|]
operator|=
name|mask
expr_stmt|;
comment|/* Set all four targets to this cpu */
name|mask
operator||=
name|mask
operator|<<
literal|8
expr_stmt|;
name|mask
operator||=
name|mask
operator|<<
literal|16
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|nirqs
condition|;
name|i
operator|+=
literal|4
control|)
block|{
name|gic_d_write_4
argument_list|(
name|sc
argument_list|,
name|GICD_IPRIORITYR
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|32
condition|)
block|{
name|gic_d_write_4
argument_list|(
name|sc
argument_list|,
name|GICD_ITARGETSR
argument_list|(
name|i
argument_list|)
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Set all the interrupts to be in Group 0 (secure) */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|GIC_SUPPORT_SECEXT
argument_list|(
name|sc
argument_list|)
operator|&&
name|i
operator|<
name|sc
operator|->
name|nirqs
condition|;
name|i
operator|+=
literal|32
control|)
block|{
name|gic_d_write_4
argument_list|(
name|sc
argument_list|,
name|GICD_IGROUPR
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Enable CPU interface */
name|gic_c_write_4
argument_list|(
name|sc
argument_list|,
name|GICC_CTLR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Set priority mask register. */
name|gic_c_write_4
argument_list|(
name|sc
argument_list|,
name|GICC_PMR
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* Enable interrupt distribution */
name|gic_d_write_4
argument_list|(
name|sc
argument_list|,
name|GICD_CTLR
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
ifdef|#
directive|ifdef
name|INTRNG
name|cleanup
label|:
name|arm_gic_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|arm_gic_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|INTRNG
name|struct
name|arm_gic_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|gic_irqs
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sc
operator|->
name|gic_irqs
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|bus_release_resources
argument_list|(
name|dev
argument_list|,
name|arm_gic_spec
argument_list|,
name|sc
operator|->
name|gic_res
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|INTRNG
end_ifdef

begin_function
specifier|static
name|int
name|arm_gic_print_child
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|resource_list
modifier|*
name|rl
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|rv
operator|=
name|bus_print_child_header
argument_list|(
name|bus
argument_list|,
name|child
argument_list|)
expr_stmt|;
name|rl
operator|=
name|BUS_GET_RESOURCE_LIST
argument_list|(
name|bus
argument_list|,
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|rl
operator|!=
name|NULL
condition|)
block|{
name|rv
operator|+=
name|resource_list_print_type
argument_list|(
name|rl
argument_list|,
literal|"mem"
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
literal|"%#jx"
argument_list|)
expr_stmt|;
name|rv
operator|+=
name|resource_list_print_type
argument_list|(
name|rl
argument_list|,
literal|"irq"
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|"%jd"
argument_list|)
expr_stmt|;
block|}
name|rv
operator|+=
name|bus_print_child_footer
argument_list|(
name|bus
argument_list|,
name|child
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|resource
modifier|*
name|arm_gic_alloc_resource
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
modifier|*
name|rid
parameter_list|,
name|rman_res_t
name|start
parameter_list|,
name|rman_res_t
name|end
parameter_list|,
name|rman_res_t
name|count
parameter_list|,
name|u_int
name|flags
parameter_list|)
block|{
name|struct
name|arm_gic_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|resource_list_entry
modifier|*
name|rle
decl_stmt|;
name|struct
name|resource_list
modifier|*
name|rl
decl_stmt|;
name|int
name|j
decl_stmt|;
name|KASSERT
argument_list|(
name|type
operator|==
name|SYS_RES_MEMORY
argument_list|,
operator|(
literal|"Invalid resoure type %x"
operator|,
name|type
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|bus
argument_list|)
expr_stmt|;
comment|/* 	 * Request for the default allocation with a given rid: use resource 	 * list stored in the local device info. 	 */
if|if
condition|(
name|RMAN_IS_DEFAULT_RANGE
argument_list|(
name|start
argument_list|,
name|end
argument_list|)
condition|)
block|{
name|rl
operator|=
name|BUS_GET_RESOURCE_LIST
argument_list|(
name|bus
argument_list|,
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|SYS_RES_IOPORT
condition|)
name|type
operator|=
name|SYS_RES_MEMORY
expr_stmt|;
name|rle
operator|=
name|resource_list_find
argument_list|(
name|rl
argument_list|,
name|type
argument_list|,
operator|*
name|rid
argument_list|)
expr_stmt|;
if|if
condition|(
name|rle
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|bus
argument_list|,
literal|"no default resources for "
literal|"rid = %d, type = %d\n"
argument_list|,
operator|*
name|rid
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|start
operator|=
name|rle
operator|->
name|start
expr_stmt|;
name|end
operator|=
name|rle
operator|->
name|end
expr_stmt|;
name|count
operator|=
name|rle
operator|->
name|count
expr_stmt|;
block|}
comment|/* Remap through ranges property */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|sc
operator|->
name|nranges
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|start
operator|>=
name|sc
operator|->
name|ranges
index|[
name|j
index|]
operator|.
name|bus
operator|&&
name|end
operator|<
name|sc
operator|->
name|ranges
index|[
name|j
index|]
operator|.
name|bus
operator|+
name|sc
operator|->
name|ranges
index|[
name|j
index|]
operator|.
name|size
condition|)
block|{
name|start
operator|-=
name|sc
operator|->
name|ranges
index|[
name|j
index|]
operator|.
name|bus
expr_stmt|;
name|start
operator|+=
name|sc
operator|->
name|ranges
index|[
name|j
index|]
operator|.
name|host
expr_stmt|;
name|end
operator|-=
name|sc
operator|->
name|ranges
index|[
name|j
index|]
operator|.
name|bus
expr_stmt|;
name|end
operator|+=
name|sc
operator|->
name|ranges
index|[
name|j
index|]
operator|.
name|host
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|j
operator|==
name|sc
operator|->
name|nranges
operator|&&
name|sc
operator|->
name|nranges
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|bus
argument_list|,
literal|"Could not map resource "
literal|"%#jx-%#jx\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|start
argument_list|,
operator|(
name|uintmax_t
operator|)
name|end
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|bus_generic_alloc_resource
argument_list|(
name|bus
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|arm_gic_read_ivar
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|which
parameter_list|,
name|uintptr_t
modifier|*
name|result
parameter_list|)
block|{
name|struct
name|arm_gic_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|which
condition|)
block|{
case|case
name|GIC_IVAR_HW_REV
case|:
name|KASSERT
argument_list|(
name|GICD_IIDR_VAR
argument_list|(
name|sc
operator|->
name|gic_iidr
argument_list|)
operator|<
literal|3
operator|&&
name|GICD_IIDR_VAR
argument_list|(
name|sc
operator|->
name|gic_iidr
argument_list|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"arm_gic_read_ivar: Unknown IIDR revision %u (%.08x)"
operator|,
name|GICD_IIDR_VAR
argument_list|(
name|sc
operator|->
name|gic_iidr
argument_list|)
operator|,
name|sc
operator|->
name|gic_iidr
operator|)
argument_list|)
expr_stmt|;
operator|*
name|result
operator|=
name|GICD_IIDR_VAR
argument_list|(
name|sc
operator|->
name|gic_iidr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|GIC_IVAR_BUS
case|:
name|KASSERT
argument_list|(
name|sc
operator|->
name|gic_bus
operator|!=
name|GIC_BUS_UNKNOWN
argument_list|,
operator|(
literal|"arm_gic_read_ivar: Unknown bus type"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|gic_bus
operator|<=
name|GIC_BUS_MAX
argument_list|,
operator|(
literal|"arm_gic_read_ivar: Invalid bus type %u"
operator|,
name|sc
operator|->
name|gic_bus
operator|)
argument_list|)
expr_stmt|;
operator|*
name|result
operator|=
name|sc
operator|->
name|gic_bus
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
end_function

begin_function
name|int
name|arm_gic_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|arm_gic_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|gic_irqsrc
modifier|*
name|gi
decl_stmt|;
name|uint32_t
name|irq_active_reg
decl_stmt|,
name|irq
decl_stmt|;
name|struct
name|trapframe
modifier|*
name|tf
decl_stmt|;
name|irq_active_reg
operator|=
name|gic_c_read_4
argument_list|(
name|sc
argument_list|,
name|GICC_IAR
argument_list|)
expr_stmt|;
name|irq
operator|=
name|irq_active_reg
operator|&
literal|0x3FF
expr_stmt|;
comment|/* 	 * 1. We do EOI here because recent read value from active interrupt 	 *    register must be used for it. Another approach is to save this 	 *    value into associated interrupt source. 	 * 2. EOI must be done on same CPU where interrupt has fired. Thus 	 *    we must ensure that interrupted thread does not migrate to 	 *    another CPU. 	 * 3. EOI cannot be delayed by any preemption which could happen on 	 *    critical_exit() used in MI intr code, when interrupt thread is 	 *    scheduled. See next point. 	 * 4. IPI_RENDEZVOUS assumes that no preemption is permitted during 	 *    an action and any use of critical_exit() could break this 	 *    assumption. See comments within smp_rendezvous_action(). 	 * 5. We always return FILTER_HANDLED as this is an interrupt 	 *    controller dispatch function. Otherwise, in cascaded interrupt 	 *    case, the whole interrupt subtree would be masked. 	 */
if|if
condition|(
name|irq
operator|>=
name|sc
operator|->
name|nirqs
condition|)
block|{
ifdef|#
directive|ifdef
name|GIC_DEBUG_SPURIOUS
name|device_printf
argument_list|(
name|sc
operator|->
name|gic_dev
argument_list|,
literal|"Spurious interrupt detected: last irq: %d on CPU%d\n"
argument_list|,
name|sc
operator|->
name|last_irq
index|[
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
index|]
argument_list|,
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|FILTER_HANDLED
operator|)
return|;
block|}
name|tf
operator|=
name|curthread
operator|->
name|td_intr_frame
expr_stmt|;
name|dispatch_irq
label|:
name|gi
operator|=
name|sc
operator|->
name|gic_irqs
operator|+
name|irq
expr_stmt|;
comment|/* 	 * Note that GIC_FIRST_SGI is zero and is not used in 'if' statement 	 * as compiler complains that comparing u_int>= 0 is always true. 	 */
if|if
condition|(
name|irq
operator|<=
name|GIC_LAST_SGI
condition|)
block|{
ifdef|#
directive|ifdef
name|SMP
comment|/* Call EOI for all IPI before dispatch. */
name|gic_c_write_4
argument_list|(
name|sc
argument_list|,
name|GICC_EOIR
argument_list|,
name|irq_active_reg
argument_list|)
expr_stmt|;
name|intr_ipi_dispatch
argument_list|(
name|sgi_to_ipi
index|[
name|gi
operator|->
name|gi_irq
index|]
argument_list|,
name|tf
argument_list|)
expr_stmt|;
goto|goto
name|next_irq
goto|;
else|#
directive|else
name|device_printf
argument_list|(
name|sc
operator|->
name|gic_dev
argument_list|,
literal|"SGI %u on UP system detected\n"
argument_list|,
name|irq
operator|-
name|GIC_FIRST_SGI
argument_list|)
expr_stmt|;
name|gic_c_write_4
argument_list|(
name|sc
argument_list|,
name|GICC_EOIR
argument_list|,
name|irq_active_reg
argument_list|)
expr_stmt|;
goto|goto
name|next_irq
goto|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|GIC_DEBUG_SPURIOUS
name|sc
operator|->
name|last_irq
index|[
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
index|]
operator|=
name|irq
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|gi
operator|->
name|gi_flags
operator|&
name|GI_FLAG_EARLY_EOI
operator|)
operator|==
name|GI_FLAG_EARLY_EOI
condition|)
name|gic_c_write_4
argument_list|(
name|sc
argument_list|,
name|GICC_EOIR
argument_list|,
name|irq_active_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|intr_isrc_dispatch
argument_list|(
operator|&
name|gi
operator|->
name|gi_isrc
argument_list|,
name|tf
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|gic_irq_mask
argument_list|(
name|sc
argument_list|,
name|irq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|gi
operator|->
name|gi_flags
operator|&
name|GI_FLAG_EARLY_EOI
operator|)
operator|!=
name|GI_FLAG_EARLY_EOI
condition|)
name|gic_c_write_4
argument_list|(
name|sc
argument_list|,
name|GICC_EOIR
argument_list|,
name|irq_active_reg
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|gic_dev
argument_list|,
literal|"Stray irq %u disabled\n"
argument_list|,
name|irq
argument_list|)
expr_stmt|;
block|}
name|next_irq
label|:
name|arm_irq_memory_barrier
argument_list|(
name|irq
argument_list|)
expr_stmt|;
name|irq_active_reg
operator|=
name|gic_c_read_4
argument_list|(
name|sc
argument_list|,
name|GICC_IAR
argument_list|)
expr_stmt|;
name|irq
operator|=
name|irq_active_reg
operator|&
literal|0x3FF
expr_stmt|;
if|if
condition|(
name|irq
operator|<
name|sc
operator|->
name|nirqs
condition|)
goto|goto
name|dispatch_irq
goto|;
return|return
operator|(
name|FILTER_HANDLED
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|gic_config
parameter_list|(
name|struct
name|arm_gic_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|irq
parameter_list|,
name|enum
name|intr_trigger
name|trig
parameter_list|,
name|enum
name|intr_polarity
name|pol
parameter_list|)
block|{
name|uint32_t
name|reg
decl_stmt|;
name|uint32_t
name|mask
decl_stmt|;
if|if
condition|(
name|irq
operator|<
name|GIC_FIRST_SPI
condition|)
return|return;
name|mtx_lock_spin
argument_list|(
operator|&
name|sc
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|reg
operator|=
name|gic_d_read_4
argument_list|(
name|sc
argument_list|,
name|GICD_ICFGR
argument_list|(
name|irq
argument_list|)
argument_list|)
expr_stmt|;
name|mask
operator|=
operator|(
name|reg
operator|>>
literal|2
operator|*
operator|(
name|irq
operator|%
literal|16
operator|)
operator|)
operator|&
literal|0x3
expr_stmt|;
if|if
condition|(
name|pol
operator|==
name|INTR_POLARITY_LOW
condition|)
block|{
name|mask
operator|&=
operator|~
name|GICD_ICFGR_POL_MASK
expr_stmt|;
name|mask
operator||=
name|GICD_ICFGR_POL_LOW
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pol
operator|==
name|INTR_POLARITY_HIGH
condition|)
block|{
name|mask
operator|&=
operator|~
name|GICD_ICFGR_POL_MASK
expr_stmt|;
name|mask
operator||=
name|GICD_ICFGR_POL_HIGH
expr_stmt|;
block|}
if|if
condition|(
name|trig
operator|==
name|INTR_TRIGGER_LEVEL
condition|)
block|{
name|mask
operator|&=
operator|~
name|GICD_ICFGR_TRIG_MASK
expr_stmt|;
name|mask
operator||=
name|GICD_ICFGR_TRIG_LVL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|trig
operator|==
name|INTR_TRIGGER_EDGE
condition|)
block|{
name|mask
operator|&=
operator|~
name|GICD_ICFGR_TRIG_MASK
expr_stmt|;
name|mask
operator||=
name|GICD_ICFGR_TRIG_EDGE
expr_stmt|;
block|}
comment|/* Set mask */
name|reg
operator|=
name|reg
operator|&
operator|~
operator|(
literal|0x3
operator|<<
literal|2
operator|*
operator|(
name|irq
operator|%
literal|16
operator|)
operator|)
expr_stmt|;
name|reg
operator|=
name|reg
operator||
operator|(
name|mask
operator|<<
literal|2
operator|*
operator|(
name|irq
operator|%
literal|16
operator|)
operator|)
expr_stmt|;
name|gic_d_write_4
argument_list|(
name|sc
argument_list|,
name|GICD_ICFGR
argument_list|(
name|irq
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sc
operator|->
name|mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|gic_bind
parameter_list|(
name|struct
name|arm_gic_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|irq
parameter_list|,
name|cpuset_t
modifier|*
name|cpus
parameter_list|)
block|{
name|uint32_t
name|cpu
decl_stmt|,
name|end
decl_stmt|,
name|mask
decl_stmt|;
name|end
operator|=
name|min
argument_list|(
name|mp_ncpus
argument_list|,
literal|8
argument_list|)
expr_stmt|;
for|for
control|(
name|cpu
operator|=
name|end
init|;
name|cpu
operator|<
name|MAXCPU
condition|;
name|cpu
operator|++
control|)
if|if
condition|(
name|CPU_ISSET
argument_list|(
name|cpu
argument_list|,
name|cpus
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
for|for
control|(
name|mask
operator|=
literal|0
operator|,
name|cpu
operator|=
literal|0
init|;
name|cpu
operator|<
name|end
condition|;
name|cpu
operator|++
control|)
if|if
condition|(
name|CPU_ISSET
argument_list|(
name|cpu
argument_list|,
name|cpus
argument_list|)
condition|)
name|mask
operator||=
name|arm_gic_map
index|[
name|cpu
index|]
expr_stmt|;
name|gic_d_write_1
argument_list|(
name|sc
argument_list|,
name|GICD_ITARGETSR
argument_list|(
literal|0
argument_list|)
operator|+
name|irq
argument_list|,
name|mask
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|FDT
end_ifdef

begin_function
specifier|static
name|int
name|gic_map_fdt
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int
name|ncells
parameter_list|,
name|pcell_t
modifier|*
name|cells
parameter_list|,
name|u_int
modifier|*
name|irqp
parameter_list|,
name|enum
name|intr_polarity
modifier|*
name|polp
parameter_list|,
name|enum
name|intr_trigger
modifier|*
name|trigp
parameter_list|)
block|{
if|if
condition|(
name|ncells
operator|==
literal|1
condition|)
block|{
operator|*
name|irqp
operator|=
name|cells
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|polp
operator|=
name|INTR_POLARITY_CONFORM
expr_stmt|;
operator|*
name|trigp
operator|=
name|INTR_TRIGGER_CONFORM
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|ncells
operator|==
literal|3
condition|)
block|{
name|u_int
name|irq
decl_stmt|,
name|tripol
decl_stmt|;
comment|/* 		 * The 1st cell is the interrupt type: 		 *	0 = SPI 		 *	1 = PPI 		 * The 2nd cell contains the interrupt number: 		 *	[0 - 987] for SPI 		 *	[0 -  15] for PPI 		 * The 3rd cell is the flags, encoded as follows: 		 *   bits[3:0] trigger type and level flags 		 *	1 = low-to-high edge triggered 		 *	2 = high-to-low edge triggered 		 *	4 = active high level-sensitive 		 *	8 = active low level-sensitive 		 *   bits[15:8] PPI interrupt cpu mask 		 *	Each bit corresponds to each of the 8 possible cpus 		 *	attached to the GIC.  A bit set to '1' indicated 		 *	the interrupt is wired to that CPU. 		 */
switch|switch
condition|(
name|cells
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|0
case|:
name|irq
operator|=
name|GIC_FIRST_SPI
operator|+
name|cells
index|[
literal|1
index|]
expr_stmt|;
comment|/* SPI irq is checked later. */
break|break;
case|case
literal|1
case|:
name|irq
operator|=
name|GIC_FIRST_PPI
operator|+
name|cells
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|irq
operator|>
name|GIC_LAST_PPI
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unsupported PPI interrupt "
literal|"number %u\n"
argument_list|,
name|cells
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
break|break;
default|default:
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unsupported interrupt type "
literal|"configuration %u\n"
argument_list|,
name|cells
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|tripol
operator|=
name|cells
index|[
literal|2
index|]
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|tripol
operator|&
literal|0xf0
operator|||
operator|(
name|tripol
operator|&
name|FDT_INTR_LOW_MASK
operator|&&
name|cells
index|[
literal|0
index|]
operator|==
literal|0
operator|)
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"unsupported trigger/polarity "
literal|"configuration 0x%02x\n"
argument_list|,
name|tripol
argument_list|)
expr_stmt|;
operator|*
name|irqp
operator|=
name|irq
expr_stmt|;
operator|*
name|polp
operator|=
name|INTR_POLARITY_CONFORM
expr_stmt|;
operator|*
name|trigp
operator|=
name|tripol
operator|&
name|FDT_INTR_EDGE_MASK
condition|?
name|INTR_TRIGGER_EDGE
else|:
name|INTR_TRIGGER_LEVEL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|gic_map_msi
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|intr_map_data_msi
modifier|*
name|msi_data
parameter_list|,
name|u_int
modifier|*
name|irqp
parameter_list|,
name|enum
name|intr_polarity
modifier|*
name|polp
parameter_list|,
name|enum
name|intr_trigger
modifier|*
name|trigp
parameter_list|)
block|{
name|struct
name|gic_irqsrc
modifier|*
name|gi
decl_stmt|;
comment|/* Map a non-GICv2m MSI */
name|gi
operator|=
operator|(
expr|struct
name|gic_irqsrc
operator|*
operator|)
name|msi_data
operator|->
name|isrc
expr_stmt|;
if|if
condition|(
name|gi
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
operator|*
name|irqp
operator|=
name|gi
operator|->
name|gi_irq
expr_stmt|;
comment|/* MSI/MSI-X interrupts are always edge triggered with high polarity */
operator|*
name|polp
operator|=
name|INTR_POLARITY_HIGH
expr_stmt|;
operator|*
name|trigp
operator|=
name|INTR_TRIGGER_EDGE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|gic_map_intr
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|intr_map_data
modifier|*
name|data
parameter_list|,
name|u_int
modifier|*
name|irqp
parameter_list|,
name|enum
name|intr_polarity
modifier|*
name|polp
parameter_list|,
name|enum
name|intr_trigger
modifier|*
name|trigp
parameter_list|)
block|{
name|u_int
name|irq
decl_stmt|;
name|enum
name|intr_polarity
name|pol
decl_stmt|;
name|enum
name|intr_trigger
name|trig
decl_stmt|;
name|struct
name|arm_gic_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|intr_map_data_msi
modifier|*
name|dam
decl_stmt|;
ifdef|#
directive|ifdef
name|FDT
name|struct
name|intr_map_data_fdt
modifier|*
name|daf
decl_stmt|;
endif|#
directive|endif
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|data
operator|->
name|type
condition|)
block|{
ifdef|#
directive|ifdef
name|FDT
case|case
name|INTR_MAP_DATA_FDT
case|:
name|daf
operator|=
operator|(
expr|struct
name|intr_map_data_fdt
operator|*
operator|)
name|data
expr_stmt|;
if|if
condition|(
name|gic_map_fdt
argument_list|(
name|dev
argument_list|,
name|daf
operator|->
name|ncells
argument_list|,
name|daf
operator|->
name|cells
argument_list|,
operator|&
name|irq
argument_list|,
operator|&
name|pol
argument_list|,
operator|&
name|trig
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|KASSERT
argument_list|(
name|irq
operator|>=
name|sc
operator|->
name|nirqs
operator|||
operator|(
name|sc
operator|->
name|gic_irqs
index|[
name|irq
index|]
operator|.
name|gi_flags
operator|&
name|GI_FLAG_MSI
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: Attempting to map a MSI interrupt from FDT"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|INTR_MAP_DATA_MSI
case|:
comment|/* Non-GICv2m MSI */
name|dam
operator|=
operator|(
expr|struct
name|intr_map_data_msi
operator|*
operator|)
name|data
expr_stmt|;
if|if
condition|(
name|gic_map_msi
argument_list|(
name|dev
argument_list|,
name|dam
argument_list|,
operator|&
name|irq
argument_list|,
operator|&
name|pol
argument_list|,
operator|&
name|trig
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
break|break;
default|default:
return|return
operator|(
name|ENOTSUP
operator|)
return|;
block|}
if|if
condition|(
name|irq
operator|>=
name|sc
operator|->
name|nirqs
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|pol
operator|!=
name|INTR_POLARITY_CONFORM
operator|&&
name|pol
operator|!=
name|INTR_POLARITY_LOW
operator|&&
name|pol
operator|!=
name|INTR_POLARITY_HIGH
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|trig
operator|!=
name|INTR_TRIGGER_CONFORM
operator|&&
name|trig
operator|!=
name|INTR_TRIGGER_EDGE
operator|&&
name|trig
operator|!=
name|INTR_TRIGGER_LEVEL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
operator|*
name|irqp
operator|=
name|irq
expr_stmt|;
if|if
condition|(
name|polp
operator|!=
name|NULL
condition|)
operator|*
name|polp
operator|=
name|pol
expr_stmt|;
if|if
condition|(
name|trigp
operator|!=
name|NULL
condition|)
operator|*
name|trigp
operator|=
name|trig
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|arm_gic_map_intr
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|intr_map_data
modifier|*
name|data
parameter_list|,
name|struct
name|intr_irqsrc
modifier|*
modifier|*
name|isrcp
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|u_int
name|irq
decl_stmt|;
name|struct
name|arm_gic_softc
modifier|*
name|sc
decl_stmt|;
name|error
operator|=
name|gic_map_intr
argument_list|(
name|dev
argument_list|,
name|data
argument_list|,
operator|&
name|irq
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
operator|*
name|isrcp
operator|=
name|GIC_INTR_ISRC
argument_list|(
name|sc
argument_list|,
name|irq
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|arm_gic_setup_intr
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|intr_irqsrc
modifier|*
name|isrc
parameter_list|,
name|struct
name|resource
modifier|*
name|res
parameter_list|,
name|struct
name|intr_map_data
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|arm_gic_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|gic_irqsrc
modifier|*
name|gi
init|=
operator|(
expr|struct
name|gic_irqsrc
operator|*
operator|)
name|isrc
decl_stmt|;
name|enum
name|intr_trigger
name|trig
decl_stmt|;
name|enum
name|intr_polarity
name|pol
decl_stmt|;
if|if
condition|(
operator|(
name|gi
operator|->
name|gi_flags
operator|&
name|GI_FLAG_MSI
operator|)
operator|==
name|GI_FLAG_MSI
condition|)
block|{
comment|/* GICv2m MSI */
name|pol
operator|=
name|gi
operator|->
name|gi_pol
expr_stmt|;
name|trig
operator|=
name|gi
operator|->
name|gi_trig
expr_stmt|;
name|KASSERT
argument_list|(
name|pol
operator|==
name|INTR_POLARITY_HIGH
argument_list|,
operator|(
literal|"%s: MSI interrupts must be active-high"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|trig
operator|==
name|INTR_TRIGGER_EDGE
argument_list|,
operator|(
literal|"%s: MSI interrupts must be edge triggered"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|data
operator|!=
name|NULL
condition|)
block|{
name|u_int
name|irq
decl_stmt|;
comment|/* Get config for resource. */
if|if
condition|(
name|gic_map_intr
argument_list|(
name|dev
argument_list|,
name|data
argument_list|,
operator|&
name|irq
argument_list|,
operator|&
name|pol
argument_list|,
operator|&
name|trig
argument_list|)
operator|||
name|gi
operator|->
name|gi_irq
operator|!=
name|irq
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
else|else
block|{
name|pol
operator|=
name|INTR_POLARITY_CONFORM
expr_stmt|;
name|trig
operator|=
name|INTR_TRIGGER_CONFORM
expr_stmt|;
block|}
comment|/* Compare config if this is not first setup. */
if|if
condition|(
name|isrc
operator|->
name|isrc_handlers
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|pol
operator|!=
name|INTR_POLARITY_CONFORM
operator|&&
name|pol
operator|!=
name|gi
operator|->
name|gi_pol
operator|)
operator|||
operator|(
name|trig
operator|!=
name|INTR_TRIGGER_CONFORM
operator|&&
name|trig
operator|!=
name|gi
operator|->
name|gi_trig
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* For MSI/MSI-X we should have already configured these */
if|if
condition|(
operator|(
name|gi
operator|->
name|gi_flags
operator|&
name|GI_FLAG_MSI
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|pol
operator|==
name|INTR_POLARITY_CONFORM
condition|)
name|pol
operator|=
name|INTR_POLARITY_LOW
expr_stmt|;
comment|/* just pick some */
if|if
condition|(
name|trig
operator|==
name|INTR_TRIGGER_CONFORM
condition|)
name|trig
operator|=
name|INTR_TRIGGER_EDGE
expr_stmt|;
comment|/* just pick some */
name|gi
operator|->
name|gi_pol
operator|=
name|pol
expr_stmt|;
name|gi
operator|->
name|gi_trig
operator|=
name|trig
expr_stmt|;
comment|/* Edge triggered interrupts need an early EOI sent */
if|if
condition|(
name|gi
operator|->
name|gi_trig
operator|==
name|INTR_TRIGGER_EDGE
condition|)
name|gi
operator|->
name|gi_flags
operator||=
name|GI_FLAG_EARLY_EOI
expr_stmt|;
block|}
comment|/* 	 * XXX - In case that per CPU interrupt is going to be enabled in time 	 *       when SMP is already started, we need some IPI call which 	 *       enables it on others CPUs. Further, it's more complicated as 	 *       pic_enable_source() and pic_disable_source() should act on 	 *       per CPU basis only. Thus, it should be solved here somehow. 	 */
if|if
condition|(
name|isrc
operator|->
name|isrc_flags
operator|&
name|INTR_ISRCF_PPI
condition|)
name|CPU_SET
argument_list|(
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
argument_list|,
operator|&
name|isrc
operator|->
name|isrc_cpu
argument_list|)
expr_stmt|;
name|gic_config
argument_list|(
name|sc
argument_list|,
name|gi
operator|->
name|gi_irq
argument_list|,
name|gi
operator|->
name|gi_trig
argument_list|,
name|gi
operator|->
name|gi_pol
argument_list|)
expr_stmt|;
name|arm_gic_bind_intr
argument_list|(
name|dev
argument_list|,
name|isrc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|arm_gic_teardown_intr
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|intr_irqsrc
modifier|*
name|isrc
parameter_list|,
name|struct
name|resource
modifier|*
name|res
parameter_list|,
name|struct
name|intr_map_data
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|gic_irqsrc
modifier|*
name|gi
init|=
operator|(
expr|struct
name|gic_irqsrc
operator|*
operator|)
name|isrc
decl_stmt|;
if|if
condition|(
name|isrc
operator|->
name|isrc_handlers
operator|==
literal|0
operator|&&
operator|(
name|gi
operator|->
name|gi_flags
operator|&
name|GI_FLAG_MSI
operator|)
operator|==
literal|0
condition|)
block|{
name|gi
operator|->
name|gi_pol
operator|=
name|INTR_POLARITY_CONFORM
expr_stmt|;
name|gi
operator|->
name|gi_trig
operator|=
name|INTR_TRIGGER_CONFORM
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|arm_gic_enable_intr
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|intr_irqsrc
modifier|*
name|isrc
parameter_list|)
block|{
name|struct
name|arm_gic_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|gic_irqsrc
modifier|*
name|gi
init|=
operator|(
expr|struct
name|gic_irqsrc
operator|*
operator|)
name|isrc
decl_stmt|;
name|arm_irq_memory_barrier
argument_list|(
name|gi
operator|->
name|gi_irq
argument_list|)
expr_stmt|;
name|gic_irq_unmask
argument_list|(
name|sc
argument_list|,
name|gi
operator|->
name|gi_irq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arm_gic_disable_intr
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|intr_irqsrc
modifier|*
name|isrc
parameter_list|)
block|{
name|struct
name|arm_gic_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|gic_irqsrc
modifier|*
name|gi
init|=
operator|(
expr|struct
name|gic_irqsrc
operator|*
operator|)
name|isrc
decl_stmt|;
name|gic_irq_mask
argument_list|(
name|sc
argument_list|,
name|gi
operator|->
name|gi_irq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arm_gic_pre_ithread
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|intr_irqsrc
modifier|*
name|isrc
parameter_list|)
block|{
name|struct
name|arm_gic_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|gic_irqsrc
modifier|*
name|gi
init|=
operator|(
expr|struct
name|gic_irqsrc
operator|*
operator|)
name|isrc
decl_stmt|;
name|arm_gic_disable_intr
argument_list|(
name|dev
argument_list|,
name|isrc
argument_list|)
expr_stmt|;
name|gic_c_write_4
argument_list|(
name|sc
argument_list|,
name|GICC_EOIR
argument_list|,
name|gi
operator|->
name|gi_irq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arm_gic_post_ithread
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|intr_irqsrc
modifier|*
name|isrc
parameter_list|)
block|{
name|arm_irq_memory_barrier
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|arm_gic_enable_intr
argument_list|(
name|dev
argument_list|,
name|isrc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arm_gic_post_filter
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|intr_irqsrc
modifier|*
name|isrc
parameter_list|)
block|{
name|struct
name|arm_gic_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|gic_irqsrc
modifier|*
name|gi
init|=
operator|(
expr|struct
name|gic_irqsrc
operator|*
operator|)
name|isrc
decl_stmt|;
comment|/* EOI for edge-triggered done earlier. */
if|if
condition|(
operator|(
name|gi
operator|->
name|gi_flags
operator|&
name|GI_FLAG_EARLY_EOI
operator|)
operator|==
name|GI_FLAG_EARLY_EOI
condition|)
return|return;
name|arm_irq_memory_barrier
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|gic_c_write_4
argument_list|(
name|sc
argument_list|,
name|GICC_EOIR
argument_list|,
name|gi
operator|->
name|gi_irq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|arm_gic_bind_intr
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|intr_irqsrc
modifier|*
name|isrc
parameter_list|)
block|{
name|struct
name|arm_gic_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|gic_irqsrc
modifier|*
name|gi
init|=
operator|(
expr|struct
name|gic_irqsrc
operator|*
operator|)
name|isrc
decl_stmt|;
if|if
condition|(
name|gi
operator|->
name|gi_irq
operator|<
name|GIC_FIRST_SPI
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|CPU_EMPTY
argument_list|(
operator|&
name|isrc
operator|->
name|isrc_cpu
argument_list|)
condition|)
block|{
name|gic_irq_cpu
operator|=
name|intr_irq_next_cpu
argument_list|(
name|gic_irq_cpu
argument_list|,
operator|&
name|all_cpus
argument_list|)
expr_stmt|;
name|CPU_SETOF
argument_list|(
name|gic_irq_cpu
argument_list|,
operator|&
name|isrc
operator|->
name|isrc_cpu
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|gic_bind
argument_list|(
name|sc
argument_list|,
name|gi
operator|->
name|gi_irq
argument_list|,
operator|&
name|isrc
operator|->
name|isrc_cpu
argument_list|)
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SMP
end_ifdef

begin_function
specifier|static
name|void
name|arm_gic_ipi_send
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|intr_irqsrc
modifier|*
name|isrc
parameter_list|,
name|cpuset_t
name|cpus
parameter_list|,
name|u_int
name|ipi
parameter_list|)
block|{
name|struct
name|arm_gic_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|gic_irqsrc
modifier|*
name|gi
init|=
operator|(
expr|struct
name|gic_irqsrc
operator|*
operator|)
name|isrc
decl_stmt|;
name|uint32_t
name|val
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXCPU
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|CPU_ISSET
argument_list|(
name|i
argument_list|,
operator|&
name|cpus
argument_list|)
condition|)
name|val
operator||=
name|arm_gic_map
index|[
name|i
index|]
operator|<<
name|GICD_SGI_TARGET_SHIFT
expr_stmt|;
name|gic_d_write_4
argument_list|(
name|sc
argument_list|,
name|GICD_SGIR
argument_list|,
name|val
operator||
name|gi
operator|->
name|gi_irq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|arm_gic_ipi_setup
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int
name|ipi
parameter_list|,
name|struct
name|intr_irqsrc
modifier|*
modifier|*
name|isrcp
parameter_list|)
block|{
name|struct
name|intr_irqsrc
modifier|*
name|isrc
decl_stmt|;
name|struct
name|arm_gic_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|sgi_first_unused
operator|>
name|GIC_LAST_SGI
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
name|isrc
operator|=
name|GIC_INTR_ISRC
argument_list|(
name|sc
argument_list|,
name|sgi_first_unused
argument_list|)
expr_stmt|;
name|sgi_to_ipi
index|[
name|sgi_first_unused
operator|++
index|]
operator|=
name|ipi
expr_stmt|;
name|CPU_SET
argument_list|(
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
argument_list|,
operator|&
name|isrc
operator|->
name|isrc_cpu
argument_list|)
expr_stmt|;
operator|*
name|isrcp
operator|=
name|isrc
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|int
name|arm_gic_next_irq
parameter_list|(
name|struct
name|arm_gic_softc
modifier|*
name|sc
parameter_list|,
name|int
name|last_irq
parameter_list|)
block|{
name|uint32_t
name|active_irq
decl_stmt|;
name|active_irq
operator|=
name|gic_c_read_4
argument_list|(
name|sc
argument_list|,
name|GICC_IAR
argument_list|)
expr_stmt|;
comment|/* 	 * Immediately EOIR the SGIs, because doing so requires the other 	 * bits (ie CPU number), not just the IRQ number, and we do not 	 * have this information later. 	 */
if|if
condition|(
operator|(
name|active_irq
operator|&
literal|0x3ff
operator|)
operator|<=
name|GIC_LAST_SGI
condition|)
name|gic_c_write_4
argument_list|(
name|sc
argument_list|,
name|GICC_EOIR
argument_list|,
name|active_irq
argument_list|)
expr_stmt|;
name|active_irq
operator|&=
literal|0x3FF
expr_stmt|;
if|if
condition|(
name|active_irq
operator|==
literal|0x3FF
condition|)
block|{
if|if
condition|(
name|last_irq
operator|==
operator|-
literal|1
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|gic_dev
argument_list|,
literal|"Spurious interrupt detected\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
name|active_irq
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|arm_gic_config
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|irq
parameter_list|,
name|enum
name|intr_trigger
name|trig
parameter_list|,
name|enum
name|intr_polarity
name|pol
parameter_list|)
block|{
name|struct
name|arm_gic_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|uint32_t
name|reg
decl_stmt|;
name|uint32_t
name|mask
decl_stmt|;
comment|/* Function is public-accessible, so validate input arguments */
if|if
condition|(
operator|(
name|irq
operator|<
literal|0
operator|)
operator|||
operator|(
name|irq
operator|>=
name|sc
operator|->
name|nirqs
operator|)
condition|)
goto|goto
name|invalid_args
goto|;
if|if
condition|(
operator|(
name|trig
operator|!=
name|INTR_TRIGGER_EDGE
operator|)
operator|&&
operator|(
name|trig
operator|!=
name|INTR_TRIGGER_LEVEL
operator|)
operator|&&
operator|(
name|trig
operator|!=
name|INTR_TRIGGER_CONFORM
operator|)
condition|)
goto|goto
name|invalid_args
goto|;
if|if
condition|(
operator|(
name|pol
operator|!=
name|INTR_POLARITY_HIGH
operator|)
operator|&&
operator|(
name|pol
operator|!=
name|INTR_POLARITY_LOW
operator|)
operator|&&
operator|(
name|pol
operator|!=
name|INTR_POLARITY_CONFORM
operator|)
condition|)
goto|goto
name|invalid_args
goto|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sc
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|reg
operator|=
name|gic_d_read_4
argument_list|(
name|sc
argument_list|,
name|GICD_ICFGR
argument_list|(
name|irq
argument_list|)
argument_list|)
expr_stmt|;
name|mask
operator|=
operator|(
name|reg
operator|>>
literal|2
operator|*
operator|(
name|irq
operator|%
literal|16
operator|)
operator|)
operator|&
literal|0x3
expr_stmt|;
if|if
condition|(
name|pol
operator|==
name|INTR_POLARITY_LOW
condition|)
block|{
name|mask
operator|&=
operator|~
name|GICD_ICFGR_POL_MASK
expr_stmt|;
name|mask
operator||=
name|GICD_ICFGR_POL_LOW
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pol
operator|==
name|INTR_POLARITY_HIGH
condition|)
block|{
name|mask
operator|&=
operator|~
name|GICD_ICFGR_POL_MASK
expr_stmt|;
name|mask
operator||=
name|GICD_ICFGR_POL_HIGH
expr_stmt|;
block|}
if|if
condition|(
name|trig
operator|==
name|INTR_TRIGGER_LEVEL
condition|)
block|{
name|mask
operator|&=
operator|~
name|GICD_ICFGR_TRIG_MASK
expr_stmt|;
name|mask
operator||=
name|GICD_ICFGR_TRIG_LVL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|trig
operator|==
name|INTR_TRIGGER_EDGE
condition|)
block|{
name|mask
operator|&=
operator|~
name|GICD_ICFGR_TRIG_MASK
expr_stmt|;
name|mask
operator||=
name|GICD_ICFGR_TRIG_EDGE
expr_stmt|;
block|}
comment|/* Set mask */
name|reg
operator|=
name|reg
operator|&
operator|~
operator|(
literal|0x3
operator|<<
literal|2
operator|*
operator|(
name|irq
operator|%
literal|16
operator|)
operator|)
expr_stmt|;
name|reg
operator|=
name|reg
operator||
operator|(
name|mask
operator|<<
literal|2
operator|*
operator|(
name|irq
operator|%
literal|16
operator|)
operator|)
expr_stmt|;
name|gic_d_write_4
argument_list|(
name|sc
argument_list|,
name|GICD_ICFGR
argument_list|(
name|irq
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sc
operator|->
name|mutex
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|invalid_args
label|:
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"gic_config_irg, invalid parameters\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|arm_gic_mask
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|irq
parameter_list|)
block|{
name|struct
name|arm_gic_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|gic_d_write_4
argument_list|(
name|sc
argument_list|,
name|GICD_ICENABLER
argument_list|(
name|irq
argument_list|)
argument_list|,
operator|(
literal|1UL
operator|<<
operator|(
name|irq
operator|&
literal|0x1F
operator|)
operator|)
argument_list|)
expr_stmt|;
name|gic_c_write_4
argument_list|(
name|sc
argument_list|,
name|GICC_EOIR
argument_list|,
name|irq
argument_list|)
expr_stmt|;
comment|/* XXX - not allowed */
block|}
end_function

begin_function
specifier|static
name|void
name|arm_gic_unmask
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|irq
parameter_list|)
block|{
name|struct
name|arm_gic_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|irq
operator|>
name|GIC_LAST_SGI
condition|)
name|arm_irq_memory_barrier
argument_list|(
name|irq
argument_list|)
expr_stmt|;
name|gic_d_write_4
argument_list|(
name|sc
argument_list|,
name|GICD_ISENABLER
argument_list|(
name|irq
argument_list|)
argument_list|,
operator|(
literal|1UL
operator|<<
operator|(
name|irq
operator|&
literal|0x1F
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SMP
end_ifdef

begin_function
specifier|static
name|void
name|arm_gic_ipi_send
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|cpuset_t
name|cpus
parameter_list|,
name|u_int
name|ipi
parameter_list|)
block|{
name|struct
name|arm_gic_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|uint32_t
name|val
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXCPU
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|CPU_ISSET
argument_list|(
name|i
argument_list|,
operator|&
name|cpus
argument_list|)
condition|)
name|val
operator||=
name|arm_gic_map
index|[
name|i
index|]
operator|<<
name|GICD_SGI_TARGET_SHIFT
expr_stmt|;
name|gic_d_write_4
argument_list|(
name|sc
argument_list|,
name|GICD_SGIR
argument_list|,
name|val
operator||
name|ipi
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|arm_gic_ipi_read
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|i
parameter_list|)
block|{
if|if
condition|(
name|i
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* 		 * The intr code will automagically give the frame pointer 		 * if the interrupt argument is 0. 		 */
if|if
condition|(
operator|(
name|unsigned
name|int
operator|)
name|i
operator|>
literal|16
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|i
operator|)
return|;
block|}
return|return
operator|(
literal|0x3ff
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|arm_gic_ipi_clear
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|ipi
parameter_list|)
block|{
comment|/* no-op */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|gic_post_filter
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|arm_gic_softc
modifier|*
name|sc
init|=
name|gic_sc
decl_stmt|;
name|uintptr_t
name|irq
init|=
operator|(
name|uintptr_t
operator|)
name|arg
decl_stmt|;
if|if
condition|(
name|irq
operator|>
name|GIC_LAST_SGI
condition|)
name|arm_irq_memory_barrier
argument_list|(
name|irq
argument_list|)
expr_stmt|;
name|gic_c_write_4
argument_list|(
name|sc
argument_list|,
name|GICC_EOIR
argument_list|,
name|irq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|gic_config_irq
parameter_list|(
name|int
name|irq
parameter_list|,
name|enum
name|intr_trigger
name|trig
parameter_list|,
name|enum
name|intr_polarity
name|pol
parameter_list|)
block|{
return|return
operator|(
name|arm_gic_config
argument_list|(
name|gic_sc
operator|->
name|gic_dev
argument_list|,
name|irq
argument_list|,
name|trig
argument_list|,
name|pol
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|arm_mask_irq
parameter_list|(
name|uintptr_t
name|nb
parameter_list|)
block|{
name|arm_gic_mask
argument_list|(
name|gic_sc
operator|->
name|gic_dev
argument_list|,
name|nb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arm_unmask_irq
parameter_list|(
name|uintptr_t
name|nb
parameter_list|)
block|{
name|arm_gic_unmask
argument_list|(
name|gic_sc
operator|->
name|gic_dev
argument_list|,
name|nb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|arm_get_next_irq
parameter_list|(
name|int
name|last_irq
parameter_list|)
block|{
return|return
operator|(
name|arm_gic_next_irq
argument_list|(
name|gic_sc
argument_list|,
name|last_irq
argument_list|)
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SMP
end_ifdef

begin_function
name|void
name|intr_pic_init_secondary
parameter_list|(
name|void
parameter_list|)
block|{
name|arm_gic_init_secondary
argument_list|(
name|gic_sc
operator|->
name|gic_dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pic_ipi_send
parameter_list|(
name|cpuset_t
name|cpus
parameter_list|,
name|u_int
name|ipi
parameter_list|)
block|{
name|arm_gic_ipi_send
argument_list|(
name|gic_sc
operator|->
name|gic_dev
argument_list|,
name|cpus
argument_list|,
name|ipi
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|pic_ipi_read
parameter_list|(
name|int
name|i
parameter_list|)
block|{
return|return
operator|(
name|arm_gic_ipi_read
argument_list|(
name|gic_sc
operator|->
name|gic_dev
argument_list|,
name|i
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pic_ipi_clear
parameter_list|(
name|int
name|ipi
parameter_list|)
block|{
name|arm_gic_ipi_clear
argument_list|(
name|gic_sc
operator|->
name|gic_dev
argument_list|,
name|ipi
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INTRNG */
end_comment

begin_decl_stmt
specifier|static
name|device_method_t
name|arm_gic_methods
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|INTRNG
comment|/* Bus interface */
name|DEVMETHOD
argument_list|(
name|bus_print_child
argument_list|,
name|arm_gic_print_child
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_add_child
argument_list|,
name|bus_generic_add_child
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_alloc_resource
argument_list|,
name|arm_gic_alloc_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_release_resource
argument_list|,
name|bus_generic_release_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_activate_resource
argument_list|,
name|bus_generic_activate_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_read_ivar
argument_list|,
name|arm_gic_read_ivar
argument_list|)
block|,
comment|/* Interrupt controller interface */
name|DEVMETHOD
argument_list|(
name|pic_disable_intr
argument_list|,
name|arm_gic_disable_intr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pic_enable_intr
argument_list|,
name|arm_gic_enable_intr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pic_map_intr
argument_list|,
name|arm_gic_map_intr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pic_setup_intr
argument_list|,
name|arm_gic_setup_intr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pic_teardown_intr
argument_list|,
name|arm_gic_teardown_intr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pic_post_filter
argument_list|,
name|arm_gic_post_filter
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pic_post_ithread
argument_list|,
name|arm_gic_post_ithread
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pic_pre_ithread
argument_list|,
name|arm_gic_pre_ithread
argument_list|)
block|,
ifdef|#
directive|ifdef
name|SMP
name|DEVMETHOD
argument_list|(
name|pic_bind_intr
argument_list|,
name|arm_gic_bind_intr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pic_init_secondary
argument_list|,
name|arm_gic_init_secondary
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pic_ipi_send
argument_list|,
name|arm_gic_ipi_send
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pic_ipi_setup
argument_list|,
name|arm_gic_ipi_setup
argument_list|)
block|,
endif|#
directive|endif
endif|#
directive|endif
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DEFINE_CLASS_0
argument_list|(
name|gic
argument_list|,
name|arm_gic_driver
argument_list|,
name|arm_gic_methods
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|arm_gic_softc
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|INTRNG
end_ifdef

begin_comment
comment|/*  * GICv2m support -- the GICv2 MSI/MSI-X controller.  */
end_comment

begin_define
define|#
directive|define
name|GICV2M_MSI_TYPER
value|0x008
end_define

begin_define
define|#
directive|define
name|MSI_TYPER_SPI_BASE
parameter_list|(
name|x
parameter_list|)
value|(((x)>> 16)& 0x3ff)
end_define

begin_define
define|#
directive|define
name|MSI_TYPER_SPI_COUNT
parameter_list|(
name|x
parameter_list|)
value|(((x)>> 0)& 0x3ff)
end_define

begin_define
define|#
directive|define
name|GICv2M_MSI_SETSPI_NS
value|0x040
end_define

begin_define
define|#
directive|define
name|GICV2M_MSI_IIDR
value|0xFCC
end_define

begin_function
name|int
name|arm_gicv2m_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|arm_gicv2m_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|arm_gic_softc
modifier|*
name|psc
decl_stmt|;
name|uint32_t
name|typer
decl_stmt|;
name|int
name|rid
decl_stmt|;
name|psc
operator|=
name|device_get_softc
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_mem
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_mem
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate resources\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|typer
operator|=
name|bus_read_4
argument_list|(
name|sc
operator|->
name|sc_mem
argument_list|,
name|GICV2M_MSI_TYPER
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_spi_start
operator|=
name|MSI_TYPER_SPI_BASE
argument_list|(
name|typer
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_spi_count
operator|=
name|MSI_TYPER_SPI_COUNT
argument_list|(
name|typer
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_spi_end
operator|=
name|sc
operator|->
name|sc_spi_start
operator|+
name|sc
operator|->
name|sc_spi_count
expr_stmt|;
comment|/* Reserve these interrupts for MSI/MSI-X use */
name|arm_gic_reserve_msi_range
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_spi_start
argument_list|,
name|sc
operator|->
name|sc_spi_count
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_mutex
argument_list|,
literal|"GICv2m lock"
argument_list|,
literal|""
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|intr_msi_register
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|sc_xref
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"using spi %u to %u\n"
argument_list|,
name|sc
operator|->
name|sc_spi_start
argument_list|,
name|sc
operator|->
name|sc_spi_start
operator|+
name|sc
operator|->
name|sc_spi_count
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|arm_gicv2m_alloc_msi
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|count
parameter_list|,
name|int
name|maxcount
parameter_list|,
name|device_t
modifier|*
name|pic
parameter_list|,
name|struct
name|intr_irqsrc
modifier|*
modifier|*
name|srcs
parameter_list|)
block|{
name|struct
name|arm_gic_softc
modifier|*
name|psc
decl_stmt|;
name|struct
name|arm_gicv2m_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|i
decl_stmt|,
name|irq
decl_stmt|,
name|end_irq
decl_stmt|;
name|bool
name|found
decl_stmt|;
name|KASSERT
argument_list|(
name|powerof2
argument_list|(
name|count
argument_list|)
argument_list|,
operator|(
literal|"%s: bad count"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|powerof2
argument_list|(
name|maxcount
argument_list|)
argument_list|,
operator|(
literal|"%s: bad maxcount"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|psc
operator|=
name|device_get_softc
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mutex
argument_list|)
expr_stmt|;
name|found
operator|=
name|false
expr_stmt|;
for|for
control|(
name|irq
operator|=
name|sc
operator|->
name|sc_spi_start
init|;
name|irq
operator|<
name|sc
operator|->
name|sc_spi_end
condition|;
name|irq
operator|++
control|)
block|{
comment|/* Start on an aligned interrupt */
if|if
condition|(
operator|(
name|irq
operator|&
operator|(
name|maxcount
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
continue|continue;
comment|/* Assume we found a valid range until shown otherwise */
name|found
operator|=
name|true
expr_stmt|;
comment|/* Check this range is valid */
for|for
control|(
name|end_irq
operator|=
name|irq
init|;
name|end_irq
operator|!=
name|irq
operator|+
name|count
condition|;
name|end_irq
operator|++
control|)
block|{
comment|/* No free interrupts */
if|if
condition|(
name|end_irq
operator|==
name|sc
operator|->
name|sc_spi_end
condition|)
block|{
name|found
operator|=
name|false
expr_stmt|;
break|break;
block|}
name|KASSERT
argument_list|(
operator|(
name|psc
operator|->
name|gic_irqs
index|[
name|end_irq
index|]
operator|.
name|gi_flags
operator|&
name|GI_FLAG_MSI
operator|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"%s: Non-MSI interrupt found"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* This is already used */
if|if
condition|(
operator|(
name|psc
operator|->
name|gic_irqs
index|[
name|end_irq
index|]
operator|.
name|gi_flags
operator|&
name|GI_FLAG_MSI_USED
operator|)
operator|==
name|GI_FLAG_MSI_USED
condition|)
block|{
name|found
operator|=
name|false
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|found
condition|)
break|break;
block|}
comment|/* Not enough interrupts were found */
if|if
condition|(
operator|!
name|found
operator|||
name|irq
operator|==
name|sc
operator|->
name|sc_spi_end
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mutex
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
comment|/* Mark the interrupt as used */
name|psc
operator|->
name|gic_irqs
index|[
name|irq
operator|+
name|i
index|]
operator|.
name|gi_flags
operator||=
name|GI_FLAG_MSI_USED
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mutex
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
name|srcs
index|[
name|i
index|]
operator|=
operator|(
expr|struct
name|intr_irqsrc
operator|*
operator|)
operator|&
name|psc
operator|->
name|gic_irqs
index|[
name|irq
operator|+
name|i
index|]
expr_stmt|;
operator|*
name|pic
operator|=
name|device_get_parent
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|arm_gicv2m_release_msi
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|count
parameter_list|,
name|struct
name|intr_irqsrc
modifier|*
modifier|*
name|isrc
parameter_list|)
block|{
name|struct
name|arm_gicv2m_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|gic_irqsrc
modifier|*
name|gi
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mutex
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|gi
operator|=
operator|(
expr|struct
name|gic_irqsrc
operator|*
operator|)
name|isrc
index|[
name|i
index|]
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|gi
operator|->
name|gi_flags
operator|&
name|GI_FLAG_MSI_USED
operator|)
operator|==
name|GI_FLAG_MSI_USED
argument_list|,
operator|(
literal|"%s: Trying to release an unused MSI-X interrupt"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|gi
operator|->
name|gi_flags
operator|&=
operator|~
name|GI_FLAG_MSI_USED
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mutex
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|arm_gicv2m_alloc_msix
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|device_t
modifier|*
name|pic
parameter_list|,
name|struct
name|intr_irqsrc
modifier|*
modifier|*
name|isrcp
parameter_list|)
block|{
name|struct
name|arm_gicv2m_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|arm_gic_softc
modifier|*
name|psc
decl_stmt|;
name|int
name|irq
decl_stmt|;
name|psc
operator|=
name|device_get_softc
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mutex
argument_list|)
expr_stmt|;
comment|/* Find an unused interrupt */
for|for
control|(
name|irq
operator|=
name|sc
operator|->
name|sc_spi_start
init|;
name|irq
operator|<
name|sc
operator|->
name|sc_spi_end
condition|;
name|irq
operator|++
control|)
block|{
name|KASSERT
argument_list|(
operator|(
name|psc
operator|->
name|gic_irqs
index|[
name|irq
index|]
operator|.
name|gi_flags
operator|&
name|GI_FLAG_MSI
operator|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"%s: Non-MSI interrupt found"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|psc
operator|->
name|gic_irqs
index|[
name|irq
index|]
operator|.
name|gi_flags
operator|&
name|GI_FLAG_MSI_USED
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
comment|/* No free interrupt was found */
if|if
condition|(
name|irq
operator|==
name|sc
operator|->
name|sc_spi_end
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mutex
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Mark the interrupt as used */
name|psc
operator|->
name|gic_irqs
index|[
name|irq
index|]
operator|.
name|gi_flags
operator||=
name|GI_FLAG_MSI_USED
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mutex
argument_list|)
expr_stmt|;
operator|*
name|isrcp
operator|=
operator|(
expr|struct
name|intr_irqsrc
operator|*
operator|)
operator|&
name|psc
operator|->
name|gic_irqs
index|[
name|irq
index|]
expr_stmt|;
operator|*
name|pic
operator|=
name|device_get_parent
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|arm_gicv2m_release_msix
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|struct
name|intr_irqsrc
modifier|*
name|isrc
parameter_list|)
block|{
name|struct
name|arm_gicv2m_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|gic_irqsrc
modifier|*
name|gi
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|gi
operator|=
operator|(
expr|struct
name|gic_irqsrc
operator|*
operator|)
name|isrc
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|gi
operator|->
name|gi_flags
operator|&
name|GI_FLAG_MSI_USED
operator|)
operator|==
name|GI_FLAG_MSI_USED
argument_list|,
operator|(
literal|"%s: Trying to release an unused MSI-X interrupt"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mutex
argument_list|)
expr_stmt|;
name|gi
operator|->
name|gi_flags
operator|&=
operator|~
name|GI_FLAG_MSI_USED
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mutex
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|arm_gicv2m_map_msi
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|struct
name|intr_irqsrc
modifier|*
name|isrc
parameter_list|,
name|uint64_t
modifier|*
name|addr
parameter_list|,
name|uint32_t
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|arm_gicv2m_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|gic_irqsrc
modifier|*
name|gi
init|=
operator|(
expr|struct
name|gic_irqsrc
operator|*
operator|)
name|isrc
decl_stmt|;
operator|*
name|addr
operator|=
name|vtophys
argument_list|(
name|rman_get_virtual
argument_list|(
name|sc
operator|->
name|sc_mem
argument_list|)
argument_list|)
operator|+
name|GICv2M_MSI_SETSPI_NS
expr_stmt|;
operator|*
name|data
operator|=
name|gi
operator|->
name|gi_irq
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|arm_gicv2m_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|arm_gicv2m_attach
argument_list|)
block|,
comment|/* MSI/MSI-X */
name|DEVMETHOD
argument_list|(
name|msi_alloc_msi
argument_list|,
name|arm_gicv2m_alloc_msi
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|msi_release_msi
argument_list|,
name|arm_gicv2m_release_msi
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|msi_alloc_msix
argument_list|,
name|arm_gicv2m_alloc_msix
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|msi_release_msix
argument_list|,
name|arm_gicv2m_release_msix
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|msi_map_msi
argument_list|,
name|arm_gicv2m_map_msi
argument_list|)
block|,
comment|/* End */
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DEFINE_CLASS_0
argument_list|(
name|gicv2m
argument_list|,
name|arm_gicv2m_driver
argument_list|,
name|arm_gicv2m_methods
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|arm_gicv2m_softc
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

end_unit

