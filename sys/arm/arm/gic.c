begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2011 The FreeBSD Foundation  * All rights reserved.  *  * Developed by Damjan Marion<damjan.marion@gmail.com>  *  * Based on OMAP4 GIC code by Ben Gray  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the company nor the name of the author may be used to  *    endorse or promote products derived from this software without specific  *    prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_platform.h"
end_include

begin_include
include|#
directive|include
file|"opt_platform.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/pcpu.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/cpuset.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ARM_INTRNG
end_ifdef

begin_include
include|#
directive|include
file|<sys/sched.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/intr.h>
end_include

begin_include
include|#
directive|include
file|<machine/smp.h>
end_include

begin_include
include|#
directive|include
file|<dev/fdt/fdt_common.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/openfirm.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/ofw_bus.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/ofw_bus_subr.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ARM_INTRNG
end_ifdef

begin_include
include|#
directive|include
file|"pic_if.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|GIC_DEBUG_SPURIOUS
end_define

begin_comment
comment|/* We are using GICv2 register naming */
end_comment

begin_comment
comment|/* Distributor Registers */
end_comment

begin_define
define|#
directive|define
name|GICD_CTLR
value|0x000
end_define

begin_comment
comment|/* v1 ICDDCR */
end_comment

begin_define
define|#
directive|define
name|GICD_TYPER
value|0x004
end_define

begin_comment
comment|/* v1 ICDICTR */
end_comment

begin_define
define|#
directive|define
name|GICD_IIDR
value|0x008
end_define

begin_comment
comment|/* v1 ICDIIDR */
end_comment

begin_define
define|#
directive|define
name|GICD_IGROUPR
parameter_list|(
name|n
parameter_list|)
value|(0x0080 + ((n) * 4))
end_define

begin_comment
comment|/* v1 ICDISER */
end_comment

begin_define
define|#
directive|define
name|GICD_ISENABLER
parameter_list|(
name|n
parameter_list|)
value|(0x0100 + ((n) * 4))
end_define

begin_comment
comment|/* v1 ICDISER */
end_comment

begin_define
define|#
directive|define
name|GICD_ICENABLER
parameter_list|(
name|n
parameter_list|)
value|(0x0180 + ((n) * 4))
end_define

begin_comment
comment|/* v1 ICDICER */
end_comment

begin_define
define|#
directive|define
name|GICD_ISPENDR
parameter_list|(
name|n
parameter_list|)
value|(0x0200 + ((n) * 4))
end_define

begin_comment
comment|/* v1 ICDISPR */
end_comment

begin_define
define|#
directive|define
name|GICD_ICPENDR
parameter_list|(
name|n
parameter_list|)
value|(0x0280 + ((n) * 4))
end_define

begin_comment
comment|/* v1 ICDICPR */
end_comment

begin_define
define|#
directive|define
name|GICD_ICACTIVER
parameter_list|(
name|n
parameter_list|)
value|(0x0380 + ((n) * 4))
end_define

begin_comment
comment|/* v1 ICDABR */
end_comment

begin_define
define|#
directive|define
name|GICD_IPRIORITYR
parameter_list|(
name|n
parameter_list|)
value|(0x0400 + ((n) * 4))
end_define

begin_comment
comment|/* v1 ICDIPR */
end_comment

begin_define
define|#
directive|define
name|GICD_ITARGETSR
parameter_list|(
name|n
parameter_list|)
value|(0x0800 + ((n) * 4))
end_define

begin_comment
comment|/* v1 ICDIPTR */
end_comment

begin_define
define|#
directive|define
name|GICD_ICFGR
parameter_list|(
name|n
parameter_list|)
value|(0x0C00 + ((n) * 4))
end_define

begin_comment
comment|/* v1 ICDICFR */
end_comment

begin_define
define|#
directive|define
name|GICD_SGIR
parameter_list|(
name|n
parameter_list|)
value|(0x0F00 + ((n) * 4))
end_define

begin_comment
comment|/* v1 ICDSGIR */
end_comment

begin_comment
comment|/* CPU Registers */
end_comment

begin_define
define|#
directive|define
name|GICC_CTLR
value|0x0000
end_define

begin_comment
comment|/* v1 ICCICR */
end_comment

begin_define
define|#
directive|define
name|GICC_PMR
value|0x0004
end_define

begin_comment
comment|/* v1 ICCPMR */
end_comment

begin_define
define|#
directive|define
name|GICC_BPR
value|0x0008
end_define

begin_comment
comment|/* v1 ICCBPR */
end_comment

begin_define
define|#
directive|define
name|GICC_IAR
value|0x000C
end_define

begin_comment
comment|/* v1 ICCIAR */
end_comment

begin_define
define|#
directive|define
name|GICC_EOIR
value|0x0010
end_define

begin_comment
comment|/* v1 ICCEOIR */
end_comment

begin_define
define|#
directive|define
name|GICC_RPR
value|0x0014
end_define

begin_comment
comment|/* v1 ICCRPR */
end_comment

begin_define
define|#
directive|define
name|GICC_HPPIR
value|0x0018
end_define

begin_comment
comment|/* v1 ICCHPIR */
end_comment

begin_define
define|#
directive|define
name|GICC_ABPR
value|0x001C
end_define

begin_comment
comment|/* v1 ICCABPR */
end_comment

begin_define
define|#
directive|define
name|GICC_IIDR
value|0x00FC
end_define

begin_comment
comment|/* v1 ICCIIDR*/
end_comment

begin_define
define|#
directive|define
name|GIC_FIRST_SGI
value|0
end_define

begin_comment
comment|/* Irqs 0-15 are SGIs/IPIs. */
end_comment

begin_define
define|#
directive|define
name|GIC_LAST_SGI
value|15
end_define

begin_define
define|#
directive|define
name|GIC_FIRST_PPI
value|16
end_define

begin_comment
comment|/* Irqs 16-31 are private (per */
end_comment

begin_define
define|#
directive|define
name|GIC_LAST_PPI
value|31
end_define

begin_comment
comment|/* core) peripheral interrupts. */
end_comment

begin_define
define|#
directive|define
name|GIC_FIRST_SPI
value|32
end_define

begin_comment
comment|/* Irqs 32+ are shared peripherals. */
end_comment

begin_comment
comment|/* First bit is a polarity bit (0 - low, 1 - high) */
end_comment

begin_define
define|#
directive|define
name|GICD_ICFGR_POL_LOW
value|(0<< 0)
end_define

begin_define
define|#
directive|define
name|GICD_ICFGR_POL_HIGH
value|(1<< 0)
end_define

begin_define
define|#
directive|define
name|GICD_ICFGR_POL_MASK
value|0x1
end_define

begin_comment
comment|/* Second bit is a trigger bit (0 - level, 1 - edge) */
end_comment

begin_define
define|#
directive|define
name|GICD_ICFGR_TRIG_LVL
value|(0<< 1)
end_define

begin_define
define|#
directive|define
name|GICD_ICFGR_TRIG_EDGE
value|(1<< 1)
end_define

begin_define
define|#
directive|define
name|GICD_ICFGR_TRIG_MASK
value|0x2
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|GIC_DEFAULT_ICFGR_INIT
end_ifndef

begin_define
define|#
directive|define
name|GIC_DEFAULT_ICFGR_INIT
value|0x00000000
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|ARM_INTRNG
end_ifdef

begin_decl_stmt
specifier|static
name|u_int
name|gic_irq_cpu
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|arm_gic_intr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|arm_gic_bind
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|intr_irqsrc
modifier|*
name|isrc
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|arm_gic_softc
block|{
name|device_t
name|gic_dev
decl_stmt|;
ifdef|#
directive|ifdef
name|ARM_INTRNG
name|void
modifier|*
name|gic_intrhand
decl_stmt|;
name|struct
name|intr_irqsrc
modifier|*
modifier|*
name|gic_irqs
decl_stmt|;
endif|#
directive|endif
name|struct
name|resource
modifier|*
name|gic_res
index|[
literal|3
index|]
decl_stmt|;
name|bus_space_tag_t
name|gic_c_bst
decl_stmt|;
name|bus_space_tag_t
name|gic_d_bst
decl_stmt|;
name|bus_space_handle_t
name|gic_c_bsh
decl_stmt|;
name|bus_space_handle_t
name|gic_d_bsh
decl_stmt|;
name|uint8_t
name|ver
decl_stmt|;
name|struct
name|mtx
name|mutex
decl_stmt|;
name|uint32_t
name|nirqs
decl_stmt|;
ifdef|#
directive|ifdef
name|GIC_DEBUG_SPURIOUS
name|uint32_t
name|last_irq
index|[
name|MAXCPU
index|]
decl_stmt|;
endif|#
directive|endif
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|resource_spec
name|arm_gic_spec
index|[]
init|=
block|{
block|{
name|SYS_RES_MEMORY
block|,
literal|0
block|,
name|RF_ACTIVE
block|}
block|,
comment|/* Distributor registers */
block|{
name|SYS_RES_MEMORY
block|,
literal|1
block|,
name|RF_ACTIVE
block|}
block|,
comment|/* CPU Interrupt Intf. registers */
ifdef|#
directive|ifdef
name|ARM_INTRNG
block|{
name|SYS_RES_IRQ
block|,
literal|0
block|,
name|RF_ACTIVE
operator||
name|RF_OPTIONAL
block|}
block|,
comment|/* Parent interrupt */
endif|#
directive|endif
block|{
operator|-
literal|1
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|arm_gic_softc
modifier|*
name|gic_sc
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|gic_c_read_4
parameter_list|(
name|_sc
parameter_list|,
name|_reg
parameter_list|)
define|\
value|bus_space_read_4((_sc)->gic_c_bst, (_sc)->gic_c_bsh, (_reg))
end_define

begin_define
define|#
directive|define
name|gic_c_write_4
parameter_list|(
name|_sc
parameter_list|,
name|_reg
parameter_list|,
name|_val
parameter_list|)
define|\
value|bus_space_write_4((_sc)->gic_c_bst, (_sc)->gic_c_bsh, (_reg), (_val))
end_define

begin_define
define|#
directive|define
name|gic_d_read_4
parameter_list|(
name|_sc
parameter_list|,
name|_reg
parameter_list|)
define|\
value|bus_space_read_4((_sc)->gic_d_bst, (_sc)->gic_d_bsh, (_reg))
end_define

begin_define
define|#
directive|define
name|gic_d_write_1
parameter_list|(
name|_sc
parameter_list|,
name|_reg
parameter_list|,
name|_val
parameter_list|)
define|\
value|bus_space_write_1((_sc)->gic_d_bst, (_sc)->gic_d_bsh, (_reg), (_val))
end_define

begin_define
define|#
directive|define
name|gic_d_write_4
parameter_list|(
name|_sc
parameter_list|,
name|_reg
parameter_list|,
name|_val
parameter_list|)
define|\
value|bus_space_write_4((_sc)->gic_d_bst, (_sc)->gic_d_bsh, (_reg), (_val))
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|ARM_INTRNG
end_ifndef

begin_function_decl
specifier|static
name|int
name|gic_config_irq
parameter_list|(
name|int
name|irq
parameter_list|,
name|enum
name|intr_trigger
name|trig
parameter_list|,
name|enum
name|intr_polarity
name|pol
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gic_post_filter
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|ofw_compat_data
name|compat_data
index|[]
init|=
block|{
block|{
literal|"arm,gic"
block|,
name|true
block|}
block|,
comment|/* Non-standard, used in FreeBSD dts. */
block|{
literal|"arm,gic-400"
block|,
name|true
block|}
block|,
block|{
literal|"arm,cortex-a15-gic"
block|,
name|true
block|}
block|,
block|{
literal|"arm,cortex-a9-gic"
block|,
name|true
block|}
block|,
block|{
literal|"arm,cortex-a7-gic"
block|,
name|true
block|}
block|,
block|{
literal|"arm,arm11mp-gic"
block|,
name|true
block|}
block|,
block|{
literal|"brcm,brahma-b15-gic"
block|,
name|true
block|}
block|,
block|{
name|NULL
block|,
name|false
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|arm_gic_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ofw_bus_status_okay
argument_list|(
name|dev
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
operator|!
name|ofw_bus_search_compatible
argument_list|(
name|dev
argument_list|,
name|compat_data
argument_list|)
operator|->
name|ocd_data
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"ARM Generic Interrupt Controller"
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ARM_INTRNG
end_ifdef

begin_function
specifier|static
specifier|inline
name|void
name|gic_irq_unmask
parameter_list|(
name|struct
name|arm_gic_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|irq
parameter_list|)
block|{
name|gic_d_write_4
argument_list|(
name|sc
argument_list|,
name|GICD_ISENABLER
argument_list|(
name|irq
operator|>>
literal|5
argument_list|)
argument_list|,
operator|(
literal|1UL
operator|<<
operator|(
name|irq
operator|&
literal|0x1F
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|gic_irq_mask
parameter_list|(
name|struct
name|arm_gic_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|irq
parameter_list|)
block|{
name|gic_d_write_4
argument_list|(
name|sc
argument_list|,
name|GICD_ICENABLER
argument_list|(
name|irq
operator|>>
literal|5
argument_list|)
argument_list|,
operator|(
literal|1UL
operator|<<
operator|(
name|irq
operator|&
literal|0x1F
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SMP
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|ARM_INTRNG
end_ifdef

begin_function
specifier|static
name|void
name|arm_gic_init_secondary
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|arm_gic_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|intr_irqsrc
modifier|*
name|isrc
decl_stmt|;
name|u_int
name|irq
decl_stmt|;
for|for
control|(
name|irq
operator|=
literal|0
init|;
name|irq
operator|<
name|sc
operator|->
name|nirqs
condition|;
name|irq
operator|+=
literal|4
control|)
name|gic_d_write_4
argument_list|(
name|sc
argument_list|,
name|GICD_IPRIORITYR
argument_list|(
name|irq
operator|>>
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set all the interrupts to be in Group 0 (secure) */
for|for
control|(
name|irq
operator|=
literal|0
init|;
name|irq
operator|<
name|sc
operator|->
name|nirqs
condition|;
name|irq
operator|+=
literal|32
control|)
block|{
name|gic_d_write_4
argument_list|(
name|sc
argument_list|,
name|GICD_IGROUPR
argument_list|(
name|irq
operator|>>
literal|5
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Enable CPU interface */
name|gic_c_write_4
argument_list|(
name|sc
argument_list|,
name|GICC_CTLR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Set priority mask register. */
name|gic_c_write_4
argument_list|(
name|sc
argument_list|,
name|GICC_PMR
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* Enable interrupt distribution */
name|gic_d_write_4
argument_list|(
name|sc
argument_list|,
name|GICD_CTLR
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
comment|/* Unmask attached SGI interrupts. */
for|for
control|(
name|irq
operator|=
name|GIC_FIRST_SGI
init|;
name|irq
operator|<=
name|GIC_LAST_SGI
condition|;
name|irq
operator|++
control|)
block|{
name|isrc
operator|=
name|sc
operator|->
name|gic_irqs
index|[
name|irq
index|]
expr_stmt|;
if|if
condition|(
name|isrc
operator|!=
name|NULL
operator|&&
name|isrc
operator|->
name|isrc_handlers
operator|!=
literal|0
condition|)
block|{
name|CPU_SET
argument_list|(
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
argument_list|,
operator|&
name|isrc
operator|->
name|isrc_cpu
argument_list|)
expr_stmt|;
name|gic_irq_unmask
argument_list|(
name|sc
argument_list|,
name|irq
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Unmask attached PPI interrupts. */
for|for
control|(
name|irq
operator|=
name|GIC_FIRST_PPI
init|;
name|irq
operator|<=
name|GIC_LAST_PPI
condition|;
name|irq
operator|++
control|)
block|{
name|isrc
operator|=
name|sc
operator|->
name|gic_irqs
index|[
name|irq
index|]
expr_stmt|;
if|if
condition|(
name|isrc
operator|==
name|NULL
operator|||
name|isrc
operator|->
name|isrc_handlers
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|isrc
operator|->
name|isrc_flags
operator|&
name|INTR_ISRCF_BOUND
condition|)
block|{
if|if
condition|(
name|CPU_ISSET
argument_list|(
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
argument_list|,
operator|&
name|isrc
operator|->
name|isrc_cpu
argument_list|)
condition|)
name|gic_irq_unmask
argument_list|(
name|sc
argument_list|,
name|irq
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CPU_SET
argument_list|(
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
argument_list|,
operator|&
name|isrc
operator|->
name|isrc_cpu
argument_list|)
expr_stmt|;
name|gic_irq_unmask
argument_list|(
name|sc
argument_list|,
name|irq
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|void
name|arm_gic_init_secondary
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|arm_gic_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|nirqs
condition|;
name|i
operator|+=
literal|4
control|)
name|gic_d_write_4
argument_list|(
name|sc
argument_list|,
name|GICD_IPRIORITYR
argument_list|(
name|i
operator|>>
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set all the interrupts to be in Group 0 (secure) */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|nirqs
condition|;
name|i
operator|+=
literal|32
control|)
block|{
name|gic_d_write_4
argument_list|(
name|sc
argument_list|,
name|GICD_IGROUPR
argument_list|(
name|i
operator|>>
literal|5
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Enable CPU interface */
name|gic_c_write_4
argument_list|(
name|sc
argument_list|,
name|GICC_CTLR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Set priority mask register. */
name|gic_c_write_4
argument_list|(
name|sc
argument_list|,
name|GICC_PMR
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* Enable interrupt distribution */
name|gic_d_write_4
argument_list|(
name|sc
argument_list|,
name|GICD_CTLR
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
comment|/* 	 * Activate the timer interrupts: virtual, secure, and non-secure. 	 */
name|gic_d_write_4
argument_list|(
name|sc
argument_list|,
name|GICD_ISENABLER
argument_list|(
literal|27
operator|>>
literal|5
argument_list|)
argument_list|,
operator|(
literal|1UL
operator|<<
operator|(
literal|27
operator|&
literal|0x1F
operator|)
operator|)
argument_list|)
expr_stmt|;
name|gic_d_write_4
argument_list|(
name|sc
argument_list|,
name|GICD_ISENABLER
argument_list|(
literal|29
operator|>>
literal|5
argument_list|)
argument_list|,
operator|(
literal|1UL
operator|<<
operator|(
literal|29
operator|&
literal|0x1F
operator|)
operator|)
argument_list|)
expr_stmt|;
name|gic_d_write_4
argument_list|(
name|sc
argument_list|,
name|GICD_ISENABLER
argument_list|(
literal|30
operator|>>
literal|5
argument_list|)
argument_list|,
operator|(
literal|1UL
operator|<<
operator|(
literal|30
operator|&
literal|0x1F
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ARM_INTRNG */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SMP */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ARM_INTRNG
end_ifndef

begin_function
name|int
name|gic_decode_fdt
parameter_list|(
name|phandle_t
name|iparent
parameter_list|,
name|pcell_t
modifier|*
name|intr
parameter_list|,
name|int
modifier|*
name|interrupt
parameter_list|,
name|int
modifier|*
name|trig
parameter_list|,
name|int
modifier|*
name|pol
parameter_list|)
block|{
specifier|static
name|u_int
name|num_intr_cells
decl_stmt|;
specifier|static
name|phandle_t
name|self
decl_stmt|;
name|struct
name|ofw_compat_data
modifier|*
name|ocd
decl_stmt|;
if|if
condition|(
name|self
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|ocd
operator|=
name|compat_data
init|;
name|ocd
operator|->
name|ocd_str
operator|!=
name|NULL
condition|;
name|ocd
operator|++
control|)
block|{
if|if
condition|(
name|fdt_is_compatible
argument_list|(
name|iparent
argument_list|,
name|ocd
operator|->
name|ocd_str
argument_list|)
condition|)
block|{
name|self
operator|=
name|iparent
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|self
operator|!=
name|iparent
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|num_intr_cells
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|OF_searchencprop
argument_list|(
name|OF_node_from_xref
argument_list|(
name|iparent
argument_list|)
argument_list|,
literal|"#interrupt-cells"
argument_list|,
operator|&
name|num_intr_cells
argument_list|,
sizeof|sizeof
argument_list|(
name|num_intr_cells
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|num_intr_cells
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|num_intr_cells
operator|==
literal|1
condition|)
block|{
operator|*
name|interrupt
operator|=
name|fdt32_to_cpu
argument_list|(
name|intr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
operator|*
name|trig
operator|=
name|INTR_TRIGGER_CONFORM
expr_stmt|;
operator|*
name|pol
operator|=
name|INTR_POLARITY_CONFORM
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|fdt32_to_cpu
argument_list|(
name|intr
index|[
literal|0
index|]
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|interrupt
operator|=
name|fdt32_to_cpu
argument_list|(
name|intr
index|[
literal|1
index|]
argument_list|)
operator|+
name|GIC_FIRST_SPI
expr_stmt|;
else|else
operator|*
name|interrupt
operator|=
name|fdt32_to_cpu
argument_list|(
name|intr
index|[
literal|1
index|]
argument_list|)
operator|+
name|GIC_FIRST_PPI
expr_stmt|;
comment|/* 		 * In intr[2], bits[3:0] are trigger type and level flags. 		 *   1 = low-to-high edge triggered 		 *   2 = high-to-low edge triggered 		 *   4 = active high level-sensitive 		 *   8 = active low level-sensitive 		 * The hardware only supports active-high-level or rising-edge 		 * for SPIs 		 */
if|if
condition|(
operator|*
name|interrupt
operator|>=
name|GIC_FIRST_SPI
operator|&&
name|fdt32_to_cpu
argument_list|(
name|intr
index|[
literal|2
index|]
argument_list|)
operator|&
literal|0x0a
condition|)
block|{
name|printf
argument_list|(
literal|"unsupported trigger/polarity configuration "
literal|"0x%02x\n"
argument_list|,
name|fdt32_to_cpu
argument_list|(
name|intr
index|[
literal|2
index|]
argument_list|)
operator|&
literal|0x0f
argument_list|)
expr_stmt|;
block|}
operator|*
name|pol
operator|=
name|INTR_POLARITY_CONFORM
expr_stmt|;
if|if
condition|(
name|fdt32_to_cpu
argument_list|(
name|intr
index|[
literal|2
index|]
argument_list|)
operator|&
literal|0x03
condition|)
operator|*
name|trig
operator|=
name|INTR_TRIGGER_EDGE
expr_stmt|;
else|else
operator|*
name|trig
operator|=
name|INTR_TRIGGER_LEVEL
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|ARM_INTRNG
end_ifdef

begin_function
specifier|static
specifier|inline
name|intptr_t
name|gic_xref
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|FDT
return|return
operator|(
name|OF_xref_from_node
argument_list|(
name|ofw_bus_get_node
argument_list|(
name|dev
argument_list|)
argument_list|)
operator|)
return|;
else|#
directive|else
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|arm_gic_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|arm_gic_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint32_t
name|icciidr
decl_stmt|;
ifdef|#
directive|ifdef
name|ARM_INTRNG
name|phandle_t
name|pxref
decl_stmt|;
name|intptr_t
name|xref
init|=
name|gic_xref
argument_list|(
name|dev
argument_list|)
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|gic_sc
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus_alloc_resources
argument_list|(
name|dev
argument_list|,
name|arm_gic_spec
argument_list|,
name|sc
operator|->
name|gic_res
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not allocate resources\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|sc
operator|->
name|gic_dev
operator|=
name|dev
expr_stmt|;
name|gic_sc
operator|=
name|sc
expr_stmt|;
comment|/* Initialize mutex */
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|mutex
argument_list|,
literal|"GIC lock"
argument_list|,
literal|""
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
comment|/* Distributor Interface */
name|sc
operator|->
name|gic_d_bst
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|gic_res
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|gic_d_bsh
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|gic_res
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* CPU Interface */
name|sc
operator|->
name|gic_c_bst
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|gic_res
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|gic_c_bsh
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|gic_res
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* Disable interrupt forwarding to the CPU interface */
name|gic_d_write_4
argument_list|(
name|sc
argument_list|,
name|GICD_CTLR
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* Get the number of interrupts */
name|sc
operator|->
name|nirqs
operator|=
name|gic_d_read_4
argument_list|(
name|sc
argument_list|,
name|GICD_TYPER
argument_list|)
expr_stmt|;
name|sc
operator|->
name|nirqs
operator|=
literal|32
operator|*
operator|(
operator|(
name|sc
operator|->
name|nirqs
operator|&
literal|0x1f
operator|)
operator|+
literal|1
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ARM_INTRNG
name|sc
operator|->
name|gic_irqs
operator|=
name|malloc
argument_list|(
name|sc
operator|->
name|nirqs
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|sc
operator|->
name|gic_irqs
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Set up function pointers */
name|arm_post_filter
operator|=
name|gic_post_filter
expr_stmt|;
name|arm_config_irq
operator|=
name|gic_config_irq
expr_stmt|;
endif|#
directive|endif
name|icciidr
operator|=
name|gic_c_read_4
argument_list|(
name|sc
argument_list|,
name|GICC_IIDR
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"pn 0x%x, arch 0x%x, rev 0x%x, implementer 0x%x irqs %u\n"
argument_list|,
name|icciidr
operator|>>
literal|20
argument_list|,
operator|(
name|icciidr
operator|>>
literal|16
operator|)
operator|&
literal|0xF
argument_list|,
operator|(
name|icciidr
operator|>>
literal|12
operator|)
operator|&
literal|0xf
argument_list|,
operator|(
name|icciidr
operator|&
literal|0xfff
operator|)
argument_list|,
name|sc
operator|->
name|nirqs
argument_list|)
expr_stmt|;
comment|/* Set all global interrupts to be level triggered, active low. */
for|for
control|(
name|i
operator|=
literal|32
init|;
name|i
operator|<
name|sc
operator|->
name|nirqs
condition|;
name|i
operator|+=
literal|16
control|)
block|{
name|gic_d_write_4
argument_list|(
name|sc
argument_list|,
name|GICD_ICFGR
argument_list|(
name|i
operator|>>
literal|4
argument_list|)
argument_list|,
name|GIC_DEFAULT_ICFGR_INIT
argument_list|)
expr_stmt|;
block|}
comment|/* Disable all interrupts. */
for|for
control|(
name|i
operator|=
literal|32
init|;
name|i
operator|<
name|sc
operator|->
name|nirqs
condition|;
name|i
operator|+=
literal|32
control|)
block|{
name|gic_d_write_4
argument_list|(
name|sc
argument_list|,
name|GICD_ICENABLER
argument_list|(
name|i
operator|>>
literal|5
argument_list|)
argument_list|,
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|nirqs
condition|;
name|i
operator|+=
literal|4
control|)
block|{
name|gic_d_write_4
argument_list|(
name|sc
argument_list|,
name|GICD_IPRIORITYR
argument_list|(
name|i
operator|>>
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gic_d_write_4
argument_list|(
name|sc
argument_list|,
name|GICD_ITARGETSR
argument_list|(
name|i
operator|>>
literal|2
argument_list|)
argument_list|,
literal|1
operator|<<
literal|0
operator||
literal|1
operator|<<
literal|8
operator||
literal|1
operator|<<
literal|16
operator||
literal|1
operator|<<
literal|24
argument_list|)
expr_stmt|;
block|}
comment|/* Set all the interrupts to be in Group 0 (secure) */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|nirqs
condition|;
name|i
operator|+=
literal|32
control|)
block|{
name|gic_d_write_4
argument_list|(
name|sc
argument_list|,
name|GICD_IGROUPR
argument_list|(
name|i
operator|>>
literal|5
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Enable CPU interface */
name|gic_c_write_4
argument_list|(
name|sc
argument_list|,
name|GICC_CTLR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Set priority mask register. */
name|gic_c_write_4
argument_list|(
name|sc
argument_list|,
name|GICC_PMR
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* Enable interrupt distribution */
name|gic_d_write_4
argument_list|(
name|sc
argument_list|,
name|GICD_CTLR
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ARM_INTRNG
return|return
operator|(
literal|0
operator|)
return|;
else|#
directive|else
comment|/* 	 * Now, when everything is initialized, it's right time to 	 * register interrupt controller to interrupt framefork. 	 */
if|if
condition|(
name|intr_pic_register
argument_list|(
name|dev
argument_list|,
name|xref
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not register PIC\n"
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* 	 * Controller is root if: 	 * - doesn't have interrupt parent 	 * - his interrupt parent is this controller 	 */
name|pxref
operator|=
name|ofw_bus_find_iparent
argument_list|(
name|ofw_bus_get_node
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pxref
operator|==
literal|0
operator|||
name|xref
operator|==
name|pxref
condition|)
block|{
if|if
condition|(
name|intr_pic_claim_root
argument_list|(
name|dev
argument_list|,
name|xref
argument_list|,
name|arm_gic_intr
argument_list|,
name|sc
argument_list|,
name|GIC_LAST_SGI
operator|-
name|GIC_FIRST_SGI
operator|+
literal|1
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not set PIC as a root\n"
argument_list|)
expr_stmt|;
name|intr_pic_unregister
argument_list|(
name|dev
argument_list|,
name|xref
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|sc
operator|->
name|gic_res
index|[
literal|2
index|]
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"not root PIC must have defined interrupt\n"
argument_list|)
expr_stmt|;
name|intr_pic_unregister
argument_list|(
name|dev
argument_list|,
name|xref
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
if|if
condition|(
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|gic_res
index|[
literal|2
index|]
argument_list|,
name|INTR_TYPE_CLK
argument_list|,
name|arm_gic_intr
argument_list|,
name|NULL
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|gic_intrhand
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not setup irq handler\n"
argument_list|)
expr_stmt|;
name|intr_pic_unregister
argument_list|(
name|dev
argument_list|,
name|xref
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
block|}
name|OF_device_register_xref
argument_list|(
name|xref
argument_list|,
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|cleanup
label|:
comment|/* 	 * XXX - not implemented arm_gic_detach() should be called ! 	 */
if|if
condition|(
name|sc
operator|->
name|gic_irqs
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sc
operator|->
name|gic_irqs
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|bus_release_resources
argument_list|(
name|dev
argument_list|,
name|arm_gic_spec
argument_list|,
name|sc
operator|->
name|gic_res
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ARM_INTRNG
end_ifdef

begin_function
specifier|static
name|int
name|arm_gic_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|arm_gic_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|intr_irqsrc
modifier|*
name|isrc
decl_stmt|;
name|uint32_t
name|irq_active_reg
decl_stmt|,
name|irq
decl_stmt|;
name|struct
name|trapframe
modifier|*
name|tf
decl_stmt|;
name|irq_active_reg
operator|=
name|gic_c_read_4
argument_list|(
name|sc
argument_list|,
name|GICC_IAR
argument_list|)
expr_stmt|;
name|irq
operator|=
name|irq_active_reg
operator|&
literal|0x3FF
expr_stmt|;
comment|/* 	 * 1. We do EOI here because recent read value from active interrupt 	 *    register must be used for it. Another approach is to save this 	 *    value into associated interrupt source. 	 * 2. EOI must be done on same CPU where interrupt has fired. Thus 	 *    we must ensure that interrupted thread does not migrate to 	 *    another CPU. 	 * 3. EOI cannot be delayed by any preemption which could happen on 	 *    critical_exit() used in MI intr code, when interrupt thread is 	 *    scheduled. See next point. 	 * 4. IPI_RENDEZVOUS assumes that no preemption is permitted during 	 *    an action and any use of critical_exit() could break this 	 *    assumption. See comments within smp_rendezvous_action(). 	 * 5. We always return FILTER_HANDLED as this is an interrupt 	 *    controller dispatch function. Otherwise, in cascaded interrupt 	 *    case, the whole interrupt subtree would be masked. 	 */
if|if
condition|(
name|irq
operator|>=
name|sc
operator|->
name|nirqs
condition|)
block|{
ifdef|#
directive|ifdef
name|GIC_DEBUG_SPURIOUS
name|device_printf
argument_list|(
name|sc
operator|->
name|gic_dev
argument_list|,
literal|"Spurious interrupt detected: last irq: %d on CPU%d\n"
argument_list|,
name|sc
operator|->
name|last_irq
index|[
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
index|]
argument_list|,
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|FILTER_HANDLED
operator|)
return|;
block|}
name|tf
operator|=
name|curthread
operator|->
name|td_intr_frame
expr_stmt|;
name|dispatch_irq
label|:
name|isrc
operator|=
name|sc
operator|->
name|gic_irqs
index|[
name|irq
index|]
expr_stmt|;
if|if
condition|(
name|isrc
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|gic_dev
argument_list|,
literal|"Stray interrupt %u detected\n"
argument_list|,
name|irq
argument_list|)
expr_stmt|;
name|gic_irq_mask
argument_list|(
name|sc
argument_list|,
name|irq
argument_list|)
expr_stmt|;
name|gic_c_write_4
argument_list|(
name|sc
argument_list|,
name|GICC_EOIR
argument_list|,
name|irq_active_reg
argument_list|)
expr_stmt|;
goto|goto
name|next_irq
goto|;
block|}
comment|/* 	 * Note that GIC_FIRST_SGI is zero and is not used in 'if' statement 	 * as compiler complains that comparing u_int>= 0 is always true. 	 */
if|if
condition|(
name|irq
operator|<=
name|GIC_LAST_SGI
condition|)
block|{
ifdef|#
directive|ifdef
name|SMP
comment|/* Call EOI for all IPI before dispatch. */
name|gic_c_write_4
argument_list|(
name|sc
argument_list|,
name|GICC_EOIR
argument_list|,
name|irq_active_reg
argument_list|)
expr_stmt|;
name|intr_ipi_dispatch
argument_list|(
name|isrc
argument_list|,
name|tf
argument_list|)
expr_stmt|;
goto|goto
name|next_irq
goto|;
else|#
directive|else
name|device_printf
argument_list|(
name|sc
operator|->
name|gic_dev
argument_list|,
literal|"SGI %u on UP system detected\n"
argument_list|,
name|irq
operator|-
name|GIC_FIRST_SGI
argument_list|)
expr_stmt|;
name|gic_c_write_4
argument_list|(
name|sc
argument_list|,
name|GICC_EOIR
argument_list|,
name|irq_active_reg
argument_list|)
expr_stmt|;
goto|goto
name|next_irq
goto|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|GIC_DEBUG_SPURIOUS
name|sc
operator|->
name|last_irq
index|[
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
index|]
operator|=
name|irq
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|isrc
operator|->
name|isrc_trig
operator|==
name|INTR_TRIGGER_EDGE
condition|)
name|gic_c_write_4
argument_list|(
name|sc
argument_list|,
name|GICC_EOIR
argument_list|,
name|irq_active_reg
argument_list|)
expr_stmt|;
name|intr_irq_dispatch
argument_list|(
name|isrc
argument_list|,
name|tf
argument_list|)
expr_stmt|;
name|next_irq
label|:
name|arm_irq_memory_barrier
argument_list|(
name|irq
argument_list|)
expr_stmt|;
name|irq_active_reg
operator|=
name|gic_c_read_4
argument_list|(
name|sc
argument_list|,
name|GICC_IAR
argument_list|)
expr_stmt|;
name|irq
operator|=
name|irq_active_reg
operator|&
literal|0x3FF
expr_stmt|;
if|if
condition|(
name|irq
operator|<
name|sc
operator|->
name|nirqs
condition|)
goto|goto
name|dispatch_irq
goto|;
return|return
operator|(
name|FILTER_HANDLED
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|gic_attach_isrc
parameter_list|(
name|struct
name|arm_gic_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|intr_irqsrc
modifier|*
name|isrc
parameter_list|,
name|u_int
name|irq
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* 	 * 1. The link between ISRC and controller must be set atomically. 	 * 2. Just do things only once in rare case when consumers 	 *    of shared interrupt came here at the same moment. 	 */
name|mtx_lock_spin
argument_list|(
operator|&
name|sc
operator|->
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|gic_irqs
index|[
name|irq
index|]
operator|!=
name|NULL
condition|)
block|{
name|mtx_unlock_spin
argument_list|(
operator|&
name|sc
operator|->
name|mutex
argument_list|)
expr_stmt|;
return|return
operator|(
name|sc
operator|->
name|gic_irqs
index|[
name|irq
index|]
operator|==
name|isrc
condition|?
literal|0
else|:
name|EEXIST
operator|)
return|;
block|}
name|sc
operator|->
name|gic_irqs
index|[
name|irq
index|]
operator|=
name|isrc
expr_stmt|;
name|isrc
operator|->
name|isrc_data
operator|=
name|irq
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sc
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|name
operator|=
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|gic_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|irq
operator|<=
name|GIC_LAST_SGI
condition|)
name|intr_irq_set_name
argument_list|(
name|isrc
argument_list|,
literal|"%s,i%u"
argument_list|,
name|name
argument_list|,
name|irq
operator|-
name|GIC_FIRST_SGI
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|irq
operator|<=
name|GIC_LAST_PPI
condition|)
name|intr_irq_set_name
argument_list|(
name|isrc
argument_list|,
literal|"%s,p%u"
argument_list|,
name|name
argument_list|,
name|irq
operator|-
name|GIC_FIRST_PPI
argument_list|)
expr_stmt|;
else|else
name|intr_irq_set_name
argument_list|(
name|isrc
argument_list|,
literal|"%s,s%u"
argument_list|,
name|name
argument_list|,
name|irq
operator|-
name|GIC_FIRST_SPI
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|gic_detach_isrc
parameter_list|(
name|struct
name|arm_gic_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|intr_irqsrc
modifier|*
name|isrc
parameter_list|,
name|u_int
name|irq
parameter_list|)
block|{
name|mtx_lock_spin
argument_list|(
operator|&
name|sc
operator|->
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|gic_irqs
index|[
name|irq
index|]
operator|!=
name|isrc
condition|)
block|{
name|mtx_unlock_spin
argument_list|(
operator|&
name|sc
operator|->
name|mutex
argument_list|)
expr_stmt|;
return|return
operator|(
name|sc
operator|->
name|gic_irqs
index|[
name|irq
index|]
operator|==
name|NULL
condition|?
literal|0
else|:
name|EINVAL
operator|)
return|;
block|}
name|sc
operator|->
name|gic_irqs
index|[
name|irq
index|]
operator|=
name|NULL
expr_stmt|;
name|isrc
operator|->
name|isrc_data
operator|=
literal|0
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sc
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|intr_irq_set_name
argument_list|(
name|isrc
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|gic_config
parameter_list|(
name|struct
name|arm_gic_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|irq
parameter_list|,
name|enum
name|intr_trigger
name|trig
parameter_list|,
name|enum
name|intr_polarity
name|pol
parameter_list|)
block|{
name|uint32_t
name|reg
decl_stmt|;
name|uint32_t
name|mask
decl_stmt|;
if|if
condition|(
name|irq
operator|<
name|GIC_FIRST_SPI
condition|)
return|return;
name|mtx_lock_spin
argument_list|(
operator|&
name|sc
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|reg
operator|=
name|gic_d_read_4
argument_list|(
name|sc
argument_list|,
name|GICD_ICFGR
argument_list|(
name|irq
operator|>>
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|mask
operator|=
operator|(
name|reg
operator|>>
literal|2
operator|*
operator|(
name|irq
operator|%
literal|16
operator|)
operator|)
operator|&
literal|0x3
expr_stmt|;
if|if
condition|(
name|pol
operator|==
name|INTR_POLARITY_LOW
condition|)
block|{
name|mask
operator|&=
operator|~
name|GICD_ICFGR_POL_MASK
expr_stmt|;
name|mask
operator||=
name|GICD_ICFGR_POL_LOW
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pol
operator|==
name|INTR_POLARITY_HIGH
condition|)
block|{
name|mask
operator|&=
operator|~
name|GICD_ICFGR_POL_MASK
expr_stmt|;
name|mask
operator||=
name|GICD_ICFGR_POL_HIGH
expr_stmt|;
block|}
if|if
condition|(
name|trig
operator|==
name|INTR_TRIGGER_LEVEL
condition|)
block|{
name|mask
operator|&=
operator|~
name|GICD_ICFGR_TRIG_MASK
expr_stmt|;
name|mask
operator||=
name|GICD_ICFGR_TRIG_LVL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|trig
operator|==
name|INTR_TRIGGER_EDGE
condition|)
block|{
name|mask
operator|&=
operator|~
name|GICD_ICFGR_TRIG_MASK
expr_stmt|;
name|mask
operator||=
name|GICD_ICFGR_TRIG_EDGE
expr_stmt|;
block|}
comment|/* Set mask */
name|reg
operator|=
name|reg
operator|&
operator|~
operator|(
literal|0x3
operator|<<
literal|2
operator|*
operator|(
name|irq
operator|%
literal|16
operator|)
operator|)
expr_stmt|;
name|reg
operator|=
name|reg
operator||
operator|(
name|mask
operator|<<
literal|2
operator|*
operator|(
name|irq
operator|%
literal|16
operator|)
operator|)
expr_stmt|;
name|gic_d_write_4
argument_list|(
name|sc
argument_list|,
name|GICD_ICFGR
argument_list|(
name|irq
operator|>>
literal|4
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sc
operator|->
name|mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|gic_bind
parameter_list|(
name|struct
name|arm_gic_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|irq
parameter_list|,
name|cpuset_t
modifier|*
name|cpus
parameter_list|)
block|{
name|uint32_t
name|cpu
decl_stmt|,
name|end
decl_stmt|,
name|mask
decl_stmt|;
name|end
operator|=
name|min
argument_list|(
name|mp_ncpus
argument_list|,
literal|8
argument_list|)
expr_stmt|;
for|for
control|(
name|cpu
operator|=
name|end
init|;
name|cpu
operator|<
name|MAXCPU
condition|;
name|cpu
operator|++
control|)
if|if
condition|(
name|CPU_ISSET
argument_list|(
name|cpu
argument_list|,
name|cpus
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
for|for
control|(
name|mask
operator|=
literal|0
operator|,
name|cpu
operator|=
literal|0
init|;
name|cpu
operator|<
name|end
condition|;
name|cpu
operator|++
control|)
if|if
condition|(
name|CPU_ISSET
argument_list|(
name|cpu
argument_list|,
name|cpus
argument_list|)
condition|)
name|mask
operator||=
literal|1
operator|<<
name|cpu
expr_stmt|;
name|gic_d_write_1
argument_list|(
name|sc
argument_list|,
name|GICD_ITARGETSR
argument_list|(
literal|0
argument_list|)
operator|+
name|irq
argument_list|,
name|mask
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|gic_irq_from_nspc
parameter_list|(
name|struct
name|arm_gic_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|type
parameter_list|,
name|u_int
name|num
parameter_list|,
name|u_int
modifier|*
name|irqp
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|INTR_IRQ_NSPC_PLAIN
case|:
operator|*
name|irqp
operator|=
name|num
expr_stmt|;
return|return
operator|(
operator|*
name|irqp
operator|<
name|sc
operator|->
name|nirqs
condition|?
literal|0
else|:
name|EINVAL
operator|)
return|;
case|case
name|INTR_IRQ_NSPC_IRQ
case|:
operator|*
name|irqp
operator|=
name|num
operator|+
name|GIC_FIRST_PPI
expr_stmt|;
return|return
operator|(
operator|*
name|irqp
operator|<
name|sc
operator|->
name|nirqs
condition|?
literal|0
else|:
name|EINVAL
operator|)
return|;
case|case
name|INTR_IRQ_NSPC_IPI
case|:
operator|*
name|irqp
operator|=
name|num
operator|+
name|GIC_FIRST_SGI
expr_stmt|;
return|return
operator|(
operator|*
name|irqp
operator|<
name|GIC_LAST_SGI
condition|?
literal|0
else|:
name|EINVAL
operator|)
return|;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|gic_map_nspc
parameter_list|(
name|struct
name|arm_gic_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|intr_irqsrc
modifier|*
name|isrc
parameter_list|,
name|u_int
modifier|*
name|irqp
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|gic_irq_from_nspc
argument_list|(
name|sc
argument_list|,
name|isrc
operator|->
name|isrc_nspc_type
argument_list|,
name|isrc
operator|->
name|isrc_nspc_num
argument_list|,
name|irqp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
name|gic_attach_isrc
argument_list|(
name|sc
argument_list|,
name|isrc
argument_list|,
operator|*
name|irqp
argument_list|)
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|FDT
end_ifdef

begin_function
specifier|static
name|int
name|gic_map_fdt
parameter_list|(
name|struct
name|arm_gic_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|intr_irqsrc
modifier|*
name|isrc
parameter_list|,
name|u_int
modifier|*
name|irqp
parameter_list|)
block|{
name|u_int
name|irq
decl_stmt|,
name|tripol
decl_stmt|;
name|enum
name|intr_trigger
name|trig
decl_stmt|;
name|enum
name|intr_polarity
name|pol
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|isrc
operator|->
name|isrc_ncells
operator|==
literal|1
condition|)
block|{
name|irq
operator|=
name|isrc
operator|->
name|isrc_cells
index|[
literal|0
index|]
expr_stmt|;
name|pol
operator|=
name|INTR_POLARITY_CONFORM
expr_stmt|;
name|trig
operator|=
name|INTR_TRIGGER_CONFORM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isrc
operator|->
name|isrc_ncells
operator|==
literal|3
condition|)
block|{
if|if
condition|(
name|isrc
operator|->
name|isrc_cells
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|irq
operator|=
name|isrc
operator|->
name|isrc_cells
index|[
literal|1
index|]
operator|+
name|GIC_FIRST_SPI
expr_stmt|;
else|else
name|irq
operator|=
name|isrc
operator|->
name|isrc_cells
index|[
literal|1
index|]
operator|+
name|GIC_FIRST_PPI
expr_stmt|;
comment|/* 		 * In intr[2], bits[3:0] are trigger type and level flags. 		 *   1 = low-to-high edge triggered 		 *   2 = high-to-low edge triggered 		 *   4 = active high level-sensitive 		 *   8 = active low level-sensitive 		 * The hardware only supports active-high-level or rising-edge. 		 */
name|tripol
operator|=
name|isrc
operator|->
name|isrc_cells
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|tripol
operator|&
literal|0x0a
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|gic_dev
argument_list|,
literal|"unsupported trigger/polarity configuration "
literal|"0x%02x\n"
argument_list|,
name|tripol
operator|&
literal|0x0f
argument_list|)
expr_stmt|;
block|}
name|pol
operator|=
name|INTR_POLARITY_CONFORM
expr_stmt|;
if|if
condition|(
name|tripol
operator|&
literal|0x03
condition|)
name|trig
operator|=
name|INTR_TRIGGER_EDGE
expr_stmt|;
else|else
name|trig
operator|=
name|INTR_TRIGGER_LEVEL
expr_stmt|;
block|}
else|else
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|irq
operator|>=
name|sc
operator|->
name|nirqs
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|error
operator|=
name|gic_attach_isrc
argument_list|(
name|sc
argument_list|,
name|isrc
argument_list|,
name|irq
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|isrc
operator|->
name|isrc_nspc_type
operator|=
name|INTR_IRQ_NSPC_PLAIN
expr_stmt|;
name|isrc
operator|->
name|isrc_nspc_num
operator|=
name|irq
expr_stmt|;
name|isrc
operator|->
name|isrc_trig
operator|=
name|trig
expr_stmt|;
name|isrc
operator|->
name|isrc_pol
operator|=
name|pol
expr_stmt|;
operator|*
name|irqp
operator|=
name|irq
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|arm_gic_register
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|intr_irqsrc
modifier|*
name|isrc
parameter_list|,
name|boolean_t
modifier|*
name|is_percpu
parameter_list|)
block|{
name|struct
name|arm_gic_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u_int
name|irq
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|isrc
operator|->
name|isrc_type
operator|==
name|INTR_ISRCT_NAMESPACE
condition|)
name|error
operator|=
name|gic_map_nspc
argument_list|(
name|sc
argument_list|,
name|isrc
argument_list|,
operator|&
name|irq
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FDT
elseif|else
if|if
condition|(
name|isrc
operator|->
name|isrc_type
operator|==
name|INTR_ISRCT_FDT
condition|)
name|error
operator|=
name|gic_map_fdt
argument_list|(
name|sc
argument_list|,
name|isrc
argument_list|,
operator|&
name|irq
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|else
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
operator|*
name|is_percpu
operator|=
name|irq
operator|<
name|GIC_FIRST_SPI
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|arm_gic_enable_intr
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|intr_irqsrc
modifier|*
name|isrc
parameter_list|)
block|{
name|struct
name|arm_gic_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u_int
name|irq
init|=
name|isrc
operator|->
name|isrc_data
decl_stmt|;
if|if
condition|(
name|isrc
operator|->
name|isrc_trig
operator|==
name|INTR_TRIGGER_CONFORM
condition|)
name|isrc
operator|->
name|isrc_trig
operator|=
name|INTR_TRIGGER_LEVEL
expr_stmt|;
comment|/* 	 * XXX - In case that per CPU interrupt is going to be enabled in time 	 *       when SMP is already started, we need some IPI call which 	 *       enables it on others CPUs. Further, it's more complicated as 	 *       pic_enable_source() and pic_disable_source() should act on 	 *       per CPU basis only. Thus, it should be solved here somehow. 	 */
if|if
condition|(
name|isrc
operator|->
name|isrc_flags
operator|&
name|INTR_ISRCF_PERCPU
condition|)
name|CPU_SET
argument_list|(
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
argument_list|,
operator|&
name|isrc
operator|->
name|isrc_cpu
argument_list|)
expr_stmt|;
name|gic_config
argument_list|(
name|sc
argument_list|,
name|irq
argument_list|,
name|isrc
operator|->
name|isrc_trig
argument_list|,
name|isrc
operator|->
name|isrc_pol
argument_list|)
expr_stmt|;
name|arm_gic_bind
argument_list|(
name|dev
argument_list|,
name|isrc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arm_gic_enable_source
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|intr_irqsrc
modifier|*
name|isrc
parameter_list|)
block|{
name|struct
name|arm_gic_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u_int
name|irq
init|=
name|isrc
operator|->
name|isrc_data
decl_stmt|;
name|arm_irq_memory_barrier
argument_list|(
name|irq
argument_list|)
expr_stmt|;
name|gic_irq_unmask
argument_list|(
name|sc
argument_list|,
name|irq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arm_gic_disable_source
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|intr_irqsrc
modifier|*
name|isrc
parameter_list|)
block|{
name|struct
name|arm_gic_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u_int
name|irq
init|=
name|isrc
operator|->
name|isrc_data
decl_stmt|;
name|gic_irq_mask
argument_list|(
name|sc
argument_list|,
name|irq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|arm_gic_unregister
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|intr_irqsrc
modifier|*
name|isrc
parameter_list|)
block|{
name|struct
name|arm_gic_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u_int
name|irq
init|=
name|isrc
operator|->
name|isrc_data
decl_stmt|;
return|return
operator|(
name|gic_detach_isrc
argument_list|(
name|sc
argument_list|,
name|isrc
argument_list|,
name|irq
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|arm_gic_pre_ithread
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|intr_irqsrc
modifier|*
name|isrc
parameter_list|)
block|{
name|struct
name|arm_gic_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|arm_gic_disable_source
argument_list|(
name|dev
argument_list|,
name|isrc
argument_list|)
expr_stmt|;
name|gic_c_write_4
argument_list|(
name|sc
argument_list|,
name|GICC_EOIR
argument_list|,
name|isrc
operator|->
name|isrc_data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arm_gic_post_ithread
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|intr_irqsrc
modifier|*
name|isrc
parameter_list|)
block|{
name|arm_irq_memory_barrier
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|arm_gic_enable_source
argument_list|(
name|dev
argument_list|,
name|isrc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arm_gic_post_filter
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|intr_irqsrc
modifier|*
name|isrc
parameter_list|)
block|{
name|struct
name|arm_gic_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
comment|/* EOI for edge-triggered done earlier. */
if|if
condition|(
name|isrc
operator|->
name|isrc_trig
operator|==
name|INTR_TRIGGER_EDGE
condition|)
return|return;
name|arm_irq_memory_barrier
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|gic_c_write_4
argument_list|(
name|sc
argument_list|,
name|GICC_EOIR
argument_list|,
name|isrc
operator|->
name|isrc_data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|arm_gic_bind
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|intr_irqsrc
modifier|*
name|isrc
parameter_list|)
block|{
name|struct
name|arm_gic_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|uint32_t
name|irq
init|=
name|isrc
operator|->
name|isrc_data
decl_stmt|;
if|if
condition|(
name|irq
operator|<
name|GIC_FIRST_SPI
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|CPU_EMPTY
argument_list|(
operator|&
name|isrc
operator|->
name|isrc_cpu
argument_list|)
condition|)
block|{
name|gic_irq_cpu
operator|=
name|intr_irq_next_cpu
argument_list|(
name|gic_irq_cpu
argument_list|,
operator|&
name|all_cpus
argument_list|)
expr_stmt|;
name|CPU_SETOF
argument_list|(
name|gic_irq_cpu
argument_list|,
operator|&
name|isrc
operator|->
name|isrc_cpu
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|gic_bind
argument_list|(
name|sc
argument_list|,
name|irq
argument_list|,
operator|&
name|isrc
operator|->
name|isrc_cpu
argument_list|)
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SMP
end_ifdef

begin_function
specifier|static
name|void
name|arm_gic_ipi_send
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|intr_irqsrc
modifier|*
name|isrc
parameter_list|,
name|cpuset_t
name|cpus
parameter_list|)
block|{
name|struct
name|arm_gic_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|uint32_t
name|irq
decl_stmt|,
name|val
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
name|irq
operator|=
name|isrc
operator|->
name|isrc_data
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXCPU
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|CPU_ISSET
argument_list|(
name|i
argument_list|,
operator|&
name|cpus
argument_list|)
condition|)
name|val
operator||=
literal|1
operator|<<
operator|(
literal|16
operator|+
name|i
operator|)
expr_stmt|;
name|gic_d_write_4
argument_list|(
name|sc
argument_list|,
name|GICD_SGIR
argument_list|(
literal|0
argument_list|)
argument_list|,
name|val
operator||
name|irq
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|int
name|arm_gic_next_irq
parameter_list|(
name|struct
name|arm_gic_softc
modifier|*
name|sc
parameter_list|,
name|int
name|last_irq
parameter_list|)
block|{
name|uint32_t
name|active_irq
decl_stmt|;
name|active_irq
operator|=
name|gic_c_read_4
argument_list|(
name|sc
argument_list|,
name|GICC_IAR
argument_list|)
expr_stmt|;
comment|/* 	 * Immediatly EOIR the SGIs, because doing so requires the other 	 * bits (ie CPU number), not just the IRQ number, and we do not 	 * have this information later. 	 */
if|if
condition|(
operator|(
name|active_irq
operator|&
literal|0x3ff
operator|)
operator|<=
name|GIC_LAST_SGI
condition|)
name|gic_c_write_4
argument_list|(
name|sc
argument_list|,
name|GICC_EOIR
argument_list|,
name|active_irq
argument_list|)
expr_stmt|;
name|active_irq
operator|&=
literal|0x3FF
expr_stmt|;
if|if
condition|(
name|active_irq
operator|==
literal|0x3FF
condition|)
block|{
if|if
condition|(
name|last_irq
operator|==
operator|-
literal|1
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|gic_dev
argument_list|,
literal|"Spurious interrupt detected\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
name|active_irq
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|arm_gic_config
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|irq
parameter_list|,
name|enum
name|intr_trigger
name|trig
parameter_list|,
name|enum
name|intr_polarity
name|pol
parameter_list|)
block|{
name|struct
name|arm_gic_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|uint32_t
name|reg
decl_stmt|;
name|uint32_t
name|mask
decl_stmt|;
comment|/* Function is public-accessible, so validate input arguments */
if|if
condition|(
operator|(
name|irq
operator|<
literal|0
operator|)
operator|||
operator|(
name|irq
operator|>=
name|sc
operator|->
name|nirqs
operator|)
condition|)
goto|goto
name|invalid_args
goto|;
if|if
condition|(
operator|(
name|trig
operator|!=
name|INTR_TRIGGER_EDGE
operator|)
operator|&&
operator|(
name|trig
operator|!=
name|INTR_TRIGGER_LEVEL
operator|)
operator|&&
operator|(
name|trig
operator|!=
name|INTR_TRIGGER_CONFORM
operator|)
condition|)
goto|goto
name|invalid_args
goto|;
if|if
condition|(
operator|(
name|pol
operator|!=
name|INTR_POLARITY_HIGH
operator|)
operator|&&
operator|(
name|pol
operator|!=
name|INTR_POLARITY_LOW
operator|)
operator|&&
operator|(
name|pol
operator|!=
name|INTR_POLARITY_CONFORM
operator|)
condition|)
goto|goto
name|invalid_args
goto|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sc
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|reg
operator|=
name|gic_d_read_4
argument_list|(
name|sc
argument_list|,
name|GICD_ICFGR
argument_list|(
name|irq
operator|>>
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|mask
operator|=
operator|(
name|reg
operator|>>
literal|2
operator|*
operator|(
name|irq
operator|%
literal|16
operator|)
operator|)
operator|&
literal|0x3
expr_stmt|;
if|if
condition|(
name|pol
operator|==
name|INTR_POLARITY_LOW
condition|)
block|{
name|mask
operator|&=
operator|~
name|GICD_ICFGR_POL_MASK
expr_stmt|;
name|mask
operator||=
name|GICD_ICFGR_POL_LOW
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pol
operator|==
name|INTR_POLARITY_HIGH
condition|)
block|{
name|mask
operator|&=
operator|~
name|GICD_ICFGR_POL_MASK
expr_stmt|;
name|mask
operator||=
name|GICD_ICFGR_POL_HIGH
expr_stmt|;
block|}
if|if
condition|(
name|trig
operator|==
name|INTR_TRIGGER_LEVEL
condition|)
block|{
name|mask
operator|&=
operator|~
name|GICD_ICFGR_TRIG_MASK
expr_stmt|;
name|mask
operator||=
name|GICD_ICFGR_TRIG_LVL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|trig
operator|==
name|INTR_TRIGGER_EDGE
condition|)
block|{
name|mask
operator|&=
operator|~
name|GICD_ICFGR_TRIG_MASK
expr_stmt|;
name|mask
operator||=
name|GICD_ICFGR_TRIG_EDGE
expr_stmt|;
block|}
comment|/* Set mask */
name|reg
operator|=
name|reg
operator|&
operator|~
operator|(
literal|0x3
operator|<<
literal|2
operator|*
operator|(
name|irq
operator|%
literal|16
operator|)
operator|)
expr_stmt|;
name|reg
operator|=
name|reg
operator||
operator|(
name|mask
operator|<<
literal|2
operator|*
operator|(
name|irq
operator|%
literal|16
operator|)
operator|)
expr_stmt|;
name|gic_d_write_4
argument_list|(
name|sc
argument_list|,
name|GICD_ICFGR
argument_list|(
name|irq
operator|>>
literal|4
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sc
operator|->
name|mutex
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|invalid_args
label|:
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"gic_config_irg, invalid parameters\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|arm_gic_mask
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|irq
parameter_list|)
block|{
name|struct
name|arm_gic_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|gic_d_write_4
argument_list|(
name|sc
argument_list|,
name|GICD_ICENABLER
argument_list|(
name|irq
operator|>>
literal|5
argument_list|)
argument_list|,
operator|(
literal|1UL
operator|<<
operator|(
name|irq
operator|&
literal|0x1F
operator|)
operator|)
argument_list|)
expr_stmt|;
name|gic_c_write_4
argument_list|(
name|sc
argument_list|,
name|GICC_EOIR
argument_list|,
name|irq
argument_list|)
expr_stmt|;
comment|/* XXX - not allowed */
block|}
end_function

begin_function
specifier|static
name|void
name|arm_gic_unmask
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|irq
parameter_list|)
block|{
name|struct
name|arm_gic_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|irq
operator|>
name|GIC_LAST_SGI
condition|)
name|arm_irq_memory_barrier
argument_list|(
name|irq
argument_list|)
expr_stmt|;
name|gic_d_write_4
argument_list|(
name|sc
argument_list|,
name|GICD_ISENABLER
argument_list|(
name|irq
operator|>>
literal|5
argument_list|)
argument_list|,
operator|(
literal|1UL
operator|<<
operator|(
name|irq
operator|&
literal|0x1F
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SMP
end_ifdef

begin_function
specifier|static
name|void
name|arm_gic_ipi_send
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|cpuset_t
name|cpus
parameter_list|,
name|u_int
name|ipi
parameter_list|)
block|{
name|struct
name|arm_gic_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|uint32_t
name|val
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXCPU
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|CPU_ISSET
argument_list|(
name|i
argument_list|,
operator|&
name|cpus
argument_list|)
condition|)
name|val
operator||=
literal|1
operator|<<
operator|(
literal|16
operator|+
name|i
operator|)
expr_stmt|;
name|gic_d_write_4
argument_list|(
name|sc
argument_list|,
name|GICD_SGIR
argument_list|(
literal|0
argument_list|)
argument_list|,
name|val
operator||
name|ipi
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|arm_gic_ipi_read
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|i
parameter_list|)
block|{
if|if
condition|(
name|i
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* 		 * The intr code will automagically give the frame pointer 		 * if the interrupt argument is 0. 		 */
if|if
condition|(
operator|(
name|unsigned
name|int
operator|)
name|i
operator|>
literal|16
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|i
operator|)
return|;
block|}
return|return
operator|(
literal|0x3ff
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|arm_gic_ipi_clear
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|ipi
parameter_list|)
block|{
comment|/* no-op */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|gic_post_filter
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|arm_gic_softc
modifier|*
name|sc
init|=
name|gic_sc
decl_stmt|;
name|uintptr_t
name|irq
init|=
operator|(
name|uintptr_t
operator|)
name|arg
decl_stmt|;
if|if
condition|(
name|irq
operator|>
name|GIC_LAST_SGI
condition|)
name|arm_irq_memory_barrier
argument_list|(
name|irq
argument_list|)
expr_stmt|;
name|gic_c_write_4
argument_list|(
name|sc
argument_list|,
name|GICC_EOIR
argument_list|,
name|irq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|gic_config_irq
parameter_list|(
name|int
name|irq
parameter_list|,
name|enum
name|intr_trigger
name|trig
parameter_list|,
name|enum
name|intr_polarity
name|pol
parameter_list|)
block|{
return|return
operator|(
name|arm_gic_config
argument_list|(
name|gic_sc
operator|->
name|gic_dev
argument_list|,
name|irq
argument_list|,
name|trig
argument_list|,
name|pol
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|arm_mask_irq
parameter_list|(
name|uintptr_t
name|nb
parameter_list|)
block|{
name|arm_gic_mask
argument_list|(
name|gic_sc
operator|->
name|gic_dev
argument_list|,
name|nb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arm_unmask_irq
parameter_list|(
name|uintptr_t
name|nb
parameter_list|)
block|{
name|arm_gic_unmask
argument_list|(
name|gic_sc
operator|->
name|gic_dev
argument_list|,
name|nb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|arm_get_next_irq
parameter_list|(
name|int
name|last_irq
parameter_list|)
block|{
return|return
operator|(
name|arm_gic_next_irq
argument_list|(
name|gic_sc
argument_list|,
name|last_irq
argument_list|)
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SMP
end_ifdef

begin_function
name|void
name|intr_pic_init_secondary
parameter_list|(
name|void
parameter_list|)
block|{
name|arm_gic_init_secondary
argument_list|(
name|gic_sc
operator|->
name|gic_dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pic_ipi_send
parameter_list|(
name|cpuset_t
name|cpus
parameter_list|,
name|u_int
name|ipi
parameter_list|)
block|{
name|arm_gic_ipi_send
argument_list|(
name|gic_sc
operator|->
name|gic_dev
argument_list|,
name|cpus
argument_list|,
name|ipi
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|pic_ipi_read
parameter_list|(
name|int
name|i
parameter_list|)
block|{
return|return
operator|(
name|arm_gic_ipi_read
argument_list|(
name|gic_sc
operator|->
name|gic_dev
argument_list|,
name|i
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pic_ipi_clear
parameter_list|(
name|int
name|ipi
parameter_list|)
block|{
name|arm_gic_ipi_clear
argument_list|(
name|gic_sc
operator|->
name|gic_dev
argument_list|,
name|ipi
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ARM_INTRNG */
end_comment

begin_decl_stmt
specifier|static
name|device_method_t
name|arm_gic_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|arm_gic_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|arm_gic_attach
argument_list|)
block|,
ifdef|#
directive|ifdef
name|ARM_INTRNG
comment|/* Interrupt controller interface */
name|DEVMETHOD
argument_list|(
name|pic_disable_source
argument_list|,
name|arm_gic_disable_source
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pic_enable_intr
argument_list|,
name|arm_gic_enable_intr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pic_enable_source
argument_list|,
name|arm_gic_enable_source
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pic_post_filter
argument_list|,
name|arm_gic_post_filter
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pic_post_ithread
argument_list|,
name|arm_gic_post_ithread
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pic_pre_ithread
argument_list|,
name|arm_gic_pre_ithread
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pic_register
argument_list|,
name|arm_gic_register
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pic_unregister
argument_list|,
name|arm_gic_unregister
argument_list|)
block|,
ifdef|#
directive|ifdef
name|SMP
name|DEVMETHOD
argument_list|(
name|pic_bind
argument_list|,
name|arm_gic_bind
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pic_init_secondary
argument_list|,
name|arm_gic_init_secondary
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pic_ipi_send
argument_list|,
name|arm_gic_ipi_send
argument_list|)
block|,
endif|#
directive|endif
endif|#
directive|endif
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|arm_gic_driver
init|=
block|{
literal|"gic"
block|,
name|arm_gic_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|arm_gic_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|arm_gic_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|EARLY_DRIVER_MODULE
argument_list|(
name|gic
argument_list|,
name|simplebus
argument_list|,
name|arm_gic_driver
argument_list|,
name|arm_gic_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|BUS_PASS_INTERRUPT
operator|+
name|BUS_PASS_ORDER_MIDDLE
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|EARLY_DRIVER_MODULE
argument_list|(
name|gic
argument_list|,
name|ofwbus
argument_list|,
name|arm_gic_driver
argument_list|,
name|arm_gic_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|BUS_PASS_INTERRUPT
operator|+
name|BUS_PASS_ORDER_MIDDLE
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

