begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2011 The FreeBSD Foundation  * All rights reserved.  *  * Developed by Damjan Marion<damjan.marion@gmail.com>  *  * Based on OMAP4 GIC code by Ben Gray  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the company nor the name of the author may be used to  *    endorse or promote products derived from this software without specific  *    prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/pcpu.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/cpuset.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/intr.h>
end_include

begin_include
include|#
directive|include
file|<machine/smp.h>
end_include

begin_include
include|#
directive|include
file|<dev/fdt/fdt_common.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/openfirm.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/ofw_bus.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/ofw_bus_subr.h>
end_include

begin_comment
comment|/* We are using GICv2 register naming */
end_comment

begin_comment
comment|/* Distributor Registers */
end_comment

begin_define
define|#
directive|define
name|GICD_CTLR
value|0x000
end_define

begin_comment
comment|/* v1 ICDDCR */
end_comment

begin_define
define|#
directive|define
name|GICD_TYPER
value|0x004
end_define

begin_comment
comment|/* v1 ICDICTR */
end_comment

begin_define
define|#
directive|define
name|GICD_IIDR
value|0x008
end_define

begin_comment
comment|/* v1 ICDIIDR */
end_comment

begin_define
define|#
directive|define
name|GICD_IGROUPR
parameter_list|(
name|n
parameter_list|)
value|(0x0080 + ((n) * 4))
end_define

begin_comment
comment|/* v1 ICDISER */
end_comment

begin_define
define|#
directive|define
name|GICD_ISENABLER
parameter_list|(
name|n
parameter_list|)
value|(0x0100 + ((n) * 4))
end_define

begin_comment
comment|/* v1 ICDISER */
end_comment

begin_define
define|#
directive|define
name|GICD_ICENABLER
parameter_list|(
name|n
parameter_list|)
value|(0x0180 + ((n) * 4))
end_define

begin_comment
comment|/* v1 ICDICER */
end_comment

begin_define
define|#
directive|define
name|GICD_ISPENDR
parameter_list|(
name|n
parameter_list|)
value|(0x0200 + ((n) * 4))
end_define

begin_comment
comment|/* v1 ICDISPR */
end_comment

begin_define
define|#
directive|define
name|GICD_ICPENDR
parameter_list|(
name|n
parameter_list|)
value|(0x0280 + ((n) * 4))
end_define

begin_comment
comment|/* v1 ICDICPR */
end_comment

begin_define
define|#
directive|define
name|GICD_ICACTIVER
parameter_list|(
name|n
parameter_list|)
value|(0x0380 + ((n) * 4))
end_define

begin_comment
comment|/* v1 ICDABR */
end_comment

begin_define
define|#
directive|define
name|GICD_IPRIORITYR
parameter_list|(
name|n
parameter_list|)
value|(0x0400 + ((n) * 4))
end_define

begin_comment
comment|/* v1 ICDIPR */
end_comment

begin_define
define|#
directive|define
name|GICD_ITARGETSR
parameter_list|(
name|n
parameter_list|)
value|(0x0800 + ((n) * 4))
end_define

begin_comment
comment|/* v1 ICDIPTR */
end_comment

begin_define
define|#
directive|define
name|GICD_ICFGR
parameter_list|(
name|n
parameter_list|)
value|(0x0C00 + ((n) * 4))
end_define

begin_comment
comment|/* v1 ICDICFR */
end_comment

begin_define
define|#
directive|define
name|GICD_SGIR
parameter_list|(
name|n
parameter_list|)
value|(0x0F00 + ((n) * 4))
end_define

begin_comment
comment|/* v1 ICDSGIR */
end_comment

begin_comment
comment|/* CPU Registers */
end_comment

begin_define
define|#
directive|define
name|GICC_CTLR
value|0x0000
end_define

begin_comment
comment|/* v1 ICCICR */
end_comment

begin_define
define|#
directive|define
name|GICC_PMR
value|0x0004
end_define

begin_comment
comment|/* v1 ICCPMR */
end_comment

begin_define
define|#
directive|define
name|GICC_BPR
value|0x0008
end_define

begin_comment
comment|/* v1 ICCBPR */
end_comment

begin_define
define|#
directive|define
name|GICC_IAR
value|0x000C
end_define

begin_comment
comment|/* v1 ICCIAR */
end_comment

begin_define
define|#
directive|define
name|GICC_EOIR
value|0x0010
end_define

begin_comment
comment|/* v1 ICCEOIR */
end_comment

begin_define
define|#
directive|define
name|GICC_RPR
value|0x0014
end_define

begin_comment
comment|/* v1 ICCRPR */
end_comment

begin_define
define|#
directive|define
name|GICC_HPPIR
value|0x0018
end_define

begin_comment
comment|/* v1 ICCHPIR */
end_comment

begin_define
define|#
directive|define
name|GICC_ABPR
value|0x001C
end_define

begin_comment
comment|/* v1 ICCABPR */
end_comment

begin_define
define|#
directive|define
name|GICC_IIDR
value|0x00FC
end_define

begin_comment
comment|/* v1 ICCIIDR*/
end_comment

begin_define
define|#
directive|define
name|GIC_FIRST_IPI
value|0
end_define

begin_comment
comment|/* Irqs 0-15 are SGIs/IPIs. */
end_comment

begin_define
define|#
directive|define
name|GIC_LAST_IPI
value|15
end_define

begin_define
define|#
directive|define
name|GIC_FIRST_PPI
value|16
end_define

begin_comment
comment|/* Irqs 16-31 are private (per */
end_comment

begin_define
define|#
directive|define
name|GIC_LAST_PPI
value|31
end_define

begin_comment
comment|/* core) peripheral interrupts. */
end_comment

begin_define
define|#
directive|define
name|GIC_FIRST_SPI
value|32
end_define

begin_comment
comment|/* Irqs 32+ are shared peripherals. */
end_comment

begin_comment
comment|/* First bit is a polarity bit (0 - low, 1 - high) */
end_comment

begin_define
define|#
directive|define
name|GICD_ICFGR_POL_LOW
value|(0<< 0)
end_define

begin_define
define|#
directive|define
name|GICD_ICFGR_POL_HIGH
value|(1<< 0)
end_define

begin_define
define|#
directive|define
name|GICD_ICFGR_POL_MASK
value|0x1
end_define

begin_comment
comment|/* Second bit is a trigger bit (0 - level, 1 - edge) */
end_comment

begin_define
define|#
directive|define
name|GICD_ICFGR_TRIG_LVL
value|(0<< 1)
end_define

begin_define
define|#
directive|define
name|GICD_ICFGR_TRIG_EDGE
value|(1<< 1)
end_define

begin_define
define|#
directive|define
name|GICD_ICFGR_TRIG_MASK
value|0x2
end_define

begin_struct
struct|struct
name|arm_gic_softc
block|{
name|struct
name|resource
modifier|*
name|gic_res
index|[
literal|3
index|]
decl_stmt|;
name|bus_space_tag_t
name|gic_c_bst
decl_stmt|;
name|bus_space_tag_t
name|gic_d_bst
decl_stmt|;
name|bus_space_handle_t
name|gic_c_bsh
decl_stmt|;
name|bus_space_handle_t
name|gic_d_bsh
decl_stmt|;
name|uint8_t
name|ver
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
name|struct
name|mtx
name|mutex
decl_stmt|;
name|uint32_t
name|nirqs
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|resource_spec
name|arm_gic_spec
index|[]
init|=
block|{
block|{
name|SYS_RES_MEMORY
block|,
literal|0
block|,
name|RF_ACTIVE
block|}
block|,
comment|/* Distributor registers */
block|{
name|SYS_RES_MEMORY
block|,
literal|1
block|,
name|RF_ACTIVE
block|}
block|,
comment|/* CPU Interrupt Intf. registers */
block|{
operator|-
literal|1
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|arm_gic_softc
modifier|*
name|arm_gic_sc
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|gic_c_read_4
parameter_list|(
name|reg
parameter_list|)
define|\
value|bus_space_read_4(arm_gic_sc->gic_c_bst, arm_gic_sc->gic_c_bsh, reg)
end_define

begin_define
define|#
directive|define
name|gic_c_write_4
parameter_list|(
name|reg
parameter_list|,
name|val
parameter_list|)
define|\
value|bus_space_write_4(arm_gic_sc->gic_c_bst, arm_gic_sc->gic_c_bsh, reg, val)
end_define

begin_define
define|#
directive|define
name|gic_d_read_4
parameter_list|(
name|reg
parameter_list|)
define|\
value|bus_space_read_4(arm_gic_sc->gic_d_bst, arm_gic_sc->gic_d_bsh, reg)
end_define

begin_define
define|#
directive|define
name|gic_d_write_4
parameter_list|(
name|reg
parameter_list|,
name|val
parameter_list|)
define|\
value|bus_space_write_4(arm_gic_sc->gic_d_bst, arm_gic_sc->gic_d_bsh, reg, val)
end_define

begin_function_decl
specifier|static
name|int
name|gic_config_irq
parameter_list|(
name|int
name|irq
parameter_list|,
name|enum
name|intr_trigger
name|trig
parameter_list|,
name|enum
name|intr_polarity
name|pol
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gic_post_filter
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|ofw_compat_data
name|compat_data
index|[]
init|=
block|{
block|{
literal|"arm,gic"
block|,
name|true
block|}
block|,
comment|/* Non-standard, used in FreeBSD dts. */
block|{
literal|"arm,gic-400"
block|,
name|true
block|}
block|,
block|{
literal|"arm,cortex-a15-gic"
block|,
name|true
block|}
block|,
block|{
literal|"arm,cortex-a9-gic"
block|,
name|true
block|}
block|,
block|{
literal|"arm,cortex-a7-gic"
block|,
name|true
block|}
block|,
block|{
literal|"arm,arm11mp-gic"
block|,
name|true
block|}
block|,
block|{
literal|"brcm,brahma-b15-gic"
block|,
name|true
block|}
block|,
block|{
name|NULL
block|,
name|false
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|arm_gic_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ofw_bus_status_okay
argument_list|(
name|dev
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
operator|!
name|ofw_bus_search_compatible
argument_list|(
name|dev
argument_list|,
name|compat_data
argument_list|)
operator|->
name|ocd_data
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"ARM Generic Interrupt Controller"
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
end_function

begin_function
name|void
name|gic_init_secondary
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|nirqs
decl_stmt|;
comment|/* Get the number of interrupts */
name|nirqs
operator|=
name|gic_d_read_4
argument_list|(
name|GICD_TYPER
argument_list|)
expr_stmt|;
name|nirqs
operator|=
literal|32
operator|*
operator|(
operator|(
name|nirqs
operator|&
literal|0x1f
operator|)
operator|+
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nirqs
condition|;
name|i
operator|+=
literal|4
control|)
name|gic_d_write_4
argument_list|(
name|GICD_IPRIORITYR
argument_list|(
name|i
operator|>>
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set all the interrupts to be in Group 0 (secure) */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nirqs
condition|;
name|i
operator|+=
literal|32
control|)
block|{
name|gic_d_write_4
argument_list|(
name|GICD_IGROUPR
argument_list|(
name|i
operator|>>
literal|5
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Enable CPU interface */
name|gic_c_write_4
argument_list|(
name|GICC_CTLR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Set priority mask register. */
name|gic_c_write_4
argument_list|(
name|GICC_PMR
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* Enable interrupt distribution */
name|gic_d_write_4
argument_list|(
name|GICD_CTLR
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
comment|/* Activate IRQ 29, ie private timer IRQ*/
name|gic_d_write_4
argument_list|(
name|GICD_ISENABLER
argument_list|(
literal|29
operator|>>
literal|5
argument_list|)
argument_list|,
operator|(
literal|1UL
operator|<<
operator|(
literal|29
operator|&
literal|0x1F
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|gic_decode_fdt
parameter_list|(
name|uint32_t
name|iparent
parameter_list|,
name|uint32_t
modifier|*
name|intr
parameter_list|,
name|int
modifier|*
name|interrupt
parameter_list|,
name|int
modifier|*
name|trig
parameter_list|,
name|int
modifier|*
name|pol
parameter_list|)
block|{
specifier|static
name|u_int
name|num_intr_cells
decl_stmt|;
if|if
condition|(
name|num_intr_cells
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|OF_searchencprop
argument_list|(
name|OF_node_from_xref
argument_list|(
name|iparent
argument_list|)
argument_list|,
literal|"#interrupt-cells"
argument_list|,
operator|&
name|num_intr_cells
argument_list|,
sizeof|sizeof
argument_list|(
name|num_intr_cells
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|num_intr_cells
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|num_intr_cells
operator|==
literal|1
condition|)
block|{
operator|*
name|interrupt
operator|=
name|fdt32_to_cpu
argument_list|(
name|intr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
operator|*
name|trig
operator|=
name|INTR_TRIGGER_CONFORM
expr_stmt|;
operator|*
name|pol
operator|=
name|INTR_POLARITY_CONFORM
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|fdt32_to_cpu
argument_list|(
name|intr
index|[
literal|0
index|]
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|interrupt
operator|=
name|fdt32_to_cpu
argument_list|(
name|intr
index|[
literal|1
index|]
argument_list|)
operator|+
name|GIC_FIRST_SPI
expr_stmt|;
else|else
operator|*
name|interrupt
operator|=
name|fdt32_to_cpu
argument_list|(
name|intr
index|[
literal|1
index|]
argument_list|)
operator|+
name|GIC_FIRST_PPI
expr_stmt|;
comment|/* 		 * In intr[2], bits[3:0] are trigger type and level flags. 		 *   1 = low-to-high edge triggered 		 *   2 = high-to-low edge triggered 		 *   4 = active high level-sensitive 		 *   8 = active low level-sensitive 		 * The hardware only supports active-high-level or rising-edge. 		 */
if|if
condition|(
name|fdt32_to_cpu
argument_list|(
name|intr
index|[
literal|2
index|]
argument_list|)
operator|&
literal|0x0a
condition|)
block|{
name|printf
argument_list|(
literal|"unsupported trigger/polarity configuration "
literal|"0x%2x\n"
argument_list|,
name|fdt32_to_cpu
argument_list|(
name|intr
index|[
literal|2
index|]
argument_list|)
operator|&
literal|0x0f
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOTSUP
operator|)
return|;
block|}
operator|*
name|pol
operator|=
name|INTR_POLARITY_CONFORM
expr_stmt|;
if|if
condition|(
name|fdt32_to_cpu
argument_list|(
name|intr
index|[
literal|2
index|]
argument_list|)
operator|&
literal|0x01
condition|)
operator|*
name|trig
operator|=
name|INTR_TRIGGER_EDGE
expr_stmt|;
else|else
operator|*
name|trig
operator|=
name|INTR_TRIGGER_LEVEL
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|arm_gic_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|arm_gic_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint32_t
name|icciidr
decl_stmt|;
if|if
condition|(
name|arm_gic_sc
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
if|if
condition|(
name|bus_alloc_resources
argument_list|(
name|dev
argument_list|,
name|arm_gic_spec
argument_list|,
name|sc
operator|->
name|gic_res
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not allocate resources\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Initialize mutex */
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|mutex
argument_list|,
literal|"GIC lock"
argument_list|,
literal|""
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
comment|/* Distributor Interface */
name|sc
operator|->
name|gic_d_bst
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|gic_res
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|gic_d_bsh
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|gic_res
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* CPU Interface */
name|sc
operator|->
name|gic_c_bst
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|gic_res
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|gic_c_bsh
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|gic_res
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|arm_gic_sc
operator|=
name|sc
expr_stmt|;
comment|/* Disable interrupt forwarding to the CPU interface */
name|gic_d_write_4
argument_list|(
name|GICD_CTLR
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* Get the number of interrupts */
name|sc
operator|->
name|nirqs
operator|=
name|gic_d_read_4
argument_list|(
name|GICD_TYPER
argument_list|)
expr_stmt|;
name|sc
operator|->
name|nirqs
operator|=
literal|32
operator|*
operator|(
operator|(
name|sc
operator|->
name|nirqs
operator|&
literal|0x1f
operator|)
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* Set up function pointers */
name|arm_post_filter
operator|=
name|gic_post_filter
expr_stmt|;
name|arm_config_irq
operator|=
name|gic_config_irq
expr_stmt|;
name|icciidr
operator|=
name|gic_c_read_4
argument_list|(
name|GICC_IIDR
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"pn 0x%x, arch 0x%x, rev 0x%x, implementer 0x%x irqs %u\n"
argument_list|,
name|icciidr
operator|>>
literal|20
argument_list|,
operator|(
name|icciidr
operator|>>
literal|16
operator|)
operator|&
literal|0xF
argument_list|,
operator|(
name|icciidr
operator|>>
literal|12
operator|)
operator|&
literal|0xf
argument_list|,
operator|(
name|icciidr
operator|&
literal|0xfff
operator|)
argument_list|,
name|sc
operator|->
name|nirqs
argument_list|)
expr_stmt|;
comment|/* Set all global interrupts to be level triggered, active low. */
for|for
control|(
name|i
operator|=
literal|32
init|;
name|i
operator|<
name|sc
operator|->
name|nirqs
condition|;
name|i
operator|+=
literal|16
control|)
block|{
name|gic_d_write_4
argument_list|(
name|GICD_ICFGR
argument_list|(
name|i
operator|>>
literal|4
argument_list|)
argument_list|,
literal|0x00000000
argument_list|)
expr_stmt|;
block|}
comment|/* Disable all interrupts. */
for|for
control|(
name|i
operator|=
literal|32
init|;
name|i
operator|<
name|sc
operator|->
name|nirqs
condition|;
name|i
operator|+=
literal|32
control|)
block|{
name|gic_d_write_4
argument_list|(
name|GICD_ICENABLER
argument_list|(
name|i
operator|>>
literal|5
argument_list|)
argument_list|,
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|nirqs
condition|;
name|i
operator|+=
literal|4
control|)
block|{
name|gic_d_write_4
argument_list|(
name|GICD_IPRIORITYR
argument_list|(
name|i
operator|>>
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gic_d_write_4
argument_list|(
name|GICD_ITARGETSR
argument_list|(
name|i
operator|>>
literal|2
argument_list|)
argument_list|,
literal|1
operator|<<
literal|0
operator||
literal|1
operator|<<
literal|8
operator||
literal|1
operator|<<
literal|16
operator||
literal|1
operator|<<
literal|24
argument_list|)
expr_stmt|;
block|}
comment|/* Set all the interrupts to be in Group 0 (secure) */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|nirqs
condition|;
name|i
operator|+=
literal|32
control|)
block|{
name|gic_d_write_4
argument_list|(
name|GICD_IGROUPR
argument_list|(
name|i
operator|>>
literal|5
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Enable CPU interface */
name|gic_c_write_4
argument_list|(
name|GICC_CTLR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Set priority mask register. */
name|gic_c_write_4
argument_list|(
name|GICC_PMR
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* Enable interrupt distribution */
name|gic_d_write_4
argument_list|(
name|GICD_CTLR
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|arm_gic_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|arm_gic_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|arm_gic_attach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|arm_gic_driver
init|=
block|{
literal|"gic"
block|,
name|arm_gic_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|arm_gic_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|arm_gic_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|EARLY_DRIVER_MODULE
argument_list|(
name|gic
argument_list|,
name|simplebus
argument_list|,
name|arm_gic_driver
argument_list|,
name|arm_gic_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|BUS_PASS_INTERRUPT
operator|+
name|BUS_PASS_ORDER_MIDDLE
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|EARLY_DRIVER_MODULE
argument_list|(
name|gic
argument_list|,
name|ofwbus
argument_list|,
name|arm_gic_driver
argument_list|,
name|arm_gic_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|BUS_PASS_INTERRUPT
operator|+
name|BUS_PASS_ORDER_MIDDLE
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|gic_post_filter
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|uintptr_t
name|irq
init|=
operator|(
name|uintptr_t
operator|)
name|arg
decl_stmt|;
if|if
condition|(
name|irq
operator|>
name|GIC_LAST_IPI
condition|)
name|arm_irq_memory_barrier
argument_list|(
name|irq
argument_list|)
expr_stmt|;
name|gic_c_write_4
argument_list|(
name|GICC_EOIR
argument_list|,
name|irq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|arm_get_next_irq
parameter_list|(
name|int
name|last_irq
parameter_list|)
block|{
name|uint32_t
name|active_irq
decl_stmt|;
name|active_irq
operator|=
name|gic_c_read_4
argument_list|(
name|GICC_IAR
argument_list|)
expr_stmt|;
comment|/* 	 * Immediatly EOIR the SGIs, because doing so requires the other 	 * bits (ie CPU number), not just the IRQ number, and we do not 	 * have this information later. 	 */
if|if
condition|(
operator|(
name|active_irq
operator|&
literal|0x3ff
operator|)
operator|<=
name|GIC_LAST_IPI
condition|)
name|gic_c_write_4
argument_list|(
name|GICC_EOIR
argument_list|,
name|active_irq
argument_list|)
expr_stmt|;
name|active_irq
operator|&=
literal|0x3FF
expr_stmt|;
if|if
condition|(
name|active_irq
operator|==
literal|0x3FF
condition|)
block|{
if|if
condition|(
name|last_irq
operator|==
operator|-
literal|1
condition|)
name|printf
argument_list|(
literal|"Spurious interrupt detected\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
name|active_irq
return|;
block|}
end_function

begin_function
name|void
name|arm_mask_irq
parameter_list|(
name|uintptr_t
name|nb
parameter_list|)
block|{
name|gic_d_write_4
argument_list|(
name|GICD_ICENABLER
argument_list|(
name|nb
operator|>>
literal|5
argument_list|)
argument_list|,
operator|(
literal|1UL
operator|<<
operator|(
name|nb
operator|&
literal|0x1F
operator|)
operator|)
argument_list|)
expr_stmt|;
name|gic_c_write_4
argument_list|(
name|GICC_EOIR
argument_list|,
name|nb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arm_unmask_irq
parameter_list|(
name|uintptr_t
name|nb
parameter_list|)
block|{
if|if
condition|(
name|nb
operator|>
name|GIC_LAST_IPI
condition|)
name|arm_irq_memory_barrier
argument_list|(
name|nb
argument_list|)
expr_stmt|;
name|gic_d_write_4
argument_list|(
name|GICD_ISENABLER
argument_list|(
name|nb
operator|>>
literal|5
argument_list|)
argument_list|,
operator|(
literal|1UL
operator|<<
operator|(
name|nb
operator|&
literal|0x1F
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|gic_config_irq
parameter_list|(
name|int
name|irq
parameter_list|,
name|enum
name|intr_trigger
name|trig
parameter_list|,
name|enum
name|intr_polarity
name|pol
parameter_list|)
block|{
name|uint32_t
name|reg
decl_stmt|;
name|uint32_t
name|mask
decl_stmt|;
comment|/* Function is public-accessible, so validate input arguments */
if|if
condition|(
operator|(
name|irq
operator|<
literal|0
operator|)
operator|||
operator|(
name|irq
operator|>=
name|arm_gic_sc
operator|->
name|nirqs
operator|)
condition|)
goto|goto
name|invalid_args
goto|;
if|if
condition|(
operator|(
name|trig
operator|!=
name|INTR_TRIGGER_EDGE
operator|)
operator|&&
operator|(
name|trig
operator|!=
name|INTR_TRIGGER_LEVEL
operator|)
operator|&&
operator|(
name|trig
operator|!=
name|INTR_TRIGGER_CONFORM
operator|)
condition|)
goto|goto
name|invalid_args
goto|;
if|if
condition|(
operator|(
name|pol
operator|!=
name|INTR_POLARITY_HIGH
operator|)
operator|&&
operator|(
name|pol
operator|!=
name|INTR_POLARITY_LOW
operator|)
operator|&&
operator|(
name|pol
operator|!=
name|INTR_POLARITY_CONFORM
operator|)
condition|)
goto|goto
name|invalid_args
goto|;
name|mtx_lock_spin
argument_list|(
operator|&
name|arm_gic_sc
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|reg
operator|=
name|gic_d_read_4
argument_list|(
name|GICD_ICFGR
argument_list|(
name|irq
operator|>>
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|mask
operator|=
operator|(
name|reg
operator|>>
literal|2
operator|*
operator|(
name|irq
operator|%
literal|16
operator|)
operator|)
operator|&
literal|0x3
expr_stmt|;
if|if
condition|(
name|pol
operator|==
name|INTR_POLARITY_LOW
condition|)
block|{
name|mask
operator|&=
operator|~
name|GICD_ICFGR_POL_MASK
expr_stmt|;
name|mask
operator||=
name|GICD_ICFGR_POL_LOW
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pol
operator|==
name|INTR_POLARITY_HIGH
condition|)
block|{
name|mask
operator|&=
operator|~
name|GICD_ICFGR_POL_MASK
expr_stmt|;
name|mask
operator||=
name|GICD_ICFGR_POL_HIGH
expr_stmt|;
block|}
if|if
condition|(
name|trig
operator|==
name|INTR_TRIGGER_LEVEL
condition|)
block|{
name|mask
operator|&=
operator|~
name|GICD_ICFGR_TRIG_MASK
expr_stmt|;
name|mask
operator||=
name|GICD_ICFGR_TRIG_LVL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|trig
operator|==
name|INTR_TRIGGER_EDGE
condition|)
block|{
name|mask
operator|&=
operator|~
name|GICD_ICFGR_TRIG_MASK
expr_stmt|;
name|mask
operator||=
name|GICD_ICFGR_TRIG_EDGE
expr_stmt|;
block|}
comment|/* Set mask */
name|reg
operator|=
name|reg
operator|&
operator|~
operator|(
literal|0x3
operator|<<
literal|2
operator|*
operator|(
name|irq
operator|%
literal|16
operator|)
operator|)
expr_stmt|;
name|reg
operator|=
name|reg
operator||
operator|(
name|mask
operator|<<
literal|2
operator|*
operator|(
name|irq
operator|%
literal|16
operator|)
operator|)
expr_stmt|;
name|gic_d_write_4
argument_list|(
name|GICD_ICFGR
argument_list|(
name|irq
operator|>>
literal|4
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|arm_gic_sc
operator|->
name|mutex
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|invalid_args
label|:
name|device_printf
argument_list|(
name|arm_gic_sc
operator|->
name|dev
argument_list|,
literal|"gic_config_irg, invalid parameters\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SMP
end_ifdef

begin_function
name|void
name|pic_ipi_send
parameter_list|(
name|cpuset_t
name|cpus
parameter_list|,
name|u_int
name|ipi
parameter_list|)
block|{
name|uint32_t
name|val
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXCPU
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|CPU_ISSET
argument_list|(
name|i
argument_list|,
operator|&
name|cpus
argument_list|)
condition|)
name|val
operator||=
literal|1
operator|<<
operator|(
literal|16
operator|+
name|i
operator|)
expr_stmt|;
name|gic_d_write_4
argument_list|(
name|GICD_SGIR
argument_list|(
literal|0
argument_list|)
argument_list|,
name|val
operator||
name|ipi
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|pic_ipi_get
parameter_list|(
name|int
name|i
parameter_list|)
block|{
if|if
condition|(
name|i
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* 		 * The intr code will automagically give the frame pointer 		 * if the interrupt argument is 0. 		 */
if|if
condition|(
operator|(
name|unsigned
name|int
operator|)
name|i
operator|>
literal|16
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|i
operator|)
return|;
block|}
return|return
operator|(
literal|0x3ff
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pic_ipi_clear
parameter_list|(
name|int
name|ipi
parameter_list|)
block|{ }
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

