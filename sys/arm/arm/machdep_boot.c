begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2004 Olivier Houchard  * Copyright (c) 1994-1998 Mark Brinicombe.  * Copyright (c) 1994 Brini.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"opt_platform.h"
end_include

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker.h>
end_include

begin_include
include|#
directive|include
file|<sys/reboot.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|LINUX_BOOT_ABI
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/boot.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<machine/atags.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/machdep.h>
end_include

begin_include
include|#
directive|include
file|<machine/metadata.h>
end_include

begin_include
include|#
directive|include
file|<machine/physmem.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|FDT
end_ifdef

begin_include
include|#
directive|include
file|<contrib/libfdt/libfdt.h>
end_include

begin_include
include|#
directive|include
file|<dev/fdt/fdt_common.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EFI
end_ifdef

begin_include
include|#
directive|include
file|<sys/efi.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
define|#
directive|define
name|debugf
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
value|printf(fmt, ##args)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|debugf
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|int
modifier|*
name|end
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|board_revision
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* hex representation of uint64_t */
end_comment

begin_decl_stmt
specifier|static
name|char
name|board_serial
index|[
literal|32
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|loader_envp
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|LINUX_BOOT_ABI
argument_list|)
end_if

begin_define
define|#
directive|define
name|LBABI_MAX_BANKS
value|10
end_define

begin_define
define|#
directive|define
name|CMDLINE_GUARD
value|"FreeBSD:"
end_define

begin_decl_stmt
specifier|static
name|uint32_t
name|board_id
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|arm_lbabi_tag
modifier|*
name|atag_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|linux_command_line
index|[
name|LBABI_MAX_COMMAND_LINE
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|atags
index|[
name|LBABI_MAX_COMMAND_LINE
operator|*
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(LINUX_BOOT_ABI) */
end_comment

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|board
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"Board attributes"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_hw_board
argument_list|,
name|OID_AUTO
argument_list|,
name|revision
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|board_revision
argument_list|,
literal|0
argument_list|,
literal|"Board revision"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_STRING
argument_list|(
name|_hw_board
argument_list|,
name|OID_AUTO
argument_list|,
name|serial
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|board_serial
argument_list|,
literal|0
argument_list|,
literal|"Board serial"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|vfp_exists
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw
argument_list|,
name|HW_FLOATINGPT
argument_list|,
name|floatingpoint
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|vfp_exists
argument_list|,
literal|0
argument_list|,
literal|"Floating point support enabled"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|board_set_serial
parameter_list|(
name|uint64_t
name|serial
parameter_list|)
block|{
name|snprintf
argument_list|(
name|board_serial
argument_list|,
sizeof|sizeof
argument_list|(
name|board_serial
argument_list|)
operator|-
literal|1
argument_list|,
literal|"%016jx"
argument_list|,
name|serial
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|board_set_revision
parameter_list|(
name|uint32_t
name|revision
parameter_list|)
block|{
name|board_revision
operator|=
name|revision
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|kenv_next
parameter_list|(
name|char
modifier|*
name|cp
parameter_list|)
block|{
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
operator|*
name|cp
operator|!=
literal|0
condition|)
name|cp
operator|++
expr_stmt|;
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|0
condition|)
name|cp
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_function

begin_function
name|void
name|arm_print_kenv
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|debugf
argument_list|(
literal|"loader passed (static) kenv:\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|loader_envp
operator|==
name|NULL
condition|)
block|{
name|debugf
argument_list|(
literal|" no env, null ptr\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|debugf
argument_list|(
literal|" loader_envp = 0x%08x\n"
argument_list|,
operator|(
name|uint32_t
operator|)
name|loader_envp
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|loader_envp
init|;
name|cp
operator|!=
name|NULL
condition|;
name|cp
operator|=
name|kenv_next
argument_list|(
name|cp
argument_list|)
control|)
name|debugf
argument_list|(
literal|" %x %s\n"
argument_list|,
operator|(
name|uint32_t
operator|)
name|cp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|LINUX_BOOT_ABI
argument_list|)
end_if

begin_comment
comment|/* Convert the U-Boot command line into FreeBSD kenv and boot options. */
end_comment

begin_function
specifier|static
name|void
name|cmdline_set_env
parameter_list|(
name|char
modifier|*
name|cmdline
parameter_list|,
specifier|const
name|char
modifier|*
name|guard
parameter_list|)
block|{
name|char
modifier|*
name|cmdline_next
decl_stmt|,
modifier|*
name|env
decl_stmt|;
name|size_t
name|size
decl_stmt|,
name|guard_len
decl_stmt|;
name|int
name|i
decl_stmt|;
name|size
operator|=
name|strlen
argument_list|(
name|cmdline
argument_list|)
expr_stmt|;
comment|/* Skip leading spaces. */
for|for
control|(
init|;
name|isspace
argument_list|(
operator|*
name|cmdline
argument_list|)
operator|&&
operator|(
name|size
operator|>
literal|0
operator|)
condition|;
name|cmdline
operator|++
control|)
name|size
operator|--
expr_stmt|;
comment|/* Test and remove guard. */
if|if
condition|(
name|guard
operator|!=
name|NULL
operator|&&
name|guard
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|guard_len
operator|=
name|strlen
argument_list|(
name|guard
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncasecmp
argument_list|(
name|cmdline
argument_list|,
name|guard
argument_list|,
name|guard_len
argument_list|)
operator|!=
literal|0
condition|)
return|return;
name|cmdline
operator|+=
name|guard_len
expr_stmt|;
name|size
operator|-=
name|guard_len
expr_stmt|;
block|}
comment|/* Skip leading spaces. */
for|for
control|(
init|;
name|isspace
argument_list|(
operator|*
name|cmdline
argument_list|)
operator|&&
operator|(
name|size
operator|>
literal|0
operator|)
condition|;
name|cmdline
operator|++
control|)
name|size
operator|--
expr_stmt|;
comment|/* Replace ',' with '\0'. */
comment|/* TODO: implement escaping for ',' character. */
name|cmdline_next
operator|=
name|cmdline
expr_stmt|;
while|while
condition|(
name|strsep
argument_list|(
operator|&
name|cmdline_next
argument_list|,
literal|","
argument_list|)
operator|!=
name|NULL
condition|)
empty_stmt|;
name|init_static_kenv
argument_list|(
name|cmdline
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Parse boothowto. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|howto_names
index|[
name|i
index|]
operator|.
name|ev
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|env
operator|=
name|kern_getenv
argument_list|(
name|howto_names
index|[
name|i
index|]
operator|.
name|ev
argument_list|)
expr_stmt|;
if|if
condition|(
name|env
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strtoul
argument_list|(
name|env
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
operator|!=
literal|0
condition|)
name|boothowto
operator||=
name|howto_names
index|[
name|i
index|]
operator|.
name|mask
expr_stmt|;
name|freeenv
argument_list|(
name|env
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|arm_parse_fdt_bootargs
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|FDT
if|if
condition|(
name|loader_envp
operator|==
name|NULL
operator|&&
name|fdt_get_chosen_bootargs
argument_list|(
name|linux_command_line
argument_list|,
name|LBABI_MAX_COMMAND_LINE
argument_list|)
operator|==
literal|0
condition|)
name|cmdline_set_env
argument_list|(
name|linux_command_line
argument_list|,
name|CMDLINE_GUARD
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|vm_offset_t
name|linux_parse_boot_param
parameter_list|(
name|struct
name|arm_boot_params
modifier|*
name|abp
parameter_list|)
block|{
name|struct
name|arm_lbabi_tag
modifier|*
name|walker
decl_stmt|;
name|uint32_t
name|revision
decl_stmt|;
name|uint64_t
name|serial
decl_stmt|;
name|int
name|size
decl_stmt|;
name|vm_offset_t
name|lastaddr
decl_stmt|;
ifdef|#
directive|ifdef
name|FDT
name|struct
name|fdt_header
modifier|*
name|dtb_ptr
decl_stmt|;
name|uint32_t
name|dtb_size
decl_stmt|;
endif|#
directive|endif
comment|/* 	 * Linux boot ABI: r0 = 0, r1 is the board type (!= 0) and r2 	 * is atags or dtb pointer.  If all of these aren't satisfied, 	 * then punt. Unfortunately, it looks like DT enabled kernels 	 * doesn't uses board type and U-Boot delivers 0 in r1 for them. 	 */
if|if
condition|(
name|abp
operator|->
name|abp_r0
operator|!=
literal|0
operator|||
name|abp
operator|->
name|abp_r2
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
ifdef|#
directive|ifdef
name|FDT
comment|/* Test if r2 point to valid DTB. */
name|dtb_ptr
operator|=
operator|(
expr|struct
name|fdt_header
operator|*
operator|)
name|abp
operator|->
name|abp_r2
expr_stmt|;
if|if
condition|(
name|fdt_check_header
argument_list|(
name|dtb_ptr
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dtb_size
operator|=
name|fdt_totalsize
argument_list|(
name|dtb_ptr
argument_list|)
expr_stmt|;
return|return
operator|(
name|fake_preload_metadata
argument_list|(
name|abp
argument_list|,
name|dtb_ptr
argument_list|,
name|dtb_size
argument_list|)
operator|)
return|;
block|}
endif|#
directive|endif
name|board_id
operator|=
name|abp
operator|->
name|abp_r1
expr_stmt|;
name|walker
operator|=
operator|(
expr|struct
name|arm_lbabi_tag
operator|*
operator|)
name|abp
operator|->
name|abp_r2
expr_stmt|;
if|if
condition|(
name|ATAG_TAG
argument_list|(
name|walker
argument_list|)
operator|!=
name|ATAG_CORE
condition|)
return|return
literal|0
return|;
name|atag_list
operator|=
name|walker
expr_stmt|;
while|while
condition|(
name|ATAG_TAG
argument_list|(
name|walker
argument_list|)
operator|!=
name|ATAG_NONE
condition|)
block|{
switch|switch
condition|(
name|ATAG_TAG
argument_list|(
name|walker
argument_list|)
condition|)
block|{
case|case
name|ATAG_CORE
case|:
break|break;
case|case
name|ATAG_MEM
case|:
name|arm_physmem_hardware_region
argument_list|(
name|walker
operator|->
name|u
operator|.
name|tag_mem
operator|.
name|start
argument_list|,
name|walker
operator|->
name|u
operator|.
name|tag_mem
operator|.
name|size
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATAG_INITRD2
case|:
break|break;
case|case
name|ATAG_SERIAL
case|:
name|serial
operator|=
name|walker
operator|->
name|u
operator|.
name|tag_sn
operator|.
name|high
expr_stmt|;
name|serial
operator|<<=
literal|32
expr_stmt|;
name|serial
operator||=
name|walker
operator|->
name|u
operator|.
name|tag_sn
operator|.
name|low
expr_stmt|;
name|board_set_serial
argument_list|(
name|serial
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATAG_REVISION
case|:
name|revision
operator|=
name|walker
operator|->
name|u
operator|.
name|tag_rev
operator|.
name|rev
expr_stmt|;
name|board_set_revision
argument_list|(
name|revision
argument_list|)
expr_stmt|;
break|break;
case|case
name|ATAG_CMDLINE
case|:
name|size
operator|=
name|ATAG_SIZE
argument_list|(
name|walker
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|arm_lbabi_header
argument_list|)
expr_stmt|;
name|size
operator|=
name|min
argument_list|(
name|size
argument_list|,
name|LBABI_MAX_COMMAND_LINE
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|linux_command_line
argument_list|,
name|walker
operator|->
name|u
operator|.
name|tag_cmd
operator|.
name|command
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|linux_command_line
index|[
name|size
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|walker
operator|=
name|ATAG_NEXT
argument_list|(
name|walker
argument_list|)
expr_stmt|;
block|}
comment|/* Save a copy for later */
name|bcopy
argument_list|(
name|atag_list
argument_list|,
name|atags
argument_list|,
operator|(
name|char
operator|*
operator|)
name|walker
operator|-
operator|(
name|char
operator|*
operator|)
name|atag_list
operator|+
name|ATAG_SIZE
argument_list|(
name|walker
argument_list|)
argument_list|)
expr_stmt|;
name|lastaddr
operator|=
name|fake_preload_metadata
argument_list|(
name|abp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cmdline_set_env
argument_list|(
name|linux_command_line
argument_list|,
name|CMDLINE_GUARD
argument_list|)
expr_stmt|;
return|return
name|lastaddr
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|FREEBSD_BOOT_LOADER
argument_list|)
end_if

begin_function
specifier|static
name|vm_offset_t
name|freebsd_parse_boot_param
parameter_list|(
name|struct
name|arm_boot_params
modifier|*
name|abp
parameter_list|)
block|{
name|vm_offset_t
name|lastaddr
init|=
literal|0
decl_stmt|;
name|void
modifier|*
name|mdp
decl_stmt|;
name|void
modifier|*
name|kmdp
decl_stmt|;
ifdef|#
directive|ifdef
name|DDB
name|vm_offset_t
name|ksym_start
decl_stmt|;
name|vm_offset_t
name|ksym_end
decl_stmt|;
endif|#
directive|endif
comment|/* 	 * Mask metadata pointer: it is supposed to be on page boundary. If 	 * the first argument (mdp) doesn't point to a valid address the 	 * bootloader must have passed us something else than the metadata 	 * ptr, so we give up.  Also give up if we cannot find metadta section 	 * the loader creates that we get all this data out of. 	 */
if|if
condition|(
operator|(
name|mdp
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|abp
operator|->
name|abp_r0
operator|&
operator|~
name|PAGE_MASK
operator|)
operator|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|preload_metadata
operator|=
name|mdp
expr_stmt|;
name|kmdp
operator|=
name|preload_search_by_type
argument_list|(
literal|"elf kernel"
argument_list|)
expr_stmt|;
if|if
condition|(
name|kmdp
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|boothowto
operator|=
name|MD_FETCH
argument_list|(
name|kmdp
argument_list|,
name|MODINFOMD_HOWTO
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|loader_envp
operator|=
name|MD_FETCH
argument_list|(
name|kmdp
argument_list|,
name|MODINFOMD_ENVP
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|init_static_kenv
argument_list|(
name|loader_envp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lastaddr
operator|=
name|MD_FETCH
argument_list|(
name|kmdp
argument_list|,
name|MODINFOMD_KERNEND
argument_list|,
name|vm_offset_t
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DDB
name|ksym_start
operator|=
name|MD_FETCH
argument_list|(
name|kmdp
argument_list|,
name|MODINFOMD_SSYM
argument_list|,
name|uintptr_t
argument_list|)
expr_stmt|;
name|ksym_end
operator|=
name|MD_FETCH
argument_list|(
name|kmdp
argument_list|,
name|MODINFOMD_ESYM
argument_list|,
name|uintptr_t
argument_list|)
expr_stmt|;
name|db_fetch_ksymtab
argument_list|(
name|ksym_start
argument_list|,
name|ksym_end
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|lastaddr
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|vm_offset_t
name|default_parse_boot_param
parameter_list|(
name|struct
name|arm_boot_params
modifier|*
name|abp
parameter_list|)
block|{
name|vm_offset_t
name|lastaddr
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|LINUX_BOOT_ABI
argument_list|)
if|if
condition|(
operator|(
name|lastaddr
operator|=
name|linux_parse_boot_param
argument_list|(
name|abp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|lastaddr
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|FREEBSD_BOOT_LOADER
argument_list|)
if|if
condition|(
operator|(
name|lastaddr
operator|=
name|freebsd_parse_boot_param
argument_list|(
name|abp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|lastaddr
return|;
endif|#
directive|endif
comment|/* Fall back to hardcoded metadata. */
name|lastaddr
operator|=
name|fake_preload_metadata
argument_list|(
name|abp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|lastaddr
return|;
block|}
end_function

begin_comment
comment|/*  * Stub version of the boot parameter parsing routine.  We are  * called early in initarm, before even VM has been initialized.  * This routine needs to preserve any data that the boot loader  * has passed in before the kernel starts to grow past the end  * of the BSS, traditionally the place boot-loaders put this data.  *  * Since this is called so early, things that depend on the vm system  * being setup (including access to some SoC's serial ports), about  * all that can be done in this routine is to copy the arguments.  *  * This is the default boot parameter parsing routine.  Individual  * kernels/boards can override this weak function with one of their  * own.  We just fake metadata...  */
end_comment

begin_expr_stmt
name|__weak_reference
argument_list|(
name|default_parse_boot_param
argument_list|,
name|parse_boot_param
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Fake up a boot descriptor table  */
end_comment

begin_function
name|vm_offset_t
name|fake_preload_metadata
parameter_list|(
name|struct
name|arm_boot_params
modifier|*
name|abp
name|__unused
parameter_list|,
name|void
modifier|*
name|dtb_ptr
parameter_list|,
name|size_t
name|dtb_size
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DDB
name|vm_offset_t
name|zstart
init|=
literal|0
decl_stmt|,
name|zend
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|vm_offset_t
name|lastaddr
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
specifier|static
name|uint32_t
name|fake_preload
index|[
literal|35
index|]
decl_stmt|;
name|fake_preload
index|[
name|i
operator|++
index|]
operator|=
name|MODINFO_NAME
expr_stmt|;
name|fake_preload
index|[
name|i
operator|++
index|]
operator|=
name|strlen
argument_list|(
literal|"kernel"
argument_list|)
operator|+
literal|1
expr_stmt|;
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|fake_preload
index|[
name|i
operator|++
index|]
argument_list|,
literal|"kernel"
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
name|fake_preload
index|[
name|i
operator|++
index|]
operator|=
name|MODINFO_TYPE
expr_stmt|;
name|fake_preload
index|[
name|i
operator|++
index|]
operator|=
name|strlen
argument_list|(
literal|"elf kernel"
argument_list|)
operator|+
literal|1
expr_stmt|;
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|fake_preload
index|[
name|i
operator|++
index|]
argument_list|,
literal|"elf kernel"
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|2
expr_stmt|;
name|fake_preload
index|[
name|i
operator|++
index|]
operator|=
name|MODINFO_ADDR
expr_stmt|;
name|fake_preload
index|[
name|i
operator|++
index|]
operator|=
sizeof|sizeof
argument_list|(
name|vm_offset_t
argument_list|)
expr_stmt|;
name|fake_preload
index|[
name|i
operator|++
index|]
operator|=
name|KERNVIRTADDR
expr_stmt|;
name|fake_preload
index|[
name|i
operator|++
index|]
operator|=
name|MODINFO_SIZE
expr_stmt|;
name|fake_preload
index|[
name|i
operator|++
index|]
operator|=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|fake_preload
index|[
name|i
operator|++
index|]
operator|=
operator|(
name|uint32_t
operator|)
operator|&
name|end
operator|-
name|KERNVIRTADDR
expr_stmt|;
ifdef|#
directive|ifdef
name|DDB
if|if
condition|(
operator|*
operator|(
name|uint32_t
operator|*
operator|)
name|KERNVIRTADDR
operator|==
name|MAGIC_TRAMP_NUMBER
condition|)
block|{
name|fake_preload
index|[
name|i
operator|++
index|]
operator|=
name|MODINFO_METADATA
operator||
name|MODINFOMD_SSYM
expr_stmt|;
name|fake_preload
index|[
name|i
operator|++
index|]
operator|=
sizeof|sizeof
argument_list|(
name|vm_offset_t
argument_list|)
expr_stmt|;
name|fake_preload
index|[
name|i
operator|++
index|]
operator|=
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|KERNVIRTADDR
operator|+
literal|4
operator|)
expr_stmt|;
name|fake_preload
index|[
name|i
operator|++
index|]
operator|=
name|MODINFO_METADATA
operator||
name|MODINFOMD_ESYM
expr_stmt|;
name|fake_preload
index|[
name|i
operator|++
index|]
operator|=
sizeof|sizeof
argument_list|(
name|vm_offset_t
argument_list|)
expr_stmt|;
name|fake_preload
index|[
name|i
operator|++
index|]
operator|=
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|KERNVIRTADDR
operator|+
literal|8
operator|)
expr_stmt|;
name|lastaddr
operator|=
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|KERNVIRTADDR
operator|+
literal|8
operator|)
expr_stmt|;
name|zend
operator|=
name|lastaddr
expr_stmt|;
name|zstart
operator|=
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|KERNVIRTADDR
operator|+
literal|4
operator|)
expr_stmt|;
name|db_fetch_ksymtab
argument_list|(
name|zstart
argument_list|,
name|zend
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|lastaddr
operator|=
operator|(
name|vm_offset_t
operator|)
operator|&
name|end
expr_stmt|;
if|if
condition|(
name|dtb_ptr
operator|!=
name|NULL
condition|)
block|{
comment|/* Copy DTB to KVA space and insert it into module chain. */
name|lastaddr
operator|=
name|roundup
argument_list|(
name|lastaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|fake_preload
index|[
name|i
operator|++
index|]
operator|=
name|MODINFO_METADATA
operator||
name|MODINFOMD_DTBP
expr_stmt|;
name|fake_preload
index|[
name|i
operator|++
index|]
operator|=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|fake_preload
index|[
name|i
operator|++
index|]
operator|=
operator|(
name|uint32_t
operator|)
name|lastaddr
expr_stmt|;
name|memmove
argument_list|(
operator|(
name|void
operator|*
operator|)
name|lastaddr
argument_list|,
name|dtb_ptr
argument_list|,
name|dtb_size
argument_list|)
expr_stmt|;
name|lastaddr
operator|+=
name|dtb_size
expr_stmt|;
name|lastaddr
operator|=
name|roundup
argument_list|(
name|lastaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fake_preload
index|[
name|i
operator|++
index|]
operator|=
literal|0
expr_stmt|;
name|fake_preload
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|preload_metadata
operator|=
operator|(
name|void
operator|*
operator|)
name|fake_preload
expr_stmt|;
name|init_static_kenv
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|lastaddr
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|EFI
end_ifdef

begin_function
name|void
name|arm_add_efi_map_entries
parameter_list|(
name|struct
name|efi_map_header
modifier|*
name|efihdr
parameter_list|,
name|struct
name|mem_region
modifier|*
name|mr
parameter_list|,
name|int
modifier|*
name|mrcnt
parameter_list|)
block|{
name|struct
name|efi_md
modifier|*
name|map
decl_stmt|,
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|type
decl_stmt|;
name|size_t
name|efisz
decl_stmt|,
name|memory_size
decl_stmt|;
name|int
name|ndesc
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|types
index|[]
init|=
block|{
literal|"Reserved"
block|,
literal|"LoaderCode"
block|,
literal|"LoaderData"
block|,
literal|"BootServicesCode"
block|,
literal|"BootServicesData"
block|,
literal|"RuntimeServicesCode"
block|,
literal|"RuntimeServicesData"
block|,
literal|"ConventionalMemory"
block|,
literal|"UnusableMemory"
block|,
literal|"ACPIReclaimMemory"
block|,
literal|"ACPIMemoryNVS"
block|,
literal|"MemoryMappedIO"
block|,
literal|"MemoryMappedIOPortSpace"
block|,
literal|"PalCode"
block|,
literal|"PersistentMemory"
block|}
decl_stmt|;
operator|*
name|mrcnt
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Memory map data provided by UEFI via the GetMemoryMap 	 * Boot Services API. 	 */
name|efisz
operator|=
name|roundup2
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|efi_map_header
argument_list|)
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
name|map
operator|=
operator|(
expr|struct
name|efi_md
operator|*
operator|)
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|efihdr
operator|+
name|efisz
operator|)
expr_stmt|;
if|if
condition|(
name|efihdr
operator|->
name|descriptor_size
operator|==
literal|0
condition|)
return|return;
name|ndesc
operator|=
name|efihdr
operator|->
name|memory_size
operator|/
name|efihdr
operator|->
name|descriptor_size
expr_stmt|;
if|if
condition|(
name|boothowto
operator|&
name|RB_VERBOSE
condition|)
name|printf
argument_list|(
literal|"%23s %12s %12s %8s %4s\n"
argument_list|,
literal|"Type"
argument_list|,
literal|"Physical"
argument_list|,
literal|"Virtual"
argument_list|,
literal|"#Pages"
argument_list|,
literal|"Attr"
argument_list|)
expr_stmt|;
name|memory_size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
operator|,
name|p
operator|=
name|map
init|;
name|i
operator|<
name|ndesc
condition|;
name|i
operator|++
operator|,
name|p
operator|=
name|efi_next_descriptor
argument_list|(
name|p
argument_list|,
name|efihdr
operator|->
name|descriptor_size
argument_list|)
control|)
block|{
if|if
condition|(
name|boothowto
operator|&
name|RB_VERBOSE
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|md_type
operator|<
name|nitems
argument_list|(
name|types
argument_list|)
condition|)
name|type
operator|=
name|types
index|[
name|p
operator|->
name|md_type
index|]
expr_stmt|;
else|else
name|type
operator|=
literal|"<INVALID>"
expr_stmt|;
name|printf
argument_list|(
literal|"%23s %012llx %12p %08llx "
argument_list|,
name|type
argument_list|,
name|p
operator|->
name|md_phys
argument_list|,
name|p
operator|->
name|md_virt
argument_list|,
name|p
operator|->
name|md_pages
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|md_attr
operator|&
name|EFI_MD_ATTR_UC
condition|)
name|printf
argument_list|(
literal|"UC "
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|md_attr
operator|&
name|EFI_MD_ATTR_WC
condition|)
name|printf
argument_list|(
literal|"WC "
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|md_attr
operator|&
name|EFI_MD_ATTR_WT
condition|)
name|printf
argument_list|(
literal|"WT "
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|md_attr
operator|&
name|EFI_MD_ATTR_WB
condition|)
name|printf
argument_list|(
literal|"WB "
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|md_attr
operator|&
name|EFI_MD_ATTR_UCE
condition|)
name|printf
argument_list|(
literal|"UCE "
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|md_attr
operator|&
name|EFI_MD_ATTR_WP
condition|)
name|printf
argument_list|(
literal|"WP "
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|md_attr
operator|&
name|EFI_MD_ATTR_RP
condition|)
name|printf
argument_list|(
literal|"RP "
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|md_attr
operator|&
name|EFI_MD_ATTR_XP
condition|)
name|printf
argument_list|(
literal|"XP "
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|md_attr
operator|&
name|EFI_MD_ATTR_NV
condition|)
name|printf
argument_list|(
literal|"NV "
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|md_attr
operator|&
name|EFI_MD_ATTR_MORE_RELIABLE
condition|)
name|printf
argument_list|(
literal|"MORE_RELIABLE "
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|md_attr
operator|&
name|EFI_MD_ATTR_RO
condition|)
name|printf
argument_list|(
literal|"RO "
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|md_attr
operator|&
name|EFI_MD_ATTR_RT
condition|)
name|printf
argument_list|(
literal|"RUNTIME"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|p
operator|->
name|md_type
condition|)
block|{
case|case
name|EFI_MD_TYPE_CODE
case|:
case|case
name|EFI_MD_TYPE_DATA
case|:
case|case
name|EFI_MD_TYPE_BS_CODE
case|:
case|case
name|EFI_MD_TYPE_BS_DATA
case|:
case|case
name|EFI_MD_TYPE_FREE
case|:
comment|/* 			 * We're allowed to use any entry with these types. 			 */
break|break;
default|default:
continue|continue;
block|}
name|j
operator|++
expr_stmt|;
if|if
condition|(
name|j
operator|>=
name|FDT_MEM_REGIONS
condition|)
break|break;
name|mr
index|[
name|j
index|]
operator|.
name|mr_start
operator|=
name|p
operator|->
name|md_phys
expr_stmt|;
name|mr
index|[
name|j
index|]
operator|.
name|mr_size
operator|=
name|p
operator|->
name|md_pages
operator|*
name|PAGE_SIZE
expr_stmt|;
name|memory_size
operator|+=
name|mr
index|[
name|j
index|]
operator|.
name|mr_size
expr_stmt|;
block|}
operator|*
name|mrcnt
operator|=
name|j
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EFI */
end_comment

end_unit

