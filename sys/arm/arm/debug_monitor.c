begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2015 Juniper Networks Inc.  * All rights reserved.  *  * Developed by Semihalf.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/kdb.h>
end_include

begin_include
include|#
directive|include
file|<sys/pcpu.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<machine/atomic.h>
end_include

begin_include
include|#
directive|include
file|<machine/armreg.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/debug_monitor.h>
end_include

begin_include
include|#
directive|include
file|<machine/kdb.h>
end_include

begin_include
include|#
directive|include
file|<machine/pcb.h>
end_include

begin_include
include|#
directive|include
file|<machine/reg.h>
end_include

begin_include
include|#
directive|include
file|<ddb/ddb.h>
end_include

begin_include
include|#
directive|include
file|<ddb/db_access.h>
end_include

begin_include
include|#
directive|include
file|<ddb/db_sym.h>
end_include

begin_enum
enum|enum
name|dbg_t
block|{
name|DBG_TYPE_BREAKPOINT
init|=
literal|0
block|,
name|DBG_TYPE_WATCHPOINT
init|=
literal|1
block|, }
enum|;
end_enum

begin_struct
struct|struct
name|dbg_wb_conf
block|{
name|enum
name|dbg_t
name|type
decl_stmt|;
name|enum
name|dbg_access_t
name|access
decl_stmt|;
name|db_addr_t
name|address
decl_stmt|;
name|db_expr_t
name|size
decl_stmt|;
name|u_int
name|slot
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|dbg_reset_state
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dbg_setup_breakpoint
parameter_list|(
name|db_expr_t
parameter_list|,
name|db_expr_t
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dbg_remove_breakpoint
parameter_list|(
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int
name|dbg_find_slot
parameter_list|(
name|enum
name|dbg_t
parameter_list|,
name|db_expr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|boolean_t
name|dbg_check_slot_free
parameter_list|(
name|enum
name|dbg_t
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dbg_remove_xpoint
parameter_list|(
name|struct
name|dbg_wb_conf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dbg_setup_xpoint
parameter_list|(
name|struct
name|dbg_wb_conf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|dbg_capable_var
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indicates that machine is capable of using 				   HW watchpoints/breakpoints */
end_comment

begin_decl_stmt
specifier|static
name|uint32_t
name|dbg_model
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Debug Arch. Model */
end_comment

begin_decl_stmt
specifier|static
name|boolean_t
name|dbg_ossr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* OS Save and Restore implemented */
end_comment

begin_decl_stmt
specifier|static
name|uint32_t
name|dbg_watchpoint_num
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|dbg_breakpoint_num
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ID_DFR0 - Debug Feature Register 0 */
end_comment

begin_define
define|#
directive|define
name|ID_DFR0_CP_DEBUG_M_SHIFT
value|0
end_define

begin_define
define|#
directive|define
name|ID_DFR0_CP_DEBUG_M_MASK
value|(0xF<< ID_DFR0_CP_DEBUG_M_SHIFT)
end_define

begin_define
define|#
directive|define
name|ID_DFR0_CP_DEBUG_M_NS
value|(0x0)
end_define

begin_comment
comment|/* Not supported */
end_comment

begin_define
define|#
directive|define
name|ID_DFR0_CP_DEBUG_M_V6
value|(0x2)
end_define

begin_comment
comment|/* v6 Debug arch. CP14 access */
end_comment

begin_define
define|#
directive|define
name|ID_DFR0_CP_DEBUG_M_V6_1
value|(0x3)
end_define

begin_comment
comment|/* v6.1 Debug arch. CP14 access */
end_comment

begin_define
define|#
directive|define
name|ID_DFR0_CP_DEBUG_M_V7
value|(0x4)
end_define

begin_comment
comment|/* v7 Debug arch. CP14 access */
end_comment

begin_define
define|#
directive|define
name|ID_DFR0_CP_DEBUG_M_V7_1
value|(0x5)
end_define

begin_comment
comment|/* v7.1 Debug arch. CP14 access */
end_comment

begin_comment
comment|/* DBGDIDR - Debug ID Register */
end_comment

begin_define
define|#
directive|define
name|DBGDIDR_WRPS_SHIFT
value|28
end_define

begin_define
define|#
directive|define
name|DBGDIDR_WRPS_MASK
value|(0xF<< DBGDIDR_WRPS_SHIFT)
end_define

begin_define
define|#
directive|define
name|DBGDIDR_WRPS_NUM
parameter_list|(
name|reg
parameter_list|)
define|\
value|((((reg)& DBGDIDR_WRPS_MASK)>> DBGDIDR_WRPS_SHIFT) + 1)
end_define

begin_define
define|#
directive|define
name|DBGDIDR_BRPS_SHIFT
value|24
end_define

begin_define
define|#
directive|define
name|DBGDIDR_BRPS_MASK
value|(0xF<< DBGDIDR_BRPS_SHIFT)
end_define

begin_define
define|#
directive|define
name|DBGDIDR_BRPS_NUM
parameter_list|(
name|reg
parameter_list|)
define|\
value|((((reg)& DBGDIDR_BRPS_MASK)>> DBGDIDR_BRPS_SHIFT) + 1)
end_define

begin_comment
comment|/* DBGPRSR - Device Powerdown and Reset Status Register */
end_comment

begin_define
define|#
directive|define
name|DBGPRSR_PU
value|(1<< 0)
end_define

begin_comment
comment|/* Powerup status */
end_comment

begin_comment
comment|/* DBGOSLSR - OS Lock Status Register */
end_comment

begin_define
define|#
directive|define
name|DBGOSLSR_OSLM0
value|(1<< 0)
end_define

begin_comment
comment|/* DBGOSDLR - OS Double Lock Register */
end_comment

begin_define
define|#
directive|define
name|DBGPRSR_DLK
value|(1<< 0)
end_define

begin_comment
comment|/* OS Double Lock set */
end_comment

begin_comment
comment|/* DBGDSCR - Debug Status and Control Register */
end_comment

begin_define
define|#
directive|define
name|DBGSCR_MDBG_EN
value|(1<< 15)
end_define

begin_comment
comment|/* Monitor debug-mode enable */
end_comment

begin_comment
comment|/* DBGWVR - Watchpoint Value Register */
end_comment

begin_define
define|#
directive|define
name|DBGWVR_ADDR_MASK
value|(~0x3U)
end_define

begin_comment
comment|/* Watchpoints/breakpoints control register bitfields */
end_comment

begin_define
define|#
directive|define
name|DBG_WB_CTRL_LEN_1
value|(0x1<< 5)
end_define

begin_define
define|#
directive|define
name|DBG_WB_CTRL_LEN_2
value|(0x3<< 5)
end_define

begin_define
define|#
directive|define
name|DBG_WB_CTRL_LEN_4
value|(0xf<< 5)
end_define

begin_define
define|#
directive|define
name|DBG_WB_CTRL_LEN_8
value|(0xff<< 5)
end_define

begin_define
define|#
directive|define
name|DBG_WB_CTRL_LEN_MASK
parameter_list|(
name|x
parameter_list|)
value|((x)& (0xff<< 5))
end_define

begin_define
define|#
directive|define
name|DBG_WB_CTRL_EXEC
value|(0x0<< 3)
end_define

begin_define
define|#
directive|define
name|DBG_WB_CTRL_LOAD
value|(0x1<< 3)
end_define

begin_define
define|#
directive|define
name|DBG_WB_CTRL_STORE
value|(0x2<< 3)
end_define

begin_define
define|#
directive|define
name|DBG_WB_CTRL_ACCESS_MASK
parameter_list|(
name|x
parameter_list|)
value|((x)& (0x3<< 3))
end_define

begin_comment
comment|/* Common for breakpoint and watchpoint */
end_comment

begin_define
define|#
directive|define
name|DBG_WB_CTRL_PL1
value|(0x1<< 1)
end_define

begin_define
define|#
directive|define
name|DBG_WB_CTRL_PL0
value|(0x2<< 1)
end_define

begin_define
define|#
directive|define
name|DBG_WB_CTRL_PLX_MASK
parameter_list|(
name|x
parameter_list|)
value|((x)& (0x3<< 1))
end_define

begin_define
define|#
directive|define
name|DBG_WB_CTRL_E
value|(0x1<< 0)
end_define

begin_comment
comment|/*  * Watchpoint/breakpoint helpers  */
end_comment

begin_define
define|#
directive|define
name|DBG_BKPT_BT_SLOT
value|0
end_define

begin_comment
comment|/* Slot for branch taken */
end_comment

begin_define
define|#
directive|define
name|DBG_BKPT_BNT_SLOT
value|1
end_define

begin_comment
comment|/* Slot for branch not taken */
end_comment

begin_define
define|#
directive|define
name|OP2_SHIFT
value|4
end_define

begin_comment
comment|/* Opc2 numbers for coprocessor instructions */
end_comment

begin_define
define|#
directive|define
name|DBG_WB_BVR
value|4
end_define

begin_define
define|#
directive|define
name|DBG_WB_BCR
value|5
end_define

begin_define
define|#
directive|define
name|DBG_WB_WVR
value|6
end_define

begin_define
define|#
directive|define
name|DBG_WB_WCR
value|7
end_define

begin_define
define|#
directive|define
name|DBG_REG_BASE_BVR
value|(DBG_WB_BVR<< OP2_SHIFT)
end_define

begin_define
define|#
directive|define
name|DBG_REG_BASE_BCR
value|(DBG_WB_BCR<< OP2_SHIFT)
end_define

begin_define
define|#
directive|define
name|DBG_REG_BASE_WVR
value|(DBG_WB_WVR<< OP2_SHIFT)
end_define

begin_define
define|#
directive|define
name|DBG_REG_BASE_WCR
value|(DBG_WB_WCR<< OP2_SHIFT)
end_define

begin_define
define|#
directive|define
name|DBG_WB_READ
parameter_list|(
name|cn
parameter_list|,
name|cm
parameter_list|,
name|op2
parameter_list|,
name|val
parameter_list|)
value|do {					\ 	__asm __volatile("mrc p14, 0, %0, " #cn "," #cm "," #op2 : "=r" (val));	\ } while (0)
end_define

begin_define
define|#
directive|define
name|DBG_WB_WRITE
parameter_list|(
name|cn
parameter_list|,
name|cm
parameter_list|,
name|op2
parameter_list|,
name|val
parameter_list|)
value|do {					\ 	__asm __volatile("mcr p14, 0, %0, " #cn "," #cm "," #op2 :: "r" (val));	\ } while (0)
end_define

begin_define
define|#
directive|define
name|READ_WB_REG_CASE
parameter_list|(
name|op2
parameter_list|,
name|m
parameter_list|,
name|val
parameter_list|)
define|\
value|case (((op2)<< OP2_SHIFT) + m):		\ 		DBG_WB_READ(c0, c ## m, op2, val);	\ 		break
end_define

begin_define
define|#
directive|define
name|WRITE_WB_REG_CASE
parameter_list|(
name|op2
parameter_list|,
name|m
parameter_list|,
name|val
parameter_list|)
define|\
value|case (((op2)<< OP2_SHIFT) + m):		\ 		DBG_WB_WRITE(c0, c ## m, op2, val);	\ 		break
end_define

begin_define
define|#
directive|define
name|SWITCH_CASES_READ_WB_REG
parameter_list|(
name|op2
parameter_list|,
name|val
parameter_list|)
define|\
value|READ_WB_REG_CASE(op2,  0, val);		\ 	READ_WB_REG_CASE(op2,  1, val);		\ 	READ_WB_REG_CASE(op2,  2, val);		\ 	READ_WB_REG_CASE(op2,  3, val);		\ 	READ_WB_REG_CASE(op2,  4, val);		\ 	READ_WB_REG_CASE(op2,  5, val);		\ 	READ_WB_REG_CASE(op2,  6, val);		\ 	READ_WB_REG_CASE(op2,  7, val);		\ 	READ_WB_REG_CASE(op2,  8, val);		\ 	READ_WB_REG_CASE(op2,  9, val);		\ 	READ_WB_REG_CASE(op2, 10, val);		\ 	READ_WB_REG_CASE(op2, 11, val);		\ 	READ_WB_REG_CASE(op2, 12, val);		\ 	READ_WB_REG_CASE(op2, 13, val);		\ 	READ_WB_REG_CASE(op2, 14, val);		\ 	READ_WB_REG_CASE(op2, 15, val)
end_define

begin_define
define|#
directive|define
name|SWITCH_CASES_WRITE_WB_REG
parameter_list|(
name|op2
parameter_list|,
name|val
parameter_list|)
define|\
value|WRITE_WB_REG_CASE(op2,  0, val);	\ 	WRITE_WB_REG_CASE(op2,  1, val);	\ 	WRITE_WB_REG_CASE(op2,  2, val);	\ 	WRITE_WB_REG_CASE(op2,  3, val);	\ 	WRITE_WB_REG_CASE(op2,  4, val);	\ 	WRITE_WB_REG_CASE(op2,  5, val);	\ 	WRITE_WB_REG_CASE(op2,  6, val);	\ 	WRITE_WB_REG_CASE(op2,  7, val);	\ 	WRITE_WB_REG_CASE(op2,  8, val);	\ 	WRITE_WB_REG_CASE(op2,  9, val);	\ 	WRITE_WB_REG_CASE(op2, 10, val);	\ 	WRITE_WB_REG_CASE(op2, 11, val);	\ 	WRITE_WB_REG_CASE(op2, 12, val);	\ 	WRITE_WB_REG_CASE(op2, 13, val);	\ 	WRITE_WB_REG_CASE(op2, 14, val);	\ 	WRITE_WB_REG_CASE(op2, 15, val)
end_define

begin_function
specifier|static
name|uint32_t
name|dbg_wb_read_reg
parameter_list|(
name|int
name|reg
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|reg
operator|+
name|n
condition|)
block|{
name|SWITCH_CASES_READ_WB_REG
argument_list|(
name|DBG_WB_WVR
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|SWITCH_CASES_READ_WB_REG
argument_list|(
name|DBG_WB_WCR
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|SWITCH_CASES_READ_WB_REG
argument_list|(
name|DBG_WB_BVR
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|SWITCH_CASES_READ_WB_REG
argument_list|(
name|DBG_WB_BCR
argument_list|,
name|val
argument_list|)
expr_stmt|;
default|default:
name|db_printf
argument_list|(
literal|"trying to read from CP14 reg. using wrong opc2 %d\n"
argument_list|,
name|reg
operator|>>
name|OP2_SHIFT
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dbg_wb_write_reg
parameter_list|(
name|int
name|reg
parameter_list|,
name|int
name|n
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
switch|switch
condition|(
name|reg
operator|+
name|n
condition|)
block|{
name|SWITCH_CASES_WRITE_WB_REG
argument_list|(
name|DBG_WB_WVR
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|SWITCH_CASES_WRITE_WB_REG
argument_list|(
name|DBG_WB_WCR
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|SWITCH_CASES_WRITE_WB_REG
argument_list|(
name|DBG_WB_BVR
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|SWITCH_CASES_WRITE_WB_REG
argument_list|(
name|DBG_WB_BCR
argument_list|,
name|val
argument_list|)
expr_stmt|;
default|default:
name|db_printf
argument_list|(
literal|"trying to write to CP14 reg. using wrong opc2 %d\n"
argument_list|,
name|reg
operator|>>
name|OP2_SHIFT
argument_list|)
expr_stmt|;
block|}
name|isb
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|boolean_t
name|dbg_capable
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|atomic_cmpset_int
argument_list|(
operator|&
name|dbg_capable_var
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|boolean_t
name|kdb_cpu_pc_is_singlestep
parameter_list|(
name|db_addr_t
name|pc
parameter_list|)
block|{
comment|/* 	 * XXX: If the platform fails to enable its debug arch. 	 *      there will be no stepping capabilities 	 *      (SOFTWARE_SSTEP is not defined for __ARM_ARCH>= 6). 	 */
if|if
condition|(
operator|!
name|dbg_capable
argument_list|()
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
name|dbg_find_slot
argument_list|(
name|DBG_TYPE_BREAKPOINT
argument_list|,
name|pc
argument_list|)
operator|!=
operator|~
literal|0U
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_function
name|void
name|kdb_cpu_set_singlestep
parameter_list|(
name|void
parameter_list|)
block|{
name|db_expr_t
name|inst
decl_stmt|;
name|db_addr_t
name|pc
decl_stmt|,
name|brpc
decl_stmt|;
name|uint32_t
name|wcr
decl_stmt|;
name|u_int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|dbg_capable
argument_list|()
condition|)
return|return;
comment|/* 	 * Disable watchpoints, e.g. stepping over watched instruction will 	 * trigger break exception instead of single-step exception and locks 	 * CPU on that instruction for ever. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dbg_watchpoint_num
condition|;
name|i
operator|++
control|)
block|{
name|wcr
operator|=
name|dbg_wb_read_reg
argument_list|(
name|DBG_REG_BASE_WCR
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|wcr
operator|&
name|DBG_WB_CTRL_E
operator|)
operator|!=
literal|0
condition|)
block|{
name|dbg_wb_write_reg
argument_list|(
name|DBG_REG_BASE_WCR
argument_list|,
name|i
argument_list|,
operator|(
name|wcr
operator|&
operator|~
name|DBG_WB_CTRL_E
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|pc
operator|=
name|PC_REGS
argument_list|()
expr_stmt|;
name|inst
operator|=
name|db_get_value
argument_list|(
name|pc
argument_list|,
sizeof|sizeof
argument_list|(
name|pc
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|inst_branch
argument_list|(
name|inst
argument_list|)
operator|||
name|inst_call
argument_list|(
name|inst
argument_list|)
operator|||
name|inst_return
argument_list|(
name|inst
argument_list|)
condition|)
block|{
name|brpc
operator|=
name|branch_taken
argument_list|(
name|inst
argument_list|,
name|pc
argument_list|)
expr_stmt|;
name|dbg_setup_breakpoint
argument_list|(
name|brpc
argument_list|,
name|INSN_SIZE
argument_list|,
name|DBG_BKPT_BT_SLOT
argument_list|)
expr_stmt|;
block|}
name|pc
operator|=
name|next_instr_address
argument_list|(
name|pc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dbg_setup_breakpoint
argument_list|(
name|pc
argument_list|,
name|INSN_SIZE
argument_list|,
name|DBG_BKPT_BNT_SLOT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|kdb_cpu_clear_singlestep
parameter_list|(
name|void
parameter_list|)
block|{
name|uint32_t
name|wvr
decl_stmt|,
name|wcr
decl_stmt|;
name|u_int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|dbg_capable
argument_list|()
condition|)
return|return;
name|dbg_remove_breakpoint
argument_list|(
name|DBG_BKPT_BT_SLOT
argument_list|)
expr_stmt|;
name|dbg_remove_breakpoint
argument_list|(
name|DBG_BKPT_BNT_SLOT
argument_list|)
expr_stmt|;
comment|/* Restore all watchpoints */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dbg_watchpoint_num
condition|;
name|i
operator|++
control|)
block|{
name|wcr
operator|=
name|dbg_wb_read_reg
argument_list|(
name|DBG_REG_BASE_WCR
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|wvr
operator|=
name|dbg_wb_read_reg
argument_list|(
name|DBG_REG_BASE_WVR
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Watchpoint considered not empty if address value is not 0 */
if|if
condition|(
operator|(
name|wvr
operator|&
name|DBGWVR_ADDR_MASK
operator|)
operator|!=
literal|0
condition|)
block|{
name|dbg_wb_write_reg
argument_list|(
name|DBG_REG_BASE_WCR
argument_list|,
name|i
argument_list|,
operator|(
name|wcr
operator||
name|DBG_WB_CTRL_E
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|int
name|dbg_setup_watchpoint
parameter_list|(
name|db_expr_t
name|addr
parameter_list|,
name|db_expr_t
name|size
parameter_list|,
name|enum
name|dbg_access_t
name|access
parameter_list|)
block|{
name|struct
name|dbg_wb_conf
name|conf
decl_stmt|;
if|if
condition|(
name|access
operator|==
name|HW_BREAKPOINT_X
condition|)
block|{
name|db_printf
argument_list|(
literal|"Invalid access type for watchpoint: %d\n"
argument_list|,
name|access
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|conf
operator|.
name|address
operator|=
name|addr
expr_stmt|;
name|conf
operator|.
name|size
operator|=
name|size
expr_stmt|;
name|conf
operator|.
name|access
operator|=
name|access
expr_stmt|;
name|conf
operator|.
name|type
operator|=
name|DBG_TYPE_WATCHPOINT
expr_stmt|;
return|return
operator|(
name|dbg_setup_xpoint
argument_list|(
operator|&
name|conf
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dbg_remove_watchpoint
parameter_list|(
name|db_expr_t
name|addr
parameter_list|,
name|db_expr_t
name|size
name|__unused
parameter_list|)
block|{
name|struct
name|dbg_wb_conf
name|conf
decl_stmt|;
name|conf
operator|.
name|address
operator|=
name|addr
expr_stmt|;
name|conf
operator|.
name|type
operator|=
name|DBG_TYPE_WATCHPOINT
expr_stmt|;
return|return
operator|(
name|dbg_remove_xpoint
argument_list|(
operator|&
name|conf
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dbg_setup_breakpoint
parameter_list|(
name|db_expr_t
name|addr
parameter_list|,
name|db_expr_t
name|size
parameter_list|,
name|u_int
name|slot
parameter_list|)
block|{
name|struct
name|dbg_wb_conf
name|conf
decl_stmt|;
name|conf
operator|.
name|address
operator|=
name|addr
expr_stmt|;
name|conf
operator|.
name|size
operator|=
name|size
expr_stmt|;
name|conf
operator|.
name|access
operator|=
name|HW_BREAKPOINT_X
expr_stmt|;
name|conf
operator|.
name|type
operator|=
name|DBG_TYPE_BREAKPOINT
expr_stmt|;
name|conf
operator|.
name|slot
operator|=
name|slot
expr_stmt|;
return|return
operator|(
name|dbg_setup_xpoint
argument_list|(
operator|&
name|conf
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dbg_remove_breakpoint
parameter_list|(
name|u_int
name|slot
parameter_list|)
block|{
name|struct
name|dbg_wb_conf
name|conf
decl_stmt|;
comment|/* Slot already cleared. Don't recurse */
if|if
condition|(
name|dbg_check_slot_free
argument_list|(
name|DBG_TYPE_BREAKPOINT
argument_list|,
name|slot
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|conf
operator|.
name|slot
operator|=
name|slot
expr_stmt|;
name|conf
operator|.
name|type
operator|=
name|DBG_TYPE_BREAKPOINT
expr_stmt|;
return|return
operator|(
name|dbg_remove_xpoint
argument_list|(
operator|&
name|conf
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|dbg_watchtype_str
parameter_list|(
name|uint32_t
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|DBG_WB_CTRL_EXEC
case|:
return|return
operator|(
literal|"execute"
operator|)
return|;
case|case
name|DBG_WB_CTRL_STORE
case|:
return|return
operator|(
literal|"write"
operator|)
return|;
case|case
name|DBG_WB_CTRL_LOAD
case|:
return|return
operator|(
literal|"read"
operator|)
return|;
case|case
name|DBG_WB_CTRL_LOAD
operator||
name|DBG_WB_CTRL_STORE
case|:
return|return
operator|(
literal|"read/write"
operator|)
return|;
default|default:
return|return
operator|(
literal|"invalid"
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|dbg_watchtype_len
parameter_list|(
name|uint32_t
name|len
parameter_list|)
block|{
switch|switch
condition|(
name|len
condition|)
block|{
case|case
name|DBG_WB_CTRL_LEN_1
case|:
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|DBG_WB_CTRL_LEN_2
case|:
return|return
operator|(
literal|2
operator|)
return|;
case|case
name|DBG_WB_CTRL_LEN_4
case|:
return|return
operator|(
literal|4
operator|)
return|;
case|case
name|DBG_WB_CTRL_LEN_8
case|:
return|return
operator|(
literal|8
operator|)
return|;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_function
name|void
name|dbg_show_watchpoint
parameter_list|(
name|void
parameter_list|)
block|{
name|uint32_t
name|wcr
decl_stmt|,
name|len
decl_stmt|,
name|type
decl_stmt|;
name|uint32_t
name|addr
decl_stmt|;
name|boolean_t
name|is_enabled
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|dbg_capable
argument_list|()
condition|)
block|{
name|db_printf
argument_list|(
literal|"Architecture does not support HW "
literal|"breakpoints/watchpoints\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|db_printf
argument_list|(
literal|"\nhardware watchpoints:\n"
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"  watch    status        type  len     address              symbol\n"
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"  -----  --------  ----------  ---  ----------  ------------------\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dbg_watchpoint_num
condition|;
name|i
operator|++
control|)
block|{
name|wcr
operator|=
name|dbg_wb_read_reg
argument_list|(
name|DBG_REG_BASE_WCR
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|wcr
operator|&
name|DBG_WB_CTRL_E
operator|)
operator|!=
literal|0
condition|)
name|is_enabled
operator|=
name|TRUE
expr_stmt|;
else|else
name|is_enabled
operator|=
name|FALSE
expr_stmt|;
name|type
operator|=
name|DBG_WB_CTRL_ACCESS_MASK
argument_list|(
name|wcr
argument_list|)
expr_stmt|;
name|len
operator|=
name|DBG_WB_CTRL_LEN_MASK
argument_list|(
name|wcr
argument_list|)
expr_stmt|;
name|addr
operator|=
name|dbg_wb_read_reg
argument_list|(
name|DBG_REG_BASE_WVR
argument_list|,
name|i
argument_list|)
operator|&
name|DBGWVR_ADDR_MASK
expr_stmt|;
name|db_printf
argument_list|(
literal|"  %-5d  %-8s  %10s  %3d  0x%08x  "
argument_list|,
name|i
argument_list|,
name|is_enabled
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|,
name|is_enabled
condition|?
name|dbg_watchtype_str
argument_list|(
name|type
argument_list|)
else|:
literal|""
argument_list|,
name|is_enabled
condition|?
name|dbg_watchtype_len
argument_list|(
name|len
argument_list|)
else|:
literal|0
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|db_printsym
argument_list|(
operator|(
name|db_addr_t
operator|)
name|addr
argument_list|,
name|DB_STGY_ANY
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|boolean_t
name|dbg_check_slot_free
parameter_list|(
name|enum
name|dbg_t
name|type
parameter_list|,
name|u_int
name|slot
parameter_list|)
block|{
name|uint32_t
name|cr
decl_stmt|,
name|vr
decl_stmt|;
name|uint32_t
name|max
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|DBG_TYPE_BREAKPOINT
case|:
name|max
operator|=
name|dbg_breakpoint_num
expr_stmt|;
name|cr
operator|=
name|DBG_REG_BASE_BCR
expr_stmt|;
name|vr
operator|=
name|DBG_REG_BASE_BVR
expr_stmt|;
break|break;
case|case
name|DBG_TYPE_WATCHPOINT
case|:
name|max
operator|=
name|dbg_watchpoint_num
expr_stmt|;
name|cr
operator|=
name|DBG_REG_BASE_WCR
expr_stmt|;
name|vr
operator|=
name|DBG_REG_BASE_WVR
expr_stmt|;
break|break;
default|default:
name|db_printf
argument_list|(
literal|"%s: Unsupported event type %d\n"
argument_list|,
name|__func__
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
if|if
condition|(
name|slot
operator|>=
name|max
condition|)
block|{
name|db_printf
argument_list|(
literal|"%s: Invalid slot number %d, max %d\n"
argument_list|,
name|__func__
argument_list|,
name|slot
argument_list|,
name|max
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|dbg_wb_read_reg
argument_list|(
name|cr
argument_list|,
name|slot
argument_list|)
operator|&
name|DBG_WB_CTRL_E
operator|)
operator|==
literal|0
operator|&&
operator|(
name|dbg_wb_read_reg
argument_list|(
name|vr
argument_list|,
name|slot
argument_list|)
operator|&
name|DBGWVR_ADDR_MASK
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int
name|dbg_find_free_slot
parameter_list|(
name|enum
name|dbg_t
name|type
parameter_list|)
block|{
name|u_int
name|max
decl_stmt|,
name|i
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|DBG_TYPE_BREAKPOINT
case|:
name|max
operator|=
name|dbg_breakpoint_num
expr_stmt|;
break|break;
case|case
name|DBG_TYPE_WATCHPOINT
case|:
name|max
operator|=
name|dbg_watchpoint_num
expr_stmt|;
break|break;
default|default:
name|db_printf
argument_list|(
literal|"Unsupported debug type\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|~
literal|0U
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dbg_check_slot_free
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
return|return
operator|(
name|i
operator|)
return|;
block|}
return|return
operator|(
operator|~
literal|0U
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int
name|dbg_find_slot
parameter_list|(
name|enum
name|dbg_t
name|type
parameter_list|,
name|db_expr_t
name|addr
parameter_list|)
block|{
name|uint32_t
name|reg_addr
decl_stmt|,
name|reg_ctrl
decl_stmt|;
name|u_int
name|max
decl_stmt|,
name|i
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|DBG_TYPE_BREAKPOINT
case|:
name|max
operator|=
name|dbg_breakpoint_num
expr_stmt|;
name|reg_addr
operator|=
name|DBG_REG_BASE_BVR
expr_stmt|;
name|reg_ctrl
operator|=
name|DBG_REG_BASE_BCR
expr_stmt|;
break|break;
case|case
name|DBG_TYPE_WATCHPOINT
case|:
name|max
operator|=
name|dbg_watchpoint_num
expr_stmt|;
name|reg_addr
operator|=
name|DBG_REG_BASE_WVR
expr_stmt|;
name|reg_ctrl
operator|=
name|DBG_REG_BASE_WCR
expr_stmt|;
break|break;
default|default:
name|db_printf
argument_list|(
literal|"Unsupported debug type\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|~
literal|0U
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|dbg_wb_read_reg
argument_list|(
name|reg_addr
argument_list|,
name|i
argument_list|)
operator|==
name|addr
operator|)
operator|&&
operator|(
operator|(
name|dbg_wb_read_reg
argument_list|(
name|reg_ctrl
argument_list|,
name|i
argument_list|)
operator|&
name|DBG_WB_CTRL_E
operator|)
operator|!=
literal|0
operator|)
condition|)
return|return
operator|(
name|i
operator|)
return|;
block|}
return|return
operator|(
operator|~
literal|0U
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|boolean_t
name|dbg_monitor_is_enabled
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
operator|(
name|cp14_dbgdscrint_get
argument_list|()
operator|&
name|DBGSCR_MDBG_EN
operator|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dbg_enable_monitor
parameter_list|(
name|void
parameter_list|)
block|{
name|uint32_t
name|dbg_dscr
decl_stmt|;
comment|/* Already enabled? Just return */
if|if
condition|(
name|dbg_monitor_is_enabled
argument_list|()
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|dbg_dscr
operator|=
name|cp14_dbgdscrint_get
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|dbg_model
condition|)
block|{
case|case
name|ID_DFR0_CP_DEBUG_M_V6
case|:
case|case
name|ID_DFR0_CP_DEBUG_M_V6_1
case|:
comment|/* fall through */
name|cp14_dbgdscr_v6_set
argument_list|(
name|dbg_dscr
operator||
name|DBGSCR_MDBG_EN
argument_list|)
expr_stmt|;
break|break;
case|case
name|ID_DFR0_CP_DEBUG_M_V7
case|:
comment|/* fall through */
case|case
name|ID_DFR0_CP_DEBUG_M_V7_1
case|:
name|cp14_dbgdscr_v7_set
argument_list|(
name|dbg_dscr
operator||
name|DBGSCR_MDBG_EN
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|isb
argument_list|()
expr_stmt|;
comment|/* Verify that Monitor mode is set */
if|if
condition|(
name|dbg_monitor_is_enabled
argument_list|()
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dbg_setup_xpoint
parameter_list|(
name|struct
name|dbg_wb_conf
modifier|*
name|conf
parameter_list|)
block|{
name|struct
name|pcpu
modifier|*
name|pcpu
decl_stmt|;
name|struct
name|dbreg
modifier|*
name|d
decl_stmt|;
specifier|const
name|char
modifier|*
name|typestr
decl_stmt|;
name|uint32_t
name|cr_size
decl_stmt|,
name|cr_priv
decl_stmt|,
name|cr_access
decl_stmt|;
name|uint32_t
name|reg_ctrl
decl_stmt|,
name|reg_addr
decl_stmt|,
name|ctrl
decl_stmt|,
name|addr
decl_stmt|;
name|boolean_t
name|is_bkpt
decl_stmt|;
name|u_int
name|cpu
decl_stmt|;
name|u_int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|dbg_capable
argument_list|()
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|is_bkpt
operator|=
operator|(
name|conf
operator|->
name|type
operator|==
name|DBG_TYPE_BREAKPOINT
operator|)
expr_stmt|;
name|typestr
operator|=
name|is_bkpt
condition|?
literal|"breakpoint"
else|:
literal|"watchpoint"
expr_stmt|;
if|if
condition|(
name|is_bkpt
condition|)
block|{
if|if
condition|(
name|dbg_breakpoint_num
operator|==
literal|0
condition|)
block|{
name|db_printf
argument_list|(
literal|"Breakpoints not supported on this architecture\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|i
operator|=
name|conf
operator|->
name|slot
expr_stmt|;
if|if
condition|(
operator|!
name|dbg_check_slot_free
argument_list|(
name|DBG_TYPE_BREAKPOINT
argument_list|,
name|i
argument_list|)
condition|)
block|{
comment|/* 			 * This should never happen. If it does it means that 			 * there is an erroneus scenario somewhere. Still, it can 			 * be done but let's inform the user. 			 */
name|db_printf
argument_list|(
literal|"ERROR: Breakpoint already set. Replacing...\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|i
operator|=
name|dbg_find_free_slot
argument_list|(
name|DBG_TYPE_WATCHPOINT
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
operator|~
literal|0U
condition|)
block|{
name|db_printf
argument_list|(
literal|"Can not find slot for %s, max %d slots supported\n"
argument_list|,
name|typestr
argument_list|,
name|dbg_watchpoint_num
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
block|}
comment|/* Kernel access only */
name|cr_priv
operator|=
name|DBG_WB_CTRL_PL1
expr_stmt|;
switch|switch
condition|(
name|conf
operator|->
name|size
condition|)
block|{
case|case
literal|1
case|:
name|cr_size
operator|=
name|DBG_WB_CTRL_LEN_1
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|cr_size
operator|=
name|DBG_WB_CTRL_LEN_2
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|cr_size
operator|=
name|DBG_WB_CTRL_LEN_4
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|cr_size
operator|=
name|DBG_WB_CTRL_LEN_8
expr_stmt|;
break|break;
default|default:
name|db_printf
argument_list|(
literal|"Unsupported address size for %s\n"
argument_list|,
name|typestr
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|is_bkpt
condition|)
block|{
name|cr_access
operator|=
name|DBG_WB_CTRL_EXEC
expr_stmt|;
name|reg_ctrl
operator|=
name|DBG_REG_BASE_BCR
expr_stmt|;
name|reg_addr
operator|=
name|DBG_REG_BASE_BVR
expr_stmt|;
comment|/* Always unlinked BKPT */
name|ctrl
operator|=
operator|(
name|cr_size
operator||
name|cr_access
operator||
name|cr_priv
operator||
name|DBG_WB_CTRL_E
operator|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|conf
operator|->
name|access
condition|)
block|{
case|case
name|HW_WATCHPOINT_R
case|:
name|cr_access
operator|=
name|DBG_WB_CTRL_LOAD
expr_stmt|;
break|break;
case|case
name|HW_WATCHPOINT_W
case|:
name|cr_access
operator|=
name|DBG_WB_CTRL_STORE
expr_stmt|;
break|break;
case|case
name|HW_WATCHPOINT_RW
case|:
name|cr_access
operator|=
name|DBG_WB_CTRL_LOAD
operator||
name|DBG_WB_CTRL_STORE
expr_stmt|;
break|break;
default|default:
name|db_printf
argument_list|(
literal|"Unsupported exception level for %s\n"
argument_list|,
name|typestr
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|reg_ctrl
operator|=
name|DBG_REG_BASE_WCR
expr_stmt|;
name|reg_addr
operator|=
name|DBG_REG_BASE_WVR
expr_stmt|;
name|ctrl
operator|=
operator|(
name|cr_size
operator||
name|cr_access
operator||
name|cr_priv
operator||
name|DBG_WB_CTRL_E
operator|)
expr_stmt|;
block|}
name|addr
operator|=
name|conf
operator|->
name|address
expr_stmt|;
name|dbg_wb_write_reg
argument_list|(
name|reg_addr
argument_list|,
name|i
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|dbg_wb_write_reg
argument_list|(
name|reg_ctrl
argument_list|,
name|i
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
comment|/* 	 * Save watchpoint settings for all CPUs. 	 * We don't need to do the same with breakpoints since HW breakpoints 	 * are only used to perform single stepping. 	 */
if|if
condition|(
operator|!
name|is_bkpt
condition|)
block|{
name|CPU_FOREACH
argument_list|(
argument|cpu
argument_list|)
block|{
name|pcpu
operator|=
name|pcpu_find
argument_list|(
name|cpu
argument_list|)
expr_stmt|;
comment|/* Fill out the settings for watchpoint */
name|d
operator|=
operator|(
expr|struct
name|dbreg
operator|*
operator|)
name|pcpu
operator|->
name|pc_dbreg
expr_stmt|;
name|d
operator|->
name|dbg_wvr
index|[
name|i
index|]
operator|=
name|addr
expr_stmt|;
name|d
operator|->
name|dbg_wcr
index|[
name|i
index|]
operator|=
name|ctrl
expr_stmt|;
comment|/* Skip update command for the current CPU */
if|if
condition|(
name|cpu
operator|!=
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
condition|)
name|pcpu
operator|->
name|pc_dbreg_cmd
operator|=
name|PC_DBREG_CMD_LOAD
expr_stmt|;
block|}
block|}
comment|/* Ensure all data is written before waking other CPUs */
name|atomic_thread_fence_rel
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dbg_remove_xpoint
parameter_list|(
name|struct
name|dbg_wb_conf
modifier|*
name|conf
parameter_list|)
block|{
name|struct
name|pcpu
modifier|*
name|pcpu
decl_stmt|;
name|struct
name|dbreg
modifier|*
name|d
decl_stmt|;
name|uint32_t
name|reg_ctrl
decl_stmt|,
name|reg_addr
decl_stmt|,
name|addr
decl_stmt|;
name|boolean_t
name|is_bkpt
decl_stmt|;
name|u_int
name|cpu
decl_stmt|;
name|u_int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|dbg_capable
argument_list|()
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|is_bkpt
operator|=
operator|(
name|conf
operator|->
name|type
operator|==
name|DBG_TYPE_BREAKPOINT
operator|)
expr_stmt|;
name|addr
operator|=
name|conf
operator|->
name|address
expr_stmt|;
if|if
condition|(
name|is_bkpt
condition|)
block|{
name|i
operator|=
name|conf
operator|->
name|slot
expr_stmt|;
name|reg_ctrl
operator|=
name|DBG_REG_BASE_BCR
expr_stmt|;
name|reg_addr
operator|=
name|DBG_REG_BASE_BVR
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
name|dbg_find_slot
argument_list|(
name|DBG_TYPE_WATCHPOINT
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
operator|~
literal|0U
condition|)
block|{
name|db_printf
argument_list|(
literal|"Can not find watchpoint for address 0%x\n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|reg_ctrl
operator|=
name|DBG_REG_BASE_WCR
expr_stmt|;
name|reg_addr
operator|=
name|DBG_REG_BASE_WVR
expr_stmt|;
block|}
name|dbg_wb_write_reg
argument_list|(
name|reg_ctrl
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dbg_wb_write_reg
argument_list|(
name|reg_addr
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Save watchpoint settings for all CPUs. 	 * We don't need to do the same with breakpoints since HW breakpoints 	 * are only used to perform single stepping. 	 */
if|if
condition|(
operator|!
name|is_bkpt
condition|)
block|{
name|CPU_FOREACH
argument_list|(
argument|cpu
argument_list|)
block|{
name|pcpu
operator|=
name|pcpu_find
argument_list|(
name|cpu
argument_list|)
expr_stmt|;
comment|/* Fill out the settings for watchpoint */
name|d
operator|=
operator|(
expr|struct
name|dbreg
operator|*
operator|)
name|pcpu
operator|->
name|pc_dbreg
expr_stmt|;
name|d
operator|->
name|dbg_wvr
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|dbg_wcr
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Skip update command for the current CPU */
if|if
condition|(
name|cpu
operator|!=
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
condition|)
name|pcpu
operator|->
name|pc_dbreg_cmd
operator|=
name|PC_DBREG_CMD_LOAD
expr_stmt|;
block|}
comment|/* Ensure all data is written before waking other CPUs */
name|atomic_thread_fence_rel
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|uint32_t
name|dbg_get_debug_model
parameter_list|(
name|void
parameter_list|)
block|{
name|uint32_t
name|dbg_m
decl_stmt|;
name|dbg_m
operator|=
operator|(
operator|(
name|cpuinfo
operator|.
name|id_dfr0
operator|&
name|ID_DFR0_CP_DEBUG_M_MASK
operator|)
operator|>>
name|ID_DFR0_CP_DEBUG_M_SHIFT
operator|)
expr_stmt|;
return|return
operator|(
name|dbg_m
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|boolean_t
name|dbg_get_ossr
parameter_list|(
name|void
parameter_list|)
block|{
switch|switch
condition|(
name|dbg_model
condition|)
block|{
case|case
name|ID_DFR0_CP_DEBUG_M_V7
case|:
if|if
condition|(
operator|(
name|cp14_dbgoslsr_get
argument_list|()
operator|&
name|DBGOSLSR_OSLM0
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
return|return
operator|(
name|FALSE
operator|)
return|;
case|case
name|ID_DFR0_CP_DEBUG_M_V7_1
case|:
return|return
operator|(
name|TRUE
operator|)
return|;
default|default:
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|__inline
name|boolean_t
name|dbg_arch_supported
parameter_list|(
name|void
parameter_list|)
block|{
name|uint32_t
name|dbg_didr
decl_stmt|;
switch|switch
condition|(
name|dbg_model
condition|)
block|{
case|case
name|ID_DFR0_CP_DEBUG_M_V6
case|:
case|case
name|ID_DFR0_CP_DEBUG_M_V6_1
case|:
name|dbg_didr
operator|=
name|cp14_dbgdidr_get
argument_list|()
expr_stmt|;
comment|/* 		 * read-all-zeroes is used by QEMU 		 * to indicate that ARMv6 debug support 		 * is not implemented. Real hardware has at 		 * least version bits set 		 */
if|if
condition|(
name|dbg_didr
operator|==
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
return|return
operator|(
name|TRUE
operator|)
return|;
case|case
name|ID_DFR0_CP_DEBUG_M_V7
case|:
case|case
name|ID_DFR0_CP_DEBUG_M_V7_1
case|:
comment|/* fall through */
return|return
operator|(
name|TRUE
operator|)
return|;
default|default:
comment|/* We only support valid v6.x/v7.x modes through CP14 */
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|__inline
name|uint32_t
name|dbg_get_wrp_num
parameter_list|(
name|void
parameter_list|)
block|{
name|uint32_t
name|dbg_didr
decl_stmt|;
name|dbg_didr
operator|=
name|cp14_dbgdidr_get
argument_list|()
expr_stmt|;
return|return
operator|(
name|DBGDIDR_WRPS_NUM
argument_list|(
name|dbg_didr
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|uint32_t
name|dgb_get_brp_num
parameter_list|(
name|void
parameter_list|)
block|{
name|uint32_t
name|dbg_didr
decl_stmt|;
name|dbg_didr
operator|=
name|cp14_dbgdidr_get
argument_list|()
expr_stmt|;
return|return
operator|(
name|DBGDIDR_BRPS_NUM
argument_list|(
name|dbg_didr
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dbg_reset_state
parameter_list|(
name|void
parameter_list|)
block|{
name|u_int
name|cpuid
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|int
name|err
decl_stmt|;
name|cpuid
operator|=
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
expr_stmt|;
name|err
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|dbg_model
condition|)
block|{
case|case
name|ID_DFR0_CP_DEBUG_M_V6
case|:
case|case
name|ID_DFR0_CP_DEBUG_M_V6_1
case|:
comment|/* fall through */
comment|/* 		 * Arch needs monitor mode selected and enabled 		 * to be able to access breakpoint/watchpoint registers. 		 */
name|err
operator|=
name|dbg_enable_monitor
argument_list|()
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
goto|goto
name|vectr_clr
goto|;
case|case
name|ID_DFR0_CP_DEBUG_M_V7
case|:
comment|/* Is core power domain powered up? */
if|if
condition|(
operator|(
name|cp14_dbgprsr_get
argument_list|()
operator|&
name|DBGPRSR_PU
operator|)
operator|==
literal|0
condition|)
name|err
operator|=
name|ENXIO
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|dbg_ossr
condition|)
goto|goto
name|vectr_clr
goto|;
break|break;
case|case
name|ID_DFR0_CP_DEBUG_M_V7_1
case|:
comment|/* Is double lock set? */
if|if
condition|(
operator|(
name|cp14_dbgosdlr_get
argument_list|()
operator|&
name|DBGPRSR_DLK
operator|)
operator|!=
literal|0
condition|)
name|err
operator|=
name|ENXIO
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|db_printf
argument_list|(
literal|"Debug facility locked (CPU%d)\n"
argument_list|,
name|cpuid
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
comment|/* 	 * DBGOSLAR is always implemented for v7.1 Debug Arch. however is 	 * optional for v7 (depends on OS save and restore support). 	 */
if|if
condition|(
operator|(
operator|(
name|dbg_model
operator|&
name|ID_DFR0_CP_DEBUG_M_V7_1
operator|)
operator|!=
literal|0
operator|)
operator|||
name|dbg_ossr
condition|)
block|{
comment|/* 		 * Clear OS lock. 		 * Writing any other value than 0xC5ACCESS will unlock. 		 */
name|cp14_dbgoslar_set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|isb
argument_list|()
expr_stmt|;
block|}
name|vectr_clr
label|:
comment|/* 	 * After reset we must ensure that DBGVCR has a defined value. 	 * Disable all vector catch events. Safe to use - required in all 	 * implementations. 	 */
name|cp14_dbgvcr_set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|isb
argument_list|()
expr_stmt|;
comment|/* 	 * We have limited number of {watch,break}points, each consists of 	 * two registers: 	 * - wcr/bcr regsiter configurates corresponding {watch,break}point 	 *   behaviour 	 * - wvr/bvr register keeps address we are hunting for 	 * 	 * Reset all breakpoints and watchpoints. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dbg_watchpoint_num
condition|;
operator|++
name|i
control|)
block|{
name|dbg_wb_write_reg
argument_list|(
name|DBG_REG_BASE_WCR
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dbg_wb_write_reg
argument_list|(
name|DBG_REG_BASE_WVR
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dbg_breakpoint_num
condition|;
operator|++
name|i
control|)
block|{
name|dbg_wb_write_reg
argument_list|(
name|DBG_REG_BASE_BCR
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dbg_wb_write_reg
argument_list|(
name|DBG_REG_BASE_BVR
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dbg_monitor_init
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
comment|/* Fetch ARM Debug Architecture model */
name|dbg_model
operator|=
name|dbg_get_debug_model
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|dbg_arch_supported
argument_list|()
condition|)
block|{
name|db_printf
argument_list|(
literal|"ARM Debug Architecture not supported\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|bootverbose
condition|)
block|{
name|db_printf
argument_list|(
literal|"ARM Debug Architecture %s\n"
argument_list|,
operator|(
name|dbg_model
operator|==
name|ID_DFR0_CP_DEBUG_M_V6
operator|)
condition|?
literal|"v6"
else|:
operator|(
name|dbg_model
operator|==
name|ID_DFR0_CP_DEBUG_M_V6_1
operator|)
condition|?
literal|"v6.1"
else|:
operator|(
name|dbg_model
operator|==
name|ID_DFR0_CP_DEBUG_M_V7
operator|)
condition|?
literal|"v7"
else|:
operator|(
name|dbg_model
operator|==
name|ID_DFR0_CP_DEBUG_M_V7_1
operator|)
condition|?
literal|"v7.1"
else|:
literal|"unknown"
argument_list|)
expr_stmt|;
block|}
comment|/* Do we have OS Save and Restore mechanism? */
name|dbg_ossr
operator|=
name|dbg_get_ossr
argument_list|()
expr_stmt|;
comment|/* Find out many breakpoints and watchpoints we can use */
name|dbg_watchpoint_num
operator|=
name|dbg_get_wrp_num
argument_list|()
expr_stmt|;
name|dbg_breakpoint_num
operator|=
name|dgb_get_brp_num
argument_list|()
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|db_printf
argument_list|(
literal|"%d watchpoints and %d breakpoints supported\n"
argument_list|,
name|dbg_watchpoint_num
argument_list|,
name|dbg_breakpoint_num
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|dbg_reset_state
argument_list|()
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|err
operator|=
name|dbg_enable_monitor
argument_list|()
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|atomic_set_int
argument_list|(
operator|&
name|dbg_capable_var
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|db_printf
argument_list|(
literal|"HW Breakpoints/Watchpoints not enabled on CPU%d\n"
argument_list|,
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|CTASSERT
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|dbreg
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
operator|(
operator|(
expr|struct
name|pcpu
operator|*
operator|)
name|NULL
operator|)
operator|->
name|pc_dbreg
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|dbg_monitor_init_secondary
parameter_list|(
name|void
parameter_list|)
block|{
name|u_int
name|cpuid
decl_stmt|;
name|int
name|err
decl_stmt|;
comment|/* 	 * This flag is set on the primary CPU 	 * and its meaning is valid for other CPUs too. 	 */
if|if
condition|(
operator|!
name|dbg_capable
argument_list|()
condition|)
return|return;
name|cpuid
operator|=
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
expr_stmt|;
name|err
operator|=
name|dbg_reset_state
argument_list|()
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Something is very wrong. 		 * WPs/BPs will not work correctly on this CPU. 		 */
name|KASSERT
argument_list|(
literal|0
argument_list|,
operator|(
literal|"%s: Failed to reset Debug Architecture "
literal|"state on CPU%d"
operator|,
name|__func__
operator|,
name|cpuid
operator|)
argument_list|)
expr_stmt|;
comment|/* Disable HW debug capabilities for all CPUs */
name|atomic_set_int
argument_list|(
operator|&
name|dbg_capable_var
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|err
operator|=
name|dbg_enable_monitor
argument_list|()
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|KASSERT
argument_list|(
literal|0
argument_list|,
operator|(
literal|"%s: Failed to enable Debug Monitor"
literal|" on CPU%d"
operator|,
name|__func__
operator|,
name|cpuid
operator|)
argument_list|)
expr_stmt|;
name|atomic_set_int
argument_list|(
operator|&
name|dbg_capable_var
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|dbg_resume_dbreg
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|dbreg
modifier|*
name|d
decl_stmt|;
name|u_int
name|i
decl_stmt|;
comment|/* 	 * This flag is set on the primary CPU 	 * and its meaning is valid for other CPUs too. 	 */
if|if
condition|(
operator|!
name|dbg_capable
argument_list|()
condition|)
return|return;
name|atomic_thread_fence_acq
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|PCPU_GET
argument_list|(
name|dbreg_cmd
argument_list|)
condition|)
block|{
case|case
name|PC_DBREG_CMD_LOAD
case|:
name|d
operator|=
operator|(
expr|struct
name|dbreg
operator|*
operator|)
name|PCPU_PTR
argument_list|(
name|dbreg
argument_list|)
expr_stmt|;
comment|/* Restore watchpoints */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dbg_watchpoint_num
condition|;
name|i
operator|++
control|)
block|{
name|dbg_wb_write_reg
argument_list|(
name|DBG_REG_BASE_WVR
argument_list|,
name|i
argument_list|,
name|d
operator|->
name|dbg_wvr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|dbg_wb_write_reg
argument_list|(
name|DBG_REG_BASE_WCR
argument_list|,
name|i
argument_list|,
name|d
operator|->
name|dbg_wcr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|PCPU_SET
argument_list|(
name|dbreg_cmd
argument_list|,
name|PC_DBREG_CMD_NONE
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

end_unit

