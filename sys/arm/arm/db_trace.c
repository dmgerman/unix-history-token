begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: db_trace.c,v 1.8 2003/01/17 22:28:48 thorpej Exp $	*/
end_comment

begin_comment
comment|/*-  * Copyright (c) 2000, 2001 Ben Harris  * Copyright (c) 1996 Scott K. Stevens  *  * Mach Operating System  * Copyright (c) 1991,1990 Carnegie Mellon University  * All Rights Reserved.  *  * Permission to use, copy, modify and distribute this software and its  * documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *  * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"  * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR  * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *  * Carnegie Mellon requests users of this software to return to  *  *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *  * any improvements or extensions that they make and grant Carnegie the  * rights to redistribute these changes.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kdb.h>
end_include

begin_include
include|#
directive|include
file|<sys/stack.h>
end_include

begin_include
include|#
directive|include
file|<machine/armreg.h>
end_include

begin_include
include|#
directive|include
file|<machine/asm.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpufunc.h>
end_include

begin_include
include|#
directive|include
file|<machine/db_machdep.h>
end_include

begin_include
include|#
directive|include
file|<machine/pcb.h>
end_include

begin_include
include|#
directive|include
file|<machine/stack.h>
end_include

begin_include
include|#
directive|include
file|<machine/vmparam.h>
end_include

begin_include
include|#
directive|include
file|<ddb/ddb.h>
end_include

begin_include
include|#
directive|include
file|<ddb/db_access.h>
end_include

begin_include
include|#
directive|include
file|<ddb/db_sym.h>
end_include

begin_include
include|#
directive|include
file|<ddb/db_output.h>
end_include

begin_function
specifier|static
name|void
name|db_stack_trace_cmd
parameter_list|(
name|struct
name|unwind_state
modifier|*
name|state
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|db_expr_t
name|value
decl_stmt|;
name|db_expr_t
name|offset
decl_stmt|;
name|c_db_sym_t
name|sym
decl_stmt|;
name|u_int
name|reg
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|sep
decl_stmt|;
name|uint16_t
name|upd_mask
decl_stmt|;
name|bool
name|finished
decl_stmt|;
name|finished
operator|=
name|false
expr_stmt|;
while|while
condition|(
operator|!
name|finished
condition|)
block|{
name|finished
operator|=
name|unwind_stack_one
argument_list|(
name|state
argument_list|)
expr_stmt|;
comment|/* Print the frame details */
name|sym
operator|=
name|db_search_symbol
argument_list|(
name|state
operator|->
name|start_pc
argument_list|,
name|DB_STGY_ANY
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|==
name|C_DB_SYM_NULL
condition|)
block|{
name|value
operator|=
literal|0
expr_stmt|;
name|name
operator|=
literal|"(null)"
expr_stmt|;
block|}
else|else
name|db_symbol_values
argument_list|(
name|sym
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"%s() at "
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|db_printsym
argument_list|(
name|state
operator|->
name|start_pc
argument_list|,
name|DB_STGY_PROC
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"\t pc = 0x%08x  lr = 0x%08x ("
argument_list|,
name|state
operator|->
name|start_pc
argument_list|,
name|state
operator|->
name|registers
index|[
name|LR
index|]
argument_list|)
expr_stmt|;
name|db_printsym
argument_list|(
name|state
operator|->
name|registers
index|[
name|LR
index|]
argument_list|,
name|DB_STGY_PROC
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|")\n"
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"\t sp = 0x%08x  fp = 0x%08x"
argument_list|,
name|state
operator|->
name|registers
index|[
name|SP
index|]
argument_list|,
name|state
operator|->
name|registers
index|[
name|FP
index|]
argument_list|)
expr_stmt|;
comment|/* Don't print the registers we have already printed */
name|upd_mask
operator|=
name|state
operator|->
name|update_mask
operator|&
operator|~
operator|(
operator|(
literal|1
operator|<<
name|SP
operator|)
operator||
operator|(
literal|1
operator|<<
name|FP
operator|)
operator||
operator|(
literal|1
operator|<<
name|LR
operator|)
operator||
operator|(
literal|1
operator|<<
name|PC
operator|)
operator|)
expr_stmt|;
name|sep
operator|=
literal|"\n\t"
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|reg
operator|=
literal|0
init|;
name|upd_mask
operator|!=
literal|0
condition|;
name|upd_mask
operator|>>=
literal|1
operator|,
name|reg
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|upd_mask
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
name|db_printf
argument_list|(
literal|"%s%sr%d = 0x%08x"
argument_list|,
name|sep
argument_list|,
operator|(
name|reg
operator|<
literal|10
operator|)
condition|?
literal|" "
else|:
literal|""
argument_list|,
name|reg
argument_list|,
name|state
operator|->
name|registers
index|[
name|reg
index|]
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|2
condition|)
block|{
name|sep
operator|=
literal|"\n\t"
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|sep
operator|=
literal|" "
expr_stmt|;
block|}
block|}
name|db_printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|finished
condition|)
break|break;
comment|/* 		 * Stop if directed to do so, or if we've unwound back to the 		 * kernel entry point, or if the unwind function didn't change 		 * anything (to avoid getting stuck in this loop forever). 		 * If the latter happens, it's an indication that the unwind 		 * information is incorrect somehow for the function named in 		 * the last frame printed before you see the unwind failure 		 * message (maybe it needs a STOP_UNWINDING). 		 */
if|if
condition|(
name|state
operator|->
name|registers
index|[
name|PC
index|]
operator|<
name|VM_MIN_KERNEL_ADDRESS
condition|)
block|{
name|db_printf
argument_list|(
literal|"Unable to unwind into user mode\n"
argument_list|)
expr_stmt|;
name|finished
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|->
name|update_mask
operator|==
literal|0
condition|)
block|{
name|db_printf
argument_list|(
literal|"Unwind failure (no registers changed)\n"
argument_list|)
expr_stmt|;
name|finished
operator|=
name|true
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* XXX stubs */
end_comment

begin_function
name|void
name|db_md_list_watchpoints
parameter_list|()
block|{ }
end_function

begin_function
name|int
name|db_md_clr_watchpoint
parameter_list|(
name|db_expr_t
name|addr
parameter_list|,
name|db_expr_t
name|size
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|db_md_set_watchpoint
parameter_list|(
name|db_expr_t
name|addr
parameter_list|,
name|db_expr_t
name|size
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|db_trace_thread
parameter_list|(
name|struct
name|thread
modifier|*
name|thr
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|struct
name|unwind_state
name|state
decl_stmt|;
name|struct
name|pcb
modifier|*
name|ctx
decl_stmt|;
if|if
condition|(
name|thr
operator|!=
name|curthread
condition|)
block|{
name|ctx
operator|=
name|kdb_thr_ctx
argument_list|(
name|thr
argument_list|)
expr_stmt|;
name|state
operator|.
name|registers
index|[
name|FP
index|]
operator|=
name|ctx
operator|->
name|pcb_regs
operator|.
name|sf_r11
expr_stmt|;
name|state
operator|.
name|registers
index|[
name|SP
index|]
operator|=
name|ctx
operator|->
name|pcb_regs
operator|.
name|sf_sp
expr_stmt|;
name|state
operator|.
name|registers
index|[
name|LR
index|]
operator|=
name|ctx
operator|->
name|pcb_regs
operator|.
name|sf_lr
expr_stmt|;
name|state
operator|.
name|registers
index|[
name|PC
index|]
operator|=
name|ctx
operator|->
name|pcb_regs
operator|.
name|sf_pc
expr_stmt|;
name|db_stack_trace_cmd
argument_list|(
operator|&
name|state
argument_list|)
expr_stmt|;
block|}
else|else
name|db_trace_self
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|db_trace_self
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|unwind_state
name|state
decl_stmt|;
name|uint32_t
name|sp
decl_stmt|;
comment|/* Read the stack pointer */
asm|__asm __volatile("mov %0, sp" : "=&r" (sp));
name|state
operator|.
name|registers
index|[
name|FP
index|]
operator|=
operator|(
name|uint32_t
operator|)
name|__builtin_frame_address
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|state
operator|.
name|registers
index|[
name|SP
index|]
operator|=
name|sp
expr_stmt|;
name|state
operator|.
name|registers
index|[
name|LR
index|]
operator|=
operator|(
name|uint32_t
operator|)
name|__builtin_return_address
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|state
operator|.
name|registers
index|[
name|PC
index|]
operator|=
operator|(
name|uint32_t
operator|)
name|db_trace_self
expr_stmt|;
name|db_stack_trace_cmd
argument_list|(
operator|&
name|state
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

