begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: db_trace.c,v 1.8 2003/01/17 22:28:48 thorpej Exp $	*/
end_comment

begin_comment
comment|/*-  * Copyright (c) 2000, 2001 Ben Harris  * Copyright (c) 1996 Scott K. Stevens  *  * Mach Operating System  * Copyright (c) 1991,1990 Carnegie Mellon University  * All Rights Reserved.  *   * Permission to use, copy, modify and distribute this software and its  * documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *   * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"  * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR  * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *   * Carnegie Mellon requests users of this software to return to  *   *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *   * any improvements or extensions that they make and grant Carnegie the  * rights to redistribute these changes.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kdb.h>
end_include

begin_include
include|#
directive|include
file|<sys/stack.h>
end_include

begin_include
include|#
directive|include
file|<machine/armreg.h>
end_include

begin_include
include|#
directive|include
file|<machine/asm.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpufunc.h>
end_include

begin_include
include|#
directive|include
file|<machine/db_machdep.h>
end_include

begin_include
include|#
directive|include
file|<machine/pcb.h>
end_include

begin_include
include|#
directive|include
file|<machine/stack.h>
end_include

begin_include
include|#
directive|include
file|<machine/vmparam.h>
end_include

begin_include
include|#
directive|include
file|<ddb/ddb.h>
end_include

begin_include
include|#
directive|include
file|<ddb/db_access.h>
end_include

begin_include
include|#
directive|include
file|<ddb/db_sym.h>
end_include

begin_include
include|#
directive|include
file|<ddb/db_output.h>
end_include

begin_comment
comment|/*  * APCS stack frames are awkward beasts, so I don't think even trying to use  * a structure to represent them is a good idea.  *  * Here's the diagram from the APCS.  Increasing address is _up_ the page.  *   *          save code pointer       [fp]<- fp points to here  *          return link value       [fp, #-4]  *          return sp value         [fp, #-8]  *          return fp value         [fp, #-12]  *          [saved v7 value]  *          [saved v6 value]  *          [saved v5 value]  *          [saved v4 value]  *          [saved v3 value]  *          [saved v2 value]  *          [saved v1 value]  *          [saved a4 value]  *          [saved a3 value]  *          [saved a2 value]  *          [saved a1 value]  *  * The save code pointer points twelve bytes beyond the start of the   * code sequence (usually a single STM) that created the stack frame.    * We have to disassemble it if we want to know which of the optional   * fields are actually present.  */
end_comment

begin_function
specifier|static
name|void
name|db_stack_trace_cmd
parameter_list|(
name|db_expr_t
name|addr
parameter_list|,
name|db_expr_t
name|count
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|frame
decl_stmt|,
modifier|*
name|lastframe
decl_stmt|;
name|c_db_sym_t
name|sym
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|db_expr_t
name|value
decl_stmt|;
name|db_expr_t
name|offset
decl_stmt|;
name|boolean_t
name|kernel_only
init|=
name|TRUE
decl_stmt|;
name|int
name|scp_offset
decl_stmt|;
name|frame
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
name|addr
expr_stmt|;
name|lastframe
operator|=
name|NULL
expr_stmt|;
name|scp_offset
operator|=
operator|-
operator|(
name|get_pc_str_offset
argument_list|()
operator|>>
literal|2
operator|)
expr_stmt|;
while|while
condition|(
name|count
operator|--
operator|&&
name|frame
operator|!=
name|NULL
operator|&&
operator|!
name|db_pager_quit
condition|)
block|{
name|db_addr_t
name|scp
decl_stmt|;
name|u_int32_t
name|savecode
decl_stmt|;
name|int
name|r
decl_stmt|;
name|u_int32_t
modifier|*
name|rp
decl_stmt|;
specifier|const
name|char
modifier|*
name|sep
decl_stmt|;
comment|/* 		 * In theory, the SCP isn't guaranteed to be in the function 		 * that generated the stack frame.  We hope for the best. 		 */
name|scp
operator|=
name|frame
index|[
name|FR_SCP
index|]
expr_stmt|;
name|sym
operator|=
name|db_search_symbol
argument_list|(
name|scp
argument_list|,
name|DB_STGY_ANY
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|==
name|C_DB_SYM_NULL
condition|)
block|{
name|value
operator|=
literal|0
expr_stmt|;
name|name
operator|=
literal|"(null)"
expr_stmt|;
block|}
else|else
name|db_symbol_values
argument_list|(
name|sym
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"%s() at "
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|db_printsym
argument_list|(
name|scp
argument_list|,
name|DB_STGY_PROC
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__PROG26
name|db_printf
argument_list|(
literal|"scp=0x%08x rlv=0x%08x ("
argument_list|,
name|scp
argument_list|,
name|frame
index|[
name|FR_RLV
index|]
operator|&
name|R15_PC
argument_list|)
expr_stmt|;
name|db_printsym
argument_list|(
name|frame
index|[
name|FR_RLV
index|]
operator|&
name|R15_PC
argument_list|,
name|DB_STGY_PROC
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|")\n"
argument_list|)
expr_stmt|;
else|#
directive|else
name|db_printf
argument_list|(
literal|"scp=0x%08x rlv=0x%08x ("
argument_list|,
name|scp
argument_list|,
name|frame
index|[
name|FR_RLV
index|]
argument_list|)
expr_stmt|;
name|db_printsym
argument_list|(
name|frame
index|[
name|FR_RLV
index|]
argument_list|,
name|DB_STGY_PROC
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|")\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|db_printf
argument_list|(
literal|"\trsp=0x%08x rfp=0x%08x"
argument_list|,
name|frame
index|[
name|FR_RSP
index|]
argument_list|,
name|frame
index|[
name|FR_RFP
index|]
argument_list|)
expr_stmt|;
name|savecode
operator|=
operator|(
operator|(
name|u_int32_t
operator|*
operator|)
name|scp
operator|)
index|[
name|scp_offset
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|savecode
operator|&
literal|0x0e100000
operator|)
operator|==
literal|0x08000000
condition|)
block|{
comment|/* Looks like an STM */
name|rp
operator|=
name|frame
operator|-
literal|4
expr_stmt|;
name|sep
operator|=
literal|"\n\t"
expr_stmt|;
for|for
control|(
name|r
operator|=
literal|10
init|;
name|r
operator|>=
literal|0
condition|;
name|r
operator|--
control|)
block|{
if|if
condition|(
name|savecode
operator|&
operator|(
literal|1
operator|<<
name|r
operator|)
condition|)
block|{
name|db_printf
argument_list|(
literal|"%sr%d=0x%08x"
argument_list|,
name|sep
argument_list|,
name|r
argument_list|,
operator|*
name|rp
operator|--
argument_list|)
expr_stmt|;
name|sep
operator|=
operator|(
name|frame
operator|-
name|rp
operator|)
operator|%
literal|4
operator|==
literal|2
condition|?
literal|"\n\t"
else|:
literal|" "
expr_stmt|;
block|}
block|}
block|}
name|db_printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* 		 * Switch to next frame up 		 */
if|if
condition|(
name|frame
index|[
name|FR_RFP
index|]
operator|==
literal|0
condition|)
break|break;
comment|/* Top of stack */
name|lastframe
operator|=
name|frame
expr_stmt|;
name|frame
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
operator|(
name|frame
index|[
name|FR_RFP
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|INKERNEL
argument_list|(
operator|(
name|int
operator|)
name|frame
argument_list|)
condition|)
block|{
comment|/* staying in kernel */
if|if
condition|(
name|frame
operator|<=
name|lastframe
condition|)
block|{
name|db_printf
argument_list|(
literal|"Bad frame pointer: %p\n"
argument_list|,
name|frame
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|INKERNEL
argument_list|(
operator|(
name|int
operator|)
name|lastframe
argument_list|)
condition|)
block|{
comment|/* switch from user to kernel */
if|if
condition|(
name|kernel_only
condition|)
break|break;
comment|/* kernel stack only */
block|}
else|else
block|{
comment|/* in user */
if|if
condition|(
name|frame
operator|<=
name|lastframe
condition|)
block|{
name|db_printf
argument_list|(
literal|"Bad user frame pointer: %p\n"
argument_list|,
name|frame
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* XXX stubs */
end_comment

begin_function
name|void
name|db_md_list_watchpoints
parameter_list|()
block|{ }
end_function

begin_function
name|int
name|db_md_clr_watchpoint
parameter_list|(
name|db_expr_t
name|addr
parameter_list|,
name|db_expr_t
name|size
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|db_md_set_watchpoint
parameter_list|(
name|db_expr_t
name|addr
parameter_list|,
name|db_expr_t
name|size
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|db_trace_thread
parameter_list|(
name|struct
name|thread
modifier|*
name|thr
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|uint32_t
name|addr
decl_stmt|;
if|if
condition|(
name|thr
operator|==
name|curthread
condition|)
name|addr
operator|=
operator|(
name|uint32_t
operator|)
name|__builtin_frame_address
argument_list|(
literal|0
argument_list|)
expr_stmt|;
else|else
name|addr
operator|=
name|thr
operator|->
name|td_pcb
operator|->
name|un_32
operator|.
name|pcb32_r11
expr_stmt|;
name|db_stack_trace_cmd
argument_list|(
name|addr
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|db_trace_self
parameter_list|(
name|void
parameter_list|)
block|{
name|db_addr_t
name|addr
decl_stmt|;
name|addr
operator|=
operator|(
name|db_addr_t
operator|)
name|__builtin_frame_address
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|db_stack_trace_cmd
argument_list|(
name|addr
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

