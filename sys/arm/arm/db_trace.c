begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: db_trace.c,v 1.8 2003/01/17 22:28:48 thorpej Exp $	*/
end_comment

begin_comment
comment|/*-  * Copyright (c) 2000, 2001 Ben Harris  * Copyright (c) 1996 Scott K. Stevens  *  * Mach Operating System  * Copyright (c) 1991,1990 Carnegie Mellon University  * All Rights Reserved.  *  * Permission to use, copy, modify and distribute this software and its  * documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *  * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"  * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR  * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *  * Carnegie Mellon requests users of this software to return to  *  *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *  * any improvements or extensions that they make and grant Carnegie the  * rights to redistribute these changes.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kdb.h>
end_include

begin_include
include|#
directive|include
file|<sys/stack.h>
end_include

begin_include
include|#
directive|include
file|<machine/armreg.h>
end_include

begin_include
include|#
directive|include
file|<machine/asm.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpufunc.h>
end_include

begin_include
include|#
directive|include
file|<machine/db_machdep.h>
end_include

begin_include
include|#
directive|include
file|<machine/pcb.h>
end_include

begin_include
include|#
directive|include
file|<machine/stack.h>
end_include

begin_include
include|#
directive|include
file|<machine/vmparam.h>
end_include

begin_include
include|#
directive|include
file|<ddb/ddb.h>
end_include

begin_include
include|#
directive|include
file|<ddb/db_access.h>
end_include

begin_include
include|#
directive|include
file|<ddb/db_sym.h>
end_include

begin_include
include|#
directive|include
file|<ddb/db_output.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__ARM_EABI__
end_ifdef

begin_comment
comment|/*  * Definitions for the instruction interpreter.  *  * The ARM EABI specifies how to perform the frame unwinding in the  * Exception Handling ABI for the ARM Architecture document. To perform  * the unwind we need to know the initial frame pointer, stack pointer,  * link register and program counter. We then find the entry within the  * index table that points to the function the program counter is within.  * This gives us either a list of three instructions to process, a 31-bit  * relative offset to a table of instructions, or a value telling us  * we can't unwind any further.  *  * When we have the instructions to process we need to decode them  * following table 4 in section 9.3. This describes a collection of bit  * patterns to encode that steps to take to update the stack pointer and  * link register to the correct values at the start of the function.  */
end_comment

begin_comment
comment|/* A special case when we are unable to unwind past this function */
end_comment

begin_define
define|#
directive|define
name|EXIDX_CANTUNWIND
value|1
end_define

begin_comment
comment|/* The register names */
end_comment

begin_define
define|#
directive|define
name|FP
value|11
end_define

begin_define
define|#
directive|define
name|SP
value|13
end_define

begin_define
define|#
directive|define
name|LR
value|14
end_define

begin_define
define|#
directive|define
name|PC
value|15
end_define

begin_comment
comment|/*  * These are set in the linker script. Their addresses will be  * either the start or end of the exception table or index.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|extab_start
decl_stmt|,
name|extab_end
decl_stmt|,
name|exidx_start
decl_stmt|,
name|exidx_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Entry types.  * These are the only entry types that have been seen in the kernel.  */
end_comment

begin_define
define|#
directive|define
name|ENTRY_MASK
value|0xff000000
end_define

begin_define
define|#
directive|define
name|ENTRY_ARM_SU16
value|0x80000000
end_define

begin_define
define|#
directive|define
name|ENTRY_ARM_LU16
value|0x81000000
end_define

begin_comment
comment|/* Instruction masks. */
end_comment

begin_define
define|#
directive|define
name|INSN_VSP_MASK
value|0xc0
end_define

begin_define
define|#
directive|define
name|INSN_VSP_SIZE_MASK
value|0x3f
end_define

begin_define
define|#
directive|define
name|INSN_STD_MASK
value|0xf0
end_define

begin_define
define|#
directive|define
name|INSN_STD_DATA_MASK
value|0x0f
end_define

begin_define
define|#
directive|define
name|INSN_POP_TYPE_MASK
value|0x08
end_define

begin_define
define|#
directive|define
name|INSN_POP_COUNT_MASK
value|0x07
end_define

begin_define
define|#
directive|define
name|INSN_VSP_LARGE_INC_MASK
value|0xff
end_define

begin_comment
comment|/* Instruction definitions */
end_comment

begin_define
define|#
directive|define
name|INSN_VSP_INC
value|0x00
end_define

begin_define
define|#
directive|define
name|INSN_VSP_DEC
value|0x40
end_define

begin_define
define|#
directive|define
name|INSN_POP_MASKED
value|0x80
end_define

begin_define
define|#
directive|define
name|INSN_VSP_REG
value|0x90
end_define

begin_define
define|#
directive|define
name|INSN_POP_COUNT
value|0xa0
end_define

begin_define
define|#
directive|define
name|INSN_FINISH
value|0xb0
end_define

begin_define
define|#
directive|define
name|INSN_POP_REGS
value|0xb1
end_define

begin_define
define|#
directive|define
name|INSN_VSP_LARGE_INC
value|0xb2
end_define

begin_comment
comment|/* An item in the exception index table */
end_comment

begin_struct
struct|struct
name|unwind_idx
block|{
name|uint32_t
name|offset
decl_stmt|;
name|uint32_t
name|insn
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The state of the unwind process */
end_comment

begin_struct
struct|struct
name|unwind_state
block|{
name|uint32_t
name|registers
index|[
literal|16
index|]
decl_stmt|;
name|uint32_t
name|start_pc
decl_stmt|;
name|uint32_t
modifier|*
name|insn
decl_stmt|;
name|u_int
name|entries
decl_stmt|;
name|u_int
name|byte
decl_stmt|;
name|uint16_t
name|update_mask
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Expand a 31-bit signed value to a 32-bit signed value */
end_comment

begin_function
specifier|static
name|__inline
name|int32_t
name|db_expand_prel31
parameter_list|(
name|uint32_t
name|prel31
parameter_list|)
block|{
return|return
operator|(
call|(
name|int32_t
call|)
argument_list|(
name|prel31
operator|&
literal|0x7fffffffu
argument_list|)
operator|<<
literal|1
operator|)
operator|/
literal|2
return|;
block|}
end_function

begin_comment
comment|/*  * Perform a binary search of the index table to find the function  * with the largest address that doesn't exceed addr.  */
end_comment

begin_function
specifier|static
name|struct
name|unwind_idx
modifier|*
name|db_find_index
parameter_list|(
name|uint32_t
name|addr
parameter_list|)
block|{
name|unsigned
name|int
name|min
decl_stmt|,
name|mid
decl_stmt|,
name|max
decl_stmt|;
name|struct
name|unwind_idx
modifier|*
name|start
decl_stmt|;
name|struct
name|unwind_idx
modifier|*
name|item
decl_stmt|;
name|int32_t
name|prel31_addr
decl_stmt|;
name|uint32_t
name|func_addr
decl_stmt|;
name|start
operator|=
operator|(
expr|struct
name|unwind_idx
operator|*
operator|)
operator|&
name|exidx_start
expr_stmt|;
name|min
operator|=
literal|0
expr_stmt|;
name|max
operator|=
operator|(
operator|&
name|exidx_end
operator|-
operator|&
name|exidx_start
operator|)
operator|/
literal|2
expr_stmt|;
while|while
condition|(
name|min
operator|!=
name|max
condition|)
block|{
name|mid
operator|=
name|min
operator|+
operator|(
name|max
operator|-
name|min
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
name|item
operator|=
operator|&
name|start
index|[
name|mid
index|]
expr_stmt|;
name|prel31_addr
operator|=
name|db_expand_prel31
argument_list|(
name|item
operator|->
name|offset
argument_list|)
expr_stmt|;
name|func_addr
operator|=
operator|(
name|uint32_t
operator|)
operator|&
name|item
operator|->
name|offset
operator|+
name|prel31_addr
expr_stmt|;
if|if
condition|(
name|func_addr
operator|<=
name|addr
condition|)
block|{
name|min
operator|=
name|mid
expr_stmt|;
block|}
else|else
block|{
name|max
operator|=
name|mid
operator|-
literal|1
expr_stmt|;
block|}
block|}
return|return
operator|&
name|start
index|[
name|min
index|]
return|;
block|}
end_function

begin_comment
comment|/* Reads the next byte from the instruction list */
end_comment

begin_function
specifier|static
name|uint8_t
name|db_unwind_exec_read_byte
parameter_list|(
name|struct
name|unwind_state
modifier|*
name|state
parameter_list|)
block|{
name|uint8_t
name|insn
decl_stmt|;
comment|/* Read the unwind instruction */
name|insn
operator|=
operator|(
operator|*
name|state
operator|->
name|insn
operator|)
operator|>>
operator|(
name|state
operator|->
name|byte
operator|*
literal|8
operator|)
expr_stmt|;
comment|/* Update the location of the next instruction */
if|if
condition|(
name|state
operator|->
name|byte
operator|==
literal|0
condition|)
block|{
name|state
operator|->
name|byte
operator|=
literal|3
expr_stmt|;
name|state
operator|->
name|insn
operator|++
expr_stmt|;
name|state
operator|->
name|entries
operator|--
expr_stmt|;
block|}
else|else
name|state
operator|->
name|byte
operator|--
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Executes the next instruction on the list */
end_comment

begin_function
specifier|static
name|int
name|db_unwind_exec_insn
parameter_list|(
name|struct
name|unwind_state
modifier|*
name|state
parameter_list|)
block|{
name|unsigned
name|int
name|insn
decl_stmt|;
name|uint32_t
modifier|*
name|vsp
init|=
operator|(
name|uint32_t
operator|*
operator|)
name|state
operator|->
name|registers
index|[
name|SP
index|]
decl_stmt|;
name|int
name|update_vsp
init|=
literal|0
decl_stmt|;
comment|/* This should never happen */
if|if
condition|(
name|state
operator|->
name|entries
operator|==
literal|0
condition|)
return|return
literal|1
return|;
comment|/* Read the next instruction */
name|insn
operator|=
name|db_unwind_exec_read_byte
argument_list|(
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|insn
operator|&
name|INSN_VSP_MASK
operator|)
operator|==
name|INSN_VSP_INC
condition|)
block|{
name|state
operator|->
name|registers
index|[
name|SP
index|]
operator|+=
operator|(
operator|(
name|insn
operator|&
name|INSN_VSP_SIZE_MASK
operator|)
operator|<<
literal|2
operator|)
operator|+
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
name|INSN_VSP_MASK
operator|)
operator|==
name|INSN_VSP_DEC
condition|)
block|{
name|state
operator|->
name|registers
index|[
name|SP
index|]
operator|-=
operator|(
operator|(
name|insn
operator|&
name|INSN_VSP_SIZE_MASK
operator|)
operator|<<
literal|2
operator|)
operator|+
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
name|INSN_STD_MASK
operator|)
operator|==
name|INSN_POP_MASKED
condition|)
block|{
name|unsigned
name|int
name|mask
decl_stmt|,
name|reg
decl_stmt|;
comment|/* Load the mask */
name|mask
operator|=
name|db_unwind_exec_read_byte
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|mask
operator||=
operator|(
name|insn
operator|&
name|INSN_STD_DATA_MASK
operator|)
operator|<<
literal|8
expr_stmt|;
comment|/* We have a refuse to unwind instruction */
if|if
condition|(
name|mask
operator|==
literal|0
condition|)
return|return
literal|1
return|;
comment|/* Update SP */
name|update_vsp
operator|=
literal|1
expr_stmt|;
comment|/* Load the registers */
for|for
control|(
name|reg
operator|=
literal|4
init|;
name|mask
operator|&&
name|reg
operator|<
literal|16
condition|;
name|mask
operator|>>=
literal|1
operator|,
name|reg
operator|++
control|)
block|{
if|if
condition|(
name|mask
operator|&
literal|1
condition|)
block|{
name|state
operator|->
name|registers
index|[
name|reg
index|]
operator|=
operator|*
name|vsp
operator|++
expr_stmt|;
name|state
operator|->
name|update_mask
operator||=
literal|1
operator|<<
name|reg
expr_stmt|;
comment|/* If we have updated SP kep its value */
if|if
condition|(
name|reg
operator|==
name|SP
condition|)
name|update_vsp
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
name|INSN_STD_MASK
operator|)
operator|==
name|INSN_VSP_REG
operator|&&
operator|(
operator|(
name|insn
operator|&
name|INSN_STD_DATA_MASK
operator|)
operator|!=
literal|13
operator|)
operator|&&
operator|(
operator|(
name|insn
operator|&
name|INSN_STD_DATA_MASK
operator|)
operator|!=
literal|15
operator|)
condition|)
block|{
comment|/* sp = register */
name|state
operator|->
name|registers
index|[
name|SP
index|]
operator|=
name|state
operator|->
name|registers
index|[
name|insn
operator|&
name|INSN_STD_DATA_MASK
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
name|INSN_STD_MASK
operator|)
operator|==
name|INSN_POP_COUNT
condition|)
block|{
name|unsigned
name|int
name|count
decl_stmt|,
name|reg
decl_stmt|;
comment|/* Read how many registers to load */
name|count
operator|=
name|insn
operator|&
name|INSN_POP_COUNT_MASK
expr_stmt|;
comment|/* Update sp */
name|update_vsp
operator|=
literal|1
expr_stmt|;
comment|/* Pop the registers */
for|for
control|(
name|reg
operator|=
literal|4
init|;
name|reg
operator|<=
literal|4
operator|+
name|count
condition|;
name|reg
operator|++
control|)
block|{
name|state
operator|->
name|registers
index|[
name|reg
index|]
operator|=
operator|*
name|vsp
operator|++
expr_stmt|;
name|state
operator|->
name|update_mask
operator||=
literal|1
operator|<<
name|reg
expr_stmt|;
block|}
comment|/* Check if we are in the pop r14 version */
if|if
condition|(
operator|(
name|insn
operator|&
name|INSN_POP_TYPE_MASK
operator|)
operator|!=
literal|0
condition|)
block|{
name|state
operator|->
name|registers
index|[
literal|14
index|]
operator|=
operator|*
name|vsp
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|insn
operator|==
name|INSN_FINISH
condition|)
block|{
comment|/* Stop processing */
name|state
operator|->
name|entries
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|insn
operator|==
name|INSN_POP_REGS
condition|)
block|{
name|unsigned
name|int
name|mask
decl_stmt|,
name|reg
decl_stmt|;
name|mask
operator|=
name|db_unwind_exec_read_byte
argument_list|(
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|==
literal|0
operator|||
operator|(
name|mask
operator|&
literal|0xf0
operator|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
comment|/* Update SP */
name|update_vsp
operator|=
literal|1
expr_stmt|;
comment|/* Load the registers */
for|for
control|(
name|reg
operator|=
literal|0
init|;
name|mask
operator|&&
name|reg
operator|<
literal|4
condition|;
name|mask
operator|>>=
literal|1
operator|,
name|reg
operator|++
control|)
block|{
if|if
condition|(
name|mask
operator|&
literal|1
condition|)
block|{
name|state
operator|->
name|registers
index|[
name|reg
index|]
operator|=
operator|*
name|vsp
operator|++
expr_stmt|;
name|state
operator|->
name|update_mask
operator||=
literal|1
operator|<<
name|reg
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
name|INSN_VSP_LARGE_INC_MASK
operator|)
operator|==
name|INSN_VSP_LARGE_INC
condition|)
block|{
name|unsigned
name|int
name|uleb128
decl_stmt|;
comment|/* Read the increment value */
name|uleb128
operator|=
name|db_unwind_exec_read_byte
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|state
operator|->
name|registers
index|[
name|SP
index|]
operator|+=
literal|0x204
operator|+
operator|(
name|uleb128
operator|<<
literal|2
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We hit a new instruction that needs to be implemented */
name|db_printf
argument_list|(
literal|"Unhandled instruction %.2x\n"
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|update_vsp
condition|)
block|{
name|state
operator|->
name|registers
index|[
name|SP
index|]
operator|=
operator|(
name|uint32_t
operator|)
name|vsp
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|db_printf("fp = %08x, sp = %08x, lr = %08x, pc = %08x\n", 	    state->registers[FP], state->registers[SP], state->registers[LR], 	    state->registers[PC]);
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Performs the unwind of a function */
end_comment

begin_function
specifier|static
name|int
name|db_unwind_tab
parameter_list|(
name|struct
name|unwind_state
modifier|*
name|state
parameter_list|)
block|{
name|uint32_t
name|entry
decl_stmt|;
comment|/* Set PC to a known value */
name|state
operator|->
name|registers
index|[
name|PC
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Read the personality */
name|entry
operator|=
operator|*
name|state
operator|->
name|insn
operator|&
name|ENTRY_MASK
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|ENTRY_ARM_SU16
condition|)
block|{
name|state
operator|->
name|byte
operator|=
literal|2
expr_stmt|;
name|state
operator|->
name|entries
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|entry
operator|==
name|ENTRY_ARM_LU16
condition|)
block|{
name|state
operator|->
name|byte
operator|=
literal|1
expr_stmt|;
name|state
operator|->
name|entries
operator|=
operator|(
operator|(
operator|*
name|state
operator|->
name|insn
operator|>>
literal|16
operator|)
operator|&
literal|0xFF
operator|)
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|db_printf
argument_list|(
literal|"Unknown entry: %x\n"
argument_list|,
name|entry
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
while|while
condition|(
name|state
operator|->
name|entries
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|db_unwind_exec_insn
argument_list|(
name|state
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
block|}
comment|/* 	 * The program counter was not updated, load it from the link register. 	 */
if|if
condition|(
name|state
operator|->
name|registers
index|[
name|PC
index|]
operator|==
literal|0
condition|)
name|state
operator|->
name|registers
index|[
name|PC
index|]
operator|=
name|state
operator|->
name|registers
index|[
name|LR
index|]
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|db_stack_trace_cmd
parameter_list|(
name|struct
name|unwind_state
modifier|*
name|state
parameter_list|)
block|{
name|struct
name|unwind_idx
modifier|*
name|index
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|db_expr_t
name|value
decl_stmt|;
name|db_expr_t
name|offset
decl_stmt|;
name|c_db_sym_t
name|sym
decl_stmt|;
name|u_int
name|reg
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|sep
decl_stmt|;
name|uint16_t
name|upd_mask
decl_stmt|;
name|bool
name|finished
decl_stmt|;
name|finished
operator|=
name|false
expr_stmt|;
while|while
condition|(
operator|!
name|finished
condition|)
block|{
comment|/* Reset the mask of updated registers */
name|state
operator|->
name|update_mask
operator|=
literal|0
expr_stmt|;
comment|/* The pc value is correct and will be overwritten, save it */
name|state
operator|->
name|start_pc
operator|=
name|state
operator|->
name|registers
index|[
name|PC
index|]
expr_stmt|;
comment|/* Find the item to run */
name|index
operator|=
name|db_find_index
argument_list|(
name|state
operator|->
name|start_pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|->
name|insn
operator|!=
name|EXIDX_CANTUNWIND
condition|)
block|{
if|if
condition|(
name|index
operator|->
name|insn
operator|&
operator|(
literal|1U
operator|<<
literal|31
operator|)
condition|)
block|{
comment|/* The data is within the instruction */
name|state
operator|->
name|insn
operator|=
operator|&
name|index
operator|->
name|insn
expr_stmt|;
block|}
else|else
block|{
comment|/* A prel31 offset to the unwind table */
name|state
operator|->
name|insn
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
operator|&
name|index
operator|->
name|insn
operator|+
name|db_expand_prel31
argument_list|(
name|index
operator|->
name|insn
argument_list|)
operator|)
expr_stmt|;
block|}
comment|/* Run the unwind function */
name|finished
operator|=
name|db_unwind_tab
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
comment|/* Print the frame details */
name|sym
operator|=
name|db_search_symbol
argument_list|(
name|state
operator|->
name|start_pc
argument_list|,
name|DB_STGY_ANY
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|==
name|C_DB_SYM_NULL
condition|)
block|{
name|value
operator|=
literal|0
expr_stmt|;
name|name
operator|=
literal|"(null)"
expr_stmt|;
block|}
else|else
name|db_symbol_values
argument_list|(
name|sym
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"%s() at "
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|db_printsym
argument_list|(
name|state
operator|->
name|start_pc
argument_list|,
name|DB_STGY_PROC
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"\t pc = 0x%08x  lr = 0x%08x ("
argument_list|,
name|state
operator|->
name|start_pc
argument_list|,
name|state
operator|->
name|registers
index|[
name|LR
index|]
argument_list|)
expr_stmt|;
name|db_printsym
argument_list|(
name|state
operator|->
name|registers
index|[
name|LR
index|]
argument_list|,
name|DB_STGY_PROC
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|")\n"
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"\t sp = 0x%08x  fp = 0x%08x"
argument_list|,
name|state
operator|->
name|registers
index|[
name|SP
index|]
argument_list|,
name|state
operator|->
name|registers
index|[
name|FP
index|]
argument_list|)
expr_stmt|;
comment|/* Don't print the registers we have already printed */
name|upd_mask
operator|=
name|state
operator|->
name|update_mask
operator|&
operator|~
operator|(
operator|(
literal|1
operator|<<
name|SP
operator|)
operator||
operator|(
literal|1
operator|<<
name|FP
operator|)
operator||
operator|(
literal|1
operator|<<
name|LR
operator|)
operator||
operator|(
literal|1
operator|<<
name|PC
operator|)
operator|)
expr_stmt|;
name|sep
operator|=
literal|"\n\t"
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|reg
operator|=
literal|0
init|;
name|upd_mask
operator|!=
literal|0
condition|;
name|upd_mask
operator|>>=
literal|1
operator|,
name|reg
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|upd_mask
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
name|db_printf
argument_list|(
literal|"%s%sr%d = 0x%08x"
argument_list|,
name|sep
argument_list|,
operator|(
name|reg
operator|<
literal|10
operator|)
condition|?
literal|" "
else|:
literal|""
argument_list|,
name|reg
argument_list|,
name|state
operator|->
name|registers
index|[
name|reg
index|]
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|2
condition|)
block|{
name|sep
operator|=
literal|"\n\t"
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|sep
operator|=
literal|" "
expr_stmt|;
block|}
block|}
name|db_printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* 		 * Stop if directed to do so, or if we've unwound back to the 		 * kernel entry point, or if the unwind function didn't change 		 * anything (to avoid getting stuck in this loop forever). 		 * If the latter happens, it's an indication that the unwind 		 * information is incorrect somehow for the function named in 		 * the last frame printed before you see the unwind failure 		 * message (maybe it needs a STOP_UNWINDING). 		 */
if|if
condition|(
name|index
operator|->
name|insn
operator|==
name|EXIDX_CANTUNWIND
condition|)
block|{
name|finished
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|->
name|registers
index|[
name|PC
index|]
operator|<
name|VM_MIN_KERNEL_ADDRESS
condition|)
block|{
name|db_printf
argument_list|(
literal|"Unable to unwind into user mode\n"
argument_list|)
expr_stmt|;
name|finished
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|->
name|update_mask
operator|==
literal|0
condition|)
block|{
name|db_printf
argument_list|(
literal|"Unwind failure (no registers changed)\n"
argument_list|)
expr_stmt|;
name|finished
operator|=
name|true
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * APCS stack frames are awkward beasts, so I don't think even trying to use  * a structure to represent them is a good idea.  *  * Here's the diagram from the APCS.  Increasing address is _up_ the page.  *  *          save code pointer       [fp]<- fp points to here  *          return link value       [fp, #-4]  *          return sp value         [fp, #-8]  *          return fp value         [fp, #-12]  *          [saved v7 value]  *          [saved v6 value]  *          [saved v5 value]  *          [saved v4 value]  *          [saved v3 value]  *          [saved v2 value]  *          [saved v1 value]  *          [saved a4 value]  *          [saved a3 value]  *          [saved a2 value]  *          [saved a1 value]  *  * The save code pointer points twelve bytes beyond the start of the  * code sequence (usually a single STM) that created the stack frame.  * We have to disassemble it if we want to know which of the optional  * fields are actually present.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__ARM_EABI__
end_ifndef

begin_comment
comment|/* The frame format is differend in AAPCS */
end_comment

begin_function
specifier|static
name|void
name|db_stack_trace_cmd
parameter_list|(
name|db_expr_t
name|addr
parameter_list|,
name|db_expr_t
name|count
parameter_list|,
name|boolean_t
name|kernel_only
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|frame
decl_stmt|,
modifier|*
name|lastframe
decl_stmt|;
name|c_db_sym_t
name|sym
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|db_expr_t
name|value
decl_stmt|;
name|db_expr_t
name|offset
decl_stmt|;
name|int
name|scp_offset
decl_stmt|;
name|frame
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
name|addr
expr_stmt|;
name|lastframe
operator|=
name|NULL
expr_stmt|;
name|scp_offset
operator|=
operator|-
operator|(
name|get_pc_str_offset
argument_list|()
operator|>>
literal|2
operator|)
expr_stmt|;
while|while
condition|(
name|count
operator|--
operator|&&
name|frame
operator|!=
name|NULL
operator|&&
operator|!
name|db_pager_quit
condition|)
block|{
name|db_addr_t
name|scp
decl_stmt|;
name|u_int32_t
name|savecode
decl_stmt|;
name|int
name|r
decl_stmt|;
name|u_int32_t
modifier|*
name|rp
decl_stmt|;
specifier|const
name|char
modifier|*
name|sep
decl_stmt|;
comment|/* 		 * In theory, the SCP isn't guaranteed to be in the function 		 * that generated the stack frame.  We hope for the best. 		 */
name|scp
operator|=
name|frame
index|[
name|FR_SCP
index|]
expr_stmt|;
name|sym
operator|=
name|db_search_symbol
argument_list|(
name|scp
argument_list|,
name|DB_STGY_ANY
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|==
name|C_DB_SYM_NULL
condition|)
block|{
name|value
operator|=
literal|0
expr_stmt|;
name|name
operator|=
literal|"(null)"
expr_stmt|;
block|}
else|else
name|db_symbol_values
argument_list|(
name|sym
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"%s() at "
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|db_printsym
argument_list|(
name|scp
argument_list|,
name|DB_STGY_PROC
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__PROG26
name|db_printf
argument_list|(
literal|"\tscp=0x%08x rlv=0x%08x ("
argument_list|,
name|scp
argument_list|,
name|frame
index|[
name|FR_RLV
index|]
operator|&
name|R15_PC
argument_list|)
expr_stmt|;
name|db_printsym
argument_list|(
name|frame
index|[
name|FR_RLV
index|]
operator|&
name|R15_PC
argument_list|,
name|DB_STGY_PROC
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|")\n"
argument_list|)
expr_stmt|;
else|#
directive|else
name|db_printf
argument_list|(
literal|"\tscp=0x%08x rlv=0x%08x ("
argument_list|,
name|scp
argument_list|,
name|frame
index|[
name|FR_RLV
index|]
argument_list|)
expr_stmt|;
name|db_printsym
argument_list|(
name|frame
index|[
name|FR_RLV
index|]
argument_list|,
name|DB_STGY_PROC
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|")\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|db_printf
argument_list|(
literal|"\trsp=0x%08x rfp=0x%08x"
argument_list|,
name|frame
index|[
name|FR_RSP
index|]
argument_list|,
name|frame
index|[
name|FR_RFP
index|]
argument_list|)
expr_stmt|;
name|savecode
operator|=
operator|(
operator|(
name|u_int32_t
operator|*
operator|)
name|scp
operator|)
index|[
name|scp_offset
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|savecode
operator|&
literal|0x0e100000
operator|)
operator|==
literal|0x08000000
condition|)
block|{
comment|/* Looks like an STM */
name|rp
operator|=
name|frame
operator|-
literal|4
expr_stmt|;
name|sep
operator|=
literal|"\n\t"
expr_stmt|;
for|for
control|(
name|r
operator|=
literal|10
init|;
name|r
operator|>=
literal|0
condition|;
name|r
operator|--
control|)
block|{
if|if
condition|(
name|savecode
operator|&
operator|(
literal|1
operator|<<
name|r
operator|)
condition|)
block|{
name|db_printf
argument_list|(
literal|"%sr%d=0x%08x"
argument_list|,
name|sep
argument_list|,
name|r
argument_list|,
operator|*
name|rp
operator|--
argument_list|)
expr_stmt|;
name|sep
operator|=
operator|(
name|frame
operator|-
name|rp
operator|)
operator|%
literal|4
operator|==
literal|2
condition|?
literal|"\n\t"
else|:
literal|" "
expr_stmt|;
block|}
block|}
block|}
name|db_printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* 		 * Switch to next frame up 		 */
if|if
condition|(
name|frame
index|[
name|FR_RFP
index|]
operator|==
literal|0
condition|)
break|break;
comment|/* Top of stack */
name|lastframe
operator|=
name|frame
expr_stmt|;
name|frame
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
operator|(
name|frame
index|[
name|FR_RFP
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|INKERNEL
argument_list|(
operator|(
name|int
operator|)
name|frame
argument_list|)
condition|)
block|{
comment|/* staying in kernel */
if|if
condition|(
name|frame
operator|<=
name|lastframe
condition|)
block|{
name|db_printf
argument_list|(
literal|"Bad frame pointer: %p\n"
argument_list|,
name|frame
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|INKERNEL
argument_list|(
operator|(
name|int
operator|)
name|lastframe
argument_list|)
condition|)
block|{
comment|/* switch from user to kernel */
if|if
condition|(
name|kernel_only
condition|)
break|break;
comment|/* kernel stack only */
block|}
else|else
block|{
comment|/* in user */
if|if
condition|(
name|frame
operator|<=
name|lastframe
condition|)
block|{
name|db_printf
argument_list|(
literal|"Bad user frame pointer: %p\n"
argument_list|,
name|frame
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* XXX stubs */
end_comment

begin_function
name|void
name|db_md_list_watchpoints
parameter_list|()
block|{ }
end_function

begin_function
name|int
name|db_md_clr_watchpoint
parameter_list|(
name|db_expr_t
name|addr
parameter_list|,
name|db_expr_t
name|size
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|db_md_set_watchpoint
parameter_list|(
name|db_expr_t
name|addr
parameter_list|,
name|db_expr_t
name|size
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|db_trace_thread
parameter_list|(
name|struct
name|thread
modifier|*
name|thr
parameter_list|,
name|int
name|count
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|__ARM_EABI__
name|struct
name|unwind_state
name|state
decl_stmt|;
endif|#
directive|endif
name|struct
name|pcb
modifier|*
name|ctx
decl_stmt|;
if|if
condition|(
name|thr
operator|!=
name|curthread
condition|)
block|{
name|ctx
operator|=
name|kdb_thr_ctx
argument_list|(
name|thr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__ARM_EABI__
name|state
operator|.
name|registers
index|[
name|FP
index|]
operator|=
name|ctx
operator|->
name|un_32
operator|.
name|pcb32_r11
expr_stmt|;
name|state
operator|.
name|registers
index|[
name|SP
index|]
operator|=
name|ctx
operator|->
name|un_32
operator|.
name|pcb32_sp
expr_stmt|;
name|state
operator|.
name|registers
index|[
name|LR
index|]
operator|=
name|ctx
operator|->
name|un_32
operator|.
name|pcb32_lr
expr_stmt|;
name|state
operator|.
name|registers
index|[
name|PC
index|]
operator|=
name|ctx
operator|->
name|un_32
operator|.
name|pcb32_pc
expr_stmt|;
name|db_stack_trace_cmd
argument_list|(
operator|&
name|state
argument_list|)
expr_stmt|;
else|#
directive|else
name|db_stack_trace_cmd
argument_list|(
name|ctx
operator|->
name|un_32
operator|.
name|pcb32_r11
argument_list|,
operator|-
literal|1
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|db_trace_self
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|db_trace_self
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|__ARM_EABI__
name|struct
name|unwind_state
name|state
decl_stmt|;
name|uint32_t
name|sp
decl_stmt|;
comment|/* Read the stack pointer */
asm|__asm __volatile("mov %0, sp" : "=&r" (sp));
name|state
operator|.
name|registers
index|[
name|FP
index|]
operator|=
operator|(
name|uint32_t
operator|)
name|__builtin_frame_address
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|state
operator|.
name|registers
index|[
name|SP
index|]
operator|=
name|sp
expr_stmt|;
name|state
operator|.
name|registers
index|[
name|LR
index|]
operator|=
operator|(
name|uint32_t
operator|)
name|__builtin_return_address
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|state
operator|.
name|registers
index|[
name|PC
index|]
operator|=
operator|(
name|uint32_t
operator|)
name|db_trace_self
expr_stmt|;
name|db_stack_trace_cmd
argument_list|(
operator|&
name|state
argument_list|)
expr_stmt|;
else|#
directive|else
name|db_addr_t
name|addr
decl_stmt|;
name|addr
operator|=
operator|(
name|db_addr_t
operator|)
name|__builtin_frame_address
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|db_stack_trace_cmd
argument_list|(
name|addr
argument_list|,
operator|-
literal|1
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

end_unit

