begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 2013-2014 Andrew Turner.  * Copyright 2013-2014 Ian Lepore.  * Copyright 2013-2014 Rui Paulo.  * Copyright 2013 Eitan Adler.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *  1. Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  2. Redistributions in binary form must reproduce the above copyright  *     notice, this list of conditions and the following disclaimer in the  *     documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR  * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker.h>
end_include

begin_include
include|#
directive|include
file|<machine/stack.h>
end_include

begin_include
include|#
directive|include
file|"linker_if.h"
end_include

begin_comment
comment|/*  * Definitions for the instruction interpreter.  *  * The ARM EABI specifies how to perform the frame unwinding in the  * Exception Handling ABI for the ARM Architecture document. To perform  * the unwind we need to know the initial frame pointer, stack pointer,  * link register and program counter. We then find the entry within the  * index table that points to the function the program counter is within.  * This gives us either a list of three instructions to process, a 31-bit  * relative offset to a table of instructions, or a value telling us  * we can't unwind any further.  *  * When we have the instructions to process we need to decode them  * following table 4 in section 9.3. This describes a collection of bit  * patterns to encode that steps to take to update the stack pointer and  * link register to the correct values at the start of the function.  */
end_comment

begin_comment
comment|/* A special case when we are unable to unwind past this function */
end_comment

begin_define
define|#
directive|define
name|EXIDX_CANTUNWIND
value|1
end_define

begin_comment
comment|/*  * These are set in the linker script. Their addresses will be  * either the start or end of the exception table or index.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|exidx_start
decl_stmt|,
name|exidx_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Entry types.  * These are the only entry types that have been seen in the kernel.  */
end_comment

begin_define
define|#
directive|define
name|ENTRY_MASK
value|0xff000000
end_define

begin_define
define|#
directive|define
name|ENTRY_ARM_SU16
value|0x80000000
end_define

begin_define
define|#
directive|define
name|ENTRY_ARM_LU16
value|0x81000000
end_define

begin_comment
comment|/* Instruction masks. */
end_comment

begin_define
define|#
directive|define
name|INSN_VSP_MASK
value|0xc0
end_define

begin_define
define|#
directive|define
name|INSN_VSP_SIZE_MASK
value|0x3f
end_define

begin_define
define|#
directive|define
name|INSN_STD_MASK
value|0xf0
end_define

begin_define
define|#
directive|define
name|INSN_STD_DATA_MASK
value|0x0f
end_define

begin_define
define|#
directive|define
name|INSN_POP_TYPE_MASK
value|0x08
end_define

begin_define
define|#
directive|define
name|INSN_POP_COUNT_MASK
value|0x07
end_define

begin_define
define|#
directive|define
name|INSN_VSP_LARGE_INC_MASK
value|0xff
end_define

begin_comment
comment|/* Instruction definitions */
end_comment

begin_define
define|#
directive|define
name|INSN_VSP_INC
value|0x00
end_define

begin_define
define|#
directive|define
name|INSN_VSP_DEC
value|0x40
end_define

begin_define
define|#
directive|define
name|INSN_POP_MASKED
value|0x80
end_define

begin_define
define|#
directive|define
name|INSN_VSP_REG
value|0x90
end_define

begin_define
define|#
directive|define
name|INSN_POP_COUNT
value|0xa0
end_define

begin_define
define|#
directive|define
name|INSN_FINISH
value|0xb0
end_define

begin_define
define|#
directive|define
name|INSN_POP_REGS
value|0xb1
end_define

begin_define
define|#
directive|define
name|INSN_VSP_LARGE_INC
value|0xb2
end_define

begin_comment
comment|/* An item in the exception index table */
end_comment

begin_struct
struct|struct
name|unwind_idx
block|{
name|uint32_t
name|offset
decl_stmt|;
name|uint32_t
name|insn
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Expand a 31-bit signed value to a 32-bit signed value */
end_comment

begin_function
specifier|static
name|__inline
name|int32_t
name|expand_prel31
parameter_list|(
name|uint32_t
name|prel31
parameter_list|)
block|{
return|return
operator|(
call|(
name|int32_t
call|)
argument_list|(
name|prel31
operator|&
literal|0x7fffffffu
argument_list|)
operator|<<
literal|1
operator|)
operator|/
literal|2
return|;
block|}
end_function

begin_struct
struct|struct
name|search_context
block|{
name|uint32_t
name|addr
decl_stmt|;
name|caddr_t
name|exidx_start
decl_stmt|;
name|caddr_t
name|exidx_end
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|module_search
parameter_list|(
name|linker_file_t
name|lf
parameter_list|,
name|void
modifier|*
name|context
parameter_list|)
block|{
name|struct
name|search_context
modifier|*
name|sc
init|=
name|context
decl_stmt|;
name|linker_symval_t
name|symval
decl_stmt|;
name|c_linker_sym_t
name|sym
decl_stmt|;
if|if
condition|(
name|lf
operator|->
name|address
operator|<=
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|addr
operator|&&
operator|(
name|lf
operator|->
name|address
operator|+
name|lf
operator|->
name|size
operator|)
operator|>=
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|addr
condition|)
block|{
if|if
condition|(
operator|(
name|LINKER_LOOKUP_SYMBOL
argument_list|(
name|lf
argument_list|,
literal|"__exidx_start"
argument_list|,
operator|&
name|sym
argument_list|)
operator|==
literal|0
operator|||
name|LINKER_LOOKUP_SYMBOL
argument_list|(
name|lf
argument_list|,
literal|"exidx_start"
argument_list|,
operator|&
name|sym
argument_list|)
operator|==
literal|0
operator|)
operator|&&
name|LINKER_SYMBOL_VALUES
argument_list|(
name|lf
argument_list|,
name|sym
argument_list|,
operator|&
name|symval
argument_list|)
operator|==
literal|0
condition|)
name|sc
operator|->
name|exidx_start
operator|=
name|symval
operator|.
name|value
expr_stmt|;
if|if
condition|(
operator|(
name|LINKER_LOOKUP_SYMBOL
argument_list|(
name|lf
argument_list|,
literal|"__exidx_end"
argument_list|,
operator|&
name|sym
argument_list|)
operator|==
literal|0
operator|||
name|LINKER_LOOKUP_SYMBOL
argument_list|(
name|lf
argument_list|,
literal|"exidx_end"
argument_list|,
operator|&
name|sym
argument_list|)
operator|==
literal|0
operator|)
operator|&&
name|LINKER_SYMBOL_VALUES
argument_list|(
name|lf
argument_list|,
name|sym
argument_list|,
operator|&
name|symval
argument_list|)
operator|==
literal|0
condition|)
name|sc
operator|->
name|exidx_end
operator|=
name|symval
operator|.
name|value
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|exidx_start
operator|!=
name|NULL
operator|&&
name|sc
operator|->
name|exidx_end
operator|!=
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|panic
argument_list|(
literal|"Invalid module %s, no unwind tables\n"
argument_list|,
name|lf
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Perform a binary search of the index table to find the function  * with the largest address that doesn't exceed addr.  */
end_comment

begin_function
specifier|static
name|struct
name|unwind_idx
modifier|*
name|find_index
parameter_list|(
name|uint32_t
name|addr
parameter_list|,
name|int
name|search_modules
parameter_list|)
block|{
name|struct
name|search_context
name|sc
decl_stmt|;
name|caddr_t
name|idx_start
decl_stmt|,
name|idx_end
decl_stmt|;
name|unsigned
name|int
name|min
decl_stmt|,
name|mid
decl_stmt|,
name|max
decl_stmt|;
name|struct
name|unwind_idx
modifier|*
name|start
decl_stmt|;
name|struct
name|unwind_idx
modifier|*
name|item
decl_stmt|;
name|int32_t
name|prel31_addr
decl_stmt|;
name|uint32_t
name|func_addr
decl_stmt|;
name|start
operator|=
operator|(
expr|struct
name|unwind_idx
operator|*
operator|)
operator|&
name|exidx_start
expr_stmt|;
name|idx_start
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|exidx_start
expr_stmt|;
name|idx_end
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|exidx_end
expr_stmt|;
comment|/* This may acquire a lock */
if|if
condition|(
name|search_modules
condition|)
block|{
name|bzero
argument_list|(
operator|&
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|.
name|addr
operator|=
name|addr
expr_stmt|;
if|if
condition|(
name|linker_file_foreach
argument_list|(
name|module_search
argument_list|,
operator|&
name|sc
argument_list|)
operator|!=
literal|0
operator|&&
name|sc
operator|.
name|exidx_start
operator|!=
name|NULL
operator|&&
name|sc
operator|.
name|exidx_end
operator|!=
name|NULL
condition|)
block|{
name|start
operator|=
operator|(
expr|struct
name|unwind_idx
operator|*
operator|)
name|sc
operator|.
name|exidx_start
expr_stmt|;
name|idx_start
operator|=
name|sc
operator|.
name|exidx_start
expr_stmt|;
name|idx_end
operator|=
name|sc
operator|.
name|exidx_end
expr_stmt|;
block|}
block|}
name|min
operator|=
literal|0
expr_stmt|;
name|max
operator|=
operator|(
name|idx_end
operator|-
name|idx_start
operator|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|unwind_idx
argument_list|)
expr_stmt|;
while|while
condition|(
name|min
operator|!=
name|max
condition|)
block|{
name|mid
operator|=
name|min
operator|+
operator|(
name|max
operator|-
name|min
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
name|item
operator|=
operator|&
name|start
index|[
name|mid
index|]
expr_stmt|;
name|prel31_addr
operator|=
name|expand_prel31
argument_list|(
name|item
operator|->
name|offset
argument_list|)
expr_stmt|;
name|func_addr
operator|=
operator|(
name|uint32_t
operator|)
operator|&
name|item
operator|->
name|offset
operator|+
name|prel31_addr
expr_stmt|;
if|if
condition|(
name|func_addr
operator|<=
name|addr
condition|)
block|{
name|min
operator|=
name|mid
expr_stmt|;
block|}
else|else
block|{
name|max
operator|=
name|mid
operator|-
literal|1
expr_stmt|;
block|}
block|}
return|return
operator|&
name|start
index|[
name|min
index|]
return|;
block|}
end_function

begin_comment
comment|/* Reads the next byte from the instruction list */
end_comment

begin_function
specifier|static
name|uint8_t
name|unwind_exec_read_byte
parameter_list|(
name|struct
name|unwind_state
modifier|*
name|state
parameter_list|)
block|{
name|uint8_t
name|insn
decl_stmt|;
comment|/* Read the unwind instruction */
name|insn
operator|=
operator|(
operator|*
name|state
operator|->
name|insn
operator|)
operator|>>
operator|(
name|state
operator|->
name|byte
operator|*
literal|8
operator|)
expr_stmt|;
comment|/* Update the location of the next instruction */
if|if
condition|(
name|state
operator|->
name|byte
operator|==
literal|0
condition|)
block|{
name|state
operator|->
name|byte
operator|=
literal|3
expr_stmt|;
name|state
operator|->
name|insn
operator|++
expr_stmt|;
name|state
operator|->
name|entries
operator|--
expr_stmt|;
block|}
else|else
name|state
operator|->
name|byte
operator|--
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Executes the next instruction on the list */
end_comment

begin_function
specifier|static
name|int
name|unwind_exec_insn
parameter_list|(
name|struct
name|unwind_state
modifier|*
name|state
parameter_list|)
block|{
name|unsigned
name|int
name|insn
decl_stmt|;
name|uint32_t
modifier|*
name|vsp
init|=
operator|(
name|uint32_t
operator|*
operator|)
name|state
operator|->
name|registers
index|[
name|SP
index|]
decl_stmt|;
name|int
name|update_vsp
init|=
literal|0
decl_stmt|;
comment|/* This should never happen */
if|if
condition|(
name|state
operator|->
name|entries
operator|==
literal|0
condition|)
return|return
literal|1
return|;
comment|/* Read the next instruction */
name|insn
operator|=
name|unwind_exec_read_byte
argument_list|(
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|insn
operator|&
name|INSN_VSP_MASK
operator|)
operator|==
name|INSN_VSP_INC
condition|)
block|{
name|state
operator|->
name|registers
index|[
name|SP
index|]
operator|+=
operator|(
operator|(
name|insn
operator|&
name|INSN_VSP_SIZE_MASK
operator|)
operator|<<
literal|2
operator|)
operator|+
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
name|INSN_VSP_MASK
operator|)
operator|==
name|INSN_VSP_DEC
condition|)
block|{
name|state
operator|->
name|registers
index|[
name|SP
index|]
operator|-=
operator|(
operator|(
name|insn
operator|&
name|INSN_VSP_SIZE_MASK
operator|)
operator|<<
literal|2
operator|)
operator|+
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
name|INSN_STD_MASK
operator|)
operator|==
name|INSN_POP_MASKED
condition|)
block|{
name|unsigned
name|int
name|mask
decl_stmt|,
name|reg
decl_stmt|;
comment|/* Load the mask */
name|mask
operator|=
name|unwind_exec_read_byte
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|mask
operator||=
operator|(
name|insn
operator|&
name|INSN_STD_DATA_MASK
operator|)
operator|<<
literal|8
expr_stmt|;
comment|/* We have a refuse to unwind instruction */
if|if
condition|(
name|mask
operator|==
literal|0
condition|)
return|return
literal|1
return|;
comment|/* Update SP */
name|update_vsp
operator|=
literal|1
expr_stmt|;
comment|/* Load the registers */
for|for
control|(
name|reg
operator|=
literal|4
init|;
name|mask
operator|&&
name|reg
operator|<
literal|16
condition|;
name|mask
operator|>>=
literal|1
operator|,
name|reg
operator|++
control|)
block|{
if|if
condition|(
name|mask
operator|&
literal|1
condition|)
block|{
name|state
operator|->
name|registers
index|[
name|reg
index|]
operator|=
operator|*
name|vsp
operator|++
expr_stmt|;
name|state
operator|->
name|update_mask
operator||=
literal|1
operator|<<
name|reg
expr_stmt|;
comment|/* If we have updated SP kep its value */
if|if
condition|(
name|reg
operator|==
name|SP
condition|)
name|update_vsp
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
name|INSN_STD_MASK
operator|)
operator|==
name|INSN_VSP_REG
operator|&&
operator|(
operator|(
name|insn
operator|&
name|INSN_STD_DATA_MASK
operator|)
operator|!=
literal|13
operator|)
operator|&&
operator|(
operator|(
name|insn
operator|&
name|INSN_STD_DATA_MASK
operator|)
operator|!=
literal|15
operator|)
condition|)
block|{
comment|/* sp = register */
name|state
operator|->
name|registers
index|[
name|SP
index|]
operator|=
name|state
operator|->
name|registers
index|[
name|insn
operator|&
name|INSN_STD_DATA_MASK
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
name|INSN_STD_MASK
operator|)
operator|==
name|INSN_POP_COUNT
condition|)
block|{
name|unsigned
name|int
name|count
decl_stmt|,
name|reg
decl_stmt|;
comment|/* Read how many registers to load */
name|count
operator|=
name|insn
operator|&
name|INSN_POP_COUNT_MASK
expr_stmt|;
comment|/* Update sp */
name|update_vsp
operator|=
literal|1
expr_stmt|;
comment|/* Pop the registers */
for|for
control|(
name|reg
operator|=
literal|4
init|;
name|reg
operator|<=
literal|4
operator|+
name|count
condition|;
name|reg
operator|++
control|)
block|{
name|state
operator|->
name|registers
index|[
name|reg
index|]
operator|=
operator|*
name|vsp
operator|++
expr_stmt|;
name|state
operator|->
name|update_mask
operator||=
literal|1
operator|<<
name|reg
expr_stmt|;
block|}
comment|/* Check if we are in the pop r14 version */
if|if
condition|(
operator|(
name|insn
operator|&
name|INSN_POP_TYPE_MASK
operator|)
operator|!=
literal|0
condition|)
block|{
name|state
operator|->
name|registers
index|[
literal|14
index|]
operator|=
operator|*
name|vsp
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|insn
operator|==
name|INSN_FINISH
condition|)
block|{
comment|/* Stop processing */
name|state
operator|->
name|entries
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|insn
operator|==
name|INSN_POP_REGS
condition|)
block|{
name|unsigned
name|int
name|mask
decl_stmt|,
name|reg
decl_stmt|;
name|mask
operator|=
name|unwind_exec_read_byte
argument_list|(
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|==
literal|0
operator|||
operator|(
name|mask
operator|&
literal|0xf0
operator|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
comment|/* Update SP */
name|update_vsp
operator|=
literal|1
expr_stmt|;
comment|/* Load the registers */
for|for
control|(
name|reg
operator|=
literal|0
init|;
name|mask
operator|&&
name|reg
operator|<
literal|4
condition|;
name|mask
operator|>>=
literal|1
operator|,
name|reg
operator|++
control|)
block|{
if|if
condition|(
name|mask
operator|&
literal|1
condition|)
block|{
name|state
operator|->
name|registers
index|[
name|reg
index|]
operator|=
operator|*
name|vsp
operator|++
expr_stmt|;
name|state
operator|->
name|update_mask
operator||=
literal|1
operator|<<
name|reg
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
name|INSN_VSP_LARGE_INC_MASK
operator|)
operator|==
name|INSN_VSP_LARGE_INC
condition|)
block|{
name|unsigned
name|int
name|uleb128
decl_stmt|;
comment|/* Read the increment value */
name|uleb128
operator|=
name|unwind_exec_read_byte
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|state
operator|->
name|registers
index|[
name|SP
index|]
operator|+=
literal|0x204
operator|+
operator|(
name|uleb128
operator|<<
literal|2
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We hit a new instruction that needs to be implemented */
if|#
directive|if
literal|0
block|db_printf("Unhandled instruction %.2x\n", insn);
endif|#
directive|endif
return|return
literal|1
return|;
block|}
if|if
condition|(
name|update_vsp
condition|)
block|{
name|state
operator|->
name|registers
index|[
name|SP
index|]
operator|=
operator|(
name|uint32_t
operator|)
name|vsp
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|db_printf("fp = %08x, sp = %08x, lr = %08x, pc = %08x\n", 	    state->registers[FP], state->registers[SP], state->registers[LR], 	    state->registers[PC]);
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Performs the unwind of a function */
end_comment

begin_function
specifier|static
name|int
name|unwind_tab
parameter_list|(
name|struct
name|unwind_state
modifier|*
name|state
parameter_list|)
block|{
name|uint32_t
name|entry
decl_stmt|;
comment|/* Set PC to a known value */
name|state
operator|->
name|registers
index|[
name|PC
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Read the personality */
name|entry
operator|=
operator|*
name|state
operator|->
name|insn
operator|&
name|ENTRY_MASK
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|ENTRY_ARM_SU16
condition|)
block|{
name|state
operator|->
name|byte
operator|=
literal|2
expr_stmt|;
name|state
operator|->
name|entries
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|entry
operator|==
name|ENTRY_ARM_LU16
condition|)
block|{
name|state
operator|->
name|byte
operator|=
literal|1
expr_stmt|;
name|state
operator|->
name|entries
operator|=
operator|(
operator|(
operator|*
name|state
operator|->
name|insn
operator|>>
literal|16
operator|)
operator|&
literal|0xFF
operator|)
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
literal|0
block|db_printf("Unknown entry: %x\n", entry);
endif|#
directive|endif
return|return
literal|1
return|;
block|}
while|while
condition|(
name|state
operator|->
name|entries
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|unwind_exec_insn
argument_list|(
name|state
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
block|}
comment|/* 	 * The program counter was not updated, load it from the link register. 	 */
if|if
condition|(
name|state
operator|->
name|registers
index|[
name|PC
index|]
operator|==
literal|0
condition|)
block|{
name|state
operator|->
name|registers
index|[
name|PC
index|]
operator|=
name|state
operator|->
name|registers
index|[
name|LR
index|]
expr_stmt|;
comment|/* 		 * If the program counter changed, flag it in the update mask. 		 */
if|if
condition|(
name|state
operator|->
name|start_pc
operator|!=
name|state
operator|->
name|registers
index|[
name|PC
index|]
condition|)
name|state
operator|->
name|update_mask
operator||=
literal|1
operator|<<
name|PC
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|unwind_stack_one
parameter_list|(
name|struct
name|unwind_state
modifier|*
name|state
parameter_list|,
name|int
name|can_lock
parameter_list|)
block|{
name|struct
name|unwind_idx
modifier|*
name|index
decl_stmt|;
name|int
name|finished
decl_stmt|;
comment|/* Reset the mask of updated registers */
name|state
operator|->
name|update_mask
operator|=
literal|0
expr_stmt|;
comment|/* The pc value is correct and will be overwritten, save it */
name|state
operator|->
name|start_pc
operator|=
name|state
operator|->
name|registers
index|[
name|PC
index|]
expr_stmt|;
comment|/* Find the item to run */
name|index
operator|=
name|find_index
argument_list|(
name|state
operator|->
name|start_pc
argument_list|,
name|can_lock
argument_list|)
expr_stmt|;
name|finished
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|index
operator|->
name|insn
operator|!=
name|EXIDX_CANTUNWIND
condition|)
block|{
if|if
condition|(
name|index
operator|->
name|insn
operator|&
operator|(
literal|1U
operator|<<
literal|31
operator|)
condition|)
block|{
comment|/* The data is within the instruction */
name|state
operator|->
name|insn
operator|=
operator|&
name|index
operator|->
name|insn
expr_stmt|;
block|}
else|else
block|{
comment|/* A prel31 offset to the unwind table */
name|state
operator|->
name|insn
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
operator|&
name|index
operator|->
name|insn
operator|+
name|expand_prel31
argument_list|(
name|index
operator|->
name|insn
argument_list|)
operator|)
expr_stmt|;
block|}
comment|/* Run the unwind function */
name|finished
operator|=
name|unwind_tab
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
comment|/* This is the top of the stack, finish */
if|if
condition|(
name|index
operator|->
name|insn
operator|==
name|EXIDX_CANTUNWIND
condition|)
name|finished
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|finished
operator|)
return|;
block|}
end_function

end_unit

