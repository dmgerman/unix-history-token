begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* From: $NetBSD: pmap.c,v 1.148 2004/04/03 04:35:48 bsh Exp $ */
end_comment

begin_comment
comment|/*-  * Copyright 2011 Semihalf  * Copyright 2004 Olivier Houchard.  * Copyright 2003 Wasabi Systems, Inc.  * All rights reserved.  *  * Written by Steve C. Woodford for Wasabi Systems, Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *      This product includes software developed for the NetBSD Project by  *      Wasabi Systems, Inc.  * 4. The name of Wasabi Systems, Inc. may not be used to endorse  *    or promote products derived from this software without specific prior  *    written permission.  *  * THIS SOFTWARE IS PROVIDED BY WASABI SYSTEMS, INC. ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL WASABI SYSTEMS, INC  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  *  * From: FreeBSD: src/sys/arm/arm/pmap.c,v 1.113 2009/07/24 13:50:29  */
end_comment

begin_comment
comment|/*-  * Copyright (c) 2002-2003 Wasabi Systems, Inc.  * Copyright (c) 2001 Richard Earnshaw  * Copyright (c) 2001-2002 Christopher Gilbert  * All rights reserved.  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the company nor the name of the author may be used to  *    endorse or promote products derived from this software without specific  *    prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*-  * Copyright (c) 1999 The NetBSD Foundation, Inc.  * All rights reserved.  *  * This code is derived from software contributed to The NetBSD Foundation  * by Charles M. Hannum.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*-  * Copyright (c) 1994-1998 Mark Brinicombe.  * Copyright (c) 1994 Brini.  * All rights reserved.  *  * This code is derived from software written for Brini by Mark Brinicombe  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *      This product includes software developed by Mark Brinicombe.  * 4. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  *  * RiscBSD kernel project  *  * pmap.c  *  * Machine dependant vm stuff  *  * Created      : 20/09/94  */
end_comment

begin_comment
comment|/*  * Special compilation symbols  * PMAP_DEBUG           - Build in pmap_debug_level code  *  * Note that pmap_mapdev() and pmap_unmapdev() are implemented in arm/devmap.c */
end_comment

begin_comment
comment|/* Include header files */
end_comment

begin_include
include|#
directive|include
file|"opt_vm.h"
end_include

begin_include
include|#
directive|include
file|"opt_pmap.h"
end_include

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/msgbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmmeter.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/rwlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/sched.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pageout.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_reserv.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpufunc.h>
end_include

begin_include
include|#
directive|include
file|<machine/pcb.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|last_fault_code
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|PMAP_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|PDEBUG
parameter_list|(
name|_lev_
parameter_list|,
name|_stat_
parameter_list|)
define|\
value|if (pmap_debug_level>= (_lev_)) \                 ((_stat_))
end_define

begin_define
define|#
directive|define
name|dprintf
value|printf
end_define

begin_decl_stmt
name|int
name|pmap_debug_level
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|PMAP_INLINE
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* PMAP_DEBUG */
end_comment

begin_define
define|#
directive|define
name|PDEBUG
parameter_list|(
name|_lev_
parameter_list|,
name|_stat_
parameter_list|)
end_define

begin_comment
comment|/* Nothing */
end_comment

begin_define
define|#
directive|define
name|dprintf
parameter_list|(
name|x
parameter_list|,
name|arg
modifier|...
parameter_list|)
end_define

begin_define
define|#
directive|define
name|PMAP_INLINE
value|__inline
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PMAP_DEBUG */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PV_STATS
end_ifdef

begin_define
define|#
directive|define
name|PV_STAT
parameter_list|(
name|x
parameter_list|)
value|do { x ; } while (0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PV_STAT
parameter_list|(
name|x
parameter_list|)
value|do { } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|pa_to_pvh
parameter_list|(
name|pa
parameter_list|)
value|(&pv_table[pa_index(pa)])
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|ARM_L2_PIPT
end_ifdef

begin_define
define|#
directive|define
name|pmap_l2cache_wbinv_range
parameter_list|(
name|va
parameter_list|,
name|pa
parameter_list|,
name|size
parameter_list|)
value|cpu_l2cache_wbinv_range((pa), (size))
end_define

begin_define
define|#
directive|define
name|pmap_l2cache_inv_range
parameter_list|(
name|va
parameter_list|,
name|pa
parameter_list|,
name|size
parameter_list|)
value|cpu_l2cache_inv_range((pa), (size))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|pmap_l2cache_wbinv_range
parameter_list|(
name|va
parameter_list|,
name|pa
parameter_list|,
name|size
parameter_list|)
value|cpu_l2cache_wbinv_range((va), (size))
end_define

begin_define
define|#
directive|define
name|pmap_l2cache_inv_range
parameter_list|(
name|va
parameter_list|,
name|pa
parameter_list|,
name|size
parameter_list|)
value|cpu_l2cache_inv_range((va), (size))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|struct
name|pv_addr
name|systempage
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Internal function prototypes  */
end_comment

begin_expr_stmt
specifier|static
name|PMAP_INLINE
expr|struct
name|pv_entry
operator|*
name|pmap_find_pv
argument_list|(
expr|struct
name|md_page
operator|*
argument_list|,
name|pmap_t
argument_list|,
name|vm_offset_t
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|void
name|pmap_free_pv_chunk
parameter_list|(
name|struct
name|pv_chunk
modifier|*
name|pc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmap_free_pv_entry
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|pv_entry_t
name|pv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|pv_entry_t
name|pmap_get_pv_entry
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|boolean_t
name|try
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|vm_page_t
name|pmap_pv_reclaim
parameter_list|(
name|pmap_t
name|locked_pmap
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|boolean_t
name|pmap_pv_insert_section
parameter_list|(
name|pmap_t
parameter_list|,
name|vm_offset_t
parameter_list|,
name|vm_paddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|pv_entry
modifier|*
name|pmap_remove_pv
parameter_list|(
name|struct
name|vm_page
modifier|*
parameter_list|,
name|pmap_t
parameter_list|,
name|vm_offset_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pmap_pvh_wired_mappings
parameter_list|(
name|struct
name|md_page
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmap_enter_locked
parameter_list|(
name|pmap_t
parameter_list|,
name|vm_offset_t
parameter_list|,
name|vm_prot_t
parameter_list|,
name|vm_page_t
parameter_list|,
name|vm_prot_t
parameter_list|,
name|boolean_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|vm_paddr_t
name|pmap_extract_locked
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmap_alloc_l1
parameter_list|(
name|pmap_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmap_free_l1
parameter_list|(
name|pmap_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmap_map_section
parameter_list|(
name|pmap_t
parameter_list|,
name|vm_offset_t
parameter_list|,
name|vm_offset_t
parameter_list|,
name|vm_prot_t
parameter_list|,
name|boolean_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmap_promote_section
parameter_list|(
name|pmap_t
parameter_list|,
name|vm_offset_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|boolean_t
name|pmap_demote_section
parameter_list|(
name|pmap_t
parameter_list|,
name|vm_offset_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|boolean_t
name|pmap_enter_section
parameter_list|(
name|pmap_t
parameter_list|,
name|vm_offset_t
parameter_list|,
name|vm_page_t
parameter_list|,
name|vm_prot_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmap_remove_section
parameter_list|(
name|pmap_t
parameter_list|,
name|vm_offset_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pmap_clearbit
parameter_list|(
name|struct
name|vm_page
modifier|*
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|l2_bucket
modifier|*
name|pmap_get_l2_bucket
parameter_list|(
name|pmap_t
parameter_list|,
name|vm_offset_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|l2_bucket
modifier|*
name|pmap_alloc_l2_bucket
parameter_list|(
name|pmap_t
parameter_list|,
name|vm_offset_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmap_free_l2_bucket
parameter_list|(
name|pmap_t
parameter_list|,
name|struct
name|l2_bucket
modifier|*
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|vm_offset_t
name|kernel_pt_lookup
parameter_list|(
name|vm_paddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_VMPMAP
argument_list|,
literal|"pmap"
argument_list|,
literal|"PMAP L1"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|vm_offset_t
name|virtual_avail
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* VA of first avail page (after kernel bss) */
end_comment

begin_decl_stmt
name|vm_offset_t
name|virtual_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* VA of last avail page (end of kernel AS) */
end_comment

begin_decl_stmt
name|vm_offset_t
name|pmap_curmaxkvaddr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_paddr_t
name|kernel_l1pa
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_offset_t
name|kernel_vm_end
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_offset_t
name|vm_max_kernel_address
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pmap
name|kernel_pmap_store
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Resources for quickly copying and zeroing pages using virtual address space  * and page table entries that are pre-allocated per-CPU by pmap_init().  */
end_comment

begin_struct
struct|struct
name|czpages
block|{
name|struct
name|mtx
name|lock
decl_stmt|;
name|pt_entry_t
modifier|*
name|srcptep
decl_stmt|;
name|pt_entry_t
modifier|*
name|dstptep
decl_stmt|;
name|vm_offset_t
name|srcva
decl_stmt|;
name|vm_offset_t
name|dstva
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|czpages
name|cpu_czpages
index|[
name|MAXCPU
index|]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|pmap_init_l1
parameter_list|(
name|struct
name|l1_ttable
modifier|*
parameter_list|,
name|pd_entry_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * These routines are called when the CPU type is identified to set up  * the PTE prototypes, cache modes, etc.  *  * The variables are always here, just in case LKMs need to reference  * them (though, they shouldn't).  */
end_comment

begin_function_decl
specifier|static
name|void
name|pmap_set_prot
parameter_list|(
name|pt_entry_t
modifier|*
name|pte
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|,
name|uint8_t
name|user
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|pt_entry_t
name|pte_l1_s_cache_mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|pt_entry_t
name|pte_l1_s_cache_mode_pt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|pt_entry_t
name|pte_l2_l_cache_mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|pt_entry_t
name|pte_l2_l_cache_mode_pt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|pt_entry_t
name|pte_l2_s_cache_mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|pt_entry_t
name|pte_l2_s_cache_mode_pt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|msgbuf
modifier|*
name|msgbufp
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Crashdump maps.  */
end_comment

begin_decl_stmt
specifier|static
name|caddr_t
name|crashdumpmap
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|void
name|bcopy_page
parameter_list|(
name|vm_offset_t
parameter_list|,
name|vm_offset_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|bzero_page
parameter_list|(
name|vm_offset_t
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|char
modifier|*
name|_tmppt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Metadata for L1 translation tables.  */
end_comment

begin_struct
struct|struct
name|l1_ttable
block|{
comment|/* Entry on the L1 Table list */
name|SLIST_ENTRY
argument_list|(
argument|l1_ttable
argument_list|)
name|l1_link
expr_stmt|;
comment|/* Entry on the L1 Least Recently Used list */
name|TAILQ_ENTRY
argument_list|(
argument|l1_ttable
argument_list|)
name|l1_lru
expr_stmt|;
comment|/* Track how many domains are allocated from this L1 */
specifier|volatile
name|u_int
name|l1_domain_use_count
decl_stmt|;
comment|/* 	 * A free-list of domain numbers for this L1. 	 * We avoid using ffs() and a bitmap to track domains since ffs() 	 * is slow on ARM. 	 */
name|u_int8_t
name|l1_domain_first
decl_stmt|;
name|u_int8_t
name|l1_domain_free
index|[
name|PMAP_DOMAINS
index|]
decl_stmt|;
comment|/* Physical address of this L1 page table */
name|vm_paddr_t
name|l1_physaddr
decl_stmt|;
comment|/* KVA of this L1 page table */
name|pd_entry_t
modifier|*
name|l1_kva
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Convert a virtual address into its L1 table index. That is, the  * index used to locate the L2 descriptor table pointer in an L1 table.  * This is basically used to index l1->l1_kva[].  *  * Each L2 descriptor table represents 1MB of VA space.  */
end_comment

begin_define
define|#
directive|define
name|L1_IDX
parameter_list|(
name|va
parameter_list|)
value|(((vm_offset_t)(va))>> L1_S_SHIFT)
end_define

begin_comment
comment|/*  * L1 Page Tables are tracked using a Least Recently Used list.  *  - New L1s are allocated from the HEAD.  *  - Freed L1s are added to the TAIl.  *  - Recently accessed L1s (where an 'access' is some change to one of  *    the userland pmaps which owns this L1) are moved to the TAIL.  */
end_comment

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|l1_ttable
argument_list|)
name|l1_lru_list
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * A list of all L1 tables  */
end_comment

begin_expr_stmt
specifier|static
name|SLIST_HEAD
argument_list|(
argument_list|,
argument|l1_ttable
argument_list|)
name|l1_list
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|l1_lru_lock
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The l2_dtable tracks L2_BUCKET_SIZE worth of L1 slots.  *  * This is normally 16MB worth L2 page descriptors for any given pmap.  * Reference counts are maintained for L2 descriptors so they can be  * freed when empty.  */
end_comment

begin_struct
struct|struct
name|l2_dtable
block|{
comment|/* The number of L2 page descriptors allocated to this l2_dtable */
name|u_int
name|l2_occupancy
decl_stmt|;
comment|/* List of L2 page descriptors */
struct|struct
name|l2_bucket
block|{
name|pt_entry_t
modifier|*
name|l2b_kva
decl_stmt|;
comment|/* KVA of L2 Descriptor Table */
name|vm_paddr_t
name|l2b_phys
decl_stmt|;
comment|/* Physical address of same */
name|u_short
name|l2b_l1idx
decl_stmt|;
comment|/* This L2 table's L1 index */
name|u_short
name|l2b_occupancy
decl_stmt|;
comment|/* How many active descriptors */
block|}
name|l2_bucket
index|[
name|L2_BUCKET_SIZE
index|]
struct|;
block|}
struct|;
end_struct

begin_comment
comment|/* pmap_kenter_internal flags */
end_comment

begin_define
define|#
directive|define
name|KENTER_CACHE
value|0x1
end_define

begin_define
define|#
directive|define
name|KENTER_DEVICE
value|0x2
end_define

begin_define
define|#
directive|define
name|KENTER_USER
value|0x4
end_define

begin_comment
comment|/*  * Given an L1 table index, calculate the corresponding l2_dtable index  * and bucket index within the l2_dtable.  */
end_comment

begin_define
define|#
directive|define
name|L2_IDX
parameter_list|(
name|l1idx
parameter_list|)
value|(((l1idx)>> L2_BUCKET_LOG2)& \ 				 (L2_SIZE - 1))
end_define

begin_define
define|#
directive|define
name|L2_BUCKET
parameter_list|(
name|l1idx
parameter_list|)
value|((l1idx)& (L2_BUCKET_SIZE - 1))
end_define

begin_comment
comment|/*  * Given a virtual address, this macro returns the  * virtual address required to drop into the next L2 bucket.  */
end_comment

begin_define
define|#
directive|define
name|L2_NEXT_BUCKET
parameter_list|(
name|va
parameter_list|)
value|(((va)& L1_S_FRAME) + L1_S_SIZE)
end_define

begin_comment
comment|/*  * We try to map the page tables write-through, if possible.  However, not  * all CPUs have a write-through cache mode, so on those we have to sync  * the cache when we frob page tables.  *  * We try to evaluate this at compile time, if possible.  However, it's  * not always possible to do that, hence this run-time var.  */
end_comment

begin_decl_stmt
name|int
name|pmap_needs_pte_sync
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Macro to determine if a mapping might be resident in the  * instruction cache and/or TLB  */
end_comment

begin_define
define|#
directive|define
name|PTE_BEEN_EXECD
parameter_list|(
name|pte
parameter_list|)
value|(L2_S_EXECUTABLE(pte)&& L2_S_REFERENCED(pte))
end_define

begin_comment
comment|/*  * Macro to determine if a mapping might be resident in the  * data cache and/or TLB  */
end_comment

begin_define
define|#
directive|define
name|PTE_BEEN_REFD
parameter_list|(
name|pte
parameter_list|)
value|(L2_S_REFERENCED(pte))
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|PMAP_SHPGPERPROC
end_ifndef

begin_define
define|#
directive|define
name|PMAP_SHPGPERPROC
value|200
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|pmap_is_current
parameter_list|(
name|pm
parameter_list|)
value|((pm) == pmap_kernel() || \             curproc->p_vmspace->vm_map.pmap == (pm))
end_define

begin_comment
comment|/*  * Data for the pv entry allocation mechanism  */
end_comment

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument|pch
argument_list|,
argument|pv_chunk
argument_list|)
name|pv_chunks
operator|=
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|pv_chunks
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|pv_entry_count
decl_stmt|,
name|pv_entry_max
decl_stmt|,
name|pv_entry_high_water
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|md_page
modifier|*
name|pv_table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|shpgperproc
init|=
name|PMAP_SHPGPERPROC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pv_chunk
modifier|*
name|pv_chunkbase
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* KVA block for pv_chunks */
end_comment

begin_decl_stmt
name|int
name|pv_maxchunks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* How many chunks we have KVA for */
end_comment

begin_decl_stmt
name|vm_offset_t
name|pv_vafree
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Freelist stored in the PTE */
end_comment

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|pv_chunk
operator|*
name|pv_to_chunk
argument_list|(
argument|pv_entry_t pv
argument_list|)
block|{
return|return
operator|(
operator|(
expr|struct
name|pv_chunk
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|pv
operator|&
operator|~
operator|(
name|uintptr_t
operator|)
name|PAGE_MASK
operator|)
operator|)
return|;
block|}
end_expr_stmt

begin_define
define|#
directive|define
name|PV_PMAP
parameter_list|(
name|pv
parameter_list|)
value|(pv_to_chunk(pv)->pc_pmap)
end_define

begin_expr_stmt
name|CTASSERT
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pv_chunk
argument_list|)
operator|==
name|PAGE_SIZE
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CTASSERT
argument_list|(
name|_NPCM
operator|==
literal|8
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CTASSERT
argument_list|(
name|_NPCPV
operator|==
literal|252
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|PC_FREE0_6
value|0xfffffffful
end_define

begin_comment
comment|/* Free values for index 0 through 6 */
end_comment

begin_define
define|#
directive|define
name|PC_FREE7
value|0x0ffffffful
end_define

begin_comment
comment|/* Free values for index 7 */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|uint32_t
name|pc_freemask
index|[
name|_NPCM
index|]
init|=
block|{
name|PC_FREE0_6
block|,
name|PC_FREE0_6
block|,
name|PC_FREE0_6
block|,
name|PC_FREE0_6
block|,
name|PC_FREE0_6
block|,
name|PC_FREE0_6
block|,
name|PC_FREE0_6
block|,
name|PC_FREE7
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_vm
argument_list|,
name|OID_AUTO
argument_list|,
name|pmap
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"VM/pmap parameters"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Superpages utilization enabled = 1 / disabled = 0 */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sp_enabled
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vm_pmap
argument_list|,
name|OID_AUTO
argument_list|,
name|sp_enabled
argument_list|,
name|CTLFLAG_RDTUN
operator||
name|CTLFLAG_NOFETCH
argument_list|,
operator|&
name|sp_enabled
argument_list|,
literal|0
argument_list|,
literal|"Are large page mappings enabled?"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vm_pmap
argument_list|,
name|OID_AUTO
argument_list|,
name|pv_entry_count
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pv_entry_count
argument_list|,
literal|0
argument_list|,
literal|"Current number of pv entries"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|PV_STATS
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|pc_chunk_count
decl_stmt|,
name|pc_chunk_allocs
decl_stmt|,
name|pc_chunk_frees
decl_stmt|,
name|pc_chunk_tryfail
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vm_pmap
argument_list|,
name|OID_AUTO
argument_list|,
name|pc_chunk_count
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pc_chunk_count
argument_list|,
literal|0
argument_list|,
literal|"Current number of pv entry chunks"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vm_pmap
argument_list|,
name|OID_AUTO
argument_list|,
name|pc_chunk_allocs
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pc_chunk_allocs
argument_list|,
literal|0
argument_list|,
literal|"Current number of pv entry chunks allocated"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vm_pmap
argument_list|,
name|OID_AUTO
argument_list|,
name|pc_chunk_frees
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pc_chunk_frees
argument_list|,
literal|0
argument_list|,
literal|"Current number of pv entry chunks frees"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vm_pmap
argument_list|,
name|OID_AUTO
argument_list|,
name|pc_chunk_tryfail
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pc_chunk_tryfail
argument_list|,
literal|0
argument_list|,
literal|"Number of times tried to get a chunk page but failed."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|long
name|pv_entry_frees
decl_stmt|,
name|pv_entry_allocs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pv_entry_spare
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_LONG
argument_list|(
name|_vm_pmap
argument_list|,
name|OID_AUTO
argument_list|,
name|pv_entry_frees
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pv_entry_frees
argument_list|,
literal|0
argument_list|,
literal|"Current number of pv entry frees"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_LONG
argument_list|(
name|_vm_pmap
argument_list|,
name|OID_AUTO
argument_list|,
name|pv_entry_allocs
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pv_entry_allocs
argument_list|,
literal|0
argument_list|,
literal|"Current number of pv entry allocs"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vm_pmap
argument_list|,
name|OID_AUTO
argument_list|,
name|pv_entry_spare
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pv_entry_spare
argument_list|,
literal|0
argument_list|,
literal|"Current number of spare pv entries"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|uma_zone_t
name|l2zone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uma_zone_t
name|l2table_zone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vm_offset_t
name|pmap_kernel_l2dtable_kva
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vm_offset_t
name|pmap_kernel_l2ptp_kva
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vm_paddr_t
name|pmap_kernel_l2ptp_phys
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|rwlock
name|pvh_global_lock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|l1_mem_types
index|[]
init|=
block|{
name|ARM_L1S_STRONG_ORD
block|,
name|ARM_L1S_DEVICE_NOSHARE
block|,
name|ARM_L1S_DEVICE_SHARE
block|,
name|ARM_L1S_NRML_NOCACHE
block|,
name|ARM_L1S_NRML_IWT_OWT
block|,
name|ARM_L1S_NRML_IWB_OWB
block|,
name|ARM_L1S_NRML_IWBA_OWBA
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|l2l_mem_types
index|[]
init|=
block|{
name|ARM_L2L_STRONG_ORD
block|,
name|ARM_L2L_DEVICE_NOSHARE
block|,
name|ARM_L2L_DEVICE_SHARE
block|,
name|ARM_L2L_NRML_NOCACHE
block|,
name|ARM_L2L_NRML_IWT_OWT
block|,
name|ARM_L2L_NRML_IWB_OWB
block|,
name|ARM_L2L_NRML_IWBA_OWBA
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|l2s_mem_types
index|[]
init|=
block|{
name|ARM_L2S_STRONG_ORD
block|,
name|ARM_L2S_DEVICE_NOSHARE
block|,
name|ARM_L2S_DEVICE_SHARE
block|,
name|ARM_L2S_NRML_NOCACHE
block|,
name|ARM_L2S_NRML_IWT_OWT
block|,
name|ARM_L2S_NRML_IWB_OWB
block|,
name|ARM_L2S_NRML_IWBA_OWBA
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This list exists for the benefit of pmap_map_chunk().  It keeps track  * of the kernel L2 tables during bootstrap, so that pmap_map_chunk() can  * find them as necessary.  *  * Note that the data on this list MUST remain valid after initarm() returns,  * as pmap_bootstrap() uses it to contruct L2 table metadata.  */
end_comment

begin_macro
name|SLIST_HEAD
argument_list|(
argument_list|,
argument|pv_addr
argument_list|)
end_macro

begin_expr_stmt
name|kernel_pt_list
operator|=
name|SLIST_HEAD_INITIALIZER
argument_list|(
name|kernel_pt_list
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|pmap_init_l1
parameter_list|(
name|struct
name|l1_ttable
modifier|*
name|l1
parameter_list|,
name|pd_entry_t
modifier|*
name|l1pt
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|l1
operator|->
name|l1_kva
operator|=
name|l1pt
expr_stmt|;
name|l1
operator|->
name|l1_domain_use_count
operator|=
literal|0
expr_stmt|;
name|l1
operator|->
name|l1_domain_first
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PMAP_DOMAINS
condition|;
name|i
operator|++
control|)
name|l1
operator|->
name|l1_domain_free
index|[
name|i
index|]
operator|=
name|i
operator|+
literal|1
expr_stmt|;
comment|/* 	 * Copy the kernel's L1 entries to each new L1. 	 */
if|if
condition|(
name|l1pt
operator|!=
name|pmap_kernel
argument_list|()
operator|->
name|pm_l1
operator|->
name|l1_kva
condition|)
name|memcpy
argument_list|(
name|l1pt
argument_list|,
name|pmap_kernel
argument_list|()
operator|->
name|pm_l1
operator|->
name|l1_kva
argument_list|,
name|L1_TABLE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|l1
operator|->
name|l1_physaddr
operator|=
name|pmap_extract
argument_list|(
name|pmap_kernel
argument_list|()
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|l1pt
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"pmap_init_l1: can't get PA of L1 at %p"
argument_list|,
name|l1pt
argument_list|)
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|l1_list
argument_list|,
name|l1
argument_list|,
name|l1_link
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|l1_lru_list
argument_list|,
name|l1
argument_list|,
name|l1_lru
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|vm_offset_t
name|kernel_pt_lookup
parameter_list|(
name|vm_paddr_t
name|pa
parameter_list|)
block|{
name|struct
name|pv_addr
modifier|*
name|pv
decl_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&kernel_pt_list
argument_list|,
argument|pv_list
argument_list|)
block|{
if|if
condition|(
name|pv
operator|->
name|pv_pa
operator|==
name|pa
condition|)
return|return
operator|(
name|pv
operator|->
name|pv_va
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pmap_pte_init_mmu_v6
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|PTE_PAGETABLE
operator|>=
literal|3
condition|)
name|pmap_needs_pte_sync
operator|=
literal|1
expr_stmt|;
name|pte_l1_s_cache_mode
operator|=
name|l1_mem_types
index|[
name|PTE_CACHE
index|]
expr_stmt|;
name|pte_l2_l_cache_mode
operator|=
name|l2l_mem_types
index|[
name|PTE_CACHE
index|]
expr_stmt|;
name|pte_l2_s_cache_mode
operator|=
name|l2s_mem_types
index|[
name|PTE_CACHE
index|]
expr_stmt|;
name|pte_l1_s_cache_mode_pt
operator|=
name|l1_mem_types
index|[
name|PTE_PAGETABLE
index|]
expr_stmt|;
name|pte_l2_l_cache_mode_pt
operator|=
name|l2l_mem_types
index|[
name|PTE_PAGETABLE
index|]
expr_stmt|;
name|pte_l2_s_cache_mode_pt
operator|=
name|l2s_mem_types
index|[
name|PTE_PAGETABLE
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate an L1 translation table for the specified pmap.  * This is called at pmap creation time.  */
end_comment

begin_function
specifier|static
name|void
name|pmap_alloc_l1
parameter_list|(
name|pmap_t
name|pmap
parameter_list|)
block|{
name|struct
name|l1_ttable
modifier|*
name|l1
decl_stmt|;
name|u_int8_t
name|domain
decl_stmt|;
comment|/* 	 * Remove the L1 at the head of the LRU list 	 */
name|mtx_lock
argument_list|(
operator|&
name|l1_lru_lock
argument_list|)
expr_stmt|;
name|l1
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|l1_lru_list
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|l1_lru_list
argument_list|,
name|l1
argument_list|,
name|l1_lru
argument_list|)
expr_stmt|;
comment|/* 	 * Pick the first available domain number, and update 	 * the link to the next number. 	 */
name|domain
operator|=
name|l1
operator|->
name|l1_domain_first
expr_stmt|;
name|l1
operator|->
name|l1_domain_first
operator|=
name|l1
operator|->
name|l1_domain_free
index|[
name|domain
index|]
expr_stmt|;
comment|/* 	 * If there are still free domain numbers in this L1, 	 * put it back on the TAIL of the LRU list. 	 */
if|if
condition|(
operator|++
name|l1
operator|->
name|l1_domain_use_count
operator|<
name|PMAP_DOMAINS
condition|)
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|l1_lru_list
argument_list|,
name|l1
argument_list|,
name|l1_lru
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|l1_lru_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Fix up the relevant bits in the pmap structure 	 */
name|pmap
operator|->
name|pm_l1
operator|=
name|l1
expr_stmt|;
name|pmap
operator|->
name|pm_domain
operator|=
name|domain
operator|+
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free an L1 translation table.  * This is called at pmap destruction time.  */
end_comment

begin_function
specifier|static
name|void
name|pmap_free_l1
parameter_list|(
name|pmap_t
name|pmap
parameter_list|)
block|{
name|struct
name|l1_ttable
modifier|*
name|l1
init|=
name|pmap
operator|->
name|pm_l1
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|l1_lru_lock
argument_list|)
expr_stmt|;
comment|/* 	 * If this L1 is currently on the LRU list, remove it. 	 */
if|if
condition|(
name|l1
operator|->
name|l1_domain_use_count
operator|<
name|PMAP_DOMAINS
condition|)
name|TAILQ_REMOVE
argument_list|(
operator|&
name|l1_lru_list
argument_list|,
name|l1
argument_list|,
name|l1_lru
argument_list|)
expr_stmt|;
comment|/* 	 * Free up the domain number which was allocated to the pmap 	 */
name|l1
operator|->
name|l1_domain_free
index|[
name|pmap
operator|->
name|pm_domain
operator|-
literal|1
index|]
operator|=
name|l1
operator|->
name|l1_domain_first
expr_stmt|;
name|l1
operator|->
name|l1_domain_first
operator|=
name|pmap
operator|->
name|pm_domain
operator|-
literal|1
expr_stmt|;
name|l1
operator|->
name|l1_domain_use_count
operator|--
expr_stmt|;
comment|/* 	 * The L1 now must have at least 1 free domain, so add 	 * it back to the LRU list. If the use count is zero, 	 * put it at the head of the list, otherwise it goes 	 * to the tail. 	 */
if|if
condition|(
name|l1
operator|->
name|l1_domain_use_count
operator|==
literal|0
condition|)
block|{
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|l1_lru_list
argument_list|,
name|l1
argument_list|,
name|l1_lru
argument_list|)
expr_stmt|;
block|}
else|else
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|l1_lru_list
argument_list|,
name|l1
argument_list|,
name|l1_lru
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|l1_lru_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Returns a pointer to the L2 bucket associated with the specified pmap  * and VA, or NULL if no L2 bucket exists for the address.  */
end_comment

begin_expr_stmt
specifier|static
name|PMAP_INLINE
expr|struct
name|l2_bucket
operator|*
name|pmap_get_l2_bucket
argument_list|(
argument|pmap_t pmap
argument_list|,
argument|vm_offset_t va
argument_list|)
block|{ 	struct
name|l2_dtable
operator|*
name|l2
block|; 	struct
name|l2_bucket
operator|*
name|l2b
block|;
name|u_short
name|l1idx
block|;
name|l1idx
operator|=
name|L1_IDX
argument_list|(
name|va
argument_list|)
block|;
if|if
condition|(
operator|(
name|l2
operator|=
name|pmap
operator|->
name|pm_l2
index|[
name|L2_IDX
argument_list|(
name|l1idx
argument_list|)
index|]
operator|)
operator|==
name|NULL
operator|||
operator|(
name|l2b
operator|=
operator|&
name|l2
operator|->
name|l2_bucket
index|[
name|L2_BUCKET
argument_list|(
name|l1idx
argument_list|)
index|]
operator|)
operator|->
name|l2b_kva
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
end_expr_stmt

begin_return
return|return
operator|(
name|l2b
operator|)
return|;
end_return

begin_comment
unit|}
comment|/*  * Returns a pointer to the L2 bucket associated with the specified pmap  * and VA.  *  * If no L2 bucket exists, perform the necessary allocations to put an L2  * bucket/page table in place.  *  * Note that if a new L2 bucket/page was allocated, the caller *must*  * increment the bucket occupancy counter appropriately *before*  * releasing the pmap's lock to ensure no other thread or cpu deallocates  * the bucket/page in the meantime.  */
end_comment

begin_function
unit|static
name|struct
name|l2_bucket
modifier|*
name|pmap_alloc_l2_bucket
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|struct
name|l2_dtable
modifier|*
name|l2
decl_stmt|;
name|struct
name|l2_bucket
modifier|*
name|l2b
decl_stmt|;
name|u_short
name|l1idx
decl_stmt|;
name|l1idx
operator|=
name|L1_IDX
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|PMAP_ASSERT_LOCKED
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|rw_assert
argument_list|(
operator|&
name|pvh_global_lock
argument_list|,
name|RA_WLOCKED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|l2
operator|=
name|pmap
operator|->
name|pm_l2
index|[
name|L2_IDX
argument_list|(
name|l1idx
argument_list|)
index|]
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * No mapping at this address, as there is 		 * no entry in the L1 table. 		 * Need to allocate a new l2_dtable. 		 */
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|l2
operator|=
name|uma_zalloc
argument_list|(
name|l2table_zone
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap
operator|->
name|pm_l2
index|[
name|L2_IDX
argument_list|(
name|l1idx
argument_list|)
index|]
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * Someone already allocated the l2_dtable while 			 * we were doing the same. 			 */
name|uma_zfree
argument_list|(
name|l2table_zone
argument_list|,
name|l2
argument_list|)
expr_stmt|;
name|l2
operator|=
name|pmap
operator|->
name|pm_l2
index|[
name|L2_IDX
argument_list|(
name|l1idx
argument_list|)
index|]
expr_stmt|;
block|}
else|else
block|{
name|bzero
argument_list|(
name|l2
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|l2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 			 * Link it into the parent pmap 			 */
name|pmap
operator|->
name|pm_l2
index|[
name|L2_IDX
argument_list|(
name|l1idx
argument_list|)
index|]
operator|=
name|l2
expr_stmt|;
block|}
block|}
name|l2b
operator|=
operator|&
name|l2
operator|->
name|l2_bucket
index|[
name|L2_BUCKET
argument_list|(
name|l1idx
argument_list|)
index|]
expr_stmt|;
comment|/* 	 * Fetch pointer to the L2 page table associated with the address. 	 */
if|if
condition|(
name|l2b
operator|->
name|l2b_kva
operator|==
name|NULL
condition|)
block|{
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|;
comment|/* 		 * No L2 page table has been allocated. Chances are, this 		 * is because we just allocated the l2_dtable, above. 		 */
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|ptep
operator|=
name|uma_zalloc
argument_list|(
name|l2zone
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|l2b
operator|->
name|l2b_kva
operator|!=
literal|0
condition|)
block|{
comment|/* We lost the race. */
name|uma_zfree
argument_list|(
name|l2zone
argument_list|,
name|ptep
argument_list|)
expr_stmt|;
return|return
operator|(
name|l2b
operator|)
return|;
block|}
name|l2b
operator|->
name|l2b_phys
operator|=
name|vtophys
argument_list|(
name|ptep
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptep
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * Oops, no more L2 page tables available at this 			 * time. We may need to deallocate the l2_dtable 			 * if we allocated a new one above. 			 */
if|if
condition|(
name|l2
operator|->
name|l2_occupancy
operator|==
literal|0
condition|)
block|{
name|pmap
operator|->
name|pm_l2
index|[
name|L2_IDX
argument_list|(
name|l1idx
argument_list|)
index|]
operator|=
name|NULL
expr_stmt|;
name|uma_zfree
argument_list|(
name|l2table_zone
argument_list|,
name|l2
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|l2
operator|->
name|l2_occupancy
operator|++
expr_stmt|;
name|l2b
operator|->
name|l2b_kva
operator|=
name|ptep
expr_stmt|;
name|l2b
operator|->
name|l2b_l1idx
operator|=
name|l1idx
expr_stmt|;
block|}
return|return
operator|(
name|l2b
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|PMAP_INLINE
name|void
name|pmap_free_l2_ptp
parameter_list|(
name|pt_entry_t
modifier|*
name|l2
parameter_list|)
block|{
name|uma_zfree
argument_list|(
name|l2zone
argument_list|,
name|l2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * One or more mappings in the specified L2 descriptor table have just been  * invalidated.  *  * Garbage collect the metadata and descriptor table itself if necessary.  *  * The pmap lock must be acquired when this is called (not necessary  * for the kernel pmap).  */
end_comment

begin_function
specifier|static
name|void
name|pmap_free_l2_bucket
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|struct
name|l2_bucket
modifier|*
name|l2b
parameter_list|,
name|u_int
name|count
parameter_list|)
block|{
name|struct
name|l2_dtable
modifier|*
name|l2
decl_stmt|;
name|pd_entry_t
modifier|*
name|pl1pd
decl_stmt|,
name|l1pd
decl_stmt|;
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|;
name|u_short
name|l1idx
decl_stmt|;
comment|/* 	 * Update the bucket's reference count according to how many 	 * PTEs the caller has just invalidated. 	 */
name|l2b
operator|->
name|l2b_occupancy
operator|-=
name|count
expr_stmt|;
comment|/* 	 * Note: 	 * 	 * Level 2 page tables allocated to the kernel pmap are never freed 	 * as that would require checking all Level 1 page tables and 	 * removing any references to the Level 2 page table. See also the 	 * comment elsewhere about never freeing bootstrap L2 descriptors. 	 * 	 * We make do with just invalidating the mapping in the L2 table. 	 * 	 * This isn't really a big deal in practice and, in fact, leads 	 * to a performance win over time as we don't need to continually 	 * alloc/free. 	 */
if|if
condition|(
name|l2b
operator|->
name|l2b_occupancy
operator|>
literal|0
operator|||
name|pmap
operator|==
name|pmap_kernel
argument_list|()
condition|)
return|return;
comment|/* 	 * There are no more valid mappings in this level 2 page table. 	 * Go ahead and NULL-out the pointer in the bucket, then 	 * free the page table. 	 */
name|l1idx
operator|=
name|l2b
operator|->
name|l2b_l1idx
expr_stmt|;
name|ptep
operator|=
name|l2b
operator|->
name|l2b_kva
expr_stmt|;
name|l2b
operator|->
name|l2b_kva
operator|=
name|NULL
expr_stmt|;
name|pl1pd
operator|=
operator|&
name|pmap
operator|->
name|pm_l1
operator|->
name|l1_kva
index|[
name|l1idx
index|]
expr_stmt|;
comment|/* 	 * If the L1 slot matches the pmap's domain 	 * number, then invalidate it. 	 */
name|l1pd
operator|=
operator|*
name|pl1pd
operator|&
operator|(
name|L1_TYPE_MASK
operator||
name|L1_C_DOM_MASK
operator|)
expr_stmt|;
if|if
condition|(
name|l1pd
operator|==
operator|(
name|L1_C_DOM
argument_list|(
name|pmap
operator|->
name|pm_domain
argument_list|)
operator||
name|L1_TYPE_C
operator|)
condition|)
block|{
operator|*
name|pl1pd
operator|=
literal|0
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|pl1pd
argument_list|)
expr_stmt|;
name|cpu_tlb_flushD_SE
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|ptep
argument_list|)
expr_stmt|;
name|cpu_cpwait
argument_list|()
expr_stmt|;
block|}
comment|/* 	 * Release the L2 descriptor table back to the pool cache. 	 */
name|pmap_free_l2_ptp
argument_list|(
name|ptep
argument_list|)
expr_stmt|;
comment|/* 	 * Update the reference count in the associated l2_dtable 	 */
name|l2
operator|=
name|pmap
operator|->
name|pm_l2
index|[
name|L2_IDX
argument_list|(
name|l1idx
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|--
name|l2
operator|->
name|l2_occupancy
operator|>
literal|0
condition|)
return|return;
comment|/* 	 * There are no more valid mappings in any of the Level 1 	 * slots managed by this l2_dtable. Go ahead and NULL-out 	 * the pointer in the parent pmap and free the l2_dtable. 	 */
name|pmap
operator|->
name|pm_l2
index|[
name|L2_IDX
argument_list|(
name|l1idx
argument_list|)
index|]
operator|=
name|NULL
expr_stmt|;
name|uma_zfree
argument_list|(
name|l2table_zone
argument_list|,
name|l2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Pool cache constructors for L2 descriptor tables, metadata and pmap  * structures.  */
end_comment

begin_function
specifier|static
name|int
name|pmap_l2ptp_ctor
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|int
name|size
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|l2_bucket
modifier|*
name|l2b
decl_stmt|;
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|,
name|pte
decl_stmt|;
name|vm_offset_t
name|va
init|=
operator|(
name|vm_offset_t
operator|)
name|mem
operator|&
operator|~
name|PAGE_MASK
decl_stmt|;
comment|/* 	 * The mappings for these page tables were initially made using 	 * pmap_kenter() by the pool subsystem. Therefore, the cache- 	 * mode will not be right for page table mappings. To avoid 	 * polluting the pmap_kenter() code with a special case for 	 * page tables, we simply fix up the cache-mode here if it's not 	 * correct. 	 */
name|l2b
operator|=
name|pmap_get_l2_bucket
argument_list|(
name|pmap_kernel
argument_list|()
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|ptep
operator|=
operator|&
name|l2b
operator|->
name|l2b_kva
index|[
name|l2pte_index
argument_list|(
name|va
argument_list|)
index|]
expr_stmt|;
name|pte
operator|=
operator|*
name|ptep
expr_stmt|;
name|cpu_idcache_wbinv_range
argument_list|(
name|va
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|pmap_l2cache_wbinv_range
argument_list|(
name|va
argument_list|,
name|pte
operator|&
name|L2_S_FRAME
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pte
operator|&
name|L2_S_CACHE_MASK
operator|)
operator|!=
name|pte_l2_s_cache_mode_pt
condition|)
block|{
comment|/* 		 * Page tables must have the cache-mode set to 		 * Write-Thru. 		 */
operator|*
name|ptep
operator|=
operator|(
name|pte
operator|&
operator|~
name|L2_S_CACHE_MASK
operator|)
operator||
name|pte_l2_s_cache_mode_pt
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|ptep
argument_list|)
expr_stmt|;
name|cpu_tlb_flushD_SE
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|cpu_cpwait
argument_list|()
expr_stmt|;
block|}
name|memset
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|,
name|L2_TABLE_SIZE_REAL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Modify pte bits for all ptes corresponding to the given physical address.  * We use `maskbits' rather than `clearbits' because we're always passing  * constants and the latter would require an extra inversion at run-time.  */
end_comment

begin_function
specifier|static
name|int
name|pmap_clearbit
parameter_list|(
name|struct
name|vm_page
modifier|*
name|m
parameter_list|,
name|u_int
name|maskbits
parameter_list|)
block|{
name|struct
name|l2_bucket
modifier|*
name|l2b
decl_stmt|;
name|struct
name|pv_entry
modifier|*
name|pv
decl_stmt|,
modifier|*
name|pve
decl_stmt|,
modifier|*
name|next_pv
decl_stmt|;
name|struct
name|md_page
modifier|*
name|pvh
decl_stmt|;
name|pd_entry_t
modifier|*
name|pl1pd
decl_stmt|;
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|,
name|npte
decl_stmt|,
name|opte
decl_stmt|;
name|pmap_t
name|pmap
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
name|u_int
name|oflags
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_FICTITIOUS
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|small_mappings
goto|;
name|pvh
operator|=
name|pa_to_pvh
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|pv
argument_list|,
argument|&pvh->pv_list
argument_list|,
argument|pv_list
argument_list|,
argument|next_pv
argument_list|)
block|{
name|va
operator|=
name|pv
operator|->
name|pv_va
expr_stmt|;
name|pmap
operator|=
name|PV_PMAP
argument_list|(
name|pv
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|pl1pd
operator|=
operator|&
name|pmap
operator|->
name|pm_l1
operator|->
name|l1_kva
index|[
name|L1_IDX
argument_list|(
name|va
argument_list|)
index|]
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
operator|*
name|pl1pd
operator|&
name|L1_TYPE_MASK
operator|)
operator|==
name|L1_S_PROTO
argument_list|,
operator|(
literal|"pmap_clearbit: valid section mapping expected"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|maskbits
operator|&
name|PVF_WRITE
operator|)
operator|&&
operator|(
name|pv
operator|->
name|pv_flags
operator|&
name|PVF_WRITE
operator|)
condition|)
operator|(
name|void
operator|)
name|pmap_demote_section
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|maskbits
operator|&
name|PVF_REF
operator|)
operator|&&
name|L1_S_REFERENCED
argument_list|(
operator|*
name|pl1pd
argument_list|)
condition|)
block|{
if|if
condition|(
name|pmap_demote_section
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|pv
operator|->
name|pv_flags
operator|&
name|PVF_WIRED
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 					 * Remove the mapping to a single page 					 * so that a subsequent access may 					 * repromote. Since the underlying 					 * l2_bucket is fully populated, this 					 * removal never frees an entire 					 * l2_bucket. 					 */
name|va
operator|+=
operator|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
operator|&
name|L1_S_OFFSET
operator|)
expr_stmt|;
name|l2b
operator|=
name|pmap_get_l2_bucket
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|l2b
operator|!=
name|NULL
argument_list|,
operator|(
literal|"pmap_clearbit: no l2 bucket for "
literal|"va 0x%#x, pmap 0x%p"
operator|,
name|va
operator|,
name|pmap
operator|)
argument_list|)
expr_stmt|;
name|ptep
operator|=
operator|&
name|l2b
operator|->
name|l2b_kva
index|[
name|l2pte_index
argument_list|(
name|va
argument_list|)
index|]
expr_stmt|;
operator|*
name|ptep
operator|=
literal|0
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|ptep
argument_list|)
expr_stmt|;
name|pmap_free_l2_bucket
argument_list|(
name|pmap
argument_list|,
name|l2b
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pve
operator|=
name|pmap_remove_pv
argument_list|(
name|m
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pve
operator|!=
name|NULL
argument_list|,
operator|(
literal|"pmap_clearbit: "
literal|"no PV entry for managed mapping"
operator|)
argument_list|)
expr_stmt|;
name|pmap_free_pv_entry
argument_list|(
name|pmap
argument_list|,
name|pve
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|maskbits
operator|&
name|PVF_MOD
operator|)
operator|&&
name|L1_S_WRITABLE
argument_list|(
operator|*
name|pl1pd
argument_list|)
condition|)
block|{
if|if
condition|(
name|pmap_demote_section
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|pv
operator|->
name|pv_flags
operator|&
name|PVF_WIRED
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 					 * Write protect the mapping to a 					 * single page so that a subsequent 					 * write access may repromote. 					 */
name|va
operator|+=
operator|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
operator|&
name|L1_S_OFFSET
operator|)
expr_stmt|;
name|l2b
operator|=
name|pmap_get_l2_bucket
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|l2b
operator|!=
name|NULL
argument_list|,
operator|(
literal|"pmap_clearbit: no l2 bucket for "
literal|"va 0x%#x, pmap 0x%p"
operator|,
name|va
operator|,
name|pmap
operator|)
argument_list|)
expr_stmt|;
name|ptep
operator|=
operator|&
name|l2b
operator|->
name|l2b_kva
index|[
name|l2pte_index
argument_list|(
name|va
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|ptep
operator|&
name|L2_S_PROTO
operator|)
operator|!=
literal|0
condition|)
block|{
name|pve
operator|=
name|pmap_find_pv
argument_list|(
operator|&
name|m
operator|->
name|md
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pve
operator|!=
name|NULL
argument_list|,
operator|(
literal|"pmap_clearbit: no PV "
literal|"entry for managed mapping"
operator|)
argument_list|)
expr_stmt|;
name|pve
operator|->
name|pv_flags
operator|&=
operator|~
name|PVF_WRITE
expr_stmt|;
operator|*
name|ptep
operator||=
name|L2_APX
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|ptep
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
name|small_mappings
label|:
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|)
condition|)
block|{
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Loop over all current mappings setting/clearing as appropos 	 */
name|TAILQ_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&m->md.pv_list
argument_list|,
argument|pv_list
argument_list|)
block|{
name|va
operator|=
name|pv
operator|->
name|pv_va
expr_stmt|;
name|pmap
operator|=
name|PV_PMAP
argument_list|(
name|pv
argument_list|)
expr_stmt|;
name|oflags
operator|=
name|pv
operator|->
name|pv_flags
expr_stmt|;
name|pv
operator|->
name|pv_flags
operator|&=
operator|~
name|maskbits
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|l2b
operator|=
name|pmap_get_l2_bucket
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|l2b
operator|!=
name|NULL
argument_list|,
operator|(
literal|"pmap_clearbit: no l2 bucket for "
literal|"va 0x%#x, pmap 0x%p"
operator|,
name|va
operator|,
name|pmap
operator|)
argument_list|)
expr_stmt|;
name|ptep
operator|=
operator|&
name|l2b
operator|->
name|l2b_kva
index|[
name|l2pte_index
argument_list|(
name|va
argument_list|)
index|]
expr_stmt|;
name|npte
operator|=
name|opte
operator|=
operator|*
name|ptep
expr_stmt|;
if|if
condition|(
name|maskbits
operator|&
operator|(
name|PVF_WRITE
operator||
name|PVF_MOD
operator|)
condition|)
block|{
comment|/* make the pte read only */
name|npte
operator||=
name|L2_APX
expr_stmt|;
block|}
if|if
condition|(
name|maskbits
operator|&
name|PVF_REF
condition|)
block|{
comment|/* 			 * Clear referenced flag in PTE so that we 			 * will take a flag fault the next time the mapping 			 * is referenced. 			 */
name|npte
operator|&=
operator|~
name|L2_S_REF
expr_stmt|;
block|}
name|CTR4
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"clearbit: pmap:%p bits:%x pte:%x->%x"
argument_list|,
name|pmap
argument_list|,
name|maskbits
argument_list|,
name|opte
argument_list|,
name|npte
argument_list|)
expr_stmt|;
if|if
condition|(
name|npte
operator|!=
name|opte
condition|)
block|{
name|count
operator|++
expr_stmt|;
operator|*
name|ptep
operator|=
name|npte
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|ptep
argument_list|)
expr_stmt|;
comment|/* Flush the TLB entry if a current pmap. */
if|if
condition|(
name|PTE_BEEN_EXECD
argument_list|(
name|opte
argument_list|)
condition|)
name|cpu_tlb_flushID_SE
argument_list|(
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|PTE_BEEN_REFD
argument_list|(
name|opte
argument_list|)
condition|)
name|cpu_tlb_flushD_SE
argument_list|(
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
name|cpu_cpwait
argument_list|()
expr_stmt|;
block|}
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|maskbits
operator|&
name|PVF_WRITE
condition|)
name|vm_page_aflag_clear
argument_list|(
name|m
argument_list|,
name|PGA_WRITEABLE
argument_list|)
expr_stmt|;
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * main pv_entry manipulation functions:  *   pmap_enter_pv: enter a mapping onto a vm_page list  *   pmap_remove_pv: remove a mappiing from a vm_page list  *  * NOTE: pmap_enter_pv expects to lock the pvh itself  *       pmap_remove_pv expects the caller to lock the pvh before calling  */
end_comment

begin_comment
comment|/*  * pmap_enter_pv: enter a mapping onto a vm_page's PV list  *  * => caller should hold the proper lock on pvh_global_lock  * => caller should have pmap locked  * => we will (someday) gain the lock on the vm_page's PV list  * => caller should adjust ptp's wire_count before calling  * => caller should not adjust pmap's wire_count  */
end_comment

begin_function
specifier|static
name|void
name|pmap_enter_pv
parameter_list|(
name|struct
name|vm_page
modifier|*
name|m
parameter_list|,
name|struct
name|pv_entry
modifier|*
name|pve
parameter_list|,
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|u_int
name|flags
parameter_list|)
block|{
name|rw_assert
argument_list|(
operator|&
name|pvh_global_lock
argument_list|,
name|RA_WLOCKED
argument_list|)
expr_stmt|;
name|PMAP_ASSERT_LOCKED
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|pve
operator|->
name|pv_va
operator|=
name|va
expr_stmt|;
name|pve
operator|->
name|pv_flags
operator|=
name|flags
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|,
name|pve
argument_list|,
name|pv_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|pve
operator|->
name|pv_flags
operator|&
name|PVF_WIRED
condition|)
operator|++
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  * pmap_find_pv: Find a pv entry  *  * => caller should hold lock on vm_page  */
end_comment

begin_expr_stmt
specifier|static
name|PMAP_INLINE
expr|struct
name|pv_entry
operator|*
name|pmap_find_pv
argument_list|(
argument|struct md_page *md
argument_list|,
argument|pmap_t pmap
argument_list|,
argument|vm_offset_t va
argument_list|)
block|{ 	struct
name|pv_entry
operator|*
name|pv
block|;
name|rw_assert
argument_list|(
operator|&
name|pvh_global_lock
argument_list|,
name|RA_WLOCKED
argument_list|)
block|;
name|TAILQ_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&md->pv_list
argument_list|,
argument|pv_list
argument_list|)
if|if
condition|(
name|pmap
operator|==
name|PV_PMAP
argument_list|(
name|pv
argument_list|)
operator|&&
name|va
operator|==
name|pv
operator|->
name|pv_va
condition|)
break|break;
end_expr_stmt

begin_return
return|return
operator|(
name|pv
operator|)
return|;
end_return

begin_comment
unit|}
comment|/*  * vector_page_setprot:  *  *	Manipulate the protection of the vector page.  */
end_comment

begin_macro
unit|void
name|vector_page_setprot
argument_list|(
argument|int prot
argument_list|)
end_macro

begin_block
block|{
name|struct
name|l2_bucket
modifier|*
name|l2b
decl_stmt|;
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|;
name|l2b
operator|=
name|pmap_get_l2_bucket
argument_list|(
name|pmap_kernel
argument_list|()
argument_list|,
name|vector_page
argument_list|)
expr_stmt|;
name|ptep
operator|=
operator|&
name|l2b
operator|->
name|l2b_kva
index|[
name|l2pte_index
argument_list|(
name|vector_page
argument_list|)
index|]
expr_stmt|;
comment|/* 	 * Set referenced flag. 	 * Vectors' page is always desired 	 * to be allowed to reside in TLB.  	 */
operator|*
name|ptep
operator||=
name|L2_S_REF
expr_stmt|;
name|pmap_set_prot
argument_list|(
name|ptep
argument_list|,
name|prot
operator||
name|VM_PROT_EXECUTE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|ptep
argument_list|)
expr_stmt|;
name|cpu_tlb_flushID_SE
argument_list|(
name|vector_page
argument_list|)
expr_stmt|;
name|cpu_cpwait
argument_list|()
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|void
name|pmap_set_prot
parameter_list|(
name|pt_entry_t
modifier|*
name|ptep
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|,
name|uint8_t
name|user
parameter_list|)
block|{
operator|*
name|ptep
operator|&=
operator|~
operator|(
name|L2_S_PROT_MASK
operator||
name|L2_XN
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|prot
operator|&
name|VM_PROT_EXECUTE
operator|)
condition|)
operator|*
name|ptep
operator||=
name|L2_XN
expr_stmt|;
comment|/* Set defaults first - kernel read access */
operator|*
name|ptep
operator||=
name|L2_APX
expr_stmt|;
operator|*
name|ptep
operator||=
name|L2_S_PROT_R
expr_stmt|;
comment|/* Now tune APs as desired */
if|if
condition|(
name|user
condition|)
operator|*
name|ptep
operator||=
name|L2_S_PROT_U
expr_stmt|;
if|if
condition|(
name|prot
operator|&
name|VM_PROT_WRITE
condition|)
operator|*
name|ptep
operator|&=
operator|~
operator|(
name|L2_APX
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * pmap_remove_pv: try to remove a mapping from a pv_list  *  * => caller should hold proper lock on pmap_main_lock  * => pmap should be locked  * => caller should hold lock on vm_page [so that attrs can be adjusted]  * => caller should adjust ptp's wire_count and free PTP if needed  * => caller should NOT adjust pmap's wire_count  * => we return the removed pve  */
end_comment

begin_function
specifier|static
name|struct
name|pv_entry
modifier|*
name|pmap_remove_pv
parameter_list|(
name|struct
name|vm_page
modifier|*
name|m
parameter_list|,
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|struct
name|pv_entry
modifier|*
name|pve
decl_stmt|;
name|rw_assert
argument_list|(
operator|&
name|pvh_global_lock
argument_list|,
name|RA_WLOCKED
argument_list|)
expr_stmt|;
name|PMAP_ASSERT_LOCKED
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|pve
operator|=
name|pmap_find_pv
argument_list|(
operator|&
name|m
operator|->
name|md
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
comment|/* find corresponding pve */
if|if
condition|(
name|pve
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|,
name|pve
argument_list|,
name|pv_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|pve
operator|->
name|pv_flags
operator|&
name|PVF_WIRED
condition|)
operator|--
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
expr_stmt|;
block|}
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|)
condition|)
name|vm_page_aflag_clear
argument_list|(
name|m
argument_list|,
name|PGA_WRITEABLE
argument_list|)
expr_stmt|;
return|return
operator|(
name|pve
operator|)
return|;
comment|/* return removed pve */
block|}
end_function

begin_comment
comment|/*  *  * pmap_modify_pv: Update pv flags  *  * => caller should hold lock on vm_page [so that attrs can be adjusted]  * => caller should NOT adjust pmap's wire_count  * => we return the old flags  *  * Modify a physical-virtual mapping in the pv table  */
end_comment

begin_function
specifier|static
name|u_int
name|pmap_modify_pv
parameter_list|(
name|struct
name|vm_page
modifier|*
name|m
parameter_list|,
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|u_int
name|clr_mask
parameter_list|,
name|u_int
name|set_mask
parameter_list|)
block|{
name|struct
name|pv_entry
modifier|*
name|npv
decl_stmt|;
name|u_int
name|flags
decl_stmt|,
name|oflags
decl_stmt|;
name|PMAP_ASSERT_LOCKED
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|rw_assert
argument_list|(
operator|&
name|pvh_global_lock
argument_list|,
name|RA_WLOCKED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|npv
operator|=
name|pmap_find_pv
argument_list|(
operator|&
name|m
operator|->
name|md
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * There is at least one VA mapping this page. 	 */
name|oflags
operator|=
name|npv
operator|->
name|pv_flags
expr_stmt|;
name|npv
operator|->
name|pv_flags
operator|=
name|flags
operator|=
operator|(
name|oflags
operator|&
operator|~
name|clr_mask
operator|)
operator||
name|set_mask
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|^
name|oflags
operator|)
operator|&
name|PVF_WIRED
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|PVF_WIRED
condition|)
operator|++
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
expr_stmt|;
else|else
operator|--
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
expr_stmt|;
block|}
return|return
operator|(
name|oflags
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Function to set the debug level of the pmap code */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PMAP_DEBUG
end_ifdef

begin_function
name|void
name|pmap_debug
parameter_list|(
name|int
name|level
parameter_list|)
block|{
name|pmap_debug_level
operator|=
name|level
expr_stmt|;
name|dprintf
argument_list|(
literal|"pmap_debug: level=%d\n"
argument_list|,
name|pmap_debug_level
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PMAP_DEBUG */
end_comment

begin_function
name|void
name|pmap_pinit0
parameter_list|(
name|struct
name|pmap
modifier|*
name|pmap
parameter_list|)
block|{
name|PDEBUG
argument_list|(
literal|1
argument_list|,
name|printf
argument_list|(
literal|"pmap_pinit0: pmap = %08x\n"
argument_list|,
operator|(
name|u_int32_t
operator|)
name|pmap
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|kernel_pmap
argument_list|,
name|pmap
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pmap
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|pmap
operator|->
name|pm_mtx
argument_list|,
sizeof|sizeof
argument_list|(
name|pmap
operator|->
name|pm_mtx
argument_list|)
argument_list|)
expr_stmt|;
name|PMAP_LOCK_INIT
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvchunk
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Initialize a vm_page's machine-dependent fields.  */
end_comment

begin_function
name|void
name|pmap_page_init
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|TAILQ_INIT
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|)
expr_stmt|;
name|m
operator|->
name|md
operator|.
name|pv_memattr
operator|=
name|VM_MEMATTR_DEFAULT
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|vm_offset_t
name|pmap_ptelist_alloc
parameter_list|(
name|vm_offset_t
modifier|*
name|head
parameter_list|)
block|{
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
name|va
operator|=
operator|*
name|head
expr_stmt|;
if|if
condition|(
name|va
operator|==
literal|0
condition|)
return|return
operator|(
name|va
operator|)
return|;
comment|/* Out of memory */
name|pte
operator|=
name|vtopte
argument_list|(
name|va
argument_list|)
expr_stmt|;
operator|*
name|head
operator|=
operator|*
name|pte
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|head
operator|&
name|L2_TYPE_MASK
operator|)
operator|!=
name|L2_TYPE_INV
condition|)
name|panic
argument_list|(
literal|"%s: va is not L2_TYPE_INV!"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
operator|*
name|pte
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|va
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pmap_ptelist_free
parameter_list|(
name|vm_offset_t
modifier|*
name|head
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
if|if
condition|(
operator|(
name|va
operator|&
name|L2_TYPE_MASK
operator|)
operator|!=
name|L2_TYPE_INV
condition|)
name|panic
argument_list|(
literal|"%s: freeing va that is not L2_TYPE INV!"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|pte
operator|=
name|vtopte
argument_list|(
name|va
argument_list|)
expr_stmt|;
operator|*
name|pte
operator|=
operator|*
name|head
expr_stmt|;
comment|/* virtual! L2_TYPE is L2_TYPE_INV though */
operator|*
name|head
operator|=
name|va
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pmap_ptelist_init
parameter_list|(
name|vm_offset_t
modifier|*
name|head
parameter_list|,
name|void
modifier|*
name|base
parameter_list|,
name|int
name|npages
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
operator|*
name|head
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|npages
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|va
operator|=
operator|(
name|vm_offset_t
operator|)
name|base
operator|+
name|i
operator|*
name|PAGE_SIZE
expr_stmt|;
name|pmap_ptelist_free
argument_list|(
name|head
argument_list|,
name|va
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *      Initialize the pmap module.  *      Called by vm_init, to initialize any structures that the pmap  *      system needs to map virtual memory.  */
end_comment

begin_function
name|void
name|pmap_init
parameter_list|(
name|void
parameter_list|)
block|{
name|vm_size_t
name|s
decl_stmt|;
name|int
name|i
decl_stmt|,
name|pv_npg
decl_stmt|;
name|l2zone
operator|=
name|uma_zcreate
argument_list|(
literal|"L2 Table"
argument_list|,
name|L2_TABLE_SIZE_REAL
argument_list|,
name|pmap_l2ptp_ctor
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
name|UMA_ZONE_VM
operator||
name|UMA_ZONE_NOFREE
argument_list|)
expr_stmt|;
name|l2table_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"L2 Table"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|l2_dtable
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
name|UMA_ZONE_VM
operator||
name|UMA_ZONE_NOFREE
argument_list|)
expr_stmt|;
comment|/* 	 * Are large page mappings supported and enabled? 	 */
name|TUNABLE_INT_FETCH
argument_list|(
literal|"vm.pmap.sp_enabled"
argument_list|,
operator|&
name|sp_enabled
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp_enabled
condition|)
block|{
name|KASSERT
argument_list|(
name|MAXPAGESIZES
operator|>
literal|1
operator|&&
name|pagesizes
index|[
literal|1
index|]
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_init: can't assign to pagesizes[1]"
operator|)
argument_list|)
expr_stmt|;
name|pagesizes
index|[
literal|1
index|]
operator|=
name|NBPDR
expr_stmt|;
block|}
comment|/* 	 * Calculate the size of the pv head table for superpages. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|phys_avail
index|[
name|i
operator|+
literal|1
index|]
condition|;
name|i
operator|+=
literal|2
control|)
empty_stmt|;
name|pv_npg
operator|=
name|round_1mpage
argument_list|(
name|phys_avail
index|[
operator|(
name|i
operator|-
literal|2
operator|)
operator|+
literal|1
index|]
argument_list|)
operator|/
name|NBPDR
expr_stmt|;
comment|/* 	 * Allocate memory for the pv head table for superpages. 	 */
name|s
operator|=
call|(
name|vm_size_t
call|)
argument_list|(
name|pv_npg
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|md_page
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|round_page
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|pv_table
operator|=
operator|(
expr|struct
name|md_page
operator|*
operator|)
name|kmem_malloc
argument_list|(
name|kernel_arena
argument_list|,
name|s
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pv_npg
condition|;
name|i
operator|++
control|)
name|TAILQ_INIT
argument_list|(
operator|&
name|pv_table
index|[
name|i
index|]
operator|.
name|pv_list
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize the address space for the pv chunks. 	 */
name|TUNABLE_INT_FETCH
argument_list|(
literal|"vm.pmap.shpgperproc"
argument_list|,
operator|&
name|shpgperproc
argument_list|)
expr_stmt|;
name|pv_entry_max
operator|=
name|shpgperproc
operator|*
name|maxproc
operator|+
name|vm_cnt
operator|.
name|v_page_count
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"vm.pmap.pv_entries"
argument_list|,
operator|&
name|pv_entry_max
argument_list|)
expr_stmt|;
name|pv_entry_max
operator|=
name|roundup
argument_list|(
name|pv_entry_max
argument_list|,
name|_NPCPV
argument_list|)
expr_stmt|;
name|pv_entry_high_water
operator|=
literal|9
operator|*
operator|(
name|pv_entry_max
operator|/
literal|10
operator|)
expr_stmt|;
name|pv_maxchunks
operator|=
name|MAX
argument_list|(
name|pv_entry_max
operator|/
name|_NPCPV
argument_list|,
name|maxproc
argument_list|)
expr_stmt|;
name|pv_chunkbase
operator|=
operator|(
expr|struct
name|pv_chunk
operator|*
operator|)
name|kva_alloc
argument_list|(
name|PAGE_SIZE
operator|*
name|pv_maxchunks
argument_list|)
expr_stmt|;
if|if
condition|(
name|pv_chunkbase
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"pmap_init: not enough kvm for pv chunks"
argument_list|)
expr_stmt|;
name|pmap_ptelist_init
argument_list|(
operator|&
name|pv_vafree
argument_list|,
name|pv_chunkbase
argument_list|,
name|pv_maxchunks
argument_list|)
expr_stmt|;
comment|/* 	 * Now it is safe to enable pv_table recording. 	 */
name|PDEBUG
argument_list|(
literal|1
argument_list|,
name|printf
argument_list|(
literal|"pmap_init: done!\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vm_pmap
argument_list|,
name|OID_AUTO
argument_list|,
name|pv_entry_max
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pv_entry_max
argument_list|,
literal|0
argument_list|,
literal|"Max number of PV entries"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vm_pmap
argument_list|,
name|OID_AUTO
argument_list|,
name|shpgperproc
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|shpgperproc
argument_list|,
literal|0
argument_list|,
literal|"Page share factor per proc"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_vm_pmap
argument_list|,
name|OID_AUTO
argument_list|,
name|section
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"1MB page mapping counters"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_long
name|pmap_section_demotions
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_ULONG
argument_list|(
name|_vm_pmap_section
argument_list|,
name|OID_AUTO
argument_list|,
name|demotions
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pmap_section_demotions
argument_list|,
literal|0
argument_list|,
literal|"1MB page demotions"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_long
name|pmap_section_mappings
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_ULONG
argument_list|(
name|_vm_pmap_section
argument_list|,
name|OID_AUTO
argument_list|,
name|mappings
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pmap_section_mappings
argument_list|,
literal|0
argument_list|,
literal|"1MB page mappings"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_long
name|pmap_section_p_failures
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_ULONG
argument_list|(
name|_vm_pmap_section
argument_list|,
name|OID_AUTO
argument_list|,
name|p_failures
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pmap_section_p_failures
argument_list|,
literal|0
argument_list|,
literal|"1MB page promotion failures"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_long
name|pmap_section_promotions
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_ULONG
argument_list|(
name|_vm_pmap_section
argument_list|,
name|OID_AUTO
argument_list|,
name|promotions
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pmap_section_promotions
argument_list|,
literal|0
argument_list|,
literal|"1MB page promotions"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|pmap_fault_fixup
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_prot_t
name|ftype
parameter_list|,
name|int
name|user
parameter_list|)
block|{
name|struct
name|l2_dtable
modifier|*
name|l2
decl_stmt|;
name|struct
name|l2_bucket
modifier|*
name|l2b
decl_stmt|;
name|pd_entry_t
modifier|*
name|pl1pd
decl_stmt|,
name|l1pd
decl_stmt|;
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|,
name|pte
decl_stmt|;
name|vm_paddr_t
name|pa
decl_stmt|;
name|u_int
name|l1idx
decl_stmt|;
name|int
name|rv
init|=
literal|0
decl_stmt|;
name|l1idx
operator|=
name|L1_IDX
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
comment|/* 	 * Check and possibly fix-up L1 section mapping 	 * only when superpage mappings are enabled to speed up. 	 */
if|if
condition|(
name|sp_enabled
condition|)
block|{
name|pl1pd
operator|=
operator|&
name|pmap
operator|->
name|pm_l1
operator|->
name|l1_kva
index|[
name|l1idx
index|]
expr_stmt|;
name|l1pd
operator|=
operator|*
name|pl1pd
expr_stmt|;
if|if
condition|(
operator|(
name|l1pd
operator|&
name|L1_TYPE_MASK
operator|)
operator|==
name|L1_S_PROTO
condition|)
block|{
comment|/* Catch an access to the vectors section */
if|if
condition|(
name|l1idx
operator|==
name|L1_IDX
argument_list|(
name|vector_page
argument_list|)
condition|)
goto|goto
name|out
goto|;
comment|/* 			 * Stay away from the kernel mappings. 			 * None of them should fault from L1 entry. 			 */
if|if
condition|(
name|pmap
operator|==
name|pmap_kernel
argument_list|()
condition|)
goto|goto
name|out
goto|;
comment|/* 			 * Catch a forbidden userland access 			 */
if|if
condition|(
name|user
operator|&&
operator|!
operator|(
name|l1pd
operator|&
name|L1_S_PROT_U
operator|)
condition|)
goto|goto
name|out
goto|;
comment|/* 			 * Superpage is always either mapped read only 			 * or it is modified and permitted to be written 			 * by default. Therefore, process only reference 			 * flag fault and demote page in case of write fault. 			 */
if|if
condition|(
operator|(
name|ftype
operator|&
name|VM_PROT_WRITE
operator|)
operator|&&
operator|!
name|L1_S_WRITABLE
argument_list|(
name|l1pd
argument_list|)
operator|&&
name|L1_S_REFERENCED
argument_list|(
name|l1pd
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|pmap_demote_section
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
elseif|else
if|if
condition|(
operator|!
name|L1_S_REFERENCED
argument_list|(
name|l1pd
argument_list|)
condition|)
block|{
comment|/* Mark the page "referenced" */
operator|*
name|pl1pd
operator|=
name|l1pd
operator||
name|L1_S_REF
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|pl1pd
argument_list|)
expr_stmt|;
goto|goto
name|l1_section_out
goto|;
block|}
else|else
goto|goto
name|out
goto|;
block|}
block|}
comment|/* 	 * If there is no l2_dtable for this address, then the process 	 * has no business accessing it. 	 * 	 * Note: This will catch userland processes trying to access 	 * kernel addresses. 	 */
name|l2
operator|=
name|pmap
operator|->
name|pm_l2
index|[
name|L2_IDX
argument_list|(
name|l1idx
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|l2
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * Likewise if there is no L2 descriptor table 	 */
name|l2b
operator|=
operator|&
name|l2
operator|->
name|l2_bucket
index|[
name|L2_BUCKET
argument_list|(
name|l1idx
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|l2b
operator|->
name|l2b_kva
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * Check the PTE itself. 	 */
name|ptep
operator|=
operator|&
name|l2b
operator|->
name|l2b_kva
index|[
name|l2pte_index
argument_list|(
name|va
argument_list|)
index|]
expr_stmt|;
name|pte
operator|=
operator|*
name|ptep
expr_stmt|;
if|if
condition|(
name|pte
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * Catch a userland access to the vector page mapped at 0x0 	 */
if|if
condition|(
name|user
operator|&&
operator|!
operator|(
name|pte
operator|&
name|L2_S_PROT_U
operator|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|va
operator|==
name|vector_page
condition|)
goto|goto
name|out
goto|;
name|pa
operator|=
name|l2pte_pa
argument_list|(
name|pte
argument_list|)
expr_stmt|;
name|CTR5
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"pmap_fault_fix: pmap:%p va:%x pte:0x%x ftype:%x user:%x"
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|,
name|pte
argument_list|,
name|ftype
argument_list|,
name|user
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ftype
operator|&
name|VM_PROT_WRITE
operator|)
operator|&&
operator|!
operator|(
name|L2_S_WRITABLE
argument_list|(
name|pte
argument_list|)
operator|)
operator|&&
name|L2_S_REFERENCED
argument_list|(
name|pte
argument_list|)
condition|)
block|{
comment|/* 		 * This looks like a good candidate for "page modified" 		 * emulation... 		 */
name|struct
name|pv_entry
modifier|*
name|pv
decl_stmt|;
name|struct
name|vm_page
modifier|*
name|m
decl_stmt|;
comment|/* Extract the physical address of the page */
if|if
condition|(
operator|(
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pa
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
goto|goto
name|out
goto|;
block|}
comment|/* Get the current flags for this page. */
name|pv
operator|=
name|pmap_find_pv
argument_list|(
operator|&
name|m
operator|->
name|md
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|pv
operator|==
name|NULL
condition|)
block|{
goto|goto
name|out
goto|;
block|}
comment|/* 		 * Do the flags say this page is writable? If not then it 		 * is a genuine write fault. If yes then the write fault is 		 * our fault as we did not reflect the write access in the 		 * PTE. Now we know a write has occurred we can correct this 		 * and also set the modified bit 		 */
if|if
condition|(
operator|(
name|pv
operator|->
name|pv_flags
operator|&
name|PVF_WRITE
operator|)
operator|==
literal|0
condition|)
block|{
goto|goto
name|out
goto|;
block|}
name|vm_page_dirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* Re-enable write permissions for the page */
operator|*
name|ptep
operator|=
operator|(
name|pte
operator|&
operator|~
name|L2_APX
operator|)
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|ptep
argument_list|)
expr_stmt|;
name|rv
operator|=
literal|1
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"pmap_fault_fix: new pte:0x%x"
argument_list|,
operator|*
name|ptep
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|L2_S_REFERENCED
argument_list|(
name|pte
argument_list|)
condition|)
block|{
comment|/* 		 * This looks like a good candidate for "page referenced" 		 * emulation. 		 */
name|struct
name|pv_entry
modifier|*
name|pv
decl_stmt|;
name|struct
name|vm_page
modifier|*
name|m
decl_stmt|;
comment|/* Extract the physical address of the page */
if|if
condition|(
operator|(
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pa
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
comment|/* Get the current flags for this page. */
name|pv
operator|=
name|pmap_find_pv
argument_list|(
operator|&
name|m
operator|->
name|md
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|pv
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
name|vm_page_aflag_set
argument_list|(
name|m
argument_list|,
name|PGA_REFERENCED
argument_list|)
expr_stmt|;
comment|/* Mark the page "referenced" */
operator|*
name|ptep
operator|=
name|pte
operator||
name|L2_S_REF
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|ptep
argument_list|)
expr_stmt|;
name|rv
operator|=
literal|1
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"pmap_fault_fix: new pte:0x%x"
argument_list|,
operator|*
name|ptep
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * We know there is a valid mapping here, so simply 	 * fix up the L1 if necessary. 	 */
name|pl1pd
operator|=
operator|&
name|pmap
operator|->
name|pm_l1
operator|->
name|l1_kva
index|[
name|l1idx
index|]
expr_stmt|;
name|l1pd
operator|=
name|l2b
operator|->
name|l2b_phys
operator||
name|L1_C_DOM
argument_list|(
name|pmap
operator|->
name|pm_domain
argument_list|)
operator||
name|L1_C_PROTO
expr_stmt|;
if|if
condition|(
operator|*
name|pl1pd
operator|!=
name|l1pd
condition|)
block|{
operator|*
name|pl1pd
operator|=
name|l1pd
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|pl1pd
argument_list|)
expr_stmt|;
name|rv
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
comment|/* 	 * If 'rv == 0' at this point, it generally indicates that there is a 	 * stale TLB entry for the faulting address. This happens when two or 	 * more processes are sharing an L1. Since we don't flush the TLB on 	 * a context switch between such processes, we can take domain faults 	 * for mappings which exist at the same VA in both processes. EVEN IF 	 * WE'VE RECENTLY FIXED UP THE CORRESPONDING L1 in pmap_enter(), for 	 * example. 	 * 	 * This is extremely likely to happen if pmap_enter() updated the L1 	 * entry for a recently entered mapping. In this case, the TLB is 	 * flushed for the new mapping, but there may still be TLB entries for 	 * other mappings belonging to other processes in the 1MB range 	 * covered by the L1 entry. 	 * 	 * Since 'rv == 0', we know that the L1 already contains the correct 	 * value, so the fault must be due to a stale TLB entry. 	 * 	 * Since we always need to flush the TLB anyway in the case where we 	 * fixed up the L1, or frobbed the L2 PTE, we effectively deal with 	 * stale TLB entries dynamically. 	 * 	 * However, the above condition can ONLY happen if the current L1 is 	 * being shared. If it happens when the L1 is unshared, it indicates 	 * that other parts of the pmap are not doing their job WRT managing 	 * the TLB. 	 */
if|if
condition|(
name|rv
operator|==
literal|0
operator|&&
name|pmap
operator|->
name|pm_l1
operator|->
name|l1_domain_use_count
operator|==
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"fixup: pmap %p, va 0x%08x, ftype %d - nothing to do!\n"
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|,
name|ftype
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"fixup: l2 %p, l2b %p, ptep %p, pl1pd %p\n"
argument_list|,
name|l2
argument_list|,
name|l2b
argument_list|,
name|ptep
argument_list|,
name|pl1pd
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"fixup: pte 0x%x, l1pd 0x%x, last code 0x%x\n"
argument_list|,
name|pte
argument_list|,
name|l1pd
argument_list|,
name|last_fault_code
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DDB
name|Debugger
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
name|l1_section_out
label|:
name|cpu_tlb_flushID_SE
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|cpu_cpwait
argument_list|()
expr_stmt|;
name|rv
operator|=
literal|1
expr_stmt|;
name|out
label|:
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pmap_postinit
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|l2_bucket
modifier|*
name|l2b
decl_stmt|;
name|struct
name|l1_ttable
modifier|*
name|l1
decl_stmt|;
name|pd_entry_t
modifier|*
name|pl1pt
decl_stmt|;
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|,
name|pte
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|,
name|eva
decl_stmt|;
name|u_int
name|loop
decl_stmt|,
name|needed
decl_stmt|;
name|needed
operator|=
operator|(
name|maxproc
operator|/
name|PMAP_DOMAINS
operator|)
operator|+
operator|(
operator|(
name|maxproc
operator|%
name|PMAP_DOMAINS
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
name|needed
operator|-=
literal|1
expr_stmt|;
name|l1
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|l1
argument_list|)
operator|*
name|needed
argument_list|,
name|M_VMPMAP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
for|for
control|(
name|loop
operator|=
literal|0
init|;
name|loop
operator|<
name|needed
condition|;
name|loop
operator|++
operator|,
name|l1
operator|++
control|)
block|{
comment|/* Allocate a L1 page table */
name|va
operator|=
operator|(
name|vm_offset_t
operator|)
name|contigmalloc
argument_list|(
name|L1_TABLE_SIZE
argument_list|,
name|M_VMPMAP
argument_list|,
literal|0
argument_list|,
literal|0x0
argument_list|,
literal|0xffffffff
argument_list|,
name|L1_TABLE_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|va
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"Cannot allocate L1 KVM"
argument_list|)
expr_stmt|;
name|eva
operator|=
name|va
operator|+
name|L1_TABLE_SIZE
expr_stmt|;
name|pl1pt
operator|=
operator|(
name|pd_entry_t
operator|*
operator|)
name|va
expr_stmt|;
while|while
condition|(
name|va
operator|<
name|eva
condition|)
block|{
name|l2b
operator|=
name|pmap_get_l2_bucket
argument_list|(
name|pmap_kernel
argument_list|()
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|ptep
operator|=
operator|&
name|l2b
operator|->
name|l2b_kva
index|[
name|l2pte_index
argument_list|(
name|va
argument_list|)
index|]
expr_stmt|;
name|pte
operator|=
operator|*
name|ptep
expr_stmt|;
name|pte
operator|=
operator|(
name|pte
operator|&
operator|~
name|L2_S_CACHE_MASK
operator|)
operator||
name|pte_l2_s_cache_mode_pt
expr_stmt|;
operator|*
name|ptep
operator|=
name|pte
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|ptep
argument_list|)
expr_stmt|;
name|cpu_tlb_flushID_SE
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|cpu_cpwait
argument_list|()
expr_stmt|;
name|va
operator|+=
name|PAGE_SIZE
expr_stmt|;
block|}
name|pmap_init_l1
argument_list|(
name|l1
argument_list|,
name|pl1pt
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"pmap_postinit: Allocated %d static L1 descriptor tables\n"
argument_list|,
name|needed
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * This is used to stuff certain critical values into the PCB where they  * can be accessed quickly from cpu_switch() et al.  */
end_comment

begin_function
name|void
name|pmap_set_pcb_pagedir
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|struct
name|pcb
modifier|*
name|pcb
parameter_list|)
block|{
name|struct
name|l2_bucket
modifier|*
name|l2b
decl_stmt|;
name|pcb
operator|->
name|pcb_pagedir
operator|=
name|pmap
operator|->
name|pm_l1
operator|->
name|l1_physaddr
expr_stmt|;
name|pcb
operator|->
name|pcb_dacr
operator|=
operator|(
name|DOMAIN_CLIENT
operator|<<
operator|(
name|PMAP_DOMAIN_KERNEL
operator|*
literal|2
operator|)
operator|)
operator||
operator|(
name|DOMAIN_CLIENT
operator|<<
operator|(
name|pmap
operator|->
name|pm_domain
operator|*
literal|2
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|vector_page
operator|<
name|KERNBASE
condition|)
block|{
name|pcb
operator|->
name|pcb_pl1vec
operator|=
operator|&
name|pmap
operator|->
name|pm_l1
operator|->
name|l1_kva
index|[
name|L1_IDX
argument_list|(
name|vector_page
argument_list|)
index|]
expr_stmt|;
name|l2b
operator|=
name|pmap_get_l2_bucket
argument_list|(
name|pmap
argument_list|,
name|vector_page
argument_list|)
expr_stmt|;
name|pcb
operator|->
name|pcb_l1vec
operator|=
name|l2b
operator|->
name|l2b_phys
operator||
name|L1_C_PROTO
operator||
name|L1_C_DOM
argument_list|(
name|pmap
operator|->
name|pm_domain
argument_list|)
operator||
name|L1_C_DOM
argument_list|(
name|PMAP_DOMAIN_KERNEL
argument_list|)
expr_stmt|;
block|}
else|else
name|pcb
operator|->
name|pcb_pl1vec
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pmap_activate
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|pmap_t
name|pmap
decl_stmt|;
name|struct
name|pcb
modifier|*
name|pcb
decl_stmt|;
name|pmap
operator|=
name|vmspace_pmap
argument_list|(
name|td
operator|->
name|td_proc
operator|->
name|p_vmspace
argument_list|)
expr_stmt|;
name|pcb
operator|=
name|td
operator|->
name|td_pcb
expr_stmt|;
name|critical_enter
argument_list|()
expr_stmt|;
name|pmap_set_pcb_pagedir
argument_list|(
name|pmap
argument_list|,
name|pcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|==
name|curthread
condition|)
block|{
name|u_int
name|cur_dacr
decl_stmt|,
name|cur_ttb
decl_stmt|;
asm|__asm __volatile("mrc p15, 0, %0, c2, c0, 0" : "=r"(cur_ttb));
asm|__asm __volatile("mrc p15, 0, %0, c3, c0, 0" : "=r"(cur_dacr));
name|cur_ttb
operator|&=
operator|~
operator|(
name|L1_TABLE_SIZE
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|cur_ttb
operator|==
operator|(
name|u_int
operator|)
name|pcb
operator|->
name|pcb_pagedir
operator|&&
name|cur_dacr
operator|==
name|pcb
operator|->
name|pcb_dacr
condition|)
block|{
comment|/* 			 * No need to switch address spaces. 			 */
name|critical_exit
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* 		 * We MUST, I repeat, MUST fix up the L1 entry corresponding 		 * to 'vector_page' in the incoming L1 table before switching 		 * to it otherwise subsequent interrupts/exceptions (including 		 * domain faults!) will jump into hyperspace. 		 */
if|if
condition|(
name|pcb
operator|->
name|pcb_pl1vec
condition|)
block|{
operator|*
name|pcb
operator|->
name|pcb_pl1vec
operator|=
name|pcb
operator|->
name|pcb_l1vec
expr_stmt|;
block|}
name|cpu_domains
argument_list|(
name|pcb
operator|->
name|pcb_dacr
argument_list|)
expr_stmt|;
name|cpu_setttb
argument_list|(
name|pcb
operator|->
name|pcb_pagedir
argument_list|)
expr_stmt|;
block|}
name|critical_exit
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pmap_set_pt_cache_mode
parameter_list|(
name|pd_entry_t
modifier|*
name|kl1
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|pd_entry_t
modifier|*
name|pdep
decl_stmt|,
name|pde
decl_stmt|;
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|,
name|pte
decl_stmt|;
name|vm_offset_t
name|pa
decl_stmt|;
name|int
name|rv
init|=
literal|0
decl_stmt|;
comment|/* 	 * Make sure the descriptor itself has the correct cache mode 	 */
name|pdep
operator|=
operator|&
name|kl1
index|[
name|L1_IDX
argument_list|(
name|va
argument_list|)
index|]
expr_stmt|;
name|pde
operator|=
operator|*
name|pdep
expr_stmt|;
if|if
condition|(
name|l1pte_section_p
argument_list|(
name|pde
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|pde
operator|&
name|L1_S_CACHE_MASK
operator|)
operator|!=
name|pte_l1_s_cache_mode_pt
condition|)
block|{
operator|*
name|pdep
operator|=
operator|(
name|pde
operator|&
operator|~
name|L1_S_CACHE_MASK
operator|)
operator||
name|pte_l1_s_cache_mode_pt
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|pdep
argument_list|)
expr_stmt|;
name|rv
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|pa
operator|=
call|(
name|vm_paddr_t
call|)
argument_list|(
name|pde
operator|&
name|L1_C_ADDR_MASK
argument_list|)
expr_stmt|;
name|ptep
operator|=
operator|(
name|pt_entry_t
operator|*
operator|)
name|kernel_pt_lookup
argument_list|(
name|pa
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptep
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"pmap_bootstrap: No L2 for L2 @ va %p\n"
argument_list|,
name|ptep
argument_list|)
expr_stmt|;
name|ptep
operator|=
operator|&
name|ptep
index|[
name|l2pte_index
argument_list|(
name|va
argument_list|)
index|]
expr_stmt|;
name|pte
operator|=
operator|*
name|ptep
expr_stmt|;
if|if
condition|(
operator|(
name|pte
operator|&
name|L2_S_CACHE_MASK
operator|)
operator|!=
name|pte_l2_s_cache_mode_pt
condition|)
block|{
operator|*
name|ptep
operator|=
operator|(
name|pte
operator|&
operator|~
name|L2_S_CACHE_MASK
operator|)
operator||
name|pte_l2_s_cache_mode_pt
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|ptep
argument_list|)
expr_stmt|;
name|rv
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pmap_alloc_specials
parameter_list|(
name|vm_offset_t
modifier|*
name|availp
parameter_list|,
name|int
name|pages
parameter_list|,
name|vm_offset_t
modifier|*
name|vap
parameter_list|,
name|pt_entry_t
modifier|*
modifier|*
name|ptep
parameter_list|)
block|{
name|vm_offset_t
name|va
init|=
operator|*
name|availp
decl_stmt|;
name|struct
name|l2_bucket
modifier|*
name|l2b
decl_stmt|;
if|if
condition|(
name|ptep
condition|)
block|{
name|l2b
operator|=
name|pmap_get_l2_bucket
argument_list|(
name|pmap_kernel
argument_list|()
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|l2b
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"pmap_alloc_specials: no l2b for 0x%x"
argument_list|,
name|va
argument_list|)
expr_stmt|;
operator|*
name|ptep
operator|=
operator|&
name|l2b
operator|->
name|l2b_kva
index|[
name|l2pte_index
argument_list|(
name|va
argument_list|)
index|]
expr_stmt|;
block|}
operator|*
name|vap
operator|=
name|va
expr_stmt|;
operator|*
name|availp
operator|=
name|va
operator|+
operator|(
name|PAGE_SIZE
operator|*
name|pages
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Bootstrap the system enough to run with virtual memory.  *  *	On the arm this is called after mapping has already been enabled  *	and just syncs the pmap module with what has already been done.  *	[We can't call it easily with mapping off since the kernel is not  *	mapped with PA == VA, hence we would have to relocate every address  *	from the linked base (virtual) address "KERNBASE" to the actual  *	(physical) address starting relative to 0]  */
end_comment

begin_define
define|#
directive|define
name|PMAP_STATIC_L2_SIZE
value|16
end_define

begin_function
name|void
name|pmap_bootstrap
parameter_list|(
name|vm_offset_t
name|firstaddr
parameter_list|,
name|struct
name|pv_addr
modifier|*
name|l1pt
parameter_list|)
block|{
specifier|static
name|struct
name|l1_ttable
name|static_l1
decl_stmt|;
specifier|static
name|struct
name|l2_dtable
name|static_l2
index|[
name|PMAP_STATIC_L2_SIZE
index|]
decl_stmt|;
name|struct
name|l1_ttable
modifier|*
name|l1
init|=
operator|&
name|static_l1
decl_stmt|;
name|struct
name|l2_dtable
modifier|*
name|l2
decl_stmt|;
name|struct
name|l2_bucket
modifier|*
name|l2b
decl_stmt|;
name|struct
name|czpages
modifier|*
name|czp
decl_stmt|;
name|pd_entry_t
name|pde
decl_stmt|;
name|pd_entry_t
modifier|*
name|kernel_l1pt
init|=
operator|(
name|pd_entry_t
operator|*
operator|)
name|l1pt
operator|->
name|pv_va
decl_stmt|;
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|;
name|vm_paddr_t
name|pa
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
name|vm_size_t
name|size
decl_stmt|;
name|int
name|i
decl_stmt|,
name|l1idx
decl_stmt|,
name|l2idx
decl_stmt|,
name|l2next
init|=
literal|0
decl_stmt|;
name|PDEBUG
argument_list|(
literal|1
argument_list|,
name|printf
argument_list|(
literal|"firstaddr = %08x, lastaddr = %08x\n"
argument_list|,
name|firstaddr
argument_list|,
name|vm_max_kernel_address
argument_list|)
argument_list|)
expr_stmt|;
name|virtual_avail
operator|=
name|firstaddr
expr_stmt|;
name|kernel_pmap
operator|->
name|pm_l1
operator|=
name|l1
expr_stmt|;
name|kernel_l1pa
operator|=
name|l1pt
operator|->
name|pv_pa
expr_stmt|;
comment|/* 	 * Scan the L1 translation table created by initarm() and create 	 * the required metadata for all valid mappings found in it. 	 */
for|for
control|(
name|l1idx
operator|=
literal|0
init|;
name|l1idx
operator|<
operator|(
name|L1_TABLE_SIZE
operator|/
sizeof|sizeof
argument_list|(
name|pd_entry_t
argument_list|)
operator|)
condition|;
name|l1idx
operator|++
control|)
block|{
name|pde
operator|=
name|kernel_l1pt
index|[
name|l1idx
index|]
expr_stmt|;
comment|/* 		 * We're only interested in Coarse mappings. 		 * pmap_extract() can deal with section mappings without 		 * recourse to checking L2 metadata. 		 */
if|if
condition|(
operator|(
name|pde
operator|&
name|L1_TYPE_MASK
operator|)
operator|!=
name|L1_TYPE_C
condition|)
continue|continue;
comment|/* 		 * Lookup the KVA of this L2 descriptor table 		 */
name|pa
operator|=
call|(
name|vm_paddr_t
call|)
argument_list|(
name|pde
operator|&
name|L1_C_ADDR_MASK
argument_list|)
expr_stmt|;
name|ptep
operator|=
operator|(
name|pt_entry_t
operator|*
operator|)
name|kernel_pt_lookup
argument_list|(
name|pa
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptep
operator|==
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"pmap_bootstrap: No L2 for va 0x%x, pa 0x%lx"
argument_list|,
operator|(
name|u_int
operator|)
name|l1idx
operator|<<
name|L1_S_SHIFT
argument_list|,
operator|(
name|long
name|unsigned
name|int
operator|)
name|pa
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Fetch the associated L2 metadata structure. 		 * Allocate a new one if necessary. 		 */
if|if
condition|(
operator|(
name|l2
operator|=
name|kernel_pmap
operator|->
name|pm_l2
index|[
name|L2_IDX
argument_list|(
name|l1idx
argument_list|)
index|]
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|l2next
operator|==
name|PMAP_STATIC_L2_SIZE
condition|)
name|panic
argument_list|(
literal|"pmap_bootstrap: out of static L2s"
argument_list|)
expr_stmt|;
name|kernel_pmap
operator|->
name|pm_l2
index|[
name|L2_IDX
argument_list|(
name|l1idx
argument_list|)
index|]
operator|=
name|l2
operator|=
operator|&
name|static_l2
index|[
name|l2next
operator|++
index|]
expr_stmt|;
block|}
comment|/* 		 * One more L1 slot tracked... 		 */
name|l2
operator|->
name|l2_occupancy
operator|++
expr_stmt|;
comment|/* 		 * Fill in the details of the L2 descriptor in the 		 * appropriate bucket. 		 */
name|l2b
operator|=
operator|&
name|l2
operator|->
name|l2_bucket
index|[
name|L2_BUCKET
argument_list|(
name|l1idx
argument_list|)
index|]
expr_stmt|;
name|l2b
operator|->
name|l2b_kva
operator|=
name|ptep
expr_stmt|;
name|l2b
operator|->
name|l2b_phys
operator|=
name|pa
expr_stmt|;
name|l2b
operator|->
name|l2b_l1idx
operator|=
name|l1idx
expr_stmt|;
comment|/* 		 * Establish an initial occupancy count for this descriptor 		 */
for|for
control|(
name|l2idx
operator|=
literal|0
init|;
name|l2idx
operator|<
operator|(
name|L2_TABLE_SIZE_REAL
operator|/
sizeof|sizeof
argument_list|(
name|pt_entry_t
argument_list|)
operator|)
condition|;
name|l2idx
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ptep
index|[
name|l2idx
index|]
operator|&
name|L2_TYPE_MASK
operator|)
operator|!=
name|L2_TYPE_INV
condition|)
block|{
name|l2b
operator|->
name|l2b_occupancy
operator|++
expr_stmt|;
block|}
block|}
comment|/* 		 * Make sure the descriptor itself has the correct cache mode. 		 * If not, fix it, but whine about the problem. Port-meisters 		 * should consider this a clue to fix up their initarm() 		 * function. :) 		 */
if|if
condition|(
name|pmap_set_pt_cache_mode
argument_list|(
name|kernel_l1pt
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|ptep
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"pmap_bootstrap: WARNING! wrong cache mode for "
literal|"L2 pte @ %p\n"
argument_list|,
name|ptep
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Ensure the primary (kernel) L1 has the correct cache mode for 	 * a page table. Bitch if it is not correctly set. 	 */
for|for
control|(
name|va
operator|=
operator|(
name|vm_offset_t
operator|)
name|kernel_l1pt
init|;
name|va
operator|<
operator|(
operator|(
name|vm_offset_t
operator|)
name|kernel_l1pt
operator|+
name|L1_TABLE_SIZE
operator|)
condition|;
name|va
operator|+=
name|PAGE_SIZE
control|)
block|{
if|if
condition|(
name|pmap_set_pt_cache_mode
argument_list|(
name|kernel_l1pt
argument_list|,
name|va
argument_list|)
condition|)
name|printf
argument_list|(
literal|"pmap_bootstrap: WARNING! wrong cache mode for "
literal|"primary L1 @ 0x%x\n"
argument_list|,
name|va
argument_list|)
expr_stmt|;
block|}
name|cpu_dcache_wbinv_all
argument_list|()
expr_stmt|;
name|cpu_l2cache_wbinv_all
argument_list|()
expr_stmt|;
name|cpu_tlb_flushID
argument_list|()
expr_stmt|;
name|cpu_cpwait
argument_list|()
expr_stmt|;
name|PMAP_LOCK_INIT
argument_list|(
name|kernel_pmap
argument_list|)
expr_stmt|;
name|CPU_FILL
argument_list|(
operator|&
name|kernel_pmap
operator|->
name|pm_active
argument_list|)
expr_stmt|;
name|kernel_pmap
operator|->
name|pm_domain
operator|=
name|PMAP_DOMAIN_KERNEL
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|kernel_pmap
operator|->
name|pm_pvchunk
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize the global pv list lock. 	 */
name|rw_init
argument_list|(
operator|&
name|pvh_global_lock
argument_list|,
literal|"pmap pv global"
argument_list|)
expr_stmt|;
comment|/* 	 * Reserve some special page table entries/VA space for temporary 	 * mapping of pages that are being copied or zeroed. 	 */
for|for
control|(
name|czp
operator|=
name|cpu_czpages
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXCPU
condition|;
operator|++
name|i
operator|,
operator|++
name|czp
control|)
block|{
name|mtx_init
argument_list|(
operator|&
name|czp
operator|->
name|lock
argument_list|,
literal|"czpages"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|pmap_alloc_specials
argument_list|(
operator|&
name|virtual_avail
argument_list|,
literal|1
argument_list|,
operator|&
name|czp
operator|->
name|srcva
argument_list|,
operator|&
name|czp
operator|->
name|srcptep
argument_list|)
expr_stmt|;
name|pmap_set_pt_cache_mode
argument_list|(
name|kernel_l1pt
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|czp
operator|->
name|srcptep
argument_list|)
expr_stmt|;
name|pmap_alloc_specials
argument_list|(
operator|&
name|virtual_avail
argument_list|,
literal|1
argument_list|,
operator|&
name|czp
operator|->
name|dstva
argument_list|,
operator|&
name|czp
operator|->
name|dstptep
argument_list|)
expr_stmt|;
name|pmap_set_pt_cache_mode
argument_list|(
name|kernel_l1pt
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|czp
operator|->
name|dstptep
argument_list|)
expr_stmt|;
block|}
name|size
operator|=
operator|(
operator|(
name|vm_max_kernel_address
operator|-
name|pmap_curmaxkvaddr
operator|)
operator|+
name|L1_S_OFFSET
operator|)
operator|/
name|L1_S_SIZE
expr_stmt|;
name|pmap_alloc_specials
argument_list|(
operator|&
name|virtual_avail
argument_list|,
name|round_page
argument_list|(
name|size
operator|*
name|L2_TABLE_SIZE_REAL
argument_list|)
operator|/
name|PAGE_SIZE
argument_list|,
operator|&
name|pmap_kernel_l2ptp_kva
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|size
operator|=
operator|(
name|size
operator|+
operator|(
name|L2_BUCKET_SIZE
operator|-
literal|1
operator|)
operator|)
operator|/
name|L2_BUCKET_SIZE
expr_stmt|;
name|pmap_alloc_specials
argument_list|(
operator|&
name|virtual_avail
argument_list|,
name|round_page
argument_list|(
name|size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|l2_dtable
argument_list|)
argument_list|)
operator|/
name|PAGE_SIZE
argument_list|,
operator|&
name|pmap_kernel_l2dtable_kva
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|pmap_alloc_specials
argument_list|(
operator|&
name|virtual_avail
argument_list|,
literal|1
argument_list|,
operator|(
name|vm_offset_t
operator|*
operator|)
operator|&
name|_tmppt
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|pmap_alloc_specials
argument_list|(
operator|&
name|virtual_avail
argument_list|,
name|MAXDUMPPGS
argument_list|,
operator|(
name|vm_offset_t
operator|*
operator|)
operator|&
name|crashdumpmap
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|l1_list
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|l1_lru_list
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|l1_lru_lock
argument_list|,
literal|"l1 list lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|pmap_init_l1
argument_list|(
name|l1
argument_list|,
name|kernel_l1pt
argument_list|)
expr_stmt|;
name|cpu_dcache_wbinv_all
argument_list|()
expr_stmt|;
name|cpu_l2cache_wbinv_all
argument_list|()
expr_stmt|;
name|cpu_tlb_flushID
argument_list|()
expr_stmt|;
name|cpu_cpwait
argument_list|()
expr_stmt|;
name|virtual_avail
operator|=
name|round_page
argument_list|(
name|virtual_avail
argument_list|)
expr_stmt|;
name|virtual_end
operator|=
name|vm_max_kernel_address
expr_stmt|;
name|kernel_vm_end
operator|=
name|pmap_curmaxkvaddr
expr_stmt|;
name|pmap_set_pcb_pagedir
argument_list|(
name|kernel_pmap
argument_list|,
name|thread0
operator|.
name|td_pcb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/***************************************************  * Pmap allocation/deallocation routines.  ***************************************************/
end_comment

begin_comment
comment|/*  * Release any resources held by the given physical map.  * Called when a pmap initialized by pmap_pinit is being released.  * Should only be called if the map contains no valid mappings.  */
end_comment

begin_function
name|void
name|pmap_release
parameter_list|(
name|pmap_t
name|pmap
parameter_list|)
block|{
name|struct
name|pcb
modifier|*
name|pcb
decl_stmt|;
name|cpu_tlb_flushID
argument_list|()
expr_stmt|;
name|cpu_cpwait
argument_list|()
expr_stmt|;
if|if
condition|(
name|vector_page
operator|<
name|KERNBASE
condition|)
block|{
name|struct
name|pcb
modifier|*
name|curpcb
init|=
name|PCPU_GET
argument_list|(
name|curpcb
argument_list|)
decl_stmt|;
name|pcb
operator|=
name|thread0
operator|.
name|td_pcb
expr_stmt|;
if|if
condition|(
name|pmap_is_current
argument_list|(
name|pmap
argument_list|)
condition|)
block|{
comment|/* 			 * Frob the L1 entry corresponding to the vector 			 * page so that it contains the kernel pmap's domain 			 * number. This will ensure pmap_remove() does not 			 * pull the current vector page out from under us. 			 */
name|critical_enter
argument_list|()
expr_stmt|;
operator|*
name|pcb
operator|->
name|pcb_pl1vec
operator|=
name|pcb
operator|->
name|pcb_l1vec
expr_stmt|;
name|cpu_domains
argument_list|(
name|pcb
operator|->
name|pcb_dacr
argument_list|)
expr_stmt|;
name|cpu_setttb
argument_list|(
name|pcb
operator|->
name|pcb_pagedir
argument_list|)
expr_stmt|;
name|critical_exit
argument_list|()
expr_stmt|;
block|}
name|pmap_remove
argument_list|(
name|pmap
argument_list|,
name|vector_page
argument_list|,
name|vector_page
operator|+
name|PAGE_SIZE
argument_list|)
expr_stmt|;
comment|/* 		 * Make sure cpu_switch(), et al, DTRT. This is safe to do 		 * since this process has no remaining mappings of its own. 		 */
name|curpcb
operator|->
name|pcb_pl1vec
operator|=
name|pcb
operator|->
name|pcb_pl1vec
expr_stmt|;
name|curpcb
operator|->
name|pcb_l1vec
operator|=
name|pcb
operator|->
name|pcb_l1vec
expr_stmt|;
name|curpcb
operator|->
name|pcb_dacr
operator|=
name|pcb
operator|->
name|pcb_dacr
expr_stmt|;
name|curpcb
operator|->
name|pcb_pagedir
operator|=
name|pcb
operator|->
name|pcb_pagedir
expr_stmt|;
block|}
name|pmap_free_l1
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|"pmap_release()\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Helper function for pmap_grow_l2_bucket()  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|pmap_grow_map
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|pt_entry_t
name|cache_mode
parameter_list|,
name|vm_paddr_t
modifier|*
name|pap
parameter_list|)
block|{
name|struct
name|l2_bucket
modifier|*
name|l2b
decl_stmt|;
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|;
name|vm_paddr_t
name|pa
decl_stmt|;
name|struct
name|vm_page
modifier|*
name|m
decl_stmt|;
name|m
operator|=
name|vm_page_alloc
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|VM_ALLOC_NOOBJ
operator||
name|VM_ALLOC_WIRED
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|pa
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|pap
condition|)
operator|*
name|pap
operator|=
name|pa
expr_stmt|;
name|l2b
operator|=
name|pmap_get_l2_bucket
argument_list|(
name|pmap_kernel
argument_list|()
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|ptep
operator|=
operator|&
name|l2b
operator|->
name|l2b_kva
index|[
name|l2pte_index
argument_list|(
name|va
argument_list|)
index|]
expr_stmt|;
operator|*
name|ptep
operator|=
name|L2_S_PROTO
operator||
name|pa
operator||
name|cache_mode
operator||
name|L2_S_REF
expr_stmt|;
name|pmap_set_prot
argument_list|(
name|ptep
argument_list|,
name|VM_PROT_READ
operator||
name|VM_PROT_WRITE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|ptep
argument_list|)
expr_stmt|;
name|cpu_tlb_flushD_SE
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|cpu_cpwait
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This is the same as pmap_alloc_l2_bucket(), except that it is only  * used by pmap_growkernel().  */
end_comment

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|l2_bucket
operator|*
name|pmap_grow_l2_bucket
argument_list|(
argument|pmap_t pmap
argument_list|,
argument|vm_offset_t va
argument_list|)
block|{ 	struct
name|l2_dtable
operator|*
name|l2
block|; 	struct
name|l2_bucket
operator|*
name|l2b
block|; 	struct
name|l1_ttable
operator|*
name|l1
block|;
name|pd_entry_t
operator|*
name|pl1pd
block|;
name|u_short
name|l1idx
block|;
name|vm_offset_t
name|nva
block|;
name|l1idx
operator|=
name|L1_IDX
argument_list|(
name|va
argument_list|)
block|;
if|if
condition|(
operator|(
name|l2
operator|=
name|pmap
operator|->
name|pm_l2
index|[
name|L2_IDX
argument_list|(
name|l1idx
argument_list|)
index|]
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * No mapping at this address, as there is 		 * no entry in the L1 table. 		 * Need to allocate a new l2_dtable. 		 */
name|nva
operator|=
name|pmap_kernel_l2dtable_kva
expr_stmt|;
if|if
condition|(
operator|(
name|nva
operator|&
name|PAGE_MASK
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Need to allocate a backing page 			 */
if|if
condition|(
name|pmap_grow_map
argument_list|(
name|nva
argument_list|,
name|pte_l2_s_cache_mode
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|l2
operator|=
operator|(
expr|struct
name|l2_dtable
operator|*
operator|)
name|nva
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|nva
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|l2_dtable
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|(
name|nva
operator|&
name|PAGE_MASK
operator|)
operator|<
operator|(
name|pmap_kernel_l2dtable_kva
operator|&
name|PAGE_MASK
operator|)
condition|)
block|{
comment|/* 			 * The new l2_dtable straddles a page boundary. 			 * Map in another page to cover it. 			 */
if|if
condition|(
name|pmap_grow_map
argument_list|(
name|nva
argument_list|,
name|pte_l2_s_cache_mode
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_if

begin_expr_stmt
name|pmap_kernel_l2dtable_kva
operator|=
name|nva
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 		 * Link it into the parent pmap 		 */
end_comment

begin_expr_stmt
name|pmap
operator|->
name|pm_l2
index|[
name|L2_IDX
argument_list|(
name|l1idx
argument_list|)
index|]
operator|=
name|l2
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|memset
argument_list|(
name|l2
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|l2
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  	l2b
operator|=
operator|&
name|l2
operator|->
name|l2_bucket
index|[
name|L2_BUCKET
argument_list|(
name|l1idx
argument_list|)
index|]
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	 * Fetch pointer to the L2 page table associated with the address. 	 */
end_comment

begin_if
if|if
condition|(
name|l2b
operator|->
name|l2b_kva
operator|==
name|NULL
condition|)
block|{
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|;
comment|/* 		 * No L2 page table has been allocated. Chances are, this 		 * is because we just allocated the l2_dtable, above. 		 */
name|nva
operator|=
name|pmap_kernel_l2ptp_kva
expr_stmt|;
name|ptep
operator|=
operator|(
name|pt_entry_t
operator|*
operator|)
name|nva
expr_stmt|;
if|if
condition|(
operator|(
name|nva
operator|&
name|PAGE_MASK
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Need to allocate a backing page 			 */
if|if
condition|(
name|pmap_grow_map
argument_list|(
name|nva
argument_list|,
name|pte_l2_s_cache_mode_pt
argument_list|,
operator|&
name|pmap_kernel_l2ptp_phys
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|memset
argument_list|(
name|ptep
argument_list|,
literal|0
argument_list|,
name|L2_TABLE_SIZE_REAL
argument_list|)
expr_stmt|;
name|l2
operator|->
name|l2_occupancy
operator|++
expr_stmt|;
name|l2b
operator|->
name|l2b_kva
operator|=
name|ptep
expr_stmt|;
name|l2b
operator|->
name|l2b_l1idx
operator|=
name|l1idx
expr_stmt|;
name|l2b
operator|->
name|l2b_phys
operator|=
name|pmap_kernel_l2ptp_phys
expr_stmt|;
name|pmap_kernel_l2ptp_kva
operator|+=
name|L2_TABLE_SIZE_REAL
expr_stmt|;
name|pmap_kernel_l2ptp_phys
operator|+=
name|L2_TABLE_SIZE_REAL
expr_stmt|;
block|}
end_if

begin_comment
comment|/* Distribute new L1 entry to all other L1s */
end_comment

begin_macro
name|SLIST_FOREACH
argument_list|(
argument|l1
argument_list|,
argument|&l1_list
argument_list|,
argument|l1_link
argument_list|)
end_macro

begin_block
block|{
name|pl1pd
operator|=
operator|&
name|l1
operator|->
name|l1_kva
index|[
name|L1_IDX
argument_list|(
name|va
argument_list|)
index|]
expr_stmt|;
operator|*
name|pl1pd
operator|=
name|l2b
operator|->
name|l2b_phys
operator||
name|L1_C_DOM
argument_list|(
name|PMAP_DOMAIN_KERNEL
argument_list|)
operator||
name|L1_C_PROTO
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|pl1pd
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|cpu_tlb_flushID_SE
argument_list|(
name|va
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|cpu_cpwait
argument_list|()
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
name|l2b
operator|)
return|;
end_return

begin_comment
unit|}
comment|/*  * grow the number of kernel page table entries, if needed  */
end_comment

begin_macro
unit|void
name|pmap_growkernel
argument_list|(
argument|vm_offset_t addr
argument_list|)
end_macro

begin_block
block|{
name|pmap_t
name|kpmap
init|=
name|pmap_kernel
argument_list|()
decl_stmt|;
if|if
condition|(
name|addr
operator|<=
name|pmap_curmaxkvaddr
condition|)
return|return;
comment|/* we are OK */
comment|/* 	 * whoops!   we need to add kernel PTPs 	 */
comment|/* Map 1MB at a time */
for|for
control|(
init|;
name|pmap_curmaxkvaddr
operator|<
name|addr
condition|;
name|pmap_curmaxkvaddr
operator|+=
name|L1_S_SIZE
control|)
name|pmap_grow_l2_bucket
argument_list|(
name|kpmap
argument_list|,
name|pmap_curmaxkvaddr
argument_list|)
expr_stmt|;
name|kernel_vm_end
operator|=
name|pmap_curmaxkvaddr
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Returns TRUE if the given page is mapped individually or as part of  * a 1MB section.  Otherwise, returns FALSE.  */
end_comment

begin_function
name|boolean_t
name|pmap_page_is_mapped
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|boolean_t
name|rv
decl_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|rv
operator|=
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|)
operator|||
operator|(
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_FICTITIOUS
operator|)
operator|==
literal|0
operator|&&
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|pa_to_pvh
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
operator|->
name|pv_list
argument_list|)
operator|)
expr_stmt|;
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove all pages from specified address space  * this aids process exit speeds.  Also, this code  * is special cased for current process only, but  * can have the more generic (and slightly slower)  * mode enabled.  This is much faster than pmap_remove  * in the case of running down an entire address space.  */
end_comment

begin_function
name|void
name|pmap_remove_pages
parameter_list|(
name|pmap_t
name|pmap
parameter_list|)
block|{
name|struct
name|pv_entry
modifier|*
name|pv
decl_stmt|;
name|struct
name|l2_bucket
modifier|*
name|l2b
init|=
name|NULL
decl_stmt|;
name|struct
name|pv_chunk
modifier|*
name|pc
decl_stmt|,
modifier|*
name|npc
decl_stmt|;
name|struct
name|md_page
modifier|*
name|pvh
decl_stmt|;
name|pd_entry_t
modifier|*
name|pl1pd
decl_stmt|,
name|l1pd
decl_stmt|;
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|,
name|mt
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
name|uint32_t
name|inuse
decl_stmt|,
name|bitmask
decl_stmt|;
name|int
name|allfree
decl_stmt|,
name|bit
decl_stmt|,
name|field
decl_stmt|,
name|idx
decl_stmt|;
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|pc
argument_list|,
argument|&pmap->pm_pvchunk
argument_list|,
argument|pc_list
argument_list|,
argument|npc
argument_list|)
block|{
name|allfree
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|field
operator|=
literal|0
init|;
name|field
operator|<
name|_NPCM
condition|;
name|field
operator|++
control|)
block|{
name|inuse
operator|=
operator|~
name|pc
operator|->
name|pc_map
index|[
name|field
index|]
operator|&
name|pc_freemask
index|[
name|field
index|]
expr_stmt|;
while|while
condition|(
name|inuse
operator|!=
literal|0
condition|)
block|{
name|bit
operator|=
name|ffs
argument_list|(
name|inuse
argument_list|)
operator|-
literal|1
expr_stmt|;
name|bitmask
operator|=
literal|1ul
operator|<<
name|bit
expr_stmt|;
name|idx
operator|=
name|field
operator|*
sizeof|sizeof
argument_list|(
name|inuse
argument_list|)
operator|*
name|NBBY
operator|+
name|bit
expr_stmt|;
name|pv
operator|=
operator|&
name|pc
operator|->
name|pc_pventry
index|[
name|idx
index|]
expr_stmt|;
name|va
operator|=
name|pv
operator|->
name|pv_va
expr_stmt|;
name|inuse
operator|&=
operator|~
name|bitmask
expr_stmt|;
if|if
condition|(
name|pv
operator|->
name|pv_flags
operator|&
name|PVF_WIRED
condition|)
block|{
comment|/* Cannot remove wired pages now. */
name|allfree
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|pl1pd
operator|=
operator|&
name|pmap
operator|->
name|pm_l1
operator|->
name|l1_kva
index|[
name|L1_IDX
argument_list|(
name|va
argument_list|)
index|]
expr_stmt|;
name|l1pd
operator|=
operator|*
name|pl1pd
expr_stmt|;
name|l2b
operator|=
name|pmap_get_l2_bucket
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|l1pd
operator|&
name|L1_TYPE_MASK
operator|)
operator|==
name|L1_S_PROTO
condition|)
block|{
name|pvh
operator|=
name|pa_to_pvh
argument_list|(
name|l1pd
operator|&
name|L1_S_FRAME
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pvh
operator|->
name|pv_list
argument_list|,
name|pv
argument_list|,
name|pv_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|pvh
operator|->
name|pv_list
argument_list|)
condition|)
block|{
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|l1pd
operator|&
name|L1_S_FRAME
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|m
operator|>=
name|KERNBASE
argument_list|,
operator|(
literal|"Trying to access non-existent page "
literal|"va %x l1pd %x"
operator|,
name|trunc_1mpage
argument_list|(
name|va
argument_list|)
operator|,
name|l1pd
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|mt
operator|=
name|m
init|;
name|mt
operator|<
operator|&
name|m
index|[
name|L2_PTE_NUM_TOTAL
index|]
condition|;
name|mt
operator|++
control|)
block|{
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|mt
operator|->
name|md
operator|.
name|pv_list
argument_list|)
condition|)
name|vm_page_aflag_clear
argument_list|(
name|mt
argument_list|,
name|PGA_WRITEABLE
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|l2b
operator|!=
name|NULL
condition|)
block|{
name|KASSERT
argument_list|(
name|l2b
operator|->
name|l2b_occupancy
operator|==
name|L2_PTE_NUM_TOTAL
argument_list|,
operator|(
literal|"pmap_remove_pages: l2_bucket occupancy error"
operator|)
argument_list|)
expr_stmt|;
name|pmap_free_l2_bucket
argument_list|(
name|pmap
argument_list|,
name|l2b
argument_list|,
name|L2_PTE_NUM_TOTAL
argument_list|)
expr_stmt|;
block|}
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|-=
name|L2_PTE_NUM_TOTAL
expr_stmt|;
operator|*
name|pl1pd
operator|=
literal|0
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|pl1pd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|KASSERT
argument_list|(
name|l2b
operator|!=
name|NULL
argument_list|,
operator|(
literal|"No L2 bucket in pmap_remove_pages"
operator|)
argument_list|)
expr_stmt|;
name|ptep
operator|=
operator|&
name|l2b
operator|->
name|l2b_kva
index|[
name|l2pte_index
argument_list|(
name|va
argument_list|)
index|]
expr_stmt|;
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|l2pte_pa
argument_list|(
operator|*
name|ptep
argument_list|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|m
operator|>=
name|KERNBASE
argument_list|,
operator|(
literal|"Trying to access non-existent page "
literal|"va %x pte %x"
operator|,
name|va
operator|,
operator|*
name|ptep
operator|)
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|,
name|pv
argument_list|,
name|pv_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|)
operator|&&
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_FICTITIOUS
operator|)
operator|==
literal|0
condition|)
block|{
name|pvh
operator|=
name|pa_to_pvh
argument_list|(
name|l2pte_pa
argument_list|(
operator|*
name|ptep
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|pvh
operator|->
name|pv_list
argument_list|)
condition|)
name|vm_page_aflag_clear
argument_list|(
name|m
argument_list|,
name|PGA_WRITEABLE
argument_list|)
expr_stmt|;
block|}
operator|*
name|ptep
operator|=
literal|0
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|ptep
argument_list|)
expr_stmt|;
name|pmap_free_l2_bucket
argument_list|(
name|pmap
argument_list|,
name|l2b
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|--
expr_stmt|;
block|}
comment|/* Mark free */
name|PV_STAT
argument_list|(
name|pv_entry_frees
operator|++
argument_list|)
expr_stmt|;
name|PV_STAT
argument_list|(
name|pv_entry_spare
operator|++
argument_list|)
expr_stmt|;
name|pv_entry_count
operator|--
expr_stmt|;
name|pc
operator|->
name|pc_map
index|[
name|field
index|]
operator||=
name|bitmask
expr_stmt|;
block|}
block|}
if|if
condition|(
name|allfree
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvchunk
argument_list|,
name|pc
argument_list|,
name|pc_list
argument_list|)
expr_stmt|;
name|pmap_free_pv_chunk
argument_list|(
name|pc
argument_list|)
expr_stmt|;
block|}
block|}
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|cpu_tlb_flushID
argument_list|()
expr_stmt|;
name|cpu_cpwait
argument_list|()
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/***************************************************  * Low level mapping routines.....  ***************************************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ARM_HAVE_SUPERSECTIONS
end_ifdef

begin_comment
comment|/* Map a super section into the KVA. */
end_comment

begin_function
name|void
name|pmap_kenter_supersection
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|uint64_t
name|pa
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|pd_entry_t
name|pd
init|=
name|L1_S_PROTO
operator||
name|L1_S_SUPERSEC
operator||
operator|(
name|pa
operator|&
name|L1_SUP_FRAME
operator|)
operator||
operator|(
operator|(
operator|(
name|pa
operator|>>
literal|32
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|20
operator|)
operator||
name|L1_S_PROT
argument_list|(
name|PTE_KERNEL
argument_list|,
name|VM_PROT_READ
operator||
name|VM_PROT_WRITE
operator||
name|VM_PROT_EXECUTE
argument_list|)
operator||
name|L1_S_DOM
argument_list|(
name|PMAP_DOMAIN_KERNEL
argument_list|)
decl_stmt|;
name|struct
name|l1_ttable
modifier|*
name|l1
decl_stmt|;
name|vm_offset_t
name|va0
decl_stmt|,
name|va_end
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
operator|(
name|va
operator||
name|pa
operator|)
operator|&
name|L1_SUP_OFFSET
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"Not a valid super section mapping"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_CACHE
condition|)
name|pd
operator||=
name|pte_l1_s_cache_mode
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|SECTION_PT
condition|)
name|pd
operator||=
name|pte_l1_s_cache_mode_pt
expr_stmt|;
name|va0
operator|=
name|va
operator|&
name|L1_SUP_FRAME
expr_stmt|;
name|va_end
operator|=
name|va
operator|+
name|L1_SUP_SIZE
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|l1
argument_list|,
argument|&l1_list
argument_list|,
argument|l1_link
argument_list|)
block|{
name|va
operator|=
name|va0
expr_stmt|;
for|for
control|(
init|;
name|va
operator|<
name|va_end
condition|;
name|va
operator|+=
name|L1_S_SIZE
control|)
block|{
name|l1
operator|->
name|l1_kva
index|[
name|L1_IDX
argument_list|(
name|va
argument_list|)
index|]
operator|=
name|pd
expr_stmt|;
name|PTE_SYNC
argument_list|(
operator|&
name|l1
operator|->
name|l1_kva
index|[
name|L1_IDX
argument_list|(
name|va
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Map a section into the KVA. */
end_comment

begin_function
name|void
name|pmap_kenter_section
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|vm_offset_t
name|pa
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|pd_entry_t
name|pd
init|=
name|L1_S_PROTO
operator||
name|pa
operator||
name|L1_S_PROT
argument_list|(
name|PTE_KERNEL
argument_list|,
name|VM_PROT_READ
operator||
name|VM_PROT_WRITE
operator||
name|VM_PROT_EXECUTE
argument_list|)
operator||
name|L1_S_REF
operator||
name|L1_S_DOM
argument_list|(
name|PMAP_DOMAIN_KERNEL
argument_list|)
decl_stmt|;
name|struct
name|l1_ttable
modifier|*
name|l1
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
operator|(
name|va
operator||
name|pa
operator|)
operator|&
name|L1_S_OFFSET
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"Not a valid section mapping"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_CACHE
condition|)
name|pd
operator||=
name|pte_l1_s_cache_mode
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|SECTION_PT
condition|)
name|pd
operator||=
name|pte_l1_s_cache_mode_pt
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|l1
argument_list|,
argument|&l1_list
argument_list|,
argument|l1_link
argument_list|)
block|{
name|l1
operator|->
name|l1_kva
index|[
name|L1_IDX
argument_list|(
name|va
argument_list|)
index|]
operator|=
name|pd
expr_stmt|;
name|PTE_SYNC
argument_list|(
operator|&
name|l1
operator|->
name|l1_kva
index|[
name|L1_IDX
argument_list|(
name|va
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
name|cpu_tlb_flushID_SE
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|cpu_cpwait
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Make a temporary mapping for a physical address.  This is only intended  * to be used for panic dumps.  */
end_comment

begin_function
name|void
modifier|*
name|pmap_kenter_temp
parameter_list|(
name|vm_paddr_t
name|pa
parameter_list|,
name|int
name|i
parameter_list|)
block|{
name|vm_offset_t
name|va
decl_stmt|;
name|va
operator|=
operator|(
name|vm_offset_t
operator|)
name|crashdumpmap
operator|+
operator|(
name|i
operator|*
name|PAGE_SIZE
operator|)
expr_stmt|;
name|pmap_kenter
argument_list|(
name|va
argument_list|,
name|pa
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|void
operator|*
operator|)
name|crashdumpmap
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * add a wired page to the kva  * note that in order for the mapping to take effect -- you  * should do a invltlb after doing the pmap_kenter...  */
end_comment

begin_function
specifier|static
name|PMAP_INLINE
name|void
name|pmap_kenter_internal
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|vm_offset_t
name|pa
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|l2_bucket
modifier|*
name|l2b
decl_stmt|;
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|;
name|pt_entry_t
name|opte
decl_stmt|;
name|PDEBUG
argument_list|(
literal|1
argument_list|,
name|printf
argument_list|(
literal|"pmap_kenter: va = %08x, pa = %08x\n"
argument_list|,
operator|(
name|uint32_t
operator|)
name|va
argument_list|,
operator|(
name|uint32_t
operator|)
name|pa
argument_list|)
argument_list|)
expr_stmt|;
name|l2b
operator|=
name|pmap_get_l2_bucket
argument_list|(
name|pmap_kernel
argument_list|()
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|l2b
operator|==
name|NULL
condition|)
name|l2b
operator|=
name|pmap_grow_l2_bucket
argument_list|(
name|pmap_kernel
argument_list|()
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|l2b
operator|!=
name|NULL
argument_list|,
operator|(
literal|"No L2 Bucket"
operator|)
argument_list|)
expr_stmt|;
name|ptep
operator|=
operator|&
name|l2b
operator|->
name|l2b_kva
index|[
name|l2pte_index
argument_list|(
name|va
argument_list|)
index|]
expr_stmt|;
name|opte
operator|=
operator|*
name|ptep
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|KENTER_CACHE
condition|)
operator|*
name|ptep
operator|=
name|L2_S_PROTO
operator||
name|l2s_mem_types
index|[
name|PTE_CACHE
index|]
operator||
name|pa
operator||
name|L2_S_REF
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|KENTER_DEVICE
condition|)
operator|*
name|ptep
operator|=
name|L2_S_PROTO
operator||
name|l2s_mem_types
index|[
name|PTE_DEVICE
index|]
operator||
name|pa
operator||
name|L2_S_REF
expr_stmt|;
else|else
operator|*
name|ptep
operator|=
name|L2_S_PROTO
operator||
name|l2s_mem_types
index|[
name|PTE_NOCACHE
index|]
operator||
name|pa
operator||
name|L2_S_REF
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|KENTER_CACHE
condition|)
block|{
name|pmap_set_prot
argument_list|(
name|ptep
argument_list|,
name|VM_PROT_READ
operator||
name|VM_PROT_WRITE
argument_list|,
name|flags
operator|&
name|KENTER_USER
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pmap_set_prot
argument_list|(
name|ptep
argument_list|,
name|VM_PROT_READ
operator||
name|VM_PROT_WRITE
operator||
name|VM_PROT_EXECUTE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|PTE_SYNC
argument_list|(
name|ptep
argument_list|)
expr_stmt|;
if|if
condition|(
name|l2pte_valid
argument_list|(
name|opte
argument_list|)
condition|)
block|{
if|if
condition|(
name|L2_S_EXECUTABLE
argument_list|(
name|opte
argument_list|)
operator|||
name|L2_S_EXECUTABLE
argument_list|(
operator|*
name|ptep
argument_list|)
condition|)
name|cpu_tlb_flushID_SE
argument_list|(
name|va
argument_list|)
expr_stmt|;
else|else
name|cpu_tlb_flushD_SE
argument_list|(
name|va
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|opte
operator|==
literal|0
condition|)
name|l2b
operator|->
name|l2b_occupancy
operator|++
expr_stmt|;
block|}
name|cpu_cpwait
argument_list|()
expr_stmt|;
name|PDEBUG
argument_list|(
literal|1
argument_list|,
name|printf
argument_list|(
literal|"pmap_kenter: pte = %08x, opte = %08x, npte = %08x\n"
argument_list|,
operator|(
name|uint32_t
operator|)
name|ptep
argument_list|,
name|opte
argument_list|,
operator|*
name|ptep
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pmap_kenter
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|vm_paddr_t
name|pa
parameter_list|)
block|{
name|pmap_kenter_internal
argument_list|(
name|va
argument_list|,
name|pa
argument_list|,
name|KENTER_CACHE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pmap_kenter_nocache
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|vm_paddr_t
name|pa
parameter_list|)
block|{
name|pmap_kenter_internal
argument_list|(
name|va
argument_list|,
name|pa
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pmap_kenter_device
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|vm_paddr_t
name|pa
parameter_list|)
block|{
name|pmap_kenter_internal
argument_list|(
name|va
argument_list|,
name|pa
argument_list|,
name|KENTER_DEVICE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pmap_kenter_user
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|vm_paddr_t
name|pa
parameter_list|)
block|{
name|pmap_kenter_internal
argument_list|(
name|va
argument_list|,
name|pa
argument_list|,
name|KENTER_CACHE
operator||
name|KENTER_USER
argument_list|)
expr_stmt|;
comment|/* 	 * Call pmap_fault_fixup now, to make sure we'll have no exception 	 * at the first use of the new address, or bad things will happen, 	 * as we use one of these addresses in the exception handlers. 	 */
name|pmap_fault_fixup
argument_list|(
name|pmap_kernel
argument_list|()
argument_list|,
name|va
argument_list|,
name|VM_PROT_READ
operator||
name|VM_PROT_WRITE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|vm_paddr_t
name|pmap_kextract
parameter_list|(
name|vm_offset_t
name|va
parameter_list|)
block|{
if|if
condition|(
name|kernel_vm_end
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|pmap_extract_locked
argument_list|(
name|kernel_pmap
argument_list|,
name|va
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * remove a page from the kernel pagetables  */
end_comment

begin_function
name|void
name|pmap_kremove
parameter_list|(
name|vm_offset_t
name|va
parameter_list|)
block|{
name|struct
name|l2_bucket
modifier|*
name|l2b
decl_stmt|;
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|,
name|opte
decl_stmt|;
name|l2b
operator|=
name|pmap_get_l2_bucket
argument_list|(
name|pmap_kernel
argument_list|()
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|l2b
condition|)
return|return;
name|KASSERT
argument_list|(
name|l2b
operator|!=
name|NULL
argument_list|,
operator|(
literal|"No L2 Bucket"
operator|)
argument_list|)
expr_stmt|;
name|ptep
operator|=
operator|&
name|l2b
operator|->
name|l2b_kva
index|[
name|l2pte_index
argument_list|(
name|va
argument_list|)
index|]
expr_stmt|;
name|opte
operator|=
operator|*
name|ptep
expr_stmt|;
if|if
condition|(
name|l2pte_valid
argument_list|(
name|opte
argument_list|)
condition|)
block|{
name|va
operator|=
name|va
operator|&
operator|~
name|PAGE_MASK
expr_stmt|;
operator|*
name|ptep
operator|=
literal|0
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|ptep
argument_list|)
expr_stmt|;
if|if
condition|(
name|L2_S_EXECUTABLE
argument_list|(
name|opte
argument_list|)
condition|)
name|cpu_tlb_flushID_SE
argument_list|(
name|va
argument_list|)
expr_stmt|;
else|else
name|cpu_tlb_flushD_SE
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|cpu_cpwait
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *	Used to map a range of physical addresses into kernel  *	virtual address space.  *  *	The value passed in '*virt' is a suggested virtual address for  *	the mapping. Architectures which can support a direct-mapped  *	physical to virtual region can return the appropriate address  *	within that region, leaving '*virt' unchanged. Other  *	architectures should map the pages starting at '*virt' and  *	update '*virt' with the first usable address after the mapped  *	region.  */
end_comment

begin_function
name|vm_offset_t
name|pmap_map
parameter_list|(
name|vm_offset_t
modifier|*
name|virt
parameter_list|,
name|vm_offset_t
name|start
parameter_list|,
name|vm_offset_t
name|end
parameter_list|,
name|int
name|prot
parameter_list|)
block|{
name|vm_offset_t
name|sva
init|=
operator|*
name|virt
decl_stmt|;
name|vm_offset_t
name|va
init|=
name|sva
decl_stmt|;
name|PDEBUG
argument_list|(
literal|1
argument_list|,
name|printf
argument_list|(
literal|"pmap_map: virt = %08x, start = %08x, end = %08x, "
literal|"prot = %d\n"
argument_list|,
operator|(
name|uint32_t
operator|)
operator|*
name|virt
argument_list|,
operator|(
name|uint32_t
operator|)
name|start
argument_list|,
operator|(
name|uint32_t
operator|)
name|end
argument_list|,
name|prot
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|start
operator|<
name|end
condition|)
block|{
name|pmap_kenter
argument_list|(
name|va
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|va
operator|+=
name|PAGE_SIZE
expr_stmt|;
name|start
operator|+=
name|PAGE_SIZE
expr_stmt|;
block|}
operator|*
name|virt
operator|=
name|va
expr_stmt|;
return|return
operator|(
name|sva
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add a list of wired pages to the kva  * this routine is only used for temporary  * kernel mappings that do not need to have  * page modification or references recorded.  * Note that old mappings are simply written  * over.  The page *must* be wired.  */
end_comment

begin_function
name|void
name|pmap_qenter
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
modifier|*
name|m
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|pmap_kenter_internal
argument_list|(
name|va
argument_list|,
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
index|[
name|i
index|]
argument_list|)
argument_list|,
name|KENTER_CACHE
argument_list|)
expr_stmt|;
name|va
operator|+=
name|PAGE_SIZE
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * this routine jerks page mappings from the  * kernel -- it is meant only for temporary mappings.  */
end_comment

begin_function
name|void
name|pmap_qremove
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|vtophys
argument_list|(
name|va
argument_list|)
condition|)
name|pmap_kremove
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|va
operator|+=
name|PAGE_SIZE
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * pmap_object_init_pt preloads the ptes for a given object  * into the specified pmap.  This eliminates the blast of soft  * faults on process startup and immediately after an mmap.  */
end_comment

begin_function
name|void
name|pmap_object_init_pt
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|addr
parameter_list|,
name|vm_object_t
name|object
parameter_list|,
name|vm_pindex_t
name|pindex
parameter_list|,
name|vm_size_t
name|size
parameter_list|)
block|{
name|VM_OBJECT_ASSERT_WLOCKED
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|object
operator|->
name|type
operator|==
name|OBJT_DEVICE
operator|||
name|object
operator|->
name|type
operator|==
name|OBJT_SG
argument_list|,
operator|(
literal|"pmap_object_init_pt: non-device object"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	pmap_is_prefaultable:  *  *	Return whether or not the specified virtual address is elgible  *	for prefault.  */
end_comment

begin_function
name|boolean_t
name|pmap_is_prefaultable
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|addr
parameter_list|)
block|{
name|pd_entry_t
modifier|*
name|pdep
decl_stmt|;
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|;
if|if
condition|(
operator|!
name|pmap_get_pde_pte
argument_list|(
name|pmap
argument_list|,
name|addr
argument_list|,
operator|&
name|pdep
argument_list|,
operator|&
name|ptep
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|KASSERT
argument_list|(
operator|(
name|pdep
operator|!=
name|NULL
operator|&&
operator|(
name|l1pte_section_p
argument_list|(
operator|*
name|pdep
argument_list|)
operator|||
name|ptep
operator|!=
name|NULL
operator|)
operator|)
argument_list|,
operator|(
literal|"Valid mapping but no pte ?"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pdep
operator|!=
literal|0
operator|&&
operator|!
name|l1pte_section_p
argument_list|(
operator|*
name|pdep
argument_list|)
condition|)
if|if
condition|(
operator|*
name|ptep
operator|==
literal|0
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Fetch pointers to the PDE/PTE for the given pmap/VA pair.  * Returns TRUE if the mapping exists, else FALSE.  *  * NOTE: This function is only used by a couple of arm-specific modules.  * It is not safe to take any pmap locks here, since we could be right  * in the middle of debugging the pmap anyway...  *  * It is possible for this routine to return FALSE even though a valid  * mapping does exist. This is because we don't lock, so the metadata  * state may be inconsistent.  *  * NOTE: We can return a NULL *ptp in the case where the L1 pde is  * a "section" mapping.  */
end_comment

begin_function
name|boolean_t
name|pmap_get_pde_pte
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|pd_entry_t
modifier|*
modifier|*
name|pdp
parameter_list|,
name|pt_entry_t
modifier|*
modifier|*
name|ptp
parameter_list|)
block|{
name|struct
name|l2_dtable
modifier|*
name|l2
decl_stmt|;
name|pd_entry_t
modifier|*
name|pl1pd
decl_stmt|,
name|l1pd
decl_stmt|;
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|;
name|u_short
name|l1idx
decl_stmt|;
if|if
condition|(
name|pmap
operator|->
name|pm_l1
operator|==
name|NULL
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|l1idx
operator|=
name|L1_IDX
argument_list|(
name|va
argument_list|)
expr_stmt|;
operator|*
name|pdp
operator|=
name|pl1pd
operator|=
operator|&
name|pmap
operator|->
name|pm_l1
operator|->
name|l1_kva
index|[
name|l1idx
index|]
expr_stmt|;
name|l1pd
operator|=
operator|*
name|pl1pd
expr_stmt|;
if|if
condition|(
name|l1pte_section_p
argument_list|(
name|l1pd
argument_list|)
condition|)
block|{
operator|*
name|ptp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
if|if
condition|(
name|pmap
operator|->
name|pm_l2
operator|==
name|NULL
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|l2
operator|=
name|pmap
operator|->
name|pm_l2
index|[
name|L2_IDX
argument_list|(
name|l1idx
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|l2
operator|==
name|NULL
operator|||
operator|(
name|ptep
operator|=
name|l2
operator|->
name|l2_bucket
index|[
name|L2_BUCKET
argument_list|(
name|l1idx
argument_list|)
index|]
operator|.
name|l2b_kva
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
operator|*
name|ptp
operator|=
operator|&
name|ptep
index|[
name|l2pte_index
argument_list|(
name|va
argument_list|)
index|]
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *      Routine:        pmap_remove_all  *      Function:  *              Removes this physical page from  *              all physical maps in which it resides.  *              Reflects back modify bits to the pager.  *  *      Notes:  *              Original versions of this routine were very  *              inefficient because they iteratively called  *              pmap_remove (slow...)  */
end_comment

begin_function
name|void
name|pmap_remove_all
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|struct
name|md_page
modifier|*
name|pvh
decl_stmt|;
name|pv_entry_t
name|pv
decl_stmt|;
name|pmap_t
name|pmap
decl_stmt|;
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|;
name|struct
name|l2_bucket
modifier|*
name|l2b
decl_stmt|;
name|boolean_t
name|flush
init|=
name|FALSE
decl_stmt|;
name|pmap_t
name|curpmap
decl_stmt|;
name|u_int
name|is_exec
init|=
literal|0
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_remove_all: page %p is not managed"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_FICTITIOUS
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|small_mappings
goto|;
name|pvh
operator|=
name|pa_to_pvh
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|pv
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pvh
operator|->
name|pv_list
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|pmap
operator|=
name|PV_PMAP
argument_list|(
name|pv
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|pd_entry_t
modifier|*
name|pl1pd
decl_stmt|;
name|pl1pd
operator|=
operator|&
name|pmap
operator|->
name|pm_l1
operator|->
name|l1_kva
index|[
name|L1_IDX
argument_list|(
name|pv
operator|->
name|pv_va
argument_list|)
index|]
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
operator|*
name|pl1pd
operator|&
name|L1_TYPE_MASK
operator|)
operator|==
name|L1_S_PROTO
argument_list|,
operator|(
literal|"pmap_remove_all: valid section mapping expected"
operator|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|pmap_demote_section
argument_list|(
name|pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
name|small_mappings
label|:
name|curpmap
operator|=
name|vmspace_pmap
argument_list|(
name|curproc
operator|->
name|p_vmspace
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|pv
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|pmap
operator|=
name|PV_PMAP
argument_list|(
name|pv
argument_list|)
expr_stmt|;
if|if
condition|(
name|flush
operator|==
name|FALSE
operator|&&
operator|(
name|pmap
operator|==
name|curpmap
operator|||
name|pmap
operator|==
name|pmap_kernel
argument_list|()
operator|)
condition|)
name|flush
operator|=
name|TRUE
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|l2b
operator|=
name|pmap_get_l2_bucket
argument_list|(
name|pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|l2b
operator|!=
name|NULL
argument_list|,
operator|(
literal|"No l2 bucket"
operator|)
argument_list|)
expr_stmt|;
name|ptep
operator|=
operator|&
name|l2b
operator|->
name|l2b_kva
index|[
name|l2pte_index
argument_list|(
name|pv
operator|->
name|pv_va
argument_list|)
index|]
expr_stmt|;
name|is_exec
operator||=
name|PTE_BEEN_EXECD
argument_list|(
operator|*
name|ptep
argument_list|)
expr_stmt|;
operator|*
name|ptep
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pmap_is_current
argument_list|(
name|pmap
argument_list|)
condition|)
name|PTE_SYNC
argument_list|(
name|ptep
argument_list|)
expr_stmt|;
name|pmap_free_l2_bucket
argument_list|(
name|pmap
argument_list|,
name|l2b
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|--
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|,
name|pv
argument_list|,
name|pv_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|pv
operator|->
name|pv_flags
operator|&
name|PVF_WIRED
condition|)
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|--
expr_stmt|;
name|pmap_free_pv_entry
argument_list|(
name|pmap
argument_list|,
name|pv
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flush
condition|)
block|{
if|if
condition|(
name|is_exec
condition|)
name|cpu_tlb_flushID
argument_list|()
expr_stmt|;
else|else
name|cpu_tlb_flushD
argument_list|()
expr_stmt|;
name|cpu_cpwait
argument_list|()
expr_stmt|;
block|}
name|vm_page_aflag_clear
argument_list|(
name|m
argument_list|,
name|PGA_WRITEABLE
argument_list|)
expr_stmt|;
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|pmap_change_attr
parameter_list|(
name|vm_offset_t
name|sva
parameter_list|,
name|vm_size_t
name|len
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|vm_offset_t
name|base
decl_stmt|,
name|offset
decl_stmt|,
name|tmpva
decl_stmt|;
name|vm_size_t
name|size
decl_stmt|;
name|struct
name|l2_bucket
modifier|*
name|l2b
decl_stmt|;
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|,
name|pte
decl_stmt|;
name|vm_offset_t
name|next_bucket
decl_stmt|;
name|PMAP_LOCK
argument_list|(
name|kernel_pmap
argument_list|)
expr_stmt|;
name|base
operator|=
name|trunc_page
argument_list|(
name|sva
argument_list|)
expr_stmt|;
name|offset
operator|=
name|sva
operator|&
name|PAGE_MASK
expr_stmt|;
name|size
operator|=
name|roundup
argument_list|(
name|offset
operator|+
name|len
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
for|for
control|(
name|tmpva
operator|=
name|base
init|;
name|tmpva
operator|<
name|base
operator|+
name|size
condition|;
control|)
block|{
name|next_bucket
operator|=
name|L2_NEXT_BUCKET
argument_list|(
name|tmpva
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_bucket
operator|>
name|base
operator|+
name|size
condition|)
name|next_bucket
operator|=
name|base
operator|+
name|size
expr_stmt|;
name|l2b
operator|=
name|pmap_get_l2_bucket
argument_list|(
name|kernel_pmap
argument_list|,
name|tmpva
argument_list|)
expr_stmt|;
if|if
condition|(
name|l2b
operator|==
name|NULL
condition|)
block|{
name|tmpva
operator|=
name|next_bucket
expr_stmt|;
continue|continue;
block|}
name|ptep
operator|=
operator|&
name|l2b
operator|->
name|l2b_kva
index|[
name|l2pte_index
argument_list|(
name|tmpva
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|ptep
operator|==
literal|0
condition|)
block|{
name|PMAP_UNLOCK
argument_list|(
name|kernel_pmap
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|pte
operator|=
operator|*
name|ptep
operator|&
operator|~
name|L2_S_CACHE_MASK
expr_stmt|;
name|cpu_idcache_wbinv_range
argument_list|(
name|tmpva
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|pmap_l2cache_wbinv_range
argument_list|(
name|tmpva
argument_list|,
name|pte
operator|&
name|L2_S_FRAME
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
operator|*
name|ptep
operator|=
name|pte
expr_stmt|;
name|cpu_tlb_flushID_SE
argument_list|(
name|tmpva
argument_list|)
expr_stmt|;
name|cpu_cpwait
argument_list|()
expr_stmt|;
name|dprintf
argument_list|(
literal|"%s: for va:%x ptep:%x pte:%x\n"
argument_list|,
name|__func__
argument_list|,
name|tmpva
argument_list|,
operator|(
name|uint32_t
operator|)
name|ptep
argument_list|,
name|pte
argument_list|)
expr_stmt|;
name|tmpva
operator|+=
name|PAGE_SIZE
expr_stmt|;
block|}
name|PMAP_UNLOCK
argument_list|(
name|kernel_pmap
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	Set the physical protection on the  *	specified range of this map as requested.  */
end_comment

begin_function
name|void
name|pmap_protect
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|sva
parameter_list|,
name|vm_offset_t
name|eva
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|)
block|{
name|struct
name|l2_bucket
modifier|*
name|l2b
decl_stmt|;
name|struct
name|md_page
modifier|*
name|pvh
decl_stmt|;
name|struct
name|pv_entry
modifier|*
name|pve
decl_stmt|;
name|pd_entry_t
modifier|*
name|pl1pd
decl_stmt|,
name|l1pd
decl_stmt|;
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|,
name|pte
decl_stmt|;
name|vm_offset_t
name|next_bucket
decl_stmt|;
name|u_int
name|is_exec
decl_stmt|,
name|is_refd
decl_stmt|;
name|int
name|flush
decl_stmt|;
if|if
condition|(
operator|(
name|prot
operator|&
name|VM_PROT_READ
operator|)
operator|==
literal|0
condition|)
block|{
name|pmap_remove
argument_list|(
name|pmap
argument_list|,
name|sva
argument_list|,
name|eva
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|prot
operator|&
name|VM_PROT_WRITE
condition|)
block|{
comment|/* 		 * If this is a read->write transition, just ignore it and let 		 * vm_fault() take care of it later. 		 */
return|return;
block|}
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
comment|/* 	 * OK, at this point, we know we're doing write-protect operation. 	 * If the pmap is active, write-back the range. 	 */
name|flush
operator|=
operator|(
operator|(
name|eva
operator|-
name|sva
operator|)
operator|>=
operator|(
name|PAGE_SIZE
operator|*
literal|4
operator|)
operator|)
condition|?
literal|0
else|:
operator|-
literal|1
expr_stmt|;
name|is_exec
operator|=
name|is_refd
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|sva
operator|<
name|eva
condition|)
block|{
name|next_bucket
operator|=
name|L2_NEXT_BUCKET
argument_list|(
name|sva
argument_list|)
expr_stmt|;
comment|/* 		 * Check for large page. 		 */
name|pl1pd
operator|=
operator|&
name|pmap
operator|->
name|pm_l1
operator|->
name|l1_kva
index|[
name|L1_IDX
argument_list|(
name|sva
argument_list|)
index|]
expr_stmt|;
name|l1pd
operator|=
operator|*
name|pl1pd
expr_stmt|;
if|if
condition|(
operator|(
name|l1pd
operator|&
name|L1_TYPE_MASK
operator|)
operator|==
name|L1_S_PROTO
condition|)
block|{
name|KASSERT
argument_list|(
name|pmap
operator|!=
name|pmap_kernel
argument_list|()
argument_list|,
operator|(
literal|"pmap_protect: trying to modify "
literal|"kernel section protections"
operator|)
argument_list|)
expr_stmt|;
comment|/* 			 * Are we protecting the entire large page? If not, 			 * demote the mapping and fall through. 			 */
if|if
condition|(
name|sva
operator|+
name|L1_S_SIZE
operator|==
name|next_bucket
operator|&&
name|eva
operator|>=
name|next_bucket
condition|)
block|{
name|l1pd
operator|&=
operator|~
operator|(
name|L1_S_PROT_MASK
operator||
name|L1_S_XN
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|prot
operator|&
name|VM_PROT_EXECUTE
operator|)
condition|)
name|l1pd
operator||=
name|L1_S_XN
expr_stmt|;
comment|/* 				 * At this point we are always setting 				 * write-protect bit. 				 */
name|l1pd
operator||=
name|L1_S_APX
expr_stmt|;
comment|/* All managed superpages are user pages. */
name|l1pd
operator||=
name|L1_S_PROT_U
expr_stmt|;
operator|*
name|pl1pd
operator|=
name|l1pd
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|pl1pd
argument_list|)
expr_stmt|;
name|pvh
operator|=
name|pa_to_pvh
argument_list|(
name|l1pd
operator|&
name|L1_S_FRAME
argument_list|)
expr_stmt|;
name|pve
operator|=
name|pmap_find_pv
argument_list|(
name|pvh
argument_list|,
name|pmap
argument_list|,
name|trunc_1mpage
argument_list|(
name|sva
argument_list|)
argument_list|)
expr_stmt|;
name|pve
operator|->
name|pv_flags
operator|&=
operator|~
name|PVF_WRITE
expr_stmt|;
name|sva
operator|=
name|next_bucket
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|!
name|pmap_demote_section
argument_list|(
name|pmap
argument_list|,
name|sva
argument_list|)
condition|)
block|{
comment|/* The large page mapping was destroyed. */
name|sva
operator|=
name|next_bucket
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|next_bucket
operator|>
name|eva
condition|)
name|next_bucket
operator|=
name|eva
expr_stmt|;
name|l2b
operator|=
name|pmap_get_l2_bucket
argument_list|(
name|pmap
argument_list|,
name|sva
argument_list|)
expr_stmt|;
if|if
condition|(
name|l2b
operator|==
name|NULL
condition|)
block|{
name|sva
operator|=
name|next_bucket
expr_stmt|;
continue|continue;
block|}
name|ptep
operator|=
operator|&
name|l2b
operator|->
name|l2b_kva
index|[
name|l2pte_index
argument_list|(
name|sva
argument_list|)
index|]
expr_stmt|;
while|while
condition|(
name|sva
operator|<
name|next_bucket
condition|)
block|{
if|if
condition|(
operator|(
name|pte
operator|=
operator|*
name|ptep
operator|)
operator|!=
literal|0
operator|&&
name|L2_S_WRITABLE
argument_list|(
name|pte
argument_list|)
condition|)
block|{
name|struct
name|vm_page
modifier|*
name|m
decl_stmt|;
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|l2pte_pa
argument_list|(
name|pte
argument_list|)
argument_list|)
expr_stmt|;
name|pmap_set_prot
argument_list|(
name|ptep
argument_list|,
name|prot
argument_list|,
operator|!
operator|(
name|pmap
operator|==
name|pmap_kernel
argument_list|()
operator|)
argument_list|)
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|ptep
argument_list|)
expr_stmt|;
name|pmap_modify_pv
argument_list|(
name|m
argument_list|,
name|pmap
argument_list|,
name|sva
argument_list|,
name|PVF_WRITE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flush
operator|>=
literal|0
condition|)
block|{
name|flush
operator|++
expr_stmt|;
name|is_exec
operator||=
name|PTE_BEEN_EXECD
argument_list|(
name|pte
argument_list|)
expr_stmt|;
name|is_refd
operator||=
name|PTE_BEEN_REFD
argument_list|(
name|pte
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|PTE_BEEN_EXECD
argument_list|(
name|pte
argument_list|)
condition|)
name|cpu_tlb_flushID_SE
argument_list|(
name|sva
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|PTE_BEEN_REFD
argument_list|(
name|pte
argument_list|)
condition|)
name|cpu_tlb_flushD_SE
argument_list|(
name|sva
argument_list|)
expr_stmt|;
block|}
block|}
name|sva
operator|+=
name|PAGE_SIZE
expr_stmt|;
name|ptep
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|flush
condition|)
block|{
if|if
condition|(
name|is_exec
condition|)
name|cpu_tlb_flushID
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|is_refd
condition|)
name|cpu_tlb_flushD
argument_list|()
expr_stmt|;
name|cpu_cpwait
argument_list|()
expr_stmt|;
block|}
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Insert the given physical page (p) at  *	the specified virtual address (v) in the  *	target physical map with the protection requested.  *  *	If specified, the page will be wired down, meaning  *	that the related pte can not be reclaimed.  *  *	NB:  This is the only routine which MAY NOT lazy-evaluate  *	or lose information.  That is, this routine must actually  *	insert this page into the given map NOW.  */
end_comment

begin_function
name|void
name|pmap_enter
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_prot_t
name|access
parameter_list|,
name|vm_page_t
name|m
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|,
name|boolean_t
name|wired
parameter_list|)
block|{
name|struct
name|l2_bucket
modifier|*
name|l2b
decl_stmt|;
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|pmap_enter_locked
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|access
argument_list|,
name|m
argument_list|,
name|prot
argument_list|,
name|wired
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
comment|/* 	 * If both the l2b_occupancy and the reservation are fully 	 * populated, then attempt promotion. 	 */
name|l2b
operator|=
name|pmap_get_l2_bucket
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|l2b
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|l2b
operator|->
name|l2b_occupancy
operator|==
name|L2_PTE_NUM_TOTAL
operator|)
operator|&&
name|sp_enabled
operator|&&
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_FICTITIOUS
operator|)
operator|==
literal|0
operator|&&
name|vm_reserv_level_iffullpop
argument_list|(
name|m
argument_list|)
operator|==
literal|0
condition|)
name|pmap_promote_section
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	The pvh global and pmap locks must be held.  */
end_comment

begin_function
specifier|static
name|void
name|pmap_enter_locked
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_prot_t
name|access
parameter_list|,
name|vm_page_t
name|m
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|,
name|boolean_t
name|wired
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|l2_bucket
modifier|*
name|l2b
init|=
name|NULL
decl_stmt|;
name|struct
name|vm_page
modifier|*
name|om
decl_stmt|;
name|struct
name|pv_entry
modifier|*
name|pve
init|=
name|NULL
decl_stmt|;
name|pd_entry_t
modifier|*
name|pl1pd
decl_stmt|,
name|l1pd
decl_stmt|;
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|,
name|npte
decl_stmt|,
name|opte
decl_stmt|;
name|u_int
name|nflags
decl_stmt|;
name|u_int
name|is_exec
decl_stmt|,
name|is_refd
decl_stmt|;
name|vm_paddr_t
name|pa
decl_stmt|;
name|u_char
name|user
decl_stmt|;
name|PMAP_ASSERT_LOCKED
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|rw_assert
argument_list|(
operator|&
name|pvh_global_lock
argument_list|,
name|RA_WLOCKED
argument_list|)
expr_stmt|;
if|if
condition|(
name|va
operator|==
name|vector_page
condition|)
block|{
name|pa
operator|=
name|systempage
operator|.
name|pv_pa
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|KASSERT
argument_list|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|!=
literal|0
operator|||
name|vm_page_xbusied
argument_list|(
name|m
argument_list|)
operator|||
operator|(
name|flags
operator|&
name|M_NOWAIT
operator|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"pmap_enter_locked: page %p is not busy"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
name|pa
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|pl1pd
operator|=
operator|&
name|pmap
operator|->
name|pm_l1
operator|->
name|l1_kva
index|[
name|L1_IDX
argument_list|(
name|va
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|va
operator|<
name|VM_MAXUSER_ADDRESS
operator|)
operator|&&
operator|(
operator|*
name|pl1pd
operator|&
name|L1_TYPE_MASK
operator|)
operator|==
name|L1_S_PROTO
condition|)
block|{
operator|(
name|void
operator|)
name|pmap_demote_section
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
block|}
name|user
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Make sure userland mappings get the right permissions 	 */
if|if
condition|(
name|pmap
operator|!=
name|pmap_kernel
argument_list|()
operator|&&
name|va
operator|!=
name|vector_page
condition|)
name|user
operator|=
literal|1
expr_stmt|;
name|nflags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|prot
operator|&
name|VM_PROT_WRITE
condition|)
name|nflags
operator||=
name|PVF_WRITE
expr_stmt|;
if|if
condition|(
name|wired
condition|)
name|nflags
operator||=
name|PVF_WIRED
expr_stmt|;
name|PDEBUG
argument_list|(
literal|1
argument_list|,
name|printf
argument_list|(
literal|"pmap_enter: pmap = %08x, va = %08x, m = %08x, "
literal|"prot = %x, wired = %x\n"
argument_list|,
operator|(
name|uint32_t
operator|)
name|pmap
argument_list|,
name|va
argument_list|,
operator|(
name|uint32_t
operator|)
name|m
argument_list|,
name|prot
argument_list|,
name|wired
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap
operator|==
name|pmap_kernel
argument_list|()
condition|)
block|{
name|l2b
operator|=
name|pmap_get_l2_bucket
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|l2b
operator|==
name|NULL
condition|)
name|l2b
operator|=
name|pmap_grow_l2_bucket
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|do_l2b_alloc
label|:
name|l2b
operator|=
name|pmap_alloc_l2_bucket
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|l2b
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|M_WAITOK
condition|)
block|{
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|VM_WAIT
expr_stmt|;
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
goto|goto
name|do_l2b_alloc
goto|;
block|}
return|return;
block|}
block|}
name|pl1pd
operator|=
operator|&
name|pmap
operator|->
name|pm_l1
operator|->
name|l1_kva
index|[
name|L1_IDX
argument_list|(
name|va
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|pl1pd
operator|&
name|L1_TYPE_MASK
operator|)
operator|==
name|L1_S_PROTO
condition|)
name|panic
argument_list|(
literal|"pmap_enter: attempt to enter on 1MB page, va: %#x"
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|ptep
operator|=
operator|&
name|l2b
operator|->
name|l2b_kva
index|[
name|l2pte_index
argument_list|(
name|va
argument_list|)
index|]
expr_stmt|;
name|opte
operator|=
operator|*
name|ptep
expr_stmt|;
name|npte
operator|=
name|pa
expr_stmt|;
name|is_exec
operator|=
name|is_refd
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|opte
condition|)
block|{
if|if
condition|(
name|l2pte_pa
argument_list|(
name|opte
argument_list|)
operator|==
name|pa
condition|)
block|{
comment|/* 			 * We're changing the attrs of an existing mapping. 			 */
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|pmap_modify_pv
argument_list|(
name|m
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|,
name|PVF_WRITE
operator||
name|PVF_WIRED
argument_list|,
name|nflags
argument_list|)
expr_stmt|;
name|is_exec
operator||=
name|PTE_BEEN_EXECD
argument_list|(
name|opte
argument_list|)
expr_stmt|;
name|is_refd
operator||=
name|PTE_BEEN_REFD
argument_list|(
name|opte
argument_list|)
expr_stmt|;
goto|goto
name|validate
goto|;
block|}
if|if
condition|(
operator|(
name|om
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|l2pte_pa
argument_list|(
name|opte
argument_list|)
argument_list|)
operator|)
condition|)
block|{
comment|/* 			 * Replacing an existing mapping with a new one. 			 * It is part of our managed memory so we 			 * must remove it from the PV list 			 */
if|if
condition|(
operator|(
name|pve
operator|=
name|pmap_remove_pv
argument_list|(
name|om
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|)
operator|)
condition|)
block|{
name|is_exec
operator||=
name|PTE_BEEN_EXECD
argument_list|(
name|opte
argument_list|)
expr_stmt|;
name|is_refd
operator||=
name|PTE_BEEN_REFD
argument_list|(
name|opte
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|&&
operator|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|)
condition|)
name|pmap_free_pv_entry
argument_list|(
name|pmap
argument_list|,
name|pve
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* 		 * Keep the stats up to date 		 */
name|l2b
operator|->
name|l2b_occupancy
operator|++
expr_stmt|;
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|++
expr_stmt|;
block|}
comment|/* 	 * Enter on the PV list if part of our managed memory. 	 */
if|if
condition|(
operator|(
name|m
operator|&&
operator|!
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
operator|!
name|pve
operator|)
operator|&&
operator|(
name|pve
operator|=
name|pmap_get_pv_entry
argument_list|(
name|pmap
argument_list|,
name|FALSE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"pmap_enter: no pv entries"
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|va
operator|<
name|kmi
operator|.
name|clean_sva
operator|||
name|va
operator|>=
name|kmi
operator|.
name|clean_eva
argument_list|,
operator|(
literal|"pmap_enter: managed mapping within the clean submap"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pve
operator|!=
name|NULL
argument_list|,
operator|(
literal|"No pv"
operator|)
argument_list|)
expr_stmt|;
name|pmap_enter_pv
argument_list|(
name|m
argument_list|,
name|pve
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|,
name|nflags
argument_list|)
expr_stmt|;
block|}
name|validate
label|:
comment|/* Make the new PTE valid */
name|npte
operator||=
name|L2_S_PROTO
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
name|npte
operator||=
name|L2_SHARED
expr_stmt|;
endif|#
directive|endif
comment|/* Set defaults first - kernel read access */
name|npte
operator||=
name|L2_APX
expr_stmt|;
name|npte
operator||=
name|L2_S_PROT_R
expr_stmt|;
comment|/* Set "referenced" flag */
name|npte
operator||=
name|L2_S_REF
expr_stmt|;
comment|/* Now tune APs as desired */
if|if
condition|(
name|user
condition|)
name|npte
operator||=
name|L2_S_PROT_U
expr_stmt|;
comment|/* 	 * If this is not a vector_page 	 * then continue setting mapping parameters 	 */
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|prot
operator|&
operator|(
name|VM_PROT_ALL
operator|)
condition|)
block|{
name|vm_page_aflag_set
argument_list|(
name|m
argument_list|,
name|PGA_REFERENCED
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Need to do page referenced emulation. 				 */
name|npte
operator|&=
operator|~
name|L2_S_REF
expr_stmt|;
block|}
block|}
if|if
condition|(
name|prot
operator|&
name|VM_PROT_WRITE
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|==
literal|0
condition|)
block|{
name|vm_page_aflag_set
argument_list|(
name|m
argument_list|,
name|PGA_WRITEABLE
argument_list|)
expr_stmt|;
comment|/* 				 * XXX: Skip modified bit emulation for now. 				 *	The emulation reveals problems 				 *	that result in random failures 				 *	during memory allocation on some 				 *	platforms. 				 *	Therefore, the page is marked RW 				 *	immediately. 				 */
name|npte
operator|&=
operator|~
operator|(
name|L2_APX
operator|)
expr_stmt|;
name|vm_page_dirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
else|else
name|npte
operator|&=
operator|~
operator|(
name|L2_APX
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|prot
operator|&
name|VM_PROT_EXECUTE
operator|)
condition|)
name|npte
operator||=
name|L2_XN
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|md
operator|.
name|pv_memattr
operator|!=
name|VM_MEMATTR_UNCACHEABLE
condition|)
name|npte
operator||=
name|pte_l2_s_cache_mode
expr_stmt|;
block|}
name|CTR5
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"enter: pmap:%p va:%x prot:%x pte:%x->%x"
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|,
name|prot
argument_list|,
name|opte
argument_list|,
name|npte
argument_list|)
expr_stmt|;
comment|/* 	 * If this is just a wiring change, the two PTEs will be 	 * identical, so there's no need to update the page table. 	 */
if|if
condition|(
name|npte
operator|!=
name|opte
condition|)
block|{
name|boolean_t
name|is_cached
init|=
name|pmap_is_current
argument_list|(
name|pmap
argument_list|)
decl_stmt|;
operator|*
name|ptep
operator|=
name|npte
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|ptep
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_cached
condition|)
block|{
comment|/* 			 * We only need to frob the cache/tlb if this pmap 			 * is current 			 */
if|if
condition|(
name|L1_IDX
argument_list|(
name|va
argument_list|)
operator|!=
name|L1_IDX
argument_list|(
name|vector_page
argument_list|)
operator|&&
name|l2pte_valid
argument_list|(
name|npte
argument_list|)
condition|)
block|{
comment|/* 				 * This mapping is likely to be accessed as 				 * soon as we return to userland. Fix up the 				 * L1 entry to avoid taking another 				 * page/domain fault. 				 */
name|l1pd
operator|=
name|l2b
operator|->
name|l2b_phys
operator||
name|L1_C_DOM
argument_list|(
name|pmap
operator|->
name|pm_domain
argument_list|)
operator||
name|L1_C_PROTO
expr_stmt|;
if|if
condition|(
operator|*
name|pl1pd
operator|!=
name|l1pd
condition|)
block|{
operator|*
name|pl1pd
operator|=
name|l1pd
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|pl1pd
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|is_exec
condition|)
name|cpu_tlb_flushID_SE
argument_list|(
name|va
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|is_refd
condition|)
name|cpu_tlb_flushD_SE
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|cpu_cpwait
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|pmap
operator|!=
name|pmap_kernel
argument_list|()
operator|)
operator|&&
operator|(
name|pmap
operator|==
operator|&
name|curproc
operator|->
name|p_vmspace
operator|->
name|vm_pmap
operator|)
condition|)
name|cpu_icache_sync_range
argument_list|(
name|va
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Maps a sequence of resident pages belonging to the same object.  * The sequence begins with the given page m_start.  This page is  * mapped at the given virtual address start.  Each subsequent page is  * mapped at a virtual address that is offset from start by the same  * amount as the page is offset from m_start within the object.  The  * last page in the sequence is the page with the largest offset from  * m_start that can be mapped at a virtual address less than the given  * virtual address end.  Not every virtual page between start and end  * is mapped; only those for which a resident page exists with the  * corresponding offset from m_start are mapped.  */
end_comment

begin_function
name|void
name|pmap_enter_object
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|start
parameter_list|,
name|vm_offset_t
name|end
parameter_list|,
name|vm_page_t
name|m_start
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|)
block|{
name|vm_offset_t
name|va
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|vm_pindex_t
name|diff
decl_stmt|,
name|psize
decl_stmt|;
name|vm_prot_t
name|access
decl_stmt|;
name|VM_OBJECT_ASSERT_LOCKED
argument_list|(
name|m_start
operator|->
name|object
argument_list|)
expr_stmt|;
name|psize
operator|=
name|atop
argument_list|(
name|end
operator|-
name|start
argument_list|)
expr_stmt|;
name|m
operator|=
name|m_start
expr_stmt|;
name|access
operator|=
name|prot
operator|=
name|prot
operator|&
operator|(
name|VM_PROT_READ
operator||
name|VM_PROT_EXECUTE
operator|)
expr_stmt|;
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
while|while
condition|(
name|m
operator|!=
name|NULL
operator|&&
operator|(
name|diff
operator|=
name|m
operator|->
name|pindex
operator|-
name|m_start
operator|->
name|pindex
operator|)
operator|<
name|psize
condition|)
block|{
name|va
operator|=
name|start
operator|+
name|ptoa
argument_list|(
name|diff
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|va
operator|&
name|L1_S_OFFSET
operator|)
operator|==
literal|0
operator|&&
name|L2_NEXT_BUCKET
argument_list|(
name|va
argument_list|)
operator|<=
name|end
operator|&&
name|m
operator|->
name|psind
operator|==
literal|1
operator|&&
name|sp_enabled
operator|&&
name|pmap_enter_section
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|m
argument_list|,
name|prot
argument_list|)
condition|)
name|m
operator|=
operator|&
name|m
index|[
name|L1_S_SIZE
operator|/
name|PAGE_SIZE
operator|-
literal|1
index|]
expr_stmt|;
else|else
name|pmap_enter_locked
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|access
argument_list|,
name|m
argument_list|,
name|prot
argument_list|,
name|FALSE
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|m
operator|=
name|TAILQ_NEXT
argument_list|(
name|m
argument_list|,
name|listq
argument_list|)
expr_stmt|;
block|}
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * this code makes some *MAJOR* assumptions:  * 1. Current pmap& pmap exists.  * 2. Not wired.  * 3. Read access.  * 4. No page table pages.  * but is *MUCH* faster than pmap_enter...  */
end_comment

begin_function
name|void
name|pmap_enter_quick
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|m
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|)
block|{
name|vm_prot_t
name|access
decl_stmt|;
name|access
operator|=
name|prot
operator|=
name|prot
operator|&
operator|(
name|VM_PROT_READ
operator||
name|VM_PROT_EXECUTE
operator|)
expr_stmt|;
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|pmap_enter_locked
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|access
argument_list|,
name|m
argument_list|,
name|prot
argument_list|,
name|FALSE
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Routine:	pmap_change_wiring  *	Function:	Change the wiring attribute for a map/virtual-address  *			pair.  *	In/out conditions:  *			The mapping must already exist in the pmap.  */
end_comment

begin_function
name|void
name|pmap_change_wiring
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|boolean_t
name|wired
parameter_list|)
block|{
name|struct
name|l2_bucket
modifier|*
name|l2b
decl_stmt|;
name|struct
name|md_page
modifier|*
name|pvh
decl_stmt|;
name|struct
name|pv_entry
modifier|*
name|pve
decl_stmt|;
name|pd_entry_t
modifier|*
name|pl1pd
decl_stmt|,
name|l1pd
decl_stmt|;
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|,
name|pte
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|pl1pd
operator|=
operator|&
name|pmap
operator|->
name|pm_l1
operator|->
name|l1_kva
index|[
name|L1_IDX
argument_list|(
name|va
argument_list|)
index|]
expr_stmt|;
name|l1pd
operator|=
operator|*
name|pl1pd
expr_stmt|;
if|if
condition|(
operator|(
name|l1pd
operator|&
name|L1_TYPE_MASK
operator|)
operator|==
name|L1_S_PROTO
condition|)
block|{
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|l1pd
operator|&
name|L1_S_FRAME
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|m
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|==
literal|0
operator|)
argument_list|,
operator|(
literal|"pmap_change_wiring: unmanaged superpage should not "
literal|"be changed"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pmap
operator|!=
name|pmap_kernel
argument_list|()
argument_list|,
operator|(
literal|"pmap_change_wiring: managed kernel superpage "
literal|"should not exist"
operator|)
argument_list|)
expr_stmt|;
name|pvh
operator|=
name|pa_to_pvh
argument_list|(
name|l1pd
operator|&
name|L1_S_FRAME
argument_list|)
expr_stmt|;
name|pve
operator|=
name|pmap_find_pv
argument_list|(
name|pvh
argument_list|,
name|pmap
argument_list|,
name|trunc_1mpage
argument_list|(
name|va
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|wired
operator|!=
operator|(
operator|(
name|pve
operator|->
name|pv_flags
operator|&
name|PVF_WIRED
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|pmap_demote_section
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
condition|)
name|panic
argument_list|(
literal|"pmap_change_wiring: demotion failed"
argument_list|)
expr_stmt|;
block|}
else|else
goto|goto
name|out
goto|;
block|}
name|l2b
operator|=
name|pmap_get_l2_bucket
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|l2b
argument_list|,
operator|(
literal|"No l2b bucket in pmap_change_wiring"
operator|)
argument_list|)
expr_stmt|;
name|ptep
operator|=
operator|&
name|l2b
operator|->
name|l2b_kva
index|[
name|l2pte_index
argument_list|(
name|va
argument_list|)
index|]
expr_stmt|;
name|pte
operator|=
operator|*
name|ptep
expr_stmt|;
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|l2pte_pa
argument_list|(
name|pte
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|pmap_modify_pv
argument_list|(
name|m
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|,
name|PVF_WIRED
argument_list|,
name|wired
operator|==
name|TRUE
condition|?
name|PVF_WIRED
else|:
literal|0
argument_list|)
expr_stmt|;
name|out
label|:
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Clear the wired attribute from the mappings for the specified range of  *	addresses in the given pmap.  Every valid mapping within that range  *	must have the wired attribute set.  In contrast, invalid mappings  *	cannot have the wired attribute set, so they are ignored.  *  *	XXX Wired mappings of unmanaged pages cannot be counted by this pmap  *	implementation.  */
end_comment

begin_function
name|void
name|pmap_unwire
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|sva
parameter_list|,
name|vm_offset_t
name|eva
parameter_list|)
block|{
name|struct
name|l2_bucket
modifier|*
name|l2b
decl_stmt|;
name|struct
name|md_page
modifier|*
name|pvh
decl_stmt|;
name|pd_entry_t
name|l1pd
decl_stmt|;
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|,
name|pte
decl_stmt|;
name|pv_entry_t
name|pv
decl_stmt|;
name|vm_offset_t
name|next_bucket
decl_stmt|;
name|vm_paddr_t
name|pa
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
while|while
condition|(
name|sva
operator|<
name|eva
condition|)
block|{
name|next_bucket
operator|=
name|L2_NEXT_BUCKET
argument_list|(
name|sva
argument_list|)
expr_stmt|;
name|l1pd
operator|=
name|pmap
operator|->
name|pm_l1
operator|->
name|l1_kva
index|[
name|L1_IDX
argument_list|(
name|sva
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|l1pd
operator|&
name|L1_TYPE_MASK
operator|)
operator|==
name|L1_S_PROTO
condition|)
block|{
name|pa
operator|=
name|l1pd
operator|&
name|L1_S_FRAME
expr_stmt|;
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|m
operator|!=
name|NULL
operator|&&
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_unwire: unmanaged 1mpage %p"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
name|pvh
operator|=
name|pa_to_pvh
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|pv
operator|=
name|pmap_find_pv
argument_list|(
name|pvh
argument_list|,
name|pmap
argument_list|,
name|trunc_1mpage
argument_list|(
name|sva
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pv
operator|->
name|pv_flags
operator|&
name|PVF_WIRED
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"pmap_unwire: pv %p isn't wired"
argument_list|,
name|pv
argument_list|)
expr_stmt|;
comment|/* 			 * Are we unwiring the entire large page? If not, 			 * demote the mapping and fall through. 			 */
if|if
condition|(
name|sva
operator|+
name|L1_S_SIZE
operator|==
name|next_bucket
operator|&&
name|eva
operator|>=
name|next_bucket
condition|)
block|{
name|pv
operator|->
name|pv_flags
operator|&=
operator|~
name|PVF_WIRED
expr_stmt|;
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|-=
name|L2_PTE_NUM_TOTAL
expr_stmt|;
name|sva
operator|=
name|next_bucket
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|!
name|pmap_demote_section
argument_list|(
name|pmap
argument_list|,
name|sva
argument_list|)
condition|)
name|panic
argument_list|(
literal|"pmap_unwire: demotion failed"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|next_bucket
operator|>
name|eva
condition|)
name|next_bucket
operator|=
name|eva
expr_stmt|;
name|l2b
operator|=
name|pmap_get_l2_bucket
argument_list|(
name|pmap
argument_list|,
name|sva
argument_list|)
expr_stmt|;
if|if
condition|(
name|l2b
operator|==
name|NULL
condition|)
block|{
name|sva
operator|=
name|next_bucket
expr_stmt|;
continue|continue;
block|}
for|for
control|(
name|ptep
operator|=
operator|&
name|l2b
operator|->
name|l2b_kva
index|[
name|l2pte_index
argument_list|(
name|sva
argument_list|)
index|]
init|;
name|sva
operator|<
name|next_bucket
condition|;
name|sva
operator|+=
name|PAGE_SIZE
operator|,
name|ptep
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|pte
operator|=
operator|*
name|ptep
operator|)
operator|==
literal|0
operator|||
operator|(
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|l2pte_pa
argument_list|(
name|pte
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|!=
literal|0
condition|)
continue|continue;
name|pv
operator|=
name|pmap_find_pv
argument_list|(
operator|&
name|m
operator|->
name|md
argument_list|,
name|pmap
argument_list|,
name|sva
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pv
operator|->
name|pv_flags
operator|&
name|PVF_WIRED
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"pmap_unwire: pv %p isn't wired"
argument_list|,
name|pv
argument_list|)
expr_stmt|;
name|pv
operator|->
name|pv_flags
operator|&=
operator|~
name|PVF_WIRED
expr_stmt|;
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|--
expr_stmt|;
block|}
block|}
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Copy the range specified by src_addr/len  *	from the source map to the range dst_addr/len  *	in the destination map.  *  *	This routine is only advisory and need not do anything.  */
end_comment

begin_function
name|void
name|pmap_copy
parameter_list|(
name|pmap_t
name|dst_pmap
parameter_list|,
name|pmap_t
name|src_pmap
parameter_list|,
name|vm_offset_t
name|dst_addr
parameter_list|,
name|vm_size_t
name|len
parameter_list|,
name|vm_offset_t
name|src_addr
parameter_list|)
block|{ }
end_function

begin_comment
comment|/*  *	Routine:	pmap_extract  *	Function:  *		Extract the physical page address associated  *		with the given map/virtual_address pair.  */
end_comment

begin_function
name|vm_paddr_t
name|pmap_extract
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|vm_paddr_t
name|pa
decl_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|pa
operator|=
name|pmap_extract_locked
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
return|return
operator|(
name|pa
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|vm_paddr_t
name|pmap_extract_locked
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|struct
name|l2_dtable
modifier|*
name|l2
decl_stmt|;
name|pd_entry_t
name|l1pd
decl_stmt|;
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|,
name|pte
decl_stmt|;
name|vm_paddr_t
name|pa
decl_stmt|;
name|u_int
name|l1idx
decl_stmt|;
if|if
condition|(
name|kernel_vm_end
operator|!=
literal|0
operator|&&
name|pmap
operator|!=
name|kernel_pmap
condition|)
name|PMAP_ASSERT_LOCKED
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|l1idx
operator|=
name|L1_IDX
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|l1pd
operator|=
name|pmap
operator|->
name|pm_l1
operator|->
name|l1_kva
index|[
name|l1idx
index|]
expr_stmt|;
if|if
condition|(
name|l1pte_section_p
argument_list|(
name|l1pd
argument_list|)
condition|)
block|{
comment|/* XXX: what to do about the bits> 32 ? */
if|if
condition|(
name|l1pd
operator|&
name|L1_S_SUPERSEC
condition|)
name|pa
operator|=
operator|(
name|l1pd
operator|&
name|L1_SUP_FRAME
operator|)
operator||
operator|(
name|va
operator|&
name|L1_SUP_OFFSET
operator|)
expr_stmt|;
else|else
name|pa
operator|=
operator|(
name|l1pd
operator|&
name|L1_S_FRAME
operator|)
operator||
operator|(
name|va
operator|&
name|L1_S_OFFSET
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Note that we can't rely on the validity of the L1 		 * descriptor as an indication that a mapping exists. 		 * We have to look it up in the L2 dtable. 		 */
name|l2
operator|=
name|pmap
operator|->
name|pm_l2
index|[
name|L2_IDX
argument_list|(
name|l1idx
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|l2
operator|==
name|NULL
operator|||
operator|(
name|ptep
operator|=
name|l2
operator|->
name|l2_bucket
index|[
name|L2_BUCKET
argument_list|(
name|l1idx
argument_list|)
index|]
operator|.
name|l2b_kva
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|pte
operator|=
name|ptep
index|[
name|l2pte_index
argument_list|(
name|va
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|pte
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
switch|switch
condition|(
name|pte
operator|&
name|L2_TYPE_MASK
condition|)
block|{
case|case
name|L2_TYPE_L
case|:
name|pa
operator|=
operator|(
name|pte
operator|&
name|L2_L_FRAME
operator|)
operator||
operator|(
name|va
operator|&
name|L2_L_OFFSET
operator|)
expr_stmt|;
break|break;
default|default:
name|pa
operator|=
operator|(
name|pte
operator|&
name|L2_S_FRAME
operator|)
operator||
operator|(
name|va
operator|&
name|L2_S_OFFSET
operator|)
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|pa
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Atomically extract and hold the physical page with the given  * pmap and virtual address pair if that mapping permits the given  * protection.  *  */
end_comment

begin_function
name|vm_page_t
name|pmap_extract_and_hold
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|)
block|{
name|struct
name|l2_dtable
modifier|*
name|l2
decl_stmt|;
name|pd_entry_t
name|l1pd
decl_stmt|;
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|,
name|pte
decl_stmt|;
name|vm_paddr_t
name|pa
decl_stmt|,
name|paddr
decl_stmt|;
name|vm_page_t
name|m
init|=
name|NULL
decl_stmt|;
name|u_int
name|l1idx
decl_stmt|;
name|l1idx
operator|=
name|L1_IDX
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|paddr
operator|=
literal|0
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|retry
label|:
name|l1pd
operator|=
name|pmap
operator|->
name|pm_l1
operator|->
name|l1_kva
index|[
name|l1idx
index|]
expr_stmt|;
if|if
condition|(
name|l1pte_section_p
argument_list|(
name|l1pd
argument_list|)
condition|)
block|{
comment|/* XXX: what to do about the bits> 32 ? */
if|if
condition|(
name|l1pd
operator|&
name|L1_S_SUPERSEC
condition|)
name|pa
operator|=
operator|(
name|l1pd
operator|&
name|L1_SUP_FRAME
operator|)
operator||
operator|(
name|va
operator|&
name|L1_SUP_OFFSET
operator|)
expr_stmt|;
else|else
name|pa
operator|=
operator|(
name|l1pd
operator|&
name|L1_S_FRAME
operator|)
operator||
operator|(
name|va
operator|&
name|L1_S_OFFSET
operator|)
expr_stmt|;
if|if
condition|(
name|vm_page_pa_tryrelock
argument_list|(
name|pmap
argument_list|,
name|pa
operator|&
name|PG_FRAME
argument_list|,
operator|&
name|paddr
argument_list|)
condition|)
goto|goto
name|retry
goto|;
if|if
condition|(
name|L1_S_WRITABLE
argument_list|(
name|l1pd
argument_list|)
operator|||
operator|(
name|prot
operator|&
name|VM_PROT_WRITE
operator|)
operator|==
literal|0
condition|)
block|{
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|vm_page_hold
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * Note that we can't rely on the validity of the L1 		 * descriptor as an indication that a mapping exists. 		 * We have to look it up in the L2 dtable. 		 */
name|l2
operator|=
name|pmap
operator|->
name|pm_l2
index|[
name|L2_IDX
argument_list|(
name|l1idx
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|l2
operator|==
name|NULL
operator|||
operator|(
name|ptep
operator|=
name|l2
operator|->
name|l2_bucket
index|[
name|L2_BUCKET
argument_list|(
name|l1idx
argument_list|)
index|]
operator|.
name|l2b_kva
operator|)
operator|==
name|NULL
condition|)
block|{
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|ptep
operator|=
operator|&
name|ptep
index|[
name|l2pte_index
argument_list|(
name|va
argument_list|)
index|]
expr_stmt|;
name|pte
operator|=
operator|*
name|ptep
expr_stmt|;
if|if
condition|(
name|pte
operator|==
literal|0
condition|)
block|{
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|prot
operator|&
name|VM_PROT_WRITE
operator|)
operator|&&
operator|(
name|pte
operator|&
name|L2_APX
operator|)
condition|)
block|{
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
else|else
block|{
switch|switch
condition|(
name|pte
operator|&
name|L2_TYPE_MASK
condition|)
block|{
case|case
name|L2_TYPE_L
case|:
name|panic
argument_list|(
literal|"extract and hold section mapping"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|pa
operator|=
operator|(
name|pte
operator|&
name|L2_S_FRAME
operator|)
operator||
operator|(
name|va
operator|&
name|L2_S_OFFSET
operator|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|vm_page_pa_tryrelock
argument_list|(
name|pmap
argument_list|,
name|pa
operator|&
name|PG_FRAME
argument_list|,
operator|&
name|paddr
argument_list|)
condition|)
goto|goto
name|retry
goto|;
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|vm_page_hold
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|PA_UNLOCK_COND
argument_list|(
name|paddr
argument_list|)
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize a preallocated and zeroed pmap structure,  * such as one in a vmspace structure.  */
end_comment

begin_function
name|int
name|pmap_pinit
parameter_list|(
name|pmap_t
name|pmap
parameter_list|)
block|{
name|PDEBUG
argument_list|(
literal|1
argument_list|,
name|printf
argument_list|(
literal|"pmap_pinit: pmap = %08x\n"
argument_list|,
operator|(
name|uint32_t
operator|)
name|pmap
argument_list|)
argument_list|)
expr_stmt|;
name|pmap_alloc_l1
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|pmap
operator|->
name|pm_l2
argument_list|,
sizeof|sizeof
argument_list|(
name|pmap
operator|->
name|pm_l2
argument_list|)
argument_list|)
expr_stmt|;
name|CPU_ZERO
argument_list|(
operator|&
name|pmap
operator|->
name|pm_active
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvchunk
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|pmap
operator|->
name|pm_stats
argument_list|,
sizeof|sizeof
name|pmap
operator|->
name|pm_stats
argument_list|)
expr_stmt|;
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|vector_page
operator|<
name|KERNBASE
condition|)
block|{
name|pmap_enter
argument_list|(
name|pmap
argument_list|,
name|vector_page
argument_list|,
name|VM_PROT_READ
argument_list|,
name|PHYS_TO_VM_PAGE
argument_list|(
name|systempage
operator|.
name|pv_pa
argument_list|)
argument_list|,
name|VM_PROT_READ
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/***************************************************  * Superpage management routines.  ***************************************************/
end_comment

begin_expr_stmt
specifier|static
name|PMAP_INLINE
expr|struct
name|pv_entry
operator|*
name|pmap_pvh_remove
argument_list|(
argument|struct md_page *pvh
argument_list|,
argument|pmap_t pmap
argument_list|,
argument|vm_offset_t va
argument_list|)
block|{
name|pv_entry_t
name|pv
block|;
name|rw_assert
argument_list|(
operator|&
name|pvh_global_lock
argument_list|,
name|RA_WLOCKED
argument_list|)
block|;
name|pv
operator|=
name|pmap_find_pv
argument_list|(
name|pvh
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|)
block|;
if|if
condition|(
name|pv
operator|!=
name|NULL
condition|)
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pvh
operator|->
name|pv_list
argument_list|,
name|pv
argument_list|,
name|pv_list
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
name|pv
operator|)
return|;
end_return

begin_function
unit|}  static
name|void
name|pmap_pvh_free
parameter_list|(
name|struct
name|md_page
modifier|*
name|pvh
parameter_list|,
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|pv_entry_t
name|pv
decl_stmt|;
name|pv
operator|=
name|pmap_pvh_remove
argument_list|(
name|pvh
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pv
operator|!=
name|NULL
argument_list|,
operator|(
literal|"pmap_pvh_free: pv not found"
operator|)
argument_list|)
expr_stmt|;
name|pmap_free_pv_entry
argument_list|(
name|pmap
argument_list|,
name|pv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|boolean_t
name|pmap_pv_insert_section
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_paddr_t
name|pa
parameter_list|)
block|{
name|struct
name|md_page
modifier|*
name|pvh
decl_stmt|;
name|pv_entry_t
name|pv
decl_stmt|;
name|rw_assert
argument_list|(
operator|&
name|pvh_global_lock
argument_list|,
name|RA_WLOCKED
argument_list|)
expr_stmt|;
if|if
condition|(
name|pv_entry_count
operator|<
name|pv_entry_high_water
operator|&&
operator|(
name|pv
operator|=
name|pmap_get_pv_entry
argument_list|(
name|pmap
argument_list|,
name|TRUE
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|pv
operator|->
name|pv_va
operator|=
name|va
expr_stmt|;
name|pvh
operator|=
name|pa_to_pvh
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|pvh
operator|->
name|pv_list
argument_list|,
name|pv
argument_list|,
name|pv_list
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
else|else
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create the pv entries for each of the pages within a superpage.  */
end_comment

begin_function
specifier|static
name|void
name|pmap_pv_demote_section
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_paddr_t
name|pa
parameter_list|)
block|{
name|struct
name|md_page
modifier|*
name|pvh
decl_stmt|;
name|pv_entry_t
name|pve
decl_stmt|,
name|pv
decl_stmt|;
name|vm_offset_t
name|va_last
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|rw_assert
argument_list|(
operator|&
name|pvh_global_lock
argument_list|,
name|RA_WLOCKED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|pa
operator|&
name|L1_S_OFFSET
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_pv_demote_section: pa is not 1mpage aligned"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Transfer the 1mpage's pv entry for this mapping to the first 	 * page's pv list. 	 */
name|pvh
operator|=
name|pa_to_pvh
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|va
operator|=
name|trunc_1mpage
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|pv
operator|=
name|pmap_pvh_remove
argument_list|(
name|pvh
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pv
operator|!=
name|NULL
argument_list|,
operator|(
literal|"pmap_pv_demote_section: pv not found"
operator|)
argument_list|)
expr_stmt|;
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|,
name|pv
argument_list|,
name|pv_list
argument_list|)
expr_stmt|;
comment|/* Instantiate the remaining pv entries. */
name|va_last
operator|=
name|L2_NEXT_BUCKET
argument_list|(
name|va
argument_list|)
operator|-
name|PAGE_SIZE
expr_stmt|;
do|do
block|{
name|m
operator|++
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_pv_demote_section: page %p is not managed"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
name|va
operator|+=
name|PAGE_SIZE
expr_stmt|;
name|pve
operator|=
name|pmap_get_pv_entry
argument_list|(
name|pmap
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|pmap_enter_pv
argument_list|(
name|m
argument_list|,
name|pve
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|,
name|pv
operator|->
name|pv_flags
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|va
operator|<
name|va_last
condition|)
do|;
block|}
end_function

begin_function
specifier|static
name|void
name|pmap_pv_promote_section
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_paddr_t
name|pa
parameter_list|)
block|{
name|struct
name|md_page
modifier|*
name|pvh
decl_stmt|;
name|pv_entry_t
name|pv
decl_stmt|;
name|vm_offset_t
name|va_last
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|rw_assert
argument_list|(
operator|&
name|pvh_global_lock
argument_list|,
name|RA_WLOCKED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|pa
operator|&
name|L1_S_OFFSET
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_pv_promote_section: pa is not 1mpage aligned"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Transfer the first page's pv entry for this mapping to the 	 * 1mpage's pv list.  Aside from avoiding the cost of a call 	 * to get_pv_entry(), a transfer avoids the possibility that 	 * get_pv_entry() calls pmap_pv_reclaim() and that pmap_pv_reclaim() 	 * removes one of the mappings that is being promoted. 	 */
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|va
operator|=
name|trunc_1mpage
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|pv
operator|=
name|pmap_pvh_remove
argument_list|(
operator|&
name|m
operator|->
name|md
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pv
operator|!=
name|NULL
argument_list|,
operator|(
literal|"pmap_pv_promote_section: pv not found"
operator|)
argument_list|)
expr_stmt|;
name|pvh
operator|=
name|pa_to_pvh
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|pvh
operator|->
name|pv_list
argument_list|,
name|pv
argument_list|,
name|pv_list
argument_list|)
expr_stmt|;
comment|/* Free the remaining pv entries in the newly mapped section pages */
name|va_last
operator|=
name|L2_NEXT_BUCKET
argument_list|(
name|va
argument_list|)
operator|-
name|PAGE_SIZE
expr_stmt|;
do|do
block|{
name|m
operator|++
expr_stmt|;
name|va
operator|+=
name|PAGE_SIZE
expr_stmt|;
comment|/* 		 * Don't care the flags, first pv contains sufficient 		 * information for all of the pages so nothing is really lost. 		 */
name|pmap_pvh_free
argument_list|(
operator|&
name|m
operator|->
name|md
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|va
operator|<
name|va_last
condition|)
do|;
block|}
end_function

begin_comment
comment|/*  * Tries to create a 1MB page mapping.  Returns TRUE if successful and  * FALSE otherwise.  Fails if (1) page is unmanageg, kernel pmap or vectors  * page, (2) a mapping already exists at the specified virtual address, or  * (3) a pv entry cannot be allocated without reclaiming another pv entry.   */
end_comment

begin_function
specifier|static
name|boolean_t
name|pmap_enter_section
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|m
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|)
block|{
name|pd_entry_t
modifier|*
name|pl1pd
decl_stmt|;
name|vm_offset_t
name|pa
decl_stmt|;
name|struct
name|l2_bucket
modifier|*
name|l2b
decl_stmt|;
name|rw_assert
argument_list|(
operator|&
name|pvh_global_lock
argument_list|,
name|RA_WLOCKED
argument_list|)
expr_stmt|;
name|PMAP_ASSERT_LOCKED
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
comment|/* Skip kernel, vectors page and unmanaged mappings */
if|if
condition|(
operator|(
name|pmap
operator|==
name|pmap_kernel
argument_list|()
operator|)
operator|||
operator|(
name|L1_IDX
argument_list|(
name|va
argument_list|)
operator|==
name|L1_IDX
argument_list|(
name|vector_page
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"pmap_enter_section: failure for va %#lx"
literal|" in pmap %p"
argument_list|,
name|va
argument_list|,
name|pmap
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/* 	 * Check whether this is a valid section superpage entry or 	 * there is a l2_bucket associated with that L1 page directory. 	 */
name|va
operator|=
name|trunc_1mpage
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|pl1pd
operator|=
operator|&
name|pmap
operator|->
name|pm_l1
operator|->
name|l1_kva
index|[
name|L1_IDX
argument_list|(
name|va
argument_list|)
index|]
expr_stmt|;
name|l2b
operator|=
name|pmap_get_l2_bucket
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|pl1pd
operator|&
name|L1_S_PROTO
operator|)
operator|||
operator|(
name|l2b
operator|!=
name|NULL
operator|)
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"pmap_enter_section: failure for va %#lx"
literal|" in pmap %p"
argument_list|,
name|va
argument_list|,
name|pmap
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|pa
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* 	 * Abort this mapping if its PV entry could not be created. 	 */
if|if
condition|(
operator|!
name|pmap_pv_insert_section
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"pmap_enter_section: failure for va %#lx"
literal|" in pmap %p"
argument_list|,
name|va
argument_list|,
name|pmap
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/* 	 * Increment counters. 	 */
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|+=
name|L2_PTE_NUM_TOTAL
expr_stmt|;
comment|/* 	 * Despite permissions, mark the superpage read-only. 	 */
name|prot
operator|&=
operator|~
name|VM_PROT_WRITE
expr_stmt|;
comment|/* 	 * Map the superpage. 	 */
name|pmap_map_section
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|pa
argument_list|,
name|prot
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|pmap_section_mappings
operator|++
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"pmap_enter_section: success for va %#lx"
literal|" in pmap %p"
argument_list|,
name|va
argument_list|,
name|pmap
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * pmap_remove_section: do the things to unmap a superpage in a process  */
end_comment

begin_function
specifier|static
name|void
name|pmap_remove_section
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|sva
parameter_list|)
block|{
name|struct
name|md_page
modifier|*
name|pvh
decl_stmt|;
name|struct
name|l2_bucket
modifier|*
name|l2b
decl_stmt|;
name|pd_entry_t
modifier|*
name|pl1pd
decl_stmt|,
name|l1pd
decl_stmt|;
name|vm_offset_t
name|eva
decl_stmt|,
name|va
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|PMAP_ASSERT_LOCKED
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pmap
operator|==
name|pmap_kernel
argument_list|()
operator|)
operator|||
operator|(
name|L1_IDX
argument_list|(
name|sva
argument_list|)
operator|==
name|L1_IDX
argument_list|(
name|vector_page
argument_list|)
operator|)
condition|)
return|return;
name|KASSERT
argument_list|(
operator|(
name|sva
operator|&
name|L1_S_OFFSET
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_remove_section: sva is not 1mpage aligned"
operator|)
argument_list|)
expr_stmt|;
name|pl1pd
operator|=
operator|&
name|pmap
operator|->
name|pm_l1
operator|->
name|l1_kva
index|[
name|L1_IDX
argument_list|(
name|sva
argument_list|)
index|]
expr_stmt|;
name|l1pd
operator|=
operator|*
name|pl1pd
expr_stmt|;
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|l1pd
operator|&
name|L1_S_FRAME
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|m
operator|!=
name|NULL
operator|&&
operator|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|==
literal|0
operator|)
operator|)
argument_list|,
operator|(
literal|"pmap_remove_section: no corresponding vm_page or "
literal|"page unmanaged"
operator|)
argument_list|)
expr_stmt|;
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|-=
name|L2_PTE_NUM_TOTAL
expr_stmt|;
name|pvh
operator|=
name|pa_to_pvh
argument_list|(
name|l1pd
operator|&
name|L1_S_FRAME
argument_list|)
expr_stmt|;
name|pmap_pvh_free
argument_list|(
name|pvh
argument_list|,
name|pmap
argument_list|,
name|sva
argument_list|)
expr_stmt|;
name|eva
operator|=
name|L2_NEXT_BUCKET
argument_list|(
name|sva
argument_list|)
expr_stmt|;
for|for
control|(
name|va
operator|=
name|sva
operator|,
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|l1pd
operator|&
name|L1_S_FRAME
argument_list|)
init|;
name|va
operator|<
name|eva
condition|;
name|va
operator|+=
name|PAGE_SIZE
operator|,
name|m
operator|++
control|)
block|{
comment|/* 		 * Mark base pages referenced but skip marking them dirty. 		 * If the superpage is writeable, hence all base pages were 		 * already marked as dirty in pmap_fault_fixup() before 		 * promotion. Reference bit however, might not have been set 		 * for each base page when the superpage was created at once, 		 * not as a result of promotion. 		 */
if|if
condition|(
name|L1_S_REFERENCED
argument_list|(
name|l1pd
argument_list|)
condition|)
name|vm_page_aflag_set
argument_list|(
name|m
argument_list|,
name|PGA_REFERENCED
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|)
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|pvh
operator|->
name|pv_list
argument_list|)
condition|)
name|vm_page_aflag_clear
argument_list|(
name|m
argument_list|,
name|PGA_WRITEABLE
argument_list|)
expr_stmt|;
block|}
name|l2b
operator|=
name|pmap_get_l2_bucket
argument_list|(
name|pmap
argument_list|,
name|sva
argument_list|)
expr_stmt|;
if|if
condition|(
name|l2b
operator|!=
name|NULL
condition|)
block|{
name|KASSERT
argument_list|(
name|l2b
operator|->
name|l2b_occupancy
operator|==
name|L2_PTE_NUM_TOTAL
argument_list|,
operator|(
literal|"pmap_remove_section: l2_bucket occupancy error"
operator|)
argument_list|)
expr_stmt|;
name|pmap_free_l2_bucket
argument_list|(
name|pmap
argument_list|,
name|l2b
argument_list|,
name|L2_PTE_NUM_TOTAL
argument_list|)
expr_stmt|;
block|}
comment|/* Now invalidate L1 slot */
operator|*
name|pl1pd
operator|=
literal|0
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|pl1pd
argument_list|)
expr_stmt|;
if|if
condition|(
name|L1_S_EXECUTABLE
argument_list|(
name|l1pd
argument_list|)
condition|)
name|cpu_tlb_flushID_SE
argument_list|(
name|sva
argument_list|)
expr_stmt|;
else|else
name|cpu_tlb_flushD_SE
argument_list|(
name|sva
argument_list|)
expr_stmt|;
name|cpu_cpwait
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Tries to promote the 256, contiguous 4KB page mappings that are  * within a single l2_bucket to a single 1MB section mapping.  * For promotion to occur, two conditions must be met: (1) the 4KB page  * mappings must map aligned, contiguous physical memory and (2) the 4KB page  * mappings must have identical characteristics.  */
end_comment

begin_function
specifier|static
name|void
name|pmap_promote_section
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|pt_entry_t
modifier|*
name|firstptep
decl_stmt|,
name|firstpte
decl_stmt|,
name|oldpte
decl_stmt|,
name|pa
decl_stmt|,
modifier|*
name|pte
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|,
name|oldm
decl_stmt|;
name|vm_offset_t
name|first_va
decl_stmt|,
name|old_va
decl_stmt|;
name|struct
name|l2_bucket
modifier|*
name|l2b
init|=
name|NULL
decl_stmt|;
name|vm_prot_t
name|prot
decl_stmt|;
name|struct
name|pv_entry
modifier|*
name|pve
decl_stmt|,
modifier|*
name|first_pve
decl_stmt|;
name|PMAP_ASSERT_LOCKED
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|prot
operator|=
name|VM_PROT_ALL
expr_stmt|;
comment|/* 	 * Skip promoting kernel pages. This is justified by following: 	 * 1. Kernel is already mapped using section mappings in each pmap 	 * 2. Managed mappings within the kernel are not to be promoted anyway 	 */
if|if
condition|(
name|pmap
operator|==
name|pmap_kernel
argument_list|()
condition|)
block|{
name|pmap_section_p_failures
operator|++
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"pmap_promote_section: failure for va %#x"
literal|" in pmap %p"
argument_list|,
name|va
argument_list|,
name|pmap
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Do not attemp to promote vectors pages */
if|if
condition|(
name|L1_IDX
argument_list|(
name|va
argument_list|)
operator|==
name|L1_IDX
argument_list|(
name|vector_page
argument_list|)
condition|)
block|{
name|pmap_section_p_failures
operator|++
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"pmap_promote_section: failure for va %#x"
literal|" in pmap %p"
argument_list|,
name|va
argument_list|,
name|pmap
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Examine the first PTE in the specified l2_bucket. Abort if this PTE 	 * is either invalid, unused, or does not map the first 4KB physical 	 * page within 1MB page. 	 */
name|first_va
operator|=
name|trunc_1mpage
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|l2b
operator|=
name|pmap_get_l2_bucket
argument_list|(
name|pmap
argument_list|,
name|first_va
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|l2b
operator|!=
name|NULL
argument_list|,
operator|(
literal|"pmap_promote_section: trying to promote "
literal|"not existing l2 bucket"
operator|)
argument_list|)
expr_stmt|;
name|firstptep
operator|=
operator|&
name|l2b
operator|->
name|l2b_kva
index|[
literal|0
index|]
expr_stmt|;
name|firstpte
operator|=
operator|*
name|firstptep
expr_stmt|;
if|if
condition|(
operator|(
name|l2pte_pa
argument_list|(
name|firstpte
argument_list|)
operator|&
name|L1_S_OFFSET
operator|)
operator|!=
literal|0
condition|)
block|{
name|pmap_section_p_failures
operator|++
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"pmap_promote_section: failure for va %#x"
literal|" in pmap %p"
argument_list|,
name|va
argument_list|,
name|pmap
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|firstpte
operator|&
operator|(
name|L2_S_PROTO
operator||
name|L2_S_REF
operator|)
operator|)
operator|!=
operator|(
name|L2_S_PROTO
operator||
name|L2_S_REF
operator|)
condition|)
block|{
name|pmap_section_p_failures
operator|++
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"pmap_promote_section: failure for va %#x"
literal|" in pmap %p"
argument_list|,
name|va
argument_list|,
name|pmap
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * ARM uses pv_entry to mark particular mapping WIRED so don't promote 	 * unmanaged pages since it is impossible to determine, whether the 	 * page is wired or not if there is no corresponding pv_entry. 	 */
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|l2pte_pa
argument_list|(
name|firstpte
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|&&
operator|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|pmap_section_p_failures
operator|++
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"pmap_promote_section: failure for va %#x"
literal|" in pmap %p"
argument_list|,
name|va
argument_list|,
name|pmap
argument_list|)
expr_stmt|;
return|return;
block|}
name|first_pve
operator|=
name|pmap_find_pv
argument_list|(
operator|&
name|m
operator|->
name|md
argument_list|,
name|pmap
argument_list|,
name|first_va
argument_list|)
expr_stmt|;
comment|/* 	 * PTE is modified only on write due to modified bit 	 * emulation. If the entry is referenced and writable 	 * then it is modified and we don't clear write enable. 	 * Otherwise, writing is disabled in PTE anyway and 	 * we just configure protections for the section mapping 	 * that is going to be created. 	 */
if|if
condition|(
operator|(
name|first_pve
operator|->
name|pv_flags
operator|&
name|PVF_WRITE
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|L2_S_WRITABLE
argument_list|(
name|firstpte
argument_list|)
condition|)
block|{
name|first_pve
operator|->
name|pv_flags
operator|&=
operator|~
name|PVF_WRITE
expr_stmt|;
name|prot
operator|&=
operator|~
name|VM_PROT_WRITE
expr_stmt|;
block|}
block|}
else|else
name|prot
operator|&=
operator|~
name|VM_PROT_WRITE
expr_stmt|;
if|if
condition|(
operator|!
name|L2_S_EXECUTABLE
argument_list|(
name|firstpte
argument_list|)
condition|)
name|prot
operator|&=
operator|~
name|VM_PROT_EXECUTE
expr_stmt|;
comment|/*  	 * Examine each of the other PTEs in the specified l2_bucket.  	 * Abort if this PTE maps an unexpected 4KB physical page or 	 * does not have identical characteristics to the first PTE. 	 */
name|pa
operator|=
name|l2pte_pa
argument_list|(
name|firstpte
argument_list|)
operator|+
operator|(
operator|(
name|L2_PTE_NUM_TOTAL
operator|-
literal|1
operator|)
operator|*
name|PAGE_SIZE
operator|)
expr_stmt|;
name|old_va
operator|=
name|L2_NEXT_BUCKET
argument_list|(
name|first_va
argument_list|)
operator|-
name|PAGE_SIZE
expr_stmt|;
for|for
control|(
name|pte
operator|=
operator|(
name|firstptep
operator|+
name|L2_PTE_NUM_TOTAL
operator|-
literal|1
operator|)
init|;
name|pte
operator|>
name|firstptep
condition|;
name|pte
operator|--
control|)
block|{
name|oldpte
operator|=
operator|*
name|pte
expr_stmt|;
if|if
condition|(
name|l2pte_pa
argument_list|(
name|oldpte
argument_list|)
operator|!=
name|pa
condition|)
block|{
name|pmap_section_p_failures
operator|++
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"pmap_promote_section: failure for "
literal|"va %#x in pmap %p"
argument_list|,
name|va
argument_list|,
name|pmap
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|oldpte
operator|&
name|L2_S_PROMOTE
operator|)
operator|!=
operator|(
name|firstpte
operator|&
name|L2_S_PROMOTE
operator|)
condition|)
block|{
name|pmap_section_p_failures
operator|++
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"pmap_promote_section: failure for "
literal|"va %#x in pmap %p"
argument_list|,
name|va
argument_list|,
name|pmap
argument_list|)
expr_stmt|;
return|return;
block|}
name|oldm
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|l2pte_pa
argument_list|(
name|oldpte
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldm
operator|&&
operator|(
operator|(
name|oldm
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|pmap_section_p_failures
operator|++
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"pmap_promote_section: failure for "
literal|"va %#x in pmap %p"
argument_list|,
name|va
argument_list|,
name|pmap
argument_list|)
expr_stmt|;
return|return;
block|}
name|pve
operator|=
name|pmap_find_pv
argument_list|(
operator|&
name|oldm
operator|->
name|md
argument_list|,
name|pmap
argument_list|,
name|old_va
argument_list|)
expr_stmt|;
if|if
condition|(
name|pve
operator|==
name|NULL
condition|)
block|{
name|pmap_section_p_failures
operator|++
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"pmap_promote_section: failure for "
literal|"va %#x old_va  %x - no pve"
argument_list|,
name|va
argument_list|,
name|old_va
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|L2_S_WRITABLE
argument_list|(
name|oldpte
argument_list|)
operator|&&
operator|(
name|pve
operator|->
name|pv_flags
operator|&
name|PVF_WRITE
operator|)
condition|)
name|pve
operator|->
name|pv_flags
operator|&=
operator|~
name|PVF_WRITE
expr_stmt|;
if|if
condition|(
name|pve
operator|->
name|pv_flags
operator|!=
name|first_pve
operator|->
name|pv_flags
condition|)
block|{
name|pmap_section_p_failures
operator|++
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"pmap_promote_section: failure for "
literal|"va %#x in pmap %p"
argument_list|,
name|va
argument_list|,
name|pmap
argument_list|)
expr_stmt|;
return|return;
block|}
name|old_va
operator|-=
name|PAGE_SIZE
expr_stmt|;
name|pa
operator|-=
name|PAGE_SIZE
expr_stmt|;
block|}
comment|/* 	 * Promote the pv entries. 	 */
name|pmap_pv_promote_section
argument_list|(
name|pmap
argument_list|,
name|first_va
argument_list|,
name|l2pte_pa
argument_list|(
name|firstpte
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Map the superpage. 	 */
name|pmap_map_section
argument_list|(
name|pmap
argument_list|,
name|first_va
argument_list|,
name|l2pte_pa
argument_list|(
name|firstpte
argument_list|)
argument_list|,
name|prot
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* 	 * Invalidate all possible TLB mappings for small 	 * pages within the newly created superpage. 	 * Rely on the first PTE's attributes since they 	 * have to be consistent across all of the base pages 	 * within the superpage. If page is not executable it 	 * is at least referenced. 	 * The fastest way to do that is to invalidate whole 	 * TLB at once instead of executing 256 CP15 TLB 	 * invalidations by single entry. TLBs usually maintain 	 * several dozen entries so loss of unrelated entries is 	 * still a less agresive approach. 	 */
if|if
condition|(
name|L2_S_EXECUTABLE
argument_list|(
name|firstpte
argument_list|)
condition|)
name|cpu_tlb_flushID
argument_list|()
expr_stmt|;
else|else
name|cpu_tlb_flushD
argument_list|()
expr_stmt|;
name|cpu_cpwait
argument_list|()
expr_stmt|;
name|pmap_section_promotions
operator|++
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"pmap_promote_section: success for va %#x"
literal|" in pmap %p"
argument_list|,
name|first_va
argument_list|,
name|pmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Fills a l2_bucket with mappings to consecutive physical pages.  */
end_comment

begin_function
specifier|static
name|void
name|pmap_fill_l2b
parameter_list|(
name|struct
name|l2_bucket
modifier|*
name|l2b
parameter_list|,
name|pt_entry_t
name|newpte
parameter_list|)
block|{
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|L2_PTE_NUM_TOTAL
condition|;
name|i
operator|++
control|)
block|{
name|ptep
operator|=
operator|&
name|l2b
operator|->
name|l2b_kva
index|[
name|i
index|]
expr_stmt|;
operator|*
name|ptep
operator|=
name|newpte
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|ptep
argument_list|)
expr_stmt|;
name|newpte
operator|+=
name|PAGE_SIZE
expr_stmt|;
block|}
name|l2b
operator|->
name|l2b_occupancy
operator|=
name|L2_PTE_NUM_TOTAL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Tries to demote a 1MB section mapping. If demotion fails, the  * 1MB section mapping is invalidated.  */
end_comment

begin_function
specifier|static
name|boolean_t
name|pmap_demote_section
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|struct
name|l2_bucket
modifier|*
name|l2b
decl_stmt|;
name|struct
name|pv_entry
modifier|*
name|l1pdpve
decl_stmt|;
name|struct
name|md_page
modifier|*
name|pvh
decl_stmt|;
name|pd_entry_t
modifier|*
name|pl1pd
decl_stmt|,
name|l1pd
decl_stmt|,
name|newl1pd
decl_stmt|;
name|pt_entry_t
modifier|*
name|firstptep
decl_stmt|,
name|newpte
decl_stmt|;
name|vm_offset_t
name|pa
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|PMAP_ASSERT_LOCKED
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
comment|/* 	 * According to assumptions described in pmap_promote_section, 	 * kernel is and always should be mapped using 1MB section mappings. 	 * What more, managed kernel pages were not to be promoted.  	 */
name|KASSERT
argument_list|(
name|pmap
operator|!=
name|pmap_kernel
argument_list|()
operator|&&
name|L1_IDX
argument_list|(
name|va
argument_list|)
operator|!=
name|L1_IDX
argument_list|(
name|vector_page
argument_list|)
argument_list|,
operator|(
literal|"pmap_demote_section: forbidden section mapping"
operator|)
argument_list|)
expr_stmt|;
name|va
operator|=
name|trunc_1mpage
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|pl1pd
operator|=
operator|&
name|pmap
operator|->
name|pm_l1
operator|->
name|l1_kva
index|[
name|L1_IDX
argument_list|(
name|va
argument_list|)
index|]
expr_stmt|;
name|l1pd
operator|=
operator|*
name|pl1pd
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|l1pd
operator|&
name|L1_TYPE_MASK
operator|)
operator|==
name|L1_S_PROTO
argument_list|,
operator|(
literal|"pmap_demote_section: not section or invalid section"
operator|)
argument_list|)
expr_stmt|;
name|pa
operator|=
name|l1pd
operator|&
name|L1_S_FRAME
expr_stmt|;
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|m
operator|!=
name|NULL
operator|&&
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|==
literal|0
operator|)
argument_list|,
operator|(
literal|"pmap_demote_section: no vm_page for selected superpage or"
literal|"unmanaged"
operator|)
argument_list|)
expr_stmt|;
name|pvh
operator|=
name|pa_to_pvh
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|l1pdpve
operator|=
name|pmap_find_pv
argument_list|(
name|pvh
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|l1pdpve
operator|!=
name|NULL
argument_list|,
operator|(
literal|"pmap_demote_section: no pv entry for "
literal|"managed page"
operator|)
argument_list|)
expr_stmt|;
name|l2b
operator|=
name|pmap_get_l2_bucket
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|l2b
operator|==
name|NULL
condition|)
block|{
name|KASSERT
argument_list|(
operator|(
name|l1pdpve
operator|->
name|pv_flags
operator|&
name|PVF_WIRED
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_demote_section: No l2_bucket for wired mapping"
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * Invalidate the 1MB section mapping and return 		 * "failure" if the mapping was never accessed or the 		 * allocation of the new l2_bucket fails. 		 */
if|if
condition|(
operator|!
name|L1_S_REFERENCED
argument_list|(
name|l1pd
argument_list|)
operator|||
operator|(
name|l2b
operator|=
name|pmap_alloc_l2_bucket
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* Unmap and invalidate superpage. */
name|pmap_remove_section
argument_list|(
name|pmap
argument_list|,
name|trunc_1mpage
argument_list|(
name|va
argument_list|)
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"pmap_demote_section: failure for "
literal|"va %#x in pmap %p"
argument_list|,
name|va
argument_list|,
name|pmap
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
block|}
comment|/* 	 * Now we should have corresponding l2_bucket available. 	 * Let's process it to recreate 256 PTEs for each base page 	 * within superpage. 	 */
name|newpte
operator|=
name|pa
operator||
name|L1_S_DEMOTE
argument_list|(
name|l1pd
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|md
operator|.
name|pv_memattr
operator|!=
name|VM_MEMATTR_UNCACHEABLE
condition|)
name|newpte
operator||=
name|pte_l2_s_cache_mode
expr_stmt|;
comment|/* 	 * If the l2_bucket is new, initialize it. 	 */
if|if
condition|(
name|l2b
operator|->
name|l2b_occupancy
operator|==
literal|0
condition|)
name|pmap_fill_l2b
argument_list|(
name|l2b
argument_list|,
name|newpte
argument_list|)
expr_stmt|;
else|else
block|{
name|firstptep
operator|=
operator|&
name|l2b
operator|->
name|l2b_kva
index|[
literal|0
index|]
expr_stmt|;
name|KASSERT
argument_list|(
name|l2pte_pa
argument_list|(
operator|*
name|firstptep
argument_list|)
operator|==
operator|(
name|pa
operator|)
argument_list|,
operator|(
literal|"pmap_demote_section: firstpte and newpte map different "
literal|"physical addresses"
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * If the mapping has changed attributes, update the page table 		 * entries. 		 */
if|if
condition|(
operator|(
operator|*
name|firstptep
operator|&
name|L2_S_PROMOTE
operator|)
operator|!=
operator|(
name|L1_S_DEMOTE
argument_list|(
name|l1pd
argument_list|)
operator|)
condition|)
name|pmap_fill_l2b
argument_list|(
name|l2b
argument_list|,
name|newpte
argument_list|)
expr_stmt|;
block|}
comment|/* Demote PV entry */
name|pmap_pv_demote_section
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|pa
argument_list|)
expr_stmt|;
comment|/* Now fix-up L1 */
name|newl1pd
operator|=
name|l2b
operator|->
name|l2b_phys
operator||
name|L1_C_DOM
argument_list|(
name|pmap
operator|->
name|pm_domain
argument_list|)
operator||
name|L1_C_PROTO
expr_stmt|;
operator|*
name|pl1pd
operator|=
name|newl1pd
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|pl1pd
argument_list|)
expr_stmt|;
comment|/* Invalidate old TLB mapping */
if|if
condition|(
name|L1_S_EXECUTABLE
argument_list|(
name|l1pd
argument_list|)
condition|)
name|cpu_tlb_flushID_SE
argument_list|(
name|va
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|L1_S_REFERENCED
argument_list|(
name|l1pd
argument_list|)
condition|)
name|cpu_tlb_flushD_SE
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|cpu_cpwait
argument_list|()
expr_stmt|;
name|pmap_section_demotions
operator|++
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"pmap_demote_section: success for va %#x"
literal|" in pmap %p"
argument_list|,
name|va
argument_list|,
name|pmap
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/***************************************************  * page management routines.  ***************************************************/
end_comment

begin_comment
comment|/*  * We are in a serious low memory condition.  Resort to  * drastic measures to free some pages so we can allocate  * another pv entry chunk.  */
end_comment

begin_function
specifier|static
name|vm_page_t
name|pmap_pv_reclaim
parameter_list|(
name|pmap_t
name|locked_pmap
parameter_list|)
block|{
name|struct
name|pch
name|newtail
decl_stmt|;
name|struct
name|pv_chunk
modifier|*
name|pc
decl_stmt|;
name|struct
name|l2_bucket
modifier|*
name|l2b
init|=
name|NULL
decl_stmt|;
name|pmap_t
name|pmap
decl_stmt|;
name|pd_entry_t
modifier|*
name|pl1pd
decl_stmt|;
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|;
name|pv_entry_t
name|pv
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
name|vm_page_t
name|free
decl_stmt|,
name|m
decl_stmt|,
name|m_pc
decl_stmt|;
name|uint32_t
name|inuse
decl_stmt|;
name|int
name|bit
decl_stmt|,
name|field
decl_stmt|,
name|freed
decl_stmt|,
name|idx
decl_stmt|;
name|PMAP_ASSERT_LOCKED
argument_list|(
name|locked_pmap
argument_list|)
expr_stmt|;
name|pmap
operator|=
name|NULL
expr_stmt|;
name|free
operator|=
name|m_pc
operator|=
name|NULL
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|newtail
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|pc
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pv_chunks
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|(
name|pv_vafree
operator|==
literal|0
operator|||
name|free
operator|==
name|NULL
operator|)
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pv_chunks
argument_list|,
name|pc
argument_list|,
name|pc_lru
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap
operator|!=
name|pc
operator|->
name|pc_pmap
condition|)
block|{
if|if
condition|(
name|pmap
operator|!=
name|NULL
condition|)
block|{
name|cpu_tlb_flushID
argument_list|()
expr_stmt|;
name|cpu_cpwait
argument_list|()
expr_stmt|;
if|if
condition|(
name|pmap
operator|!=
name|locked_pmap
condition|)
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
name|pmap
operator|=
name|pc
operator|->
name|pc_pmap
expr_stmt|;
comment|/* Avoid deadlock and lock recursion. */
if|if
condition|(
name|pmap
operator|>
name|locked_pmap
condition|)
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pmap
operator|!=
name|locked_pmap
operator|&&
operator|!
name|PMAP_TRYLOCK
argument_list|(
name|pmap
argument_list|)
condition|)
block|{
name|pmap
operator|=
name|NULL
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|newtail
argument_list|,
name|pc
argument_list|,
name|pc_lru
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* 		 * Destroy every non-wired, 4 KB page mapping in the chunk. 		 */
name|freed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|field
operator|=
literal|0
init|;
name|field
operator|<
name|_NPCM
condition|;
name|field
operator|++
control|)
block|{
for|for
control|(
name|inuse
operator|=
operator|~
name|pc
operator|->
name|pc_map
index|[
name|field
index|]
operator|&
name|pc_freemask
index|[
name|field
index|]
init|;
name|inuse
operator|!=
literal|0
condition|;
name|inuse
operator|&=
operator|~
operator|(
literal|1UL
operator|<<
name|bit
operator|)
control|)
block|{
name|bit
operator|=
name|ffs
argument_list|(
name|inuse
argument_list|)
operator|-
literal|1
expr_stmt|;
name|idx
operator|=
name|field
operator|*
sizeof|sizeof
argument_list|(
name|inuse
argument_list|)
operator|*
name|NBBY
operator|+
name|bit
expr_stmt|;
name|pv
operator|=
operator|&
name|pc
operator|->
name|pc_pventry
index|[
name|idx
index|]
expr_stmt|;
name|va
operator|=
name|pv
operator|->
name|pv_va
expr_stmt|;
name|pl1pd
operator|=
operator|&
name|pmap
operator|->
name|pm_l1
operator|->
name|l1_kva
index|[
name|L1_IDX
argument_list|(
name|va
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|pl1pd
operator|&
name|L1_TYPE_MASK
operator|)
operator|==
name|L1_S_PROTO
condition|)
continue|continue;
if|if
condition|(
name|pv
operator|->
name|pv_flags
operator|&
name|PVF_WIRED
condition|)
continue|continue;
name|l2b
operator|=
name|pmap_get_l2_bucket
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|l2b
operator|!=
name|NULL
argument_list|,
operator|(
literal|"No l2 bucket"
operator|)
argument_list|)
expr_stmt|;
name|ptep
operator|=
operator|&
name|l2b
operator|->
name|l2b_kva
index|[
name|l2pte_index
argument_list|(
name|va
argument_list|)
index|]
expr_stmt|;
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|l2pte_pa
argument_list|(
operator|*
name|ptep
argument_list|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|m
operator|>=
name|KERNBASE
argument_list|,
operator|(
literal|"Trying to access non-existent page "
literal|"va %x pte %x"
operator|,
name|va
operator|,
operator|*
name|ptep
operator|)
argument_list|)
expr_stmt|;
operator|*
name|ptep
operator|=
literal|0
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|ptep
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|,
name|pv
argument_list|,
name|pv_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|)
condition|)
name|vm_page_aflag_clear
argument_list|(
name|m
argument_list|,
name|PGA_WRITEABLE
argument_list|)
expr_stmt|;
name|pc
operator|->
name|pc_map
index|[
name|field
index|]
operator||=
literal|1UL
operator|<<
name|bit
expr_stmt|;
name|freed
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|freed
operator|==
literal|0
condition|)
block|{
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|newtail
argument_list|,
name|pc
argument_list|,
name|pc_lru
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Every freed mapping is for a 4 KB page. */
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|-=
name|freed
expr_stmt|;
name|PV_STAT
argument_list|(
name|pv_entry_frees
operator|+=
name|freed
argument_list|)
expr_stmt|;
name|PV_STAT
argument_list|(
name|pv_entry_spare
operator|+=
name|freed
argument_list|)
expr_stmt|;
name|pv_entry_count
operator|-=
name|freed
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvchunk
argument_list|,
name|pc
argument_list|,
name|pc_list
argument_list|)
expr_stmt|;
for|for
control|(
name|field
operator|=
literal|0
init|;
name|field
operator|<
name|_NPCM
condition|;
name|field
operator|++
control|)
if|if
condition|(
name|pc
operator|->
name|pc_map
index|[
name|field
index|]
operator|!=
name|pc_freemask
index|[
name|field
index|]
condition|)
block|{
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvchunk
argument_list|,
name|pc
argument_list|,
name|pc_list
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|newtail
argument_list|,
name|pc
argument_list|,
name|pc_lru
argument_list|)
expr_stmt|;
comment|/* 				 * One freed pv entry in locked_pmap is 				 * sufficient. 				 */
if|if
condition|(
name|pmap
operator|==
name|locked_pmap
condition|)
goto|goto
name|out
goto|;
break|break;
block|}
if|if
condition|(
name|field
operator|==
name|_NPCM
condition|)
block|{
name|PV_STAT
argument_list|(
name|pv_entry_spare
operator|-=
name|_NPCPV
argument_list|)
expr_stmt|;
name|PV_STAT
argument_list|(
name|pc_chunk_count
operator|--
argument_list|)
expr_stmt|;
name|PV_STAT
argument_list|(
name|pc_chunk_frees
operator|++
argument_list|)
expr_stmt|;
comment|/* Entire chunk is free; return it. */
name|m_pc
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pmap_kextract
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|pc
argument_list|)
argument_list|)
expr_stmt|;
name|pmap_qremove
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|pc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pmap_ptelist_free
argument_list|(
operator|&
name|pv_vafree
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|pc
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|out
label|:
name|TAILQ_CONCAT
argument_list|(
operator|&
name|pv_chunks
argument_list|,
operator|&
name|newtail
argument_list|,
name|pc_lru
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap
operator|!=
name|NULL
condition|)
block|{
name|cpu_tlb_flushID
argument_list|()
expr_stmt|;
name|cpu_cpwait
argument_list|()
expr_stmt|;
if|if
condition|(
name|pmap
operator|!=
name|locked_pmap
condition|)
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|m_pc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * free the pv_entry back to the free list  */
end_comment

begin_function
specifier|static
name|void
name|pmap_free_pv_entry
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|pv_entry_t
name|pv
parameter_list|)
block|{
name|struct
name|pv_chunk
modifier|*
name|pc
decl_stmt|;
name|int
name|bit
decl_stmt|,
name|field
decl_stmt|,
name|idx
decl_stmt|;
name|rw_assert
argument_list|(
operator|&
name|pvh_global_lock
argument_list|,
name|RA_WLOCKED
argument_list|)
expr_stmt|;
name|PMAP_ASSERT_LOCKED
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|PV_STAT
argument_list|(
name|pv_entry_frees
operator|++
argument_list|)
expr_stmt|;
name|PV_STAT
argument_list|(
name|pv_entry_spare
operator|++
argument_list|)
expr_stmt|;
name|pv_entry_count
operator|--
expr_stmt|;
name|pc
operator|=
name|pv_to_chunk
argument_list|(
name|pv
argument_list|)
expr_stmt|;
name|idx
operator|=
name|pv
operator|-
operator|&
name|pc
operator|->
name|pc_pventry
index|[
literal|0
index|]
expr_stmt|;
name|field
operator|=
name|idx
operator|/
operator|(
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
operator|*
name|NBBY
operator|)
expr_stmt|;
name|bit
operator|=
name|idx
operator|%
operator|(
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
operator|*
name|NBBY
operator|)
expr_stmt|;
name|pc
operator|->
name|pc_map
index|[
name|field
index|]
operator||=
literal|1ul
operator|<<
name|bit
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|_NPCM
condition|;
name|idx
operator|++
control|)
if|if
condition|(
name|pc
operator|->
name|pc_map
index|[
name|idx
index|]
operator|!=
name|pc_freemask
index|[
name|idx
index|]
condition|)
block|{
comment|/* 			 * 98% of the time, pc is already at the head of the 			 * list.  If it isn't already, move it to the head. 			 */
if|if
condition|(
name|__predict_false
argument_list|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvchunk
argument_list|)
operator|!=
name|pc
argument_list|)
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvchunk
argument_list|,
name|pc
argument_list|,
name|pc_list
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvchunk
argument_list|,
name|pc
argument_list|,
name|pc_list
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvchunk
argument_list|,
name|pc
argument_list|,
name|pc_list
argument_list|)
expr_stmt|;
name|pmap_free_pv_chunk
argument_list|(
name|pc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pmap_free_pv_chunk
parameter_list|(
name|struct
name|pv_chunk
modifier|*
name|pc
parameter_list|)
block|{
name|vm_page_t
name|m
decl_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pv_chunks
argument_list|,
name|pc
argument_list|,
name|pc_lru
argument_list|)
expr_stmt|;
name|PV_STAT
argument_list|(
name|pv_entry_spare
operator|-=
name|_NPCPV
argument_list|)
expr_stmt|;
name|PV_STAT
argument_list|(
name|pc_chunk_count
operator|--
argument_list|)
expr_stmt|;
name|PV_STAT
argument_list|(
name|pc_chunk_frees
operator|++
argument_list|)
expr_stmt|;
comment|/* entire chunk is free, return it */
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pmap_kextract
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|pc
argument_list|)
argument_list|)
expr_stmt|;
name|pmap_qremove
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|pc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vm_page_unwire
argument_list|(
name|m
argument_list|,
name|PQ_INACTIVE
argument_list|)
expr_stmt|;
name|vm_page_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|pmap_ptelist_free
argument_list|(
operator|&
name|pv_vafree
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|pc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|pv_entry_t
name|pmap_get_pv_entry
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|boolean_t
name|try
parameter_list|)
block|{
specifier|static
specifier|const
name|struct
name|timeval
name|printinterval
init|=
block|{
literal|60
block|,
literal|0
block|}
decl_stmt|;
specifier|static
name|struct
name|timeval
name|lastprint
decl_stmt|;
name|struct
name|pv_chunk
modifier|*
name|pc
decl_stmt|;
name|pv_entry_t
name|pv
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|int
name|bit
decl_stmt|,
name|field
decl_stmt|,
name|idx
decl_stmt|;
name|rw_assert
argument_list|(
operator|&
name|pvh_global_lock
argument_list|,
name|RA_WLOCKED
argument_list|)
expr_stmt|;
name|PMAP_ASSERT_LOCKED
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|PV_STAT
argument_list|(
name|pv_entry_allocs
operator|++
argument_list|)
expr_stmt|;
name|pv_entry_count
operator|++
expr_stmt|;
if|if
condition|(
name|pv_entry_count
operator|>
name|pv_entry_high_water
condition|)
if|if
condition|(
name|ratecheck
argument_list|(
operator|&
name|lastprint
argument_list|,
operator|&
name|printinterval
argument_list|)
condition|)
name|printf
argument_list|(
literal|"%s: Approaching the limit on PV entries.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|retry
label|:
name|pc
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvchunk
argument_list|)
expr_stmt|;
if|if
condition|(
name|pc
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|field
operator|=
literal|0
init|;
name|field
operator|<
name|_NPCM
condition|;
name|field
operator|++
control|)
block|{
if|if
condition|(
name|pc
operator|->
name|pc_map
index|[
name|field
index|]
condition|)
block|{
name|bit
operator|=
name|ffs
argument_list|(
name|pc
operator|->
name|pc_map
index|[
name|field
index|]
argument_list|)
operator|-
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|field
operator|<
name|_NPCM
condition|)
block|{
name|idx
operator|=
name|field
operator|*
sizeof|sizeof
argument_list|(
name|pc
operator|->
name|pc_map
index|[
name|field
index|]
argument_list|)
operator|*
name|NBBY
operator|+
name|bit
expr_stmt|;
name|pv
operator|=
operator|&
name|pc
operator|->
name|pc_pventry
index|[
name|idx
index|]
expr_stmt|;
name|pc
operator|->
name|pc_map
index|[
name|field
index|]
operator|&=
operator|~
operator|(
literal|1ul
operator|<<
name|bit
operator|)
expr_stmt|;
comment|/* If this was the last item, move it to tail */
for|for
control|(
name|field
operator|=
literal|0
init|;
name|field
operator|<
name|_NPCM
condition|;
name|field
operator|++
control|)
if|if
condition|(
name|pc
operator|->
name|pc_map
index|[
name|field
index|]
operator|!=
literal|0
condition|)
block|{
name|PV_STAT
argument_list|(
name|pv_entry_spare
operator|--
argument_list|)
expr_stmt|;
return|return
operator|(
name|pv
operator|)
return|;
comment|/* not full, return */
block|}
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvchunk
argument_list|,
name|pc
argument_list|,
name|pc_list
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvchunk
argument_list|,
name|pc
argument_list|,
name|pc_list
argument_list|)
expr_stmt|;
name|PV_STAT
argument_list|(
name|pv_entry_spare
operator|--
argument_list|)
expr_stmt|;
return|return
operator|(
name|pv
operator|)
return|;
block|}
block|}
comment|/* 	 * Access to the ptelist "pv_vafree" is synchronized by the pvh 	 * global lock.  If "pv_vafree" is currently non-empty, it will 	 * remain non-empty until pmap_ptelist_alloc() completes. 	 */
if|if
condition|(
name|pv_vafree
operator|==
literal|0
operator|||
operator|(
name|m
operator|=
name|vm_page_alloc
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|VM_ALLOC_NORMAL
operator||
name|VM_ALLOC_NOOBJ
operator||
name|VM_ALLOC_WIRED
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|try
condition|)
block|{
name|pv_entry_count
operator|--
expr_stmt|;
name|PV_STAT
argument_list|(
name|pc_chunk_tryfail
operator|++
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|m
operator|=
name|pmap_pv_reclaim
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
goto|goto
name|retry
goto|;
block|}
name|PV_STAT
argument_list|(
name|pc_chunk_count
operator|++
argument_list|)
expr_stmt|;
name|PV_STAT
argument_list|(
name|pc_chunk_allocs
operator|++
argument_list|)
expr_stmt|;
name|pc
operator|=
operator|(
expr|struct
name|pv_chunk
operator|*
operator|)
name|pmap_ptelist_alloc
argument_list|(
operator|&
name|pv_vafree
argument_list|)
expr_stmt|;
name|pmap_qenter
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|pc
argument_list|,
operator|&
name|m
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pc
operator|->
name|pc_pmap
operator|=
name|pmap
expr_stmt|;
name|pc
operator|->
name|pc_map
index|[
literal|0
index|]
operator|=
name|pc_freemask
index|[
literal|0
index|]
operator|&
operator|~
literal|1ul
expr_stmt|;
comment|/* preallocated bit 0 */
for|for
control|(
name|field
operator|=
literal|1
init|;
name|field
operator|<
name|_NPCM
condition|;
name|field
operator|++
control|)
name|pc
operator|->
name|pc_map
index|[
name|field
index|]
operator|=
name|pc_freemask
index|[
name|field
index|]
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|pv_chunks
argument_list|,
name|pc
argument_list|,
name|pc_lru
argument_list|)
expr_stmt|;
name|pv
operator|=
operator|&
name|pc
operator|->
name|pc_pventry
index|[
literal|0
index|]
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvchunk
argument_list|,
name|pc
argument_list|,
name|pc_list
argument_list|)
expr_stmt|;
name|PV_STAT
argument_list|(
name|pv_entry_spare
operator|+=
name|_NPCPV
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|pv
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	Remove the given range of addresses from the specified map.  *  *	It is assumed that the start and end are properly  *	rounded to the page size.  */
end_comment

begin_define
define|#
directive|define
name|PMAP_REMOVE_CLEAN_LIST_SIZE
value|3
end_define

begin_function
name|void
name|pmap_remove
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|sva
parameter_list|,
name|vm_offset_t
name|eva
parameter_list|)
block|{
name|struct
name|l2_bucket
modifier|*
name|l2b
decl_stmt|;
name|vm_offset_t
name|next_bucket
decl_stmt|;
name|pd_entry_t
name|l1pd
decl_stmt|;
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|;
name|u_int
name|total
decl_stmt|;
name|u_int
name|mappings
decl_stmt|,
name|is_exec
decl_stmt|,
name|is_refd
decl_stmt|;
name|int
name|flushall
init|=
literal|0
decl_stmt|;
comment|/* 	 * we lock in the pmap => pv_head direction 	 */
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|total
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|sva
operator|<
name|eva
condition|)
block|{
name|next_bucket
operator|=
name|L2_NEXT_BUCKET
argument_list|(
name|sva
argument_list|)
expr_stmt|;
comment|/* 		 * Check for large page. 		 */
name|l1pd
operator|=
name|pmap
operator|->
name|pm_l1
operator|->
name|l1_kva
index|[
name|L1_IDX
argument_list|(
name|sva
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|l1pd
operator|&
name|L1_TYPE_MASK
operator|)
operator|==
name|L1_S_PROTO
condition|)
block|{
name|KASSERT
argument_list|(
operator|(
name|l1pd
operator|&
name|L1_S_DOM_MASK
operator|)
operator|!=
name|L1_S_DOM
argument_list|(
name|PMAP_DOMAIN_KERNEL
argument_list|)
argument_list|,
operator|(
literal|"pmap_remove: "
literal|"Trying to remove kernel section mapping"
operator|)
argument_list|)
expr_stmt|;
comment|/* 			 * Are we removing the entire large page?  If not, 			 * demote the mapping and fall through. 			 */
if|if
condition|(
name|sva
operator|+
name|L1_S_SIZE
operator|==
name|next_bucket
operator|&&
name|eva
operator|>=
name|next_bucket
condition|)
block|{
name|pmap_remove_section
argument_list|(
name|pmap
argument_list|,
name|sva
argument_list|)
expr_stmt|;
name|sva
operator|=
name|next_bucket
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|!
name|pmap_demote_section
argument_list|(
name|pmap
argument_list|,
name|sva
argument_list|)
condition|)
block|{
comment|/* The large page mapping was destroyed. */
name|sva
operator|=
name|next_bucket
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* 		 * Do one L2 bucket's worth at a time. 		 */
if|if
condition|(
name|next_bucket
operator|>
name|eva
condition|)
name|next_bucket
operator|=
name|eva
expr_stmt|;
name|l2b
operator|=
name|pmap_get_l2_bucket
argument_list|(
name|pmap
argument_list|,
name|sva
argument_list|)
expr_stmt|;
if|if
condition|(
name|l2b
operator|==
name|NULL
condition|)
block|{
name|sva
operator|=
name|next_bucket
expr_stmt|;
continue|continue;
block|}
name|ptep
operator|=
operator|&
name|l2b
operator|->
name|l2b_kva
index|[
name|l2pte_index
argument_list|(
name|sva
argument_list|)
index|]
expr_stmt|;
name|mappings
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|sva
operator|<
name|next_bucket
condition|)
block|{
name|struct
name|vm_page
modifier|*
name|m
decl_stmt|;
name|pt_entry_t
name|pte
decl_stmt|;
name|vm_paddr_t
name|pa
decl_stmt|;
name|pte
operator|=
operator|*
name|ptep
expr_stmt|;
if|if
condition|(
name|pte
operator|==
literal|0
condition|)
block|{
comment|/* 				 * Nothing here, move along 				 */
name|sva
operator|+=
name|PAGE_SIZE
expr_stmt|;
name|ptep
operator|++
expr_stmt|;
continue|continue;
block|}
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|--
expr_stmt|;
name|pa
operator|=
name|l2pte_pa
argument_list|(
name|pte
argument_list|)
expr_stmt|;
name|is_exec
operator|=
literal|0
expr_stmt|;
name|is_refd
operator|=
literal|1
expr_stmt|;
comment|/* 			 * Update flags. In a number of circumstances, 			 * we could cluster a lot of these and do a 			 * number of sequential pages in one go. 			 */
if|if
condition|(
operator|(
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pa
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|struct
name|pv_entry
modifier|*
name|pve
decl_stmt|;
name|pve
operator|=
name|pmap_remove_pv
argument_list|(
name|m
argument_list|,
name|pmap
argument_list|,
name|sva
argument_list|)
expr_stmt|;
if|if
condition|(
name|pve
condition|)
block|{
name|is_exec
operator|=
name|PTE_BEEN_EXECD
argument_list|(
name|pte
argument_list|)
expr_stmt|;
name|is_refd
operator|=
name|PTE_BEEN_REFD
argument_list|(
name|pte
argument_list|)
expr_stmt|;
name|pmap_free_pv_entry
argument_list|(
name|pmap
argument_list|,
name|pve
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|ptep
operator|=
literal|0
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|ptep
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap_is_current
argument_list|(
name|pmap
argument_list|)
condition|)
block|{
name|total
operator|++
expr_stmt|;
if|if
condition|(
name|total
operator|<
name|PMAP_REMOVE_CLEAN_LIST_SIZE
condition|)
block|{
if|if
condition|(
name|is_exec
condition|)
name|cpu_tlb_flushID_SE
argument_list|(
name|sva
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|is_refd
condition|)
name|cpu_tlb_flushD_SE
argument_list|(
name|sva
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|total
operator|==
name|PMAP_REMOVE_CLEAN_LIST_SIZE
condition|)
name|flushall
operator|=
literal|1
expr_stmt|;
block|}
name|sva
operator|+=
name|PAGE_SIZE
expr_stmt|;
name|ptep
operator|++
expr_stmt|;
name|mappings
operator|++
expr_stmt|;
block|}
name|pmap_free_l2_bucket
argument_list|(
name|pmap
argument_list|,
name|l2b
argument_list|,
name|mappings
argument_list|)
expr_stmt|;
block|}
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|flushall
condition|)
name|cpu_tlb_flushID
argument_list|()
expr_stmt|;
name|cpu_cpwait
argument_list|()
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * pmap_zero_page()  *  * Zero a given physical page by mapping it at a page hook point.  * In doing the zero page op, the page we zero is mapped cachable, as with  * StrongARM accesses to non-cached pages are non-burst making writing  * _any_ bulk data very slow.  */
end_comment

begin_function
specifier|static
name|void
name|pmap_zero_page_gen
parameter_list|(
name|vm_page_t
name|m
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|struct
name|czpages
modifier|*
name|czp
decl_stmt|;
name|KASSERT
argument_list|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|)
argument_list|,
operator|(
literal|"pmap_zero_page_gen: page has mappings"
operator|)
argument_list|)
expr_stmt|;
name|vm_paddr_t
name|phys
init|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|sched_pin
argument_list|()
expr_stmt|;
name|czp
operator|=
operator|&
name|cpu_czpages
index|[
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
index|]
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|czp
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* 	 * Hook in the page, zero it. 	 */
operator|*
name|czp
operator|->
name|dstptep
operator|=
name|L2_S_PROTO
operator||
name|phys
operator||
name|pte_l2_s_cache_mode
operator||
name|L2_S_REF
expr_stmt|;
name|pmap_set_prot
argument_list|(
name|czp
operator|->
name|dstptep
argument_list|,
name|VM_PROT_WRITE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|czp
operator|->
name|dstptep
argument_list|)
expr_stmt|;
name|cpu_tlb_flushD_SE
argument_list|(
name|czp
operator|->
name|dstva
argument_list|)
expr_stmt|;
name|cpu_cpwait
argument_list|()
expr_stmt|;
if|if
condition|(
name|off
operator|||
name|size
operator|!=
name|PAGE_SIZE
condition|)
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|czp
operator|->
name|dstva
operator|+
name|off
operator|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
name|bzero_page
argument_list|(
name|czp
operator|->
name|dstva
argument_list|)
expr_stmt|;
comment|/* 	 * Although aliasing is not possible, if we use temporary mappings with 	 * memory that will be mapped later as non-cached or with write-through 	 * caches, we might end up overwriting it when calling wbinv_all.  So 	 * make sure caches are clean after the operation. 	 */
name|cpu_idcache_wbinv_range
argument_list|(
name|czp
operator|->
name|dstva
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|pmap_l2cache_wbinv_range
argument_list|(
name|czp
operator|->
name|dstva
argument_list|,
name|phys
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|czp
operator|->
name|lock
argument_list|)
expr_stmt|;
name|sched_unpin
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	pmap_zero_page zeros the specified hardware page by mapping  *	the page into KVM and using bzero to clear its contents.  */
end_comment

begin_function
name|void
name|pmap_zero_page
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|pmap_zero_page_gen
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	pmap_zero_page_area zeros the specified hardware page by mapping  *	the page into KVM and using bzero to clear its contents.  *  *	off and size may not cover an area beyond a single hardware page.  */
end_comment

begin_function
name|void
name|pmap_zero_page_area
parameter_list|(
name|vm_page_t
name|m
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|pmap_zero_page_gen
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	pmap_zero_page_idle zeros the specified hardware page by mapping  *	the page into KVM and using bzero to clear its contents.  This  *	is intended to be called from the vm_pagezero process only and  *	outside of Giant.  */
end_comment

begin_function
name|void
name|pmap_zero_page_idle
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|pmap_zero_page
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	pmap_copy_page copies the specified (machine independent)  *	page by mapping the page into virtual memory and using  *	bcopy to copy the page, one machine dependent page at a  *	time.  */
end_comment

begin_comment
comment|/*  * pmap_copy_page()  *  * Copy one physical page into another, by mapping the pages into  * hook points. The same comment regarding cachability as in  * pmap_zero_page also applies here.  */
end_comment

begin_function
name|void
name|pmap_copy_page_generic
parameter_list|(
name|vm_paddr_t
name|src
parameter_list|,
name|vm_paddr_t
name|dst
parameter_list|)
block|{
name|struct
name|czpages
modifier|*
name|czp
decl_stmt|;
name|sched_pin
argument_list|()
expr_stmt|;
name|czp
operator|=
operator|&
name|cpu_czpages
index|[
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
index|]
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|czp
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* 	 * Map the pages into the page hook points, copy them, and purge the 	 * cache for the appropriate page. 	 */
operator|*
name|czp
operator|->
name|srcptep
operator|=
name|L2_S_PROTO
operator||
name|src
operator||
name|pte_l2_s_cache_mode
operator||
name|L2_S_REF
expr_stmt|;
name|pmap_set_prot
argument_list|(
name|czp
operator|->
name|srcptep
argument_list|,
name|VM_PROT_READ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|czp
operator|->
name|srcptep
argument_list|)
expr_stmt|;
name|cpu_tlb_flushD_SE
argument_list|(
name|czp
operator|->
name|srcva
argument_list|)
expr_stmt|;
operator|*
name|czp
operator|->
name|dstptep
operator|=
name|L2_S_PROTO
operator||
name|dst
operator||
name|pte_l2_s_cache_mode
operator||
name|L2_S_REF
expr_stmt|;
name|pmap_set_prot
argument_list|(
name|czp
operator|->
name|dstptep
argument_list|,
name|VM_PROT_READ
operator||
name|VM_PROT_WRITE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|czp
operator|->
name|dstptep
argument_list|)
expr_stmt|;
name|cpu_tlb_flushD_SE
argument_list|(
name|czp
operator|->
name|dstva
argument_list|)
expr_stmt|;
name|cpu_cpwait
argument_list|()
expr_stmt|;
name|bcopy_page
argument_list|(
name|czp
operator|->
name|srcva
argument_list|,
name|czp
operator|->
name|dstva
argument_list|)
expr_stmt|;
comment|/* 	 * Although aliasing is not possible, if we use temporary mappings with 	 * memory that will be mapped later as non-cached or with write-through 	 * caches, we might end up overwriting it when calling wbinv_all.  So 	 * make sure caches are clean after the operation. 	 */
name|cpu_idcache_wbinv_range
argument_list|(
name|czp
operator|->
name|dstva
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|pmap_l2cache_wbinv_range
argument_list|(
name|czp
operator|->
name|dstva
argument_list|,
name|dst
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|czp
operator|->
name|lock
argument_list|)
expr_stmt|;
name|sched_unpin
argument_list|()
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|int
name|unmapped_buf_allowed
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|pmap_copy_pages
parameter_list|(
name|vm_page_t
name|ma
index|[]
parameter_list|,
name|vm_offset_t
name|a_offset
parameter_list|,
name|vm_page_t
name|mb
index|[]
parameter_list|,
name|vm_offset_t
name|b_offset
parameter_list|,
name|int
name|xfersize
parameter_list|)
block|{
name|vm_page_t
name|a_pg
decl_stmt|,
name|b_pg
decl_stmt|;
name|vm_offset_t
name|a_pg_offset
decl_stmt|,
name|b_pg_offset
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|struct
name|czpages
modifier|*
name|czp
decl_stmt|;
name|sched_pin
argument_list|()
expr_stmt|;
name|czp
operator|=
operator|&
name|cpu_czpages
index|[
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
index|]
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|czp
operator|->
name|lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|xfersize
operator|>
literal|0
condition|)
block|{
name|a_pg
operator|=
name|ma
index|[
name|a_offset
operator|>>
name|PAGE_SHIFT
index|]
expr_stmt|;
name|a_pg_offset
operator|=
name|a_offset
operator|&
name|PAGE_MASK
expr_stmt|;
name|cnt
operator|=
name|min
argument_list|(
name|xfersize
argument_list|,
name|PAGE_SIZE
operator|-
name|a_pg_offset
argument_list|)
expr_stmt|;
name|b_pg
operator|=
name|mb
index|[
name|b_offset
operator|>>
name|PAGE_SHIFT
index|]
expr_stmt|;
name|b_pg_offset
operator|=
name|b_offset
operator|&
name|PAGE_MASK
expr_stmt|;
name|cnt
operator|=
name|min
argument_list|(
name|cnt
argument_list|,
name|PAGE_SIZE
operator|-
name|b_pg_offset
argument_list|)
expr_stmt|;
operator|*
name|czp
operator|->
name|srcptep
operator|=
name|L2_S_PROTO
operator||
name|VM_PAGE_TO_PHYS
argument_list|(
name|a_pg
argument_list|)
operator||
name|pte_l2_s_cache_mode
operator||
name|L2_S_REF
expr_stmt|;
name|pmap_set_prot
argument_list|(
name|czp
operator|->
name|srcptep
argument_list|,
name|VM_PROT_READ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|czp
operator|->
name|srcptep
argument_list|)
expr_stmt|;
name|cpu_tlb_flushD_SE
argument_list|(
name|czp
operator|->
name|srcva
argument_list|)
expr_stmt|;
operator|*
name|czp
operator|->
name|dstptep
operator|=
name|L2_S_PROTO
operator||
name|VM_PAGE_TO_PHYS
argument_list|(
name|b_pg
argument_list|)
operator||
name|pte_l2_s_cache_mode
operator||
name|L2_S_REF
expr_stmt|;
name|pmap_set_prot
argument_list|(
name|czp
operator|->
name|dstptep
argument_list|,
name|VM_PROT_READ
operator||
name|VM_PROT_WRITE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|czp
operator|->
name|dstptep
argument_list|)
expr_stmt|;
name|cpu_tlb_flushD_SE
argument_list|(
name|czp
operator|->
name|dstva
argument_list|)
expr_stmt|;
name|cpu_cpwait
argument_list|()
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|czp
operator|->
name|srcva
operator|+
name|a_pg_offset
argument_list|,
operator|(
name|char
operator|*
operator|)
name|czp
operator|->
name|dstva
operator|+
name|b_pg_offset
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
name|cpu_idcache_wbinv_range
argument_list|(
name|czp
operator|->
name|dstva
operator|+
name|b_pg_offset
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
name|pmap_l2cache_wbinv_range
argument_list|(
name|czp
operator|->
name|dstva
operator|+
name|b_pg_offset
argument_list|,
name|VM_PAGE_TO_PHYS
argument_list|(
name|b_pg
argument_list|)
operator|+
name|b_pg_offset
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
name|xfersize
operator|-=
name|cnt
expr_stmt|;
name|a_offset
operator|+=
name|cnt
expr_stmt|;
name|b_offset
operator|+=
name|cnt
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|czp
operator|->
name|lock
argument_list|)
expr_stmt|;
name|sched_unpin
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pmap_copy_page
parameter_list|(
name|vm_page_t
name|src
parameter_list|,
name|vm_page_t
name|dst
parameter_list|)
block|{
if|if
condition|(
name|_arm_memcpy
operator|&&
name|PAGE_SIZE
operator|>=
name|_min_memcpy_size
operator|&&
name|_arm_memcpy
argument_list|(
operator|(
name|void
operator|*
operator|)
name|VM_PAGE_TO_PHYS
argument_list|(
name|dst
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
name|VM_PAGE_TO_PHYS
argument_list|(
name|src
argument_list|)
argument_list|,
name|PAGE_SIZE
argument_list|,
name|IS_PHYSICAL
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|pmap_copy_page_generic
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|src
argument_list|)
argument_list|,
name|VM_PAGE_TO_PHYS
argument_list|(
name|dst
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * this routine returns true if a physical page resides  * in the given pmap.  */
end_comment

begin_function
name|boolean_t
name|pmap_page_exists_quick
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_page_t
name|m
parameter_list|)
block|{
name|struct
name|md_page
modifier|*
name|pvh
decl_stmt|;
name|pv_entry_t
name|pv
decl_stmt|;
name|int
name|loops
init|=
literal|0
decl_stmt|;
name|boolean_t
name|rv
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_page_exists_quick: page %p is not managed"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
name|rv
operator|=
name|FALSE
expr_stmt|;
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&m->md.pv_list
argument_list|,
argument|pv_list
argument_list|)
block|{
if|if
condition|(
name|PV_PMAP
argument_list|(
name|pv
argument_list|)
operator|==
name|pmap
condition|)
block|{
name|rv
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
name|loops
operator|++
expr_stmt|;
if|if
condition|(
name|loops
operator|>=
literal|16
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|rv
operator|&&
name|loops
operator|<
literal|16
operator|&&
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_FICTITIOUS
operator|)
operator|==
literal|0
condition|)
block|{
name|pvh
operator|=
name|pa_to_pvh
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&pvh->pv_list
argument_list|,
argument|pv_list
argument_list|)
block|{
if|if
condition|(
name|PV_PMAP
argument_list|(
name|pv
argument_list|)
operator|==
name|pmap
condition|)
block|{
name|rv
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
name|loops
operator|++
expr_stmt|;
if|if
condition|(
name|loops
operator|>=
literal|16
condition|)
break|break;
block|}
block|}
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	pmap_page_wired_mappings:  *  *	Return the number of managed mappings to the given physical page  *	that are wired.  */
end_comment

begin_function
name|int
name|pmap_page_wired_mappings
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|int
name|count
decl_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|count
operator|)
return|;
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|count
operator|=
name|pmap_pvh_wired_mappings
argument_list|(
operator|&
name|m
operator|->
name|md
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_FICTITIOUS
operator|)
operator|==
literal|0
condition|)
block|{
name|count
operator|=
name|pmap_pvh_wired_mappings
argument_list|(
name|pa_to_pvh
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	pmap_pvh_wired_mappings:  *  *	Return the updated number "count" of managed mappings that are wired.  */
end_comment

begin_function
specifier|static
name|int
name|pmap_pvh_wired_mappings
parameter_list|(
name|struct
name|md_page
modifier|*
name|pvh
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|pv_entry_t
name|pv
decl_stmt|;
name|rw_assert
argument_list|(
operator|&
name|pvh_global_lock
argument_list|,
name|RA_WLOCKED
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&pvh->pv_list
argument_list|,
argument|pv_list
argument_list|)
block|{
if|if
condition|(
operator|(
name|pv
operator|->
name|pv_flags
operator|&
name|PVF_WIRED
operator|)
operator|!=
literal|0
condition|)
name|count
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns TRUE if any of the given mappings were referenced and FALSE  * otherwise.  Both page and section mappings are supported.  */
end_comment

begin_function
specifier|static
name|boolean_t
name|pmap_is_referenced_pvh
parameter_list|(
name|struct
name|md_page
modifier|*
name|pvh
parameter_list|)
block|{
name|struct
name|l2_bucket
modifier|*
name|l2b
decl_stmt|;
name|pv_entry_t
name|pv
decl_stmt|;
name|pd_entry_t
modifier|*
name|pl1pd
decl_stmt|;
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|;
name|pmap_t
name|pmap
decl_stmt|;
name|boolean_t
name|rv
decl_stmt|;
name|rw_assert
argument_list|(
operator|&
name|pvh_global_lock
argument_list|,
name|RA_WLOCKED
argument_list|)
expr_stmt|;
name|rv
operator|=
name|FALSE
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&pvh->pv_list
argument_list|,
argument|pv_list
argument_list|)
block|{
name|pmap
operator|=
name|PV_PMAP
argument_list|(
name|pv
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|pl1pd
operator|=
operator|&
name|pmap
operator|->
name|pm_l1
operator|->
name|l1_kva
index|[
name|L1_IDX
argument_list|(
name|pv
operator|->
name|pv_va
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|pl1pd
operator|&
name|L1_TYPE_MASK
operator|)
operator|==
name|L1_S_PROTO
condition|)
name|rv
operator|=
name|L1_S_REFERENCED
argument_list|(
operator|*
name|pl1pd
argument_list|)
expr_stmt|;
else|else
block|{
name|l2b
operator|=
name|pmap_get_l2_bucket
argument_list|(
name|pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
name|ptep
operator|=
operator|&
name|l2b
operator|->
name|l2b_kva
index|[
name|l2pte_index
argument_list|(
name|pv
operator|->
name|pv_va
argument_list|)
index|]
expr_stmt|;
name|rv
operator|=
name|L2_S_REFERENCED
argument_list|(
operator|*
name|ptep
argument_list|)
expr_stmt|;
block|}
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
condition|)
break|break;
block|}
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	pmap_is_referenced:  *  *	Return whether or not the specified physical page was referenced  *	in any physical maps.  */
end_comment

begin_function
name|boolean_t
name|pmap_is_referenced
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|boolean_t
name|rv
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_is_referenced: page %p is not managed"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|rv
operator|=
name|pmap_is_referenced_pvh
argument_list|(
operator|&
name|m
operator|->
name|md
argument_list|)
operator|||
operator|(
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_FICTITIOUS
operator|)
operator|==
literal|0
operator|&&
name|pmap_is_referenced_pvh
argument_list|(
name|pa_to_pvh
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	pmap_ts_referenced:  *  *	Return the count of reference bits for a page, clearing all of them.  */
end_comment

begin_function
name|int
name|pmap_ts_referenced
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|KASSERT
argument_list|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_ts_referenced: page %p is not managed"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|pmap_clearbit
argument_list|(
name|m
argument_list|,
name|PVF_REF
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns TRUE if any of the given mappings were used to modify  * physical memory. Otherwise, returns FALSE. Both page and 1MB section  * mappings are supported.  */
end_comment

begin_function
specifier|static
name|boolean_t
name|pmap_is_modified_pvh
parameter_list|(
name|struct
name|md_page
modifier|*
name|pvh
parameter_list|)
block|{
name|pd_entry_t
modifier|*
name|pl1pd
decl_stmt|;
name|struct
name|l2_bucket
modifier|*
name|l2b
decl_stmt|;
name|pv_entry_t
name|pv
decl_stmt|;
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|;
name|pmap_t
name|pmap
decl_stmt|;
name|boolean_t
name|rv
decl_stmt|;
name|rw_assert
argument_list|(
operator|&
name|pvh_global_lock
argument_list|,
name|RA_WLOCKED
argument_list|)
expr_stmt|;
name|rv
operator|=
name|FALSE
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&pvh->pv_list
argument_list|,
argument|pv_list
argument_list|)
block|{
name|pmap
operator|=
name|PV_PMAP
argument_list|(
name|pv
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|pl1pd
operator|=
operator|&
name|pmap
operator|->
name|pm_l1
operator|->
name|l1_kva
index|[
name|L1_IDX
argument_list|(
name|pv
operator|->
name|pv_va
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|pl1pd
operator|&
name|L1_TYPE_MASK
operator|)
operator|==
name|L1_S_PROTO
condition|)
name|rv
operator|=
name|L1_S_WRITABLE
argument_list|(
operator|*
name|pl1pd
argument_list|)
expr_stmt|;
else|else
block|{
name|l2b
operator|=
name|pmap_get_l2_bucket
argument_list|(
name|pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
name|ptep
operator|=
operator|&
name|l2b
operator|->
name|l2b_kva
index|[
name|l2pte_index
argument_list|(
name|pv
operator|->
name|pv_va
argument_list|)
index|]
expr_stmt|;
name|rv
operator|=
name|L2_S_WRITABLE
argument_list|(
operator|*
name|ptep
argument_list|)
expr_stmt|;
block|}
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
condition|)
break|break;
block|}
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
name|boolean_t
name|pmap_is_modified
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|boolean_t
name|rv
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_is_modified: page %p is not managed"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * If the page is not exclusive busied, then PGA_WRITEABLE cannot be 	 * concurrently set while the object is locked.  Thus, if PGA_WRITEABLE 	 * is clear, no PTEs can have APX cleared. 	 */
name|VM_OBJECT_ASSERT_WLOCKED
argument_list|(
name|m
operator|->
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vm_page_xbusied
argument_list|(
name|m
argument_list|)
operator|&&
operator|(
name|m
operator|->
name|aflags
operator|&
name|PGA_WRITEABLE
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|rv
operator|=
name|pmap_is_modified_pvh
argument_list|(
operator|&
name|m
operator|->
name|md
argument_list|)
operator|||
operator|(
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_FICTITIOUS
operator|)
operator|==
literal|0
operator|&&
name|pmap_is_modified_pvh
argument_list|(
name|pa_to_pvh
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	Apply the given advice to the specified range of addresses within the  *	given pmap.  Depending on the advice, clear the referenced and/or  *	modified flags in each mapping.  */
end_comment

begin_function
name|void
name|pmap_advise
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|sva
parameter_list|,
name|vm_offset_t
name|eva
parameter_list|,
name|int
name|advice
parameter_list|)
block|{
name|struct
name|l2_bucket
modifier|*
name|l2b
decl_stmt|;
name|struct
name|pv_entry
modifier|*
name|pve
decl_stmt|;
name|pd_entry_t
name|l1pd
decl_stmt|;
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|,
name|opte
decl_stmt|,
name|pte
decl_stmt|;
name|vm_offset_t
name|next_bucket
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
if|if
condition|(
name|advice
operator|!=
name|MADV_DONTNEED
operator|&&
name|advice
operator|!=
name|MADV_FREE
condition|)
return|return;
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|sva
operator|<
name|eva
condition|;
name|sva
operator|=
name|next_bucket
control|)
block|{
name|next_bucket
operator|=
name|L2_NEXT_BUCKET
argument_list|(
name|sva
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_bucket
operator|<
name|sva
condition|)
name|next_bucket
operator|=
name|eva
expr_stmt|;
name|l1pd
operator|=
name|pmap
operator|->
name|pm_l1
operator|->
name|l1_kva
index|[
name|L1_IDX
argument_list|(
name|sva
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|l1pd
operator|&
name|L1_TYPE_MASK
operator|)
operator|==
name|L1_S_PROTO
condition|)
block|{
if|if
condition|(
name|pmap
operator|==
name|pmap_kernel
argument_list|()
condition|)
continue|continue;
if|if
condition|(
operator|!
name|pmap_demote_section
argument_list|(
name|pmap
argument_list|,
name|sva
argument_list|)
condition|)
block|{
comment|/* 				 * The large page mapping was destroyed. 				 */
continue|continue;
block|}
comment|/* 			 * Unless the page mappings are wired, remove the 			 * mapping to a single page so that a subsequent 			 * access may repromote. Since the underlying 			 * l2_bucket is fully populated, this removal 			 * never frees an entire l2_bucket. 			 */
name|l2b
operator|=
name|pmap_get_l2_bucket
argument_list|(
name|pmap
argument_list|,
name|sva
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|l2b
operator|!=
name|NULL
argument_list|,
operator|(
literal|"pmap_advise: no l2 bucket for "
literal|"va 0x%#x, pmap 0x%p"
operator|,
name|sva
operator|,
name|pmap
operator|)
argument_list|)
expr_stmt|;
name|ptep
operator|=
operator|&
name|l2b
operator|->
name|l2b_kva
index|[
name|l2pte_index
argument_list|(
name|sva
argument_list|)
index|]
expr_stmt|;
name|opte
operator|=
operator|*
name|ptep
expr_stmt|;
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|l2pte_pa
argument_list|(
operator|*
name|ptep
argument_list|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|m
operator|!=
name|NULL
argument_list|,
operator|(
literal|"pmap_advise: no vm_page for demoted superpage"
operator|)
argument_list|)
expr_stmt|;
name|pve
operator|=
name|pmap_find_pv
argument_list|(
operator|&
name|m
operator|->
name|md
argument_list|,
name|pmap
argument_list|,
name|sva
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pve
operator|!=
name|NULL
argument_list|,
operator|(
literal|"pmap_advise: no PV entry for managed mapping"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pve
operator|->
name|pv_flags
operator|&
name|PVF_WIRED
operator|)
operator|==
literal|0
condition|)
block|{
name|pmap_free_l2_bucket
argument_list|(
name|pmap
argument_list|,
name|l2b
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pve
operator|=
name|pmap_remove_pv
argument_list|(
name|m
argument_list|,
name|pmap
argument_list|,
name|sva
argument_list|)
expr_stmt|;
name|pmap_free_pv_entry
argument_list|(
name|pmap
argument_list|,
name|pve
argument_list|)
expr_stmt|;
operator|*
name|ptep
operator|=
literal|0
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|ptep
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap_is_current
argument_list|(
name|pmap
argument_list|)
condition|)
block|{
if|if
condition|(
name|PTE_BEEN_EXECD
argument_list|(
name|opte
argument_list|)
condition|)
name|cpu_tlb_flushID_SE
argument_list|(
name|sva
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|PTE_BEEN_REFD
argument_list|(
name|opte
argument_list|)
condition|)
name|cpu_tlb_flushD_SE
argument_list|(
name|sva
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|next_bucket
operator|>
name|eva
condition|)
name|next_bucket
operator|=
name|eva
expr_stmt|;
name|l2b
operator|=
name|pmap_get_l2_bucket
argument_list|(
name|pmap
argument_list|,
name|sva
argument_list|)
expr_stmt|;
if|if
condition|(
name|l2b
operator|==
name|NULL
condition|)
continue|continue;
for|for
control|(
name|ptep
operator|=
operator|&
name|l2b
operator|->
name|l2b_kva
index|[
name|l2pte_index
argument_list|(
name|sva
argument_list|)
index|]
init|;
name|sva
operator|!=
name|next_bucket
condition|;
name|ptep
operator|++
operator|,
name|sva
operator|+=
name|PAGE_SIZE
control|)
block|{
name|opte
operator|=
name|pte
operator|=
operator|*
name|ptep
expr_stmt|;
if|if
condition|(
operator|(
name|opte
operator|&
name|L2_S_PROTO
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|l2pte_pa
argument_list|(
name|opte
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
operator|||
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|!=
literal|0
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|L2_S_WRITABLE
argument_list|(
name|opte
argument_list|)
condition|)
block|{
if|if
condition|(
name|advice
operator|==
name|MADV_DONTNEED
condition|)
block|{
comment|/* 					 * Don't need to mark the page 					 * dirty as it was already marked as 					 * such in pmap_fault_fixup() or 					 * pmap_enter_locked(). 					 * Just clear the state. 					 */
block|}
else|else
name|pte
operator||=
name|L2_APX
expr_stmt|;
name|pte
operator|&=
operator|~
name|L2_S_REF
expr_stmt|;
operator|*
name|ptep
operator|=
name|pte
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|ptep
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|L2_S_REFERENCED
argument_list|(
name|opte
argument_list|)
condition|)
block|{
name|pte
operator|&=
operator|~
name|L2_S_REF
expr_stmt|;
operator|*
name|ptep
operator|=
name|pte
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|ptep
argument_list|)
expr_stmt|;
block|}
else|else
continue|continue;
if|if
condition|(
name|pmap_is_current
argument_list|(
name|pmap
argument_list|)
condition|)
block|{
if|if
condition|(
name|PTE_BEEN_EXECD
argument_list|(
name|opte
argument_list|)
condition|)
name|cpu_tlb_flushID_SE
argument_list|(
name|sva
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|PTE_BEEN_REFD
argument_list|(
name|opte
argument_list|)
condition|)
name|cpu_tlb_flushD_SE
argument_list|(
name|sva
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|cpu_cpwait
argument_list|()
expr_stmt|;
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Clear the modify bits on the specified physical page.  */
end_comment

begin_function
name|void
name|pmap_clear_modify
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|KASSERT
argument_list|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_clear_modify: page %p is not managed"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
name|VM_OBJECT_ASSERT_WLOCKED
argument_list|(
name|m
operator|->
name|object
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|!
name|vm_page_xbusied
argument_list|(
name|m
argument_list|)
argument_list|,
operator|(
literal|"pmap_clear_modify: page %p is exclusive busied"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * If the page is not PGA_WRITEABLE, then no mappings can be modified. 	 * If the object containing the page is locked and the page is not 	 * exclusive busied, then PGA_WRITEABLE cannot be concurrently set. 	 */
if|if
condition|(
operator|(
name|m
operator|->
name|aflags
operator|&
name|PGA_WRITEABLE
operator|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|pmap_is_modified
argument_list|(
name|m
argument_list|)
condition|)
name|pmap_clearbit
argument_list|(
name|m
argument_list|,
name|PVF_MOD
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Clear the write and modified bits in each of the given page's mappings.  */
end_comment

begin_function
name|void
name|pmap_remove_write
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|KASSERT
argument_list|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_remove_write: page %p is not managed"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * If the page is not exclusive busied, then PGA_WRITEABLE cannot be 	 * set by another thread while the object is locked.  Thus, 	 * if PGA_WRITEABLE is clear, no page table entries need updating. 	 */
name|VM_OBJECT_ASSERT_WLOCKED
argument_list|(
name|m
operator|->
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
name|vm_page_xbusied
argument_list|(
name|m
argument_list|)
operator|||
operator|(
name|m
operator|->
name|aflags
operator|&
name|PGA_WRITEABLE
operator|)
operator|!=
literal|0
condition|)
name|pmap_clearbit
argument_list|(
name|m
argument_list|,
name|PVF_WRITE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * perform the pmap work for mincore  */
end_comment

begin_function
name|int
name|pmap_mincore
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|addr
parameter_list|,
name|vm_paddr_t
modifier|*
name|locked_pa
parameter_list|)
block|{
name|struct
name|l2_bucket
modifier|*
name|l2b
decl_stmt|;
name|pd_entry_t
modifier|*
name|pl1pd
decl_stmt|,
name|l1pd
decl_stmt|;
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|,
name|pte
decl_stmt|;
name|vm_paddr_t
name|pa
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|int
name|val
decl_stmt|;
name|boolean_t
name|managed
decl_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|retry
label|:
name|pl1pd
operator|=
operator|&
name|pmap
operator|->
name|pm_l1
operator|->
name|l1_kva
index|[
name|L1_IDX
argument_list|(
name|addr
argument_list|)
index|]
expr_stmt|;
name|l1pd
operator|=
operator|*
name|pl1pd
expr_stmt|;
if|if
condition|(
operator|(
name|l1pd
operator|&
name|L1_TYPE_MASK
operator|)
operator|==
name|L1_S_PROTO
condition|)
block|{
name|pa
operator|=
operator|(
name|l1pd
operator|&
name|L1_S_FRAME
operator|)
expr_stmt|;
name|val
operator|=
name|MINCORE_SUPER
operator||
name|MINCORE_INCORE
expr_stmt|;
if|if
condition|(
name|L1_S_WRITABLE
argument_list|(
name|l1pd
argument_list|)
condition|)
name|val
operator||=
name|MINCORE_MODIFIED
operator||
name|MINCORE_MODIFIED_OTHER
expr_stmt|;
name|managed
operator|=
name|FALSE
expr_stmt|;
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pa
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
operator|&&
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|==
literal|0
condition|)
name|managed
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|managed
condition|)
block|{
if|if
condition|(
name|L1_S_REFERENCED
argument_list|(
name|l1pd
argument_list|)
condition|)
name|val
operator||=
name|MINCORE_REFERENCED
operator||
name|MINCORE_REFERENCED_OTHER
expr_stmt|;
block|}
block|}
else|else
block|{
name|l2b
operator|=
name|pmap_get_l2_bucket
argument_list|(
name|pmap
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|l2b
operator|==
name|NULL
condition|)
block|{
name|val
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ptep
operator|=
operator|&
name|l2b
operator|->
name|l2b_kva
index|[
name|l2pte_index
argument_list|(
name|addr
argument_list|)
index|]
expr_stmt|;
name|pte
operator|=
operator|*
name|ptep
expr_stmt|;
if|if
condition|(
operator|!
name|l2pte_valid
argument_list|(
name|pte
argument_list|)
condition|)
block|{
name|val
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|val
operator|=
name|MINCORE_INCORE
expr_stmt|;
if|if
condition|(
name|L2_S_WRITABLE
argument_list|(
name|pte
argument_list|)
condition|)
name|val
operator||=
name|MINCORE_MODIFIED
operator||
name|MINCORE_MODIFIED_OTHER
expr_stmt|;
name|managed
operator|=
name|FALSE
expr_stmt|;
name|pa
operator|=
name|l2pte_pa
argument_list|(
name|pte
argument_list|)
expr_stmt|;
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pa
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
operator|&&
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|==
literal|0
condition|)
name|managed
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|managed
condition|)
block|{
if|if
condition|(
name|L2_S_REFERENCED
argument_list|(
name|pte
argument_list|)
condition|)
name|val
operator||=
name|MINCORE_REFERENCED
operator||
name|MINCORE_REFERENCED_OTHER
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|val
operator|&
operator|(
name|MINCORE_MODIFIED_OTHER
operator||
name|MINCORE_REFERENCED_OTHER
operator|)
operator|)
operator|!=
operator|(
name|MINCORE_MODIFIED_OTHER
operator||
name|MINCORE_REFERENCED_OTHER
operator|)
operator|&&
name|managed
condition|)
block|{
comment|/* Ensure that "PHYS_TO_VM_PAGE(pa)->object" doesn't change. */
if|if
condition|(
name|vm_page_pa_tryrelock
argument_list|(
name|pmap
argument_list|,
name|pa
argument_list|,
name|locked_pa
argument_list|)
condition|)
goto|goto
name|retry
goto|;
block|}
else|else
name|out
label|:
name|PA_UNLOCK_COND
argument_list|(
operator|*
name|locked_pa
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pmap_sync_icache
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_size_t
name|sz
parameter_list|)
block|{ }
end_function

begin_comment
comment|/*  *	Increase the starting virtual address of the given mapping if a  *	different alignment might result in more superpage mappings.  */
end_comment

begin_function
name|void
name|pmap_align_superpage
parameter_list|(
name|vm_object_t
name|object
parameter_list|,
name|vm_ooffset_t
name|offset
parameter_list|,
name|vm_offset_t
modifier|*
name|addr
parameter_list|,
name|vm_size_t
name|size
parameter_list|)
block|{
name|vm_offset_t
name|superpage_offset
decl_stmt|;
if|if
condition|(
name|size
operator|<
name|NBPDR
condition|)
return|return;
if|if
condition|(
name|object
operator|!=
name|NULL
operator|&&
operator|(
name|object
operator|->
name|flags
operator|&
name|OBJ_COLORED
operator|)
operator|!=
literal|0
condition|)
name|offset
operator|+=
name|ptoa
argument_list|(
name|object
operator|->
name|pg_color
argument_list|)
expr_stmt|;
name|superpage_offset
operator|=
name|offset
operator|&
name|PDRMASK
expr_stmt|;
if|if
condition|(
name|size
operator|-
operator|(
operator|(
name|NBPDR
operator|-
name|superpage_offset
operator|)
operator|&
name|PDRMASK
operator|)
operator|<
name|NBPDR
operator|||
operator|(
operator|*
name|addr
operator|&
name|PDRMASK
operator|)
operator|==
name|superpage_offset
condition|)
return|return;
if|if
condition|(
operator|(
operator|*
name|addr
operator|&
name|PDRMASK
operator|)
operator|<
name|superpage_offset
condition|)
operator|*
name|addr
operator|=
operator|(
operator|*
name|addr
operator|&
operator|~
name|PDRMASK
operator|)
operator|+
name|superpage_offset
expr_stmt|;
else|else
operator|*
name|addr
operator|=
operator|(
operator|(
operator|*
name|addr
operator|+
name|PDRMASK
operator|)
operator|&
operator|~
name|PDRMASK
operator|)
operator|+
name|superpage_offset
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * pmap_map_section:  *  *	Create a single section mapping.  */
end_comment

begin_function
name|void
name|pmap_map_section
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_offset_t
name|pa
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|,
name|boolean_t
name|ref
parameter_list|)
block|{
name|pd_entry_t
modifier|*
name|pl1pd
decl_stmt|,
name|l1pd
decl_stmt|;
name|pd_entry_t
name|fl
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
operator|(
name|va
operator||
name|pa
operator|)
operator|&
name|L1_S_OFFSET
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"Not a valid section mapping"
operator|)
argument_list|)
expr_stmt|;
name|fl
operator|=
name|pte_l1_s_cache_mode
expr_stmt|;
name|pl1pd
operator|=
operator|&
name|pmap
operator|->
name|pm_l1
operator|->
name|l1_kva
index|[
name|L1_IDX
argument_list|(
name|va
argument_list|)
index|]
expr_stmt|;
name|l1pd
operator|=
name|L1_S_PROTO
operator||
name|pa
operator||
name|L1_S_PROT
argument_list|(
name|PTE_USER
argument_list|,
name|prot
argument_list|)
operator||
name|fl
operator||
name|L1_S_DOM
argument_list|(
name|pmap
operator|->
name|pm_domain
argument_list|)
expr_stmt|;
comment|/* Mark page referenced if this section is a result of a promotion. */
if|if
condition|(
name|ref
operator|==
name|TRUE
condition|)
name|l1pd
operator||=
name|L1_S_REF
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
name|l1pd
operator||=
name|L1_SHARED
expr_stmt|;
endif|#
directive|endif
operator|*
name|pl1pd
operator|=
name|l1pd
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|pl1pd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * pmap_link_l2pt:  *  *	Link the L2 page table specified by l2pv.pv_pa into the L1  *	page table at the slot for "va".  */
end_comment

begin_function
name|void
name|pmap_link_l2pt
parameter_list|(
name|vm_offset_t
name|l1pt
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|struct
name|pv_addr
modifier|*
name|l2pv
parameter_list|)
block|{
name|pd_entry_t
modifier|*
name|pde
init|=
operator|(
name|pd_entry_t
operator|*
operator|)
name|l1pt
decl_stmt|,
name|proto
decl_stmt|;
name|u_int
name|slot
init|=
name|va
operator|>>
name|L1_S_SHIFT
decl_stmt|;
name|proto
operator|=
name|L1_S_DOM
argument_list|(
name|PMAP_DOMAIN_KERNEL
argument_list|)
operator||
name|L1_C_PROTO
expr_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE_INIT_ARM
name|printf
argument_list|(
literal|"pmap_link_l2pt: pa=0x%x va=0x%x\n"
argument_list|,
name|l2pv
operator|->
name|pv_pa
argument_list|,
name|l2pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pde
index|[
name|slot
operator|+
literal|0
index|]
operator|=
name|proto
operator||
operator|(
name|l2pv
operator|->
name|pv_pa
operator|+
literal|0x000
operator|)
expr_stmt|;
name|PTE_SYNC
argument_list|(
operator|&
name|pde
index|[
name|slot
index|]
argument_list|)
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|kernel_pt_list
argument_list|,
name|l2pv
argument_list|,
name|pv_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * pmap_map_entry  *  *	Create a single page mapping.  */
end_comment

begin_function
name|void
name|pmap_map_entry
parameter_list|(
name|vm_offset_t
name|l1pt
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_offset_t
name|pa
parameter_list|,
name|int
name|prot
parameter_list|,
name|int
name|cache
parameter_list|)
block|{
name|pd_entry_t
modifier|*
name|pde
init|=
operator|(
name|pd_entry_t
operator|*
operator|)
name|l1pt
decl_stmt|;
name|pt_entry_t
name|fl
decl_stmt|;
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
operator|(
name|va
operator||
name|pa
operator|)
operator|&
name|PAGE_MASK
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"ouin"
operator|)
argument_list|)
expr_stmt|;
name|fl
operator|=
name|l2s_mem_types
index|[
name|cache
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|pde
index|[
name|va
operator|>>
name|L1_S_SHIFT
index|]
operator|&
name|L1_TYPE_MASK
operator|)
operator|!=
name|L1_TYPE_C
condition|)
name|panic
argument_list|(
literal|"pmap_map_entry: no L2 table for VA 0x%08x"
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|ptep
operator|=
operator|(
name|pt_entry_t
operator|*
operator|)
name|kernel_pt_lookup
argument_list|(
name|pde
index|[
name|L1_IDX
argument_list|(
name|va
argument_list|)
index|]
operator|&
name|L1_C_ADDR_MASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptep
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"pmap_map_entry: can't find L2 table for VA 0x%08x"
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|ptep
index|[
name|l2pte_index
argument_list|(
name|va
argument_list|)
index|]
operator|=
name|L2_S_PROTO
operator||
name|pa
operator||
name|fl
operator||
name|L2_S_REF
expr_stmt|;
name|pmap_set_prot
argument_list|(
operator|&
name|ptep
index|[
name|l2pte_index
argument_list|(
name|va
argument_list|)
index|]
argument_list|,
name|prot
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PTE_SYNC
argument_list|(
operator|&
name|ptep
index|[
name|l2pte_index
argument_list|(
name|va
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * pmap_map_chunk:  *  *	Map a chunk of memory using the most efficient mappings  *	possible (section. large page, small page) into the  *	provided L1 and L2 tables at the specified virtual address.  */
end_comment

begin_function
name|vm_size_t
name|pmap_map_chunk
parameter_list|(
name|vm_offset_t
name|l1pt
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_offset_t
name|pa
parameter_list|,
name|vm_size_t
name|size
parameter_list|,
name|int
name|prot
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|pd_entry_t
modifier|*
name|pde
init|=
operator|(
name|pd_entry_t
operator|*
operator|)
name|l1pt
decl_stmt|;
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|,
name|f1
decl_stmt|,
name|f2s
decl_stmt|,
name|f2l
decl_stmt|;
name|vm_size_t
name|resid
decl_stmt|;
name|int
name|i
decl_stmt|;
name|resid
operator|=
operator|(
name|size
operator|+
operator|(
name|PAGE_SIZE
operator|-
literal|1
operator|)
operator|)
operator|&
operator|~
operator|(
name|PAGE_SIZE
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|l1pt
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"pmap_map_chunk: no L1 table provided"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE_INIT_ARM
name|printf
argument_list|(
literal|"pmap_map_chunk: pa=0x%x va=0x%x size=0x%x resid=0x%x "
literal|"prot=0x%x type=%d\n"
argument_list|,
name|pa
argument_list|,
name|va
argument_list|,
name|size
argument_list|,
name|resid
argument_list|,
name|prot
argument_list|,
name|type
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|f1
operator|=
name|l1_mem_types
index|[
name|type
index|]
expr_stmt|;
name|f2l
operator|=
name|l2l_mem_types
index|[
name|type
index|]
expr_stmt|;
name|f2s
operator|=
name|l2s_mem_types
index|[
name|type
index|]
expr_stmt|;
name|size
operator|=
name|resid
expr_stmt|;
while|while
condition|(
name|resid
operator|>
literal|0
condition|)
block|{
comment|/* See if we can use a section mapping. */
if|if
condition|(
name|L1_S_MAPPABLE_P
argument_list|(
name|va
argument_list|,
name|pa
argument_list|,
name|resid
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|VERBOSE_INIT_ARM
name|printf
argument_list|(
literal|"S"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pde
index|[
name|va
operator|>>
name|L1_S_SHIFT
index|]
operator|=
name|L1_S_PROTO
operator||
name|pa
operator||
name|L1_S_PROT
argument_list|(
name|PTE_KERNEL
argument_list|,
name|prot
operator||
name|VM_PROT_EXECUTE
argument_list|)
operator||
name|f1
operator||
name|L1_S_DOM
argument_list|(
name|PMAP_DOMAIN_KERNEL
argument_list|)
operator||
name|L1_S_REF
expr_stmt|;
name|PTE_SYNC
argument_list|(
operator|&
name|pde
index|[
name|va
operator|>>
name|L1_S_SHIFT
index|]
argument_list|)
expr_stmt|;
name|va
operator|+=
name|L1_S_SIZE
expr_stmt|;
name|pa
operator|+=
name|L1_S_SIZE
expr_stmt|;
name|resid
operator|-=
name|L1_S_SIZE
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Ok, we're going to use an L2 table.  Make sure 		 * one is actually in the corresponding L1 slot 		 * for the current VA. 		 */
if|if
condition|(
operator|(
name|pde
index|[
name|va
operator|>>
name|L1_S_SHIFT
index|]
operator|&
name|L1_TYPE_MASK
operator|)
operator|!=
name|L1_TYPE_C
condition|)
name|panic
argument_list|(
literal|"pmap_map_chunk: no L2 table for VA 0x%08x"
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|ptep
operator|=
operator|(
name|pt_entry_t
operator|*
operator|)
name|kernel_pt_lookup
argument_list|(
name|pde
index|[
name|L1_IDX
argument_list|(
name|va
argument_list|)
index|]
operator|&
name|L1_C_ADDR_MASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptep
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"pmap_map_chunk: can't find L2 table for VA"
literal|"0x%08x"
argument_list|,
name|va
argument_list|)
expr_stmt|;
comment|/* See if we can use a L2 large page mapping. */
if|if
condition|(
name|L2_L_MAPPABLE_P
argument_list|(
name|va
argument_list|,
name|pa
argument_list|,
name|resid
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|VERBOSE_INIT_ARM
name|printf
argument_list|(
literal|"L"
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|ptep
index|[
name|l2pte_index
argument_list|(
name|va
argument_list|)
operator|+
name|i
index|]
operator|=
name|L2_L_PROTO
operator||
name|pa
operator||
name|L2_L_PROT
argument_list|(
name|PTE_KERNEL
argument_list|,
name|prot
argument_list|)
operator||
name|f2l
expr_stmt|;
name|PTE_SYNC
argument_list|(
operator|&
name|ptep
index|[
name|l2pte_index
argument_list|(
name|va
argument_list|)
operator|+
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|va
operator|+=
name|L2_L_SIZE
expr_stmt|;
name|pa
operator|+=
name|L2_L_SIZE
expr_stmt|;
name|resid
operator|-=
name|L2_L_SIZE
expr_stmt|;
continue|continue;
block|}
comment|/* Use a small page mapping. */
ifdef|#
directive|ifdef
name|VERBOSE_INIT_ARM
name|printf
argument_list|(
literal|"P"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ptep
index|[
name|l2pte_index
argument_list|(
name|va
argument_list|)
index|]
operator|=
name|L2_S_PROTO
operator||
name|pa
operator||
name|f2s
operator||
name|L2_S_REF
expr_stmt|;
name|pmap_set_prot
argument_list|(
operator|&
name|ptep
index|[
name|l2pte_index
argument_list|(
name|va
argument_list|)
index|]
argument_list|,
name|prot
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PTE_SYNC
argument_list|(
operator|&
name|ptep
index|[
name|l2pte_index
argument_list|(
name|va
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|va
operator|+=
name|PAGE_SIZE
expr_stmt|;
name|pa
operator|+=
name|PAGE_SIZE
expr_stmt|;
name|resid
operator|-=
name|PAGE_SIZE
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|VERBOSE_INIT_ARM
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|size
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pmap_dmap_iscurrent
parameter_list|(
name|pmap_t
name|pmap
parameter_list|)
block|{
return|return
operator|(
name|pmap_is_current
argument_list|(
name|pmap
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pmap_page_set_memattr
parameter_list|(
name|vm_page_t
name|m
parameter_list|,
name|vm_memattr_t
name|ma
parameter_list|)
block|{
comment|/*  	 * Remember the memattr in a field that gets used to set the appropriate 	 * bits in the PTEs as mappings are established. 	 */
name|m
operator|->
name|md
operator|.
name|pv_memattr
operator|=
name|ma
expr_stmt|;
comment|/* 	 * It appears that this function can only be called before any mappings 	 * for the page are established on ARM.  If this ever changes, this code 	 * will need to walk the pv_list and make each of the existing mappings 	 * uncacheable, being careful to sync caches and PTEs (and maybe 	 * invalidate TLB?) for any current mapping it modifies. 	 */
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|)
operator|!=
name|NULL
condition|)
name|panic
argument_list|(
literal|"Can't change memattr on page with existing mappings"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

