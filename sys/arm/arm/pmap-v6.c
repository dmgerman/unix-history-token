begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* From: $NetBSD: pmap.c,v 1.148 2004/04/03 04:35:48 bsh Exp $ */
end_comment

begin_comment
comment|/*-  * Copyright 2011 Semihalf  * Copyright 2004 Olivier Houchard.  * Copyright 2003 Wasabi Systems, Inc.  * All rights reserved.  *  * Written by Steve C. Woodford for Wasabi Systems, Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *      This product includes software developed for the NetBSD Project by  *      Wasabi Systems, Inc.  * 4. The name of Wasabi Systems, Inc. may not be used to endorse  *    or promote products derived from this software without specific prior  *    written permission.  *  * THIS SOFTWARE IS PROVIDED BY WASABI SYSTEMS, INC. ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL WASABI SYSTEMS, INC  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  *  * From: FreeBSD: src/sys/arm/arm/pmap.c,v 1.113 2009/07/24 13:50:29  */
end_comment

begin_comment
comment|/*-  * Copyright (c) 2002-2003 Wasabi Systems, Inc.  * Copyright (c) 2001 Richard Earnshaw  * Copyright (c) 2001-2002 Christopher Gilbert  * All rights reserved.  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the company nor the name of the author may be used to  *    endorse or promote products derived from this software without specific  *    prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*-  * Copyright (c) 1999 The NetBSD Foundation, Inc.  * All rights reserved.  *  * This code is derived from software contributed to The NetBSD Foundation  * by Charles M. Hannum.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*-  * Copyright (c) 1994-1998 Mark Brinicombe.  * Copyright (c) 1994 Brini.  * All rights reserved.  *  * This code is derived from software written for Brini by Mark Brinicombe  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *      This product includes software developed by Mark Brinicombe.  * 4. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  *  * RiscBSD kernel project  *  * pmap.c  *  * Machine dependant vm stuff  *  * Created      : 20/09/94  */
end_comment

begin_comment
comment|/*  * Special compilation symbols  * PMAP_DEBUG           - Build in pmap_debug_level code  */
end_comment

begin_comment
comment|/* Include header files */
end_comment

begin_include
include|#
directive|include
file|"opt_vm.h"
end_include

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/msgbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmmeter.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/rwlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/sched.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pageout.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpufunc.h>
end_include

begin_include
include|#
directive|include
file|<machine/pcb.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|last_fault_code
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|PMAP_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|PDEBUG
parameter_list|(
name|_lev_
parameter_list|,
name|_stat_
parameter_list|)
define|\
value|if (pmap_debug_level>= (_lev_)) \                 ((_stat_))
end_define

begin_define
define|#
directive|define
name|dprintf
value|printf
end_define

begin_decl_stmt
name|int
name|pmap_debug_level
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|PMAP_INLINE
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* PMAP_DEBUG */
end_comment

begin_define
define|#
directive|define
name|PDEBUG
parameter_list|(
name|_lev_
parameter_list|,
name|_stat_
parameter_list|)
end_define

begin_comment
comment|/* Nothing */
end_comment

begin_define
define|#
directive|define
name|dprintf
parameter_list|(
name|x
parameter_list|,
name|arg
modifier|...
parameter_list|)
end_define

begin_define
define|#
directive|define
name|PMAP_INLINE
value|__inline
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PMAP_DEBUG */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|pv_addr
name|systempage
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Internal function prototypes  */
end_comment

begin_function_decl
specifier|static
name|void
name|pmap_free_pv_entry
parameter_list|(
name|pv_entry_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|pv_entry_t
name|pmap_get_pv_entry
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmap_enter_locked
parameter_list|(
name|pmap_t
parameter_list|,
name|vm_offset_t
parameter_list|,
name|vm_page_t
parameter_list|,
name|vm_prot_t
parameter_list|,
name|boolean_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmap_alloc_l1
parameter_list|(
name|pmap_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmap_free_l1
parameter_list|(
name|pmap_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pmap_clearbit
parameter_list|(
name|struct
name|vm_page
modifier|*
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|l2_bucket
modifier|*
name|pmap_get_l2_bucket
parameter_list|(
name|pmap_t
parameter_list|,
name|vm_offset_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|l2_bucket
modifier|*
name|pmap_alloc_l2_bucket
parameter_list|(
name|pmap_t
parameter_list|,
name|vm_offset_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmap_free_l2_bucket
parameter_list|(
name|pmap_t
parameter_list|,
name|struct
name|l2_bucket
modifier|*
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|vm_offset_t
name|kernel_pt_lookup
parameter_list|(
name|vm_paddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_VMPMAP
argument_list|,
literal|"pmap"
argument_list|,
literal|"PMAP L1"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|vm_offset_t
name|virtual_avail
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* VA of first avail page (after kernel bss) */
end_comment

begin_decl_stmt
name|vm_offset_t
name|virtual_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* VA of last avail page (end of kernel AS) */
end_comment

begin_decl_stmt
name|vm_offset_t
name|pmap_curmaxkvaddr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_paddr_t
name|kernel_l1pa
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
modifier|*
name|end
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_offset_t
name|kernel_vm_end
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pmap
name|kernel_pmap_store
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|pt_entry_t
modifier|*
name|csrc_pte
decl_stmt|,
modifier|*
name|cdst_pte
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vm_offset_t
name|csrcp
decl_stmt|,
name|cdstp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|cmtx
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|pmap_init_l1
parameter_list|(
name|struct
name|l1_ttable
modifier|*
parameter_list|,
name|pd_entry_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * These routines are called when the CPU type is identified to set up  * the PTE prototypes, cache modes, etc.  *  * The variables are always here, just in case LKMs need to reference  * them (though, they shouldn't).  */
end_comment

begin_function_decl
specifier|static
name|void
name|pmap_set_prot
parameter_list|(
name|pt_entry_t
modifier|*
name|pte
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|,
name|uint8_t
name|user
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|pt_entry_t
name|pte_l1_s_cache_mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|pt_entry_t
name|pte_l1_s_cache_mode_pt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|pt_entry_t
name|pte_l2_l_cache_mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|pt_entry_t
name|pte_l2_l_cache_mode_pt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|pt_entry_t
name|pte_l2_s_cache_mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|pt_entry_t
name|pte_l2_s_cache_mode_pt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Which pmap is currently 'live' in the cache  *  * XXXSCW: Fix for SMP ...  */
end_comment

begin_decl_stmt
name|union
name|pmap_cache_state
modifier|*
name|pmap_cache_state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|msgbuf
modifier|*
name|msgbufp
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Crashdump maps.  */
end_comment

begin_decl_stmt
specifier|static
name|caddr_t
name|crashdumpmap
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|void
name|bcopy_page
parameter_list|(
name|vm_offset_t
parameter_list|,
name|vm_offset_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|bzero_page
parameter_list|(
name|vm_offset_t
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|vm_offset_t
name|alloc_firstaddr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|_tmppt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Metadata for L1 translation tables.  */
end_comment

begin_struct
struct|struct
name|l1_ttable
block|{
comment|/* Entry on the L1 Table list */
name|SLIST_ENTRY
argument_list|(
argument|l1_ttable
argument_list|)
name|l1_link
expr_stmt|;
comment|/* Entry on the L1 Least Recently Used list */
name|TAILQ_ENTRY
argument_list|(
argument|l1_ttable
argument_list|)
name|l1_lru
expr_stmt|;
comment|/* Track how many domains are allocated from this L1 */
specifier|volatile
name|u_int
name|l1_domain_use_count
decl_stmt|;
comment|/* 	 * A free-list of domain numbers for this L1. 	 * We avoid using ffs() and a bitmap to track domains since ffs() 	 * is slow on ARM. 	 */
name|u_int8_t
name|l1_domain_first
decl_stmt|;
name|u_int8_t
name|l1_domain_free
index|[
name|PMAP_DOMAINS
index|]
decl_stmt|;
comment|/* Physical address of this L1 page table */
name|vm_paddr_t
name|l1_physaddr
decl_stmt|;
comment|/* KVA of this L1 page table */
name|pd_entry_t
modifier|*
name|l1_kva
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Convert a virtual address into its L1 table index. That is, the  * index used to locate the L2 descriptor table pointer in an L1 table.  * This is basically used to index l1->l1_kva[].  *  * Each L2 descriptor table represents 1MB of VA space.  */
end_comment

begin_define
define|#
directive|define
name|L1_IDX
parameter_list|(
name|va
parameter_list|)
value|(((vm_offset_t)(va))>> L1_S_SHIFT)
end_define

begin_comment
comment|/*  * L1 Page Tables are tracked using a Least Recently Used list.  *  - New L1s are allocated from the HEAD.  *  - Freed L1s are added to the TAIl.  *  - Recently accessed L1s (where an 'access' is some change to one of  *    the userland pmaps which owns this L1) are moved to the TAIL.  */
end_comment

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|l1_ttable
argument_list|)
name|l1_lru_list
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * A list of all L1 tables  */
end_comment

begin_expr_stmt
specifier|static
name|SLIST_HEAD
argument_list|(
argument_list|,
argument|l1_ttable
argument_list|)
name|l1_list
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|l1_lru_lock
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The l2_dtable tracks L2_BUCKET_SIZE worth of L1 slots.  *  * This is normally 16MB worth L2 page descriptors for any given pmap.  * Reference counts are maintained for L2 descriptors so they can be  * freed when empty.  */
end_comment

begin_struct
struct|struct
name|l2_dtable
block|{
comment|/* The number of L2 page descriptors allocated to this l2_dtable */
name|u_int
name|l2_occupancy
decl_stmt|;
comment|/* List of L2 page descriptors */
struct|struct
name|l2_bucket
block|{
name|pt_entry_t
modifier|*
name|l2b_kva
decl_stmt|;
comment|/* KVA of L2 Descriptor Table */
name|vm_paddr_t
name|l2b_phys
decl_stmt|;
comment|/* Physical address of same */
name|u_short
name|l2b_l1idx
decl_stmt|;
comment|/* This L2 table's L1 index */
name|u_short
name|l2b_occupancy
decl_stmt|;
comment|/* How many active descriptors */
block|}
name|l2_bucket
index|[
name|L2_BUCKET_SIZE
index|]
struct|;
block|}
struct|;
end_struct

begin_comment
comment|/* pmap_kenter_internal flags */
end_comment

begin_define
define|#
directive|define
name|KENTER_CACHE
value|0x1
end_define

begin_define
define|#
directive|define
name|KENTER_USER
value|0x2
end_define

begin_comment
comment|/*  * Given an L1 table index, calculate the corresponding l2_dtable index  * and bucket index within the l2_dtable.  */
end_comment

begin_define
define|#
directive|define
name|L2_IDX
parameter_list|(
name|l1idx
parameter_list|)
value|(((l1idx)>> L2_BUCKET_LOG2)& \ 				 (L2_SIZE - 1))
end_define

begin_define
define|#
directive|define
name|L2_BUCKET
parameter_list|(
name|l1idx
parameter_list|)
value|((l1idx)& (L2_BUCKET_SIZE - 1))
end_define

begin_comment
comment|/*  * Given a virtual address, this macro returns the  * virtual address required to drop into the next L2 bucket.  */
end_comment

begin_define
define|#
directive|define
name|L2_NEXT_BUCKET
parameter_list|(
name|va
parameter_list|)
value|(((va)& L1_S_FRAME) + L1_S_SIZE)
end_define

begin_comment
comment|/*  * We try to map the page tables write-through, if possible.  However, not  * all CPUs have a write-through cache mode, so on those we have to sync  * the cache when we frob page tables.  *  * We try to evaluate this at compile time, if possible.  However, it's  * not always possible to do that, hence this run-time var.  */
end_comment

begin_decl_stmt
name|int
name|pmap_needs_pte_sync
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Macro to determine if a mapping might be resident in the  * instruction cache and/or TLB  */
end_comment

begin_define
define|#
directive|define
name|PV_BEEN_EXECD
parameter_list|(
name|f
parameter_list|)
value|(((f)& (PVF_REF | PVF_EXEC)) == (PVF_REF | PVF_EXEC))
end_define

begin_comment
comment|/*  * Macro to determine if a mapping might be resident in the  * data cache and/or TLB  */
end_comment

begin_define
define|#
directive|define
name|PV_BEEN_REFD
parameter_list|(
name|f
parameter_list|)
value|(((f)& PVF_REF) != 0)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|PMAP_SHPGPERPROC
end_ifndef

begin_define
define|#
directive|define
name|PMAP_SHPGPERPROC
value|200
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|pmap_is_current
parameter_list|(
name|pm
parameter_list|)
value|((pm) == pmap_kernel() || \             curproc->p_vmspace->vm_map.pmap == (pm))
end_define

begin_decl_stmt
specifier|static
name|uma_zone_t
name|pvzone
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uma_zone_t
name|l2zone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uma_zone_t
name|l2table_zone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vm_offset_t
name|pmap_kernel_l2dtable_kva
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vm_offset_t
name|pmap_kernel_l2ptp_kva
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vm_paddr_t
name|pmap_kernel_l2ptp_phys
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|vm_object
name|pvzone_obj
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pv_entry_count
init|=
literal|0
decl_stmt|,
name|pv_entry_max
init|=
literal|0
decl_stmt|,
name|pv_entry_high_water
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|rwlock
name|pvh_global_lock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|l1_mem_types
index|[]
init|=
block|{
name|ARM_L1S_STRONG_ORD
block|,
name|ARM_L1S_DEVICE_NOSHARE
block|,
name|ARM_L1S_DEVICE_SHARE
block|,
name|ARM_L1S_NRML_NOCACHE
block|,
name|ARM_L1S_NRML_IWT_OWT
block|,
name|ARM_L1S_NRML_IWB_OWB
block|,
name|ARM_L1S_NRML_IWBA_OWBA
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|l2l_mem_types
index|[]
init|=
block|{
name|ARM_L2L_STRONG_ORD
block|,
name|ARM_L2L_DEVICE_NOSHARE
block|,
name|ARM_L2L_DEVICE_SHARE
block|,
name|ARM_L2L_NRML_NOCACHE
block|,
name|ARM_L2L_NRML_IWT_OWT
block|,
name|ARM_L2L_NRML_IWB_OWB
block|,
name|ARM_L2L_NRML_IWBA_OWBA
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|l2s_mem_types
index|[]
init|=
block|{
name|ARM_L2S_STRONG_ORD
block|,
name|ARM_L2S_DEVICE_NOSHARE
block|,
name|ARM_L2S_DEVICE_SHARE
block|,
name|ARM_L2S_NRML_NOCACHE
block|,
name|ARM_L2S_NRML_IWT_OWT
block|,
name|ARM_L2S_NRML_IWB_OWB
block|,
name|ARM_L2S_NRML_IWBA_OWBA
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This list exists for the benefit of pmap_map_chunk().  It keeps track  * of the kernel L2 tables during bootstrap, so that pmap_map_chunk() can  * find them as necessary.  *  * Note that the data on this list MUST remain valid after initarm() returns,  * as pmap_bootstrap() uses it to contruct L2 table metadata.  */
end_comment

begin_macro
name|SLIST_HEAD
argument_list|(
argument_list|,
argument|pv_addr
argument_list|)
end_macro

begin_expr_stmt
name|kernel_pt_list
operator|=
name|SLIST_HEAD_INITIALIZER
argument_list|(
name|kernel_pt_list
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|pmap_init_l1
parameter_list|(
name|struct
name|l1_ttable
modifier|*
name|l1
parameter_list|,
name|pd_entry_t
modifier|*
name|l1pt
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|l1
operator|->
name|l1_kva
operator|=
name|l1pt
expr_stmt|;
name|l1
operator|->
name|l1_domain_use_count
operator|=
literal|0
expr_stmt|;
name|l1
operator|->
name|l1_domain_first
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PMAP_DOMAINS
condition|;
name|i
operator|++
control|)
name|l1
operator|->
name|l1_domain_free
index|[
name|i
index|]
operator|=
name|i
operator|+
literal|1
expr_stmt|;
comment|/* 	 * Copy the kernel's L1 entries to each new L1. 	 */
if|if
condition|(
name|l1pt
operator|!=
name|pmap_kernel
argument_list|()
operator|->
name|pm_l1
operator|->
name|l1_kva
condition|)
name|memcpy
argument_list|(
name|l1pt
argument_list|,
name|pmap_kernel
argument_list|()
operator|->
name|pm_l1
operator|->
name|l1_kva
argument_list|,
name|L1_TABLE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|l1
operator|->
name|l1_physaddr
operator|=
name|pmap_extract
argument_list|(
name|pmap_kernel
argument_list|()
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|l1pt
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"pmap_init_l1: can't get PA of L1 at %p"
argument_list|,
name|l1pt
argument_list|)
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|l1_list
argument_list|,
name|l1
argument_list|,
name|l1_link
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|l1_lru_list
argument_list|,
name|l1
argument_list|,
name|l1_lru
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|vm_offset_t
name|kernel_pt_lookup
parameter_list|(
name|vm_paddr_t
name|pa
parameter_list|)
block|{
name|struct
name|pv_addr
modifier|*
name|pv
decl_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&kernel_pt_list
argument_list|,
argument|pv_list
argument_list|)
block|{
if|if
condition|(
name|pv
operator|->
name|pv_pa
operator|==
name|pa
condition|)
return|return
operator|(
name|pv
operator|->
name|pv_va
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pmap_pte_init_mmu_v6
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|PTE_PAGETABLE
operator|>=
literal|3
condition|)
name|pmap_needs_pte_sync
operator|=
literal|1
expr_stmt|;
name|pte_l1_s_cache_mode
operator|=
name|l1_mem_types
index|[
name|PTE_CACHE
index|]
expr_stmt|;
name|pte_l2_l_cache_mode
operator|=
name|l2l_mem_types
index|[
name|PTE_CACHE
index|]
expr_stmt|;
name|pte_l2_s_cache_mode
operator|=
name|l2s_mem_types
index|[
name|PTE_CACHE
index|]
expr_stmt|;
name|pte_l1_s_cache_mode_pt
operator|=
name|l1_mem_types
index|[
name|PTE_PAGETABLE
index|]
expr_stmt|;
name|pte_l2_l_cache_mode_pt
operator|=
name|l2l_mem_types
index|[
name|PTE_PAGETABLE
index|]
expr_stmt|;
name|pte_l2_s_cache_mode_pt
operator|=
name|l2s_mem_types
index|[
name|PTE_PAGETABLE
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate an L1 translation table for the specified pmap.  * This is called at pmap creation time.  */
end_comment

begin_function
specifier|static
name|void
name|pmap_alloc_l1
parameter_list|(
name|pmap_t
name|pm
parameter_list|)
block|{
name|struct
name|l1_ttable
modifier|*
name|l1
decl_stmt|;
name|u_int8_t
name|domain
decl_stmt|;
comment|/* 	 * Remove the L1 at the head of the LRU list 	 */
name|mtx_lock
argument_list|(
operator|&
name|l1_lru_lock
argument_list|)
expr_stmt|;
name|l1
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|l1_lru_list
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|l1_lru_list
argument_list|,
name|l1
argument_list|,
name|l1_lru
argument_list|)
expr_stmt|;
comment|/* 	 * Pick the first available domain number, and update 	 * the link to the next number. 	 */
name|domain
operator|=
name|l1
operator|->
name|l1_domain_first
expr_stmt|;
name|l1
operator|->
name|l1_domain_first
operator|=
name|l1
operator|->
name|l1_domain_free
index|[
name|domain
index|]
expr_stmt|;
comment|/* 	 * If there are still free domain numbers in this L1, 	 * put it back on the TAIL of the LRU list. 	 */
if|if
condition|(
operator|++
name|l1
operator|->
name|l1_domain_use_count
operator|<
name|PMAP_DOMAINS
condition|)
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|l1_lru_list
argument_list|,
name|l1
argument_list|,
name|l1_lru
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|l1_lru_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Fix up the relevant bits in the pmap structure 	 */
name|pm
operator|->
name|pm_l1
operator|=
name|l1
expr_stmt|;
name|pm
operator|->
name|pm_domain
operator|=
name|domain
operator|+
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free an L1 translation table.  * This is called at pmap destruction time.  */
end_comment

begin_function
specifier|static
name|void
name|pmap_free_l1
parameter_list|(
name|pmap_t
name|pm
parameter_list|)
block|{
name|struct
name|l1_ttable
modifier|*
name|l1
init|=
name|pm
operator|->
name|pm_l1
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|l1_lru_lock
argument_list|)
expr_stmt|;
comment|/* 	 * If this L1 is currently on the LRU list, remove it. 	 */
if|if
condition|(
name|l1
operator|->
name|l1_domain_use_count
operator|<
name|PMAP_DOMAINS
condition|)
name|TAILQ_REMOVE
argument_list|(
operator|&
name|l1_lru_list
argument_list|,
name|l1
argument_list|,
name|l1_lru
argument_list|)
expr_stmt|;
comment|/* 	 * Free up the domain number which was allocated to the pmap 	 */
name|l1
operator|->
name|l1_domain_free
index|[
name|pm
operator|->
name|pm_domain
operator|-
literal|1
index|]
operator|=
name|l1
operator|->
name|l1_domain_first
expr_stmt|;
name|l1
operator|->
name|l1_domain_first
operator|=
name|pm
operator|->
name|pm_domain
operator|-
literal|1
expr_stmt|;
name|l1
operator|->
name|l1_domain_use_count
operator|--
expr_stmt|;
comment|/* 	 * The L1 now must have at least 1 free domain, so add 	 * it back to the LRU list. If the use count is zero, 	 * put it at the head of the list, otherwise it goes 	 * to the tail. 	 */
if|if
condition|(
name|l1
operator|->
name|l1_domain_use_count
operator|==
literal|0
condition|)
block|{
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|l1_lru_list
argument_list|,
name|l1
argument_list|,
name|l1_lru
argument_list|)
expr_stmt|;
block|}
else|else
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|l1_lru_list
argument_list|,
name|l1
argument_list|,
name|l1_lru
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|l1_lru_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Returns a pointer to the L2 bucket associated with the specified pmap  * and VA, or NULL if no L2 bucket exists for the address.  */
end_comment

begin_expr_stmt
specifier|static
name|PMAP_INLINE
expr|struct
name|l2_bucket
operator|*
name|pmap_get_l2_bucket
argument_list|(
argument|pmap_t pm
argument_list|,
argument|vm_offset_t va
argument_list|)
block|{ 	struct
name|l2_dtable
operator|*
name|l2
block|; 	struct
name|l2_bucket
operator|*
name|l2b
block|;
name|u_short
name|l1idx
block|;
name|l1idx
operator|=
name|L1_IDX
argument_list|(
name|va
argument_list|)
block|;
if|if
condition|(
operator|(
name|l2
operator|=
name|pm
operator|->
name|pm_l2
index|[
name|L2_IDX
argument_list|(
name|l1idx
argument_list|)
index|]
operator|)
operator|==
name|NULL
operator|||
operator|(
name|l2b
operator|=
operator|&
name|l2
operator|->
name|l2_bucket
index|[
name|L2_BUCKET
argument_list|(
name|l1idx
argument_list|)
index|]
operator|)
operator|->
name|l2b_kva
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
end_expr_stmt

begin_return
return|return
operator|(
name|l2b
operator|)
return|;
end_return

begin_comment
unit|}
comment|/*  * Returns a pointer to the L2 bucket associated with the specified pmap  * and VA.  *  * If no L2 bucket exists, perform the necessary allocations to put an L2  * bucket/page table in place.  *  * Note that if a new L2 bucket/page was allocated, the caller *must*  * increment the bucket occupancy counter appropriately *before*  * releasing the pmap's lock to ensure no other thread or cpu deallocates  * the bucket/page in the meantime.  */
end_comment

begin_function
unit|static
name|struct
name|l2_bucket
modifier|*
name|pmap_alloc_l2_bucket
parameter_list|(
name|pmap_t
name|pm
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|struct
name|l2_dtable
modifier|*
name|l2
decl_stmt|;
name|struct
name|l2_bucket
modifier|*
name|l2b
decl_stmt|;
name|u_short
name|l1idx
decl_stmt|;
name|l1idx
operator|=
name|L1_IDX
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|PMAP_ASSERT_LOCKED
argument_list|(
name|pm
argument_list|)
expr_stmt|;
name|rw_assert
argument_list|(
operator|&
name|pvh_global_lock
argument_list|,
name|RA_WLOCKED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|l2
operator|=
name|pm
operator|->
name|pm_l2
index|[
name|L2_IDX
argument_list|(
name|l1idx
argument_list|)
index|]
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * No mapping at this address, as there is 		 * no entry in the L1 table. 		 * Need to allocate a new l2_dtable. 		 */
name|PMAP_UNLOCK
argument_list|(
name|pm
argument_list|)
expr_stmt|;
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|l2
operator|=
name|uma_zalloc
argument_list|(
name|l2table_zone
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pm
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pm
argument_list|)
expr_stmt|;
if|if
condition|(
name|pm
operator|->
name|pm_l2
index|[
name|L2_IDX
argument_list|(
name|l1idx
argument_list|)
index|]
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * Someone already allocated the l2_dtable while 			 * we were doing the same. 			 */
name|uma_zfree
argument_list|(
name|l2table_zone
argument_list|,
name|l2
argument_list|)
expr_stmt|;
name|l2
operator|=
name|pm
operator|->
name|pm_l2
index|[
name|L2_IDX
argument_list|(
name|l1idx
argument_list|)
index|]
expr_stmt|;
block|}
else|else
block|{
name|bzero
argument_list|(
name|l2
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|l2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 			 * Link it into the parent pmap 			 */
name|pm
operator|->
name|pm_l2
index|[
name|L2_IDX
argument_list|(
name|l1idx
argument_list|)
index|]
operator|=
name|l2
expr_stmt|;
block|}
block|}
name|l2b
operator|=
operator|&
name|l2
operator|->
name|l2_bucket
index|[
name|L2_BUCKET
argument_list|(
name|l1idx
argument_list|)
index|]
expr_stmt|;
comment|/* 	 * Fetch pointer to the L2 page table associated with the address. 	 */
if|if
condition|(
name|l2b
operator|->
name|l2b_kva
operator|==
name|NULL
condition|)
block|{
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|;
comment|/* 		 * No L2 page table has been allocated. Chances are, this 		 * is because we just allocated the l2_dtable, above. 		 */
name|PMAP_UNLOCK
argument_list|(
name|pm
argument_list|)
expr_stmt|;
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|ptep
operator|=
name|uma_zalloc
argument_list|(
name|l2zone
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pm
argument_list|)
expr_stmt|;
if|if
condition|(
name|l2b
operator|->
name|l2b_kva
operator|!=
literal|0
condition|)
block|{
comment|/* We lost the race. */
name|uma_zfree
argument_list|(
name|l2zone
argument_list|,
name|ptep
argument_list|)
expr_stmt|;
return|return
operator|(
name|l2b
operator|)
return|;
block|}
name|l2b
operator|->
name|l2b_phys
operator|=
name|vtophys
argument_list|(
name|ptep
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptep
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * Oops, no more L2 page tables available at this 			 * time. We may need to deallocate the l2_dtable 			 * if we allocated a new one above. 			 */
if|if
condition|(
name|l2
operator|->
name|l2_occupancy
operator|==
literal|0
condition|)
block|{
name|pm
operator|->
name|pm_l2
index|[
name|L2_IDX
argument_list|(
name|l1idx
argument_list|)
index|]
operator|=
name|NULL
expr_stmt|;
name|uma_zfree
argument_list|(
name|l2table_zone
argument_list|,
name|l2
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|l2
operator|->
name|l2_occupancy
operator|++
expr_stmt|;
name|l2b
operator|->
name|l2b_kva
operator|=
name|ptep
expr_stmt|;
name|l2b
operator|->
name|l2b_l1idx
operator|=
name|l1idx
expr_stmt|;
block|}
return|return
operator|(
name|l2b
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|PMAP_INLINE
name|void
name|pmap_free_l2_ptp
parameter_list|(
name|pt_entry_t
modifier|*
name|l2
parameter_list|)
block|{
name|uma_zfree
argument_list|(
name|l2zone
argument_list|,
name|l2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * One or more mappings in the specified L2 descriptor table have just been  * invalidated.  *  * Garbage collect the metadata and descriptor table itself if necessary.  *  * The pmap lock must be acquired when this is called (not necessary  * for the kernel pmap).  */
end_comment

begin_function
specifier|static
name|void
name|pmap_free_l2_bucket
parameter_list|(
name|pmap_t
name|pm
parameter_list|,
name|struct
name|l2_bucket
modifier|*
name|l2b
parameter_list|,
name|u_int
name|count
parameter_list|)
block|{
name|struct
name|l2_dtable
modifier|*
name|l2
decl_stmt|;
name|pd_entry_t
modifier|*
name|pl1pd
decl_stmt|,
name|l1pd
decl_stmt|;
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|;
name|u_short
name|l1idx
decl_stmt|;
comment|/* 	 * Update the bucket's reference count according to how many 	 * PTEs the caller has just invalidated. 	 */
name|l2b
operator|->
name|l2b_occupancy
operator|-=
name|count
expr_stmt|;
comment|/* 	 * Note: 	 * 	 * Level 2 page tables allocated to the kernel pmap are never freed 	 * as that would require checking all Level 1 page tables and 	 * removing any references to the Level 2 page table. See also the 	 * comment elsewhere about never freeing bootstrap L2 descriptors. 	 * 	 * We make do with just invalidating the mapping in the L2 table. 	 * 	 * This isn't really a big deal in practice and, in fact, leads 	 * to a performance win over time as we don't need to continually 	 * alloc/free. 	 */
if|if
condition|(
name|l2b
operator|->
name|l2b_occupancy
operator|>
literal|0
operator|||
name|pm
operator|==
name|pmap_kernel
argument_list|()
condition|)
return|return;
comment|/* 	 * There are no more valid mappings in this level 2 page table. 	 * Go ahead and NULL-out the pointer in the bucket, then 	 * free the page table. 	 */
name|l1idx
operator|=
name|l2b
operator|->
name|l2b_l1idx
expr_stmt|;
name|ptep
operator|=
name|l2b
operator|->
name|l2b_kva
expr_stmt|;
name|l2b
operator|->
name|l2b_kva
operator|=
name|NULL
expr_stmt|;
name|pl1pd
operator|=
operator|&
name|pm
operator|->
name|pm_l1
operator|->
name|l1_kva
index|[
name|l1idx
index|]
expr_stmt|;
comment|/* 	 * If the L1 slot matches the pmap's domain 	 * number, then invalidate it. 	 */
name|l1pd
operator|=
operator|*
name|pl1pd
operator|&
operator|(
name|L1_TYPE_MASK
operator||
name|L1_C_DOM_MASK
operator|)
expr_stmt|;
if|if
condition|(
name|l1pd
operator|==
operator|(
name|L1_C_DOM
argument_list|(
name|pm
operator|->
name|pm_domain
argument_list|)
operator||
name|L1_TYPE_C
operator|)
condition|)
block|{
operator|*
name|pl1pd
operator|=
literal|0
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|pl1pd
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Release the L2 descriptor table back to the pool cache. 	 */
name|pmap_free_l2_ptp
argument_list|(
name|ptep
argument_list|)
expr_stmt|;
comment|/* 	 * Update the reference count in the associated l2_dtable 	 */
name|l2
operator|=
name|pm
operator|->
name|pm_l2
index|[
name|L2_IDX
argument_list|(
name|l1idx
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|--
name|l2
operator|->
name|l2_occupancy
operator|>
literal|0
condition|)
return|return;
comment|/* 	 * There are no more valid mappings in any of the Level 1 	 * slots managed by this l2_dtable. Go ahead and NULL-out 	 * the pointer in the parent pmap and free the l2_dtable. 	 */
name|pm
operator|->
name|pm_l2
index|[
name|L2_IDX
argument_list|(
name|l1idx
argument_list|)
index|]
operator|=
name|NULL
expr_stmt|;
name|uma_zfree
argument_list|(
name|l2table_zone
argument_list|,
name|l2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Pool cache constructors for L2 descriptor tables, metadata and pmap  * structures.  */
end_comment

begin_function
specifier|static
name|int
name|pmap_l2ptp_ctor
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|int
name|size
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|l2_bucket
modifier|*
name|l2b
decl_stmt|;
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|,
name|pte
decl_stmt|;
name|vm_offset_t
name|va
init|=
operator|(
name|vm_offset_t
operator|)
name|mem
operator|&
operator|~
name|PAGE_MASK
decl_stmt|;
comment|/* 	 * The mappings for these page tables were initially made using 	 * pmap_kenter() by the pool subsystem. Therefore, the cache- 	 * mode will not be right for page table mappings. To avoid 	 * polluting the pmap_kenter() code with a special case for 	 * page tables, we simply fix up the cache-mode here if it's not 	 * correct. 	 */
name|l2b
operator|=
name|pmap_get_l2_bucket
argument_list|(
name|pmap_kernel
argument_list|()
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|ptep
operator|=
operator|&
name|l2b
operator|->
name|l2b_kva
index|[
name|l2pte_index
argument_list|(
name|va
argument_list|)
index|]
expr_stmt|;
name|pte
operator|=
operator|*
name|ptep
expr_stmt|;
name|cpu_idcache_wbinv_range
argument_list|(
name|va
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ARM_L2_PIPT
name|cpu_l2cache_wbinv_range
argument_list|(
name|pte
operator|&
name|L2_S_FRAME
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
else|#
directive|else
name|cpu_l2cache_wbinv_range
argument_list|(
name|va
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|pte
operator|&
name|L2_S_CACHE_MASK
operator|)
operator|!=
name|pte_l2_s_cache_mode_pt
condition|)
block|{
comment|/* 		 * Page tables must have the cache-mode set to 		 * Write-Thru. 		 */
operator|*
name|ptep
operator|=
operator|(
name|pte
operator|&
operator|~
name|L2_S_CACHE_MASK
operator|)
operator||
name|pte_l2_s_cache_mode_pt
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|ptep
argument_list|)
expr_stmt|;
name|cpu_tlb_flushD_SE
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|cpu_cpwait
argument_list|()
expr_stmt|;
block|}
name|memset
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|,
name|L2_TABLE_SIZE_REAL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Modify pte bits for all ptes corresponding to the given physical address.  * We use `maskbits' rather than `clearbits' because we're always passing  * constants and the latter would require an extra inversion at run-time.  */
end_comment

begin_function
specifier|static
name|int
name|pmap_clearbit
parameter_list|(
name|struct
name|vm_page
modifier|*
name|pg
parameter_list|,
name|u_int
name|maskbits
parameter_list|)
block|{
name|struct
name|l2_bucket
modifier|*
name|l2b
decl_stmt|;
name|struct
name|pv_entry
modifier|*
name|pv
decl_stmt|;
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|,
name|npte
decl_stmt|,
name|opte
decl_stmt|;
name|pmap_t
name|pm
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
name|u_int
name|oflags
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|maskbits
operator|&
name|PVF_WRITE
condition|)
name|maskbits
operator||=
name|PVF_MOD
expr_stmt|;
comment|/* 	 * Clear saved attributes (modify, reference) 	 */
name|pg
operator|->
name|md
operator|.
name|pvh_attrs
operator|&=
operator|~
operator|(
name|maskbits
operator|&
operator|(
name|PVF_MOD
operator||
name|PVF_REF
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|pg
operator|->
name|md
operator|.
name|pv_list
argument_list|)
condition|)
block|{
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Loop over all current mappings setting/clearing as appropos 	 */
name|TAILQ_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&pg->md.pv_list
argument_list|,
argument|pv_list
argument_list|)
block|{
name|va
operator|=
name|pv
operator|->
name|pv_va
expr_stmt|;
name|pm
operator|=
name|pv
operator|->
name|pv_pmap
expr_stmt|;
name|oflags
operator|=
name|pv
operator|->
name|pv_flags
expr_stmt|;
name|pv
operator|->
name|pv_flags
operator|&=
operator|~
name|maskbits
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pm
argument_list|)
expr_stmt|;
name|l2b
operator|=
name|pmap_get_l2_bucket
argument_list|(
name|pm
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|ptep
operator|=
operator|&
name|l2b
operator|->
name|l2b_kva
index|[
name|l2pte_index
argument_list|(
name|va
argument_list|)
index|]
expr_stmt|;
name|npte
operator|=
name|opte
operator|=
operator|*
name|ptep
expr_stmt|;
if|if
condition|(
operator|(
name|maskbits
operator|&
operator|(
name|PVF_WRITE
operator||
name|PVF_MOD
operator|)
operator|)
operator|&&
name|L2_S_WRITABLE
argument_list|(
name|opte
argument_list|)
condition|)
block|{
name|vm_page_dirty
argument_list|(
name|pg
argument_list|)
expr_stmt|;
comment|/* make the pte read only */
name|npte
operator||=
name|L2_APX
expr_stmt|;
block|}
if|if
condition|(
name|maskbits
operator|&
name|PVF_REF
condition|)
block|{
comment|/* 			 * Make the PTE invalid so that we will take a 			 * page fault the next time the mapping is 			 * referenced. 			 */
name|npte
operator|&=
operator|~
name|L2_TYPE_MASK
expr_stmt|;
name|npte
operator||=
name|L2_TYPE_INV
expr_stmt|;
block|}
name|CTR4
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"clearbit: pmap:%p bits:%x pte:%x->%x"
argument_list|,
name|pm
argument_list|,
name|maskbits
argument_list|,
name|opte
argument_list|,
name|npte
argument_list|)
expr_stmt|;
if|if
condition|(
name|npte
operator|!=
name|opte
condition|)
block|{
name|count
operator|++
expr_stmt|;
operator|*
name|ptep
operator|=
name|npte
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|ptep
argument_list|)
expr_stmt|;
comment|/* Flush the TLB entry if a current pmap. */
if|if
condition|(
name|PV_BEEN_EXECD
argument_list|(
name|oflags
argument_list|)
condition|)
name|cpu_tlb_flushID_SE
argument_list|(
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|PV_BEEN_REFD
argument_list|(
name|oflags
argument_list|)
condition|)
name|cpu_tlb_flushD_SE
argument_list|(
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
block|}
name|PMAP_UNLOCK
argument_list|(
name|pm
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|maskbits
operator|&
name|PVF_WRITE
condition|)
name|vm_page_aflag_clear
argument_list|(
name|pg
argument_list|,
name|PGA_WRITEABLE
argument_list|)
expr_stmt|;
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * main pv_entry manipulation functions:  *   pmap_enter_pv: enter a mapping onto a vm_page list  *   pmap_remove_pv: remove a mappiing from a vm_page list  *  * NOTE: pmap_enter_pv expects to lock the pvh itself  *       pmap_remove_pv expects the caller to lock the pvh before calling  */
end_comment

begin_comment
comment|/*  * pmap_enter_pv: enter a mapping onto a vm_page's PV list  *  * => caller should hold the proper lock on pvh_global_lock  * => caller should have pmap locked  * => we will (someday) gain the lock on the vm_page's PV list  * => caller should adjust ptp's wire_count before calling  * => caller should not adjust pmap's wire_count  */
end_comment

begin_function
specifier|static
name|void
name|pmap_enter_pv
parameter_list|(
name|struct
name|vm_page
modifier|*
name|pg
parameter_list|,
name|struct
name|pv_entry
modifier|*
name|pve
parameter_list|,
name|pmap_t
name|pm
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|u_int
name|flags
parameter_list|)
block|{
name|rw_assert
argument_list|(
operator|&
name|pvh_global_lock
argument_list|,
name|RA_WLOCKED
argument_list|)
expr_stmt|;
name|PMAP_ASSERT_LOCKED
argument_list|(
name|pm
argument_list|)
expr_stmt|;
name|pve
operator|->
name|pv_pmap
operator|=
name|pm
expr_stmt|;
name|pve
operator|->
name|pv_va
operator|=
name|va
expr_stmt|;
name|pve
operator|->
name|pv_flags
operator|=
name|flags
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|pg
operator|->
name|md
operator|.
name|pv_list
argument_list|,
name|pve
argument_list|,
name|pv_list
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|pm
operator|->
name|pm_pvlist
argument_list|,
name|pve
argument_list|,
name|pv_plist
argument_list|)
expr_stmt|;
name|pg
operator|->
name|md
operator|.
name|pvh_attrs
operator||=
name|flags
operator|&
operator|(
name|PVF_REF
operator||
name|PVF_MOD
operator|)
expr_stmt|;
if|if
condition|(
name|pve
operator|->
name|pv_flags
operator|&
name|PVF_WIRED
condition|)
operator|++
name|pm
operator|->
name|pm_stats
operator|.
name|wired_count
expr_stmt|;
name|vm_page_aflag_set
argument_list|(
name|pg
argument_list|,
name|PGA_REFERENCED
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  * pmap_find_pv: Find a pv entry  *  * => caller should hold lock on vm_page  */
end_comment

begin_expr_stmt
specifier|static
name|PMAP_INLINE
expr|struct
name|pv_entry
operator|*
name|pmap_find_pv
argument_list|(
argument|struct vm_page *pg
argument_list|,
argument|pmap_t pm
argument_list|,
argument|vm_offset_t va
argument_list|)
block|{ 	struct
name|pv_entry
operator|*
name|pv
block|;
name|rw_assert
argument_list|(
operator|&
name|pvh_global_lock
argument_list|,
name|RA_WLOCKED
argument_list|)
block|;
name|TAILQ_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&pg->md.pv_list
argument_list|,
argument|pv_list
argument_list|)
if|if
condition|(
name|pm
operator|==
name|pv
operator|->
name|pv_pmap
operator|&&
name|va
operator|==
name|pv
operator|->
name|pv_va
condition|)
break|break;
end_expr_stmt

begin_return
return|return
operator|(
name|pv
operator|)
return|;
end_return

begin_comment
unit|}
comment|/*  * vector_page_setprot:  *  *	Manipulate the protection of the vector page.  */
end_comment

begin_macro
unit|void
name|vector_page_setprot
argument_list|(
argument|int prot
argument_list|)
end_macro

begin_block
block|{
name|struct
name|l2_bucket
modifier|*
name|l2b
decl_stmt|;
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|;
name|l2b
operator|=
name|pmap_get_l2_bucket
argument_list|(
name|pmap_kernel
argument_list|()
argument_list|,
name|vector_page
argument_list|)
expr_stmt|;
name|ptep
operator|=
operator|&
name|l2b
operator|->
name|l2b_kva
index|[
name|l2pte_index
argument_list|(
name|vector_page
argument_list|)
index|]
expr_stmt|;
name|pmap_set_prot
argument_list|(
name|ptep
argument_list|,
name|prot
operator||
name|VM_PROT_EXECUTE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cpu_tlb_flushD_SE
argument_list|(
name|vector_page
argument_list|)
expr_stmt|;
name|cpu_cpwait
argument_list|()
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|void
name|pmap_set_prot
parameter_list|(
name|pt_entry_t
modifier|*
name|ptep
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|,
name|uint8_t
name|user
parameter_list|)
block|{
operator|*
name|ptep
operator|&=
operator|~
name|L2_S_PROT_MASK
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|prot
operator|&
name|VM_PROT_EXECUTE
operator|)
condition|)
operator|*
name|ptep
operator||=
name|L2_XN
expr_stmt|;
operator|*
name|ptep
operator||=
name|L2_S_PROT_R
expr_stmt|;
if|if
condition|(
name|user
condition|)
operator|*
name|ptep
operator||=
name|L2_S_PROT_U
expr_stmt|;
if|if
condition|(
name|prot
operator|&
name|VM_PROT_WRITE
condition|)
operator|*
name|ptep
operator|&=
operator|~
operator|(
name|L2_APX
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * pmap_remove_pv: try to remove a mapping from a pv_list  *  * => caller should hold proper lock on pmap_main_lock  * => pmap should be locked  * => caller should hold lock on vm_page [so that attrs can be adjusted]  * => caller should adjust ptp's wire_count and free PTP if needed  * => caller should NOT adjust pmap's wire_count  * => we return the removed pve  */
end_comment

begin_function
specifier|static
name|void
name|pmap_nuke_pv
parameter_list|(
name|struct
name|vm_page
modifier|*
name|pg
parameter_list|,
name|pmap_t
name|pm
parameter_list|,
name|struct
name|pv_entry
modifier|*
name|pve
parameter_list|)
block|{
name|rw_assert
argument_list|(
operator|&
name|pvh_global_lock
argument_list|,
name|RA_WLOCKED
argument_list|)
expr_stmt|;
name|PMAP_ASSERT_LOCKED
argument_list|(
name|pm
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pg
operator|->
name|md
operator|.
name|pv_list
argument_list|,
name|pve
argument_list|,
name|pv_list
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pm
operator|->
name|pm_pvlist
argument_list|,
name|pve
argument_list|,
name|pv_plist
argument_list|)
expr_stmt|;
if|if
condition|(
name|pve
operator|->
name|pv_flags
operator|&
name|PVF_WIRED
condition|)
operator|--
name|pm
operator|->
name|pm_stats
operator|.
name|wired_count
expr_stmt|;
if|if
condition|(
name|pg
operator|->
name|md
operator|.
name|pvh_attrs
operator|&
name|PVF_MOD
condition|)
name|vm_page_dirty
argument_list|(
name|pg
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|pg
operator|->
name|md
operator|.
name|pv_list
argument_list|)
operator|==
name|NULL
condition|)
name|pg
operator|->
name|md
operator|.
name|pvh_attrs
operator|&=
operator|~
name|PVF_REF
expr_stmt|;
else|else
name|vm_page_aflag_set
argument_list|(
name|pg
argument_list|,
name|PGA_REFERENCED
argument_list|)
expr_stmt|;
if|if
condition|(
name|pve
operator|->
name|pv_flags
operator|&
name|PVF_WRITE
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|pve
argument_list|,
argument|&pg->md.pv_list
argument_list|,
argument|pv_list
argument_list|)
if|if
condition|(
name|pve
operator|->
name|pv_flags
operator|&
name|PVF_WRITE
condition|)
break|break;
if|if
condition|(
operator|!
name|pve
condition|)
block|{
name|pg
operator|->
name|md
operator|.
name|pvh_attrs
operator|&=
operator|~
name|PVF_MOD
expr_stmt|;
name|vm_page_aflag_clear
argument_list|(
name|pg
argument_list|,
name|PGA_WRITEABLE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|pv_entry
modifier|*
name|pmap_remove_pv
parameter_list|(
name|struct
name|vm_page
modifier|*
name|pg
parameter_list|,
name|pmap_t
name|pm
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|struct
name|pv_entry
modifier|*
name|pve
decl_stmt|;
name|rw_assert
argument_list|(
operator|&
name|pvh_global_lock
argument_list|,
name|RA_WLOCKED
argument_list|)
expr_stmt|;
name|pve
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pg
operator|->
name|md
operator|.
name|pv_list
argument_list|)
expr_stmt|;
while|while
condition|(
name|pve
condition|)
block|{
if|if
condition|(
name|pve
operator|->
name|pv_pmap
operator|==
name|pm
operator|&&
name|pve
operator|->
name|pv_va
operator|==
name|va
condition|)
block|{
comment|/* match? */
name|pmap_nuke_pv
argument_list|(
name|pg
argument_list|,
name|pm
argument_list|,
name|pve
argument_list|)
expr_stmt|;
break|break;
block|}
name|pve
operator|=
name|TAILQ_NEXT
argument_list|(
name|pve
argument_list|,
name|pv_list
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|pve
operator|)
return|;
comment|/* return removed pve */
block|}
end_function

begin_comment
comment|/*  *  * pmap_modify_pv: Update pv flags  *  * => caller should hold lock on vm_page [so that attrs can be adjusted]  * => caller should NOT adjust pmap's wire_count  * => we return the old flags  *  * Modify a physical-virtual mapping in the pv table  */
end_comment

begin_function
specifier|static
name|u_int
name|pmap_modify_pv
parameter_list|(
name|struct
name|vm_page
modifier|*
name|pg
parameter_list|,
name|pmap_t
name|pm
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|u_int
name|clr_mask
parameter_list|,
name|u_int
name|set_mask
parameter_list|)
block|{
name|struct
name|pv_entry
modifier|*
name|npv
decl_stmt|;
name|u_int
name|flags
decl_stmt|,
name|oflags
decl_stmt|;
name|PMAP_ASSERT_LOCKED
argument_list|(
name|pm
argument_list|)
expr_stmt|;
name|rw_assert
argument_list|(
operator|&
name|pvh_global_lock
argument_list|,
name|RA_WLOCKED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|npv
operator|=
name|pmap_find_pv
argument_list|(
name|pg
argument_list|,
name|pm
argument_list|,
name|va
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * There is at least one VA mapping this page. 	 */
if|if
condition|(
name|clr_mask
operator|&
operator|(
name|PVF_REF
operator||
name|PVF_MOD
operator|)
condition|)
name|pg
operator|->
name|md
operator|.
name|pvh_attrs
operator||=
name|set_mask
operator|&
operator|(
name|PVF_REF
operator||
name|PVF_MOD
operator|)
expr_stmt|;
name|oflags
operator|=
name|npv
operator|->
name|pv_flags
expr_stmt|;
name|npv
operator|->
name|pv_flags
operator|=
name|flags
operator|=
operator|(
name|oflags
operator|&
operator|~
name|clr_mask
operator|)
operator||
name|set_mask
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|^
name|oflags
operator|)
operator|&
name|PVF_WIRED
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|PVF_WIRED
condition|)
operator|++
name|pm
operator|->
name|pm_stats
operator|.
name|wired_count
expr_stmt|;
else|else
operator|--
name|pm
operator|->
name|pm_stats
operator|.
name|wired_count
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|oflags
operator|&
name|PVF_WRITE
operator|)
operator|&&
operator|!
operator|(
name|flags
operator|&
name|PVF_WRITE
operator|)
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|npv
argument_list|,
argument|&pg->md.pv_list
argument_list|,
argument|pv_list
argument_list|)
block|{
if|if
condition|(
name|npv
operator|->
name|pv_flags
operator|&
name|PVF_WRITE
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|npv
condition|)
block|{
name|pg
operator|->
name|md
operator|.
name|pvh_attrs
operator|&=
operator|~
name|PVF_MOD
expr_stmt|;
name|vm_page_aflag_clear
argument_list|(
name|pg
argument_list|,
name|PGA_WRITEABLE
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|oflags
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Function to set the debug level of the pmap code */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PMAP_DEBUG
end_ifdef

begin_function
name|void
name|pmap_debug
parameter_list|(
name|int
name|level
parameter_list|)
block|{
name|pmap_debug_level
operator|=
name|level
expr_stmt|;
name|dprintf
argument_list|(
literal|"pmap_debug: level=%d\n"
argument_list|,
name|pmap_debug_level
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PMAP_DEBUG */
end_comment

begin_function
name|void
name|pmap_pinit0
parameter_list|(
name|struct
name|pmap
modifier|*
name|pmap
parameter_list|)
block|{
name|PDEBUG
argument_list|(
literal|1
argument_list|,
name|printf
argument_list|(
literal|"pmap_pinit0: pmap = %08x\n"
argument_list|,
operator|(
name|u_int32_t
operator|)
name|pmap
argument_list|)
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|"pmap_pinit0: pmap = %08x, pm_pdir = %08x\n"
argument_list|,
operator|(
name|u_int32_t
operator|)
name|pmap
argument_list|,
operator|(
name|u_int32_t
operator|)
name|pmap
operator|->
name|pm_pdir
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|kernel_pmap
argument_list|,
name|pmap
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pmap
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|pmap
operator|->
name|pm_mtx
argument_list|,
sizeof|sizeof
argument_list|(
name|pmap
operator|->
name|pm_mtx
argument_list|)
argument_list|)
expr_stmt|;
name|PMAP_LOCK_INIT
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Initialize a vm_page's machine-dependent fields.  */
end_comment

begin_function
name|void
name|pmap_page_init
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|TAILQ_INIT
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *      Initialize the pmap module.  *      Called by vm_init, to initialize any structures that the pmap  *      system needs to map virtual memory.  */
end_comment

begin_function
name|void
name|pmap_init
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|shpgperproc
init|=
name|PMAP_SHPGPERPROC
decl_stmt|;
name|PDEBUG
argument_list|(
literal|1
argument_list|,
name|printf
argument_list|(
literal|"pmap_init: phys_start = %08x\n"
argument_list|,
name|PHYSADDR
argument_list|)
argument_list|)
expr_stmt|;
name|l2zone
operator|=
name|uma_zcreate
argument_list|(
literal|"L2 Table"
argument_list|,
name|L2_TABLE_SIZE_REAL
argument_list|,
name|pmap_l2ptp_ctor
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
name|UMA_ZONE_VM
operator||
name|UMA_ZONE_NOFREE
argument_list|)
expr_stmt|;
name|l2table_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"L2 Table"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|l2_dtable
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
name|UMA_ZONE_VM
operator||
name|UMA_ZONE_NOFREE
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize the PV entry allocator. 	 */
name|pvzone
operator|=
name|uma_zcreate
argument_list|(
literal|"PV ENTRY"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pv_entry
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
name|UMA_ZONE_VM
operator||
name|UMA_ZONE_NOFREE
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"vm.pmap.shpgperproc"
argument_list|,
operator|&
name|shpgperproc
argument_list|)
expr_stmt|;
name|pv_entry_max
operator|=
name|shpgperproc
operator|*
name|maxproc
operator|+
name|cnt
operator|.
name|v_page_count
expr_stmt|;
name|uma_zone_set_obj
argument_list|(
name|pvzone
argument_list|,
operator|&
name|pvzone_obj
argument_list|,
name|pv_entry_max
argument_list|)
expr_stmt|;
name|pv_entry_high_water
operator|=
literal|9
operator|*
operator|(
name|pv_entry_max
operator|/
literal|10
operator|)
expr_stmt|;
comment|/* 	 * Now it is safe to enable pv_table recording. 	 */
name|PDEBUG
argument_list|(
literal|1
argument_list|,
name|printf
argument_list|(
literal|"pmap_init: done!\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|pmap_fault_fixup
parameter_list|(
name|pmap_t
name|pm
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_prot_t
name|ftype
parameter_list|,
name|int
name|user
parameter_list|)
block|{
name|struct
name|l2_dtable
modifier|*
name|l2
decl_stmt|;
name|struct
name|l2_bucket
modifier|*
name|l2b
decl_stmt|;
name|pd_entry_t
modifier|*
name|pl1pd
decl_stmt|,
name|l1pd
decl_stmt|;
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|,
name|pte
decl_stmt|;
name|vm_paddr_t
name|pa
decl_stmt|;
name|u_int
name|l1idx
decl_stmt|;
name|int
name|rv
init|=
literal|0
decl_stmt|;
name|l1idx
operator|=
name|L1_IDX
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pm
argument_list|)
expr_stmt|;
comment|/* 	 * If there is no l2_dtable for this address, then the process 	 * has no business accessing it. 	 * 	 * Note: This will catch userland processes trying to access 	 * kernel addresses. 	 */
name|l2
operator|=
name|pm
operator|->
name|pm_l2
index|[
name|L2_IDX
argument_list|(
name|l1idx
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|l2
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * Likewise if there is no L2 descriptor table 	 */
name|l2b
operator|=
operator|&
name|l2
operator|->
name|l2_bucket
index|[
name|L2_BUCKET
argument_list|(
name|l1idx
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|l2b
operator|->
name|l2b_kva
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * Check the PTE itself. 	 */
name|ptep
operator|=
operator|&
name|l2b
operator|->
name|l2b_kva
index|[
name|l2pte_index
argument_list|(
name|va
argument_list|)
index|]
expr_stmt|;
name|pte
operator|=
operator|*
name|ptep
expr_stmt|;
if|if
condition|(
name|pte
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * Catch a userland access to the vector page mapped at 0x0 	 */
if|if
condition|(
name|user
operator|&&
operator|(
operator|(
name|pte
operator|&
name|L2_S_PROT_MASK
operator|)
operator|==
name|L2_S_PROT_U
operator|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|va
operator|==
name|vector_page
condition|)
goto|goto
name|out
goto|;
name|pa
operator|=
name|l2pte_pa
argument_list|(
name|pte
argument_list|)
expr_stmt|;
name|CTR5
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"pmap_fault_fix: pmap:%p va:%x pte:0x%x ftype:%x user:%x"
argument_list|,
name|pm
argument_list|,
name|va
argument_list|,
name|pte
argument_list|,
name|ftype
argument_list|,
name|user
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ftype
operator|&
name|VM_PROT_WRITE
operator|)
operator|&&
operator|!
operator|(
name|L2_S_WRITABLE
argument_list|(
name|pte
argument_list|)
operator|)
condition|)
block|{
comment|/* 		 * This looks like a good candidate for "page modified" 		 * emulation... 		 */
name|struct
name|pv_entry
modifier|*
name|pv
decl_stmt|;
name|struct
name|vm_page
modifier|*
name|pg
decl_stmt|;
comment|/* Extract the physical address of the page */
if|if
condition|(
operator|(
name|pg
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pa
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
goto|goto
name|out
goto|;
block|}
comment|/* Get the current flags for this page. */
name|pv
operator|=
name|pmap_find_pv
argument_list|(
name|pg
argument_list|,
name|pm
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|pv
operator|==
name|NULL
condition|)
block|{
goto|goto
name|out
goto|;
block|}
comment|/* 		 * Do the flags say this page is writable? If not then it 		 * is a genuine write fault. If yes then the write fault is 		 * our fault as we did not reflect the write access in the 		 * PTE. Now we know a write has occurred we can correct this 		 * and also set the modified bit 		 */
if|if
condition|(
operator|(
name|pv
operator|->
name|pv_flags
operator|&
name|PVF_WRITE
operator|)
operator|==
literal|0
condition|)
block|{
goto|goto
name|out
goto|;
block|}
name|pg
operator|->
name|md
operator|.
name|pvh_attrs
operator||=
name|PVF_REF
operator||
name|PVF_MOD
expr_stmt|;
name|vm_page_dirty
argument_list|(
name|pg
argument_list|)
expr_stmt|;
name|pv
operator|->
name|pv_flags
operator||=
name|PVF_REF
operator||
name|PVF_MOD
expr_stmt|;
comment|/* Re-enable write permissions for the page */
operator|*
name|ptep
operator|=
operator|(
name|pte
operator|&
operator|~
name|L2_TYPE_MASK
operator|)
operator||
name|L2_S_PROTO
expr_stmt|;
name|pmap_set_prot
argument_list|(
name|ptep
argument_list|,
name|VM_PROT_WRITE
argument_list|,
operator|*
name|ptep
operator|&
name|L2_S_PROT_U
argument_list|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"pmap_fault_fix: new pte:0x%x"
argument_list|,
name|pte
argument_list|)
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|ptep
argument_list|)
expr_stmt|;
name|rv
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|pte
operator|&
name|L2_TYPE_MASK
operator|)
operator|==
name|L2_TYPE_INV
condition|)
block|{
comment|/* 		 * This looks like a good candidate for "page referenced" 		 * emulation. 		 */
name|struct
name|pv_entry
modifier|*
name|pv
decl_stmt|;
name|struct
name|vm_page
modifier|*
name|pg
decl_stmt|;
comment|/* Extract the physical address of the page */
if|if
condition|(
operator|(
name|pg
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pa
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
comment|/* Get the current flags for this page. */
name|pv
operator|=
name|pmap_find_pv
argument_list|(
name|pg
argument_list|,
name|pm
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|pv
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
name|pg
operator|->
name|md
operator|.
name|pvh_attrs
operator||=
name|PVF_REF
expr_stmt|;
name|pv
operator|->
name|pv_flags
operator||=
name|PVF_REF
expr_stmt|;
operator|*
name|ptep
operator|=
operator|(
name|pte
operator|&
operator|~
name|L2_TYPE_MASK
operator|)
operator||
name|L2_S_PROTO
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|ptep
argument_list|)
expr_stmt|;
name|rv
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * We know there is a valid mapping here, so simply 	 * fix up the L1 if necessary. 	 */
name|pl1pd
operator|=
operator|&
name|pm
operator|->
name|pm_l1
operator|->
name|l1_kva
index|[
name|l1idx
index|]
expr_stmt|;
name|l1pd
operator|=
name|l2b
operator|->
name|l2b_phys
operator||
name|L1_C_DOM
argument_list|(
name|pm
operator|->
name|pm_domain
argument_list|)
operator||
name|L1_C_PROTO
expr_stmt|;
if|if
condition|(
operator|*
name|pl1pd
operator|!=
name|l1pd
condition|)
block|{
operator|*
name|pl1pd
operator|=
name|l1pd
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|pl1pd
argument_list|)
expr_stmt|;
name|rv
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
comment|/* 	 * If 'rv == 0' at this point, it generally indicates that there is a 	 * stale TLB entry for the faulting address. This happens when two or 	 * more processes are sharing an L1. Since we don't flush the TLB on 	 * a context switch between such processes, we can take domain faults 	 * for mappings which exist at the same VA in both processes. EVEN IF 	 * WE'VE RECENTLY FIXED UP THE CORRESPONDING L1 in pmap_enter(), for 	 * example. 	 * 	 * This is extremely likely to happen if pmap_enter() updated the L1 	 * entry for a recently entered mapping. In this case, the TLB is 	 * flushed for the new mapping, but there may still be TLB entries for 	 * other mappings belonging to other processes in the 1MB range 	 * covered by the L1 entry. 	 * 	 * Since 'rv == 0', we know that the L1 already contains the correct 	 * value, so the fault must be due to a stale TLB entry. 	 * 	 * Since we always need to flush the TLB anyway in the case where we 	 * fixed up the L1, or frobbed the L2 PTE, we effectively deal with 	 * stale TLB entries dynamically. 	 * 	 * However, the above condition can ONLY happen if the current L1 is 	 * being shared. If it happens when the L1 is unshared, it indicates 	 * that other parts of the pmap are not doing their job WRT managing 	 * the TLB. 	 */
if|if
condition|(
name|rv
operator|==
literal|0
operator|&&
name|pm
operator|->
name|pm_l1
operator|->
name|l1_domain_use_count
operator|==
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"fixup: pm %p, va 0x%08x, ftype %d - nothing to do!\n"
argument_list|,
name|pm
argument_list|,
name|va
argument_list|,
name|ftype
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"fixup: l2 %p, l2b %p, ptep %p, pl1pd %p\n"
argument_list|,
name|l2
argument_list|,
name|l2b
argument_list|,
name|ptep
argument_list|,
name|pl1pd
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"fixup: pte 0x%x, l1pd 0x%x, last code 0x%x\n"
argument_list|,
name|pte
argument_list|,
name|l1pd
argument_list|,
name|last_fault_code
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DDB
name|Debugger
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
name|cpu_tlb_flushID_SE
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|cpu_cpwait
argument_list|()
expr_stmt|;
name|rv
operator|=
literal|1
expr_stmt|;
name|out
label|:
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pm
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pmap_postinit
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|l2_bucket
modifier|*
name|l2b
decl_stmt|;
name|struct
name|l1_ttable
modifier|*
name|l1
decl_stmt|;
name|pd_entry_t
modifier|*
name|pl1pt
decl_stmt|;
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|,
name|pte
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|,
name|eva
decl_stmt|;
name|u_int
name|loop
decl_stmt|,
name|needed
decl_stmt|;
name|needed
operator|=
operator|(
name|maxproc
operator|/
name|PMAP_DOMAINS
operator|)
operator|+
operator|(
operator|(
name|maxproc
operator|%
name|PMAP_DOMAINS
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
name|needed
operator|-=
literal|1
expr_stmt|;
name|l1
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|l1
argument_list|)
operator|*
name|needed
argument_list|,
name|M_VMPMAP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
for|for
control|(
name|loop
operator|=
literal|0
init|;
name|loop
operator|<
name|needed
condition|;
name|loop
operator|++
operator|,
name|l1
operator|++
control|)
block|{
comment|/* Allocate a L1 page table */
name|va
operator|=
operator|(
name|vm_offset_t
operator|)
name|contigmalloc
argument_list|(
name|L1_TABLE_SIZE
argument_list|,
name|M_VMPMAP
argument_list|,
literal|0
argument_list|,
literal|0x0
argument_list|,
literal|0xffffffff
argument_list|,
name|L1_TABLE_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|va
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"Cannot allocate L1 KVM"
argument_list|)
expr_stmt|;
name|eva
operator|=
name|va
operator|+
name|L1_TABLE_SIZE
expr_stmt|;
name|pl1pt
operator|=
operator|(
name|pd_entry_t
operator|*
operator|)
name|va
expr_stmt|;
while|while
condition|(
name|va
operator|<
name|eva
condition|)
block|{
name|l2b
operator|=
name|pmap_get_l2_bucket
argument_list|(
name|pmap_kernel
argument_list|()
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|ptep
operator|=
operator|&
name|l2b
operator|->
name|l2b_kva
index|[
name|l2pte_index
argument_list|(
name|va
argument_list|)
index|]
expr_stmt|;
name|pte
operator|=
operator|*
name|ptep
expr_stmt|;
name|pte
operator|=
operator|(
name|pte
operator|&
operator|~
name|L2_S_CACHE_MASK
operator|)
operator||
name|pte_l2_s_cache_mode_pt
expr_stmt|;
operator|*
name|ptep
operator|=
name|pte
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|ptep
argument_list|)
expr_stmt|;
name|cpu_tlb_flushD_SE
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|va
operator|+=
name|PAGE_SIZE
expr_stmt|;
block|}
name|pmap_init_l1
argument_list|(
name|l1
argument_list|,
name|pl1pt
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"pmap_postinit: Allocated %d static L1 descriptor tables\n"
argument_list|,
name|needed
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * This is used to stuff certain critical values into the PCB where they  * can be accessed quickly from cpu_switch() et al.  */
end_comment

begin_function
name|void
name|pmap_set_pcb_pagedir
parameter_list|(
name|pmap_t
name|pm
parameter_list|,
name|struct
name|pcb
modifier|*
name|pcb
parameter_list|)
block|{
name|struct
name|l2_bucket
modifier|*
name|l2b
decl_stmt|;
name|pcb
operator|->
name|pcb_pagedir
operator|=
name|pm
operator|->
name|pm_l1
operator|->
name|l1_physaddr
expr_stmt|;
name|pcb
operator|->
name|pcb_dacr
operator|=
operator|(
name|DOMAIN_CLIENT
operator|<<
operator|(
name|PMAP_DOMAIN_KERNEL
operator|*
literal|2
operator|)
operator|)
operator||
operator|(
name|DOMAIN_CLIENT
operator|<<
operator|(
name|pm
operator|->
name|pm_domain
operator|*
literal|2
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|vector_page
operator|<
name|KERNBASE
condition|)
block|{
name|pcb
operator|->
name|pcb_pl1vec
operator|=
operator|&
name|pm
operator|->
name|pm_l1
operator|->
name|l1_kva
index|[
name|L1_IDX
argument_list|(
name|vector_page
argument_list|)
index|]
expr_stmt|;
name|l2b
operator|=
name|pmap_get_l2_bucket
argument_list|(
name|pm
argument_list|,
name|vector_page
argument_list|)
expr_stmt|;
name|pcb
operator|->
name|pcb_l1vec
operator|=
name|l2b
operator|->
name|l2b_phys
operator||
name|L1_C_PROTO
operator||
name|L1_C_DOM
argument_list|(
name|pm
operator|->
name|pm_domain
argument_list|)
operator||
name|L1_C_DOM
argument_list|(
name|PMAP_DOMAIN_KERNEL
argument_list|)
expr_stmt|;
block|}
else|else
name|pcb
operator|->
name|pcb_pl1vec
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pmap_activate
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|pmap_t
name|pm
decl_stmt|;
name|struct
name|pcb
modifier|*
name|pcb
decl_stmt|;
name|pm
operator|=
name|vmspace_pmap
argument_list|(
name|td
operator|->
name|td_proc
operator|->
name|p_vmspace
argument_list|)
expr_stmt|;
name|pcb
operator|=
name|td
operator|->
name|td_pcb
expr_stmt|;
name|critical_enter
argument_list|()
expr_stmt|;
name|pmap_set_pcb_pagedir
argument_list|(
name|pm
argument_list|,
name|pcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|==
name|curthread
condition|)
block|{
name|u_int
name|cur_dacr
decl_stmt|,
name|cur_ttb
decl_stmt|;
asm|__asm __volatile("mrc p15, 0, %0, c2, c0, 0" : "=r"(cur_ttb));
asm|__asm __volatile("mrc p15, 0, %0, c3, c0, 0" : "=r"(cur_dacr));
name|cur_ttb
operator|&=
operator|~
operator|(
name|L1_TABLE_SIZE
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|cur_ttb
operator|==
operator|(
name|u_int
operator|)
name|pcb
operator|->
name|pcb_pagedir
operator|&&
name|cur_dacr
operator|==
name|pcb
operator|->
name|pcb_dacr
condition|)
block|{
comment|/* 			 * No need to switch address spaces. 			 */
name|critical_exit
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* 		 * We MUST, I repeat, MUST fix up the L1 entry corresponding 		 * to 'vector_page' in the incoming L1 table before switching 		 * to it otherwise subsequent interrupts/exceptions (including 		 * domain faults!) will jump into hyperspace. 		 */
if|if
condition|(
name|pcb
operator|->
name|pcb_pl1vec
condition|)
block|{
operator|*
name|pcb
operator|->
name|pcb_pl1vec
operator|=
name|pcb
operator|->
name|pcb_l1vec
expr_stmt|;
block|}
name|cpu_domains
argument_list|(
name|pcb
operator|->
name|pcb_dacr
argument_list|)
expr_stmt|;
name|cpu_setttb
argument_list|(
name|pcb
operator|->
name|pcb_pagedir
argument_list|)
expr_stmt|;
block|}
name|critical_exit
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pmap_set_pt_cache_mode
parameter_list|(
name|pd_entry_t
modifier|*
name|kl1
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|pd_entry_t
modifier|*
name|pdep
decl_stmt|,
name|pde
decl_stmt|;
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|,
name|pte
decl_stmt|;
name|vm_offset_t
name|pa
decl_stmt|;
name|int
name|rv
init|=
literal|0
decl_stmt|;
comment|/* 	 * Make sure the descriptor itself has the correct cache mode 	 */
name|pdep
operator|=
operator|&
name|kl1
index|[
name|L1_IDX
argument_list|(
name|va
argument_list|)
index|]
expr_stmt|;
name|pde
operator|=
operator|*
name|pdep
expr_stmt|;
if|if
condition|(
name|l1pte_section_p
argument_list|(
name|pde
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|pde
operator|&
name|L1_S_CACHE_MASK
operator|)
operator|!=
name|pte_l1_s_cache_mode_pt
condition|)
block|{
operator|*
name|pdep
operator|=
operator|(
name|pde
operator|&
operator|~
name|L1_S_CACHE_MASK
operator|)
operator||
name|pte_l1_s_cache_mode_pt
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|pdep
argument_list|)
expr_stmt|;
name|rv
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|pa
operator|=
call|(
name|vm_paddr_t
call|)
argument_list|(
name|pde
operator|&
name|L1_C_ADDR_MASK
argument_list|)
expr_stmt|;
name|ptep
operator|=
operator|(
name|pt_entry_t
operator|*
operator|)
name|kernel_pt_lookup
argument_list|(
name|pa
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptep
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"pmap_bootstrap: No L2 for L2 @ va %p\n"
argument_list|,
name|ptep
argument_list|)
expr_stmt|;
name|ptep
operator|=
operator|&
name|ptep
index|[
name|l2pte_index
argument_list|(
name|va
argument_list|)
index|]
expr_stmt|;
name|pte
operator|=
operator|*
name|ptep
expr_stmt|;
if|if
condition|(
operator|(
name|pte
operator|&
name|L2_S_CACHE_MASK
operator|)
operator|!=
name|pte_l2_s_cache_mode_pt
condition|)
block|{
operator|*
name|ptep
operator|=
operator|(
name|pte
operator|&
operator|~
name|L2_S_CACHE_MASK
operator|)
operator||
name|pte_l2_s_cache_mode_pt
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|ptep
argument_list|)
expr_stmt|;
name|rv
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pmap_alloc_specials
parameter_list|(
name|vm_offset_t
modifier|*
name|availp
parameter_list|,
name|int
name|pages
parameter_list|,
name|vm_offset_t
modifier|*
name|vap
parameter_list|,
name|pt_entry_t
modifier|*
modifier|*
name|ptep
parameter_list|)
block|{
name|vm_offset_t
name|va
init|=
operator|*
name|availp
decl_stmt|;
name|struct
name|l2_bucket
modifier|*
name|l2b
decl_stmt|;
if|if
condition|(
name|ptep
condition|)
block|{
name|l2b
operator|=
name|pmap_get_l2_bucket
argument_list|(
name|pmap_kernel
argument_list|()
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|l2b
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"pmap_alloc_specials: no l2b for 0x%x"
argument_list|,
name|va
argument_list|)
expr_stmt|;
operator|*
name|ptep
operator|=
operator|&
name|l2b
operator|->
name|l2b_kva
index|[
name|l2pte_index
argument_list|(
name|va
argument_list|)
index|]
expr_stmt|;
block|}
operator|*
name|vap
operator|=
name|va
expr_stmt|;
operator|*
name|availp
operator|=
name|va
operator|+
operator|(
name|PAGE_SIZE
operator|*
name|pages
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Bootstrap the system enough to run with virtual memory.  *  *	On the arm this is called after mapping has already been enabled  *	and just syncs the pmap module with what has already been done.  *	[We can't call it easily with mapping off since the kernel is not  *	mapped with PA == VA, hence we would have to relocate every address  *	from the linked base (virtual) address "KERNBASE" to the actual  *	(physical) address starting relative to 0]  */
end_comment

begin_define
define|#
directive|define
name|PMAP_STATIC_L2_SIZE
value|16
end_define

begin_function
name|void
name|pmap_bootstrap
parameter_list|(
name|vm_offset_t
name|firstaddr
parameter_list|,
name|vm_offset_t
name|lastaddr
parameter_list|,
name|struct
name|pv_addr
modifier|*
name|l1pt
parameter_list|)
block|{
specifier|static
name|struct
name|l1_ttable
name|static_l1
decl_stmt|;
specifier|static
name|struct
name|l2_dtable
name|static_l2
index|[
name|PMAP_STATIC_L2_SIZE
index|]
decl_stmt|;
name|struct
name|l1_ttable
modifier|*
name|l1
init|=
operator|&
name|static_l1
decl_stmt|;
name|struct
name|l2_dtable
modifier|*
name|l2
decl_stmt|;
name|struct
name|l2_bucket
modifier|*
name|l2b
decl_stmt|;
name|pd_entry_t
name|pde
decl_stmt|;
name|pd_entry_t
modifier|*
name|kernel_l1pt
init|=
operator|(
name|pd_entry_t
operator|*
operator|)
name|l1pt
operator|->
name|pv_va
decl_stmt|;
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|;
name|vm_paddr_t
name|pa
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
name|vm_size_t
name|size
decl_stmt|;
name|int
name|l1idx
decl_stmt|,
name|l2idx
decl_stmt|,
name|l2next
init|=
literal|0
decl_stmt|;
name|PDEBUG
argument_list|(
literal|1
argument_list|,
name|printf
argument_list|(
literal|"firstaddr = %08x, lastaddr = %08x\n"
argument_list|,
name|firstaddr
argument_list|,
name|lastaddr
argument_list|)
argument_list|)
expr_stmt|;
name|virtual_avail
operator|=
name|firstaddr
expr_stmt|;
name|kernel_pmap
operator|->
name|pm_l1
operator|=
name|l1
expr_stmt|;
name|kernel_l1pa
operator|=
name|l1pt
operator|->
name|pv_pa
expr_stmt|;
comment|/* 	 * Scan the L1 translation table created by initarm() and create 	 * the required metadata for all valid mappings found in it. 	 */
for|for
control|(
name|l1idx
operator|=
literal|0
init|;
name|l1idx
operator|<
operator|(
name|L1_TABLE_SIZE
operator|/
sizeof|sizeof
argument_list|(
name|pd_entry_t
argument_list|)
operator|)
condition|;
name|l1idx
operator|++
control|)
block|{
name|pde
operator|=
name|kernel_l1pt
index|[
name|l1idx
index|]
expr_stmt|;
comment|/* 		 * We're only interested in Coarse mappings. 		 * pmap_extract() can deal with section mappings without 		 * recourse to checking L2 metadata. 		 */
if|if
condition|(
operator|(
name|pde
operator|&
name|L1_TYPE_MASK
operator|)
operator|!=
name|L1_TYPE_C
condition|)
continue|continue;
comment|/* 		 * Lookup the KVA of this L2 descriptor table 		 */
name|pa
operator|=
call|(
name|vm_paddr_t
call|)
argument_list|(
name|pde
operator|&
name|L1_C_ADDR_MASK
argument_list|)
expr_stmt|;
name|ptep
operator|=
operator|(
name|pt_entry_t
operator|*
operator|)
name|kernel_pt_lookup
argument_list|(
name|pa
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptep
operator|==
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"pmap_bootstrap: No L2 for va 0x%x, pa 0x%lx"
argument_list|,
operator|(
name|u_int
operator|)
name|l1idx
operator|<<
name|L1_S_SHIFT
argument_list|,
operator|(
name|long
name|unsigned
name|int
operator|)
name|pa
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Fetch the associated L2 metadata structure. 		 * Allocate a new one if necessary. 		 */
if|if
condition|(
operator|(
name|l2
operator|=
name|kernel_pmap
operator|->
name|pm_l2
index|[
name|L2_IDX
argument_list|(
name|l1idx
argument_list|)
index|]
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|l2next
operator|==
name|PMAP_STATIC_L2_SIZE
condition|)
name|panic
argument_list|(
literal|"pmap_bootstrap: out of static L2s"
argument_list|)
expr_stmt|;
name|kernel_pmap
operator|->
name|pm_l2
index|[
name|L2_IDX
argument_list|(
name|l1idx
argument_list|)
index|]
operator|=
name|l2
operator|=
operator|&
name|static_l2
index|[
name|l2next
operator|++
index|]
expr_stmt|;
block|}
comment|/* 		 * One more L1 slot tracked... 		 */
name|l2
operator|->
name|l2_occupancy
operator|++
expr_stmt|;
comment|/* 		 * Fill in the details of the L2 descriptor in the 		 * appropriate bucket. 		 */
name|l2b
operator|=
operator|&
name|l2
operator|->
name|l2_bucket
index|[
name|L2_BUCKET
argument_list|(
name|l1idx
argument_list|)
index|]
expr_stmt|;
name|l2b
operator|->
name|l2b_kva
operator|=
name|ptep
expr_stmt|;
name|l2b
operator|->
name|l2b_phys
operator|=
name|pa
expr_stmt|;
name|l2b
operator|->
name|l2b_l1idx
operator|=
name|l1idx
expr_stmt|;
comment|/* 		 * Establish an initial occupancy count for this descriptor 		 */
for|for
control|(
name|l2idx
operator|=
literal|0
init|;
name|l2idx
operator|<
operator|(
name|L2_TABLE_SIZE_REAL
operator|/
sizeof|sizeof
argument_list|(
name|pt_entry_t
argument_list|)
operator|)
condition|;
name|l2idx
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ptep
index|[
name|l2idx
index|]
operator|&
name|L2_TYPE_MASK
operator|)
operator|!=
name|L2_TYPE_INV
condition|)
block|{
name|l2b
operator|->
name|l2b_occupancy
operator|++
expr_stmt|;
block|}
block|}
comment|/* 		 * Make sure the descriptor itself has the correct cache mode. 		 * If not, fix it, but whine about the problem. Port-meisters 		 * should consider this a clue to fix up their initarm() 		 * function. :) 		 */
if|if
condition|(
name|pmap_set_pt_cache_mode
argument_list|(
name|kernel_l1pt
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|ptep
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"pmap_bootstrap: WARNING! wrong cache mode for "
literal|"L2 pte @ %p\n"
argument_list|,
name|ptep
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Ensure the primary (kernel) L1 has the correct cache mode for 	 * a page table. Bitch if it is not correctly set. 	 */
for|for
control|(
name|va
operator|=
operator|(
name|vm_offset_t
operator|)
name|kernel_l1pt
init|;
name|va
operator|<
operator|(
operator|(
name|vm_offset_t
operator|)
name|kernel_l1pt
operator|+
name|L1_TABLE_SIZE
operator|)
condition|;
name|va
operator|+=
name|PAGE_SIZE
control|)
block|{
if|if
condition|(
name|pmap_set_pt_cache_mode
argument_list|(
name|kernel_l1pt
argument_list|,
name|va
argument_list|)
condition|)
name|printf
argument_list|(
literal|"pmap_bootstrap: WARNING! wrong cache mode for "
literal|"primary L1 @ 0x%x\n"
argument_list|,
name|va
argument_list|)
expr_stmt|;
block|}
name|cpu_dcache_wbinv_all
argument_list|()
expr_stmt|;
name|cpu_l2cache_wbinv_all
argument_list|()
expr_stmt|;
name|cpu_tlb_flushID
argument_list|()
expr_stmt|;
name|cpu_cpwait
argument_list|()
expr_stmt|;
name|PMAP_LOCK_INIT
argument_list|(
name|kernel_pmap
argument_list|)
expr_stmt|;
name|CPU_FILL
argument_list|(
operator|&
name|kernel_pmap
operator|->
name|pm_active
argument_list|)
expr_stmt|;
name|kernel_pmap
operator|->
name|pm_domain
operator|=
name|PMAP_DOMAIN_KERNEL
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|kernel_pmap
operator|->
name|pm_pvlist
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize the global pv list lock. 	 */
name|rw_init_flags
argument_list|(
operator|&
name|pvh_global_lock
argument_list|,
literal|"pmap pv global"
argument_list|,
name|RW_RECURSE
argument_list|)
expr_stmt|;
comment|/* 	 * Reserve some special page table entries/VA space for temporary 	 * mapping of pages. 	 */
name|pmap_alloc_specials
argument_list|(
operator|&
name|virtual_avail
argument_list|,
literal|1
argument_list|,
operator|&
name|csrcp
argument_list|,
operator|&
name|csrc_pte
argument_list|)
expr_stmt|;
name|pmap_set_pt_cache_mode
argument_list|(
name|kernel_l1pt
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|csrc_pte
argument_list|)
expr_stmt|;
name|pmap_alloc_specials
argument_list|(
operator|&
name|virtual_avail
argument_list|,
literal|1
argument_list|,
operator|&
name|cdstp
argument_list|,
operator|&
name|cdst_pte
argument_list|)
expr_stmt|;
name|pmap_set_pt_cache_mode
argument_list|(
name|kernel_l1pt
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|cdst_pte
argument_list|)
expr_stmt|;
name|size
operator|=
operator|(
operator|(
name|lastaddr
operator|-
name|pmap_curmaxkvaddr
operator|)
operator|+
name|L1_S_OFFSET
operator|)
operator|/
name|L1_S_SIZE
expr_stmt|;
name|pmap_alloc_specials
argument_list|(
operator|&
name|virtual_avail
argument_list|,
name|round_page
argument_list|(
name|size
operator|*
name|L2_TABLE_SIZE_REAL
argument_list|)
operator|/
name|PAGE_SIZE
argument_list|,
operator|&
name|pmap_kernel_l2ptp_kva
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|size
operator|=
operator|(
name|size
operator|+
operator|(
name|L2_BUCKET_SIZE
operator|-
literal|1
operator|)
operator|)
operator|/
name|L2_BUCKET_SIZE
expr_stmt|;
name|pmap_alloc_specials
argument_list|(
operator|&
name|virtual_avail
argument_list|,
name|round_page
argument_list|(
name|size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|l2_dtable
argument_list|)
argument_list|)
operator|/
name|PAGE_SIZE
argument_list|,
operator|&
name|pmap_kernel_l2dtable_kva
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|pmap_alloc_specials
argument_list|(
operator|&
name|virtual_avail
argument_list|,
literal|1
argument_list|,
operator|(
name|vm_offset_t
operator|*
operator|)
operator|&
name|_tmppt
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|pmap_alloc_specials
argument_list|(
operator|&
name|virtual_avail
argument_list|,
name|MAXDUMPPGS
argument_list|,
operator|(
name|vm_offset_t
operator|*
operator|)
operator|&
name|crashdumpmap
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|l1_list
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|l1_lru_list
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|l1_lru_lock
argument_list|,
literal|"l1 list lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|pmap_init_l1
argument_list|(
name|l1
argument_list|,
name|kernel_l1pt
argument_list|)
expr_stmt|;
name|cpu_dcache_wbinv_all
argument_list|()
expr_stmt|;
name|cpu_l2cache_wbinv_all
argument_list|()
expr_stmt|;
name|virtual_avail
operator|=
name|round_page
argument_list|(
name|virtual_avail
argument_list|)
expr_stmt|;
name|virtual_end
operator|=
name|lastaddr
expr_stmt|;
name|kernel_vm_end
operator|=
name|pmap_curmaxkvaddr
expr_stmt|;
name|arm_nocache_startaddr
operator|=
name|lastaddr
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|cmtx
argument_list|,
literal|"TMP mappings mtx"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|pmap_set_pcb_pagedir
argument_list|(
name|kernel_pmap
argument_list|,
name|thread0
operator|.
name|td_pcb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/***************************************************  * Pmap allocation/deallocation routines.  ***************************************************/
end_comment

begin_comment
comment|/*  * Release any resources held by the given physical map.  * Called when a pmap initialized by pmap_pinit is being released.  * Should only be called if the map contains no valid mappings.  */
end_comment

begin_function
name|void
name|pmap_release
parameter_list|(
name|pmap_t
name|pmap
parameter_list|)
block|{
name|struct
name|pcb
modifier|*
name|pcb
decl_stmt|;
name|cpu_idcache_wbinv_all
argument_list|()
expr_stmt|;
name|cpu_l2cache_wbinv_all
argument_list|()
expr_stmt|;
name|cpu_tlb_flushID
argument_list|()
expr_stmt|;
name|cpu_cpwait
argument_list|()
expr_stmt|;
if|if
condition|(
name|vector_page
operator|<
name|KERNBASE
condition|)
block|{
name|struct
name|pcb
modifier|*
name|curpcb
init|=
name|PCPU_GET
argument_list|(
name|curpcb
argument_list|)
decl_stmt|;
name|pcb
operator|=
name|thread0
operator|.
name|td_pcb
expr_stmt|;
if|if
condition|(
name|pmap_is_current
argument_list|(
name|pmap
argument_list|)
condition|)
block|{
comment|/* 			 * Frob the L1 entry corresponding to the vector 			 * page so that it contains the kernel pmap's domain 			 * number. This will ensure pmap_remove() does not 			 * pull the current vector page out from under us. 			 */
name|critical_enter
argument_list|()
expr_stmt|;
operator|*
name|pcb
operator|->
name|pcb_pl1vec
operator|=
name|pcb
operator|->
name|pcb_l1vec
expr_stmt|;
name|cpu_domains
argument_list|(
name|pcb
operator|->
name|pcb_dacr
argument_list|)
expr_stmt|;
name|cpu_setttb
argument_list|(
name|pcb
operator|->
name|pcb_pagedir
argument_list|)
expr_stmt|;
name|critical_exit
argument_list|()
expr_stmt|;
block|}
name|pmap_remove
argument_list|(
name|pmap
argument_list|,
name|vector_page
argument_list|,
name|vector_page
operator|+
name|PAGE_SIZE
argument_list|)
expr_stmt|;
comment|/* 		 * Make sure cpu_switch(), et al, DTRT. This is safe to do 		 * since this process has no remaining mappings of its own. 		 */
name|curpcb
operator|->
name|pcb_pl1vec
operator|=
name|pcb
operator|->
name|pcb_pl1vec
expr_stmt|;
name|curpcb
operator|->
name|pcb_l1vec
operator|=
name|pcb
operator|->
name|pcb_l1vec
expr_stmt|;
name|curpcb
operator|->
name|pcb_dacr
operator|=
name|pcb
operator|->
name|pcb_dacr
expr_stmt|;
name|curpcb
operator|->
name|pcb_pagedir
operator|=
name|pcb
operator|->
name|pcb_pagedir
expr_stmt|;
block|}
name|pmap_free_l1
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|PMAP_LOCK_DESTROY
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|"pmap_release()\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Helper function for pmap_grow_l2_bucket()  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|pmap_grow_map
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|pt_entry_t
name|cache_mode
parameter_list|,
name|vm_paddr_t
modifier|*
name|pap
parameter_list|)
block|{
name|struct
name|l2_bucket
modifier|*
name|l2b
decl_stmt|;
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|;
name|vm_paddr_t
name|pa
decl_stmt|;
name|struct
name|vm_page
modifier|*
name|pg
decl_stmt|;
name|pg
operator|=
name|vm_page_alloc
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|VM_ALLOC_NOOBJ
operator||
name|VM_ALLOC_WIRED
argument_list|)
expr_stmt|;
if|if
condition|(
name|pg
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|pa
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|pg
argument_list|)
expr_stmt|;
if|if
condition|(
name|pap
condition|)
operator|*
name|pap
operator|=
name|pa
expr_stmt|;
name|l2b
operator|=
name|pmap_get_l2_bucket
argument_list|(
name|pmap_kernel
argument_list|()
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|ptep
operator|=
operator|&
name|l2b
operator|->
name|l2b_kva
index|[
name|l2pte_index
argument_list|(
name|va
argument_list|)
index|]
expr_stmt|;
operator|*
name|ptep
operator|=
name|L2_S_PROTO
operator||
name|pa
operator||
name|cache_mode
expr_stmt|;
name|pmap_set_prot
argument_list|(
name|ptep
argument_list|,
name|VM_PROT_READ
operator||
name|VM_PROT_WRITE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|ptep
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This is the same as pmap_alloc_l2_bucket(), except that it is only  * used by pmap_growkernel().  */
end_comment

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|l2_bucket
operator|*
name|pmap_grow_l2_bucket
argument_list|(
argument|pmap_t pm
argument_list|,
argument|vm_offset_t va
argument_list|)
block|{ 	struct
name|l2_dtable
operator|*
name|l2
block|; 	struct
name|l2_bucket
operator|*
name|l2b
block|; 	struct
name|l1_ttable
operator|*
name|l1
block|;
name|pd_entry_t
operator|*
name|pl1pd
block|;
name|u_short
name|l1idx
block|;
name|vm_offset_t
name|nva
block|;
name|l1idx
operator|=
name|L1_IDX
argument_list|(
name|va
argument_list|)
block|;
if|if
condition|(
operator|(
name|l2
operator|=
name|pm
operator|->
name|pm_l2
index|[
name|L2_IDX
argument_list|(
name|l1idx
argument_list|)
index|]
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * No mapping at this address, as there is 		 * no entry in the L1 table. 		 * Need to allocate a new l2_dtable. 		 */
name|nva
operator|=
name|pmap_kernel_l2dtable_kva
expr_stmt|;
if|if
condition|(
operator|(
name|nva
operator|&
name|PAGE_MASK
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Need to allocate a backing page 			 */
if|if
condition|(
name|pmap_grow_map
argument_list|(
name|nva
argument_list|,
name|pte_l2_s_cache_mode
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|l2
operator|=
operator|(
expr|struct
name|l2_dtable
operator|*
operator|)
name|nva
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|nva
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|l2_dtable
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|(
name|nva
operator|&
name|PAGE_MASK
operator|)
operator|<
operator|(
name|pmap_kernel_l2dtable_kva
operator|&
name|PAGE_MASK
operator|)
condition|)
block|{
comment|/* 			 * The new l2_dtable straddles a page boundary. 			 * Map in another page to cover it. 			 */
if|if
condition|(
name|pmap_grow_map
argument_list|(
name|nva
argument_list|,
name|pte_l2_s_cache_mode
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_if

begin_expr_stmt
name|pmap_kernel_l2dtable_kva
operator|=
name|nva
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 		 * Link it into the parent pmap 		 */
end_comment

begin_expr_stmt
name|pm
operator|->
name|pm_l2
index|[
name|L2_IDX
argument_list|(
name|l1idx
argument_list|)
index|]
operator|=
name|l2
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|memset
argument_list|(
name|l2
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|l2
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  	l2b
operator|=
operator|&
name|l2
operator|->
name|l2_bucket
index|[
name|L2_BUCKET
argument_list|(
name|l1idx
argument_list|)
index|]
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	 * Fetch pointer to the L2 page table associated with the address. 	 */
end_comment

begin_if
if|if
condition|(
name|l2b
operator|->
name|l2b_kva
operator|==
name|NULL
condition|)
block|{
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|;
comment|/* 		 * No L2 page table has been allocated. Chances are, this 		 * is because we just allocated the l2_dtable, above. 		 */
name|nva
operator|=
name|pmap_kernel_l2ptp_kva
expr_stmt|;
name|ptep
operator|=
operator|(
name|pt_entry_t
operator|*
operator|)
name|nva
expr_stmt|;
if|if
condition|(
operator|(
name|nva
operator|&
name|PAGE_MASK
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Need to allocate a backing page 			 */
if|if
condition|(
name|pmap_grow_map
argument_list|(
name|nva
argument_list|,
name|pte_l2_s_cache_mode_pt
argument_list|,
operator|&
name|pmap_kernel_l2ptp_phys
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|memset
argument_list|(
name|ptep
argument_list|,
literal|0
argument_list|,
name|L2_TABLE_SIZE_REAL
argument_list|)
expr_stmt|;
name|l2
operator|->
name|l2_occupancy
operator|++
expr_stmt|;
name|l2b
operator|->
name|l2b_kva
operator|=
name|ptep
expr_stmt|;
name|l2b
operator|->
name|l2b_l1idx
operator|=
name|l1idx
expr_stmt|;
name|l2b
operator|->
name|l2b_phys
operator|=
name|pmap_kernel_l2ptp_phys
expr_stmt|;
name|pmap_kernel_l2ptp_kva
operator|+=
name|L2_TABLE_SIZE_REAL
expr_stmt|;
name|pmap_kernel_l2ptp_phys
operator|+=
name|L2_TABLE_SIZE_REAL
expr_stmt|;
block|}
end_if

begin_comment
comment|/* Distribute new L1 entry to all other L1s */
end_comment

begin_macro
name|SLIST_FOREACH
argument_list|(
argument|l1
argument_list|,
argument|&l1_list
argument_list|,
argument|l1_link
argument_list|)
end_macro

begin_block
block|{
name|pl1pd
operator|=
operator|&
name|l1
operator|->
name|l1_kva
index|[
name|L1_IDX
argument_list|(
name|va
argument_list|)
index|]
expr_stmt|;
operator|*
name|pl1pd
operator|=
name|l2b
operator|->
name|l2b_phys
operator||
name|L1_C_DOM
argument_list|(
name|PMAP_DOMAIN_KERNEL
argument_list|)
operator||
name|L1_C_PROTO
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|pl1pd
argument_list|)
expr_stmt|;
block|}
end_block

begin_return
return|return
operator|(
name|l2b
operator|)
return|;
end_return

begin_comment
unit|}
comment|/*  * grow the number of kernel page table entries, if needed  */
end_comment

begin_macro
unit|void
name|pmap_growkernel
argument_list|(
argument|vm_offset_t addr
argument_list|)
end_macro

begin_block
block|{
name|pmap_t
name|kpm
init|=
name|pmap_kernel
argument_list|()
decl_stmt|;
if|if
condition|(
name|addr
operator|<=
name|pmap_curmaxkvaddr
condition|)
return|return;
comment|/* we are OK */
comment|/* 	 * whoops!   we need to add kernel PTPs 	 */
comment|/* Map 1MB at a time */
for|for
control|(
init|;
name|pmap_curmaxkvaddr
operator|<
name|addr
condition|;
name|pmap_curmaxkvaddr
operator|+=
name|L1_S_SIZE
control|)
name|pmap_grow_l2_bucket
argument_list|(
name|kpm
argument_list|,
name|pmap_curmaxkvaddr
argument_list|)
expr_stmt|;
comment|/* 	 * flush out the cache, expensive but growkernel will happen so 	 * rarely 	 */
name|cpu_dcache_wbinv_all
argument_list|()
expr_stmt|;
name|cpu_l2cache_wbinv_all
argument_list|()
expr_stmt|;
name|cpu_tlb_flushD
argument_list|()
expr_stmt|;
name|cpu_cpwait
argument_list|()
expr_stmt|;
name|kernel_vm_end
operator|=
name|pmap_curmaxkvaddr
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Remove all pages from specified address space  * this aids process exit speeds.  Also, this code  * is special cased for current process only, but  * can have the more generic (and slightly slower)  * mode enabled.  This is much faster than pmap_remove  * in the case of running down an entire address space.  */
end_comment

begin_function
name|void
name|pmap_remove_pages
parameter_list|(
name|pmap_t
name|pmap
parameter_list|)
block|{
name|struct
name|pv_entry
modifier|*
name|pv
decl_stmt|,
modifier|*
name|npv
decl_stmt|;
name|struct
name|l2_bucket
modifier|*
name|l2b
init|=
name|NULL
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|pt_entry_t
modifier|*
name|pt
decl_stmt|;
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
for|for
control|(
name|pv
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvlist
argument_list|)
init|;
name|pv
condition|;
name|pv
operator|=
name|npv
control|)
block|{
if|if
condition|(
name|pv
operator|->
name|pv_flags
operator|&
name|PVF_WIRED
condition|)
block|{
comment|/* Cannot remove wired pages now. */
name|npv
operator|=
name|TAILQ_NEXT
argument_list|(
name|pv
argument_list|,
name|pv_plist
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|--
expr_stmt|;
name|l2b
operator|=
name|pmap_get_l2_bucket
argument_list|(
name|pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|l2b
operator|!=
name|NULL
argument_list|,
operator|(
literal|"No L2 bucket in pmap_remove_pages"
operator|)
argument_list|)
expr_stmt|;
name|pt
operator|=
operator|&
name|l2b
operator|->
name|l2b_kva
index|[
name|l2pte_index
argument_list|(
name|pv
operator|->
name|pv_va
argument_list|)
index|]
expr_stmt|;
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
operator|*
name|pt
operator|&
name|L2_ADDR_MASK
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|m
operator|>=
name|KERNBASE
argument_list|,
operator|(
literal|"Trying to access non-existent page va %x pte %x"
operator|,
name|pv
operator|->
name|pv_va
operator|,
operator|*
name|pt
operator|)
argument_list|)
expr_stmt|;
operator|*
name|pt
operator|=
literal|0
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|pt
argument_list|)
expr_stmt|;
name|npv
operator|=
name|TAILQ_NEXT
argument_list|(
name|pv
argument_list|,
name|pv_plist
argument_list|)
expr_stmt|;
name|pmap_nuke_pv
argument_list|(
name|m
argument_list|,
name|pmap
argument_list|,
name|pv
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|)
condition|)
name|vm_page_aflag_clear
argument_list|(
name|m
argument_list|,
name|PGA_WRITEABLE
argument_list|)
expr_stmt|;
name|pmap_free_pv_entry
argument_list|(
name|pv
argument_list|)
expr_stmt|;
name|pmap_free_l2_bucket
argument_list|(
name|pmap
argument_list|,
name|l2b
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|cpu_tlb_flushID
argument_list|()
expr_stmt|;
name|cpu_cpwait
argument_list|()
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/***************************************************  * Low level mapping routines.....  ***************************************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ARM_HAVE_SUPERSECTIONS
end_ifdef

begin_comment
comment|/* Map a super section into the KVA. */
end_comment

begin_function
name|void
name|pmap_kenter_supersection
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|uint64_t
name|pa
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|pd_entry_t
name|pd
init|=
name|L1_S_PROTO
operator||
name|L1_S_SUPERSEC
operator||
operator|(
name|pa
operator|&
name|L1_SUP_FRAME
operator|)
operator||
operator|(
operator|(
operator|(
name|pa
operator|>>
literal|32
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|20
operator|)
operator||
name|L1_S_PROT
argument_list|(
name|PTE_KERNEL
argument_list|,
name|VM_PROT_READ
operator||
name|VM_PROT_WRITE
argument_list|)
operator||
name|L1_S_DOM
argument_list|(
name|PMAP_DOMAIN_KERNEL
argument_list|)
decl_stmt|;
name|struct
name|l1_ttable
modifier|*
name|l1
decl_stmt|;
name|vm_offset_t
name|va0
decl_stmt|,
name|va_end
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
operator|(
name|va
operator||
name|pa
operator|)
operator|&
name|L1_SUP_OFFSET
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"Not a valid super section mapping"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_CACHE
condition|)
name|pd
operator||=
name|pte_l1_s_cache_mode
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|SECTION_PT
condition|)
name|pd
operator||=
name|pte_l1_s_cache_mode_pt
expr_stmt|;
name|va0
operator|=
name|va
operator|&
name|L1_SUP_FRAME
expr_stmt|;
name|va_end
operator|=
name|va
operator|+
name|L1_SUP_SIZE
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|l1
argument_list|,
argument|&l1_list
argument_list|,
argument|l1_link
argument_list|)
block|{
name|va
operator|=
name|va0
expr_stmt|;
for|for
control|(
init|;
name|va
operator|<
name|va_end
condition|;
name|va
operator|+=
name|L1_S_SIZE
control|)
block|{
name|l1
operator|->
name|l1_kva
index|[
name|L1_IDX
argument_list|(
name|va
argument_list|)
index|]
operator|=
name|pd
expr_stmt|;
name|PTE_SYNC
argument_list|(
operator|&
name|l1
operator|->
name|l1_kva
index|[
name|L1_IDX
argument_list|(
name|va
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Map a section into the KVA. */
end_comment

begin_function
name|void
name|pmap_kenter_section
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|vm_offset_t
name|pa
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|pd_entry_t
name|pd
init|=
name|L1_S_PROTO
operator||
name|pa
operator||
name|L1_S_PROT
argument_list|(
name|PTE_KERNEL
argument_list|,
name|VM_PROT_READ
operator||
name|VM_PROT_WRITE
argument_list|)
operator||
name|L1_S_DOM
argument_list|(
name|PMAP_DOMAIN_KERNEL
argument_list|)
decl_stmt|;
name|struct
name|l1_ttable
modifier|*
name|l1
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
operator|(
name|va
operator||
name|pa
operator|)
operator|&
name|L1_S_OFFSET
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"Not a valid section mapping"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_CACHE
condition|)
name|pd
operator||=
name|pte_l1_s_cache_mode
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|SECTION_PT
condition|)
name|pd
operator||=
name|pte_l1_s_cache_mode_pt
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|l1
argument_list|,
argument|&l1_list
argument_list|,
argument|l1_link
argument_list|)
block|{
name|l1
operator|->
name|l1_kva
index|[
name|L1_IDX
argument_list|(
name|va
argument_list|)
index|]
operator|=
name|pd
expr_stmt|;
name|PTE_SYNC
argument_list|(
operator|&
name|l1
operator|->
name|l1_kva
index|[
name|L1_IDX
argument_list|(
name|va
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Make a temporary mapping for a physical address.  This is only intended  * to be used for panic dumps.  */
end_comment

begin_function
name|void
modifier|*
name|pmap_kenter_temp
parameter_list|(
name|vm_paddr_t
name|pa
parameter_list|,
name|int
name|i
parameter_list|)
block|{
name|vm_offset_t
name|va
decl_stmt|;
name|va
operator|=
operator|(
name|vm_offset_t
operator|)
name|crashdumpmap
operator|+
operator|(
name|i
operator|*
name|PAGE_SIZE
operator|)
expr_stmt|;
name|pmap_kenter
argument_list|(
name|va
argument_list|,
name|pa
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|void
operator|*
operator|)
name|crashdumpmap
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * add a wired page to the kva  * note that in order for the mapping to take effect -- you  * should do a invltlb after doing the pmap_kenter...  */
end_comment

begin_function
specifier|static
name|PMAP_INLINE
name|void
name|pmap_kenter_internal
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|vm_offset_t
name|pa
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|l2_bucket
modifier|*
name|l2b
decl_stmt|;
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
name|pt_entry_t
name|opte
decl_stmt|;
name|PDEBUG
argument_list|(
literal|1
argument_list|,
name|printf
argument_list|(
literal|"pmap_kenter: va = %08x, pa = %08x\n"
argument_list|,
operator|(
name|uint32_t
operator|)
name|va
argument_list|,
operator|(
name|uint32_t
operator|)
name|pa
argument_list|)
argument_list|)
expr_stmt|;
name|l2b
operator|=
name|pmap_get_l2_bucket
argument_list|(
name|pmap_kernel
argument_list|()
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|l2b
operator|==
name|NULL
condition|)
name|l2b
operator|=
name|pmap_grow_l2_bucket
argument_list|(
name|pmap_kernel
argument_list|()
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|l2b
operator|!=
name|NULL
argument_list|,
operator|(
literal|"No L2 Bucket"
operator|)
argument_list|)
expr_stmt|;
name|pte
operator|=
operator|&
name|l2b
operator|->
name|l2b_kva
index|[
name|l2pte_index
argument_list|(
name|va
argument_list|)
index|]
expr_stmt|;
name|opte
operator|=
operator|*
name|pte
expr_stmt|;
if|if
condition|(
name|l2pte_valid
argument_list|(
name|opte
argument_list|)
condition|)
block|{
name|cpu_tlb_flushD_SE
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|cpu_cpwait
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|opte
operator|==
literal|0
condition|)
name|l2b
operator|->
name|l2b_occupancy
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|KENTER_CACHE
condition|)
block|{
operator|*
name|pte
operator|=
name|L2_S_PROTO
operator||
name|pa
operator||
name|pte_l2_s_cache_mode
expr_stmt|;
name|pmap_set_prot
argument_list|(
name|pte
argument_list|,
name|VM_PROT_READ
operator||
name|VM_PROT_WRITE
argument_list|,
name|flags
operator|&
name|KENTER_USER
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|pte
operator|=
name|L2_S_PROTO
operator||
name|pa
expr_stmt|;
name|pmap_set_prot
argument_list|(
name|pte
argument_list|,
name|VM_PROT_READ
operator||
name|VM_PROT_WRITE
operator||
name|VM_PROT_EXECUTE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|PDEBUG
argument_list|(
literal|1
argument_list|,
name|printf
argument_list|(
literal|"pmap_kenter: pte = %08x, opte = %08x, npte = %08x\n"
argument_list|,
operator|(
name|uint32_t
operator|)
name|pte
argument_list|,
name|opte
argument_list|,
operator|*
name|pte
argument_list|)
argument_list|)
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|pte
argument_list|)
expr_stmt|;
name|cpu_cpwait
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pmap_kenter
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|vm_paddr_t
name|pa
parameter_list|)
block|{
name|pmap_kenter_internal
argument_list|(
name|va
argument_list|,
name|pa
argument_list|,
name|KENTER_CACHE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pmap_kenter_nocache
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|vm_paddr_t
name|pa
parameter_list|)
block|{
name|pmap_kenter_internal
argument_list|(
name|va
argument_list|,
name|pa
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pmap_kenter_user
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|vm_paddr_t
name|pa
parameter_list|)
block|{
name|pmap_kenter_internal
argument_list|(
name|va
argument_list|,
name|pa
argument_list|,
name|KENTER_CACHE
operator||
name|KENTER_USER
argument_list|)
expr_stmt|;
comment|/* 	 * Call pmap_fault_fixup now, to make sure we'll have no exception 	 * at the first use of the new address, or bad things will happen, 	 * as we use one of these addresses in the exception handlers. 	 */
name|pmap_fault_fixup
argument_list|(
name|pmap_kernel
argument_list|()
argument_list|,
name|va
argument_list|,
name|VM_PROT_READ
operator||
name|VM_PROT_WRITE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * remove a page from the kernel pagetables  */
end_comment

begin_function
name|void
name|pmap_kremove
parameter_list|(
name|vm_offset_t
name|va
parameter_list|)
block|{
name|struct
name|l2_bucket
modifier|*
name|l2b
decl_stmt|;
name|pt_entry_t
modifier|*
name|pte
decl_stmt|,
name|opte
decl_stmt|;
name|l2b
operator|=
name|pmap_get_l2_bucket
argument_list|(
name|pmap_kernel
argument_list|()
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|l2b
condition|)
return|return;
name|KASSERT
argument_list|(
name|l2b
operator|!=
name|NULL
argument_list|,
operator|(
literal|"No L2 Bucket"
operator|)
argument_list|)
expr_stmt|;
name|pte
operator|=
operator|&
name|l2b
operator|->
name|l2b_kva
index|[
name|l2pte_index
argument_list|(
name|va
argument_list|)
index|]
expr_stmt|;
name|opte
operator|=
operator|*
name|pte
expr_stmt|;
if|if
condition|(
name|l2pte_valid
argument_list|(
name|opte
argument_list|)
condition|)
block|{
name|va
operator|=
name|va
operator|&
operator|~
name|PAGE_MASK
expr_stmt|;
name|cpu_tlb_flushD_SE
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|cpu_cpwait
argument_list|()
expr_stmt|;
operator|*
name|pte
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *	Used to map a range of physical addresses into kernel  *	virtual address space.  *  *	The value passed in '*virt' is a suggested virtual address for  *	the mapping. Architectures which can support a direct-mapped  *	physical to virtual region can return the appropriate address  *	within that region, leaving '*virt' unchanged. Other  *	architectures should map the pages starting at '*virt' and  *	update '*virt' with the first usable address after the mapped  *	region.  */
end_comment

begin_function
name|vm_offset_t
name|pmap_map
parameter_list|(
name|vm_offset_t
modifier|*
name|virt
parameter_list|,
name|vm_offset_t
name|start
parameter_list|,
name|vm_offset_t
name|end
parameter_list|,
name|int
name|prot
parameter_list|)
block|{
name|vm_offset_t
name|sva
init|=
operator|*
name|virt
decl_stmt|;
name|vm_offset_t
name|va
init|=
name|sva
decl_stmt|;
name|PDEBUG
argument_list|(
literal|1
argument_list|,
name|printf
argument_list|(
literal|"pmap_map: virt = %08x, start = %08x, end = %08x, "
literal|"prot = %d\n"
argument_list|,
operator|(
name|uint32_t
operator|)
operator|*
name|virt
argument_list|,
operator|(
name|uint32_t
operator|)
name|start
argument_list|,
operator|(
name|uint32_t
operator|)
name|end
argument_list|,
name|prot
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|start
operator|<
name|end
condition|)
block|{
name|pmap_kenter
argument_list|(
name|va
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|va
operator|+=
name|PAGE_SIZE
expr_stmt|;
name|start
operator|+=
name|PAGE_SIZE
expr_stmt|;
block|}
operator|*
name|virt
operator|=
name|va
expr_stmt|;
return|return
operator|(
name|sva
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add a list of wired pages to the kva  * this routine is only used for temporary  * kernel mappings that do not need to have  * page modification or references recorded.  * Note that old mappings are simply written  * over.  The page *must* be wired.  */
end_comment

begin_function
name|void
name|pmap_qenter
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
modifier|*
name|m
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|pmap_kenter_internal
argument_list|(
name|va
argument_list|,
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
index|[
name|i
index|]
argument_list|)
argument_list|,
name|KENTER_CACHE
argument_list|)
expr_stmt|;
name|va
operator|+=
name|PAGE_SIZE
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * this routine jerks page mappings from the  * kernel -- it is meant only for temporary mappings.  */
end_comment

begin_function
name|void
name|pmap_qremove
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|vtophys
argument_list|(
name|va
argument_list|)
condition|)
name|pmap_kremove
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|va
operator|+=
name|PAGE_SIZE
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * pmap_object_init_pt preloads the ptes for a given object  * into the specified pmap.  This eliminates the blast of soft  * faults on process startup and immediately after an mmap.  */
end_comment

begin_function
name|void
name|pmap_object_init_pt
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|addr
parameter_list|,
name|vm_object_t
name|object
parameter_list|,
name|vm_pindex_t
name|pindex
parameter_list|,
name|vm_size_t
name|size
parameter_list|)
block|{
name|VM_OBJECT_LOCK_ASSERT
argument_list|(
name|object
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|object
operator|->
name|type
operator|==
name|OBJT_DEVICE
operator|||
name|object
operator|->
name|type
operator|==
name|OBJT_SG
argument_list|,
operator|(
literal|"pmap_object_init_pt: non-device object"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	pmap_is_prefaultable:  *  *	Return whether or not the specified virtual address is elgible  *	for prefault.  */
end_comment

begin_function
name|boolean_t
name|pmap_is_prefaultable
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|addr
parameter_list|)
block|{
name|pd_entry_t
modifier|*
name|pde
decl_stmt|;
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
if|if
condition|(
operator|!
name|pmap_get_pde_pte
argument_list|(
name|pmap
argument_list|,
name|addr
argument_list|,
operator|&
name|pde
argument_list|,
operator|&
name|pte
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|KASSERT
argument_list|(
name|pte
operator|!=
name|NULL
argument_list|,
operator|(
literal|"Valid mapping but no pte ?"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pte
operator|==
literal|0
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Fetch pointers to the PDE/PTE for the given pmap/VA pair.  * Returns TRUE if the mapping exists, else FALSE.  *  * NOTE: This function is only used by a couple of arm-specific modules.  * It is not safe to take any pmap locks here, since we could be right  * in the middle of debugging the pmap anyway...  *  * It is possible for this routine to return FALSE even though a valid  * mapping does exist. This is because we don't lock, so the metadata  * state may be inconsistent.  *  * NOTE: We can return a NULL *ptp in the case where the L1 pde is  * a "section" mapping.  */
end_comment

begin_function
name|boolean_t
name|pmap_get_pde_pte
parameter_list|(
name|pmap_t
name|pm
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|pd_entry_t
modifier|*
modifier|*
name|pdp
parameter_list|,
name|pt_entry_t
modifier|*
modifier|*
name|ptp
parameter_list|)
block|{
name|struct
name|l2_dtable
modifier|*
name|l2
decl_stmt|;
name|pd_entry_t
modifier|*
name|pl1pd
decl_stmt|,
name|l1pd
decl_stmt|;
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|;
name|u_short
name|l1idx
decl_stmt|;
if|if
condition|(
name|pm
operator|->
name|pm_l1
operator|==
name|NULL
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|l1idx
operator|=
name|L1_IDX
argument_list|(
name|va
argument_list|)
expr_stmt|;
operator|*
name|pdp
operator|=
name|pl1pd
operator|=
operator|&
name|pm
operator|->
name|pm_l1
operator|->
name|l1_kva
index|[
name|l1idx
index|]
expr_stmt|;
name|l1pd
operator|=
operator|*
name|pl1pd
expr_stmt|;
if|if
condition|(
name|l1pte_section_p
argument_list|(
name|l1pd
argument_list|)
condition|)
block|{
operator|*
name|ptp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
if|if
condition|(
name|pm
operator|->
name|pm_l2
operator|==
name|NULL
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|l2
operator|=
name|pm
operator|->
name|pm_l2
index|[
name|L2_IDX
argument_list|(
name|l1idx
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|l2
operator|==
name|NULL
operator|||
operator|(
name|ptep
operator|=
name|l2
operator|->
name|l2_bucket
index|[
name|L2_BUCKET
argument_list|(
name|l1idx
argument_list|)
index|]
operator|.
name|l2b_kva
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
operator|*
name|ptp
operator|=
operator|&
name|ptep
index|[
name|l2pte_index
argument_list|(
name|va
argument_list|)
index|]
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *      Routine:        pmap_remove_all  *      Function:  *              Removes this physical page from  *              all physical maps in which it resides.  *              Reflects back modify bits to the pager.  *  *      Notes:  *              Original versions of this routine were very  *              inefficient because they iteratively called  *              pmap_remove (slow...)  */
end_comment

begin_function
name|void
name|pmap_remove_all
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|pv_entry_t
name|pv
decl_stmt|;
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|;
name|struct
name|l2_bucket
modifier|*
name|l2b
decl_stmt|;
name|boolean_t
name|flush
init|=
name|FALSE
decl_stmt|;
name|pmap_t
name|curpm
decl_stmt|;
name|int
name|flags
init|=
literal|0
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_FICTITIOUS
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_remove_all: page %p is fictitious"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|)
condition|)
return|return;
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|pmap_remove_write
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|curpm
operator|=
name|vmspace_pmap
argument_list|(
name|curproc
operator|->
name|p_vmspace
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|pv
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|flush
operator|==
name|FALSE
operator|&&
operator|(
name|pv
operator|->
name|pv_pmap
operator|==
name|curpm
operator|||
name|pv
operator|->
name|pv_pmap
operator|==
name|pmap_kernel
argument_list|()
operator|)
condition|)
name|flush
operator|=
name|TRUE
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|)
expr_stmt|;
name|l2b
operator|=
name|pmap_get_l2_bucket
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|l2b
operator|!=
name|NULL
argument_list|,
operator|(
literal|"No l2 bucket"
operator|)
argument_list|)
expr_stmt|;
name|ptep
operator|=
operator|&
name|l2b
operator|->
name|l2b_kva
index|[
name|l2pte_index
argument_list|(
name|pv
operator|->
name|pv_va
argument_list|)
index|]
expr_stmt|;
operator|*
name|ptep
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pmap_is_current
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|)
condition|)
name|PTE_SYNC
argument_list|(
name|ptep
argument_list|)
expr_stmt|;
name|pmap_free_l2_bucket
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|,
name|l2b
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pv
operator|->
name|pv_pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|--
expr_stmt|;
name|flags
operator||=
name|pv
operator|->
name|pv_flags
expr_stmt|;
name|pmap_nuke_pv
argument_list|(
name|m
argument_list|,
name|pv
operator|->
name|pv_pmap
argument_list|,
name|pv
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|)
expr_stmt|;
name|pmap_free_pv_entry
argument_list|(
name|pv
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flush
condition|)
block|{
if|if
condition|(
name|PV_BEEN_EXECD
argument_list|(
name|flags
argument_list|)
condition|)
name|cpu_tlb_flushID
argument_list|()
expr_stmt|;
else|else
name|cpu_tlb_flushD
argument_list|()
expr_stmt|;
block|}
name|vm_page_aflag_clear
argument_list|(
name|m
argument_list|,
name|PGA_WRITEABLE
argument_list|)
expr_stmt|;
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|pmap_change_attr
parameter_list|(
name|vm_offset_t
name|sva
parameter_list|,
name|vm_size_t
name|len
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|vm_offset_t
name|base
decl_stmt|,
name|offset
decl_stmt|,
name|tmpva
decl_stmt|;
name|vm_size_t
name|size
decl_stmt|;
name|struct
name|l2_bucket
modifier|*
name|l2b
decl_stmt|;
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|,
name|pte
decl_stmt|;
name|vm_offset_t
name|next_bucket
decl_stmt|;
name|PMAP_LOCK
argument_list|(
name|kernel_pmap
argument_list|)
expr_stmt|;
name|base
operator|=
name|trunc_page
argument_list|(
name|sva
argument_list|)
expr_stmt|;
name|offset
operator|=
name|sva
operator|&
name|PAGE_MASK
expr_stmt|;
name|size
operator|=
name|roundup
argument_list|(
name|offset
operator|+
name|len
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|checkit
comment|/* 	 * Only supported on kernel virtual addresses, including the direct 	 * map but excluding the recursive map. 	 */
if|if
condition|(
name|base
operator|<
name|DMAP_MIN_ADDRESS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
endif|#
directive|endif
for|for
control|(
name|tmpva
operator|=
name|base
init|;
name|tmpva
operator|<
name|base
operator|+
name|size
condition|;
control|)
block|{
name|next_bucket
operator|=
name|L2_NEXT_BUCKET
argument_list|(
name|tmpva
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_bucket
operator|>
name|base
operator|+
name|size
condition|)
name|next_bucket
operator|=
name|base
operator|+
name|size
expr_stmt|;
name|l2b
operator|=
name|pmap_get_l2_bucket
argument_list|(
name|kernel_pmap
argument_list|,
name|tmpva
argument_list|)
expr_stmt|;
if|if
condition|(
name|l2b
operator|==
name|NULL
condition|)
block|{
name|tmpva
operator|=
name|next_bucket
expr_stmt|;
continue|continue;
block|}
name|ptep
operator|=
operator|&
name|l2b
operator|->
name|l2b_kva
index|[
name|l2pte_index
argument_list|(
name|tmpva
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|ptep
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|pte
operator|=
operator|*
name|ptep
operator|&
operator|~
name|L2_S_CACHE_MASK
expr_stmt|;
name|cpu_idcache_wbinv_range
argument_list|(
name|tmpva
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ARM_L2_PIPT
name|cpu_l2cache_wbinv_range
argument_list|(
name|pte
operator|&
name|L2_S_FRAME
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
else|#
directive|else
name|cpu_l2cache_wbinv_range
argument_list|(
name|tmpva
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|ptep
operator|=
name|pte
expr_stmt|;
name|cpu_tlb_flushID_SE
argument_list|(
name|tmpva
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|"%s: for va:%x ptep:%x pte:%x\n"
argument_list|,
name|__func__
argument_list|,
name|tmpva
argument_list|,
operator|(
name|uint32_t
operator|)
name|ptep
argument_list|,
name|pte
argument_list|)
expr_stmt|;
name|tmpva
operator|+=
name|PAGE_SIZE
expr_stmt|;
block|}
name|PMAP_UNLOCK
argument_list|(
name|kernel_pmap
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	Set the physical protection on the  *	specified range of this map as requested.  */
end_comment

begin_function
name|void
name|pmap_protect
parameter_list|(
name|pmap_t
name|pm
parameter_list|,
name|vm_offset_t
name|sva
parameter_list|,
name|vm_offset_t
name|eva
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|)
block|{
name|struct
name|l2_bucket
modifier|*
name|l2b
decl_stmt|;
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|,
name|pte
decl_stmt|;
name|vm_offset_t
name|next_bucket
decl_stmt|;
name|u_int
name|flags
decl_stmt|;
name|int
name|flush
decl_stmt|;
if|if
condition|(
operator|(
name|prot
operator|&
name|VM_PROT_READ
operator|)
operator|==
literal|0
condition|)
block|{
name|pmap_remove
argument_list|(
name|pm
argument_list|,
name|sva
argument_list|,
name|eva
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|prot
operator|&
name|VM_PROT_WRITE
condition|)
block|{
comment|/* 		 * If this is a read->write transition, just ignore it and let 		 * vm_fault() take care of it later. 		 */
return|return;
block|}
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pm
argument_list|)
expr_stmt|;
comment|/* 	 * OK, at this point, we know we're doing write-protect operation. 	 * If the pmap is active, write-back the range. 	 */
name|flush
operator|=
operator|(
operator|(
name|eva
operator|-
name|sva
operator|)
operator|>=
operator|(
name|PAGE_SIZE
operator|*
literal|4
operator|)
operator|)
condition|?
literal|0
else|:
operator|-
literal|1
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|sva
operator|<
name|eva
condition|)
block|{
name|next_bucket
operator|=
name|L2_NEXT_BUCKET
argument_list|(
name|sva
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_bucket
operator|>
name|eva
condition|)
name|next_bucket
operator|=
name|eva
expr_stmt|;
name|l2b
operator|=
name|pmap_get_l2_bucket
argument_list|(
name|pm
argument_list|,
name|sva
argument_list|)
expr_stmt|;
if|if
condition|(
name|l2b
operator|==
name|NULL
condition|)
block|{
name|sva
operator|=
name|next_bucket
expr_stmt|;
continue|continue;
block|}
name|ptep
operator|=
operator|&
name|l2b
operator|->
name|l2b_kva
index|[
name|l2pte_index
argument_list|(
name|sva
argument_list|)
index|]
expr_stmt|;
while|while
condition|(
name|sva
operator|<
name|next_bucket
condition|)
block|{
if|if
condition|(
operator|(
name|pte
operator|=
operator|*
name|ptep
operator|)
operator|!=
literal|0
operator|&&
name|L2_S_WRITABLE
argument_list|(
name|pte
argument_list|)
condition|)
block|{
name|struct
name|vm_page
modifier|*
name|pg
decl_stmt|;
name|u_int
name|f
decl_stmt|;
name|pg
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|l2pte_pa
argument_list|(
name|pte
argument_list|)
argument_list|)
expr_stmt|;
name|pmap_set_prot
argument_list|(
name|ptep
argument_list|,
name|prot
argument_list|,
operator|!
operator|(
name|pm
operator|==
name|pmap_kernel
argument_list|()
operator|)
argument_list|)
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|ptep
argument_list|)
expr_stmt|;
name|f
operator|=
name|pmap_modify_pv
argument_list|(
name|pg
argument_list|,
name|pm
argument_list|,
name|sva
argument_list|,
name|PVF_WRITE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|&
name|PVF_WRITE
condition|)
name|vm_page_dirty
argument_list|(
name|pg
argument_list|)
expr_stmt|;
if|if
condition|(
name|flush
operator|>=
literal|0
condition|)
block|{
name|flush
operator|++
expr_stmt|;
name|flags
operator||=
name|f
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|PV_BEEN_EXECD
argument_list|(
name|f
argument_list|)
condition|)
name|cpu_tlb_flushID_SE
argument_list|(
name|sva
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|PV_BEEN_REFD
argument_list|(
name|f
argument_list|)
condition|)
name|cpu_tlb_flushD_SE
argument_list|(
name|sva
argument_list|)
expr_stmt|;
block|}
name|sva
operator|+=
name|PAGE_SIZE
expr_stmt|;
name|ptep
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|flush
condition|)
block|{
if|if
condition|(
name|PV_BEEN_EXECD
argument_list|(
name|flags
argument_list|)
condition|)
name|cpu_tlb_flushID
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|PV_BEEN_REFD
argument_list|(
name|flags
argument_list|)
condition|)
name|cpu_tlb_flushD
argument_list|()
expr_stmt|;
block|}
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pm
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Insert the given physical page (p) at  *	the specified virtual address (v) in the  *	target physical map with the protection requested.  *  *	If specified, the page will be wired down, meaning  *	that the related pte can not be reclaimed.  *  *	NB:  This is the only routine which MAY NOT lazy-evaluate  *	or lose information.  That is, this routine must actually  *	insert this page into the given map NOW.  */
end_comment

begin_function
name|void
name|pmap_enter
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_prot_t
name|access
parameter_list|,
name|vm_page_t
name|m
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|,
name|boolean_t
name|wired
parameter_list|)
block|{
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|pmap_enter_locked
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|m
argument_list|,
name|prot
argument_list|,
name|wired
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	The pvh global and pmap locks must be held.  */
end_comment

begin_function
specifier|static
name|void
name|pmap_enter_locked
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|m
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|,
name|boolean_t
name|wired
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|l2_bucket
modifier|*
name|l2b
init|=
name|NULL
decl_stmt|;
name|struct
name|vm_page
modifier|*
name|opg
decl_stmt|;
name|struct
name|pv_entry
modifier|*
name|pve
init|=
name|NULL
decl_stmt|;
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|,
name|npte
decl_stmt|,
name|opte
decl_stmt|;
name|u_int
name|nflags
decl_stmt|;
name|u_int
name|oflags
decl_stmt|;
name|vm_paddr_t
name|pa
decl_stmt|;
name|u_char
name|user
decl_stmt|;
name|PMAP_ASSERT_LOCKED
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|rw_assert
argument_list|(
operator|&
name|pvh_global_lock
argument_list|,
name|RA_WLOCKED
argument_list|)
expr_stmt|;
if|if
condition|(
name|va
operator|==
name|vector_page
condition|)
block|{
name|pa
operator|=
name|systempage
operator|.
name|pv_pa
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|KASSERT
argument_list|(
operator|(
name|m
operator|->
name|oflags
operator|&
operator|(
name|VPO_UNMANAGED
operator||
name|VPO_BUSY
operator|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|flags
operator|&
name|M_NOWAIT
operator|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"pmap_enter_locked: page %p is not busy"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
name|pa
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|user
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Make sure userland mappings get the right permissions 	 */
if|if
condition|(
name|pmap
operator|!=
name|pmap_kernel
argument_list|()
operator|&&
name|va
operator|!=
name|vector_page
condition|)
name|user
operator|=
literal|1
expr_stmt|;
name|nflags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|prot
operator|&
name|VM_PROT_WRITE
condition|)
name|nflags
operator||=
name|PVF_WRITE
expr_stmt|;
if|if
condition|(
name|prot
operator|&
name|VM_PROT_EXECUTE
condition|)
name|nflags
operator||=
name|PVF_EXEC
expr_stmt|;
if|if
condition|(
name|wired
condition|)
name|nflags
operator||=
name|PVF_WIRED
expr_stmt|;
name|PDEBUG
argument_list|(
literal|1
argument_list|,
name|printf
argument_list|(
literal|"pmap_enter: pmap = %08x, va = %08x, m = %08x, prot = %x, "
literal|"wired = %x\n"
argument_list|,
operator|(
name|uint32_t
operator|)
name|pmap
argument_list|,
name|va
argument_list|,
operator|(
name|uint32_t
operator|)
name|m
argument_list|,
name|prot
argument_list|,
name|wired
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap
operator|==
name|pmap_kernel
argument_list|()
condition|)
block|{
name|l2b
operator|=
name|pmap_get_l2_bucket
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|l2b
operator|==
name|NULL
condition|)
name|l2b
operator|=
name|pmap_grow_l2_bucket
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|do_l2b_alloc
label|:
name|l2b
operator|=
name|pmap_alloc_l2_bucket
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|l2b
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|M_WAITOK
condition|)
block|{
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|VM_WAIT
expr_stmt|;
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
goto|goto
name|do_l2b_alloc
goto|;
block|}
return|return;
block|}
block|}
name|ptep
operator|=
operator|&
name|l2b
operator|->
name|l2b_kva
index|[
name|l2pte_index
argument_list|(
name|va
argument_list|)
index|]
expr_stmt|;
name|opte
operator|=
operator|*
name|ptep
expr_stmt|;
name|npte
operator|=
name|pa
expr_stmt|;
name|oflags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|opte
condition|)
block|{
comment|/* 		 * There is already a mapping at this address. 		 * If the physical address is different, lookup the 		 * vm_page. 		 */
if|if
condition|(
name|l2pte_pa
argument_list|(
name|opte
argument_list|)
operator|!=
name|pa
condition|)
name|opg
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|l2pte_pa
argument_list|(
name|opte
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|opg
operator|=
name|m
expr_stmt|;
block|}
else|else
name|opg
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|prot
operator|&
operator|(
name|VM_PROT_ALL
operator|)
operator|)
operator|||
operator|(
operator|!
name|m
operator|||
name|m
operator|->
name|md
operator|.
name|pvh_attrs
operator|&
name|PVF_REF
operator|)
condition|)
block|{
comment|/* 		 * - The access type indicates that we don't need 		 *   to do referenced emulation. 		 * OR 		 * - The physical page has already been referenced 		 *   so no need to re-do referenced emulation here. 		 */
name|npte
operator||=
name|L2_S_PROTO
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
name|npte
operator||=
name|L2_SHARED
expr_stmt|;
endif|#
directive|endif
name|nflags
operator||=
name|PVF_REF
expr_stmt|;
if|if
condition|(
name|m
operator|&&
operator|(
operator|(
name|prot
operator|&
name|VM_PROT_WRITE
operator|)
operator|!=
literal|0
operator|||
operator|(
name|m
operator|->
name|md
operator|.
name|pvh_attrs
operator|&
name|PVF_MOD
operator|)
operator|)
condition|)
block|{
comment|/* 			 * This is a writable mapping, and the 			 * page's mod state indicates it has 			 * already been modified. Make it 			 * writable from the outset. 			 */
name|nflags
operator||=
name|PVF_MOD
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|m
operator|->
name|md
operator|.
name|pvh_attrs
operator|&
name|PVF_MOD
operator|)
condition|)
name|vm_page_dirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|&&
name|opte
condition|)
name|vm_page_aflag_set
argument_list|(
name|m
argument_list|,
name|PGA_REFERENCED
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Need to do page referenced emulation. 		 */
name|npte
operator||=
name|L2_TYPE_INV
expr_stmt|;
block|}
name|npte
operator||=
name|L2_S_PROT_R
expr_stmt|;
if|if
condition|(
name|prot
operator|&
name|VM_PROT_WRITE
condition|)
block|{
name|npte
operator|&=
operator|~
operator|(
name|L2_APX
operator|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
operator|&&
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|==
literal|0
condition|)
name|vm_page_aflag_set
argument_list|(
name|m
argument_list|,
name|PGA_WRITEABLE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|user
condition|)
name|npte
operator||=
name|L2_S_PROT_U
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|prot
operator|&
name|VM_PROT_EXECUTE
operator|)
operator|&&
name|m
condition|)
name|npte
operator||=
name|L2_XN
expr_stmt|;
name|npte
operator||=
name|pte_l2_s_cache_mode
expr_stmt|;
if|if
condition|(
name|m
operator|&&
name|m
operator|==
name|opg
condition|)
block|{
comment|/* 		 * We're changing the attrs of an existing mapping. 		 */
name|oflags
operator|=
name|pmap_modify_pv
argument_list|(
name|m
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|,
name|PVF_WRITE
operator||
name|PVF_EXEC
operator||
name|PVF_WIRED
operator||
name|PVF_MOD
operator||
name|PVF_REF
argument_list|,
name|nflags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * New mapping, or changing the backing page 		 * of an existing mapping. 		 */
if|if
condition|(
name|opg
condition|)
block|{
comment|/* 			 * Replacing an existing mapping with a new one. 			 * It is part of our managed memory so we 			 * must remove it from the PV list 			 */
if|if
condition|(
operator|(
name|pve
operator|=
name|pmap_remove_pv
argument_list|(
name|opg
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|)
operator|)
condition|)
block|{
name|oflags
operator|=
name|pve
operator|->
name|pv_flags
expr_stmt|;
if|if
condition|(
name|m
operator|&&
operator|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|)
condition|)
block|{
name|pmap_free_pv_entry
argument_list|(
name|pve
argument_list|)
expr_stmt|;
name|pve
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|m
operator|&&
operator|!
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
operator|!
name|pve
operator|)
operator|&&
operator|(
name|pve
operator|=
name|pmap_get_pv_entry
argument_list|()
operator|)
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"pmap_enter: no pv entries"
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|va
operator|<
name|kmi
operator|.
name|clean_sva
operator|||
name|va
operator|>=
name|kmi
operator|.
name|clean_eva
argument_list|,
operator|(
literal|"pmap_enter: managed mapping within the clean submap"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pve
operator|!=
name|NULL
argument_list|,
operator|(
literal|"No pv"
operator|)
argument_list|)
expr_stmt|;
name|pmap_enter_pv
argument_list|(
name|m
argument_list|,
name|pve
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|,
name|nflags
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Keep the stats up to date 	 */
if|if
condition|(
name|opte
operator|==
literal|0
condition|)
block|{
name|l2b
operator|->
name|l2b_occupancy
operator|++
expr_stmt|;
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|++
expr_stmt|;
block|}
name|CTR5
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"enter: pmap:%p va:%x prot:%x pte:%x->%x"
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|,
name|prot
argument_list|,
name|opte
argument_list|,
name|npte
argument_list|)
expr_stmt|;
comment|/* 	 * If this is just a wiring change, the two PTEs will be 	 * identical, so there's no need to update the page table. 	 */
if|if
condition|(
name|npte
operator|!=
name|opte
condition|)
block|{
name|boolean_t
name|is_cached
init|=
name|pmap_is_current
argument_list|(
name|pmap
argument_list|)
decl_stmt|;
operator|*
name|ptep
operator|=
name|npte
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|ptep
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_cached
condition|)
block|{
comment|/* 			 * We only need to frob the cache/tlb if this pmap 			 * is current 			 */
if|if
condition|(
name|L1_IDX
argument_list|(
name|va
argument_list|)
operator|!=
name|L1_IDX
argument_list|(
name|vector_page
argument_list|)
operator|&&
name|l2pte_valid
argument_list|(
name|npte
argument_list|)
condition|)
block|{
comment|/* 				 * This mapping is likely to be accessed as 				 * soon as we return to userland. Fix up the 				 * L1 entry to avoid taking another 				 * page/domain fault. 				 */
name|pd_entry_t
modifier|*
name|pl1pd
decl_stmt|,
name|l1pd
decl_stmt|;
name|pl1pd
operator|=
operator|&
name|pmap
operator|->
name|pm_l1
operator|->
name|l1_kva
index|[
name|L1_IDX
argument_list|(
name|va
argument_list|)
index|]
expr_stmt|;
name|l1pd
operator|=
name|l2b
operator|->
name|l2b_phys
operator||
name|L1_C_DOM
argument_list|(
name|pmap
operator|->
name|pm_domain
argument_list|)
operator||
name|L1_C_PROTO
expr_stmt|;
if|if
condition|(
operator|*
name|pl1pd
operator|!=
name|l1pd
condition|)
block|{
operator|*
name|pl1pd
operator|=
name|l1pd
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|pl1pd
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|PV_BEEN_EXECD
argument_list|(
name|oflags
argument_list|)
condition|)
name|cpu_tlb_flushID_SE
argument_list|(
name|va
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|PV_BEEN_REFD
argument_list|(
name|oflags
argument_list|)
condition|)
name|cpu_tlb_flushD_SE
argument_list|(
name|va
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Maps a sequence of resident pages belonging to the same object.  * The sequence begins with the given page m_start.  This page is  * mapped at the given virtual address start.  Each subsequent page is  * mapped at a virtual address that is offset from start by the same  * amount as the page is offset from m_start within the object.  The  * last page in the sequence is the page with the largest offset from  * m_start that can be mapped at a virtual address less than the given  * virtual address end.  Not every virtual page between start and end  * is mapped; only those for which a resident page exists with the  * corresponding offset from m_start are mapped.  */
end_comment

begin_function
name|void
name|pmap_enter_object
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|start
parameter_list|,
name|vm_offset_t
name|end
parameter_list|,
name|vm_page_t
name|m_start
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|)
block|{
name|vm_page_t
name|m
decl_stmt|;
name|vm_pindex_t
name|diff
decl_stmt|,
name|psize
decl_stmt|;
name|psize
operator|=
name|atop
argument_list|(
name|end
operator|-
name|start
argument_list|)
expr_stmt|;
name|m
operator|=
name|m_start
expr_stmt|;
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
while|while
condition|(
name|m
operator|!=
name|NULL
operator|&&
operator|(
name|diff
operator|=
name|m
operator|->
name|pindex
operator|-
name|m_start
operator|->
name|pindex
operator|)
operator|<
name|psize
condition|)
block|{
name|pmap_enter_locked
argument_list|(
name|pmap
argument_list|,
name|start
operator|+
name|ptoa
argument_list|(
name|diff
argument_list|)
argument_list|,
name|m
argument_list|,
name|prot
operator|&
operator|(
name|VM_PROT_READ
operator||
name|VM_PROT_EXECUTE
operator|)
argument_list|,
name|FALSE
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|m
operator|=
name|TAILQ_NEXT
argument_list|(
name|m
argument_list|,
name|listq
argument_list|)
expr_stmt|;
block|}
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * this code makes some *MAJOR* assumptions:  * 1. Current pmap& pmap exists.  * 2. Not wired.  * 3. Read access.  * 4. No page table pages.  * but is *MUCH* faster than pmap_enter...  */
end_comment

begin_function
name|void
name|pmap_enter_quick
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|m
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|)
block|{
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|pmap_enter_locked
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|m
argument_list|,
name|prot
operator|&
operator|(
name|VM_PROT_READ
operator||
name|VM_PROT_EXECUTE
operator|)
argument_list|,
name|FALSE
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Routine:	pmap_change_wiring  *	Function:	Change the wiring attribute for a map/virtual-address  *			pair.  *	In/out conditions:  *			The mapping must already exist in the pmap.  */
end_comment

begin_function
name|void
name|pmap_change_wiring
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|boolean_t
name|wired
parameter_list|)
block|{
name|struct
name|l2_bucket
modifier|*
name|l2b
decl_stmt|;
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|,
name|pte
decl_stmt|;
name|vm_page_t
name|pg
decl_stmt|;
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|l2b
operator|=
name|pmap_get_l2_bucket
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|l2b
argument_list|,
operator|(
literal|"No l2b bucket in pmap_change_wiring"
operator|)
argument_list|)
expr_stmt|;
name|ptep
operator|=
operator|&
name|l2b
operator|->
name|l2b_kva
index|[
name|l2pte_index
argument_list|(
name|va
argument_list|)
index|]
expr_stmt|;
name|pte
operator|=
operator|*
name|ptep
expr_stmt|;
name|pg
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|l2pte_pa
argument_list|(
name|pte
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pg
condition|)
name|pmap_modify_pv
argument_list|(
name|pg
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|,
name|PVF_WIRED
argument_list|,
name|wired
argument_list|)
expr_stmt|;
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Copy the range specified by src_addr/len  *	from the source map to the range dst_addr/len  *	in the destination map.  *  *	This routine is only advisory and need not do anything.  */
end_comment

begin_function
name|void
name|pmap_copy
parameter_list|(
name|pmap_t
name|dst_pmap
parameter_list|,
name|pmap_t
name|src_pmap
parameter_list|,
name|vm_offset_t
name|dst_addr
parameter_list|,
name|vm_size_t
name|len
parameter_list|,
name|vm_offset_t
name|src_addr
parameter_list|)
block|{ }
end_function

begin_comment
comment|/*  *	Routine:	pmap_extract  *	Function:  *		Extract the physical page address associated  *		with the given map/virtual_address pair.  */
end_comment

begin_function
name|vm_paddr_t
name|pmap_extract
parameter_list|(
name|pmap_t
name|pm
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|struct
name|l2_dtable
modifier|*
name|l2
decl_stmt|;
name|pd_entry_t
name|l1pd
decl_stmt|;
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|,
name|pte
decl_stmt|;
name|vm_paddr_t
name|pa
decl_stmt|;
name|u_int
name|l1idx
decl_stmt|;
name|l1idx
operator|=
name|L1_IDX
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pm
argument_list|)
expr_stmt|;
name|l1pd
operator|=
name|pm
operator|->
name|pm_l1
operator|->
name|l1_kva
index|[
name|l1idx
index|]
expr_stmt|;
if|if
condition|(
name|l1pte_section_p
argument_list|(
name|l1pd
argument_list|)
condition|)
block|{
comment|/* 		 * These should only happen for pmap_kernel() 		 */
name|KASSERT
argument_list|(
name|pm
operator|==
name|pmap_kernel
argument_list|()
argument_list|,
operator|(
literal|"huh"
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX: what to do about the bits> 32 ? */
if|if
condition|(
name|l1pd
operator|&
name|L1_S_SUPERSEC
condition|)
name|pa
operator|=
operator|(
name|l1pd
operator|&
name|L1_SUP_FRAME
operator|)
operator||
operator|(
name|va
operator|&
name|L1_SUP_OFFSET
operator|)
expr_stmt|;
else|else
name|pa
operator|=
operator|(
name|l1pd
operator|&
name|L1_S_FRAME
operator|)
operator||
operator|(
name|va
operator|&
name|L1_S_OFFSET
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Note that we can't rely on the validity of the L1 		 * descriptor as an indication that a mapping exists. 		 * We have to look it up in the L2 dtable. 		 */
name|l2
operator|=
name|pm
operator|->
name|pm_l2
index|[
name|L2_IDX
argument_list|(
name|l1idx
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|l2
operator|==
name|NULL
operator|||
operator|(
name|ptep
operator|=
name|l2
operator|->
name|l2_bucket
index|[
name|L2_BUCKET
argument_list|(
name|l1idx
argument_list|)
index|]
operator|.
name|l2b_kva
operator|)
operator|==
name|NULL
condition|)
block|{
name|PMAP_UNLOCK
argument_list|(
name|pm
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ptep
operator|=
operator|&
name|ptep
index|[
name|l2pte_index
argument_list|(
name|va
argument_list|)
index|]
expr_stmt|;
name|pte
operator|=
operator|*
name|ptep
expr_stmt|;
if|if
condition|(
name|pte
operator|==
literal|0
condition|)
block|{
name|PMAP_UNLOCK
argument_list|(
name|pm
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
switch|switch
condition|(
name|pte
operator|&
name|L2_TYPE_MASK
condition|)
block|{
case|case
name|L2_TYPE_L
case|:
name|pa
operator|=
operator|(
name|pte
operator|&
name|L2_L_FRAME
operator|)
operator||
operator|(
name|va
operator|&
name|L2_L_OFFSET
operator|)
expr_stmt|;
break|break;
default|default:
name|pa
operator|=
operator|(
name|pte
operator|&
name|L2_S_FRAME
operator|)
operator||
operator|(
name|va
operator|&
name|L2_S_OFFSET
operator|)
expr_stmt|;
break|break;
block|}
block|}
name|PMAP_UNLOCK
argument_list|(
name|pm
argument_list|)
expr_stmt|;
return|return
operator|(
name|pa
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Atomically extract and hold the physical page with the given  * pmap and virtual address pair if that mapping permits the given  * protection.  *  */
end_comment

begin_function
name|vm_page_t
name|pmap_extract_and_hold
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|)
block|{
name|struct
name|l2_dtable
modifier|*
name|l2
decl_stmt|;
name|pd_entry_t
name|l1pd
decl_stmt|;
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|,
name|pte
decl_stmt|;
name|vm_paddr_t
name|pa
decl_stmt|,
name|paddr
decl_stmt|;
name|vm_page_t
name|m
init|=
name|NULL
decl_stmt|;
name|u_int
name|l1idx
decl_stmt|;
name|l1idx
operator|=
name|L1_IDX
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|paddr
operator|=
literal|0
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|retry
label|:
name|l1pd
operator|=
name|pmap
operator|->
name|pm_l1
operator|->
name|l1_kva
index|[
name|l1idx
index|]
expr_stmt|;
if|if
condition|(
name|l1pte_section_p
argument_list|(
name|l1pd
argument_list|)
condition|)
block|{
comment|/* 		 * These should only happen for pmap_kernel() 		 */
name|KASSERT
argument_list|(
name|pmap
operator|==
name|pmap_kernel
argument_list|()
argument_list|,
operator|(
literal|"huh"
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX: what to do about the bits> 32 ? */
if|if
condition|(
name|l1pd
operator|&
name|L1_S_SUPERSEC
condition|)
name|pa
operator|=
operator|(
name|l1pd
operator|&
name|L1_SUP_FRAME
operator|)
operator||
operator|(
name|va
operator|&
name|L1_SUP_OFFSET
operator|)
expr_stmt|;
else|else
name|pa
operator|=
operator|(
name|l1pd
operator|&
name|L1_S_FRAME
operator|)
operator||
operator|(
name|va
operator|&
name|L1_S_OFFSET
operator|)
expr_stmt|;
if|if
condition|(
name|vm_page_pa_tryrelock
argument_list|(
name|pmap
argument_list|,
name|pa
operator|&
name|PG_FRAME
argument_list|,
operator|&
name|paddr
argument_list|)
condition|)
goto|goto
name|retry
goto|;
if|if
condition|(
name|L1_S_WRITABLE
argument_list|(
name|l1pd
argument_list|)
operator|||
operator|(
name|prot
operator|&
name|VM_PROT_WRITE
operator|)
operator|==
literal|0
condition|)
block|{
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|vm_page_hold
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * Note that we can't rely on the validity of the L1 		 * descriptor as an indication that a mapping exists. 		 * We have to look it up in the L2 dtable. 		 */
name|l2
operator|=
name|pmap
operator|->
name|pm_l2
index|[
name|L2_IDX
argument_list|(
name|l1idx
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|l2
operator|==
name|NULL
operator|||
operator|(
name|ptep
operator|=
name|l2
operator|->
name|l2_bucket
index|[
name|L2_BUCKET
argument_list|(
name|l1idx
argument_list|)
index|]
operator|.
name|l2b_kva
operator|)
operator|==
name|NULL
condition|)
block|{
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|ptep
operator|=
operator|&
name|ptep
index|[
name|l2pte_index
argument_list|(
name|va
argument_list|)
index|]
expr_stmt|;
name|pte
operator|=
operator|*
name|ptep
expr_stmt|;
if|if
condition|(
name|pte
operator|==
literal|0
condition|)
block|{
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|prot
operator|&
name|VM_PROT_WRITE
operator|)
operator|&&
operator|(
name|pte
operator|&
name|L2_APX
operator|)
condition|)
block|{
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
else|else
block|{
switch|switch
condition|(
name|pte
operator|&
name|L2_TYPE_MASK
condition|)
block|{
case|case
name|L2_TYPE_L
case|:
name|panic
argument_list|(
literal|"extract and hold section mapping"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|pa
operator|=
operator|(
name|pte
operator|&
name|L2_S_FRAME
operator|)
operator||
operator|(
name|va
operator|&
name|L2_S_OFFSET
operator|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|vm_page_pa_tryrelock
argument_list|(
name|pmap
argument_list|,
name|pa
operator|&
name|PG_FRAME
argument_list|,
operator|&
name|paddr
argument_list|)
condition|)
goto|goto
name|retry
goto|;
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|vm_page_hold
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|PA_UNLOCK_COND
argument_list|(
name|paddr
argument_list|)
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize a preallocated and zeroed pmap structure,  * such as one in a vmspace structure.  */
end_comment

begin_function
name|int
name|pmap_pinit
parameter_list|(
name|pmap_t
name|pmap
parameter_list|)
block|{
name|PDEBUG
argument_list|(
literal|1
argument_list|,
name|printf
argument_list|(
literal|"pmap_pinit: pmap = %08x\n"
argument_list|,
operator|(
name|uint32_t
operator|)
name|pmap
argument_list|)
argument_list|)
expr_stmt|;
name|PMAP_LOCK_INIT
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|pmap_alloc_l1
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|pmap
operator|->
name|pm_l2
argument_list|,
sizeof|sizeof
argument_list|(
name|pmap
operator|->
name|pm_l2
argument_list|)
argument_list|)
expr_stmt|;
name|CPU_ZERO
argument_list|(
operator|&
name|pmap
operator|->
name|pm_active
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvlist
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|pmap
operator|->
name|pm_stats
argument_list|,
sizeof|sizeof
name|pmap
operator|->
name|pm_stats
argument_list|)
expr_stmt|;
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|vector_page
operator|<
name|KERNBASE
condition|)
block|{
name|pmap_enter
argument_list|(
name|pmap
argument_list|,
name|vector_page
argument_list|,
name|VM_PROT_READ
argument_list|,
name|PHYS_TO_VM_PAGE
argument_list|(
name|systempage
operator|.
name|pv_pa
argument_list|)
argument_list|,
name|VM_PROT_READ
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/***************************************************  * page management routines.  ***************************************************/
end_comment

begin_function
specifier|static
name|void
name|pmap_free_pv_entry
parameter_list|(
name|pv_entry_t
name|pv
parameter_list|)
block|{
name|pv_entry_count
operator|--
expr_stmt|;
name|uma_zfree
argument_list|(
name|pvzone
argument_list|,
name|pv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * get a new pv_entry, allocating a block from the system  * when needed.  * the memory allocation is performed bypassing the malloc code  * because of the possibility of allocations at interrupt time.  */
end_comment

begin_function
specifier|static
name|pv_entry_t
name|pmap_get_pv_entry
parameter_list|(
name|void
parameter_list|)
block|{
name|pv_entry_t
name|ret_value
decl_stmt|;
name|pv_entry_count
operator|++
expr_stmt|;
if|if
condition|(
name|pv_entry_count
operator|>
name|pv_entry_high_water
condition|)
name|pagedaemon_wakeup
argument_list|()
expr_stmt|;
name|ret_value
operator|=
name|uma_zalloc
argument_list|(
name|pvzone
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
return|return
name|ret_value
return|;
block|}
end_function

begin_comment
comment|/*  *	Remove the given range of addresses from the specified map.  *  *	It is assumed that the start and end are properly  *	rounded to the page size.  */
end_comment

begin_define
define|#
directive|define
name|PMAP_REMOVE_CLEAN_LIST_SIZE
value|3
end_define

begin_function
name|void
name|pmap_remove
parameter_list|(
name|pmap_t
name|pm
parameter_list|,
name|vm_offset_t
name|sva
parameter_list|,
name|vm_offset_t
name|eva
parameter_list|)
block|{
name|struct
name|l2_bucket
modifier|*
name|l2b
decl_stmt|;
name|vm_offset_t
name|next_bucket
decl_stmt|;
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|;
name|u_int
name|total
decl_stmt|;
name|u_int
name|mappings
decl_stmt|,
name|is_exec
decl_stmt|,
name|is_refd
decl_stmt|;
name|int
name|flushall
init|=
literal|0
decl_stmt|;
comment|/* 	 * we lock in the pmap => pv_head direction 	 */
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pm
argument_list|)
expr_stmt|;
name|total
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|sva
operator|<
name|eva
condition|)
block|{
comment|/* 		 * Do one L2 bucket's worth at a time. 		 */
name|next_bucket
operator|=
name|L2_NEXT_BUCKET
argument_list|(
name|sva
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_bucket
operator|>
name|eva
condition|)
name|next_bucket
operator|=
name|eva
expr_stmt|;
name|l2b
operator|=
name|pmap_get_l2_bucket
argument_list|(
name|pm
argument_list|,
name|sva
argument_list|)
expr_stmt|;
if|if
condition|(
name|l2b
operator|==
name|NULL
condition|)
block|{
name|sva
operator|=
name|next_bucket
expr_stmt|;
continue|continue;
block|}
name|ptep
operator|=
operator|&
name|l2b
operator|->
name|l2b_kva
index|[
name|l2pte_index
argument_list|(
name|sva
argument_list|)
index|]
expr_stmt|;
name|mappings
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|sva
operator|<
name|next_bucket
condition|)
block|{
name|struct
name|vm_page
modifier|*
name|pg
decl_stmt|;
name|pt_entry_t
name|pte
decl_stmt|;
name|vm_paddr_t
name|pa
decl_stmt|;
name|pte
operator|=
operator|*
name|ptep
expr_stmt|;
if|if
condition|(
name|pte
operator|==
literal|0
condition|)
block|{
comment|/* 				 * Nothing here, move along 				 */
name|sva
operator|+=
name|PAGE_SIZE
expr_stmt|;
name|ptep
operator|++
expr_stmt|;
continue|continue;
block|}
name|pm
operator|->
name|pm_stats
operator|.
name|resident_count
operator|--
expr_stmt|;
name|pa
operator|=
name|l2pte_pa
argument_list|(
name|pte
argument_list|)
expr_stmt|;
name|is_exec
operator|=
literal|0
expr_stmt|;
name|is_refd
operator|=
literal|1
expr_stmt|;
comment|/* 			 * Update flags. In a number of circumstances, 			 * we could cluster a lot of these and do a 			 * number of sequential pages in one go. 			 */
if|if
condition|(
operator|(
name|pg
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pa
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|struct
name|pv_entry
modifier|*
name|pve
decl_stmt|;
name|pve
operator|=
name|pmap_remove_pv
argument_list|(
name|pg
argument_list|,
name|pm
argument_list|,
name|sva
argument_list|)
expr_stmt|;
if|if
condition|(
name|pve
condition|)
block|{
name|is_exec
operator|=
name|PV_BEEN_EXECD
argument_list|(
name|pve
operator|->
name|pv_flags
argument_list|)
expr_stmt|;
name|is_refd
operator|=
name|PV_BEEN_REFD
argument_list|(
name|pve
operator|->
name|pv_flags
argument_list|)
expr_stmt|;
name|pmap_free_pv_entry
argument_list|(
name|pve
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pmap_is_current
argument_list|(
name|pm
argument_list|)
condition|)
block|{
name|total
operator|++
expr_stmt|;
if|if
condition|(
name|total
operator|<
name|PMAP_REMOVE_CLEAN_LIST_SIZE
condition|)
block|{
if|if
condition|(
name|is_exec
condition|)
name|cpu_tlb_flushID_SE
argument_list|(
name|sva
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|is_refd
condition|)
name|cpu_tlb_flushD_SE
argument_list|(
name|sva
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|total
operator|==
name|PMAP_REMOVE_CLEAN_LIST_SIZE
condition|)
block|{
name|flushall
operator|=
literal|1
expr_stmt|;
block|}
block|}
operator|*
name|ptep
operator|=
literal|0
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|ptep
argument_list|)
expr_stmt|;
name|sva
operator|+=
name|PAGE_SIZE
expr_stmt|;
name|ptep
operator|++
expr_stmt|;
name|mappings
operator|++
expr_stmt|;
block|}
name|pmap_free_l2_bucket
argument_list|(
name|pm
argument_list|,
name|l2b
argument_list|,
name|mappings
argument_list|)
expr_stmt|;
block|}
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|flushall
condition|)
name|cpu_tlb_flushID
argument_list|()
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pm
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * pmap_zero_page()  *  * Zero a given physical page by mapping it at a page hook point.  * In doing the zero page op, the page we zero is mapped cachable, as with  * StrongARM accesses to non-cached pages are non-burst making writing  * _any_ bulk data very slow.  */
end_comment

begin_function
specifier|static
name|void
name|pmap_zero_page_gen
parameter_list|(
name|vm_page_t
name|pg
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|vm_paddr_t
name|phys
init|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|pg
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|pg
operator|->
name|md
operator|.
name|pv_list
argument_list|)
condition|)
name|panic
argument_list|(
literal|"pmap_zero_page: page has mappings"
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|cmtx
argument_list|)
expr_stmt|;
comment|/* 	 * Hook in the page, zero it, invalidate the TLB as needed. 	 * 	 * Note the temporary zero-page mapping must be a non-cached page in 	 * order to work without corruption when write-allocate is enabled. 	 */
operator|*
name|cdst_pte
operator|=
name|L2_S_PROTO
operator||
name|phys
operator||
name|pte_l2_s_cache_mode
expr_stmt|;
name|pmap_set_prot
argument_list|(
name|cdst_pte
argument_list|,
name|VM_PROT_WRITE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|cdst_pte
argument_list|)
expr_stmt|;
name|cpu_tlb_flushD_SE
argument_list|(
name|cdstp
argument_list|)
expr_stmt|;
name|cpu_cpwait
argument_list|()
expr_stmt|;
if|if
condition|(
name|off
operator|||
name|size
operator|!=
name|PAGE_SIZE
condition|)
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|cdstp
operator|+
name|off
operator|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
name|bzero_page
argument_list|(
name|cdstp
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|cmtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	pmap_zero_page zeros the specified hardware page by mapping  *	the page into KVM and using bzero to clear its contents.  */
end_comment

begin_function
name|void
name|pmap_zero_page
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|pmap_zero_page_gen
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	pmap_zero_page_area zeros the specified hardware page by mapping  *	the page into KVM and using bzero to clear its contents.  *  *	off and size may not cover an area beyond a single hardware page.  */
end_comment

begin_function
name|void
name|pmap_zero_page_area
parameter_list|(
name|vm_page_t
name|m
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|pmap_zero_page_gen
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	pmap_zero_page_idle zeros the specified hardware page by mapping  *	the page into KVM and using bzero to clear its contents.  This  *	is intended to be called from the vm_pagezero process only and  *	outside of Giant.  */
end_comment

begin_function
name|void
name|pmap_zero_page_idle
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|pmap_zero_page
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	pmap_copy_page copies the specified (machine independent)  *	page by mapping the page into virtual memory and using  *	bcopy to copy the page, one machine dependent page at a  *	time.  */
end_comment

begin_comment
comment|/*  * pmap_copy_page()  *  * Copy one physical page into another, by mapping the pages into  * hook points. The same comment regarding cachability as in  * pmap_zero_page also applies here.  */
end_comment

begin_function
name|void
name|pmap_copy_page_generic
parameter_list|(
name|vm_paddr_t
name|src
parameter_list|,
name|vm_paddr_t
name|dst
parameter_list|)
block|{
comment|/* 	 * Hold the source page's lock for the duration of the copy 	 * so that no other mappings can be created while we have a 	 * potentially aliased mapping. 	 * Map the pages into the page hook points, copy them, and purge 	 * the cache for the appropriate page. Invalidate the TLB 	 * as required. 	 */
name|mtx_lock
argument_list|(
operator|&
name|cmtx
argument_list|)
expr_stmt|;
comment|/* For ARMv6 using System bit is deprecated and mapping with AP 	 * bits set to 0x0 makes page not accessible. csrc_pte is mapped 	 * read/write until proper mapping defines are created for ARMv6. 	 */
operator|*
name|csrc_pte
operator|=
name|L2_S_PROTO
operator||
name|src
operator||
name|pte_l2_s_cache_mode
expr_stmt|;
name|pmap_set_prot
argument_list|(
name|csrc_pte
argument_list|,
name|VM_PROT_READ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|csrc_pte
argument_list|)
expr_stmt|;
operator|*
name|cdst_pte
operator|=
name|L2_S_PROTO
operator||
name|dst
operator||
name|pte_l2_s_cache_mode
expr_stmt|;
name|pmap_set_prot
argument_list|(
name|cdst_pte
argument_list|,
name|VM_PROT_READ
operator||
name|VM_PROT_WRITE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|cdst_pte
argument_list|)
expr_stmt|;
name|cpu_tlb_flushD_SE
argument_list|(
name|csrcp
argument_list|)
expr_stmt|;
name|cpu_tlb_flushD_SE
argument_list|(
name|cdstp
argument_list|)
expr_stmt|;
name|cpu_cpwait
argument_list|()
expr_stmt|;
name|bcopy_page
argument_list|(
name|csrcp
argument_list|,
name|cdstp
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|cmtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pmap_copy_page
parameter_list|(
name|vm_page_t
name|src
parameter_list|,
name|vm_page_t
name|dst
parameter_list|)
block|{
if|if
condition|(
name|_arm_memcpy
operator|&&
name|PAGE_SIZE
operator|>=
name|_min_memcpy_size
operator|&&
name|_arm_memcpy
argument_list|(
operator|(
name|void
operator|*
operator|)
name|VM_PAGE_TO_PHYS
argument_list|(
name|dst
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
name|VM_PAGE_TO_PHYS
argument_list|(
name|src
argument_list|)
argument_list|,
name|PAGE_SIZE
argument_list|,
name|IS_PHYSICAL
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|pmap_copy_page_generic
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|src
argument_list|)
argument_list|,
name|VM_PAGE_TO_PHYS
argument_list|(
name|dst
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * this routine returns true if a physical page resides  * in the given pmap.  */
end_comment

begin_function
name|boolean_t
name|pmap_page_exists_quick
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_page_t
name|m
parameter_list|)
block|{
name|pv_entry_t
name|pv
decl_stmt|;
name|int
name|loops
init|=
literal|0
decl_stmt|;
name|boolean_t
name|rv
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_page_exists_quick: page %p is not managed"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
name|rv
operator|=
name|FALSE
expr_stmt|;
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&m->md.pv_list
argument_list|,
argument|pv_list
argument_list|)
block|{
if|if
condition|(
name|pv
operator|->
name|pv_pmap
operator|==
name|pmap
condition|)
block|{
name|rv
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
name|loops
operator|++
expr_stmt|;
if|if
condition|(
name|loops
operator|>=
literal|16
condition|)
break|break;
block|}
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	pmap_page_wired_mappings:  *  *	Return the number of managed mappings to the given physical page  *	that are wired.  */
end_comment

begin_function
name|int
name|pmap_page_wired_mappings
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|pv_entry_t
name|pv
decl_stmt|;
name|int
name|count
decl_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_FICTITIOUS
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|count
operator|)
return|;
name|rw_wlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&m->md.pv_list
argument_list|,
argument|pv_list
argument_list|)
if|if
condition|(
operator|(
name|pv
operator|->
name|pv_flags
operator|&
name|PVF_WIRED
operator|)
operator|!=
literal|0
condition|)
name|count
operator|++
expr_stmt|;
name|rw_wunlock
argument_list|(
operator|&
name|pvh_global_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	pmap_is_referenced:  *  *	Return whether or not the specified physical page was referenced  *	in any physical maps.  */
end_comment

begin_function
name|boolean_t
name|pmap_is_referenced
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|KASSERT
argument_list|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_is_referenced: page %p is not managed"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|m
operator|->
name|md
operator|.
name|pvh_attrs
operator|&
name|PVF_REF
operator|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	pmap_ts_referenced:  *  *	Return the count of reference bits for a page, clearing all of them.  */
end_comment

begin_function
name|int
name|pmap_ts_referenced
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|KASSERT
argument_list|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_ts_referenced: page %p is not managed"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|pmap_clearbit
argument_list|(
name|m
argument_list|,
name|PVF_REF
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|boolean_t
name|pmap_is_modified
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|KASSERT
argument_list|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_is_modified: page %p is not managed"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|md
operator|.
name|pvh_attrs
operator|&
name|PVF_MOD
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	Clear the modify bits on the specified physical page.  */
end_comment

begin_function
name|void
name|pmap_clear_modify
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|KASSERT
argument_list|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_clear_modify: page %p is not managed"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
name|VM_OBJECT_LOCK_ASSERT
argument_list|(
name|m
operator|->
name|object
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_BUSY
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_clear_modify: page %p is busy"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * If the page is not PGA_WRITEABLE, then no mappings can be modified. 	 * If the object containing the page is locked and the page is not 	 * VPO_BUSY, then PGA_WRITEABLE cannot be concurrently set. 	 */
if|if
condition|(
operator|(
name|m
operator|->
name|aflags
operator|&
name|PGA_WRITEABLE
operator|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|m
operator|->
name|md
operator|.
name|pvh_attrs
operator|&
name|PVF_MOD
condition|)
name|pmap_clearbit
argument_list|(
name|m
argument_list|,
name|PVF_MOD
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	pmap_clear_reference:  *  *	Clear the reference bit on the specified physical page.  */
end_comment

begin_function
name|void
name|pmap_clear_reference
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|KASSERT
argument_list|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_clear_reference: page %p is not managed"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|md
operator|.
name|pvh_attrs
operator|&
name|PVF_REF
condition|)
name|pmap_clearbit
argument_list|(
name|m
argument_list|,
name|PVF_REF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Clear the write and modified bits in each of the given page's mappings.  */
end_comment

begin_function
name|void
name|pmap_remove_write
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|KASSERT
argument_list|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_remove_write: page %p is not managed"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * If the page is not VPO_BUSY, then PGA_WRITEABLE cannot be set by 	 * another thread while the object is locked.  Thus, if PGA_WRITEABLE 	 * is clear, no page table entries need updating. 	 */
name|VM_OBJECT_LOCK_ASSERT
argument_list|(
name|m
operator|->
name|object
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_BUSY
operator|)
operator|!=
literal|0
operator|||
operator|(
name|m
operator|->
name|aflags
operator|&
name|PGA_WRITEABLE
operator|)
operator|!=
literal|0
condition|)
name|pmap_clearbit
argument_list|(
name|m
argument_list|,
name|PVF_WRITE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * perform the pmap work for mincore  */
end_comment

begin_function
name|int
name|pmap_mincore
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|addr
parameter_list|,
name|vm_paddr_t
modifier|*
name|locked_pa
parameter_list|)
block|{
name|printf
argument_list|(
literal|"pmap_mincore()\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pmap_sync_icache
parameter_list|(
name|pmap_t
name|pm
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_size_t
name|sz
parameter_list|)
block|{ }
end_function

begin_comment
comment|/*  *	Increase the starting virtual address of the given mapping if a  *	different alignment might result in more superpage mappings.  */
end_comment

begin_function
name|void
name|pmap_align_superpage
parameter_list|(
name|vm_object_t
name|object
parameter_list|,
name|vm_ooffset_t
name|offset
parameter_list|,
name|vm_offset_t
modifier|*
name|addr
parameter_list|,
name|vm_size_t
name|size
parameter_list|)
block|{ }
end_function

begin_comment
comment|/*  * Map a set of physical memory pages into the kernel virtual  * address space. Return a pointer to where it is mapped. This  * routine is intended to be used for mapping device memory,  * NOT real memory.  */
end_comment

begin_function
name|void
modifier|*
name|pmap_mapdev
parameter_list|(
name|vm_offset_t
name|pa
parameter_list|,
name|vm_size_t
name|size
parameter_list|)
block|{
name|vm_offset_t
name|va
decl_stmt|,
name|tmpva
decl_stmt|,
name|offset
decl_stmt|;
name|offset
operator|=
name|pa
operator|&
name|PAGE_MASK
expr_stmt|;
name|size
operator|=
name|roundup
argument_list|(
name|size
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|GIANT_REQUIRED
expr_stmt|;
name|va
operator|=
name|kmem_alloc_nofault
argument_list|(
name|kernel_map
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|va
condition|)
name|panic
argument_list|(
literal|"pmap_mapdev: Couldn't alloc kernel virtual memory"
argument_list|)
expr_stmt|;
for|for
control|(
name|tmpva
operator|=
name|va
init|;
name|size
operator|>
literal|0
condition|;
control|)
block|{
name|pmap_kenter_internal
argument_list|(
name|tmpva
argument_list|,
name|pa
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|size
operator|-=
name|PAGE_SIZE
expr_stmt|;
name|tmpva
operator|+=
name|PAGE_SIZE
expr_stmt|;
name|pa
operator|+=
name|PAGE_SIZE
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|void
operator|*
operator|)
operator|(
name|va
operator|+
name|offset
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * pmap_map_section:  *  *	Create a single section mapping.  */
end_comment

begin_function
name|void
name|pmap_map_section
parameter_list|(
name|vm_offset_t
name|l1pt
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_offset_t
name|pa
parameter_list|,
name|int
name|prot
parameter_list|,
name|int
name|cache
parameter_list|)
block|{
name|pd_entry_t
modifier|*
name|pde
init|=
operator|(
name|pd_entry_t
operator|*
operator|)
name|l1pt
decl_stmt|;
name|pd_entry_t
name|fl
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
operator|(
name|va
operator||
name|pa
operator|)
operator|&
name|L1_S_OFFSET
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"ouin2"
operator|)
argument_list|)
expr_stmt|;
name|fl
operator|=
name|l1_mem_types
index|[
name|cache
index|]
expr_stmt|;
name|pde
index|[
name|va
operator|>>
name|L1_S_SHIFT
index|]
operator|=
name|L1_S_PROTO
operator||
name|pa
operator||
name|L1_S_PROT
argument_list|(
name|PTE_KERNEL
argument_list|,
name|prot
argument_list|)
operator||
name|fl
operator||
name|L1_S_DOM
argument_list|(
name|PMAP_DOMAIN_KERNEL
argument_list|)
expr_stmt|;
name|PTE_SYNC
argument_list|(
operator|&
name|pde
index|[
name|va
operator|>>
name|L1_S_SHIFT
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * pmap_link_l2pt:  *  *	Link the L2 page table specified by l2pv.pv_pa into the L1  *	page table at the slot for "va".  */
end_comment

begin_function
name|void
name|pmap_link_l2pt
parameter_list|(
name|vm_offset_t
name|l1pt
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|struct
name|pv_addr
modifier|*
name|l2pv
parameter_list|)
block|{
name|pd_entry_t
modifier|*
name|pde
init|=
operator|(
name|pd_entry_t
operator|*
operator|)
name|l1pt
decl_stmt|,
name|proto
decl_stmt|;
name|u_int
name|slot
init|=
name|va
operator|>>
name|L1_S_SHIFT
decl_stmt|;
name|proto
operator|=
name|L1_S_DOM
argument_list|(
name|PMAP_DOMAIN_KERNEL
argument_list|)
operator||
name|L1_C_PROTO
expr_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE_INIT_ARM
name|printf
argument_list|(
literal|"pmap_link_l2pt: pa=0x%x va=0x%x\n"
argument_list|,
name|l2pv
operator|->
name|pv_pa
argument_list|,
name|l2pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pde
index|[
name|slot
operator|+
literal|0
index|]
operator|=
name|proto
operator||
operator|(
name|l2pv
operator|->
name|pv_pa
operator|+
literal|0x000
operator|)
expr_stmt|;
name|PTE_SYNC
argument_list|(
operator|&
name|pde
index|[
name|slot
index|]
argument_list|)
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|kernel_pt_list
argument_list|,
name|l2pv
argument_list|,
name|pv_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * pmap_map_entry  *  *	Create a single page mapping.  */
end_comment

begin_function
name|void
name|pmap_map_entry
parameter_list|(
name|vm_offset_t
name|l1pt
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_offset_t
name|pa
parameter_list|,
name|int
name|prot
parameter_list|,
name|int
name|cache
parameter_list|)
block|{
name|pd_entry_t
modifier|*
name|pde
init|=
operator|(
name|pd_entry_t
operator|*
operator|)
name|l1pt
decl_stmt|;
name|pt_entry_t
name|fl
decl_stmt|;
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
operator|(
name|va
operator||
name|pa
operator|)
operator|&
name|PAGE_MASK
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"ouin"
operator|)
argument_list|)
expr_stmt|;
name|fl
operator|=
name|l2s_mem_types
index|[
name|cache
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|pde
index|[
name|va
operator|>>
name|L1_S_SHIFT
index|]
operator|&
name|L1_TYPE_MASK
operator|)
operator|!=
name|L1_TYPE_C
condition|)
name|panic
argument_list|(
literal|"pmap_map_entry: no L2 table for VA 0x%08x"
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|pte
operator|=
operator|(
name|pt_entry_t
operator|*
operator|)
name|kernel_pt_lookup
argument_list|(
name|pde
index|[
name|L1_IDX
argument_list|(
name|va
argument_list|)
index|]
operator|&
name|L1_C_ADDR_MASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|pte
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"pmap_map_entry: can't find L2 table for VA 0x%08x"
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|pte
index|[
name|l2pte_index
argument_list|(
name|va
argument_list|)
index|]
operator|=
name|L2_S_PROTO
operator||
name|pa
operator||
name|fl
expr_stmt|;
name|pmap_set_prot
argument_list|(
operator|&
name|pte
index|[
name|l2pte_index
argument_list|(
name|va
argument_list|)
index|]
argument_list|,
name|prot
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PTE_SYNC
argument_list|(
operator|&
name|pte
index|[
name|l2pte_index
argument_list|(
name|va
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * pmap_map_chunk:  *  *	Map a chunk of memory using the most efficient mappings  *	possible (section. large page, small page) into the  *	provided L1 and L2 tables at the specified virtual address.  */
end_comment

begin_function
name|vm_size_t
name|pmap_map_chunk
parameter_list|(
name|vm_offset_t
name|l1pt
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_offset_t
name|pa
parameter_list|,
name|vm_size_t
name|size
parameter_list|,
name|int
name|prot
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|pd_entry_t
modifier|*
name|pde
init|=
operator|(
name|pd_entry_t
operator|*
operator|)
name|l1pt
decl_stmt|;
name|pt_entry_t
modifier|*
name|pte
decl_stmt|,
name|f1
decl_stmt|,
name|f2s
decl_stmt|,
name|f2l
decl_stmt|;
name|vm_size_t
name|resid
decl_stmt|;
name|int
name|i
decl_stmt|;
name|resid
operator|=
operator|(
name|size
operator|+
operator|(
name|PAGE_SIZE
operator|-
literal|1
operator|)
operator|)
operator|&
operator|~
operator|(
name|PAGE_SIZE
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|l1pt
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"pmap_map_chunk: no L1 table provided"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE_INIT_ARM
name|printf
argument_list|(
literal|"pmap_map_chunk: pa=0x%x va=0x%x size=0x%x resid=0x%x "
literal|"prot=0x%x type=%d\n"
argument_list|,
name|pa
argument_list|,
name|va
argument_list|,
name|size
argument_list|,
name|resid
argument_list|,
name|prot
argument_list|,
name|type
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|f1
operator|=
name|l1_mem_types
index|[
name|type
index|]
expr_stmt|;
name|f2l
operator|=
name|l2l_mem_types
index|[
name|type
index|]
expr_stmt|;
name|f2s
operator|=
name|l2s_mem_types
index|[
name|type
index|]
expr_stmt|;
name|size
operator|=
name|resid
expr_stmt|;
while|while
condition|(
name|resid
operator|>
literal|0
condition|)
block|{
comment|/* See if we can use a section mapping. */
if|if
condition|(
name|L1_S_MAPPABLE_P
argument_list|(
name|va
argument_list|,
name|pa
argument_list|,
name|resid
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|VERBOSE_INIT_ARM
name|printf
argument_list|(
literal|"S"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pde
index|[
name|va
operator|>>
name|L1_S_SHIFT
index|]
operator|=
name|L1_S_PROTO
operator||
name|pa
operator||
name|L1_S_PROT
argument_list|(
name|PTE_KERNEL
argument_list|,
name|prot
argument_list|)
operator||
name|f1
operator||
name|L1_S_DOM
argument_list|(
name|PMAP_DOMAIN_KERNEL
argument_list|)
expr_stmt|;
name|PTE_SYNC
argument_list|(
operator|&
name|pde
index|[
name|va
operator|>>
name|L1_S_SHIFT
index|]
argument_list|)
expr_stmt|;
name|va
operator|+=
name|L1_S_SIZE
expr_stmt|;
name|pa
operator|+=
name|L1_S_SIZE
expr_stmt|;
name|resid
operator|-=
name|L1_S_SIZE
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Ok, we're going to use an L2 table.  Make sure 		 * one is actually in the corresponding L1 slot 		 * for the current VA. 		 */
if|if
condition|(
operator|(
name|pde
index|[
name|va
operator|>>
name|L1_S_SHIFT
index|]
operator|&
name|L1_TYPE_MASK
operator|)
operator|!=
name|L1_TYPE_C
condition|)
name|panic
argument_list|(
literal|"pmap_map_chunk: no L2 table for VA 0x%08x"
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|pte
operator|=
operator|(
name|pt_entry_t
operator|*
operator|)
name|kernel_pt_lookup
argument_list|(
name|pde
index|[
name|L1_IDX
argument_list|(
name|va
argument_list|)
index|]
operator|&
name|L1_C_ADDR_MASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|pte
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"pmap_map_chunk: can't find L2 table for VA"
literal|"0x%08x"
argument_list|,
name|va
argument_list|)
expr_stmt|;
comment|/* See if we can use a L2 large page mapping. */
if|if
condition|(
name|L2_L_MAPPABLE_P
argument_list|(
name|va
argument_list|,
name|pa
argument_list|,
name|resid
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|VERBOSE_INIT_ARM
name|printf
argument_list|(
literal|"L"
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|pte
index|[
name|l2pte_index
argument_list|(
name|va
argument_list|)
operator|+
name|i
index|]
operator|=
name|L2_L_PROTO
operator||
name|pa
operator||
name|L2_L_PROT
argument_list|(
name|PTE_KERNEL
argument_list|,
name|prot
argument_list|)
operator||
name|f2l
expr_stmt|;
name|PTE_SYNC
argument_list|(
operator|&
name|pte
index|[
name|l2pte_index
argument_list|(
name|va
argument_list|)
operator|+
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|va
operator|+=
name|L2_L_SIZE
expr_stmt|;
name|pa
operator|+=
name|L2_L_SIZE
expr_stmt|;
name|resid
operator|-=
name|L2_L_SIZE
expr_stmt|;
continue|continue;
block|}
comment|/* Use a small page mapping. */
ifdef|#
directive|ifdef
name|VERBOSE_INIT_ARM
name|printf
argument_list|(
literal|"P"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pte
index|[
name|l2pte_index
argument_list|(
name|va
argument_list|)
index|]
operator|=
name|L2_S_PROTO
operator||
name|pa
operator||
name|f2s
expr_stmt|;
name|pmap_set_prot
argument_list|(
operator|&
name|pte
index|[
name|l2pte_index
argument_list|(
name|va
argument_list|)
index|]
argument_list|,
name|prot
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PTE_SYNC
argument_list|(
operator|&
name|pte
index|[
name|l2pte_index
argument_list|(
name|va
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|va
operator|+=
name|PAGE_SIZE
expr_stmt|;
name|pa
operator|+=
name|PAGE_SIZE
expr_stmt|;
name|resid
operator|-=
name|PAGE_SIZE
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|VERBOSE_INIT_ARM
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|size
operator|)
return|;
block|}
end_function

begin_comment
comment|/********************** Static device map routines ***************************/
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|pmap_devmap
modifier|*
name|pmap_devmap_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Register the devmap table.  This is provided in case early console  * initialization needs to register mappings created by bootstrap code  * before pmap_devmap_bootstrap() is called.  */
end_comment

begin_function
name|void
name|pmap_devmap_register
parameter_list|(
specifier|const
name|struct
name|pmap_devmap
modifier|*
name|table
parameter_list|)
block|{
name|pmap_devmap_table
operator|=
name|table
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Map all of the static regions in the devmap table, and remember  * the devmap table so other parts of the kernel can look up entries  * later.  */
end_comment

begin_function
name|void
name|pmap_devmap_bootstrap
parameter_list|(
name|vm_offset_t
name|l1pt
parameter_list|,
specifier|const
name|struct
name|pmap_devmap
modifier|*
name|table
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|pmap_devmap_table
operator|=
name|table
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|pmap_devmap_table
index|[
name|i
index|]
operator|.
name|pd_size
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|VERBOSE_INIT_ARM
name|printf
argument_list|(
literal|"devmap: %08x -> %08x @ %08x\n"
argument_list|,
name|pmap_devmap_table
index|[
name|i
index|]
operator|.
name|pd_pa
argument_list|,
name|pmap_devmap_table
index|[
name|i
index|]
operator|.
name|pd_pa
operator|+
name|pmap_devmap_table
index|[
name|i
index|]
operator|.
name|pd_size
operator|-
literal|1
argument_list|,
name|pmap_devmap_table
index|[
name|i
index|]
operator|.
name|pd_va
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pmap_map_chunk
argument_list|(
name|l1pt
argument_list|,
name|pmap_devmap_table
index|[
name|i
index|]
operator|.
name|pd_va
argument_list|,
name|pmap_devmap_table
index|[
name|i
index|]
operator|.
name|pd_pa
argument_list|,
name|pmap_devmap_table
index|[
name|i
index|]
operator|.
name|pd_size
argument_list|,
name|pmap_devmap_table
index|[
name|i
index|]
operator|.
name|pd_prot
argument_list|,
name|pmap_devmap_table
index|[
name|i
index|]
operator|.
name|pd_cache
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|const
name|struct
name|pmap_devmap
modifier|*
name|pmap_devmap_find_pa
parameter_list|(
name|vm_paddr_t
name|pa
parameter_list|,
name|vm_size_t
name|size
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|pmap_devmap_table
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|pmap_devmap_table
index|[
name|i
index|]
operator|.
name|pd_size
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pa
operator|>=
name|pmap_devmap_table
index|[
name|i
index|]
operator|.
name|pd_pa
operator|&&
name|pa
operator|+
name|size
operator|<=
name|pmap_devmap_table
index|[
name|i
index|]
operator|.
name|pd_pa
operator|+
name|pmap_devmap_table
index|[
name|i
index|]
operator|.
name|pd_size
condition|)
return|return
operator|(
operator|&
name|pmap_devmap_table
index|[
name|i
index|]
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|struct
name|pmap_devmap
modifier|*
name|pmap_devmap_find_va
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|vm_size_t
name|size
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|pmap_devmap_table
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|pmap_devmap_table
index|[
name|i
index|]
operator|.
name|pd_size
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|va
operator|>=
name|pmap_devmap_table
index|[
name|i
index|]
operator|.
name|pd_va
operator|&&
name|va
operator|+
name|size
operator|<=
name|pmap_devmap_table
index|[
name|i
index|]
operator|.
name|pd_va
operator|+
name|pmap_devmap_table
index|[
name|i
index|]
operator|.
name|pd_size
condition|)
return|return
operator|(
operator|&
name|pmap_devmap_table
index|[
name|i
index|]
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pmap_dmap_iscurrent
parameter_list|(
name|pmap_t
name|pmap
parameter_list|)
block|{
return|return
operator|(
name|pmap_is_current
argument_list|(
name|pmap
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

