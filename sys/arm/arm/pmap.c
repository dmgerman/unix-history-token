begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* From: $NetBSD: pmap.c,v 1.148 2004/04/03 04:35:48 bsh Exp $ */
end_comment

begin_comment
comment|/*-  * Copyright 2004 Olivier Houchard.  * Copyright 2003 Wasabi Systems, Inc.  * All rights reserved.  *  * Written by Steve C. Woodford for Wasabi Systems, Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *      This product includes software developed for the NetBSD Project by  *      Wasabi Systems, Inc.  * 4. The name of Wasabi Systems, Inc. may not be used to endorse  *    or promote products derived from this software without specific prior  *    written permission.  *  * THIS SOFTWARE IS PROVIDED BY WASABI SYSTEMS, INC. ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL WASABI SYSTEMS, INC  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*-  * Copyright (c) 2002-2003 Wasabi Systems, Inc.  * Copyright (c) 2001 Richard Earnshaw  * Copyright (c) 2001-2002 Christopher Gilbert  * All rights reserved.  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the company nor the name of the author may be used to  *    endorse or promote products derived from this software without specific  *    prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*-  * Copyright (c) 1999 The NetBSD Foundation, Inc.  * All rights reserved.  *  * This code is derived from software contributed to The NetBSD Foundation  * by Charles M. Hannum.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *        This product includes software developed by the NetBSD  *        Foundation, Inc. and its contributors.  * 4. Neither the name of The NetBSD Foundation nor the names of its  *    contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*-  * Copyright (c) 1994-1998 Mark Brinicombe.  * Copyright (c) 1994 Brini.  * All rights reserved.  *  * This code is derived from software written for Brini by Mark Brinicombe  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *      This product includes software developed by Mark Brinicombe.  * 4. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  *  * RiscBSD kernel project  *  * pmap.c  *  * Machine dependant vm stuff  *  * Created      : 20/09/94  */
end_comment

begin_comment
comment|/*  * Special compilation symbols  * PMAP_DEBUG           - Build in pmap_debug_level code  */
end_comment

begin_comment
comment|/* Include header files */
end_comment

begin_include
include|#
directive|include
file|"opt_vm.h"
end_include

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/msgbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmmeter.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/sched.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pageout.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/vmparam.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpufunc.h>
end_include

begin_include
include|#
directive|include
file|<machine/pcb.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|PMAP_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|PDEBUG
parameter_list|(
name|_lev_
parameter_list|,
name|_stat_
parameter_list|)
define|\
value|if (pmap_debug_level>= (_lev_)) \                 ((_stat_))
end_define

begin_define
define|#
directive|define
name|dprintf
value|printf
end_define

begin_decl_stmt
name|int
name|pmap_debug_level
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|PMAP_INLINE
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* PMAP_DEBUG */
end_comment

begin_define
define|#
directive|define
name|PDEBUG
parameter_list|(
name|_lev_
parameter_list|,
name|_stat_
parameter_list|)
end_define

begin_comment
comment|/* Nothing */
end_comment

begin_define
define|#
directive|define
name|dprintf
parameter_list|(
name|x
parameter_list|,
name|arg
modifier|...
parameter_list|)
end_define

begin_define
define|#
directive|define
name|PMAP_INLINE
value|__inline
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PMAP_DEBUG */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|pv_addr
name|systempage
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Internal function prototypes  */
end_comment

begin_function_decl
specifier|static
name|void
name|pmap_free_pv_entry
parameter_list|(
name|pv_entry_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|pv_entry_t
name|pmap_get_pv_entry
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmap_vac_me_harder
parameter_list|(
name|struct
name|vm_page
modifier|*
parameter_list|,
name|pmap_t
parameter_list|,
name|vm_offset_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmap_vac_me_kpmap
parameter_list|(
name|struct
name|vm_page
modifier|*
parameter_list|,
name|pmap_t
parameter_list|,
name|vm_offset_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmap_vac_me_user
parameter_list|(
name|struct
name|vm_page
modifier|*
parameter_list|,
name|pmap_t
parameter_list|,
name|vm_offset_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmap_alloc_l1
parameter_list|(
name|pmap_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmap_free_l1
parameter_list|(
name|pmap_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmap_use_l1
parameter_list|(
name|pmap_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pmap_clearbit
parameter_list|(
name|struct
name|vm_page
modifier|*
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|l2_bucket
modifier|*
name|pmap_get_l2_bucket
parameter_list|(
name|pmap_t
parameter_list|,
name|vm_offset_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|l2_bucket
modifier|*
name|pmap_alloc_l2_bucket
parameter_list|(
name|pmap_t
parameter_list|,
name|vm_offset_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmap_free_l2_bucket
parameter_list|(
name|pmap_t
parameter_list|,
name|struct
name|l2_bucket
modifier|*
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|vm_offset_t
name|kernel_pt_lookup
parameter_list|(
name|vm_paddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_VMPMAP
argument_list|,
literal|"pmap"
argument_list|,
literal|"PMAP L1"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|vm_offset_t
name|avail_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* PA of last available physical page */
end_comment

begin_decl_stmt
name|vm_offset_t
name|virtual_avail
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* VA of first avail page (after kernel bss) */
end_comment

begin_decl_stmt
name|vm_offset_t
name|virtual_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* VA of last avail page (end of kernel AS) */
end_comment

begin_decl_stmt
name|vm_offset_t
name|pmap_curmaxkvaddr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_paddr_t
name|kernel_l1pa
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
modifier|*
name|end
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_offset_t
name|kernel_vm_end
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pmap
name|kernel_pmap_store
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|pmap_t
name|kernel_pmap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|pt_entry_t
modifier|*
name|csrc_pte
decl_stmt|,
modifier|*
name|cdst_pte
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vm_offset_t
name|csrcp
decl_stmt|,
name|cdstp
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|pmap_init_l1
parameter_list|(
name|struct
name|l1_ttable
modifier|*
parameter_list|,
name|pd_entry_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * These routines are called when the CPU type is identified to set up  * the PTE prototypes, cache modes, etc.  *  * The variables are always here, just in case LKMs need to reference  * them (though, they shouldn't).  */
end_comment

begin_decl_stmt
name|pt_entry_t
name|pte_l1_s_cache_mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|pt_entry_t
name|pte_l1_s_cache_mode_pt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|pt_entry_t
name|pte_l1_s_cache_mask
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|pt_entry_t
name|pte_l2_l_cache_mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|pt_entry_t
name|pte_l2_l_cache_mode_pt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|pt_entry_t
name|pte_l2_l_cache_mask
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|pt_entry_t
name|pte_l2_s_cache_mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|pt_entry_t
name|pte_l2_s_cache_mode_pt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|pt_entry_t
name|pte_l2_s_cache_mask
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|pt_entry_t
name|pte_l2_s_prot_u
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|pt_entry_t
name|pte_l2_s_prot_w
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|pt_entry_t
name|pte_l2_s_prot_mask
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|pt_entry_t
name|pte_l1_s_proto
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|pt_entry_t
name|pte_l1_c_proto
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|pt_entry_t
name|pte_l2_s_proto
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
function_decl|(
modifier|*
name|pmap_copy_page_func
function_decl|)
parameter_list|(
name|vm_paddr_t
parameter_list|,
name|vm_paddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
function_decl|(
modifier|*
name|pmap_zero_page_func
function_decl|)
parameter_list|(
name|vm_paddr_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Which pmap is currently 'live' in the cache  *  * XXXSCW: Fix for SMP ...  */
end_comment

begin_decl_stmt
name|union
name|pmap_cache_state
modifier|*
name|pmap_cache_state
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|LIST_HEAD
argument_list|(
name|pmaplist
argument_list|,
name|pmap
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|pmaplist
name|allpmaps
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* static pt_entry_t *msgbufmap;*/
end_comment

begin_decl_stmt
name|struct
name|msgbuf
modifier|*
name|msgbufp
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|void
name|bcopy_page
parameter_list|(
name|vm_offset_t
parameter_list|,
name|vm_offset_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|bzero_page
parameter_list|(
name|vm_offset_t
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|char
modifier|*
name|_tmppt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Metadata for L1 translation tables.  */
end_comment

begin_struct
struct|struct
name|l1_ttable
block|{
comment|/* Entry on the L1 Table list */
name|SLIST_ENTRY
argument_list|(
argument|l1_ttable
argument_list|)
name|l1_link
expr_stmt|;
comment|/* Entry on the L1 Least Recently Used list */
name|TAILQ_ENTRY
argument_list|(
argument|l1_ttable
argument_list|)
name|l1_lru
expr_stmt|;
comment|/* Track how many domains are allocated from this L1 */
specifier|volatile
name|u_int
name|l1_domain_use_count
decl_stmt|;
comment|/* 	 * A free-list of domain numbers for this L1. 	 * We avoid using ffs() and a bitmap to track domains since ffs() 	 * is slow on ARM. 	 */
name|u_int8_t
name|l1_domain_first
decl_stmt|;
name|u_int8_t
name|l1_domain_free
index|[
name|PMAP_DOMAINS
index|]
decl_stmt|;
comment|/* Physical address of this L1 page table */
name|vm_paddr_t
name|l1_physaddr
decl_stmt|;
comment|/* KVA of this L1 page table */
name|pd_entry_t
modifier|*
name|l1_kva
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Convert a virtual address into its L1 table index. That is, the  * index used to locate the L2 descriptor table pointer in an L1 table.  * This is basically used to index l1->l1_kva[].  *  * Each L2 descriptor table represents 1MB of VA space.  */
end_comment

begin_define
define|#
directive|define
name|L1_IDX
parameter_list|(
name|va
parameter_list|)
value|(((vm_offset_t)(va))>> L1_S_SHIFT)
end_define

begin_comment
comment|/*  * L1 Page Tables are tracked using a Least Recently Used list.  *  - New L1s are allocated from the HEAD.  *  - Freed L1s are added to the TAIl.  *  - Recently accessed L1s (where an 'access' is some change to one of  *    the userland pmaps which owns this L1) are moved to the TAIL.  */
end_comment

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|l1_ttable
argument_list|)
name|l1_lru_list
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * A list of all L1 tables  */
end_comment

begin_expr_stmt
specifier|static
name|SLIST_HEAD
argument_list|(
argument_list|,
argument|l1_ttable
argument_list|)
name|l1_list
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|l1_lru_lock
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The l2_dtable tracks L2_BUCKET_SIZE worth of L1 slots.  *  * This is normally 16MB worth L2 page descriptors for any given pmap.  * Reference counts are maintained for L2 descriptors so they can be  * freed when empty.  */
end_comment

begin_struct
struct|struct
name|l2_dtable
block|{
comment|/* The number of L2 page descriptors allocated to this l2_dtable */
name|u_int
name|l2_occupancy
decl_stmt|;
comment|/* List of L2 page descriptors */
struct|struct
name|l2_bucket
block|{
name|pt_entry_t
modifier|*
name|l2b_kva
decl_stmt|;
comment|/* KVA of L2 Descriptor Table */
name|vm_paddr_t
name|l2b_phys
decl_stmt|;
comment|/* Physical address of same */
name|u_short
name|l2b_l1idx
decl_stmt|;
comment|/* This L2 table's L1 index */
name|u_short
name|l2b_occupancy
decl_stmt|;
comment|/* How many active descriptors */
block|}
name|l2_bucket
index|[
name|L2_BUCKET_SIZE
index|]
struct|;
block|}
struct|;
end_struct

begin_comment
comment|/* pmap_kenter_internal flags */
end_comment

begin_define
define|#
directive|define
name|KENTER_CACHE
value|0x1
end_define

begin_define
define|#
directive|define
name|KENTER_USER
value|0x2
end_define

begin_comment
comment|/*  * Given an L1 table index, calculate the corresponding l2_dtable index  * and bucket index within the l2_dtable.  */
end_comment

begin_define
define|#
directive|define
name|L2_IDX
parameter_list|(
name|l1idx
parameter_list|)
value|(((l1idx)>> L2_BUCKET_LOG2)& \ 				 (L2_SIZE - 1))
end_define

begin_define
define|#
directive|define
name|L2_BUCKET
parameter_list|(
name|l1idx
parameter_list|)
value|((l1idx)& (L2_BUCKET_SIZE - 1))
end_define

begin_comment
comment|/*  * Given a virtual address, this macro returns the  * virtual address required to drop into the next L2 bucket.  */
end_comment

begin_define
define|#
directive|define
name|L2_NEXT_BUCKET
parameter_list|(
name|va
parameter_list|)
value|(((va)& L1_S_FRAME) + L1_S_SIZE)
end_define

begin_comment
comment|/*  * L2 allocation.  */
end_comment

begin_define
define|#
directive|define
name|pmap_alloc_l2_dtable
parameter_list|()
define|\
value|(void*)uma_zalloc(l2table_zone, M_NOWAIT)
end_define

begin_define
define|#
directive|define
name|pmap_free_l2_dtable
parameter_list|(
name|l2
parameter_list|)
define|\
value|uma_zfree(l2table_zone, l2)
end_define

begin_comment
comment|/*  * We try to map the page tables write-through, if possible.  However, not  * all CPUs have a write-through cache mode, so on those we have to sync  * the cache when we frob page tables.  *  * We try to evaluate this at compile time, if possible.  However, it's  * not always possible to do that, hence this run-time var.  */
end_comment

begin_decl_stmt
name|int
name|pmap_needs_pte_sync
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Macro to determine if a mapping might be resident in the  * instruction cache and/or TLB  */
end_comment

begin_define
define|#
directive|define
name|PV_BEEN_EXECD
parameter_list|(
name|f
parameter_list|)
value|(((f)& (PVF_REF | PVF_EXEC)) == (PVF_REF | PVF_EXEC))
end_define

begin_comment
comment|/*  * Macro to determine if a mapping might be resident in the  * data cache and/or TLB  */
end_comment

begin_define
define|#
directive|define
name|PV_BEEN_REFD
parameter_list|(
name|f
parameter_list|)
value|(((f)& PVF_REF) != 0)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|PMAP_SHPGPERPROC
end_ifndef

begin_define
define|#
directive|define
name|PMAP_SHPGPERPROC
value|200
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|pmap_is_current
parameter_list|(
name|pm
parameter_list|)
value|((pm) == pmap_kernel() || \             curproc->p_vmspace->vm_map.pmap == (pm))
end_define

begin_decl_stmt
specifier|static
name|uma_zone_t
name|pvzone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uma_zone_t
name|l2zone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uma_zone_t
name|l2table_zone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vm_offset_t
name|pmap_kernel_l2dtable_kva
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vm_offset_t
name|pmap_kernel_l2ptp_kva
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vm_paddr_t
name|pmap_kernel_l2ptp_phys
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|vm_object
name|pvzone_obj
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|vm_object
name|l2zone_obj
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pv_entry_count
init|=
literal|0
decl_stmt|,
name|pv_entry_max
init|=
literal|0
decl_stmt|,
name|pv_entry_high_water
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pmap_pagedaemon_waken
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This list exists for the benefit of pmap_map_chunk().  It keeps track  * of the kernel L2 tables during bootstrap, so that pmap_map_chunk() can  * find them as necessary.  *  * Note that the data on this list MUST remain valid after initarm() returns,  * as pmap_bootstrap() uses it to contruct L2 table metadata.  */
end_comment

begin_macro
name|SLIST_HEAD
argument_list|(
argument_list|,
argument|pv_addr
argument_list|)
end_macro

begin_expr_stmt
name|kernel_pt_list
operator|=
name|SLIST_HEAD_INITIALIZER
argument_list|(
name|kernel_pt_list
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|pmap_init_l1
parameter_list|(
name|struct
name|l1_ttable
modifier|*
name|l1
parameter_list|,
name|pd_entry_t
modifier|*
name|l1pt
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|l1
operator|->
name|l1_kva
operator|=
name|l1pt
expr_stmt|;
name|l1
operator|->
name|l1_domain_use_count
operator|=
literal|0
expr_stmt|;
name|l1
operator|->
name|l1_domain_first
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PMAP_DOMAINS
condition|;
name|i
operator|++
control|)
name|l1
operator|->
name|l1_domain_free
index|[
name|i
index|]
operator|=
name|i
operator|+
literal|1
expr_stmt|;
comment|/* 	 * Copy the kernel's L1 entries to each new L1. 	 */
if|if
condition|(
name|l1pt
operator|!=
name|pmap_kernel
argument_list|()
operator|->
name|pm_l1
operator|->
name|l1_kva
condition|)
name|memcpy
argument_list|(
name|l1pt
argument_list|,
name|pmap_kernel
argument_list|()
operator|->
name|pm_l1
operator|->
name|l1_kva
argument_list|,
name|L1_TABLE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|l1
operator|->
name|l1_physaddr
operator|=
name|pmap_extract
argument_list|(
name|pmap_kernel
argument_list|()
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|l1pt
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"pmap_init_l1: can't get PA of L1 at %p"
argument_list|,
name|l1pt
argument_list|)
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|l1_list
argument_list|,
name|l1
argument_list|,
name|l1_link
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|l1_lru_list
argument_list|,
name|l1
argument_list|,
name|l1_lru
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|vm_offset_t
name|kernel_pt_lookup
parameter_list|(
name|vm_paddr_t
name|pa
parameter_list|)
block|{
name|struct
name|pv_addr
modifier|*
name|pv
decl_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&kernel_pt_list
argument_list|,
argument|pv_list
argument_list|)
block|{
ifndef|#
directive|ifndef
name|ARM32_NEW_VM_LAYOUT
if|if
condition|(
name|pv
operator|->
name|pv_pa
operator|==
operator|(
name|pa
operator|&
operator|~
name|PAGE_MASK
operator|)
condition|)
block|{
return|return
operator|(
name|pv
operator|->
name|pv_va
operator||
operator|(
name|pa
operator|&
name|PAGE_MASK
operator|)
operator|)
return|;
block|}
else|#
directive|else
if|if
condition|(
name|pv
operator|->
name|pv_pa
operator|==
name|pa
condition|)
return|return
operator|(
name|pv
operator|->
name|pv_va
operator|)
return|;
endif|#
directive|endif
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
operator|(
name|ARM_MMU_GENERIC
operator|+
name|ARM_MMU_SA1
operator|)
operator|!=
literal|0
end_if

begin_function
name|void
name|pmap_pte_init_generic
parameter_list|(
name|void
parameter_list|)
block|{
name|pte_l1_s_cache_mode
operator|=
name|L1_S_B
operator||
name|L1_S_C
expr_stmt|;
name|pte_l1_s_cache_mask
operator|=
name|L1_S_CACHE_MASK_generic
expr_stmt|;
name|pte_l2_l_cache_mode
operator|=
name|L2_B
operator||
name|L2_C
expr_stmt|;
name|pte_l2_l_cache_mask
operator|=
name|L2_L_CACHE_MASK_generic
expr_stmt|;
name|pte_l2_s_cache_mode
operator|=
name|L2_B
operator||
name|L2_C
expr_stmt|;
name|pte_l2_s_cache_mask
operator|=
name|L2_S_CACHE_MASK_generic
expr_stmt|;
comment|/* 	 * If we have a write-through cache, set B and C.  If 	 * we have a write-back cache, then we assume setting 	 * only C will make those pages write-through. 	 */
if|if
condition|(
name|cpufuncs
operator|.
name|cf_dcache_wb_range
operator|==
operator|(
name|void
operator|*
operator|)
name|cpufunc_nullop
condition|)
block|{
name|pte_l1_s_cache_mode_pt
operator|=
name|L1_S_B
operator||
name|L1_S_C
expr_stmt|;
name|pte_l2_l_cache_mode_pt
operator|=
name|L2_B
operator||
name|L2_C
expr_stmt|;
name|pte_l2_s_cache_mode_pt
operator|=
name|L2_B
operator||
name|L2_C
expr_stmt|;
block|}
else|else
block|{
name|pte_l1_s_cache_mode_pt
operator|=
name|L1_S_C
expr_stmt|;
name|pte_l2_l_cache_mode_pt
operator|=
name|L2_C
expr_stmt|;
name|pte_l2_s_cache_mode_pt
operator|=
name|L2_C
expr_stmt|;
block|}
name|pte_l2_s_prot_u
operator|=
name|L2_S_PROT_U_generic
expr_stmt|;
name|pte_l2_s_prot_w
operator|=
name|L2_S_PROT_W_generic
expr_stmt|;
name|pte_l2_s_prot_mask
operator|=
name|L2_S_PROT_MASK_generic
expr_stmt|;
name|pte_l1_s_proto
operator|=
name|L1_S_PROTO_generic
expr_stmt|;
name|pte_l1_c_proto
operator|=
name|L1_C_PROTO_generic
expr_stmt|;
name|pte_l2_s_proto
operator|=
name|L2_S_PROTO_generic
expr_stmt|;
name|pmap_copy_page_func
operator|=
name|pmap_copy_page_generic
expr_stmt|;
name|pmap_zero_page_func
operator|=
name|pmap_zero_page_generic
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CPU_ARM8
argument_list|)
end_if

begin_function
name|void
name|pmap_pte_init_arm8
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* 	 * ARM8 is compatible with generic, but we need to use 	 * the page tables uncached. 	 */
name|pmap_pte_init_generic
argument_list|()
expr_stmt|;
name|pte_l1_s_cache_mode_pt
operator|=
literal|0
expr_stmt|;
name|pte_l2_l_cache_mode_pt
operator|=
literal|0
expr_stmt|;
name|pte_l2_s_cache_mode_pt
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CPU_ARM8 */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CPU_ARM9
argument_list|)
operator|&&
name|defined
argument_list|(
name|ARM9_CACHE_WRITE_THROUGH
argument_list|)
end_if

begin_function
name|void
name|pmap_pte_init_arm9
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* 	 * ARM9 is compatible with generic, but we want to use 	 * write-through caching for now. 	 */
name|pmap_pte_init_generic
argument_list|()
expr_stmt|;
name|pte_l1_s_cache_mode
operator|=
name|L1_S_C
expr_stmt|;
name|pte_l2_l_cache_mode
operator|=
name|L2_C
expr_stmt|;
name|pte_l2_s_cache_mode
operator|=
name|L2_C
expr_stmt|;
name|pte_l1_s_cache_mode_pt
operator|=
name|L1_S_C
expr_stmt|;
name|pte_l2_l_cache_mode_pt
operator|=
name|L2_C
expr_stmt|;
name|pte_l2_s_cache_mode_pt
operator|=
name|L2_C
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CPU_ARM9 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* (ARM_MMU_GENERIC + ARM_MMU_SA1) != 0 */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CPU_ARM10
argument_list|)
end_if

begin_function
name|void
name|pmap_pte_init_arm10
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* 	 * ARM10 is compatible with generic, but we want to use 	 * write-through caching for now. 	 */
name|pmap_pte_init_generic
argument_list|()
expr_stmt|;
name|pte_l1_s_cache_mode
operator|=
name|L1_S_B
operator||
name|L1_S_C
expr_stmt|;
name|pte_l2_l_cache_mode
operator|=
name|L2_B
operator||
name|L2_C
expr_stmt|;
name|pte_l2_s_cache_mode
operator|=
name|L2_B
operator||
name|L2_C
expr_stmt|;
name|pte_l1_s_cache_mode_pt
operator|=
name|L1_S_C
expr_stmt|;
name|pte_l2_l_cache_mode_pt
operator|=
name|L2_C
expr_stmt|;
name|pte_l2_s_cache_mode_pt
operator|=
name|L2_C
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CPU_ARM10 */
end_comment

begin_if
if|#
directive|if
name|ARM_MMU_SA1
operator|==
literal|1
end_if

begin_function
name|void
name|pmap_pte_init_sa1
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* 	 * The StrongARM SA-1 cache does not have a write-through 	 * mode.  So, do the generic initialization, then reset 	 * the page table cache mode to B=1,C=1, and note that 	 * the PTEs need to be sync'd. 	 */
name|pmap_pte_init_generic
argument_list|()
expr_stmt|;
name|pte_l1_s_cache_mode_pt
operator|=
name|L1_S_B
operator||
name|L1_S_C
expr_stmt|;
name|pte_l2_l_cache_mode_pt
operator|=
name|L2_B
operator||
name|L2_C
expr_stmt|;
name|pte_l2_s_cache_mode_pt
operator|=
name|L2_B
operator||
name|L2_C
expr_stmt|;
name|pmap_needs_pte_sync
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ARM_MMU_SA1 == 1*/
end_comment

begin_if
if|#
directive|if
name|ARM_MMU_XSCALE
operator|==
literal|1
end_if

begin_if
if|#
directive|if
operator|(
name|ARM_NMMUS
operator|>
literal|1
operator|)
end_if

begin_decl_stmt
specifier|static
name|u_int
name|xscale_use_minidata
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|pmap_pte_init_xscale
parameter_list|(
name|void
parameter_list|)
block|{
name|uint32_t
name|auxctl
decl_stmt|;
name|int
name|write_through
init|=
literal|0
decl_stmt|;
name|pte_l1_s_cache_mode
operator|=
name|L1_S_B
operator||
name|L1_S_C
operator||
name|L1_S_XSCALE_P
expr_stmt|;
name|pte_l1_s_cache_mask
operator|=
name|L1_S_CACHE_MASK_xscale
expr_stmt|;
name|pte_l2_l_cache_mode
operator|=
name|L2_B
operator||
name|L2_C
expr_stmt|;
name|pte_l2_l_cache_mask
operator|=
name|L2_L_CACHE_MASK_xscale
expr_stmt|;
name|pte_l2_s_cache_mode
operator|=
name|L2_B
operator||
name|L2_C
expr_stmt|;
name|pte_l2_s_cache_mask
operator|=
name|L2_S_CACHE_MASK_xscale
expr_stmt|;
name|pte_l1_s_cache_mode_pt
operator|=
name|L1_S_C
expr_stmt|;
name|pte_l2_l_cache_mode_pt
operator|=
name|L2_C
expr_stmt|;
name|pte_l2_s_cache_mode_pt
operator|=
name|L2_C
expr_stmt|;
ifdef|#
directive|ifdef
name|XSCALE_CACHE_READ_WRITE_ALLOCATE
comment|/* 	 * The XScale core has an enhanced mode where writes that 	 * miss the cache cause a cache line to be allocated.  This 	 * is significantly faster than the traditional, write-through 	 * behavior of this case. 	 */
name|pte_l1_s_cache_mode
operator||=
name|L1_S_XSCALE_TEX
argument_list|(
name|TEX_XSCALE_X
argument_list|)
expr_stmt|;
name|pte_l2_l_cache_mode
operator||=
name|L2_XSCALE_L_TEX
argument_list|(
name|TEX_XSCALE_X
argument_list|)
expr_stmt|;
name|pte_l2_s_cache_mode
operator||=
name|L2_XSCALE_T_TEX
argument_list|(
name|TEX_XSCALE_X
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* XSCALE_CACHE_READ_WRITE_ALLOCATE */
ifdef|#
directive|ifdef
name|XSCALE_CACHE_WRITE_THROUGH
comment|/* 	 * Some versions of the XScale core have various bugs in 	 * their cache units, the work-around for which is to run 	 * the cache in write-through mode.  Unfortunately, this 	 * has a major (negative) impact on performance.  So, we 	 * go ahead and run fast-and-loose, in the hopes that we 	 * don't line up the planets in a way that will trip the 	 * bugs. 	 * 	 * However, we give you the option to be slow-but-correct. 	 */
name|write_through
operator|=
literal|1
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|XSCALE_CACHE_WRITE_BACK
argument_list|)
comment|/* force write back cache mode */
name|write_through
operator|=
literal|0
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|CPU_XSCALE_PXA2X0
argument_list|)
comment|/* 	 * Intel PXA2[15]0 processors are known to have a bug in 	 * write-back cache on revision 4 and earlier (stepping 	 * A[01] and B[012]).  Fixed for C0 and later. 	 */
block|{
name|uint32_t
name|id
decl_stmt|,
name|type
decl_stmt|;
name|id
operator|=
name|cpufunc_id
argument_list|()
expr_stmt|;
name|type
operator|=
name|id
operator|&
operator|~
operator|(
name|CPU_ID_XSCALE_COREREV_MASK
operator||
name|CPU_ID_REVISION_MASK
operator|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|CPU_ID_PXA250
operator|||
name|type
operator|==
name|CPU_ID_PXA210
condition|)
block|{
if|if
condition|(
operator|(
name|id
operator|&
name|CPU_ID_REVISION_MASK
operator|)
operator|<
literal|5
condition|)
block|{
comment|/* write through for stepping A0-1 and B0-2 */
name|write_through
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* XSCALE_CACHE_WRITE_THROUGH */
if|if
condition|(
name|write_through
condition|)
block|{
name|pte_l1_s_cache_mode
operator|=
name|L1_S_C
expr_stmt|;
name|pte_l2_l_cache_mode
operator|=
name|L2_C
expr_stmt|;
name|pte_l2_s_cache_mode
operator|=
name|L2_C
expr_stmt|;
block|}
if|#
directive|if
operator|(
name|ARM_NMMUS
operator|>
literal|1
operator|)
name|xscale_use_minidata
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|pte_l2_s_prot_u
operator|=
name|L2_S_PROT_U_xscale
expr_stmt|;
name|pte_l2_s_prot_w
operator|=
name|L2_S_PROT_W_xscale
expr_stmt|;
name|pte_l2_s_prot_mask
operator|=
name|L2_S_PROT_MASK_xscale
expr_stmt|;
name|pte_l1_s_proto
operator|=
name|L1_S_PROTO_xscale
expr_stmt|;
name|pte_l1_c_proto
operator|=
name|L1_C_PROTO_xscale
expr_stmt|;
name|pte_l2_s_proto
operator|=
name|L2_S_PROTO_xscale
expr_stmt|;
name|pmap_copy_page_func
operator|=
name|pmap_copy_page_xscale
expr_stmt|;
name|pmap_zero_page_func
operator|=
name|pmap_zero_page_xscale
expr_stmt|;
comment|/* 	 * Disable ECC protection of page table access, for now. 	 */
asm|__asm __volatile("mrc p15, 0, %0, c1, c0, 1" : "=r" (auxctl));
name|auxctl
operator|&=
operator|~
name|XSCALE_AUXCTL_P
expr_stmt|;
asm|__asm __volatile("mcr p15, 0, %0, c1, c0, 1" : : "r" (auxctl));
block|}
end_function

begin_comment
comment|/*  * xscale_setup_minidata:  *  *	Set up the mini-data cache clean area.  We require the  *	caller to allocate the right amount of physically and  *	virtually contiguous space.  */
end_comment

begin_decl_stmt
specifier|extern
name|vm_offset_t
name|xscale_minidata_clean_addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|vm_size_t
name|xscale_minidata_clean_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* already initialized */
end_comment

begin_function
name|void
name|xscale_setup_minidata
parameter_list|(
name|vm_offset_t
name|l1pt
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_paddr_t
name|pa
parameter_list|)
block|{
name|pd_entry_t
modifier|*
name|pde
init|=
operator|(
name|pd_entry_t
operator|*
operator|)
name|l1pt
decl_stmt|;
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
name|vm_size_t
name|size
decl_stmt|;
name|uint32_t
name|auxctl
decl_stmt|;
name|xscale_minidata_clean_addr
operator|=
name|va
expr_stmt|;
comment|/* Round it to page size. */
name|size
operator|=
operator|(
name|xscale_minidata_clean_size
operator|+
name|L2_S_OFFSET
operator|)
operator|&
name|L2_S_FRAME
expr_stmt|;
for|for
control|(
init|;
name|size
operator|!=
literal|0
condition|;
name|va
operator|+=
name|L2_S_SIZE
operator|,
name|pa
operator|+=
name|L2_S_SIZE
operator|,
name|size
operator|-=
name|L2_S_SIZE
control|)
block|{
ifndef|#
directive|ifndef
name|ARM32_NEW_VM_LAYOUT
name|pte
operator|=
operator|(
name|pt_entry_t
operator|*
operator|)
name|kernel_pt_lookup
argument_list|(
name|pde
index|[
name|va
operator|>>
name|L1_S_SHIFT
index|]
operator|&
name|L2_S_FRAME
argument_list|)
expr_stmt|;
else|#
directive|else
name|pte
operator|=
operator|(
name|pt_entry_t
operator|*
operator|)
name|kernel_pt_lookup
argument_list|(
name|pde
index|[
name|L1_IDX
argument_list|(
name|va
argument_list|)
index|]
operator|&
name|L1_C_ADDR_MASK
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pte
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"xscale_setup_minidata: can't find L2 table for "
literal|"VA 0x%08x"
argument_list|,
operator|(
name|u_int32_t
operator|)
name|va
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ARM32_NEW_VM_LAYOUT
name|pte
index|[
operator|(
name|va
operator|>>
name|PAGE_SHIFT
operator|)
operator|&
literal|0x3ff
index|]
operator|=
else|#
directive|else
name|pte
index|[
name|l2pte_index
argument_list|(
name|va
argument_list|)
index|]
operator|=
endif|#
directive|endif
name|L2_S_PROTO
operator||
name|pa
operator||
name|L2_S_PROT
argument_list|(
name|PTE_KERNEL
argument_list|,
name|VM_PROT_READ
argument_list|)
operator||
name|L2_C
operator||
name|L2_XSCALE_T_TEX
argument_list|(
name|TEX_XSCALE_X
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Configure the mini-data cache for write-back with 	 * read/write-allocate. 	 * 	 * NOTE: In order to reconfigure the mini-data cache, we must 	 * make sure it contains no valid data!  In order to do that, 	 * we must issue a global data cache invalidate command! 	 * 	 * WE ASSUME WE ARE RUNNING UN-CACHED WHEN THIS ROUTINE IS CALLED! 	 * THIS IS VERY IMPORTANT! 	 */
comment|/* Invalidate data and mini-data. */
asm|__asm __volatile("mcr p15, 0, %0, c7, c6, 0" : : "r" (0));
asm|__asm __volatile("mrc p15, 0, %0, c1, c0, 1" : "=r" (auxctl));
name|auxctl
operator|=
operator|(
name|auxctl
operator|&
operator|~
name|XSCALE_AUXCTL_MD_MASK
operator|)
operator||
name|XSCALE_AUXCTL_MD_WB_RWA
expr_stmt|;
asm|__asm __volatile("mcr p15, 0, %0, c1, c0, 1" : : "r" (auxctl));
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Allocate an L1 translation table for the specified pmap.  * This is called at pmap creation time.  */
end_comment

begin_function
specifier|static
name|void
name|pmap_alloc_l1
parameter_list|(
name|pmap_t
name|pm
parameter_list|)
block|{
name|struct
name|l1_ttable
modifier|*
name|l1
decl_stmt|;
name|u_int8_t
name|domain
decl_stmt|;
comment|/* 	 * Remove the L1 at the head of the LRU list 	 */
name|mtx_lock
argument_list|(
operator|&
name|l1_lru_lock
argument_list|)
expr_stmt|;
name|l1
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|l1_lru_list
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|l1_lru_list
argument_list|,
name|l1
argument_list|,
name|l1_lru
argument_list|)
expr_stmt|;
comment|/* 	 * Pick the first available domain number, and update 	 * the link to the next number. 	 */
name|domain
operator|=
name|l1
operator|->
name|l1_domain_first
expr_stmt|;
name|l1
operator|->
name|l1_domain_first
operator|=
name|l1
operator|->
name|l1_domain_free
index|[
name|domain
index|]
expr_stmt|;
comment|/* 	 * If there are still free domain numbers in this L1, 	 * put it back on the TAIL of the LRU list. 	 */
if|if
condition|(
operator|++
name|l1
operator|->
name|l1_domain_use_count
operator|<
name|PMAP_DOMAINS
condition|)
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|l1_lru_list
argument_list|,
name|l1
argument_list|,
name|l1_lru
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|l1_lru_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Fix up the relevant bits in the pmap structure 	 */
name|pm
operator|->
name|pm_l1
operator|=
name|l1
expr_stmt|;
name|pm
operator|->
name|pm_domain
operator|=
name|domain
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free an L1 translation table.  * This is called at pmap destruction time.  */
end_comment

begin_function
specifier|static
name|void
name|pmap_free_l1
parameter_list|(
name|pmap_t
name|pm
parameter_list|)
block|{
name|struct
name|l1_ttable
modifier|*
name|l1
init|=
name|pm
operator|->
name|pm_l1
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|l1_lru_lock
argument_list|)
expr_stmt|;
comment|/* 	 * If this L1 is currently on the LRU list, remove it. 	 */
if|if
condition|(
name|l1
operator|->
name|l1_domain_use_count
operator|<
name|PMAP_DOMAINS
condition|)
name|TAILQ_REMOVE
argument_list|(
operator|&
name|l1_lru_list
argument_list|,
name|l1
argument_list|,
name|l1_lru
argument_list|)
expr_stmt|;
comment|/* 	 * Free up the domain number which was allocated to the pmap 	 */
name|l1
operator|->
name|l1_domain_free
index|[
name|pm
operator|->
name|pm_domain
index|]
operator|=
name|l1
operator|->
name|l1_domain_first
expr_stmt|;
name|l1
operator|->
name|l1_domain_first
operator|=
name|pm
operator|->
name|pm_domain
expr_stmt|;
name|l1
operator|->
name|l1_domain_use_count
operator|--
expr_stmt|;
comment|/* 	 * The L1 now must have at least 1 free domain, so add 	 * it back to the LRU list. If the use count is zero, 	 * put it at the head of the list, otherwise it goes 	 * to the tail. 	 */
if|if
condition|(
name|l1
operator|->
name|l1_domain_use_count
operator|==
literal|0
condition|)
block|{
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|l1_lru_list
argument_list|,
name|l1
argument_list|,
name|l1_lru
argument_list|)
expr_stmt|;
block|}
else|else
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|l1_lru_list
argument_list|,
name|l1
argument_list|,
name|l1_lru
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|l1_lru_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|PMAP_INLINE
name|void
name|pmap_use_l1
parameter_list|(
name|pmap_t
name|pm
parameter_list|)
block|{
name|struct
name|l1_ttable
modifier|*
name|l1
decl_stmt|;
comment|/* 	 * Do nothing if we're in interrupt context. 	 * Access to an L1 by the kernel pmap must not affect 	 * the LRU list. 	 */
if|if
condition|(
name|pm
operator|==
name|pmap_kernel
argument_list|()
condition|)
return|return;
name|l1
operator|=
name|pm
operator|->
name|pm_l1
expr_stmt|;
comment|/* 	 * If the L1 is not currently on the LRU list, just return 	 */
if|if
condition|(
name|l1
operator|->
name|l1_domain_use_count
operator|==
name|PMAP_DOMAINS
condition|)
return|return;
name|mtx_lock
argument_list|(
operator|&
name|l1_lru_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Check the use count again, now that we've acquired the lock 	 */
if|if
condition|(
name|l1
operator|->
name|l1_domain_use_count
operator|==
name|PMAP_DOMAINS
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|l1_lru_lock
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Move the L1 to the back of the LRU list 	 */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|l1_lru_list
argument_list|,
name|l1
argument_list|,
name|l1_lru
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|l1_lru_list
argument_list|,
name|l1
argument_list|,
name|l1_lru
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|l1_lru_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Returns a pointer to the L2 bucket associated with the specified pmap  * and VA, or NULL if no L2 bucket exists for the address.  */
end_comment

begin_expr_stmt
specifier|static
name|PMAP_INLINE
expr|struct
name|l2_bucket
operator|*
name|pmap_get_l2_bucket
argument_list|(
argument|pmap_t pm
argument_list|,
argument|vm_offset_t va
argument_list|)
block|{ 	struct
name|l2_dtable
operator|*
name|l2
block|; 	struct
name|l2_bucket
operator|*
name|l2b
block|;
name|u_short
name|l1idx
block|;
name|l1idx
operator|=
name|L1_IDX
argument_list|(
name|va
argument_list|)
block|;
if|if
condition|(
operator|(
name|l2
operator|=
name|pm
operator|->
name|pm_l2
index|[
name|L2_IDX
argument_list|(
name|l1idx
argument_list|)
index|]
operator|)
operator|==
name|NULL
operator|||
operator|(
name|l2b
operator|=
operator|&
name|l2
operator|->
name|l2_bucket
index|[
name|L2_BUCKET
argument_list|(
name|l1idx
argument_list|)
index|]
operator|)
operator|->
name|l2b_kva
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
end_expr_stmt

begin_return
return|return
operator|(
name|l2b
operator|)
return|;
end_return

begin_comment
unit|}
comment|/*  * Returns a pointer to the L2 bucket associated with the specified pmap  * and VA.  *  * If no L2 bucket exists, perform the necessary allocations to put an L2  * bucket/page table in place.  *  * Note that if a new L2 bucket/page was allocated, the caller *must*  * increment the bucket occupancy counter appropriately *before*   * releasing the pmap's lock to ensure no other thread or cpu deallocates  * the bucket/page in the meantime.  */
end_comment

begin_function
unit|static
name|struct
name|l2_bucket
modifier|*
name|pmap_alloc_l2_bucket
parameter_list|(
name|pmap_t
name|pm
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|struct
name|l2_dtable
modifier|*
name|l2
decl_stmt|;
name|struct
name|l2_bucket
modifier|*
name|l2b
decl_stmt|;
name|u_short
name|l1idx
decl_stmt|;
name|l1idx
operator|=
name|L1_IDX
argument_list|(
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|l2
operator|=
name|pm
operator|->
name|pm_l2
index|[
name|L2_IDX
argument_list|(
name|l1idx
argument_list|)
index|]
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * No mapping at this address, as there is 		 * no entry in the L1 table. 		 * Need to allocate a new l2_dtable. 		 */
if|if
condition|(
operator|(
name|l2
operator|=
name|pmap_alloc_l2_dtable
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|bzero
argument_list|(
name|l2
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|l2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * Link it into the parent pmap 		 */
name|pm
operator|->
name|pm_l2
index|[
name|L2_IDX
argument_list|(
name|l1idx
argument_list|)
index|]
operator|=
name|l2
expr_stmt|;
block|}
name|l2b
operator|=
operator|&
name|l2
operator|->
name|l2_bucket
index|[
name|L2_BUCKET
argument_list|(
name|l1idx
argument_list|)
index|]
expr_stmt|;
comment|/* 	 * Fetch pointer to the L2 page table associated with the address. 	 */
if|if
condition|(
name|l2b
operator|->
name|l2b_kva
operator|==
name|NULL
condition|)
block|{
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|;
comment|/* 		 * No L2 page table has been allocated. Chances are, this 		 * is because we just allocated the l2_dtable, above. 		 */
name|ptep
operator|=
operator|(
name|void
operator|*
operator|)
name|uma_zalloc
argument_list|(
name|l2zone
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|l2b
operator|->
name|l2b_phys
operator|=
name|vtophys
argument_list|(
name|ptep
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptep
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * Oops, no more L2 page tables available at this 			 * time. We may need to deallocate the l2_dtable 			 * if we allocated a new one above. 			 */
if|if
condition|(
name|l2
operator|->
name|l2_occupancy
operator|==
literal|0
condition|)
block|{
name|pm
operator|->
name|pm_l2
index|[
name|L2_IDX
argument_list|(
name|l1idx
argument_list|)
index|]
operator|=
name|NULL
expr_stmt|;
name|pmap_free_l2_dtable
argument_list|(
name|l2
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|l2
operator|->
name|l2_occupancy
operator|++
expr_stmt|;
name|l2b
operator|->
name|l2b_kva
operator|=
name|ptep
expr_stmt|;
name|l2b
operator|->
name|l2b_l1idx
operator|=
name|l1idx
expr_stmt|;
block|}
return|return
operator|(
name|l2b
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|PMAP_INLINE
name|void
ifndef|#
directive|ifndef
name|PMAP_INCLUDE_PTE_SYNC
name|pmap_free_l2_ptp
parameter_list|(
name|pt_entry_t
modifier|*
name|l2
parameter_list|)
else|#
directive|else
function|pmap_free_l2_ptp
parameter_list|(
name|boolean_t
name|need_sync
parameter_list|,
name|pt_entry_t
modifier|*
name|l2
parameter_list|)
endif|#
directive|endif
block|{
ifdef|#
directive|ifdef
name|PMAP_INCLUDE_PTE_SYNC
comment|/* 	 * Note: With a write-back cache, we may need to sync this 	 * L2 table before re-using it. 	 * This is because it may have belonged to a non-current 	 * pmap, in which case the cache syncs would have been 	 * skipped when the pages were being unmapped. If the 	 * L2 table were then to be immediately re-allocated to 	 * the *current* pmap, it may well contain stale mappings 	 * which have not yet been cleared by a cache write-back 	 * and so would still be visible to the mmu. 	 */
if|if
condition|(
name|need_sync
condition|)
name|PTE_SYNC_RANGE
argument_list|(
name|l2
argument_list|,
name|L2_TABLE_SIZE_REAL
operator|/
sizeof|sizeof
argument_list|(
name|pt_entry_t
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|uma_zfree
argument_list|(
name|l2zone
argument_list|,
name|l2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * One or more mappings in the specified L2 descriptor table have just been  * invalidated.  *  * Garbage collect the metadata and descriptor table itself if necessary.  *  * The pmap lock must be acquired when this is called (not necessary  * for the kernel pmap).  */
end_comment

begin_function
specifier|static
name|void
name|pmap_free_l2_bucket
parameter_list|(
name|pmap_t
name|pm
parameter_list|,
name|struct
name|l2_bucket
modifier|*
name|l2b
parameter_list|,
name|u_int
name|count
parameter_list|)
block|{
name|struct
name|l2_dtable
modifier|*
name|l2
decl_stmt|;
name|pd_entry_t
modifier|*
name|pl1pd
decl_stmt|,
name|l1pd
decl_stmt|;
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|;
name|u_short
name|l1idx
decl_stmt|;
comment|/* 	 * Update the bucket's reference count according to how many 	 * PTEs the caller has just invalidated. 	 */
name|l2b
operator|->
name|l2b_occupancy
operator|-=
name|count
expr_stmt|;
comment|/* 	 * Note: 	 * 	 * Level 2 page tables allocated to the kernel pmap are never freed 	 * as that would require checking all Level 1 page tables and 	 * removing any references to the Level 2 page table. See also the 	 * comment elsewhere about never freeing bootstrap L2 descriptors. 	 * 	 * We make do with just invalidating the mapping in the L2 table. 	 * 	 * This isn't really a big deal in practice and, in fact, leads 	 * to a performance win over time as we don't need to continually 	 * alloc/free. 	 */
if|if
condition|(
name|l2b
operator|->
name|l2b_occupancy
operator|>
literal|0
operator|||
name|pm
operator|==
name|pmap_kernel
argument_list|()
condition|)
return|return;
comment|/* 	 * There are no more valid mappings in this level 2 page table. 	 * Go ahead and NULL-out the pointer in the bucket, then 	 * free the page table. 	 */
name|l1idx
operator|=
name|l2b
operator|->
name|l2b_l1idx
expr_stmt|;
name|ptep
operator|=
name|l2b
operator|->
name|l2b_kva
expr_stmt|;
name|l2b
operator|->
name|l2b_kva
operator|=
name|NULL
expr_stmt|;
name|pl1pd
operator|=
operator|&
name|pm
operator|->
name|pm_l1
operator|->
name|l1_kva
index|[
name|l1idx
index|]
expr_stmt|;
comment|/* 	 * If the L1 slot matches the pmap's domain 	 * number, then invalidate it. 	 */
name|l1pd
operator|=
operator|*
name|pl1pd
operator|&
operator|(
name|L1_TYPE_MASK
operator||
name|L1_C_DOM_MASK
operator|)
expr_stmt|;
if|if
condition|(
name|l1pd
operator|==
operator|(
name|L1_C_DOM
argument_list|(
name|pm
operator|->
name|pm_domain
argument_list|)
operator||
name|L1_TYPE_C
operator|)
condition|)
block|{
operator|*
name|pl1pd
operator|=
literal|0
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|pl1pd
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Release the L2 descriptor table back to the pool cache. 	 */
ifndef|#
directive|ifndef
name|PMAP_INCLUDE_PTE_SYNC
name|pmap_free_l2_ptp
argument_list|(
name|ptep
argument_list|)
expr_stmt|;
else|#
directive|else
name|pmap_free_l2_ptp
argument_list|(
operator|!
name|pmap_is_current
argument_list|(
name|pm
argument_list|)
argument_list|,
name|ptep
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Update the reference count in the associated l2_dtable 	 */
name|l2
operator|=
name|pm
operator|->
name|pm_l2
index|[
name|L2_IDX
argument_list|(
name|l1idx
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|--
name|l2
operator|->
name|l2_occupancy
operator|>
literal|0
condition|)
return|return;
comment|/* 	 * There are no more valid mappings in any of the Level 1 	 * slots managed by this l2_dtable. Go ahead and NULL-out 	 * the pointer in the parent pmap and free the l2_dtable. 	 */
name|pm
operator|->
name|pm_l2
index|[
name|L2_IDX
argument_list|(
name|l1idx
argument_list|)
index|]
operator|=
name|NULL
expr_stmt|;
name|pmap_free_l2_dtable
argument_list|(
name|l2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Pool cache constructors for L2 descriptor tables, metadata and pmap  * structures.  */
end_comment

begin_function
specifier|static
name|int
name|pmap_l2ptp_ctor
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|int
name|size
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|PMAP_INCLUDE_PTE_SYNC
name|struct
name|l2_bucket
modifier|*
name|l2b
decl_stmt|;
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|,
name|pte
decl_stmt|;
ifdef|#
directive|ifdef
name|ARM_USE_SMALL_ALLOC
name|pd_entry_t
modifier|*
name|pde
decl_stmt|;
endif|#
directive|endif
name|vm_offset_t
name|va
init|=
operator|(
name|vm_offset_t
operator|)
name|mem
operator|&
operator|~
name|PAGE_MASK
decl_stmt|;
comment|/* 	 * The mappings for these page tables were initially made using 	 * pmap_kenter() by the pool subsystem. Therefore, the cache- 	 * mode will not be right for page table mappings. To avoid 	 * polluting the pmap_kenter() code with a special case for 	 * page tables, we simply fix up the cache-mode here if it's not 	 * correct. 	 */
ifdef|#
directive|ifdef
name|ARM_USE_SMALL_ALLOC
name|pde
operator|=
operator|&
name|kernel_pmap
operator|->
name|pm_l1
operator|->
name|l1_kva
index|[
name|L1_IDX
argument_list|(
name|va
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|l1pte_section_p
argument_list|(
operator|*
name|pde
argument_list|)
condition|)
block|{
endif|#
directive|endif
name|l2b
operator|=
name|pmap_get_l2_bucket
argument_list|(
name|pmap_kernel
argument_list|()
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|ptep
operator|=
operator|&
name|l2b
operator|->
name|l2b_kva
index|[
name|l2pte_index
argument_list|(
name|va
argument_list|)
index|]
expr_stmt|;
name|pte
operator|=
operator|*
name|ptep
expr_stmt|;
if|if
condition|(
operator|(
name|pte
operator|&
name|L2_S_CACHE_MASK
operator|)
operator|!=
name|pte_l2_s_cache_mode_pt
condition|)
block|{
comment|/* 			 * Page tables must have the cache-mode set to  			 * Write-Thru. 			 */
operator|*
name|ptep
operator|=
operator|(
name|pte
operator|&
operator|~
name|L2_S_CACHE_MASK
operator|)
operator||
name|pte_l2_s_cache_mode_pt
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|ptep
argument_list|)
expr_stmt|;
name|cpu_tlb_flushD_SE
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|cpu_cpwait
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ARM_USE_SMALL_ALLOC
block|}
endif|#
directive|endif
endif|#
directive|endif
name|memset
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|,
name|L2_TABLE_SIZE_REAL
argument_list|)
expr_stmt|;
name|PTE_SYNC_RANGE
argument_list|(
name|mem
argument_list|,
name|L2_TABLE_SIZE_REAL
operator|/
sizeof|sizeof
argument_list|(
name|pt_entry_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * A bunch of routines to conditionally flush the caches/TLB depending  * on whether the specified pmap actually needs to be flushed at any  * given time.  */
end_comment

begin_function
specifier|static
name|PMAP_INLINE
name|void
name|pmap_tlb_flushID_SE
parameter_list|(
name|pmap_t
name|pm
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
if|if
condition|(
name|pmap_is_current
argument_list|(
name|pm
argument_list|)
condition|)
name|cpu_tlb_flushID_SE
argument_list|(
name|va
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|PMAP_INLINE
name|void
name|pmap_tlb_flushD_SE
parameter_list|(
name|pmap_t
name|pm
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
if|if
condition|(
name|pmap_is_current
argument_list|(
name|pm
argument_list|)
condition|)
name|cpu_tlb_flushD_SE
argument_list|(
name|va
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|PMAP_INLINE
name|void
name|pmap_tlb_flushID
parameter_list|(
name|pmap_t
name|pm
parameter_list|)
block|{
if|if
condition|(
name|pmap_is_current
argument_list|(
name|pm
argument_list|)
condition|)
name|cpu_tlb_flushID
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|PMAP_INLINE
name|void
name|pmap_tlb_flushD
parameter_list|(
name|pmap_t
name|pm
parameter_list|)
block|{
if|if
condition|(
name|pmap_is_current
argument_list|(
name|pm
argument_list|)
condition|)
name|cpu_tlb_flushD
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|PMAP_INLINE
name|void
name|pmap_idcache_wbinv_range
parameter_list|(
name|pmap_t
name|pm
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_size_t
name|len
parameter_list|)
block|{
if|if
condition|(
name|pmap_is_current
argument_list|(
name|pm
argument_list|)
condition|)
name|cpu_idcache_wbinv_range
argument_list|(
name|va
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|PMAP_INLINE
name|void
name|pmap_dcache_wb_range
parameter_list|(
name|pmap_t
name|pm
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_size_t
name|len
parameter_list|,
name|boolean_t
name|do_inv
parameter_list|,
name|boolean_t
name|rd_only
parameter_list|)
block|{
if|if
condition|(
name|pmap_is_current
argument_list|(
name|pm
argument_list|)
condition|)
block|{
if|if
condition|(
name|do_inv
condition|)
block|{
if|if
condition|(
name|rd_only
condition|)
name|cpu_dcache_inv_range
argument_list|(
name|va
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
name|cpu_dcache_wbinv_range
argument_list|(
name|va
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|rd_only
condition|)
name|cpu_dcache_wb_range
argument_list|(
name|va
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|PMAP_INLINE
name|void
name|pmap_idcache_wbinv_all
parameter_list|(
name|pmap_t
name|pm
parameter_list|)
block|{
if|if
condition|(
name|pmap_is_current
argument_list|(
name|pm
argument_list|)
condition|)
name|cpu_idcache_wbinv_all
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|PMAP_INLINE
name|void
name|pmap_dcache_wbinv_all
parameter_list|(
name|pmap_t
name|pm
parameter_list|)
block|{
if|if
condition|(
name|pmap_is_current
argument_list|(
name|pm
argument_list|)
condition|)
name|cpu_dcache_wbinv_all
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * this routine defines the region(s) of memory that should  * not be tested for the modified bit.  */
end_comment

begin_function
specifier|static
name|PMAP_INLINE
name|int
name|pmap_track_modified
parameter_list|(
name|vm_offset_t
name|va
parameter_list|)
block|{
if|if
condition|(
operator|(
name|va
operator|<
name|kmi
operator|.
name|clean_sva
operator|)
operator|||
operator|(
name|va
operator|>=
name|kmi
operator|.
name|clean_eva
operator|)
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * PTE_SYNC_CURRENT:  *  *     Make sure the pte is written out to RAM.  *     We need to do this for one of two cases:  *       - We're dealing with the kernel pmap  *       - There is no pmap active in the cache/tlb.  *       - The specified pmap is 'active' in the cache/tlb.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PMAP_INCLUDE_PTE_SYNC
end_ifdef

begin_define
define|#
directive|define
name|PTE_SYNC_CURRENT
parameter_list|(
name|pm
parameter_list|,
name|ptep
parameter_list|)
define|\
value|do {					\ 	if (PMAP_NEEDS_PTE_SYNC&& 	\ 	    pmap_is_current(pm))	\ 		PTE_SYNC(ptep);		\ } while (
comment|/*CONSTCOND*/
value|0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PTE_SYNC_CURRENT
parameter_list|(
name|pm
parameter_list|,
name|ptep
parameter_list|)
end_define

begin_comment
comment|/* nothing */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Since we have a virtually indexed cache, we may need to inhibit caching if  * there is more than one mapping and at least one of them is writable.  * Since we purge the cache on every context switch, we only need to check for  * other mappings within the same pmap, or kernel_pmap.  * This function is also called when a page is unmapped, to possibly reenable  * caching on any remaining mappings.  *  * The code implements the following logic, where:  *  * KW = # of kernel read/write pages  * KR = # of kernel read only pages  * UW = # of user read/write pages  * UR = # of user read only pages  *   * KC = kernel mapping is cacheable  * UC = user mapping is cacheable  *  *               KW=0,KR=0  KW=0,KR>0  KW=1,KR=0  KW>1,KR>=0  *             +---------------------------------------------  * UW=0,UR=0   | ---        KC=1       KC=1       KC=0  * UW=0,UR>0   | UC=1       KC=1,UC=1  KC=0,UC=0  KC=0,UC=0  * UW=1,UR=0   | UC=1       KC=0,UC=0  KC=0,UC=0  KC=0,UC=0  * UW>1,UR>=0  | UC=0       KC=0,UC=0  KC=0,UC=0  KC=0,UC=0  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|int
name|pmap_vac_flags
index|[
literal|4
index|]
index|[
literal|4
index|]
init|=
block|{
block|{
operator|-
literal|1
block|,
literal|0
block|,
literal|0
block|,
name|PVF_KNC
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
name|PVF_NC
block|,
name|PVF_NC
block|}
block|,
block|{
literal|0
block|,
name|PVF_NC
block|,
name|PVF_NC
block|,
name|PVF_NC
block|}
block|,
block|{
name|PVF_UNC
block|,
name|PVF_NC
block|,
name|PVF_NC
block|,
name|PVF_NC
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|PMAP_INLINE
name|int
name|pmap_get_vac_flags
parameter_list|(
specifier|const
name|struct
name|vm_page
modifier|*
name|pg
parameter_list|)
block|{
name|int
name|kidx
decl_stmt|,
name|uidx
decl_stmt|;
name|kidx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pg
operator|->
name|md
operator|.
name|kro_mappings
operator|||
name|pg
operator|->
name|md
operator|.
name|krw_mappings
operator|>
literal|1
condition|)
name|kidx
operator||=
literal|1
expr_stmt|;
if|if
condition|(
name|pg
operator|->
name|md
operator|.
name|krw_mappings
condition|)
name|kidx
operator||=
literal|2
expr_stmt|;
name|uidx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pg
operator|->
name|md
operator|.
name|uro_mappings
operator|||
name|pg
operator|->
name|md
operator|.
name|urw_mappings
operator|>
literal|1
condition|)
name|uidx
operator||=
literal|1
expr_stmt|;
if|if
condition|(
name|pg
operator|->
name|md
operator|.
name|urw_mappings
condition|)
name|uidx
operator||=
literal|2
expr_stmt|;
return|return
operator|(
name|pmap_vac_flags
index|[
name|uidx
index|]
index|[
name|kidx
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|pmap_vac_me_harder
parameter_list|(
name|struct
name|vm_page
modifier|*
name|pg
parameter_list|,
name|pmap_t
name|pm
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|int
name|nattr
decl_stmt|;
name|nattr
operator|=
name|pmap_get_vac_flags
argument_list|(
name|pg
argument_list|)
expr_stmt|;
if|if
condition|(
name|nattr
operator|<
literal|0
condition|)
block|{
name|pg
operator|->
name|md
operator|.
name|pvh_attrs
operator|&=
operator|~
name|PVF_NC
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|nattr
operator|==
literal|0
operator|&&
operator|(
name|pg
operator|->
name|md
operator|.
name|pvh_attrs
operator|&
name|PVF_NC
operator|)
operator|==
literal|0
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|pm
operator|==
name|pmap_kernel
argument_list|()
condition|)
name|pmap_vac_me_kpmap
argument_list|(
name|pg
argument_list|,
name|pm
argument_list|,
name|va
argument_list|)
expr_stmt|;
else|else
name|pmap_vac_me_user
argument_list|(
name|pg
argument_list|,
name|pm
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|pg
operator|->
name|md
operator|.
name|pvh_attrs
operator|=
operator|(
name|pg
operator|->
name|md
operator|.
name|pvh_attrs
operator|&
operator|~
name|PVF_NC
operator|)
operator||
name|nattr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pmap_vac_me_kpmap
parameter_list|(
name|struct
name|vm_page
modifier|*
name|pg
parameter_list|,
name|pmap_t
name|pm
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|u_int
name|u_cacheable
decl_stmt|,
name|u_entries
decl_stmt|;
name|struct
name|pv_entry
modifier|*
name|pv
decl_stmt|;
name|pmap_t
name|last_pmap
init|=
name|pm
decl_stmt|;
comment|/*  	 * Pass one, see if there are both kernel and user pmaps for 	 * this page.  Calculate whether there are user-writable or 	 * kernel-writable pages. 	 */
name|u_cacheable
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&pg->md.pv_list
argument_list|,
argument|pv_list
argument_list|)
block|{
if|if
condition|(
name|pv
operator|->
name|pv_pmap
operator|!=
name|pm
operator|&&
operator|(
name|pv
operator|->
name|pv_flags
operator|&
name|PVF_NC
operator|)
operator|==
literal|0
condition|)
name|u_cacheable
operator|++
expr_stmt|;
block|}
name|u_entries
operator|=
name|pg
operator|->
name|md
operator|.
name|urw_mappings
operator|+
name|pg
operator|->
name|md
operator|.
name|uro_mappings
expr_stmt|;
comment|/*  	 * We know we have just been updating a kernel entry, so if 	 * all user pages are already cacheable, then there is nothing 	 * further to do. 	 */
if|if
condition|(
name|pg
operator|->
name|md
operator|.
name|k_mappings
operator|==
literal|0
operator|&&
name|u_cacheable
operator|==
name|u_entries
condition|)
return|return;
if|if
condition|(
name|u_entries
condition|)
block|{
comment|/*  		 * Scan over the list again, for each entry, if it 		 * might not be set correctly, call pmap_vac_me_user 		 * to recalculate the settings. 		 */
name|TAILQ_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&pg->md.pv_list
argument_list|,
argument|pv_list
argument_list|)
block|{
comment|/*  			 * We know kernel mappings will get set 			 * correctly in other calls.  We also know 			 * that if the pmap is the same as last_pmap 			 * then we've just handled this entry. 			 */
if|if
condition|(
name|pv
operator|->
name|pv_pmap
operator|==
name|pm
operator|||
name|pv
operator|->
name|pv_pmap
operator|==
name|last_pmap
condition|)
continue|continue;
comment|/*  			 * If there are kernel entries and this page 			 * is writable but non-cacheable, then we can 			 * skip this entry also.   			 */
if|if
condition|(
name|pg
operator|->
name|md
operator|.
name|k_mappings
operator|&&
operator|(
name|pv
operator|->
name|pv_flags
operator|&
operator|(
name|PVF_NC
operator||
name|PVF_WRITE
operator|)
operator|)
operator|==
operator|(
name|PVF_NC
operator||
name|PVF_WRITE
operator|)
condition|)
continue|continue;
comment|/*  			 * Similarly if there are no kernel-writable  			 * entries and the page is already  			 * read-only/cacheable. 			 */
if|if
condition|(
name|pg
operator|->
name|md
operator|.
name|krw_mappings
operator|==
literal|0
operator|&&
operator|(
name|pv
operator|->
name|pv_flags
operator|&
operator|(
name|PVF_NC
operator||
name|PVF_WRITE
operator|)
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/*  			 * For some of the remaining cases, we know 			 * that we must recalculate, but for others we 			 * can't tell if they are correct or not, so 			 * we recalculate anyway. 			 */
name|pmap_vac_me_user
argument_list|(
name|pg
argument_list|,
operator|(
name|last_pmap
operator|=
name|pv
operator|->
name|pv_pmap
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pg
operator|->
name|md
operator|.
name|k_mappings
operator|==
literal|0
condition|)
return|return;
block|}
name|pmap_vac_me_user
argument_list|(
name|pg
argument_list|,
name|pm
argument_list|,
name|va
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pmap_vac_me_user
parameter_list|(
name|struct
name|vm_page
modifier|*
name|pg
parameter_list|,
name|pmap_t
name|pm
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|pmap_t
name|kpmap
init|=
name|pmap_kernel
argument_list|()
decl_stmt|;
name|struct
name|pv_entry
modifier|*
name|pv
decl_stmt|,
modifier|*
name|npv
decl_stmt|;
name|struct
name|l2_bucket
modifier|*
name|l2b
decl_stmt|;
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|,
name|pte
decl_stmt|;
name|u_int
name|entries
init|=
literal|0
decl_stmt|;
name|u_int
name|writable
init|=
literal|0
decl_stmt|;
name|u_int
name|cacheable_entries
init|=
literal|0
decl_stmt|;
name|u_int
name|kern_cacheable
init|=
literal|0
decl_stmt|;
name|u_int
name|other_writable
init|=
literal|0
decl_stmt|;
comment|/* 	 * Count mappings and writable mappings in this pmap. 	 * Include kernel mappings as part of our own. 	 * Keep a pointer to the first one. 	 */
name|npv
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pg
operator|->
name|md
operator|.
name|pv_list
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&pg->md.pv_list
argument_list|,
argument|pv_list
argument_list|)
block|{
comment|/* Count mappings in the same pmap */
if|if
condition|(
name|pm
operator|==
name|pv
operator|->
name|pv_pmap
operator|||
name|kpmap
operator|==
name|pv
operator|->
name|pv_pmap
condition|)
block|{
if|if
condition|(
name|entries
operator|++
operator|==
literal|0
condition|)
name|npv
operator|=
name|pv
expr_stmt|;
comment|/* Cacheable mappings */
if|if
condition|(
operator|(
name|pv
operator|->
name|pv_flags
operator|&
name|PVF_NC
operator|)
operator|==
literal|0
condition|)
block|{
name|cacheable_entries
operator|++
expr_stmt|;
if|if
condition|(
name|kpmap
operator|==
name|pv
operator|->
name|pv_pmap
condition|)
name|kern_cacheable
operator|++
expr_stmt|;
block|}
comment|/* Writable mappings */
if|if
condition|(
name|pv
operator|->
name|pv_flags
operator|&
name|PVF_WRITE
condition|)
operator|++
name|writable
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pv
operator|->
name|pv_flags
operator|&
name|PVF_WRITE
condition|)
name|other_writable
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * Enable or disable caching as necessary. 	 * Note: the first entry might be part of the kernel pmap, 	 * so we can't assume this is indicative of the state of the 	 * other (maybe non-kpmap) entries. 	 */
if|if
condition|(
operator|(
name|entries
operator|>
literal|1
operator|&&
name|writable
operator|)
operator|||
operator|(
name|entries
operator|>
literal|0
operator|&&
name|pm
operator|==
name|kpmap
operator|&&
name|other_writable
operator|)
condition|)
block|{
if|if
condition|(
name|cacheable_entries
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|pv
operator|=
name|npv
init|;
name|pv
condition|;
name|pv
operator|=
name|TAILQ_NEXT
argument_list|(
name|pv
argument_list|,
name|pv_list
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|pm
operator|!=
name|pv
operator|->
name|pv_pmap
operator|&&
name|kpmap
operator|!=
name|pv
operator|->
name|pv_pmap
operator|)
operator|||
operator|(
name|pv
operator|->
name|pv_flags
operator|&
name|PVF_NC
operator|)
condition|)
continue|continue;
name|pv
operator|->
name|pv_flags
operator||=
name|PVF_NC
expr_stmt|;
name|l2b
operator|=
name|pmap_get_l2_bucket
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
name|ptep
operator|=
operator|&
name|l2b
operator|->
name|l2b_kva
index|[
name|l2pte_index
argument_list|(
name|pv
operator|->
name|pv_va
argument_list|)
index|]
expr_stmt|;
name|pte
operator|=
operator|*
name|ptep
operator|&
operator|~
name|L2_S_CACHE_MASK
expr_stmt|;
if|if
condition|(
operator|(
name|va
operator|!=
name|pv
operator|->
name|pv_va
operator|||
name|pm
operator|!=
name|pv
operator|->
name|pv_pmap
operator|)
operator|&&
name|l2pte_valid
argument_list|(
name|pte
argument_list|)
condition|)
block|{
if|if
condition|(
name|PV_BEEN_EXECD
argument_list|(
name|pv
operator|->
name|pv_flags
argument_list|)
condition|)
block|{
name|pmap_idcache_wbinv_range
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|pmap_tlb_flushID_SE
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|PV_BEEN_REFD
argument_list|(
name|pv
operator|->
name|pv_flags
argument_list|)
condition|)
block|{
name|pmap_dcache_wb_range
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|,
name|PAGE_SIZE
argument_list|,
name|TRUE
argument_list|,
operator|(
name|pv
operator|->
name|pv_flags
operator|&
name|PVF_WRITE
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|pmap_tlb_flushD_SE
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|ptep
operator|=
name|pte
expr_stmt|;
name|PTE_SYNC_CURRENT
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|,
name|ptep
argument_list|)
expr_stmt|;
block|}
name|cpu_cpwait
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|entries
operator|>
name|cacheable_entries
condition|)
block|{
comment|/* 		 * Turn cacheing back on for some pages.  If it is a kernel 		 * page, only do so if there are no other writable pages. 		 */
for|for
control|(
name|pv
operator|=
name|npv
init|;
name|pv
condition|;
name|pv
operator|=
name|TAILQ_NEXT
argument_list|(
name|pv
argument_list|,
name|pv_list
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|pv
operator|->
name|pv_flags
operator|&
name|PVF_NC
operator|)
operator|||
operator|(
name|pm
operator|!=
name|pv
operator|->
name|pv_pmap
operator|&&
operator|(
name|kpmap
operator|!=
name|pv
operator|->
name|pv_pmap
operator|||
name|other_writable
operator|)
operator|)
condition|)
continue|continue;
name|pv
operator|->
name|pv_flags
operator|&=
operator|~
name|PVF_NC
expr_stmt|;
name|l2b
operator|=
name|pmap_get_l2_bucket
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
name|ptep
operator|=
operator|&
name|l2b
operator|->
name|l2b_kva
index|[
name|l2pte_index
argument_list|(
name|pv
operator|->
name|pv_va
argument_list|)
index|]
expr_stmt|;
name|pte
operator|=
operator|(
operator|*
name|ptep
operator|&
operator|~
name|L2_S_CACHE_MASK
operator|)
operator||
name|pte_l2_s_cache_mode
expr_stmt|;
if|if
condition|(
name|l2pte_valid
argument_list|(
name|pte
argument_list|)
condition|)
block|{
if|if
condition|(
name|PV_BEEN_EXECD
argument_list|(
name|pv
operator|->
name|pv_flags
argument_list|)
condition|)
block|{
name|pmap_tlb_flushID_SE
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|PV_BEEN_REFD
argument_list|(
name|pv
operator|->
name|pv_flags
argument_list|)
condition|)
block|{
name|pmap_tlb_flushD_SE
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|ptep
operator|=
name|pte
expr_stmt|;
name|PTE_SYNC_CURRENT
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|,
name|ptep
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Modify pte bits for all ptes corresponding to the given physical address.  * We use `maskbits' rather than `clearbits' because we're always passing  * constants and the latter would require an extra inversion at run-time.  */
end_comment

begin_function
specifier|static
name|int
name|pmap_clearbit
parameter_list|(
name|struct
name|vm_page
modifier|*
name|pg
parameter_list|,
name|u_int
name|maskbits
parameter_list|)
block|{
name|struct
name|l2_bucket
modifier|*
name|l2b
decl_stmt|;
name|struct
name|pv_entry
modifier|*
name|pv
decl_stmt|;
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|,
name|npte
decl_stmt|,
name|opte
decl_stmt|;
name|pmap_t
name|pm
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
name|u_int
name|oflags
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
if|#
directive|if
literal|0
block|PMAP_HEAD_TO_MAP_LOCK(); 	simple_lock(&pg->mdpage.pvh_slock);
endif|#
directive|endif
comment|/* 	 * Clear saved attributes (modify, reference) 	 */
name|pg
operator|->
name|md
operator|.
name|pvh_attrs
operator|&=
operator|~
operator|(
name|maskbits
operator|&
operator|(
name|PVF_MOD
operator||
name|PVF_REF
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|pg
operator|->
name|md
operator|.
name|pv_list
argument_list|)
condition|)
block|{
if|#
directive|if
literal|0
block|simple_unlock(&pg->mdpage.pvh_slock); 		PMAP_HEAD_TO_MAP_UNLOCK();
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Loop over all current mappings setting/clearing as appropos 	 */
name|TAILQ_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&pg->md.pv_list
argument_list|,
argument|pv_list
argument_list|)
block|{
name|va
operator|=
name|pv
operator|->
name|pv_va
expr_stmt|;
name|pm
operator|=
name|pv
operator|->
name|pv_pmap
expr_stmt|;
name|oflags
operator|=
name|pv
operator|->
name|pv_flags
expr_stmt|;
name|pv
operator|->
name|pv_flags
operator|&=
operator|~
name|maskbits
expr_stmt|;
if|#
directive|if
literal|0
block|pmap_acquire_pmap_lock(pm);
endif|#
directive|endif
name|l2b
operator|=
name|pmap_get_l2_bucket
argument_list|(
name|pm
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|ptep
operator|=
operator|&
name|l2b
operator|->
name|l2b_kva
index|[
name|l2pte_index
argument_list|(
name|va
argument_list|)
index|]
expr_stmt|;
name|npte
operator|=
name|opte
operator|=
operator|*
name|ptep
expr_stmt|;
if|if
condition|(
name|maskbits
operator|&
operator|(
name|PVF_WRITE
operator||
name|PVF_MOD
operator|)
operator|&&
operator|!
name|pmap_track_modified
argument_list|(
name|pv
operator|->
name|pv_va
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|pv
operator|->
name|pv_flags
operator|&
name|PVF_NC
operator|)
condition|)
block|{
comment|/*  				 * Entry is not cacheable: 				 * 				 * Don't turn caching on again if this is a  				 * modified emulation. This would be 				 * inconsitent with the settings created by 				 * pmap_vac_me_harder(). Otherwise, it's safe 				 * to re-enable cacheing. 				 * 				 * There's no need to call pmap_vac_me_harder() 				 * here: all pages are losing their write 				 * permission. 				 */
if|if
condition|(
name|maskbits
operator|&
name|PVF_WRITE
condition|)
block|{
name|npte
operator||=
name|pte_l2_s_cache_mode
expr_stmt|;
name|pv
operator|->
name|pv_flags
operator|&=
operator|~
name|PVF_NC
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|opte
operator|&
name|L2_S_PROT_W
condition|)
block|{
name|vm_page_dirty
argument_list|(
name|pg
argument_list|)
expr_stmt|;
comment|/*  				 * Entry is writable/cacheable: check if pmap 				 * is current if it is flush it, otherwise it 				 * won't be in the cache 				 */
if|if
condition|(
name|PV_BEEN_EXECD
argument_list|(
name|oflags
argument_list|)
condition|)
name|pmap_idcache_wbinv_range
argument_list|(
name|pm
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|PV_BEEN_REFD
argument_list|(
name|oflags
argument_list|)
condition|)
name|pmap_dcache_wb_range
argument_list|(
name|pm
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|,
name|PAGE_SIZE
argument_list|,
operator|(
name|maskbits
operator|&
name|PVF_REF
operator|)
condition|?
name|TRUE
else|:
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* make the pte read only */
name|npte
operator|&=
operator|~
name|L2_S_PROT_W
expr_stmt|;
if|if
condition|(
name|maskbits
operator|&
name|PVF_WRITE
condition|)
block|{
comment|/* 				 * Keep alias accounting up to date 				 */
if|if
condition|(
name|pv
operator|->
name|pv_pmap
operator|==
name|pmap_kernel
argument_list|()
condition|)
block|{
if|if
condition|(
name|oflags
operator|&
name|PVF_WRITE
condition|)
block|{
name|pg
operator|->
name|md
operator|.
name|krw_mappings
operator|--
expr_stmt|;
name|pg
operator|->
name|md
operator|.
name|kro_mappings
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|oflags
operator|&
name|PVF_WRITE
condition|)
block|{
name|pg
operator|->
name|md
operator|.
name|urw_mappings
operator|--
expr_stmt|;
name|pg
operator|->
name|md
operator|.
name|uro_mappings
operator|++
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|maskbits
operator|&
name|PVF_REF
operator|&&
operator|!
name|pmap_track_modified
argument_list|(
name|pv
operator|->
name|pv_va
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|pv
operator|->
name|pv_flags
operator|&
name|PVF_NC
operator|)
operator|==
literal|0
operator|&&
operator|(
name|maskbits
operator|&
operator|(
name|PVF_WRITE
operator||
name|PVF_MOD
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 				 * Check npte here; we may have already 				 * done the wbinv above, and the validity 				 * of the PTE is the same for opte and 				 * npte. 				 */
if|if
condition|(
name|npte
operator|&
name|L2_S_PROT_W
condition|)
block|{
if|if
condition|(
name|PV_BEEN_EXECD
argument_list|(
name|oflags
argument_list|)
condition|)
name|pmap_idcache_wbinv_range
argument_list|(
name|pm
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|PV_BEEN_REFD
argument_list|(
name|oflags
argument_list|)
condition|)
name|pmap_dcache_wb_range
argument_list|(
name|pm
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|,
name|PAGE_SIZE
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|npte
operator|&
name|L2_TYPE_MASK
operator|)
operator|!=
name|L2_TYPE_INV
condition|)
block|{
comment|/* XXXJRT need idcache_inv_range */
if|if
condition|(
name|PV_BEEN_EXECD
argument_list|(
name|oflags
argument_list|)
condition|)
name|pmap_idcache_wbinv_range
argument_list|(
name|pm
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|PV_BEEN_REFD
argument_list|(
name|oflags
argument_list|)
condition|)
name|pmap_dcache_wb_range
argument_list|(
name|pm
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|,
name|PAGE_SIZE
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 			 * Make the PTE invalid so that we will take a 			 * page fault the next time the mapping is 			 * referenced. 			 */
name|npte
operator|&=
operator|~
name|L2_TYPE_MASK
expr_stmt|;
name|npte
operator||=
name|L2_TYPE_INV
expr_stmt|;
block|}
if|if
condition|(
name|npte
operator|!=
name|opte
condition|)
block|{
name|count
operator|++
expr_stmt|;
operator|*
name|ptep
operator|=
name|npte
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|ptep
argument_list|)
expr_stmt|;
comment|/* Flush the TLB entry if a current pmap. */
if|if
condition|(
name|PV_BEEN_EXECD
argument_list|(
name|oflags
argument_list|)
condition|)
name|pmap_tlb_flushID_SE
argument_list|(
name|pm
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|PV_BEEN_REFD
argument_list|(
name|oflags
argument_list|)
condition|)
name|pmap_tlb_flushD_SE
argument_list|(
name|pm
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|pmap_release_pmap_lock(pm);
endif|#
directive|endif
block|}
if|#
directive|if
literal|0
block|simple_unlock(&pg->mdpage.pvh_slock); 	PMAP_HEAD_TO_MAP_UNLOCK();
endif|#
directive|endif
if|if
condition|(
name|maskbits
operator|&
name|PVF_WRITE
condition|)
name|vm_page_flag_clear
argument_list|(
name|pg
argument_list|,
name|PG_WRITEABLE
argument_list|)
expr_stmt|;
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * main pv_entry manipulation functions:  *   pmap_enter_pv: enter a mapping onto a vm_page list  *   pmap_remove_pv: remove a mappiing from a vm_page list  *  * NOTE: pmap_enter_pv expects to lock the pvh itself  *       pmap_remove_pv expects te caller to lock the pvh before calling  */
end_comment

begin_comment
comment|/*  * pmap_enter_pv: enter a mapping onto a vm_page lst  *  * => caller should hold the proper lock on pmap_main_lock  * => caller should have pmap locked  * => we will gain the lock on the vm_page and allocate the new pv_entry  * => caller should adjust ptp's wire_count before calling  * => caller should not adjust pmap's wire_count  */
end_comment

begin_function
specifier|static
name|void
name|pmap_enter_pv
parameter_list|(
name|struct
name|vm_page
modifier|*
name|pg
parameter_list|,
name|struct
name|pv_entry
modifier|*
name|pve
parameter_list|,
name|pmap_t
name|pm
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|u_int
name|flags
parameter_list|)
block|{
name|pve
operator|->
name|pv_pmap
operator|=
name|pm
expr_stmt|;
name|pve
operator|->
name|pv_va
operator|=
name|va
expr_stmt|;
name|pve
operator|->
name|pv_flags
operator|=
name|flags
expr_stmt|;
if|#
directive|if
literal|0
block|mtx_lock(&pg->md.pvh_mtx);
endif|#
directive|endif
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|pg
operator|->
name|md
operator|.
name|pv_list
argument_list|,
name|pve
argument_list|,
name|pv_list
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|pm
operator|->
name|pm_pvlist
argument_list|,
name|pve
argument_list|,
name|pv_plist
argument_list|)
expr_stmt|;
name|pg
operator|->
name|md
operator|.
name|pvh_attrs
operator||=
name|flags
operator|&
operator|(
name|PVF_REF
operator||
name|PVF_MOD
operator|)
expr_stmt|;
if|if
condition|(
name|pm
operator|==
name|pmap_kernel
argument_list|()
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|PVF_WRITE
condition|)
name|pg
operator|->
name|md
operator|.
name|krw_mappings
operator|++
expr_stmt|;
else|else
name|pg
operator|->
name|md
operator|.
name|kro_mappings
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|PVF_WRITE
condition|)
name|pg
operator|->
name|md
operator|.
name|urw_mappings
operator|++
expr_stmt|;
else|else
name|pg
operator|->
name|md
operator|.
name|uro_mappings
operator|++
expr_stmt|;
name|pg
operator|->
name|md
operator|.
name|pv_list_count
operator|++
expr_stmt|;
if|#
directive|if
literal|0
block|mtx_unlock(&pg->md.pvh_mtx);
endif|#
directive|endif
if|if
condition|(
name|pve
operator|->
name|pv_flags
operator|&
name|PVF_WIRED
condition|)
operator|++
name|pm
operator|->
name|pm_stats
operator|.
name|wired_count
expr_stmt|;
name|vm_page_flag_set
argument_list|(
name|pg
argument_list|,
name|PG_REFERENCED
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  * pmap_find_pv: Find a pv entry  *  * => caller should hold lock on vm_page  */
end_comment

begin_expr_stmt
specifier|static
name|PMAP_INLINE
expr|struct
name|pv_entry
operator|*
name|pmap_find_pv
argument_list|(
argument|struct vm_page *pg
argument_list|,
argument|pmap_t pm
argument_list|,
argument|vm_offset_t va
argument_list|)
block|{ 	struct
name|pv_entry
operator|*
name|pv
block|;
name|TAILQ_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&pg->md.pv_list
argument_list|,
argument|pv_list
argument_list|)
if|if
condition|(
name|pm
operator|==
name|pv
operator|->
name|pv_pmap
operator|&&
name|va
operator|==
name|pv
operator|->
name|pv_va
condition|)
break|break;
end_expr_stmt

begin_return
return|return
operator|(
name|pv
operator|)
return|;
end_return

begin_comment
unit|}
comment|/*  * vector_page_setprot:  *  *	Manipulate the protection of the vector page.  */
end_comment

begin_macro
unit|void
name|vector_page_setprot
argument_list|(
argument|int prot
argument_list|)
end_macro

begin_block
block|{
name|struct
name|l2_bucket
modifier|*
name|l2b
decl_stmt|;
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|;
name|l2b
operator|=
name|pmap_get_l2_bucket
argument_list|(
name|pmap_kernel
argument_list|()
argument_list|,
name|vector_page
argument_list|)
expr_stmt|;
name|ptep
operator|=
operator|&
name|l2b
operator|->
name|l2b_kva
index|[
name|l2pte_index
argument_list|(
name|vector_page
argument_list|)
index|]
expr_stmt|;
operator|*
name|ptep
operator|=
operator|(
operator|*
name|ptep
operator|&
operator|~
name|L1_S_PROT_MASK
operator|)
operator||
name|L2_S_PROT
argument_list|(
name|PTE_KERNEL
argument_list|,
name|prot
argument_list|)
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|ptep
argument_list|)
expr_stmt|;
name|cpu_tlb_flushD_SE
argument_list|(
name|vector_page
argument_list|)
expr_stmt|;
name|cpu_cpwait
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * pmap_remove_pv: try to remove a mapping from a pv_list  *  * => caller should hold proper lock on pmap_main_lock  * => pmap should be locked  * => caller should hold lock on vm_page [so that attrs can be adjusted]  * => caller should adjust ptp's wire_count and free PTP if needed  * => caller should NOT adjust pmap's wire_count  * => we return the removed pve  */
end_comment

begin_function
specifier|static
name|void
name|pmap_nuke_pv
parameter_list|(
name|struct
name|vm_page
modifier|*
name|pg
parameter_list|,
name|pmap_t
name|pm
parameter_list|,
name|struct
name|pv_entry
modifier|*
name|pve
parameter_list|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pg
operator|->
name|md
operator|.
name|pv_list
argument_list|,
name|pve
argument_list|,
name|pv_list
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pm
operator|->
name|pm_pvlist
argument_list|,
name|pve
argument_list|,
name|pv_plist
argument_list|)
expr_stmt|;
if|if
condition|(
name|pve
operator|->
name|pv_flags
operator|&
name|PVF_WIRED
condition|)
operator|--
name|pm
operator|->
name|pm_stats
operator|.
name|wired_count
expr_stmt|;
name|pg
operator|->
name|md
operator|.
name|pv_list_count
operator|--
expr_stmt|;
if|if
condition|(
name|pg
operator|->
name|md
operator|.
name|pvh_attrs
operator|&
name|PVF_MOD
condition|)
name|vm_page_dirty
argument_list|(
name|pg
argument_list|)
expr_stmt|;
if|if
condition|(
name|pm
operator|==
name|pmap_kernel
argument_list|()
condition|)
block|{
if|if
condition|(
name|pve
operator|->
name|pv_flags
operator|&
name|PVF_WRITE
condition|)
name|pg
operator|->
name|md
operator|.
name|krw_mappings
operator|--
expr_stmt|;
else|else
name|pg
operator|->
name|md
operator|.
name|kro_mappings
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pve
operator|->
name|pv_flags
operator|&
name|PVF_WRITE
condition|)
name|pg
operator|->
name|md
operator|.
name|urw_mappings
operator|--
expr_stmt|;
else|else
name|pg
operator|->
name|md
operator|.
name|uro_mappings
operator|--
expr_stmt|;
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|pg
operator|->
name|md
operator|.
name|pv_list
argument_list|)
operator|==
name|NULL
operator|||
operator|(
name|pg
operator|->
name|md
operator|.
name|krw_mappings
operator|==
literal|0
operator|&&
name|pg
operator|->
name|md
operator|.
name|urw_mappings
operator|==
literal|0
operator|)
condition|)
block|{
name|pg
operator|->
name|md
operator|.
name|pvh_attrs
operator|&=
operator|~
name|PVF_MOD
expr_stmt|;
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|pg
operator|->
name|md
operator|.
name|pv_list
argument_list|)
operator|==
name|NULL
condition|)
name|pg
operator|->
name|md
operator|.
name|pvh_attrs
operator|&=
operator|~
name|PVF_REF
expr_stmt|;
name|vm_page_flag_clear
argument_list|(
name|pg
argument_list|,
name|PG_WRITEABLE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|pg
operator|->
name|md
operator|.
name|pv_list
argument_list|)
condition|)
name|vm_page_flag_set
argument_list|(
name|pg
argument_list|,
name|PG_REFERENCED
argument_list|)
expr_stmt|;
if|if
condition|(
name|pve
operator|->
name|pv_flags
operator|&
name|PVF_WRITE
condition|)
name|pmap_vac_me_harder
argument_list|(
name|pg
argument_list|,
name|pm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|pv_entry
modifier|*
name|pmap_remove_pv
parameter_list|(
name|struct
name|vm_page
modifier|*
name|pg
parameter_list|,
name|pmap_t
name|pm
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|struct
name|pv_entry
modifier|*
name|pve
decl_stmt|;
name|pve
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pg
operator|->
name|md
operator|.
name|pv_list
argument_list|)
expr_stmt|;
while|while
condition|(
name|pve
condition|)
block|{
if|if
condition|(
name|pve
operator|->
name|pv_pmap
operator|==
name|pm
operator|&&
name|pve
operator|->
name|pv_va
operator|==
name|va
condition|)
block|{
comment|/* match? */
name|pmap_nuke_pv
argument_list|(
name|pg
argument_list|,
name|pm
argument_list|,
name|pve
argument_list|)
expr_stmt|;
break|break;
block|}
name|pve
operator|=
name|TAILQ_NEXT
argument_list|(
name|pve
argument_list|,
name|pv_list
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|pve
operator|)
return|;
comment|/* return removed pve */
block|}
end_function

begin_comment
comment|/*  *  * pmap_modify_pv: Update pv flags  *  * => caller should hold lock on vm_page [so that attrs can be adjusted]  * => caller should NOT adjust pmap's wire_count  * => caller must call pmap_vac_me_harder() if writable status of a page  *    may have changed.  * => we return the old flags  *   * Modify a physical-virtual mapping in the pv table  */
end_comment

begin_function
specifier|static
name|u_int
name|pmap_modify_pv
parameter_list|(
name|struct
name|vm_page
modifier|*
name|pg
parameter_list|,
name|pmap_t
name|pm
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|u_int
name|clr_mask
parameter_list|,
name|u_int
name|set_mask
parameter_list|)
block|{
name|struct
name|pv_entry
modifier|*
name|npv
decl_stmt|;
name|u_int
name|flags
decl_stmt|,
name|oflags
decl_stmt|;
if|if
condition|(
operator|(
name|npv
operator|=
name|pmap_find_pv
argument_list|(
name|pg
argument_list|,
name|pm
argument_list|,
name|va
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * There is at least one VA mapping this page. 	 */
if|if
condition|(
name|clr_mask
operator|&
operator|(
name|PVF_REF
operator||
name|PVF_MOD
operator|)
condition|)
name|pg
operator|->
name|md
operator|.
name|pvh_attrs
operator||=
name|set_mask
operator|&
operator|(
name|PVF_REF
operator||
name|PVF_MOD
operator|)
expr_stmt|;
name|oflags
operator|=
name|npv
operator|->
name|pv_flags
expr_stmt|;
name|npv
operator|->
name|pv_flags
operator|=
name|flags
operator|=
operator|(
name|oflags
operator|&
operator|~
name|clr_mask
operator|)
operator||
name|set_mask
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|^
name|oflags
operator|)
operator|&
name|PVF_WIRED
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|PVF_WIRED
condition|)
operator|++
name|pm
operator|->
name|pm_stats
operator|.
name|wired_count
expr_stmt|;
else|else
operator|--
name|pm
operator|->
name|pm_stats
operator|.
name|wired_count
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|^
name|oflags
operator|)
operator|&
name|PVF_WRITE
condition|)
block|{
if|if
condition|(
name|pm
operator|==
name|pmap_kernel
argument_list|()
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|PVF_WRITE
condition|)
block|{
name|pg
operator|->
name|md
operator|.
name|krw_mappings
operator|++
expr_stmt|;
name|pg
operator|->
name|md
operator|.
name|kro_mappings
operator|--
expr_stmt|;
block|}
else|else
block|{
name|pg
operator|->
name|md
operator|.
name|kro_mappings
operator|++
expr_stmt|;
name|pg
operator|->
name|md
operator|.
name|krw_mappings
operator|--
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|PVF_WRITE
condition|)
block|{
name|pg
operator|->
name|md
operator|.
name|urw_mappings
operator|++
expr_stmt|;
name|pg
operator|->
name|md
operator|.
name|uro_mappings
operator|--
expr_stmt|;
block|}
else|else
block|{
name|pg
operator|->
name|md
operator|.
name|uro_mappings
operator|++
expr_stmt|;
name|pg
operator|->
name|md
operator|.
name|urw_mappings
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|pg
operator|->
name|md
operator|.
name|krw_mappings
operator|==
literal|0
operator|&&
name|pg
operator|->
name|md
operator|.
name|urw_mappings
operator|==
literal|0
condition|)
block|{
name|pg
operator|->
name|md
operator|.
name|pvh_attrs
operator|&=
operator|~
name|PVF_MOD
expr_stmt|;
name|vm_page_flag_clear
argument_list|(
name|pg
argument_list|,
name|PG_WRITEABLE
argument_list|)
expr_stmt|;
block|}
name|pmap_vac_me_harder
argument_list|(
name|pg
argument_list|,
name|pm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|oflags
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Function to set the debug level of the pmap code */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PMAP_DEBUG
end_ifdef

begin_function
name|void
name|pmap_debug
parameter_list|(
name|int
name|level
parameter_list|)
block|{
name|pmap_debug_level
operator|=
name|level
expr_stmt|;
name|dprintf
argument_list|(
literal|"pmap_debug: level=%d\n"
argument_list|,
name|pmap_debug_level
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PMAP_DEBUG */
end_comment

begin_function
name|void
name|pmap_pinit0
parameter_list|(
name|struct
name|pmap
modifier|*
name|pmap
parameter_list|)
block|{
name|PDEBUG
argument_list|(
literal|1
argument_list|,
name|printf
argument_list|(
literal|"pmap_pinit0: pmap = %08x\n"
argument_list|,
operator|(
name|u_int32_t
operator|)
name|pmap
argument_list|)
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|"pmap_pinit0: pmap = %08x, pm_pdir = %08x\n"
argument_list|,
operator|(
name|u_int32_t
operator|)
name|pmap
argument_list|,
operator|(
name|u_int32_t
operator|)
name|pmap
operator|->
name|pm_pdir
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|kernel_pmap
argument_list|,
name|pmap
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pmap
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Initialize a vm_page's machine-dependent fields.  */
end_comment

begin_function
name|void
name|pmap_page_init
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|TAILQ_INIT
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|)
expr_stmt|;
name|m
operator|->
name|md
operator|.
name|pv_list_count
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *      Initialize the pmap module.  *      Called by vm_init, to initialize any structures that the pmap  *      system needs to map virtual memory.  */
end_comment

begin_function
name|void
name|pmap_init
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|shpgperproc
init|=
name|PMAP_SHPGPERPROC
decl_stmt|;
name|PDEBUG
argument_list|(
literal|1
argument_list|,
name|printf
argument_list|(
literal|"pmap_init: phys_start = %08x\n"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * init the pv free list 	 */
name|pvzone
operator|=
name|uma_zcreate
argument_list|(
literal|"PV ENTRY"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pv_entry
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
name|UMA_ZONE_VM
operator||
name|UMA_ZONE_NOFREE
argument_list|)
expr_stmt|;
comment|/* 	 * Now it is safe to enable pv_table recording. 	 */
name|PDEBUG
argument_list|(
literal|1
argument_list|,
name|printf
argument_list|(
literal|"pmap_init: done!\n"
argument_list|)
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"vm.pmap.shpgperproc"
argument_list|,
operator|&
name|shpgperproc
argument_list|)
expr_stmt|;
name|pv_entry_max
operator|=
name|shpgperproc
operator|*
name|maxproc
operator|+
name|vm_page_array_size
expr_stmt|;
name|pv_entry_high_water
operator|=
literal|9
operator|*
operator|(
name|pv_entry_max
operator|/
literal|10
operator|)
expr_stmt|;
name|l2zone
operator|=
name|uma_zcreate
argument_list|(
literal|"L2 Table"
argument_list|,
name|L2_TABLE_SIZE_REAL
argument_list|,
name|pmap_l2ptp_ctor
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
name|UMA_ZONE_VM
operator||
name|UMA_ZONE_NOFREE
argument_list|)
expr_stmt|;
name|l2table_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"L2 Table"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|l2_dtable
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
name|UMA_ZONE_VM
operator||
name|UMA_ZONE_NOFREE
argument_list|)
expr_stmt|;
name|uma_zone_set_obj
argument_list|(
name|pvzone
argument_list|,
operator|&
name|pvzone_obj
argument_list|,
name|pv_entry_max
argument_list|)
expr_stmt|;
name|uma_zone_set_obj
argument_list|(
name|l2zone
argument_list|,
operator|&
name|l2zone_obj
argument_list|,
name|pv_entry_max
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|pmap_fault_fixup
parameter_list|(
name|pmap_t
name|pm
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_prot_t
name|ftype
parameter_list|,
name|int
name|user
parameter_list|)
block|{
name|struct
name|l2_dtable
modifier|*
name|l2
decl_stmt|;
name|struct
name|l2_bucket
modifier|*
name|l2b
decl_stmt|;
name|pd_entry_t
modifier|*
name|pl1pd
decl_stmt|,
name|l1pd
decl_stmt|;
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|,
name|pte
decl_stmt|;
name|vm_paddr_t
name|pa
decl_stmt|;
name|u_int
name|l1idx
decl_stmt|;
name|int
name|rv
init|=
literal|0
decl_stmt|;
if|#
directive|if
literal|0
block|PMAP_MAP_TO_HEAD_LOCK(); 	pmap_acquire_pmap_lock(pm);
endif|#
directive|endif
name|l1idx
operator|=
name|L1_IDX
argument_list|(
name|va
argument_list|)
expr_stmt|;
comment|/* 	 * If there is no l2_dtable for this address, then the process 	 * has no business accessing it. 	 * 	 * Note: This will catch userland processes trying to access 	 * kernel addresses. 	 */
name|l2
operator|=
name|pm
operator|->
name|pm_l2
index|[
name|L2_IDX
argument_list|(
name|l1idx
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|l2
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * Likewise if there is no L2 descriptor table 	 */
name|l2b
operator|=
operator|&
name|l2
operator|->
name|l2_bucket
index|[
name|L2_BUCKET
argument_list|(
name|l1idx
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|l2b
operator|->
name|l2b_kva
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * Check the PTE itself. 	 */
name|ptep
operator|=
operator|&
name|l2b
operator|->
name|l2b_kva
index|[
name|l2pte_index
argument_list|(
name|va
argument_list|)
index|]
expr_stmt|;
name|pte
operator|=
operator|*
name|ptep
expr_stmt|;
if|if
condition|(
name|pte
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * Catch a userland access to the vector page mapped at 0x0 	 */
if|if
condition|(
name|user
operator|&&
operator|(
name|pte
operator|&
name|L2_S_PROT_U
operator|)
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|va
operator|==
name|vector_page
condition|)
goto|goto
name|out
goto|;
name|pa
operator|=
name|l2pte_pa
argument_list|(
name|pte
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ftype
operator|&
name|VM_PROT_WRITE
operator|)
operator|&&
operator|(
name|pte
operator|&
name|L2_S_PROT_W
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * This looks like a good candidate for "page modified" 		 * emulation... 		 */
name|struct
name|pv_entry
modifier|*
name|pv
decl_stmt|;
name|struct
name|vm_page
modifier|*
name|pg
decl_stmt|;
comment|/* Extract the physical address of the page */
if|if
condition|(
operator|(
name|pg
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pa
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
goto|goto
name|out
goto|;
block|}
comment|/* Get the current flags for this page. */
name|pv
operator|=
name|pmap_find_pv
argument_list|(
name|pg
argument_list|,
name|pm
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|pv
operator|==
name|NULL
condition|)
block|{
goto|goto
name|out
goto|;
block|}
comment|/* 		 * Do the flags say this page is writable? If not then it 		 * is a genuine write fault. If yes then the write fault is 		 * our fault as we did not reflect the write access in the 		 * PTE. Now we know a write has occurred we can correct this 		 * and also set the modified bit 		 */
if|if
condition|(
operator|(
name|pv
operator|->
name|pv_flags
operator|&
name|PVF_WRITE
operator|)
operator|==
literal|0
condition|)
block|{
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|pmap_track_modified
argument_list|(
name|pv
operator|->
name|pv_va
argument_list|)
condition|)
block|{
name|pg
operator|->
name|md
operator|.
name|pvh_attrs
operator||=
name|PVF_REF
operator||
name|PVF_MOD
expr_stmt|;
name|vm_page_dirty
argument_list|(
name|pg
argument_list|)
expr_stmt|;
block|}
name|pv
operator|->
name|pv_flags
operator||=
name|PVF_REF
operator||
name|PVF_MOD
expr_stmt|;
comment|/*  		 * Re-enable write permissions for the page.  No need to call 		 * pmap_vac_me_harder(), since this is just a 		 * modified-emulation fault, and the PVF_WRITE bit isn't 		 * changing. We've already set the cacheable bits based on 		 * the assumption that we can write to this page. 		 */
operator|*
name|ptep
operator|=
operator|(
name|pte
operator|&
operator|~
name|L2_TYPE_MASK
operator|)
operator||
name|L2_S_PROTO
operator||
name|L2_S_PROT_W
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|ptep
argument_list|)
expr_stmt|;
name|rv
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|pte
operator|&
name|L2_TYPE_MASK
operator|)
operator|==
name|L2_TYPE_INV
condition|)
block|{
comment|/* 		 * This looks like a good candidate for "page referenced" 		 * emulation. 		 */
name|struct
name|pv_entry
modifier|*
name|pv
decl_stmt|;
name|struct
name|vm_page
modifier|*
name|pg
decl_stmt|;
comment|/* Extract the physical address of the page */
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|pg
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pa
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Get the current flags for this page. */
name|pv
operator|=
name|pmap_find_pv
argument_list|(
name|pg
argument_list|,
name|pm
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|pv
operator|==
name|NULL
condition|)
block|{
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|pg
operator|->
name|md
operator|.
name|pvh_attrs
operator||=
name|PVF_REF
expr_stmt|;
name|pv
operator|->
name|pv_flags
operator||=
name|PVF_REF
expr_stmt|;
operator|*
name|ptep
operator|=
operator|(
name|pte
operator|&
operator|~
name|L2_TYPE_MASK
operator|)
operator||
name|L2_S_PROTO
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|ptep
argument_list|)
expr_stmt|;
name|rv
operator|=
literal|1
expr_stmt|;
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
block|}
comment|/* 	 * We know there is a valid mapping here, so simply 	 * fix up the L1 if necessary. 	 */
name|pl1pd
operator|=
operator|&
name|pm
operator|->
name|pm_l1
operator|->
name|l1_kva
index|[
name|l1idx
index|]
expr_stmt|;
name|l1pd
operator|=
name|l2b
operator|->
name|l2b_phys
operator||
name|L1_C_DOM
argument_list|(
name|pm
operator|->
name|pm_domain
argument_list|)
operator||
name|L1_C_PROTO
expr_stmt|;
if|if
condition|(
operator|*
name|pl1pd
operator|!=
name|l1pd
condition|)
block|{
operator|*
name|pl1pd
operator|=
name|l1pd
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|pl1pd
argument_list|)
expr_stmt|;
name|rv
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|CPU_SA110
comment|/* 	 * There are bugs in the rev K SA110.  This is a check for one 	 * of them. 	 */
if|if
condition|(
name|rv
operator|==
literal|0
operator|&&
name|curcpu
argument_list|()
operator|->
name|ci_arm_cputype
operator|==
name|CPU_ID_SA110
operator|&&
name|curcpu
argument_list|()
operator|->
name|ci_arm_cpurev
operator|<
literal|3
condition|)
block|{
comment|/* Always current pmap */
if|if
condition|(
name|l2pte_valid
argument_list|(
name|pte
argument_list|)
condition|)
block|{
specifier|extern
name|int
name|kernel_debug
decl_stmt|;
if|if
condition|(
name|kernel_debug
operator|&
literal|1
condition|)
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|curlwp
operator|->
name|l_proc
decl_stmt|;
name|printf
argument_list|(
literal|"prefetch_abort: page is already "
literal|"mapped - pte=%p *pte=%08x\n"
argument_list|,
name|ptep
argument_list|,
name|pte
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"prefetch_abort: pc=%08lx proc=%p "
literal|"process=%s\n"
argument_list|,
name|va
argument_list|,
name|p
argument_list|,
name|p
operator|->
name|p_comm
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"prefetch_abort: far=%08x fs=%x\n"
argument_list|,
name|cpu_faultaddress
argument_list|()
argument_list|,
name|cpu_faultstatus
argument_list|()
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DDB
if|if
condition|(
name|kernel_debug
operator|&
literal|2
condition|)
name|Debugger
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|rv
operator|=
literal|1
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* CPU_SA110 */
ifdef|#
directive|ifdef
name|DEBUG
comment|/* 	 * If 'rv == 0' at this point, it generally indicates that there is a 	 * stale TLB entry for the faulting address. This happens when two or 	 * more processes are sharing an L1. Since we don't flush the TLB on 	 * a context switch between such processes, we can take domain faults 	 * for mappings which exist at the same VA in both processes. EVEN IF 	 * WE'VE RECENTLY FIXED UP THE CORRESPONDING L1 in pmap_enter(), for 	 * example. 	 * 	 * This is extremely likely to happen if pmap_enter() updated the L1 	 * entry for a recently entered mapping. In this case, the TLB is 	 * flushed for the new mapping, but there may still be TLB entries for 	 * other mappings belonging to other processes in the 1MB range 	 * covered by the L1 entry. 	 * 	 * Since 'rv == 0', we know that the L1 already contains the correct 	 * value, so the fault must be due to a stale TLB entry. 	 * 	 * Since we always need to flush the TLB anyway in the case where we 	 * fixed up the L1, or frobbed the L2 PTE, we effectively deal with 	 * stale TLB entries dynamically. 	 * 	 * However, the above condition can ONLY happen if the current L1 is 	 * being shared. If it happens when the L1 is unshared, it indicates 	 * that other parts of the pmap are not doing their job WRT managing 	 * the TLB. 	 */
if|if
condition|(
name|rv
operator|==
literal|0
operator|&&
name|pm
operator|->
name|pm_l1
operator|->
name|l1_domain_use_count
operator|==
literal|1
condition|)
block|{
specifier|extern
name|int
name|last_fault_code
decl_stmt|;
name|printf
argument_list|(
literal|"fixup: pm %p, va 0x%lx, ftype %d - nothing to do!\n"
argument_list|,
name|pm
argument_list|,
name|va
argument_list|,
name|ftype
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"fixup: l2 %p, l2b %p, ptep %p, pl1pd %p\n"
argument_list|,
name|l2
argument_list|,
name|l2b
argument_list|,
name|ptep
argument_list|,
name|pl1pd
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"fixup: pte 0x%x, l1pd 0x%x, last code 0x%x\n"
argument_list|,
name|pte
argument_list|,
name|l1pd
argument_list|,
name|last_fault_code
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DDB
name|Debugger
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
name|cpu_tlb_flushID_SE
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|cpu_cpwait
argument_list|()
expr_stmt|;
name|rv
operator|=
literal|1
expr_stmt|;
name|out
label|:
if|#
directive|if
literal|0
block|pmap_release_pmap_lock(pm); 	PMAP_MAP_TO_HEAD_UNLOCK();
endif|#
directive|endif
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pmap_postinit
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|l2_bucket
modifier|*
name|l2b
decl_stmt|;
name|struct
name|l1_ttable
modifier|*
name|l1
decl_stmt|;
name|pd_entry_t
modifier|*
name|pl1pt
decl_stmt|;
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|,
name|pte
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|,
name|eva
decl_stmt|;
name|u_int
name|loop
decl_stmt|,
name|needed
decl_stmt|;
name|needed
operator|=
operator|(
name|maxproc
operator|/
name|PMAP_DOMAINS
operator|)
operator|+
operator|(
operator|(
name|maxproc
operator|%
name|PMAP_DOMAINS
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
name|needed
operator|-=
literal|1
expr_stmt|;
name|l1
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|l1
argument_list|)
operator|*
name|needed
argument_list|,
name|M_VMPMAP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
for|for
control|(
name|loop
operator|=
literal|0
init|;
name|loop
operator|<
name|needed
condition|;
name|loop
operator|++
operator|,
name|l1
operator|++
control|)
block|{
comment|/* Allocate a L1 page table */
name|va
operator|=
operator|(
name|vm_offset_t
operator|)
name|contigmalloc
argument_list|(
name|L1_TABLE_SIZE
argument_list|,
name|M_VMPMAP
argument_list|,
literal|0
argument_list|,
literal|0x0
argument_list|,
literal|0xffffffff
argument_list|,
name|L1_TABLE_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|va
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"Cannot allocate L1 KVM"
argument_list|)
expr_stmt|;
name|eva
operator|=
name|va
operator|+
name|L1_TABLE_SIZE
expr_stmt|;
name|pl1pt
operator|=
operator|(
name|pd_entry_t
operator|*
operator|)
name|va
expr_stmt|;
while|while
condition|(
name|va
operator|<
name|eva
condition|)
block|{
name|l2b
operator|=
name|pmap_get_l2_bucket
argument_list|(
name|pmap_kernel
argument_list|()
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|ptep
operator|=
operator|&
name|l2b
operator|->
name|l2b_kva
index|[
name|l2pte_index
argument_list|(
name|va
argument_list|)
index|]
expr_stmt|;
name|pte
operator|=
operator|*
name|ptep
expr_stmt|;
name|pte
operator|=
operator|(
name|pte
operator|&
operator|~
name|L2_S_CACHE_MASK
operator|)
operator||
name|pte_l2_s_cache_mode_pt
expr_stmt|;
operator|*
name|ptep
operator|=
name|pte
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|ptep
argument_list|)
expr_stmt|;
name|cpu_tlb_flushD_SE
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|va
operator|+=
name|PAGE_SIZE
expr_stmt|;
block|}
name|pmap_init_l1
argument_list|(
name|l1
argument_list|,
name|pl1pt
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"pmap_postinit: Allocated %d static L1 descriptor tables\n"
argument_list|,
name|needed
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * This is used to stuff certain critical values into the PCB where they  * can be accessed quickly from cpu_switch() et al.  */
end_comment

begin_function
name|void
name|pmap_set_pcb_pagedir
parameter_list|(
name|pmap_t
name|pm
parameter_list|,
name|struct
name|pcb
modifier|*
name|pcb
parameter_list|)
block|{
name|struct
name|l2_bucket
modifier|*
name|l2b
decl_stmt|;
name|pcb
operator|->
name|pcb_pagedir
operator|=
name|pm
operator|->
name|pm_l1
operator|->
name|l1_physaddr
expr_stmt|;
name|pcb
operator|->
name|pcb_dacr
operator|=
operator|(
name|DOMAIN_CLIENT
operator|<<
operator|(
name|PMAP_DOMAIN_KERNEL
operator|*
literal|2
operator|)
operator|)
operator||
operator|(
name|DOMAIN_CLIENT
operator|<<
operator|(
name|pm
operator|->
name|pm_domain
operator|*
literal|2
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|vector_page
operator|<
name|KERNBASE
condition|)
block|{
name|pcb
operator|->
name|pcb_pl1vec
operator|=
operator|&
name|pm
operator|->
name|pm_l1
operator|->
name|l1_kva
index|[
name|L1_IDX
argument_list|(
name|vector_page
argument_list|)
index|]
expr_stmt|;
name|l2b
operator|=
name|pmap_get_l2_bucket
argument_list|(
name|pm
argument_list|,
name|vector_page
argument_list|)
expr_stmt|;
name|pcb
operator|->
name|pcb_l1vec
operator|=
name|l2b
operator|->
name|l2b_phys
operator||
name|L1_C_PROTO
operator||
name|L1_C_DOM
argument_list|(
name|pm
operator|->
name|pm_domain
argument_list|)
operator||
name|L1_C_DOM
argument_list|(
name|PMAP_DOMAIN_KERNEL
argument_list|)
expr_stmt|;
block|}
else|else
name|pcb
operator|->
name|pcb_pl1vec
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pmap_activate
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|pmap_t
name|pm
decl_stmt|;
name|struct
name|pcb
modifier|*
name|pcb
decl_stmt|;
name|int
name|s
decl_stmt|;
name|pm
operator|=
name|vmspace_pmap
argument_list|(
name|td
operator|->
name|td_proc
operator|->
name|p_vmspace
argument_list|)
expr_stmt|;
name|pcb
operator|=
name|td
operator|->
name|td_pcb
expr_stmt|;
name|critical_enter
argument_list|()
expr_stmt|;
name|pmap_set_pcb_pagedir
argument_list|(
name|pm
argument_list|,
name|pcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|==
name|curthread
condition|)
block|{
name|u_int
name|cur_dacr
decl_stmt|,
name|cur_ttb
decl_stmt|;
asm|__asm __volatile("mrc p15, 0, %0, c2, c0, 0" : "=r"(cur_ttb));
asm|__asm __volatile("mrc p15, 0, %0, c3, c0, 0" : "=r"(cur_dacr));
name|cur_ttb
operator|&=
operator|~
operator|(
name|L1_TABLE_SIZE
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|cur_ttb
operator|==
operator|(
name|u_int
operator|)
name|pcb
operator|->
name|pcb_pagedir
operator|&&
name|cur_dacr
operator|==
name|pcb
operator|->
name|pcb_dacr
condition|)
block|{
comment|/* 			 * No need to switch address spaces. 			 */
name|critical_exit
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* 		 * We MUST, I repeat, MUST fix up the L1 entry corresponding 		 * to 'vector_page' in the incoming L1 table before switching 		 * to it otherwise subsequent interrupts/exceptions (including 		 * domain faults!) will jump into hyperspace. 		 */
if|if
condition|(
name|pcb
operator|->
name|pcb_pl1vec
condition|)
block|{
operator|*
name|pcb
operator|->
name|pcb_pl1vec
operator|=
name|pcb
operator|->
name|pcb_l1vec
expr_stmt|;
comment|/* 			 * Don't need to PTE_SYNC() at this point since 			 * cpu_setttb() is about to flush both the cache 			 * and the TLB. 			 */
block|}
name|cpu_domains
argument_list|(
name|pcb
operator|->
name|pcb_dacr
argument_list|)
expr_stmt|;
name|cpu_setttb
argument_list|(
name|pcb
operator|->
name|pcb_pagedir
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|critical_exit
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pmap_set_pt_cache_mode
parameter_list|(
name|pd_entry_t
modifier|*
name|kl1
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|pd_entry_t
modifier|*
name|pdep
decl_stmt|,
name|pde
decl_stmt|;
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|,
name|pte
decl_stmt|;
name|vm_offset_t
name|pa
decl_stmt|;
name|int
name|rv
init|=
literal|0
decl_stmt|;
comment|/* 	 * Make sure the descriptor itself has the correct cache mode 	 */
name|pdep
operator|=
operator|&
name|kl1
index|[
name|L1_IDX
argument_list|(
name|va
argument_list|)
index|]
expr_stmt|;
name|pde
operator|=
operator|*
name|pdep
expr_stmt|;
if|if
condition|(
name|l1pte_section_p
argument_list|(
name|pde
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|pde
operator|&
name|L1_S_CACHE_MASK
operator|)
operator|!=
name|pte_l1_s_cache_mode_pt
condition|)
block|{
operator|*
name|pdep
operator|=
operator|(
name|pde
operator|&
operator|~
name|L1_S_CACHE_MASK
operator|)
operator||
name|pte_l1_s_cache_mode_pt
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|pdep
argument_list|)
expr_stmt|;
name|cpu_dcache_wbinv_range
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|pdep
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pdep
argument_list|)
argument_list|)
expr_stmt|;
name|rv
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|pa
operator|=
call|(
name|vm_paddr_t
call|)
argument_list|(
name|pde
operator|&
name|L1_C_ADDR_MASK
argument_list|)
expr_stmt|;
name|ptep
operator|=
operator|(
name|pt_entry_t
operator|*
operator|)
name|kernel_pt_lookup
argument_list|(
name|pa
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptep
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"pmap_bootstrap: No L2 for L2 @ va %p\n"
argument_list|,
name|ptep
argument_list|)
expr_stmt|;
name|ptep
operator|=
operator|&
name|ptep
index|[
name|l2pte_index
argument_list|(
name|va
argument_list|)
index|]
expr_stmt|;
name|pte
operator|=
operator|*
name|ptep
expr_stmt|;
if|if
condition|(
operator|(
name|pte
operator|&
name|L2_S_CACHE_MASK
operator|)
operator|!=
name|pte_l2_s_cache_mode_pt
condition|)
block|{
operator|*
name|ptep
operator|=
operator|(
name|pte
operator|&
operator|~
name|L2_S_CACHE_MASK
operator|)
operator||
name|pte_l2_s_cache_mode_pt
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|ptep
argument_list|)
expr_stmt|;
name|cpu_dcache_wbinv_range
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|ptep
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ptep
argument_list|)
argument_list|)
expr_stmt|;
name|rv
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pmap_alloc_specials
parameter_list|(
name|vm_offset_t
modifier|*
name|availp
parameter_list|,
name|int
name|pages
parameter_list|,
name|vm_offset_t
modifier|*
name|vap
parameter_list|,
name|pt_entry_t
modifier|*
modifier|*
name|ptep
parameter_list|)
block|{
name|vm_offset_t
name|va
init|=
operator|*
name|availp
decl_stmt|;
name|struct
name|l2_bucket
modifier|*
name|l2b
decl_stmt|;
if|if
condition|(
name|ptep
condition|)
block|{
name|l2b
operator|=
name|pmap_get_l2_bucket
argument_list|(
name|pmap_kernel
argument_list|()
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|l2b
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"pmap_alloc_specials: no l2b for 0x%x"
argument_list|,
name|va
argument_list|)
expr_stmt|;
operator|*
name|ptep
operator|=
operator|&
name|l2b
operator|->
name|l2b_kva
index|[
name|l2pte_index
argument_list|(
name|va
argument_list|)
index|]
expr_stmt|;
block|}
operator|*
name|vap
operator|=
name|va
expr_stmt|;
operator|*
name|availp
operator|=
name|va
operator|+
operator|(
name|PAGE_SIZE
operator|*
name|pages
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Bootstrap the system enough to run with virtual memory.  *  *	On the arm this is called after mapping has already been enabled  *	and just syncs the pmap module with what has already been done.  *	[We can't call it easily with mapping off since the kernel is not  *	mapped with PA == VA, hence we would have to relocate every address  *	from the linked base (virtual) address "KERNBASE" to the actual  *	(physical) address starting relative to 0]  */
end_comment

begin_define
define|#
directive|define
name|PMAP_STATIC_L2_SIZE
value|16
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|ARM_USE_SMALL_ALLOC
end_ifdef

begin_decl_stmt
specifier|extern
name|struct
name|mtx
name|smallalloc_mtx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|vm_offset_t
name|alloc_curaddr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|vm_offset_t
name|alloc_firstaddr
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|pmap_bootstrap
parameter_list|(
name|vm_offset_t
name|firstaddr
parameter_list|,
name|vm_offset_t
name|lastaddr
parameter_list|,
name|struct
name|pv_addr
modifier|*
name|l1pt
parameter_list|)
block|{
specifier|static
name|struct
name|l1_ttable
name|static_l1
decl_stmt|;
specifier|static
name|struct
name|l2_dtable
name|static_l2
index|[
name|PMAP_STATIC_L2_SIZE
index|]
decl_stmt|;
name|struct
name|l1_ttable
modifier|*
name|l1
init|=
operator|&
name|static_l1
decl_stmt|;
name|struct
name|l2_dtable
modifier|*
name|l2
decl_stmt|;
name|struct
name|l2_bucket
modifier|*
name|l2b
decl_stmt|;
name|pd_entry_t
name|pde
decl_stmt|;
name|pd_entry_t
modifier|*
name|kernel_l1pt
init|=
operator|(
name|pd_entry_t
operator|*
operator|)
name|l1pt
operator|->
name|pv_va
decl_stmt|;
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|;
name|vm_paddr_t
name|pa
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
name|vm_size_t
name|size
decl_stmt|;
name|int
name|l1idx
decl_stmt|,
name|l2idx
decl_stmt|,
name|l2next
init|=
literal|0
decl_stmt|;
name|PDEBUG
argument_list|(
literal|1
argument_list|,
name|printf
argument_list|(
literal|"firstaddr = %08x, loadaddr = %08x\n"
argument_list|,
name|firstaddr
argument_list|,
name|loadaddr
argument_list|)
argument_list|)
expr_stmt|;
name|virtual_avail
operator|=
name|firstaddr
expr_stmt|;
name|kernel_pmap
operator|=
operator|&
name|kernel_pmap_store
expr_stmt|;
name|kernel_pmap
operator|->
name|pm_l1
operator|=
name|l1
expr_stmt|;
name|kernel_l1pa
operator|=
name|l1pt
operator|->
name|pv_pa
expr_stmt|;
comment|/* 	 * Scan the L1 translation table created by initarm() and create 	 * the required metadata for all valid mappings found in it. 	 */
for|for
control|(
name|l1idx
operator|=
literal|0
init|;
name|l1idx
operator|<
operator|(
name|L1_TABLE_SIZE
operator|/
sizeof|sizeof
argument_list|(
name|pd_entry_t
argument_list|)
operator|)
condition|;
name|l1idx
operator|++
control|)
block|{
name|pde
operator|=
name|kernel_l1pt
index|[
name|l1idx
index|]
expr_stmt|;
comment|/* 		 * We're only interested in Coarse mappings. 		 * pmap_extract() can deal with section mappings without 		 * recourse to checking L2 metadata. 		 */
if|if
condition|(
operator|(
name|pde
operator|&
name|L1_TYPE_MASK
operator|)
operator|!=
name|L1_TYPE_C
condition|)
continue|continue;
comment|/* 		 * Lookup the KVA of this L2 descriptor table 		 */
name|pa
operator|=
call|(
name|vm_paddr_t
call|)
argument_list|(
name|pde
operator|&
name|L1_C_ADDR_MASK
argument_list|)
expr_stmt|;
name|ptep
operator|=
operator|(
name|pt_entry_t
operator|*
operator|)
name|kernel_pt_lookup
argument_list|(
name|pa
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptep
operator|==
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"pmap_bootstrap: No L2 for va 0x%x, pa 0x%lx"
argument_list|,
operator|(
name|u_int
operator|)
name|l1idx
operator|<<
name|L1_S_SHIFT
argument_list|,
operator|(
name|long
name|unsigned
name|int
operator|)
name|pa
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Fetch the associated L2 metadata structure. 		 * Allocate a new one if necessary. 		 */
if|if
condition|(
operator|(
name|l2
operator|=
name|kernel_pmap
operator|->
name|pm_l2
index|[
name|L2_IDX
argument_list|(
name|l1idx
argument_list|)
index|]
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|l2next
operator|==
name|PMAP_STATIC_L2_SIZE
condition|)
name|panic
argument_list|(
literal|"pmap_bootstrap: out of static L2s"
argument_list|)
expr_stmt|;
name|kernel_pmap
operator|->
name|pm_l2
index|[
name|L2_IDX
argument_list|(
name|l1idx
argument_list|)
index|]
operator|=
name|l2
operator|=
operator|&
name|static_l2
index|[
name|l2next
operator|++
index|]
expr_stmt|;
block|}
comment|/* 		 * One more L1 slot tracked... 		 */
name|l2
operator|->
name|l2_occupancy
operator|++
expr_stmt|;
comment|/* 		 * Fill in the details of the L2 descriptor in the 		 * appropriate bucket. 		 */
name|l2b
operator|=
operator|&
name|l2
operator|->
name|l2_bucket
index|[
name|L2_BUCKET
argument_list|(
name|l1idx
argument_list|)
index|]
expr_stmt|;
name|l2b
operator|->
name|l2b_kva
operator|=
name|ptep
expr_stmt|;
name|l2b
operator|->
name|l2b_phys
operator|=
name|pa
expr_stmt|;
name|l2b
operator|->
name|l2b_l1idx
operator|=
name|l1idx
expr_stmt|;
comment|/* 		 * Establish an initial occupancy count for this descriptor 		 */
for|for
control|(
name|l2idx
operator|=
literal|0
init|;
name|l2idx
operator|<
operator|(
name|L2_TABLE_SIZE_REAL
operator|/
sizeof|sizeof
argument_list|(
name|pt_entry_t
argument_list|)
operator|)
condition|;
name|l2idx
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ptep
index|[
name|l2idx
index|]
operator|&
name|L2_TYPE_MASK
operator|)
operator|!=
name|L2_TYPE_INV
condition|)
block|{
name|l2b
operator|->
name|l2b_occupancy
operator|++
expr_stmt|;
block|}
block|}
comment|/* 		 * Make sure the descriptor itself has the correct cache mode. 		 * If not, fix it, but whine about the problem. Port-meisters 		 * should consider this a clue to fix up their initarm() 		 * function. :) 		 */
if|if
condition|(
name|pmap_set_pt_cache_mode
argument_list|(
name|kernel_l1pt
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|ptep
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"pmap_bootstrap: WARNING! wrong cache mode for "
literal|"L2 pte @ %p\n"
argument_list|,
name|ptep
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Ensure the primary (kernel) L1 has the correct cache mode for 	 * a page table. Bitch if it is not correctly set. 	 */
for|for
control|(
name|va
operator|=
operator|(
name|vm_offset_t
operator|)
name|kernel_l1pt
init|;
name|va
operator|<
operator|(
operator|(
name|vm_offset_t
operator|)
name|kernel_l1pt
operator|+
name|L1_TABLE_SIZE
operator|)
condition|;
name|va
operator|+=
name|PAGE_SIZE
control|)
block|{
if|if
condition|(
name|pmap_set_pt_cache_mode
argument_list|(
name|kernel_l1pt
argument_list|,
name|va
argument_list|)
condition|)
name|printf
argument_list|(
literal|"pmap_bootstrap: WARNING! wrong cache mode for "
literal|"primary L1 @ 0x%x\n"
argument_list|,
name|va
argument_list|)
expr_stmt|;
block|}
name|cpu_dcache_wbinv_all
argument_list|()
expr_stmt|;
name|cpu_tlb_flushID
argument_list|()
expr_stmt|;
name|cpu_cpwait
argument_list|()
expr_stmt|;
name|kernel_pmap
operator|->
name|pm_active
operator|=
operator|-
literal|1
expr_stmt|;
name|kernel_pmap
operator|->
name|pm_domain
operator|=
name|PMAP_DOMAIN_KERNEL
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|allpmaps
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|kernel_pmap
operator|->
name|pm_pvlist
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|allpmaps
argument_list|,
name|kernel_pmap
argument_list|,
name|pm_list
argument_list|)
expr_stmt|;
comment|/* 	 * Reserve some special page table entries/VA space for temporary 	 * mapping of pages. 	 */
define|#
directive|define
name|SYSMAP
parameter_list|(
name|c
parameter_list|,
name|p
parameter_list|,
name|v
parameter_list|,
name|n
parameter_list|)
define|\
value|v = (c)va; va += ((n)*PAGE_SIZE); p = pte; pte += (n);
name|pmap_alloc_specials
argument_list|(
operator|&
name|virtual_avail
argument_list|,
literal|1
argument_list|,
operator|&
name|csrcp
argument_list|,
operator|&
name|csrc_pte
argument_list|)
expr_stmt|;
name|pmap_set_pt_cache_mode
argument_list|(
name|kernel_l1pt
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|csrc_pte
argument_list|)
expr_stmt|;
name|pmap_alloc_specials
argument_list|(
operator|&
name|virtual_avail
argument_list|,
literal|1
argument_list|,
operator|&
name|cdstp
argument_list|,
operator|&
name|cdst_pte
argument_list|)
expr_stmt|;
name|pmap_set_pt_cache_mode
argument_list|(
name|kernel_l1pt
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|cdst_pte
argument_list|)
expr_stmt|;
name|size
operator|=
operator|(
operator|(
name|lastaddr
operator|-
name|pmap_curmaxkvaddr
operator|)
operator|+
name|L1_S_OFFSET
operator|)
operator|/
name|L1_S_SIZE
expr_stmt|;
name|pmap_alloc_specials
argument_list|(
operator|&
name|virtual_avail
argument_list|,
name|round_page
argument_list|(
name|size
operator|*
name|L2_TABLE_SIZE_REAL
argument_list|)
operator|/
name|PAGE_SIZE
argument_list|,
operator|&
name|pmap_kernel_l2ptp_kva
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|size
operator|=
operator|(
name|size
operator|+
operator|(
name|L2_BUCKET_SIZE
operator|-
literal|1
operator|)
operator|)
operator|/
name|L2_BUCKET_SIZE
expr_stmt|;
name|pmap_alloc_specials
argument_list|(
operator|&
name|virtual_avail
argument_list|,
name|round_page
argument_list|(
name|size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|l2_dtable
argument_list|)
argument_list|)
operator|/
name|PAGE_SIZE
argument_list|,
operator|&
name|pmap_kernel_l2dtable_kva
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|pmap_alloc_specials
argument_list|(
operator|&
name|virtual_avail
argument_list|,
literal|1
argument_list|,
operator|(
name|vm_offset_t
operator|*
operator|)
operator|&
name|_tmppt
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|l1_list
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|l1_lru_list
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|l1_lru_lock
argument_list|,
literal|"l1 list lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|pmap_init_l1
argument_list|(
name|l1
argument_list|,
name|kernel_l1pt
argument_list|)
expr_stmt|;
name|cpu_dcache_wbinv_all
argument_list|()
expr_stmt|;
name|virtual_avail
operator|=
name|round_page
argument_list|(
name|virtual_avail
argument_list|)
expr_stmt|;
name|virtual_end
operator|=
name|lastaddr
expr_stmt|;
name|kernel_vm_end
operator|=
name|pmap_curmaxkvaddr
expr_stmt|;
name|arm_nocache_startaddr
operator|=
name|lastaddr
expr_stmt|;
ifdef|#
directive|ifdef
name|ARM_USE_SMALL_ALLOC
name|mtx_init
argument_list|(
operator|&
name|smallalloc_mtx
argument_list|,
literal|"Small alloc page list"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|alloc_firstaddr
operator|=
name|alloc_curaddr
operator|=
name|arm_nocache_startaddr
operator|+
name|ARM_NOCACHE_KVA_SIZE
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/***************************************************  * Pmap allocation/deallocation routines.  ***************************************************/
end_comment

begin_comment
comment|/*  * Release any resources held by the given physical map.  * Called when a pmap initialized by pmap_pinit is being released.  * Should only be called if the map contains no valid mappings.  */
end_comment

begin_function
name|void
name|pmap_release
parameter_list|(
name|pmap_t
name|pmap
parameter_list|)
block|{
name|struct
name|pcb
modifier|*
name|pcb
decl_stmt|;
name|pmap_idcache_wbinv_all
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|pmap_tlb_flushID
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|cpu_cpwait
argument_list|()
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|pmap
argument_list|,
name|pm_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|vector_page
operator|<
name|KERNBASE
condition|)
block|{
name|struct
name|pcb
modifier|*
name|curpcb
init|=
name|PCPU_GET
argument_list|(
name|curpcb
argument_list|)
decl_stmt|;
name|pcb
operator|=
name|thread0
operator|.
name|td_pcb
expr_stmt|;
if|if
condition|(
name|pmap_is_current
argument_list|(
name|pmap
argument_list|)
condition|)
block|{
comment|/*  			 * Frob the L1 entry corresponding to the vector 			 * page so that it contains the kernel pmap's domain 			 * number. This will ensure pmap_remove() does not 			 * pull the current vector page out from under us. 			 */
name|critical_enter
argument_list|()
expr_stmt|;
operator|*
name|pcb
operator|->
name|pcb_pl1vec
operator|=
name|pcb
operator|->
name|pcb_l1vec
expr_stmt|;
name|cpu_domains
argument_list|(
name|pcb
operator|->
name|pcb_dacr
argument_list|)
expr_stmt|;
name|cpu_setttb
argument_list|(
name|pcb
operator|->
name|pcb_pagedir
argument_list|)
expr_stmt|;
name|critical_exit
argument_list|()
expr_stmt|;
block|}
name|pmap_remove
argument_list|(
name|pmap
argument_list|,
name|vector_page
argument_list|,
name|vector_page
operator|+
name|PAGE_SIZE
argument_list|)
expr_stmt|;
comment|/* 		 * Make sure cpu_switch(), et al, DTRT. This is safe to do 		 * since this process has no remaining mappings of its own. 		 */
name|curpcb
operator|->
name|pcb_pl1vec
operator|=
name|pcb
operator|->
name|pcb_pl1vec
expr_stmt|;
name|curpcb
operator|->
name|pcb_l1vec
operator|=
name|pcb
operator|->
name|pcb_l1vec
expr_stmt|;
name|curpcb
operator|->
name|pcb_dacr
operator|=
name|pcb
operator|->
name|pcb_dacr
expr_stmt|;
name|curpcb
operator|->
name|pcb_pagedir
operator|=
name|pcb
operator|->
name|pcb_pagedir
expr_stmt|;
block|}
name|pmap_free_l1
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|"pmap_release()\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Helper function for pmap_grow_l2_bucket()  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|pmap_grow_map
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|pt_entry_t
name|cache_mode
parameter_list|,
name|vm_paddr_t
modifier|*
name|pap
parameter_list|)
block|{
name|struct
name|l2_bucket
modifier|*
name|l2b
decl_stmt|;
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|;
name|vm_paddr_t
name|pa
decl_stmt|;
name|struct
name|vm_page
modifier|*
name|pg
decl_stmt|;
name|pg
operator|=
name|vm_page_alloc
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|VM_ALLOC_NOOBJ
operator||
name|VM_ALLOC_WIRED
argument_list|)
expr_stmt|;
if|if
condition|(
name|pg
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|pa
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|pg
argument_list|)
expr_stmt|;
if|if
condition|(
name|pap
condition|)
operator|*
name|pap
operator|=
name|pa
expr_stmt|;
name|l2b
operator|=
name|pmap_get_l2_bucket
argument_list|(
name|pmap_kernel
argument_list|()
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|ptep
operator|=
operator|&
name|l2b
operator|->
name|l2b_kva
index|[
name|l2pte_index
argument_list|(
name|va
argument_list|)
index|]
expr_stmt|;
operator|*
name|ptep
operator|=
name|L2_S_PROTO
operator||
name|pa
operator||
name|cache_mode
operator||
name|L2_S_PROT
argument_list|(
name|PTE_KERNEL
argument_list|,
name|VM_PROT_READ
operator||
name|VM_PROT_WRITE
argument_list|)
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|ptep
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This is the same as pmap_alloc_l2_bucket(), except that it is only  * used by pmap_growkernel().  */
end_comment

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|l2_bucket
operator|*
name|pmap_grow_l2_bucket
argument_list|(
argument|pmap_t pm
argument_list|,
argument|vm_offset_t va
argument_list|)
block|{ 	struct
name|l2_dtable
operator|*
name|l2
block|; 	struct
name|l2_bucket
operator|*
name|l2b
block|; 	struct
name|l1_ttable
operator|*
name|l1
block|;
name|pd_entry_t
operator|*
name|pl1pd
block|;
name|u_short
name|l1idx
block|;
name|vm_offset_t
name|nva
block|;
name|l1idx
operator|=
name|L1_IDX
argument_list|(
name|va
argument_list|)
block|;
if|if
condition|(
operator|(
name|l2
operator|=
name|pm
operator|->
name|pm_l2
index|[
name|L2_IDX
argument_list|(
name|l1idx
argument_list|)
index|]
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * No mapping at this address, as there is 		 * no entry in the L1 table. 		 * Need to allocate a new l2_dtable. 		 */
name|nva
operator|=
name|pmap_kernel_l2dtable_kva
expr_stmt|;
if|if
condition|(
operator|(
name|nva
operator|&
name|PAGE_MASK
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Need to allocate a backing page 			 */
if|if
condition|(
name|pmap_grow_map
argument_list|(
name|nva
argument_list|,
name|pte_l2_s_cache_mode
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|l2
operator|=
operator|(
expr|struct
name|l2_dtable
operator|*
operator|)
name|nva
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|nva
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|l2_dtable
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|(
name|nva
operator|&
name|PAGE_MASK
operator|)
operator|<
operator|(
name|pmap_kernel_l2dtable_kva
operator|&
name|PAGE_MASK
operator|)
condition|)
block|{
comment|/* 			 * The new l2_dtable straddles a page boundary. 			 * Map in another page to cover it. 			 */
if|if
condition|(
name|pmap_grow_map
argument_list|(
name|nva
argument_list|,
name|pte_l2_s_cache_mode
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_if

begin_expr_stmt
name|pmap_kernel_l2dtable_kva
operator|=
name|nva
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 		 * Link it into the parent pmap 		 */
end_comment

begin_expr_stmt
name|pm
operator|->
name|pm_l2
index|[
name|L2_IDX
argument_list|(
name|l1idx
argument_list|)
index|]
operator|=
name|l2
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|memset
argument_list|(
name|l2
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|l2
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  	l2b
operator|=
operator|&
name|l2
operator|->
name|l2_bucket
index|[
name|L2_BUCKET
argument_list|(
name|l1idx
argument_list|)
index|]
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	 * Fetch pointer to the L2 page table associated with the address. 	 */
end_comment

begin_if
if|if
condition|(
name|l2b
operator|->
name|l2b_kva
operator|==
name|NULL
condition|)
block|{
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|;
comment|/* 		 * No L2 page table has been allocated. Chances are, this 		 * is because we just allocated the l2_dtable, above. 		 */
name|nva
operator|=
name|pmap_kernel_l2ptp_kva
expr_stmt|;
name|ptep
operator|=
operator|(
name|pt_entry_t
operator|*
operator|)
name|nva
expr_stmt|;
if|if
condition|(
operator|(
name|nva
operator|&
name|PAGE_MASK
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Need to allocate a backing page 			 */
if|if
condition|(
name|pmap_grow_map
argument_list|(
name|nva
argument_list|,
name|pte_l2_s_cache_mode_pt
argument_list|,
operator|&
name|pmap_kernel_l2ptp_phys
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|PTE_SYNC_RANGE
argument_list|(
name|ptep
argument_list|,
name|PAGE_SIZE
operator|/
sizeof|sizeof
argument_list|(
name|pt_entry_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
name|ptep
argument_list|,
literal|0
argument_list|,
name|L2_TABLE_SIZE_REAL
argument_list|)
expr_stmt|;
name|l2
operator|->
name|l2_occupancy
operator|++
expr_stmt|;
name|l2b
operator|->
name|l2b_kva
operator|=
name|ptep
expr_stmt|;
name|l2b
operator|->
name|l2b_l1idx
operator|=
name|l1idx
expr_stmt|;
name|l2b
operator|->
name|l2b_phys
operator|=
name|pmap_kernel_l2ptp_phys
expr_stmt|;
name|pmap_kernel_l2ptp_kva
operator|+=
name|L2_TABLE_SIZE_REAL
expr_stmt|;
name|pmap_kernel_l2ptp_phys
operator|+=
name|L2_TABLE_SIZE_REAL
expr_stmt|;
block|}
end_if

begin_comment
comment|/* Distribute new L1 entry to all other L1s */
end_comment

begin_macro
name|SLIST_FOREACH
argument_list|(
argument|l1
argument_list|,
argument|&l1_list
argument_list|,
argument|l1_link
argument_list|)
end_macro

begin_block
block|{
name|pl1pd
operator|=
operator|&
name|l1
operator|->
name|l1_kva
index|[
name|L1_IDX
argument_list|(
name|va
argument_list|)
index|]
expr_stmt|;
operator|*
name|pl1pd
operator|=
name|l2b
operator|->
name|l2b_phys
operator||
name|L1_C_DOM
argument_list|(
name|PMAP_DOMAIN_KERNEL
argument_list|)
operator||
name|L1_C_PROTO
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|pl1pd
argument_list|)
expr_stmt|;
block|}
end_block

begin_return
return|return
operator|(
name|l2b
operator|)
return|;
end_return

begin_comment
unit|}
comment|/*  * grow the number of kernel page table entries, if needed  */
end_comment

begin_macro
unit|void
name|pmap_growkernel
argument_list|(
argument|vm_offset_t addr
argument_list|)
end_macro

begin_block
block|{
name|pmap_t
name|kpm
init|=
name|pmap_kernel
argument_list|()
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
name|addr
operator|<=
name|pmap_curmaxkvaddr
condition|)
return|return;
comment|/* we are OK */
comment|/* 	 * whoops!   we need to add kernel PTPs 	 */
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
comment|/* to be safe */
comment|/* Map 1MB at a time */
for|for
control|(
init|;
name|pmap_curmaxkvaddr
operator|<
name|addr
condition|;
name|pmap_curmaxkvaddr
operator|+=
name|L1_S_SIZE
control|)
name|pmap_grow_l2_bucket
argument_list|(
name|kpm
argument_list|,
name|pmap_curmaxkvaddr
argument_list|)
expr_stmt|;
comment|/* 	 * flush out the cache, expensive but growkernel will happen so 	 * rarely 	 */
name|cpu_dcache_wbinv_all
argument_list|()
expr_stmt|;
name|cpu_tlb_flushD
argument_list|()
expr_stmt|;
name|cpu_cpwait
argument_list|()
expr_stmt|;
name|kernel_vm_end
operator|=
name|pmap_curmaxkvaddr
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *      pmap_page_protect:  *  *      Lower the permission for all mappings to a given page.  */
end_comment

begin_function
name|void
name|pmap_page_protect
parameter_list|(
name|vm_page_t
name|m
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|)
block|{
switch|switch
condition|(
name|prot
condition|)
block|{
case|case
name|VM_PROT_READ
operator||
name|VM_PROT_WRITE
operator||
name|VM_PROT_EXECUTE
case|:
case|case
name|VM_PROT_READ
operator||
name|VM_PROT_WRITE
case|:
return|return;
case|case
name|VM_PROT_READ
case|:
case|case
name|VM_PROT_READ
operator||
name|VM_PROT_EXECUTE
case|:
name|pmap_clearbit
argument_list|(
name|m
argument_list|,
name|PVF_WRITE
argument_list|)
expr_stmt|;
break|break;
default|default:
name|pmap_remove_all
argument_list|(
name|m
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Remove all pages from specified address space  * this aids process exit speeds.  Also, this code  * is special cased for current process only, but  * can have the more generic (and slightly slower)  * mode enabled.  This is much faster than pmap_remove  * in the case of running down an entire address space.  */
end_comment

begin_function
name|void
name|pmap_remove_pages
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|sva
parameter_list|,
name|vm_offset_t
name|eva
parameter_list|)
block|{
name|struct
name|pv_entry
modifier|*
name|pv
decl_stmt|,
modifier|*
name|npv
decl_stmt|;
name|struct
name|l2_bucket
modifier|*
name|l2b
init|=
name|NULL
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|pt_entry_t
modifier|*
name|pt
decl_stmt|;
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
for|for
control|(
name|pv
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvlist
argument_list|)
init|;
name|pv
condition|;
name|pv
operator|=
name|npv
control|)
block|{
if|if
condition|(
name|pv
operator|->
name|pv_va
operator|>=
name|eva
operator|||
name|pv
operator|->
name|pv_va
operator|<
name|sva
condition|)
block|{
name|npv
operator|=
name|TAILQ_NEXT
argument_list|(
name|pv
argument_list|,
name|pv_plist
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|pv
operator|->
name|pv_flags
operator|&
name|PVF_WIRED
condition|)
block|{
comment|/* The page is wired, cannot remove it now. */
name|npv
operator|=
name|TAILQ_NEXT
argument_list|(
name|pv
argument_list|,
name|pv_plist
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|--
expr_stmt|;
name|l2b
operator|=
name|pmap_get_l2_bucket
argument_list|(
name|pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|l2b
operator|!=
name|NULL
argument_list|,
operator|(
literal|"No L2 bucket in pmap_remove_pages"
operator|)
argument_list|)
expr_stmt|;
name|pt
operator|=
operator|&
name|l2b
operator|->
name|l2b_kva
index|[
name|l2pte_index
argument_list|(
name|pv
operator|->
name|pv_va
argument_list|)
index|]
expr_stmt|;
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
operator|*
name|pt
operator|&
name|L2_ADDR_MASK
argument_list|)
expr_stmt|;
operator|*
name|pt
operator|=
literal|0
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|pt
argument_list|)
expr_stmt|;
name|npv
operator|=
name|TAILQ_NEXT
argument_list|(
name|pv
argument_list|,
name|pv_plist
argument_list|)
expr_stmt|;
name|pmap_nuke_pv
argument_list|(
name|m
argument_list|,
name|pmap
argument_list|,
name|pv
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|)
condition|)
name|vm_page_flag_clear
argument_list|(
name|m
argument_list|,
name|PG_WRITEABLE
argument_list|)
expr_stmt|;
name|pmap_free_pv_entry
argument_list|(
name|pv
argument_list|)
expr_stmt|;
block|}
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
name|cpu_idcache_wbinv_all
argument_list|()
expr_stmt|;
name|cpu_tlb_flushID
argument_list|()
expr_stmt|;
name|cpu_cpwait
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/***************************************************  * Low level mapping routines.....  ***************************************************/
end_comment

begin_comment
comment|/* Map a section into the KVA. */
end_comment

begin_function
name|void
name|pmap_kenter_section
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|vm_offset_t
name|pa
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|pd_entry_t
name|pd
init|=
name|L1_S_PROTO
operator||
name|pa
operator||
name|L1_S_PROT
argument_list|(
name|PTE_KERNEL
argument_list|,
name|VM_PROT_READ
operator||
name|VM_PROT_WRITE
argument_list|)
operator||
name|L1_S_DOM
argument_list|(
name|PMAP_DOMAIN_KERNEL
argument_list|)
decl_stmt|;
name|struct
name|l1_ttable
modifier|*
name|l1
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
operator|(
name|va
operator||
name|pa
operator|)
operator|&
name|L1_S_OFFSET
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"Not a valid section mapping"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_CACHE
condition|)
name|pd
operator||=
name|pte_l1_s_cache_mode
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|SECTION_PT
condition|)
name|pd
operator||=
name|pte_l1_s_cache_mode_pt
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|l1
argument_list|,
argument|&l1_list
argument_list|,
argument|l1_link
argument_list|)
block|{
name|l1
operator|->
name|l1_kva
index|[
name|L1_IDX
argument_list|(
name|va
argument_list|)
index|]
operator|=
name|pd
expr_stmt|;
name|PTE_SYNC
argument_list|(
operator|&
name|l1
operator|->
name|l1_kva
index|[
name|L1_IDX
argument_list|(
name|va
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * add a wired page to the kva  * note that in order for the mapping to take effect -- you  * should do a invltlb after doing the pmap_kenter...  */
end_comment

begin_function
specifier|static
name|PMAP_INLINE
name|void
name|pmap_kenter_internal
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|vm_offset_t
name|pa
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|l2_bucket
modifier|*
name|l2b
decl_stmt|;
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
name|pt_entry_t
name|opte
decl_stmt|;
name|PDEBUG
argument_list|(
literal|1
argument_list|,
name|printf
argument_list|(
literal|"pmap_kenter: va = %08x, pa = %08x\n"
argument_list|,
operator|(
name|uint32_t
operator|)
name|va
argument_list|,
operator|(
name|uint32_t
operator|)
name|pa
argument_list|)
argument_list|)
expr_stmt|;
name|l2b
operator|=
name|pmap_get_l2_bucket
argument_list|(
name|pmap_kernel
argument_list|()
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|l2b
operator|==
name|NULL
condition|)
name|l2b
operator|=
name|pmap_grow_l2_bucket
argument_list|(
name|pmap_kernel
argument_list|()
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|l2b
operator|!=
name|NULL
argument_list|,
operator|(
literal|"No L2 Bucket"
operator|)
argument_list|)
expr_stmt|;
name|pte
operator|=
operator|&
name|l2b
operator|->
name|l2b_kva
index|[
name|l2pte_index
argument_list|(
name|va
argument_list|)
index|]
expr_stmt|;
name|opte
operator|=
operator|*
name|pte
expr_stmt|;
name|PDEBUG
argument_list|(
literal|1
argument_list|,
name|printf
argument_list|(
literal|"pmap_kenter: pte = %08x, opte = %08x, npte = %08x\n"
argument_list|,
operator|(
name|uint32_t
operator|)
name|pte
argument_list|,
name|opte
argument_list|,
operator|*
name|pte
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|l2pte_valid
argument_list|(
name|opte
argument_list|)
condition|)
block|{
name|cpu_dcache_wbinv_range
argument_list|(
name|va
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|cpu_tlb_flushD_SE
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|cpu_cpwait
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|opte
operator|==
literal|0
condition|)
name|l2b
operator|->
name|l2b_occupancy
operator|++
expr_stmt|;
block|}
operator|*
name|pte
operator|=
name|L2_S_PROTO
operator||
name|pa
operator||
name|L2_S_PROT
argument_list|(
name|PTE_KERNEL
argument_list|,
name|VM_PROT_READ
operator||
name|VM_PROT_WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|KENTER_CACHE
condition|)
operator|*
name|pte
operator||=
name|pte_l2_s_cache_mode
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|KENTER_USER
condition|)
operator|*
name|pte
operator||=
name|L2_S_PROT_U
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|pte
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pmap_kenter
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|vm_paddr_t
name|pa
parameter_list|)
block|{
name|pmap_kenter_internal
argument_list|(
name|va
argument_list|,
name|pa
argument_list|,
name|KENTER_CACHE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pmap_kenter_nocache
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|vm_paddr_t
name|pa
parameter_list|)
block|{
name|pmap_kenter_internal
argument_list|(
name|va
argument_list|,
name|pa
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pmap_kenter_user
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|vm_paddr_t
name|pa
parameter_list|)
block|{
name|pmap_kenter_internal
argument_list|(
name|va
argument_list|,
name|pa
argument_list|,
name|KENTER_CACHE
operator||
name|KENTER_USER
argument_list|)
expr_stmt|;
comment|/* 	 * Call pmap_fault_fixup now, to make sure we'll have no exception 	 * at the first use of the new address, or bad things will happen, 	 * as we use one of these addresses in the exception handlers. 	 */
name|pmap_fault_fixup
argument_list|(
name|pmap_kernel
argument_list|()
argument_list|,
name|va
argument_list|,
name|VM_PROT_READ
operator||
name|VM_PROT_WRITE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * remove a page rom the kernel pagetables  */
end_comment

begin_function
name|PMAP_INLINE
name|void
name|pmap_kremove
parameter_list|(
name|vm_offset_t
name|va
parameter_list|)
block|{
name|struct
name|l2_bucket
modifier|*
name|l2b
decl_stmt|;
name|pt_entry_t
modifier|*
name|pte
decl_stmt|,
name|opte
decl_stmt|;
name|l2b
operator|=
name|pmap_get_l2_bucket
argument_list|(
name|pmap_kernel
argument_list|()
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|l2b
condition|)
return|return;
name|KASSERT
argument_list|(
name|l2b
operator|!=
name|NULL
argument_list|,
operator|(
literal|"No L2 Bucket"
operator|)
argument_list|)
expr_stmt|;
name|pte
operator|=
operator|&
name|l2b
operator|->
name|l2b_kva
index|[
name|l2pte_index
argument_list|(
name|va
argument_list|)
index|]
expr_stmt|;
name|opte
operator|=
operator|*
name|pte
expr_stmt|;
if|if
condition|(
name|l2pte_valid
argument_list|(
name|opte
argument_list|)
condition|)
block|{
name|cpu_dcache_wbinv_range
argument_list|(
name|va
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|cpu_tlb_flushD_SE
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|cpu_cpwait
argument_list|()
expr_stmt|;
operator|*
name|pte
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *	Used to map a range of physical addresses into kernel  *	virtual address space.  *  *	The value passed in '*virt' is a suggested virtual address for  *	the mapping. Architectures which can support a direct-mapped  *	physical to virtual region can return the appropriate address  *	within that region, leaving '*virt' unchanged. Other  *	architectures should map the pages starting at '*virt' and  *	update '*virt' with the first usable address after the mapped  *	region.  */
end_comment

begin_function
name|vm_offset_t
name|pmap_map
parameter_list|(
name|vm_offset_t
modifier|*
name|virt
parameter_list|,
name|vm_offset_t
name|start
parameter_list|,
name|vm_offset_t
name|end
parameter_list|,
name|int
name|prot
parameter_list|)
block|{
name|vm_offset_t
name|sva
init|=
operator|*
name|virt
decl_stmt|;
name|vm_offset_t
name|va
init|=
name|sva
decl_stmt|;
name|PDEBUG
argument_list|(
literal|1
argument_list|,
name|printf
argument_list|(
literal|"pmap_map: virt = %08x, start = %08x, end = %08x, "
literal|"prot = %d\n"
argument_list|,
operator|(
name|uint32_t
operator|)
operator|*
name|virt
argument_list|,
operator|(
name|uint32_t
operator|)
name|start
argument_list|,
operator|(
name|uint32_t
operator|)
name|end
argument_list|,
name|prot
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|start
operator|<
name|end
condition|)
block|{
name|pmap_kenter
argument_list|(
name|va
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|va
operator|+=
name|PAGE_SIZE
expr_stmt|;
name|start
operator|+=
name|PAGE_SIZE
expr_stmt|;
block|}
operator|*
name|virt
operator|=
name|va
expr_stmt|;
return|return
operator|(
name|sva
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pmap_wb_page
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|struct
name|pv_entry
modifier|*
name|pv
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&m->md.pv_list
argument_list|,
argument|pv_list
argument_list|)
name|pmap_dcache_wb_range
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|,
name|PAGE_SIZE
argument_list|,
name|FALSE
argument_list|,
operator|(
name|pv
operator|->
name|pv_flags
operator|&
name|PVF_WRITE
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pmap_inv_page
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|struct
name|pv_entry
modifier|*
name|pv
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&m->md.pv_list
argument_list|,
argument|pv_list
argument_list|)
name|pmap_dcache_wb_range
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|,
name|PAGE_SIZE
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add a list of wired pages to the kva  * this routine is only used for temporary  * kernel mappings that do not need to have  * page modification or references recorded.  * Note that old mappings are simply written  * over.  The page *must* be wired.  */
end_comment

begin_function
name|void
name|pmap_qenter
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
modifier|*
name|m
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|pmap_wb_page
argument_list|(
name|m
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|pmap_kenter_internal
argument_list|(
name|va
argument_list|,
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
index|[
name|i
index|]
argument_list|)
argument_list|,
name|KENTER_CACHE
argument_list|)
expr_stmt|;
name|va
operator|+=
name|PAGE_SIZE
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * this routine jerks page mappings from the  * kernel -- it is meant only for temporary mappings.  */
end_comment

begin_function
name|void
name|pmap_qremove
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|vm_paddr_t
name|pa
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|pa
operator|=
name|vtophys
argument_list|(
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|pa
condition|)
block|{
name|pmap_inv_page
argument_list|(
name|PHYS_TO_VM_PAGE
argument_list|(
name|pa
argument_list|)
argument_list|)
expr_stmt|;
name|pmap_kremove
argument_list|(
name|va
argument_list|)
expr_stmt|;
block|}
name|va
operator|+=
name|PAGE_SIZE
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * pmap_object_init_pt preloads the ptes for a given object  * into the specified pmap.  This eliminates the blast of soft  * faults on process startup and immediately after an mmap.  */
end_comment

begin_function
name|void
name|pmap_object_init_pt
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|addr
parameter_list|,
name|vm_object_t
name|object
parameter_list|,
name|vm_pindex_t
name|pindex
parameter_list|,
name|vm_size_t
name|size
parameter_list|)
block|{
name|printf
argument_list|(
literal|"pmap_object_init_pt()\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	pmap_is_prefaultable:  *  *	Return whether or not the specified virtual address is elgible  *	for prefault.  */
end_comment

begin_function
name|boolean_t
name|pmap_is_prefaultable
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|addr
parameter_list|)
block|{
name|pd_entry_t
modifier|*
name|pde
decl_stmt|;
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
if|if
condition|(
operator|!
name|pmap_get_pde_pte
argument_list|(
name|pmap
argument_list|,
name|addr
argument_list|,
operator|&
name|pde
argument_list|,
operator|&
name|pte
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
operator|*
name|pte
operator|==
literal|0
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Fetch pointers to the PDE/PTE for the given pmap/VA pair.  * Returns TRUE if the mapping exists, else FALSE.  *  * NOTE: This function is only used by a couple of arm-specific modules.  * It is not safe to take any pmap locks here, since we could be right  * in the middle of debugging the pmap anyway...  *  * It is possible for this routine to return FALSE even though a valid  * mapping does exist. This is because we don't lock, so the metadata  * state may be inconsistent.  *  * NOTE: We can return a NULL *ptp in the case where the L1 pde is  * a "section" mapping.  */
end_comment

begin_function
name|boolean_t
name|pmap_get_pde_pte
parameter_list|(
name|pmap_t
name|pm
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|pd_entry_t
modifier|*
modifier|*
name|pdp
parameter_list|,
name|pt_entry_t
modifier|*
modifier|*
name|ptp
parameter_list|)
block|{
name|struct
name|l2_dtable
modifier|*
name|l2
decl_stmt|;
name|pd_entry_t
modifier|*
name|pl1pd
decl_stmt|,
name|l1pd
decl_stmt|;
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|;
name|u_short
name|l1idx
decl_stmt|;
if|if
condition|(
name|pm
operator|->
name|pm_l1
operator|==
name|NULL
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|l1idx
operator|=
name|L1_IDX
argument_list|(
name|va
argument_list|)
expr_stmt|;
operator|*
name|pdp
operator|=
name|pl1pd
operator|=
operator|&
name|pm
operator|->
name|pm_l1
operator|->
name|l1_kva
index|[
name|l1idx
index|]
expr_stmt|;
name|l1pd
operator|=
operator|*
name|pl1pd
expr_stmt|;
if|if
condition|(
name|l1pte_section_p
argument_list|(
name|l1pd
argument_list|)
condition|)
block|{
operator|*
name|ptp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
if|if
condition|(
name|pm
operator|->
name|pm_l2
operator|==
name|NULL
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|l2
operator|=
name|pm
operator|->
name|pm_l2
index|[
name|L2_IDX
argument_list|(
name|l1idx
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|l2
operator|==
name|NULL
operator|||
operator|(
name|ptep
operator|=
name|l2
operator|->
name|l2_bucket
index|[
name|L2_BUCKET
argument_list|(
name|l1idx
argument_list|)
index|]
operator|.
name|l2b_kva
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
operator|*
name|ptp
operator|=
operator|&
name|ptep
index|[
name|l2pte_index
argument_list|(
name|va
argument_list|)
index|]
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *      Routine:        pmap_remove_all  *      Function:  *              Removes this physical page from  *              all physical maps in which it resides.  *              Reflects back modify bits to the pager.  *  *      Notes:  *              Original versions of this routine were very  *              inefficient because they iteratively called  *              pmap_remove (slow...)  */
end_comment

begin_function
name|void
name|pmap_remove_all
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|pv_entry_t
name|pv
decl_stmt|;
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|,
name|pte
decl_stmt|;
name|struct
name|l2_bucket
modifier|*
name|l2b
decl_stmt|;
name|boolean_t
name|flush
init|=
name|FALSE
decl_stmt|;
name|pmap_t
name|curpm
decl_stmt|;
name|int
name|flags
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|PMAP_DEBUG
argument_list|)
comment|/* 	 * XXX this makes pmap_page_protect(NONE) illegal for non-managed 	 * pages! 	 */
if|if
condition|(
name|m
operator|->
name|flags
operator|&
name|PG_FICTITIOUS
condition|)
block|{
name|panic
argument_list|(
literal|"pmap_page_protect: illegal for unmanaged page, va: 0x%x"
argument_list|,
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|)
condition|)
return|return;
name|curpm
operator|=
name|vmspace_pmap
argument_list|(
name|curproc
operator|->
name|p_vmspace
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|pv
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|flush
operator|==
name|FALSE
operator|&&
operator|(
name|pv
operator|->
name|pv_pmap
operator|==
name|curpm
operator|||
name|pv
operator|->
name|pv_pmap
operator|==
name|pmap_kernel
argument_list|()
operator|)
condition|)
name|flush
operator|=
name|TRUE
expr_stmt|;
name|l2b
operator|=
name|pmap_get_l2_bucket
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|l2b
operator|!=
name|NULL
argument_list|,
operator|(
literal|"No l2 bucket"
operator|)
argument_list|)
expr_stmt|;
name|ptep
operator|=
operator|&
name|l2b
operator|->
name|l2b_kva
index|[
name|l2pte_index
argument_list|(
name|pv
operator|->
name|pv_va
argument_list|)
index|]
expr_stmt|;
name|pte
operator|=
operator|*
name|ptep
expr_stmt|;
operator|*
name|ptep
operator|=
literal|0
expr_stmt|;
name|PTE_SYNC_CURRENT
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|,
name|ptep
argument_list|)
expr_stmt|;
name|pmap_free_l2_bucket
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|,
name|l2b
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pv
operator|->
name|pv_flags
operator|&
name|PVF_WIRED
condition|)
name|pv
operator|->
name|pv_pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|--
expr_stmt|;
name|pv
operator|->
name|pv_pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|--
expr_stmt|;
name|flags
operator||=
name|pv
operator|->
name|pv_flags
expr_stmt|;
name|pmap_nuke_pv
argument_list|(
name|m
argument_list|,
name|pv
operator|->
name|pv_pmap
argument_list|,
name|pv
argument_list|)
expr_stmt|;
name|pmap_free_pv_entry
argument_list|(
name|pv
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flush
condition|)
block|{
if|if
condition|(
name|PV_BEEN_EXECD
argument_list|(
name|flags
argument_list|)
condition|)
name|pmap_tlb_flushID
argument_list|(
name|curpm
argument_list|)
expr_stmt|;
else|else
name|pmap_tlb_flushD
argument_list|(
name|curpm
argument_list|)
expr_stmt|;
block|}
name|vm_page_flag_clear
argument_list|(
name|m
argument_list|,
name|PG_WRITEABLE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Set the physical protection on the  *	specified range of this map as requested.  */
end_comment

begin_function
name|void
name|pmap_protect
parameter_list|(
name|pmap_t
name|pm
parameter_list|,
name|vm_offset_t
name|sva
parameter_list|,
name|vm_offset_t
name|eva
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|)
block|{
name|struct
name|l2_bucket
modifier|*
name|l2b
decl_stmt|;
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|,
name|pte
decl_stmt|;
name|vm_offset_t
name|next_bucket
decl_stmt|;
name|u_int
name|flags
decl_stmt|;
name|int
name|flush
decl_stmt|;
if|if
condition|(
operator|(
name|prot
operator|&
name|VM_PROT_READ
operator|)
operator|==
literal|0
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|pmap_remove
argument_list|(
name|pm
argument_list|,
name|sva
argument_list|,
name|eva
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|prot
operator|&
name|VM_PROT_WRITE
condition|)
block|{
comment|/* 		 * If this is a read->write transition, just ignore it and let 		 * vm_fault() take care of it later. 		 */
return|return;
block|}
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
comment|/* 	 * OK, at this point, we know we're doing write-protect operation. 	 * If the pmap is active, write-back the range. 	 */
name|pmap_dcache_wb_range
argument_list|(
name|pm
argument_list|,
name|sva
argument_list|,
name|eva
operator|-
name|sva
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|flush
operator|=
operator|(
operator|(
name|eva
operator|-
name|sva
operator|)
operator|>=
operator|(
name|PAGE_SIZE
operator|*
literal|4
operator|)
operator|)
condition|?
literal|0
else|:
operator|-
literal|1
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
while|while
condition|(
name|sva
operator|<
name|eva
condition|)
block|{
name|next_bucket
operator|=
name|L2_NEXT_BUCKET
argument_list|(
name|sva
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_bucket
operator|>
name|eva
condition|)
name|next_bucket
operator|=
name|eva
expr_stmt|;
name|l2b
operator|=
name|pmap_get_l2_bucket
argument_list|(
name|pm
argument_list|,
name|sva
argument_list|)
expr_stmt|;
if|if
condition|(
name|l2b
operator|==
name|NULL
condition|)
block|{
name|sva
operator|=
name|next_bucket
expr_stmt|;
continue|continue;
block|}
name|ptep
operator|=
operator|&
name|l2b
operator|->
name|l2b_kva
index|[
name|l2pte_index
argument_list|(
name|sva
argument_list|)
index|]
expr_stmt|;
while|while
condition|(
name|sva
operator|<
name|next_bucket
condition|)
block|{
if|if
condition|(
operator|(
name|pte
operator|=
operator|*
name|ptep
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|pte
operator|&
name|L2_S_PROT_W
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|vm_page
modifier|*
name|pg
decl_stmt|;
name|u_int
name|f
decl_stmt|;
name|pg
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|l2pte_pa
argument_list|(
name|pte
argument_list|)
argument_list|)
expr_stmt|;
name|pte
operator|&=
operator|~
name|L2_S_PROT_W
expr_stmt|;
operator|*
name|ptep
operator|=
name|pte
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|ptep
argument_list|)
expr_stmt|;
if|if
condition|(
name|pg
operator|!=
name|NULL
condition|)
block|{
name|f
operator|=
name|pmap_modify_pv
argument_list|(
name|pg
argument_list|,
name|pm
argument_list|,
name|sva
argument_list|,
name|PVF_WRITE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pmap_vac_me_harder
argument_list|(
name|pg
argument_list|,
name|pm
argument_list|,
name|sva
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap_track_modified
argument_list|(
name|sva
argument_list|)
condition|)
name|vm_page_dirty
argument_list|(
name|pg
argument_list|)
expr_stmt|;
block|}
else|else
name|f
operator|=
name|PVF_REF
operator||
name|PVF_EXEC
expr_stmt|;
if|if
condition|(
name|flush
operator|>=
literal|0
condition|)
block|{
name|flush
operator|++
expr_stmt|;
name|flags
operator||=
name|f
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|PV_BEEN_EXECD
argument_list|(
name|f
argument_list|)
condition|)
name|pmap_tlb_flushID_SE
argument_list|(
name|pm
argument_list|,
name|sva
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|PV_BEEN_REFD
argument_list|(
name|f
argument_list|)
condition|)
name|pmap_tlb_flushD_SE
argument_list|(
name|pm
argument_list|,
name|sva
argument_list|)
expr_stmt|;
block|}
name|sva
operator|+=
name|PAGE_SIZE
expr_stmt|;
name|ptep
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|flush
condition|)
block|{
if|if
condition|(
name|PV_BEEN_EXECD
argument_list|(
name|flags
argument_list|)
condition|)
name|pmap_tlb_flushID
argument_list|(
name|pm
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|PV_BEEN_REFD
argument_list|(
name|flags
argument_list|)
condition|)
name|pmap_tlb_flushD
argument_list|(
name|pm
argument_list|)
expr_stmt|;
block|}
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Insert the given physical page (p) at  *	the specified virtual address (v) in the  *	target physical map with the protection requested.  *  *	If specified, the page will be wired down, meaning  *	that the related pte can not be reclaimed.  *  *	NB:  This is the only routine which MAY NOT lazy-evaluate  *	or lose information.  That is, this routine must actually  *	insert this page into the given map NOW.  */
end_comment

begin_function
name|void
name|pmap_enter
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|m
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|,
name|boolean_t
name|wired
parameter_list|)
block|{
name|struct
name|l2_bucket
modifier|*
name|l2b
init|=
name|NULL
decl_stmt|;
name|struct
name|vm_page
modifier|*
name|opg
decl_stmt|;
name|struct
name|pv_entry
modifier|*
name|pve
init|=
name|NULL
decl_stmt|;
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|,
name|npte
decl_stmt|,
name|opte
decl_stmt|;
name|u_int
name|nflags
decl_stmt|;
name|u_int
name|oflags
decl_stmt|;
name|vm_paddr_t
name|pa
decl_stmt|;
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
if|if
condition|(
name|va
operator|==
name|vector_page
condition|)
block|{
name|pa
operator|=
name|systempage
operator|.
name|pv_pa
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|pa
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|nflags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|prot
operator|&
name|VM_PROT_WRITE
condition|)
name|nflags
operator||=
name|PVF_WRITE
expr_stmt|;
if|if
condition|(
name|prot
operator|&
name|VM_PROT_EXECUTE
condition|)
name|nflags
operator||=
name|PVF_EXEC
expr_stmt|;
if|if
condition|(
name|wired
condition|)
name|nflags
operator||=
name|PVF_WIRED
expr_stmt|;
name|PDEBUG
argument_list|(
literal|1
argument_list|,
name|printf
argument_list|(
literal|"pmap_enter: pmap = %08x, va = %08x, m = %08x, prot = %x, "
literal|"wired = %x\n"
argument_list|,
operator|(
name|uint32_t
operator|)
name|pmap
argument_list|,
name|va
argument_list|,
operator|(
name|uint32_t
operator|)
name|m
argument_list|,
name|prot
argument_list|,
name|wired
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap
operator|==
name|pmap_kernel
argument_list|()
condition|)
block|{
name|l2b
operator|=
name|pmap_get_l2_bucket
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|l2b
operator|==
name|NULL
condition|)
name|l2b
operator|=
name|pmap_grow_l2_bucket
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
block|}
else|else
name|l2b
operator|=
name|pmap_alloc_l2_bucket
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|l2b
operator|!=
name|NULL
argument_list|,
operator|(
literal|"pmap_enter: failed to allocate l2 bucket"
operator|)
argument_list|)
expr_stmt|;
name|ptep
operator|=
operator|&
name|l2b
operator|->
name|l2b_kva
index|[
name|l2pte_index
argument_list|(
name|va
argument_list|)
index|]
expr_stmt|;
name|opte
operator|=
operator|*
name|ptep
expr_stmt|;
name|npte
operator|=
name|pa
expr_stmt|;
name|oflags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|opte
condition|)
block|{
comment|/* 		 * There is already a mapping at this address. 		 * If the physical address is different, lookup the 		 * vm_page. 		 */
if|if
condition|(
name|l2pte_pa
argument_list|(
name|opte
argument_list|)
operator|!=
name|pa
condition|)
name|opg
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|l2pte_pa
argument_list|(
name|opte
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|opg
operator|=
name|m
expr_stmt|;
block|}
else|else
name|opg
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|prot
operator|&
operator|(
name|VM_PROT_ALL
operator|)
operator|)
operator|||
operator|(
operator|!
name|m
operator|||
name|m
operator|->
name|md
operator|.
name|pvh_attrs
operator|&
name|PVF_REF
operator|)
condition|)
block|{
comment|/* 		 * - The access type indicates that we don't need 		 *   to do referenced emulation. 		 * OR 		 * - The physical page has already been referenced 		 *   so no need to re-do referenced emulation here. 		 */
name|npte
operator||=
name|L2_S_PROTO
expr_stmt|;
name|nflags
operator||=
name|PVF_REF
expr_stmt|;
if|if
condition|(
name|m
operator|&&
operator|(
operator|(
name|prot
operator|&
name|VM_PROT_WRITE
operator|)
operator|!=
literal|0
operator|||
operator|(
name|m
operator|->
name|md
operator|.
name|pvh_attrs
operator|&
name|PVF_MOD
operator|)
operator|)
condition|)
block|{
comment|/* 			 * This is a writable mapping, and the 			 * page's mod state indicates it has 			 * already been modified. Make it 			 * writable from the outset. 			 */
name|nflags
operator||=
name|PVF_MOD
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|m
operator|->
name|md
operator|.
name|pvh_attrs
operator|&
name|PVF_MOD
operator|)
operator|&&
name|pmap_track_modified
argument_list|(
name|va
argument_list|)
condition|)
name|vm_page_dirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|&&
name|opte
condition|)
name|vm_page_flag_set
argument_list|(
name|m
argument_list|,
name|PG_REFERENCED
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Need to do page referenced emulation. 		 */
name|npte
operator||=
name|L2_TYPE_INV
expr_stmt|;
block|}
if|if
condition|(
name|prot
operator|&
name|VM_PROT_WRITE
condition|)
name|npte
operator||=
name|L2_S_PROT_W
expr_stmt|;
name|npte
operator||=
name|pte_l2_s_cache_mode
expr_stmt|;
if|if
condition|(
name|m
operator|&&
name|m
operator|==
name|opg
condition|)
block|{
comment|/* 		 * We're changing the attrs of an existing mapping. 		 */
if|#
directive|if
literal|0
block|simple_lock(&pg->mdpage.pvh_slock);
endif|#
directive|endif
name|oflags
operator|=
name|pmap_modify_pv
argument_list|(
name|m
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|,
name|PVF_WRITE
operator||
name|PVF_EXEC
operator||
name|PVF_WIRED
operator||
name|PVF_MOD
operator||
name|PVF_REF
argument_list|,
name|nflags
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|simple_unlock(&pg->mdpage.pvh_slock);
endif|#
directive|endif
comment|/* 		 * We may need to flush the cache if we're 		 * doing rw-ro... 		 */
if|if
condition|(
name|pmap_is_current
argument_list|(
name|pmap
argument_list|)
operator|&&
operator|(
name|oflags
operator|&
name|PVF_NC
operator|)
operator|==
literal|0
operator|&&
operator|(
name|opte
operator|&
name|L2_S_PROT_W
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|prot
operator|&
name|VM_PROT_WRITE
operator|)
operator|==
literal|0
condition|)
name|cpu_dcache_wb_range
argument_list|(
name|va
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * New mapping, or changing the backing page 		 * of an existing mapping. 		 */
if|if
condition|(
name|opg
condition|)
block|{
comment|/* 			 * Replacing an existing mapping with a new one. 			 * It is part of our managed memory so we 			 * must remove it from the PV list 			 */
if|#
directive|if
literal|0
block|simple_lock(&opg->mdpage.pvh_slock);
endif|#
directive|endif
name|pve
operator|=
name|pmap_remove_pv
argument_list|(
name|opg
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|&&
operator|(
name|m
operator|->
name|flags
operator|&
operator|(
name|PG_UNMANAGED
operator||
name|PG_FICTITIOUS
operator|)
operator|)
operator|&&
name|pve
condition|)
name|pmap_free_pv_entry
argument_list|(
name|pve
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|pve
condition|)
name|pve
operator|=
name|pmap_get_pv_entry
argument_list|()
expr_stmt|;
name|KASSERT
argument_list|(
name|pve
operator|!=
name|NULL
argument_list|,
operator|(
literal|"No pv"
operator|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|simple_unlock(&opg->mdpage.pvh_slock);
endif|#
directive|endif
name|oflags
operator|=
name|pve
operator|->
name|pv_flags
expr_stmt|;
comment|/* 			 * If the old mapping was valid (ref/mod 			 * emulation creates 'invalid' mappings 			 * initially) then make sure to frob 			 * the cache. 			 */
if|if
condition|(
operator|(
name|oflags
operator|&
name|PVF_NC
operator|)
operator|==
literal|0
operator|&&
name|l2pte_valid
argument_list|(
name|opte
argument_list|)
condition|)
block|{
if|if
condition|(
name|PV_BEEN_EXECD
argument_list|(
name|oflags
argument_list|)
condition|)
block|{
name|pmap_idcache_wbinv_range
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|PV_BEEN_REFD
argument_list|(
name|oflags
argument_list|)
condition|)
block|{
name|pmap_dcache_wb_range
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|PAGE_SIZE
argument_list|,
name|TRUE
argument_list|,
operator|(
name|oflags
operator|&
name|PVF_WRITE
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|m
operator|&&
operator|!
operator|(
name|m
operator|->
name|flags
operator|&
operator|(
name|PG_UNMANAGED
operator||
name|PG_FICTITIOUS
operator|)
operator|)
condition|)
if|if
condition|(
operator|(
name|pve
operator|=
name|pmap_get_pv_entry
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"pmap_enter: no pv entries"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|&&
operator|!
operator|(
name|m
operator|->
name|flags
operator|&
operator|(
name|PG_UNMANAGED
operator||
name|PG_FICTITIOUS
operator|)
operator|)
condition|)
name|pmap_enter_pv
argument_list|(
name|m
argument_list|,
name|pve
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|,
name|nflags
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Make sure userland mappings get the right permissions 	 */
if|if
condition|(
name|pmap
operator|!=
name|pmap_kernel
argument_list|()
operator|&&
name|va
operator|!=
name|vector_page
condition|)
block|{
name|npte
operator||=
name|L2_S_PROT_U
expr_stmt|;
block|}
comment|/* 	 * Keep the stats up to date 	 */
if|if
condition|(
name|opte
operator|==
literal|0
condition|)
block|{
name|l2b
operator|->
name|l2b_occupancy
operator|++
expr_stmt|;
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|++
expr_stmt|;
block|}
comment|/* 	 * If this is just a wiring change, the two PTEs will be 	 * identical, so there's no need to update the page table. 	 */
if|if
condition|(
name|npte
operator|!=
name|opte
condition|)
block|{
name|boolean_t
name|is_cached
init|=
name|pmap_is_current
argument_list|(
name|pmap
argument_list|)
decl_stmt|;
operator|*
name|ptep
operator|=
name|npte
expr_stmt|;
if|if
condition|(
name|is_cached
condition|)
block|{
comment|/* 			 * We only need to frob the cache/tlb if this pmap 			 * is current 			 */
name|PTE_SYNC
argument_list|(
name|ptep
argument_list|)
expr_stmt|;
if|if
condition|(
name|L1_IDX
argument_list|(
name|va
argument_list|)
operator|!=
name|L1_IDX
argument_list|(
name|vector_page
argument_list|)
operator|&&
name|l2pte_valid
argument_list|(
name|npte
argument_list|)
condition|)
block|{
comment|/* 				 * This mapping is likely to be accessed as 				 * soon as we return to userland. Fix up the 				 * L1 entry to avoid taking another 				 * page/domain fault. 				 */
name|pd_entry_t
modifier|*
name|pl1pd
decl_stmt|,
name|l1pd
decl_stmt|;
name|pl1pd
operator|=
operator|&
name|pmap
operator|->
name|pm_l1
operator|->
name|l1_kva
index|[
name|L1_IDX
argument_list|(
name|va
argument_list|)
index|]
expr_stmt|;
name|l1pd
operator|=
name|l2b
operator|->
name|l2b_phys
operator||
name|L1_C_DOM
argument_list|(
name|pmap
operator|->
name|pm_domain
argument_list|)
operator||
name|L1_C_PROTO
expr_stmt|;
if|if
condition|(
operator|*
name|pl1pd
operator|!=
name|l1pd
condition|)
block|{
operator|*
name|pl1pd
operator|=
name|l1pd
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|pl1pd
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|PV_BEEN_EXECD
argument_list|(
name|oflags
argument_list|)
condition|)
name|pmap_tlb_flushID_SE
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|PV_BEEN_REFD
argument_list|(
name|oflags
argument_list|)
condition|)
name|pmap_tlb_flushD_SE
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
name|pmap_vac_me_harder
argument_list|(
name|m
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
block|}
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * this code makes some *MAJOR* assumptions:  * 1. Current pmap& pmap exists.  * 2. Not wired.  * 3. Read access.  * 4. No page table pages.  * but is *MUCH* faster than pmap_enter...  */
end_comment

begin_function
name|vm_page_t
name|pmap_enter_quick
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|m
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|,
name|vm_page_t
name|mpte
parameter_list|)
block|{
name|vm_page_busy
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
name|VM_OBJECT_UNLOCK
argument_list|(
name|m
operator|->
name|object
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|pmap_enter
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|m
argument_list|,
name|prot
operator|&
operator|(
name|VM_PROT_READ
operator||
name|VM_PROT_EXECUTE
operator|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|VM_OBJECT_LOCK
argument_list|(
name|m
operator|->
name|object
argument_list|)
expr_stmt|;
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
name|vm_page_wakeup
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	Routine:	pmap_change_wiring  *	Function:	Change the wiring attribute for a map/virtual-address  *			pair.  *	In/out conditions:  *			The mapping must already exist in the pmap.  */
end_comment

begin_function
name|void
name|pmap_change_wiring
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|boolean_t
name|wired
parameter_list|)
block|{
name|struct
name|l2_bucket
modifier|*
name|l2b
decl_stmt|;
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|,
name|pte
decl_stmt|;
name|vm_page_t
name|pg
decl_stmt|;
name|l2b
operator|=
name|pmap_get_l2_bucket
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|l2b
argument_list|,
operator|(
literal|"No l2b bucket in pmap_change_wiring"
operator|)
argument_list|)
expr_stmt|;
name|ptep
operator|=
operator|&
name|l2b
operator|->
name|l2b_kva
index|[
name|l2pte_index
argument_list|(
name|va
argument_list|)
index|]
expr_stmt|;
name|pte
operator|=
operator|*
name|ptep
expr_stmt|;
name|pg
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|l2pte_pa
argument_list|(
name|pte
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pg
condition|)
name|pmap_modify_pv
argument_list|(
name|pg
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|,
name|PVF_WIRED
argument_list|,
name|wired
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Copy the range specified by src_addr/len  *	from the source map to the range dst_addr/len  *	in the destination map.  *  *	This routine is only advisory and need not do anything.  */
end_comment

begin_function
name|void
name|pmap_copy
parameter_list|(
name|pmap_t
name|dst_pmap
parameter_list|,
name|pmap_t
name|src_pmap
parameter_list|,
name|vm_offset_t
name|dst_addr
parameter_list|,
name|vm_size_t
name|len
parameter_list|,
name|vm_offset_t
name|src_addr
parameter_list|)
block|{ }
end_function

begin_comment
comment|/*  *	Routine:	pmap_extract  *	Function:  *		Extract the physical page address associated  *		with the given map/virtual_address pair.  */
end_comment

begin_function
name|vm_paddr_t
name|pmap_extract
parameter_list|(
name|pmap_t
name|pm
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|struct
name|l2_dtable
modifier|*
name|l2
decl_stmt|;
name|pd_entry_t
modifier|*
name|pl1pd
decl_stmt|,
name|l1pd
decl_stmt|;
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|,
name|pte
decl_stmt|;
name|vm_paddr_t
name|pa
decl_stmt|;
name|u_int
name|l1idx
decl_stmt|;
name|l1idx
operator|=
name|L1_IDX
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|pl1pd
operator|=
operator|&
name|pm
operator|->
name|pm_l1
operator|->
name|l1_kva
index|[
name|l1idx
index|]
expr_stmt|;
name|l1pd
operator|=
operator|*
name|pl1pd
expr_stmt|;
if|if
condition|(
name|l1pte_section_p
argument_list|(
name|l1pd
argument_list|)
condition|)
block|{
comment|/* 		 * These should only happen for pmap_kernel() 		 */
name|KASSERT
argument_list|(
name|pm
operator|==
name|pmap_kernel
argument_list|()
argument_list|,
operator|(
literal|"huh"
operator|)
argument_list|)
expr_stmt|;
name|pa
operator|=
operator|(
name|l1pd
operator|&
name|L1_S_FRAME
operator|)
operator||
operator|(
name|va
operator|&
name|L1_S_OFFSET
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Note that we can't rely on the validity of the L1 		 * descriptor as an indication that a mapping exists. 		 * We have to look it up in the L2 dtable. 		 */
name|l2
operator|=
name|pm
operator|->
name|pm_l2
index|[
name|L2_IDX
argument_list|(
name|l1idx
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|l2
operator|==
name|NULL
operator|||
operator|(
name|ptep
operator|=
name|l2
operator|->
name|l2_bucket
index|[
name|L2_BUCKET
argument_list|(
name|l1idx
argument_list|)
index|]
operator|.
name|l2b_kva
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ptep
operator|=
operator|&
name|ptep
index|[
name|l2pte_index
argument_list|(
name|va
argument_list|)
index|]
expr_stmt|;
name|pte
operator|=
operator|*
name|ptep
expr_stmt|;
if|if
condition|(
name|pte
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
switch|switch
condition|(
name|pte
operator|&
name|L2_TYPE_MASK
condition|)
block|{
case|case
name|L2_TYPE_L
case|:
name|pa
operator|=
operator|(
name|pte
operator|&
name|L2_L_FRAME
operator|)
operator||
operator|(
name|va
operator|&
name|L2_L_OFFSET
operator|)
expr_stmt|;
break|break;
default|default:
name|pa
operator|=
operator|(
name|pte
operator|&
name|L2_S_FRAME
operator|)
operator||
operator|(
name|va
operator|&
name|L2_S_OFFSET
operator|)
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|pa
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Atomically extract and hold the physical page with the given  * pmap and virtual address pair if that mapping permits the given  * protection.  *  */
end_comment

begin_function
name|vm_page_t
name|pmap_extract_and_hold
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|)
block|{
name|struct
name|l2_dtable
modifier|*
name|l2
decl_stmt|;
name|pd_entry_t
modifier|*
name|pl1pd
decl_stmt|,
name|l1pd
decl_stmt|;
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|,
name|pte
decl_stmt|;
name|vm_paddr_t
name|pa
decl_stmt|;
name|vm_page_t
name|m
init|=
name|NULL
decl_stmt|;
name|u_int
name|l1idx
decl_stmt|;
name|l1idx
operator|=
name|L1_IDX
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|pl1pd
operator|=
operator|&
name|pmap
operator|->
name|pm_l1
operator|->
name|l1_kva
index|[
name|l1idx
index|]
expr_stmt|;
name|l1pd
operator|=
operator|*
name|pl1pd
expr_stmt|;
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
if|if
condition|(
name|l1pte_section_p
argument_list|(
name|l1pd
argument_list|)
condition|)
block|{
comment|/* 		 * These should only happen for pmap_kernel() 		 */
name|KASSERT
argument_list|(
name|pmap
operator|==
name|pmap_kernel
argument_list|()
argument_list|,
operator|(
literal|"huh"
operator|)
argument_list|)
expr_stmt|;
name|pa
operator|=
operator|(
name|l1pd
operator|&
name|L1_S_FRAME
operator|)
operator||
operator|(
name|va
operator|&
name|L1_S_OFFSET
operator|)
expr_stmt|;
if|if
condition|(
name|l1pd
operator|&
name|L1_S_PROT_W
operator|||
operator|(
name|prot
operator|&
name|VM_PROT_WRITE
operator|)
operator|==
literal|0
condition|)
block|{
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|vm_page_hold
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * Note that we can't rely on the validity of the L1 		 * descriptor as an indication that a mapping exists. 		 * We have to look it up in the L2 dtable. 		 */
name|l2
operator|=
name|pmap
operator|->
name|pm_l2
index|[
name|L2_IDX
argument_list|(
name|l1idx
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|l2
operator|==
name|NULL
operator|||
operator|(
name|ptep
operator|=
name|l2
operator|->
name|l2_bucket
index|[
name|L2_BUCKET
argument_list|(
name|l1idx
argument_list|)
index|]
operator|.
name|l2b_kva
operator|)
operator|==
name|NULL
condition|)
block|{
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|ptep
operator|=
operator|&
name|ptep
index|[
name|l2pte_index
argument_list|(
name|va
argument_list|)
index|]
expr_stmt|;
name|pte
operator|=
operator|*
name|ptep
expr_stmt|;
if|if
condition|(
name|pte
operator|==
literal|0
condition|)
block|{
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|pte
operator|&
name|L2_S_PROT_W
operator|||
operator|(
name|prot
operator|&
name|VM_PROT_WRITE
operator|)
operator|==
literal|0
condition|)
block|{
switch|switch
condition|(
name|pte
operator|&
name|L2_TYPE_MASK
condition|)
block|{
case|case
name|L2_TYPE_L
case|:
name|pa
operator|=
operator|(
name|pte
operator|&
name|L2_L_FRAME
operator|)
operator||
operator|(
name|va
operator|&
name|L2_L_OFFSET
operator|)
expr_stmt|;
break|break;
default|default:
name|pa
operator|=
operator|(
name|pte
operator|&
name|L2_S_FRAME
operator|)
operator||
operator|(
name|va
operator|&
name|L2_S_OFFSET
operator|)
expr_stmt|;
break|break;
block|}
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|vm_page_hold
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize a preallocated and zeroed pmap structure,  * such as one in a vmspace structure.  */
end_comment

begin_function
name|void
name|pmap_pinit
parameter_list|(
name|pmap_t
name|pmap
parameter_list|)
block|{
name|PDEBUG
argument_list|(
literal|1
argument_list|,
name|printf
argument_list|(
literal|"pmap_pinit: pmap = %08x\n"
argument_list|,
operator|(
name|uint32_t
operator|)
name|pmap
argument_list|)
argument_list|)
expr_stmt|;
name|pmap_alloc_l1
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|pmap
operator|->
name|pm_l2
argument_list|,
sizeof|sizeof
argument_list|(
name|pmap
operator|->
name|pm_l2
argument_list|)
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|allpmaps
argument_list|,
name|pmap
argument_list|,
name|pm_list
argument_list|)
expr_stmt|;
name|pmap
operator|->
name|pm_count
operator|=
literal|1
expr_stmt|;
name|pmap
operator|->
name|pm_active
operator|=
literal|0
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvlist
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|pmap
operator|->
name|pm_stats
argument_list|,
sizeof|sizeof
name|pmap
operator|->
name|pm_stats
argument_list|)
expr_stmt|;
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|vector_page
operator|<
name|KERNBASE
condition|)
block|{
name|pmap_enter
argument_list|(
name|pmap
argument_list|,
name|vector_page
argument_list|,
name|PHYS_TO_VM_PAGE
argument_list|(
name|systempage
operator|.
name|pv_pa
argument_list|)
argument_list|,
name|VM_PROT_READ
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/***************************************************  * page management routines.  ***************************************************/
end_comment

begin_function
specifier|static
name|void
name|pmap_free_pv_entry
parameter_list|(
name|pv_entry_t
name|pv
parameter_list|)
block|{
name|pv_entry_count
operator|--
expr_stmt|;
name|uma_zfree
argument_list|(
name|pvzone
argument_list|,
name|pv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * get a new pv_entry, allocating a block from the system  * when needed.  * the memory allocation is performed bypassing the malloc code  * because of the possibility of allocations at interrupt time.  */
end_comment

begin_function
specifier|static
name|pv_entry_t
name|pmap_get_pv_entry
parameter_list|(
name|void
parameter_list|)
block|{
name|pv_entry_t
name|ret_value
decl_stmt|;
name|pv_entry_count
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|pv_entry_count
operator|>
name|pv_entry_high_water
operator|)
operator|&&
operator|(
name|pmap_pagedaemon_waken
operator|==
literal|0
operator|)
condition|)
block|{
name|pmap_pagedaemon_waken
operator|=
literal|1
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|vm_pages_needed
argument_list|)
expr_stmt|;
block|}
name|ret_value
operator|=
name|uma_zalloc
argument_list|(
name|pvzone
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
return|return
name|ret_value
return|;
block|}
end_function

begin_comment
comment|/*  *	Remove the given range of addresses from the specified map.  *  *	It is assumed that the start and end are properly  *	rounded to the page size.  */
end_comment

begin_define
define|#
directive|define
name|PMAP_REMOVE_CLEAN_LIST_SIZE
value|3
end_define

begin_function
name|void
name|pmap_remove
parameter_list|(
name|pmap_t
name|pm
parameter_list|,
name|vm_offset_t
name|sva
parameter_list|,
name|vm_offset_t
name|eva
parameter_list|)
block|{
name|struct
name|l2_bucket
modifier|*
name|l2b
decl_stmt|;
name|vm_offset_t
name|next_bucket
decl_stmt|;
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|;
name|u_int
name|cleanlist_idx
decl_stmt|,
name|total
decl_stmt|,
name|cnt
decl_stmt|;
struct|struct
block|{
name|vm_offset_t
name|va
decl_stmt|;
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
block|}
name|cleanlist
index|[
name|PMAP_REMOVE_CLEAN_LIST_SIZE
index|]
struct|;
name|u_int
name|mappings
decl_stmt|,
name|is_exec
decl_stmt|,
name|is_refd
decl_stmt|;
name|int
name|flushall
init|=
literal|0
decl_stmt|;
comment|/* 	 * we lock in the pmap => pv_head direction 	 */
if|#
directive|if
literal|0
block|PMAP_MAP_TO_HEAD_LOCK(); 	pmap_acquire_pmap_lock(pm);
endif|#
directive|endif
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|pmap_is_current
argument_list|(
name|pm
argument_list|)
condition|)
block|{
name|cleanlist_idx
operator|=
name|PMAP_REMOVE_CLEAN_LIST_SIZE
operator|+
literal|1
expr_stmt|;
block|}
else|else
name|cleanlist_idx
operator|=
literal|0
expr_stmt|;
name|total
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|sva
operator|<
name|eva
condition|)
block|{
comment|/* 		 * Do one L2 bucket's worth at a time. 		 */
name|next_bucket
operator|=
name|L2_NEXT_BUCKET
argument_list|(
name|sva
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_bucket
operator|>
name|eva
condition|)
name|next_bucket
operator|=
name|eva
expr_stmt|;
name|l2b
operator|=
name|pmap_get_l2_bucket
argument_list|(
name|pm
argument_list|,
name|sva
argument_list|)
expr_stmt|;
if|if
condition|(
name|l2b
operator|==
name|NULL
condition|)
block|{
name|sva
operator|=
name|next_bucket
expr_stmt|;
continue|continue;
block|}
name|ptep
operator|=
operator|&
name|l2b
operator|->
name|l2b_kva
index|[
name|l2pte_index
argument_list|(
name|sva
argument_list|)
index|]
expr_stmt|;
name|mappings
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|sva
operator|<
name|next_bucket
condition|)
block|{
name|struct
name|vm_page
modifier|*
name|pg
decl_stmt|;
name|pt_entry_t
name|pte
decl_stmt|;
name|vm_paddr_t
name|pa
decl_stmt|;
name|pte
operator|=
operator|*
name|ptep
expr_stmt|;
if|if
condition|(
name|pte
operator|==
literal|0
condition|)
block|{
comment|/* 				 * Nothing here, move along 				 */
name|sva
operator|+=
name|PAGE_SIZE
expr_stmt|;
name|ptep
operator|++
expr_stmt|;
continue|continue;
block|}
name|pm
operator|->
name|pm_stats
operator|.
name|resident_count
operator|--
expr_stmt|;
name|pa
operator|=
name|l2pte_pa
argument_list|(
name|pte
argument_list|)
expr_stmt|;
name|is_exec
operator|=
literal|0
expr_stmt|;
name|is_refd
operator|=
literal|1
expr_stmt|;
comment|/* 			 * Update flags. In a number of circumstances, 			 * we could cluster a lot of these and do a 			 * number of sequential pages in one go. 			 */
if|if
condition|(
operator|(
name|pg
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pa
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|struct
name|pv_entry
modifier|*
name|pve
decl_stmt|;
if|#
directive|if
literal|0
block|simple_lock(&pg->mdpage.pvh_slock);
endif|#
directive|endif
name|pve
operator|=
name|pmap_remove_pv
argument_list|(
name|pg
argument_list|,
name|pm
argument_list|,
name|sva
argument_list|)
expr_stmt|;
if|if
condition|(
name|pve
condition|)
block|{
if|#
directive|if
literal|0
block|simple_unlock(&pg->mdpage.pvh_slock);
endif|#
directive|endif
name|is_exec
operator|=
name|PV_BEEN_EXECD
argument_list|(
name|pve
operator|->
name|pv_flags
argument_list|)
expr_stmt|;
name|is_refd
operator|=
name|PV_BEEN_REFD
argument_list|(
name|pve
operator|->
name|pv_flags
argument_list|)
expr_stmt|;
name|pmap_free_pv_entry
argument_list|(
name|pve
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|l2pte_valid
argument_list|(
name|pte
argument_list|)
condition|)
block|{
operator|*
name|ptep
operator|=
literal|0
expr_stmt|;
name|PTE_SYNC_CURRENT
argument_list|(
name|pm
argument_list|,
name|ptep
argument_list|)
expr_stmt|;
name|sva
operator|+=
name|PAGE_SIZE
expr_stmt|;
name|ptep
operator|++
expr_stmt|;
name|mappings
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|cleanlist_idx
operator|<
name|PMAP_REMOVE_CLEAN_LIST_SIZE
condition|)
block|{
comment|/* Add to the clean list. */
name|cleanlist
index|[
name|cleanlist_idx
index|]
operator|.
name|pte
operator|=
name|ptep
expr_stmt|;
name|cleanlist
index|[
name|cleanlist_idx
index|]
operator|.
name|va
operator|=
name|sva
operator||
operator|(
name|is_exec
operator|&
literal|1
operator|)
expr_stmt|;
name|cleanlist_idx
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cleanlist_idx
operator|==
name|PMAP_REMOVE_CLEAN_LIST_SIZE
condition|)
block|{
comment|/* Nuke everything if needed. */
name|pmap_idcache_wbinv_all
argument_list|(
name|pm
argument_list|)
expr_stmt|;
name|pmap_tlb_flushID
argument_list|(
name|pm
argument_list|)
expr_stmt|;
comment|/* 				 * Roll back the previous PTE list, 				 * and zero out the current PTE. 				 */
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|PMAP_REMOVE_CLEAN_LIST_SIZE
condition|;
name|cnt
operator|++
control|)
block|{
operator|*
name|cleanlist
index|[
name|cnt
index|]
operator|.
name|pte
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|ptep
operator|=
literal|0
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|ptep
argument_list|)
expr_stmt|;
name|cleanlist_idx
operator|++
expr_stmt|;
name|flushall
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
operator|*
name|ptep
operator|=
literal|0
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|ptep
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_exec
condition|)
name|pmap_tlb_flushID_SE
argument_list|(
name|pm
argument_list|,
name|sva
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|is_refd
condition|)
name|pmap_tlb_flushD_SE
argument_list|(
name|pm
argument_list|,
name|sva
argument_list|)
expr_stmt|;
block|}
name|sva
operator|+=
name|PAGE_SIZE
expr_stmt|;
name|ptep
operator|++
expr_stmt|;
name|mappings
operator|++
expr_stmt|;
block|}
comment|/* 		 * Deal with any left overs 		 */
if|if
condition|(
name|cleanlist_idx
operator|<=
name|PMAP_REMOVE_CLEAN_LIST_SIZE
condition|)
block|{
name|total
operator|+=
name|cleanlist_idx
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|cleanlist_idx
condition|;
name|cnt
operator|++
control|)
block|{
name|vm_offset_t
name|clva
init|=
name|cleanlist
index|[
name|cnt
index|]
operator|.
name|va
operator|&
operator|~
literal|1
decl_stmt|;
if|if
condition|(
name|cleanlist
index|[
name|cnt
index|]
operator|.
name|va
operator|&
literal|1
condition|)
block|{
name|pmap_idcache_wbinv_range
argument_list|(
name|pm
argument_list|,
name|clva
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|pmap_tlb_flushID_SE
argument_list|(
name|pm
argument_list|,
name|clva
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pmap_dcache_wb_range
argument_list|(
name|pm
argument_list|,
name|clva
argument_list|,
name|PAGE_SIZE
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|pmap_tlb_flushD_SE
argument_list|(
name|pm
argument_list|,
name|clva
argument_list|)
expr_stmt|;
block|}
operator|*
name|cleanlist
index|[
name|cnt
index|]
operator|.
name|pte
operator|=
literal|0
expr_stmt|;
name|PTE_SYNC_CURRENT
argument_list|(
name|pm
argument_list|,
name|cleanlist
index|[
name|cnt
index|]
operator|.
name|pte
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|total
operator|<=
name|PMAP_REMOVE_CLEAN_LIST_SIZE
condition|)
name|cleanlist_idx
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* 				 * We are removing so much entries it's just 				 * easier to flush the whole cache. 				 */
name|cleanlist_idx
operator|=
name|PMAP_REMOVE_CLEAN_LIST_SIZE
operator|+
literal|1
expr_stmt|;
name|pmap_idcache_wbinv_all
argument_list|(
name|pm
argument_list|)
expr_stmt|;
name|flushall
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|pmap_free_l2_bucket
argument_list|(
name|pm
argument_list|,
name|l2b
argument_list|,
name|mappings
argument_list|)
expr_stmt|;
block|}
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
if|if
condition|(
name|flushall
condition|)
name|cpu_tlb_flushID
argument_list|()
expr_stmt|;
if|#
directive|if
literal|0
block|pmap_release_pmap_lock(pm); 	PMAP_MAP_TO_HEAD_UNLOCK();
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * pmap_zero_page()  *   * Zero a given physical page by mapping it at a page hook point.  * In doing the zero page op, the page we zero is mapped cachable, as with  * StrongARM accesses to non-cached pages are non-burst making writing  * _any_ bulk data very slow.  */
end_comment

begin_if
if|#
directive|if
operator|(
name|ARM_MMU_GENERIC
operator|+
name|ARM_MMU_SA1
operator|)
operator|!=
literal|0
end_if

begin_function
name|void
name|pmap_zero_page_generic
parameter_list|(
name|vm_paddr_t
name|phys
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|size
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|struct
name|vm_page
modifier|*
name|pg
init|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|phys
argument_list|)
decl_stmt|;
if|if
condition|(
name|pg
operator|->
name|md
operator|.
name|pvh_list
operator|!=
name|NULL
condition|)
name|panic
argument_list|(
literal|"pmap_zero_page: page has mappings"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|_arm_bzero
operator|&&
name|_arm_bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|phys
operator|+
name|off
operator|)
argument_list|,
name|size
argument_list|,
name|IS_PHYSICAL
argument_list|)
operator|==
literal|0
condition|)
return|return;
comment|/* 	 * Hook in the page, zero it, and purge the cache for that 	 * zeroed page. Invalidate the TLB as needed. 	 */
operator|*
name|cdst_pte
operator|=
name|L2_S_PROTO
operator||
name|phys
operator||
name|L2_S_PROT
argument_list|(
name|PTE_KERNEL
argument_list|,
name|VM_PROT_WRITE
argument_list|)
operator||
name|pte_l2_s_cache_mode
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|cdst_pte
argument_list|)
expr_stmt|;
name|cpu_tlb_flushD_SE
argument_list|(
name|cdstp
argument_list|)
expr_stmt|;
name|cpu_cpwait
argument_list|()
expr_stmt|;
if|if
condition|(
name|off
operator|||
name|size
operator|!=
name|PAGE_SIZE
condition|)
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|cdstp
operator|+
name|off
operator|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
name|bzero_page
argument_list|(
name|cdstp
argument_list|)
expr_stmt|;
name|cpu_dcache_wbinv_range
argument_list|(
name|cdstp
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* (ARM_MMU_GENERIC + ARM_MMU_SA1) != 0 */
end_comment

begin_if
if|#
directive|if
name|ARM_MMU_XSCALE
operator|==
literal|1
end_if

begin_function
name|void
name|pmap_zero_page_xscale
parameter_list|(
name|vm_paddr_t
name|phys
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|size
parameter_list|)
block|{
if|if
condition|(
name|_arm_bzero
operator|&&
name|_arm_bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|phys
operator|+
name|off
operator|)
argument_list|,
name|size
argument_list|,
name|IS_PHYSICAL
argument_list|)
operator|==
literal|0
condition|)
return|return;
comment|/* 	 * Hook in the page, zero it, and purge the cache for that 	 * zeroed page. Invalidate the TLB as needed. 	 */
operator|*
name|cdst_pte
operator|=
name|L2_S_PROTO
operator||
name|phys
operator||
name|L2_S_PROT
argument_list|(
name|PTE_KERNEL
argument_list|,
name|VM_PROT_WRITE
argument_list|)
operator||
name|L2_C
operator||
name|L2_XSCALE_T_TEX
argument_list|(
name|TEX_XSCALE_X
argument_list|)
expr_stmt|;
comment|/* mini-data */
name|PTE_SYNC
argument_list|(
name|cdst_pte
argument_list|)
expr_stmt|;
name|cpu_tlb_flushD_SE
argument_list|(
name|cdstp
argument_list|)
expr_stmt|;
name|cpu_cpwait
argument_list|()
expr_stmt|;
if|if
condition|(
name|off
operator|||
name|size
operator|!=
name|PAGE_SIZE
condition|)
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|cdstp
operator|+
name|off
operator|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
name|bzero_page
argument_list|(
name|cdstp
argument_list|)
expr_stmt|;
name|xscale_cache_clean_minidata
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Change the PTEs for the specified kernel mappings such that they  * will use the mini data cache instead of the main data cache.  */
end_comment

begin_function
name|void
name|pmap_use_minicache
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|vm_size_t
name|size
parameter_list|)
block|{
name|struct
name|l2_bucket
modifier|*
name|l2b
decl_stmt|;
name|pt_entry_t
modifier|*
name|ptep
decl_stmt|,
modifier|*
name|sptep
decl_stmt|,
name|pte
decl_stmt|;
name|vm_offset_t
name|next_bucket
decl_stmt|,
name|eva
decl_stmt|;
if|#
directive|if
operator|(
name|ARM_NMMUS
operator|>
literal|1
operator|)
if|if
condition|(
name|xscale_use_minidata
operator|==
literal|0
condition|)
return|return;
endif|#
directive|endif
name|eva
operator|=
name|va
operator|+
name|size
expr_stmt|;
while|while
condition|(
name|va
operator|<
name|eva
condition|)
block|{
name|next_bucket
operator|=
name|L2_NEXT_BUCKET
argument_list|(
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_bucket
operator|>
name|eva
condition|)
name|next_bucket
operator|=
name|eva
expr_stmt|;
name|l2b
operator|=
name|pmap_get_l2_bucket
argument_list|(
name|pmap_kernel
argument_list|()
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|sptep
operator|=
name|ptep
operator|=
operator|&
name|l2b
operator|->
name|l2b_kva
index|[
name|l2pte_index
argument_list|(
name|va
argument_list|)
index|]
expr_stmt|;
while|while
condition|(
name|va
operator|<
name|next_bucket
condition|)
block|{
name|pte
operator|=
operator|*
name|ptep
expr_stmt|;
if|if
condition|(
operator|!
name|l2pte_minidata
argument_list|(
name|pte
argument_list|)
condition|)
block|{
name|cpu_dcache_wbinv_range
argument_list|(
name|va
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|cpu_tlb_flushD_SE
argument_list|(
name|va
argument_list|)
expr_stmt|;
operator|*
name|ptep
operator|=
name|pte
operator|&
operator|~
name|L2_B
expr_stmt|;
block|}
name|ptep
operator|++
expr_stmt|;
name|va
operator|+=
name|PAGE_SIZE
expr_stmt|;
block|}
name|PTE_SYNC_RANGE
argument_list|(
name|sptep
argument_list|,
call|(
name|u_int
call|)
argument_list|(
name|ptep
operator|-
name|sptep
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|cpu_cpwait
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ARM_MMU_XSCALE == 1 */
end_comment

begin_comment
comment|/*  *	pmap_zero_page zeros the specified hardware page by mapping   *	the page into KVM and using bzero to clear its contents.  */
end_comment

begin_function
name|void
name|pmap_zero_page
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|pmap_zero_page_func
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|,
literal|0
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	pmap_zero_page_area zeros the specified hardware page by mapping   *	the page into KVM and using bzero to clear its contents.  *  *	off and size may not cover an area beyond a single hardware page.  */
end_comment

begin_function
name|void
name|pmap_zero_page_area
parameter_list|(
name|vm_page_t
name|m
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|pmap_zero_page_func
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|,
name|off
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	pmap_zero_page_idle zeros the specified hardware page by mapping   *	the page into KVM and using bzero to clear its contents.  This  *	is intended to be called from the vm_pagezero process only and  *	outside of Giant.  */
end_comment

begin_function
name|void
name|pmap_zero_page_idle
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|pmap_zero_page
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*  * pmap_clean_page()  *  * This is a local function used to work out the best strategy to clean  * a single page referenced by its entry in the PV table. It's used by  * pmap_copy_page, pmap_zero page and maybe some others later on.  *  * Its policy is effectively:  *  o If there are no mappings, we don't bother doing anything with the cache.  *  o If there is one mapping, we clean just that page.  *  o If there are multiple mappings, we clean the entire cache.  *  * So that some functions can be further optimised, it returns 0 if it didn't  * clean the entire cache, or 1 if it did.  *  * XXX One bug in this routine is that if the pv_entry has a single page  * mapped at 0x00000000 a whole cache clean will be performed rather than  * just the 1 page. Since this should not occur in everyday use and if it does  * it will just result in not the most efficient clean for the page.  */
end_comment

begin_comment
unit|static int pmap_clean_page(struct pv_entry *pv, boolean_t is_src) { 	pmap_t pm, pm_to_clean = NULL; 	struct pv_entry *npv; 	u_int cache_needs_cleaning = 0; 	u_int flags = 0; 	vm_offset_t page_to_clean = 0;  	if (pv == NULL) {
comment|/* nothing mapped in so nothing to flush */
end_comment

begin_comment
unit|return (0); 	}
comment|/* 	 * Since we flush the cache each time we change to a different 	 * user vmspace, we only need to flush the page if it is in the 	 * current pmap. 	 */
end_comment

begin_comment
unit|if (curthread) 		pm = vmspace_pmap(curproc->p_vmspace); 	else 		pm = pmap_kernel();  	for (npv = pv; npv; npv = TAILQ_NEXT(npv, pv_list)) { 		if (npv->pv_pmap == pmap_kernel() || npv->pv_pmap == pm) { 			flags |= npv->pv_flags;
comment|/* 			 * The page is mapped non-cacheable in  			 * this map.  No need to flush the cache. 			 */
end_comment

begin_ifdef
unit|if (npv->pv_flags& PVF_NC) {
ifdef|#
directive|ifdef
name|DIAGNOSTIC
end_ifdef

begin_endif
unit|if (cache_needs_cleaning) 					panic("pmap_clean_page: " 					    "cache inconsistency");
endif|#
directive|endif
end_endif

begin_endif
unit|break; 			} else if (is_src&& (npv->pv_flags& PVF_WRITE) == 0) 				continue; 			if (cache_needs_cleaning) { 				page_to_clean = 0; 				break; 			} else { 				page_to_clean = npv->pv_va; 				pm_to_clean = npv->pv_pmap; 			} 			cache_needs_cleaning = 1; 		} 	} 	if (page_to_clean) { 		if (PV_BEEN_EXECD(flags)) 			pmap_idcache_wbinv_range(pm_to_clean, page_to_clean, 			    PAGE_SIZE); 		else 			pmap_dcache_wb_range(pm_to_clean, page_to_clean, 			    PAGE_SIZE, !is_src, (flags& PVF_WRITE) == 0); 	} else if (cache_needs_cleaning) { 		if (PV_BEEN_EXECD(flags)) 			pmap_idcache_wbinv_all(pm); 		else 			pmap_dcache_wbinv_all(pm); 		return (1); 	} 	return (0); }
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *	pmap_copy_page copies the specified (machine independent)  *	page by mapping the page into virtual memory and using  *	bcopy to copy the page, one machine dependent page at a  *	time.  */
end_comment

begin_comment
comment|/*  * pmap_copy_page()  *  * Copy one physical page into another, by mapping the pages into  * hook points. The same comment regarding cachability as in  * pmap_zero_page also applies here.  */
end_comment

begin_if
if|#
directive|if
operator|(
name|ARM_MMU_GENERIC
operator|+
name|ARM_MMU_SA1
operator|)
operator|!=
literal|0
end_if

begin_function
name|void
name|pmap_copy_page_generic
parameter_list|(
name|vm_paddr_t
name|src
parameter_list|,
name|vm_paddr_t
name|dst
parameter_list|)
block|{
if|#
directive|if
literal|0
block|struct vm_page *src_pg = PHYS_TO_VM_PAGE(src);
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG
name|struct
name|vm_page
modifier|*
name|dst_pg
init|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|dst
argument_list|)
decl_stmt|;
if|if
condition|(
name|dst_pg
operator|->
name|md
operator|.
name|pvh_list
operator|!=
name|NULL
condition|)
name|panic
argument_list|(
literal|"pmap_copy_page: dst page has mappings"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Clean the source page.  Hold the source page's lock for 	 * the duration of the copy so that no other mappings can 	 * be created while we have a potentially aliased mapping. 	 */
if|#
directive|if
literal|0
block|mtx_lock(&src_pg->md.pvh_mtx);
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/* 	 * XXX: Not needed while we call cpu_dcache_wbinv_all() in 	 * pmap_copy_page(). 	 */
block|(void) pmap_clean_page(TAILQ_FIRST(&src_pg->md.pv_list), TRUE);
endif|#
directive|endif
comment|/* 	 * Map the pages into the page hook points, copy them, and purge 	 * the cache for the appropriate page. Invalidate the TLB 	 * as required. 	 */
operator|*
name|csrc_pte
operator|=
name|L2_S_PROTO
operator||
name|src
operator||
name|L2_S_PROT
argument_list|(
name|PTE_KERNEL
argument_list|,
name|VM_PROT_READ
argument_list|)
operator||
name|pte_l2_s_cache_mode
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|csrc_pte
argument_list|)
expr_stmt|;
operator|*
name|cdst_pte
operator|=
name|L2_S_PROTO
operator||
name|dst
operator||
name|L2_S_PROT
argument_list|(
name|PTE_KERNEL
argument_list|,
name|VM_PROT_WRITE
argument_list|)
operator||
name|pte_l2_s_cache_mode
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|cdst_pte
argument_list|)
expr_stmt|;
name|cpu_tlb_flushD_SE
argument_list|(
name|csrcp
argument_list|)
expr_stmt|;
name|cpu_tlb_flushD_SE
argument_list|(
name|cdstp
argument_list|)
expr_stmt|;
name|cpu_cpwait
argument_list|()
expr_stmt|;
name|bcopy_page
argument_list|(
name|csrcp
argument_list|,
name|cdstp
argument_list|)
expr_stmt|;
name|cpu_dcache_inv_range
argument_list|(
name|csrcp
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|mtx_lock(&src_pg->md.pvh_mtx);
endif|#
directive|endif
name|cpu_dcache_wbinv_range
argument_list|(
name|cdstp
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* (ARM_MMU_GENERIC + ARM_MMU_SA1) != 0 */
end_comment

begin_if
if|#
directive|if
name|ARM_MMU_XSCALE
operator|==
literal|1
end_if

begin_function
name|void
name|pmap_copy_page_xscale
parameter_list|(
name|vm_paddr_t
name|src
parameter_list|,
name|vm_paddr_t
name|dst
parameter_list|)
block|{
if|#
directive|if
literal|0
comment|/* XXX: Only needed for pmap_clean_page(), which is commented out. */
block|struct vm_page *src_pg = PHYS_TO_VM_PAGE(src);
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG
name|struct
name|vm_page
modifier|*
name|dst_pg
init|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|dst
argument_list|)
decl_stmt|;
if|if
condition|(
name|dst_pg
operator|->
name|md
operator|.
name|pvh_list
operator|!=
name|NULL
condition|)
name|panic
argument_list|(
literal|"pmap_copy_page: dst page has mappings"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Clean the source page.  Hold the source page's lock for 	 * the duration of the copy so that no other mappings can 	 * be created while we have a potentially aliased mapping. 	 */
if|#
directive|if
literal|0
comment|/* 	 * XXX: Not needed while we call cpu_dcache_wbinv_all() in 	 * pmap_copy_page(). 	 */
block|(void) pmap_clean_page(TAILQ_FIRST(&src_pg->md.pv_list), TRUE);
endif|#
directive|endif
comment|/* 	 * Map the pages into the page hook points, copy them, and purge 	 * the cache for the appropriate page. Invalidate the TLB 	 * as required. 	 */
operator|*
name|csrc_pte
operator|=
name|L2_S_PROTO
operator||
name|src
operator||
name|L2_S_PROT
argument_list|(
name|PTE_KERNEL
argument_list|,
name|VM_PROT_READ
argument_list|)
operator||
name|L2_C
operator||
name|L2_XSCALE_T_TEX
argument_list|(
name|TEX_XSCALE_X
argument_list|)
expr_stmt|;
comment|/* mini-data */
name|PTE_SYNC
argument_list|(
name|csrc_pte
argument_list|)
expr_stmt|;
operator|*
name|cdst_pte
operator|=
name|L2_S_PROTO
operator||
name|dst
operator||
name|L2_S_PROT
argument_list|(
name|PTE_KERNEL
argument_list|,
name|VM_PROT_WRITE
argument_list|)
operator||
name|L2_C
operator||
name|L2_XSCALE_T_TEX
argument_list|(
name|TEX_XSCALE_X
argument_list|)
expr_stmt|;
comment|/* mini-data */
name|PTE_SYNC
argument_list|(
name|cdst_pte
argument_list|)
expr_stmt|;
name|cpu_tlb_flushD_SE
argument_list|(
name|csrcp
argument_list|)
expr_stmt|;
name|cpu_tlb_flushD_SE
argument_list|(
name|cdstp
argument_list|)
expr_stmt|;
name|cpu_cpwait
argument_list|()
expr_stmt|;
name|bcopy_page
argument_list|(
name|csrcp
argument_list|,
name|cdstp
argument_list|)
expr_stmt|;
name|xscale_cache_clean_minidata
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ARM_MMU_XSCALE == 1 */
end_comment

begin_function
name|void
name|pmap_copy_page
parameter_list|(
name|vm_page_t
name|src
parameter_list|,
name|vm_page_t
name|dst
parameter_list|)
block|{
name|cpu_dcache_wbinv_all
argument_list|()
expr_stmt|;
if|if
condition|(
name|_arm_memcpy
operator|&&
name|_arm_memcpy
argument_list|(
operator|(
name|void
operator|*
operator|)
name|VM_PAGE_TO_PHYS
argument_list|(
name|dst
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
name|VM_PAGE_TO_PHYS
argument_list|(
name|src
argument_list|)
argument_list|,
name|PAGE_SIZE
argument_list|,
name|IS_PHYSICAL
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|pmap_copy_page_func
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|src
argument_list|)
argument_list|,
name|VM_PAGE_TO_PHYS
argument_list|(
name|dst
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * this routine returns true if a physical page resides  * in the given pmap.  */
end_comment

begin_function
name|boolean_t
name|pmap_page_exists_quick
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_page_t
name|m
parameter_list|)
block|{
name|pv_entry_t
name|pv
decl_stmt|;
name|int
name|loops
init|=
literal|0
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
name|m
operator|->
name|flags
operator|&
name|PG_FICTITIOUS
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|s
operator|=
name|splvm
argument_list|()
expr_stmt|;
comment|/* 	 * Not found, check current mappings returning immediately 	 */
for|for
control|(
name|pv
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|)
init|;
name|pv
condition|;
name|pv
operator|=
name|TAILQ_NEXT
argument_list|(
name|pv
argument_list|,
name|pv_list
argument_list|)
control|)
block|{
if|if
condition|(
name|pv
operator|->
name|pv_pmap
operator|==
name|pmap
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
name|loops
operator|++
expr_stmt|;
if|if
condition|(
name|loops
operator|>=
literal|16
condition|)
break|break;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	pmap_ts_referenced:  *  *	Return the count of reference bits for a page, clearing all of them.  */
end_comment

begin_function
name|int
name|pmap_ts_referenced
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
return|return
operator|(
name|pmap_clearbit
argument_list|(
name|m
argument_list|,
name|PVF_REF
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|boolean_t
name|pmap_is_modified
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
if|if
condition|(
name|m
operator|->
name|md
operator|.
name|pvh_attrs
operator|&
name|PVF_MOD
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	Clear the modify bits on the specified physical page.  */
end_comment

begin_function
name|void
name|pmap_clear_modify
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
if|if
condition|(
name|m
operator|->
name|md
operator|.
name|pvh_attrs
operator|&
name|PVF_MOD
condition|)
name|pmap_clearbit
argument_list|(
name|m
argument_list|,
name|PVF_MOD
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	pmap_clear_reference:  *  *	Clear the reference bit on the specified physical page.  */
end_comment

begin_function
name|void
name|pmap_clear_reference
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
if|if
condition|(
name|m
operator|->
name|md
operator|.
name|pvh_attrs
operator|&
name|PVF_REF
condition|)
name|pmap_clearbit
argument_list|(
name|m
argument_list|,
name|PVF_REF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * perform the pmap work for mincore  */
end_comment

begin_function
name|int
name|pmap_mincore
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|addr
parameter_list|)
block|{
name|printf
argument_list|(
literal|"pmap_mincore()\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|vm_offset_t
name|pmap_addr_hint
parameter_list|(
name|vm_object_t
name|obj
parameter_list|,
name|vm_offset_t
name|addr
parameter_list|,
name|vm_size_t
name|size
parameter_list|)
block|{
return|return
operator|(
name|addr
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Map a set of physical memory pages into the kernel virtual  * address space. Return a pointer to where it is mapped. This  * routine is intended to be used for mapping device memory,  * NOT real memory.  */
end_comment

begin_function
name|void
modifier|*
name|pmap_mapdev
parameter_list|(
name|vm_offset_t
name|pa
parameter_list|,
name|vm_size_t
name|size
parameter_list|)
block|{
name|vm_offset_t
name|va
decl_stmt|,
name|tmpva
decl_stmt|,
name|offset
decl_stmt|;
name|offset
operator|=
name|pa
operator|&
name|PAGE_MASK
expr_stmt|;
name|size
operator|=
name|roundup
argument_list|(
name|size
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|GIANT_REQUIRED
expr_stmt|;
name|va
operator|=
name|kmem_alloc_nofault
argument_list|(
name|kernel_map
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|va
condition|)
name|panic
argument_list|(
literal|"pmap_mapdev: Couldn't alloc kernel virtual memory"
argument_list|)
expr_stmt|;
for|for
control|(
name|tmpva
operator|=
name|va
init|;
name|size
operator|>
literal|0
condition|;
control|)
block|{
name|pmap_kenter_internal
argument_list|(
name|tmpva
argument_list|,
name|pa
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|size
operator|-=
name|PAGE_SIZE
expr_stmt|;
name|tmpva
operator|+=
name|PAGE_SIZE
expr_stmt|;
name|pa
operator|+=
name|PAGE_SIZE
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|void
operator|*
operator|)
operator|(
name|va
operator|)
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|BOOTSTRAP_DEBUG
end_define

begin_comment
comment|/*  * pmap_map_section:  *  *	Create a single section mapping.  */
end_comment

begin_function
name|void
name|pmap_map_section
parameter_list|(
name|vm_offset_t
name|l1pt
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_offset_t
name|pa
parameter_list|,
name|int
name|prot
parameter_list|,
name|int
name|cache
parameter_list|)
block|{
name|pd_entry_t
modifier|*
name|pde
init|=
operator|(
name|pd_entry_t
operator|*
operator|)
name|l1pt
decl_stmt|;
name|pd_entry_t
name|fl
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
operator|(
name|va
operator||
name|pa
operator|)
operator|&
name|L1_S_OFFSET
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"ouin2"
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cache
condition|)
block|{
case|case
name|PTE_NOCACHE
case|:
default|default:
name|fl
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|PTE_CACHE
case|:
name|fl
operator|=
name|pte_l1_s_cache_mode
expr_stmt|;
break|break;
case|case
name|PTE_PAGETABLE
case|:
name|fl
operator|=
name|pte_l1_s_cache_mode_pt
expr_stmt|;
break|break;
block|}
name|pde
index|[
name|va
operator|>>
name|L1_S_SHIFT
index|]
operator|=
name|L1_S_PROTO
operator||
name|pa
operator||
name|L1_S_PROT
argument_list|(
name|PTE_KERNEL
argument_list|,
name|prot
argument_list|)
operator||
name|fl
operator||
name|L1_S_DOM
argument_list|(
name|PMAP_DOMAIN_KERNEL
argument_list|)
expr_stmt|;
name|PTE_SYNC
argument_list|(
operator|&
name|pde
index|[
name|va
operator|>>
name|L1_S_SHIFT
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * pmap_link_l2pt:  *  *	Link the L2 page table specified by "pa" into the L1  *	page table at the slot for "va".  */
end_comment

begin_function
name|void
name|pmap_link_l2pt
parameter_list|(
name|vm_offset_t
name|l1pt
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|struct
name|pv_addr
modifier|*
name|l2pv
parameter_list|)
block|{
name|pd_entry_t
modifier|*
name|pde
init|=
operator|(
name|pd_entry_t
operator|*
operator|)
name|l1pt
decl_stmt|,
name|proto
decl_stmt|;
name|u_int
name|slot
init|=
name|va
operator|>>
name|L1_S_SHIFT
decl_stmt|;
ifndef|#
directive|ifndef
name|ARM32_NEW_VM_LAYOUT
name|KASSERT
argument_list|(
operator|(
name|va
operator|&
operator|(
operator|(
name|L1_S_SIZE
operator|*
literal|4
operator|)
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"blah"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|l2pv
operator|->
name|pv_pa
operator|&
name|PAGE_MASK
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"ouin"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|proto
operator|=
name|L1_S_DOM
argument_list|(
name|PMAP_DOMAIN_KERNEL
argument_list|)
operator||
name|L1_C_PROTO
expr_stmt|;
name|pde
index|[
name|slot
operator|+
literal|0
index|]
operator|=
name|proto
operator||
operator|(
name|l2pv
operator|->
name|pv_pa
operator|+
literal|0x000
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ARM32_NEW_VM_LAYOUT
name|PTE_SYNC
argument_list|(
operator|&
name|pde
index|[
name|slot
index|]
argument_list|)
expr_stmt|;
else|#
directive|else
name|pde
index|[
name|slot
operator|+
literal|1
index|]
operator|=
name|proto
operator||
operator|(
name|l2pv
operator|->
name|pv_pa
operator|+
literal|0x400
operator|)
expr_stmt|;
name|pde
index|[
name|slot
operator|+
literal|2
index|]
operator|=
name|proto
operator||
operator|(
name|l2pv
operator|->
name|pv_pa
operator|+
literal|0x800
operator|)
expr_stmt|;
name|pde
index|[
name|slot
operator|+
literal|3
index|]
operator|=
name|proto
operator||
operator|(
name|l2pv
operator|->
name|pv_pa
operator|+
literal|0xc00
operator|)
expr_stmt|;
name|PTE_SYNC_RANGE
argument_list|(
operator|&
name|pde
index|[
name|slot
operator|+
literal|0
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|kernel_pt_list
argument_list|,
name|l2pv
argument_list|,
name|pv_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * pmap_map_entry  *  * 	Create a single page mapping.  */
end_comment

begin_function
name|void
name|pmap_map_entry
parameter_list|(
name|vm_offset_t
name|l1pt
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_offset_t
name|pa
parameter_list|,
name|int
name|prot
parameter_list|,
name|int
name|cache
parameter_list|)
block|{
name|pd_entry_t
modifier|*
name|pde
init|=
operator|(
name|pd_entry_t
operator|*
operator|)
name|l1pt
decl_stmt|;
name|pt_entry_t
name|fl
decl_stmt|;
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
operator|(
name|va
operator||
name|pa
operator|)
operator|&
name|PAGE_MASK
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"ouin"
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cache
condition|)
block|{
case|case
name|PTE_NOCACHE
case|:
default|default:
name|fl
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|PTE_CACHE
case|:
name|fl
operator|=
name|pte_l2_s_cache_mode
expr_stmt|;
break|break;
case|case
name|PTE_PAGETABLE
case|:
name|fl
operator|=
name|pte_l2_s_cache_mode_pt
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|pde
index|[
name|va
operator|>>
name|L1_S_SHIFT
index|]
operator|&
name|L1_TYPE_MASK
operator|)
operator|!=
name|L1_TYPE_C
condition|)
name|panic
argument_list|(
literal|"pmap_map_entry: no L2 table for VA 0x%08x"
argument_list|,
name|va
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ARM32_NEW_VM_LAYOUT
name|pte
operator|=
operator|(
name|pt_entry_t
operator|*
operator|)
name|kernel_pt_lookup
argument_list|(
name|pde
index|[
name|va
operator|>>
name|L1_S_SHIFT
index|]
operator|&
name|L2_S_FRAME
argument_list|)
expr_stmt|;
else|#
directive|else
name|pte
operator|=
operator|(
name|pt_entry_t
operator|*
operator|)
name|kernel_pt_lookup
argument_list|(
name|pde
index|[
name|L1_IDX
argument_list|(
name|va
argument_list|)
index|]
operator|&
name|L1_C_ADDR_MASK
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pte
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"pmap_map_entry: can't find L2 table for VA 0x%08x"
argument_list|,
name|va
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ARM32_NEW_VM_LAYOUT
name|pte
index|[
operator|(
name|va
operator|>>
name|PAGE_SHIFT
operator|)
operator|&
literal|0x3ff
index|]
operator|=
name|L2_S_PROTO
operator||
name|pa
operator||
name|L2_S_PROT
argument_list|(
name|PTE_KERNEL
argument_list|,
name|prot
argument_list|)
operator||
name|fl
expr_stmt|;
name|PTE_SYNC
argument_list|(
operator|&
name|pte
index|[
operator|(
name|va
operator|>>
name|PAGE_SHIFT
operator|)
operator|&
literal|0x3ff
index|]
argument_list|)
expr_stmt|;
else|#
directive|else
name|pte
index|[
name|l2pte_index
argument_list|(
name|va
argument_list|)
index|]
operator|=
name|L2_S_PROTO
operator||
name|pa
operator||
name|L2_S_PROT
argument_list|(
name|PTE_KERNEL
argument_list|,
name|prot
argument_list|)
operator||
name|fl
expr_stmt|;
name|PTE_SYNC
argument_list|(
operator|&
name|pte
index|[
name|l2pte_index
argument_list|(
name|va
argument_list|)
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * pmap_map_chunk:  *  *	Map a chunk of memory using the most efficient mappings  *	possible (section. large page, small page) into the  *	provided L1 and L2 tables at the specified virtual address.  */
end_comment

begin_function
name|vm_size_t
name|pmap_map_chunk
parameter_list|(
name|vm_offset_t
name|l1pt
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_offset_t
name|pa
parameter_list|,
name|vm_size_t
name|size
parameter_list|,
name|int
name|prot
parameter_list|,
name|int
name|cache
parameter_list|)
block|{
name|pd_entry_t
modifier|*
name|pde
init|=
operator|(
name|pd_entry_t
operator|*
operator|)
name|l1pt
decl_stmt|;
name|pt_entry_t
modifier|*
name|pte
decl_stmt|,
name|f1
decl_stmt|,
name|f2s
decl_stmt|,
name|f2l
decl_stmt|;
name|vm_size_t
name|resid
decl_stmt|;
name|int
name|i
decl_stmt|;
name|resid
operator|=
operator|(
name|size
operator|+
operator|(
name|PAGE_SIZE
operator|-
literal|1
operator|)
operator|)
operator|&
operator|~
operator|(
name|PAGE_SIZE
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|l1pt
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"pmap_map_chunk: no L1 table provided"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE_INIT_ARM
name|printf
argument_list|(
literal|"pmap_map_chunk: pa=0x%lx va=0x%lx size=0x%lx resid=0x%lx "
literal|"prot=0x%x cache=%d\n"
argument_list|,
name|pa
argument_list|,
name|va
argument_list|,
name|size
argument_list|,
name|resid
argument_list|,
name|prot
argument_list|,
name|cache
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|cache
condition|)
block|{
case|case
name|PTE_NOCACHE
case|:
default|default:
name|f1
operator|=
literal|0
expr_stmt|;
name|f2l
operator|=
literal|0
expr_stmt|;
name|f2s
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|PTE_CACHE
case|:
name|f1
operator|=
name|pte_l1_s_cache_mode
expr_stmt|;
name|f2l
operator|=
name|pte_l2_l_cache_mode
expr_stmt|;
name|f2s
operator|=
name|pte_l2_s_cache_mode
expr_stmt|;
break|break;
case|case
name|PTE_PAGETABLE
case|:
name|f1
operator|=
name|pte_l1_s_cache_mode_pt
expr_stmt|;
name|f2l
operator|=
name|pte_l2_l_cache_mode_pt
expr_stmt|;
name|f2s
operator|=
name|pte_l2_s_cache_mode_pt
expr_stmt|;
break|break;
block|}
name|size
operator|=
name|resid
expr_stmt|;
while|while
condition|(
name|resid
operator|>
literal|0
condition|)
block|{
comment|/* See if we can use a section mapping. */
if|if
condition|(
name|L1_S_MAPPABLE_P
argument_list|(
name|va
argument_list|,
name|pa
argument_list|,
name|resid
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|VERBOSE_INIT_ARM
name|printf
argument_list|(
literal|"S"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pde
index|[
name|va
operator|>>
name|L1_S_SHIFT
index|]
operator|=
name|L1_S_PROTO
operator||
name|pa
operator||
name|L1_S_PROT
argument_list|(
name|PTE_KERNEL
argument_list|,
name|prot
argument_list|)
operator||
name|f1
operator||
name|L1_S_DOM
argument_list|(
name|PMAP_DOMAIN_KERNEL
argument_list|)
expr_stmt|;
name|PTE_SYNC
argument_list|(
operator|&
name|pde
index|[
name|va
operator|>>
name|L1_S_SHIFT
index|]
argument_list|)
expr_stmt|;
name|va
operator|+=
name|L1_S_SIZE
expr_stmt|;
name|pa
operator|+=
name|L1_S_SIZE
expr_stmt|;
name|resid
operator|-=
name|L1_S_SIZE
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Ok, we're going to use an L2 table.  Make sure 		 * one is actually in the corresponding L1 slot 		 * for the current VA. 		 */
if|if
condition|(
operator|(
name|pde
index|[
name|va
operator|>>
name|L1_S_SHIFT
index|]
operator|&
name|L1_TYPE_MASK
operator|)
operator|!=
name|L1_TYPE_C
condition|)
name|panic
argument_list|(
literal|"pmap_map_chunk: no L2 table for VA 0x%08x"
argument_list|,
name|va
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ARM32_NEW_VM_LAYOUT
name|pte
operator|=
operator|(
name|pt_entry_t
operator|*
operator|)
name|kernel_pt_lookup
argument_list|(
name|pde
index|[
name|va
operator|>>
name|L1_S_SHIFT
index|]
operator|&
name|L2_S_FRAME
argument_list|)
expr_stmt|;
else|#
directive|else
name|pte
operator|=
operator|(
name|pt_entry_t
operator|*
operator|)
name|kernel_pt_lookup
argument_list|(
name|pde
index|[
name|L1_IDX
argument_list|(
name|va
argument_list|)
index|]
operator|&
name|L1_C_ADDR_MASK
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pte
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"pmap_map_chunk: can't find L2 table for VA"
literal|"0x%08x"
argument_list|,
name|va
argument_list|)
expr_stmt|;
comment|/* See if we can use a L2 large page mapping. */
if|if
condition|(
name|L2_L_MAPPABLE_P
argument_list|(
name|va
argument_list|,
name|pa
argument_list|,
name|resid
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|VERBOSE_INIT_ARM
name|printf
argument_list|(
literal|"L"
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
ifndef|#
directive|ifndef
name|ARM32_NEW_VM_LAYOUT
name|pte
index|[
operator|(
operator|(
name|va
operator|>>
name|PAGE_SHIFT
operator|)
operator|&
literal|0x3f0
operator|)
operator|+
name|i
index|]
operator|=
name|L2_L_PROTO
operator||
name|pa
operator||
name|L2_L_PROT
argument_list|(
name|PTE_KERNEL
argument_list|,
name|prot
argument_list|)
operator||
name|f2l
expr_stmt|;
name|PTE_SYNC
argument_list|(
operator|&
name|pte
index|[
operator|(
operator|(
name|va
operator|>>
name|PAGE_SHIFT
operator|)
operator|&
literal|0x3f0
operator|)
operator|+
name|i
index|]
argument_list|)
expr_stmt|;
else|#
directive|else
name|pte
index|[
name|l2pte_index
argument_list|(
name|va
argument_list|)
operator|+
name|i
index|]
operator|=
name|L2_L_PROTO
operator||
name|pa
operator||
name|L2_L_PROT
argument_list|(
name|PTE_KERNEL
argument_list|,
name|prot
argument_list|)
operator||
name|f2l
expr_stmt|;
name|PTE_SYNC
argument_list|(
operator|&
name|pte
index|[
name|l2pte_index
argument_list|(
name|va
argument_list|)
operator|+
name|i
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|va
operator|+=
name|L2_L_SIZE
expr_stmt|;
name|pa
operator|+=
name|L2_L_SIZE
expr_stmt|;
name|resid
operator|-=
name|L2_L_SIZE
expr_stmt|;
continue|continue;
block|}
comment|/* Use a small page mapping. */
ifdef|#
directive|ifdef
name|VERBOSE_INIT_ARM
name|printf
argument_list|(
literal|"P"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|ARM32_NEW_VM_LAYOUT
name|pte
index|[
operator|(
name|va
operator|>>
name|PAGE_SHIFT
operator|)
operator|&
literal|0x3ff
index|]
operator|=
name|L2_S_PROTO
operator||
name|pa
operator||
name|L2_S_PROT
argument_list|(
name|PTE_KERNEL
argument_list|,
name|prot
argument_list|)
operator||
name|f2s
expr_stmt|;
name|PTE_SYNC
argument_list|(
operator|&
name|pte
index|[
operator|(
name|va
operator|>>
name|PAGE_SHIFT
operator|)
operator|&
literal|0x3ff
index|]
argument_list|)
expr_stmt|;
else|#
directive|else
name|pte
index|[
name|l2pte_index
argument_list|(
name|va
argument_list|)
index|]
operator|=
name|L2_S_PROTO
operator||
name|pa
operator||
name|L2_S_PROT
argument_list|(
name|PTE_KERNEL
argument_list|,
name|prot
argument_list|)
operator||
name|f2s
expr_stmt|;
name|PTE_SYNC
argument_list|(
operator|&
name|pte
index|[
name|l2pte_index
argument_list|(
name|va
argument_list|)
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|va
operator|+=
name|PAGE_SIZE
expr_stmt|;
name|pa
operator|+=
name|PAGE_SIZE
expr_stmt|;
name|resid
operator|-=
name|PAGE_SIZE
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|VERBOSE_INIT_ARM
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|size
operator|)
return|;
block|}
end_function

begin_comment
comment|/********************** Static device map routines ***************************/
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|pmap_devmap
modifier|*
name|pmap_devmap_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Register the devmap table.  This is provided in case early console  * initialization needs to register mappings created by bootstrap code  * before pmap_devmap_bootstrap() is called.  */
end_comment

begin_function
name|void
name|pmap_devmap_register
parameter_list|(
specifier|const
name|struct
name|pmap_devmap
modifier|*
name|table
parameter_list|)
block|{
name|pmap_devmap_table
operator|=
name|table
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Map all of the static regions in the devmap table, and remember  * the devmap table so other parts of the kernel can look up entries  * later.  */
end_comment

begin_function
name|void
name|pmap_devmap_bootstrap
parameter_list|(
name|vm_offset_t
name|l1pt
parameter_list|,
specifier|const
name|struct
name|pmap_devmap
modifier|*
name|table
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|pmap_devmap_table
operator|=
name|table
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|pmap_devmap_table
index|[
name|i
index|]
operator|.
name|pd_size
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|VERBOSE_INIT_ARM
name|printf
argument_list|(
literal|"devmap: %08lx -> %08lx @ %08lx\n"
argument_list|,
name|pmap_devmap_table
index|[
name|i
index|]
operator|.
name|pd_pa
argument_list|,
name|pmap_devmap_table
index|[
name|i
index|]
operator|.
name|pd_pa
operator|+
name|pmap_devmap_table
index|[
name|i
index|]
operator|.
name|pd_size
operator|-
literal|1
argument_list|,
name|pmap_devmap_table
index|[
name|i
index|]
operator|.
name|pd_va
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pmap_map_chunk
argument_list|(
name|l1pt
argument_list|,
name|pmap_devmap_table
index|[
name|i
index|]
operator|.
name|pd_va
argument_list|,
name|pmap_devmap_table
index|[
name|i
index|]
operator|.
name|pd_pa
argument_list|,
name|pmap_devmap_table
index|[
name|i
index|]
operator|.
name|pd_size
argument_list|,
name|pmap_devmap_table
index|[
name|i
index|]
operator|.
name|pd_prot
argument_list|,
name|pmap_devmap_table
index|[
name|i
index|]
operator|.
name|pd_cache
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|const
name|struct
name|pmap_devmap
modifier|*
name|pmap_devmap_find_pa
parameter_list|(
name|vm_paddr_t
name|pa
parameter_list|,
name|vm_size_t
name|size
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|pmap_devmap_table
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|pmap_devmap_table
index|[
name|i
index|]
operator|.
name|pd_size
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pa
operator|>=
name|pmap_devmap_table
index|[
name|i
index|]
operator|.
name|pd_pa
operator|&&
name|pa
operator|+
name|size
operator|<=
name|pmap_devmap_table
index|[
name|i
index|]
operator|.
name|pd_pa
operator|+
name|pmap_devmap_table
index|[
name|i
index|]
operator|.
name|pd_size
condition|)
return|return
operator|(
operator|&
name|pmap_devmap_table
index|[
name|i
index|]
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|struct
name|pmap_devmap
modifier|*
name|pmap_devmap_find_va
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|vm_size_t
name|size
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|pmap_devmap_table
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|pmap_devmap_table
index|[
name|i
index|]
operator|.
name|pd_size
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|va
operator|>=
name|pmap_devmap_table
index|[
name|i
index|]
operator|.
name|pd_va
operator|&&
name|va
operator|+
name|size
operator|<=
name|pmap_devmap_table
index|[
name|i
index|]
operator|.
name|pd_va
operator|+
name|pmap_devmap_table
index|[
name|i
index|]
operator|.
name|pd_size
condition|)
return|return
operator|(
operator|&
name|pmap_devmap_table
index|[
name|i
index|]
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

end_unit

