begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2014 Ian Lepore<ian@freebsd.org>  * All rights excluded.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_comment
comment|/*  * Routines for describing and initializing anything related to physical memory.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/physmem.h>
end_include

begin_comment
comment|/*  * These structures are used internally to keep track of regions of physical  * ram, and regions within the physical ram that need to be excluded.  An  * exclusion region can be excluded from crash dumps, from the vm pool of pages  * that can be allocated, or both, depending on the exclusion flags associated  * with the region.  */
end_comment

begin_define
define|#
directive|define
name|MAX_HWCNT
value|10
end_define

begin_define
define|#
directive|define
name|MAX_EXCNT
value|10
end_define

begin_struct
struct|struct
name|region
block|{
name|vm_paddr_t
name|addr
decl_stmt|;
name|vm_size_t
name|size
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|region
name|hwregions
index|[
name|MAX_HWCNT
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|region
name|exregions
index|[
name|MAX_EXCNT
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|hwcnt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|excnt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * These "avail lists" are globals used to communicate physical memory layout to  * other parts of the kernel.  Within the arrays, each value is the starting  * address of a contiguous area of physical address space.  The values at even  * indexes are areas that contain usable memory and the values at odd indexes  * are areas that aren't usable.  Each list is terminated by a pair of zero  * entries.  *  * dump_avail tells the dump code what regions to include in a crash dump, and  * phys_avail is the way we hand all the remaining physical ram we haven't used  * in early kernel init over to the vm system for allocation management.  *  * We size these arrays to hold twice as many available regions as we allow for  * hardware memory regions, to allow for the fact that exclusions can split a  * hardware region into two or more available regions.  In the real world there  * will typically be one or two hardware regions and two or three exclusions.  *  * Each available region in this list occupies two array slots (the start of the  * available region and the start of the unavailable region that follows it).  */
end_comment

begin_define
define|#
directive|define
name|MAX_AVAIL_REGIONS
value|(MAX_HWCNT * 2)
end_define

begin_define
define|#
directive|define
name|MAX_AVAIL_ENTRIES
value|(MAX_AVAIL_REGIONS * 2)
end_define

begin_decl_stmt
name|vm_paddr_t
name|phys_avail
index|[
name|MAX_AVAIL_ENTRIES
operator|+
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* +2 to allow for a pair  */
end_comment

begin_decl_stmt
name|vm_paddr_t
name|dump_avail
index|[
name|MAX_AVAIL_ENTRIES
operator|+
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* of zeroes to terminate. */
end_comment

begin_comment
comment|/*  * realmem is the total number of hardware pages, excluded or not.  * Maxmem is one greater than the last physical page number.  */
end_comment

begin_decl_stmt
name|long
name|realmem
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|Maxmem
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The address at which the kernel was loaded.  Set early in initarm(). */
end_comment

begin_decl_stmt
name|vm_paddr_t
name|arm_physmem_kernaddr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Print the contents of the physical and excluded region tables using the  * provided printf-like output function (which will be either printf or  * db_printf).  */
end_comment

begin_function
specifier|static
name|void
name|physmem_dump_tables
parameter_list|(
name|int
function_decl|(
modifier|*
name|prfunc
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
parameter_list|)
block|{
name|int
name|flags
decl_stmt|,
name|i
decl_stmt|;
name|uintmax_t
name|addr
decl_stmt|,
name|size
decl_stmt|;
specifier|const
name|unsigned
name|int
name|mbyte
init|=
literal|1024
operator|*
literal|1024
decl_stmt|;
name|prfunc
argument_list|(
literal|"Physical memory chunk(s):\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hwcnt
condition|;
operator|++
name|i
control|)
block|{
name|addr
operator|=
name|hwregions
index|[
name|i
index|]
operator|.
name|addr
expr_stmt|;
name|size
operator|=
name|hwregions
index|[
name|i
index|]
operator|.
name|size
expr_stmt|;
name|prfunc
argument_list|(
literal|"  0x%08jx - 0x%08jx, %5ju MB (%7ju pages)\n"
argument_list|,
name|addr
argument_list|,
name|addr
operator|+
name|size
operator|-
literal|1
argument_list|,
name|size
operator|/
name|mbyte
argument_list|,
name|size
operator|/
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
name|prfunc
argument_list|(
literal|"Excluded memory regions:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|excnt
condition|;
operator|++
name|i
control|)
block|{
name|addr
operator|=
name|exregions
index|[
name|i
index|]
operator|.
name|addr
expr_stmt|;
name|size
operator|=
name|exregions
index|[
name|i
index|]
operator|.
name|size
expr_stmt|;
name|flags
operator|=
name|exregions
index|[
name|i
index|]
operator|.
name|flags
expr_stmt|;
name|prfunc
argument_list|(
literal|"  0x%08jx - 0x%08jx, %5ju MB (%7ju pages) %s %s\n"
argument_list|,
name|addr
argument_list|,
name|addr
operator|+
name|size
operator|-
literal|1
argument_list|,
name|size
operator|/
name|mbyte
argument_list|,
name|size
operator|/
name|PAGE_SIZE
argument_list|,
operator|(
name|flags
operator|&
name|EXFLAG_NOALLOC
operator|)
condition|?
literal|"NoAlloc"
else|:
literal|""
argument_list|,
operator|(
name|flags
operator|&
name|EXFLAG_NODUMP
operator|)
condition|?
literal|"NoDump"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|prfunc
argument_list|(
literal|"Avail lists:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|phys_avail
index|[
name|i
index|]
operator|!=
literal|0
condition|;
operator|++
name|i
control|)
block|{
name|prfunc
argument_list|(
literal|"  phys_avail[%d] 0x%08x\n"
argument_list|,
name|i
argument_list|,
name|phys_avail
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|dump_avail
index|[
name|i
index|]
operator|!=
literal|0
condition|;
operator|++
name|i
control|)
block|{
name|prfunc
argument_list|(
literal|"  dump_avail[%d] 0x%08x\n"
argument_list|,
name|i
argument_list|,
name|dump_avail
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Print the contents of the static mapping table.  Used for bootverbose.  */
end_comment

begin_function
name|void
name|arm_physmem_print_tables
parameter_list|()
block|{
name|physmem_dump_tables
argument_list|(
name|printf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Walk the list of hardware regions, processing it against the list of  * exclusions that contain the given exflags, and generating an "avail list".  *  * Updates the value at *pavail with the sum of all pages in all hw regions.  *  * Returns the number of pages of non-excluded memory added to the avail list.  */
end_comment

begin_function
specifier|static
name|size_t
name|regions_to_avail
parameter_list|(
name|vm_paddr_t
modifier|*
name|avail
parameter_list|,
name|uint32_t
name|exflags
parameter_list|,
name|long
modifier|*
name|pavail
parameter_list|)
block|{
name|size_t
name|acnt
decl_stmt|,
name|exi
decl_stmt|,
name|hwi
decl_stmt|;
name|uint64_t
name|end
decl_stmt|,
name|start
decl_stmt|,
name|xend
decl_stmt|,
name|xstart
decl_stmt|;
name|long
name|availmem
decl_stmt|;
specifier|const
name|struct
name|region
modifier|*
name|exp
decl_stmt|,
modifier|*
name|hwp
decl_stmt|;
name|realmem
operator|=
literal|0
expr_stmt|;
name|availmem
operator|=
literal|0
expr_stmt|;
name|acnt
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|hwi
operator|=
literal|0
operator|,
name|hwp
operator|=
name|hwregions
init|;
name|hwi
operator|<
name|hwcnt
condition|;
operator|++
name|hwi
operator|,
operator|++
name|hwp
control|)
block|{
name|start
operator|=
name|hwp
operator|->
name|addr
expr_stmt|;
name|end
operator|=
name|hwp
operator|->
name|size
operator|+
name|start
expr_stmt|;
name|realmem
operator|+=
name|arm32_btop
argument_list|(
call|(
name|vm_offset_t
call|)
argument_list|(
name|end
operator|-
name|start
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|exi
operator|=
literal|0
operator|,
name|exp
operator|=
name|exregions
init|;
name|exi
operator|<
name|excnt
condition|;
operator|++
name|exi
operator|,
operator|++
name|exp
control|)
block|{
comment|/* 			 * If the excluded region does not match given flags, 			 * continue checking with the next excluded region. 			 */
if|if
condition|(
operator|(
name|exp
operator|->
name|flags
operator|&
name|exflags
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|xstart
operator|=
name|exp
operator|->
name|addr
expr_stmt|;
name|xend
operator|=
name|exp
operator|->
name|size
operator|+
name|xstart
expr_stmt|;
comment|/* 			 * If the excluded region ends before this hw region, 			 * continue checking with the next excluded region. 			 */
if|if
condition|(
name|xend
operator|<=
name|start
condition|)
continue|continue;
comment|/* 			 * If the excluded region begins after this hw region 			 * we're done because both lists are sorted. 			 */
if|if
condition|(
name|xstart
operator|>=
name|end
condition|)
break|break;
comment|/* 			 * If the excluded region completely covers this hw 			 * region, shrink this hw region to zero size. 			 */
if|if
condition|(
operator|(
name|start
operator|>=
name|xstart
operator|)
operator|&&
operator|(
name|end
operator|<=
name|xend
operator|)
condition|)
block|{
name|start
operator|=
name|xend
expr_stmt|;
name|end
operator|=
name|xend
expr_stmt|;
break|break;
block|}
comment|/* 			 * If the excluded region falls wholly within this hw 			 * region without abutting or overlapping the beginning 			 * or end, create an available entry from the leading 			 * fragment, then adjust the start of this hw region to 			 * the end of the excluded region, and continue checking 			 * the next excluded region because another exclusion 			 * could affect the remainder of this hw region. 			 */
if|if
condition|(
operator|(
name|xstart
operator|>
name|start
operator|)
operator|&&
operator|(
name|xend
operator|<
name|end
operator|)
condition|)
block|{
name|avail
index|[
name|acnt
operator|++
index|]
operator|=
operator|(
name|vm_paddr_t
operator|)
name|start
expr_stmt|;
name|avail
index|[
name|acnt
operator|++
index|]
operator|=
operator|(
name|vm_paddr_t
operator|)
name|xstart
expr_stmt|;
name|availmem
operator|+=
name|arm32_btop
argument_list|(
call|(
name|vm_offset_t
call|)
argument_list|(
name|xstart
operator|-
name|start
argument_list|)
argument_list|)
expr_stmt|;
name|start
operator|=
name|xend
expr_stmt|;
continue|continue;
block|}
comment|/* 			 * We know the excluded region overlaps either the start 			 * or end of this hardware region (but not both), trim 			 * the excluded portion off the appropriate end. 			 */
if|if
condition|(
name|xstart
operator|<=
name|start
condition|)
name|start
operator|=
name|xend
expr_stmt|;
else|else
name|end
operator|=
name|xstart
expr_stmt|;
block|}
comment|/* 		 * If the trimming actions above left a non-zero size, create an 		 * available entry for it. 		 */
if|if
condition|(
name|end
operator|>
name|start
condition|)
block|{
name|avail
index|[
name|acnt
operator|++
index|]
operator|=
operator|(
name|vm_paddr_t
operator|)
name|start
expr_stmt|;
name|avail
index|[
name|acnt
operator|++
index|]
operator|=
operator|(
name|vm_paddr_t
operator|)
name|end
expr_stmt|;
name|availmem
operator|+=
name|arm32_btop
argument_list|(
call|(
name|vm_offset_t
call|)
argument_list|(
name|end
operator|-
name|start
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|acnt
operator|>=
name|MAX_AVAIL_ENTRIES
condition|)
name|panic
argument_list|(
literal|"Not enough space in the dump/phys_avail arrays"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pavail
condition|)
operator|*
name|pavail
operator|=
name|availmem
expr_stmt|;
return|return
operator|(
name|acnt
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Insertion-sort a new entry into a regions list; sorted by start address.  */
end_comment

begin_function
specifier|static
name|void
name|insert_region
parameter_list|(
name|struct
name|region
modifier|*
name|regions
parameter_list|,
name|size_t
name|rcnt
parameter_list|,
name|vm_paddr_t
name|addr
parameter_list|,
name|vm_size_t
name|size
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|struct
name|region
modifier|*
name|ep
decl_stmt|,
modifier|*
name|rp
decl_stmt|;
name|ep
operator|=
name|regions
operator|+
name|rcnt
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|rp
operator|=
name|regions
init|;
name|i
operator|<
name|rcnt
condition|;
operator|++
name|i
operator|,
operator|++
name|rp
control|)
block|{
if|if
condition|(
name|addr
operator|<
name|rp
operator|->
name|addr
condition|)
block|{
name|bcopy
argument_list|(
name|rp
argument_list|,
name|rp
operator|+
literal|1
argument_list|,
operator|(
name|ep
operator|-
name|rp
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|rp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|rp
operator|->
name|addr
operator|=
name|addr
expr_stmt|;
name|rp
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|rp
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add a hardware memory region.  */
end_comment

begin_function
name|void
name|arm_physmem_hardware_region
parameter_list|(
name|vm_paddr_t
name|pa
parameter_list|,
name|vm_size_t
name|sz
parameter_list|)
block|{
name|vm_offset_t
name|adj
decl_stmt|;
comment|/* 	 * Filter out the page at PA 0x00000000.  The VM can't handle it, as 	 * pmap_extract() == 0 means failure. 	 * 	 * Also filter out the page at the end of the physical address space -- 	 * if addr is non-zero and addr+size is zero we wrapped to the next byte 	 * beyond what vm_paddr_t can express.  That leads to a NULL pointer 	 * deref early in startup; work around it by leaving the last page out. 	 * 	 * XXX This just in:  subtract out a whole megabyte, not just 1 page. 	 * Reducing the size by anything less than 1MB results in the NULL 	 * pointer deref in _vm_map_lock_read().  Better to give up a megabyte 	 * than leave some folks with an unusable system while we investigate. 	 */
if|if
condition|(
name|pa
operator|==
literal|0
condition|)
block|{
name|pa
operator|=
name|PAGE_SIZE
expr_stmt|;
name|sz
operator|-=
name|PAGE_SIZE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pa
operator|+
name|sz
operator|==
literal|0
condition|)
block|{
name|sz
operator|-=
literal|1024
operator|*
literal|1024
expr_stmt|;
block|}
comment|/* 	 * Round the starting address up to a page boundary, and truncate the 	 * ending page down to a page boundary. 	 */
name|adj
operator|=
name|round_page
argument_list|(
name|pa
argument_list|)
operator|-
name|pa
expr_stmt|;
name|pa
operator|=
name|round_page
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|sz
operator|=
name|trunc_page
argument_list|(
name|sz
operator|-
name|adj
argument_list|)
expr_stmt|;
if|if
condition|(
name|hwcnt
operator|<
name|nitems
argument_list|(
name|hwregions
argument_list|)
condition|)
name|insert_region
argument_list|(
name|hwregions
argument_list|,
name|hwcnt
operator|++
argument_list|,
name|pa
argument_list|,
name|sz
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add an exclusion region.  */
end_comment

begin_function
name|void
name|arm_physmem_exclude_region
parameter_list|(
name|vm_paddr_t
name|pa
parameter_list|,
name|vm_size_t
name|sz
parameter_list|,
name|uint32_t
name|exflags
parameter_list|)
block|{
name|vm_offset_t
name|adj
decl_stmt|;
comment|/* 	 * Truncate the starting address down to a page boundary, and round the 	 * ending page up to a page boundary. 	 */
name|adj
operator|=
name|pa
operator|-
name|trunc_page
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|pa
operator|=
name|trunc_page
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|sz
operator|=
name|round_page
argument_list|(
name|sz
operator|+
name|adj
argument_list|)
expr_stmt|;
if|if
condition|(
name|excnt
operator|<
name|nitems
argument_list|(
name|exregions
argument_list|)
condition|)
name|insert_region
argument_list|(
name|exregions
argument_list|,
name|excnt
operator|++
argument_list|,
name|pa
argument_list|,
name|sz
argument_list|,
name|exflags
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process all the regions added earlier into the global avail lists.  *  * Updates the kernel global 'physmem' with the number of physical pages  * available for use (all pages not in any exclusion region).  *  * Updates the kernel global 'Maxmem' with the page number one greater then the  * last page of physical memory in the system.  */
end_comment

begin_function
name|void
name|arm_physmem_init_kernel_globals
parameter_list|(
name|void
parameter_list|)
block|{
name|size_t
name|nextidx
decl_stmt|;
name|regions_to_avail
argument_list|(
name|dump_avail
argument_list|,
name|EXFLAG_NODUMP
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|nextidx
operator|=
name|regions_to_avail
argument_list|(
name|phys_avail
argument_list|,
name|EXFLAG_NOALLOC
argument_list|,
operator|&
name|physmem
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextidx
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"No memory entries in phys_avail"
argument_list|)
expr_stmt|;
name|Maxmem
operator|=
name|atop
argument_list|(
name|phys_avail
index|[
name|nextidx
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_include
include|#
directive|include
file|<ddb/ddb.h>
end_include

begin_macro
name|DB_SHOW_COMMAND
argument_list|(
argument|physmem
argument_list|,
argument|db_show_physmem
argument_list|)
end_macro

begin_block
block|{
name|physmem_dump_tables
argument_list|(
name|db_printf
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DDB */
end_comment

end_unit

