begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: ntfs_vfsops.c,v 1.23 1999/11/15 19:38:14 jdolecek Exp $	*/
end_comment

begin_comment
comment|/*-  * Copyright (c) 1998, 1999 Semen Ustimenko  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<geom/geom.h>
end_include

begin_include
include|#
directive|include
file|<geom/geom_vfs.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_comment
comment|/*#define NTFS_DEBUG 1*/
end_comment

begin_include
include|#
directive|include
file|<fs/ntfs/ntfs.h>
end_include

begin_include
include|#
directive|include
file|<fs/ntfs/ntfs_inode.h>
end_include

begin_include
include|#
directive|include
file|<fs/ntfs/ntfs_subr.h>
end_include

begin_include
include|#
directive|include
file|<fs/ntfs/ntfs_vfsops.h>
end_include

begin_include
include|#
directive|include
file|<fs/ntfs/ntfs_ihash.h>
end_include

begin_include
include|#
directive|include
file|<fs/ntfs/ntfsmount.h>
end_include

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_NTFSMNT
argument_list|,
literal|"NTFS mount"
argument_list|,
literal|"NTFS mount structure"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_NTFSNTNODE
argument_list|,
literal|"NTFS ntnode"
argument_list|,
literal|"NTFS ntnode information"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_NTFSFNODE
argument_list|,
literal|"NTFS fnode"
argument_list|,
literal|"NTFS fnode information"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_NTFSDIR
argument_list|,
literal|"NTFS dir"
argument_list|,
literal|"NTFS dir buffer"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct_decl
struct_decl|struct
name|sockaddr
struct_decl|;
end_struct_decl

begin_function_decl
specifier|static
name|int
name|ntfs_mountfs
parameter_list|(
specifier|register
name|struct
name|vnode
modifier|*
parameter_list|,
name|struct
name|mount
modifier|*
parameter_list|,
name|struct
name|ntfs_args
modifier|*
parameter_list|,
name|struct
name|thread
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|vfs_init_t
name|ntfs_init
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vfs_uninit_t
name|ntfs_uninit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vfs_vget_t
name|ntfs_vget
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vfs_fhtovp_t
name|ntfs_fhtovp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vfs_omount_t
name|ntfs_omount
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vfs_root_t
name|ntfs_root
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vfs_statfs_t
name|ntfs_statfs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vfs_unmount_t
name|ntfs_unmount
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vfs_vptofh_t
name|ntfs_vptofh
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|ntfs_init
parameter_list|(
name|struct
name|vfsconf
modifier|*
name|vcp
parameter_list|)
block|{
name|ntfs_nthashinit
argument_list|()
expr_stmt|;
name|ntfs_toupper_init
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntfs_uninit
parameter_list|(
name|struct
name|vfsconf
modifier|*
name|vcp
parameter_list|)
block|{
name|ntfs_toupper_destroy
argument_list|()
expr_stmt|;
name|ntfs_nthashdestroy
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntfs_omount
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|char
modifier|*
name|path
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|size_t
name|size
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|struct
name|vnode
modifier|*
name|devvp
decl_stmt|,
modifier|*
name|rootvp
decl_stmt|;
name|struct
name|ntfs_args
name|args
decl_stmt|;
name|struct
name|nameidata
name|ndp
decl_stmt|;
comment|/* 	 * Use NULL path to flag a root mount 	 */
if|if
condition|(
name|mp
operator|->
name|mnt_flag
operator|&
name|MNT_ROOTFS
condition|)
block|{
comment|/* 		 *** 		 * Mounting root filesystem 		 *** 		 */
comment|/* Get vnode for root device*/
if|if
condition|(
name|bdevvp
argument_list|(
name|rootdev
argument_list|,
operator|&
name|rootvp
argument_list|)
condition|)
name|panic
argument_list|(
literal|"ntfs_mountroot: can't setup bdevvp for root"
argument_list|)
expr_stmt|;
comment|/* 		 * FS specific handling 		 */
name|mp
operator|->
name|mnt_flag
operator||=
name|MNT_RDONLY
expr_stmt|;
comment|/* XXX globally applicable?*/
comment|/* 		 * Attempt mount 		 */
if|if
condition|(
operator|(
name|err
operator|=
name|ntfs_mountfs
argument_list|(
name|rootvp
argument_list|,
name|mp
argument_list|,
operator|&
name|args
argument_list|,
name|td
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* fs specific cleanup (if any)*/
goto|goto
name|error_1
goto|;
block|}
goto|goto
name|dostatfs
goto|;
comment|/* success*/
block|}
comment|/* 	 *** 	 * Mounting non-root filesystem or updating a filesystem 	 *** 	 */
comment|/* copy in user arguments*/
name|err
operator|=
name|copyin
argument_list|(
name|data
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|args
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ntfs_args
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|error_1
goto|;
comment|/* can't get arguments*/
comment|/* 	 * If updating, check whether changing from read-only to 	 * read/write; if there is no device name, that's all we do. 	 */
if|if
condition|(
name|mp
operator|->
name|mnt_flag
operator|&
name|MNT_UPDATE
condition|)
block|{
comment|/* if not updating name...*/
if|if
condition|(
name|args
operator|.
name|fspec
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Process export requests.  Jumping to "success" 			 * will return the vfs_export() error code. 			 */
name|err
operator|=
name|vfs_export
argument_list|(
name|mp
argument_list|,
operator|&
name|args
operator|.
name|export
argument_list|)
expr_stmt|;
goto|goto
name|success
goto|;
block|}
name|printf
argument_list|(
literal|"ntfs_mount(): MNT_UPDATE not supported\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|error_1
goto|;
block|}
comment|/* 	 * Not an update, or updating the name: look up the name 	 * and verify that it refers to a sensible block device. 	 */
name|NDINIT
argument_list|(
operator|&
name|ndp
argument_list|,
name|LOOKUP
argument_list|,
name|FOLLOW
argument_list|,
name|UIO_USERSPACE
argument_list|,
name|args
operator|.
name|fspec
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|err
operator|=
name|namei
argument_list|(
operator|&
name|ndp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
comment|/* can't get devvp!*/
goto|goto
name|error_1
goto|;
block|}
name|NDFREE
argument_list|(
operator|&
name|ndp
argument_list|,
name|NDF_ONLY_PNBUF
argument_list|)
expr_stmt|;
name|devvp
operator|=
name|ndp
operator|.
name|ni_vp
expr_stmt|;
if|if
condition|(
operator|!
name|vn_isdisk
argument_list|(
name|devvp
argument_list|,
operator|&
name|err
argument_list|)
condition|)
goto|goto
name|error_2
goto|;
if|if
condition|(
name|mp
operator|->
name|mnt_flag
operator|&
name|MNT_UPDATE
condition|)
block|{
if|#
directive|if
literal|0
comment|/* 		 ******************** 		 * UPDATE 		 ******************** 		 */
block|if (devvp != ntmp->um_devvp) 			err = EINVAL;
comment|/* needs translation */
block|else 			vrele(devvp);
comment|/* 		 * Update device name only on success 		 */
block|if( !err) {
comment|/* Save "mounted from" info for mount point (NULL pad)*/
block|copyinstr(	args.fspec, 					mp->mnt_stat.f_mntfromname, 					MNAMELEN - 1,&size); 			bzero( mp->mnt_stat.f_mntfromname + size, MNAMELEN - size); 		}
endif|#
directive|endif
block|}
else|else
block|{
comment|/* 		 ******************** 		 * NEW MOUNT 		 ******************** 		 */
comment|/* 		 * Since this is a new mount, we want the names for 		 * the device and the mount point copied in.  If an 		 * error occurs, the mountpoint is discarded by the 		 * upper level code.  Note that vfs_mount() handles 		 * copying the mountpoint f_mntonname for us, so we 		 * don't have to do it here unless we want to set it 		 * to something other than "path" for some rason. 		 */
comment|/* Save "mounted from" info for mount point (NULL pad)*/
name|copyinstr
argument_list|(
name|args
operator|.
name|fspec
argument_list|,
comment|/* device name*/
name|mp
operator|->
name|mnt_stat
operator|.
name|f_mntfromname
argument_list|,
comment|/* save area*/
name|MNAMELEN
operator|-
literal|1
argument_list|,
comment|/* max size*/
operator|&
name|size
argument_list|)
expr_stmt|;
comment|/* real size*/
name|bzero
argument_list|(
name|mp
operator|->
name|mnt_stat
operator|.
name|f_mntfromname
operator|+
name|size
argument_list|,
name|MNAMELEN
operator|-
name|size
argument_list|)
expr_stmt|;
name|err
operator|=
name|ntfs_mountfs
argument_list|(
name|devvp
argument_list|,
name|mp
argument_list|,
operator|&
name|args
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
block|{
goto|goto
name|error_2
goto|;
block|}
name|dostatfs
label|:
comment|/* 	 * Initialize FS stat information in mount struct; uses both 	 * mp->mnt_stat.f_mntonname and mp->mnt_stat.f_mntfromname 	 * 	 * This code is common to root and non-root mounts 	 */
operator|(
name|void
operator|)
name|VFS_STATFS
argument_list|(
name|mp
argument_list|,
operator|&
name|mp
operator|->
name|mnt_stat
argument_list|,
name|td
argument_list|)
expr_stmt|;
goto|goto
name|success
goto|;
name|error_2
label|:
comment|/* error with devvp held*/
comment|/* release devvp before failing*/
name|vrele
argument_list|(
name|devvp
argument_list|)
expr_stmt|;
name|error_1
label|:
comment|/* no state to back out*/
comment|/* XXX: missing NDFREE(&ndp, ...) */
name|success
label|:
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Common code for mount and mountroot  */
end_comment

begin_function
name|int
name|ntfs_mountfs
parameter_list|(
name|devvp
parameter_list|,
name|mp
parameter_list|,
name|argsp
parameter_list|,
name|td
parameter_list|)
specifier|register
name|struct
name|vnode
modifier|*
name|devvp
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|struct
name|ntfs_args
modifier|*
name|argsp
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|ntfsmount
modifier|*
name|ntmp
decl_stmt|;
name|struct
name|cdev
modifier|*
name|dev
init|=
name|devvp
operator|->
name|v_rdev
decl_stmt|;
name|int
name|error
decl_stmt|,
name|ronly
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|ronly
operator|=
operator|(
name|mp
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
operator|)
operator|!=
literal|0
expr_stmt|;
name|vn_lock
argument_list|(
name|devvp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|DROP_GIANT
argument_list|()
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
name|error
operator|=
name|g_vfs_open
argument_list|(
name|devvp
argument_list|,
operator|&
name|cp
argument_list|,
literal|"ntfs"
argument_list|,
name|ronly
condition|?
literal|0
else|:
literal|1
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|PICKUP_GIANT
argument_list|()
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|devvp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|bp
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|bread
argument_list|(
name|devvp
argument_list|,
name|BBLOCK
argument_list|,
name|BBSIZE
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|ntmp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|ntmp
argument_list|,
name|M_NTFSMNT
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|bp
operator|->
name|b_data
argument_list|,
operator|&
name|ntmp
operator|->
name|ntm_bootfile
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bootfile
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * We must not cache the boot block if its size is not exactly 	 * one cluster in order to avoid confusing the buffer cache when 	 * the boot file is read later by ntfs_readntvattr_plain(), which 	 * reads a cluster at a time. 	 */
if|if
condition|(
name|ntfs_cntob
argument_list|(
literal|1
argument_list|)
operator|!=
name|BBSIZE
condition|)
name|bp
operator|->
name|b_flags
operator||=
name|B_NOCACHE
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|ntmp
operator|->
name|ntm_bootfile
operator|.
name|bf_sysid
argument_list|,
name|NTFS_BBID
argument_list|,
name|NTFS_BBIDLEN
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"ntfs_mountfs: invalid boot block\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|{
name|int8_t
name|cpr
init|=
name|ntmp
operator|->
name|ntm_mftrecsz
decl_stmt|;
if|if
condition|(
name|cpr
operator|>
literal|0
condition|)
name|ntmp
operator|->
name|ntm_bpmftrec
operator|=
name|ntmp
operator|->
name|ntm_spc
operator|*
name|cpr
expr_stmt|;
else|else
name|ntmp
operator|->
name|ntm_bpmftrec
operator|=
operator|(
literal|1
operator|<<
operator|(
operator|-
name|cpr
operator|)
operator|)
operator|/
name|ntmp
operator|->
name|ntm_bps
expr_stmt|;
block|}
name|dprintf
argument_list|(
operator|(
literal|"ntfs_mountfs(): bps: %d, spc: %d, media: %x, mftrecsz: %d (%d sects)\n"
operator|,
name|ntmp
operator|->
name|ntm_bps
operator|,
name|ntmp
operator|->
name|ntm_spc
operator|,
name|ntmp
operator|->
name|ntm_bootfile
operator|.
name|bf_media
operator|,
name|ntmp
operator|->
name|ntm_mftrecsz
operator|,
name|ntmp
operator|->
name|ntm_bpmftrec
operator|)
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"ntfs_mountfs(): mftcn: 0x%x|0x%x\n"
operator|,
operator|(
name|u_int32_t
operator|)
name|ntmp
operator|->
name|ntm_mftcn
operator|,
operator|(
name|u_int32_t
operator|)
name|ntmp
operator|->
name|ntm_mftmirrcn
operator|)
argument_list|)
expr_stmt|;
name|ntmp
operator|->
name|ntm_mountp
operator|=
name|mp
expr_stmt|;
name|ntmp
operator|->
name|ntm_devvp
operator|=
name|devvp
expr_stmt|;
name|ntmp
operator|->
name|ntm_uid
operator|=
name|argsp
operator|->
name|uid
expr_stmt|;
name|ntmp
operator|->
name|ntm_gid
operator|=
name|argsp
operator|->
name|gid
expr_stmt|;
name|ntmp
operator|->
name|ntm_mode
operator|=
name|argsp
operator|->
name|mode
expr_stmt|;
name|ntmp
operator|->
name|ntm_flag
operator|=
name|argsp
operator|->
name|flag
expr_stmt|;
name|ntmp
operator|->
name|ntm_cp
operator|=
name|cp
expr_stmt|;
name|ntmp
operator|->
name|ntm_bo
operator|=
operator|&
name|devvp
operator|->
name|v_bufobj
expr_stmt|;
comment|/* Copy in the 8-bit to Unicode conversion table */
comment|/* Initialize Unicode to 8-bit table from 8toU table */
if|if
condition|(
name|argsp
operator|->
name|flag
operator|&
name|NTFS_MFLAG_KICONV
condition|)
block|{
name|ntfs_82u_init
argument_list|(
name|ntmp
argument_list|,
name|argsp
operator|->
name|cs_local
argument_list|,
name|argsp
operator|->
name|cs_ntfs
argument_list|)
expr_stmt|;
name|ntfs_u28_init
argument_list|(
name|ntmp
argument_list|,
name|NULL
argument_list|,
name|argsp
operator|->
name|cs_local
argument_list|,
name|argsp
operator|->
name|cs_ntfs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ntfs_82u_init
argument_list|(
name|ntmp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ntfs_u28_init
argument_list|(
name|ntmp
argument_list|,
name|ntmp
operator|->
name|ntm_82u
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|mp
operator|->
name|mnt_data
operator|=
operator|(
name|qaddr_t
operator|)
name|ntmp
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"ntfs_mountfs(): case-%s,%s uid: %d, gid: %d, mode: %o\n"
operator|,
operator|(
name|ntmp
operator|->
name|ntm_flag
operator|&
name|NTFS_MFLAG_CASEINS
operator|)
condition|?
literal|"insens."
else|:
literal|"sens."
operator|,
operator|(
name|ntmp
operator|->
name|ntm_flag
operator|&
name|NTFS_MFLAG_ALLNAMES
operator|)
condition|?
literal|" allnames,"
else|:
literal|""
operator|,
name|ntmp
operator|->
name|ntm_uid
operator|,
name|ntmp
operator|->
name|ntm_gid
operator|,
name|ntmp
operator|->
name|ntm_mode
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * We read in some system nodes to do not allow  	 * reclaim them and to have everytime access to them. 	 */
block|{
name|int
name|pi
index|[
literal|3
index|]
init|=
block|{
name|NTFS_MFTINO
block|,
name|NTFS_ROOTINO
block|,
name|NTFS_BITMAPINO
block|}
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|error
operator|=
name|VFS_VGET
argument_list|(
name|mp
argument_list|,
name|pi
index|[
name|i
index|]
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
operator|&
operator|(
name|ntmp
operator|->
name|ntm_sysvn
index|[
name|pi
index|[
name|i
index|]
index|]
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out1
goto|;
name|ntmp
operator|->
name|ntm_sysvn
index|[
name|pi
index|[
name|i
index|]
index|]
operator|->
name|v_vflag
operator||=
name|VV_SYSTEM
expr_stmt|;
name|VREF
argument_list|(
name|ntmp
operator|->
name|ntm_sysvn
index|[
name|pi
index|[
name|i
index|]
index|]
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|ntmp
operator|->
name|ntm_sysvn
index|[
name|pi
index|[
name|i
index|]
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* read the Unicode lowercase --> uppercase translation table, 	 * if necessary */
if|if
condition|(
operator|(
name|error
operator|=
name|ntfs_toupper_use
argument_list|(
name|mp
argument_list|,
name|ntmp
argument_list|)
operator|)
condition|)
goto|goto
name|out1
goto|;
comment|/* 	 * Scan $BitMap and count free clusters 	 */
name|error
operator|=
name|ntfs_calccfree
argument_list|(
name|ntmp
argument_list|,
operator|&
name|ntmp
operator|->
name|ntm_cfree
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out1
goto|;
comment|/* 	 * Read and translate to internal format attribute 	 * definition file.  	 */
block|{
name|int
name|num
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|attrdef
name|ad
decl_stmt|;
comment|/* Open $AttrDef */
name|error
operator|=
name|VFS_VGET
argument_list|(
name|mp
argument_list|,
name|NTFS_ATTRDEFINO
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
operator|&
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out1
goto|;
comment|/* Count valid entries */
for|for
control|(
name|num
operator|=
literal|0
init|;
condition|;
name|num
operator|++
control|)
block|{
name|error
operator|=
name|ntfs_readattr
argument_list|(
name|ntmp
argument_list|,
name|VTONT
argument_list|(
name|vp
argument_list|)
argument_list|,
name|NTFS_A_DATA
argument_list|,
name|NULL
argument_list|,
name|num
operator|*
sizeof|sizeof
argument_list|(
name|ad
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|ad
argument_list|)
argument_list|,
operator|&
name|ad
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out1
goto|;
if|if
condition|(
name|ad
operator|.
name|ad_name
index|[
literal|0
index|]
operator|==
literal|0
condition|)
break|break;
block|}
comment|/* Alloc memory for attribute definitions */
name|MALLOC
argument_list|(
name|ntmp
operator|->
name|ntm_ad
argument_list|,
expr|struct
name|ntvattrdef
operator|*
argument_list|,
name|num
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ntvattrdef
argument_list|)
argument_list|,
name|M_NTFSMNT
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|ntmp
operator|->
name|ntm_adnum
operator|=
name|num
expr_stmt|;
comment|/* Read them and translate */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|error
operator|=
name|ntfs_readattr
argument_list|(
name|ntmp
argument_list|,
name|VTONT
argument_list|(
name|vp
argument_list|)
argument_list|,
name|NTFS_A_DATA
argument_list|,
name|NULL
argument_list|,
name|i
operator|*
sizeof|sizeof
argument_list|(
name|ad
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|ad
argument_list|)
argument_list|,
operator|&
name|ad
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out1
goto|;
name|j
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|ntmp
operator|->
name|ntm_ad
index|[
name|i
index|]
operator|.
name|ad_name
index|[
name|j
index|]
operator|=
name|ad
operator|.
name|ad_name
index|[
name|j
index|]
expr_stmt|;
block|}
do|while
condition|(
name|ad
operator|.
name|ad_name
index|[
name|j
operator|++
index|]
condition|)
do|;
name|ntmp
operator|->
name|ntm_ad
index|[
name|i
index|]
operator|.
name|ad_namelen
operator|=
name|j
operator|-
literal|1
expr_stmt|;
name|ntmp
operator|->
name|ntm_ad
index|[
name|i
index|]
operator|.
name|ad_type
operator|=
name|ad
operator|.
name|ad_type
expr_stmt|;
block|}
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
name|mp
operator|->
name|mnt_stat
operator|.
name|f_fsid
operator|.
name|val
index|[
literal|0
index|]
operator|=
name|dev2udev
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mp
operator|->
name|mnt_stat
operator|.
name|f_fsid
operator|.
name|val
index|[
literal|1
index|]
operator|=
name|mp
operator|->
name|mnt_vfc
operator|->
name|vfc_typenum
expr_stmt|;
name|mp
operator|->
name|mnt_maxsymlinklen
operator|=
literal|0
expr_stmt|;
name|mp
operator|->
name|mnt_flag
operator||=
name|MNT_LOCAL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|out1
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTFS_SYSNODESNUM
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ntmp
operator|->
name|ntm_sysvn
index|[
name|i
index|]
condition|)
name|vrele
argument_list|(
name|ntmp
operator|->
name|ntm_sysvn
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|vflush
argument_list|(
name|mp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
condition|)
name|dprintf
argument_list|(
operator|(
literal|"ntfs_mountfs: vflush failed\n"
operator|)
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|bp
condition|)
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|DROP_GIANT
argument_list|()
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
name|g_wither_geom_close
argument_list|(
name|cp
operator|->
name|geom
argument_list|,
name|ENXIO
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|PICKUP_GIANT
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntfs_unmount
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|int
name|mntflags
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|ntfsmount
modifier|*
name|ntmp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|flags
decl_stmt|,
name|i
decl_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"ntfs_unmount: unmounting...\n"
operator|)
argument_list|)
expr_stmt|;
name|ntmp
operator|=
name|VFSTONTFS
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mntflags
operator|&
name|MNT_FORCE
condition|)
name|flags
operator||=
name|FORCECLOSE
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"ntfs_unmount: vflushing...\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|vflush
argument_list|(
name|mp
argument_list|,
literal|0
argument_list|,
name|flags
operator||
name|SKIPSYSTEM
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"ntfs_unmount: vflush failed: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Check if only system vnodes are rest */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTFS_SYSNODESNUM
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|ntmp
operator|->
name|ntm_sysvn
index|[
name|i
index|]
operator|)
operator|&&
operator|(
name|vrefcnt
argument_list|(
name|ntmp
operator|->
name|ntm_sysvn
index|[
name|i
index|]
argument_list|)
operator|>
literal|1
operator|)
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
comment|/* Dereference all system vnodes */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTFS_SYSNODESNUM
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ntmp
operator|->
name|ntm_sysvn
index|[
name|i
index|]
condition|)
name|vrele
argument_list|(
name|ntmp
operator|->
name|ntm_sysvn
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* vflush system vnodes */
name|error
operator|=
name|vflush
argument_list|(
name|mp
argument_list|,
literal|0
argument_list|,
name|flags
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|printf
argument_list|(
literal|"ntfs_unmount: vflush failed(sysnodes): %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|vinvalbuf
argument_list|(
name|ntmp
operator|->
name|ntm_devvp
argument_list|,
name|V_SAVE
argument_list|,
name|NOCRED
argument_list|,
name|td
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DROP_GIANT
argument_list|()
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
name|g_wither_geom_close
argument_list|(
name|ntmp
operator|->
name|ntm_cp
operator|->
name|geom
argument_list|,
name|ENXIO
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|PICKUP_GIANT
argument_list|()
expr_stmt|;
name|vrele
argument_list|(
name|ntmp
operator|->
name|ntm_devvp
argument_list|)
expr_stmt|;
comment|/* free the toupper table, if this has been last mounted ntfs volume */
name|ntfs_toupper_unuse
argument_list|()
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"ntfs_umount: freeing memory...\n"
operator|)
argument_list|)
expr_stmt|;
name|ntfs_u28_uninit
argument_list|(
name|ntmp
argument_list|)
expr_stmt|;
name|ntfs_82u_uninit
argument_list|(
name|ntmp
argument_list|)
expr_stmt|;
name|mp
operator|->
name|mnt_data
operator|=
operator|(
name|qaddr_t
operator|)
literal|0
expr_stmt|;
name|mp
operator|->
name|mnt_flag
operator|&=
operator|~
name|MNT_LOCAL
expr_stmt|;
name|FREE
argument_list|(
name|ntmp
operator|->
name|ntm_ad
argument_list|,
name|M_NTFSMNT
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|ntmp
argument_list|,
name|M_NTFSMNT
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntfs_root
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|nvp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"ntfs_root(): sysvn: %p\n"
operator|,
name|VFSTONTFS
argument_list|(
name|mp
argument_list|)
operator|->
name|ntm_sysvn
index|[
name|NTFS_ROOTINO
index|]
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|VFS_VGET
argument_list|(
name|mp
argument_list|,
operator|(
name|ino_t
operator|)
name|NTFS_ROOTINO
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
operator|&
name|nvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"ntfs_root: VFS_VGET failed: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
operator|*
name|vpp
operator|=
name|nvp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ntfs_calccfree
parameter_list|(
name|struct
name|ntfsmount
modifier|*
name|ntmp
parameter_list|,
name|cn_t
modifier|*
name|cfreep
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|u_int8_t
modifier|*
name|tmp
decl_stmt|;
name|int
name|j
decl_stmt|,
name|error
decl_stmt|;
name|long
name|cfree
init|=
literal|0
decl_stmt|;
name|size_t
name|bmsize
decl_stmt|,
name|i
decl_stmt|;
name|vp
operator|=
name|ntmp
operator|->
name|ntm_sysvn
index|[
name|NTFS_BITMAPINO
index|]
expr_stmt|;
name|bmsize
operator|=
name|VTOF
argument_list|(
name|vp
argument_list|)
operator|->
name|f_size
expr_stmt|;
name|MALLOC
argument_list|(
name|tmp
argument_list|,
name|u_int8_t
operator|*
argument_list|,
name|bmsize
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|error
operator|=
name|ntfs_readattr
argument_list|(
name|ntmp
argument_list|,
name|VTONT
argument_list|(
name|vp
argument_list|)
argument_list|,
name|NTFS_A_DATA
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|bmsize
argument_list|,
name|tmp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bmsize
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|8
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|~
name|tmp
index|[
name|i
index|]
operator|&
operator|(
literal|1
operator|<<
name|j
operator|)
condition|)
name|cfree
operator|++
expr_stmt|;
operator|*
name|cfreep
operator|=
name|cfree
expr_stmt|;
name|out
label|:
name|FREE
argument_list|(
name|tmp
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntfs_statfs
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|struct
name|statfs
modifier|*
name|sbp
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|ntfsmount
modifier|*
name|ntmp
init|=
name|VFSTONTFS
argument_list|(
name|mp
argument_list|)
decl_stmt|;
name|u_int64_t
name|mftsize
decl_stmt|,
name|mftallocated
decl_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"ntfs_statfs():\n"
operator|)
argument_list|)
expr_stmt|;
name|mftsize
operator|=
name|VTOF
argument_list|(
name|ntmp
operator|->
name|ntm_sysvn
index|[
name|NTFS_MFTINO
index|]
argument_list|)
operator|->
name|f_size
expr_stmt|;
name|mftallocated
operator|=
name|VTOF
argument_list|(
name|ntmp
operator|->
name|ntm_sysvn
index|[
name|NTFS_MFTINO
index|]
argument_list|)
operator|->
name|f_allocated
expr_stmt|;
name|sbp
operator|->
name|f_type
operator|=
name|mp
operator|->
name|mnt_vfc
operator|->
name|vfc_typenum
expr_stmt|;
name|sbp
operator|->
name|f_bsize
operator|=
name|ntmp
operator|->
name|ntm_bps
expr_stmt|;
name|sbp
operator|->
name|f_iosize
operator|=
name|ntmp
operator|->
name|ntm_bps
operator|*
name|ntmp
operator|->
name|ntm_spc
expr_stmt|;
name|sbp
operator|->
name|f_blocks
operator|=
name|ntmp
operator|->
name|ntm_bootfile
operator|.
name|bf_spv
expr_stmt|;
name|sbp
operator|->
name|f_bfree
operator|=
name|sbp
operator|->
name|f_bavail
operator|=
name|ntfs_cntobn
argument_list|(
name|ntmp
operator|->
name|ntm_cfree
argument_list|)
expr_stmt|;
name|sbp
operator|->
name|f_ffree
operator|=
name|sbp
operator|->
name|f_bfree
operator|/
name|ntmp
operator|->
name|ntm_bpmftrec
expr_stmt|;
name|sbp
operator|->
name|f_files
operator|=
name|mftallocated
operator|/
name|ntfs_bntob
argument_list|(
name|ntmp
operator|->
name|ntm_bpmftrec
argument_list|)
operator|+
name|sbp
operator|->
name|f_ffree
expr_stmt|;
if|if
condition|(
name|sbp
operator|!=
operator|&
name|mp
operator|->
name|mnt_stat
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|mp
operator|->
name|mnt_stat
operator|.
name|f_mntonname
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|sbp
operator|->
name|f_mntonname
index|[
literal|0
index|]
argument_list|,
name|MNAMELEN
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|mp
operator|->
name|mnt_stat
operator|.
name|f_mntfromname
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|sbp
operator|->
name|f_mntfromname
index|[
literal|0
index|]
argument_list|,
name|MNAMELEN
argument_list|)
expr_stmt|;
block|}
name|sbp
operator|->
name|f_flags
operator|=
name|mp
operator|->
name|mnt_flag
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|ntfs_fhtovp
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|struct
name|fid
modifier|*
name|fhp
parameter_list|,
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|nvp
decl_stmt|;
name|struct
name|ntfid
modifier|*
name|ntfhp
init|=
operator|(
expr|struct
name|ntfid
operator|*
operator|)
name|fhp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ddprintf
argument_list|(
operator|(
literal|"ntfs_fhtovp(): %d\n"
operator|,
name|ntfhp
operator|->
name|ntfid_ino
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|VFS_VGET
argument_list|(
name|mp
argument_list|,
name|ntfhp
operator|->
name|ntfid_ino
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
operator|&
name|nvp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|vpp
operator|=
name|NULLVP
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* XXX as unlink/rmdir/mkdir/creat are not currently possible 	 * with NTFS, we don't need to check anything else for now */
operator|*
name|vpp
operator|=
name|nvp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntfs_vptofh
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|struct
name|fid
modifier|*
name|fhp
parameter_list|)
block|{
specifier|register
name|struct
name|ntnode
modifier|*
name|ntp
decl_stmt|;
specifier|register
name|struct
name|ntfid
modifier|*
name|ntfhp
decl_stmt|;
name|ddprintf
argument_list|(
operator|(
literal|"ntfs_fhtovp(): %p\n"
operator|,
name|vp
operator|)
argument_list|)
expr_stmt|;
name|ntp
operator|=
name|VTONT
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|ntfhp
operator|=
operator|(
expr|struct
name|ntfid
operator|*
operator|)
name|fhp
expr_stmt|;
name|ntfhp
operator|->
name|ntfid_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ntfid
argument_list|)
expr_stmt|;
name|ntfhp
operator|->
name|ntfid_ino
operator|=
name|ntp
operator|->
name|i_number
expr_stmt|;
comment|/* ntfhp->ntfid_gen = ntp->i_gen; */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ntfs_vgetex
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|ino_t
name|ino
parameter_list|,
name|u_int32_t
name|attrtype
parameter_list|,
name|char
modifier|*
name|attrname
parameter_list|,
name|u_long
name|lkflags
parameter_list|,
name|u_long
name|flags
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
specifier|register
name|struct
name|ntfsmount
modifier|*
name|ntmp
decl_stmt|;
name|struct
name|ntnode
modifier|*
name|ip
decl_stmt|;
name|struct
name|fnode
modifier|*
name|fp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|enum
name|vtype
name|f_type
decl_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"ntfs_vgetex: ino: %d, attr: 0x%x:%s, lkf: 0x%lx, f: 0x%lx\n"
operator|,
name|ino
operator|,
name|attrtype
operator|,
name|attrname
condition|?
name|attrname
else|:
literal|""
operator|,
operator|(
name|u_long
operator|)
name|lkflags
operator|,
operator|(
name|u_long
operator|)
name|flags
operator|)
argument_list|)
expr_stmt|;
name|ntmp
operator|=
name|VFSTONTFS
argument_list|(
name|mp
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|NULL
expr_stmt|;
comment|/* Get ntnode */
name|error
operator|=
name|ntfs_ntlookup
argument_list|(
name|ntmp
argument_list|,
name|ino
argument_list|,
operator|&
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"ntfs_vget: ntfs_ntget failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* It may be not initialized fully, so force load it */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|VG_DONTLOADIN
operator|)
operator|&&
operator|!
operator|(
name|ip
operator|->
name|i_flag
operator|&
name|IN_LOADED
operator|)
condition|)
block|{
name|error
operator|=
name|ntfs_loadntnode
argument_list|(
name|ntmp
argument_list|,
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"ntfs_vget: CAN'T LOAD ATTRIBUTES FOR INO: %d\n"
argument_list|,
name|ip
operator|->
name|i_number
argument_list|)
expr_stmt|;
name|ntfs_ntput
argument_list|(
name|ip
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
name|error
operator|=
name|ntfs_fget
argument_list|(
name|ntmp
argument_list|,
name|ip
argument_list|,
name|attrtype
argument_list|,
name|attrname
argument_list|,
operator|&
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"ntfs_vget: ntfs_fget failed\n"
argument_list|)
expr_stmt|;
name|ntfs_ntput
argument_list|(
name|ip
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|f_type
operator|=
name|VNON
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|VG_DONTVALIDFN
operator|)
operator|&&
operator|!
operator|(
name|fp
operator|->
name|f_flag
operator|&
name|FN_VALID
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|ip
operator|->
name|i_frflag
operator|&
name|NTFS_FRFLAG_DIR
operator|)
operator|&&
operator|(
name|fp
operator|->
name|f_attrtype
operator|==
name|NTFS_A_DATA
operator|&&
name|fp
operator|->
name|f_attrname
operator|==
name|NULL
operator|)
condition|)
block|{
name|f_type
operator|=
name|VDIR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|VG_EXT
condition|)
block|{
name|f_type
operator|=
name|VNON
expr_stmt|;
name|fp
operator|->
name|f_size
operator|=
name|fp
operator|->
name|f_allocated
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|f_type
operator|=
name|VREG
expr_stmt|;
name|error
operator|=
name|ntfs_filesize
argument_list|(
name|ntmp
argument_list|,
name|fp
argument_list|,
operator|&
name|fp
operator|->
name|f_size
argument_list|,
operator|&
name|fp
operator|->
name|f_allocated
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|ntfs_ntput
argument_list|(
name|ip
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
name|fp
operator|->
name|f_flag
operator||=
name|FN_VALID
expr_stmt|;
block|}
if|if
condition|(
name|FTOV
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|vget
argument_list|(
name|FTOV
argument_list|(
name|fp
argument_list|)
argument_list|,
name|lkflags
argument_list|,
name|td
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|FTOV
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|ntfs_ntput
argument_list|(
name|ip
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|error
operator|=
name|getnewvnode
argument_list|(
literal|"ntfs"
argument_list|,
name|ntmp
operator|->
name|ntm_mountp
argument_list|,
name|ntfs_vnodeop_p
argument_list|,
operator|&
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|ntfs_frele
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|ntfs_ntput
argument_list|(
name|ip
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|dprintf
argument_list|(
operator|(
literal|"ntfs_vget: vnode: %p for ntnode: %d\n"
operator|,
name|vp
operator|,
name|ino
operator|)
argument_list|)
expr_stmt|;
name|fp
operator|->
name|f_vp
operator|=
name|vp
expr_stmt|;
name|vp
operator|->
name|v_data
operator|=
name|fp
expr_stmt|;
name|vp
operator|->
name|v_type
operator|=
name|f_type
expr_stmt|;
if|if
condition|(
name|ino
operator|==
name|NTFS_ROOTINO
condition|)
name|vp
operator|->
name|v_vflag
operator||=
name|VV_ROOT
expr_stmt|;
name|ntfs_ntput
argument_list|(
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
name|lkflags
operator|&
name|LK_TYPE_MASK
condition|)
block|{
name|error
operator|=
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|lkflags
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
operator|*
name|vpp
operator|=
name|vp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntfs_vget
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|ino_t
name|ino
parameter_list|,
name|int
name|lkflags
parameter_list|,
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
parameter_list|)
block|{
return|return
name|ntfs_vgetex
argument_list|(
name|mp
argument_list|,
name|ino
argument_list|,
name|NTFS_A_DATA
argument_list|,
name|NULL
argument_list|,
name|lkflags
argument_list|,
literal|0
argument_list|,
name|curthread
argument_list|,
name|vpp
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|vfsops
name|ntfs_vfsops
init|=
block|{
operator|.
name|vfs_fhtovp
operator|=
name|ntfs_fhtovp
block|,
operator|.
name|vfs_init
operator|=
name|ntfs_init
block|,
operator|.
name|vfs_omount
operator|=
name|ntfs_omount
block|,
operator|.
name|vfs_root
operator|=
name|ntfs_root
block|,
operator|.
name|vfs_statfs
operator|=
name|ntfs_statfs
block|,
operator|.
name|vfs_uninit
operator|=
name|ntfs_uninit
block|,
operator|.
name|vfs_unmount
operator|=
name|ntfs_unmount
block|,
operator|.
name|vfs_vget
operator|=
name|ntfs_vget
block|,
operator|.
name|vfs_vptofh
operator|=
name|ntfs_vptofh
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|VFS_SET
argument_list|(
name|ntfs_vfsops
argument_list|,
name|ntfs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|ntfs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

