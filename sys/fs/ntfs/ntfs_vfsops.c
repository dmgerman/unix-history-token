begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: ntfs_vfsops.c,v 1.23 1999/11/15 19:38:14 jdolecek Exp $	*/
end_comment

begin_comment
comment|/*-  * Copyright (c) 1998, 1999 Semen Ustimenko  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<geom/geom.h>
end_include

begin_include
include|#
directive|include
file|<geom/geom_vfs.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_comment
comment|/*#define NTFS_DEBUG 1*/
end_comment

begin_include
include|#
directive|include
file|<fs/ntfs/ntfs.h>
end_include

begin_include
include|#
directive|include
file|<fs/ntfs/ntfs_inode.h>
end_include

begin_include
include|#
directive|include
file|<fs/ntfs/ntfs_subr.h>
end_include

begin_include
include|#
directive|include
file|<fs/ntfs/ntfs_vfsops.h>
end_include

begin_include
include|#
directive|include
file|<fs/ntfs/ntfs_ihash.h>
end_include

begin_include
include|#
directive|include
file|<fs/ntfs/ntfsmount.h>
end_include

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_NTFSMNT
argument_list|,
literal|"ntfs_mount"
argument_list|,
literal|"NTFS mount structure"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_NTFSNTNODE
argument_list|,
literal|"ntfs_ntnode"
argument_list|,
literal|"NTFS ntnode information"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_NTFSFNODE
argument_list|,
literal|"ntfs_fnode"
argument_list|,
literal|"NTFS fnode information"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_NTFSDIR
argument_list|,
literal|"ntfs_dir"
argument_list|,
literal|"NTFS dir buffer"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct_decl
struct_decl|struct
name|sockaddr
struct_decl|;
end_struct_decl

begin_function_decl
specifier|static
name|int
name|ntfs_mountfs
parameter_list|(
specifier|register
name|struct
name|vnode
modifier|*
parameter_list|,
name|struct
name|mount
modifier|*
parameter_list|,
name|struct
name|thread
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ntfs_calccfree
parameter_list|(
name|struct
name|ntfsmount
modifier|*
name|ntmp
parameter_list|,
name|cn_t
modifier|*
name|cfreep
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|vfs_init_t
name|ntfs_init
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vfs_uninit_t
name|ntfs_uninit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vfs_vget_t
name|ntfs_vget
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vfs_fhtovp_t
name|ntfs_fhtovp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vfs_cmount_t
name|ntfs_cmount
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vfs_mount_t
name|ntfs_mount
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vfs_root_t
name|ntfs_root
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vfs_statfs_t
name|ntfs_statfs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vfs_unmount_t
name|ntfs_unmount
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|b_strategy_t
name|ntfs_bufstrategy
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   * Buffer operations for NTFS vnodes.  * We punt on VOP_BMAP, so we need to do  * strategy on the file's vnode rather  * than the underlying device's  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|buf_ops
name|ntfs_vnbufops
init|=
block|{
operator|.
name|bop_name
operator|=
literal|"NTFS"
block|,
operator|.
name|bop_strategy
operator|=
name|ntfs_bufstrategy
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|ntfs_init
parameter_list|(
name|struct
name|vfsconf
modifier|*
name|vcp
parameter_list|)
block|{
name|ntfs_nthashinit
argument_list|()
expr_stmt|;
name|ntfs_toupper_init
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntfs_uninit
parameter_list|(
name|struct
name|vfsconf
modifier|*
name|vcp
parameter_list|)
block|{
name|ntfs_toupper_destroy
argument_list|()
expr_stmt|;
name|ntfs_nthashdestroy
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntfs_cmount
parameter_list|(
name|struct
name|mntarg
modifier|*
name|ma
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|ntfs_args
name|args
decl_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|data
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|args
argument_list|,
sizeof|sizeof
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|ma
operator|=
name|mount_argsu
argument_list|(
name|ma
argument_list|,
literal|"from"
argument_list|,
name|args
operator|.
name|fspec
argument_list|,
name|MAXPATHLEN
argument_list|)
expr_stmt|;
name|ma
operator|=
name|mount_arg
argument_list|(
name|ma
argument_list|,
literal|"export"
argument_list|,
operator|&
name|args
operator|.
name|export
argument_list|,
sizeof|sizeof
name|args
operator|.
name|export
argument_list|)
expr_stmt|;
name|ma
operator|=
name|mount_argf
argument_list|(
name|ma
argument_list|,
literal|"uid"
argument_list|,
literal|"%d"
argument_list|,
name|args
operator|.
name|uid
argument_list|)
expr_stmt|;
name|ma
operator|=
name|mount_argf
argument_list|(
name|ma
argument_list|,
literal|"gid"
argument_list|,
literal|"%d"
argument_list|,
name|args
operator|.
name|gid
argument_list|)
expr_stmt|;
name|ma
operator|=
name|mount_argf
argument_list|(
name|ma
argument_list|,
literal|"mode"
argument_list|,
literal|"%d"
argument_list|,
name|args
operator|.
name|mode
argument_list|)
expr_stmt|;
name|ma
operator|=
name|mount_argb
argument_list|(
name|ma
argument_list|,
name|args
operator|.
name|flag
operator|&
name|NTFS_MFLAG_CASEINS
argument_list|,
literal|"nocaseins"
argument_list|)
expr_stmt|;
name|ma
operator|=
name|mount_argb
argument_list|(
name|ma
argument_list|,
name|args
operator|.
name|flag
operator|&
name|NTFS_MFLAG_ALLNAMES
argument_list|,
literal|"noallnames"
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|.
name|flag
operator|&
name|NTFS_MFLAG_KICONV
condition|)
block|{
name|ma
operator|=
name|mount_argsu
argument_list|(
name|ma
argument_list|,
literal|"cs_ntfs"
argument_list|,
name|args
operator|.
name|cs_ntfs
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|ma
operator|=
name|mount_argsu
argument_list|(
name|ma
argument_list|,
literal|"cs_local"
argument_list|,
name|args
operator|.
name|cs_local
argument_list|,
literal|64
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|kernel_mount
argument_list|(
name|ma
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|ntfs_opts
index|[]
init|=
block|{
literal|"from"
block|,
literal|"export"
block|,
literal|"uid"
block|,
literal|"gid"
block|,
literal|"mode"
block|,
literal|"caseins"
block|,
literal|"allnames"
block|,
literal|"kiconv"
block|,
literal|"cs_ntfs"
block|,
literal|"cs_local"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|ntfs_mount
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|err
init|=
literal|0
decl_stmt|,
name|error
decl_stmt|;
name|struct
name|vnode
modifier|*
name|devvp
decl_stmt|;
name|struct
name|nameidata
name|ndp
decl_stmt|;
name|char
modifier|*
name|from
decl_stmt|;
if|if
condition|(
name|vfs_filteropt
argument_list|(
name|mp
operator|->
name|mnt_optnew
argument_list|,
name|ntfs_opts
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|from
operator|=
name|vfs_getopts
argument_list|(
name|mp
operator|->
name|mnt_optnew
argument_list|,
literal|"from"
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * If updating, check whether changing from read-only to 	 * read/write. 	 */
if|if
condition|(
name|mp
operator|->
name|mnt_flag
operator|&
name|MNT_UPDATE
condition|)
block|{
if|if
condition|(
name|vfs_flagopt
argument_list|(
name|mp
operator|->
name|mnt_optnew
argument_list|,
literal|"export"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* Process export requests in vfs_mount.c */
goto|goto
name|success
goto|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"ntfs_mount(): MNT_UPDATE not supported\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|error_1
goto|;
block|}
block|}
comment|/* 	 * Not an update, or updating the name: look up the name 	 * and verify that it refers to a sensible block device. 	 */
name|NDINIT
argument_list|(
operator|&
name|ndp
argument_list|,
name|LOOKUP
argument_list|,
name|FOLLOW
operator||
name|LOCKLEAF
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|from
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|err
operator|=
name|namei
argument_list|(
operator|&
name|ndp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
comment|/* can't get devvp!*/
goto|goto
name|error_1
goto|;
block|}
name|NDFREE
argument_list|(
operator|&
name|ndp
argument_list|,
name|NDF_ONLY_PNBUF
argument_list|)
expr_stmt|;
name|devvp
operator|=
name|ndp
operator|.
name|ni_vp
expr_stmt|;
if|if
condition|(
operator|!
name|vn_isdisk
argument_list|(
name|devvp
argument_list|,
operator|&
name|err
argument_list|)
condition|)
block|{
name|vput
argument_list|(
name|devvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
if|if
condition|(
name|mp
operator|->
name|mnt_flag
operator|&
name|MNT_UPDATE
condition|)
block|{
if|#
directive|if
literal|0
comment|/* 		 ******************** 		 * UPDATE 		 ******************** 		 */
block|if (devvp != ntmp->um_devvp) 			err = EINVAL;
comment|/* needs translation */
block|vput(devvp); 		if (err) 			return (err);
endif|#
directive|endif
block|}
else|else
block|{
comment|/* 		 ******************** 		 * NEW MOUNT 		 ******************** 		 */
comment|/* 		 * Since this is a new mount, we want the names for 		 * the device and the mount point copied in.  If an 		 * error occurs, the mountpoint is discarded by the 		 * upper level code.  Note that vfs_mount() handles 		 * copying the mountpoint f_mntonname for us, so we 		 * don't have to do it here unless we want to set it 		 * to something other than "path" for some rason. 		 */
comment|/* Save "mounted from" info for mount point (NULL pad)*/
name|vfs_mountedfrom
argument_list|(
name|mp
argument_list|,
name|from
argument_list|)
expr_stmt|;
name|err
operator|=
name|ntfs_mountfs
argument_list|(
name|devvp
argument_list|,
name|mp
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
block|{
name|vrele
argument_list|(
name|devvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
goto|goto
name|success
goto|;
name|error_1
label|:
comment|/* no state to back out*/
comment|/* XXX: missing NDFREE(&ndp, ...) */
name|success
label|:
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Common code for mount and mountroot  */
end_comment

begin_function
name|int
name|ntfs_mountfs
parameter_list|(
name|devvp
parameter_list|,
name|mp
parameter_list|,
name|td
parameter_list|)
specifier|register
name|struct
name|vnode
modifier|*
name|devvp
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|ntfsmount
modifier|*
name|ntmp
decl_stmt|;
name|struct
name|cdev
modifier|*
name|dev
init|=
name|devvp
operator|->
name|v_rdev
decl_stmt|;
name|int
name|error
decl_stmt|,
name|ronly
decl_stmt|,
name|i
decl_stmt|,
name|v
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|char
modifier|*
name|cs_ntfs
decl_stmt|,
modifier|*
name|cs_local
decl_stmt|;
name|ronly
operator|=
operator|(
name|mp
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
operator|)
operator|!=
literal|0
expr_stmt|;
name|DROP_GIANT
argument_list|()
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
comment|/* 	 * XXX: Do not allow more than one consumer to open a device 	 *      associated with a particular GEOM provider. 	 *      This disables multiple read-only mounts of a device, 	 *      but it gets rid of panics in vget() when you try to 	 *      mount the same device more than once. 	 */
name|pp
operator|=
name|g_dev_getprovider
argument_list|(
name|devvp
operator|->
name|v_rdev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pp
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|pp
operator|->
name|acr
operator||
name|pp
operator|->
name|acw
operator||
name|pp
operator|->
name|ace
operator|)
operator|!=
literal|0
operator|)
condition|)
name|error
operator|=
name|EPERM
expr_stmt|;
else|else
name|error
operator|=
name|g_vfs_open
argument_list|(
name|devvp
argument_list|,
operator|&
name|cp
argument_list|,
literal|"ntfs"
argument_list|,
name|ronly
condition|?
literal|0
else|:
literal|1
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|PICKUP_GIANT
argument_list|()
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|devvp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|bp
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|bread
argument_list|(
name|devvp
argument_list|,
name|BBLOCK
argument_list|,
name|BBSIZE
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|ntmp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|ntmp
argument_list|,
name|M_NTFSMNT
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|bp
operator|->
name|b_data
argument_list|,
operator|&
name|ntmp
operator|->
name|ntm_bootfile
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bootfile
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * We must not cache the boot block if its size is not exactly 	 * one cluster in order to avoid confusing the buffer cache when 	 * the boot file is read later by ntfs_readntvattr_plain(), which 	 * reads a cluster at a time. 	 */
if|if
condition|(
name|ntfs_cntob
argument_list|(
literal|1
argument_list|)
operator|!=
name|BBSIZE
condition|)
name|bp
operator|->
name|b_flags
operator||=
name|B_NOCACHE
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|ntmp
operator|->
name|ntm_bootfile
operator|.
name|bf_sysid
argument_list|,
name|NTFS_BBID
argument_list|,
name|NTFS_BBIDLEN
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"ntfs_mountfs: invalid boot block\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|{
name|int8_t
name|cpr
init|=
name|ntmp
operator|->
name|ntm_mftrecsz
decl_stmt|;
if|if
condition|(
name|cpr
operator|>
literal|0
condition|)
name|ntmp
operator|->
name|ntm_bpmftrec
operator|=
name|ntmp
operator|->
name|ntm_spc
operator|*
name|cpr
expr_stmt|;
else|else
name|ntmp
operator|->
name|ntm_bpmftrec
operator|=
operator|(
literal|1
operator|<<
operator|(
operator|-
name|cpr
operator|)
operator|)
operator|/
name|ntmp
operator|->
name|ntm_bps
expr_stmt|;
block|}
name|dprintf
argument_list|(
operator|(
literal|"ntfs_mountfs(): bps: %d, spc: %d, media: %x, mftrecsz: %d (%d sects)\n"
operator|,
name|ntmp
operator|->
name|ntm_bps
operator|,
name|ntmp
operator|->
name|ntm_spc
operator|,
name|ntmp
operator|->
name|ntm_bootfile
operator|.
name|bf_media
operator|,
name|ntmp
operator|->
name|ntm_mftrecsz
operator|,
name|ntmp
operator|->
name|ntm_bpmftrec
operator|)
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"ntfs_mountfs(): mftcn: 0x%x|0x%x\n"
operator|,
operator|(
name|u_int32_t
operator|)
name|ntmp
operator|->
name|ntm_mftcn
operator|,
operator|(
name|u_int32_t
operator|)
name|ntmp
operator|->
name|ntm_mftmirrcn
operator|)
argument_list|)
expr_stmt|;
name|ntmp
operator|->
name|ntm_mountp
operator|=
name|mp
expr_stmt|;
name|ntmp
operator|->
name|ntm_devvp
operator|=
name|devvp
expr_stmt|;
if|if
condition|(
literal|1
operator|==
name|vfs_scanopt
argument_list|(
name|mp
operator|->
name|mnt_optnew
argument_list|,
literal|"uid"
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|v
argument_list|)
condition|)
name|ntmp
operator|->
name|ntm_uid
operator|=
name|v
expr_stmt|;
if|if
condition|(
literal|1
operator|==
name|vfs_scanopt
argument_list|(
name|mp
operator|->
name|mnt_optnew
argument_list|,
literal|"gid"
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|v
argument_list|)
condition|)
name|ntmp
operator|->
name|ntm_gid
operator|=
name|v
expr_stmt|;
if|if
condition|(
literal|1
operator|==
name|vfs_scanopt
argument_list|(
name|mp
operator|->
name|mnt_optnew
argument_list|,
literal|"mode"
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|v
argument_list|)
condition|)
name|ntmp
operator|->
name|ntm_mode
operator|=
name|v
expr_stmt|;
name|vfs_flagopt
argument_list|(
name|mp
operator|->
name|mnt_optnew
argument_list|,
literal|"caseins"
argument_list|,
operator|&
name|ntmp
operator|->
name|ntm_flag
argument_list|,
name|NTFS_MFLAG_CASEINS
argument_list|)
expr_stmt|;
name|vfs_flagopt
argument_list|(
name|mp
operator|->
name|mnt_optnew
argument_list|,
literal|"allnames"
argument_list|,
operator|&
name|ntmp
operator|->
name|ntm_flag
argument_list|,
name|NTFS_MFLAG_ALLNAMES
argument_list|)
expr_stmt|;
name|ntmp
operator|->
name|ntm_cp
operator|=
name|cp
expr_stmt|;
name|ntmp
operator|->
name|ntm_bo
operator|=
operator|&
name|devvp
operator|->
name|v_bufobj
expr_stmt|;
name|cs_local
operator|=
name|vfs_getopts
argument_list|(
name|mp
operator|->
name|mnt_optnew
argument_list|,
literal|"cs_local"
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|ENOENT
condition|)
goto|goto
name|out
goto|;
name|cs_ntfs
operator|=
name|vfs_getopts
argument_list|(
name|mp
operator|->
name|mnt_optnew
argument_list|,
literal|"cs_ntfs"
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|ENOENT
condition|)
goto|goto
name|out
goto|;
comment|/* Copy in the 8-bit to Unicode conversion table */
comment|/* Initialize Unicode to 8-bit table from 8toU table */
name|ntfs_82u_init
argument_list|(
name|ntmp
argument_list|,
name|cs_local
argument_list|,
name|cs_ntfs
argument_list|)
expr_stmt|;
if|if
condition|(
name|cs_local
operator|!=
name|NULL
operator|&&
name|cs_ntfs
operator|!=
name|NULL
condition|)
name|ntfs_u28_init
argument_list|(
name|ntmp
argument_list|,
name|NULL
argument_list|,
name|cs_local
argument_list|,
name|cs_ntfs
argument_list|)
expr_stmt|;
else|else
name|ntfs_u28_init
argument_list|(
name|ntmp
argument_list|,
name|ntmp
operator|->
name|ntm_82u
argument_list|,
name|cs_local
argument_list|,
name|cs_ntfs
argument_list|)
expr_stmt|;
name|mp
operator|->
name|mnt_data
operator|=
name|ntmp
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"ntfs_mountfs(): case-%s,%s uid: %d, gid: %d, mode: %o\n"
operator|,
operator|(
name|ntmp
operator|->
name|ntm_flag
operator|&
name|NTFS_MFLAG_CASEINS
operator|)
condition|?
literal|"insens."
else|:
literal|"sens."
operator|,
operator|(
name|ntmp
operator|->
name|ntm_flag
operator|&
name|NTFS_MFLAG_ALLNAMES
operator|)
condition|?
literal|" allnames,"
else|:
literal|""
operator|,
name|ntmp
operator|->
name|ntm_uid
operator|,
name|ntmp
operator|->
name|ntm_gid
operator|,
name|ntmp
operator|->
name|ntm_mode
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * We read in some system nodes to do not allow  	 * reclaim them and to have everytime access to them. 	 */
block|{
name|int
name|pi
index|[
literal|3
index|]
init|=
block|{
name|NTFS_MFTINO
block|,
name|NTFS_ROOTINO
block|,
name|NTFS_BITMAPINO
block|}
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|error
operator|=
name|VFS_VGET
argument_list|(
name|mp
argument_list|,
name|pi
index|[
name|i
index|]
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
operator|&
operator|(
name|ntmp
operator|->
name|ntm_sysvn
index|[
name|pi
index|[
name|i
index|]
index|]
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out1
goto|;
name|ntmp
operator|->
name|ntm_sysvn
index|[
name|pi
index|[
name|i
index|]
index|]
operator|->
name|v_vflag
operator||=
name|VV_SYSTEM
expr_stmt|;
name|VREF
argument_list|(
name|ntmp
operator|->
name|ntm_sysvn
index|[
name|pi
index|[
name|i
index|]
index|]
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|ntmp
operator|->
name|ntm_sysvn
index|[
name|pi
index|[
name|i
index|]
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* read the Unicode lowercase --> uppercase translation table, 	 * if necessary */
if|if
condition|(
operator|(
name|error
operator|=
name|ntfs_toupper_use
argument_list|(
name|mp
argument_list|,
name|ntmp
argument_list|)
operator|)
condition|)
goto|goto
name|out1
goto|;
comment|/* 	 * Scan $BitMap and count free clusters 	 */
name|error
operator|=
name|ntfs_calccfree
argument_list|(
name|ntmp
argument_list|,
operator|&
name|ntmp
operator|->
name|ntm_cfree
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out1
goto|;
comment|/* 	 * Read and translate to internal format attribute 	 * definition file.  	 */
block|{
name|int
name|num
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|attrdef
name|ad
decl_stmt|;
comment|/* Open $AttrDef */
name|error
operator|=
name|VFS_VGET
argument_list|(
name|mp
argument_list|,
name|NTFS_ATTRDEFINO
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
operator|&
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out1
goto|;
comment|/* Count valid entries */
for|for
control|(
name|num
operator|=
literal|0
init|;
condition|;
name|num
operator|++
control|)
block|{
name|error
operator|=
name|ntfs_readattr
argument_list|(
name|ntmp
argument_list|,
name|VTONT
argument_list|(
name|vp
argument_list|)
argument_list|,
name|NTFS_A_DATA
argument_list|,
name|NULL
argument_list|,
name|num
operator|*
sizeof|sizeof
argument_list|(
name|ad
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|ad
argument_list|)
argument_list|,
operator|&
name|ad
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out1
goto|;
if|if
condition|(
name|ad
operator|.
name|ad_name
index|[
literal|0
index|]
operator|==
literal|0
condition|)
break|break;
block|}
comment|/* Alloc memory for attribute definitions */
name|MALLOC
argument_list|(
name|ntmp
operator|->
name|ntm_ad
argument_list|,
expr|struct
name|ntvattrdef
operator|*
argument_list|,
name|num
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ntvattrdef
argument_list|)
argument_list|,
name|M_NTFSMNT
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|ntmp
operator|->
name|ntm_adnum
operator|=
name|num
expr_stmt|;
comment|/* Read them and translate */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|error
operator|=
name|ntfs_readattr
argument_list|(
name|ntmp
argument_list|,
name|VTONT
argument_list|(
name|vp
argument_list|)
argument_list|,
name|NTFS_A_DATA
argument_list|,
name|NULL
argument_list|,
name|i
operator|*
sizeof|sizeof
argument_list|(
name|ad
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|ad
argument_list|)
argument_list|,
operator|&
name|ad
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out1
goto|;
name|j
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|ntmp
operator|->
name|ntm_ad
index|[
name|i
index|]
operator|.
name|ad_name
index|[
name|j
index|]
operator|=
name|ad
operator|.
name|ad_name
index|[
name|j
index|]
expr_stmt|;
block|}
do|while
condition|(
name|ad
operator|.
name|ad_name
index|[
name|j
operator|++
index|]
condition|)
do|;
name|ntmp
operator|->
name|ntm_ad
index|[
name|i
index|]
operator|.
name|ad_namelen
operator|=
name|j
operator|-
literal|1
expr_stmt|;
name|ntmp
operator|->
name|ntm_ad
index|[
name|i
index|]
operator|.
name|ad_type
operator|=
name|ad
operator|.
name|ad_type
expr_stmt|;
block|}
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
name|mp
operator|->
name|mnt_stat
operator|.
name|f_fsid
operator|.
name|val
index|[
literal|0
index|]
operator|=
name|dev2udev
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mp
operator|->
name|mnt_stat
operator|.
name|f_fsid
operator|.
name|val
index|[
literal|1
index|]
operator|=
name|mp
operator|->
name|mnt_vfc
operator|->
name|vfc_typenum
expr_stmt|;
name|mp
operator|->
name|mnt_maxsymlinklen
operator|=
literal|0
expr_stmt|;
name|MNT_ILOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|mp
operator|->
name|mnt_flag
operator||=
name|MNT_LOCAL
expr_stmt|;
name|MNT_IUNLOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|out1
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTFS_SYSNODESNUM
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ntmp
operator|->
name|ntm_sysvn
index|[
name|i
index|]
condition|)
name|vrele
argument_list|(
name|ntmp
operator|->
name|ntm_sysvn
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|vflush
argument_list|(
name|mp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
condition|)
name|dprintf
argument_list|(
operator|(
literal|"ntfs_mountfs: vflush failed\n"
operator|)
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|bp
condition|)
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|DROP_GIANT
argument_list|()
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
name|g_vfs_close
argument_list|(
name|cp
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|PICKUP_GIANT
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntfs_unmount
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|int
name|mntflags
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|ntfsmount
modifier|*
name|ntmp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|flags
decl_stmt|,
name|i
decl_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"ntfs_unmount: unmounting...\n"
operator|)
argument_list|)
expr_stmt|;
name|ntmp
operator|=
name|VFSTONTFS
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mntflags
operator|&
name|MNT_FORCE
condition|)
name|flags
operator||=
name|FORCECLOSE
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"ntfs_unmount: vflushing...\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|vflush
argument_list|(
name|mp
argument_list|,
literal|0
argument_list|,
name|flags
operator||
name|SKIPSYSTEM
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"ntfs_unmount: vflush failed: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Check if only system vnodes are rest */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTFS_SYSNODESNUM
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|ntmp
operator|->
name|ntm_sysvn
index|[
name|i
index|]
operator|)
operator|&&
operator|(
name|vrefcnt
argument_list|(
name|ntmp
operator|->
name|ntm_sysvn
index|[
name|i
index|]
argument_list|)
operator|>
literal|1
operator|)
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
comment|/* Dereference all system vnodes */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTFS_SYSNODESNUM
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ntmp
operator|->
name|ntm_sysvn
index|[
name|i
index|]
condition|)
name|vrele
argument_list|(
name|ntmp
operator|->
name|ntm_sysvn
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* vflush system vnodes */
name|error
operator|=
name|vflush
argument_list|(
name|mp
argument_list|,
literal|0
argument_list|,
name|flags
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|printf
argument_list|(
literal|"ntfs_unmount: vflush failed(sysnodes): %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|vinvalbuf
argument_list|(
name|ntmp
operator|->
name|ntm_devvp
argument_list|,
name|V_SAVE
argument_list|,
name|td
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DROP_GIANT
argument_list|()
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
name|g_vfs_close
argument_list|(
name|ntmp
operator|->
name|ntm_cp
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|PICKUP_GIANT
argument_list|()
expr_stmt|;
name|vrele
argument_list|(
name|ntmp
operator|->
name|ntm_devvp
argument_list|)
expr_stmt|;
comment|/* free the toupper table, if this has been last mounted ntfs volume */
name|ntfs_toupper_unuse
argument_list|()
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"ntfs_umount: freeing memory...\n"
operator|)
argument_list|)
expr_stmt|;
name|ntfs_u28_uninit
argument_list|(
name|ntmp
argument_list|)
expr_stmt|;
name|ntfs_82u_uninit
argument_list|(
name|ntmp
argument_list|)
expr_stmt|;
name|mp
operator|->
name|mnt_data
operator|=
name|NULL
expr_stmt|;
name|MNT_ILOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|mp
operator|->
name|mnt_flag
operator|&=
operator|~
name|MNT_LOCAL
expr_stmt|;
name|MNT_IUNLOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|ntmp
operator|->
name|ntm_ad
argument_list|,
name|M_NTFSMNT
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|ntmp
argument_list|,
name|M_NTFSMNT
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntfs_root
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|nvp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"ntfs_root(): sysvn: %p\n"
operator|,
name|VFSTONTFS
argument_list|(
name|mp
argument_list|)
operator|->
name|ntm_sysvn
index|[
name|NTFS_ROOTINO
index|]
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|VFS_VGET
argument_list|(
name|mp
argument_list|,
operator|(
name|ino_t
operator|)
name|NTFS_ROOTINO
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
operator|&
name|nvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"ntfs_root: VFS_VGET failed: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
operator|*
name|vpp
operator|=
name|nvp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntfs_calccfree
parameter_list|(
name|struct
name|ntfsmount
modifier|*
name|ntmp
parameter_list|,
name|cn_t
modifier|*
name|cfreep
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|u_int8_t
modifier|*
name|tmp
decl_stmt|;
name|int
name|j
decl_stmt|,
name|error
decl_stmt|;
name|long
name|cfree
init|=
literal|0
decl_stmt|;
name|size_t
name|bmsize
decl_stmt|,
name|i
decl_stmt|;
name|vp
operator|=
name|ntmp
operator|->
name|ntm_sysvn
index|[
name|NTFS_BITMAPINO
index|]
expr_stmt|;
name|bmsize
operator|=
name|VTOF
argument_list|(
name|vp
argument_list|)
operator|->
name|f_size
expr_stmt|;
name|MALLOC
argument_list|(
name|tmp
argument_list|,
name|u_int8_t
operator|*
argument_list|,
name|bmsize
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|error
operator|=
name|ntfs_readattr
argument_list|(
name|ntmp
argument_list|,
name|VTONT
argument_list|(
name|vp
argument_list|)
argument_list|,
name|NTFS_A_DATA
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|bmsize
argument_list|,
name|tmp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bmsize
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|8
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|~
name|tmp
index|[
name|i
index|]
operator|&
operator|(
literal|1
operator|<<
name|j
operator|)
condition|)
name|cfree
operator|++
expr_stmt|;
operator|*
name|cfreep
operator|=
name|cfree
expr_stmt|;
name|out
label|:
name|FREE
argument_list|(
name|tmp
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntfs_statfs
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|struct
name|statfs
modifier|*
name|sbp
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|ntfsmount
modifier|*
name|ntmp
init|=
name|VFSTONTFS
argument_list|(
name|mp
argument_list|)
decl_stmt|;
name|u_int64_t
name|mftsize
decl_stmt|,
name|mftallocated
decl_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"ntfs_statfs():\n"
operator|)
argument_list|)
expr_stmt|;
name|mftsize
operator|=
name|VTOF
argument_list|(
name|ntmp
operator|->
name|ntm_sysvn
index|[
name|NTFS_MFTINO
index|]
argument_list|)
operator|->
name|f_size
expr_stmt|;
name|mftallocated
operator|=
name|VTOF
argument_list|(
name|ntmp
operator|->
name|ntm_sysvn
index|[
name|NTFS_MFTINO
index|]
argument_list|)
operator|->
name|f_allocated
expr_stmt|;
name|sbp
operator|->
name|f_type
operator|=
name|mp
operator|->
name|mnt_vfc
operator|->
name|vfc_typenum
expr_stmt|;
name|sbp
operator|->
name|f_bsize
operator|=
name|ntmp
operator|->
name|ntm_bps
expr_stmt|;
name|sbp
operator|->
name|f_iosize
operator|=
name|ntmp
operator|->
name|ntm_bps
operator|*
name|ntmp
operator|->
name|ntm_spc
expr_stmt|;
name|sbp
operator|->
name|f_blocks
operator|=
name|ntmp
operator|->
name|ntm_bootfile
operator|.
name|bf_spv
expr_stmt|;
name|sbp
operator|->
name|f_bfree
operator|=
name|sbp
operator|->
name|f_bavail
operator|=
name|ntfs_cntobn
argument_list|(
name|ntmp
operator|->
name|ntm_cfree
argument_list|)
expr_stmt|;
name|sbp
operator|->
name|f_ffree
operator|=
name|sbp
operator|->
name|f_bfree
operator|/
name|ntmp
operator|->
name|ntm_bpmftrec
expr_stmt|;
name|sbp
operator|->
name|f_files
operator|=
name|mftallocated
operator|/
name|ntfs_bntob
argument_list|(
name|ntmp
operator|->
name|ntm_bpmftrec
argument_list|)
operator|+
name|sbp
operator|->
name|f_ffree
expr_stmt|;
name|sbp
operator|->
name|f_flags
operator|=
name|mp
operator|->
name|mnt_flag
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|ntfs_fhtovp
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|struct
name|fid
modifier|*
name|fhp
parameter_list|,
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|nvp
decl_stmt|;
name|struct
name|ntfid
modifier|*
name|ntfhp
init|=
operator|(
expr|struct
name|ntfid
operator|*
operator|)
name|fhp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ddprintf
argument_list|(
operator|(
literal|"ntfs_fhtovp(): %d\n"
operator|,
name|ntfhp
operator|->
name|ntfid_ino
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|VFS_VGET
argument_list|(
name|mp
argument_list|,
name|ntfhp
operator|->
name|ntfid_ino
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
operator|&
name|nvp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|vpp
operator|=
name|NULLVP
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* XXX as unlink/rmdir/mkdir/creat are not currently possible 	 * with NTFS, we don't need to check anything else for now */
operator|*
name|vpp
operator|=
name|nvp
expr_stmt|;
name|vnode_create_vobject
argument_list|(
name|nvp
argument_list|,
name|VTOF
argument_list|(
name|nvp
argument_list|)
operator|->
name|f_size
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ntfs_vgetex
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|ino_t
name|ino
parameter_list|,
name|u_int32_t
name|attrtype
parameter_list|,
name|char
modifier|*
name|attrname
parameter_list|,
name|u_long
name|lkflags
parameter_list|,
name|u_long
name|flags
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
specifier|register
name|struct
name|ntfsmount
modifier|*
name|ntmp
decl_stmt|;
name|struct
name|ntnode
modifier|*
name|ip
decl_stmt|;
name|struct
name|fnode
modifier|*
name|fp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|enum
name|vtype
name|f_type
decl_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"ntfs_vgetex: ino: %d, attr: 0x%x:%s, lkf: 0x%lx, f: 0x%lx\n"
operator|,
name|ino
operator|,
name|attrtype
operator|,
name|attrname
condition|?
name|attrname
else|:
literal|""
operator|,
operator|(
name|u_long
operator|)
name|lkflags
operator|,
operator|(
name|u_long
operator|)
name|flags
operator|)
argument_list|)
expr_stmt|;
name|ntmp
operator|=
name|VFSTONTFS
argument_list|(
name|mp
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|NULL
expr_stmt|;
comment|/* Get ntnode */
name|error
operator|=
name|ntfs_ntlookup
argument_list|(
name|ntmp
argument_list|,
name|ino
argument_list|,
operator|&
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"ntfs_vget: ntfs_ntget failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* It may be not initialized fully, so force load it */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|VG_DONTLOADIN
operator|)
operator|&&
operator|!
operator|(
name|ip
operator|->
name|i_flag
operator|&
name|IN_LOADED
operator|)
condition|)
block|{
name|error
operator|=
name|ntfs_loadntnode
argument_list|(
name|ntmp
argument_list|,
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"ntfs_vget: CAN'T LOAD ATTRIBUTES FOR INO: %d\n"
argument_list|,
name|ip
operator|->
name|i_number
argument_list|)
expr_stmt|;
name|ntfs_ntput
argument_list|(
name|ip
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
name|error
operator|=
name|ntfs_fget
argument_list|(
name|ntmp
argument_list|,
name|ip
argument_list|,
name|attrtype
argument_list|,
name|attrname
argument_list|,
operator|&
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"ntfs_vget: ntfs_fget failed\n"
argument_list|)
expr_stmt|;
name|ntfs_ntput
argument_list|(
name|ip
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|f_type
operator|=
name|VNON
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|VG_DONTVALIDFN
operator|)
operator|&&
operator|!
operator|(
name|fp
operator|->
name|f_flag
operator|&
name|FN_VALID
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|ip
operator|->
name|i_frflag
operator|&
name|NTFS_FRFLAG_DIR
operator|)
operator|&&
operator|(
name|fp
operator|->
name|f_attrtype
operator|==
name|NTFS_A_DATA
operator|&&
name|fp
operator|->
name|f_attrname
operator|==
name|NULL
operator|)
condition|)
block|{
name|f_type
operator|=
name|VDIR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|VG_EXT
condition|)
block|{
name|f_type
operator|=
name|VNON
expr_stmt|;
name|fp
operator|->
name|f_size
operator|=
name|fp
operator|->
name|f_allocated
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|f_type
operator|=
name|VREG
expr_stmt|;
name|error
operator|=
name|ntfs_filesize
argument_list|(
name|ntmp
argument_list|,
name|fp
argument_list|,
operator|&
name|fp
operator|->
name|f_size
argument_list|,
operator|&
name|fp
operator|->
name|f_allocated
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|ntfs_ntput
argument_list|(
name|ip
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
name|fp
operator|->
name|f_flag
operator||=
name|FN_VALID
expr_stmt|;
block|}
if|if
condition|(
name|FTOV
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|vget
argument_list|(
name|FTOV
argument_list|(
name|fp
argument_list|)
argument_list|,
name|lkflags
argument_list|,
name|td
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|FTOV
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|ntfs_ntput
argument_list|(
name|ip
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|error
operator|=
name|getnewvnode
argument_list|(
literal|"ntfs"
argument_list|,
name|ntmp
operator|->
name|ntm_mountp
argument_list|,
operator|&
name|ntfs_vnodeops
argument_list|,
operator|&
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|ntfs_frele
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|ntfs_ntput
argument_list|(
name|ip
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* XXX: Too early for mpsafe fs, lacks vnode lock */
name|error
operator|=
name|insmntque
argument_list|(
name|vp
argument_list|,
name|ntmp
operator|->
name|ntm_mountp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|ntfs_frele
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|ntfs_ntput
argument_list|(
name|ip
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|dprintf
argument_list|(
operator|(
literal|"ntfs_vget: vnode: %p for ntnode: %d\n"
operator|,
name|vp
operator|,
name|ino
operator|)
argument_list|)
expr_stmt|;
name|fp
operator|->
name|f_vp
operator|=
name|vp
expr_stmt|;
name|vp
operator|->
name|v_data
operator|=
name|fp
expr_stmt|;
name|vp
operator|->
name|v_type
operator|=
name|f_type
expr_stmt|;
name|vp
operator|->
name|v_bufobj
operator|.
name|bo_ops
operator|=
operator|&
name|ntfs_vnbufops
expr_stmt|;
name|vp
operator|->
name|v_bufobj
operator|.
name|bo_private
operator|=
name|vp
expr_stmt|;
if|if
condition|(
name|ino
operator|==
name|NTFS_ROOTINO
condition|)
name|vp
operator|->
name|v_vflag
operator||=
name|VV_ROOT
expr_stmt|;
name|ntfs_ntput
argument_list|(
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
name|lkflags
operator|&
name|LK_TYPE_MASK
condition|)
block|{
name|error
operator|=
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|lkflags
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
operator|*
name|vpp
operator|=
name|vp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntfs_vget
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|ino_t
name|ino
parameter_list|,
name|int
name|lkflags
parameter_list|,
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
parameter_list|)
block|{
return|return
name|ntfs_vgetex
argument_list|(
name|mp
argument_list|,
name|ino
argument_list|,
name|NTFS_A_DATA
argument_list|,
name|NULL
argument_list|,
name|lkflags
argument_list|,
literal|0
argument_list|,
name|curthread
argument_list|,
name|vpp
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntfs_bufstrategy
parameter_list|(
name|struct
name|bufobj
modifier|*
name|bo
parameter_list|,
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|vp
operator|=
name|bo
operator|->
name|bo_private
expr_stmt|;
name|KASSERT
argument_list|(
name|bo
operator|==
operator|&
name|vp
operator|->
name|v_bufobj
argument_list|,
operator|(
literal|"BO/VP mismatch: vp %p bo %p != %p"
operator|,
name|vp
operator|,
operator|&
name|vp
operator|->
name|v_bufobj
operator|,
name|bo
operator|)
argument_list|)
expr_stmt|;
name|rc
operator|=
name|VOP_STRATEGY
argument_list|(
name|vp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|rc
operator|==
literal|0
argument_list|,
operator|(
literal|"NTFS VOP_STRATEGY failed: bp=%p, "
literal|"vp=%p, rc=%d"
operator|,
name|bp
operator|,
name|vp
operator|,
name|rc
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|vfsops
name|ntfs_vfsops
init|=
block|{
operator|.
name|vfs_fhtovp
operator|=
name|ntfs_fhtovp
block|,
operator|.
name|vfs_init
operator|=
name|ntfs_init
block|,
operator|.
name|vfs_cmount
operator|=
name|ntfs_cmount
block|,
operator|.
name|vfs_mount
operator|=
name|ntfs_mount
block|,
operator|.
name|vfs_root
operator|=
name|ntfs_root
block|,
operator|.
name|vfs_statfs
operator|=
name|ntfs_statfs
block|,
operator|.
name|vfs_uninit
operator|=
name|ntfs_uninit
block|,
operator|.
name|vfs_unmount
operator|=
name|ntfs_unmount
block|,
operator|.
name|vfs_vget
operator|=
name|ntfs_vget
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|VFS_SET
argument_list|(
name|ntfs_vfsops
argument_list|,
name|ntfs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|ntfs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

