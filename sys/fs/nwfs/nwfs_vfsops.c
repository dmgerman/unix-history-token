begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1999, 2000 Boris Popov  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *    This product includes software developed by Boris Popov.  * 4. Neither the name of the author nor the names of any co-contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"opt_ncp.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|NCP
end_ifndef

begin_error
error|#
directive|error
literal|"NWFS requires NCP protocol"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<netncp/ncp.h>
end_include

begin_include
include|#
directive|include
file|<netncp/ncp_conn.h>
end_include

begin_include
include|#
directive|include
file|<netncp/ncp_subr.h>
end_include

begin_include
include|#
directive|include
file|<netncp/ncp_ncp.h>
end_include

begin_include
include|#
directive|include
file|<netncp/ncp_nls.h>
end_include

begin_include
include|#
directive|include
file|<fs/nwfs/nwfs.h>
end_include

begin_include
include|#
directive|include
file|<fs/nwfs/nwfs_node.h>
end_include

begin_include
include|#
directive|include
file|<fs/nwfs/nwfs_subr.h>
end_include

begin_decl_stmt
name|int
name|nwfs_debuglevel
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nwfs_version
init|=
name|NWFS_VERSION
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_vfs_nwfs
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_vfs
argument_list|,
name|OID_AUTO
argument_list|,
name|nwfs
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"Netware file system"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_nwfs
argument_list|,
name|OID_AUTO
argument_list|,
name|version
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|nwfs_version
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_nwfs
argument_list|,
name|OID_AUTO
argument_list|,
name|debuglevel
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|nwfs_debuglevel
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|nwfs
argument_list|,
name|ncp
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|nwfs
argument_list|,
name|libmchain
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|int
name|nwfs_mount
parameter_list|(
name|struct
name|mount
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|caddr_t
parameter_list|,
name|struct
name|nameidata
modifier|*
parameter_list|,
name|struct
name|proc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nwfs_quotactl
parameter_list|(
name|struct
name|mount
modifier|*
parameter_list|,
name|int
parameter_list|,
name|uid_t
parameter_list|,
name|caddr_t
parameter_list|,
name|struct
name|proc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nwfs_root
parameter_list|(
name|struct
name|mount
modifier|*
parameter_list|,
name|struct
name|vnode
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nwfs_start
parameter_list|(
name|struct
name|mount
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|proc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nwfs_statfs
parameter_list|(
name|struct
name|mount
modifier|*
parameter_list|,
name|struct
name|statfs
modifier|*
parameter_list|,
name|struct
name|proc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nwfs_sync
parameter_list|(
name|struct
name|mount
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|ucred
modifier|*
parameter_list|,
name|struct
name|proc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nwfs_unmount
parameter_list|(
name|struct
name|mount
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|proc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nwfs_init
parameter_list|(
name|struct
name|vfsconf
modifier|*
name|vfsp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nwfs_uninit
parameter_list|(
name|struct
name|vfsconf
modifier|*
name|vfsp
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|vfsops
name|nwfs_vfsops
init|=
block|{
name|nwfs_mount
block|,
name|nwfs_start
block|,
name|nwfs_unmount
block|,
name|nwfs_root
block|,
name|nwfs_quotactl
block|,
name|nwfs_statfs
block|,
name|nwfs_sync
block|,
name|vfs_stdvget
block|,
name|vfs_stdfhtovp
block|,
comment|/* shouldn't happen */
name|vfs_stdcheckexp
block|,
name|vfs_stdvptofh
block|,
comment|/* shouldn't happen */
name|nwfs_init
block|,
name|nwfs_uninit
block|,
name|vfs_stdextattrctl
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|VFS_SET
argument_list|(
name|nwfs_vfsops
argument_list|,
name|nwfs
argument_list|,
name|VFCF_NETWORK
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|nwfs_pbuf_freecnt
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* start out unlimited */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nwfsid
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|nwfs_initnls
parameter_list|(
name|struct
name|nwmount
modifier|*
name|nmp
parameter_list|)
block|{
name|char
modifier|*
name|pc
decl_stmt|,
modifier|*
name|pe
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
define|#
directive|define
name|COPY_TABLE
parameter_list|(
name|t
parameter_list|,
name|d
parameter_list|)
value|{ \ 		if (t) { \ 			error = copyin((t), pc, 256); \ 			if (error) break; \ 		} else \ 			bcopy(d, pc, 256); \ 		(t) = pc; pc += 256; \ 	}
name|nmp
operator|->
name|m
operator|.
name|nls
operator|.
name|opt
operator||=
name|NWHP_NLS
operator||
name|NWHP_DOS
expr_stmt|;
if|if
condition|(
operator|(
name|nmp
operator|->
name|m
operator|.
name|flags
operator|&
name|NWFS_MOUNT_HAVE_NLS
operator|)
operator|==
literal|0
condition|)
block|{
name|nmp
operator|->
name|m
operator|.
name|nls
operator|.
name|to_lower
operator|=
name|ncp_defnls
operator|.
name|to_lower
expr_stmt|;
name|nmp
operator|->
name|m
operator|.
name|nls
operator|.
name|to_upper
operator|=
name|ncp_defnls
operator|.
name|to_upper
expr_stmt|;
name|nmp
operator|->
name|m
operator|.
name|nls
operator|.
name|n2u
operator|=
name|ncp_defnls
operator|.
name|n2u
expr_stmt|;
name|nmp
operator|->
name|m
operator|.
name|nls
operator|.
name|u2n
operator|=
name|ncp_defnls
operator|.
name|u2n
expr_stmt|;
return|return
literal|0
return|;
block|}
name|MALLOC
argument_list|(
name|pe
argument_list|,
name|char
operator|*
argument_list|,
literal|256
operator|*
literal|4
argument_list|,
name|M_NWFSDATA
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|pc
operator|=
name|pe
expr_stmt|;
do|do
block|{
name|COPY_TABLE
argument_list|(
name|nmp
operator|->
name|m
operator|.
name|nls
operator|.
name|to_lower
argument_list|,
name|ncp_defnls
operator|.
name|to_lower
argument_list|)
expr_stmt|;
name|COPY_TABLE
argument_list|(
name|nmp
operator|->
name|m
operator|.
name|nls
operator|.
name|to_upper
argument_list|,
name|ncp_defnls
operator|.
name|to_upper
argument_list|)
expr_stmt|;
name|COPY_TABLE
argument_list|(
name|nmp
operator|->
name|m
operator|.
name|nls
operator|.
name|n2u
argument_list|,
name|ncp_defnls
operator|.
name|n2u
argument_list|)
expr_stmt|;
name|COPY_TABLE
argument_list|(
name|nmp
operator|->
name|m
operator|.
name|nls
operator|.
name|u2n
argument_list|,
name|ncp_defnls
operator|.
name|u2n
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|pe
argument_list|,
name|M_NWFSDATA
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * mp - path - addr in user space of mount point (ie /usr or whatever)  * data - addr in user space of mount params   */
end_comment

begin_function
specifier|static
name|int
name|nwfs_mount
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|char
modifier|*
name|path
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|struct
name|nameidata
modifier|*
name|ndp
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|nwfs_args
name|args
decl_stmt|;
comment|/* will hold data from mount request */
name|int
name|error
decl_stmt|;
name|struct
name|nwmount
modifier|*
name|nmp
init|=
name|NULL
decl_stmt|;
name|struct
name|ncp_conn
modifier|*
name|conn
init|=
name|NULL
decl_stmt|;
name|struct
name|ncp_handle
modifier|*
name|handle
init|=
name|NULL
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|char
modifier|*
name|pc
decl_stmt|,
modifier|*
name|pe
decl_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
block|{
name|nwfs_printf
argument_list|(
literal|"missing data argument\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|mp
operator|->
name|mnt_flag
operator|&
name|MNT_UPDATE
condition|)
block|{
name|nwfs_printf
argument_list|(
literal|"MNT_UPDATE not implemented"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
name|error
operator|=
name|copyin
argument_list|(
name|data
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|args
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nwfs_args
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|args
operator|.
name|version
operator|!=
name|NWFS_VERSION
condition|)
block|{
name|nwfs_printf
argument_list|(
literal|"mount version mismatch: kernel=%d, mount=%d\n"
argument_list|,
name|NWFS_VERSION
argument_list|,
name|args
operator|.
name|version
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|error
operator|=
name|ncp_conn_getbyref
argument_list|(
name|args
operator|.
name|connRef
argument_list|,
name|p
argument_list|,
name|p
operator|->
name|p_ucred
argument_list|,
name|NCPM_EXECUTE
argument_list|,
operator|&
name|conn
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|nwfs_printf
argument_list|(
literal|"invalid connection refernce %d\n"
argument_list|,
name|args
operator|.
name|connRef
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|ncp_conn_gethandle
argument_list|(
name|conn
argument_list|,
name|NULL
argument_list|,
operator|&
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|nwfs_printf
argument_list|(
literal|"can't get connection handle\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|ncp_conn_unlock
argument_list|(
name|conn
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* we keep the ref */
name|mp
operator|->
name|mnt_stat
operator|.
name|f_iosize
operator|=
name|conn
operator|->
name|buffer_size
expr_stmt|;
comment|/* We must malloc our own mount info */
name|MALLOC
argument_list|(
name|nmp
argument_list|,
expr|struct
name|nwmount
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nwmount
argument_list|)
argument_list|,
name|M_NWFSDATA
argument_list|,
name|M_USE_RESERVE
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmp
operator|==
name|NULL
condition|)
block|{
name|nwfs_printf
argument_list|(
literal|"could not alloc nwmount\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|mp
operator|->
name|mnt_data
operator|=
operator|(
name|qaddr_t
operator|)
name|nmp
expr_stmt|;
name|nmp
operator|->
name|connh
operator|=
name|handle
expr_stmt|;
name|nmp
operator|->
name|n_root
operator|=
name|NULL
expr_stmt|;
name|nmp
operator|->
name|n_id
operator|=
name|nwfsid
operator|++
expr_stmt|;
name|nmp
operator|->
name|m
operator|=
name|args
expr_stmt|;
name|nmp
operator|->
name|m
operator|.
name|file_mode
operator|=
operator|(
name|nmp
operator|->
name|m
operator|.
name|file_mode
operator|&
operator|(
name|S_IRWXU
operator||
name|S_IRWXG
operator||
name|S_IRWXO
operator|)
operator|)
operator||
name|S_IFREG
expr_stmt|;
name|nmp
operator|->
name|m
operator|.
name|dir_mode
operator|=
operator|(
name|nmp
operator|->
name|m
operator|.
name|dir_mode
operator|&
operator|(
name|S_IRWXU
operator||
name|S_IRWXG
operator||
name|S_IRWXO
operator|)
operator|)
operator||
name|S_IFDIR
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|nwfs_initnls
argument_list|(
name|nmp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|bad
goto|;
name|pc
operator|=
name|mp
operator|->
name|mnt_stat
operator|.
name|f_mntfromname
expr_stmt|;
name|pe
operator|=
name|pc
operator|+
sizeof|sizeof
argument_list|(
name|mp
operator|->
name|mnt_stat
operator|.
name|f_mntfromname
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|pc
argument_list|,
name|MNAMELEN
argument_list|)
expr_stmt|;
operator|*
operator|(
name|pc
operator|++
operator|)
operator|=
literal|'/'
expr_stmt|;
name|pc
operator|=
name|index
argument_list|(
name|strncpy
argument_list|(
name|pc
argument_list|,
name|conn
operator|->
name|li
operator|.
name|server
argument_list|,
name|pe
operator|-
name|pc
operator|-
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pc
operator|<
name|pe
operator|-
literal|1
condition|)
block|{
operator|*
operator|(
name|pc
operator|++
operator|)
operator|=
literal|':'
expr_stmt|;
name|pc
operator|=
name|index
argument_list|(
name|strncpy
argument_list|(
name|pc
argument_list|,
name|conn
operator|->
name|li
operator|.
name|user
argument_list|,
name|pe
operator|-
name|pc
operator|-
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pc
operator|<
name|pe
operator|-
literal|1
condition|)
block|{
operator|*
operator|(
name|pc
operator|++
operator|)
operator|=
literal|'/'
expr_stmt|;
name|strncpy
argument_list|(
name|pc
argument_list|,
name|nmp
operator|->
name|m
operator|.
name|mounted_vol
argument_list|,
name|pe
operator|-
name|pc
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* protect against invalid mount points */
name|nmp
operator|->
name|m
operator|.
name|mount_point
index|[
sizeof|sizeof
argument_list|(
name|nmp
operator|->
name|m
operator|.
name|mount_point
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|vfs_getnewfsid
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|error
operator|=
name|nwfs_root
argument_list|(
name|mp
argument_list|,
operator|&
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
comment|/* 	 * Lose the lock but keep the ref. 	 */
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|curproc
argument_list|)
expr_stmt|;
name|NCPVODEBUG
argument_list|(
literal|"rootvp.vrefcnt=%d\n"
argument_list|,
name|vp
operator|->
name|v_usecount
argument_list|)
expr_stmt|;
return|return
name|error
return|;
name|bad
label|:
if|if
condition|(
name|nmp
condition|)
name|free
argument_list|(
name|nmp
argument_list|,
name|M_NWFSDATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|handle
condition|)
name|ncp_conn_puthandle
argument_list|(
name|handle
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* Unmount the filesystem described by mp. */
end_comment

begin_function
specifier|static
name|int
name|nwfs_unmount
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|int
name|mntflags
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|nwmount
modifier|*
name|nmp
init|=
name|VFSTONWFS
argument_list|(
name|mp
argument_list|)
decl_stmt|;
name|struct
name|ncp_conn
modifier|*
name|conn
decl_stmt|;
name|int
name|error
decl_stmt|,
name|flags
decl_stmt|;
name|NCPVODEBUG
argument_list|(
literal|"nwfs_unmount: flags=%04x\n"
argument_list|,
name|mntflags
argument_list|)
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mntflags
operator|&
name|MNT_FORCE
condition|)
name|flags
operator||=
name|FORCECLOSE
expr_stmt|;
comment|/* There is 1 extra root vnode reference from nwfs_mount(). */
name|error
operator|=
name|vflush
argument_list|(
name|mp
argument_list|,
literal|1
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|conn
operator|=
name|NWFSTOCONN
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
name|ncp_conn_puthandle
argument_list|(
name|nmp
operator|->
name|connh
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ncp_conn_lock
argument_list|(
name|conn
argument_list|,
name|p
argument_list|,
name|p
operator|->
name|p_ucred
argument_list|,
name|NCPM_WRITE
operator||
name|NCPM_EXECUTE
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ncp_conn_free
argument_list|(
name|conn
argument_list|)
condition|)
name|ncp_conn_unlock
argument_list|(
name|conn
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
name|mp
operator|->
name|mnt_data
operator|=
operator|(
name|qaddr_t
operator|)
literal|0
expr_stmt|;
if|if
condition|(
name|nmp
operator|->
name|m
operator|.
name|flags
operator|&
name|NWFS_MOUNT_HAVE_NLS
condition|)
name|free
argument_list|(
name|nmp
operator|->
name|m
operator|.
name|nls
operator|.
name|to_lower
argument_list|,
name|M_NWFSDATA
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nmp
argument_list|,
name|M_NWFSDATA
argument_list|)
expr_stmt|;
name|mp
operator|->
name|mnt_flag
operator|&=
operator|~
name|MNT_LOCAL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  Return locked vnode to root of a filesystem */
end_comment

begin_function
specifier|static
name|int
name|nwfs_root
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|nwmount
modifier|*
name|nmp
decl_stmt|;
name|struct
name|nwnode
modifier|*
name|np
decl_stmt|;
name|struct
name|ncp_conn
modifier|*
name|conn
decl_stmt|;
name|struct
name|nw_entry_info
name|fattr
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|curproc
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|p
operator|->
name|p_ucred
decl_stmt|;
name|int
name|error
decl_stmt|,
name|nsf
decl_stmt|,
name|opt
decl_stmt|;
name|u_char
name|vol
decl_stmt|;
name|nmp
operator|=
name|VFSTONWFS
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|conn
operator|=
name|NWFSTOCONN
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmp
operator|->
name|n_root
condition|)
block|{
operator|*
name|vpp
operator|=
name|NWTOV
argument_list|(
name|nmp
operator|->
name|n_root
argument_list|)
expr_stmt|;
while|while
condition|(
name|vget
argument_list|(
operator|*
name|vpp
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
name|curproc
argument_list|)
operator|!=
literal|0
condition|)
empty_stmt|;
return|return
literal|0
return|;
block|}
name|error
operator|=
name|ncp_lookup_volume
argument_list|(
name|conn
argument_list|,
name|nmp
operator|->
name|m
operator|.
name|mounted_vol
argument_list|,
operator|&
name|vol
argument_list|,
operator|&
name|nmp
operator|->
name|n_rootent
operator|.
name|f_id
argument_list|,
name|p
argument_list|,
name|cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|ENOENT
return|;
name|nmp
operator|->
name|n_volume
operator|=
name|vol
expr_stmt|;
name|error
operator|=
name|ncp_get_namespaces
argument_list|(
name|conn
argument_list|,
name|vol
argument_list|,
operator|&
name|nsf
argument_list|,
name|p
argument_list|,
name|cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|ENOENT
return|;
if|if
condition|(
name|nsf
operator|&
name|NW_NSB_OS2
condition|)
block|{
name|NCPVODEBUG
argument_list|(
literal|"volume %s has os2 namespace\n"
argument_list|,
name|nmp
operator|->
name|m
operator|.
name|mounted_vol
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nmp
operator|->
name|m
operator|.
name|flags
operator|&
name|NWFS_MOUNT_NO_OS2
operator|)
operator|==
literal|0
condition|)
block|{
name|nmp
operator|->
name|name_space
operator|=
name|NW_NS_OS2
expr_stmt|;
name|nmp
operator|->
name|m
operator|.
name|nls
operator|.
name|opt
operator|&=
operator|~
name|NWHP_DOS
expr_stmt|;
block|}
block|}
name|opt
operator|=
name|nmp
operator|->
name|m
operator|.
name|nls
operator|.
name|opt
expr_stmt|;
name|nsf
operator|=
name|opt
operator|&
operator|(
name|NWHP_UPPER
operator||
name|NWHP_LOWER
operator|)
expr_stmt|;
if|if
condition|(
name|opt
operator|&
name|NWHP_DOS
condition|)
block|{
if|if
condition|(
name|nsf
operator|==
operator|(
name|NWHP_UPPER
operator||
name|NWHP_LOWER
operator|)
condition|)
block|{
name|nmp
operator|->
name|m
operator|.
name|nls
operator|.
name|opt
operator|&=
operator|~
operator|(
name|NWHP_LOWER
operator||
name|NWHP_UPPER
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nsf
operator|==
literal|0
condition|)
block|{
name|nmp
operator|->
name|m
operator|.
name|nls
operator|.
name|opt
operator||=
name|NWHP_LOWER
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|nsf
operator|==
operator|(
name|NWHP_UPPER
operator||
name|NWHP_LOWER
operator|)
condition|)
block|{
name|nmp
operator|->
name|m
operator|.
name|nls
operator|.
name|opt
operator|&=
operator|~
operator|(
name|NWHP_LOWER
operator||
name|NWHP_UPPER
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nmp
operator|->
name|m
operator|.
name|root_path
index|[
literal|0
index|]
condition|)
block|{
name|nmp
operator|->
name|m
operator|.
name|root_path
index|[
literal|0
index|]
operator|--
expr_stmt|;
name|error
operator|=
name|ncp_obtain_info
argument_list|(
name|nmp
argument_list|,
name|nmp
operator|->
name|n_rootent
operator|.
name|f_id
argument_list|,
operator|-
name|nmp
operator|->
name|m
operator|.
name|root_path
index|[
literal|0
index|]
argument_list|,
name|nmp
operator|->
name|m
operator|.
name|root_path
argument_list|,
operator|&
name|fattr
argument_list|,
name|p
argument_list|,
name|cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|NCPFATAL
argument_list|(
literal|"Invalid root path specified\n"
argument_list|)
expr_stmt|;
return|return
name|ENOENT
return|;
block|}
name|nmp
operator|->
name|n_rootent
operator|.
name|f_parent
operator|=
name|fattr
operator|.
name|dirEntNum
expr_stmt|;
name|nmp
operator|->
name|m
operator|.
name|root_path
index|[
literal|0
index|]
operator|++
expr_stmt|;
name|error
operator|=
name|ncp_obtain_info
argument_list|(
name|nmp
argument_list|,
name|nmp
operator|->
name|n_rootent
operator|.
name|f_id
argument_list|,
operator|-
name|nmp
operator|->
name|m
operator|.
name|root_path
index|[
literal|0
index|]
argument_list|,
name|nmp
operator|->
name|m
operator|.
name|root_path
argument_list|,
operator|&
name|fattr
argument_list|,
name|p
argument_list|,
name|cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|NCPFATAL
argument_list|(
literal|"Invalid root path specified\n"
argument_list|)
expr_stmt|;
return|return
name|ENOENT
return|;
block|}
name|nmp
operator|->
name|n_rootent
operator|.
name|f_id
operator|=
name|fattr
operator|.
name|dirEntNum
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|ncp_obtain_info
argument_list|(
name|nmp
argument_list|,
name|nmp
operator|->
name|n_rootent
operator|.
name|f_id
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|fattr
argument_list|,
name|p
argument_list|,
name|cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|NCPFATAL
argument_list|(
literal|"Can't obtain volume info\n"
argument_list|)
expr_stmt|;
return|return
name|ENOENT
return|;
block|}
name|fattr
operator|.
name|nameLen
operator|=
name|strlen
argument_list|(
name|strcpy
argument_list|(
name|fattr
operator|.
name|entryName
argument_list|,
literal|"#.ROOT"
argument_list|)
argument_list|)
expr_stmt|;
name|nmp
operator|->
name|n_rootent
operator|.
name|f_parent
operator|=
name|nmp
operator|->
name|n_rootent
operator|.
name|f_id
expr_stmt|;
block|}
name|error
operator|=
name|nwfs_nget
argument_list|(
name|mp
argument_list|,
name|nmp
operator|->
name|n_rootent
argument_list|,
operator|&
name|fattr
argument_list|,
name|NULL
argument_list|,
operator|&
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|vp
operator|->
name|v_flag
operator||=
name|VROOT
expr_stmt|;
name|np
operator|=
name|VTONW
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmp
operator|->
name|m
operator|.
name|root_path
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|np
operator|->
name|n_flag
operator||=
name|NVOLUME
expr_stmt|;
name|nmp
operator|->
name|n_root
operator|=
name|np
expr_stmt|;
comment|/*	error = VOP_GETATTR(vp,&vattr, cred, p); 	if (error) { 		vput(vp); 		NCPFATAL("Can't get root directory entry\n"); 		return error; 	}*/
operator|*
name|vpp
operator|=
name|vp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Vfs start routine, a no-op.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|nwfs_start
parameter_list|(
name|mp
parameter_list|,
name|flags
parameter_list|,
name|p
parameter_list|)
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|NCPVODEBUG
argument_list|(
literal|"flags=%04x\n"
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Do operations associated with quotas, not supported  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|nwfs_quotactl
parameter_list|(
name|mp
parameter_list|,
name|cmd
parameter_list|,
name|uid
parameter_list|,
name|arg
parameter_list|,
name|p
parameter_list|)
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|int
name|cmd
decl_stmt|;
name|uid_t
name|uid
decl_stmt|;
name|caddr_t
name|arg
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|NCPVODEBUG
argument_list|(
literal|"return EOPNOTSUPP\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|nwfs_init
parameter_list|(
name|struct
name|vfsconf
modifier|*
name|vfsp
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|SMP
name|int
name|name
index|[
literal|2
index|]
decl_stmt|;
name|int
name|olen
decl_stmt|,
name|ncpu
decl_stmt|,
name|plen
decl_stmt|,
name|error
decl_stmt|;
name|name
index|[
literal|0
index|]
operator|=
name|CTL_HW
expr_stmt|;
name|name
index|[
literal|1
index|]
operator|=
name|HW_NCPU
expr_stmt|;
name|error
operator|=
name|kernel_sysctl
argument_list|(
name|curproc
argument_list|,
name|name
argument_list|,
literal|2
argument_list|,
operator|&
name|ncpu
argument_list|,
operator|&
name|olen
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|plen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|ncpu
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"warning: nwfs module compiled without SMP support."
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|nwfs_hash_init
argument_list|()
expr_stmt|;
name|nwfs_pbuf_freecnt
operator|=
name|nswbuf
operator|/
literal|2
operator|+
literal|1
expr_stmt|;
name|NCPVODEBUG
argument_list|(
literal|"always happy to load!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|nwfs_uninit
parameter_list|(
name|struct
name|vfsconf
modifier|*
name|vfsp
parameter_list|)
block|{
name|nwfs_hash_free
argument_list|()
expr_stmt|;
name|NCPVODEBUG
argument_list|(
literal|"unloaded\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nwfs_statfs call  */
end_comment

begin_function
name|int
name|nwfs_statfs
parameter_list|(
name|mp
parameter_list|,
name|sbp
parameter_list|,
name|p
parameter_list|)
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|struct
name|statfs
modifier|*
name|sbp
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|nwmount
modifier|*
name|nmp
init|=
name|VFSTONWFS
argument_list|(
name|mp
argument_list|)
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|secsize
decl_stmt|;
name|struct
name|nwnode
modifier|*
name|np
init|=
name|nmp
operator|->
name|n_root
decl_stmt|;
name|struct
name|ncp_volume_info
name|vi
decl_stmt|;
if|if
condition|(
name|np
operator|==
name|NULL
condition|)
return|return
name|EINVAL
return|;
name|error
operator|=
name|ncp_get_volume_info_with_number
argument_list|(
name|NWFSTOCONN
argument_list|(
name|nmp
argument_list|)
argument_list|,
name|nmp
operator|->
name|n_volume
argument_list|,
operator|&
name|vi
argument_list|,
name|p
argument_list|,
name|p
operator|->
name|p_ucred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|secsize
operator|=
literal|512
expr_stmt|;
comment|/* XXX how to get real value ??? */
name|sbp
operator|->
name|f_spare2
operator|=
literal|0
expr_stmt|;
comment|/* placeholder */
comment|/* fundamental file system block size */
name|sbp
operator|->
name|f_bsize
operator|=
name|vi
operator|.
name|sectors_per_block
operator|*
name|secsize
expr_stmt|;
comment|/* optimal transfer block size */
name|sbp
operator|->
name|f_iosize
operator|=
name|NWFSTOCONN
argument_list|(
name|nmp
argument_list|)
operator|->
name|buffer_size
expr_stmt|;
comment|/* total data blocks in file system */
name|sbp
operator|->
name|f_blocks
operator|=
name|vi
operator|.
name|total_blocks
expr_stmt|;
comment|/* free blocks in fs */
name|sbp
operator|->
name|f_bfree
operator|=
name|vi
operator|.
name|free_blocks
operator|+
name|vi
operator|.
name|purgeable_blocks
expr_stmt|;
comment|/* free blocks avail to non-superuser */
name|sbp
operator|->
name|f_bavail
operator|=
name|vi
operator|.
name|free_blocks
operator|+
name|vi
operator|.
name|purgeable_blocks
expr_stmt|;
comment|/* total file nodes in file system */
name|sbp
operator|->
name|f_files
operator|=
name|vi
operator|.
name|total_dir_entries
expr_stmt|;
comment|/* free file nodes in fs */
name|sbp
operator|->
name|f_ffree
operator|=
name|vi
operator|.
name|available_dir_entries
expr_stmt|;
name|sbp
operator|->
name|f_flags
operator|=
literal|0
expr_stmt|;
comment|/* copy of mount exported flags */
if|if
condition|(
name|sbp
operator|!=
operator|&
name|mp
operator|->
name|mnt_stat
condition|)
block|{
name|sbp
operator|->
name|f_fsid
operator|=
name|mp
operator|->
name|mnt_stat
operator|.
name|f_fsid
expr_stmt|;
comment|/* file system id */
name|sbp
operator|->
name|f_owner
operator|=
name|mp
operator|->
name|mnt_stat
operator|.
name|f_owner
expr_stmt|;
comment|/* user that mounted the filesystem */
name|sbp
operator|->
name|f_type
operator|=
name|mp
operator|->
name|mnt_vfc
operator|->
name|vfc_typenum
expr_stmt|;
comment|/* type of filesystem */
name|bcopy
argument_list|(
name|mp
operator|->
name|mnt_stat
operator|.
name|f_mntonname
argument_list|,
name|sbp
operator|->
name|f_mntonname
argument_list|,
name|MNAMELEN
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|mp
operator|->
name|mnt_stat
operator|.
name|f_mntfromname
argument_list|,
name|sbp
operator|->
name|f_mntfromname
argument_list|,
name|MNAMELEN
argument_list|)
expr_stmt|;
block|}
name|strncpy
argument_list|(
name|sbp
operator|->
name|f_fstypename
argument_list|,
name|mp
operator|->
name|mnt_vfc
operator|->
name|vfc_name
argument_list|,
name|MFSNAMELEN
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Flush out the buffer cache  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|nwfs_sync
parameter_list|(
name|mp
parameter_list|,
name|waitfor
parameter_list|,
name|cred
parameter_list|,
name|p
parameter_list|)
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|int
name|waitfor
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|allerror
init|=
literal|0
decl_stmt|;
comment|/* 	 * Force stale buffer cache information to be flushed. 	 */
name|loop
label|:
for|for
control|(
name|vp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|mp
operator|->
name|mnt_vnodelist
argument_list|)
init|;
name|vp
operator|!=
name|NULL
condition|;
name|vp
operator|=
name|LIST_NEXT
argument_list|(
name|vp
argument_list|,
name|v_mntvnodes
argument_list|)
control|)
block|{
comment|/* 		 * If the vnode that we are about to sync is no longer 		 * associated with this mount point, start over. 		 */
if|if
condition|(
name|vp
operator|->
name|v_mount
operator|!=
name|mp
condition|)
goto|goto
name|loop
goto|;
if|if
condition|(
name|VOP_ISLOCKED
argument_list|(
name|vp
argument_list|,
name|NULL
argument_list|)
operator|||
name|TAILQ_EMPTY
argument_list|(
operator|&
name|vp
operator|->
name|v_dirtyblkhd
argument_list|)
operator|||
name|waitfor
operator|==
name|MNT_LAZY
condition|)
continue|continue;
if|if
condition|(
name|vget
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
name|p
argument_list|)
condition|)
goto|goto
name|loop
goto|;
name|error
operator|=
name|VOP_FSYNC
argument_list|(
name|vp
argument_list|,
name|cred
argument_list|,
name|waitfor
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|allerror
operator|=
name|error
expr_stmt|;
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|allerror
operator|)
return|;
block|}
end_function

end_unit

