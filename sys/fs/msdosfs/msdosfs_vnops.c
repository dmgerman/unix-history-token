begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Written by Paul Popelka (paulp@uts.amdahl.com)  *   * You can do anything you want with this software, just don't say you wrote  * it, and don't remove this notice.  *   * This software is provided "as is".  *   * The author supplies this software to be publicly redistributed on the  * understanding that the author is not responsible for the correct  * functioning of this software in any circumstances and is not liable for  * any damages caused by this software.  *   * October 1992  *   *	from NetBSD:	msdosfs_vnops.c,v 1.1 1993/08/13 11:35:40 cgd Exp  *	$Id$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_comment
comment|/* defines plimit structure in proc struct */
end_comment

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_comment
comment|/* define FWRITE ... */
end_comment

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<miscfs/specfs/specdev.h>
end_include

begin_comment
comment|/* XXX */
end_comment

begin_comment
comment|/* defines v_rdev */
end_comment

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_comment
comment|/* defines dirent structure */
end_comment

begin_include
include|#
directive|include
file|<msdosfs/bpb.h>
end_include

begin_include
include|#
directive|include
file|<msdosfs/direntry.h>
end_include

begin_include
include|#
directive|include
file|<msdosfs/denode.h>
end_include

begin_include
include|#
directive|include
file|<msdosfs/msdosfsmount.h>
end_include

begin_include
include|#
directive|include
file|<msdosfs/fat.h>
end_include

begin_comment
comment|/*  * Some general notes:  *   * In the ufs filesystem the inodes, superblocks, and indirect blocks are  * read/written using the vnode for the filesystem. Blocks that represent  * the contents of a file are read/written using the vnode for the file  * (including directories when they are read/written as files). This  * presents problems for the dos filesystem because data that should be in  * an inode (if dos had them) resides in the directory itself.  Since we  * must update directory entries without the benefit of having the vnode  * for the directory we must use the vnode for the filesystem.  This means  * that when a directory is actually read/written (via read, write, or  * readdir, or seek) we must use the vnode for the filesystem instead of  * the vnode for the directory as would happen in ufs. This is to insure we  * retreive the correct block from the buffer cache since the hash value is  * based upon the vnode address and the desired block number.  */
end_comment

begin_comment
comment|/*  * Create a regular file. On entry the directory to contain the file being  * created is locked.  We must release before we return. We must also free  * the pathname buffer pointed at by ndp->ni_pnbuf, always on error, or  * only if the SAVESTART bit in ni_nameiop is clear on success.  */
end_comment

begin_function
name|int
name|msdosfs_create
parameter_list|(
name|ndp
parameter_list|,
name|vap
parameter_list|,
name|p
parameter_list|)
name|struct
name|nameidata
modifier|*
name|ndp
decl_stmt|;
name|struct
name|vattr
modifier|*
name|vap
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|denode
name|ndirent
decl_stmt|;
name|struct
name|direntry
modifier|*
name|ndirp
init|=
operator|&
name|ndirent
operator|.
name|de_de
decl_stmt|;
name|struct
name|denode
modifier|*
name|dep
decl_stmt|;
name|struct
name|denode
modifier|*
name|pdep
init|=
name|VTODE
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|MSDOSFSDEBUG
argument_list|)
name|printf
argument_list|(
literal|"msdosfs_create(ndp %08x, vap %08x, p %08x\n"
argument_list|,
name|ndp
argument_list|,
name|vap
argument_list|,
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(MSDOSFSDEBUG) */
comment|/* 	 * Create a directory entry for the file, then call createde() to 	 * have it installed. NOTE: DOS files are always executable.  We 	 * use the absence of the owner write bit to make the file 	 * readonly. 	 */
name|bzero
argument_list|(
operator|&
name|ndirent
argument_list|,
sizeof|sizeof
argument_list|(
name|ndirent
argument_list|)
argument_list|)
expr_stmt|;
name|unix2dostime
argument_list|(
operator|&
name|time
argument_list|,
operator|(
expr|union
name|dosdate
operator|*
operator|)
operator|&
name|ndirp
operator|->
name|deDate
argument_list|,
operator|(
expr|union
name|dostime
operator|*
operator|)
operator|&
name|ndirp
operator|->
name|deTime
argument_list|)
expr_stmt|;
name|unix2dosfn
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|ndp
operator|->
name|ni_ptr
argument_list|,
name|ndirp
operator|->
name|deName
argument_list|,
name|ndp
operator|->
name|ni_namelen
argument_list|)
expr_stmt|;
name|ndirp
operator|->
name|deAttributes
operator|=
operator|(
name|vap
operator|->
name|va_mode
operator|&
name|VWRITE
operator|)
condition|?
literal|0
else|:
name|ATTR_READONLY
expr_stmt|;
name|ndirp
operator|->
name|deStartCluster
operator|=
literal|0
expr_stmt|;
name|ndirp
operator|->
name|deFileSize
operator|=
literal|0
expr_stmt|;
name|ndirent
operator|.
name|de_pmp
operator|=
name|pdep
operator|->
name|de_pmp
expr_stmt|;
name|ndirent
operator|.
name|de_dev
operator|=
name|pdep
operator|->
name|de_dev
expr_stmt|;
name|ndirent
operator|.
name|de_devvp
operator|=
name|pdep
operator|->
name|de_devvp
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|createde
argument_list|(
operator|&
name|ndirent
argument_list|,
name|ndp
argument_list|,
operator|&
name|dep
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|ndp
operator|->
name|ni_vp
operator|=
name|DETOV
argument_list|(
name|dep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ndp
operator|->
name|ni_nameiop
operator|&
name|SAVESTART
operator|)
operator|==
literal|0
condition|)
name|free
argument_list|(
name|ndp
operator|->
name|ni_pnbuf
argument_list|,
name|M_NAMEI
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|free
argument_list|(
name|ndp
operator|->
name|ni_pnbuf
argument_list|,
name|M_NAMEI
argument_list|)
expr_stmt|;
block|}
name|deput
argument_list|(
name|pdep
argument_list|)
expr_stmt|;
comment|/* release parent dir */
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|msdosfs_mknod
parameter_list|(
name|ndp
parameter_list|,
name|vap
parameter_list|,
name|cred
parameter_list|,
name|p
parameter_list|)
name|struct
name|nameidata
modifier|*
name|ndp
decl_stmt|;
name|struct
name|vattr
modifier|*
name|vap
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|struct
name|denode
modifier|*
name|pdep
init|=
name|VTODE
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|vap
operator|->
name|va_type
condition|)
block|{
case|case
name|VDIR
case|:
name|error
operator|=
name|msdosfs_mkdir
argument_list|(
name|ndp
argument_list|,
name|vap
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
comment|/* 		 * msdosfs_create() sets ndp->ni_vp. 		 */
case|case
name|VREG
case|:
name|error
operator|=
name|msdosfs_create
argument_list|(
name|ndp
argument_list|,
name|vap
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
name|free
argument_list|(
name|ndp
operator|->
name|ni_pnbuf
argument_list|,
name|M_NAMEI
argument_list|)
expr_stmt|;
name|deput
argument_list|(
name|pdep
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|msdosfs_open
parameter_list|(
name|vp
parameter_list|,
name|mode
parameter_list|,
name|cred
parameter_list|,
name|p
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|msdosfs_close
parameter_list|(
name|vp
parameter_list|,
name|fflag
parameter_list|,
name|cred
parameter_list|,
name|p
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|int
name|fflag
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|denode
modifier|*
name|dep
init|=
name|VTODE
argument_list|(
name|vp
argument_list|)
decl_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_usecount
operator|>
literal|1
operator|&&
operator|!
operator|(
name|dep
operator|->
name|de_flag
operator|&
name|DELOCKED
operator|)
condition|)
name|DETIMES
argument_list|(
name|dep
argument_list|,
operator|&
name|time
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|msdosfs_access
parameter_list|(
name|vp
parameter_list|,
name|mode
parameter_list|,
name|cred
parameter_list|,
name|p
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|dosmode
decl_stmt|;
name|struct
name|denode
modifier|*
name|dep
init|=
name|VTODE
argument_list|(
name|vp
argument_list|)
decl_stmt|;
comment|/* 	 * Root gets to do anything.  Even execute a file without the x-bit 	 * on?  But, for dos filesystems every file is executable.  I may 	 * regret this. 	 */
if|if
condition|(
name|cred
operator|->
name|cr_uid
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* 	 * mode is filled with a combination of VREAD, VWRITE, and/or VEXEC 	 * bits turned on.  In an octal number these are the Y in 0Y00. 	 *  	 * Since the dos filesystem doesn't have the concept of file ownership 	 * we just give everybody read and execute access and write access 	 * if the readonly bit is off. 	 */
name|dosmode
operator|=
name|VEXEC
operator||
name|VREAD
operator||
operator|(
operator|(
name|dep
operator|->
name|de_Attributes
operator|&
name|ATTR_READONLY
operator|)
condition|?
literal|0
else|:
name|VWRITE
operator|)
expr_stmt|;
return|return
operator|(
operator|(
name|dosmode
operator|&
name|mode
operator|)
operator|!=
literal|0
operator|)
condition|?
literal|0
else|:
name|EACCES
return|;
block|}
end_function

begin_function
name|int
name|msdosfs_getattr
parameter_list|(
name|vp
parameter_list|,
name|vap
parameter_list|,
name|cred
parameter_list|,
name|p
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|vattr
modifier|*
name|vap
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|u_int
name|cn
decl_stmt|;
name|struct
name|denode
modifier|*
name|dep
init|=
name|VTODE
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|DETIMES
argument_list|(
name|dep
argument_list|,
operator|&
name|time
argument_list|)
expr_stmt|;
name|vap
operator|->
name|va_fsid
operator|=
name|dep
operator|->
name|de_dev
expr_stmt|;
comment|/* 	 * The following computation of the fileid must be the same as that 	 * used in msdosfs_readdir() to compute d_fileno. If not, pwd 	 * doesn't work. 	 */
if|if
condition|(
name|dep
operator|->
name|de_Attributes
operator|&
name|ATTR_DIRECTORY
condition|)
block|{
if|if
condition|(
operator|(
name|cn
operator|=
name|dep
operator|->
name|de_StartCluster
operator|)
operator|==
name|MSDOSFSROOT
condition|)
name|cn
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|cn
operator|=
name|dep
operator|->
name|de_dirclust
operator|)
operator|==
name|MSDOSFSROOT
condition|)
name|cn
operator|=
literal|1
expr_stmt|;
name|cn
operator|=
operator|(
name|cn
operator|<<
literal|16
operator|)
operator||
operator|(
name|dep
operator|->
name|de_diroffset
operator|&
literal|0xffff
operator|)
expr_stmt|;
block|}
name|vap
operator|->
name|va_fileid
operator|=
name|cn
expr_stmt|;
name|vap
operator|->
name|va_mode
operator|=
operator|(
name|dep
operator|->
name|de_Attributes
operator|&
name|ATTR_READONLY
operator|)
condition|?
literal|0555
else|:
literal|0777
expr_stmt|;
if|if
condition|(
name|dep
operator|->
name|de_Attributes
operator|&
name|ATTR_DIRECTORY
condition|)
name|vap
operator|->
name|va_mode
operator||=
name|S_IFDIR
expr_stmt|;
name|vap
operator|->
name|va_nlink
operator|=
literal|1
expr_stmt|;
name|vap
operator|->
name|va_gid
operator|=
literal|0
expr_stmt|;
name|vap
operator|->
name|va_uid
operator|=
literal|0
expr_stmt|;
name|vap
operator|->
name|va_rdev
operator|=
literal|0
expr_stmt|;
name|vap
operator|->
name|va_size
operator|=
name|dep
operator|->
name|de_FileSize
expr_stmt|;
name|vap
operator|->
name|va_size_rsv
operator|=
literal|0
expr_stmt|;
name|dos2unixtime
argument_list|(
operator|(
expr|union
name|dosdate
operator|*
operator|)
operator|&
name|dep
operator|->
name|de_Date
argument_list|,
operator|(
expr|union
name|dostime
operator|*
operator|)
operator|&
name|dep
operator|->
name|de_Time
argument_list|,
operator|&
name|vap
operator|->
name|va_atime
argument_list|)
expr_stmt|;
name|vap
operator|->
name|va_atime
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|vap
operator|->
name|va_mtime
operator|.
name|tv_sec
operator|=
name|vap
operator|->
name|va_atime
operator|.
name|tv_sec
expr_stmt|;
name|vap
operator|->
name|va_mtime
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|MSDOSFS_NODIRMOD
if|if
condition|(
name|vap
operator|->
name|va_mode
operator|&
name|S_IFDIR
condition|)
block|{
name|vap
operator|->
name|va_mtime
operator|.
name|tv_sec
operator|=
name|time
operator|.
name|tv_sec
expr_stmt|;
name|vap
operator|->
name|va_mtime
operator|.
name|tv_usec
operator|=
name|time
operator|.
name|tv_usec
expr_stmt|;
block|}
endif|#
directive|endif
name|vap
operator|->
name|va_ctime
operator|.
name|tv_sec
operator|=
name|vap
operator|->
name|va_atime
operator|.
name|tv_sec
expr_stmt|;
name|vap
operator|->
name|va_ctime
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|vap
operator|->
name|va_flags
operator|=
name|dep
operator|->
name|de_flag
expr_stmt|;
name|vap
operator|->
name|va_gen
operator|=
literal|0
expr_stmt|;
name|vap
operator|->
name|va_blocksize
operator|=
name|dep
operator|->
name|de_pmp
operator|->
name|pm_bpcluster
expr_stmt|;
name|vap
operator|->
name|va_bytes
operator|=
operator|(
name|dep
operator|->
name|de_FileSize
operator|+
name|dep
operator|->
name|de_pmp
operator|->
name|pm_crbomask
operator|)
operator|&
operator|~
operator|(
name|dep
operator|->
name|de_pmp
operator|->
name|pm_crbomask
operator|)
expr_stmt|;
name|vap
operator|->
name|va_bytes_rsv
operator|=
literal|0
expr_stmt|;
name|vap
operator|->
name|va_type
operator|=
name|vp
operator|->
name|v_type
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|msdosfs_setattr
parameter_list|(
name|vp
parameter_list|,
name|vap
parameter_list|,
name|cred
parameter_list|,
name|p
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|vattr
modifier|*
name|vap
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|denode
modifier|*
name|dep
init|=
name|VTODE
argument_list|(
name|vp
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|MSDOSFSDEBUG
argument_list|)
name|printf
argument_list|(
literal|"msdosfs_setattr(): vp %08x, vap %08x, cred %08x, p %08x\n"
argument_list|,
name|vp
argument_list|,
name|vap
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(MSDOSFSDEBUG) */
if|if
condition|(
operator|(
name|vap
operator|->
name|va_type
operator|!=
name|VNON
operator|)
operator|||
operator|(
name|vap
operator|->
name|va_nlink
operator|!=
name|VNOVAL
operator|)
operator|||
operator|(
name|vap
operator|->
name|va_fsid
operator|!=
name|VNOVAL
operator|)
operator|||
operator|(
name|vap
operator|->
name|va_fileid
operator|!=
name|VNOVAL
operator|)
operator|||
operator|(
name|vap
operator|->
name|va_blocksize
operator|!=
name|VNOVAL
operator|)
operator|||
operator|(
name|vap
operator|->
name|va_rdev
operator|!=
name|VNOVAL
operator|)
operator|||
operator|(
name|vap
operator|->
name|va_bytes
operator|!=
name|VNOVAL
operator|)
operator|||
operator|(
name|vap
operator|->
name|va_gen
operator|!=
name|VNOVAL
operator|)
operator|||
operator|(
name|vap
operator|->
name|va_uid
operator|!=
operator|(
name|u_short
operator|)
name|VNOVAL
operator|)
operator|||
operator|(
name|vap
operator|->
name|va_gid
operator|!=
operator|(
name|u_short
operator|)
name|VNOVAL
operator|)
operator|||
operator|(
name|vap
operator|->
name|va_atime
operator|.
name|tv_sec
operator|!=
name|VNOVAL
operator|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|MSDOSFSDEBUG
argument_list|)
name|printf
argument_list|(
literal|"msdosfs_setattr(): returning EINVAL\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    va_type %d, va_nlink %x, va_fsid %x, va_fileid %x\n"
argument_list|,
name|vap
operator|->
name|va_type
argument_list|,
name|vap
operator|->
name|va_nlink
argument_list|,
name|vap
operator|->
name|va_fsid
argument_list|,
name|vap
operator|->
name|va_fileid
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    va_blocksize %x, va_rdev %x, va_bytes %x, va_gen %x\n"
argument_list|,
name|vap
operator|->
name|va_blocksize
argument_list|,
name|vap
operator|->
name|va_rdev
argument_list|,
name|vap
operator|->
name|va_bytes
argument_list|,
name|vap
operator|->
name|va_gen
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    va_uid %x, va_gid %x, va_atime.tv_sec %x\n"
argument_list|,
name|vap
operator|->
name|va_uid
argument_list|,
name|vap
operator|->
name|va_gid
argument_list|,
name|vap
operator|->
name|va_atime
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(MSDOSFSDEBUG) */
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
name|vap
operator|->
name|va_size
operator|!=
name|VNOVAL
condition|)
block|{
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VDIR
condition|)
return|return
name|EISDIR
return|;
if|if
condition|(
name|error
operator|=
name|detrunc
argument_list|(
name|dep
argument_list|,
name|vap
operator|->
name|va_size
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|error
return|;
block|}
if|if
condition|(
name|vap
operator|->
name|va_mtime
operator|.
name|tv_sec
operator|!=
name|VNOVAL
condition|)
block|{
name|dep
operator|->
name|de_flag
operator||=
name|DEUPD
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|deupdat
argument_list|(
name|dep
argument_list|,
operator|&
name|vap
operator|->
name|va_mtime
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|error
return|;
block|}
comment|/* 	 * DOS files only have the ability to have thier writability 	 * attribute set, so we use the owner write bit to set the readonly 	 * attribute. 	 */
if|if
condition|(
name|vap
operator|->
name|va_mode
operator|!=
operator|(
name|u_short
operator|)
name|VNOVAL
condition|)
block|{
comment|/* We ignore the read and execute bits */
if|if
condition|(
name|vap
operator|->
name|va_mode
operator|&
name|VWRITE
condition|)
name|dep
operator|->
name|de_Attributes
operator|&=
operator|~
name|ATTR_READONLY
expr_stmt|;
else|else
name|dep
operator|->
name|de_Attributes
operator||=
name|ATTR_READONLY
expr_stmt|;
name|dep
operator|->
name|de_flag
operator||=
name|DEUPD
expr_stmt|;
block|}
if|if
condition|(
name|vap
operator|->
name|va_flags
operator|!=
name|VNOVAL
condition|)
block|{
if|if
condition|(
name|error
operator|=
name|suser
argument_list|(
name|cred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
condition|)
return|return
name|error
return|;
if|if
condition|(
name|cred
operator|->
name|cr_uid
operator|==
literal|0
condition|)
name|dep
operator|->
name|de_flag
operator|=
name|vap
operator|->
name|va_flags
expr_stmt|;
else|else
block|{
name|dep
operator|->
name|de_flag
operator|&=
literal|0xffff0000
expr_stmt|;
name|dep
operator|->
name|de_flag
operator||=
operator|(
name|vap
operator|->
name|va_flags
operator|&
literal|0xffff
operator|)
expr_stmt|;
block|}
name|dep
operator|->
name|de_flag
operator||=
name|DEUPD
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|msdosfs_read
parameter_list|(
name|vp
parameter_list|,
name|uio
parameter_list|,
name|ioflag
parameter_list|,
name|cred
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
name|int
name|ioflag
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|diff
decl_stmt|;
name|int
name|isadir
decl_stmt|;
name|long
name|n
decl_stmt|;
name|long
name|on
decl_stmt|;
name|daddr_t
name|bn
decl_stmt|;
name|daddr_t
name|lbn
decl_stmt|;
name|daddr_t
name|rablock
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|denode
modifier|*
name|dep
init|=
name|VTODE
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|msdosfsmount
modifier|*
name|pmp
init|=
name|dep
operator|->
name|de_pmp
decl_stmt|;
comment|/* 	 * If they didn't ask for any data, then we are done. 	 */
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|uio
operator|->
name|uio_offset
operator|<
literal|0
condition|)
return|return
name|EINVAL
return|;
name|isadir
operator|=
name|dep
operator|->
name|de_Attributes
operator|&
name|ATTR_DIRECTORY
expr_stmt|;
do|do
block|{
name|lbn
operator|=
name|uio
operator|->
name|uio_offset
operator|>>
name|pmp
operator|->
name|pm_cnshift
expr_stmt|;
name|on
operator|=
name|uio
operator|->
name|uio_offset
operator|&
name|pmp
operator|->
name|pm_crbomask
expr_stmt|;
name|n
operator|=
name|MIN
argument_list|(
call|(
name|u_long
call|)
argument_list|(
name|pmp
operator|->
name|pm_bpcluster
operator|-
name|on
argument_list|)
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|)
expr_stmt|;
name|diff
operator|=
name|dep
operator|->
name|de_FileSize
operator|-
name|uio
operator|->
name|uio_offset
expr_stmt|;
if|if
condition|(
name|diff
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* convert cluster # to block # if a directory */
if|if
condition|(
name|isadir
condition|)
block|{
name|error
operator|=
name|pcbmap
argument_list|(
name|dep
argument_list|,
name|lbn
argument_list|,
operator|&
name|lbn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
block|}
if|if
condition|(
name|diff
operator|<
name|n
condition|)
name|n
operator|=
name|diff
expr_stmt|;
comment|/* 		 * If we are operating on a directory file then be sure to 		 * do i/o with the vnode for the filesystem instead of the 		 * vnode for the directory. 		 */
if|if
condition|(
name|isadir
condition|)
block|{
name|error
operator|=
name|bread
argument_list|(
name|pmp
operator|->
name|pm_devvp
argument_list|,
name|lbn
argument_list|,
name|pmp
operator|->
name|pm_bpcluster
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rablock
operator|=
name|lbn
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_lastr
operator|+
literal|1
operator|==
name|lbn
operator|&&
name|rablock
operator|*
name|pmp
operator|->
name|pm_bpcluster
operator|<
name|dep
operator|->
name|de_FileSize
condition|)
block|{
name|error
operator|=
name|breada
argument_list|(
name|vp
argument_list|,
name|lbn
argument_list|,
name|pmp
operator|->
name|pm_bpcluster
argument_list|,
name|rablock
argument_list|,
name|pmp
operator|->
name|pm_bpcluster
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|bread
argument_list|(
name|vp
argument_list|,
name|lbn
argument_list|,
name|pmp
operator|->
name|pm_bpcluster
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
block|}
name|vp
operator|->
name|v_lastr
operator|=
name|lbn
expr_stmt|;
block|}
name|n
operator|=
name|MIN
argument_list|(
name|n
argument_list|,
name|pmp
operator|->
name|pm_bpcluster
operator|-
name|bp
operator|->
name|b_resid
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|error
operator|=
name|uiomove
argument_list|(
name|bp
operator|->
name|b_un
operator|.
name|b_addr
operator|+
name|on
argument_list|,
operator|(
name|int
operator|)
name|n
argument_list|,
name|uio
argument_list|)
expr_stmt|;
comment|/* 		 * If we have read everything from this block or have read 		 * to end of file then we are done with this block.  Mark 		 * it to say the buffer can be reused if need be. 		 */
if|#
directive|if
literal|0
block|if (n + on == pmp->pm_bpcluster || 		    uio->uio_offset == dep->de_FileSize) 			bp->b_flags |= B_AGE;
endif|#
directive|endif
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|error
operator|==
literal|0
operator|&&
name|uio
operator|->
name|uio_resid
operator|>
literal|0
operator|&&
name|n
operator|!=
literal|0
condition|)
do|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Write data to a file or directory.  */
end_comment

begin_function
name|int
name|msdosfs_write
parameter_list|(
name|vp
parameter_list|,
name|uio
parameter_list|,
name|ioflag
parameter_list|,
name|cred
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
name|int
name|ioflag
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
name|int
name|isadir
decl_stmt|;
name|int
name|croffset
decl_stmt|;
name|int
name|resid
decl_stmt|;
name|int
name|osize
decl_stmt|;
name|int
name|error
decl_stmt|;
name|u_long
name|cluster
decl_stmt|;
name|u_long
name|nextcluster
decl_stmt|;
name|u_long
name|lastcluster
decl_stmt|;
name|daddr_t
name|bn
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|uio
operator|->
name|uio_procp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|thisvp
decl_stmt|;
name|struct
name|denode
modifier|*
name|dep
init|=
name|VTODE
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|msdosfsmount
modifier|*
name|pmp
init|=
name|dep
operator|->
name|de_pmp
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|MSDOSFSDEBUG
argument_list|)
name|printf
argument_list|(
literal|"msdosfs_write(vp %08x, uio %08x, ioflag %08x, cred %08x\n"
argument_list|,
name|vp
argument_list|,
name|uio
argument_list|,
name|ioflag
argument_list|,
name|cred
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"msdosfs_write(): diroff %d, dirclust %d, startcluster %d\n"
argument_list|,
name|dep
operator|->
name|de_diroffset
argument_list|,
name|dep
operator|->
name|de_dirclust
argument_list|,
name|dep
operator|->
name|de_StartCluster
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(MSDOSFSDEBUG) */
switch|switch
condition|(
name|vp
operator|->
name|v_type
condition|)
block|{
case|case
name|VREG
case|:
if|if
condition|(
name|ioflag
operator|&
name|IO_APPEND
condition|)
name|uio
operator|->
name|uio_offset
operator|=
name|dep
operator|->
name|de_FileSize
expr_stmt|;
name|isadir
operator|=
literal|0
expr_stmt|;
name|thisvp
operator|=
name|vp
expr_stmt|;
break|break;
case|case
name|VDIR
case|:
if|if
condition|(
operator|(
name|ioflag
operator|&
name|IO_SYNC
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"msdosfs_write(): non-sync directory update"
argument_list|)
expr_stmt|;
name|isadir
operator|=
literal|1
expr_stmt|;
name|thisvp
operator|=
name|pmp
operator|->
name|pm_devvp
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"msdosfs_write(): bad file type"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|uio
operator|->
name|uio_offset
operator|<
literal|0
condition|)
block|{
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* 	 * If they've exceeded their filesize limit, tell them about it. 	 */
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VREG
operator|&&
name|p
operator|&&
operator|(
operator|(
name|uio
operator|->
name|uio_offset
operator|+
name|uio
operator|->
name|uio_resid
operator|)
operator|>
name|p
operator|->
name|p_rlimit
index|[
name|RLIMIT_FSIZE
index|]
operator|.
name|rlim_cur
operator|)
condition|)
block|{
name|psignal
argument_list|(
name|p
argument_list|,
name|SIGXFSZ
argument_list|)
expr_stmt|;
return|return
name|EFBIG
return|;
block|}
comment|/* 	 * If attempting to write beyond the end of the root directory we 	 * stop that here because the root directory can not grow. 	 */
if|if
condition|(
operator|(
name|dep
operator|->
name|de_Attributes
operator|&
name|ATTR_DIRECTORY
operator|)
operator|&&
name|dep
operator|->
name|de_StartCluster
operator|==
name|MSDOSFSROOT
operator|&&
operator|(
name|uio
operator|->
name|uio_offset
operator|+
name|uio
operator|->
name|uio_resid
operator|)
operator|>
name|dep
operator|->
name|de_FileSize
condition|)
return|return
name|ENOSPC
return|;
comment|/* 	 * If the offset we are starting the write at is beyond the end of 	 * the file, then they've done a seek.  Unix filesystems allow 	 * files with holes in them, DOS doesn't so we must fill the hole 	 * with zeroed blocks.  We do this by calling our seek function. 	 * This could probably be cleaned up someday. 	 */
if|if
condition|(
name|uio
operator|->
name|uio_offset
operator|>
name|dep
operator|->
name|de_FileSize
condition|)
block|{
name|error
operator|=
name|msdosfs_seek
argument_list|(
name|vp
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
name|uio
operator|->
name|uio_offset
argument_list|,
name|cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
block|}
comment|/* 	 * Remember some values in case the write fails. 	 */
name|resid
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
name|osize
operator|=
name|dep
operator|->
name|de_FileSize
expr_stmt|;
do|do
block|{
name|bn
operator|=
name|uio
operator|->
name|uio_offset
operator|>>
name|pmp
operator|->
name|pm_cnshift
expr_stmt|;
comment|/* 		 * If we are appending to the file and we are on a cluster 		 * boundary, then allocate a new cluster and chain it onto 		 * the file. 		 */
if|if
condition|(
name|uio
operator|->
name|uio_offset
operator|==
name|dep
operator|->
name|de_FileSize
operator|&&
operator|(
name|uio
operator|->
name|uio_offset
operator|&
name|pmp
operator|->
name|pm_crbomask
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|error
operator|=
name|extendfile
argument_list|(
name|dep
argument_list|,
operator|&
name|bp
argument_list|,
literal|0
argument_list|)
condition|)
break|break;
block|}
else|else
block|{
comment|/* 			 * The block we need to write into exists, so just 			 * read it in. 			 */
if|if
condition|(
name|isadir
condition|)
block|{
name|error
operator|=
name|pcbmap
argument_list|(
name|dep
argument_list|,
name|bn
argument_list|,
operator|&
name|bn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
block|}
name|error
operator|=
name|bread
argument_list|(
name|thisvp
argument_list|,
name|bn
argument_list|,
name|pmp
operator|->
name|pm_bpcluster
argument_list|,
name|cred
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
block|}
name|croffset
operator|=
name|uio
operator|->
name|uio_offset
operator|&
name|pmp
operator|->
name|pm_crbomask
expr_stmt|;
name|n
operator|=
name|MIN
argument_list|(
name|uio
operator|->
name|uio_resid
argument_list|,
name|pmp
operator|->
name|pm_bpcluster
operator|-
name|croffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|uio
operator|->
name|uio_offset
operator|+
name|n
operator|>
name|dep
operator|->
name|de_FileSize
condition|)
block|{
name|dep
operator|->
name|de_FileSize
operator|=
name|uio
operator|->
name|uio_offset
operator|+
name|n
expr_stmt|;
name|vnode_pager_setsize
argument_list|(
name|vp
argument_list|,
name|dep
operator|->
name|de_FileSize
argument_list|)
expr_stmt|;
comment|/* why? */
block|}
operator|(
name|void
operator|)
name|vnode_pager_uncache
argument_list|(
name|vp
argument_list|)
expr_stmt|;
comment|/* why not? */
comment|/* 		 * Should these vnode_pager_* functions be done on dir 		 * files? 		 */
comment|/* 		 * Copy the data from user space into the buf header. 		 */
name|error
operator|=
name|uiomove
argument_list|(
name|bp
operator|->
name|b_un
operator|.
name|b_addr
operator|+
name|croffset
argument_list|,
name|n
argument_list|,
name|uio
argument_list|)
expr_stmt|;
comment|/* 		 * If they want this synchronous then write it and wait for 		 * it.  Otherwise, if on a cluster boundary write it 		 * asynchronously so we can move on to the next block 		 * without delay.  Otherwise do a delayed write because we 		 * may want to write somemore into the block later. 		 */
if|if
condition|(
name|ioflag
operator|&
name|IO_SYNC
condition|)
operator|(
name|void
operator|)
name|bwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|n
operator|+
name|croffset
operator|==
name|pmp
operator|->
name|pm_bpcluster
condition|)
block|{
name|bp
operator|->
name|b_flags
operator||=
name|B_AGE
expr_stmt|;
name|bawrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
name|bdwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|dep
operator|->
name|de_flag
operator||=
name|DEUPD
expr_stmt|;
block|}
do|while
condition|(
name|error
operator|==
literal|0
operator|&&
name|uio
operator|->
name|uio_resid
operator|>
literal|0
condition|)
do|;
comment|/* 	 * If the write failed and they want us to, truncate the file back 	 * to the size it was before the write was attempted. 	 */
if|if
condition|(
name|error
operator|&&
operator|(
name|ioflag
operator|&
name|IO_UNIT
operator|)
condition|)
block|{
name|detrunc
argument_list|(
name|dep
argument_list|,
name|osize
argument_list|,
name|ioflag
operator|&
name|IO_SYNC
argument_list|)
expr_stmt|;
name|uio
operator|->
name|uio_offset
operator|-=
name|resid
operator|-
name|uio
operator|->
name|uio_resid
expr_stmt|;
name|uio
operator|->
name|uio_resid
operator|=
name|resid
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|error
operator|&&
operator|(
name|ioflag
operator|&
name|IO_UNIT
operator|)
condition|)
name|error
operator|=
name|deupdat
argument_list|(
name|dep
argument_list|,
operator|&
name|time
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|msdosfs_ioctl
parameter_list|(
name|vp
parameter_list|,
name|com
parameter_list|,
name|data
parameter_list|,
name|fflag
parameter_list|,
name|cred
parameter_list|,
name|p
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|int
name|com
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
return|return
name|ENOTTY
return|;
block|}
end_function

begin_function
name|int
name|msdosfs_select
parameter_list|(
name|vp
parameter_list|,
name|which
parameter_list|,
name|fflags
parameter_list|,
name|cred
parameter_list|,
name|p
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|int
name|which
decl_stmt|;
name|int
name|fflags
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
return|return
literal|1
return|;
comment|/* DOS filesystems never block? */
block|}
end_function

begin_function
name|int
name|msdosfs_mmap
parameter_list|(
name|vp
parameter_list|,
name|fflags
parameter_list|,
name|cred
parameter_list|,
name|p
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|int
name|fflags
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
return|return
name|EINVAL
return|;
block|}
end_function

begin_comment
comment|/*  * Flush the blocks of a file to disk.  *   * This function is worthless for vnodes that represent directories. Maybe we  * could just do a sync if they try an fsync on a directory file.  */
end_comment

begin_function
name|int
name|msdosfs_fsync
parameter_list|(
name|vp
parameter_list|,
name|fflags
parameter_list|,
name|cred
parameter_list|,
name|waitfor
parameter_list|,
name|p
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|int
name|fflags
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|int
name|waitfor
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|denode
modifier|*
name|dep
init|=
name|VTODE
argument_list|(
name|vp
argument_list|)
decl_stmt|;
if|if
condition|(
name|fflags
operator|&
name|FWRITE
condition|)
name|dep
operator|->
name|de_flag
operator||=
name|DEUPD
expr_stmt|;
comment|/* 	 * Does this call to vflushbuf() do anything?  I can find no code 	 * anywhere that sets v_dirtyblkhd in the vnode, which vflushbuf() 	 * seems to depend upon. 	 */
name|vflushbuf
argument_list|(
name|vp
argument_list|,
name|waitfor
operator|==
name|MNT_WAIT
condition|?
name|B_SYNC
else|:
literal|0
argument_list|)
expr_stmt|;
return|return
name|deupdat
argument_list|(
name|dep
argument_list|,
operator|&
name|time
argument_list|,
name|waitfor
operator|==
name|MNT_WAIT
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Since the dos filesystem does not allow files with holes in them we must  * fill the file with zeroed blocks when a seek past the end of file  * happens.  *   * It seems that nothing in the kernel calls the filesystem specific file seek  * functions.  And, someone on the net told me that NFS never sends  * announcements of seeks to the server.  So, if msdosfs ever becomes NFS  * mountable it will have to use other means to fill in holes in what would  * be a sparse file. (This appears fixed since msdosfs_write() calls seek  * before writing if the offset is past EOF)  */
end_comment

begin_function
name|int
name|msdosfs_seek
parameter_list|(
name|vp
parameter_list|,
name|oldoff
parameter_list|,
name|newoff
parameter_list|,
name|cred
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|off_t
name|oldoff
decl_stmt|;
name|off_t
name|newoff
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|off_t
name|foff
decl_stmt|;
name|daddr_t
name|bn
decl_stmt|;
name|u_long
name|cluster
decl_stmt|;
name|u_long
name|lastcluster
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|denode
modifier|*
name|dep
init|=
name|VTODE
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|msdosfsmount
modifier|*
name|pmp
init|=
name|dep
operator|->
name|de_pmp
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|MSDOSFSDEBUG
argument_list|)
name|printf
argument_list|(
literal|"msdosfs_seek(vp %08x, oldoff %d, newoff %d, cred %08x)\n"
argument_list|,
name|vp
argument_list|,
name|oldoff
argument_list|,
name|newoff
argument_list|,
name|cred
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(MSDOSFSDEBUG) */
comment|/* 	 * Compute the offset of the first byte after the last block in the 	 * file. If seeking beyond the end of file then fill the file with 	 * zeroed blocks up to the seek address. 	 */
name|foff
operator|=
operator|(
name|dep
operator|->
name|de_FileSize
operator|+
operator|(
name|pmp
operator|->
name|pm_bpcluster
operator|-
literal|1
operator|)
operator|)
operator|&
operator|~
name|pmp
operator|->
name|pm_crbomask
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|MSDOSFSDEBUG
argument_list|)
name|printf
argument_list|(
literal|"seek: newoff %d> foff %d\n"
argument_list|,
name|newoff
argument_list|,
name|foff
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(MSDOSFSDEBUG) */
if|if
condition|(
name|newoff
operator|>
name|foff
condition|)
block|{
comment|/* 		 * If this is the root directory and we are attempting to 		 * seek beyond the end disallow it.  DOS filesystem root 		 * directories can not grow. 		 */
if|if
condition|(
name|vp
operator|->
name|v_flag
operator|&
name|VROOT
condition|)
return|return
name|EINVAL
return|;
comment|/* 		 * If this is a directory and the caller is not root, then 		 * do not let them seek beyond the end of file.  If we 		 * allowed this then users could cause directories to grow. 		 * Is this really that important? 		 */
if|if
condition|(
name|dep
operator|->
name|de_Attributes
operator|&
name|ATTR_DIRECTORY
condition|)
block|{
if|if
condition|(
name|error
operator|=
name|suser
argument_list|(
name|cred
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
comment|/* 		 * Allocate and chain together as many clusters as are 		 * needed to get to newoff. 		 */
while|while
condition|(
name|foff
operator|<
name|newoff
condition|)
block|{
if|if
condition|(
name|error
operator|=
name|extendfile
argument_list|(
name|dep
argument_list|,
operator|&
name|bp
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|error
return|;
name|dep
operator|->
name|de_flag
operator||=
name|DEUPD
expr_stmt|;
name|bdwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|foff
operator|+=
name|pmp
operator|->
name|pm_bpcluster
expr_stmt|;
name|dep
operator|->
name|de_FileSize
operator|+=
name|pmp
operator|->
name|pm_bpcluster
expr_stmt|;
block|}
comment|/* end while() */
name|dep
operator|->
name|de_FileSize
operator|=
name|newoff
expr_stmt|;
return|return
name|deupdat
argument_list|(
name|dep
argument_list|,
operator|&
name|time
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|msdosfs_remove
parameter_list|(
name|ndp
parameter_list|,
name|p
parameter_list|)
name|struct
name|nameidata
modifier|*
name|ndp
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|struct
name|denode
modifier|*
name|dep
init|=
name|VTODE
argument_list|(
name|ndp
operator|->
name|ni_vp
argument_list|)
decl_stmt|;
name|struct
name|denode
modifier|*
name|ddep
init|=
name|VTODE
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|)
decl_stmt|;
name|error
operator|=
name|removede
argument_list|(
name|ndp
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|MSDOSFSDEBUG
argument_list|)
name|printf
argument_list|(
literal|"msdosfs_remove(), dep %08x, v_usecount %d\n"
argument_list|,
name|dep
argument_list|,
name|ndp
operator|->
name|ni_vp
operator|->
name|v_usecount
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(MSDOSFSDEBUG) */
if|if
condition|(
name|ddep
operator|==
name|dep
condition|)
name|vrele
argument_list|(
name|DETOV
argument_list|(
name|dep
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|deput
argument_list|(
name|dep
argument_list|)
expr_stmt|;
comment|/* causes msdosfs_inactive() to be called 				 * via vrele() */
name|deput
argument_list|(
name|ddep
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * DOS filesystems don't know what links are. But since we already called  * msdosfs_lookup() with create and lockparent, the parent is locked so we  * have to free it before we return the error.  */
end_comment

begin_function
name|int
name|msdosfs_link
parameter_list|(
name|vp
parameter_list|,
name|ndp
parameter_list|,
name|p
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|nameidata
modifier|*
name|ndp
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|denode
modifier|*
name|pdep
init|=
name|VTODE
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|)
decl_stmt|;
name|free
argument_list|(
name|ndp
operator|->
name|ni_pnbuf
argument_list|,
name|M_NAMEI
argument_list|)
expr_stmt|;
name|deput
argument_list|(
name|pdep
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
end_function

begin_comment
comment|/*  * Renames on files require moving the denode to a new hash queue since the  * denode's location is used to compute which hash queue to put the file  * in. Unless it is a rename in place.  For example "mv a b".  *   * What follows is the basic algorithm:  *   * if (file move) { if (dest file exists) { remove dest file } if (dest and  * src in same directory) { rewrite name in existing directory slot } else  * { write new entry in dest directory update offset and dirclust in denode  * move denode to new hash chain clear old directory entry } } else {  * directory move if (dest directory exists) { if (dest is not empty) {  * return ENOTEMPTY } remove dest directory } if (dest and src in same  * directory) { rewrite name in existing entry } else { be sure dest is not  * a child of src directory write entry in dest directory update "." and  * ".." in moved directory update offset and dirclust in denode move denode  * to new hash chain clear old directory entry for moved directory } }  *   * On entry: source's parent directory is unlocked source file or directory is  * unlocked destination's parent directory is locked destination file or  * directory is locked if it exists  *   * On exit: all denodes should be released Notes: I'm not sure how the memory  * containing the pathnames pointed at by the nameidata structures is  * freed, there may be some memory bleeding for each rename done.  */
end_comment

begin_function
name|int
name|msdosfs_rename
parameter_list|(
name|fndp
parameter_list|,
name|tndp
parameter_list|,
name|p
parameter_list|)
name|struct
name|nameidata
modifier|*
name|fndp
decl_stmt|;
name|struct
name|nameidata
modifier|*
name|tndp
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|u_char
name|toname
index|[
literal|11
index|]
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|newparent
init|=
literal|0
decl_stmt|;
name|int
name|sourceisadirectory
init|=
literal|0
decl_stmt|;
name|u_long
name|to_dirclust
decl_stmt|;
name|u_long
name|to_diroffset
decl_stmt|;
name|u_long
name|cn
decl_stmt|;
name|daddr_t
name|bn
decl_stmt|;
name|struct
name|denode
modifier|*
name|fddep
decl_stmt|;
comment|/* from file's parent directory	 */
name|struct
name|denode
modifier|*
name|fdep
decl_stmt|;
comment|/* from file or directory	 */
name|struct
name|denode
modifier|*
name|tddep
decl_stmt|;
comment|/* to file's parent directory	 */
name|struct
name|denode
modifier|*
name|tdep
decl_stmt|;
comment|/* to file or directory		 */
name|struct
name|msdosfsmount
modifier|*
name|pmp
decl_stmt|;
name|struct
name|direntry
modifier|*
name|dotdotp
decl_stmt|;
name|struct
name|direntry
modifier|*
name|ep
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|MSDOSFSDEBUG
argument_list|)
name|printf
argument_list|(
literal|"msdosfs_rename(fndp %08x, tndp %08x, p %08x\n"
argument_list|,
name|fndp
argument_list|,
name|tndp
argument_list|,
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(MSDOSFSDEBUG) */
name|fddep
operator|=
name|VTODE
argument_list|(
name|fndp
operator|->
name|ni_dvp
argument_list|)
expr_stmt|;
name|fdep
operator|=
name|VTODE
argument_list|(
name|fndp
operator|->
name|ni_vp
argument_list|)
expr_stmt|;
name|tddep
operator|=
name|VTODE
argument_list|(
name|tndp
operator|->
name|ni_dvp
argument_list|)
expr_stmt|;
name|tdep
operator|=
name|tndp
operator|->
name|ni_vp
condition|?
name|VTODE
argument_list|(
name|tndp
operator|->
name|ni_vp
argument_list|)
else|:
name|NULL
expr_stmt|;
name|pmp
operator|=
name|fddep
operator|->
name|de_pmp
expr_stmt|;
ifdef|#
directive|ifdef
name|__NetBSD__
comment|/* Check for cross-device rename */
if|if
condition|(
operator|(
name|fndp
operator|->
name|ni_vp
operator|->
name|v_mount
operator|!=
name|tndp
operator|->
name|ni_dvp
operator|->
name|v_mount
operator|)
operator|||
operator|(
name|tndp
operator|->
name|ni_vp
operator|&&
operator|(
name|fndp
operator|->
name|ni_vp
operator|->
name|v_mount
operator|!=
name|tndp
operator|->
name|ni_vp
operator|->
name|v_mount
operator|)
operator|)
condition|)
block|{
name|error
operator|=
name|EXDEV
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
endif|#
directive|endif
comment|/* 	 * Convert the filename in tdnp into a dos filename. We copy this 	 * into the denode and directory entry for the destination 	 * file/directory. 	 */
name|unix2dosfn
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|tndp
operator|->
name|ni_ptr
argument_list|,
name|toname
argument_list|,
name|tndp
operator|->
name|ni_namelen
argument_list|)
expr_stmt|;
comment|/* 	 * At this point this is the lock state of the denodes: fddep 	 * referenced fdep  referenced tddep locked tdep  locked if it 	 * exists 	 */
comment|/* 	 * Be sure we are not renaming ".", "..", or an alias of ".". This 	 * leads to a crippled directory tree.  It's pretty tough to do a 	 * "ls" or "pwd" with the "." directory entry missing, and "cd .." 	 * doesn't work if the ".." entry is missing. 	 */
if|if
condition|(
name|fdep
operator|->
name|de_Attributes
operator|&
name|ATTR_DIRECTORY
condition|)
block|{
if|if
condition|(
operator|(
name|fndp
operator|->
name|ni_namelen
operator|==
literal|1
operator|&&
name|fndp
operator|->
name|ni_ptr
index|[
literal|0
index|]
operator|==
literal|'.'
operator|)
operator|||
name|fddep
operator|==
name|fdep
operator|||
comment|/* won't happen ? */
name|fndp
operator|->
name|ni_isdotdot
condition|)
block|{
name|VOP_ABORTOP
argument_list|(
name|tndp
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|tndp
operator|->
name|ni_dvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tndp
operator|->
name|ni_vp
condition|)
name|vput
argument_list|(
name|tndp
operator|->
name|ni_vp
argument_list|)
expr_stmt|;
name|VOP_ABORTOP
argument_list|(
name|fndp
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|fndp
operator|->
name|ni_dvp
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|fndp
operator|->
name|ni_vp
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|sourceisadirectory
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * If we are renaming a directory, and the directory is being moved 	 * to another directory, then we must be sure the destination 	 * directory is not in the subtree of the source directory.  This 	 * could orphan everything under the source directory. 	 * doscheckpath() unlocks the destination's parent directory so we 	 * must look it up again to relock it. 	 */
if|if
condition|(
name|fddep
operator|->
name|de_StartCluster
operator|!=
name|tddep
operator|->
name|de_StartCluster
condition|)
name|newparent
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sourceisadirectory
operator|&&
name|newparent
condition|)
block|{
if|if
condition|(
name|tdep
condition|)
block|{
name|deput
argument_list|(
name|tdep
argument_list|)
expr_stmt|;
name|tdep
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* doscheckpath() deput()'s tddep */
name|error
operator|=
name|doscheckpath
argument_list|(
name|fdep
argument_list|,
name|tddep
argument_list|,
name|tndp
operator|->
name|ni_cred
argument_list|)
expr_stmt|;
name|tddep
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
operator|(
name|tndp
operator|->
name|ni_nameiop
operator|&
name|SAVESTART
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"msdosfs_rename(): lost to startdir"
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|lookup
argument_list|(
name|tndp
argument_list|,
name|p
argument_list|)
condition|)
block|{
goto|goto
name|bad
goto|;
block|}
name|tddep
operator|=
name|VTODE
argument_list|(
name|tndp
operator|->
name|ni_dvp
argument_list|)
expr_stmt|;
name|tdep
operator|=
name|tndp
operator|->
name|ni_vp
condition|?
name|VTODE
argument_list|(
name|tndp
operator|->
name|ni_vp
argument_list|)
else|:
name|NULL
expr_stmt|;
block|}
comment|/* 	 * If the destination exists, then be sure its type (file or dir) 	 * matches that of the source.  And, if it is a directory make sure 	 * it is empty.  Then delete the destination. 	 */
if|if
condition|(
name|tdep
condition|)
block|{
if|if
condition|(
name|tdep
operator|->
name|de_Attributes
operator|&
name|ATTR_DIRECTORY
condition|)
block|{
if|if
condition|(
operator|!
name|sourceisadirectory
condition|)
block|{
name|error
operator|=
name|ENOTDIR
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
operator|!
name|dosdirempty
argument_list|(
name|tdep
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENOTEMPTY
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
else|else
block|{
comment|/* destination is file */
if|if
condition|(
name|sourceisadirectory
condition|)
block|{
name|error
operator|=
name|EISDIR
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
name|to_dirclust
operator|=
name|tdep
operator|->
name|de_dirclust
expr_stmt|;
name|to_diroffset
operator|=
name|tdep
operator|->
name|de_diroffset
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|removede
argument_list|(
name|tndp
argument_list|)
condition|)
block|{
goto|goto
name|bad
goto|;
block|}
name|deput
argument_list|(
name|tdep
argument_list|)
expr_stmt|;
name|tdep
operator|=
name|NULL
expr_stmt|;
comment|/* 		 * Remember where the slot was for createde(). 		 */
name|tndp
operator|->
name|ni_msdosfs
operator|.
name|msdosfs_count
operator|=
literal|1
expr_stmt|;
name|tndp
operator|->
name|ni_msdosfs
operator|.
name|msdosfs_cluster
operator|=
name|to_dirclust
expr_stmt|;
name|tndp
operator|->
name|ni_msdosfs
operator|.
name|msdosfs_offset
operator|=
name|to_diroffset
expr_stmt|;
block|}
comment|/* 	 * If the source and destination are in the same directory then 	 * just read in the directory entry, change the name in the 	 * directory entry and write it back to disk. 	 */
if|if
condition|(
name|newparent
operator|==
literal|0
condition|)
block|{
comment|/* tddep and fddep point to the same denode here */
name|DELOCK
argument_list|(
name|fdep
argument_list|)
expr_stmt|;
comment|/* tddep is already locked */
if|if
condition|(
name|error
operator|=
name|readep
argument_list|(
name|fdep
operator|->
name|de_pmp
argument_list|,
name|fndp
operator|->
name|ni_msdosfs
operator|.
name|msdosfs_cluster
argument_list|,
name|fndp
operator|->
name|ni_msdosfs
operator|.
name|msdosfs_offset
argument_list|,
operator|&
name|bp
argument_list|,
operator|&
name|ep
argument_list|)
condition|)
block|{
name|DEUNLOCK
argument_list|(
name|fdep
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|bcopy
argument_list|(
name|toname
argument_list|,
name|ep
operator|->
name|deName
argument_list|,
literal|11
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|bwrite
argument_list|(
name|bp
argument_list|)
condition|)
block|{
name|DEUNLOCK
argument_list|(
name|fdep
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|bcopy
argument_list|(
name|toname
argument_list|,
name|fdep
operator|->
name|de_Name
argument_list|,
literal|11
argument_list|)
expr_stmt|;
comment|/* update denode */
comment|/* 		 * fdep locked fddep and tddep point to the same denode 		 * which is locked tdep is unlocked and unreferenced 		 */
block|}
else|else
block|{
name|u_long
name|dirsize
decl_stmt|;
comment|/* 		 * If the source and destination are in different 		 * directories, then mark the entry in the source directory 		 * as deleted and write a new entry in the destination 		 * directory.  Then move the denode to the correct hash 		 * chain for its new location in the filesystem.  And, if 		 * we moved a directory, then update its .. entry to point 		 * to the new parent directory. If we moved a directory 		 * will also insure that the directory entry on disk has a 		 * filesize of zero. 		 */
name|DELOCK
argument_list|(
name|fdep
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|toname
argument_list|,
name|fdep
operator|->
name|de_Name
argument_list|,
literal|11
argument_list|)
expr_stmt|;
comment|/* update denode */
if|if
condition|(
name|fdep
operator|->
name|de_Attributes
operator|&
name|ATTR_DIRECTORY
condition|)
block|{
name|dirsize
operator|=
name|fdep
operator|->
name|de_FileSize
expr_stmt|;
name|fdep
operator|->
name|de_FileSize
operator|=
literal|0
expr_stmt|;
block|}
name|error
operator|=
name|createde
argument_list|(
name|fdep
argument_list|,
name|tndp
argument_list|,
operator|(
expr|struct
name|denode
operator|*
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdep
operator|->
name|de_Attributes
operator|&
name|ATTR_DIRECTORY
condition|)
block|{
name|fdep
operator|->
name|de_FileSize
operator|=
name|dirsize
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
comment|/* should put back filename */
name|DEUNLOCK
argument_list|(
name|fdep
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|DELOCK
argument_list|(
name|fddep
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|readep
argument_list|(
name|fdep
operator|->
name|de_pmp
argument_list|,
name|fndp
operator|->
name|ni_msdosfs
operator|.
name|msdosfs_cluster
argument_list|,
name|fndp
operator|->
name|ni_msdosfs
operator|.
name|msdosfs_offset
argument_list|,
operator|&
name|bp
argument_list|,
operator|&
name|ep
argument_list|)
condition|)
block|{
name|DEUNLOCK
argument_list|(
name|fdep
argument_list|)
expr_stmt|;
name|DEUNLOCK
argument_list|(
name|fddep
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|ep
operator|->
name|deName
index|[
literal|0
index|]
operator|=
name|SLOT_DELETED
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|bwrite
argument_list|(
name|bp
argument_list|)
condition|)
block|{
name|DEUNLOCK
argument_list|(
name|fdep
argument_list|)
expr_stmt|;
name|DEUNLOCK
argument_list|(
name|fddep
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|fdep
operator|->
name|de_dirclust
operator|=
name|tndp
operator|->
name|ni_msdosfs
operator|.
name|msdosfs_cluster
expr_stmt|;
name|fdep
operator|->
name|de_diroffset
operator|=
name|tndp
operator|->
name|ni_msdosfs
operator|.
name|msdosfs_offset
expr_stmt|;
name|reinsert
argument_list|(
name|fdep
argument_list|)
expr_stmt|;
name|DEUNLOCK
argument_list|(
name|fddep
argument_list|)
expr_stmt|;
block|}
comment|/* fdep is still locked here */
comment|/* 	 * If we moved a directory to a new parent directory, then we must 	 * fixup the ".." entry in the moved directory. 	 */
if|if
condition|(
name|sourceisadirectory
operator|&&
name|newparent
condition|)
block|{
name|cn
operator|=
name|fdep
operator|->
name|de_StartCluster
expr_stmt|;
if|if
condition|(
name|cn
operator|==
name|MSDOSFSROOT
condition|)
block|{
comment|/* this should never happen */
name|panic
argument_list|(
literal|"msdosfs_rename(): updating .. in root directory?\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bn
operator|=
name|cntobn
argument_list|(
name|pmp
argument_list|,
name|cn
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|bread
argument_list|(
name|pmp
operator|->
name|pm_devvp
argument_list|,
name|bn
argument_list|,
name|pmp
operator|->
name|pm_bpcluster
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* should really panic here, fs is corrupt */
name|DEUNLOCK
argument_list|(
name|fdep
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|dotdotp
operator|=
operator|(
expr|struct
name|direntry
operator|*
operator|)
name|bp
operator|->
name|b_un
operator|.
name|b_addr
operator|+
literal|1
expr_stmt|;
name|dotdotp
operator|->
name|deStartCluster
operator|=
name|tddep
operator|->
name|de_StartCluster
expr_stmt|;
name|error
operator|=
name|bwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|DEUNLOCK
argument_list|(
name|fdep
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* should really panic here, fs is corrupt */
goto|goto
name|bad
goto|;
block|}
block|}
else|else
block|{
name|DEUNLOCK
argument_list|(
name|fdep
argument_list|)
expr_stmt|;
block|}
name|bad
label|:
empty_stmt|;
name|vrele
argument_list|(
name|DETOV
argument_list|(
name|fdep
argument_list|)
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|DETOV
argument_list|(
name|fddep
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdep
condition|)
name|vput
argument_list|(
name|DETOV
argument_list|(
name|tdep
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tddep
condition|)
name|vput
argument_list|(
name|DETOV
argument_list|(
name|tddep
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_struct
struct|struct
block|{
name|struct
name|direntry
name|dot
decl_stmt|;
name|struct
name|direntry
name|dotdot
decl_stmt|;
block|}
name|dosdirtemplate
init|=
block|{
literal|".       "
block|,
literal|"   "
block|,
comment|/* the . entry */
name|ATTR_DIRECTORY
block|,
comment|/* file attribute */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* resevered */
literal|1234
block|,
literal|1234
block|,
comment|/* time and date */
literal|0
block|,
comment|/* startcluster */
literal|0
block|,
comment|/* filesize */
literal|"..      "
block|,
literal|"   "
block|,
comment|/* the .. entry */
name|ATTR_DIRECTORY
block|,
comment|/* file attribute */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* resevered */
literal|1234
block|,
literal|1234
block|,
comment|/* time and date */
literal|0
block|,
comment|/* startcluster */
literal|0
block|,
comment|/* filesize */
block|}
struct|;
end_struct

begin_function
name|int
name|msdosfs_mkdir
parameter_list|(
name|ndp
parameter_list|,
name|vap
parameter_list|,
name|p
parameter_list|)
name|struct
name|nameidata
modifier|*
name|ndp
decl_stmt|;
name|struct
name|vattr
modifier|*
name|vap
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|bn
decl_stmt|;
name|int
name|error
decl_stmt|;
name|u_long
name|newcluster
decl_stmt|;
name|struct
name|denode
modifier|*
name|pdep
decl_stmt|;
name|struct
name|denode
modifier|*
name|ndep
decl_stmt|;
name|struct
name|vnode
modifier|*
name|pvp
decl_stmt|;
name|struct
name|direntry
modifier|*
name|denp
decl_stmt|;
name|struct
name|denode
name|ndirent
decl_stmt|;
name|struct
name|msdosfsmount
modifier|*
name|pmp
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|pvp
operator|=
name|ndp
operator|->
name|ni_dvp
expr_stmt|;
name|pdep
operator|=
name|VTODE
argument_list|(
name|pvp
argument_list|)
expr_stmt|;
comment|/* 	 * If this is the root directory and there is no space left we 	 * can't do anything.  This is because the root directory can not 	 * change size. 	 */
if|if
condition|(
name|pdep
operator|->
name|de_StartCluster
operator|==
name|MSDOSFSROOT
operator|&&
name|ndp
operator|->
name|ni_msdosfs
operator|.
name|msdosfs_count
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|ndp
operator|->
name|ni_pnbuf
argument_list|,
name|M_NAMEI
argument_list|)
expr_stmt|;
name|deput
argument_list|(
name|pdep
argument_list|)
expr_stmt|;
return|return
name|ENOSPC
return|;
block|}
name|pmp
operator|=
name|pdep
operator|->
name|de_pmp
expr_stmt|;
comment|/* 	 * Allocate a cluster to hold the about to be created directory. 	 */
if|if
condition|(
name|error
operator|=
name|clusteralloc
argument_list|(
name|pmp
argument_list|,
operator|&
name|newcluster
argument_list|,
name|CLUST_EOFE
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|ndp
operator|->
name|ni_pnbuf
argument_list|,
name|M_NAMEI
argument_list|)
expr_stmt|;
name|deput
argument_list|(
name|pdep
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* 	 * Now fill the cluster with the "." and ".." entries. And write 	 * the cluster to disk.  This way it is there for the parent 	 * directory to be pointing at if there were a crash. 	 */
name|bn
operator|=
name|cntobn
argument_list|(
name|pmp
argument_list|,
name|newcluster
argument_list|)
expr_stmt|;
name|bp
operator|=
name|getblk
argument_list|(
name|pmp
operator|->
name|pm_devvp
argument_list|,
name|bn
argument_list|,
name|pmp
operator|->
name|pm_bpcluster
argument_list|)
expr_stmt|;
comment|/* always succeeds */
name|bzero
argument_list|(
name|bp
operator|->
name|b_un
operator|.
name|b_addr
argument_list|,
name|pmp
operator|->
name|pm_bpcluster
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|dosdirtemplate
argument_list|,
name|bp
operator|->
name|b_un
operator|.
name|b_addr
argument_list|,
sizeof|sizeof
name|dosdirtemplate
argument_list|)
expr_stmt|;
name|denp
operator|=
operator|(
expr|struct
name|direntry
operator|*
operator|)
name|bp
operator|->
name|b_un
operator|.
name|b_addr
expr_stmt|;
name|denp
operator|->
name|deStartCluster
operator|=
name|newcluster
expr_stmt|;
name|unix2dostime
argument_list|(
operator|&
name|time
argument_list|,
operator|(
expr|union
name|dosdate
operator|*
operator|)
operator|&
name|denp
operator|->
name|deDate
argument_list|,
operator|(
expr|union
name|dostime
operator|*
operator|)
operator|&
name|denp
operator|->
name|deTime
argument_list|)
expr_stmt|;
name|denp
operator|++
expr_stmt|;
name|denp
operator|->
name|deStartCluster
operator|=
name|pdep
operator|->
name|de_StartCluster
expr_stmt|;
name|unix2dostime
argument_list|(
operator|&
name|time
argument_list|,
operator|(
expr|union
name|dosdate
operator|*
operator|)
operator|&
name|denp
operator|->
name|deDate
argument_list|,
operator|(
expr|union
name|dostime
operator|*
operator|)
operator|&
name|denp
operator|->
name|deTime
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|bwrite
argument_list|(
name|bp
argument_list|)
condition|)
block|{
name|clusterfree
argument_list|(
name|pmp
argument_list|,
name|newcluster
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ndp
operator|->
name|ni_pnbuf
argument_list|,
name|M_NAMEI
argument_list|)
expr_stmt|;
name|deput
argument_list|(
name|pdep
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* 	 * Now build up a directory entry pointing to the newly allocated 	 * cluster.  This will be written to an empty slot in the parent 	 * directory. 	 */
name|ndep
operator|=
operator|&
name|ndirent
expr_stmt|;
name|bzero
argument_list|(
name|ndep
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ndep
argument_list|)
argument_list|)
expr_stmt|;
name|unix2dosfn
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|ndp
operator|->
name|ni_ptr
argument_list|,
name|ndep
operator|->
name|de_Name
argument_list|,
name|ndp
operator|->
name|ni_namelen
argument_list|)
expr_stmt|;
name|unix2dostime
argument_list|(
operator|&
name|time
argument_list|,
operator|(
expr|union
name|dosdate
operator|*
operator|)
operator|&
name|ndep
operator|->
name|de_Date
argument_list|,
operator|(
expr|union
name|dostime
operator|*
operator|)
operator|&
name|ndep
operator|->
name|de_Time
argument_list|)
expr_stmt|;
name|ndep
operator|->
name|de_StartCluster
operator|=
name|newcluster
expr_stmt|;
name|ndep
operator|->
name|de_Attributes
operator|=
name|ATTR_DIRECTORY
expr_stmt|;
name|ndep
operator|->
name|de_pmp
operator|=
name|pmp
expr_stmt|;
comment|/* createde() needs this	 */
name|error
operator|=
name|createde
argument_list|(
name|ndep
argument_list|,
name|ndp
argument_list|,
operator|&
name|ndep
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|clusterfree
argument_list|(
name|pmp
argument_list|,
name|newcluster
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ndp
operator|->
name|ni_vp
operator|=
name|DETOV
argument_list|(
name|ndep
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|ndp
operator|->
name|ni_pnbuf
argument_list|,
name|M_NAMEI
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|MSDOSFSDEBUG
argument_list|)
name|printf
argument_list|(
literal|"msdosfs_mkdir(): deput(%08x), vnode %08x\n"
argument_list|,
name|pdep
argument_list|,
name|DETOV
argument_list|(
name|pdep
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(MSDOSFSDEBUG) */
name|deput
argument_list|(
name|pdep
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|msdosfs_rmdir
parameter_list|(
name|ndp
parameter_list|,
name|p
parameter_list|)
name|struct
name|nameidata
modifier|*
name|ndp
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|denode
modifier|*
name|ddep
decl_stmt|;
name|struct
name|denode
modifier|*
name|dep
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|ddep
operator|=
name|VTODE
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|)
expr_stmt|;
comment|/* parent dir of dir to delete	 */
name|dep
operator|=
name|VTODE
argument_list|(
name|ndp
operator|->
name|ni_vp
argument_list|)
expr_stmt|;
comment|/* directory to delete	 */
comment|/* 	 * Don't let "rmdir ." go thru. 	 */
if|if
condition|(
name|ddep
operator|==
name|dep
condition|)
block|{
name|vrele
argument_list|(
name|DETOV
argument_list|(
name|dep
argument_list|)
argument_list|)
expr_stmt|;
name|deput
argument_list|(
name|dep
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
comment|/* 	 * Be sure the directory being deleted is empty. 	 */
if|if
condition|(
name|dosdirempty
argument_list|(
name|dep
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|ENOTEMPTY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Delete the entry from the directory.  For dos filesystems this 	 * gets rid of the directory entry on disk, the in memory copy 	 * still exists but the de_refcnt is<= 0.  This prevents it from 	 * being found by deget().  When the deput() on dep is done we give 	 * up access and eventually msdosfs_reclaim() will be called which 	 * will remove it from the denode cache. 	 */
if|if
condition|(
name|error
operator|=
name|removede
argument_list|(
name|ndp
argument_list|)
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * This is where we decrement the link count in the parent 	 * directory.  Since dos filesystems don't do this we just purge 	 * the name cache and let go of the parent directory denode. 	 */
name|cache_purge
argument_list|(
name|DETOV
argument_list|(
name|ddep
argument_list|)
argument_list|)
expr_stmt|;
name|deput
argument_list|(
name|ddep
argument_list|)
expr_stmt|;
name|ndp
operator|->
name|ni_dvp
operator|=
name|NULL
expr_stmt|;
comment|/* getting rid of parent dir pointer? */
comment|/* 	 * Truncate the directory that is being deleted. 	 */
name|error
operator|=
name|detrunc
argument_list|(
name|dep
argument_list|,
operator|(
name|u_long
operator|)
literal|0
argument_list|,
name|IO_SYNC
argument_list|)
expr_stmt|;
name|cache_purge
argument_list|(
name|DETOV
argument_list|(
name|dep
argument_list|)
argument_list|)
expr_stmt|;
name|out
label|:
empty_stmt|;
if|if
condition|(
name|ndp
operator|->
name|ni_dvp
condition|)
name|deput
argument_list|(
name|ddep
argument_list|)
expr_stmt|;
name|deput
argument_list|(
name|dep
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * DOS filesystems don't know what symlinks are.  */
end_comment

begin_function
name|int
name|msdosfs_symlink
parameter_list|(
name|ndp
parameter_list|,
name|vap
parameter_list|,
name|target
parameter_list|,
name|p
parameter_list|)
name|struct
name|nameidata
modifier|*
name|ndp
decl_stmt|;
name|struct
name|vattr
modifier|*
name|vap
decl_stmt|;
name|char
modifier|*
name|target
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|denode
modifier|*
name|pdep
init|=
name|VTODE
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|)
decl_stmt|;
name|free
argument_list|(
name|ndp
operator|->
name|ni_pnbuf
argument_list|,
name|M_NAMEI
argument_list|)
expr_stmt|;
name|deput
argument_list|(
name|pdep
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
end_function

begin_comment
comment|/*  * Dummy dirents to simulate the "." and ".." entries of the root directory  * in a dos filesystem.  Dos doesn't provide these. Note that each entry  * must be the same size as a dos directory entry (32 bytes).  */
end_comment

begin_struct
struct|struct
name|dos_dirent
block|{
name|u_long
name|d_fileno
decl_stmt|;
name|u_short
name|d_reclen
decl_stmt|;
name|u_short
name|d_namlen
decl_stmt|;
name|u_char
name|d_name
index|[
literal|24
index|]
decl_stmt|;
block|}
name|rootdots
index|[
literal|2
index|]
init|=
block|{
block|{
literal|1
block|,
comment|/* d_fileno			 */
sizeof|sizeof
argument_list|(
expr|struct
name|direntry
argument_list|)
block|,
comment|/* d_reclen			 */
literal|1
block|,
comment|/* d_namlen			 */
literal|"."
comment|/* d_name			 */
block|}
block|,
block|{
literal|1
block|,
comment|/* d_fileno			 */
sizeof|sizeof
argument_list|(
expr|struct
name|direntry
argument_list|)
block|,
comment|/* d_reclen			 */
literal|2
block|,
comment|/* d_namlen			 */
literal|".."
comment|/* d_name			 */
block|}
block|}
struct|;
end_struct

begin_function
name|int
name|msdosfs_readdir
parameter_list|(
name|vp
parameter_list|,
name|uio
parameter_list|,
name|cred
parameter_list|,
name|eofflagp
parameter_list|,
name|cookies
parameter_list|,
name|ncookies
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|int
modifier|*
name|eofflagp
decl_stmt|;
name|u_int
modifier|*
name|cookies
decl_stmt|;
name|int
name|ncookies
decl_stmt|;
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|diff
decl_stmt|;
name|char
name|pushout
decl_stmt|;
name|long
name|n
decl_stmt|;
name|long
name|on
decl_stmt|;
name|long
name|lost
decl_stmt|;
name|long
name|count
decl_stmt|;
name|u_long
name|cn
decl_stmt|;
name|u_long
name|fileno
decl_stmt|;
name|long
name|bias
init|=
literal|0
decl_stmt|;
name|daddr_t
name|bn
decl_stmt|;
name|daddr_t
name|lbn
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|denode
modifier|*
name|dep
init|=
name|VTODE
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|msdosfsmount
modifier|*
name|pmp
init|=
name|dep
operator|->
name|de_pmp
decl_stmt|;
name|struct
name|direntry
modifier|*
name|dentp
decl_stmt|;
name|struct
name|dirent
modifier|*
name|prev
decl_stmt|;
name|struct
name|dirent
modifier|*
name|crnt
decl_stmt|;
name|u_char
name|dirbuf
index|[
literal|512
index|]
decl_stmt|;
comment|/* holds converted dos directories */
name|int
name|i
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|MSDOSFSDEBUG
argument_list|)
name|printf
argument_list|(
literal|"msdosfs_readdir(): vp %08x, uio %08x, cred %08x, eofflagp %08x\n"
argument_list|,
name|vp
argument_list|,
name|uio
argument_list|,
name|cred
argument_list|,
name|eofflagp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(MSDOSFSDEBUG) */
if|if
condition|(
operator|!
name|cookies
condition|)
name|ncookies
operator|=
literal|1
expr_stmt|;
comment|/* 	 * msdosfs_readdir() won't operate properly on regular files since 	 * it does i/o only with the the filesystem vnode, and hence can 	 * retrieve the wrong block from the buffer cache for a plain file. 	 * So, fail attempts to readdir() on a plain file. 	 */
if|if
condition|(
operator|(
name|dep
operator|->
name|de_Attributes
operator|&
name|ATTR_DIRECTORY
operator|)
operator|==
literal|0
condition|)
return|return
name|ENOTDIR
return|;
comment|/* 	 * If the user buffer is smaller than the size of one dos directory 	 * entry or the file offset is not a multiple of the size of a 	 * directory entry, then we fail the read. 	 */
name|count
operator|=
name|uio
operator|->
name|uio_resid
operator|&
operator|~
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|direntry
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
name|lost
operator|=
name|uio
operator|->
name|uio_resid
operator|-
name|count
expr_stmt|;
if|if
condition|(
name|count
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|direntry
argument_list|)
operator|||
operator|(
name|uio
operator|->
name|uio_offset
operator|&
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|direntry
argument_list|)
operator|-
literal|1
operator|)
operator|)
condition|)
return|return
name|EINVAL
return|;
name|uio
operator|->
name|uio_resid
operator|=
name|count
expr_stmt|;
name|uio
operator|->
name|uio_iov
operator|->
name|iov_len
operator|=
name|count
expr_stmt|;
comment|/* 	 * If they are reading from the root directory then, we simulate 	 * the . and .. entries since these don't exist in the root 	 * directory.  We also set the offset bias to make up for having to 	 * simulate these entries. By this I mean that at file offset 64 we 	 * read the first entry in the root directory that lives on disk. 	 */
if|if
condition|(
name|dep
operator|->
name|de_StartCluster
operator|==
name|MSDOSFSROOT
condition|)
block|{
comment|/* 		 * printf("msdosfs_readdir(): going after . or .. in root 		 * dir, offset %d\n", uio->uio_offset); 		 */
name|bias
operator|=
literal|2
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|direntry
argument_list|)
expr_stmt|;
if|if
condition|(
name|uio
operator|->
name|uio_offset
operator|<
literal|2
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|direntry
argument_list|)
condition|)
block|{
if|if
condition|(
name|uio
operator|->
name|uio_offset
operator|&&
name|uio
operator|->
name|uio_offset
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|direntry
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|n
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|uio
operator|->
name|uio_offset
condition|)
block|{
name|n
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|cookies
condition|)
block|{
operator|*
name|cookies
operator|++
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|direntry
argument_list|)
expr_stmt|;
name|ncookies
operator|--
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cookies
condition|)
block|{
if|if
condition|(
name|ncookies
operator|--
operator|<=
literal|0
condition|)
name|n
operator|--
expr_stmt|;
else|else
operator|*
name|cookies
operator|++
operator|=
literal|2
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|direntry
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|uiomove
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rootdots
operator|+
name|uio
operator|->
name|uio_offset
argument_list|,
name|n
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|direntry
argument_list|)
argument_list|,
name|uio
argument_list|)
expr_stmt|;
block|}
block|}
while|while
condition|(
operator|!
name|error
operator|&&
name|uio
operator|->
name|uio_resid
operator|>
literal|0
operator|&&
name|ncookies
operator|>
literal|0
condition|)
block|{
name|lbn
operator|=
operator|(
name|uio
operator|->
name|uio_offset
operator|-
name|bias
operator|)
operator|>>
name|pmp
operator|->
name|pm_cnshift
expr_stmt|;
name|on
operator|=
operator|(
name|uio
operator|->
name|uio_offset
operator|-
name|bias
operator|)
operator|&
name|pmp
operator|->
name|pm_crbomask
expr_stmt|;
name|n
operator|=
name|MIN
argument_list|(
call|(
name|u_long
call|)
argument_list|(
name|pmp
operator|->
name|pm_bpcluster
operator|-
name|on
argument_list|)
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|)
expr_stmt|;
name|diff
operator|=
name|dep
operator|->
name|de_FileSize
operator|-
operator|(
name|uio
operator|->
name|uio_offset
operator|-
name|bias
operator|)
expr_stmt|;
if|if
condition|(
name|diff
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|diff
operator|<
name|n
condition|)
name|n
operator|=
name|diff
expr_stmt|;
name|error
operator|=
name|pcbmap
argument_list|(
name|dep
argument_list|,
name|lbn
argument_list|,
operator|&
name|bn
argument_list|,
operator|&
name|cn
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|error
operator|=
name|bread
argument_list|(
name|pmp
operator|->
name|pm_devvp
argument_list|,
name|bn
argument_list|,
name|pmp
operator|->
name|pm_bpcluster
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
name|n
operator|=
name|MIN
argument_list|(
name|n
argument_list|,
name|pmp
operator|->
name|pm_bpcluster
operator|-
name|bp
operator|->
name|b_resid
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* 		 * code to convert from dos directory entries to ufs 		 * directory entries 		 */
name|pushout
operator|=
literal|0
expr_stmt|;
name|dentp
operator|=
operator|(
expr|struct
name|direntry
operator|*
operator|)
operator|(
name|bp
operator|->
name|b_un
operator|.
name|b_addr
operator|+
name|on
operator|)
expr_stmt|;
name|prev
operator|=
literal|0
expr_stmt|;
name|crnt
operator|=
operator|(
expr|struct
name|dirent
operator|*
operator|)
name|dirbuf
expr_stmt|;
while|while
condition|(
operator|(
name|char
operator|*
operator|)
name|dentp
operator|<
name|bp
operator|->
name|b_un
operator|.
name|b_addr
operator|+
name|on
operator|+
name|n
condition|)
block|{
comment|/* 			 * printf("rd: dentp %08x prev %08x crnt %08x 			 * deName %02x attr %02x\n", dentp, prev, crnt, 			 * dentp->deName[0], dentp->deAttributes); 			 */
comment|/* 			 * If we have an empty entry or a slot from a 			 * deleted file, or a volume label entry just 			 * concatenate its space onto the end of the 			 * previous entry or, manufacture an empty entry if 			 * there is no previous entry. 			 */
if|if
condition|(
name|dentp
operator|->
name|deName
index|[
literal|0
index|]
operator|==
name|SLOT_EMPTY
operator|||
name|dentp
operator|->
name|deName
index|[
literal|0
index|]
operator|==
name|SLOT_DELETED
operator|||
operator|(
name|dentp
operator|->
name|deAttributes
operator|&
name|ATTR_VOLUME
operator|)
condition|)
block|{
if|if
condition|(
name|prev
condition|)
block|{
name|prev
operator|->
name|d_reclen
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|direntry
argument_list|)
expr_stmt|;
if|if
condition|(
name|cookies
condition|)
block|{
name|ncookies
operator|++
expr_stmt|;
name|cookies
operator|--
expr_stmt|;
block|}
block|}
else|else
block|{
name|prev
operator|=
name|crnt
expr_stmt|;
name|prev
operator|->
name|d_fileno
operator|=
literal|0
expr_stmt|;
name|prev
operator|->
name|d_reclen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|direntry
argument_list|)
expr_stmt|;
name|prev
operator|->
name|d_namlen
operator|=
literal|0
expr_stmt|;
name|prev
operator|->
name|d_name
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 				 * this computation of d_fileno must match 				 * the computation of va_fileid in 				 * msdosfs_getattr 				 */
if|if
condition|(
name|dentp
operator|->
name|deAttributes
operator|&
name|ATTR_DIRECTORY
condition|)
block|{
comment|/* if this is the root directory */
if|if
condition|(
operator|(
name|fileno
operator|=
name|dentp
operator|->
name|deStartCluster
operator|)
operator|==
name|MSDOSFSROOT
condition|)
name|fileno
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* 					 * if the file's dirent lives in 					 * root dir 					 */
if|if
condition|(
operator|(
name|fileno
operator|=
name|cn
operator|)
operator|==
name|MSDOSFSROOT
condition|)
name|fileno
operator|=
literal|1
expr_stmt|;
name|fileno
operator|=
operator|(
name|fileno
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|dentp
operator|-
operator|(
expr|struct
name|direntry
operator|*
operator|)
name|bp
operator|->
name|b_un
operator|.
name|b_addr
operator|)
operator|&
literal|0xffff
operator|)
expr_stmt|;
block|}
name|crnt
operator|->
name|d_fileno
operator|=
name|fileno
expr_stmt|;
name|crnt
operator|->
name|d_reclen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|direntry
argument_list|)
expr_stmt|;
name|crnt
operator|->
name|d_namlen
operator|=
name|dos2unixfn
argument_list|(
name|dentp
operator|->
name|deName
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|crnt
operator|->
name|d_name
argument_list|)
expr_stmt|;
comment|/* 				 * printf("readdir: file %s, fileno %08x, 				 * attr %02x, start %08x\n", crnt->d_name, 				 * crnt->d_fileno, dentp->deAttributes, 				 * dentp->deStartCluster); 				 */
name|prev
operator|=
name|crnt
expr_stmt|;
block|}
name|dentp
operator|++
expr_stmt|;
if|if
condition|(
name|cookies
condition|)
block|{
operator|*
name|cookies
operator|++
operator|=
call|(
name|u_int
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dentp
operator|-
name|bp
operator|->
name|b_un
operator|.
name|b_addr
operator|-
name|on
argument_list|)
operator|+
name|uio
operator|->
name|uio_offset
expr_stmt|;
name|ncookies
operator|--
expr_stmt|;
block|}
name|crnt
operator|=
operator|(
expr|struct
name|dirent
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|crnt
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|direntry
argument_list|)
operator|)
expr_stmt|;
name|pushout
operator|=
literal|1
expr_stmt|;
comment|/* 			 * If our intermediate buffer is full then copy its 			 * contents to user space.  I would just use the 			 * buffer the buf header points to but, I'm afraid 			 * that when we brelse() it someone else might find 			 * it in the cache and think its contents are 			 * valid.  Maybe there is a way to invalidate the 			 * buffer before brelse()'ing it. 			 */
if|if
condition|(
operator|(
name|u_char
operator|*
operator|)
name|crnt
operator|>=
operator|&
name|dirbuf
index|[
sizeof|sizeof
name|dirbuf
index|]
condition|)
block|{
name|pushout
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|uiomove
argument_list|(
name|dirbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|dirbuf
argument_list|)
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|prev
operator|=
literal|0
expr_stmt|;
name|crnt
operator|=
operator|(
expr|struct
name|dirent
operator|*
operator|)
name|dirbuf
expr_stmt|;
block|}
if|if
condition|(
name|ncookies
operator|<=
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|pushout
condition|)
block|{
name|pushout
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|uiomove
argument_list|(
name|dirbuf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|crnt
operator|-
operator|(
name|char
operator|*
operator|)
name|dirbuf
argument_list|,
name|uio
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* 		 * If we have read everything from this block or have read 		 * to end of file then we are done with this block.  Mark 		 * it to say the buffer can be reused if need be. 		 */
block|if (n + on == pmp->pm_bpcluster || 		    (uio->uio_offset - bias) == dep->de_FileSize) 			bp->b_flags |= B_AGE;
endif|#
directive|endif
comment|/* if 0 */
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
break|break;
block|}
name|out
label|:
empty_stmt|;
name|uio
operator|->
name|uio_resid
operator|+=
name|lost
expr_stmt|;
comment|/* 	 * I don't know why we bother setting this eofflag, getdirentries() 	 * in vfs_syscalls.c doesn't bother to look at it when we return. 	 * (because NFS uses it in nfs_serv.c -- JMP) 	 */
if|if
condition|(
name|dep
operator|->
name|de_FileSize
operator|-
name|uio
operator|->
name|uio_offset
operator|-
name|bias
operator|<=
literal|0
condition|)
operator|*
name|eofflagp
operator|=
literal|1
expr_stmt|;
else|else
operator|*
name|eofflagp
operator|=
literal|0
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * DOS filesystems don't know what symlinks are.  */
end_comment

begin_function
name|int
name|msdosfs_readlink
parameter_list|(
name|vp
parameter_list|,
name|uio
parameter_list|,
name|cred
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
block|{
return|return
name|EINVAL
return|;
block|}
end_function

begin_function
name|int
name|msdosfs_abortop
parameter_list|(
name|ndp
parameter_list|)
name|struct
name|nameidata
modifier|*
name|ndp
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|ndp
operator|->
name|ni_nameiop
operator|&
operator|(
name|HASBUF
operator||
name|SAVESTART
operator|)
operator|)
operator|==
name|HASBUF
condition|)
name|FREE
argument_list|(
name|ndp
operator|->
name|ni_pnbuf
argument_list|,
name|M_NAMEI
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|msdosfs_lock
parameter_list|(
name|vp
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
block|{
name|struct
name|denode
modifier|*
name|dep
init|=
name|VTODE
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|DELOCK
argument_list|(
name|dep
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|msdosfs_unlock
parameter_list|(
name|vp
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
block|{
name|struct
name|denode
modifier|*
name|dep
init|=
name|VTODE
argument_list|(
name|vp
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|dep
operator|->
name|de_flag
operator|&
name|DELOCKED
operator|)
condition|)
name|panic
argument_list|(
literal|"msdosfs_unlock: denode not locked"
argument_list|)
expr_stmt|;
name|DEUNLOCK
argument_list|(
name|dep
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|msdosfs_islocked
parameter_list|(
name|vp
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
block|{
return|return
name|VTODE
argument_list|(
name|vp
argument_list|)
operator|->
name|de_flag
operator|&
name|DELOCKED
condition|?
literal|1
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * vp - address of vnode file the file bn - which cluster we are interested  * in mapping to a filesystem block number. vpp - returns the vnode for the  * block special file holding the filesystem containing the file of  * interest bnp - address of where to return the filesystem relative block  * number  */
end_comment

begin_function
name|int
name|msdosfs_bmap
parameter_list|(
name|vp
parameter_list|,
name|bn
parameter_list|,
name|vpp
parameter_list|,
name|bnp
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|daddr_t
name|bn
decl_stmt|;
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
decl_stmt|;
name|daddr_t
modifier|*
name|bnp
decl_stmt|;
block|{
name|struct
name|denode
modifier|*
name|dep
init|=
name|VTODE
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|msdosfsmount
modifier|*
name|pmp
init|=
name|dep
operator|->
name|de_pmp
decl_stmt|;
if|if
condition|(
name|vpp
operator|!=
name|NULL
condition|)
operator|*
name|vpp
operator|=
name|dep
operator|->
name|de_devvp
expr_stmt|;
if|if
condition|(
name|bnp
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
return|return
name|pcbmap
argument_list|(
name|dep
argument_list|,
name|bn
operator|<<
operator|(
name|pmp
operator|->
name|pm_cnshift
operator|-
name|pmp
operator|->
name|pm_bnshift
operator|)
argument_list|,
name|bnp
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|msdosfs_strategy
parameter_list|(
name|bp
parameter_list|)
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
block|{
name|struct
name|denode
modifier|*
name|dep
init|=
name|VTODE
argument_list|(
name|bp
operator|->
name|b_vp
argument_list|)
decl_stmt|;
name|struct
name|msdosfsmount
modifier|*
name|pmp
init|=
name|dep
operator|->
name|de_pmp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_vp
operator|->
name|v_type
operator|==
name|VBLK
operator|||
name|bp
operator|->
name|b_vp
operator|->
name|v_type
operator|==
name|VCHR
condition|)
name|panic
argument_list|(
literal|"msdosfs_strategy: spec"
argument_list|)
expr_stmt|;
comment|/* 	 * If we don't already know the filesystem relative block number 	 * then get it using pcbmap().  If pcbmap() returns the block 	 * number as -1 then we've got a hole in the file.  DOS filesystems 	 * don't allow files with holes, so we shouldn't ever see this. 	 */
if|if
condition|(
name|bp
operator|->
name|b_blkno
operator|==
name|bp
operator|->
name|b_lblkno
condition|)
block|{
if|if
condition|(
name|error
operator|=
name|pcbmap
argument_list|(
name|dep
argument_list|,
name|bp
operator|->
name|b_lblkno
argument_list|,
operator|&
name|bp
operator|->
name|b_blkno
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|error
return|;
if|if
condition|(
operator|(
name|long
operator|)
name|bp
operator|->
name|b_blkno
operator|==
operator|-
literal|1
condition|)
name|clrbuf
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|long
operator|)
name|bp
operator|->
name|b_blkno
operator|==
operator|-
literal|1
condition|)
block|{
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
ifdef|#
directive|ifdef
name|DIAGNOSTIC
endif|#
directive|endif
comment|/* defined(DIAGNOSTIC) */
comment|/* 	 * Read/write the block from/to the disk that contains the desired 	 * file block. 	 */
name|vp
operator|=
name|dep
operator|->
name|de_devvp
expr_stmt|;
name|bp
operator|->
name|b_dev
operator|=
name|vp
operator|->
name|v_rdev
expr_stmt|;
operator|(
operator|*
operator|(
name|vp
operator|->
name|v_op
operator|->
name|vop_strategy
operator|)
operator|)
operator|(
name|bp
operator|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|msdosfs_print
parameter_list|(
name|vp
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
block|{
name|struct
name|denode
modifier|*
name|dep
init|=
name|VTODE
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"tag VT_MSDOSFS, startcluster %d, dircluster %d, diroffset %d "
argument_list|,
name|dep
operator|->
name|de_StartCluster
argument_list|,
name|dep
operator|->
name|de_dirclust
argument_list|,
name|dep
operator|->
name|de_diroffset
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" dev %d, %d, %s\n"
argument_list|,
name|major
argument_list|(
name|dep
operator|->
name|de_dev
argument_list|)
argument_list|,
name|minor
argument_list|(
name|dep
operator|->
name|de_dev
argument_list|)
argument_list|,
name|dep
operator|->
name|de_flag
operator|&
name|DELOCKED
condition|?
literal|"(LOCKED)"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|dep
operator|->
name|de_spare0
condition|)
block|{
name|printf
argument_list|(
literal|"    owner pid %d"
argument_list|,
name|dep
operator|->
name|de_spare0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dep
operator|->
name|de_spare1
condition|)
name|printf
argument_list|(
literal|" waiting pid %d"
argument_list|,
name|dep
operator|->
name|de_spare1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|msdosfs_advlock
parameter_list|(
name|vp
parameter_list|,
name|id
parameter_list|,
name|op
parameter_list|,
name|fl
parameter_list|,
name|flags
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|caddr_t
name|id
decl_stmt|;
name|int
name|op
decl_stmt|;
name|struct
name|flock
modifier|*
name|fl
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
return|return
name|EINVAL
return|;
comment|/* we don't do locking yet		 */
block|}
end_function

begin_decl_stmt
name|struct
name|vnodeops
name|msdosfs_vnodeops
init|=
block|{
name|msdosfs_lookup
block|,
name|msdosfs_create
block|,
name|msdosfs_mknod
block|,
name|msdosfs_open
block|,
name|msdosfs_close
block|,
name|msdosfs_access
block|,
name|msdosfs_getattr
block|,
name|msdosfs_setattr
block|,
name|msdosfs_read
block|,
name|msdosfs_write
block|,
name|msdosfs_ioctl
block|,
name|msdosfs_select
block|,
name|msdosfs_mmap
block|,
name|msdosfs_fsync
block|,
name|msdosfs_seek
block|,
name|msdosfs_remove
block|,
name|msdosfs_link
block|,
name|msdosfs_rename
block|,
name|msdosfs_mkdir
block|,
name|msdosfs_rmdir
block|,
name|msdosfs_symlink
block|,
name|msdosfs_readdir
block|,
name|msdosfs_readlink
block|,
name|msdosfs_abortop
block|,
name|msdosfs_inactive
block|,
name|msdosfs_reclaim
block|,
name|msdosfs_lock
block|,
name|msdosfs_unlock
block|,
name|msdosfs_bmap
block|,
name|msdosfs_strategy
block|,
name|msdosfs_print
block|,
name|msdosfs_islocked
block|,
name|msdosfs_advlock
block|, }
decl_stmt|;
end_decl_stmt

end_unit

