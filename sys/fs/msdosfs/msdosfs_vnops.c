begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/*	$NetBSD: msdosfs_vnops.c,v 1.68 1998/02/10 14:10:04 mrg Exp $	*/
end_comment

begin_comment
comment|/*-  * Copyright (C) 1994, 1995, 1997 Wolfgang Solfrank.  * Copyright (C) 1994, 1995, 1997 TooLs GmbH.  * All rights reserved.  * Original code by Paul Popelka (paulp@uts.amdahl.com) (see below).  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by TooLs GmbH.  * 4. The name of TooLs GmbH may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY TOOLS GMBH ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL TOOLS GMBH BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;  * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*-  * Written by Paul Popelka (paulp@uts.amdahl.com)  *  * You can do anything you want with this software, just don't say you wrote  * it, and don't remove this notice.  *  * This software is provided "as is".  *  * The author supplies this software to be publicly redistributed on the  * understanding that the author is not responsible for the correct  * functioning of this software in any circumstances and is not liable for  * any damages caused by this software.  *  * October 1992  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/clock.h>
end_include

begin_include
include|#
directive|include
file|<sys/dirent.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/lockf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<fs/msdosfs/bpb.h>
end_include

begin_include
include|#
directive|include
file|<fs/msdosfs/direntry.h>
end_include

begin_include
include|#
directive|include
file|<fs/msdosfs/denode.h>
end_include

begin_include
include|#
directive|include
file|<fs/msdosfs/fat.h>
end_include

begin_include
include|#
directive|include
file|<fs/msdosfs/msdosfsmount.h>
end_include

begin_define
define|#
directive|define
name|DOS_FILESIZE_MAX
value|0xffffffff
end_define

begin_comment
comment|/*  * Prototypes for MSDOSFS vnode operations  */
end_comment

begin_decl_stmt
specifier|static
name|vop_create_t
name|msdosfs_create
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_mknod_t
name|msdosfs_mknod
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_open_t
name|msdosfs_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_close_t
name|msdosfs_close
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_access_t
name|msdosfs_access
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_getattr_t
name|msdosfs_getattr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_setattr_t
name|msdosfs_setattr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_read_t
name|msdosfs_read
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_write_t
name|msdosfs_write
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_fsync_t
name|msdosfs_fsync
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_remove_t
name|msdosfs_remove
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_link_t
name|msdosfs_link
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_rename_t
name|msdosfs_rename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_mkdir_t
name|msdosfs_mkdir
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_rmdir_t
name|msdosfs_rmdir
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_symlink_t
name|msdosfs_symlink
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_readdir_t
name|msdosfs_readdir
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_bmap_t
name|msdosfs_bmap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_strategy_t
name|msdosfs_strategy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_print_t
name|msdosfs_print
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_pathconf_t
name|msdosfs_pathconf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_vptofh_t
name|msdosfs_vptofh
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Some general notes:  *  * In the ufs filesystem the inodes, superblocks, and indirect blocks are  * read/written using the vnode for the filesystem. Blocks that represent  * the contents of a file are read/written using the vnode for the file  * (including directories when they are read/written as files). This  * presents problems for the dos filesystem because data that should be in  * an inode (if dos had them) resides in the directory itself.  Since we  * must update directory entries without the benefit of having the vnode  * for the directory we must use the vnode for the filesystem.  This means  * that when a directory is actually read/written (via read, write, or  * readdir, or seek) we must use the vnode for the filesystem instead of  * the vnode for the directory as would happen in ufs. This is to insure we  * retreive the correct block from the buffer cache since the hash value is  * based upon the vnode address and the desired block number.  */
end_comment

begin_comment
comment|/*  * Create a regular file. On entry the directory to contain the file being  * created is locked.  We must release before we return. We must also free  * the pathname buffer pointed at by cnp->cn_pnbuf, always on error, or  * only if the SAVESTART bit in cn_flags is clear on success.  */
end_comment

begin_function
specifier|static
name|int
name|msdosfs_create
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_create_args
comment|/* { 		struct vnode *a_dvp; 		struct vnode **a_vpp; 		struct componentname *a_cnp; 		struct vattr *a_vap; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
name|struct
name|denode
name|ndirent
decl_stmt|;
name|struct
name|denode
modifier|*
name|dep
decl_stmt|;
name|struct
name|denode
modifier|*
name|pdep
init|=
name|VTODE
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
decl_stmt|;
name|struct
name|timespec
name|ts
decl_stmt|;
name|int
name|error
decl_stmt|;
ifdef|#
directive|ifdef
name|MSDOSFS_DEBUG
name|printf
argument_list|(
literal|"msdosfs_create(cnp %p, vap %p\n"
argument_list|,
name|cnp
argument_list|,
name|ap
operator|->
name|a_vap
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * If this is the root directory and there is no space left we 	 * can't do anything.  This is because the root directory can not 	 * change size. 	 */
if|if
condition|(
name|pdep
operator|->
name|de_StartCluster
operator|==
name|MSDOSFSROOT
operator|&&
name|pdep
operator|->
name|de_fndoffset
operator|>=
name|pdep
operator|->
name|de_FileSize
condition|)
block|{
name|error
operator|=
name|ENOSPC
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * Create a directory entry for the file, then call createde() to 	 * have it installed. NOTE: DOS files are always executable.  We 	 * use the absence of the owner write bit to make the file 	 * readonly. 	 */
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
operator|(
name|cnp
operator|->
name|cn_flags
operator|&
name|HASBUF
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"msdosfs_create: no name"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bzero
argument_list|(
operator|&
name|ndirent
argument_list|,
sizeof|sizeof
argument_list|(
name|ndirent
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|uniqdosname
argument_list|(
name|pdep
argument_list|,
name|cnp
argument_list|,
name|ndirent
operator|.
name|de_Name
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
name|ndirent
operator|.
name|de_Attributes
operator|=
name|ATTR_ARCHIVE
expr_stmt|;
name|ndirent
operator|.
name|de_LowerCase
operator|=
literal|0
expr_stmt|;
name|ndirent
operator|.
name|de_StartCluster
operator|=
literal|0
expr_stmt|;
name|ndirent
operator|.
name|de_FileSize
operator|=
literal|0
expr_stmt|;
name|ndirent
operator|.
name|de_pmp
operator|=
name|pdep
operator|->
name|de_pmp
expr_stmt|;
name|ndirent
operator|.
name|de_flag
operator|=
name|DE_ACCESS
operator||
name|DE_CREATE
operator||
name|DE_UPDATE
expr_stmt|;
name|getnanotime
argument_list|(
operator|&
name|ts
argument_list|)
expr_stmt|;
name|DETIMES
argument_list|(
operator|&
name|ndirent
argument_list|,
operator|&
name|ts
argument_list|,
operator|&
name|ts
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
name|error
operator|=
name|createde
argument_list|(
operator|&
name|ndirent
argument_list|,
name|pdep
argument_list|,
operator|&
name|dep
argument_list|,
name|cnp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
operator|*
name|ap
operator|->
name|a_vpp
operator|=
name|DETOV
argument_list|(
name|dep
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|bad
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|msdosfs_mknod
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_mknod_args
comment|/* { 		struct vnode *a_dvp; 		struct vnode **a_vpp; 		struct componentname *a_cnp; 		struct vattr *a_vap; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|msdosfs_open
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_open_args
comment|/* { 		struct vnode *a_vp; 		int a_mode; 		struct ucred *a_cred; 		struct thread *a_td; 		struct file *a_fp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|denode
modifier|*
name|dep
init|=
name|VTODE
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|vnode_create_vobject
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|dep
operator|->
name|de_FileSize
argument_list|,
name|ap
operator|->
name|a_td
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|msdosfs_close
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_close_args
comment|/* { 		struct vnode *a_vp; 		int a_fflag; 		struct ucred *a_cred; 		struct thread *a_td; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|denode
modifier|*
name|dep
init|=
name|VTODE
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|timespec
name|ts
decl_stmt|;
name|VI_LOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_usecount
operator|>
literal|1
condition|)
block|{
name|getnanotime
argument_list|(
operator|&
name|ts
argument_list|)
expr_stmt|;
name|DETIMES
argument_list|(
name|dep
argument_list|,
operator|&
name|ts
argument_list|,
operator|&
name|ts
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
block|}
name|VI_UNLOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|msdosfs_access
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_access_args
comment|/* { 		struct vnode *a_vp; 		accmode_t a_accmode; 		struct ucred *a_cred; 		struct thread *a_td; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|denode
modifier|*
name|dep
init|=
name|VTODE
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|struct
name|msdosfsmount
modifier|*
name|pmp
init|=
name|dep
operator|->
name|de_pmp
decl_stmt|;
name|mode_t
name|file_mode
decl_stmt|;
name|accmode_t
name|accmode
init|=
name|ap
operator|->
name|a_accmode
decl_stmt|;
name|file_mode
operator|=
name|S_IRWXU
operator||
name|S_IRWXG
operator||
name|S_IRWXO
expr_stmt|;
name|file_mode
operator|&=
operator|(
name|vp
operator|->
name|v_type
operator|==
name|VDIR
condition|?
name|pmp
operator|->
name|pm_dirmask
else|:
name|pmp
operator|->
name|pm_mask
operator|)
expr_stmt|;
comment|/* 	 * Disallow writing to directories and regular files if the 	 * filesystem is read-only. 	 */
if|if
condition|(
name|accmode
operator|&
name|VWRITE
condition|)
block|{
switch|switch
condition|(
name|vp
operator|->
name|v_type
condition|)
block|{
case|case
name|VREG
case|:
case|case
name|VDIR
case|:
if|if
condition|(
name|vp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
condition|)
return|return
operator|(
name|EROFS
operator|)
return|;
break|break;
default|default:
break|break;
block|}
block|}
return|return
operator|(
name|vaccess
argument_list|(
name|vp
operator|->
name|v_type
argument_list|,
name|file_mode
argument_list|,
name|pmp
operator|->
name|pm_uid
argument_list|,
name|pmp
operator|->
name|pm_gid
argument_list|,
name|ap
operator|->
name|a_accmode
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|msdosfs_getattr
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_getattr_args
comment|/* { 		struct vnode *a_vp; 		struct vattr *a_vap; 		struct ucred *a_cred; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|denode
modifier|*
name|dep
init|=
name|VTODE
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|struct
name|msdosfsmount
modifier|*
name|pmp
init|=
name|dep
operator|->
name|de_pmp
decl_stmt|;
name|struct
name|vattr
modifier|*
name|vap
init|=
name|ap
operator|->
name|a_vap
decl_stmt|;
name|mode_t
name|mode
decl_stmt|;
name|struct
name|timespec
name|ts
decl_stmt|;
name|u_long
name|dirsperblk
init|=
name|pmp
operator|->
name|pm_BytesPerSec
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|direntry
argument_list|)
decl_stmt|;
name|uint64_t
name|fileid
decl_stmt|;
name|getnanotime
argument_list|(
operator|&
name|ts
argument_list|)
expr_stmt|;
name|DETIMES
argument_list|(
name|dep
argument_list|,
operator|&
name|ts
argument_list|,
operator|&
name|ts
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
name|vap
operator|->
name|va_fsid
operator|=
name|dev2udev
argument_list|(
name|pmp
operator|->
name|pm_dev
argument_list|)
expr_stmt|;
comment|/* 	 * The following computation of the fileid must be the same as that 	 * used in msdosfs_readdir() to compute d_fileno. If not, pwd 	 * doesn't work. 	 */
if|if
condition|(
name|dep
operator|->
name|de_Attributes
operator|&
name|ATTR_DIRECTORY
condition|)
block|{
name|fileid
operator|=
operator|(
name|uint64_t
operator|)
name|cntobn
argument_list|(
name|pmp
argument_list|,
name|dep
operator|->
name|de_StartCluster
argument_list|)
operator|*
name|dirsperblk
expr_stmt|;
if|if
condition|(
name|dep
operator|->
name|de_StartCluster
operator|==
name|MSDOSFSROOT
condition|)
name|fileid
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|fileid
operator|=
operator|(
name|uint64_t
operator|)
name|cntobn
argument_list|(
name|pmp
argument_list|,
name|dep
operator|->
name|de_dirclust
argument_list|)
operator|*
name|dirsperblk
expr_stmt|;
if|if
condition|(
name|dep
operator|->
name|de_dirclust
operator|==
name|MSDOSFSROOT
condition|)
name|fileid
operator|=
operator|(
name|uint64_t
operator|)
name|roottobn
argument_list|(
name|pmp
argument_list|,
literal|0
argument_list|)
operator|*
name|dirsperblk
expr_stmt|;
name|fileid
operator|+=
operator|(
name|uoff_t
operator|)
name|dep
operator|->
name|de_diroffset
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|direntry
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pmp
operator|->
name|pm_flags
operator|&
name|MSDOSFS_LARGEFS
condition|)
name|vap
operator|->
name|va_fileid
operator|=
name|msdosfs_fileno_map
argument_list|(
name|pmp
operator|->
name|pm_mountp
argument_list|,
name|fileid
argument_list|)
expr_stmt|;
else|else
name|vap
operator|->
name|va_fileid
operator|=
operator|(
name|long
operator|)
name|fileid
expr_stmt|;
name|mode
operator|=
name|S_IRWXU
operator||
name|S_IRWXG
operator||
name|S_IRWXO
expr_stmt|;
name|vap
operator|->
name|va_mode
operator|=
name|mode
operator|&
operator|(
name|ap
operator|->
name|a_vp
operator|->
name|v_type
operator|==
name|VDIR
condition|?
name|pmp
operator|->
name|pm_dirmask
else|:
name|pmp
operator|->
name|pm_mask
operator|)
expr_stmt|;
name|vap
operator|->
name|va_uid
operator|=
name|pmp
operator|->
name|pm_uid
expr_stmt|;
name|vap
operator|->
name|va_gid
operator|=
name|pmp
operator|->
name|pm_gid
expr_stmt|;
name|vap
operator|->
name|va_nlink
operator|=
literal|1
expr_stmt|;
name|vap
operator|->
name|va_rdev
operator|=
name|NODEV
expr_stmt|;
name|vap
operator|->
name|va_size
operator|=
name|dep
operator|->
name|de_FileSize
expr_stmt|;
name|fattime2timespec
argument_list|(
name|dep
operator|->
name|de_MDate
argument_list|,
name|dep
operator|->
name|de_MTime
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|vap
operator|->
name|va_mtime
argument_list|)
expr_stmt|;
name|vap
operator|->
name|va_ctime
operator|=
name|vap
operator|->
name|va_mtime
expr_stmt|;
if|if
condition|(
name|pmp
operator|->
name|pm_flags
operator|&
name|MSDOSFSMNT_LONGNAME
condition|)
block|{
name|fattime2timespec
argument_list|(
name|dep
operator|->
name|de_ADate
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|vap
operator|->
name|va_atime
argument_list|)
expr_stmt|;
name|fattime2timespec
argument_list|(
name|dep
operator|->
name|de_CDate
argument_list|,
name|dep
operator|->
name|de_CTime
argument_list|,
name|dep
operator|->
name|de_CHun
argument_list|,
literal|0
argument_list|,
operator|&
name|vap
operator|->
name|va_birthtime
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vap
operator|->
name|va_atime
operator|=
name|vap
operator|->
name|va_mtime
expr_stmt|;
name|vap
operator|->
name|va_birthtime
operator|.
name|tv_sec
operator|=
operator|-
literal|1
expr_stmt|;
name|vap
operator|->
name|va_birthtime
operator|.
name|tv_nsec
operator|=
literal|0
expr_stmt|;
block|}
name|vap
operator|->
name|va_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dep
operator|->
name|de_Attributes
operator|&
name|ATTR_ARCHIVE
condition|)
name|vap
operator|->
name|va_flags
operator||=
name|UF_ARCHIVE
expr_stmt|;
if|if
condition|(
name|dep
operator|->
name|de_Attributes
operator|&
name|ATTR_HIDDEN
condition|)
name|vap
operator|->
name|va_flags
operator||=
name|UF_HIDDEN
expr_stmt|;
if|if
condition|(
name|dep
operator|->
name|de_Attributes
operator|&
name|ATTR_READONLY
condition|)
name|vap
operator|->
name|va_flags
operator||=
name|UF_READONLY
expr_stmt|;
if|if
condition|(
name|dep
operator|->
name|de_Attributes
operator|&
name|ATTR_SYSTEM
condition|)
name|vap
operator|->
name|va_flags
operator||=
name|UF_SYSTEM
expr_stmt|;
name|vap
operator|->
name|va_gen
operator|=
literal|0
expr_stmt|;
name|vap
operator|->
name|va_blocksize
operator|=
name|pmp
operator|->
name|pm_bpcluster
expr_stmt|;
name|vap
operator|->
name|va_bytes
operator|=
operator|(
name|dep
operator|->
name|de_FileSize
operator|+
name|pmp
operator|->
name|pm_crbomask
operator|)
operator|&
operator|~
name|pmp
operator|->
name|pm_crbomask
expr_stmt|;
name|vap
operator|->
name|va_type
operator|=
name|ap
operator|->
name|a_vp
operator|->
name|v_type
expr_stmt|;
name|vap
operator|->
name|va_filerev
operator|=
name|dep
operator|->
name|de_modrev
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|msdosfs_setattr
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_setattr_args
comment|/* { 		struct vnode *a_vp; 		struct vattr *a_vap; 		struct ucred *a_cred; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|denode
modifier|*
name|dep
init|=
name|VTODE
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|struct
name|msdosfsmount
modifier|*
name|pmp
init|=
name|dep
operator|->
name|de_pmp
decl_stmt|;
name|struct
name|vattr
modifier|*
name|vap
init|=
name|ap
operator|->
name|a_vap
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|ap
operator|->
name|a_cred
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|MSDOSFS_DEBUG
name|printf
argument_list|(
literal|"msdosfs_setattr(): vp %p, vap %p, cred %p\n"
argument_list|,
name|ap
operator|->
name|a_vp
argument_list|,
name|vap
argument_list|,
name|cred
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Check for unsettable attributes. 	 */
if|if
condition|(
operator|(
name|vap
operator|->
name|va_type
operator|!=
name|VNON
operator|)
operator|||
operator|(
name|vap
operator|->
name|va_nlink
operator|!=
name|VNOVAL
operator|)
operator|||
operator|(
name|vap
operator|->
name|va_fsid
operator|!=
name|VNOVAL
operator|)
operator|||
operator|(
name|vap
operator|->
name|va_fileid
operator|!=
name|VNOVAL
operator|)
operator|||
operator|(
name|vap
operator|->
name|va_blocksize
operator|!=
name|VNOVAL
operator|)
operator|||
operator|(
name|vap
operator|->
name|va_rdev
operator|!=
name|VNOVAL
operator|)
operator|||
operator|(
name|vap
operator|->
name|va_bytes
operator|!=
name|VNOVAL
operator|)
operator|||
operator|(
name|vap
operator|->
name|va_gen
operator|!=
name|VNOVAL
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|MSDOSFS_DEBUG
name|printf
argument_list|(
literal|"msdosfs_setattr(): returning EINVAL\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    va_type %d, va_nlink %x, va_fsid %lx, va_fileid %lx\n"
argument_list|,
name|vap
operator|->
name|va_type
argument_list|,
name|vap
operator|->
name|va_nlink
argument_list|,
name|vap
operator|->
name|va_fsid
argument_list|,
name|vap
operator|->
name|va_fileid
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    va_blocksize %lx, va_rdev %x, va_bytes %qx, va_gen %lx\n"
argument_list|,
name|vap
operator|->
name|va_blocksize
argument_list|,
name|vap
operator|->
name|va_rdev
argument_list|,
name|vap
operator|->
name|va_bytes
argument_list|,
name|vap
operator|->
name|va_gen
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    va_uid %x, va_gid %x\n"
argument_list|,
name|vap
operator|->
name|va_uid
argument_list|,
name|vap
operator|->
name|va_gid
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 	 * We don't allow setting attributes on the root directory. 	 * The special case for the root directory is because before 	 * FAT32, the root directory didn't have an entry for itself 	 * (and was otherwise special).  With FAT32, the root 	 * directory is not so special, but still doesn't have an 	 * entry for itself. 	 */
if|if
condition|(
name|vp
operator|->
name|v_vflag
operator|&
name|VV_ROOT
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|vap
operator|->
name|va_flags
operator|!=
name|VNOVAL
condition|)
block|{
if|if
condition|(
name|vp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
condition|)
return|return
operator|(
name|EROFS
operator|)
return|;
if|if
condition|(
name|cred
operator|->
name|cr_uid
operator|!=
name|pmp
operator|->
name|pm_uid
condition|)
block|{
name|error
operator|=
name|priv_check_cred
argument_list|(
name|cred
argument_list|,
name|PRIV_VFS_ADMIN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 		 * We are very inconsistent about handling unsupported 		 * attributes.  We ignored the access time and the 		 * read and execute bits.  We were strict for the other 		 * attributes. 		 */
if|if
condition|(
name|vap
operator|->
name|va_flags
operator|&
operator|~
operator|(
name|UF_ARCHIVE
operator||
name|UF_HIDDEN
operator||
name|UF_READONLY
operator||
name|UF_SYSTEM
operator|)
condition|)
return|return
name|EOPNOTSUPP
return|;
if|if
condition|(
name|vap
operator|->
name|va_flags
operator|&
name|UF_ARCHIVE
condition|)
name|dep
operator|->
name|de_Attributes
operator||=
name|ATTR_ARCHIVE
expr_stmt|;
else|else
name|dep
operator|->
name|de_Attributes
operator|&=
operator|~
name|ATTR_ARCHIVE
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|va_flags
operator|&
name|UF_HIDDEN
condition|)
name|dep
operator|->
name|de_Attributes
operator||=
name|ATTR_HIDDEN
expr_stmt|;
else|else
name|dep
operator|->
name|de_Attributes
operator|&=
operator|~
name|ATTR_HIDDEN
expr_stmt|;
comment|/* We don't allow changing the readonly bit on directories. */
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|VDIR
condition|)
block|{
if|if
condition|(
name|vap
operator|->
name|va_flags
operator|&
name|UF_READONLY
condition|)
name|dep
operator|->
name|de_Attributes
operator||=
name|ATTR_READONLY
expr_stmt|;
else|else
name|dep
operator|->
name|de_Attributes
operator|&=
operator|~
name|ATTR_READONLY
expr_stmt|;
block|}
if|if
condition|(
name|vap
operator|->
name|va_flags
operator|&
name|UF_SYSTEM
condition|)
name|dep
operator|->
name|de_Attributes
operator||=
name|ATTR_SYSTEM
expr_stmt|;
else|else
name|dep
operator|->
name|de_Attributes
operator|&=
operator|~
name|ATTR_SYSTEM
expr_stmt|;
name|dep
operator|->
name|de_flag
operator||=
name|DE_MODIFIED
expr_stmt|;
block|}
if|if
condition|(
name|vap
operator|->
name|va_uid
operator|!=
operator|(
name|uid_t
operator|)
name|VNOVAL
operator|||
name|vap
operator|->
name|va_gid
operator|!=
operator|(
name|gid_t
operator|)
name|VNOVAL
condition|)
block|{
name|uid_t
name|uid
decl_stmt|;
name|gid_t
name|gid
decl_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
condition|)
return|return
operator|(
name|EROFS
operator|)
return|;
name|uid
operator|=
name|vap
operator|->
name|va_uid
expr_stmt|;
if|if
condition|(
name|uid
operator|==
operator|(
name|uid_t
operator|)
name|VNOVAL
condition|)
name|uid
operator|=
name|pmp
operator|->
name|pm_uid
expr_stmt|;
name|gid
operator|=
name|vap
operator|->
name|va_gid
expr_stmt|;
if|if
condition|(
name|gid
operator|==
operator|(
name|gid_t
operator|)
name|VNOVAL
condition|)
name|gid
operator|=
name|pmp
operator|->
name|pm_gid
expr_stmt|;
if|if
condition|(
name|cred
operator|->
name|cr_uid
operator|!=
name|pmp
operator|->
name|pm_uid
operator|||
name|uid
operator|!=
name|pmp
operator|->
name|pm_uid
operator|||
operator|(
name|gid
operator|!=
name|pmp
operator|->
name|pm_gid
operator|&&
operator|!
name|groupmember
argument_list|(
name|gid
argument_list|,
name|cred
argument_list|)
operator|)
condition|)
block|{
name|error
operator|=
name|priv_check_cred
argument_list|(
name|cred
argument_list|,
name|PRIV_VFS_CHOWN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|uid
operator|!=
name|pmp
operator|->
name|pm_uid
operator|||
name|gid
operator|!=
name|pmp
operator|->
name|pm_gid
condition|)
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
name|vap
operator|->
name|va_size
operator|!=
name|VNOVAL
condition|)
block|{
switch|switch
condition|(
name|vp
operator|->
name|v_type
condition|)
block|{
case|case
name|VDIR
case|:
return|return
operator|(
name|EISDIR
operator|)
return|;
case|case
name|VREG
case|:
comment|/* 			 * Truncation is only supported for regular files, 			 * Disallow it if the filesystem is read-only. 			 */
if|if
condition|(
name|vp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
condition|)
return|return
operator|(
name|EROFS
operator|)
return|;
break|break;
default|default:
comment|/* 			 * According to POSIX, the result is unspecified 			 * for file types other than regular files, 			 * directories and shared memory objects.  We 			 * don't support any file types except regular 			 * files and directories in this file system, so 			 * this (default) case is unreachable and can do 			 * anything.  Keep falling through to detrunc() 			 * for now. 			 */
break|break;
block|}
name|error
operator|=
name|detrunc
argument_list|(
name|dep
argument_list|,
name|vap
operator|->
name|va_size
argument_list|,
literal|0
argument_list|,
name|cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
block|}
if|if
condition|(
name|vap
operator|->
name|va_atime
operator|.
name|tv_sec
operator|!=
name|VNOVAL
operator|||
name|vap
operator|->
name|va_mtime
operator|.
name|tv_sec
operator|!=
name|VNOVAL
condition|)
block|{
if|if
condition|(
name|vp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
condition|)
return|return
operator|(
name|EROFS
operator|)
return|;
name|error
operator|=
name|vn_utimes_perm
argument_list|(
name|vp
argument_list|,
name|vap
argument_list|,
name|cred
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|pmp
operator|->
name|pm_flags
operator|&
name|MSDOSFSMNT_NOWIN95
operator|)
operator|==
literal|0
operator|&&
name|vap
operator|->
name|va_atime
operator|.
name|tv_sec
operator|!=
name|VNOVAL
condition|)
block|{
name|dep
operator|->
name|de_flag
operator|&=
operator|~
name|DE_ACCESS
expr_stmt|;
name|timespec2fattime
argument_list|(
operator|&
name|vap
operator|->
name|va_atime
argument_list|,
literal|0
argument_list|,
operator|&
name|dep
operator|->
name|de_ADate
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vap
operator|->
name|va_mtime
operator|.
name|tv_sec
operator|!=
name|VNOVAL
condition|)
block|{
name|dep
operator|->
name|de_flag
operator|&=
operator|~
name|DE_UPDATE
expr_stmt|;
name|timespec2fattime
argument_list|(
operator|&
name|vap
operator|->
name|va_mtime
argument_list|,
literal|0
argument_list|,
operator|&
name|dep
operator|->
name|de_MDate
argument_list|,
operator|&
name|dep
operator|->
name|de_MTime
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * We don't set the archive bit when modifying the time of 		 * a directory to emulate the Windows/DOS behavior. 		 */
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|VDIR
condition|)
name|dep
operator|->
name|de_Attributes
operator||=
name|ATTR_ARCHIVE
expr_stmt|;
name|dep
operator|->
name|de_flag
operator||=
name|DE_MODIFIED
expr_stmt|;
block|}
comment|/* 	 * DOS files only have the ability to have their writability 	 * attribute set, so we use the owner write bit to set the readonly 	 * attribute. 	 */
if|if
condition|(
name|vap
operator|->
name|va_mode
operator|!=
operator|(
name|mode_t
operator|)
name|VNOVAL
condition|)
block|{
if|if
condition|(
name|vp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
condition|)
return|return
operator|(
name|EROFS
operator|)
return|;
if|if
condition|(
name|cred
operator|->
name|cr_uid
operator|!=
name|pmp
operator|->
name|pm_uid
condition|)
block|{
name|error
operator|=
name|priv_check_cred
argument_list|(
name|cred
argument_list|,
name|PRIV_VFS_ADMIN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|VDIR
condition|)
block|{
comment|/* We ignore the read and execute bits. */
if|if
condition|(
name|vap
operator|->
name|va_mode
operator|&
name|VWRITE
condition|)
name|dep
operator|->
name|de_Attributes
operator|&=
operator|~
name|ATTR_READONLY
expr_stmt|;
else|else
name|dep
operator|->
name|de_Attributes
operator||=
name|ATTR_READONLY
expr_stmt|;
name|dep
operator|->
name|de_Attributes
operator||=
name|ATTR_ARCHIVE
expr_stmt|;
name|dep
operator|->
name|de_flag
operator||=
name|DE_MODIFIED
expr_stmt|;
block|}
block|}
return|return
operator|(
name|deupdat
argument_list|(
name|dep
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|msdosfs_read
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_read_args
comment|/* { 		struct vnode *a_vp; 		struct uio *a_uio; 		int a_ioflag; 		struct ucred *a_cred; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|blsize
decl_stmt|;
name|int
name|isadir
decl_stmt|;
name|ssize_t
name|orig_resid
decl_stmt|;
name|u_int
name|n
decl_stmt|;
name|u_long
name|diff
decl_stmt|;
name|u_long
name|on
decl_stmt|;
name|daddr_t
name|lbn
decl_stmt|;
name|daddr_t
name|rablock
decl_stmt|;
name|int
name|rasize
decl_stmt|;
name|int
name|seqcount
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|denode
modifier|*
name|dep
init|=
name|VTODE
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|msdosfsmount
modifier|*
name|pmp
init|=
name|dep
operator|->
name|de_pmp
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
init|=
name|ap
operator|->
name|a_uio
decl_stmt|;
comment|/* 	 * If they didn't ask for any data, then we are done. 	 */
name|orig_resid
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
if|if
condition|(
name|orig_resid
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * The caller is supposed to ensure that 	 * uio->uio_offset>= 0 and uio->uio_resid>= 0. 	 * We don't need to check for large offsets as in ffs because 	 * dep->de_FileSize<= DOS_FILESIZE_MAX< OFF_MAX, so large 	 * offsets cannot cause overflow even in theory. 	 */
name|seqcount
operator|=
name|ap
operator|->
name|a_ioflag
operator|>>
name|IO_SEQSHIFT
expr_stmt|;
name|isadir
operator|=
name|dep
operator|->
name|de_Attributes
operator|&
name|ATTR_DIRECTORY
expr_stmt|;
do|do
block|{
if|if
condition|(
name|uio
operator|->
name|uio_offset
operator|>=
name|dep
operator|->
name|de_FileSize
condition|)
break|break;
name|lbn
operator|=
name|de_cluster
argument_list|(
name|pmp
argument_list|,
name|uio
operator|->
name|uio_offset
argument_list|)
expr_stmt|;
name|rablock
operator|=
name|lbn
operator|+
literal|1
expr_stmt|;
name|blsize
operator|=
name|pmp
operator|->
name|pm_bpcluster
expr_stmt|;
name|on
operator|=
name|uio
operator|->
name|uio_offset
operator|&
name|pmp
operator|->
name|pm_crbomask
expr_stmt|;
comment|/* 		 * If we are operating on a directory file then be sure to 		 * do i/o with the vnode for the filesystem instead of the 		 * vnode for the directory. 		 */
if|if
condition|(
name|isadir
condition|)
block|{
comment|/* convert cluster # to block # */
name|error
operator|=
name|pcbmap
argument_list|(
name|dep
argument_list|,
name|lbn
argument_list|,
operator|&
name|lbn
argument_list|,
literal|0
argument_list|,
operator|&
name|blsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|E2BIG
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|error
condition|)
break|break;
name|error
operator|=
name|bread
argument_list|(
name|pmp
operator|->
name|pm_devvp
argument_list|,
name|lbn
argument_list|,
name|blsize
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|de_cn2off
argument_list|(
name|pmp
argument_list|,
name|rablock
argument_list|)
operator|>=
name|dep
operator|->
name|de_FileSize
condition|)
block|{
name|error
operator|=
name|bread
argument_list|(
name|vp
argument_list|,
name|lbn
argument_list|,
name|blsize
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|vp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_NOCLUSTERR
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|cluster_read
argument_list|(
name|vp
argument_list|,
name|dep
operator|->
name|de_FileSize
argument_list|,
name|lbn
argument_list|,
name|blsize
argument_list|,
name|NOCRED
argument_list|,
name|on
operator|+
name|uio
operator|->
name|uio_resid
argument_list|,
name|seqcount
argument_list|,
literal|0
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|seqcount
operator|>
literal|1
condition|)
block|{
name|rasize
operator|=
name|blsize
expr_stmt|;
name|error
operator|=
name|breadn
argument_list|(
name|vp
argument_list|,
name|lbn
argument_list|,
name|blsize
argument_list|,
operator|&
name|rablock
argument_list|,
operator|&
name|rasize
argument_list|,
literal|1
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|bread
argument_list|(
name|vp
argument_list|,
name|lbn
argument_list|,
name|blsize
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
break|break;
block|}
name|diff
operator|=
name|pmp
operator|->
name|pm_bpcluster
operator|-
name|on
expr_stmt|;
name|n
operator|=
name|diff
operator|>
name|uio
operator|->
name|uio_resid
condition|?
name|uio
operator|->
name|uio_resid
else|:
name|diff
expr_stmt|;
name|diff
operator|=
name|dep
operator|->
name|de_FileSize
operator|-
name|uio
operator|->
name|uio_offset
expr_stmt|;
if|if
condition|(
name|diff
operator|<
name|n
condition|)
name|n
operator|=
name|diff
expr_stmt|;
name|diff
operator|=
name|blsize
operator|-
name|bp
operator|->
name|b_resid
expr_stmt|;
if|if
condition|(
name|diff
operator|<
name|n
condition|)
name|n
operator|=
name|diff
expr_stmt|;
name|error
operator|=
name|uiomove
argument_list|(
name|bp
operator|->
name|b_data
operator|+
name|on
argument_list|,
operator|(
name|int
operator|)
name|n
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|error
operator|==
literal|0
operator|&&
name|uio
operator|->
name|uio_resid
operator|>
literal|0
operator|&&
name|n
operator|!=
literal|0
condition|)
do|;
if|if
condition|(
operator|!
name|isadir
operator|&&
operator|(
name|error
operator|==
literal|0
operator|||
name|uio
operator|->
name|uio_resid
operator|!=
name|orig_resid
operator|)
operator|&&
operator|(
name|vp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_NOATIME
operator|)
operator|==
literal|0
condition|)
name|dep
operator|->
name|de_flag
operator||=
name|DE_ACCESS
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Write data to a file or directory.  */
end_comment

begin_function
specifier|static
name|int
name|msdosfs_write
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_write_args
comment|/* { 		struct vnode *a_vp; 		struct uio *a_uio; 		int a_ioflag; 		struct ucred *a_cred; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
name|int
name|croffset
decl_stmt|;
name|ssize_t
name|resid
decl_stmt|;
name|u_long
name|osize
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|u_long
name|count
decl_stmt|;
name|int
name|seqcount
decl_stmt|;
name|daddr_t
name|bn
decl_stmt|,
name|lastcn
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|ioflag
init|=
name|ap
operator|->
name|a_ioflag
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
init|=
name|ap
operator|->
name|a_uio
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|thisvp
decl_stmt|;
name|struct
name|denode
modifier|*
name|dep
init|=
name|VTODE
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|msdosfsmount
modifier|*
name|pmp
init|=
name|dep
operator|->
name|de_pmp
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|ap
operator|->
name|a_cred
decl_stmt|;
ifdef|#
directive|ifdef
name|MSDOSFS_DEBUG
name|printf
argument_list|(
literal|"msdosfs_write(vp %p, uio %p, ioflag %x, cred %p\n"
argument_list|,
name|vp
argument_list|,
name|uio
argument_list|,
name|ioflag
argument_list|,
name|cred
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"msdosfs_write(): diroff %lu, dirclust %lu, startcluster %lu\n"
argument_list|,
name|dep
operator|->
name|de_diroffset
argument_list|,
name|dep
operator|->
name|de_dirclust
argument_list|,
name|dep
operator|->
name|de_StartCluster
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|vp
operator|->
name|v_type
condition|)
block|{
case|case
name|VREG
case|:
if|if
condition|(
name|ioflag
operator|&
name|IO_APPEND
condition|)
name|uio
operator|->
name|uio_offset
operator|=
name|dep
operator|->
name|de_FileSize
expr_stmt|;
name|thisvp
operator|=
name|vp
expr_stmt|;
break|break;
case|case
name|VDIR
case|:
return|return
name|EISDIR
return|;
default|default:
name|panic
argument_list|(
literal|"msdosfs_write(): bad file type"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * This is needed (unlike in ffs_write()) because we extend the 	 * file outside of the loop but we don't want to extend the file 	 * for writes of 0 bytes. 	 */
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * The caller is supposed to ensure that 	 * uio->uio_offset>= 0 and uio->uio_resid>= 0. 	 */
if|if
condition|(
operator|(
name|uoff_t
operator|)
name|uio
operator|->
name|uio_offset
operator|+
name|uio
operator|->
name|uio_resid
operator|>
name|DOS_FILESIZE_MAX
condition|)
return|return
operator|(
name|EFBIG
operator|)
return|;
comment|/* 	 * If they've exceeded their filesize limit, tell them about it. 	 */
if|if
condition|(
name|vn_rlimit_fsize
argument_list|(
name|vp
argument_list|,
name|uio
argument_list|,
name|uio
operator|->
name|uio_td
argument_list|)
condition|)
return|return
operator|(
name|EFBIG
operator|)
return|;
comment|/* 	 * If the offset we are starting the write at is beyond the end of 	 * the file, then they've done a seek.  Unix filesystems allow 	 * files with holes in them, DOS doesn't so we must fill the hole 	 * with zeroed blocks. 	 */
if|if
condition|(
name|uio
operator|->
name|uio_offset
operator|>
name|dep
operator|->
name|de_FileSize
condition|)
block|{
name|error
operator|=
name|deextend
argument_list|(
name|dep
argument_list|,
name|uio
operator|->
name|uio_offset
argument_list|,
name|cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Remember some values in case the write fails. 	 */
name|resid
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
name|osize
operator|=
name|dep
operator|->
name|de_FileSize
expr_stmt|;
comment|/* 	 * If we write beyond the end of the file, extend it to its ultimate 	 * size ahead of the time to hopefully get a contiguous area. 	 */
if|if
condition|(
name|uio
operator|->
name|uio_offset
operator|+
name|resid
operator|>
name|osize
condition|)
block|{
name|count
operator|=
name|de_clcount
argument_list|(
name|pmp
argument_list|,
name|uio
operator|->
name|uio_offset
operator|+
name|resid
argument_list|)
operator|-
name|de_clcount
argument_list|(
name|pmp
argument_list|,
name|osize
argument_list|)
expr_stmt|;
name|error
operator|=
name|extendfile
argument_list|(
name|dep
argument_list|,
name|count
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
operator|(
name|error
operator|!=
name|ENOSPC
operator|||
operator|(
name|ioflag
operator|&
name|IO_UNIT
operator|)
operator|)
condition|)
goto|goto
name|errexit
goto|;
name|lastcn
operator|=
name|dep
operator|->
name|de_fc
index|[
name|FC_LASTFC
index|]
operator|.
name|fc_frcn
expr_stmt|;
block|}
else|else
name|lastcn
operator|=
name|de_clcount
argument_list|(
name|pmp
argument_list|,
name|osize
argument_list|)
operator|-
literal|1
expr_stmt|;
name|seqcount
operator|=
name|ioflag
operator|>>
name|IO_SEQSHIFT
expr_stmt|;
do|do
block|{
if|if
condition|(
name|de_cluster
argument_list|(
name|pmp
argument_list|,
name|uio
operator|->
name|uio_offset
argument_list|)
operator|>
name|lastcn
condition|)
block|{
name|error
operator|=
name|ENOSPC
expr_stmt|;
break|break;
block|}
name|croffset
operator|=
name|uio
operator|->
name|uio_offset
operator|&
name|pmp
operator|->
name|pm_crbomask
expr_stmt|;
name|n
operator|=
name|min
argument_list|(
name|uio
operator|->
name|uio_resid
argument_list|,
name|pmp
operator|->
name|pm_bpcluster
operator|-
name|croffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|uio
operator|->
name|uio_offset
operator|+
name|n
operator|>
name|dep
operator|->
name|de_FileSize
condition|)
block|{
name|dep
operator|->
name|de_FileSize
operator|=
name|uio
operator|->
name|uio_offset
operator|+
name|n
expr_stmt|;
comment|/* The object size needs to be set before buffer is allocated */
name|vnode_pager_setsize
argument_list|(
name|vp
argument_list|,
name|dep
operator|->
name|de_FileSize
argument_list|)
expr_stmt|;
block|}
name|bn
operator|=
name|de_cluster
argument_list|(
name|pmp
argument_list|,
name|uio
operator|->
name|uio_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|uio
operator|->
name|uio_offset
operator|&
name|pmp
operator|->
name|pm_crbomask
operator|)
operator|==
literal|0
operator|&&
operator|(
name|de_cluster
argument_list|(
name|pmp
argument_list|,
name|uio
operator|->
name|uio_offset
operator|+
name|uio
operator|->
name|uio_resid
argument_list|)
operator|>
name|de_cluster
argument_list|(
name|pmp
argument_list|,
name|uio
operator|->
name|uio_offset
argument_list|)
operator|||
name|uio
operator|->
name|uio_offset
operator|+
name|uio
operator|->
name|uio_resid
operator|>=
name|dep
operator|->
name|de_FileSize
operator|)
condition|)
block|{
comment|/* 			 * If either the whole cluster gets written, 			 * or we write the cluster from its start beyond EOF, 			 * then no need to read data from disk. 			 */
name|bp
operator|=
name|getblk
argument_list|(
name|thisvp
argument_list|,
name|bn
argument_list|,
name|pmp
operator|->
name|pm_bpcluster
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vfs_bio_clrbuf
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* 			 * Do the bmap now, since pcbmap needs buffers 			 * for the fat table. (see msdosfs_strategy) 			 */
if|if
condition|(
name|bp
operator|->
name|b_blkno
operator|==
name|bp
operator|->
name|b_lblkno
condition|)
block|{
name|error
operator|=
name|pcbmap
argument_list|(
name|dep
argument_list|,
name|bp
operator|->
name|b_lblkno
argument_list|,
operator|&
name|bn
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|bp
operator|->
name|b_blkno
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|bp
operator|->
name|b_blkno
operator|=
name|bn
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|->
name|b_blkno
operator|==
operator|-
literal|1
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|EIO
expr_stmt|;
comment|/* XXX */
break|break;
block|}
block|}
else|else
block|{
comment|/* 			 * The block we need to write into exists, so read it in. 			 */
name|error
operator|=
name|bread
argument_list|(
name|thisvp
argument_list|,
name|bn
argument_list|,
name|pmp
operator|->
name|pm_bpcluster
argument_list|,
name|cred
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* 		 * Should these vnode_pager_* functions be done on dir 		 * files? 		 */
comment|/* 		 * Copy the data from user space into the buf header. 		 */
name|error
operator|=
name|uiomove
argument_list|(
name|bp
operator|->
name|b_data
operator|+
name|croffset
argument_list|,
name|n
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Prepare for clustered writes in some else clauses. */
if|if
condition|(
operator|(
name|vp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_NOCLUSTERW
operator|)
operator|==
literal|0
condition|)
name|bp
operator|->
name|b_flags
operator||=
name|B_CLUSTEROK
expr_stmt|;
comment|/* 		 * If IO_SYNC, then each buffer is written synchronously. 		 * Otherwise, if we have a severe page deficiency then 		 * write the buffer asynchronously.  Otherwise, if on a 		 * cluster boundary then write the buffer asynchronously, 		 * combining it with contiguous clusters if permitted and 		 * possible, since we don't expect more writes into this 		 * buffer soon.  Otherwise, do a delayed write because we 		 * expect more writes into this buffer soon. 		 */
if|if
condition|(
name|ioflag
operator|&
name|IO_SYNC
condition|)
operator|(
name|void
operator|)
name|bwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|vm_page_count_severe
argument_list|()
operator|||
name|buf_dirty_count_severe
argument_list|()
condition|)
name|bawrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|n
operator|+
name|croffset
operator|==
name|pmp
operator|->
name|pm_bpcluster
condition|)
block|{
if|if
condition|(
operator|(
name|vp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_NOCLUSTERW
operator|)
operator|==
literal|0
condition|)
name|cluster_write
argument_list|(
name|vp
argument_list|,
name|bp
argument_list|,
name|dep
operator|->
name|de_FileSize
argument_list|,
name|seqcount
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|bawrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
name|bdwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|dep
operator|->
name|de_flag
operator||=
name|DE_UPDATE
expr_stmt|;
block|}
do|while
condition|(
name|error
operator|==
literal|0
operator|&&
name|uio
operator|->
name|uio_resid
operator|>
literal|0
condition|)
do|;
comment|/* 	 * If the write failed and they want us to, truncate the file back 	 * to the size it was before the write was attempted. 	 */
name|errexit
label|:
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|ioflag
operator|&
name|IO_UNIT
condition|)
block|{
name|detrunc
argument_list|(
name|dep
argument_list|,
name|osize
argument_list|,
name|ioflag
operator|&
name|IO_SYNC
argument_list|,
name|NOCRED
argument_list|)
expr_stmt|;
name|uio
operator|->
name|uio_offset
operator|-=
name|resid
operator|-
name|uio
operator|->
name|uio_resid
expr_stmt|;
name|uio
operator|->
name|uio_resid
operator|=
name|resid
expr_stmt|;
block|}
else|else
block|{
name|detrunc
argument_list|(
name|dep
argument_list|,
name|dep
operator|->
name|de_FileSize
argument_list|,
name|ioflag
operator|&
name|IO_SYNC
argument_list|,
name|NOCRED
argument_list|)
expr_stmt|;
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|!=
name|resid
condition|)
name|error
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ioflag
operator|&
name|IO_SYNC
condition|)
name|error
operator|=
name|deupdat
argument_list|(
name|dep
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Flush the blocks of a file to disk.  */
end_comment

begin_function
specifier|static
name|int
name|msdosfs_fsync
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_fsync_args
comment|/* { 		struct vnode *a_vp; 		struct ucred *a_cred; 		int a_waitfor; 		struct thread *a_td; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|vnode
modifier|*
name|devvp
decl_stmt|;
name|int
name|allerror
decl_stmt|,
name|error
decl_stmt|;
name|vop_stdfsync
argument_list|(
name|ap
argument_list|)
expr_stmt|;
comment|/* 	* If the syncing request comes from fsync(2), sync the entire 	* FAT and any other metadata that happens to be on devvp.  We 	* need this mainly for the FAT.  We write the FAT sloppily, and 	* syncing it all now is the best we can easily do to get all 	* directory entries associated with the file (not just the file) 	* fully synced.  The other metadata includes critical metadata 	* for all directory entries, but only in the MNT_ASYNC case.  We 	* will soon sync all metadata in the file's directory entry. 	* Non-critical metadata for associated directory entries only 	* gets synced accidentally, as in most file systems. 	*/
if|if
condition|(
name|ap
operator|->
name|a_waitfor
operator|==
name|MNT_WAIT
condition|)
block|{
name|devvp
operator|=
name|VTODE
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
operator|->
name|de_pmp
operator|->
name|pm_devvp
expr_stmt|;
name|vn_lock
argument_list|(
name|devvp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
name|allerror
operator|=
name|VOP_FSYNC
argument_list|(
name|devvp
argument_list|,
name|MNT_WAIT
argument_list|,
name|ap
operator|->
name|a_td
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|devvp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|allerror
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|deupdat
argument_list|(
name|VTODE
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
argument_list|,
name|ap
operator|->
name|a_waitfor
operator|==
name|MNT_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|allerror
operator|==
literal|0
condition|)
name|allerror
operator|=
name|error
expr_stmt|;
return|return
operator|(
name|allerror
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|msdosfs_remove
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_remove_args
comment|/* { 		struct vnode *a_dvp; 		struct vnode *a_vp; 		struct componentname *a_cnp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|denode
modifier|*
name|dep
init|=
name|VTODE
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|struct
name|denode
modifier|*
name|ddep
init|=
name|VTODE
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|ap
operator|->
name|a_vp
operator|->
name|v_type
operator|==
name|VDIR
condition|)
name|error
operator|=
name|EPERM
expr_stmt|;
else|else
name|error
operator|=
name|removede
argument_list|(
name|ddep
argument_list|,
name|dep
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MSDOSFS_DEBUG
name|printf
argument_list|(
literal|"msdosfs_remove(), dep %p, v_usecount %d\n"
argument_list|,
name|dep
argument_list|,
name|ap
operator|->
name|a_vp
operator|->
name|v_usecount
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * DOS filesystems don't know what links are.  */
end_comment

begin_function
specifier|static
name|int
name|msdosfs_link
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_link_args
comment|/* { 		struct vnode *a_tdvp; 		struct vnode *a_vp; 		struct componentname *a_cnp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Renames on files require moving the denode to a new hash queue since the  * denode's location is used to compute which hash queue to put the file  * in. Unless it is a rename in place.  For example "mv a b".  *  * What follows is the basic algorithm:  *  * if (file move) {  *	if (dest file exists) {  *		remove dest file  *	}  *	if (dest and src in same directory) {  *		rewrite name in existing directory slot  *	} else {  *		write new entry in dest directory  *		update offset and dirclust in denode  *		move denode to new hash chain  *		clear old directory entry  *	}  * } else {  *	directory move  *	if (dest directory exists) {  *		if (dest is not empty) {  *			return ENOTEMPTY  *		}  *		remove dest directory  *	}  *	if (dest and src in same directory) {  *		rewrite name in existing entry  *	} else {  *		be sure dest is not a child of src directory  *		write entry in dest directory  *		update "." and ".." in moved directory  *		clear old directory entry for moved directory  *	}  * }  *  * On entry:  *	source's parent directory is unlocked  *	source file or directory is unlocked  *	destination's parent directory is locked  *	destination file or directory is locked if it exists  *  * On exit:  *	all denodes should be released  */
end_comment

begin_function
specifier|static
name|int
name|msdosfs_rename
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_rename_args
comment|/* { 		struct vnode *a_fdvp; 		struct vnode *a_fvp; 		struct componentname *a_fcnp; 		struct vnode *a_tdvp; 		struct vnode *a_tvp; 		struct componentname *a_tcnp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|vnode
modifier|*
name|tdvp
init|=
name|ap
operator|->
name|a_tdvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|fvp
init|=
name|ap
operator|->
name|a_fvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|fdvp
init|=
name|ap
operator|->
name|a_fdvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|tvp
init|=
name|ap
operator|->
name|a_tvp
decl_stmt|;
name|struct
name|componentname
modifier|*
name|tcnp
init|=
name|ap
operator|->
name|a_tcnp
decl_stmt|;
name|struct
name|componentname
modifier|*
name|fcnp
init|=
name|ap
operator|->
name|a_fcnp
decl_stmt|;
name|struct
name|denode
modifier|*
name|ip
decl_stmt|,
modifier|*
name|xp
decl_stmt|,
modifier|*
name|dp
decl_stmt|,
modifier|*
name|zp
decl_stmt|;
name|u_char
name|toname
index|[
literal|12
index|]
decl_stmt|,
name|oldname
index|[
literal|11
index|]
decl_stmt|;
name|u_long
name|from_diroffset
decl_stmt|,
name|to_diroffset
decl_stmt|;
name|u_char
name|to_count
decl_stmt|;
name|int
name|doingdirectory
init|=
literal|0
decl_stmt|,
name|newparent
init|=
literal|0
decl_stmt|;
name|int
name|error
decl_stmt|;
name|u_long
name|cn
decl_stmt|,
name|pcl
decl_stmt|;
name|daddr_t
name|bn
decl_stmt|;
name|struct
name|denode
modifier|*
name|fddep
decl_stmt|;
comment|/* from file's parent directory	 */
name|struct
name|msdosfsmount
modifier|*
name|pmp
decl_stmt|;
name|struct
name|direntry
modifier|*
name|dotdotp
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|fddep
operator|=
name|VTODE
argument_list|(
name|ap
operator|->
name|a_fdvp
argument_list|)
expr_stmt|;
name|pmp
operator|=
name|fddep
operator|->
name|de_pmp
expr_stmt|;
name|pmp
operator|=
name|VFSTOMSDOSFS
argument_list|(
name|fdvp
operator|->
name|v_mount
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
operator|(
name|tcnp
operator|->
name|cn_flags
operator|&
name|HASBUF
operator|)
operator|==
literal|0
operator|||
operator|(
name|fcnp
operator|->
name|cn_flags
operator|&
name|HASBUF
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"msdosfs_rename: no name"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Check for cross-device rename. 	 */
if|if
condition|(
name|fvp
operator|->
name|v_mount
operator|!=
name|tdvp
operator|->
name|v_mount
operator|||
operator|(
name|tvp
operator|&&
name|fvp
operator|->
name|v_mount
operator|!=
name|tvp
operator|->
name|v_mount
operator|)
condition|)
block|{
name|error
operator|=
name|EXDEV
expr_stmt|;
name|abortit
label|:
if|if
condition|(
name|tdvp
operator|==
name|tvp
condition|)
name|vrele
argument_list|(
name|tdvp
argument_list|)
expr_stmt|;
else|else
name|vput
argument_list|(
name|tdvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tvp
condition|)
name|vput
argument_list|(
name|tvp
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|fdvp
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|fvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * If source and dest are the same, do nothing. 	 */
if|if
condition|(
name|tvp
operator|==
name|fvp
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
goto|goto
name|abortit
goto|;
block|}
name|error
operator|=
name|vn_lock
argument_list|(
name|fvp
argument_list|,
name|LK_EXCLUSIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|abortit
goto|;
name|dp
operator|=
name|VTODE
argument_list|(
name|fdvp
argument_list|)
expr_stmt|;
name|ip
operator|=
name|VTODE
argument_list|(
name|fvp
argument_list|)
expr_stmt|;
comment|/* 	 * Be sure we are not renaming ".", "..", or an alias of ".". This 	 * leads to a crippled directory tree.  It's pretty tough to do a 	 * "ls" or "pwd" with the "." directory entry missing, and "cd .." 	 * doesn't work if the ".." entry is missing. 	 */
if|if
condition|(
name|ip
operator|->
name|de_Attributes
operator|&
name|ATTR_DIRECTORY
condition|)
block|{
comment|/* 		 * Avoid ".", "..", and aliases of "." for obvious reasons. 		 */
if|if
condition|(
operator|(
name|fcnp
operator|->
name|cn_namelen
operator|==
literal|1
operator|&&
name|fcnp
operator|->
name|cn_nameptr
index|[
literal|0
index|]
operator|==
literal|'.'
operator|)
operator|||
name|dp
operator|==
name|ip
operator|||
operator|(
name|fcnp
operator|->
name|cn_flags
operator|&
name|ISDOTDOT
operator|)
operator|||
operator|(
name|tcnp
operator|->
name|cn_flags
operator|&
name|ISDOTDOT
operator|)
operator|||
operator|(
name|ip
operator|->
name|de_flag
operator|&
name|DE_RENAME
operator|)
condition|)
block|{
name|VOP_UNLOCK
argument_list|(
name|fvp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|abortit
goto|;
block|}
name|ip
operator|->
name|de_flag
operator||=
name|DE_RENAME
expr_stmt|;
name|doingdirectory
operator|++
expr_stmt|;
block|}
comment|/* 	 * When the target exists, both the directory 	 * and target vnodes are returned locked. 	 */
name|dp
operator|=
name|VTODE
argument_list|(
name|tdvp
argument_list|)
expr_stmt|;
name|xp
operator|=
name|tvp
condition|?
name|VTODE
argument_list|(
name|tvp
argument_list|)
else|:
name|NULL
expr_stmt|;
comment|/* 	 * Remember direntry place to use for destination 	 */
name|to_diroffset
operator|=
name|dp
operator|->
name|de_fndoffset
expr_stmt|;
name|to_count
operator|=
name|dp
operator|->
name|de_fndcnt
expr_stmt|;
comment|/* 	 * If ".." must be changed (ie the directory gets a new 	 * parent) then the source directory must not be in the 	 * directory hierarchy above the target, as this would 	 * orphan everything below the source directory. Also 	 * the user must have write permission in the source so 	 * as to be able to change "..". We must repeat the call 	 * to namei, as the parent directory is unlocked by the 	 * call to doscheckpath(). 	 */
name|error
operator|=
name|VOP_ACCESS
argument_list|(
name|fvp
argument_list|,
name|VWRITE
argument_list|,
name|tcnp
operator|->
name|cn_cred
argument_list|,
name|tcnp
operator|->
name|cn_thread
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|fvp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|VTODE
argument_list|(
name|fdvp
argument_list|)
operator|->
name|de_StartCluster
operator|!=
name|VTODE
argument_list|(
name|tdvp
argument_list|)
operator|->
name|de_StartCluster
condition|)
name|newparent
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|doingdirectory
operator|&&
name|newparent
condition|)
block|{
if|if
condition|(
name|error
condition|)
comment|/* write access check above */
goto|goto
name|bad
goto|;
if|if
condition|(
name|xp
operator|!=
name|NULL
condition|)
name|vput
argument_list|(
name|tvp
argument_list|)
expr_stmt|;
comment|/* 		 * doscheckpath() vput()'s dp, 		 * so we have to do a relookup afterwards 		 */
name|error
operator|=
name|doscheckpath
argument_list|(
name|ip
argument_list|,
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|(
name|tcnp
operator|->
name|cn_flags
operator|&
name|SAVESTART
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"msdosfs_rename: lost to startdir"
argument_list|)
expr_stmt|;
name|error
operator|=
name|relookup
argument_list|(
name|tdvp
argument_list|,
operator|&
name|tvp
argument_list|,
name|tcnp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|dp
operator|=
name|VTODE
argument_list|(
name|tdvp
argument_list|)
expr_stmt|;
name|xp
operator|=
name|tvp
condition|?
name|VTODE
argument_list|(
name|tvp
argument_list|)
else|:
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|xp
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Target must be empty if a directory and have no links 		 * to it. Also, ensure source and target are compatible 		 * (both directories, or both not directories). 		 */
if|if
condition|(
name|xp
operator|->
name|de_Attributes
operator|&
name|ATTR_DIRECTORY
condition|)
block|{
if|if
condition|(
operator|!
name|dosdirempty
argument_list|(
name|xp
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENOTEMPTY
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
operator|!
name|doingdirectory
condition|)
block|{
name|error
operator|=
name|ENOTDIR
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|cache_purge
argument_list|(
name|tdvp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|doingdirectory
condition|)
block|{
name|error
operator|=
name|EISDIR
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|error
operator|=
name|removede
argument_list|(
name|dp
argument_list|,
name|xp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
name|vput
argument_list|(
name|tvp
argument_list|)
expr_stmt|;
name|xp
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * Convert the filename in tcnp into a dos filename. We copy this 	 * into the denode and directory entry for the destination 	 * file/directory. 	 */
name|error
operator|=
name|uniqdosname
argument_list|(
name|VTODE
argument_list|(
name|tdvp
argument_list|)
argument_list|,
name|tcnp
argument_list|,
name|toname
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|abortit
goto|;
comment|/* 	 * Since from wasn't locked at various places above, 	 * have to do a relookup here. 	 */
name|fcnp
operator|->
name|cn_flags
operator|&=
operator|~
name|MODMASK
expr_stmt|;
name|fcnp
operator|->
name|cn_flags
operator||=
name|LOCKPARENT
operator||
name|LOCKLEAF
expr_stmt|;
if|if
condition|(
operator|(
name|fcnp
operator|->
name|cn_flags
operator|&
name|SAVESTART
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"msdosfs_rename: lost from startdir"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|newparent
condition|)
name|VOP_UNLOCK
argument_list|(
name|tdvp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|relookup
argument_list|(
name|fdvp
argument_list|,
operator|&
name|fvp
argument_list|,
name|fcnp
argument_list|)
operator|==
literal|0
condition|)
name|vrele
argument_list|(
name|fdvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fvp
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * From name has disappeared. 		 */
if|if
condition|(
name|doingdirectory
condition|)
name|panic
argument_list|(
literal|"rename: lost dir entry"
argument_list|)
expr_stmt|;
if|if
condition|(
name|newparent
condition|)
name|VOP_UNLOCK
argument_list|(
name|tdvp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|tdvp
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|ap
operator|->
name|a_fvp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|xp
operator|=
name|VTODE
argument_list|(
name|fvp
argument_list|)
expr_stmt|;
name|zp
operator|=
name|VTODE
argument_list|(
name|fdvp
argument_list|)
expr_stmt|;
name|from_diroffset
operator|=
name|zp
operator|->
name|de_fndoffset
expr_stmt|;
comment|/* 	 * Ensure that the directory entry still exists and has not 	 * changed till now. If the source is a file the entry may 	 * have been unlinked or renamed. In either case there is 	 * no further work to be done. If the source is a directory 	 * then it cannot have been rmdir'ed or renamed; this is 	 * prohibited by the DE_RENAME flag. 	 */
if|if
condition|(
name|xp
operator|!=
name|ip
condition|)
block|{
if|if
condition|(
name|doingdirectory
condition|)
name|panic
argument_list|(
literal|"rename: lost dir entry"
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|fvp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|newparent
condition|)
name|VOP_UNLOCK
argument_list|(
name|fdvp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|ap
operator|->
name|a_fvp
argument_list|)
expr_stmt|;
name|xp
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|vrele
argument_list|(
name|fvp
argument_list|)
expr_stmt|;
name|xp
operator|=
name|NULL
expr_stmt|;
comment|/* 		 * First write a new entry in the destination 		 * directory and mark the entry in the source directory 		 * as deleted.  Then move the denode to the correct hash 		 * chain for its new location in the filesystem.  And, if 		 * we moved a directory, then update its .. entry to point 		 * to the new parent directory. 		 */
name|bcopy
argument_list|(
name|ip
operator|->
name|de_Name
argument_list|,
name|oldname
argument_list|,
literal|11
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|toname
argument_list|,
name|ip
operator|->
name|de_Name
argument_list|,
literal|11
argument_list|)
expr_stmt|;
comment|/* update denode */
name|dp
operator|->
name|de_fndoffset
operator|=
name|to_diroffset
expr_stmt|;
name|dp
operator|->
name|de_fndcnt
operator|=
name|to_count
expr_stmt|;
name|error
operator|=
name|createde
argument_list|(
name|ip
argument_list|,
name|dp
argument_list|,
operator|(
expr|struct
name|denode
operator|*
operator|*
operator|)
literal|0
argument_list|,
name|tcnp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|bcopy
argument_list|(
name|oldname
argument_list|,
name|ip
operator|->
name|de_Name
argument_list|,
literal|11
argument_list|)
expr_stmt|;
if|if
condition|(
name|newparent
condition|)
name|VOP_UNLOCK
argument_list|(
name|fdvp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|fvp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 		 * If ip is for a directory, then its name should always 		 * be "." since it is for the directory entry in the 		 * directory itself (msdosfs_lookup() always translates 		 * to the "." entry so as to get a unique denode, except 		 * for the root directory there are different 		 * complications).  However, we just corrupted its name 		 * to pass the correct name to createde().  Undo this. 		 */
if|if
condition|(
operator|(
name|ip
operator|->
name|de_Attributes
operator|&
name|ATTR_DIRECTORY
operator|)
operator|!=
literal|0
condition|)
name|bcopy
argument_list|(
name|oldname
argument_list|,
name|ip
operator|->
name|de_Name
argument_list|,
literal|11
argument_list|)
expr_stmt|;
name|ip
operator|->
name|de_refcnt
operator|++
expr_stmt|;
name|zp
operator|->
name|de_fndoffset
operator|=
name|from_diroffset
expr_stmt|;
name|error
operator|=
name|removede
argument_list|(
name|zp
argument_list|,
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* XXX should downgrade to ro here, fs is corrupt */
if|if
condition|(
name|newparent
condition|)
name|VOP_UNLOCK
argument_list|(
name|fdvp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|fvp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
operator|!
name|doingdirectory
condition|)
block|{
name|error
operator|=
name|pcbmap
argument_list|(
name|dp
argument_list|,
name|de_cluster
argument_list|(
name|pmp
argument_list|,
name|to_diroffset
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|&
name|ip
operator|->
name|de_dirclust
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* XXX should downgrade to ro here, fs is corrupt */
if|if
condition|(
name|newparent
condition|)
name|VOP_UNLOCK
argument_list|(
name|fdvp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|fvp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|ip
operator|->
name|de_dirclust
operator|==
name|MSDOSFSROOT
condition|)
name|ip
operator|->
name|de_diroffset
operator|=
name|to_diroffset
expr_stmt|;
else|else
name|ip
operator|->
name|de_diroffset
operator|=
name|to_diroffset
operator|&
name|pmp
operator|->
name|pm_crbomask
expr_stmt|;
block|}
name|reinsert
argument_list|(
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
name|newparent
condition|)
name|VOP_UNLOCK
argument_list|(
name|fdvp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we moved a directory to a new parent directory, then we must 	 * fixup the ".." entry in the moved directory. 	 */
if|if
condition|(
name|doingdirectory
operator|&&
name|newparent
condition|)
block|{
name|cn
operator|=
name|ip
operator|->
name|de_StartCluster
expr_stmt|;
if|if
condition|(
name|cn
operator|==
name|MSDOSFSROOT
condition|)
block|{
comment|/* this should never happen */
name|panic
argument_list|(
literal|"msdosfs_rename(): updating .. in root directory?"
argument_list|)
expr_stmt|;
block|}
else|else
name|bn
operator|=
name|cntobn
argument_list|(
name|pmp
argument_list|,
name|cn
argument_list|)
expr_stmt|;
name|error
operator|=
name|bread
argument_list|(
name|pmp
operator|->
name|pm_devvp
argument_list|,
name|bn
argument_list|,
name|pmp
operator|->
name|pm_bpcluster
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* XXX should downgrade to ro here, fs is corrupt */
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|fvp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|dotdotp
operator|=
operator|(
expr|struct
name|direntry
operator|*
operator|)
name|bp
operator|->
name|b_data
operator|+
literal|1
expr_stmt|;
name|pcl
operator|=
name|dp
operator|->
name|de_StartCluster
expr_stmt|;
if|if
condition|(
name|FAT32
argument_list|(
name|pmp
argument_list|)
operator|&&
name|pcl
operator|==
name|pmp
operator|->
name|pm_rootdirblk
condition|)
name|pcl
operator|=
name|MSDOSFSROOT
expr_stmt|;
name|putushort
argument_list|(
name|dotdotp
operator|->
name|deStartCluster
argument_list|,
name|pcl
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAT32
argument_list|(
name|pmp
argument_list|)
condition|)
name|putushort
argument_list|(
name|dotdotp
operator|->
name|deHighClust
argument_list|,
name|pcl
operator|>>
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|DOINGASYNC
argument_list|(
name|fvp
argument_list|)
condition|)
name|bdwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|error
operator|=
name|bwrite
argument_list|(
name|bp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* XXX should downgrade to ro here, fs is corrupt */
name|VOP_UNLOCK
argument_list|(
name|fvp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
comment|/* 	 * The msdosfs lookup is case insensitive. Several aliases may 	 * be inserted for a single directory entry. As a consequnce, 	 * name cache purge done by lookup for fvp when DELETE op for 	 * namei is specified, might be not enough to expunge all 	 * namecache entries that were installed for this direntry. 	 */
name|cache_purge
argument_list|(
name|fvp
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|fvp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bad
label|:
if|if
condition|(
name|xp
condition|)
name|vput
argument_list|(
name|tvp
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|tdvp
argument_list|)
expr_stmt|;
name|out
label|:
name|ip
operator|->
name|de_flag
operator|&=
operator|~
name|DE_RENAME
expr_stmt|;
name|vrele
argument_list|(
name|fdvp
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|fvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_struct
specifier|static
struct|struct
block|{
name|struct
name|direntry
name|dot
decl_stmt|;
name|struct
name|direntry
name|dotdot
decl_stmt|;
block|}
name|dosdirtemplate
init|=
block|{
block|{
literal|".          "
block|,
comment|/* the . entry */
name|ATTR_DIRECTORY
block|,
comment|/* file attribute */
literal|0
block|,
comment|/* reserved */
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/* create time& date */
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/* access date */
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/* high bits of start cluster */
block|{
literal|210
block|,
literal|4
block|}
block|,
block|{
literal|210
block|,
literal|4
block|}
block|,
comment|/* modify time& date */
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/* startcluster */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
comment|/* filesize */
block|}
block|,
block|{
literal|"..         "
block|,
comment|/* the .. entry */
name|ATTR_DIRECTORY
block|,
comment|/* file attribute */
literal|0
block|,
comment|/* reserved */
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/* create time& date */
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/* access date */
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/* high bits of start cluster */
block|{
literal|210
block|,
literal|4
block|}
block|,
block|{
literal|210
block|,
literal|4
block|}
block|,
comment|/* modify time& date */
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/* startcluster */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
comment|/* filesize */
block|}
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|msdosfs_mkdir
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_mkdir_args
comment|/* { 		struct vnode *a_dvp; 		struct vnode **a_vpp; 		struvt componentname *a_cnp; 		struct vattr *a_vap; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
name|struct
name|denode
modifier|*
name|dep
decl_stmt|;
name|struct
name|denode
modifier|*
name|pdep
init|=
name|VTODE
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
decl_stmt|;
name|struct
name|direntry
modifier|*
name|denp
decl_stmt|;
name|struct
name|msdosfsmount
modifier|*
name|pmp
init|=
name|pdep
operator|->
name|de_pmp
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|u_long
name|newcluster
decl_stmt|,
name|pcl
decl_stmt|;
name|int
name|bn
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|denode
name|ndirent
decl_stmt|;
name|struct
name|timespec
name|ts
decl_stmt|;
comment|/* 	 * If this is the root directory and there is no space left we 	 * can't do anything.  This is because the root directory can not 	 * change size. 	 */
if|if
condition|(
name|pdep
operator|->
name|de_StartCluster
operator|==
name|MSDOSFSROOT
operator|&&
name|pdep
operator|->
name|de_fndoffset
operator|>=
name|pdep
operator|->
name|de_FileSize
condition|)
block|{
name|error
operator|=
name|ENOSPC
expr_stmt|;
goto|goto
name|bad2
goto|;
block|}
comment|/* 	 * Allocate a cluster to hold the about to be created directory. 	 */
name|error
operator|=
name|clusteralloc
argument_list|(
name|pmp
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|CLUST_EOFE
argument_list|,
operator|&
name|newcluster
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad2
goto|;
name|bzero
argument_list|(
operator|&
name|ndirent
argument_list|,
sizeof|sizeof
argument_list|(
name|ndirent
argument_list|)
argument_list|)
expr_stmt|;
name|ndirent
operator|.
name|de_pmp
operator|=
name|pmp
expr_stmt|;
name|ndirent
operator|.
name|de_flag
operator|=
name|DE_ACCESS
operator||
name|DE_CREATE
operator||
name|DE_UPDATE
expr_stmt|;
name|getnanotime
argument_list|(
operator|&
name|ts
argument_list|)
expr_stmt|;
name|DETIMES
argument_list|(
operator|&
name|ndirent
argument_list|,
operator|&
name|ts
argument_list|,
operator|&
name|ts
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
comment|/* 	 * Now fill the cluster with the "." and ".." entries. And write 	 * the cluster to disk.  This way it is there for the parent 	 * directory to be pointing at if there were a crash. 	 */
name|bn
operator|=
name|cntobn
argument_list|(
name|pmp
argument_list|,
name|newcluster
argument_list|)
expr_stmt|;
comment|/* always succeeds */
name|bp
operator|=
name|getblk
argument_list|(
name|pmp
operator|->
name|pm_devvp
argument_list|,
name|bn
argument_list|,
name|pmp
operator|->
name|pm_bpcluster
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|bp
operator|->
name|b_data
argument_list|,
name|pmp
operator|->
name|pm_bpcluster
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|dosdirtemplate
argument_list|,
name|bp
operator|->
name|b_data
argument_list|,
sizeof|sizeof
name|dosdirtemplate
argument_list|)
expr_stmt|;
name|denp
operator|=
operator|(
expr|struct
name|direntry
operator|*
operator|)
name|bp
operator|->
name|b_data
expr_stmt|;
name|putushort
argument_list|(
name|denp
index|[
literal|0
index|]
operator|.
name|deStartCluster
argument_list|,
name|newcluster
argument_list|)
expr_stmt|;
name|putushort
argument_list|(
name|denp
index|[
literal|0
index|]
operator|.
name|deCDate
argument_list|,
name|ndirent
operator|.
name|de_CDate
argument_list|)
expr_stmt|;
name|putushort
argument_list|(
name|denp
index|[
literal|0
index|]
operator|.
name|deCTime
argument_list|,
name|ndirent
operator|.
name|de_CTime
argument_list|)
expr_stmt|;
name|denp
index|[
literal|0
index|]
operator|.
name|deCHundredth
operator|=
name|ndirent
operator|.
name|de_CHun
expr_stmt|;
name|putushort
argument_list|(
name|denp
index|[
literal|0
index|]
operator|.
name|deADate
argument_list|,
name|ndirent
operator|.
name|de_ADate
argument_list|)
expr_stmt|;
name|putushort
argument_list|(
name|denp
index|[
literal|0
index|]
operator|.
name|deMDate
argument_list|,
name|ndirent
operator|.
name|de_MDate
argument_list|)
expr_stmt|;
name|putushort
argument_list|(
name|denp
index|[
literal|0
index|]
operator|.
name|deMTime
argument_list|,
name|ndirent
operator|.
name|de_MTime
argument_list|)
expr_stmt|;
name|pcl
operator|=
name|pdep
operator|->
name|de_StartCluster
expr_stmt|;
comment|/* 	 * Although the root directory has a non-magic starting cluster 	 * number for FAT32, chkdsk and fsck_msdosfs still require 	 * references to it in dotdot entries to be magic. 	 */
if|if
condition|(
name|FAT32
argument_list|(
name|pmp
argument_list|)
operator|&&
name|pcl
operator|==
name|pmp
operator|->
name|pm_rootdirblk
condition|)
name|pcl
operator|=
name|MSDOSFSROOT
expr_stmt|;
name|putushort
argument_list|(
name|denp
index|[
literal|1
index|]
operator|.
name|deStartCluster
argument_list|,
name|pcl
argument_list|)
expr_stmt|;
name|putushort
argument_list|(
name|denp
index|[
literal|1
index|]
operator|.
name|deCDate
argument_list|,
name|ndirent
operator|.
name|de_CDate
argument_list|)
expr_stmt|;
name|putushort
argument_list|(
name|denp
index|[
literal|1
index|]
operator|.
name|deCTime
argument_list|,
name|ndirent
operator|.
name|de_CTime
argument_list|)
expr_stmt|;
name|denp
index|[
literal|1
index|]
operator|.
name|deCHundredth
operator|=
name|ndirent
operator|.
name|de_CHun
expr_stmt|;
name|putushort
argument_list|(
name|denp
index|[
literal|1
index|]
operator|.
name|deADate
argument_list|,
name|ndirent
operator|.
name|de_ADate
argument_list|)
expr_stmt|;
name|putushort
argument_list|(
name|denp
index|[
literal|1
index|]
operator|.
name|deMDate
argument_list|,
name|ndirent
operator|.
name|de_MDate
argument_list|)
expr_stmt|;
name|putushort
argument_list|(
name|denp
index|[
literal|1
index|]
operator|.
name|deMTime
argument_list|,
name|ndirent
operator|.
name|de_MTime
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAT32
argument_list|(
name|pmp
argument_list|)
condition|)
block|{
name|putushort
argument_list|(
name|denp
index|[
literal|0
index|]
operator|.
name|deHighClust
argument_list|,
name|newcluster
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|putushort
argument_list|(
name|denp
index|[
literal|1
index|]
operator|.
name|deHighClust
argument_list|,
name|pcl
operator|>>
literal|16
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DOINGASYNC
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
condition|)
name|bdwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|error
operator|=
name|bwrite
argument_list|(
name|bp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|bad
goto|;
comment|/* 	 * Now build up a directory entry pointing to the newly allocated 	 * cluster.  This will be written to an empty slot in the parent 	 * directory. 	 */
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
operator|(
name|cnp
operator|->
name|cn_flags
operator|&
name|HASBUF
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"msdosfs_mkdir: no name"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|error
operator|=
name|uniqdosname
argument_list|(
name|pdep
argument_list|,
name|cnp
argument_list|,
name|ndirent
operator|.
name|de_Name
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
name|ndirent
operator|.
name|de_Attributes
operator|=
name|ATTR_DIRECTORY
expr_stmt|;
name|ndirent
operator|.
name|de_LowerCase
operator|=
literal|0
expr_stmt|;
name|ndirent
operator|.
name|de_StartCluster
operator|=
name|newcluster
expr_stmt|;
name|ndirent
operator|.
name|de_FileSize
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|createde
argument_list|(
operator|&
name|ndirent
argument_list|,
name|pdep
argument_list|,
operator|&
name|dep
argument_list|,
name|cnp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
operator|*
name|ap
operator|->
name|a_vpp
operator|=
name|DETOV
argument_list|(
name|dep
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|bad
label|:
name|clusterfree
argument_list|(
name|pmp
argument_list|,
name|newcluster
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|bad2
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|msdosfs_rmdir
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_rmdir_args
comment|/* { 		struct vnode *a_dvp; 		struct vnode *a_vp; 		struct componentname *a_cnp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|dvp
init|=
name|ap
operator|->
name|a_dvp
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
name|struct
name|denode
modifier|*
name|ip
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ip
operator|=
name|VTODE
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|dp
operator|=
name|VTODE
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
comment|/* 	 * Verify the directory is empty (and valid). 	 * (Rmdir ".." won't be valid since 	 *  ".." will contain a reference to 	 *  the current directory and thus be 	 *  non-empty.) 	 */
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|dosdirempty
argument_list|(
name|ip
argument_list|)
operator|||
name|ip
operator|->
name|de_flag
operator|&
name|DE_RENAME
condition|)
block|{
name|error
operator|=
name|ENOTEMPTY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Delete the entry from the directory.  For dos filesystems this 	 * gets rid of the directory entry on disk, the in memory copy 	 * still exists but the de_refcnt is<= 0.  This prevents it from 	 * being found by deget().  When the vput() on dep is done we give 	 * up access and eventually msdosfs_reclaim() will be called which 	 * will remove it from the denode cache. 	 */
name|error
operator|=
name|removede
argument_list|(
name|dp
argument_list|,
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * This is where we decrement the link count in the parent 	 * directory.  Since dos filesystems don't do this we just purge 	 * the name cache. 	 */
name|cache_purge
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
comment|/* 	 * Truncate the directory that is being deleted. 	 */
name|error
operator|=
name|detrunc
argument_list|(
name|ip
argument_list|,
operator|(
name|u_long
operator|)
literal|0
argument_list|,
name|IO_SYNC
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|)
expr_stmt|;
name|cache_purge
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|out
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * DOS filesystems don't know what symlinks are.  */
end_comment

begin_function
specifier|static
name|int
name|msdosfs_symlink
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_symlink_args
comment|/* { 		struct vnode *a_dvp; 		struct vnode **a_vpp; 		struct componentname *a_cnp; 		struct vattr *a_vap; 		char *a_target; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|msdosfs_readdir
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_readdir_args
comment|/* { 		struct vnode *a_vp; 		struct uio *a_uio; 		struct ucred *a_cred; 		int *a_eofflag; 		int *a_ncookies; 		u_long **a_cookies; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|mbnambuf
name|nb
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|diff
decl_stmt|;
name|long
name|n
decl_stmt|;
name|int
name|blsize
decl_stmt|;
name|long
name|on
decl_stmt|;
name|u_long
name|cn
decl_stmt|;
name|uint64_t
name|fileno
decl_stmt|;
name|u_long
name|dirsperblk
decl_stmt|;
name|long
name|bias
init|=
literal|0
decl_stmt|;
name|daddr_t
name|bn
decl_stmt|,
name|lbn
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|denode
modifier|*
name|dep
init|=
name|VTODE
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|struct
name|msdosfsmount
modifier|*
name|pmp
init|=
name|dep
operator|->
name|de_pmp
decl_stmt|;
name|struct
name|direntry
modifier|*
name|dentp
decl_stmt|;
name|struct
name|dirent
name|dirbuf
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
init|=
name|ap
operator|->
name|a_uio
decl_stmt|;
name|u_long
modifier|*
name|cookies
init|=
name|NULL
decl_stmt|;
name|int
name|ncookies
init|=
literal|0
decl_stmt|;
name|off_t
name|offset
decl_stmt|,
name|off
decl_stmt|;
name|int
name|chksum
init|=
operator|-
literal|1
decl_stmt|;
ifdef|#
directive|ifdef
name|MSDOSFS_DEBUG
name|printf
argument_list|(
literal|"msdosfs_readdir(): vp %p, uio %p, cred %p, eofflagp %p\n"
argument_list|,
name|ap
operator|->
name|a_vp
argument_list|,
name|uio
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_eofflag
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * msdosfs_readdir() won't operate properly on regular files since 	 * it does i/o only with the filesystem vnode, and hence can 	 * retrieve the wrong block from the buffer cache for a plain file. 	 * So, fail attempts to readdir() on a plain file. 	 */
if|if
condition|(
operator|(
name|dep
operator|->
name|de_Attributes
operator|&
name|ATTR_DIRECTORY
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ENOTDIR
operator|)
return|;
comment|/* 	 * To be safe, initialize dirbuf 	 */
name|bzero
argument_list|(
name|dirbuf
operator|.
name|d_name
argument_list|,
sizeof|sizeof
argument_list|(
name|dirbuf
operator|.
name|d_name
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * If the user buffer is smaller than the size of one dos directory 	 * entry or the file offset is not a multiple of the size of a 	 * directory entry, then we fail the read. 	 */
name|off
operator|=
name|offset
operator|=
name|uio
operator|->
name|uio_offset
expr_stmt|;
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|direntry
argument_list|)
operator|||
operator|(
name|offset
operator|&
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|direntry
argument_list|)
operator|-
literal|1
operator|)
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|ap
operator|->
name|a_ncookies
condition|)
block|{
name|ncookies
operator|=
name|uio
operator|->
name|uio_resid
operator|/
literal|16
expr_stmt|;
name|cookies
operator|=
name|malloc
argument_list|(
name|ncookies
operator|*
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
operator|*
name|ap
operator|->
name|a_cookies
operator|=
name|cookies
expr_stmt|;
operator|*
name|ap
operator|->
name|a_ncookies
operator|=
name|ncookies
expr_stmt|;
block|}
name|dirsperblk
operator|=
name|pmp
operator|->
name|pm_BytesPerSec
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|direntry
argument_list|)
expr_stmt|;
comment|/* 	 * If they are reading from the root directory then, we simulate 	 * the . and .. entries since these don't exist in the root 	 * directory.  We also set the offset bias to make up for having to 	 * simulate these entries. By this I mean that at file offset 64 we 	 * read the first entry in the root directory that lives on disk. 	 */
if|if
condition|(
name|dep
operator|->
name|de_StartCluster
operator|==
name|MSDOSFSROOT
operator|||
operator|(
name|FAT32
argument_list|(
name|pmp
argument_list|)
operator|&&
name|dep
operator|->
name|de_StartCluster
operator|==
name|pmp
operator|->
name|pm_rootdirblk
operator|)
condition|)
block|{
if|#
directive|if
literal|0
block|printf("msdosfs_readdir(): going after . or .. in root dir, offset %d\n", 		    offset);
endif|#
directive|endif
name|bias
operator|=
literal|2
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|direntry
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|<
name|bias
condition|)
block|{
for|for
control|(
name|n
operator|=
operator|(
name|int
operator|)
name|offset
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|direntry
argument_list|)
init|;
name|n
operator|<
literal|2
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|FAT32
argument_list|(
name|pmp
argument_list|)
condition|)
name|fileno
operator|=
operator|(
name|uint64_t
operator|)
name|cntobn
argument_list|(
name|pmp
argument_list|,
name|pmp
operator|->
name|pm_rootdirblk
argument_list|)
operator|*
name|dirsperblk
expr_stmt|;
else|else
name|fileno
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|pmp
operator|->
name|pm_flags
operator|&
name|MSDOSFS_LARGEFS
condition|)
block|{
name|dirbuf
operator|.
name|d_fileno
operator|=
name|msdosfs_fileno_map
argument_list|(
name|pmp
operator|->
name|pm_mountp
argument_list|,
name|fileno
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dirbuf
operator|.
name|d_fileno
operator|=
operator|(
name|uint32_t
operator|)
name|fileno
expr_stmt|;
block|}
name|dirbuf
operator|.
name|d_type
operator|=
name|DT_DIR
expr_stmt|;
switch|switch
condition|(
name|n
condition|)
block|{
case|case
literal|0
case|:
name|dirbuf
operator|.
name|d_namlen
operator|=
literal|1
expr_stmt|;
name|strcpy
argument_list|(
name|dirbuf
operator|.
name|d_name
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|dirbuf
operator|.
name|d_namlen
operator|=
literal|2
expr_stmt|;
name|strcpy
argument_list|(
name|dirbuf
operator|.
name|d_name
argument_list|,
literal|".."
argument_list|)
expr_stmt|;
break|break;
block|}
name|dirbuf
operator|.
name|d_reclen
operator|=
name|GENERIC_DIRSIZ
argument_list|(
operator|&
name|dirbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|<
name|dirbuf
operator|.
name|d_reclen
condition|)
goto|goto
name|out
goto|;
name|error
operator|=
name|uiomove
argument_list|(
operator|&
name|dirbuf
argument_list|,
name|dirbuf
operator|.
name|d_reclen
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|offset
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|direntry
argument_list|)
expr_stmt|;
name|off
operator|=
name|offset
expr_stmt|;
if|if
condition|(
name|cookies
condition|)
block|{
operator|*
name|cookies
operator|++
operator|=
name|offset
expr_stmt|;
if|if
condition|(
operator|--
name|ncookies
operator|<=
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
block|}
block|}
block|}
name|mbnambuf_init
argument_list|(
operator|&
name|nb
argument_list|)
expr_stmt|;
name|off
operator|=
name|offset
expr_stmt|;
while|while
condition|(
name|uio
operator|->
name|uio_resid
operator|>
literal|0
condition|)
block|{
name|lbn
operator|=
name|de_cluster
argument_list|(
name|pmp
argument_list|,
name|offset
operator|-
name|bias
argument_list|)
expr_stmt|;
name|on
operator|=
operator|(
name|offset
operator|-
name|bias
operator|)
operator|&
name|pmp
operator|->
name|pm_crbomask
expr_stmt|;
name|n
operator|=
name|min
argument_list|(
name|pmp
operator|->
name|pm_bpcluster
operator|-
name|on
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|)
expr_stmt|;
name|diff
operator|=
name|dep
operator|->
name|de_FileSize
operator|-
operator|(
name|offset
operator|-
name|bias
operator|)
expr_stmt|;
if|if
condition|(
name|diff
operator|<=
literal|0
condition|)
break|break;
name|n
operator|=
name|min
argument_list|(
name|n
argument_list|,
name|diff
argument_list|)
expr_stmt|;
name|error
operator|=
name|pcbmap
argument_list|(
name|dep
argument_list|,
name|lbn
argument_list|,
operator|&
name|bn
argument_list|,
operator|&
name|cn
argument_list|,
operator|&
name|blsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|error
operator|=
name|bread
argument_list|(
name|pmp
operator|->
name|pm_devvp
argument_list|,
name|bn
argument_list|,
name|blsize
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|n
operator|=
name|min
argument_list|(
name|n
argument_list|,
name|blsize
operator|-
name|bp
operator|->
name|b_resid
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* 		 * Convert from dos directory entries to fs-independent 		 * directory entries. 		 */
for|for
control|(
name|dentp
operator|=
operator|(
expr|struct
name|direntry
operator|*
operator|)
operator|(
name|bp
operator|->
name|b_data
operator|+
name|on
operator|)
init|;
operator|(
name|char
operator|*
operator|)
name|dentp
operator|<
name|bp
operator|->
name|b_data
operator|+
name|on
operator|+
name|n
condition|;
name|dentp
operator|++
operator|,
name|offset
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|direntry
argument_list|)
control|)
block|{
if|#
directive|if
literal|0
block|printf("rd: dentp %08x prev %08x crnt %08x deName %02x attr %02x\n", 			    dentp, prev, crnt, dentp->deName[0], dentp->deAttributes);
endif|#
directive|endif
comment|/* 			 * If this is an unused entry, we can stop. 			 */
if|if
condition|(
name|dentp
operator|->
name|deName
index|[
literal|0
index|]
operator|==
name|SLOT_EMPTY
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 			 * Skip deleted entries. 			 */
if|if
condition|(
name|dentp
operator|->
name|deName
index|[
literal|0
index|]
operator|==
name|SLOT_DELETED
condition|)
block|{
name|chksum
operator|=
operator|-
literal|1
expr_stmt|;
name|mbnambuf_init
argument_list|(
operator|&
name|nb
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 			 * Handle Win95 long directory entries 			 */
if|if
condition|(
name|dentp
operator|->
name|deAttributes
operator|==
name|ATTR_WIN95
condition|)
block|{
if|if
condition|(
name|pmp
operator|->
name|pm_flags
operator|&
name|MSDOSFSMNT_SHORTNAME
condition|)
continue|continue;
name|chksum
operator|=
name|win2unixfn
argument_list|(
operator|&
name|nb
argument_list|,
operator|(
expr|struct
name|winentry
operator|*
operator|)
name|dentp
argument_list|,
name|chksum
argument_list|,
name|pmp
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 			 * Skip volume labels 			 */
if|if
condition|(
name|dentp
operator|->
name|deAttributes
operator|&
name|ATTR_VOLUME
condition|)
block|{
name|chksum
operator|=
operator|-
literal|1
expr_stmt|;
name|mbnambuf_init
argument_list|(
operator|&
name|nb
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 			 * This computation of d_fileno must match 			 * the computation of va_fileid in 			 * msdosfs_getattr. 			 */
if|if
condition|(
name|dentp
operator|->
name|deAttributes
operator|&
name|ATTR_DIRECTORY
condition|)
block|{
name|fileno
operator|=
name|getushort
argument_list|(
name|dentp
operator|->
name|deStartCluster
argument_list|)
expr_stmt|;
if|if
condition|(
name|FAT32
argument_list|(
name|pmp
argument_list|)
condition|)
name|fileno
operator||=
name|getushort
argument_list|(
name|dentp
operator|->
name|deHighClust
argument_list|)
operator|<<
literal|16
expr_stmt|;
comment|/* if this is the root directory */
if|if
condition|(
name|fileno
operator|==
name|MSDOSFSROOT
condition|)
if|if
condition|(
name|FAT32
argument_list|(
name|pmp
argument_list|)
condition|)
name|fileno
operator|=
operator|(
name|uint64_t
operator|)
name|cntobn
argument_list|(
name|pmp
argument_list|,
name|pmp
operator|->
name|pm_rootdirblk
argument_list|)
operator|*
name|dirsperblk
expr_stmt|;
else|else
name|fileno
operator|=
literal|1
expr_stmt|;
else|else
name|fileno
operator|=
operator|(
name|uint64_t
operator|)
name|cntobn
argument_list|(
name|pmp
argument_list|,
name|fileno
argument_list|)
operator|*
name|dirsperblk
expr_stmt|;
name|dirbuf
operator|.
name|d_type
operator|=
name|DT_DIR
expr_stmt|;
block|}
else|else
block|{
name|fileno
operator|=
operator|(
name|uoff_t
operator|)
name|offset
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|direntry
argument_list|)
expr_stmt|;
name|dirbuf
operator|.
name|d_type
operator|=
name|DT_REG
expr_stmt|;
block|}
if|if
condition|(
name|pmp
operator|->
name|pm_flags
operator|&
name|MSDOSFS_LARGEFS
condition|)
block|{
name|dirbuf
operator|.
name|d_fileno
operator|=
name|msdosfs_fileno_map
argument_list|(
name|pmp
operator|->
name|pm_mountp
argument_list|,
name|fileno
argument_list|)
expr_stmt|;
block|}
else|else
name|dirbuf
operator|.
name|d_fileno
operator|=
operator|(
name|uint32_t
operator|)
name|fileno
expr_stmt|;
if|if
condition|(
name|chksum
operator|!=
name|winChksum
argument_list|(
name|dentp
operator|->
name|deName
argument_list|)
condition|)
block|{
name|dirbuf
operator|.
name|d_namlen
operator|=
name|dos2unixfn
argument_list|(
name|dentp
operator|->
name|deName
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|dirbuf
operator|.
name|d_name
argument_list|,
name|dentp
operator|->
name|deLowerCase
operator||
operator|(
operator|(
name|pmp
operator|->
name|pm_flags
operator|&
name|MSDOSFSMNT_SHORTNAME
operator|)
condition|?
operator|(
name|LCASE_BASE
operator||
name|LCASE_EXT
operator|)
else|:
literal|0
operator|)
argument_list|,
name|pmp
argument_list|)
expr_stmt|;
name|mbnambuf_init
argument_list|(
operator|&
name|nb
argument_list|)
expr_stmt|;
block|}
else|else
name|mbnambuf_flush
argument_list|(
operator|&
name|nb
argument_list|,
operator|&
name|dirbuf
argument_list|)
expr_stmt|;
name|chksum
operator|=
operator|-
literal|1
expr_stmt|;
name|dirbuf
operator|.
name|d_reclen
operator|=
name|GENERIC_DIRSIZ
argument_list|(
operator|&
name|dirbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|<
name|dirbuf
operator|.
name|d_reclen
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|error
operator|=
name|uiomove
argument_list|(
operator|&
name|dirbuf
argument_list|,
name|dirbuf
operator|.
name|d_reclen
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|cookies
condition|)
block|{
operator|*
name|cookies
operator|++
operator|=
name|offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|direntry
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|ncookies
operator|<=
literal|0
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|off
operator|=
name|offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|direntry
argument_list|)
expr_stmt|;
block|}
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
name|out
label|:
comment|/* Subtract unused cookies */
if|if
condition|(
name|ap
operator|->
name|a_ncookies
condition|)
operator|*
name|ap
operator|->
name|a_ncookies
operator|-=
name|ncookies
expr_stmt|;
name|uio
operator|->
name|uio_offset
operator|=
name|off
expr_stmt|;
comment|/* 	 * Set the eofflag (NFS uses it) 	 */
if|if
condition|(
name|ap
operator|->
name|a_eofflag
condition|)
block|{
if|if
condition|(
name|dep
operator|->
name|de_FileSize
operator|-
operator|(
name|offset
operator|-
name|bias
operator|)
operator|<=
literal|0
condition|)
operator|*
name|ap
operator|->
name|a_eofflag
operator|=
literal|1
expr_stmt|;
else|else
operator|*
name|ap
operator|->
name|a_eofflag
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  * a_vp   - pointer to the file's vnode  * a_bn   - logical block number within the file (cluster number for us)  * a_bop  - where to return the bufobj of the special file containing the fs  * a_bnp  - where to return the "physical" block number corresponding to a_bn  *          (relative to the special file; units are blocks of size DEV_BSIZE)  * a_runp - where to return the "run past" a_bn.  This is the count of logical  *          blocks whose physical blocks (together with a_bn's physical block)  *          are contiguous.  * a_runb - where to return the "run before" a_bn.  */
end_comment

begin_function
specifier|static
name|int
name|msdosfs_bmap
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_bmap_args
comment|/* { 		struct vnode *a_vp; 		daddr_t a_bn; 		struct bufobj **a_bop; 		daddr_t *a_bnp; 		int *a_runp; 		int *a_runb; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|denode
modifier|*
name|dep
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|struct
name|msdosfsmount
modifier|*
name|pmp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|daddr_t
name|runbn
decl_stmt|;
name|u_long
name|cn
decl_stmt|;
name|int
name|bnpercn
decl_stmt|,
name|error
decl_stmt|,
name|maxio
decl_stmt|,
name|maxrun
decl_stmt|,
name|run
decl_stmt|;
name|vp
operator|=
name|ap
operator|->
name|a_vp
expr_stmt|;
name|dep
operator|=
name|VTODE
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|pmp
operator|=
name|dep
operator|->
name|de_pmp
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|a_bop
operator|!=
name|NULL
condition|)
operator|*
name|ap
operator|->
name|a_bop
operator|=
operator|&
name|pmp
operator|->
name|pm_devvp
operator|->
name|v_bufobj
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|a_bnp
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|ap
operator|->
name|a_runp
operator|!=
name|NULL
condition|)
operator|*
name|ap
operator|->
name|a_runp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|a_runb
operator|!=
name|NULL
condition|)
operator|*
name|ap
operator|->
name|a_runb
operator|=
literal|0
expr_stmt|;
name|cn
operator|=
name|ap
operator|->
name|a_bn
expr_stmt|;
if|if
condition|(
name|cn
operator|!=
name|ap
operator|->
name|a_bn
condition|)
return|return
operator|(
name|EFBIG
operator|)
return|;
name|error
operator|=
name|pcbmap
argument_list|(
name|dep
argument_list|,
name|cn
argument_list|,
name|ap
operator|->
name|a_bnp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
operator|(
name|ap
operator|->
name|a_runp
operator|==
name|NULL
operator|&&
name|ap
operator|->
name|a_runb
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|mp
operator|=
name|vp
operator|->
name|v_mount
expr_stmt|;
name|maxio
operator|=
name|mp
operator|->
name|mnt_iosize_max
operator|/
name|mp
operator|->
name|mnt_stat
operator|.
name|f_iosize
expr_stmt|;
name|bnpercn
operator|=
name|de_cn2bn
argument_list|(
name|pmp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|a_runp
operator|!=
name|NULL
condition|)
block|{
name|maxrun
operator|=
name|ulmin
argument_list|(
name|maxio
operator|-
literal|1
argument_list|,
name|pmp
operator|->
name|pm_maxcluster
operator|-
name|cn
argument_list|)
expr_stmt|;
for|for
control|(
name|run
operator|=
literal|1
init|;
name|run
operator|<=
name|maxrun
condition|;
name|run
operator|++
control|)
block|{
if|if
condition|(
name|pcbmap
argument_list|(
name|dep
argument_list|,
name|cn
operator|+
name|run
argument_list|,
operator|&
name|runbn
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
operator|||
name|runbn
operator|!=
operator|*
name|ap
operator|->
name|a_bnp
operator|+
name|run
operator|*
name|bnpercn
condition|)
break|break;
block|}
operator|*
name|ap
operator|->
name|a_runp
operator|=
name|run
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|ap
operator|->
name|a_runb
operator|!=
name|NULL
condition|)
block|{
name|maxrun
operator|=
name|ulmin
argument_list|(
name|maxio
operator|-
literal|1
argument_list|,
name|cn
argument_list|)
expr_stmt|;
for|for
control|(
name|run
operator|=
literal|1
init|;
name|run
operator|<
name|maxrun
condition|;
name|run
operator|++
control|)
block|{
if|if
condition|(
name|pcbmap
argument_list|(
name|dep
argument_list|,
name|cn
operator|-
name|run
argument_list|,
operator|&
name|runbn
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
operator|||
name|runbn
operator|!=
operator|*
name|ap
operator|->
name|a_bnp
operator|-
name|run
operator|*
name|bnpercn
condition|)
break|break;
block|}
operator|*
name|ap
operator|->
name|a_runb
operator|=
name|run
operator|-
literal|1
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|msdosfs_strategy
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_strategy_args
comment|/* { 		struct vnode *a_vp; 		struct buf *a_bp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|buf
modifier|*
name|bp
init|=
name|ap
operator|->
name|a_bp
decl_stmt|;
name|struct
name|denode
modifier|*
name|dep
init|=
name|VTODE
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|struct
name|bufobj
modifier|*
name|bo
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|daddr_t
name|blkno
decl_stmt|;
comment|/* 	 * If we don't already know the filesystem relative block number 	 * then get it using pcbmap().  If pcbmap() returns the block 	 * number as -1 then we've got a hole in the file.  DOS filesystems 	 * don't allow files with holes, so we shouldn't ever see this. 	 */
if|if
condition|(
name|bp
operator|->
name|b_blkno
operator|==
name|bp
operator|->
name|b_lblkno
condition|)
block|{
name|error
operator|=
name|pcbmap
argument_list|(
name|dep
argument_list|,
name|bp
operator|->
name|b_lblkno
argument_list|,
operator|&
name|blkno
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_blkno
operator|=
name|blkno
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|error
expr_stmt|;
name|bp
operator|->
name|b_ioflags
operator||=
name|BIO_ERROR
expr_stmt|;
name|bufdone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|long
operator|)
name|bp
operator|->
name|b_blkno
operator|==
operator|-
literal|1
condition|)
name|vfs_bio_clrbuf
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|->
name|b_blkno
operator|==
operator|-
literal|1
condition|)
block|{
name|bufdone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Read/write the block from/to the disk that contains the desired 	 * file block. 	 */
name|bp
operator|->
name|b_iooffset
operator|=
name|dbtob
argument_list|(
name|bp
operator|->
name|b_blkno
argument_list|)
expr_stmt|;
name|bo
operator|=
name|dep
operator|->
name|de_pmp
operator|->
name|pm_bo
expr_stmt|;
name|BO_STRATEGY
argument_list|(
name|bo
argument_list|,
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|msdosfs_print
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_print_args
comment|/* { 		struct vnode *vp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|denode
modifier|*
name|dep
init|=
name|VTODE
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"\tstartcluster %lu, dircluster %lu, diroffset %lu, "
argument_list|,
name|dep
operator|->
name|de_StartCluster
argument_list|,
name|dep
operator|->
name|de_dirclust
argument_list|,
name|dep
operator|->
name|de_diroffset
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"on dev %s\n"
argument_list|,
name|devtoname
argument_list|(
name|dep
operator|->
name|de_pmp
operator|->
name|pm_dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|msdosfs_pathconf
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_pathconf_args
comment|/* { 		struct vnode *a_vp; 		int a_name; 		int *a_retval; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|msdosfsmount
modifier|*
name|pmp
init|=
name|VTODE
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
operator|->
name|de_pmp
decl_stmt|;
switch|switch
condition|(
name|ap
operator|->
name|a_name
condition|)
block|{
case|case
name|_PC_LINK_MAX
case|:
operator|*
name|ap
operator|->
name|a_retval
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|_PC_NAME_MAX
case|:
operator|*
name|ap
operator|->
name|a_retval
operator|=
name|pmp
operator|->
name|pm_flags
operator|&
name|MSDOSFSMNT_LONGNAME
condition|?
name|WIN_MAXLEN
else|:
literal|12
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|_PC_PATH_MAX
case|:
operator|*
name|ap
operator|->
name|a_retval
operator|=
name|PATH_MAX
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|_PC_CHOWN_RESTRICTED
case|:
operator|*
name|ap
operator|->
name|a_retval
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|_PC_NO_TRUNC
case|:
operator|*
name|ap
operator|->
name|a_retval
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_function
specifier|static
name|int
name|msdosfs_vptofh
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_vptofh_args
comment|/* { 		struct vnode *a_vp; 		struct fid *a_fhp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|denode
modifier|*
name|dep
decl_stmt|;
name|struct
name|defid
modifier|*
name|defhp
decl_stmt|;
name|dep
operator|=
name|VTODE
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
name|defhp
operator|=
operator|(
expr|struct
name|defid
operator|*
operator|)
name|ap
operator|->
name|a_fhp
expr_stmt|;
name|defhp
operator|->
name|defid_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|defid
argument_list|)
expr_stmt|;
name|defhp
operator|->
name|defid_dirclust
operator|=
name|dep
operator|->
name|de_dirclust
expr_stmt|;
name|defhp
operator|->
name|defid_dirofs
operator|=
name|dep
operator|->
name|de_diroffset
expr_stmt|;
comment|/* defhp->defid_gen = dep->de_gen; */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Global vfs data structures for msdosfs */
end_comment

begin_decl_stmt
name|struct
name|vop_vector
name|msdosfs_vnodeops
init|=
block|{
operator|.
name|vop_default
operator|=
operator|&
name|default_vnodeops
block|,
operator|.
name|vop_access
operator|=
name|msdosfs_access
block|,
operator|.
name|vop_bmap
operator|=
name|msdosfs_bmap
block|,
operator|.
name|vop_cachedlookup
operator|=
name|msdosfs_lookup
block|,
operator|.
name|vop_open
operator|=
name|msdosfs_open
block|,
operator|.
name|vop_close
operator|=
name|msdosfs_close
block|,
operator|.
name|vop_create
operator|=
name|msdosfs_create
block|,
operator|.
name|vop_fsync
operator|=
name|msdosfs_fsync
block|,
operator|.
name|vop_getattr
operator|=
name|msdosfs_getattr
block|,
operator|.
name|vop_inactive
operator|=
name|msdosfs_inactive
block|,
operator|.
name|vop_link
operator|=
name|msdosfs_link
block|,
operator|.
name|vop_lookup
operator|=
name|vfs_cache_lookup
block|,
operator|.
name|vop_mkdir
operator|=
name|msdosfs_mkdir
block|,
operator|.
name|vop_mknod
operator|=
name|msdosfs_mknod
block|,
operator|.
name|vop_pathconf
operator|=
name|msdosfs_pathconf
block|,
operator|.
name|vop_print
operator|=
name|msdosfs_print
block|,
operator|.
name|vop_read
operator|=
name|msdosfs_read
block|,
operator|.
name|vop_readdir
operator|=
name|msdosfs_readdir
block|,
operator|.
name|vop_reclaim
operator|=
name|msdosfs_reclaim
block|,
operator|.
name|vop_remove
operator|=
name|msdosfs_remove
block|,
operator|.
name|vop_rename
operator|=
name|msdosfs_rename
block|,
operator|.
name|vop_rmdir
operator|=
name|msdosfs_rmdir
block|,
operator|.
name|vop_setattr
operator|=
name|msdosfs_setattr
block|,
operator|.
name|vop_strategy
operator|=
name|msdosfs_strategy
block|,
operator|.
name|vop_symlink
operator|=
name|msdosfs_symlink
block|,
operator|.
name|vop_write
operator|=
name|msdosfs_write
block|,
operator|.
name|vop_vptofh
operator|=
name|msdosfs_vptofh
block|, }
decl_stmt|;
end_decl_stmt

end_unit

