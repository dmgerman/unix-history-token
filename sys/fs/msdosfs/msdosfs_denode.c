begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Written by Paul Popelka (paulp@uts.amdahl.com)  *   * You can do anything you want with this software, just don't say you wrote  * it, and don't reoove this notice.  *   * This software is provided "as is".  *   * The authop supplies this software to be publicly redistributed on the  * understanding that the author is not responsible for the correct  * functioning of this software in any circumstances and is not liable for  * any damages caused by this software.  *   * October 1992  *   *	from NetBSD:	msdosfs_denode.c,v 1.2 1993/12/18 00:50:51 mycroft Exp  *	$Id$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_comment
comment|/* defines "time" */
end_comment

begin_include
include|#
directive|include
file|<msdosfs/bpb.h>
end_include

begin_include
include|#
directive|include
file|<msdosfs/msdosfsmount.h>
end_include

begin_include
include|#
directive|include
file|<msdosfs/direntry.h>
end_include

begin_include
include|#
directive|include
file|<msdosfs/denode.h>
end_include

begin_include
include|#
directive|include
file|<msdosfs/fat.h>
end_include

begin_define
define|#
directive|define
name|DEHSZ
value|512
end_define

begin_if
if|#
directive|if
operator|(
operator|(
name|DEHSZ
operator|&
operator|(
name|DEHSZ
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
operator|)
end_if

begin_define
define|#
directive|define
name|DEHASH
parameter_list|(
name|dev
parameter_list|,
name|deno
parameter_list|)
value|(((dev)+(deno)+((deno)>>16))&(DEHSZ-1))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DEHASH
parameter_list|(
name|dev
parameter_list|,
name|deno
parameter_list|)
value|(((dev)+(deno)+((deno)>>16))%DEHSZ)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ((DEHSZ& (DEHSZ-1)) == 0) */
end_comment

begin_union
union|union
name|dehead
block|{
name|union
name|dehead
modifier|*
name|deh_head
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|denode
modifier|*
name|deh_chain
index|[
literal|2
index|]
decl_stmt|;
block|}
name|dehead
index|[
name|DEHSZ
index|]
union|;
end_union

begin_macro
name|msdosfs_init
argument_list|()
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|;
name|union
name|dehead
modifier|*
name|deh
decl_stmt|;
if|if
condition|(
name|VN_MAXPRIVATE
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|denode
argument_list|)
condition|)
name|panic
argument_list|(
literal|"msdosfs_init: vnode too small"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|DEHSZ
operator|,
name|deh
operator|=
name|dehead
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|deh
operator|++
control|)
block|{
name|deh
operator|->
name|deh_head
index|[
literal|0
index|]
operator|=
name|deh
expr_stmt|;
name|deh
operator|->
name|deh_head
index|[
literal|1
index|]
operator|=
name|deh
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * If deget() succeeds it returns with the gotten denode locked().   * pmp - address of msdosfsmount structure of the filesystem   *   containing the denode of interest.  The pm_dev field and the address   *   of the msdosfsmount structure are used.   * dirclust - which cluster bp contains, if dirclust is 0 (root directory)   *   diroffset is relative to the beginning of the root directory, otherwise   *   it is cluster relative.   * diroffset - offset past begin of cluster of denode we want   * direntptr - address of the direntry structure of interest. direntptr   *   is NULL, the block is read if necessary.   * depp - returns the address of the gotten denode.  */
end_comment

begin_function
name|int
name|deget
parameter_list|(
name|pmp
parameter_list|,
name|dirclust
parameter_list|,
name|diroffset
parameter_list|,
name|direntptr
parameter_list|,
name|depp
parameter_list|)
name|struct
name|msdosfsmount
modifier|*
name|pmp
decl_stmt|;
comment|/* so we know the maj/min number */
name|u_long
name|dirclust
decl_stmt|;
comment|/* cluster this dir entry came from */
name|u_long
name|diroffset
decl_stmt|;
comment|/* index of entry within the cluster */
name|struct
name|direntry
modifier|*
name|direntptr
decl_stmt|;
name|struct
name|denode
modifier|*
modifier|*
name|depp
decl_stmt|;
comment|/* returns the addr of the gotten denode */
block|{
name|int
name|error
decl_stmt|;
name|dev_t
name|dev
init|=
name|pmp
operator|->
name|pm_dev
decl_stmt|;
name|union
name|dehead
modifier|*
name|deh
decl_stmt|;
name|struct
name|mount
modifier|*
name|mntp
init|=
name|pmp
operator|->
name|pm_mountp
decl_stmt|;
specifier|extern
name|struct
name|vnodeops
name|msdosfs_vnodeops
decl_stmt|;
name|struct
name|denode
modifier|*
name|ldep
decl_stmt|;
name|struct
name|vnode
modifier|*
name|nvp
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|MSDOSFSDEBUG
argument_list|)
name|printf
argument_list|(
literal|"deget(pmp %08x, dirclust %d, diroffset %x, direntptr %x, depp %08x)\n"
argument_list|,
name|pmp
argument_list|,
name|dirclust
argument_list|,
name|diroffset
argument_list|,
name|direntptr
argument_list|,
name|depp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(MSDOSFSDEBUG) */
comment|/* 	 * If dir entry is given and refers to a directory, convert to 	 * canonical form 	 */
if|if
condition|(
name|direntptr
operator|&&
operator|(
name|direntptr
operator|->
name|deAttributes
operator|&
name|ATTR_DIRECTORY
operator|)
condition|)
block|{
name|dirclust
operator|=
name|direntptr
operator|->
name|deStartCluster
expr_stmt|;
if|if
condition|(
name|dirclust
operator|==
name|MSDOSFSROOT
condition|)
name|diroffset
operator|=
name|MSDOSFSROOT_OFS
expr_stmt|;
else|else
name|diroffset
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * See if the denode is in the denode cache. Use the location of 	 * the directory entry to compute the hash value. For subdir use 	 * address of "." entry. for root dir use cluster MSDOSFSROOT, 	 * offset MSDOSFSROOT_OFS 	 *  	 * NOTE: The check for de_refcnt> 0 below insures the denode being 	 * examined does not represent an unlinked but still open file. 	 * These files are not to be accessible even when the directory 	 * entry that represented the file happens to be reused while the 	 * deleted file is still open. 	 */
name|deh
operator|=
operator|&
name|dehead
index|[
name|DEHASH
argument_list|(
name|dev
argument_list|,
name|dirclust
operator|+
name|diroffset
argument_list|)
index|]
expr_stmt|;
name|loop
label|:
for|for
control|(
name|ldep
operator|=
name|deh
operator|->
name|deh_chain
index|[
literal|0
index|]
init|;
name|ldep
operator|!=
operator|(
expr|struct
name|denode
operator|*
operator|)
name|deh
condition|;
name|ldep
operator|=
name|ldep
operator|->
name|de_forw
control|)
block|{
if|if
condition|(
name|dev
operator|!=
name|ldep
operator|->
name|de_dev
operator|||
name|ldep
operator|->
name|de_refcnt
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|dirclust
operator|!=
name|ldep
operator|->
name|de_dirclust
operator|||
name|diroffset
operator|!=
name|ldep
operator|->
name|de_diroffset
condition|)
continue|continue;
if|if
condition|(
name|ldep
operator|->
name|de_flag
operator|&
name|DELOCKED
condition|)
block|{
comment|/* 			 * should we brelse() the passed buf hdr to avoid 			 * some potential deadlock? 			 */
name|ldep
operator|->
name|de_flag
operator||=
name|DEWANT
expr_stmt|;
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|ldep
argument_list|,
name|PINOD
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
if|if
condition|(
name|vget
argument_list|(
name|DETOV
argument_list|(
name|ldep
argument_list|)
argument_list|)
condition|)
goto|goto
name|loop
goto|;
operator|*
name|depp
operator|=
name|ldep
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * Directory entry was not in cache, have to create a vnode and 	 * copy it from the passed disk buffer. 	 */
comment|/* getnewvnode() does a VREF() on the vnode */
if|if
condition|(
name|error
operator|=
name|getnewvnode
argument_list|(
name|VT_MSDOSFS
argument_list|,
name|mntp
argument_list|,
operator|&
name|msdosfs_vnodeops
argument_list|,
operator|&
name|nvp
argument_list|)
condition|)
block|{
operator|*
name|depp
operator|=
literal|0
expr_stmt|;
return|return
name|error
return|;
block|}
name|ldep
operator|=
name|VTODE
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
name|ldep
operator|->
name|de_vnode
operator|=
name|nvp
expr_stmt|;
name|ldep
operator|->
name|de_flag
operator|=
literal|0
expr_stmt|;
name|ldep
operator|->
name|de_devvp
operator|=
literal|0
expr_stmt|;
name|ldep
operator|->
name|de_lockf
operator|=
literal|0
expr_stmt|;
name|ldep
operator|->
name|de_dev
operator|=
name|dev
expr_stmt|;
name|fc_purge
argument_list|(
name|ldep
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* init the fat cache for this denode */
comment|/* 	 * Insert the denode into the hash queue and lock the denode so it 	 * can't be accessed until we've read it in and have done what we 	 * need to it. 	 */
name|insque
argument_list|(
name|ldep
argument_list|,
name|deh
argument_list|)
expr_stmt|;
name|DELOCK
argument_list|(
name|ldep
argument_list|)
expr_stmt|;
comment|/* 	 * Copy the directory entry into the denode area of the vnode. 	 */
if|if
condition|(
name|dirclust
operator|==
name|MSDOSFSROOT
operator|&&
name|diroffset
operator|==
name|MSDOSFSROOT_OFS
condition|)
block|{
comment|/* 		 * Directory entry for the root directory. There isn't one, 		 * so we manufacture one. We should probably rummage 		 * through the root directory and find a label entry (if it 		 * exists), and then use the time and date from that entry 		 * as the time and date for the root denode. 		 */
name|ldep
operator|->
name|de_Attributes
operator|=
name|ATTR_DIRECTORY
expr_stmt|;
name|ldep
operator|->
name|de_StartCluster
operator|=
name|MSDOSFSROOT
expr_stmt|;
name|ldep
operator|->
name|de_FileSize
operator|=
name|pmp
operator|->
name|pm_rootdirsize
operator|*
name|pmp
operator|->
name|pm_BytesPerSec
expr_stmt|;
comment|/* 		 * fill in time and date so that dos2unixtime() doesn't 		 * spit up when called from msdosfs_getattr() with root 		 * denode 		 */
name|ldep
operator|->
name|de_Time
operator|=
literal|0x0000
expr_stmt|;
comment|/* 00:00:00	 */
name|ldep
operator|->
name|de_Date
operator|=
operator|(
literal|0
operator|<<
literal|9
operator|)
operator||
operator|(
literal|1
operator|<<
literal|5
operator|)
operator||
operator|(
literal|1
operator|<<
literal|0
operator|)
expr_stmt|;
comment|/* Jan 1, 1980	 */
comment|/* leave the other fields as garbage */
block|}
else|else
block|{
name|bp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|direntptr
condition|)
block|{
name|error
operator|=
name|readep
argument_list|(
name|pmp
argument_list|,
name|dirclust
argument_list|,
name|diroffset
argument_list|,
operator|&
name|bp
argument_list|,
operator|&
name|direntptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
block|}
name|ldep
operator|->
name|de_de
operator|=
operator|*
name|direntptr
expr_stmt|;
if|if
condition|(
name|bp
condition|)
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Fill in a few fields of the vnode and finish filling in the 	 * denode.  Then return the address of the found denode. 	 */
name|ldep
operator|->
name|de_pmp
operator|=
name|pmp
expr_stmt|;
name|ldep
operator|->
name|de_devvp
operator|=
name|pmp
operator|->
name|pm_devvp
expr_stmt|;
name|ldep
operator|->
name|de_refcnt
operator|=
literal|1
expr_stmt|;
name|ldep
operator|->
name|de_dirclust
operator|=
name|dirclust
expr_stmt|;
name|ldep
operator|->
name|de_diroffset
operator|=
name|diroffset
expr_stmt|;
if|if
condition|(
name|ldep
operator|->
name|de_Attributes
operator|&
name|ATTR_DIRECTORY
condition|)
block|{
comment|/* 		 * Since DOS directory entries that describe directories 		 * have 0 in the filesize field, we take this opportunity 		 * to find out the length of the directory and plug it into 		 * the denode structure. 		 */
name|u_long
name|size
decl_stmt|;
name|nvp
operator|->
name|v_type
operator|=
name|VDIR
expr_stmt|;
if|if
condition|(
name|ldep
operator|->
name|de_StartCluster
operator|==
name|MSDOSFSROOT
condition|)
name|nvp
operator|->
name|v_flag
operator||=
name|VROOT
expr_stmt|;
else|else
block|{
name|error
operator|=
name|pcbmap
argument_list|(
name|ldep
argument_list|,
literal|0xffff
argument_list|,
literal|0
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|E2BIG
condition|)
block|{
name|ldep
operator|->
name|de_FileSize
operator|=
name|size
operator|<<
name|pmp
operator|->
name|pm_cnshift
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"deget(): pcbmap returned %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|nvp
operator|->
name|v_type
operator|=
name|VREG
expr_stmt|;
name|VREF
argument_list|(
name|ldep
operator|->
name|de_devvp
argument_list|)
expr_stmt|;
operator|*
name|depp
operator|=
name|ldep
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|deput
parameter_list|(
name|dep
parameter_list|)
name|struct
name|denode
modifier|*
name|dep
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|dep
operator|->
name|de_flag
operator|&
name|DELOCKED
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"deput: denode not locked"
argument_list|)
expr_stmt|;
name|DEUNLOCK
argument_list|(
name|dep
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|DETOV
argument_list|(
name|dep
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|deupdat
parameter_list|(
name|dep
parameter_list|,
name|tp
parameter_list|,
name|waitfor
parameter_list|)
name|struct
name|denode
modifier|*
name|dep
decl_stmt|;
name|struct
name|timeval
modifier|*
name|tp
decl_stmt|;
name|int
name|waitfor
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|daddr_t
name|bn
decl_stmt|;
name|int
name|diro
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|direntry
modifier|*
name|dirp
decl_stmt|;
name|struct
name|msdosfsmount
modifier|*
name|pmp
init|=
name|dep
operator|->
name|de_pmp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
init|=
name|DETOV
argument_list|(
name|dep
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|MSDOSFSDEBUG
argument_list|)
name|printf
argument_list|(
literal|"deupdat(): dep %08x\n"
argument_list|,
name|dep
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(MSDOSFSDEBUG) */
comment|/* 	 * If the update bit is off, or this denode is from a readonly 	 * filesystem, or this denode is for a directory, or the denode 	 * represents an open but unlinked file then don't do anything. DOS 	 * directory entries that describe a directory do not ever get 	 * updated.  This is the way dos treats them. 	 */
if|if
condition|(
operator|(
name|dep
operator|->
name|de_flag
operator|&
name|DEUPD
operator|)
operator|==
literal|0
operator|||
name|vp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
operator|||
name|dep
operator|->
name|de_Attributes
operator|&
name|ATTR_DIRECTORY
operator|||
name|dep
operator|->
name|de_refcnt
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* 	 * Read in the cluster containing the directory entry we want to 	 * update. 	 */
if|if
condition|(
name|error
operator|=
name|readde
argument_list|(
name|dep
argument_list|,
operator|&
name|bp
argument_list|,
operator|&
name|dirp
argument_list|)
condition|)
return|return
name|error
return|;
comment|/* 	 * Put the passed in time into the directory entry. 	 */
name|unix2dostime
argument_list|(
operator|&
name|time
argument_list|,
operator|(
expr|union
name|dosdate
operator|*
operator|)
operator|&
name|dep
operator|->
name|de_Date
argument_list|,
operator|(
expr|union
name|dostime
operator|*
operator|)
operator|&
name|dep
operator|->
name|de_Time
argument_list|)
expr_stmt|;
name|dep
operator|->
name|de_flag
operator|&=
operator|~
name|DEUPD
expr_stmt|;
comment|/* 	 * Copy the directory entry out of the denode into the cluster it 	 * came from. 	 */
operator|*
name|dirp
operator|=
name|dep
operator|->
name|de_de
expr_stmt|;
comment|/* structure copy */
comment|/* 	 * Write the cluster back to disk.  If they asked for us to wait 	 * for the write to complete, then use bwrite() otherwise use 	 * bdwrite(). 	 */
name|error
operator|=
literal|0
expr_stmt|;
comment|/* note that error is 0 from above, but ... */
if|if
condition|(
name|waitfor
condition|)
name|error
operator|=
name|bwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
else|else
name|bdwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Truncate the file described by dep to the length specified by length.  */
end_comment

begin_function
name|int
name|detrunc
parameter_list|(
name|dep
parameter_list|,
name|length
parameter_list|,
name|flags
parameter_list|)
name|struct
name|denode
modifier|*
name|dep
decl_stmt|;
name|u_long
name|length
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|int
name|allerror
decl_stmt|;
name|u_long
name|eofentry
decl_stmt|;
name|u_long
name|chaintofree
decl_stmt|;
name|daddr_t
name|bn
decl_stmt|;
name|int
name|boff
decl_stmt|;
name|int
name|isadir
init|=
name|dep
operator|->
name|de_Attributes
operator|&
name|ATTR_DIRECTORY
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|msdosfsmount
modifier|*
name|pmp
init|=
name|dep
operator|->
name|de_pmp
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|MSDOSFSDEBUG
argument_list|)
name|printf
argument_list|(
literal|"detrunc(): file %s, length %d, flags %d\n"
argument_list|,
name|dep
operator|->
name|de_Name
argument_list|,
name|length
argument_list|,
name|flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(MSDOSFSDEBUG) */
comment|/* 	 * Disallow attempts to truncate the root directory since it is of 	 * fixed size.  That's just the way dos filesystems are.  We use 	 * the VROOT bit in the vnode because checking for the directory 	 * bit and a startcluster of 0 in the denode is not adequate to 	 * recognize the root directory at this point in a file or 	 * directory's life. 	 */
if|if
condition|(
name|DETOV
argument_list|(
name|dep
argument_list|)
operator|->
name|v_flag
operator|&
name|VROOT
condition|)
block|{
name|printf
argument_list|(
literal|"detrunc(): can't truncate root directory, clust %d, offset %d\n"
argument_list|,
name|dep
operator|->
name|de_dirclust
argument_list|,
name|dep
operator|->
name|de_diroffset
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|vnode_pager_setsize
argument_list|(
name|DETOV
argument_list|(
name|dep
argument_list|)
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|dep
operator|->
name|de_FileSize
operator|<=
name|length
condition|)
block|{
name|dep
operator|->
name|de_flag
operator||=
name|DEUPD
expr_stmt|;
name|error
operator|=
name|deupdat
argument_list|(
name|dep
argument_list|,
operator|&
name|time
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|MSDOSFSDEBUG
argument_list|)
name|printf
argument_list|(
literal|"detrunc(): file is shorter return point, errno %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(MSDOSFSDEBUG) */
return|return
name|error
return|;
block|}
comment|/* 	 * If the desired length is 0 then remember the starting cluster of 	 * the file and set the StartCluster field in the directory entry 	 * to 0.  If the desired length is not zero, then get the number of 	 * the last cluster in the shortened file.  Then get the number of 	 * the first cluster in the part of the file that is to be freed. 	 * Then set the next cluster pointer in the last cluster of the 	 * file to CLUST_EOFE. 	 */
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
name|chaintofree
operator|=
name|dep
operator|->
name|de_StartCluster
expr_stmt|;
name|dep
operator|->
name|de_StartCluster
operator|=
literal|0
expr_stmt|;
name|eofentry
operator|=
operator|~
literal|0
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|pcbmap
argument_list|(
name|dep
argument_list|,
operator|(
name|length
operator|-
literal|1
operator|)
operator|>>
name|pmp
operator|->
name|pm_cnshift
argument_list|,
literal|0
argument_list|,
operator|&
name|eofentry
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|MSDOSFSDEBUG
argument_list|)
name|printf
argument_list|(
literal|"detrunc(): pcbmap fails %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(MSDOSFSDEBUG) */
return|return
name|error
return|;
block|}
block|}
name|fc_purge
argument_list|(
name|dep
argument_list|,
operator|(
name|length
operator|+
name|pmp
operator|->
name|pm_crbomask
operator|)
operator|>>
name|pmp
operator|->
name|pm_cnshift
argument_list|)
expr_stmt|;
comment|/* 	 * If the new length is not a multiple of the cluster size then we 	 * must zero the tail end of the new last cluster in case it 	 * becomes part of the file again because of a seek. 	 */
if|if
condition|(
operator|(
name|boff
operator|=
name|length
operator|&
name|pmp
operator|->
name|pm_crbomask
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * should read from file vnode or filesystem vnode 		 * depending on if file or dir 		 */
if|if
condition|(
name|isadir
condition|)
block|{
name|bn
operator|=
name|cntobn
argument_list|(
name|pmp
argument_list|,
name|eofentry
argument_list|)
expr_stmt|;
name|error
operator|=
name|bread
argument_list|(
name|pmp
operator|->
name|pm_devvp
argument_list|,
name|bn
argument_list|,
name|pmp
operator|->
name|pm_bpcluster
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bn
operator|=
operator|(
name|length
operator|-
literal|1
operator|)
operator|>>
name|pmp
operator|->
name|pm_cnshift
expr_stmt|;
name|error
operator|=
name|bread
argument_list|(
name|DETOV
argument_list|(
name|dep
argument_list|)
argument_list|,
name|bn
argument_list|,
name|pmp
operator|->
name|pm_bpcluster
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|MSDOSFSDEBUG
argument_list|)
name|printf
argument_list|(
literal|"detrunc(): bread fails %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(MSDOSFSDEBUG) */
return|return
name|error
return|;
block|}
name|vnode_pager_uncache
argument_list|(
name|DETOV
argument_list|(
name|dep
argument_list|)
argument_list|)
expr_stmt|;
comment|/* what's this for? */
comment|/* 		 * is this the right place for it? 		 */
name|bzero
argument_list|(
name|bp
operator|->
name|b_un
operator|.
name|b_addr
operator|+
name|boff
argument_list|,
name|pmp
operator|->
name|pm_bpcluster
operator|-
name|boff
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|IO_SYNC
condition|)
name|bwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
else|else
name|bdwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Write out the updated directory entry.  Even if the update fails 	 * we free the trailing clusters. 	 */
name|dep
operator|->
name|de_FileSize
operator|=
name|length
expr_stmt|;
name|dep
operator|->
name|de_flag
operator||=
name|DEUPD
expr_stmt|;
name|vinvalbuf
argument_list|(
name|DETOV
argument_list|(
name|dep
argument_list|)
argument_list|,
name|length
operator|>
literal|0
argument_list|)
expr_stmt|;
name|allerror
operator|=
name|deupdat
argument_list|(
name|dep
argument_list|,
operator|&
name|time
argument_list|,
name|MNT_WAIT
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|MSDOSFSDEBUG
argument_list|)
name|printf
argument_list|(
literal|"detrunc(): allerror %d, eofentry %d\n"
argument_list|,
name|allerror
argument_list|,
name|eofentry
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(MSDOSFSDEBUG) */
comment|/* 	 * If we need to break the cluster chain for the file then do it 	 * now. 	 */
if|if
condition|(
name|eofentry
operator|!=
operator|~
literal|0
condition|)
block|{
name|error
operator|=
name|fatentry
argument_list|(
name|FAT_GET_AND_SET
argument_list|,
name|pmp
argument_list|,
name|eofentry
argument_list|,
operator|&
name|chaintofree
argument_list|,
name|CLUST_EOFE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|MSDOSFSDEBUG
argument_list|)
name|printf
argument_list|(
literal|"detrunc(): fatentry errors %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(MSDOSFSDEBUG) */
return|return
name|error
return|;
block|}
name|fc_setcache
argument_list|(
name|dep
argument_list|,
name|FC_LASTFC
argument_list|,
operator|(
name|length
operator|-
literal|1
operator|)
operator|>>
name|pmp
operator|->
name|pm_cnshift
argument_list|,
name|eofentry
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Now free the clusters removed from the file because of the 	 * truncation. 	 */
if|if
condition|(
name|chaintofree
operator|!=
literal|0
operator|&&
operator|!
name|MSDOSFSEOF
argument_list|(
name|chaintofree
argument_list|)
condition|)
name|freeclusterchain
argument_list|(
name|pmp
argument_list|,
name|chaintofree
argument_list|)
expr_stmt|;
return|return
name|allerror
return|;
block|}
end_function

begin_comment
comment|/*  * Move a denode to its correct hash queue after the file it represents has  * been moved to a new directory.  */
end_comment

begin_macro
name|reinsert
argument_list|(
argument|dep
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|denode
modifier|*
name|dep
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|msdosfsmount
modifier|*
name|pmp
init|=
name|dep
operator|->
name|de_pmp
decl_stmt|;
name|union
name|dehead
modifier|*
name|deh
decl_stmt|;
comment|/* 	 * Fix up the denode cache.  If the denode is for a directory, 	 * there is nothing to do since the hash is based on the starting 	 * cluster of the directory file and that hasn't changed.  If for a 	 * file the hash is based on the location of the directory entry, 	 * so we must remove it from the cache and re-enter it with the 	 * hash based on the new location of the directory entry. 	 */
if|if
condition|(
operator|(
name|dep
operator|->
name|de_Attributes
operator|&
name|ATTR_DIRECTORY
operator|)
operator|==
literal|0
condition|)
block|{
name|remque
argument_list|(
name|dep
argument_list|)
expr_stmt|;
name|deh
operator|=
operator|&
name|dehead
index|[
name|DEHASH
argument_list|(
name|pmp
operator|->
name|pm_dev
argument_list|,
name|dep
operator|->
name|de_dirclust
operator|+
name|dep
operator|->
name|de_diroffset
argument_list|)
index|]
expr_stmt|;
name|insque
argument_list|(
name|dep
argument_list|,
name|deh
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_decl_stmt
name|int
name|msdosfs_prtactive
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* print reclaims of active vnodes */
end_comment

begin_function
name|int
name|msdosfs_reclaim
parameter_list|(
name|vp
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
block|{
name|struct
name|denode
modifier|*
name|dep
init|=
name|VTODE
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|MSDOSFSDEBUG
argument_list|)
name|printf
argument_list|(
literal|"msdosfs_reclaim(): dep %08x, file %s, refcnt %d\n"
argument_list|,
name|dep
argument_list|,
name|dep
operator|->
name|de_Name
argument_list|,
name|dep
operator|->
name|de_refcnt
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(MSDOSFSDEBUG) */
if|if
condition|(
name|msdosfs_prtactive
operator|&&
name|vp
operator|->
name|v_usecount
operator|!=
literal|0
condition|)
name|vprint
argument_list|(
literal|"msdosfs_reclaim(): pushing active"
argument_list|,
name|vp
argument_list|)
expr_stmt|;
comment|/* 	 * Remove the denode from the denode hash chain we are in. 	 */
name|remque
argument_list|(
name|dep
argument_list|)
expr_stmt|;
name|dep
operator|->
name|de_forw
operator|=
name|dep
expr_stmt|;
name|dep
operator|->
name|de_back
operator|=
name|dep
expr_stmt|;
name|cache_purge
argument_list|(
name|vp
argument_list|)
expr_stmt|;
comment|/* 	 * Indicate that one less file on the filesystem is open. 	 */
if|if
condition|(
name|dep
operator|->
name|de_devvp
condition|)
block|{
name|vrele
argument_list|(
name|dep
operator|->
name|de_devvp
argument_list|)
expr_stmt|;
name|dep
operator|->
name|de_devvp
operator|=
literal|0
expr_stmt|;
block|}
name|dep
operator|->
name|de_flag
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|msdosfs_inactive
parameter_list|(
name|vp
parameter_list|,
name|p
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|denode
modifier|*
name|dep
init|=
name|VTODE
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|MSDOSFSDEBUG
argument_list|)
name|printf
argument_list|(
literal|"msdosfs_inactive(): dep %08x, de_Name[0] %x\n"
argument_list|,
name|dep
argument_list|,
name|dep
operator|->
name|de_Name
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(MSDOSFSDEBUG) */
if|if
condition|(
name|msdosfs_prtactive
operator|&&
name|vp
operator|->
name|v_usecount
operator|!=
literal|0
condition|)
name|vprint
argument_list|(
literal|"msdosfs_inactive(): pushing active"
argument_list|,
name|vp
argument_list|)
expr_stmt|;
comment|/* 	 * Get rid of denodes related to stale file handles. Hmmm, what 	 * does this really do? 	 */
if|if
condition|(
name|dep
operator|->
name|de_Name
index|[
literal|0
index|]
operator|==
name|SLOT_DELETED
condition|)
block|{
if|if
condition|(
operator|(
name|vp
operator|->
name|v_flag
operator|&
name|VXLOCK
operator|)
operator|==
literal|0
condition|)
name|vgone
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * If the file has been deleted and it is on a read/write 	 * filesystem, then truncate the file, and mark the directory slot 	 * as empty.  (This may not be necessary for the dos filesystem. 	 */
if|#
directive|if
name|defined
argument_list|(
name|MSDOSFSDEBUG
argument_list|)
name|printf
argument_list|(
literal|"msdosfs_inactive(): dep %08x, refcnt %d, mntflag %x, MNT_RDONLY %x\n"
argument_list|,
name|dep
argument_list|,
name|dep
operator|->
name|de_refcnt
argument_list|,
name|vp
operator|->
name|v_mount
operator|->
name|mnt_flag
argument_list|,
name|MNT_RDONLY
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(MSDOSFSDEBUG) */
name|DELOCK
argument_list|(
name|dep
argument_list|)
expr_stmt|;
if|if
condition|(
name|dep
operator|->
name|de_refcnt
operator|<=
literal|0
operator|&&
operator|(
name|vp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|detrunc
argument_list|(
name|dep
argument_list|,
operator|(
name|u_long
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dep
operator|->
name|de_flag
operator||=
name|DEUPD
expr_stmt|;
name|dep
operator|->
name|de_Name
index|[
literal|0
index|]
operator|=
name|SLOT_DELETED
expr_stmt|;
block|}
name|DEUPDAT
argument_list|(
name|dep
argument_list|,
operator|&
name|time
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DEUNLOCK
argument_list|(
name|dep
argument_list|)
expr_stmt|;
name|dep
operator|->
name|de_flag
operator|=
literal|0
expr_stmt|;
comment|/* 	 * If we are done with the denode, then reclaim it so that it can 	 * be reused now. 	 */
if|#
directive|if
name|defined
argument_list|(
name|MSDOSFSDEBUG
argument_list|)
name|printf
argument_list|(
literal|"msdosfs_inactive(): v_usecount %d, de_Name[0] %x\n"
argument_list|,
name|vp
operator|->
name|v_usecount
argument_list|,
name|dep
operator|->
name|de_Name
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(MSDOSFSDEBUG) */
if|if
condition|(
name|vp
operator|->
name|v_usecount
operator|==
literal|0
operator|&&
name|dep
operator|->
name|de_Name
index|[
literal|0
index|]
operator|==
name|SLOT_DELETED
condition|)
name|vgone
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|delock
parameter_list|(
name|dep
parameter_list|)
name|struct
name|denode
modifier|*
name|dep
decl_stmt|;
block|{
while|while
condition|(
name|dep
operator|->
name|de_flag
operator|&
name|DELOCKED
condition|)
block|{
name|dep
operator|->
name|de_flag
operator||=
name|DEWANT
expr_stmt|;
if|if
condition|(
name|dep
operator|->
name|de_spare0
operator|==
name|curproc
operator|->
name|p_pid
condition|)
name|panic
argument_list|(
literal|"delock: locking against myself"
argument_list|)
expr_stmt|;
name|dep
operator|->
name|de_spare1
operator|=
name|curproc
operator|->
name|p_pid
expr_stmt|;
operator|(
name|void
operator|)
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|dep
argument_list|,
name|PINOD
argument_list|)
expr_stmt|;
block|}
name|dep
operator|->
name|de_spare1
operator|=
literal|0
expr_stmt|;
name|dep
operator|->
name|de_spare0
operator|=
name|curproc
operator|->
name|p_pid
expr_stmt|;
name|dep
operator|->
name|de_flag
operator||=
name|DELOCKED
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|deunlock
parameter_list|(
name|dep
parameter_list|)
name|struct
name|denode
modifier|*
name|dep
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|dep
operator|->
name|de_flag
operator|&
name|DELOCKED
operator|)
operator|==
literal|0
condition|)
name|vprint
argument_list|(
literal|"deunlock: found unlocked denode"
argument_list|,
name|DETOV
argument_list|(
name|dep
argument_list|)
argument_list|)
expr_stmt|;
name|dep
operator|->
name|de_spare0
operator|=
literal|0
expr_stmt|;
name|dep
operator|->
name|de_flag
operator|&=
operator|~
name|DELOCKED
expr_stmt|;
if|if
condition|(
name|dep
operator|->
name|de_flag
operator|&
name|DEWANT
condition|)
block|{
name|dep
operator|->
name|de_flag
operator|&=
operator|~
name|DEWANT
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|dep
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

end_unit

