begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/*	$NetBSD: msdosfs_denode.c,v 1.28 1998/02/10 14:10:00 mrg Exp $	*/
end_comment

begin_comment
comment|/*-  * Copyright (C) 1994, 1995, 1997 Wolfgang Solfrank.  * Copyright (C) 1994, 1995, 1997 TooLs GmbH.  * All rights reserved.  * Original code by Paul Popelka (paulp@uts.amdahl.com) (see below).  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by TooLs GmbH.  * 4. The name of TooLs GmbH may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY TOOLS GMBH ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL TOOLS GMBH BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;  * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*-  * Written by Paul Popelka (paulp@uts.amdahl.com)  *  * You can do anything you want with this software, just don't say you wrote  * it, and don't remove this notice.  *  * This software is provided "as is".  *  * The author supplies this software to be publicly redistributed on the  * understanding that the author is not responsible for the correct  * functioning of this software in any circumstances and is not liable for  * any damages caused by this software.  *  * October 1992  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/clock.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<fs/msdosfs/bpb.h>
end_include

begin_include
include|#
directive|include
file|<fs/msdosfs/msdosfsmount.h>
end_include

begin_include
include|#
directive|include
file|<fs/msdosfs/direntry.h>
end_include

begin_include
include|#
directive|include
file|<fs/msdosfs/denode.h>
end_include

begin_include
include|#
directive|include
file|<fs/msdosfs/fat.h>
end_include

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_MSDOSFSNODE
argument_list|,
literal|"msdosfs_node"
argument_list|,
literal|"MSDOSFS vnode private part"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|de_vncmpf
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|denode
modifier|*
name|de
decl_stmt|;
name|uint64_t
modifier|*
name|a
decl_stmt|;
name|a
operator|=
name|arg
expr_stmt|;
name|de
operator|=
name|VTODE
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
name|de
operator|->
name|de_inode
operator|!=
operator|*
name|a
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * If deget() succeeds it returns with the gotten denode locked().  *  * pmp	     - address of msdosfsmount structure of the filesystem containing  *	       the denode of interest.  The address of  *	       the msdosfsmount structure are used.  * dirclust  - which cluster bp contains, if dirclust is 0 (root directory)  *	       diroffset is relative to the beginning of the root directory,  *	       otherwise it is cluster relative.  * diroffset - offset past begin of cluster of denode we want  * depp	     - returns the address of the gotten denode.  */
end_comment

begin_function
name|int
name|deget
parameter_list|(
name|pmp
parameter_list|,
name|dirclust
parameter_list|,
name|diroffset
parameter_list|,
name|depp
parameter_list|)
name|struct
name|msdosfsmount
modifier|*
name|pmp
decl_stmt|;
comment|/* so we know the maj/min number */
name|u_long
name|dirclust
decl_stmt|;
comment|/* cluster this dir entry came from */
name|u_long
name|diroffset
decl_stmt|;
comment|/* index of entry within the cluster */
name|struct
name|denode
modifier|*
modifier|*
name|depp
decl_stmt|;
comment|/* returns the addr of the gotten denode */
block|{
name|int
name|error
decl_stmt|;
name|uint64_t
name|inode
decl_stmt|;
name|struct
name|mount
modifier|*
name|mntp
init|=
name|pmp
operator|->
name|pm_mountp
decl_stmt|;
name|struct
name|direntry
modifier|*
name|direntptr
decl_stmt|;
name|struct
name|denode
modifier|*
name|ldep
decl_stmt|;
name|struct
name|vnode
modifier|*
name|nvp
decl_stmt|,
modifier|*
name|xvp
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
ifdef|#
directive|ifdef
name|MSDOSFS_DEBUG
name|printf
argument_list|(
literal|"deget(pmp %p, dirclust %lu, diroffset %lx, depp %p)\n"
argument_list|,
name|pmp
argument_list|,
name|dirclust
argument_list|,
name|diroffset
argument_list|,
name|depp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * On FAT32 filesystems, root is a (more or less) normal 	 * directory 	 */
if|if
condition|(
name|FAT32
argument_list|(
name|pmp
argument_list|)
operator|&&
name|dirclust
operator|==
name|MSDOSFSROOT
condition|)
name|dirclust
operator|=
name|pmp
operator|->
name|pm_rootdirblk
expr_stmt|;
comment|/* 	 * See if the denode is in the denode cache. Use the location of 	 * the directory entry to compute the hash value. For subdir use 	 * address of "." entry. For root dir (if not FAT32) use cluster 	 * MSDOSFSROOT, offset MSDOSFSROOT_OFS 	 * 	 * NOTE: The check for de_refcnt> 0 below insures the denode being 	 * examined does not represent an unlinked but still open file. 	 * These files are not to be accessible even when the directory 	 * entry that represented the file happens to be reused while the 	 * deleted file is still open. 	 */
name|inode
operator|=
operator|(
name|uint64_t
operator|)
name|pmp
operator|->
name|pm_bpcluster
operator|*
name|dirclust
operator|+
name|diroffset
expr_stmt|;
name|error
operator|=
name|vfs_hash_get
argument_list|(
name|mntp
argument_list|,
name|inode
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
name|curthread
argument_list|,
operator|&
name|nvp
argument_list|,
name|de_vncmpf
argument_list|,
operator|&
name|inode
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|nvp
operator|!=
name|NULL
condition|)
block|{
operator|*
name|depp
operator|=
name|VTODE
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
operator|*
name|depp
operator|)
operator|->
name|de_dirclust
operator|==
name|dirclust
argument_list|,
operator|(
literal|"wrong dirclust"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
operator|*
name|depp
operator|)
operator|->
name|de_diroffset
operator|==
name|diroffset
argument_list|,
operator|(
literal|"wrong diroffset"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Do the MALLOC before the getnewvnode since doing so afterward 	 * might cause a bogus v_data pointer to get dereferenced 	 * elsewhere if MALLOC should block. 	 */
name|MALLOC
argument_list|(
name|ldep
argument_list|,
expr|struct
name|denode
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|denode
argument_list|)
argument_list|,
name|M_MSDOSFSNODE
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
comment|/* 	 * Directory entry was not in cache, have to create a vnode and 	 * copy it from the passed disk buffer. 	 */
comment|/* getnewvnode() does a VREF() on the vnode */
name|error
operator|=
name|getnewvnode
argument_list|(
literal|"msdosfs"
argument_list|,
name|mntp
argument_list|,
operator|&
name|msdosfs_vnodeops
argument_list|,
operator|&
name|nvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
operator|*
name|depp
operator|=
name|NULL
expr_stmt|;
name|FREE
argument_list|(
name|ldep
argument_list|,
name|M_MSDOSFSNODE
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|ldep
argument_list|,
sizeof|sizeof
expr|*
name|ldep
argument_list|)
expr_stmt|;
name|nvp
operator|->
name|v_data
operator|=
name|ldep
expr_stmt|;
name|ldep
operator|->
name|de_vnode
operator|=
name|nvp
expr_stmt|;
name|ldep
operator|->
name|de_flag
operator|=
literal|0
expr_stmt|;
name|ldep
operator|->
name|de_dirclust
operator|=
name|dirclust
expr_stmt|;
name|ldep
operator|->
name|de_diroffset
operator|=
name|diroffset
expr_stmt|;
name|ldep
operator|->
name|de_inode
operator|=
name|inode
expr_stmt|;
name|fc_purge
argument_list|(
name|ldep
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* init the fat cache for this denode */
name|td
operator|=
name|curthread
expr_stmt|;
name|lockmgr
argument_list|(
name|nvp
operator|->
name|v_vnlock
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
name|NULL
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|error
operator|=
name|insmntque
argument_list|(
name|nvp
argument_list|,
name|mntp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|FREE
argument_list|(
name|ldep
argument_list|,
name|M_MSDOSFSNODE
argument_list|)
expr_stmt|;
operator|*
name|depp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|vfs_hash_insert
argument_list|(
name|nvp
argument_list|,
name|inode
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
name|td
argument_list|,
operator|&
name|xvp
argument_list|,
name|de_vncmpf
argument_list|,
operator|&
name|inode
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
operator|*
name|depp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|xvp
operator|!=
name|NULL
condition|)
block|{
comment|/* XXX: Not sure this is right */
name|nvp
operator|=
name|xvp
expr_stmt|;
name|ldep
operator|->
name|de_vnode
operator|=
name|nvp
expr_stmt|;
block|}
name|ldep
operator|->
name|de_pmp
operator|=
name|pmp
expr_stmt|;
name|ldep
operator|->
name|de_refcnt
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Copy the directory entry into the denode area of the vnode. 	 */
if|if
condition|(
operator|(
name|dirclust
operator|==
name|MSDOSFSROOT
operator|||
operator|(
name|FAT32
argument_list|(
name|pmp
argument_list|)
operator|&&
name|dirclust
operator|==
name|pmp
operator|->
name|pm_rootdirblk
operator|)
operator|)
operator|&&
name|diroffset
operator|==
name|MSDOSFSROOT_OFS
condition|)
block|{
comment|/* 		 * Directory entry for the root directory. There isn't one, 		 * so we manufacture one. We should probably rummage 		 * through the root directory and find a label entry (if it 		 * exists), and then use the time and date from that entry 		 * as the time and date for the root denode. 		 */
name|nvp
operator|->
name|v_vflag
operator||=
name|VV_ROOT
expr_stmt|;
comment|/* should be further down XXX */
name|ldep
operator|->
name|de_Attributes
operator|=
name|ATTR_DIRECTORY
expr_stmt|;
name|ldep
operator|->
name|de_LowerCase
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|FAT32
argument_list|(
name|pmp
argument_list|)
condition|)
name|ldep
operator|->
name|de_StartCluster
operator|=
name|pmp
operator|->
name|pm_rootdirblk
expr_stmt|;
comment|/* de_FileSize will be filled in further down */
else|else
block|{
name|ldep
operator|->
name|de_StartCluster
operator|=
name|MSDOSFSROOT
expr_stmt|;
name|ldep
operator|->
name|de_FileSize
operator|=
name|pmp
operator|->
name|pm_rootdirsize
operator|*
name|DEV_BSIZE
expr_stmt|;
block|}
comment|/* 		 * fill in time and date so that fattime2timespec() doesn't 		 * spit up when called from msdosfs_getattr() with root 		 * denode 		 */
name|ldep
operator|->
name|de_CHun
operator|=
literal|0
expr_stmt|;
name|ldep
operator|->
name|de_CTime
operator|=
literal|0x0000
expr_stmt|;
comment|/* 00:00:00	 */
name|ldep
operator|->
name|de_CDate
operator|=
operator|(
literal|0
operator|<<
name|DD_YEAR_SHIFT
operator|)
operator||
operator|(
literal|1
operator|<<
name|DD_MONTH_SHIFT
operator|)
operator||
operator|(
literal|1
operator|<<
name|DD_DAY_SHIFT
operator|)
expr_stmt|;
comment|/* Jan 1, 1980	 */
name|ldep
operator|->
name|de_ADate
operator|=
name|ldep
operator|->
name|de_CDate
expr_stmt|;
name|ldep
operator|->
name|de_MTime
operator|=
name|ldep
operator|->
name|de_CTime
expr_stmt|;
name|ldep
operator|->
name|de_MDate
operator|=
name|ldep
operator|->
name|de_CDate
expr_stmt|;
comment|/* leave the other fields as garbage */
block|}
else|else
block|{
name|error
operator|=
name|readep
argument_list|(
name|pmp
argument_list|,
name|dirclust
argument_list|,
name|diroffset
argument_list|,
operator|&
name|bp
argument_list|,
operator|&
name|direntptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* 			 * The denode does not contain anything useful, so 			 * it would be wrong to leave it on its hash chain. 			 * Arrange for vput() to just forget about it. 			 */
name|ldep
operator|->
name|de_Name
index|[
literal|0
index|]
operator|=
name|SLOT_DELETED
expr_stmt|;
name|vput
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
operator|*
name|depp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|DE_INTERNALIZE
argument_list|(
name|ldep
argument_list|,
name|direntptr
argument_list|)
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Fill in a few fields of the vnode and finish filling in the 	 * denode.  Then return the address of the found denode. 	 */
if|if
condition|(
name|ldep
operator|->
name|de_Attributes
operator|&
name|ATTR_DIRECTORY
condition|)
block|{
comment|/* 		 * Since DOS directory entries that describe directories 		 * have 0 in the filesize field, we take this opportunity 		 * to find out the length of the directory and plug it into 		 * the denode structure. 		 */
name|u_long
name|size
decl_stmt|;
comment|/* 		 * XXX Sometimes, these arrives that . entry have cluster 		 * number 0, when it shouldn't.  Use real cluster number 		 * instead of what is written in directory entry. 		 */
if|if
condition|(
operator|(
name|diroffset
operator|==
literal|0
operator|)
operator|&&
operator|(
name|ldep
operator|->
name|de_StartCluster
operator|!=
name|dirclust
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"deget(): . entry at clust %ld != %ld\n"
argument_list|,
name|dirclust
argument_list|,
name|ldep
operator|->
name|de_StartCluster
argument_list|)
expr_stmt|;
name|ldep
operator|->
name|de_StartCluster
operator|=
name|dirclust
expr_stmt|;
block|}
name|nvp
operator|->
name|v_type
operator|=
name|VDIR
expr_stmt|;
if|if
condition|(
name|ldep
operator|->
name|de_StartCluster
operator|!=
name|MSDOSFSROOT
condition|)
block|{
name|error
operator|=
name|pcbmap
argument_list|(
name|ldep
argument_list|,
literal|0xffff
argument_list|,
literal|0
argument_list|,
operator|&
name|size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|E2BIG
condition|)
block|{
name|ldep
operator|->
name|de_FileSize
operator|=
name|de_cn2off
argument_list|(
name|pmp
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"deget(): pcbmap returned %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|nvp
operator|->
name|v_type
operator|=
name|VREG
expr_stmt|;
name|ldep
operator|->
name|de_modrev
operator|=
name|init_va_filerev
argument_list|()
expr_stmt|;
operator|*
name|depp
operator|=
name|ldep
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|deupdat
parameter_list|(
name|dep
parameter_list|,
name|waitfor
parameter_list|)
name|struct
name|denode
modifier|*
name|dep
decl_stmt|;
name|int
name|waitfor
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|direntry
modifier|*
name|dirp
decl_stmt|;
name|struct
name|timespec
name|ts
decl_stmt|;
if|if
condition|(
name|DETOV
argument_list|(
name|dep
argument_list|)
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|getnanotime
argument_list|(
operator|&
name|ts
argument_list|)
expr_stmt|;
name|DETIMES
argument_list|(
name|dep
argument_list|,
operator|&
name|ts
argument_list|,
operator|&
name|ts
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dep
operator|->
name|de_flag
operator|&
name|DE_MODIFIED
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|dep
operator|->
name|de_flag
operator|&=
operator|~
name|DE_MODIFIED
expr_stmt|;
if|if
condition|(
name|dep
operator|->
name|de_Attributes
operator|&
name|ATTR_DIRECTORY
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|dep
operator|->
name|de_refcnt
operator|<=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|error
operator|=
name|readde
argument_list|(
name|dep
argument_list|,
operator|&
name|bp
argument_list|,
operator|&
name|dirp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|DE_EXTERNALIZE
argument_list|(
name|dirp
argument_list|,
name|dep
argument_list|)
expr_stmt|;
if|if
condition|(
name|waitfor
condition|)
return|return
operator|(
name|bwrite
argument_list|(
name|bp
argument_list|)
operator|)
return|;
else|else
block|{
name|bdwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Truncate the file described by dep to the length specified by length.  */
end_comment

begin_function
name|int
name|detrunc
parameter_list|(
name|dep
parameter_list|,
name|length
parameter_list|,
name|flags
parameter_list|,
name|cred
parameter_list|,
name|td
parameter_list|)
name|struct
name|denode
modifier|*
name|dep
decl_stmt|;
name|u_long
name|length
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|int
name|allerror
decl_stmt|;
name|u_long
name|eofentry
decl_stmt|;
name|u_long
name|chaintofree
decl_stmt|;
name|daddr_t
name|bn
decl_stmt|;
name|int
name|boff
decl_stmt|;
name|int
name|isadir
init|=
name|dep
operator|->
name|de_Attributes
operator|&
name|ATTR_DIRECTORY
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|msdosfsmount
modifier|*
name|pmp
init|=
name|dep
operator|->
name|de_pmp
decl_stmt|;
ifdef|#
directive|ifdef
name|MSDOSFS_DEBUG
name|printf
argument_list|(
literal|"detrunc(): file %s, length %lu, flags %x\n"
argument_list|,
name|dep
operator|->
name|de_Name
argument_list|,
name|length
argument_list|,
name|flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Disallow attempts to truncate the root directory since it is of 	 * fixed size.  That's just the way dos filesystems are.  We use 	 * the VROOT bit in the vnode because checking for the directory 	 * bit and a startcluster of 0 in the denode is not adequate to 	 * recognize the root directory at this point in a file or 	 * directory's life. 	 */
if|if
condition|(
operator|(
name|DETOV
argument_list|(
name|dep
argument_list|)
operator|->
name|v_vflag
operator|&
name|VV_ROOT
operator|)
operator|&&
operator|!
name|FAT32
argument_list|(
name|pmp
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"detrunc(): can't truncate root directory, clust %ld, offset %ld\n"
argument_list|,
name|dep
operator|->
name|de_dirclust
argument_list|,
name|dep
operator|->
name|de_diroffset
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|dep
operator|->
name|de_FileSize
operator|<
name|length
condition|)
block|{
name|vnode_pager_setsize
argument_list|(
name|DETOV
argument_list|(
name|dep
argument_list|)
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return
name|deextend
argument_list|(
name|dep
argument_list|,
name|length
argument_list|,
name|cred
argument_list|)
return|;
block|}
comment|/* 	 * If the desired length is 0 then remember the starting cluster of 	 * the file and set the StartCluster field in the directory entry 	 * to 0.  If the desired length is not zero, then get the number of 	 * the last cluster in the shortened file.  Then get the number of 	 * the first cluster in the part of the file that is to be freed. 	 * Then set the next cluster pointer in the last cluster of the 	 * file to CLUST_EOFE. 	 */
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
name|chaintofree
operator|=
name|dep
operator|->
name|de_StartCluster
expr_stmt|;
name|dep
operator|->
name|de_StartCluster
operator|=
literal|0
expr_stmt|;
name|eofentry
operator|=
operator|~
literal|0
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|pcbmap
argument_list|(
name|dep
argument_list|,
name|de_clcount
argument_list|(
name|pmp
argument_list|,
name|length
argument_list|)
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
operator|&
name|eofentry
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
ifdef|#
directive|ifdef
name|MSDOSFS_DEBUG
name|printf
argument_list|(
literal|"detrunc(): pcbmap fails %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
name|fc_purge
argument_list|(
name|dep
argument_list|,
name|de_clcount
argument_list|(
name|pmp
argument_list|,
name|length
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * If the new length is not a multiple of the cluster size then we 	 * must zero the tail end of the new last cluster in case it 	 * becomes part of the file again because of a seek. 	 */
if|if
condition|(
operator|(
name|boff
operator|=
name|length
operator|&
name|pmp
operator|->
name|pm_crbomask
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|isadir
condition|)
block|{
name|bn
operator|=
name|cntobn
argument_list|(
name|pmp
argument_list|,
name|eofentry
argument_list|)
expr_stmt|;
name|error
operator|=
name|bread
argument_list|(
name|pmp
operator|->
name|pm_devvp
argument_list|,
name|bn
argument_list|,
name|pmp
operator|->
name|pm_bpcluster
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MSDOSFS_DEBUG
name|printf
argument_list|(
literal|"detrunc(): bread fails %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|error
operator|)
return|;
block|}
name|bzero
argument_list|(
name|bp
operator|->
name|b_data
operator|+
name|boff
argument_list|,
name|pmp
operator|->
name|pm_bpcluster
operator|-
name|boff
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|IO_SYNC
condition|)
name|bwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
else|else
name|bdwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Write out the updated directory entry.  Even if the update fails 	 * we free the trailing clusters. 	 */
name|dep
operator|->
name|de_FileSize
operator|=
name|length
expr_stmt|;
if|if
condition|(
operator|!
name|isadir
condition|)
name|dep
operator|->
name|de_flag
operator||=
name|DE_UPDATE
operator||
name|DE_MODIFIED
expr_stmt|;
name|allerror
operator|=
name|vtruncbuf
argument_list|(
name|DETOV
argument_list|(
name|dep
argument_list|)
argument_list|,
name|cred
argument_list|,
name|td
argument_list|,
name|length
argument_list|,
name|pmp
operator|->
name|pm_bpcluster
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MSDOSFS_DEBUG
if|if
condition|(
name|allerror
condition|)
name|printf
argument_list|(
literal|"detrunc(): vtruncbuf error %d\n"
argument_list|,
name|allerror
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|error
operator|=
name|deupdat
argument_list|(
name|dep
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
operator|(
name|allerror
operator|==
literal|0
operator|)
condition|)
name|allerror
operator|=
name|error
expr_stmt|;
ifdef|#
directive|ifdef
name|MSDOSFS_DEBUG
name|printf
argument_list|(
literal|"detrunc(): allerror %d, eofentry %lu\n"
argument_list|,
name|allerror
argument_list|,
name|eofentry
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * If we need to break the cluster chain for the file then do it 	 * now. 	 */
if|if
condition|(
name|eofentry
operator|!=
operator|~
literal|0
condition|)
block|{
name|error
operator|=
name|fatentry
argument_list|(
name|FAT_GET_AND_SET
argument_list|,
name|pmp
argument_list|,
name|eofentry
argument_list|,
operator|&
name|chaintofree
argument_list|,
name|CLUST_EOFE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
ifdef|#
directive|ifdef
name|MSDOSFS_DEBUG
name|printf
argument_list|(
literal|"detrunc(): fatentry errors %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|error
operator|)
return|;
block|}
name|fc_setcache
argument_list|(
name|dep
argument_list|,
name|FC_LASTFC
argument_list|,
name|de_cluster
argument_list|(
name|pmp
argument_list|,
name|length
operator|-
literal|1
argument_list|)
argument_list|,
name|eofentry
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Now free the clusters removed from the file because of the 	 * truncation. 	 */
if|if
condition|(
name|chaintofree
operator|!=
literal|0
operator|&&
operator|!
name|MSDOSFSEOF
argument_list|(
name|pmp
argument_list|,
name|chaintofree
argument_list|)
condition|)
name|freeclusterchain
argument_list|(
name|pmp
argument_list|,
name|chaintofree
argument_list|)
expr_stmt|;
return|return
operator|(
name|allerror
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Extend the file described by dep to length specified by length.  */
end_comment

begin_function
name|int
name|deextend
parameter_list|(
name|dep
parameter_list|,
name|length
parameter_list|,
name|cred
parameter_list|)
name|struct
name|denode
modifier|*
name|dep
decl_stmt|;
name|u_long
name|length
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
block|{
name|struct
name|msdosfsmount
modifier|*
name|pmp
init|=
name|dep
operator|->
name|de_pmp
decl_stmt|;
name|u_long
name|count
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * The root of a DOS filesystem cannot be extended. 	 */
if|if
condition|(
operator|(
name|DETOV
argument_list|(
name|dep
argument_list|)
operator|->
name|v_vflag
operator|&
name|VV_ROOT
operator|)
operator|&&
operator|!
name|FAT32
argument_list|(
name|pmp
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * Directories cannot be extended. 	 */
if|if
condition|(
name|dep
operator|->
name|de_Attributes
operator|&
name|ATTR_DIRECTORY
condition|)
return|return
operator|(
name|EISDIR
operator|)
return|;
if|if
condition|(
name|length
operator|<=
name|dep
operator|->
name|de_FileSize
condition|)
name|panic
argument_list|(
literal|"deextend: file too large"
argument_list|)
expr_stmt|;
comment|/* 	 * Compute the number of clusters to allocate. 	 */
name|count
operator|=
name|de_clcount
argument_list|(
name|pmp
argument_list|,
name|length
argument_list|)
operator|-
name|de_clcount
argument_list|(
name|pmp
argument_list|,
name|dep
operator|->
name|de_FileSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|count
operator|>
name|pmp
operator|->
name|pm_freeclustercount
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
name|error
operator|=
name|extendfile
argument_list|(
name|dep
argument_list|,
name|count
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|DE_CLEAR
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* truncate the added clusters away again */
operator|(
name|void
operator|)
name|detrunc
argument_list|(
name|dep
argument_list|,
name|dep
operator|->
name|de_FileSize
argument_list|,
literal|0
argument_list|,
name|cred
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
name|dep
operator|->
name|de_FileSize
operator|=
name|length
expr_stmt|;
name|dep
operator|->
name|de_flag
operator||=
name|DE_UPDATE
operator||
name|DE_MODIFIED
expr_stmt|;
return|return
operator|(
name|deupdat
argument_list|(
name|dep
argument_list|,
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Move a denode to its correct hash queue after the file it represents has  * been moved to a new directory.  */
end_comment

begin_function
name|void
name|reinsert
parameter_list|(
name|dep
parameter_list|)
name|struct
name|denode
modifier|*
name|dep
decl_stmt|;
block|{
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
comment|/* 	 * Fix up the denode cache.  If the denode is for a directory, 	 * there is nothing to do since the hash is based on the starting 	 * cluster of the directory file and that hasn't changed.  If for a 	 * file the hash is based on the location of the directory entry, 	 * so we must remove it from the cache and re-enter it with the 	 * hash based on the new location of the directory entry. 	 */
if|#
directive|if
literal|0
block|if (dep->de_Attributes& ATTR_DIRECTORY) 		return;
endif|#
directive|endif
name|vp
operator|=
name|DETOV
argument_list|(
name|dep
argument_list|)
expr_stmt|;
name|dep
operator|->
name|de_inode
operator|=
operator|(
name|uint64_t
operator|)
name|dep
operator|->
name|de_pmp
operator|->
name|pm_bpcluster
operator|*
name|dep
operator|->
name|de_dirclust
operator|+
name|dep
operator|->
name|de_diroffset
expr_stmt|;
name|vfs_hash_rehash
argument_list|(
name|vp
argument_list|,
name|dep
operator|->
name|de_inode
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|msdosfs_reclaim
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_reclaim_args
comment|/* { 		struct vnode *a_vp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|denode
modifier|*
name|dep
init|=
name|VTODE
argument_list|(
name|vp
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|MSDOSFS_DEBUG
name|printf
argument_list|(
literal|"msdosfs_reclaim(): dep %p, file %s, refcnt %ld\n"
argument_list|,
name|dep
argument_list|,
name|dep
operator|->
name|de_Name
argument_list|,
name|dep
operator|->
name|de_refcnt
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|prtactive
operator|&&
name|vrefcnt
argument_list|(
name|vp
argument_list|)
operator|!=
literal|0
condition|)
name|vprint
argument_list|(
literal|"msdosfs_reclaim(): pushing active"
argument_list|,
name|vp
argument_list|)
expr_stmt|;
comment|/* 	 * Destroy the vm object and flush associated pages. 	 */
name|vnode_destroy_vobject
argument_list|(
name|vp
argument_list|)
expr_stmt|;
comment|/* 	 * Remove the denode from its hash chain. 	 */
name|vfs_hash_remove
argument_list|(
name|vp
argument_list|)
expr_stmt|;
comment|/* 	 * Purge old data structures associated with the denode. 	 */
if|#
directive|if
literal|0
comment|/* XXX */
block|dep->de_flag = 0;
endif|#
directive|endif
name|FREE
argument_list|(
name|dep
argument_list|,
name|M_MSDOSFSNODE
argument_list|)
expr_stmt|;
name|vp
operator|->
name|v_data
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|msdosfs_inactive
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_inactive_args
comment|/* { 		struct vnode *a_vp; 		struct thread *a_td; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|denode
modifier|*
name|dep
init|=
name|VTODE
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|ap
operator|->
name|a_td
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|MSDOSFS_DEBUG
name|printf
argument_list|(
literal|"msdosfs_inactive(): dep %p, de_Name[0] %x\n"
argument_list|,
name|dep
argument_list|,
name|dep
operator|->
name|de_Name
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|prtactive
operator|&&
name|vrefcnt
argument_list|(
name|vp
argument_list|)
operator|!=
literal|0
condition|)
name|vprint
argument_list|(
literal|"msdosfs_inactive(): pushing active"
argument_list|,
name|vp
argument_list|)
expr_stmt|;
comment|/* 	 * Ignore denodes related to stale file handles. 	 */
if|if
condition|(
name|dep
operator|->
name|de_Name
index|[
literal|0
index|]
operator|==
name|SLOT_DELETED
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * If the file has been deleted and it is on a read/write 	 * filesystem, then truncate the file, and mark the directory slot 	 * as empty.  (This may not be necessary for the dos filesystem.) 	 */
ifdef|#
directive|ifdef
name|MSDOSFS_DEBUG
name|printf
argument_list|(
literal|"msdosfs_inactive(): dep %p, refcnt %ld, mntflag %x, MNT_RDONLY %x\n"
argument_list|,
name|dep
argument_list|,
name|dep
operator|->
name|de_refcnt
argument_list|,
name|vp
operator|->
name|v_mount
operator|->
name|mnt_flag
argument_list|,
name|MNT_RDONLY
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|dep
operator|->
name|de_refcnt
operator|<=
literal|0
operator|&&
operator|(
name|vp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|detrunc
argument_list|(
name|dep
argument_list|,
operator|(
name|u_long
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
name|NOCRED
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|dep
operator|->
name|de_flag
operator||=
name|DE_UPDATE
expr_stmt|;
name|dep
operator|->
name|de_Name
index|[
literal|0
index|]
operator|=
name|SLOT_DELETED
expr_stmt|;
block|}
name|deupdat
argument_list|(
name|dep
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|out
label|:
comment|/* 	 * If we are done with the denode, reclaim it 	 * so that it can be reused immediately. 	 */
ifdef|#
directive|ifdef
name|MSDOSFS_DEBUG
name|printf
argument_list|(
literal|"msdosfs_inactive(): v_usecount %d, de_Name[0] %x\n"
argument_list|,
name|vrefcnt
argument_list|(
name|vp
argument_list|)
argument_list|,
name|dep
operator|->
name|de_Name
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|dep
operator|->
name|de_Name
index|[
literal|0
index|]
operator|==
name|SLOT_DELETED
condition|)
name|vrecycle
argument_list|(
name|vp
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

