begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1994  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley  * by Pace Willisson (pace@blitz.com).  The Rock Ridge Extension  * Support code is derived from software contributed to Berkeley  * by Atsushi Murai (amurai@spec.co.jp).  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)cd9660_vnops.c	8.19 (Berkeley) 5/27/95  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<fs/fifofs/fifo.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/dirent.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/filio.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vnode_pager.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<fs/cd9660/iso.h>
end_include

begin_include
include|#
directive|include
file|<fs/cd9660/cd9660_node.h>
end_include

begin_include
include|#
directive|include
file|<fs/cd9660/iso_rrip.h>
end_include

begin_decl_stmt
specifier|static
name|vop_setattr_t
name|cd9660_setattr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_open_t
name|cd9660_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_access_t
name|cd9660_access
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_getattr_t
name|cd9660_getattr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_ioctl_t
name|cd9660_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_pathconf_t
name|cd9660_pathconf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_read_t
name|cd9660_read
decl_stmt|;
end_decl_stmt

begin_struct_decl
struct_decl|struct
name|isoreaddir
struct_decl|;
end_struct_decl

begin_function_decl
specifier|static
name|int
name|iso_uiodir
parameter_list|(
name|struct
name|isoreaddir
modifier|*
name|idp
parameter_list|,
name|struct
name|dirent
modifier|*
name|dp
parameter_list|,
name|off_t
name|off
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iso_shipdir
parameter_list|(
name|struct
name|isoreaddir
modifier|*
name|idp
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|vop_readdir_t
name|cd9660_readdir
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_readlink_t
name|cd9660_readlink
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_strategy_t
name|cd9660_strategy
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Setattr call. Only allowed for block and character special devices.  */
end_comment

begin_function
specifier|static
name|int
name|cd9660_setattr
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_setattr_args
comment|/* { 		struct vnodeop_desc *a_desc; 		struct vnode *a_vp; 		struct vattr *a_vap; 		struct ucred *a_cred; 		struct thread *a_td; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|vattr
modifier|*
name|vap
init|=
name|ap
operator|->
name|a_vap
decl_stmt|;
if|if
condition|(
name|vap
operator|->
name|va_flags
operator|!=
operator|(
name|u_long
operator|)
name|VNOVAL
operator|||
name|vap
operator|->
name|va_uid
operator|!=
operator|(
name|uid_t
operator|)
name|VNOVAL
operator|||
name|vap
operator|->
name|va_gid
operator|!=
operator|(
name|gid_t
operator|)
name|VNOVAL
operator|||
name|vap
operator|->
name|va_atime
operator|.
name|tv_sec
operator|!=
name|VNOVAL
operator|||
name|vap
operator|->
name|va_mtime
operator|.
name|tv_sec
operator|!=
name|VNOVAL
operator|||
name|vap
operator|->
name|va_mode
operator|!=
operator|(
name|mode_t
operator|)
name|VNOVAL
condition|)
return|return
operator|(
name|EROFS
operator|)
return|;
if|if
condition|(
name|vap
operator|->
name|va_size
operator|!=
operator|(
name|u_quad_t
operator|)
name|VNOVAL
condition|)
block|{
switch|switch
condition|(
name|vp
operator|->
name|v_type
condition|)
block|{
case|case
name|VDIR
case|:
return|return
operator|(
name|EISDIR
operator|)
return|;
case|case
name|VLNK
case|:
case|case
name|VREG
case|:
return|return
operator|(
name|EROFS
operator|)
return|;
case|case
name|VCHR
case|:
case|case
name|VBLK
case|:
case|case
name|VSOCK
case|:
case|case
name|VFIFO
case|:
case|case
name|VNON
case|:
case|case
name|VBAD
case|:
case|case
name|VMARKER
case|:
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check mode permission on inode pointer. Mode is READ, WRITE or EXEC.  * The mode is shifted to select the owner/group/other fields. The  * super user is granted all permissions.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|cd9660_access
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_access_args
comment|/* { 		struct vnode *a_vp; 		int  a_mode; 		struct ucred *a_cred; 		struct thread *a_td; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|iso_node
modifier|*
name|ip
init|=
name|VTOI
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|mode_t
name|mode
init|=
name|ap
operator|->
name|a_mode
decl_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VCHR
operator|||
name|vp
operator|->
name|v_type
operator|==
name|VBLK
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
comment|/* 	 * Disallow write attempts unless the file is a socket, 	 * fifo, or a block or character device resident on the 	 * filesystem. 	 */
if|if
condition|(
name|mode
operator|&
name|VWRITE
condition|)
block|{
switch|switch
condition|(
name|vp
operator|->
name|v_type
condition|)
block|{
case|case
name|VDIR
case|:
case|case
name|VLNK
case|:
case|case
name|VREG
case|:
return|return
operator|(
name|EROFS
operator|)
return|;
comment|/* NOT REACHED */
default|default:
break|break;
block|}
block|}
return|return
operator|(
name|vaccess
argument_list|(
name|vp
operator|->
name|v_type
argument_list|,
name|ip
operator|->
name|inode
operator|.
name|iso_mode
argument_list|,
name|ip
operator|->
name|inode
operator|.
name|iso_uid
argument_list|,
name|ip
operator|->
name|inode
operator|.
name|iso_gid
argument_list|,
name|ap
operator|->
name|a_mode
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cd9660_open
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_open_args
comment|/* { 		struct vnode *a_vp; 		int a_mode; 		struct ucred *a_cred; 		struct thread *a_td; 		int a_fdidx; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|iso_node
modifier|*
name|ip
init|=
name|VTOI
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|vnode_create_vobject
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|ip
operator|->
name|i_size
argument_list|,
name|ap
operator|->
name|a_td
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cd9660_getattr
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_getattr_args
comment|/* { 		struct vnode *a_vp; 		struct vattr *a_vap; 		struct ucred *a_cred; 		struct thread *a_td; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|vattr
modifier|*
name|vap
init|=
name|ap
operator|->
name|a_vap
decl_stmt|;
name|struct
name|iso_node
modifier|*
name|ip
init|=
name|VTOI
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|vap
operator|->
name|va_fsid
operator|=
name|dev2udev
argument_list|(
name|ip
operator|->
name|i_mnt
operator|->
name|im_dev
argument_list|)
expr_stmt|;
name|vap
operator|->
name|va_fileid
operator|=
name|ip
operator|->
name|i_number
expr_stmt|;
name|vap
operator|->
name|va_mode
operator|=
name|ip
operator|->
name|inode
operator|.
name|iso_mode
expr_stmt|;
name|vap
operator|->
name|va_nlink
operator|=
name|ip
operator|->
name|inode
operator|.
name|iso_links
expr_stmt|;
name|vap
operator|->
name|va_uid
operator|=
name|ip
operator|->
name|inode
operator|.
name|iso_uid
expr_stmt|;
name|vap
operator|->
name|va_gid
operator|=
name|ip
operator|->
name|inode
operator|.
name|iso_gid
expr_stmt|;
name|vap
operator|->
name|va_atime
operator|=
name|ip
operator|->
name|inode
operator|.
name|iso_atime
expr_stmt|;
name|vap
operator|->
name|va_mtime
operator|=
name|ip
operator|->
name|inode
operator|.
name|iso_mtime
expr_stmt|;
name|vap
operator|->
name|va_ctime
operator|=
name|ip
operator|->
name|inode
operator|.
name|iso_ctime
expr_stmt|;
name|vap
operator|->
name|va_rdev
operator|=
name|ip
operator|->
name|inode
operator|.
name|iso_rdev
expr_stmt|;
name|vap
operator|->
name|va_size
operator|=
operator|(
name|u_quad_t
operator|)
name|ip
operator|->
name|i_size
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|i_size
operator|==
literal|0
operator|&&
operator|(
name|vap
operator|->
name|va_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFLNK
condition|)
block|{
name|struct
name|vop_readlink_args
name|rdlnk
decl_stmt|;
name|struct
name|iovec
name|aiov
decl_stmt|;
name|struct
name|uio
name|auio
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|MALLOC
argument_list|(
name|cp
argument_list|,
name|char
operator|*
argument_list|,
name|MAXPATHLEN
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|aiov
operator|.
name|iov_base
operator|=
name|cp
expr_stmt|;
name|aiov
operator|.
name|iov_len
operator|=
name|MAXPATHLEN
expr_stmt|;
name|auio
operator|.
name|uio_iov
operator|=
operator|&
name|aiov
expr_stmt|;
name|auio
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|auio
operator|.
name|uio_offset
operator|=
literal|0
expr_stmt|;
name|auio
operator|.
name|uio_rw
operator|=
name|UIO_READ
expr_stmt|;
name|auio
operator|.
name|uio_segflg
operator|=
name|UIO_SYSSPACE
expr_stmt|;
name|auio
operator|.
name|uio_td
operator|=
name|ap
operator|->
name|a_td
expr_stmt|;
name|auio
operator|.
name|uio_resid
operator|=
name|MAXPATHLEN
expr_stmt|;
name|rdlnk
operator|.
name|a_uio
operator|=
operator|&
name|auio
expr_stmt|;
name|rdlnk
operator|.
name|a_vp
operator|=
name|ap
operator|->
name|a_vp
expr_stmt|;
name|rdlnk
operator|.
name|a_cred
operator|=
name|ap
operator|->
name|a_cred
expr_stmt|;
if|if
condition|(
name|cd9660_readlink
argument_list|(
operator|&
name|rdlnk
argument_list|)
operator|==
literal|0
condition|)
name|vap
operator|->
name|va_size
operator|=
name|MAXPATHLEN
operator|-
name|auio
operator|.
name|uio_resid
expr_stmt|;
name|FREE
argument_list|(
name|cp
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
name|vap
operator|->
name|va_flags
operator|=
literal|0
expr_stmt|;
name|vap
operator|->
name|va_gen
operator|=
literal|1
expr_stmt|;
name|vap
operator|->
name|va_blocksize
operator|=
name|ip
operator|->
name|i_mnt
operator|->
name|logical_block_size
expr_stmt|;
name|vap
operator|->
name|va_bytes
operator|=
operator|(
name|u_quad_t
operator|)
name|ip
operator|->
name|i_size
expr_stmt|;
name|vap
operator|->
name|va_type
operator|=
name|vp
operator|->
name|v_type
expr_stmt|;
name|vap
operator|->
name|va_filerev
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Vnode op for ioctl.  */
end_comment

begin_function
specifier|static
name|int
name|cd9660_ioctl
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_ioctl_args
comment|/* { 		struct vnode *a_vp; 		u_long  a_command; 		caddr_t  a_data; 		int  a_fflag; 		struct ucred *a_cred; 		struct thread *a_td; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|iso_node
modifier|*
name|ip
init|=
name|VTOI
argument_list|(
name|vp
argument_list|)
decl_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VCHR
operator|||
name|vp
operator|->
name|v_type
operator|==
name|VBLK
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
switch|switch
condition|(
name|ap
operator|->
name|a_command
condition|)
block|{
case|case
name|FIOGETLBA
case|:
operator|*
operator|(
name|int
operator|*
operator|)
operator|(
name|ap
operator|->
name|a_data
operator|)
operator|=
name|ip
operator|->
name|iso_start
expr_stmt|;
return|return
literal|0
return|;
default|default:
return|return
operator|(
name|ENOTTY
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Vnode op for reading.  */
end_comment

begin_function
specifier|static
name|int
name|cd9660_read
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_read_args
comment|/* { 		struct vnode *a_vp; 		struct uio *a_uio; 		int a_ioflag; 		struct ucred *a_cred; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
init|=
name|ap
operator|->
name|a_uio
decl_stmt|;
name|struct
name|iso_node
modifier|*
name|ip
init|=
name|VTOI
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|iso_mnt
modifier|*
name|imp
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|daddr_t
name|lbn
decl_stmt|,
name|rablock
decl_stmt|;
name|off_t
name|diff
decl_stmt|;
name|int
name|rasize
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|int
name|seqcount
decl_stmt|;
name|long
name|size
decl_stmt|,
name|n
decl_stmt|,
name|on
decl_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VCHR
operator|||
name|vp
operator|->
name|v_type
operator|==
name|VBLK
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
name|seqcount
operator|=
name|ap
operator|->
name|a_ioflag
operator|>>
name|IO_SEQSHIFT
expr_stmt|;
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|uio
operator|->
name|uio_offset
operator|<
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ip
operator|->
name|i_flag
operator||=
name|IN_ACCESS
expr_stmt|;
name|imp
operator|=
name|ip
operator|->
name|i_mnt
expr_stmt|;
do|do
block|{
name|lbn
operator|=
name|lblkno
argument_list|(
name|imp
argument_list|,
name|uio
operator|->
name|uio_offset
argument_list|)
expr_stmt|;
name|on
operator|=
name|blkoff
argument_list|(
name|imp
argument_list|,
name|uio
operator|->
name|uio_offset
argument_list|)
expr_stmt|;
name|n
operator|=
name|min
argument_list|(
call|(
name|u_int
call|)
argument_list|(
name|imp
operator|->
name|logical_block_size
operator|-
name|on
argument_list|)
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|)
expr_stmt|;
name|diff
operator|=
operator|(
name|off_t
operator|)
name|ip
operator|->
name|i_size
operator|-
name|uio
operator|->
name|uio_offset
expr_stmt|;
if|if
condition|(
name|diff
operator|<=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|diff
operator|<
name|n
condition|)
name|n
operator|=
name|diff
expr_stmt|;
name|size
operator|=
name|blksize
argument_list|(
name|imp
argument_list|,
name|ip
argument_list|,
name|lbn
argument_list|)
expr_stmt|;
name|rablock
operator|=
name|lbn
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|vp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_NOCLUSTERR
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|lblktosize
argument_list|(
name|imp
argument_list|,
name|rablock
argument_list|)
operator|<
name|ip
operator|->
name|i_size
condition|)
name|error
operator|=
name|cluster_read
argument_list|(
name|vp
argument_list|,
operator|(
name|off_t
operator|)
name|ip
operator|->
name|i_size
argument_list|,
name|lbn
argument_list|,
name|size
argument_list|,
name|NOCRED
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|,
operator|(
name|ap
operator|->
name|a_ioflag
operator|>>
literal|16
operator|)
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|bread
argument_list|(
name|vp
argument_list|,
name|lbn
argument_list|,
name|size
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|seqcount
operator|>
literal|1
operator|&&
name|lblktosize
argument_list|(
name|imp
argument_list|,
name|rablock
argument_list|)
operator|<
name|ip
operator|->
name|i_size
condition|)
block|{
name|rasize
operator|=
name|blksize
argument_list|(
name|imp
argument_list|,
name|ip
argument_list|,
name|rablock
argument_list|)
expr_stmt|;
name|error
operator|=
name|breadn
argument_list|(
name|vp
argument_list|,
name|lbn
argument_list|,
name|size
argument_list|,
operator|&
name|rablock
argument_list|,
operator|&
name|rasize
argument_list|,
literal|1
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
name|bread
argument_list|(
name|vp
argument_list|,
name|lbn
argument_list|,
name|size
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
block|}
name|n
operator|=
name|min
argument_list|(
name|n
argument_list|,
name|size
operator|-
name|bp
operator|->
name|b_resid
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|uiomove
argument_list|(
name|bp
operator|->
name|b_data
operator|+
name|on
argument_list|,
operator|(
name|int
operator|)
name|n
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|error
operator|==
literal|0
operator|&&
name|uio
operator|->
name|uio_resid
operator|>
literal|0
operator|&&
name|n
operator|!=
literal|0
condition|)
do|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Structure for reading directories  */
end_comment

begin_struct
struct|struct
name|isoreaddir
block|{
name|struct
name|dirent
name|saveent
decl_stmt|;
name|struct
name|dirent
name|assocent
decl_stmt|;
name|struct
name|dirent
name|current
decl_stmt|;
name|off_t
name|saveoff
decl_stmt|;
name|off_t
name|assocoff
decl_stmt|;
name|off_t
name|curroff
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
name|off_t
name|uio_off
decl_stmt|;
name|int
name|eofflag
decl_stmt|;
name|u_long
modifier|*
name|cookies
decl_stmt|;
name|int
name|ncookies
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|iso_uiodir
parameter_list|(
name|idp
parameter_list|,
name|dp
parameter_list|,
name|off
parameter_list|)
name|struct
name|isoreaddir
modifier|*
name|idp
decl_stmt|;
name|struct
name|dirent
modifier|*
name|dp
decl_stmt|;
name|off_t
name|off
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|dp
operator|->
name|d_name
index|[
name|dp
operator|->
name|d_namlen
index|]
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|d_reclen
operator|=
name|GENERIC_DIRSIZ
argument_list|(
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|idp
operator|->
name|uio
operator|->
name|uio_resid
operator|<
name|dp
operator|->
name|d_reclen
condition|)
block|{
name|idp
operator|->
name|eofflag
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|idp
operator|->
name|cookies
condition|)
block|{
if|if
condition|(
name|idp
operator|->
name|ncookies
operator|<=
literal|0
condition|)
block|{
name|idp
operator|->
name|eofflag
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|*
name|idp
operator|->
name|cookies
operator|++
operator|=
name|off
expr_stmt|;
operator|--
name|idp
operator|->
name|ncookies
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|uiomove
argument_list|(
name|dp
argument_list|,
name|dp
operator|->
name|d_reclen
argument_list|,
name|idp
operator|->
name|uio
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|idp
operator|->
name|uio_off
operator|=
name|off
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iso_shipdir
parameter_list|(
name|idp
parameter_list|)
name|struct
name|isoreaddir
modifier|*
name|idp
decl_stmt|;
block|{
name|struct
name|dirent
modifier|*
name|dp
decl_stmt|;
name|int
name|cl
decl_stmt|,
name|sl
decl_stmt|,
name|assoc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|char
modifier|*
name|cname
decl_stmt|,
modifier|*
name|sname
decl_stmt|;
name|cl
operator|=
name|idp
operator|->
name|current
operator|.
name|d_namlen
expr_stmt|;
name|cname
operator|=
name|idp
operator|->
name|current
operator|.
name|d_name
expr_stmt|;
name|assoc
operator|=
operator|(
name|cl
operator|>
literal|1
operator|)
operator|&&
operator|(
operator|*
name|cname
operator|==
name|ASSOCCHAR
operator|)
expr_stmt|;
if|if
condition|(
name|assoc
condition|)
block|{
name|cl
operator|--
expr_stmt|;
name|cname
operator|++
expr_stmt|;
block|}
name|dp
operator|=
operator|&
name|idp
operator|->
name|saveent
expr_stmt|;
name|sname
operator|=
name|dp
operator|->
name|d_name
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sl
operator|=
name|dp
operator|->
name|d_namlen
operator|)
condition|)
block|{
name|dp
operator|=
operator|&
name|idp
operator|->
name|assocent
expr_stmt|;
name|sname
operator|=
name|dp
operator|->
name|d_name
operator|+
literal|1
expr_stmt|;
name|sl
operator|=
name|dp
operator|->
name|d_namlen
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|sl
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|sl
operator|!=
name|cl
operator|||
name|bcmp
argument_list|(
name|sname
argument_list|,
name|cname
argument_list|,
name|sl
argument_list|)
condition|)
block|{
if|if
condition|(
name|idp
operator|->
name|assocent
operator|.
name|d_namlen
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|iso_uiodir
argument_list|(
name|idp
argument_list|,
operator|&
name|idp
operator|->
name|assocent
argument_list|,
name|idp
operator|->
name|assocoff
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|idp
operator|->
name|assocent
operator|.
name|d_namlen
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|idp
operator|->
name|saveent
operator|.
name|d_namlen
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|iso_uiodir
argument_list|(
name|idp
argument_list|,
operator|&
name|idp
operator|->
name|saveent
argument_list|,
name|idp
operator|->
name|saveoff
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|idp
operator|->
name|saveent
operator|.
name|d_namlen
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
name|idp
operator|->
name|current
operator|.
name|d_reclen
operator|=
name|GENERIC_DIRSIZ
argument_list|(
operator|&
name|idp
operator|->
name|current
argument_list|)
expr_stmt|;
if|if
condition|(
name|assoc
condition|)
block|{
name|idp
operator|->
name|assocoff
operator|=
name|idp
operator|->
name|curroff
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|idp
operator|->
name|current
argument_list|,
operator|&
name|idp
operator|->
name|assocent
argument_list|,
name|idp
operator|->
name|current
operator|.
name|d_reclen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|idp
operator|->
name|saveoff
operator|=
name|idp
operator|->
name|curroff
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|idp
operator|->
name|current
argument_list|,
operator|&
name|idp
operator|->
name|saveent
argument_list|,
name|idp
operator|->
name|current
operator|.
name|d_reclen
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Vnode op for readdir  */
end_comment

begin_function
specifier|static
name|int
name|cd9660_readdir
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_readdir_args
comment|/* { 		struct vnode *a_vp; 		struct uio *a_uio; 		struct ucred *a_cred; 		int *a_eofflag; 		int *a_ncookies; 		u_long **a_cookies; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|uio
modifier|*
name|uio
init|=
name|ap
operator|->
name|a_uio
decl_stmt|;
name|struct
name|isoreaddir
modifier|*
name|idp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vdp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|iso_node
modifier|*
name|dp
decl_stmt|;
name|struct
name|iso_mnt
modifier|*
name|imp
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
init|=
name|NULL
decl_stmt|;
name|struct
name|iso_directory_record
modifier|*
name|ep
decl_stmt|;
name|int
name|entryoffsetinblock
decl_stmt|;
name|doff_t
name|endsearch
decl_stmt|;
name|u_long
name|bmask
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|reclen
decl_stmt|;
name|u_short
name|namelen
decl_stmt|;
name|int
name|ncookies
init|=
literal|0
decl_stmt|;
name|u_long
modifier|*
name|cookies
init|=
name|NULL
decl_stmt|;
name|dp
operator|=
name|VTOI
argument_list|(
name|vdp
argument_list|)
expr_stmt|;
name|imp
operator|=
name|dp
operator|->
name|i_mnt
expr_stmt|;
name|bmask
operator|=
name|imp
operator|->
name|im_bmask
expr_stmt|;
name|MALLOC
argument_list|(
name|idp
argument_list|,
expr|struct
name|isoreaddir
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|idp
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|idp
operator|->
name|saveent
operator|.
name|d_namlen
operator|=
name|idp
operator|->
name|assocent
operator|.
name|d_namlen
operator|=
literal|0
expr_stmt|;
comment|/* 	 * XXX 	 * Is it worth trying to figure out the type? 	 */
name|idp
operator|->
name|saveent
operator|.
name|d_type
operator|=
name|idp
operator|->
name|assocent
operator|.
name|d_type
operator|=
name|idp
operator|->
name|current
operator|.
name|d_type
operator|=
name|DT_UNKNOWN
expr_stmt|;
name|idp
operator|->
name|uio
operator|=
name|uio
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|a_ncookies
operator|==
name|NULL
condition|)
block|{
name|idp
operator|->
name|cookies
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Guess the number of cookies needed. 		 */
name|ncookies
operator|=
name|uio
operator|->
name|uio_resid
operator|/
literal|16
expr_stmt|;
name|MALLOC
argument_list|(
name|cookies
argument_list|,
name|u_long
operator|*
argument_list|,
name|ncookies
operator|*
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|idp
operator|->
name|cookies
operator|=
name|cookies
expr_stmt|;
name|idp
operator|->
name|ncookies
operator|=
name|ncookies
expr_stmt|;
block|}
name|idp
operator|->
name|eofflag
operator|=
literal|1
expr_stmt|;
name|idp
operator|->
name|curroff
operator|=
name|uio
operator|->
name|uio_offset
expr_stmt|;
if|if
condition|(
operator|(
name|entryoffsetinblock
operator|=
name|idp
operator|->
name|curroff
operator|&
name|bmask
operator|)
operator|&&
operator|(
name|error
operator|=
name|cd9660_blkatoff
argument_list|(
name|vdp
argument_list|,
operator|(
name|off_t
operator|)
name|idp
operator|->
name|curroff
argument_list|,
name|NULL
argument_list|,
operator|&
name|bp
argument_list|)
operator|)
condition|)
block|{
name|FREE
argument_list|(
name|idp
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|endsearch
operator|=
name|dp
operator|->
name|i_size
expr_stmt|;
while|while
condition|(
name|idp
operator|->
name|curroff
operator|<
name|endsearch
condition|)
block|{
comment|/* 		 * If offset is on a block boundary, 		 * read the next directory block. 		 * Release previous if it exists. 		 */
if|if
condition|(
operator|(
name|idp
operator|->
name|curroff
operator|&
name|bmask
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|cd9660_blkatoff
argument_list|(
name|vdp
argument_list|,
operator|(
name|off_t
operator|)
name|idp
operator|->
name|curroff
argument_list|,
name|NULL
argument_list|,
operator|&
name|bp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
name|entryoffsetinblock
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 		 * Get pointer to next entry. 		 */
name|ep
operator|=
operator|(
expr|struct
name|iso_directory_record
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|bp
operator|->
name|b_data
operator|+
name|entryoffsetinblock
operator|)
expr_stmt|;
name|reclen
operator|=
name|isonum_711
argument_list|(
name|ep
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|reclen
operator|==
literal|0
condition|)
block|{
comment|/* skip to next block, if any */
name|idp
operator|->
name|curroff
operator|=
operator|(
name|idp
operator|->
name|curroff
operator|&
operator|~
name|bmask
operator|)
operator|+
name|imp
operator|->
name|logical_block_size
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|reclen
operator|<
name|ISO_DIRECTORY_RECORD_SIZE
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
comment|/* illegal entry, stop */
break|break;
block|}
if|if
condition|(
name|entryoffsetinblock
operator|+
name|reclen
operator|>
name|imp
operator|->
name|logical_block_size
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
comment|/* illegal directory, so stop looking */
break|break;
block|}
name|idp
operator|->
name|current
operator|.
name|d_namlen
operator|=
name|isonum_711
argument_list|(
name|ep
operator|->
name|name_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|reclen
operator|<
name|ISO_DIRECTORY_RECORD_SIZE
operator|+
name|idp
operator|->
name|current
operator|.
name|d_namlen
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
comment|/* illegal entry, stop */
break|break;
block|}
if|if
condition|(
name|isonum_711
argument_list|(
name|ep
operator|->
name|flags
argument_list|)
operator|&
literal|2
condition|)
name|idp
operator|->
name|current
operator|.
name|d_fileno
operator|=
name|isodirino
argument_list|(
name|ep
argument_list|,
name|imp
argument_list|)
expr_stmt|;
else|else
name|idp
operator|->
name|current
operator|.
name|d_fileno
operator|=
name|dbtob
argument_list|(
name|bp
operator|->
name|b_blkno
argument_list|)
operator|+
name|entryoffsetinblock
expr_stmt|;
name|idp
operator|->
name|curroff
operator|+=
name|reclen
expr_stmt|;
switch|switch
condition|(
name|imp
operator|->
name|iso_ftype
condition|)
block|{
case|case
name|ISO_FTYPE_RRIP
case|:
name|cd9660_rrip_getname
argument_list|(
name|ep
argument_list|,
name|idp
operator|->
name|current
operator|.
name|d_name
argument_list|,
operator|&
name|namelen
argument_list|,
operator|&
name|idp
operator|->
name|current
operator|.
name|d_fileno
argument_list|,
name|imp
argument_list|)
expr_stmt|;
name|idp
operator|->
name|current
operator|.
name|d_namlen
operator|=
operator|(
name|u_char
operator|)
name|namelen
expr_stmt|;
if|if
condition|(
name|idp
operator|->
name|current
operator|.
name|d_namlen
condition|)
name|error
operator|=
name|iso_uiodir
argument_list|(
name|idp
argument_list|,
operator|&
name|idp
operator|->
name|current
argument_list|,
name|idp
operator|->
name|curroff
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* ISO_FTYPE_DEFAULT || ISO_FTYPE_9660 || ISO_FTYPE_HIGH_SIERRA*/
name|strcpy
argument_list|(
name|idp
operator|->
name|current
operator|.
name|d_name
argument_list|,
literal|".."
argument_list|)
expr_stmt|;
if|if
condition|(
name|idp
operator|->
name|current
operator|.
name|d_namlen
operator|==
literal|1
operator|&&
name|ep
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|idp
operator|->
name|current
operator|.
name|d_namlen
operator|=
literal|1
expr_stmt|;
name|error
operator|=
name|iso_uiodir
argument_list|(
name|idp
argument_list|,
operator|&
name|idp
operator|->
name|current
argument_list|,
name|idp
operator|->
name|curroff
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|idp
operator|->
name|current
operator|.
name|d_namlen
operator|==
literal|1
operator|&&
name|ep
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|1
condition|)
block|{
name|idp
operator|->
name|current
operator|.
name|d_namlen
operator|=
literal|2
expr_stmt|;
name|error
operator|=
name|iso_uiodir
argument_list|(
name|idp
argument_list|,
operator|&
name|idp
operator|->
name|current
argument_list|,
name|idp
operator|->
name|curroff
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|isofntrans
argument_list|(
name|ep
operator|->
name|name
argument_list|,
name|idp
operator|->
name|current
operator|.
name|d_namlen
argument_list|,
name|idp
operator|->
name|current
operator|.
name|d_name
argument_list|,
operator|&
name|namelen
argument_list|,
name|imp
operator|->
name|iso_ftype
operator|==
name|ISO_FTYPE_9660
argument_list|,
name|isonum_711
argument_list|(
name|ep
operator|->
name|flags
argument_list|)
operator|&
literal|4
argument_list|,
name|imp
operator|->
name|joliet_level
argument_list|,
name|imp
operator|->
name|im_flags
argument_list|,
name|imp
operator|->
name|im_d2l
argument_list|)
expr_stmt|;
name|idp
operator|->
name|current
operator|.
name|d_namlen
operator|=
operator|(
name|u_char
operator|)
name|namelen
expr_stmt|;
if|if
condition|(
name|imp
operator|->
name|iso_ftype
operator|==
name|ISO_FTYPE_DEFAULT
condition|)
name|error
operator|=
name|iso_shipdir
argument_list|(
name|idp
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|iso_uiodir
argument_list|(
name|idp
argument_list|,
operator|&
name|idp
operator|->
name|current
argument_list|,
name|idp
operator|->
name|curroff
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error
condition|)
break|break;
name|entryoffsetinblock
operator|+=
name|reclen
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|error
operator|&&
name|imp
operator|->
name|iso_ftype
operator|==
name|ISO_FTYPE_DEFAULT
condition|)
block|{
name|idp
operator|->
name|current
operator|.
name|d_namlen
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|iso_shipdir
argument_list|(
name|idp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|<
literal|0
condition|)
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|a_ncookies
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|error
condition|)
name|free
argument_list|(
name|cookies
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* 			 * Work out the number of cookies actually used. 			 */
operator|*
name|ap
operator|->
name|a_ncookies
operator|=
name|ncookies
operator|-
name|idp
operator|->
name|ncookies
expr_stmt|;
operator|*
name|ap
operator|->
name|a_cookies
operator|=
name|cookies
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bp
condition|)
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|uio
operator|->
name|uio_offset
operator|=
name|idp
operator|->
name|uio_off
expr_stmt|;
operator|*
name|ap
operator|->
name|a_eofflag
operator|=
name|idp
operator|->
name|eofflag
expr_stmt|;
name|FREE
argument_list|(
name|idp
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return target name of a symbolic link  * Shouldn't we get the parent vnode and read the data from there?  * This could eventually result in deadlocks in cd9660_lookup.  * But otherwise the block read here is in the block buffer two times.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|iso_directory_record
name|ISODIR
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|iso_node
name|ISONODE
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|iso_mnt
name|ISOMNT
typedef|;
end_typedef

begin_function
specifier|static
name|int
name|cd9660_readlink
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_readlink_args
comment|/* { 		struct vnode *a_vp; 		struct uio *a_uio; 		struct ucred *a_cred; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|ISONODE
modifier|*
name|ip
decl_stmt|;
name|ISODIR
modifier|*
name|dirp
decl_stmt|;
name|ISOMNT
modifier|*
name|imp
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
name|u_short
name|symlen
decl_stmt|;
name|int
name|error
decl_stmt|;
name|char
modifier|*
name|symname
decl_stmt|;
name|ip
operator|=
name|VTOI
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
name|imp
operator|=
name|ip
operator|->
name|i_mnt
expr_stmt|;
name|uio
operator|=
name|ap
operator|->
name|a_uio
expr_stmt|;
if|if
condition|(
name|imp
operator|->
name|iso_ftype
operator|!=
name|ISO_FTYPE_RRIP
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * Get parents directory record block that this inode included. 	 */
name|error
operator|=
name|bread
argument_list|(
name|imp
operator|->
name|im_devvp
argument_list|,
operator|(
name|ip
operator|->
name|i_number
operator|>>
name|imp
operator|->
name|im_bshift
operator|)
operator|<<
operator|(
name|imp
operator|->
name|im_bshift
operator|-
name|DEV_BSHIFT
operator|)
argument_list|,
name|imp
operator|->
name|logical_block_size
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 	 * Setup the directory pointer for this inode 	 */
name|dirp
operator|=
operator|(
name|ISODIR
operator|*
operator|)
operator|(
name|bp
operator|->
name|b_data
operator|+
operator|(
name|ip
operator|->
name|i_number
operator|&
name|imp
operator|->
name|im_bmask
operator|)
operator|)
expr_stmt|;
comment|/* 	 * Just make sure, we have a right one.... 	 *   1: Check not cross boundary on block 	 */
if|if
condition|(
operator|(
name|ip
operator|->
name|i_number
operator|&
name|imp
operator|->
name|im_bmask
operator|)
operator|+
name|isonum_711
argument_list|(
name|dirp
operator|->
name|length
argument_list|)
operator|>
operator|(
name|unsigned
operator|)
name|imp
operator|->
name|logical_block_size
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 	 * Now get a buffer 	 * Abuse a namei buffer for now. 	 */
if|if
condition|(
name|uio
operator|->
name|uio_segflg
operator|==
name|UIO_SYSSPACE
condition|)
name|symname
operator|=
name|uio
operator|->
name|uio_iov
operator|->
name|iov_base
expr_stmt|;
else|else
name|symname
operator|=
name|uma_zalloc
argument_list|(
name|namei_zone
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
comment|/* 	 * Ok, we just gathering a symbolic name in SL record. 	 */
if|if
condition|(
name|cd9660_rrip_getsymname
argument_list|(
name|dirp
argument_list|,
name|symname
argument_list|,
operator|&
name|symlen
argument_list|,
name|imp
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|uio
operator|->
name|uio_segflg
operator|!=
name|UIO_SYSSPACE
condition|)
name|uma_zfree
argument_list|(
name|namei_zone
argument_list|,
name|symname
argument_list|)
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 	 * Don't forget before you leave from home ;-) 	 */
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* 	 * return with the symbolic name to caller's. 	 */
if|if
condition|(
name|uio
operator|->
name|uio_segflg
operator|!=
name|UIO_SYSSPACE
condition|)
block|{
name|error
operator|=
name|uiomove
argument_list|(
name|symname
argument_list|,
name|symlen
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|namei_zone
argument_list|,
name|symname
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|uio
operator|->
name|uio_resid
operator|-=
name|symlen
expr_stmt|;
name|uio
operator|->
name|uio_iov
operator|->
name|iov_base
operator|=
operator|(
name|char
operator|*
operator|)
name|uio
operator|->
name|uio_iov
operator|->
name|iov_base
operator|+
name|symlen
expr_stmt|;
name|uio
operator|->
name|uio_iov
operator|->
name|iov_len
operator|-=
name|symlen
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Calculate the logical to physical mapping if not done already,  * then call the device strategy routine.  */
end_comment

begin_function
specifier|static
name|int
name|cd9660_strategy
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_strategy_args
comment|/* { 		struct buf *a_vp; 		struct buf *a_bp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|buf
modifier|*
name|bp
init|=
name|ap
operator|->
name|a_bp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|iso_node
modifier|*
name|ip
decl_stmt|;
name|struct
name|bufobj
modifier|*
name|bo
decl_stmt|;
name|ip
operator|=
name|VTOI
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VBLK
operator|||
name|vp
operator|->
name|v_type
operator|==
name|VCHR
condition|)
name|panic
argument_list|(
literal|"cd9660_strategy: spec"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_blkno
operator|==
name|bp
operator|->
name|b_lblkno
condition|)
block|{
name|bp
operator|->
name|b_blkno
operator|=
operator|(
name|ip
operator|->
name|iso_start
operator|+
name|bp
operator|->
name|b_lblkno
operator|)
operator|<<
operator|(
name|ip
operator|->
name|i_mnt
operator|->
name|im_bshift
operator|-
name|DEV_BSHIFT
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|long
operator|)
name|bp
operator|->
name|b_blkno
operator|==
operator|-
literal|1
condition|)
comment|/* XXX: cut&paste junk ? */
name|clrbuf
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|long
operator|)
name|bp
operator|->
name|b_blkno
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* XXX: cut&paste junk ? */
name|bufdone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|bp
operator|->
name|b_iooffset
operator|=
name|dbtob
argument_list|(
name|bp
operator|->
name|b_blkno
argument_list|)
expr_stmt|;
name|bo
operator|=
name|ip
operator|->
name|i_mnt
operator|->
name|im_bo
expr_stmt|;
name|BO_STRATEGY
argument_list|(
name|bo
argument_list|,
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return POSIX pathconf information applicable to cd9660 filesystems.  */
end_comment

begin_function
specifier|static
name|int
name|cd9660_pathconf
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_pathconf_args
comment|/* { 		struct vnode *a_vp; 		int a_name; 		register_t *a_retval; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
switch|switch
condition|(
name|ap
operator|->
name|a_name
condition|)
block|{
case|case
name|_PC_LINK_MAX
case|:
operator|*
name|ap
operator|->
name|a_retval
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|_PC_NAME_MAX
case|:
if|if
condition|(
name|VTOI
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
operator|->
name|i_mnt
operator|->
name|iso_ftype
operator|==
name|ISO_FTYPE_RRIP
condition|)
operator|*
name|ap
operator|->
name|a_retval
operator|=
name|NAME_MAX
expr_stmt|;
else|else
operator|*
name|ap
operator|->
name|a_retval
operator|=
literal|37
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|_PC_PATH_MAX
case|:
operator|*
name|ap
operator|->
name|a_retval
operator|=
name|PATH_MAX
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|_PC_PIPE_BUF
case|:
operator|*
name|ap
operator|->
name|a_retval
operator|=
name|PIPE_BUF
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|_PC_CHOWN_RESTRICTED
case|:
operator|*
name|ap
operator|->
name|a_retval
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|_PC_NO_TRUNC
case|:
operator|*
name|ap
operator|->
name|a_retval
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/*  * Global vfs data structures for cd9660  */
end_comment

begin_decl_stmt
name|struct
name|vop_vector
name|cd9660_vnodeops
init|=
block|{
operator|.
name|vop_default
operator|=
operator|&
name|default_vnodeops
block|,
operator|.
name|vop_open
operator|=
name|cd9660_open
block|,
operator|.
name|vop_access
operator|=
name|cd9660_access
block|,
operator|.
name|vop_bmap
operator|=
name|cd9660_bmap
block|,
operator|.
name|vop_cachedlookup
operator|=
name|cd9660_lookup
block|,
operator|.
name|vop_getattr
operator|=
name|cd9660_getattr
block|,
operator|.
name|vop_inactive
operator|=
name|cd9660_inactive
block|,
operator|.
name|vop_ioctl
operator|=
name|cd9660_ioctl
block|,
operator|.
name|vop_lookup
operator|=
name|vfs_cache_lookup
block|,
operator|.
name|vop_pathconf
operator|=
name|cd9660_pathconf
block|,
operator|.
name|vop_read
operator|=
name|cd9660_read
block|,
operator|.
name|vop_readdir
operator|=
name|cd9660_readdir
block|,
operator|.
name|vop_readlink
operator|=
name|cd9660_readlink
block|,
operator|.
name|vop_reclaim
operator|=
name|cd9660_reclaim
block|,
operator|.
name|vop_setattr
operator|=
name|cd9660_setattr
block|,
operator|.
name|vop_strategy
operator|=
name|cd9660_strategy
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Special device vnode ops  */
end_comment

begin_decl_stmt
name|struct
name|vop_vector
name|cd9660_fifoops
init|=
block|{
operator|.
name|vop_default
operator|=
operator|&
name|fifo_specops
block|,
operator|.
name|vop_access
operator|=
name|cd9660_access
block|,
operator|.
name|vop_getattr
operator|=
name|cd9660_getattr
block|,
operator|.
name|vop_inactive
operator|=
name|cd9660_inactive
block|,
operator|.
name|vop_reclaim
operator|=
name|cd9660_reclaim
block|,
operator|.
name|vop_setattr
operator|=
name|cd9660_setattr
block|, }
decl_stmt|;
end_decl_stmt

end_unit

