begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2002 Dima Dorfman.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * DEVFS ruleset implementation.  *  * A note on terminology: To "run" a rule on a dirent is to take the  * prescribed action; to "apply" a rule is to check whether it matches  * a dirent and run if if it does.  *  * A note on locking: Only foreign entry points (non-static functions)  * should deal with locking.  Everything else assumes we already hold  * the required kind of lock.  *  * A note on namespace: devfs_rules_* are the non-static functions for  * the entire "ruleset" subsystem, devfs_rule_* are the static  * functions that operate on rules, and devfs_ruleset_* are the static  * functions that operate on rulesets.  The line between the last two  * isn't always clear, but the guideline is still useful.  *  * A note on "special" identifiers: Ruleset 0 is the NULL, or empty,  * ruleset; it cannot be deleted or changed in any way.  This may be  * assumed inside the code; e.g., a ruleset of 0 may be interpeted to  * mean "no ruleset".  The interpretation of rule 0 is  * command-dependent, but in no case is there a real rule with number  * 0.  *  * A note on errno codes: To make it easier for the userland to tell  * what went wrong, we sometimes use errno codes that are not entirely  * appropriate for the error but that would be less ambiguous than the  * appropriate "generic" code.  For example, when we can't find a  * ruleset, we return ESRCH instead of ENOENT (except in  * DEVFSIO_{R,S}GETNEXT, where a nonexistent ruleset means "end of  * list", and the userland expects ENOENT to be this indicator); this  * way, when an operation fails, it's clear that what couldn't be  * found is a ruleset and not a rule (well, it's clear to those who  * know the convention).  */
end_comment

begin_include
include|#
directive|include
file|"opt_devfs.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/dirent.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioccom.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<fs/devfs/devfs.h>
end_include

begin_include
include|#
directive|include
file|<fs/devfs/devfs_int.h>
end_include

begin_comment
comment|/*  * Kernel version of devfs_rule.  */
end_comment

begin_struct
struct|struct
name|devfs_krule
block|{
name|TAILQ_ENTRY
argument_list|(
argument|devfs_krule
argument_list|)
name|dk_list
expr_stmt|;
name|struct
name|devfs_ruleset
modifier|*
name|dk_ruleset
decl_stmt|;
name|struct
name|devfs_rule
name|dk_rule
decl_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
name|TAILQ_HEAD
argument_list|(
name|rulehead
argument_list|,
name|devfs_krule
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_DEVFSRULE
argument_list|,
literal|"DEVFS_RULE"
argument_list|,
literal|"DEVFS rule storage"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Structure to describe a ruleset.  */
end_comment

begin_struct
struct|struct
name|devfs_ruleset
block|{
name|TAILQ_ENTRY
argument_list|(
argument|devfs_ruleset
argument_list|)
name|ds_list
expr_stmt|;
name|struct
name|rulehead
name|ds_rules
decl_stmt|;
name|devfs_rsnum
name|ds_number
decl_stmt|;
name|int
name|ds_refcount
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|devfs_rid
name|devfs_rid_input
parameter_list|(
name|devfs_rid
name|rid
parameter_list|,
name|struct
name|devfs_mount
modifier|*
name|dm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|devfs_rule_applyde_recursive
parameter_list|(
name|struct
name|devfs_krule
modifier|*
name|dk
parameter_list|,
name|struct
name|devfs_dirent
modifier|*
name|de
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|devfs_rule_applydm
parameter_list|(
name|struct
name|devfs_krule
modifier|*
name|dk
parameter_list|,
name|struct
name|devfs_mount
modifier|*
name|dm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|devfs_rule_autonumber
parameter_list|(
name|struct
name|devfs_ruleset
modifier|*
name|ds
parameter_list|,
name|devfs_rnum
modifier|*
name|rnp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|devfs_krule
modifier|*
name|devfs_rule_byid
parameter_list|(
name|devfs_rid
name|rid
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|devfs_rule_delete
parameter_list|(
name|struct
name|devfs_krule
modifier|*
name|dkp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|cdev
modifier|*
name|devfs_rule_getdev
parameter_list|(
name|struct
name|devfs_dirent
modifier|*
name|de
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|devfs_rule_input
parameter_list|(
name|struct
name|devfs_rule
modifier|*
name|dr
parameter_list|,
name|struct
name|devfs_mount
modifier|*
name|dm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|devfs_rule_insert
parameter_list|(
name|struct
name|devfs_rule
modifier|*
name|dr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|devfs_rule_match
parameter_list|(
name|struct
name|devfs_krule
modifier|*
name|dk
parameter_list|,
name|struct
name|devfs_dirent
modifier|*
name|de
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|devfs_rule_matchpath
parameter_list|(
name|struct
name|devfs_krule
modifier|*
name|dk
parameter_list|,
name|struct
name|devfs_dirent
modifier|*
name|de
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|devfs_rule_run
parameter_list|(
name|struct
name|devfs_krule
modifier|*
name|dk
parameter_list|,
name|struct
name|devfs_dirent
modifier|*
name|de
parameter_list|,
name|unsigned
name|depth
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|devfs_ruleset_applyde
parameter_list|(
name|struct
name|devfs_ruleset
modifier|*
name|ds
parameter_list|,
name|struct
name|devfs_dirent
modifier|*
name|de
parameter_list|,
name|unsigned
name|depth
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|devfs_ruleset_applydm
parameter_list|(
name|struct
name|devfs_ruleset
modifier|*
name|ds
parameter_list|,
name|struct
name|devfs_mount
modifier|*
name|dm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|devfs_ruleset
modifier|*
name|devfs_ruleset_bynum
parameter_list|(
name|devfs_rsnum
name|rsnum
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|devfs_ruleset
modifier|*
name|devfs_ruleset_create
parameter_list|(
name|devfs_rsnum
name|rsnum
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|devfs_ruleset_reap
parameter_list|(
name|struct
name|devfs_ruleset
modifier|*
name|dsp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|devfs_ruleset_use
parameter_list|(
name|devfs_rsnum
name|rsnum
parameter_list|,
name|struct
name|devfs_mount
modifier|*
name|dm
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|sx
name|sx_rules
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SX_SYSINIT
argument_list|(
name|sx_rules
argument_list|,
operator|&
name|sx_rules
argument_list|,
literal|"DEVFS ruleset lock"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|devfs_ruleset
argument_list|)
name|devfs_rulesets
operator|=
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|devfs_rulesets
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Called to apply the proper rules for 'de' before it can be  * exposed to the userland.  This should be called with an exclusive  * lock on dm in case we need to run anything.  */
end_comment

begin_function
name|void
name|devfs_rules_apply
parameter_list|(
name|struct
name|devfs_mount
modifier|*
name|dm
parameter_list|,
name|struct
name|devfs_dirent
modifier|*
name|de
parameter_list|)
block|{
name|struct
name|devfs_ruleset
modifier|*
name|ds
decl_stmt|;
if|if
condition|(
name|dm
operator|->
name|dm_ruleset
operator|==
literal|0
condition|)
return|return;
name|sx_slock
argument_list|(
operator|&
name|sx_rules
argument_list|)
expr_stmt|;
name|ds
operator|=
name|devfs_ruleset_bynum
argument_list|(
name|dm
operator|->
name|dm_ruleset
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ds
operator|!=
name|NULL
argument_list|,
operator|(
literal|"mount-point has NULL ruleset"
operator|)
argument_list|)
expr_stmt|;
name|devfs_ruleset_applyde
argument_list|(
name|ds
argument_list|,
name|de
argument_list|,
name|devfs_rule_depth
argument_list|)
expr_stmt|;
name|sx_sunlock
argument_list|(
operator|&
name|sx_rules
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Rule subsystem ioctl hook.  */
end_comment

begin_function
name|int
name|devfs_rules_ioctl
parameter_list|(
name|struct
name|devfs_mount
modifier|*
name|dm
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|devfs_ruleset
modifier|*
name|ds
decl_stmt|;
name|struct
name|devfs_krule
modifier|*
name|dk
decl_stmt|;
name|struct
name|devfs_rule
modifier|*
name|dr
decl_stmt|;
name|devfs_rsnum
name|rsnum
decl_stmt|;
name|devfs_rnum
name|rnum
decl_stmt|;
name|devfs_rid
name|rid
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sx_assert
argument_list|(
operator|&
name|dm
operator|->
name|dm_lock
argument_list|,
name|SX_XLOCKED
argument_list|)
expr_stmt|;
comment|/* 	 * XXX: This returns an error regardless of whether we 	 * actually support the cmd or not. 	 */
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|sx_xlock
argument_list|(
operator|&
name|sx_rules
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|DEVFSIO_RADD
case|:
name|dr
operator|=
operator|(
expr|struct
name|devfs_rule
operator|*
operator|)
name|data
expr_stmt|;
name|error
operator|=
name|devfs_rule_input
argument_list|(
name|dr
argument_list|,
name|dm
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
name|dk
operator|=
name|devfs_rule_byid
argument_list|(
name|dr
operator|->
name|dr_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|dk
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|EEXIST
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|rid2rsn
argument_list|(
name|dr
operator|->
name|dr_id
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|error
operator|=
name|devfs_rule_insert
argument_list|(
name|dr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEVFSIO_RAPPLY
case|:
name|dr
operator|=
operator|(
expr|struct
name|devfs_rule
operator|*
operator|)
name|data
expr_stmt|;
name|error
operator|=
name|devfs_rule_input
argument_list|(
name|dr
argument_list|,
name|dm
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
comment|/* 		 * This is one of many possible hackish 		 * implementations.  The primary contender is an 		 * implementation where the rule we read in is 		 * temporarily inserted into some ruleset, perhaps 		 * with a hypothetical DRO_NOAUTO flag so that it 		 * doesn't get used where it isn't intended, and 		 * applied in the normal way.  This can be done in the 		 * userland (DEVFSIO_ADD, DEVFSIO_APPLYID, 		 * DEVFSIO_DEL) or in the kernel; either way it breaks 		 * some corner case assumptions in other parts of the 		 * code (not that this implementation doesn't do 		 * that). 		 */
if|if
condition|(
name|dr
operator|->
name|dr_iacts
operator|&
name|DRA_INCSET
operator|&&
name|devfs_ruleset_bynum
argument_list|(
name|dr
operator|->
name|dr_incset
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ESRCH
expr_stmt|;
break|break;
block|}
name|dk
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|dk
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|dk
operator|->
name|dk_rule
argument_list|,
name|dr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dr
argument_list|)
argument_list|)
expr_stmt|;
name|devfs_rule_applydm
argument_list|(
name|dk
argument_list|,
name|dm
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dk
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEVFSIO_RAPPLYID
case|:
name|rid
operator|=
operator|*
operator|(
name|devfs_rid
operator|*
operator|)
name|data
expr_stmt|;
name|rid
operator|=
name|devfs_rid_input
argument_list|(
name|rid
argument_list|,
name|dm
argument_list|)
expr_stmt|;
name|dk
operator|=
name|devfs_rule_byid
argument_list|(
name|rid
argument_list|)
expr_stmt|;
if|if
condition|(
name|dk
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOENT
expr_stmt|;
break|break;
block|}
name|devfs_rule_applydm
argument_list|(
name|dk
argument_list|,
name|dm
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEVFSIO_RDEL
case|:
name|rid
operator|=
operator|*
operator|(
name|devfs_rid
operator|*
operator|)
name|data
expr_stmt|;
name|rid
operator|=
name|devfs_rid_input
argument_list|(
name|rid
argument_list|,
name|dm
argument_list|)
expr_stmt|;
name|dk
operator|=
name|devfs_rule_byid
argument_list|(
name|rid
argument_list|)
expr_stmt|;
if|if
condition|(
name|dk
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOENT
expr_stmt|;
break|break;
block|}
name|ds
operator|=
name|dk
operator|->
name|dk_ruleset
expr_stmt|;
name|error
operator|=
name|devfs_rule_delete
argument_list|(
name|dk
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEVFSIO_RGETNEXT
case|:
name|dr
operator|=
operator|(
expr|struct
name|devfs_rule
operator|*
operator|)
name|data
expr_stmt|;
name|error
operator|=
name|devfs_rule_input
argument_list|(
name|dr
argument_list|,
name|dm
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
comment|/* 		 * We can't use devfs_rule_byid() here since that 		 * requires the rule specified to exist, but we want 		 * getnext(N) to work whether there is a rule N or not 		 * (specifically, getnext(0) must work, but we should 		 * never have a rule 0 since the add command 		 * interprets 0 to mean "auto-number"). 		 */
name|ds
operator|=
name|devfs_ruleset_bynum
argument_list|(
name|rid2rsn
argument_list|(
name|dr
operator|->
name|dr_id
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOENT
expr_stmt|;
break|break;
block|}
name|rnum
operator|=
name|rid2rn
argument_list|(
name|dr
operator|->
name|dr_id
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|dk
argument_list|,
argument|&ds->ds_rules
argument_list|,
argument|dk_list
argument_list|)
block|{
if|if
condition|(
name|rid2rn
argument_list|(
name|dk
operator|->
name|dk_rule
operator|.
name|dr_id
argument_list|)
operator|>
name|rnum
condition|)
break|break;
block|}
if|if
condition|(
name|dk
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOENT
expr_stmt|;
break|break;
block|}
name|memcpy
argument_list|(
name|dr
argument_list|,
operator|&
name|dk
operator|->
name|dk_rule
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEVFSIO_SUSE
case|:
name|rsnum
operator|=
operator|*
operator|(
name|devfs_rsnum
operator|*
operator|)
name|data
expr_stmt|;
name|error
operator|=
name|devfs_ruleset_use
argument_list|(
name|rsnum
argument_list|,
name|dm
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEVFSIO_SAPPLY
case|:
name|rsnum
operator|=
operator|*
operator|(
name|devfs_rsnum
operator|*
operator|)
name|data
expr_stmt|;
name|rsnum
operator|=
name|rid2rsn
argument_list|(
name|devfs_rid_input
argument_list|(
name|mkrid
argument_list|(
name|rsnum
argument_list|,
literal|0
argument_list|)
argument_list|,
name|dm
argument_list|)
argument_list|)
expr_stmt|;
name|ds
operator|=
name|devfs_ruleset_bynum
argument_list|(
name|rsnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ESRCH
expr_stmt|;
break|break;
block|}
name|devfs_ruleset_applydm
argument_list|(
name|ds
argument_list|,
name|dm
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEVFSIO_SGETNEXT
case|:
name|rsnum
operator|=
operator|*
operator|(
name|devfs_rsnum
operator|*
operator|)
name|data
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ds
argument_list|,
argument|&devfs_rulesets
argument_list|,
argument|ds_list
argument_list|)
block|{
if|if
condition|(
name|ds
operator|->
name|ds_number
operator|>
name|rsnum
condition|)
break|break;
block|}
if|if
condition|(
name|ds
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOENT
expr_stmt|;
break|break;
block|}
operator|*
operator|(
name|devfs_rsnum
operator|*
operator|)
name|data
operator|=
name|ds
operator|->
name|ds_number
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ENOIOCTL
expr_stmt|;
break|break;
block|}
name|sx_xunlock
argument_list|(
operator|&
name|sx_rules
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Adjust the rule identifier to use the ruleset of dm if one isn't  * explicitly specified.  *  * Note that after this operation, rid2rsn(rid) might still be 0, and  * that's okay; ruleset 0 is a valid ruleset, but when it's read in  * from the userland, it means "current ruleset for this mount-point".  */
end_comment

begin_function
specifier|static
name|devfs_rid
name|devfs_rid_input
parameter_list|(
name|devfs_rid
name|rid
parameter_list|,
name|struct
name|devfs_mount
modifier|*
name|dm
parameter_list|)
block|{
if|if
condition|(
name|rid2rsn
argument_list|(
name|rid
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|mkrid
argument_list|(
name|dm
operator|->
name|dm_ruleset
argument_list|,
name|rid2rn
argument_list|(
name|rid
argument_list|)
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|rid
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Apply dk to de and everything under de.  *  * XXX: This method needs a function call for every nested  * subdirectory in a devfs mount.  If we plan to have many of these,  * we might eventually run out of kernel stack space.  * XXX: a linear search could be done through the cdev list instead.  */
end_comment

begin_function
specifier|static
name|void
name|devfs_rule_applyde_recursive
parameter_list|(
name|struct
name|devfs_krule
modifier|*
name|dk
parameter_list|,
name|struct
name|devfs_dirent
modifier|*
name|de
parameter_list|)
block|{
name|struct
name|devfs_dirent
modifier|*
name|de2
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|de2
argument_list|,
argument|&de->de_dlist
argument_list|,
argument|de_list
argument_list|)
name|devfs_rule_applyde_recursive
argument_list|(
name|dk
argument_list|,
name|de2
argument_list|)
expr_stmt|;
name|devfs_rule_run
argument_list|(
name|dk
argument_list|,
name|de
argument_list|,
name|devfs_rule_depth
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Apply dk to all entires in dm.  */
end_comment

begin_function
specifier|static
name|void
name|devfs_rule_applydm
parameter_list|(
name|struct
name|devfs_krule
modifier|*
name|dk
parameter_list|,
name|struct
name|devfs_mount
modifier|*
name|dm
parameter_list|)
block|{
name|devfs_rule_applyde_recursive
argument_list|(
name|dk
argument_list|,
name|dm
operator|->
name|dm_rootdir
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Automatically select a number for a new rule in ds, and write the  * result into rnump.  */
end_comment

begin_function
specifier|static
name|int
name|devfs_rule_autonumber
parameter_list|(
name|struct
name|devfs_ruleset
modifier|*
name|ds
parameter_list|,
name|devfs_rnum
modifier|*
name|rnump
parameter_list|)
block|{
name|struct
name|devfs_krule
modifier|*
name|dk
decl_stmt|;
comment|/* Find the last rule. */
name|dk
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|ds
operator|->
name|ds_rules
argument_list|,
name|rulehead
argument_list|)
expr_stmt|;
if|if
condition|(
name|dk
operator|==
name|NULL
condition|)
operator|*
name|rnump
operator|=
literal|100
expr_stmt|;
else|else
block|{
operator|*
name|rnump
operator|=
name|rid2rn
argument_list|(
name|dk
operator|->
name|dk_rule
operator|.
name|dr_id
argument_list|)
operator|+
literal|100
expr_stmt|;
comment|/* Detect overflow. */
if|if
condition|(
operator|*
name|rnump
operator|<
name|rid2rn
argument_list|(
name|dk
operator|->
name|dk_rule
operator|.
name|dr_id
argument_list|)
condition|)
return|return
operator|(
name|ERANGE
operator|)
return|;
block|}
name|KASSERT
argument_list|(
name|devfs_rule_byid
argument_list|(
name|mkrid
argument_list|(
name|ds
operator|->
name|ds_number
argument_list|,
operator|*
name|rnump
argument_list|)
argument_list|)
operator|==
name|NULL
argument_list|,
operator|(
literal|"autonumbering resulted in an already existing rule"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find a krule by id.  */
end_comment

begin_function
specifier|static
name|struct
name|devfs_krule
modifier|*
name|devfs_rule_byid
parameter_list|(
name|devfs_rid
name|rid
parameter_list|)
block|{
name|struct
name|devfs_ruleset
modifier|*
name|ds
decl_stmt|;
name|struct
name|devfs_krule
modifier|*
name|dk
decl_stmt|;
name|devfs_rnum
name|rn
decl_stmt|;
name|rn
operator|=
name|rid2rn
argument_list|(
name|rid
argument_list|)
expr_stmt|;
name|ds
operator|=
name|devfs_ruleset_bynum
argument_list|(
name|rid2rsn
argument_list|(
name|rid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|TAILQ_FOREACH
argument_list|(
argument|dk
argument_list|,
argument|&ds->ds_rules
argument_list|,
argument|dk_list
argument_list|)
block|{
if|if
condition|(
name|rid2rn
argument_list|(
name|dk
operator|->
name|dk_rule
operator|.
name|dr_id
argument_list|)
operator|==
name|rn
condition|)
return|return
operator|(
name|dk
operator|)
return|;
elseif|else
if|if
condition|(
name|rid2rn
argument_list|(
name|dk
operator|->
name|dk_rule
operator|.
name|dr_id
argument_list|)
operator|>
name|rn
condition|)
break|break;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove dkp from any lists it may be on and remove memory associated  * with it.  */
end_comment

begin_function
specifier|static
name|int
name|devfs_rule_delete
parameter_list|(
name|struct
name|devfs_krule
modifier|*
name|dk
parameter_list|)
block|{
name|struct
name|devfs_ruleset
modifier|*
name|ds
decl_stmt|;
if|if
condition|(
name|dk
operator|->
name|dk_rule
operator|.
name|dr_iacts
operator|&
name|DRA_INCSET
condition|)
block|{
name|ds
operator|=
name|devfs_ruleset_bynum
argument_list|(
name|dk
operator|->
name|dk_rule
operator|.
name|dr_incset
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ds
operator|!=
name|NULL
argument_list|,
operator|(
literal|"DRA_INCSET but bad dr_incset"
operator|)
argument_list|)
expr_stmt|;
operator|--
name|ds
operator|->
name|ds_refcount
expr_stmt|;
name|devfs_ruleset_reap
argument_list|(
name|ds
argument_list|)
expr_stmt|;
block|}
name|ds
operator|=
name|dk
operator|->
name|dk_ruleset
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ds
operator|->
name|ds_rules
argument_list|,
name|dk
argument_list|,
name|dk_list
argument_list|)
expr_stmt|;
name|devfs_ruleset_reap
argument_list|(
name|ds
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dk
argument_list|,
name|M_DEVFSRULE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get a struct cdev *corresponding to de so we can try to match rules based  * on it.  If this routine returns NULL, there is no struct cdev *associated  * with the dirent (symlinks and directories don't have dev_ts), and  * the caller should assume that any critera dependent on a dev_t  * don't match.  */
end_comment

begin_function
specifier|static
name|struct
name|cdev
modifier|*
name|devfs_rule_getdev
parameter_list|(
name|struct
name|devfs_dirent
modifier|*
name|de
parameter_list|)
block|{
if|if
condition|(
name|de
operator|->
name|de_cdp
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|de
operator|->
name|de_cdp
operator|->
name|cdp_flags
operator|&
name|CDP_ACTIVE
condition|)
return|return
operator|(
operator|&
name|de
operator|->
name|de_cdp
operator|->
name|cdp_c
operator|)
return|;
else|else
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Do what we need to do to a rule that we just loaded from the  * userland.  In particular, we need to check the magic, and adjust  * the ruleset appropriate if desired.  */
end_comment

begin_function
specifier|static
name|int
name|devfs_rule_input
parameter_list|(
name|struct
name|devfs_rule
modifier|*
name|dr
parameter_list|,
name|struct
name|devfs_mount
modifier|*
name|dm
parameter_list|)
block|{
if|if
condition|(
name|dr
operator|->
name|dr_magic
operator|!=
name|DEVFS_MAGIC
condition|)
return|return
operator|(
name|ERPCMISMATCH
operator|)
return|;
name|dr
operator|->
name|dr_id
operator|=
name|devfs_rid_input
argument_list|(
name|dr
operator|->
name|dr_id
argument_list|,
name|dm
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Import dr into the appropriate place in the kernel (i.e., make a  * krule).  The value of dr is copied, so the pointer may be destroyed  * after this call completes.  */
end_comment

begin_function
specifier|static
name|int
name|devfs_rule_insert
parameter_list|(
name|struct
name|devfs_rule
modifier|*
name|dr
parameter_list|)
block|{
name|struct
name|devfs_ruleset
modifier|*
name|ds
decl_stmt|,
modifier|*
name|dsi
decl_stmt|;
name|struct
name|devfs_krule
modifier|*
name|k1
decl_stmt|;
name|struct
name|devfs_krule
modifier|*
name|dk
decl_stmt|;
name|devfs_rsnum
name|rsnum
decl_stmt|;
name|devfs_rnum
name|dkrn
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * This stuff seems out of place here, but we want to do it as 	 * soon as possible so that if it fails, we don't have to roll 	 * back any changes we already made (e.g., ruleset creation). 	 */
if|if
condition|(
name|dr
operator|->
name|dr_iacts
operator|&
name|DRA_INCSET
condition|)
block|{
name|dsi
operator|=
name|devfs_ruleset_bynum
argument_list|(
name|dr
operator|->
name|dr_incset
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsi
operator|==
name|NULL
condition|)
return|return
operator|(
name|ESRCH
operator|)
return|;
block|}
else|else
name|dsi
operator|=
name|NULL
expr_stmt|;
name|rsnum
operator|=
name|rid2rsn
argument_list|(
name|dr
operator|->
name|dr_id
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|rsnum
operator|!=
literal|0
argument_list|,
operator|(
literal|"Inserting into ruleset zero"
operator|)
argument_list|)
expr_stmt|;
name|ds
operator|=
name|devfs_ruleset_bynum
argument_list|(
name|rsnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|==
name|NULL
condition|)
name|ds
operator|=
name|devfs_ruleset_create
argument_list|(
name|rsnum
argument_list|)
expr_stmt|;
name|dkrn
operator|=
name|rid2rn
argument_list|(
name|dr
operator|->
name|dr_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|dkrn
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|devfs_rule_autonumber
argument_list|(
name|ds
argument_list|,
operator|&
name|dkrn
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|devfs_ruleset_reap
argument_list|(
name|ds
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
name|dk
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|dk
argument_list|)
argument_list|,
name|M_DEVFSRULE
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|dk
operator|->
name|dk_ruleset
operator|=
name|ds
expr_stmt|;
if|if
condition|(
name|dsi
operator|!=
name|NULL
condition|)
operator|++
name|dsi
operator|->
name|ds_refcount
expr_stmt|;
comment|/* XXX: Inspect dr? */
name|memcpy
argument_list|(
operator|&
name|dk
operator|->
name|dk_rule
argument_list|,
name|dr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dr
argument_list|)
argument_list|)
expr_stmt|;
name|dk
operator|->
name|dk_rule
operator|.
name|dr_id
operator|=
name|mkrid
argument_list|(
name|rid2rsn
argument_list|(
name|dk
operator|->
name|dk_rule
operator|.
name|dr_id
argument_list|)
argument_list|,
name|dkrn
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|k1
argument_list|,
argument|&ds->ds_rules
argument_list|,
argument|dk_list
argument_list|)
block|{
if|if
condition|(
name|rid2rn
argument_list|(
name|k1
operator|->
name|dk_rule
operator|.
name|dr_id
argument_list|)
operator|>
name|dkrn
condition|)
block|{
name|TAILQ_INSERT_BEFORE
argument_list|(
name|k1
argument_list|,
name|dk
argument_list|,
name|dk_list
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|k1
operator|==
name|NULL
condition|)
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ds
operator|->
name|ds_rules
argument_list|,
name|dk
argument_list|,
name|dk_list
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Determine whether dk matches de.  Returns 1 if dk should be run on  * de; 0, otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|devfs_rule_match
parameter_list|(
name|struct
name|devfs_krule
modifier|*
name|dk
parameter_list|,
name|struct
name|devfs_dirent
modifier|*
name|de
parameter_list|)
block|{
name|struct
name|devfs_rule
modifier|*
name|dr
init|=
operator|&
name|dk
operator|->
name|dk_rule
decl_stmt|;
name|struct
name|cdev
modifier|*
name|dev
decl_stmt|;
name|dev
operator|=
name|devfs_rule_getdev
argument_list|(
name|de
argument_list|)
expr_stmt|;
comment|/* 	 * At this point, if dev is NULL, we should assume that any 	 * criteria that depend on it don't match.  We should *not* 	 * just ignore them (i.e., act like they weren't specified), 	 * since that makes a rule that only has criteria dependent on 	 * the struct cdev *match all symlinks and directories. 	 * 	 * Note also that the following tests are somewhat reversed: 	 * They're actually testing to see whether the condition does 	 * *not* match, since the default is to assume the rule should 	 * be run (such as if there are no conditions). 	 * 	 * XXX: lacks threadref on dev 	 */
if|if
condition|(
name|dr
operator|->
name|dr_icond
operator|&
name|DRC_DSWFLAGS
condition|)
if|if
condition|(
name|dev
operator|==
name|NULL
operator|||
operator|(
name|dev
operator|->
name|si_devsw
operator|->
name|d_flags
operator|&
name|dr
operator|->
name|dr_dswflags
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|dr
operator|->
name|dr_icond
operator|&
name|DRC_PATHPTRN
condition|)
if|if
condition|(
operator|!
name|devfs_rule_matchpath
argument_list|(
name|dk
argument_list|,
name|de
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Determine whether dk matches de on account of dr_pathptrn.  */
end_comment

begin_function
specifier|static
name|int
name|devfs_rule_matchpath
parameter_list|(
name|struct
name|devfs_krule
modifier|*
name|dk
parameter_list|,
name|struct
name|devfs_dirent
modifier|*
name|de
parameter_list|)
block|{
name|struct
name|devfs_rule
modifier|*
name|dr
init|=
operator|&
name|dk
operator|->
name|dk_rule
decl_stmt|;
name|char
modifier|*
name|pname
decl_stmt|;
name|struct
name|cdev
modifier|*
name|dev
decl_stmt|;
name|dev
operator|=
name|devfs_rule_getdev
argument_list|(
name|de
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|!=
name|NULL
condition|)
name|pname
operator|=
name|dev
operator|->
name|si_name
expr_stmt|;
elseif|else
if|if
condition|(
name|de
operator|->
name|de_dirent
operator|->
name|d_type
operator|==
name|DT_LNK
operator|||
name|de
operator|->
name|de_dirent
operator|->
name|d_type
operator|==
name|DT_DIR
condition|)
name|pname
operator|=
name|de
operator|->
name|de_dirent
operator|->
name|d_name
expr_stmt|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
name|KASSERT
argument_list|(
name|pname
operator|!=
name|NULL
argument_list|,
operator|(
literal|"devfs_rule_matchpath: NULL pname"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|fnmatch
argument_list|(
name|dr
operator|->
name|dr_pathptrn
argument_list|,
name|pname
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Run dk on de.  */
end_comment

begin_function
specifier|static
name|void
name|devfs_rule_run
parameter_list|(
name|struct
name|devfs_krule
modifier|*
name|dk
parameter_list|,
name|struct
name|devfs_dirent
modifier|*
name|de
parameter_list|,
name|unsigned
name|depth
parameter_list|)
block|{
name|struct
name|devfs_rule
modifier|*
name|dr
init|=
operator|&
name|dk
operator|->
name|dk_rule
decl_stmt|;
name|struct
name|devfs_ruleset
modifier|*
name|ds
decl_stmt|;
if|if
condition|(
operator|!
name|devfs_rule_match
argument_list|(
name|dk
argument_list|,
name|de
argument_list|)
condition|)
return|return;
if|if
condition|(
name|dr
operator|->
name|dr_iacts
operator|&
name|DRA_BACTS
condition|)
block|{
if|if
condition|(
name|dr
operator|->
name|dr_bacts
operator|&
name|DRB_HIDE
condition|)
name|de
operator|->
name|de_flags
operator||=
name|DE_WHITEOUT
expr_stmt|;
if|if
condition|(
name|dr
operator|->
name|dr_bacts
operator|&
name|DRB_UNHIDE
condition|)
name|de
operator|->
name|de_flags
operator|&=
operator|~
name|DE_WHITEOUT
expr_stmt|;
block|}
if|if
condition|(
name|dr
operator|->
name|dr_iacts
operator|&
name|DRA_UID
condition|)
name|de
operator|->
name|de_uid
operator|=
name|dr
operator|->
name|dr_uid
expr_stmt|;
if|if
condition|(
name|dr
operator|->
name|dr_iacts
operator|&
name|DRA_GID
condition|)
name|de
operator|->
name|de_gid
operator|=
name|dr
operator|->
name|dr_gid
expr_stmt|;
if|if
condition|(
name|dr
operator|->
name|dr_iacts
operator|&
name|DRA_MODE
condition|)
name|de
operator|->
name|de_mode
operator|=
name|dr
operator|->
name|dr_mode
expr_stmt|;
if|if
condition|(
name|dr
operator|->
name|dr_iacts
operator|&
name|DRA_INCSET
condition|)
block|{
comment|/* 		 * XXX: we should tell the user if the depth is exceeded here 		 * XXX: but it is not obvious how to.  A return value will 		 * XXX: not work as this is called when devices are created 		 * XXX: long time after the rules were instantiated. 		 * XXX: a printf() would probably give too much noise, or 		 * XXX: DoS the machine.  I guess a a rate-limited message 		 * XXX: might work. 		 */
if|if
condition|(
name|depth
operator|>
literal|0
condition|)
block|{
name|ds
operator|=
name|devfs_ruleset_bynum
argument_list|(
name|dk
operator|->
name|dk_rule
operator|.
name|dr_incset
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ds
operator|!=
name|NULL
argument_list|,
operator|(
literal|"DRA_INCSET but bad dr_incset"
operator|)
argument_list|)
expr_stmt|;
name|devfs_ruleset_applyde
argument_list|(
name|ds
argument_list|,
name|de
argument_list|,
name|depth
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Apply all the rules in ds to de.  */
end_comment

begin_function
specifier|static
name|void
name|devfs_ruleset_applyde
parameter_list|(
name|struct
name|devfs_ruleset
modifier|*
name|ds
parameter_list|,
name|struct
name|devfs_dirent
modifier|*
name|de
parameter_list|,
name|unsigned
name|depth
parameter_list|)
block|{
name|struct
name|devfs_krule
modifier|*
name|dk
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|dk
argument_list|,
argument|&ds->ds_rules
argument_list|,
argument|dk_list
argument_list|)
name|devfs_rule_run
argument_list|(
name|dk
argument_list|,
name|de
argument_list|,
name|depth
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Apply all the rules in ds to all the entires in dm.  */
end_comment

begin_function
specifier|static
name|void
name|devfs_ruleset_applydm
parameter_list|(
name|struct
name|devfs_ruleset
modifier|*
name|ds
parameter_list|,
name|struct
name|devfs_mount
modifier|*
name|dm
parameter_list|)
block|{
name|struct
name|devfs_krule
modifier|*
name|dk
decl_stmt|;
comment|/* 	 * XXX: Does it matter whether we do 	 * 	 *	foreach(dk in ds) 	 *		foreach(de in dm) 	 *			apply(dk to de) 	 * 	 * as opposed to 	 * 	 *	foreach(de in dm) 	 *		foreach(dk in ds) 	 *			apply(dk to de) 	 * 	 * The end result is obviously the same, but does the order 	 * matter? 	 */
name|TAILQ_FOREACH
argument_list|(
argument|dk
argument_list|,
argument|&ds->ds_rules
argument_list|,
argument|dk_list
argument_list|)
name|devfs_rule_applydm
argument_list|(
name|dk
argument_list|,
name|dm
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Find a ruleset by number.  */
end_comment

begin_function
specifier|static
name|struct
name|devfs_ruleset
modifier|*
name|devfs_ruleset_bynum
parameter_list|(
name|devfs_rsnum
name|rsnum
parameter_list|)
block|{
name|struct
name|devfs_ruleset
modifier|*
name|ds
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ds
argument_list|,
argument|&devfs_rulesets
argument_list|,
argument|ds_list
argument_list|)
block|{
if|if
condition|(
name|ds
operator|->
name|ds_number
operator|==
name|rsnum
condition|)
return|return
operator|(
name|ds
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create a new ruleset.  */
end_comment

begin_function
specifier|static
name|struct
name|devfs_ruleset
modifier|*
name|devfs_ruleset_create
parameter_list|(
name|devfs_rsnum
name|rsnum
parameter_list|)
block|{
name|struct
name|devfs_ruleset
modifier|*
name|s1
decl_stmt|;
name|struct
name|devfs_ruleset
modifier|*
name|ds
decl_stmt|;
name|KASSERT
argument_list|(
name|rsnum
operator|!=
literal|0
argument_list|,
operator|(
literal|"creating ruleset zero"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|devfs_ruleset_bynum
argument_list|(
name|rsnum
argument_list|)
operator|==
name|NULL
argument_list|,
operator|(
literal|"creating already existent ruleset %d"
operator|,
name|rsnum
operator|)
argument_list|)
expr_stmt|;
name|ds
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ds
argument_list|)
argument_list|,
name|M_DEVFSRULE
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_number
operator|=
name|rsnum
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|ds
operator|->
name|ds_rules
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|s1
argument_list|,
argument|&devfs_rulesets
argument_list|,
argument|ds_list
argument_list|)
block|{
if|if
condition|(
name|s1
operator|->
name|ds_number
operator|>
name|rsnum
condition|)
block|{
name|TAILQ_INSERT_BEFORE
argument_list|(
name|s1
argument_list|,
name|ds
argument_list|,
name|ds_list
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|s1
operator|==
name|NULL
condition|)
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|devfs_rulesets
argument_list|,
name|ds
argument_list|,
name|ds_list
argument_list|)
expr_stmt|;
return|return
operator|(
name|ds
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove a ruleset from the system if it's empty and not used  * anywhere.  This should be called after every time a rule is deleted  * from this ruleset or the reference count is decremented.  */
end_comment

begin_function
specifier|static
name|void
name|devfs_ruleset_reap
parameter_list|(
name|struct
name|devfs_ruleset
modifier|*
name|ds
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|ds
operator|->
name|ds_number
operator|!=
literal|0
argument_list|,
operator|(
literal|"reaping ruleset zero "
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|ds
operator|->
name|ds_rules
argument_list|)
operator|||
name|ds
operator|->
name|ds_refcount
operator|!=
literal|0
condition|)
return|return;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|devfs_rulesets
argument_list|,
name|ds
argument_list|,
name|ds_list
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ds
argument_list|,
name|M_DEVFSRULE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Make rsnum the active ruleset for dm.  */
end_comment

begin_function
specifier|static
name|int
name|devfs_ruleset_use
parameter_list|(
name|devfs_rsnum
name|rsnum
parameter_list|,
name|struct
name|devfs_mount
modifier|*
name|dm
parameter_list|)
block|{
name|struct
name|devfs_ruleset
modifier|*
name|cds
decl_stmt|,
modifier|*
name|ds
decl_stmt|;
name|ds
operator|=
name|devfs_ruleset_bynum
argument_list|(
name|rsnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|==
name|NULL
condition|)
name|ds
operator|=
name|devfs_ruleset_create
argument_list|(
name|rsnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|dm
operator|->
name|dm_ruleset
operator|!=
literal|0
condition|)
block|{
name|cds
operator|=
name|devfs_ruleset_bynum
argument_list|(
name|dm
operator|->
name|dm_ruleset
argument_list|)
expr_stmt|;
operator|--
name|cds
operator|->
name|ds_refcount
expr_stmt|;
name|devfs_ruleset_reap
argument_list|(
name|cds
argument_list|)
expr_stmt|;
block|}
comment|/* These should probably be made atomic somehow. */
operator|++
name|ds
operator|->
name|ds_refcount
expr_stmt|;
name|dm
operator|->
name|dm_ruleset
operator|=
name|rsnum
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|devfs_rules_cleanup
parameter_list|(
name|struct
name|devfs_mount
modifier|*
name|dm
parameter_list|)
block|{
name|struct
name|devfs_ruleset
modifier|*
name|ds
decl_stmt|;
name|sx_assert
argument_list|(
operator|&
name|dm
operator|->
name|dm_lock
argument_list|,
name|SX_XLOCKED
argument_list|)
expr_stmt|;
if|if
condition|(
name|dm
operator|->
name|dm_ruleset
operator|!=
literal|0
condition|)
block|{
name|ds
operator|=
name|devfs_ruleset_bynum
argument_list|(
name|dm
operator|->
name|dm_ruleset
argument_list|)
expr_stmt|;
operator|--
name|ds
operator|->
name|ds_refcount
expr_stmt|;
name|devfs_ruleset_reap
argument_list|(
name|ds
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

