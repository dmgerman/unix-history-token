begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1989, 1991, 1993, 1995  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Rick Macklem at The University of Guelph.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Socket operations for use by nfs  */
end_comment

begin_include
include|#
directive|include
file|"opt_kgssapi.h"
end_include

begin_include
include|#
directive|include
file|"opt_nfs.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/syscallsubr.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<rpc/rpc.h>
end_include

begin_include
include|#
directive|include
file|<rpc/krpc.h>
end_include

begin_include
include|#
directive|include
file|<kgssapi/krb5/kcrypto.h>
end_include

begin_include
include|#
directive|include
file|<fs/nfs/nfsport.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|KDTRACE_HOOKS
end_ifdef

begin_include
include|#
directive|include
file|<sys/dtrace_bsd.h>
end_include

begin_decl_stmt
name|dtrace_nfsclient_nfs23_start_probe_func_t
name|dtrace_nfscl_nfs234_start_probe
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|dtrace_nfsclient_nfs23_done_probe_func_t
name|dtrace_nfscl_nfs234_done_probe
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Registered probes by RPC type.  */
end_comment

begin_decl_stmt
name|uint32_t
name|nfscl_nfs2_start_probes
index|[
name|NFSV41_NPROCS
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint32_t
name|nfscl_nfs2_done_probes
index|[
name|NFSV41_NPROCS
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint32_t
name|nfscl_nfs3_start_probes
index|[
name|NFSV41_NPROCS
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint32_t
name|nfscl_nfs3_done_probes
index|[
name|NFSV41_NPROCS
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint32_t
name|nfscl_nfs4_start_probes
index|[
name|NFSV41_NPROCS
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint32_t
name|nfscl_nfs4_done_probes
index|[
name|NFSV41_NPROCS
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|NFSSTATESPINLOCK
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|NFSREQSPINLOCK
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|NFSDLOCKMUTEX
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|NFSCLSTATEMUTEX
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|extern
name|struct
name|nfsstatsv1
name|nfsstatsv1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|nfsreqhead
name|nfsd_reqq
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|nfscl_ticks
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|void
function_decl|(
modifier|*
name|ncl_call_invalcaches
function_decl|)
parameter_list|(
name|struct
name|vnode
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|int
name|nfs_numnfscbd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|nfscl_debuglevel
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|SVCPOOL
modifier|*
name|nfscbd_pool
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfsrv_gsscallbackson
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfs_bufpackets
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfs_reconnects
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfs3_jukebox_delay
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfs_skip_wcc_data_onerr
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_vfs_nfs
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_nfs
argument_list|,
name|OID_AUTO
argument_list|,
name|bufpackets
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|nfs_bufpackets
argument_list|,
literal|0
argument_list|,
literal|"Buffer reservation size 2< x< 64"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_nfs
argument_list|,
name|OID_AUTO
argument_list|,
name|reconnects
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|nfs_reconnects
argument_list|,
literal|0
argument_list|,
literal|"Number of times the nfs client has had to reconnect"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_nfs
argument_list|,
name|OID_AUTO
argument_list|,
name|nfs3_jukebox_delay
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|nfs3_jukebox_delay
argument_list|,
literal|0
argument_list|,
literal|"Number of seconds to delay a retry after receiving EJUKEBOX"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_nfs
argument_list|,
name|OID_AUTO
argument_list|,
name|skip_wcc_data_onerr
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|nfs_skip_wcc_data_onerr
argument_list|,
literal|0
argument_list|,
literal|"Disable weak cache consistency checking when server returns an error"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|void
name|nfs_down
parameter_list|(
name|struct
name|nfsmount
modifier|*
parameter_list|,
name|struct
name|thread
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nfs_up
parameter_list|(
name|struct
name|nfsmount
modifier|*
parameter_list|,
name|struct
name|thread
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nfs_msg
parameter_list|(
name|struct
name|thread
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_struct
struct|struct
name|nfs_cached_auth
block|{
name|int
name|ca_refs
decl_stmt|;
comment|/* refcount, including 1 from the cache */
name|uid_t
name|ca_uid
decl_stmt|;
comment|/* uid that corresponds to this auth */
name|AUTH
modifier|*
name|ca_auth
decl_stmt|;
comment|/* RPC auth handle */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|nfsv2_procid
index|[
name|NFS_V3NPROCS
index|]
init|=
block|{
name|NFSV2PROC_NULL
block|,
name|NFSV2PROC_GETATTR
block|,
name|NFSV2PROC_SETATTR
block|,
name|NFSV2PROC_LOOKUP
block|,
name|NFSV2PROC_NOOP
block|,
name|NFSV2PROC_READLINK
block|,
name|NFSV2PROC_READ
block|,
name|NFSV2PROC_WRITE
block|,
name|NFSV2PROC_CREATE
block|,
name|NFSV2PROC_MKDIR
block|,
name|NFSV2PROC_SYMLINK
block|,
name|NFSV2PROC_CREATE
block|,
name|NFSV2PROC_REMOVE
block|,
name|NFSV2PROC_RMDIR
block|,
name|NFSV2PROC_RENAME
block|,
name|NFSV2PROC_LINK
block|,
name|NFSV2PROC_READDIR
block|,
name|NFSV2PROC_NOOP
block|,
name|NFSV2PROC_STATFS
block|,
name|NFSV2PROC_NOOP
block|,
name|NFSV2PROC_NOOP
block|,
name|NFSV2PROC_NOOP
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Initialize sockets and congestion for a new NFS connection.  * We do not free the sockaddr if error.  */
end_comment

begin_function
name|int
name|newnfs_connect
parameter_list|(
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|,
name|struct
name|nfssockreq
modifier|*
name|nrp
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|int
name|callback_retry_mult
parameter_list|)
block|{
name|int
name|rcvreserve
decl_stmt|,
name|sndreserve
decl_stmt|;
name|int
name|pktscale
decl_stmt|,
name|pktscalesav
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|saddr
decl_stmt|;
name|struct
name|ucred
modifier|*
name|origcred
decl_stmt|;
name|CLIENT
modifier|*
name|client
decl_stmt|;
name|struct
name|netconfig
modifier|*
name|nconf
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|int
name|one
init|=
literal|1
decl_stmt|,
name|retries
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|SVCXPRT
modifier|*
name|xprt
decl_stmt|;
name|struct
name|timeval
name|timo
decl_stmt|;
comment|/* 	 * We need to establish the socket using the credentials of 	 * the mountpoint.  Some parts of this process (such as 	 * sobind() and soconnect()) will use the curent thread's 	 * credential instead of the socket credential.  To work 	 * around this, temporarily change the current thread's 	 * credential to that of the mountpoint. 	 * 	 * XXX: It would be better to explicitly pass the correct 	 * credential to sobind() and soconnect(). 	 */
name|origcred
operator|=
name|td
operator|->
name|td_ucred
expr_stmt|;
comment|/* 	 * Use the credential in nr_cred, if not NULL. 	 */
if|if
condition|(
name|nrp
operator|->
name|nr_cred
operator|!=
name|NULL
condition|)
name|td
operator|->
name|td_ucred
operator|=
name|nrp
operator|->
name|nr_cred
expr_stmt|;
else|else
name|td
operator|->
name|td_ucred
operator|=
name|cred
expr_stmt|;
name|saddr
operator|=
name|nrp
operator|->
name|nr_nam
expr_stmt|;
if|if
condition|(
name|saddr
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
if|if
condition|(
name|nrp
operator|->
name|nr_sotype
operator|==
name|SOCK_DGRAM
condition|)
name|nconf
operator|=
name|getnetconfigent
argument_list|(
literal|"udp"
argument_list|)
expr_stmt|;
else|else
name|nconf
operator|=
name|getnetconfigent
argument_list|(
literal|"tcp"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|nrp
operator|->
name|nr_sotype
operator|==
name|SOCK_DGRAM
condition|)
name|nconf
operator|=
name|getnetconfigent
argument_list|(
literal|"udp6"
argument_list|)
expr_stmt|;
else|else
name|nconf
operator|=
name|getnetconfigent
argument_list|(
literal|"tcp6"
argument_list|)
expr_stmt|;
name|pktscale
operator|=
name|nfs_bufpackets
expr_stmt|;
if|if
condition|(
name|pktscale
operator|<
literal|2
condition|)
name|pktscale
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|pktscale
operator|>
literal|64
condition|)
name|pktscale
operator|=
literal|64
expr_stmt|;
name|pktscalesav
operator|=
name|pktscale
expr_stmt|;
comment|/* 	 * soreserve() can fail if sb_max is too small, so shrink pktscale 	 * and try again if there is an error. 	 * Print a log message suggesting increasing sb_max. 	 * Creating a socket and doing this is necessary since, if the 	 * reservation sizes are too large and will make soreserve() fail, 	 * the connection will work until a large send is attempted and 	 * then it will loop in the krpc code. 	 */
name|so
operator|=
name|NULL
expr_stmt|;
name|saddr
operator|=
name|NFSSOCKADDR
argument_list|(
name|nrp
operator|->
name|nr_nam
argument_list|,
expr|struct
name|sockaddr
operator|*
argument_list|)
expr_stmt|;
name|error
operator|=
name|socreate
argument_list|(
name|saddr
operator|->
name|sa_family
argument_list|,
operator|&
name|so
argument_list|,
name|nrp
operator|->
name|nr_sotype
argument_list|,
name|nrp
operator|->
name|nr_soproto
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|td
operator|->
name|td_ucred
operator|=
name|origcred
expr_stmt|;
goto|goto
name|out
goto|;
block|}
do|do
block|{
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|pktscale
operator|>
literal|2
condition|)
block|{
if|if
condition|(
name|nmp
operator|!=
name|NULL
operator|&&
name|nrp
operator|->
name|nr_sotype
operator|==
name|SOCK_STREAM
operator|&&
name|pktscale
operator|==
name|pktscalesav
condition|)
name|printf
argument_list|(
literal|"Consider increasing kern.ipc.maxsockbuf\n"
argument_list|)
expr_stmt|;
name|pktscale
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|nrp
operator|->
name|nr_sotype
operator|==
name|SOCK_DGRAM
condition|)
block|{
if|if
condition|(
name|nmp
operator|!=
name|NULL
condition|)
block|{
name|sndreserve
operator|=
operator|(
name|NFS_MAXDGRAMDATA
operator|+
name|NFS_MAXPKTHDR
operator|)
operator|*
name|pktscale
expr_stmt|;
name|rcvreserve
operator|=
operator|(
name|NFS_MAXDGRAMDATA
operator|+
name|NFS_MAXPKTHDR
operator|)
operator|*
name|pktscale
expr_stmt|;
block|}
else|else
block|{
name|sndreserve
operator|=
name|rcvreserve
operator|=
literal|1024
operator|*
name|pktscale
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|nrp
operator|->
name|nr_sotype
operator|!=
name|SOCK_STREAM
condition|)
name|panic
argument_list|(
literal|"nfscon sotype"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmp
operator|!=
name|NULL
condition|)
block|{
name|sndreserve
operator|=
operator|(
name|NFS_MAXBSIZE
operator|+
name|NFS_MAXXDR
operator|+
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
operator|)
operator|*
name|pktscale
expr_stmt|;
name|rcvreserve
operator|=
operator|(
name|NFS_MAXBSIZE
operator|+
name|NFS_MAXXDR
operator|+
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
operator|)
operator|*
name|pktscale
expr_stmt|;
block|}
else|else
block|{
name|sndreserve
operator|=
name|rcvreserve
operator|=
literal|1024
operator|*
name|pktscale
expr_stmt|;
block|}
block|}
name|error
operator|=
name|soreserve
argument_list|(
name|so
argument_list|,
name|sndreserve
argument_list|,
name|rcvreserve
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|nmp
operator|!=
name|NULL
operator|&&
name|nrp
operator|->
name|nr_sotype
operator|==
name|SOCK_STREAM
operator|&&
name|pktscale
operator|<=
literal|2
condition|)
name|printf
argument_list|(
literal|"Must increase kern.ipc.maxsockbuf or reduce"
literal|" rsize, wsize\n"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|error
operator|!=
literal|0
operator|&&
name|pktscale
operator|>
literal|2
condition|)
do|;
name|soclose
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|td
operator|->
name|td_ucred
operator|=
name|origcred
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|client
operator|=
name|clnt_reconnect_create
argument_list|(
name|nconf
argument_list|,
name|saddr
argument_list|,
name|nrp
operator|->
name|nr_prog
argument_list|,
name|nrp
operator|->
name|nr_vers
argument_list|,
name|sndreserve
argument_list|,
name|rcvreserve
argument_list|)
expr_stmt|;
name|CLNT_CONTROL
argument_list|(
name|client
argument_list|,
name|CLSET_WAITCHAN
argument_list|,
literal|"nfsreq"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_INT
operator|)
condition|)
name|CLNT_CONTROL
argument_list|(
name|client
argument_list|,
name|CLSET_INTERRUPTIBLE
argument_list|,
operator|&
name|one
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_RESVPORT
operator|)
condition|)
name|CLNT_CONTROL
argument_list|(
name|client
argument_list|,
name|CLSET_PRIVPORT
argument_list|,
operator|&
name|one
argument_list|)
expr_stmt|;
if|if
condition|(
name|NFSHASSOFT
argument_list|(
name|nmp
argument_list|)
condition|)
block|{
if|if
condition|(
name|nmp
operator|->
name|nm_sotype
operator|==
name|SOCK_DGRAM
condition|)
comment|/* 				 * For UDP, the large timeout for a reconnect 				 * will be set to "nm_retry * nm_timeo / 2", so 				 * we only want to do 2 reconnect timeout 				 * retries. 				 */
name|retries
operator|=
literal|2
expr_stmt|;
else|else
name|retries
operator|=
name|nmp
operator|->
name|nm_retry
expr_stmt|;
block|}
else|else
name|retries
operator|=
name|INT_MAX
expr_stmt|;
comment|/* cred == NULL for DS connects. */
if|if
condition|(
name|NFSHASNFSV4N
argument_list|(
name|nmp
argument_list|)
operator|&&
name|cred
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * Make sure the nfscbd_pool doesn't get destroyed 			 * while doing this. 			 */
name|NFSD_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|nfs_numnfscbd
operator|>
literal|0
condition|)
block|{
name|nfs_numnfscbd
operator|++
expr_stmt|;
name|NFSD_UNLOCK
argument_list|()
expr_stmt|;
name|xprt
operator|=
name|svc_vc_create_backchannel
argument_list|(
name|nfscbd_pool
argument_list|)
expr_stmt|;
name|CLNT_CONTROL
argument_list|(
name|client
argument_list|,
name|CLSET_BACKCHANNEL
argument_list|,
name|xprt
argument_list|)
expr_stmt|;
name|NFSD_LOCK
argument_list|()
expr_stmt|;
name|nfs_numnfscbd
operator|--
expr_stmt|;
if|if
condition|(
name|nfs_numnfscbd
operator|==
literal|0
condition|)
name|wakeup
argument_list|(
operator|&
name|nfs_numnfscbd
argument_list|)
expr_stmt|;
block|}
name|NFSD_UNLOCK
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * Three cases: 		 * - Null RPC callback to client 		 * - Non-Null RPC callback to client, wait a little longer 		 * - upcalls to nfsuserd and gssd (clp == NULL) 		 */
if|if
condition|(
name|callback_retry_mult
operator|==
literal|0
condition|)
block|{
name|retries
operator|=
name|NFSV4_UPCALLRETRY
expr_stmt|;
name|CLNT_CONTROL
argument_list|(
name|client
argument_list|,
name|CLSET_PRIVPORT
argument_list|,
operator|&
name|one
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|retries
operator|=
name|NFSV4_CALLBACKRETRY
operator|*
name|callback_retry_mult
expr_stmt|;
block|}
block|}
name|CLNT_CONTROL
argument_list|(
name|client
argument_list|,
name|CLSET_RETRIES
argument_list|,
operator|&
name|retries
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmp
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * For UDP, there are 2 timeouts: 		 * - CLSET_RETRY_TIMEOUT sets the initial timeout for the timer 		 *   that does a retransmit of an RPC request using the same  		 *   socket and xid. This is what you normally want to do, 		 *   since NFS servers depend on "same xid" for their 		 *   Duplicate Request Cache. 		 * - timeout specified in CLNT_CALL_MBUF(), which specifies when 		 *   retransmits on the same socket should fail and a fresh 		 *   socket created. Each of these timeouts counts as one 		 *   CLSET_RETRIES as set above. 		 * Set the initial retransmit timeout for UDP. This timeout 		 * doesn't exist for TCP and the following call just fails, 		 * which is ok. 		 */
name|timo
operator|.
name|tv_sec
operator|=
name|nmp
operator|->
name|nm_timeo
operator|/
name|NFS_HZ
expr_stmt|;
name|timo
operator|.
name|tv_usec
operator|=
operator|(
name|nmp
operator|->
name|nm_timeo
operator|%
name|NFS_HZ
operator|)
operator|*
literal|1000000
operator|/
name|NFS_HZ
expr_stmt|;
name|CLNT_CONTROL
argument_list|(
name|client
argument_list|,
name|CLSET_RETRY_TIMEOUT
argument_list|,
operator|&
name|timo
argument_list|)
expr_stmt|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|nrp
operator|->
name|nr_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|nrp
operator|->
name|nr_client
operator|!=
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|nrp
operator|->
name|nr_mtx
argument_list|)
expr_stmt|;
comment|/* 		 * Someone else already connected. 		 */
name|CLNT_RELEASE
argument_list|(
name|client
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nrp
operator|->
name|nr_client
operator|=
name|client
expr_stmt|;
comment|/* 		 * Protocols that do not require connections may be optionally 		 * left unconnected for servers that reply from a port other 		 * than NFS_PORT. 		 */
if|if
condition|(
name|nmp
operator|==
name|NULL
operator|||
operator|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_NOCONN
operator|)
operator|==
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|nrp
operator|->
name|nr_mtx
argument_list|)
expr_stmt|;
name|CLNT_CONTROL
argument_list|(
name|client
argument_list|,
name|CLSET_CONNECT
argument_list|,
operator|&
name|one
argument_list|)
expr_stmt|;
block|}
else|else
name|mtx_unlock
argument_list|(
operator|&
name|nrp
operator|->
name|nr_mtx
argument_list|)
expr_stmt|;
block|}
comment|/* Restore current thread's credentials. */
name|td
operator|->
name|td_ucred
operator|=
name|origcred
expr_stmt|;
name|out
label|:
name|NFSEXITCODE
argument_list|(
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * NFS disconnect. Clean up and unlink.  */
end_comment

begin_function
name|void
name|newnfs_disconnect
parameter_list|(
name|struct
name|nfssockreq
modifier|*
name|nrp
parameter_list|)
block|{
name|CLIENT
modifier|*
name|client
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|nrp
operator|->
name|nr_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|nrp
operator|->
name|nr_client
operator|!=
name|NULL
condition|)
block|{
name|client
operator|=
name|nrp
operator|->
name|nr_client
expr_stmt|;
name|nrp
operator|->
name|nr_client
operator|=
name|NULL
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|nrp
operator|->
name|nr_mtx
argument_list|)
expr_stmt|;
name|rpc_gss_secpurge_call
argument_list|(
name|client
argument_list|)
expr_stmt|;
name|CLNT_CLOSE
argument_list|(
name|client
argument_list|)
expr_stmt|;
name|CLNT_RELEASE
argument_list|(
name|client
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mtx_unlock
argument_list|(
operator|&
name|nrp
operator|->
name|nr_mtx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|AUTH
modifier|*
name|nfs_getauth
parameter_list|(
name|struct
name|nfssockreq
modifier|*
name|nrp
parameter_list|,
name|int
name|secflavour
parameter_list|,
name|char
modifier|*
name|clnt_principal
parameter_list|,
name|char
modifier|*
name|srv_principal
parameter_list|,
name|gss_OID
name|mech_oid
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|)
block|{
name|rpc_gss_service_t
name|svc
decl_stmt|;
name|AUTH
modifier|*
name|auth
decl_stmt|;
switch|switch
condition|(
name|secflavour
condition|)
block|{
case|case
name|RPCSEC_GSS_KRB5
case|:
case|case
name|RPCSEC_GSS_KRB5I
case|:
case|case
name|RPCSEC_GSS_KRB5P
case|:
if|if
condition|(
operator|!
name|mech_oid
condition|)
block|{
if|if
condition|(
operator|!
name|rpc_gss_mech_to_oid_call
argument_list|(
literal|"kerberosv5"
argument_list|,
operator|&
name|mech_oid
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|secflavour
operator|==
name|RPCSEC_GSS_KRB5
condition|)
name|svc
operator|=
name|rpc_gss_svc_none
expr_stmt|;
elseif|else
if|if
condition|(
name|secflavour
operator|==
name|RPCSEC_GSS_KRB5I
condition|)
name|svc
operator|=
name|rpc_gss_svc_integrity
expr_stmt|;
else|else
name|svc
operator|=
name|rpc_gss_svc_privacy
expr_stmt|;
if|if
condition|(
name|clnt_principal
operator|==
name|NULL
condition|)
name|auth
operator|=
name|rpc_gss_secfind_call
argument_list|(
name|nrp
operator|->
name|nr_client
argument_list|,
name|cred
argument_list|,
name|srv_principal
argument_list|,
name|mech_oid
argument_list|,
name|svc
argument_list|)
expr_stmt|;
else|else
block|{
name|auth
operator|=
name|rpc_gss_seccreate_call
argument_list|(
name|nrp
operator|->
name|nr_client
argument_list|,
name|cred
argument_list|,
name|clnt_principal
argument_list|,
name|srv_principal
argument_list|,
literal|"kerberosv5"
argument_list|,
name|svc
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|auth
operator|)
return|;
block|}
if|if
condition|(
name|auth
operator|!=
name|NULL
condition|)
return|return
operator|(
name|auth
operator|)
return|;
comment|/* fallthrough */
case|case
name|AUTH_SYS
case|:
default|default:
return|return
operator|(
name|authunix_create
argument_list|(
name|cred
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Callback from the RPC code to generate up/down notifications.  */
end_comment

begin_struct
struct|struct
name|nfs_feedback_arg
block|{
name|struct
name|nfsmount
modifier|*
name|nf_mount
decl_stmt|;
name|int
name|nf_lastmsg
decl_stmt|;
comment|/* last tprintf */
name|int
name|nf_tprintfmsg
decl_stmt|;
name|struct
name|thread
modifier|*
name|nf_td
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|nfs_feedback
parameter_list|(
name|int
name|type
parameter_list|,
name|int
name|proc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|nfs_feedback_arg
modifier|*
name|nf
init|=
operator|(
expr|struct
name|nfs_feedback_arg
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
init|=
name|nf
operator|->
name|nf_mount
decl_stmt|;
name|time_t
name|now
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|FEEDBACK_REXMIT2
case|:
case|case
name|FEEDBACK_RECONNECT
case|:
name|now
operator|=
name|NFSD_MONOSEC
expr_stmt|;
if|if
condition|(
name|nf
operator|->
name|nf_lastmsg
operator|+
name|nmp
operator|->
name|nm_tprintf_delay
operator|<
name|now
condition|)
block|{
name|nfs_down
argument_list|(
name|nmp
argument_list|,
name|nf
operator|->
name|nf_td
argument_list|,
literal|"not responding"
argument_list|,
literal|0
argument_list|,
name|NFSSTA_TIMEO
argument_list|)
expr_stmt|;
name|nf
operator|->
name|nf_tprintfmsg
operator|=
name|TRUE
expr_stmt|;
name|nf
operator|->
name|nf_lastmsg
operator|=
name|now
expr_stmt|;
block|}
break|break;
case|case
name|FEEDBACK_OK
case|:
name|nfs_up
argument_list|(
name|nf
operator|->
name|nf_mount
argument_list|,
name|nf
operator|->
name|nf_td
argument_list|,
literal|"is alive again"
argument_list|,
name|NFSSTA_TIMEO
argument_list|,
name|nf
operator|->
name|nf_tprintfmsg
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * newnfs_request - goes something like this  *	- does the rpc by calling the krpc layer  *	- break down rpc header and return with nfs reply  * nb: always frees up nd_mreq mbuf list  */
end_comment

begin_function
name|int
name|newnfs_request
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|,
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|,
name|struct
name|nfsclient
modifier|*
name|clp
parameter_list|,
name|struct
name|nfssockreq
modifier|*
name|nrp
parameter_list|,
name|vnode_t
name|vp
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|u_int32_t
name|prog
parameter_list|,
name|u_int32_t
name|vers
parameter_list|,
name|u_char
modifier|*
name|retsum
parameter_list|,
name|int
name|toplevel
parameter_list|,
name|u_int64_t
modifier|*
name|xidp
parameter_list|,
name|struct
name|nfsclsession
modifier|*
name|dssep
parameter_list|)
block|{
name|uint32_t
name|retseq
decl_stmt|,
name|retval
decl_stmt|,
name|slotseq
decl_stmt|,
modifier|*
name|tl
decl_stmt|;
name|time_t
name|waituntil
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|,
name|opcnt
decl_stmt|,
name|set_sigset
init|=
literal|0
decl_stmt|,
name|slot
decl_stmt|;
name|int
name|trycnt
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|,
name|usegssname
init|=
literal|0
decl_stmt|,
name|secflavour
init|=
name|AUTH_SYS
decl_stmt|;
name|int
name|freeslot
decl_stmt|,
name|maxslot
decl_stmt|,
name|reterr
decl_stmt|,
name|slotpos
decl_stmt|,
name|timeo
decl_stmt|;
name|u_int16_t
name|procnum
decl_stmt|;
name|u_int
name|trylater_delay
init|=
literal|1
decl_stmt|;
name|struct
name|nfs_feedback_arg
name|nf
decl_stmt|;
name|struct
name|timeval
name|timo
decl_stmt|;
name|AUTH
modifier|*
name|auth
decl_stmt|;
name|struct
name|rpc_callextra
name|ext
decl_stmt|;
name|enum
name|clnt_stat
name|stat
decl_stmt|;
name|struct
name|nfsreq
modifier|*
name|rep
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|srv_principal
init|=
name|NULL
decl_stmt|,
modifier|*
name|clnt_principal
init|=
name|NULL
decl_stmt|;
name|sigset_t
name|oldset
decl_stmt|;
name|struct
name|ucred
modifier|*
name|authcred
decl_stmt|;
name|struct
name|nfsclsession
modifier|*
name|sep
decl_stmt|;
name|uint8_t
name|sessionid
index|[
name|NFSX_V4SESSIONID
index|]
decl_stmt|;
name|sep
operator|=
name|dssep
expr_stmt|;
if|if
condition|(
name|xidp
operator|!=
name|NULL
condition|)
operator|*
name|xidp
operator|=
literal|0
expr_stmt|;
comment|/* Reject requests while attempting a forced unmount. */
if|if
condition|(
name|nmp
operator|!=
name|NULL
operator|&&
operator|(
name|nmp
operator|->
name|nm_mountp
operator|->
name|mnt_kern_flag
operator|&
name|MNTK_UNMOUNTF
operator|)
condition|)
block|{
name|m_freem
argument_list|(
name|nd
operator|->
name|nd_mreq
argument_list|)
expr_stmt|;
return|return
operator|(
name|ESTALE
operator|)
return|;
block|}
comment|/* 	 * Set authcred, which is used to acquire RPC credentials to 	 * the cred argument, by default. The crhold() should not be 	 * necessary, but will ensure that some future code change 	 * doesn't result in the credential being free'd prematurely. 	 */
name|authcred
operator|=
name|crhold
argument_list|(
name|cred
argument_list|)
expr_stmt|;
comment|/* For client side interruptible mounts, mask off the signals. */
if|if
condition|(
name|nmp
operator|!=
name|NULL
operator|&&
name|td
operator|!=
name|NULL
operator|&&
name|NFSHASINT
argument_list|(
name|nmp
argument_list|)
condition|)
block|{
name|newnfs_set_sigmask
argument_list|(
name|td
argument_list|,
operator|&
name|oldset
argument_list|)
expr_stmt|;
name|set_sigset
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * XXX if not already connected call nfs_connect now. Longer 	 * term, change nfs_mount to call nfs_connect unconditionally 	 * and let clnt_reconnect_create handle reconnects. 	 */
if|if
condition|(
name|nrp
operator|->
name|nr_client
operator|==
name|NULL
condition|)
name|newnfs_connect
argument_list|(
name|nmp
argument_list|,
name|nrp
argument_list|,
name|cred
argument_list|,
name|td
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * For a client side mount, nmp is != NULL and clp == NULL. For 	 * server calls (callbacks or upcalls), nmp == NULL. 	 */
if|if
condition|(
name|clp
operator|!=
name|NULL
condition|)
block|{
name|NFSLOCKSTATE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|clp
operator|->
name|lc_flags
operator|&
name|LCL_GSS
operator|)
operator|&&
name|nfsrv_gsscallbackson
condition|)
block|{
name|secflavour
operator|=
name|RPCSEC_GSS_KRB5
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_procnum
operator|!=
name|NFSPROC_NULL
condition|)
block|{
if|if
condition|(
name|clp
operator|->
name|lc_flags
operator|&
name|LCL_GSSINTEGRITY
condition|)
name|secflavour
operator|=
name|RPCSEC_GSS_KRB5I
expr_stmt|;
elseif|else
if|if
condition|(
name|clp
operator|->
name|lc_flags
operator|&
name|LCL_GSSPRIVACY
condition|)
name|secflavour
operator|=
name|RPCSEC_GSS_KRB5P
expr_stmt|;
block|}
block|}
name|NFSUNLOCKSTATE
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nmp
operator|!=
name|NULL
operator|&&
name|NFSHASKERB
argument_list|(
name|nmp
argument_list|)
operator|&&
name|nd
operator|->
name|nd_procnum
operator|!=
name|NFSPROC_NULL
condition|)
block|{
if|if
condition|(
name|NFSHASALLGSSNAME
argument_list|(
name|nmp
argument_list|)
operator|&&
name|nmp
operator|->
name|nm_krbnamelen
operator|>
literal|0
condition|)
name|nd
operator|->
name|nd_flag
operator||=
name|ND_USEGSSNAME
expr_stmt|;
if|if
condition|(
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_USEGSSNAME
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * If there is a client side host based credential, 			 * use that, otherwise use the system uid, if set. 			 * The system uid is in the nmp->nm_sockreq.nr_cred 			 * credentials. 			 */
if|if
condition|(
name|nmp
operator|->
name|nm_krbnamelen
operator|>
literal|0
condition|)
block|{
name|usegssname
operator|=
literal|1
expr_stmt|;
name|clnt_principal
operator|=
name|nmp
operator|->
name|nm_krbname
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nmp
operator|->
name|nm_uid
operator|!=
operator|(
name|uid_t
operator|)
operator|-
literal|1
condition|)
block|{
name|KASSERT
argument_list|(
name|nmp
operator|->
name|nm_sockreq
operator|.
name|nr_cred
operator|!=
name|NULL
argument_list|,
operator|(
literal|"newnfs_request: NULL nr_cred"
operator|)
argument_list|)
expr_stmt|;
name|crfree
argument_list|(
name|authcred
argument_list|)
expr_stmt|;
name|authcred
operator|=
name|crhold
argument_list|(
name|nmp
operator|->
name|nm_sockreq
operator|.
name|nr_cred
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|nmp
operator|->
name|nm_krbnamelen
operator|==
literal|0
operator|&&
name|nmp
operator|->
name|nm_uid
operator|!=
operator|(
name|uid_t
operator|)
operator|-
literal|1
operator|&&
name|cred
operator|->
name|cr_uid
operator|==
operator|(
name|uid_t
operator|)
literal|0
condition|)
block|{
comment|/* 			 * If there is no host based principal name and 			 * the system uid is set and this is root, use the 			 * system uid, since root won't have user 			 * credentials in a credentials cache file. 			 * The system uid is in the nmp->nm_sockreq.nr_cred 			 * credentials. 			 */
name|KASSERT
argument_list|(
name|nmp
operator|->
name|nm_sockreq
operator|.
name|nr_cred
operator|!=
name|NULL
argument_list|,
operator|(
literal|"newnfs_request: NULL nr_cred"
operator|)
argument_list|)
expr_stmt|;
name|crfree
argument_list|(
name|authcred
argument_list|)
expr_stmt|;
name|authcred
operator|=
name|crhold
argument_list|(
name|nmp
operator|->
name|nm_sockreq
operator|.
name|nr_cred
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|NFSHASINTEGRITY
argument_list|(
name|nmp
argument_list|)
condition|)
name|secflavour
operator|=
name|RPCSEC_GSS_KRB5I
expr_stmt|;
elseif|else
if|if
condition|(
name|NFSHASPRIVACY
argument_list|(
name|nmp
argument_list|)
condition|)
name|secflavour
operator|=
name|RPCSEC_GSS_KRB5P
expr_stmt|;
else|else
name|secflavour
operator|=
name|RPCSEC_GSS_KRB5
expr_stmt|;
name|srv_principal
operator|=
name|NFSMNT_SRVKRBNAME
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nmp
operator|!=
name|NULL
operator|&&
operator|!
name|NFSHASKERB
argument_list|(
name|nmp
argument_list|)
operator|&&
name|nd
operator|->
name|nd_procnum
operator|!=
name|NFSPROC_NULL
operator|&&
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_USEGSSNAME
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Use the uid that did the mount when the RPC is doing 		 * NFSv4 system operations, as indicated by the 		 * ND_USEGSSNAME flag, for the AUTH_SYS case. 		 * The credentials in nm_sockreq.nr_cred were used for the 		 * mount. 		 */
name|KASSERT
argument_list|(
name|nmp
operator|->
name|nm_sockreq
operator|.
name|nr_cred
operator|!=
name|NULL
argument_list|,
operator|(
literal|"newnfs_request: NULL nr_cred"
operator|)
argument_list|)
expr_stmt|;
name|crfree
argument_list|(
name|authcred
argument_list|)
expr_stmt|;
name|authcred
operator|=
name|crhold
argument_list|(
name|nmp
operator|->
name|nm_sockreq
operator|.
name|nr_cred
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nmp
operator|!=
name|NULL
condition|)
block|{
name|bzero
argument_list|(
operator|&
name|nf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nfs_feedback_arg
argument_list|)
argument_list|)
expr_stmt|;
name|nf
operator|.
name|nf_mount
operator|=
name|nmp
expr_stmt|;
name|nf
operator|.
name|nf_td
operator|=
name|td
expr_stmt|;
name|nf
operator|.
name|nf_lastmsg
operator|=
name|NFSD_MONOSEC
operator|-
operator|(
operator|(
name|nmp
operator|->
name|nm_tprintf_delay
operator|)
operator|-
operator|(
name|nmp
operator|->
name|nm_tprintf_initial_delay
operator|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|nd
operator|->
name|nd_procnum
operator|==
name|NFSPROC_NULL
condition|)
name|auth
operator|=
name|authnone_create
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|usegssname
condition|)
block|{
comment|/* 		 * For this case, the authenticator is held in the 		 * nfssockreq structure, so don't release the reference count 		 * held on it. --> Don't AUTH_DESTROY() it in this function. 		 */
if|if
condition|(
name|nrp
operator|->
name|nr_auth
operator|==
name|NULL
condition|)
name|nrp
operator|->
name|nr_auth
operator|=
name|nfs_getauth
argument_list|(
name|nrp
argument_list|,
name|secflavour
argument_list|,
name|clnt_principal
argument_list|,
name|srv_principal
argument_list|,
name|NULL
argument_list|,
name|authcred
argument_list|)
expr_stmt|;
else|else
name|rpc_gss_refresh_auth_call
argument_list|(
name|nrp
operator|->
name|nr_auth
argument_list|)
expr_stmt|;
name|auth
operator|=
name|nrp
operator|->
name|nr_auth
expr_stmt|;
block|}
else|else
name|auth
operator|=
name|nfs_getauth
argument_list|(
name|nrp
argument_list|,
name|secflavour
argument_list|,
name|NULL
argument_list|,
name|srv_principal
argument_list|,
name|NULL
argument_list|,
name|authcred
argument_list|)
expr_stmt|;
name|crfree
argument_list|(
name|authcred
argument_list|)
expr_stmt|;
if|if
condition|(
name|auth
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|nd
operator|->
name|nd_mreq
argument_list|)
expr_stmt|;
if|if
condition|(
name|set_sigset
condition|)
name|newnfs_restore_sigmask
argument_list|(
name|td
argument_list|,
operator|&
name|oldset
argument_list|)
expr_stmt|;
return|return
operator|(
name|EACCES
operator|)
return|;
block|}
name|bzero
argument_list|(
operator|&
name|ext
argument_list|,
sizeof|sizeof
argument_list|(
name|ext
argument_list|)
argument_list|)
expr_stmt|;
name|ext
operator|.
name|rc_auth
operator|=
name|auth
expr_stmt|;
if|if
condition|(
name|nmp
operator|!=
name|NULL
condition|)
block|{
name|ext
operator|.
name|rc_feedback
operator|=
name|nfs_feedback
expr_stmt|;
name|ext
operator|.
name|rc_feedback_arg
operator|=
operator|&
name|nf
expr_stmt|;
block|}
name|procnum
operator|=
name|nd
operator|->
name|nd_procnum
expr_stmt|;
if|if
condition|(
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
operator|)
operator|&&
name|nd
operator|->
name|nd_procnum
operator|!=
name|NFSPROC_NULL
operator|&&
name|nd
operator|->
name|nd_procnum
operator|!=
name|NFSV4PROC_CBCOMPOUND
condition|)
name|procnum
operator|=
name|NFSV4PROC_COMPOUND
expr_stmt|;
if|if
condition|(
name|nmp
operator|!=
name|NULL
condition|)
block|{
name|NFSINCRGLOBAL
argument_list|(
name|nfsstatsv1
operator|.
name|rpcrequests
argument_list|)
expr_stmt|;
comment|/* Map the procnum to the old NFSv2 one, as required. */
if|if
condition|(
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV2
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|nd
operator|->
name|nd_procnum
operator|<
name|NFS_V3NPROCS
condition|)
name|procnum
operator|=
name|nfsv2_procid
index|[
name|nd
operator|->
name|nd_procnum
index|]
expr_stmt|;
else|else
name|procnum
operator|=
name|NFSV2PROC_NOOP
expr_stmt|;
block|}
comment|/* 		 * Now only used for the R_DONTRECOVER case, but until that is 		 * supported within the krpc code, I need to keep a queue of 		 * outstanding RPCs for nfsv4 client requests. 		 */
if|if
condition|(
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
operator|)
operator|&&
name|procnum
operator|==
name|NFSV4PROC_COMPOUND
condition|)
name|MALLOC
argument_list|(
name|rep
argument_list|,
expr|struct
name|nfsreq
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nfsreq
argument_list|)
argument_list|,
name|M_NFSDREQ
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KDTRACE_HOOKS
if|if
condition|(
name|dtrace_nfscl_nfs234_start_probe
operator|!=
name|NULL
condition|)
block|{
name|uint32_t
name|probe_id
decl_stmt|;
name|int
name|probe_procnum
decl_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
block|{
name|probe_id
operator|=
name|nfscl_nfs4_start_probes
index|[
name|nd
operator|->
name|nd_procnum
index|]
expr_stmt|;
name|probe_procnum
operator|=
name|nd
operator|->
name|nd_procnum
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
condition|)
block|{
name|probe_id
operator|=
name|nfscl_nfs3_start_probes
index|[
name|procnum
index|]
expr_stmt|;
name|probe_procnum
operator|=
name|procnum
expr_stmt|;
block|}
else|else
block|{
name|probe_id
operator|=
name|nfscl_nfs2_start_probes
index|[
name|nd
operator|->
name|nd_procnum
index|]
expr_stmt|;
name|probe_procnum
operator|=
name|procnum
expr_stmt|;
block|}
if|if
condition|(
name|probe_id
operator|!=
literal|0
condition|)
call|(
name|dtrace_nfscl_nfs234_start_probe
call|)
argument_list|(
name|probe_id
argument_list|,
name|vp
argument_list|,
name|nd
operator|->
name|nd_mreq
argument_list|,
name|cred
argument_list|,
name|probe_procnum
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|trycnt
operator|=
literal|0
expr_stmt|;
name|freeslot
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Set to slot that needs to be free'd */
name|tryagain
label|:
name|slot
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Slot that needs a sequence# increment. */
comment|/* 	 * This timeout specifies when a new socket should be created, 	 * along with new xid values. For UDP, this should be done 	 * infrequently, since retransmits of RPC requests should normally 	 * use the same xid. 	 */
if|if
condition|(
name|nmp
operator|==
name|NULL
condition|)
block|{
name|timo
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|clp
operator|==
name|NULL
condition|)
name|timo
operator|.
name|tv_sec
operator|=
name|NFSV4_UPCALLTIMEO
expr_stmt|;
else|else
name|timo
operator|.
name|tv_sec
operator|=
name|NFSV4_CALLBACKTIMEO
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|nrp
operator|->
name|nr_sotype
operator|!=
name|SOCK_DGRAM
condition|)
block|{
name|timo
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_NFSV4
operator|)
condition|)
name|timo
operator|.
name|tv_sec
operator|=
name|INT_MAX
expr_stmt|;
else|else
name|timo
operator|.
name|tv_sec
operator|=
name|NFS_TCPTIMEO
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|NFSHASSOFT
argument_list|(
name|nmp
argument_list|)
condition|)
block|{
comment|/* 				 * CLSET_RETRIES is set to 2, so this should be 				 * half of the total timeout required. 				 */
name|timeo
operator|=
name|nmp
operator|->
name|nm_retry
operator|*
name|nmp
operator|->
name|nm_timeo
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|timeo
operator|<
literal|1
condition|)
name|timeo
operator|=
literal|1
expr_stmt|;
name|timo
operator|.
name|tv_sec
operator|=
name|timeo
operator|/
name|NFS_HZ
expr_stmt|;
name|timo
operator|.
name|tv_usec
operator|=
operator|(
name|timeo
operator|%
name|NFS_HZ
operator|)
operator|*
literal|1000000
operator|/
name|NFS_HZ
expr_stmt|;
block|}
else|else
block|{
comment|/* For UDP hard mounts, use a large value. */
name|timo
operator|.
name|tv_sec
operator|=
name|NFS_MAXTIMEO
operator|/
name|NFS_HZ
expr_stmt|;
name|timo
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rep
operator|!=
name|NULL
condition|)
block|{
name|rep
operator|->
name|r_flags
operator|=
literal|0
expr_stmt|;
name|rep
operator|->
name|r_nmp
operator|=
name|nmp
expr_stmt|;
comment|/* 			 * Chain request into list of outstanding requests. 			 */
name|NFSLOCKREQ
argument_list|()
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|nfsd_reqq
argument_list|,
name|rep
argument_list|,
name|r_chain
argument_list|)
expr_stmt|;
name|NFSUNLOCKREQ
argument_list|()
expr_stmt|;
block|}
block|}
name|nd
operator|->
name|nd_mrep
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|clp
operator|!=
name|NULL
operator|&&
name|sep
operator|!=
name|NULL
condition|)
name|stat
operator|=
name|clnt_bck_call
argument_list|(
name|nrp
operator|->
name|nr_client
argument_list|,
operator|&
name|ext
argument_list|,
name|procnum
argument_list|,
name|nd
operator|->
name|nd_mreq
argument_list|,
operator|&
name|nd
operator|->
name|nd_mrep
argument_list|,
name|timo
argument_list|,
name|sep
operator|->
name|nfsess_xprt
argument_list|)
expr_stmt|;
else|else
name|stat
operator|=
name|CLNT_CALL_MBUF
argument_list|(
name|nrp
operator|->
name|nr_client
argument_list|,
operator|&
name|ext
argument_list|,
name|procnum
argument_list|,
name|nd
operator|->
name|nd_mreq
argument_list|,
operator|&
name|nd
operator|->
name|nd_mrep
argument_list|,
name|timo
argument_list|)
expr_stmt|;
if|if
condition|(
name|rep
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * RPC done, unlink the request. 		 */
name|NFSLOCKREQ
argument_list|()
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|nfsd_reqq
argument_list|,
name|rep
argument_list|,
name|r_chain
argument_list|)
expr_stmt|;
name|NFSUNLOCKREQ
argument_list|()
expr_stmt|;
block|}
comment|/* 	 * If there was a successful reply and a tprintf msg. 	 * tprintf a response. 	 */
if|if
condition|(
name|stat
operator|==
name|RPC_SUCCESS
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|stat
operator|==
name|RPC_TIMEDOUT
condition|)
block|{
name|NFSINCRGLOBAL
argument_list|(
name|nfsstatsv1
operator|.
name|rpctimeouts
argument_list|)
expr_stmt|;
name|error
operator|=
name|ETIMEDOUT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|stat
operator|==
name|RPC_VERSMISMATCH
condition|)
block|{
name|NFSINCRGLOBAL
argument_list|(
name|nfsstatsv1
operator|.
name|rpcinvalid
argument_list|)
expr_stmt|;
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|stat
operator|==
name|RPC_PROGVERSMISMATCH
condition|)
block|{
name|NFSINCRGLOBAL
argument_list|(
name|nfsstatsv1
operator|.
name|rpcinvalid
argument_list|)
expr_stmt|;
name|error
operator|=
name|EPROTONOSUPPORT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|stat
operator|==
name|RPC_INTR
condition|)
block|{
name|error
operator|=
name|EINTR
expr_stmt|;
block|}
else|else
block|{
name|NFSINCRGLOBAL
argument_list|(
name|nfsstatsv1
operator|.
name|rpcinvalid
argument_list|)
expr_stmt|;
name|error
operator|=
name|EACCES
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|m_freem
argument_list|(
name|nd
operator|->
name|nd_mreq
argument_list|)
expr_stmt|;
if|if
condition|(
name|usegssname
operator|==
literal|0
condition|)
name|AUTH_DESTROY
argument_list|(
name|auth
argument_list|)
expr_stmt|;
if|if
condition|(
name|rep
operator|!=
name|NULL
condition|)
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|rep
argument_list|,
name|M_NFSDREQ
argument_list|)
expr_stmt|;
if|if
condition|(
name|set_sigset
condition|)
name|newnfs_restore_sigmask
argument_list|(
name|td
argument_list|,
operator|&
name|oldset
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|KASSERT
argument_list|(
name|nd
operator|->
name|nd_mrep
operator|!=
name|NULL
argument_list|,
operator|(
literal|"mrep shouldn't be NULL if no error\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Search for any mbufs that are not a multiple of 4 bytes long 	 * or with m_data not longword aligned. 	 * These could cause pointer alignment problems, so copy them to 	 * well aligned mbufs. 	 */
name|newnfs_realign
argument_list|(
operator|&
name|nd
operator|->
name|nd_mrep
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_md
operator|=
name|nd
operator|->
name|nd_mrep
expr_stmt|;
name|nd
operator|->
name|nd_dpos
operator|=
name|NFSMTOD
argument_list|(
name|nd
operator|->
name|nd_md
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_repstat
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_procnum
operator|!=
name|NFSPROC_NULL
operator|&&
name|nd
operator|->
name|nd_procnum
operator|!=
name|NFSV4PROC_CBNULL
condition|)
block|{
comment|/* If sep == NULL, set it to the default in nmp. */
if|if
condition|(
name|sep
operator|==
name|NULL
operator|&&
name|nmp
operator|!=
name|NULL
condition|)
name|sep
operator|=
name|nfsmnt_mdssession
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
comment|/* 		 * and now the actual NFS xdr. 		 */
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_repstat
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|>=
literal|10000
condition|)
name|NFSCL_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"proc=%d reps=%d\n"
argument_list|,
operator|(
name|int
operator|)
name|nd
operator|->
name|nd_procnum
argument_list|,
operator|(
name|int
operator|)
name|nd
operator|->
name|nd_repstat
argument_list|)
expr_stmt|;
comment|/* 		 * Get rid of the tag, return count and SEQUENCE result for 		 * NFSv4. 		 */
if|if
condition|(
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
operator|)
operator|!=
literal|0
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|i
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfsm_advance
argument_list|(
name|nd
argument_list|,
name|NFSM_RNDUP
argument_list|(
name|i
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|3
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|opcnt
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
name|i
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
name|j
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|>=
literal|10000
condition|)
name|NFSCL_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"fop=%d fst=%d\n"
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
comment|/* 			 * If the first op is Sequence, free up the slot. 			 */
if|if
condition|(
operator|(
name|nmp
operator|!=
name|NULL
operator|&&
name|i
operator|==
name|NFSV4OP_SEQUENCE
operator|&&
name|j
operator|!=
literal|0
operator|)
operator|||
operator|(
name|clp
operator|!=
name|NULL
operator|&&
name|i
operator|==
name|NFSV4OP_CBSEQUENCE
operator|&&
name|j
operator|!=
literal|0
operator|)
condition|)
name|NFSCL_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"failed seq=%d\n"
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nmp
operator|!=
name|NULL
operator|&&
name|i
operator|==
name|NFSV4OP_SEQUENCE
operator|&&
name|j
operator|==
literal|0
operator|)
operator|||
operator|(
name|clp
operator|!=
name|NULL
operator|&&
name|i
operator|==
name|NFSV4OP_CBSEQUENCE
operator|&&
name|j
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|i
operator|==
name|NFSV4OP_SEQUENCE
condition|)
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|uint32_t
operator|*
argument_list|,
name|NFSX_V4SESSIONID
operator|+
literal|5
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
else|else
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|uint32_t
operator|*
argument_list|,
name|NFSX_V4SESSIONID
operator|+
literal|4
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sep
operator|->
name|nfsess_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
name|tl
argument_list|,
name|sep
operator|->
name|nfsess_sessionid
argument_list|,
name|NFSX_V4SESSIONID
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tl
operator|+=
name|NFSX_V4SESSIONID
operator|/
name|NFSX_UNSIGNED
expr_stmt|;
name|retseq
operator|=
name|fxdr_unsigned
argument_list|(
name|uint32_t
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
name|slot
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
name|freeslot
operator|=
name|slot
expr_stmt|;
if|if
condition|(
name|retseq
operator|!=
name|sep
operator|->
name|nfsess_slotseq
index|[
name|slot
index|]
condition|)
name|printf
argument_list|(
literal|"retseq diff 0x%x\n"
argument_list|,
name|retseq
argument_list|)
expr_stmt|;
name|retval
operator|=
name|fxdr_unsigned
argument_list|(
name|uint32_t
argument_list|,
operator|*
operator|++
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|retval
operator|+
literal|1
operator|)
operator|<
name|sep
operator|->
name|nfsess_foreslots
condition|)
name|sep
operator|->
name|nfsess_foreslots
operator|=
operator|(
name|retval
operator|+
literal|1
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|retval
operator|+
literal|1
operator|)
operator|>
name|sep
operator|->
name|nfsess_foreslots
condition|)
name|sep
operator|->
name|nfsess_foreslots
operator|=
operator|(
name|retval
operator|<
literal|64
operator|)
condition|?
operator|(
name|retval
operator|+
literal|1
operator|)
else|:
literal|64
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sep
operator|->
name|nfsess_mtx
argument_list|)
expr_stmt|;
comment|/* Grab the op and status for the next one. */
if|if
condition|(
name|opcnt
operator|>
literal|1
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|uint32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|i
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
name|j
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|==
name|NFSERR_BADSESSION
operator|&&
name|nmp
operator|!=
name|NULL
operator|&&
name|dssep
operator|==
name|NULL
condition|)
block|{
comment|/* 				 * If this is a client side MDS RPC, mark 				 * the MDS session defunct and initiate 				 * recovery, as required. 				 * The nfsess_defunct field is protected by 				 * the NFSLOCKMNT()/nm_mtx lock and not the 				 * nfsess_mtx lock to simplify its handling, 				 * for the MDS session. This lock is also 				 * sufficient for nfsess_sessionid, since it 				 * never changes in the structure. 				 */
name|NFSCL_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Got badsession\n"
argument_list|)
expr_stmt|;
name|NFSLOCKCLSTATE
argument_list|()
expr_stmt|;
name|NFSLOCKMNT
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
name|sep
operator|=
name|NFSMNT_MDSSESSION
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
name|sep
operator|->
name|nfsess_sessionid
argument_list|,
name|nd
operator|->
name|nd_sequence
argument_list|,
name|NFSX_V4SESSIONID
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Initiate recovery. */
name|sep
operator|->
name|nfsess_defunct
operator|=
literal|1
expr_stmt|;
name|NFSCL_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Marked defunct\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmp
operator|->
name|nm_clp
operator|!=
name|NULL
condition|)
block|{
name|nmp
operator|->
name|nm_clp
operator|->
name|nfsc_flags
operator||=
name|NFSCLFLAGS_RECOVER
expr_stmt|;
name|wakeup
argument_list|(
name|nmp
operator|->
name|nm_clp
argument_list|)
expr_stmt|;
block|}
block|}
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
comment|/* 				 * Sleep for up to 1sec waiting for a new 				 * session. 				 */
name|mtx_sleep
argument_list|(
operator|&
name|nmp
operator|->
name|nm_sess
argument_list|,
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|,
name|PZERO
argument_list|,
literal|"nfsbadsess"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
comment|/* 				 * Get the session again, in case a new one 				 * has been created during the sleep. 				 */
name|sep
operator|=
name|NFSMNT_MDSSESSION
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
name|NFSUNLOCKMNT
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_LOOPBADSESS
operator|)
operator|!=
literal|0
condition|)
block|{
name|reterr
operator|=
name|nfsv4_sequencelookup
argument_list|(
name|nmp
argument_list|,
name|sep
argument_list|,
operator|&
name|slotpos
argument_list|,
operator|&
name|maxslot
argument_list|,
operator|&
name|slotseq
argument_list|,
name|sessionid
argument_list|)
expr_stmt|;
if|if
condition|(
name|reterr
operator|==
literal|0
condition|)
block|{
comment|/* Fill in new session info. */
name|NFSCL_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Filling in new sequence\n"
argument_list|)
expr_stmt|;
name|tl
operator|=
name|nd
operator|->
name|nd_sequence
expr_stmt|;
name|bcopy
argument_list|(
name|sessionid
argument_list|,
name|tl
argument_list|,
name|NFSX_V4SESSIONID
argument_list|)
expr_stmt|;
name|tl
operator|+=
name|NFSX_V4SESSIONID
operator|/
name|NFSX_UNSIGNED
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|slotseq
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|slotpos
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|maxslot
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reterr
operator|==
name|NFSERR_BADSESSION
operator|||
name|reterr
operator|==
literal|0
condition|)
block|{
name|NFSCL_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Badsession looping\n"
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_mrep
operator|=
name|NULL
expr_stmt|;
goto|goto
name|tryagain
goto|;
block|}
name|nd
operator|->
name|nd_repstat
operator|=
name|reterr
expr_stmt|;
name|NFSCL_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Got err=%d\n"
argument_list|,
name|reterr
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
operator|(
name|nd
operator|->
name|nd_repstat
operator|==
name|NFSERR_DELAY
operator|||
name|nd
operator|->
name|nd_repstat
operator|==
name|NFSERR_GRACE
operator|)
operator|&&
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
operator|)
operator|&&
name|nd
operator|->
name|nd_procnum
operator|!=
name|NFSPROC_DELEGRETURN
operator|&&
name|nd
operator|->
name|nd_procnum
operator|!=
name|NFSPROC_SETATTR
operator|&&
name|nd
operator|->
name|nd_procnum
operator|!=
name|NFSPROC_READ
operator|&&
name|nd
operator|->
name|nd_procnum
operator|!=
name|NFSPROC_READDS
operator|&&
name|nd
operator|->
name|nd_procnum
operator|!=
name|NFSPROC_WRITE
operator|&&
name|nd
operator|->
name|nd_procnum
operator|!=
name|NFSPROC_WRITEDS
operator|&&
name|nd
operator|->
name|nd_procnum
operator|!=
name|NFSPROC_OPEN
operator|&&
name|nd
operator|->
name|nd_procnum
operator|!=
name|NFSPROC_CREATE
operator|&&
name|nd
operator|->
name|nd_procnum
operator|!=
name|NFSPROC_OPENCONFIRM
operator|&&
name|nd
operator|->
name|nd_procnum
operator|!=
name|NFSPROC_OPENDOWNGRADE
operator|&&
name|nd
operator|->
name|nd_procnum
operator|!=
name|NFSPROC_CLOSE
operator|&&
name|nd
operator|->
name|nd_procnum
operator|!=
name|NFSPROC_LOCK
operator|&&
name|nd
operator|->
name|nd_procnum
operator|!=
name|NFSPROC_LOCKU
operator|)
operator|||
operator|(
name|nd
operator|->
name|nd_repstat
operator|==
name|NFSERR_DELAY
operator|&&
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
operator|)
operator|==
literal|0
operator|)
operator|||
name|nd
operator|->
name|nd_repstat
operator|==
name|NFSERR_RESOURCE
condition|)
block|{
if|if
condition|(
name|trylater_delay
operator|>
name|NFS_TRYLATERDEL
condition|)
name|trylater_delay
operator|=
name|NFS_TRYLATERDEL
expr_stmt|;
name|waituntil
operator|=
name|NFSD_MONOSEC
operator|+
name|trylater_delay
expr_stmt|;
while|while
condition|(
name|NFSD_MONOSEC
operator|<
name|waituntil
condition|)
operator|(
name|void
operator|)
name|nfs_catnap
argument_list|(
name|PZERO
argument_list|,
literal|0
argument_list|,
literal|"nfstry"
argument_list|)
expr_stmt|;
name|trylater_delay
operator|*=
literal|2
expr_stmt|;
if|if
condition|(
name|slot
operator|!=
operator|-
literal|1
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sep
operator|->
name|nfsess_mtx
argument_list|)
expr_stmt|;
name|sep
operator|->
name|nfsess_slotseq
index|[
name|slot
index|]
operator|++
expr_stmt|;
operator|*
name|nd
operator|->
name|nd_slotseq
operator|=
name|txdr_unsigned
argument_list|(
name|sep
operator|->
name|nfsess_slotseq
index|[
name|slot
index|]
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sep
operator|->
name|nfsess_mtx
argument_list|)
expr_stmt|;
block|}
name|m_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_mrep
operator|=
name|NULL
expr_stmt|;
goto|goto
name|tryagain
goto|;
block|}
comment|/* 			 * If the File Handle was stale, invalidate the 			 * lookup cache, just in case. 			 * (vp != NULL implies a client side call) 			 */
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|==
name|ESTALE
operator|&&
name|vp
operator|!=
name|NULL
condition|)
block|{
name|cache_purge
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ncl_call_invalcaches
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|ncl_call_invalcaches
call|)
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Free the slot, as required. */
if|if
condition|(
name|freeslot
operator|!=
operator|-
literal|1
condition|)
name|nfsv4_freeslot
argument_list|(
name|sep
argument_list|,
name|freeslot
argument_list|)
expr_stmt|;
comment|/* 			 * If this op is Putfh, throw its results away. 			 */
if|if
condition|(
name|j
operator|>=
literal|10000
condition|)
name|NFSCL_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"nop=%d nst=%d\n"
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmp
operator|!=
name|NULL
operator|&&
name|i
operator|==
name|NFSV4OP_PUTFH
operator|&&
name|j
operator|==
literal|0
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|i
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
name|j
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|>=
literal|10000
condition|)
name|NFSCL_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"n2op=%d n2st=%d\n"
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
comment|/* 				 * All Compounds that do an Op that must 				 * be in sequence consist of NFSV4OP_PUTFH 				 * followed by one of these. As such, we 				 * can determine if the seqid# should be 				 * incremented, here. 				 */
if|if
condition|(
operator|(
name|i
operator|==
name|NFSV4OP_OPEN
operator|||
name|i
operator|==
name|NFSV4OP_OPENCONFIRM
operator|||
name|i
operator|==
name|NFSV4OP_OPENDOWNGRADE
operator|||
name|i
operator|==
name|NFSV4OP_CLOSE
operator|||
name|i
operator|==
name|NFSV4OP_LOCK
operator|||
name|i
operator|==
name|NFSV4OP_LOCKU
operator|)
operator|&&
operator|(
name|j
operator|==
literal|0
operator|||
operator|(
name|j
operator|!=
name|NFSERR_STALECLIENTID
operator|&&
name|j
operator|!=
name|NFSERR_STALESTATEID
operator|&&
name|j
operator|!=
name|NFSERR_BADSTATEID
operator|&&
name|j
operator|!=
name|NFSERR_BADSEQID
operator|&&
name|j
operator|!=
name|NFSERR_BADXDR
operator|&&
name|j
operator|!=
name|NFSERR_RESOURCE
operator|&&
name|j
operator|!=
name|NFSERR_NOFILEHANDLE
operator|)
operator|)
condition|)
name|nd
operator|->
name|nd_flag
operator||=
name|ND_INCRSEQID
expr_stmt|;
block|}
comment|/* 			 * If this op's status is non-zero, mark 			 * that there is no more data to process. 			 * The exception is Setattr, which always has xdr 			 * when it has failed. 			 */
if|if
condition|(
name|j
operator|!=
literal|0
operator|&&
name|i
operator|!=
name|NFSV4OP_SETATTR
condition|)
name|nd
operator|->
name|nd_flag
operator||=
name|ND_NOMOREDATA
expr_stmt|;
comment|/* 			 * If R_DONTRECOVER is set, replace the stale error 			 * reply, so that recovery isn't initiated. 			 */
if|if
condition|(
operator|(
name|nd
operator|->
name|nd_repstat
operator|==
name|NFSERR_STALECLIENTID
operator|||
name|nd
operator|->
name|nd_repstat
operator|==
name|NFSERR_BADSESSION
operator|||
name|nd
operator|->
name|nd_repstat
operator|==
name|NFSERR_STALESTATEID
operator|)
operator|&&
name|rep
operator|!=
name|NULL
operator|&&
operator|(
name|rep
operator|->
name|r_flags
operator|&
name|R_DONTRECOVER
operator|)
condition|)
name|nd
operator|->
name|nd_repstat
operator|=
name|NFSERR_STALEDONTRECOVER
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|KDTRACE_HOOKS
if|if
condition|(
name|nmp
operator|!=
name|NULL
operator|&&
name|dtrace_nfscl_nfs234_done_probe
operator|!=
name|NULL
condition|)
block|{
name|uint32_t
name|probe_id
decl_stmt|;
name|int
name|probe_procnum
decl_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
block|{
name|probe_id
operator|=
name|nfscl_nfs4_done_probes
index|[
name|nd
operator|->
name|nd_procnum
index|]
expr_stmt|;
name|probe_procnum
operator|=
name|nd
operator|->
name|nd_procnum
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
condition|)
block|{
name|probe_id
operator|=
name|nfscl_nfs3_done_probes
index|[
name|procnum
index|]
expr_stmt|;
name|probe_procnum
operator|=
name|procnum
expr_stmt|;
block|}
else|else
block|{
name|probe_id
operator|=
name|nfscl_nfs2_done_probes
index|[
name|nd
operator|->
name|nd_procnum
index|]
expr_stmt|;
name|probe_procnum
operator|=
name|procnum
expr_stmt|;
block|}
if|if
condition|(
name|probe_id
operator|!=
literal|0
condition|)
call|(
name|dtrace_nfscl_nfs234_done_probe
call|)
argument_list|(
name|probe_id
argument_list|,
name|vp
argument_list|,
name|nd
operator|->
name|nd_mreq
argument_list|,
name|cred
argument_list|,
name|probe_procnum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|m_freem
argument_list|(
name|nd
operator|->
name|nd_mreq
argument_list|)
expr_stmt|;
if|if
condition|(
name|usegssname
operator|==
literal|0
condition|)
name|AUTH_DESTROY
argument_list|(
name|auth
argument_list|)
expr_stmt|;
if|if
condition|(
name|rep
operator|!=
name|NULL
condition|)
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|rep
argument_list|,
name|M_NFSDREQ
argument_list|)
expr_stmt|;
if|if
condition|(
name|set_sigset
condition|)
name|newnfs_restore_sigmask
argument_list|(
name|td
argument_list|,
operator|&
name|oldset
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|nfsmout
label|:
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mreq
argument_list|)
expr_stmt|;
if|if
condition|(
name|usegssname
operator|==
literal|0
condition|)
name|AUTH_DESTROY
argument_list|(
name|auth
argument_list|)
expr_stmt|;
if|if
condition|(
name|rep
operator|!=
name|NULL
condition|)
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|rep
argument_list|,
name|M_NFSDREQ
argument_list|)
expr_stmt|;
if|if
condition|(
name|set_sigset
condition|)
name|newnfs_restore_sigmask
argument_list|(
name|td
argument_list|,
operator|&
name|oldset
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Mark all of an nfs mount's outstanding requests with R_SOFTTERM and  * wait for all requests to complete. This is used by forced unmounts  * to terminate any outstanding RPCs.  */
end_comment

begin_function
name|int
name|newnfs_nmcancelreqs
parameter_list|(
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|)
block|{
if|if
condition|(
name|nmp
operator|->
name|nm_sockreq
operator|.
name|nr_client
operator|!=
name|NULL
condition|)
name|CLNT_CLOSE
argument_list|(
name|nmp
operator|->
name|nm_sockreq
operator|.
name|nr_client
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Any signal that can interrupt an NFS operation in an intr mount  * should be added to this set. SIGSTOP and SIGKILL cannot be masked.  */
end_comment

begin_decl_stmt
name|int
name|newnfs_sig_set
index|[]
init|=
block|{
name|SIGINT
block|,
name|SIGTERM
block|,
name|SIGHUP
block|,
name|SIGKILL
block|,
name|SIGQUIT
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Check to see if one of the signals in our subset is pending on  * the process (in an intr mount).  */
end_comment

begin_function
specifier|static
name|int
name|nfs_sig_pending
parameter_list|(
name|sigset_t
name|set
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|newnfs_sig_set
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|SIGISMEMBER
argument_list|(
name|set
argument_list|,
name|newnfs_sig_set
index|[
name|i
index|]
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The set/restore sigmask functions are used to (temporarily) overwrite  * the thread td_sigmask during an RPC call (for example). These are also  * used in other places in the NFS client that might tsleep().  */
end_comment

begin_function
name|void
name|newnfs_set_sigmask
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|sigset_t
modifier|*
name|oldset
parameter_list|)
block|{
name|sigset_t
name|newset
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|SIGFILLSET
argument_list|(
name|newset
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|==
name|NULL
condition|)
name|td
operator|=
name|curthread
expr_stmt|;
comment|/* XXX */
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
comment|/* Remove the NFS set of signals from newset */
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|p
operator|->
name|p_sigacts
operator|->
name|ps_mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|newnfs_sig_set
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * But make sure we leave the ones already masked 		 * by the process, ie. remove the signal from the 		 * temporary signalmask only if it wasn't already 		 * in p_sigmask. 		 */
if|if
condition|(
operator|!
name|SIGISMEMBER
argument_list|(
name|td
operator|->
name|td_sigmask
argument_list|,
name|newnfs_sig_set
index|[
name|i
index|]
argument_list|)
operator|&&
operator|!
name|SIGISMEMBER
argument_list|(
name|p
operator|->
name|p_sigacts
operator|->
name|ps_sigignore
argument_list|,
name|newnfs_sig_set
index|[
name|i
index|]
argument_list|)
condition|)
name|SIGDELSET
argument_list|(
name|newset
argument_list|,
name|newnfs_sig_set
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|p
operator|->
name|p_sigacts
operator|->
name|ps_mtx
argument_list|)
expr_stmt|;
name|kern_sigprocmask
argument_list|(
name|td
argument_list|,
name|SIG_SETMASK
argument_list|,
operator|&
name|newset
argument_list|,
name|oldset
argument_list|,
name|SIGPROCMASK_PROC_LOCKED
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|newnfs_restore_sigmask
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|sigset_t
modifier|*
name|set
parameter_list|)
block|{
if|if
condition|(
name|td
operator|==
name|NULL
condition|)
name|td
operator|=
name|curthread
expr_stmt|;
comment|/* XXX */
name|kern_sigprocmask
argument_list|(
name|td
argument_list|,
name|SIG_SETMASK
argument_list|,
name|set
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * NFS wrapper to msleep(), that shoves a new p_sigmask and restores the  * old one after msleep() returns.  */
end_comment

begin_function
name|int
name|newnfs_msleep
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|void
modifier|*
name|ident
parameter_list|,
name|struct
name|mtx
modifier|*
name|mtx
parameter_list|,
name|int
name|priority
parameter_list|,
name|char
modifier|*
name|wmesg
parameter_list|,
name|int
name|timo
parameter_list|)
block|{
name|sigset_t
name|oldset
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|priority
operator|&
name|PCATCH
operator|)
operator|==
literal|0
condition|)
return|return
name|msleep
argument_list|(
name|ident
argument_list|,
name|mtx
argument_list|,
name|priority
argument_list|,
name|wmesg
argument_list|,
name|timo
argument_list|)
return|;
if|if
condition|(
name|td
operator|==
name|NULL
condition|)
name|td
operator|=
name|curthread
expr_stmt|;
comment|/* XXX */
name|newnfs_set_sigmask
argument_list|(
name|td
argument_list|,
operator|&
name|oldset
argument_list|)
expr_stmt|;
name|error
operator|=
name|msleep
argument_list|(
name|ident
argument_list|,
name|mtx
argument_list|,
name|priority
argument_list|,
name|wmesg
argument_list|,
name|timo
argument_list|)
expr_stmt|;
name|newnfs_restore_sigmask
argument_list|(
name|td
argument_list|,
operator|&
name|oldset
argument_list|)
expr_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Test for a termination condition pending on the process.  * This is used for NFSMNT_INT mounts.  */
end_comment

begin_function
name|int
name|newnfs_sigintr
parameter_list|(
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|sigset_t
name|tmpset
decl_stmt|;
comment|/* Terminate all requests while attempting a forced unmount. */
if|if
condition|(
name|nmp
operator|->
name|nm_mountp
operator|->
name|mnt_kern_flag
operator|&
name|MNTK_UNMOUNTF
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_INT
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|td
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|tmpset
operator|=
name|p
operator|->
name|p_siglist
expr_stmt|;
name|SIGSETOR
argument_list|(
name|tmpset
argument_list|,
name|td
operator|->
name|td_siglist
argument_list|)
expr_stmt|;
name|SIGSETNAND
argument_list|(
name|tmpset
argument_list|,
name|td
operator|->
name|td_sigmask
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|p
operator|->
name|p_sigacts
operator|->
name|ps_mtx
argument_list|)
expr_stmt|;
name|SIGSETNAND
argument_list|(
name|tmpset
argument_list|,
name|p
operator|->
name|p_sigacts
operator|->
name|ps_sigignore
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|p
operator|->
name|p_sigacts
operator|->
name|ps_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|SIGNOTEMPTY
argument_list|(
name|p
operator|->
name|p_siglist
argument_list|)
operator|||
name|SIGNOTEMPTY
argument_list|(
name|td
operator|->
name|td_siglist
argument_list|)
operator|)
operator|&&
name|nfs_sig_pending
argument_list|(
name|tmpset
argument_list|)
condition|)
block|{
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINTR
operator|)
return|;
block|}
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nfs_msg
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
specifier|const
name|char
modifier|*
name|server
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|td
condition|?
name|td
operator|->
name|td_proc
else|:
name|NULL
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|tprintf
argument_list|(
name|p
argument_list|,
name|LOG_INFO
argument_list|,
literal|"nfs server %s: %s, error %d\n"
argument_list|,
name|server
argument_list|,
name|msg
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tprintf
argument_list|(
name|p
argument_list|,
name|LOG_INFO
argument_list|,
literal|"nfs server %s: %s\n"
argument_list|,
name|server
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nfs_down
parameter_list|(
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
name|int
name|error
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
if|if
condition|(
name|nmp
operator|==
name|NULL
condition|)
return|return;
name|mtx_lock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|NFSSTA_TIMEO
operator|)
operator|&&
operator|!
operator|(
name|nmp
operator|->
name|nm_state
operator|&
name|NFSSTA_TIMEO
operator|)
condition|)
block|{
name|nmp
operator|->
name|nm_state
operator||=
name|NFSSTA_TIMEO
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
name|vfs_event_signal
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mountp
operator|->
name|mnt_stat
operator|.
name|f_fsid
argument_list|,
name|VQ_NOTRESP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|NFSSTA_LOCKTIMEO
operator|)
operator|&&
operator|!
operator|(
name|nmp
operator|->
name|nm_state
operator|&
name|NFSSTA_LOCKTIMEO
operator|)
condition|)
block|{
name|nmp
operator|->
name|nm_state
operator||=
name|NFSSTA_LOCKTIMEO
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
name|vfs_event_signal
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mountp
operator|->
name|mnt_stat
operator|.
name|f_fsid
argument_list|,
name|VQ_NOTRESPLOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
name|nfs_msg
argument_list|(
name|td
argument_list|,
name|nmp
operator|->
name|nm_mountp
operator|->
name|mnt_stat
operator|.
name|f_mntfromname
argument_list|,
name|msg
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|nfs_up
parameter_list|(
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|tprintfmsg
parameter_list|)
block|{
if|if
condition|(
name|nmp
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|tprintfmsg
condition|)
block|{
name|nfs_msg
argument_list|(
name|td
argument_list|,
name|nmp
operator|->
name|nm_mountp
operator|->
name|mnt_stat
operator|.
name|f_mntfromname
argument_list|,
name|msg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|NFSSTA_TIMEO
operator|)
operator|&&
operator|(
name|nmp
operator|->
name|nm_state
operator|&
name|NFSSTA_TIMEO
operator|)
condition|)
block|{
name|nmp
operator|->
name|nm_state
operator|&=
operator|~
name|NFSSTA_TIMEO
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
name|vfs_event_signal
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mountp
operator|->
name|mnt_stat
operator|.
name|f_fsid
argument_list|,
name|VQ_NOTRESP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|NFSSTA_LOCKTIMEO
operator|)
operator|&&
operator|(
name|nmp
operator|->
name|nm_state
operator|&
name|NFSSTA_LOCKTIMEO
operator|)
condition|)
block|{
name|nmp
operator|->
name|nm_state
operator|&=
operator|~
name|NFSSTA_LOCKTIMEO
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
name|vfs_event_signal
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mountp
operator|->
name|mnt_stat
operator|.
name|f_fsid
argument_list|,
name|VQ_NOTRESPLOCK
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

