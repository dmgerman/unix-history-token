begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1989, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Rick Macklem at The University of Guelph.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * These functions support the macros and help fiddle mbuf chains for  * the nfs op functions. They do things like create the rpc header and  * copy data between mbuf chains and uio lists.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|APPLEKEXT
end_ifndef

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|<fs/nfs/nfsport.h>
end_include

begin_include
include|#
directive|include
file|<security/mac/mac_framework.h>
end_include

begin_comment
comment|/*  * Data items converted to xdr at startup, since they are constant  * This is kinda hokey, but may save a little time doing byte swaps  */
end_comment

begin_decl_stmt
name|u_int32_t
name|newnfs_true
decl_stmt|,
name|newnfs_false
decl_stmt|,
name|newnfs_xdrneg1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* And other global data */
end_comment

begin_decl_stmt
name|nfstype
name|nfsv34_type
index|[
literal|9
index|]
init|=
block|{
name|NFNON
block|,
name|NFREG
block|,
name|NFDIR
block|,
name|NFBLK
block|,
name|NFCHR
block|,
name|NFLNK
block|,
name|NFSOCK
block|,
name|NFFIFO
block|,
name|NFNON
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|vtype
name|newnv2tov_type
index|[
literal|8
index|]
init|=
block|{
name|VNON
block|,
name|VREG
block|,
name|VDIR
block|,
name|VBLK
block|,
name|VCHR
block|,
name|VLNK
block|,
name|VNON
block|,
name|VNON
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|vtype
name|nv34tov_type
index|[
literal|8
index|]
init|=
block|{
name|VNON
block|,
name|VREG
block|,
name|VDIR
block|,
name|VBLK
block|,
name|VCHR
block|,
name|VLNK
block|,
name|VSOCK
block|,
name|VFIFO
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|timeval
name|nfsboottime
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Copy boottime once, so it never changes */
end_comment

begin_decl_stmt
name|int
name|nfscl_ticks
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nfsrv_useacl
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|nfssockreq
name|nfsrv_nfsuserdsock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nfsrv_nfsuserd
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|nfsreqhead
name|nfsd_reqq
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uid_t
name|nfsrv_defaultuid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|gid_t
name|nfsrv_defaultgid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nfsrv_lease
init|=
name|NFSRV_LEASE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ncl_mbuf_mlen
init|=
name|MLEN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nfsd_enable_stringtouid
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|NFSNAMEIDMUTEX
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|NFSSOCKMUTEX
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|extern
name|int
name|nfsrv_lughashsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This array of structures indicates, for V4:  * retfh - which of 3 types of calling args are used  *	0 - doesn't change cfh or use a sfh  *	1 - replaces cfh with a new one (unless it returns an error status)  *	2 - uses cfh and sfh  * needscfh - if the op wants a cfh and premtime  *	0 - doesn't use a cfh  *	1 - uses a cfh, but doesn't want pre-op attributes  *	2 - uses a cfh and wants pre-op attributes  * savereply - indicates a non-idempotent Op  *	0 - not non-idempotent  *	1 - non-idempotent  * Ops that are ordered via seqid# are handled separately from these  * non-idempotent Ops.  * Define it here, since it is used by both the client and server.  */
end_comment

begin_decl_stmt
name|struct
name|nfsv4_opflag
name|nfsv4_opflag
index|[
name|NFSV41_NOPS
index|]
init|=
block|{
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|LK_EXCLUSIVE
block|,
literal|1
block|}
block|,
comment|/* undef */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|LK_EXCLUSIVE
block|,
literal|1
block|}
block|,
comment|/* undef */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|LK_EXCLUSIVE
block|,
literal|1
block|}
block|,
comment|/* undef */
block|{
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
name|LK_SHARED
block|,
literal|1
block|}
block|,
comment|/* Access */
block|{
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
name|LK_EXCLUSIVE
block|,
literal|1
block|}
block|,
comment|/* Close */
block|{
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
name|LK_EXCLUSIVE
block|,
literal|1
block|}
block|,
comment|/* Commit */
block|{
literal|1
block|,
literal|2
block|,
literal|1
block|,
literal|1
block|,
name|LK_EXCLUSIVE
block|,
literal|1
block|}
block|,
comment|/* Create */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|LK_EXCLUSIVE
block|,
literal|1
block|}
block|,
comment|/* Delegpurge */
block|{
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
name|LK_EXCLUSIVE
block|,
literal|1
block|}
block|,
comment|/* Delegreturn */
block|{
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
name|LK_SHARED
block|,
literal|1
block|}
block|,
comment|/* Getattr */
block|{
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
name|LK_EXCLUSIVE
block|,
literal|1
block|}
block|,
comment|/* GetFH */
block|{
literal|2
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
name|LK_EXCLUSIVE
block|,
literal|1
block|}
block|,
comment|/* Link */
block|{
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
name|LK_EXCLUSIVE
block|,
literal|1
block|}
block|,
comment|/* Lock */
block|{
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
name|LK_EXCLUSIVE
block|,
literal|1
block|}
block|,
comment|/* LockT */
block|{
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
name|LK_EXCLUSIVE
block|,
literal|1
block|}
block|,
comment|/* LockU */
block|{
literal|1
block|,
literal|2
block|,
literal|0
block|,
literal|0
block|,
name|LK_EXCLUSIVE
block|,
literal|1
block|}
block|,
comment|/* Lookup */
block|{
literal|1
block|,
literal|2
block|,
literal|0
block|,
literal|0
block|,
name|LK_EXCLUSIVE
block|,
literal|1
block|}
block|,
comment|/* Lookupp */
block|{
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
name|LK_EXCLUSIVE
block|,
literal|1
block|}
block|,
comment|/* NVerify */
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
name|LK_EXCLUSIVE
block|,
literal|1
block|}
block|,
comment|/* Open */
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
name|LK_EXCLUSIVE
block|,
literal|1
block|}
block|,
comment|/* OpenAttr */
block|{
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
name|LK_EXCLUSIVE
block|,
literal|1
block|}
block|,
comment|/* OpenConfirm */
block|{
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
name|LK_EXCLUSIVE
block|,
literal|1
block|}
block|,
comment|/* OpenDowngrade */
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|LK_EXCLUSIVE
block|,
literal|1
block|}
block|,
comment|/* PutFH */
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|LK_EXCLUSIVE
block|,
literal|1
block|}
block|,
comment|/* PutPubFH */
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|LK_EXCLUSIVE
block|,
literal|1
block|}
block|,
comment|/* PutRootFH */
block|{
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
name|LK_SHARED
block|,
literal|1
block|}
block|,
comment|/* Read */
block|{
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
name|LK_SHARED
block|,
literal|1
block|}
block|,
comment|/* Readdir */
block|{
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
name|LK_SHARED
block|,
literal|1
block|}
block|,
comment|/* ReadLink */
block|{
literal|0
block|,
literal|2
block|,
literal|1
block|,
literal|1
block|,
name|LK_EXCLUSIVE
block|,
literal|1
block|}
block|,
comment|/* Remove */
block|{
literal|2
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
name|LK_EXCLUSIVE
block|,
literal|1
block|}
block|,
comment|/* Rename */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|LK_EXCLUSIVE
block|,
literal|1
block|}
block|,
comment|/* Renew */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|LK_EXCLUSIVE
block|,
literal|1
block|}
block|,
comment|/* RestoreFH */
block|{
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
name|LK_EXCLUSIVE
block|,
literal|1
block|}
block|,
comment|/* SaveFH */
block|{
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
name|LK_EXCLUSIVE
block|,
literal|1
block|}
block|,
comment|/* SecInfo */
block|{
literal|0
block|,
literal|2
block|,
literal|1
block|,
literal|1
block|,
name|LK_EXCLUSIVE
block|,
literal|1
block|}
block|,
comment|/* Setattr */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|LK_EXCLUSIVE
block|,
literal|1
block|}
block|,
comment|/* SetClientID */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|LK_EXCLUSIVE
block|,
literal|1
block|}
block|,
comment|/* SetClientIDConfirm */
block|{
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
name|LK_EXCLUSIVE
block|,
literal|1
block|}
block|,
comment|/* Verify */
block|{
literal|0
block|,
literal|2
block|,
literal|1
block|,
literal|1
block|,
name|LK_EXCLUSIVE
block|,
literal|1
block|}
block|,
comment|/* Write */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|LK_EXCLUSIVE
block|,
literal|1
block|}
block|,
comment|/* ReleaseLockOwner */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|LK_EXCLUSIVE
block|,
literal|1
block|}
block|,
comment|/* Backchannel Ctrl */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|LK_EXCLUSIVE
block|,
literal|1
block|}
block|,
comment|/* Bind Conn to Sess */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|LK_EXCLUSIVE
block|,
literal|0
block|}
block|,
comment|/* Exchange ID */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|LK_EXCLUSIVE
block|,
literal|0
block|}
block|,
comment|/* Create Session */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|LK_EXCLUSIVE
block|,
literal|0
block|}
block|,
comment|/* Destroy Session */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|LK_EXCLUSIVE
block|,
literal|1
block|}
block|,
comment|/* Free StateID */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|LK_EXCLUSIVE
block|,
literal|1
block|}
block|,
comment|/* Get Dir Deleg */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|LK_EXCLUSIVE
block|,
literal|1
block|}
block|,
comment|/* Get Device Info */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|LK_EXCLUSIVE
block|,
literal|1
block|}
block|,
comment|/* Get Device List */
block|{
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
name|LK_EXCLUSIVE
block|,
literal|1
block|}
block|,
comment|/* Layout Commit */
block|{
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
name|LK_EXCLUSIVE
block|,
literal|1
block|}
block|,
comment|/* Layout Get */
block|{
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
name|LK_EXCLUSIVE
block|,
literal|1
block|}
block|,
comment|/* Layout Return */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|LK_EXCLUSIVE
block|,
literal|1
block|}
block|,
comment|/* Secinfo No name */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|LK_EXCLUSIVE
block|,
literal|1
block|}
block|,
comment|/* Sequence */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|LK_EXCLUSIVE
block|,
literal|1
block|}
block|,
comment|/* Set SSV */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|LK_EXCLUSIVE
block|,
literal|1
block|}
block|,
comment|/* Test StateID */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|LK_EXCLUSIVE
block|,
literal|1
block|}
block|,
comment|/* Want Delegation */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|LK_EXCLUSIVE
block|,
literal|0
block|}
block|,
comment|/* Destroy ClientID */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|LK_EXCLUSIVE
block|,
literal|1
block|}
block|,
comment|/* Reclaim Complete */
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !APPLEKEXT */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ncl_mbuf_mhlen
init|=
name|MHLEN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfsrv_usercnt
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfsrv_dnsnamelen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
modifier|*
name|nfsrv_dnsname
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfsrv_usermax
init|=
literal|999999999
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|nfsrv_lughash
block|{
name|struct
name|mtx
name|mtx
decl_stmt|;
name|struct
name|nfsuserhashhead
name|lughead
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|nfsrv_lughash
modifier|*
name|nfsuserhash
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|nfsrv_lughash
modifier|*
name|nfsusernamehash
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|nfsrv_lughash
modifier|*
name|nfsgrouphash
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|nfsrv_lughash
modifier|*
name|nfsgroupnamehash
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This static array indicates whether or not the RPC generates a large  * reply. This is used by nfs_reply() to decide whether or not an mbuf  * cluster should be allocated. (If a cluster is required by an RPC  * marked 0 in this array, the code will still work, just not quite as  * efficiently.)  */
end_comment

begin_decl_stmt
name|int
name|nfs_bigreply
index|[
name|NFSV41_NPROCS
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* local functions */
end_comment

begin_function_decl
specifier|static
name|int
name|nfsrv_skipace
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|,
name|int
modifier|*
name|acesizep
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nfsv4_wanted
parameter_list|(
name|struct
name|nfsv4lock
modifier|*
name|lp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nfsrv_cmpmixedcase
parameter_list|(
name|u_char
modifier|*
name|cp
parameter_list|,
name|u_char
modifier|*
name|cp2
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nfsrv_getuser
parameter_list|(
name|int
name|procnum
parameter_list|,
name|uid_t
name|uid
parameter_list|,
name|gid_t
name|gid
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nfsrv_removeuser
parameter_list|(
name|struct
name|nfsusrgrp
modifier|*
name|usrp
parameter_list|,
name|int
name|isuser
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nfsrv_getrefstr
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
parameter_list|,
name|u_char
modifier|*
modifier|*
parameter_list|,
name|u_char
modifier|*
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nfsrv_refstrbigenough
parameter_list|(
name|int
parameter_list|,
name|u_char
modifier|*
modifier|*
parameter_list|,
name|u_char
modifier|*
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|APPLE
end_ifndef

begin_comment
comment|/*  * copies mbuf chain to the uio scatter/gather list  */
end_comment

begin_function
name|int
name|nfsm_mbufuio
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|,
name|struct
name|uio
modifier|*
name|uiop
parameter_list|,
name|int
name|siz
parameter_list|)
block|{
name|char
modifier|*
name|mbufcp
decl_stmt|,
modifier|*
name|uiocp
decl_stmt|;
name|int
name|xfer
decl_stmt|,
name|left
decl_stmt|,
name|len
decl_stmt|;
name|mbuf_t
name|mp
decl_stmt|;
name|long
name|uiosiz
decl_stmt|,
name|rem
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|mp
operator|=
name|nd
operator|->
name|nd_md
expr_stmt|;
name|mbufcp
operator|=
name|nd
operator|->
name|nd_dpos
expr_stmt|;
name|len
operator|=
name|NFSMTOD
argument_list|(
name|mp
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|mbuf_len
argument_list|(
name|mp
argument_list|)
operator|-
name|mbufcp
expr_stmt|;
name|rem
operator|=
name|NFSM_RNDUP
argument_list|(
name|siz
argument_list|)
operator|-
name|siz
expr_stmt|;
while|while
condition|(
name|siz
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|uiop
operator|->
name|uio_iovcnt
operator|<=
literal|0
operator|||
name|uiop
operator|->
name|uio_iov
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EBADRPC
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|left
operator|=
name|uiop
operator|->
name|uio_iov
operator|->
name|iov_len
expr_stmt|;
name|uiocp
operator|=
name|uiop
operator|->
name|uio_iov
operator|->
name|iov_base
expr_stmt|;
if|if
condition|(
name|left
operator|>
name|siz
condition|)
name|left
operator|=
name|siz
expr_stmt|;
name|uiosiz
operator|=
name|left
expr_stmt|;
while|while
condition|(
name|left
operator|>
literal|0
condition|)
block|{
while|while
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|mp
operator|=
name|mbuf_next
argument_list|(
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EBADRPC
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|mbufcp
operator|=
name|NFSMTOD
argument_list|(
name|mp
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
name|len
operator|=
name|mbuf_len
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|len
operator|>=
literal|0
argument_list|,
operator|(
literal|"len %d, corrupted mbuf?"
operator|,
name|len
operator|)
argument_list|)
expr_stmt|;
block|}
name|xfer
operator|=
operator|(
name|left
operator|>
name|len
operator|)
condition|?
name|len
else|:
name|left
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
comment|/* Not Yet.. */
if|if
condition|(
name|uiop
operator|->
name|uio_iov
operator|->
name|iov_op
operator|!=
name|NULL
condition|)
operator|(
operator|*
operator|(
name|uiop
operator|->
name|uio_iov
operator|->
name|iov_op
operator|)
operator|)
operator|(
name|mbufcp
operator|,
name|uiocp
operator|,
name|xfer
operator|)
expr_stmt|;
elseif|else
endif|#
directive|endif
if|if
condition|(
name|uiop
operator|->
name|uio_segflg
operator|==
name|UIO_SYSSPACE
condition|)
name|NFSBCOPY
argument_list|(
name|mbufcp
argument_list|,
name|uiocp
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
else|else
name|copyout
argument_list|(
name|mbufcp
argument_list|,
name|CAST_USER_ADDR_T
argument_list|(
name|uiocp
argument_list|)
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
name|left
operator|-=
name|xfer
expr_stmt|;
name|len
operator|-=
name|xfer
expr_stmt|;
name|mbufcp
operator|+=
name|xfer
expr_stmt|;
name|uiocp
operator|+=
name|xfer
expr_stmt|;
name|uiop
operator|->
name|uio_offset
operator|+=
name|xfer
expr_stmt|;
name|uiop
operator|->
name|uio_resid
operator|-=
name|xfer
expr_stmt|;
block|}
if|if
condition|(
name|uiop
operator|->
name|uio_iov
operator|->
name|iov_len
operator|<=
name|siz
condition|)
block|{
name|uiop
operator|->
name|uio_iovcnt
operator|--
expr_stmt|;
name|uiop
operator|->
name|uio_iov
operator|++
expr_stmt|;
block|}
else|else
block|{
name|uiop
operator|->
name|uio_iov
operator|->
name|iov_base
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|uiop
operator|->
name|uio_iov
operator|->
name|iov_base
operator|+
name|uiosiz
operator|)
expr_stmt|;
name|uiop
operator|->
name|uio_iov
operator|->
name|iov_len
operator|-=
name|uiosiz
expr_stmt|;
block|}
name|siz
operator|-=
name|uiosiz
expr_stmt|;
block|}
name|nd
operator|->
name|nd_dpos
operator|=
name|mbufcp
expr_stmt|;
name|nd
operator|->
name|nd_md
operator|=
name|mp
expr_stmt|;
if|if
condition|(
name|rem
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|len
operator|<
name|rem
condition|)
name|error
operator|=
name|nfsm_advance
argument_list|(
name|nd
argument_list|,
name|rem
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
name|nd
operator|->
name|nd_dpos
operator|+=
name|rem
expr_stmt|;
block|}
name|out
label|:
name|NFSEXITCODE2
argument_list|(
name|error
argument_list|,
name|nd
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !APPLE */
end_comment

begin_comment
comment|/*  * Help break down an mbuf chain by setting the first siz bytes contiguous  * pointed to by returned val.  * This is used by the macro NFSM_DISSECT for tough  * cases.  */
end_comment

begin_function
name|APPLESTATIC
name|void
modifier|*
name|nfsm_dissct
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|,
name|int
name|siz
parameter_list|,
name|int
name|how
parameter_list|)
block|{
name|mbuf_t
name|mp2
decl_stmt|;
name|int
name|siz2
decl_stmt|,
name|xfer
decl_stmt|;
name|caddr_t
name|p
decl_stmt|;
name|int
name|left
decl_stmt|;
name|caddr_t
name|retp
decl_stmt|;
name|retp
operator|=
name|NULL
expr_stmt|;
name|left
operator|=
name|NFSMTOD
argument_list|(
name|nd
operator|->
name|nd_md
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|mbuf_len
argument_list|(
name|nd
operator|->
name|nd_md
argument_list|)
operator|-
name|nd
operator|->
name|nd_dpos
expr_stmt|;
while|while
condition|(
name|left
operator|==
literal|0
condition|)
block|{
name|nd
operator|->
name|nd_md
operator|=
name|mbuf_next
argument_list|(
name|nd
operator|->
name|nd_md
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_md
operator|==
name|NULL
condition|)
return|return
operator|(
name|retp
operator|)
return|;
name|left
operator|=
name|mbuf_len
argument_list|(
name|nd
operator|->
name|nd_md
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_dpos
operator|=
name|NFSMTOD
argument_list|(
name|nd
operator|->
name|nd_md
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|left
operator|>=
name|siz
condition|)
block|{
name|retp
operator|=
name|nd
operator|->
name|nd_dpos
expr_stmt|;
name|nd
operator|->
name|nd_dpos
operator|+=
name|siz
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mbuf_next
argument_list|(
name|nd
operator|->
name|nd_md
argument_list|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|retp
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|siz
operator|>
name|ncl_mbuf_mhlen
condition|)
block|{
name|panic
argument_list|(
literal|"nfs S too big"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|MGET
argument_list|(
name|mp2
argument_list|,
name|MT_DATA
argument_list|,
name|how
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp2
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|mbuf_setnext
argument_list|(
name|mp2
argument_list|,
name|mbuf_next
argument_list|(
name|nd
operator|->
name|nd_md
argument_list|)
argument_list|)
expr_stmt|;
name|mbuf_setnext
argument_list|(
name|nd
operator|->
name|nd_md
argument_list|,
name|mp2
argument_list|)
expr_stmt|;
name|mbuf_setlen
argument_list|(
name|nd
operator|->
name|nd_md
argument_list|,
name|mbuf_len
argument_list|(
name|nd
operator|->
name|nd_md
argument_list|)
operator|-
name|left
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_md
operator|=
name|mp2
expr_stmt|;
name|retp
operator|=
name|p
operator|=
name|NFSMTOD
argument_list|(
name|mp2
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
name|NFSBCOPY
argument_list|(
name|nd
operator|->
name|nd_dpos
argument_list|,
name|p
argument_list|,
name|left
argument_list|)
expr_stmt|;
comment|/* Copy what was left */
name|siz2
operator|=
name|siz
operator|-
name|left
expr_stmt|;
name|p
operator|+=
name|left
expr_stmt|;
name|mp2
operator|=
name|mbuf_next
argument_list|(
name|mp2
argument_list|)
expr_stmt|;
comment|/* Loop around copying up the siz2 bytes */
while|while
condition|(
name|siz2
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|mp2
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|xfer
operator|=
operator|(
name|siz2
operator|>
name|mbuf_len
argument_list|(
name|mp2
argument_list|)
operator|)
condition|?
name|mbuf_len
argument_list|(
name|mp2
argument_list|)
else|:
name|siz2
expr_stmt|;
if|if
condition|(
name|xfer
operator|>
literal|0
condition|)
block|{
name|NFSBCOPY
argument_list|(
name|NFSMTOD
argument_list|(
name|mp2
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|p
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
name|NFSM_DATAP
argument_list|(
name|mp2
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
name|mbuf_setlen
argument_list|(
name|mp2
argument_list|,
name|mbuf_len
argument_list|(
name|mp2
argument_list|)
operator|-
name|xfer
argument_list|)
expr_stmt|;
name|p
operator|+=
name|xfer
expr_stmt|;
name|siz2
operator|-=
name|xfer
expr_stmt|;
block|}
if|if
condition|(
name|siz2
operator|>
literal|0
condition|)
name|mp2
operator|=
name|mbuf_next
argument_list|(
name|mp2
argument_list|)
expr_stmt|;
block|}
name|mbuf_setlen
argument_list|(
name|nd
operator|->
name|nd_md
argument_list|,
name|siz
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_md
operator|=
name|mp2
expr_stmt|;
name|nd
operator|->
name|nd_dpos
operator|=
name|NFSMTOD
argument_list|(
name|mp2
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|retp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Advance the position in the mbuf chain.  * If offs == 0, this is a no-op, but it is simpler to just return from  * here than check for offs> 0 for all calls to nfsm_advance.  * If left == -1, it should be calculated here.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsm_advance
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|,
name|int
name|offs
parameter_list|,
name|int
name|left
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|offs
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * A negative offs should be considered a serious problem. 	 */
if|if
condition|(
name|offs
operator|<
literal|0
condition|)
name|panic
argument_list|(
literal|"nfsrv_advance"
argument_list|)
expr_stmt|;
comment|/* 	 * If left == -1, calculate it here. 	 */
if|if
condition|(
name|left
operator|==
operator|-
literal|1
condition|)
name|left
operator|=
name|NFSMTOD
argument_list|(
name|nd
operator|->
name|nd_md
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|mbuf_len
argument_list|(
name|nd
operator|->
name|nd_md
argument_list|)
operator|-
name|nd
operator|->
name|nd_dpos
expr_stmt|;
comment|/* 	 * Loop around, advancing over the mbuf data. 	 */
while|while
condition|(
name|offs
operator|>
name|left
condition|)
block|{
name|offs
operator|-=
name|left
expr_stmt|;
name|nd
operator|->
name|nd_md
operator|=
name|mbuf_next
argument_list|(
name|nd
operator|->
name|nd_md
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_md
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EBADRPC
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|left
operator|=
name|mbuf_len
argument_list|(
name|nd
operator|->
name|nd_md
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_dpos
operator|=
name|NFSMTOD
argument_list|(
name|nd
operator|->
name|nd_md
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
block|}
name|nd
operator|->
name|nd_dpos
operator|+=
name|offs
expr_stmt|;
name|out
label|:
name|NFSEXITCODE
argument_list|(
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Copy a string into mbuf(s).  * Return the number of bytes output, including XDR overheads.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsm_strtom
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|,
specifier|const
name|char
modifier|*
name|cp
parameter_list|,
name|int
name|siz
parameter_list|)
block|{
name|mbuf_t
name|m2
decl_stmt|;
name|int
name|xfer
decl_stmt|,
name|left
decl_stmt|;
name|mbuf_t
name|m1
decl_stmt|;
name|int
name|rem
decl_stmt|,
name|bytesize
decl_stmt|;
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|char
modifier|*
name|cp2
decl_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|siz
argument_list|)
expr_stmt|;
name|rem
operator|=
name|NFSM_RNDUP
argument_list|(
name|siz
argument_list|)
operator|-
name|siz
expr_stmt|;
name|bytesize
operator|=
name|NFSX_UNSIGNED
operator|+
name|siz
operator|+
name|rem
expr_stmt|;
name|m2
operator|=
name|nd
operator|->
name|nd_mb
expr_stmt|;
name|cp2
operator|=
name|nd
operator|->
name|nd_bpos
expr_stmt|;
name|left
operator|=
name|M_TRAILINGSPACE
argument_list|(
name|m2
argument_list|)
expr_stmt|;
comment|/* 	 * Loop around copying the string to mbuf(s). 	 */
while|while
condition|(
name|siz
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|left
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|siz
operator|>
name|ncl_mbuf_mlen
condition|)
name|NFSMCLGET
argument_list|(
name|m1
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
else|else
name|NFSMGET
argument_list|(
name|m1
argument_list|)
expr_stmt|;
name|mbuf_setlen
argument_list|(
name|m1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mbuf_setnext
argument_list|(
name|m2
argument_list|,
name|m1
argument_list|)
expr_stmt|;
name|m2
operator|=
name|m1
expr_stmt|;
name|cp2
operator|=
name|NFSMTOD
argument_list|(
name|m2
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
name|left
operator|=
name|M_TRAILINGSPACE
argument_list|(
name|m2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|left
operator|>=
name|siz
condition|)
name|xfer
operator|=
name|siz
expr_stmt|;
else|else
name|xfer
operator|=
name|left
expr_stmt|;
name|NFSBCOPY
argument_list|(
name|cp
argument_list|,
name|cp2
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|xfer
expr_stmt|;
name|mbuf_setlen
argument_list|(
name|m2
argument_list|,
name|mbuf_len
argument_list|(
name|m2
argument_list|)
operator|+
name|xfer
argument_list|)
expr_stmt|;
name|siz
operator|-=
name|xfer
expr_stmt|;
name|left
operator|-=
name|xfer
expr_stmt|;
if|if
condition|(
name|siz
operator|==
literal|0
operator|&&
name|rem
condition|)
block|{
if|if
condition|(
name|left
operator|<
name|rem
condition|)
name|panic
argument_list|(
literal|"nfsm_strtom"
argument_list|)
expr_stmt|;
name|NFSBZERO
argument_list|(
name|cp2
operator|+
name|xfer
argument_list|,
name|rem
argument_list|)
expr_stmt|;
name|mbuf_setlen
argument_list|(
name|m2
argument_list|,
name|mbuf_len
argument_list|(
name|m2
argument_list|)
operator|+
name|rem
argument_list|)
expr_stmt|;
block|}
block|}
name|nd
operator|->
name|nd_mb
operator|=
name|m2
expr_stmt|;
name|nd
operator|->
name|nd_bpos
operator|=
name|NFSMTOD
argument_list|(
name|m2
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|mbuf_len
argument_list|(
name|m2
argument_list|)
expr_stmt|;
return|return
operator|(
name|bytesize
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called once to initialize data structures...  */
end_comment

begin_function
name|APPLESTATIC
name|void
name|newnfs_init
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|int
name|nfs_inited
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|nfs_inited
condition|)
return|return;
name|nfs_inited
operator|=
literal|1
expr_stmt|;
name|newnfs_true
operator|=
name|txdr_unsigned
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|newnfs_false
operator|=
name|txdr_unsigned
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|newnfs_xdrneg1
operator|=
name|txdr_unsigned
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|nfscl_ticks
operator|=
operator|(
name|hz
operator|*
name|NFS_TICKINTVL
operator|+
literal|500
operator|)
operator|/
literal|1000
expr_stmt|;
if|if
condition|(
name|nfscl_ticks
operator|<
literal|1
condition|)
name|nfscl_ticks
operator|=
literal|1
expr_stmt|;
name|NFSSETBOOTTIME
argument_list|(
name|nfsboottime
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize reply list and start timer 	 */
name|TAILQ_INIT
argument_list|(
operator|&
name|nfsd_reqq
argument_list|)
expr_stmt|;
name|NFS_TIMERINIT
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Put a file handle in an mbuf list.  * If the size argument == 0, just use the default size.  * set_true == 1 if there should be an newnfs_true prepended on the file handle.  * Return the number of bytes output, including XDR overhead.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsm_fhtom
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|,
name|u_int8_t
modifier|*
name|fhp
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|set_true
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|u_int8_t
modifier|*
name|cp
decl_stmt|;
name|int
name|fullsiz
decl_stmt|,
name|rem
decl_stmt|,
name|bytesize
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
name|size
operator|=
name|NFSX_MYFH
expr_stmt|;
switch|switch
condition|(
name|nd
operator|->
name|nd_flag
operator|&
operator|(
name|ND_NFSV2
operator||
name|ND_NFSV3
operator||
name|ND_NFSV4
operator|)
condition|)
block|{
case|case
name|ND_NFSV2
case|:
if|if
condition|(
name|size
operator|>
name|NFSX_V2FH
condition|)
name|panic
argument_list|(
literal|"fh size> NFSX_V2FH for NFSv2"
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|cp
argument_list|,
name|u_int8_t
operator|*
argument_list|,
name|NFSX_V2FH
argument_list|)
expr_stmt|;
name|NFSBCOPY
argument_list|(
name|fhp
argument_list|,
name|cp
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
name|NFSX_V2FH
condition|)
name|NFSBZERO
argument_list|(
name|cp
operator|+
name|size
argument_list|,
name|NFSX_V2FH
operator|-
name|size
argument_list|)
expr_stmt|;
name|bytesize
operator|=
name|NFSX_V2FH
expr_stmt|;
break|break;
case|case
name|ND_NFSV3
case|:
case|case
name|ND_NFSV4
case|:
name|fullsiz
operator|=
name|NFSM_RNDUP
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|rem
operator|=
name|fullsiz
operator|-
name|size
expr_stmt|;
if|if
condition|(
name|set_true
condition|)
block|{
name|bytesize
operator|=
literal|2
operator|*
name|NFSX_UNSIGNED
operator|+
name|fullsiz
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|newnfs_true
expr_stmt|;
block|}
else|else
block|{
name|bytesize
operator|=
name|NFSX_UNSIGNED
operator|+
name|fullsiz
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|nfsm_strtom
argument_list|(
name|nd
argument_list|,
name|fhp
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
block|}
empty_stmt|;
return|return
operator|(
name|bytesize
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This function compares two net addresses by family and returns TRUE  * if they are the same host.  * If there is any doubt, return FALSE.  * The AF_INET family is handled as a special case so that address mbufs  * don't need to be saved to store "struct in_addr", which is only 4 bytes.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsaddr_match
parameter_list|(
name|int
name|family
parameter_list|,
name|union
name|nethostaddr
modifier|*
name|haddr
parameter_list|,
name|NFSSOCKADDR_T
name|nam
parameter_list|)
block|{
name|struct
name|sockaddr_in
modifier|*
name|inetaddr
decl_stmt|;
switch|switch
condition|(
name|family
condition|)
block|{
case|case
name|AF_INET
case|:
name|inetaddr
operator|=
name|NFSSOCKADDR
argument_list|(
name|nam
argument_list|,
expr|struct
name|sockaddr_in
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|inetaddr
operator|->
name|sin_family
operator|==
name|AF_INET
operator|&&
name|inetaddr
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
name|haddr
operator|->
name|had_inet
operator|.
name|s_addr
condition|)
return|return
operator|(
literal|1
operator|)
return|;
break|break;
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
block|{
name|struct
name|sockaddr_in6
modifier|*
name|inetaddr6
decl_stmt|;
name|inetaddr6
operator|=
name|NFSSOCKADDR
argument_list|(
name|nam
argument_list|,
expr|struct
name|sockaddr_in6
operator|*
argument_list|)
expr_stmt|;
comment|/* XXX - should test sin6_scope_id ? */
if|if
condition|(
name|inetaddr6
operator|->
name|sin6_family
operator|==
name|AF_INET6
operator|&&
name|IN6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|inetaddr6
operator|->
name|sin6_addr
argument_list|,
operator|&
name|haddr
operator|->
name|had_inet6
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
break|break;
endif|#
directive|endif
block|}
empty_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Similar to the above, but takes to NFSSOCKADDR_T args.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsaddr2_match
parameter_list|(
name|NFSSOCKADDR_T
name|nam1
parameter_list|,
name|NFSSOCKADDR_T
name|nam2
parameter_list|)
block|{
name|struct
name|sockaddr_in
modifier|*
name|addr1
decl_stmt|,
modifier|*
name|addr2
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|inaddr
decl_stmt|;
name|inaddr
operator|=
name|NFSSOCKADDR
argument_list|(
name|nam1
argument_list|,
expr|struct
name|sockaddr
operator|*
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|inaddr
operator|->
name|sa_family
condition|)
block|{
case|case
name|AF_INET
case|:
name|addr1
operator|=
name|NFSSOCKADDR
argument_list|(
name|nam1
argument_list|,
expr|struct
name|sockaddr_in
operator|*
argument_list|)
expr_stmt|;
name|addr2
operator|=
name|NFSSOCKADDR
argument_list|(
name|nam2
argument_list|,
expr|struct
name|sockaddr_in
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr2
operator|->
name|sin_family
operator|==
name|AF_INET
operator|&&
name|addr1
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
name|addr2
operator|->
name|sin_addr
operator|.
name|s_addr
condition|)
return|return
operator|(
literal|1
operator|)
return|;
break|break;
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
block|{
name|struct
name|sockaddr_in6
modifier|*
name|inet6addr1
decl_stmt|,
modifier|*
name|inet6addr2
decl_stmt|;
name|inet6addr1
operator|=
name|NFSSOCKADDR
argument_list|(
name|nam1
argument_list|,
expr|struct
name|sockaddr_in6
operator|*
argument_list|)
expr_stmt|;
name|inet6addr2
operator|=
name|NFSSOCKADDR
argument_list|(
name|nam2
argument_list|,
expr|struct
name|sockaddr_in6
operator|*
argument_list|)
expr_stmt|;
comment|/* XXX - should test sin6_scope_id ? */
if|if
condition|(
name|inet6addr2
operator|->
name|sin6_family
operator|==
name|AF_INET6
operator|&&
name|IN6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|inet6addr1
operator|->
name|sin6_addr
argument_list|,
operator|&
name|inet6addr2
operator|->
name|sin6_addr
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
break|break;
endif|#
directive|endif
block|}
empty_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Trim the stuff already dissected off the mbuf list.  */
end_comment

begin_function
name|APPLESTATIC
name|void
name|newnfs_trimleading
parameter_list|(
name|nd
parameter_list|)
name|struct
name|nfsrv_descript
modifier|*
name|nd
decl_stmt|;
block|{
name|mbuf_t
name|m
decl_stmt|,
name|n
decl_stmt|;
name|int
name|offs
decl_stmt|;
comment|/* 	 * First, free up leading mbufs. 	 */
if|if
condition|(
name|nd
operator|->
name|nd_mrep
operator|!=
name|nd
operator|->
name|nd_md
condition|)
block|{
name|m
operator|=
name|nd
operator|->
name|nd_mrep
expr_stmt|;
while|while
condition|(
name|mbuf_next
argument_list|(
name|m
argument_list|)
operator|!=
name|nd
operator|->
name|nd_md
condition|)
block|{
if|if
condition|(
name|mbuf_next
argument_list|(
name|m
argument_list|)
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"nfsm trim leading"
argument_list|)
expr_stmt|;
name|m
operator|=
name|mbuf_next
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|mbuf_setnext
argument_list|(
name|m
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
block|}
name|m
operator|=
name|nd
operator|->
name|nd_md
expr_stmt|;
comment|/* 	 * Now, adjust this mbuf, based on nd_dpos. 	 */
name|offs
operator|=
name|nd
operator|->
name|nd_dpos
operator|-
name|NFSMTOD
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|offs
operator|==
name|mbuf_len
argument_list|(
name|m
argument_list|)
condition|)
block|{
name|n
operator|=
name|m
expr_stmt|;
name|m
operator|=
name|mbuf_next
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"nfsm trim leading2"
argument_list|)
expr_stmt|;
name|mbuf_setnext
argument_list|(
name|n
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mbuf_freem
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|offs
operator|>
literal|0
condition|)
block|{
name|mbuf_setlen
argument_list|(
name|m
argument_list|,
name|mbuf_len
argument_list|(
name|m
argument_list|)
operator|-
name|offs
argument_list|)
expr_stmt|;
name|NFSM_DATAP
argument_list|(
name|m
argument_list|,
name|offs
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|offs
operator|<
literal|0
condition|)
name|panic
argument_list|(
literal|"nfsm trimleading offs"
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_mrep
operator|=
name|m
expr_stmt|;
name|nd
operator|->
name|nd_md
operator|=
name|m
expr_stmt|;
name|nd
operator|->
name|nd_dpos
operator|=
name|NFSMTOD
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Trim trailing data off the mbuf list being built.  */
end_comment

begin_function
name|APPLESTATIC
name|void
name|newnfs_trimtrailing
parameter_list|(
name|nd
parameter_list|,
name|mb
parameter_list|,
name|bpos
parameter_list|)
name|struct
name|nfsrv_descript
modifier|*
name|nd
decl_stmt|;
name|mbuf_t
name|mb
decl_stmt|;
name|caddr_t
name|bpos
decl_stmt|;
block|{
if|if
condition|(
name|mbuf_next
argument_list|(
name|mb
argument_list|)
condition|)
block|{
name|mbuf_freem
argument_list|(
name|mbuf_next
argument_list|(
name|mb
argument_list|)
argument_list|)
expr_stmt|;
name|mbuf_setnext
argument_list|(
name|mb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|mbuf_setlen
argument_list|(
name|mb
argument_list|,
name|bpos
operator|-
name|NFSMTOD
argument_list|(
name|mb
argument_list|,
name|caddr_t
argument_list|)
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_mb
operator|=
name|mb
expr_stmt|;
name|nd
operator|->
name|nd_bpos
operator|=
name|bpos
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Dissect a file handle on the client.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsm_getfh
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|,
name|struct
name|nfsfh
modifier|*
modifier|*
name|nfhpp
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|struct
name|nfsfh
modifier|*
name|nfhp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|len
decl_stmt|;
operator|*
name|nfhpp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
operator|(
name|ND_NFSV3
operator||
name|ND_NFSV4
operator|)
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
operator|)
operator|<=
literal|0
operator|||
name|len
operator|>
name|NFSX_FHMAX
condition|)
block|{
name|error
operator|=
name|EBADRPC
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
block|}
else|else
name|len
operator|=
name|NFSX_V2FH
expr_stmt|;
name|MALLOC
argument_list|(
name|nfhp
argument_list|,
expr|struct
name|nfsfh
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nfsfh
argument_list|)
operator|+
name|len
argument_list|,
name|M_NFSFH
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfsrv_mtostr
argument_list|(
name|nd
argument_list|,
name|nfhp
operator|->
name|nfh_fh
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|nfhp
argument_list|,
name|M_NFSFH
argument_list|)
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
name|nfhp
operator|->
name|nfh_len
operator|=
name|len
expr_stmt|;
operator|*
name|nfhpp
operator|=
name|nfhp
expr_stmt|;
name|nfsmout
label|:
name|NFSEXITCODE2
argument_list|(
name|error
argument_list|,
name|nd
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Break down the nfsv4 acl.  * If the aclp == NULL or won't fit in an acl, just discard the acl info.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrv_dissectacl
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|,
name|NFSACL_T
modifier|*
name|aclp
parameter_list|,
name|int
modifier|*
name|aclerrp
parameter_list|,
name|int
modifier|*
name|aclsizep
parameter_list|,
name|__unused
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|int
name|i
decl_stmt|,
name|aclsize
decl_stmt|;
name|int
name|acecnt
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|,
name|aceerr
init|=
literal|0
decl_stmt|,
name|acesize
decl_stmt|;
operator|*
name|aclerrp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|aclp
condition|)
name|aclp
operator|->
name|acl_cnt
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Parse out the ace entries and expect them to conform to 	 * what can be supported by R/W/X bits. 	 */
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|aclsize
operator|=
name|NFSX_UNSIGNED
expr_stmt|;
name|acecnt
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
name|acecnt
operator|>
name|ACL_MAX_ENTRIES
condition|)
name|aceerr
operator|=
name|NFSERR_ATTRNOTSUPP
expr_stmt|;
if|if
condition|(
name|nfsrv_useacl
operator|==
literal|0
condition|)
name|aceerr
operator|=
name|NFSERR_ATTRNOTSUPP
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|acecnt
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|aclp
operator|&&
operator|!
name|aceerr
condition|)
name|error
operator|=
name|nfsrv_dissectace
argument_list|(
name|nd
argument_list|,
operator|&
name|aclp
operator|->
name|acl_entry
index|[
name|i
index|]
argument_list|,
operator|&
name|aceerr
argument_list|,
operator|&
name|acesize
argument_list|,
name|p
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|nfsrv_skipace
argument_list|(
name|nd
argument_list|,
operator|&
name|acesize
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
name|aclsize
operator|+=
name|acesize
expr_stmt|;
block|}
if|if
condition|(
name|aclp
operator|&&
operator|!
name|aceerr
condition|)
name|aclp
operator|->
name|acl_cnt
operator|=
name|acecnt
expr_stmt|;
if|if
condition|(
name|aceerr
condition|)
operator|*
name|aclerrp
operator|=
name|aceerr
expr_stmt|;
if|if
condition|(
name|aclsizep
condition|)
operator|*
name|aclsizep
operator|=
name|aclsize
expr_stmt|;
name|nfsmout
label|:
name|NFSEXITCODE2
argument_list|(
name|error
argument_list|,
name|nd
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Skip over an NFSv4 ace entry. Just dissect the xdr and discard it.  */
end_comment

begin_function
specifier|static
name|int
name|nfsrv_skipace
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|,
name|int
modifier|*
name|acesizep
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|int
name|error
decl_stmt|,
name|len
init|=
literal|0
decl_stmt|;
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|4
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|len
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
operator|(
name|tl
operator|+
literal|3
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfsm_advance
argument_list|(
name|nd
argument_list|,
name|NFSM_RNDUP
argument_list|(
name|len
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|nfsmout
label|:
operator|*
name|acesizep
operator|=
name|NFSM_RNDUP
argument_list|(
name|len
argument_list|)
operator|+
operator|(
literal|4
operator|*
name|NFSX_UNSIGNED
operator|)
expr_stmt|;
name|NFSEXITCODE2
argument_list|(
name|error
argument_list|,
name|nd
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get attribute bits from an mbuf list.  * Returns EBADRPC for a parsing error, 0 otherwise.  * If the clearinvalid flag is set, clear the bits not supported.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrv_getattrbits
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|,
name|nfsattrbit_t
modifier|*
name|attrbitp
parameter_list|,
name|int
modifier|*
name|cntp
parameter_list|,
name|int
modifier|*
name|retnotsupp
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|int
name|cnt
decl_stmt|,
name|i
decl_stmt|,
name|outcnt
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|cnt
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|<
literal|0
condition|)
block|{
name|error
operator|=
name|NFSERR_BADXDR
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
if|if
condition|(
name|cnt
operator|>
name|NFSATTRBIT_MAXWORDS
condition|)
name|outcnt
operator|=
name|NFSATTRBIT_MAXWORDS
expr_stmt|;
else|else
name|outcnt
operator|=
name|cnt
expr_stmt|;
name|NFSZERO_ATTRBIT
argument_list|(
name|attrbitp
argument_list|)
expr_stmt|;
if|if
condition|(
name|outcnt
operator|>
literal|0
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|outcnt
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|outcnt
condition|;
name|i
operator|++
control|)
name|attrbitp
operator|->
name|bits
index|[
name|i
index|]
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|cnt
operator|-
name|outcnt
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|retnotsupp
operator|!=
name|NULL
operator|&&
operator|*
name|tl
operator|!=
literal|0
condition|)
operator|*
name|retnotsupp
operator|=
name|NFSERR_ATTRNOTSUPP
expr_stmt|;
block|}
if|if
condition|(
name|cntp
condition|)
operator|*
name|cntp
operator|=
name|NFSX_UNSIGNED
operator|+
operator|(
name|cnt
operator|*
name|NFSX_UNSIGNED
operator|)
expr_stmt|;
name|nfsmout
label|:
name|NFSEXITCODE2
argument_list|(
name|error
argument_list|,
name|nd
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get the attributes for V4.  * If the compare flag is true, test for any attribute changes,  * otherwise return the attribute values.  * These attributes cover fields in "struct vattr", "struct statfs",  * "struct nfsfsinfo", the file handle and the lease duration.  * The value of retcmpp is set to 1 if all attributes are the same,  * and 0 otherwise.  * Returns EBADRPC if it can't be parsed, 0 otherwise.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsv4_loadattr
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|,
name|vnode_t
name|vp
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|nap
parameter_list|,
name|struct
name|nfsfh
modifier|*
modifier|*
name|nfhpp
parameter_list|,
name|fhandle_t
modifier|*
name|fhp
parameter_list|,
name|int
name|fhsize
parameter_list|,
name|struct
name|nfsv3_pathconf
modifier|*
name|pc
parameter_list|,
name|struct
name|statfs
modifier|*
name|sbp
parameter_list|,
name|struct
name|nfsstatfs
modifier|*
name|sfp
parameter_list|,
name|struct
name|nfsfsinfo
modifier|*
name|fsp
parameter_list|,
name|NFSACL_T
modifier|*
name|aclp
parameter_list|,
name|int
name|compare
parameter_list|,
name|int
modifier|*
name|retcmpp
parameter_list|,
name|u_int32_t
modifier|*
name|leasep
parameter_list|,
name|u_int32_t
modifier|*
name|rderrp
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|l
init|=
literal|0
decl_stmt|,
name|m
decl_stmt|,
name|bitpos
decl_stmt|,
name|attrsum
init|=
literal|0
decl_stmt|;
name|int
name|error
decl_stmt|,
name|tfhsize
decl_stmt|,
name|aceerr
decl_stmt|,
name|attrsize
decl_stmt|,
name|cnt
decl_stmt|,
name|retnotsup
decl_stmt|;
name|u_char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cp2
decl_stmt|,
name|namestr
index|[
name|NFSV4_SMALLSTR
operator|+
literal|1
index|]
decl_stmt|;
name|nfsattrbit_t
name|attrbits
decl_stmt|,
name|retattrbits
decl_stmt|,
name|checkattrbits
decl_stmt|;
name|struct
name|nfsfh
modifier|*
name|tnfhp
decl_stmt|;
name|struct
name|nfsreferral
modifier|*
name|refp
decl_stmt|;
name|u_quad_t
name|tquad
decl_stmt|;
name|nfsquad_t
name|tnfsquad
decl_stmt|;
name|struct
name|timespec
name|temptime
decl_stmt|;
name|uid_t
name|uid
decl_stmt|;
name|gid_t
name|gid
decl_stmt|;
name|long
name|fid
decl_stmt|;
name|u_int32_t
name|freenum
init|=
literal|0
decl_stmt|,
name|tuint
decl_stmt|;
name|u_int64_t
name|uquad
init|=
literal|0
decl_stmt|,
name|thyp
decl_stmt|,
name|thyp2
decl_stmt|;
ifdef|#
directive|ifdef
name|QUOTA
name|struct
name|dqblk
name|dqb
decl_stmt|;
name|uid_t
name|savuid
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|compare
condition|)
block|{
name|retnotsup
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|nfsrv_getattrbits
argument_list|(
name|nd
argument_list|,
operator|&
name|attrbits
argument_list|,
name|NULL
argument_list|,
operator|&
name|retnotsup
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|nfsrv_getattrbits
argument_list|(
name|nd
argument_list|,
operator|&
name|attrbits
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
if|if
condition|(
name|compare
condition|)
block|{
operator|*
name|retcmpp
operator|=
name|retnotsup
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Just set default values to some of the important ones. 		 */
if|if
condition|(
name|nap
operator|!=
name|NULL
condition|)
block|{
name|nap
operator|->
name|na_type
operator|=
name|VREG
expr_stmt|;
name|nap
operator|->
name|na_mode
operator|=
literal|0
expr_stmt|;
name|nap
operator|->
name|na_rdev
operator|=
operator|(
name|NFSDEV_T
operator|)
literal|0
expr_stmt|;
name|nap
operator|->
name|na_mtime
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|nap
operator|->
name|na_mtime
operator|.
name|tv_nsec
operator|=
literal|0
expr_stmt|;
name|nap
operator|->
name|na_gen
operator|=
literal|0
expr_stmt|;
name|nap
operator|->
name|na_flags
operator|=
literal|0
expr_stmt|;
name|nap
operator|->
name|na_blocksize
operator|=
name|NFS_FABLKSIZE
expr_stmt|;
block|}
if|if
condition|(
name|sbp
operator|!=
name|NULL
condition|)
block|{
name|sbp
operator|->
name|f_bsize
operator|=
name|NFS_FABLKSIZE
expr_stmt|;
name|sbp
operator|->
name|f_blocks
operator|=
literal|0
expr_stmt|;
name|sbp
operator|->
name|f_bfree
operator|=
literal|0
expr_stmt|;
name|sbp
operator|->
name|f_bavail
operator|=
literal|0
expr_stmt|;
name|sbp
operator|->
name|f_files
operator|=
literal|0
expr_stmt|;
name|sbp
operator|->
name|f_ffree
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|fsp
operator|!=
name|NULL
condition|)
block|{
name|fsp
operator|->
name|fs_rtmax
operator|=
literal|8192
expr_stmt|;
name|fsp
operator|->
name|fs_rtpref
operator|=
literal|8192
expr_stmt|;
name|fsp
operator|->
name|fs_maxname
operator|=
name|NFS_MAXNAMLEN
expr_stmt|;
name|fsp
operator|->
name|fs_wtmax
operator|=
literal|8192
expr_stmt|;
name|fsp
operator|->
name|fs_wtpref
operator|=
literal|8192
expr_stmt|;
name|fsp
operator|->
name|fs_wtmult
operator|=
name|NFS_FABLKSIZE
expr_stmt|;
name|fsp
operator|->
name|fs_dtpref
operator|=
literal|8192
expr_stmt|;
name|fsp
operator|->
name|fs_maxfilesize
operator|=
literal|0xffffffffffffffffull
expr_stmt|;
name|fsp
operator|->
name|fs_timedelta
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|fsp
operator|->
name|fs_timedelta
operator|.
name|tv_nsec
operator|=
literal|1
expr_stmt|;
name|fsp
operator|->
name|fs_properties
operator|=
operator|(
name|NFSV3_FSFLINK
operator||
name|NFSV3_FSFSYMLINK
operator||
name|NFSV3_FSFHOMOGENEOUS
operator||
name|NFSV3_FSFCANSETTIME
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|pc
operator|!=
name|NULL
condition|)
block|{
name|pc
operator|->
name|pc_linkmax
operator|=
name|LINK_MAX
expr_stmt|;
name|pc
operator|->
name|pc_namemax
operator|=
name|NAME_MAX
expr_stmt|;
name|pc
operator|->
name|pc_notrunc
operator|=
literal|0
expr_stmt|;
name|pc
operator|->
name|pc_chownrestricted
operator|=
literal|0
expr_stmt|;
name|pc
operator|->
name|pc_caseinsensitive
operator|=
literal|0
expr_stmt|;
name|pc
operator|->
name|pc_casepreserving
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* 	 * Loop around getting the attributes. 	 */
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|attrsize
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
for|for
control|(
name|bitpos
operator|=
literal|0
init|;
name|bitpos
operator|<
name|NFSATTRBIT_MAX
condition|;
name|bitpos
operator|++
control|)
block|{
if|if
condition|(
name|attrsum
operator|>
name|attrsize
condition|)
block|{
name|error
operator|=
name|NFSERR_BADXDR
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
if|if
condition|(
name|NFSISSET_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|,
name|bitpos
argument_list|)
condition|)
switch|switch
condition|(
name|bitpos
condition|)
block|{
case|case
name|NFSATTRBIT_SUPPORTEDATTRS
case|:
name|retnotsup
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|compare
operator|||
name|nap
operator|==
name|NULL
condition|)
name|error
operator|=
name|nfsrv_getattrbits
argument_list|(
name|nd
argument_list|,
operator|&
name|retattrbits
argument_list|,
operator|&
name|cnt
argument_list|,
operator|&
name|retnotsup
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|nfsrv_getattrbits
argument_list|(
name|nd
argument_list|,
operator|&
name|nap
operator|->
name|na_suppattr
argument_list|,
operator|&
name|cnt
argument_list|,
operator|&
name|retnotsup
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
if|if
condition|(
name|compare
operator|&&
operator|!
operator|(
operator|*
name|retcmpp
operator|)
condition|)
block|{
name|NFSSETSUPP_ATTRBIT
argument_list|(
operator|&
name|checkattrbits
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NFSEQUAL_ATTRBIT
argument_list|(
operator|&
name|retattrbits
argument_list|,
operator|&
name|checkattrbits
argument_list|)
operator|||
name|retnotsup
condition|)
operator|*
name|retcmpp
operator|=
name|NFSERR_NOTSAME
expr_stmt|;
block|}
name|attrsum
operator|+=
name|cnt
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_TYPE
case|:
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|retcmpp
operator|)
condition|)
block|{
if|if
condition|(
name|nap
operator|->
name|na_type
operator|!=
name|nfsv34tov_type
argument_list|(
operator|*
name|tl
argument_list|)
condition|)
operator|*
name|retcmpp
operator|=
name|NFSERR_NOTSAME
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|nap
operator|!=
name|NULL
condition|)
block|{
name|nap
operator|->
name|na_type
operator|=
name|nfsv34tov_type
argument_list|(
operator|*
name|tl
argument_list|)
expr_stmt|;
block|}
name|attrsum
operator|+=
name|NFSX_UNSIGNED
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_FHEXPIRETYPE
case|:
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare
operator|&&
operator|!
operator|(
operator|*
name|retcmpp
operator|)
condition|)
block|{
if|if
condition|(
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
operator|!=
name|NFSV4FHTYPE_PERSISTENT
condition|)
operator|*
name|retcmpp
operator|=
name|NFSERR_NOTSAME
expr_stmt|;
block|}
name|attrsum
operator|+=
name|NFSX_UNSIGNED
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_CHANGE
case|:
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_HYPER
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|retcmpp
operator|)
condition|)
block|{
if|if
condition|(
name|nap
operator|->
name|na_filerev
operator|!=
name|fxdr_hyper
argument_list|(
name|tl
argument_list|)
condition|)
operator|*
name|retcmpp
operator|=
name|NFSERR_NOTSAME
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|nap
operator|!=
name|NULL
condition|)
block|{
name|nap
operator|->
name|na_filerev
operator|=
name|fxdr_hyper
argument_list|(
name|tl
argument_list|)
expr_stmt|;
block|}
name|attrsum
operator|+=
name|NFSX_HYPER
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_SIZE
case|:
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_HYPER
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|retcmpp
operator|)
condition|)
block|{
if|if
condition|(
name|nap
operator|->
name|na_size
operator|!=
name|fxdr_hyper
argument_list|(
name|tl
argument_list|)
condition|)
operator|*
name|retcmpp
operator|=
name|NFSERR_NOTSAME
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|nap
operator|!=
name|NULL
condition|)
block|{
name|nap
operator|->
name|na_size
operator|=
name|fxdr_hyper
argument_list|(
name|tl
argument_list|)
expr_stmt|;
block|}
name|attrsum
operator|+=
name|NFSX_HYPER
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_LINKSUPPORT
case|:
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|retcmpp
operator|)
condition|)
block|{
if|if
condition|(
name|fsp
operator|->
name|fs_properties
operator|&
name|NFSV3_FSFLINK
condition|)
block|{
if|if
condition|(
operator|*
name|tl
operator|==
name|newnfs_false
condition|)
operator|*
name|retcmpp
operator|=
name|NFSERR_NOTSAME
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|tl
operator|==
name|newnfs_true
condition|)
operator|*
name|retcmpp
operator|=
name|NFSERR_NOTSAME
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|fsp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
name|tl
operator|==
name|newnfs_true
condition|)
name|fsp
operator|->
name|fs_properties
operator||=
name|NFSV3_FSFLINK
expr_stmt|;
else|else
name|fsp
operator|->
name|fs_properties
operator|&=
operator|~
name|NFSV3_FSFLINK
expr_stmt|;
block|}
name|attrsum
operator|+=
name|NFSX_UNSIGNED
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_SYMLINKSUPPORT
case|:
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|retcmpp
operator|)
condition|)
block|{
if|if
condition|(
name|fsp
operator|->
name|fs_properties
operator|&
name|NFSV3_FSFSYMLINK
condition|)
block|{
if|if
condition|(
operator|*
name|tl
operator|==
name|newnfs_false
condition|)
operator|*
name|retcmpp
operator|=
name|NFSERR_NOTSAME
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|tl
operator|==
name|newnfs_true
condition|)
operator|*
name|retcmpp
operator|=
name|NFSERR_NOTSAME
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|fsp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
name|tl
operator|==
name|newnfs_true
condition|)
name|fsp
operator|->
name|fs_properties
operator||=
name|NFSV3_FSFSYMLINK
expr_stmt|;
else|else
name|fsp
operator|->
name|fs_properties
operator|&=
operator|~
name|NFSV3_FSFSYMLINK
expr_stmt|;
block|}
name|attrsum
operator|+=
name|NFSX_UNSIGNED
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_NAMEDATTR
case|:
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare
operator|&&
operator|!
operator|(
operator|*
name|retcmpp
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|tl
operator|!=
name|newnfs_false
condition|)
operator|*
name|retcmpp
operator|=
name|NFSERR_NOTSAME
expr_stmt|;
block|}
name|attrsum
operator|+=
name|NFSX_UNSIGNED
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_FSID
case|:
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|4
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|thyp
operator|=
name|fxdr_hyper
argument_list|(
name|tl
argument_list|)
expr_stmt|;
name|tl
operator|+=
literal|2
expr_stmt|;
name|thyp2
operator|=
name|fxdr_hyper
argument_list|(
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare
condition|)
block|{
if|if
condition|(
operator|*
name|retcmpp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|thyp
operator|!=
operator|(
name|u_int64_t
operator|)
name|vfs_statfs
argument_list|(
name|vnode_mount
argument_list|(
name|vp
argument_list|)
argument_list|)
operator|->
name|f_fsid
operator|.
name|val
index|[
literal|0
index|]
operator|||
name|thyp2
operator|!=
operator|(
name|u_int64_t
operator|)
name|vfs_statfs
argument_list|(
name|vnode_mount
argument_list|(
name|vp
argument_list|)
argument_list|)
operator|->
name|f_fsid
operator|.
name|val
index|[
literal|1
index|]
condition|)
operator|*
name|retcmpp
operator|=
name|NFSERR_NOTSAME
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|nap
operator|!=
name|NULL
condition|)
block|{
name|nap
operator|->
name|na_filesid
index|[
literal|0
index|]
operator|=
name|thyp
expr_stmt|;
name|nap
operator|->
name|na_filesid
index|[
literal|1
index|]
operator|=
name|thyp2
expr_stmt|;
block|}
name|attrsum
operator|+=
operator|(
literal|4
operator|*
name|NFSX_UNSIGNED
operator|)
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_UNIQUEHANDLES
case|:
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare
operator|&&
operator|!
operator|(
operator|*
name|retcmpp
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|tl
operator|!=
name|newnfs_true
condition|)
operator|*
name|retcmpp
operator|=
name|NFSERR_NOTSAME
expr_stmt|;
block|}
name|attrsum
operator|+=
name|NFSX_UNSIGNED
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_LEASETIME
case|:
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare
condition|)
block|{
if|if
condition|(
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
operator|!=
name|nfsrv_lease
operator|&&
operator|!
operator|(
operator|*
name|retcmpp
operator|)
condition|)
operator|*
name|retcmpp
operator|=
name|NFSERR_NOTSAME
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|leasep
operator|!=
name|NULL
condition|)
block|{
operator|*
name|leasep
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
block|}
name|attrsum
operator|+=
name|NFSX_UNSIGNED
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_RDATTRERROR
case|:
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|retcmpp
operator|)
condition|)
operator|*
name|retcmpp
operator|=
name|NFSERR_INVAL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rderrp
operator|!=
name|NULL
condition|)
block|{
operator|*
name|rderrp
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
block|}
name|attrsum
operator|+=
name|NFSX_UNSIGNED
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_ACL
case|:
if|if
condition|(
name|compare
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|retcmpp
operator|)
condition|)
block|{
if|if
condition|(
name|nfsrv_useacl
condition|)
block|{
name|NFSACL_T
modifier|*
name|naclp
decl_stmt|;
name|naclp
operator|=
name|acl_alloc
argument_list|(
name|M_WAITOK
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfsrv_dissectacl
argument_list|(
name|nd
argument_list|,
name|naclp
argument_list|,
operator|&
name|aceerr
argument_list|,
operator|&
name|cnt
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|acl_free
argument_list|(
name|naclp
argument_list|)
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
if|if
condition|(
name|aceerr
operator|||
name|aclp
operator|==
name|NULL
operator|||
name|nfsrv_compareacl
argument_list|(
name|aclp
argument_list|,
name|naclp
argument_list|)
condition|)
operator|*
name|retcmpp
operator|=
name|NFSERR_NOTSAME
expr_stmt|;
name|acl_free
argument_list|(
name|naclp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|nfsrv_dissectacl
argument_list|(
name|nd
argument_list|,
name|NULL
argument_list|,
operator|&
name|aceerr
argument_list|,
operator|&
name|cnt
argument_list|,
name|p
argument_list|)
expr_stmt|;
operator|*
name|retcmpp
operator|=
name|NFSERR_ATTRNOTSUPP
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|vp
operator|!=
name|NULL
operator|&&
name|aclp
operator|!=
name|NULL
condition|)
name|error
operator|=
name|nfsrv_dissectacl
argument_list|(
name|nd
argument_list|,
name|aclp
argument_list|,
operator|&
name|aceerr
argument_list|,
operator|&
name|cnt
argument_list|,
name|p
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|nfsrv_dissectacl
argument_list|(
name|nd
argument_list|,
name|NULL
argument_list|,
operator|&
name|aceerr
argument_list|,
operator|&
name|cnt
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
block|}
name|attrsum
operator|+=
name|cnt
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_ACLSUPPORT
case|:
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare
operator|&&
operator|!
operator|(
operator|*
name|retcmpp
operator|)
condition|)
block|{
if|if
condition|(
name|nfsrv_useacl
condition|)
block|{
if|if
condition|(
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
name|tl
argument_list|)
operator|!=
name|NFSV4ACE_SUPTYPES
condition|)
operator|*
name|retcmpp
operator|=
name|NFSERR_NOTSAME
expr_stmt|;
block|}
else|else
block|{
operator|*
name|retcmpp
operator|=
name|NFSERR_ATTRNOTSUPP
expr_stmt|;
block|}
block|}
name|attrsum
operator|+=
name|NFSX_UNSIGNED
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_ARCHIVE
case|:
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare
operator|&&
operator|!
operator|(
operator|*
name|retcmpp
operator|)
condition|)
operator|*
name|retcmpp
operator|=
name|NFSERR_ATTRNOTSUPP
expr_stmt|;
name|attrsum
operator|+=
name|NFSX_UNSIGNED
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_CANSETTIME
case|:
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|retcmpp
operator|)
condition|)
block|{
if|if
condition|(
name|fsp
operator|->
name|fs_properties
operator|&
name|NFSV3_FSFCANSETTIME
condition|)
block|{
if|if
condition|(
operator|*
name|tl
operator|==
name|newnfs_false
condition|)
operator|*
name|retcmpp
operator|=
name|NFSERR_NOTSAME
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|tl
operator|==
name|newnfs_true
condition|)
operator|*
name|retcmpp
operator|=
name|NFSERR_NOTSAME
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|fsp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
name|tl
operator|==
name|newnfs_true
condition|)
name|fsp
operator|->
name|fs_properties
operator||=
name|NFSV3_FSFCANSETTIME
expr_stmt|;
else|else
name|fsp
operator|->
name|fs_properties
operator|&=
operator|~
name|NFSV3_FSFCANSETTIME
expr_stmt|;
block|}
name|attrsum
operator|+=
name|NFSX_UNSIGNED
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_CASEINSENSITIVE
case|:
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|retcmpp
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|tl
operator|!=
name|newnfs_false
condition|)
operator|*
name|retcmpp
operator|=
name|NFSERR_NOTSAME
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|pc
operator|!=
name|NULL
condition|)
block|{
name|pc
operator|->
name|pc_caseinsensitive
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
block|}
name|attrsum
operator|+=
name|NFSX_UNSIGNED
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_CASEPRESERVING
case|:
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|retcmpp
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|tl
operator|!=
name|newnfs_true
condition|)
operator|*
name|retcmpp
operator|=
name|NFSERR_NOTSAME
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|pc
operator|!=
name|NULL
condition|)
block|{
name|pc
operator|->
name|pc_casepreserving
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
block|}
name|attrsum
operator|+=
name|NFSX_UNSIGNED
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_CHOWNRESTRICTED
case|:
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|retcmpp
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|tl
operator|!=
name|newnfs_true
condition|)
operator|*
name|retcmpp
operator|=
name|NFSERR_NOTSAME
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|pc
operator|!=
name|NULL
condition|)
block|{
name|pc
operator|->
name|pc_chownrestricted
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
block|}
name|attrsum
operator|+=
name|NFSX_UNSIGNED
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_FILEHANDLE
case|:
name|error
operator|=
name|nfsm_getfh
argument_list|(
name|nd
argument_list|,
operator|&
name|tnfhp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
name|tfhsize
operator|=
name|tnfhp
operator|->
name|nfh_len
expr_stmt|;
if|if
condition|(
name|compare
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|retcmpp
operator|)
operator|&&
operator|!
name|NFSRV_CMPFH
argument_list|(
name|tnfhp
operator|->
name|nfh_fh
argument_list|,
name|tfhsize
argument_list|,
name|fhp
argument_list|,
name|fhsize
argument_list|)
condition|)
operator|*
name|retcmpp
operator|=
name|NFSERR_NOTSAME
expr_stmt|;
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|tnfhp
argument_list|,
name|M_NFSFH
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nfhpp
operator|!=
name|NULL
condition|)
block|{
operator|*
name|nfhpp
operator|=
name|tnfhp
expr_stmt|;
block|}
else|else
block|{
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|tnfhp
argument_list|,
name|M_NFSFH
argument_list|)
expr_stmt|;
block|}
name|attrsum
operator|+=
operator|(
name|NFSX_UNSIGNED
operator|+
name|NFSM_RNDUP
argument_list|(
name|tfhsize
argument_list|)
operator|)
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_FILEID
case|:
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_HYPER
argument_list|)
expr_stmt|;
name|thyp
operator|=
name|fxdr_hyper
argument_list|(
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|retcmpp
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|u_int64_t
operator|)
name|nap
operator|->
name|na_fileid
operator|!=
name|thyp
condition|)
operator|*
name|retcmpp
operator|=
name|NFSERR_NOTSAME
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|nap
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
name|tl
operator|++
condition|)
name|printf
argument_list|(
literal|"NFSv4 fileid> 32bits\n"
argument_list|)
expr_stmt|;
name|nap
operator|->
name|na_fileid
operator|=
name|thyp
expr_stmt|;
block|}
name|attrsum
operator|+=
name|NFSX_HYPER
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_FILESAVAIL
case|:
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_HYPER
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|retcmpp
operator|)
operator|&&
name|sfp
operator|->
name|sf_afiles
operator|!=
name|fxdr_hyper
argument_list|(
name|tl
argument_list|)
condition|)
operator|*
name|retcmpp
operator|=
name|NFSERR_NOTSAME
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sfp
operator|!=
name|NULL
condition|)
block|{
name|sfp
operator|->
name|sf_afiles
operator|=
name|fxdr_hyper
argument_list|(
name|tl
argument_list|)
expr_stmt|;
block|}
name|attrsum
operator|+=
name|NFSX_HYPER
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_FILESFREE
case|:
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_HYPER
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|retcmpp
operator|)
operator|&&
name|sfp
operator|->
name|sf_ffiles
operator|!=
name|fxdr_hyper
argument_list|(
name|tl
argument_list|)
condition|)
operator|*
name|retcmpp
operator|=
name|NFSERR_NOTSAME
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sfp
operator|!=
name|NULL
condition|)
block|{
name|sfp
operator|->
name|sf_ffiles
operator|=
name|fxdr_hyper
argument_list|(
name|tl
argument_list|)
expr_stmt|;
block|}
name|attrsum
operator|+=
name|NFSX_HYPER
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_FILESTOTAL
case|:
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_HYPER
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|retcmpp
operator|)
operator|&&
name|sfp
operator|->
name|sf_tfiles
operator|!=
name|fxdr_hyper
argument_list|(
name|tl
argument_list|)
condition|)
operator|*
name|retcmpp
operator|=
name|NFSERR_NOTSAME
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sfp
operator|!=
name|NULL
condition|)
block|{
name|sfp
operator|->
name|sf_tfiles
operator|=
name|fxdr_hyper
argument_list|(
name|tl
argument_list|)
expr_stmt|;
block|}
name|attrsum
operator|+=
name|NFSX_HYPER
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_FSLOCATIONS
case|:
name|error
operator|=
name|nfsrv_getrefstr
argument_list|(
name|nd
argument_list|,
operator|&
name|cp
argument_list|,
operator|&
name|cp2
argument_list|,
operator|&
name|l
argument_list|,
operator|&
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
name|attrsum
operator|+=
name|l
expr_stmt|;
if|if
condition|(
name|compare
operator|&&
operator|!
operator|(
operator|*
name|retcmpp
operator|)
condition|)
block|{
name|refp
operator|=
name|nfsv4root_getreferral
argument_list|(
name|vp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|refp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|cp
operator|==
name|NULL
operator|||
name|cp2
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"/"
argument_list|)
operator|||
name|strcmp
argument_list|(
name|cp2
argument_list|,
name|refp
operator|->
name|nfr_srvlist
argument_list|)
condition|)
operator|*
name|retcmpp
operator|=
name|NFSERR_NOTSAME
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
operator|*
name|retcmpp
operator|=
name|NFSERR_NOTSAME
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|cp
argument_list|,
name|M_NFSSTRING
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp2
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|cp2
argument_list|,
name|M_NFSSTRING
argument_list|)
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_HIDDEN
case|:
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare
operator|&&
operator|!
operator|(
operator|*
name|retcmpp
operator|)
condition|)
operator|*
name|retcmpp
operator|=
name|NFSERR_ATTRNOTSUPP
expr_stmt|;
name|attrsum
operator|+=
name|NFSX_UNSIGNED
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_HOMOGENEOUS
case|:
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|retcmpp
operator|)
condition|)
block|{
if|if
condition|(
name|fsp
operator|->
name|fs_properties
operator|&
name|NFSV3_FSFHOMOGENEOUS
condition|)
block|{
if|if
condition|(
operator|*
name|tl
operator|==
name|newnfs_false
condition|)
operator|*
name|retcmpp
operator|=
name|NFSERR_NOTSAME
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|tl
operator|==
name|newnfs_true
condition|)
operator|*
name|retcmpp
operator|=
name|NFSERR_NOTSAME
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|fsp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
name|tl
operator|==
name|newnfs_true
condition|)
name|fsp
operator|->
name|fs_properties
operator||=
name|NFSV3_FSFHOMOGENEOUS
expr_stmt|;
else|else
name|fsp
operator|->
name|fs_properties
operator|&=
operator|~
name|NFSV3_FSFHOMOGENEOUS
expr_stmt|;
block|}
name|attrsum
operator|+=
name|NFSX_UNSIGNED
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_MAXFILESIZE
case|:
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_HYPER
argument_list|)
expr_stmt|;
name|tnfsquad
operator|.
name|qval
operator|=
name|fxdr_hyper
argument_list|(
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|retcmpp
operator|)
condition|)
block|{
name|tquad
operator|=
name|NFSRV_MAXFILESIZE
expr_stmt|;
if|if
condition|(
name|tquad
operator|!=
name|tnfsquad
operator|.
name|qval
condition|)
operator|*
name|retcmpp
operator|=
name|NFSERR_NOTSAME
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|fsp
operator|!=
name|NULL
condition|)
block|{
name|fsp
operator|->
name|fs_maxfilesize
operator|=
name|tnfsquad
operator|.
name|qval
expr_stmt|;
block|}
name|attrsum
operator|+=
name|NFSX_HYPER
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_MAXLINK
case|:
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|retcmpp
operator|)
condition|)
block|{
if|if
condition|(
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
operator|!=
name|LINK_MAX
condition|)
operator|*
name|retcmpp
operator|=
name|NFSERR_NOTSAME
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|pc
operator|!=
name|NULL
condition|)
block|{
name|pc
operator|->
name|pc_linkmax
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
block|}
name|attrsum
operator|+=
name|NFSX_UNSIGNED
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_MAXNAME
case|:
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|retcmpp
operator|)
condition|)
block|{
if|if
condition|(
name|fsp
operator|->
name|fs_maxname
operator|!=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
name|tl
argument_list|)
condition|)
operator|*
name|retcmpp
operator|=
name|NFSERR_NOTSAME
expr_stmt|;
block|}
block|}
else|else
block|{
name|tuint
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
comment|/* 				 * Some Linux NFSv4 servers report this 				 * as 0 or 4billion, so I'll set it to 				 * NFS_MAXNAMLEN. If a server actually creates 				 * a name longer than NFS_MAXNAMLEN, it will 				 * get an error back. 				 */
if|if
condition|(
name|tuint
operator|==
literal|0
operator|||
name|tuint
operator|>
name|NFS_MAXNAMLEN
condition|)
name|tuint
operator|=
name|NFS_MAXNAMLEN
expr_stmt|;
if|if
condition|(
name|fsp
operator|!=
name|NULL
condition|)
name|fsp
operator|->
name|fs_maxname
operator|=
name|tuint
expr_stmt|;
if|if
condition|(
name|pc
operator|!=
name|NULL
condition|)
name|pc
operator|->
name|pc_namemax
operator|=
name|tuint
expr_stmt|;
block|}
name|attrsum
operator|+=
name|NFSX_UNSIGNED
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_MAXREAD
case|:
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_HYPER
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|retcmpp
operator|)
condition|)
block|{
if|if
condition|(
name|fsp
operator|->
name|fs_rtmax
operator|!=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
operator|(
name|tl
operator|+
literal|1
operator|)
argument_list|)
operator|||
operator|*
name|tl
operator|!=
literal|0
condition|)
operator|*
name|retcmpp
operator|=
name|NFSERR_NOTSAME
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|fsp
operator|!=
name|NULL
condition|)
block|{
name|fsp
operator|->
name|fs_rtmax
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
operator|++
name|tl
argument_list|)
expr_stmt|;
name|fsp
operator|->
name|fs_rtpref
operator|=
name|fsp
operator|->
name|fs_rtmax
expr_stmt|;
name|fsp
operator|->
name|fs_dtpref
operator|=
name|fsp
operator|->
name|fs_rtpref
expr_stmt|;
block|}
name|attrsum
operator|+=
name|NFSX_HYPER
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_MAXWRITE
case|:
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_HYPER
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|retcmpp
operator|)
condition|)
block|{
if|if
condition|(
name|fsp
operator|->
name|fs_wtmax
operator|!=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
operator|(
name|tl
operator|+
literal|1
operator|)
argument_list|)
operator|||
operator|*
name|tl
operator|!=
literal|0
condition|)
operator|*
name|retcmpp
operator|=
name|NFSERR_NOTSAME
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|fsp
operator|!=
name|NULL
condition|)
block|{
name|fsp
operator|->
name|fs_wtmax
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
operator|++
name|tl
argument_list|)
expr_stmt|;
name|fsp
operator|->
name|fs_wtpref
operator|=
name|fsp
operator|->
name|fs_wtmax
expr_stmt|;
block|}
name|attrsum
operator|+=
name|NFSX_HYPER
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_MIMETYPE
case|:
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|i
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
name|attrsum
operator|+=
operator|(
name|NFSX_UNSIGNED
operator|+
name|NFSM_RNDUP
argument_list|(
name|i
argument_list|)
operator|)
expr_stmt|;
name|error
operator|=
name|nfsm_advance
argument_list|(
name|nd
argument_list|,
name|NFSM_RNDUP
argument_list|(
name|i
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
if|if
condition|(
name|compare
operator|&&
operator|!
operator|(
operator|*
name|retcmpp
operator|)
condition|)
operator|*
name|retcmpp
operator|=
name|NFSERR_ATTRNOTSUPP
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_MODE
case|:
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|retcmpp
operator|)
condition|)
block|{
if|if
condition|(
name|nap
operator|->
name|na_mode
operator|!=
name|nfstov_mode
argument_list|(
operator|*
name|tl
argument_list|)
condition|)
operator|*
name|retcmpp
operator|=
name|NFSERR_NOTSAME
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|nap
operator|!=
name|NULL
condition|)
block|{
name|nap
operator|->
name|na_mode
operator|=
name|nfstov_mode
argument_list|(
operator|*
name|tl
argument_list|)
expr_stmt|;
block|}
name|attrsum
operator|+=
name|NFSX_UNSIGNED
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_NOTRUNC
case|:
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|retcmpp
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|tl
operator|!=
name|newnfs_true
condition|)
operator|*
name|retcmpp
operator|=
name|NFSERR_NOTSAME
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|pc
operator|!=
name|NULL
condition|)
block|{
name|pc
operator|->
name|pc_notrunc
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
block|}
name|attrsum
operator|+=
name|NFSX_UNSIGNED
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_NUMLINKS
case|:
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|tuint
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|retcmpp
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|u_int32_t
operator|)
name|nap
operator|->
name|na_nlink
operator|!=
name|tuint
condition|)
operator|*
name|retcmpp
operator|=
name|NFSERR_NOTSAME
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|nap
operator|!=
name|NULL
condition|)
block|{
name|nap
operator|->
name|na_nlink
operator|=
name|tuint
expr_stmt|;
block|}
name|attrsum
operator|+=
name|NFSX_UNSIGNED
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_OWNER
case|:
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|j
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|<
literal|0
condition|)
block|{
name|error
operator|=
name|NFSERR_BADXDR
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
name|attrsum
operator|+=
operator|(
name|NFSX_UNSIGNED
operator|+
name|NFSM_RNDUP
argument_list|(
name|j
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|j
operator|>
name|NFSV4_SMALLSTR
condition|)
name|cp
operator|=
name|malloc
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|M_NFSSTRING
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
else|else
name|cp
operator|=
name|namestr
expr_stmt|;
name|error
operator|=
name|nfsrv_mtostr
argument_list|(
name|nd
argument_list|,
name|cp
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|j
operator|>
name|NFSV4_SMALLSTR
condition|)
name|free
argument_list|(
name|cp
argument_list|,
name|M_NFSSTRING
argument_list|)
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
if|if
condition|(
name|compare
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|retcmpp
operator|)
condition|)
block|{
if|if
condition|(
name|nfsv4_strtouid
argument_list|(
name|nd
argument_list|,
name|cp
argument_list|,
name|j
argument_list|,
operator|&
name|uid
argument_list|,
name|p
argument_list|)
operator|||
name|nap
operator|->
name|na_uid
operator|!=
name|uid
condition|)
operator|*
name|retcmpp
operator|=
name|NFSERR_NOTSAME
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|nap
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|nfsv4_strtouid
argument_list|(
name|nd
argument_list|,
name|cp
argument_list|,
name|j
argument_list|,
operator|&
name|uid
argument_list|,
name|p
argument_list|)
condition|)
name|nap
operator|->
name|na_uid
operator|=
name|nfsrv_defaultuid
expr_stmt|;
else|else
name|nap
operator|->
name|na_uid
operator|=
name|uid
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|>
name|NFSV4_SMALLSTR
condition|)
name|free
argument_list|(
name|cp
argument_list|,
name|M_NFSSTRING
argument_list|)
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_OWNERGROUP
case|:
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|j
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|<
literal|0
condition|)
block|{
name|error
operator|=
name|NFSERR_BADXDR
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
name|attrsum
operator|+=
operator|(
name|NFSX_UNSIGNED
operator|+
name|NFSM_RNDUP
argument_list|(
name|j
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|j
operator|>
name|NFSV4_SMALLSTR
condition|)
name|cp
operator|=
name|malloc
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|M_NFSSTRING
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
else|else
name|cp
operator|=
name|namestr
expr_stmt|;
name|error
operator|=
name|nfsrv_mtostr
argument_list|(
name|nd
argument_list|,
name|cp
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|j
operator|>
name|NFSV4_SMALLSTR
condition|)
name|free
argument_list|(
name|cp
argument_list|,
name|M_NFSSTRING
argument_list|)
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
if|if
condition|(
name|compare
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|retcmpp
operator|)
condition|)
block|{
if|if
condition|(
name|nfsv4_strtogid
argument_list|(
name|nd
argument_list|,
name|cp
argument_list|,
name|j
argument_list|,
operator|&
name|gid
argument_list|,
name|p
argument_list|)
operator|||
name|nap
operator|->
name|na_gid
operator|!=
name|gid
condition|)
operator|*
name|retcmpp
operator|=
name|NFSERR_NOTSAME
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|nap
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|nfsv4_strtogid
argument_list|(
name|nd
argument_list|,
name|cp
argument_list|,
name|j
argument_list|,
operator|&
name|gid
argument_list|,
name|p
argument_list|)
condition|)
name|nap
operator|->
name|na_gid
operator|=
name|nfsrv_defaultgid
expr_stmt|;
else|else
name|nap
operator|->
name|na_gid
operator|=
name|gid
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|>
name|NFSV4_SMALLSTR
condition|)
name|free
argument_list|(
name|cp
argument_list|,
name|M_NFSSTRING
argument_list|)
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_QUOTAHARD
case|:
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_HYPER
argument_list|)
expr_stmt|;
if|if
condition|(
name|sbp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|priv_check_cred
argument_list|(
name|cred
argument_list|,
name|PRIV_VFS_EXCEEDQUOTA
argument_list|,
literal|0
argument_list|)
condition|)
name|freenum
operator|=
name|sbp
operator|->
name|f_bfree
expr_stmt|;
else|else
name|freenum
operator|=
name|sbp
operator|->
name|f_bavail
expr_stmt|;
ifdef|#
directive|ifdef
name|QUOTA
comment|/* 			     * ufs_quotactl() insists that the uid argument 			     * equal p_ruid for non-root quota access, so 			     * we'll just make sure that's the case. 			     */
name|savuid
operator|=
name|p
operator|->
name|p_cred
operator|->
name|p_ruid
expr_stmt|;
name|p
operator|->
name|p_cred
operator|->
name|p_ruid
operator|=
name|cred
operator|->
name|cr_uid
expr_stmt|;
if|if
condition|(
operator|!
name|VFS_QUOTACTL
argument_list|(
name|vnode_mount
argument_list|(
name|vp
argument_list|)
argument_list|,
name|QCMD
argument_list|(
name|Q_GETQUOTA
argument_list|,
name|USRQUOTA
argument_list|)
argument_list|,
name|cred
operator|->
name|cr_uid
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|dqb
argument_list|)
condition|)
name|freenum
operator|=
name|min
argument_list|(
name|dqb
operator|.
name|dqb_bhardlimit
argument_list|,
name|freenum
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_cred
operator|->
name|p_ruid
operator|=
name|savuid
expr_stmt|;
endif|#
directive|endif
comment|/* QUOTA */
name|uquad
operator|=
operator|(
name|u_int64_t
operator|)
name|freenum
expr_stmt|;
name|NFSQUOTABLKTOBYTE
argument_list|(
name|uquad
argument_list|,
name|sbp
operator|->
name|f_bsize
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|compare
operator|&&
operator|!
operator|(
operator|*
name|retcmpp
operator|)
condition|)
block|{
if|if
condition|(
name|uquad
operator|!=
name|fxdr_hyper
argument_list|(
name|tl
argument_list|)
condition|)
operator|*
name|retcmpp
operator|=
name|NFSERR_NOTSAME
expr_stmt|;
block|}
name|attrsum
operator|+=
name|NFSX_HYPER
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_QUOTASOFT
case|:
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_HYPER
argument_list|)
expr_stmt|;
if|if
condition|(
name|sbp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|priv_check_cred
argument_list|(
name|cred
argument_list|,
name|PRIV_VFS_EXCEEDQUOTA
argument_list|,
literal|0
argument_list|)
condition|)
name|freenum
operator|=
name|sbp
operator|->
name|f_bfree
expr_stmt|;
else|else
name|freenum
operator|=
name|sbp
operator|->
name|f_bavail
expr_stmt|;
ifdef|#
directive|ifdef
name|QUOTA
comment|/* 			     * ufs_quotactl() insists that the uid argument 			     * equal p_ruid for non-root quota access, so 			     * we'll just make sure that's the case. 			     */
name|savuid
operator|=
name|p
operator|->
name|p_cred
operator|->
name|p_ruid
expr_stmt|;
name|p
operator|->
name|p_cred
operator|->
name|p_ruid
operator|=
name|cred
operator|->
name|cr_uid
expr_stmt|;
if|if
condition|(
operator|!
name|VFS_QUOTACTL
argument_list|(
name|vnode_mount
argument_list|(
name|vp
argument_list|)
argument_list|,
name|QCMD
argument_list|(
name|Q_GETQUOTA
argument_list|,
name|USRQUOTA
argument_list|)
argument_list|,
name|cred
operator|->
name|cr_uid
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|dqb
argument_list|)
condition|)
name|freenum
operator|=
name|min
argument_list|(
name|dqb
operator|.
name|dqb_bsoftlimit
argument_list|,
name|freenum
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_cred
operator|->
name|p_ruid
operator|=
name|savuid
expr_stmt|;
endif|#
directive|endif
comment|/* QUOTA */
name|uquad
operator|=
operator|(
name|u_int64_t
operator|)
name|freenum
expr_stmt|;
name|NFSQUOTABLKTOBYTE
argument_list|(
name|uquad
argument_list|,
name|sbp
operator|->
name|f_bsize
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|compare
operator|&&
operator|!
operator|(
operator|*
name|retcmpp
operator|)
condition|)
block|{
if|if
condition|(
name|uquad
operator|!=
name|fxdr_hyper
argument_list|(
name|tl
argument_list|)
condition|)
operator|*
name|retcmpp
operator|=
name|NFSERR_NOTSAME
expr_stmt|;
block|}
name|attrsum
operator|+=
name|NFSX_HYPER
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_QUOTAUSED
case|:
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_HYPER
argument_list|)
expr_stmt|;
if|if
condition|(
name|sbp
operator|!=
name|NULL
condition|)
block|{
name|freenum
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|QUOTA
comment|/* 			     * ufs_quotactl() insists that the uid argument 			     * equal p_ruid for non-root quota access, so 			     * we'll just make sure that's the case. 			     */
name|savuid
operator|=
name|p
operator|->
name|p_cred
operator|->
name|p_ruid
expr_stmt|;
name|p
operator|->
name|p_cred
operator|->
name|p_ruid
operator|=
name|cred
operator|->
name|cr_uid
expr_stmt|;
if|if
condition|(
operator|!
name|VFS_QUOTACTL
argument_list|(
name|vnode_mount
argument_list|(
name|vp
argument_list|)
argument_list|,
name|QCMD
argument_list|(
name|Q_GETQUOTA
argument_list|,
name|USRQUOTA
argument_list|)
argument_list|,
name|cred
operator|->
name|cr_uid
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|dqb
argument_list|)
condition|)
name|freenum
operator|=
name|dqb
operator|.
name|dqb_curblocks
expr_stmt|;
name|p
operator|->
name|p_cred
operator|->
name|p_ruid
operator|=
name|savuid
expr_stmt|;
endif|#
directive|endif
comment|/* QUOTA */
name|uquad
operator|=
operator|(
name|u_int64_t
operator|)
name|freenum
expr_stmt|;
name|NFSQUOTABLKTOBYTE
argument_list|(
name|uquad
argument_list|,
name|sbp
operator|->
name|f_bsize
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|compare
operator|&&
operator|!
operator|(
operator|*
name|retcmpp
operator|)
condition|)
block|{
if|if
condition|(
name|uquad
operator|!=
name|fxdr_hyper
argument_list|(
name|tl
argument_list|)
condition|)
operator|*
name|retcmpp
operator|=
name|NFSERR_NOTSAME
expr_stmt|;
block|}
name|attrsum
operator|+=
name|NFSX_HYPER
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_RAWDEV
case|:
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_V4SPECDATA
argument_list|)
expr_stmt|;
name|j
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
name|k
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|retcmpp
operator|)
condition|)
block|{
if|if
condition|(
name|nap
operator|->
name|na_rdev
operator|!=
name|NFSMAKEDEV
argument_list|(
name|j
argument_list|,
name|k
argument_list|)
condition|)
operator|*
name|retcmpp
operator|=
name|NFSERR_NOTSAME
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|nap
operator|!=
name|NULL
condition|)
block|{
name|nap
operator|->
name|na_rdev
operator|=
name|NFSMAKEDEV
argument_list|(
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
block|}
name|attrsum
operator|+=
name|NFSX_V4SPECDATA
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_SPACEAVAIL
case|:
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_HYPER
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|retcmpp
operator|)
operator|&&
name|sfp
operator|->
name|sf_abytes
operator|!=
name|fxdr_hyper
argument_list|(
name|tl
argument_list|)
condition|)
operator|*
name|retcmpp
operator|=
name|NFSERR_NOTSAME
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sfp
operator|!=
name|NULL
condition|)
block|{
name|sfp
operator|->
name|sf_abytes
operator|=
name|fxdr_hyper
argument_list|(
name|tl
argument_list|)
expr_stmt|;
block|}
name|attrsum
operator|+=
name|NFSX_HYPER
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_SPACEFREE
case|:
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_HYPER
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|retcmpp
operator|)
operator|&&
name|sfp
operator|->
name|sf_fbytes
operator|!=
name|fxdr_hyper
argument_list|(
name|tl
argument_list|)
condition|)
operator|*
name|retcmpp
operator|=
name|NFSERR_NOTSAME
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sfp
operator|!=
name|NULL
condition|)
block|{
name|sfp
operator|->
name|sf_fbytes
operator|=
name|fxdr_hyper
argument_list|(
name|tl
argument_list|)
expr_stmt|;
block|}
name|attrsum
operator|+=
name|NFSX_HYPER
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_SPACETOTAL
case|:
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_HYPER
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|retcmpp
operator|)
operator|&&
name|sfp
operator|->
name|sf_tbytes
operator|!=
name|fxdr_hyper
argument_list|(
name|tl
argument_list|)
condition|)
operator|*
name|retcmpp
operator|=
name|NFSERR_NOTSAME
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sfp
operator|!=
name|NULL
condition|)
block|{
name|sfp
operator|->
name|sf_tbytes
operator|=
name|fxdr_hyper
argument_list|(
name|tl
argument_list|)
expr_stmt|;
block|}
name|attrsum
operator|+=
name|NFSX_HYPER
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_SPACEUSED
case|:
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_HYPER
argument_list|)
expr_stmt|;
name|thyp
operator|=
name|fxdr_hyper
argument_list|(
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|retcmpp
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|u_int64_t
operator|)
name|nap
operator|->
name|na_bytes
operator|!=
name|thyp
condition|)
operator|*
name|retcmpp
operator|=
name|NFSERR_NOTSAME
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|nap
operator|!=
name|NULL
condition|)
block|{
name|nap
operator|->
name|na_bytes
operator|=
name|thyp
expr_stmt|;
block|}
name|attrsum
operator|+=
name|NFSX_HYPER
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_SYSTEM
case|:
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare
operator|&&
operator|!
operator|(
operator|*
name|retcmpp
operator|)
condition|)
operator|*
name|retcmpp
operator|=
name|NFSERR_ATTRNOTSUPP
expr_stmt|;
name|attrsum
operator|+=
name|NFSX_UNSIGNED
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_TIMEACCESS
case|:
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_V4TIME
argument_list|)
expr_stmt|;
name|fxdr_nfsv4time
argument_list|(
name|tl
argument_list|,
operator|&
name|temptime
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|retcmpp
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|NFS_CMPTIME
argument_list|(
name|temptime
argument_list|,
name|nap
operator|->
name|na_atime
argument_list|)
condition|)
operator|*
name|retcmpp
operator|=
name|NFSERR_NOTSAME
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|nap
operator|!=
name|NULL
condition|)
block|{
name|nap
operator|->
name|na_atime
operator|=
name|temptime
expr_stmt|;
block|}
name|attrsum
operator|+=
name|NFSX_V4TIME
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_TIMEACCESSSET
case|:
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|attrsum
operator|+=
name|NFSX_UNSIGNED
expr_stmt|;
name|i
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|NFSV4SATTRTIME_TOCLIENT
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_V4TIME
argument_list|)
expr_stmt|;
name|attrsum
operator|+=
name|NFSX_V4TIME
expr_stmt|;
block|}
if|if
condition|(
name|compare
operator|&&
operator|!
operator|(
operator|*
name|retcmpp
operator|)
condition|)
operator|*
name|retcmpp
operator|=
name|NFSERR_INVAL
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_TIMEBACKUP
case|:
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_V4TIME
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare
operator|&&
operator|!
operator|(
operator|*
name|retcmpp
operator|)
condition|)
operator|*
name|retcmpp
operator|=
name|NFSERR_ATTRNOTSUPP
expr_stmt|;
name|attrsum
operator|+=
name|NFSX_V4TIME
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_TIMECREATE
case|:
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_V4TIME
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare
operator|&&
operator|!
operator|(
operator|*
name|retcmpp
operator|)
condition|)
operator|*
name|retcmpp
operator|=
name|NFSERR_ATTRNOTSUPP
expr_stmt|;
name|attrsum
operator|+=
name|NFSX_V4TIME
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_TIMEDELTA
case|:
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_V4TIME
argument_list|)
expr_stmt|;
if|if
condition|(
name|fsp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|compare
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|retcmpp
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|u_int32_t
operator|)
name|fsp
operator|->
name|fs_timedelta
operator|.
name|tv_sec
operator|!=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
operator|(
name|tl
operator|+
literal|1
operator|)
argument_list|)
operator|||
operator|(
name|u_int32_t
operator|)
name|fsp
operator|->
name|fs_timedelta
operator|.
name|tv_nsec
operator|!=
operator|(
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
operator|(
name|tl
operator|+
literal|2
operator|)
argument_list|)
operator|%
literal|1000000000
operator|)
operator|||
operator|*
name|tl
operator|!=
literal|0
condition|)
operator|*
name|retcmpp
operator|=
name|NFSERR_NOTSAME
expr_stmt|;
block|}
block|}
else|else
block|{
name|fxdr_nfsv4time
argument_list|(
name|tl
argument_list|,
operator|&
name|fsp
operator|->
name|fs_timedelta
argument_list|)
expr_stmt|;
block|}
block|}
name|attrsum
operator|+=
name|NFSX_V4TIME
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_TIMEMETADATA
case|:
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_V4TIME
argument_list|)
expr_stmt|;
name|fxdr_nfsv4time
argument_list|(
name|tl
argument_list|,
operator|&
name|temptime
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|retcmpp
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|NFS_CMPTIME
argument_list|(
name|temptime
argument_list|,
name|nap
operator|->
name|na_ctime
argument_list|)
condition|)
operator|*
name|retcmpp
operator|=
name|NFSERR_NOTSAME
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|nap
operator|!=
name|NULL
condition|)
block|{
name|nap
operator|->
name|na_ctime
operator|=
name|temptime
expr_stmt|;
block|}
name|attrsum
operator|+=
name|NFSX_V4TIME
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_TIMEMODIFY
case|:
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_V4TIME
argument_list|)
expr_stmt|;
name|fxdr_nfsv4time
argument_list|(
name|tl
argument_list|,
operator|&
name|temptime
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|retcmpp
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|NFS_CMPTIME
argument_list|(
name|temptime
argument_list|,
name|nap
operator|->
name|na_mtime
argument_list|)
condition|)
operator|*
name|retcmpp
operator|=
name|NFSERR_NOTSAME
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|nap
operator|!=
name|NULL
condition|)
block|{
name|nap
operator|->
name|na_mtime
operator|=
name|temptime
expr_stmt|;
block|}
name|attrsum
operator|+=
name|NFSX_V4TIME
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_TIMEMODIFYSET
case|:
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|attrsum
operator|+=
name|NFSX_UNSIGNED
expr_stmt|;
name|i
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|NFSV4SATTRTIME_TOCLIENT
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_V4TIME
argument_list|)
expr_stmt|;
name|attrsum
operator|+=
name|NFSX_V4TIME
expr_stmt|;
block|}
if|if
condition|(
name|compare
operator|&&
operator|!
operator|(
operator|*
name|retcmpp
operator|)
condition|)
operator|*
name|retcmpp
operator|=
name|NFSERR_INVAL
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_MOUNTEDONFILEID
case|:
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_HYPER
argument_list|)
expr_stmt|;
name|thyp
operator|=
name|fxdr_hyper
argument_list|(
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|retcmpp
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|tl
operator|++
condition|)
block|{
operator|*
name|retcmpp
operator|=
name|NFSERR_NOTSAME
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|vp
operator|||
operator|!
name|nfsrv_atroot
argument_list|(
name|vp
argument_list|,
operator|&
name|fid
argument_list|)
condition|)
name|fid
operator|=
name|nap
operator|->
name|na_fileid
expr_stmt|;
if|if
condition|(
operator|(
name|u_int64_t
operator|)
name|fid
operator|!=
name|thyp
condition|)
operator|*
name|retcmpp
operator|=
name|NFSERR_NOTSAME
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|nap
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
name|tl
operator|++
condition|)
name|printf
argument_list|(
literal|"NFSv4 mounted on fileid> 32bits\n"
argument_list|)
expr_stmt|;
name|nap
operator|->
name|na_mntonfileno
operator|=
name|thyp
expr_stmt|;
block|}
name|attrsum
operator|+=
name|NFSX_HYPER
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_SUPPATTREXCLCREAT
case|:
name|retnotsup
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|nfsrv_getattrbits
argument_list|(
name|nd
argument_list|,
operator|&
name|retattrbits
argument_list|,
operator|&
name|cnt
argument_list|,
operator|&
name|retnotsup
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
if|if
condition|(
name|compare
operator|&&
operator|!
operator|(
operator|*
name|retcmpp
operator|)
condition|)
block|{
name|NFSSETSUPP_ATTRBIT
argument_list|(
operator|&
name|checkattrbits
argument_list|)
expr_stmt|;
name|NFSCLRNOTSETABLE_ATTRBIT
argument_list|(
operator|&
name|checkattrbits
argument_list|)
expr_stmt|;
name|NFSCLRBIT_ATTRBIT
argument_list|(
operator|&
name|checkattrbits
argument_list|,
name|NFSATTRBIT_TIMEACCESSSET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NFSEQUAL_ATTRBIT
argument_list|(
operator|&
name|retattrbits
argument_list|,
operator|&
name|checkattrbits
argument_list|)
operator|||
name|retnotsup
condition|)
operator|*
name|retcmpp
operator|=
name|NFSERR_NOTSAME
expr_stmt|;
block|}
name|attrsum
operator|+=
name|cnt
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"EEK! nfsv4_loadattr unknown attr=%d\n"
argument_list|,
name|bitpos
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare
operator|&&
operator|!
operator|(
operator|*
name|retcmpp
operator|)
condition|)
operator|*
name|retcmpp
operator|=
name|NFSERR_ATTRNOTSUPP
expr_stmt|;
comment|/* 			 * and get out of the loop, since we can't parse 			 * the unknown attrbute data. 			 */
name|bitpos
operator|=
name|NFSATTRBIT_MAX
expr_stmt|;
break|break;
block|}
empty_stmt|;
block|}
comment|/* 	 * some clients pad the attrlist, so we need to skip over the 	 * padding. 	 */
if|if
condition|(
name|attrsum
operator|>
name|attrsize
condition|)
block|{
name|error
operator|=
name|NFSERR_BADXDR
expr_stmt|;
block|}
else|else
block|{
name|attrsize
operator|=
name|NFSM_RNDUP
argument_list|(
name|attrsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|attrsum
operator|<
name|attrsize
condition|)
name|error
operator|=
name|nfsm_advance
argument_list|(
name|nd
argument_list|,
name|attrsize
operator|-
name|attrsum
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|nfsmout
label|:
name|NFSEXITCODE2
argument_list|(
name|error
argument_list|,
name|nd
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Implement sleep locks for newnfs. The nfslock_usecnt allows for a  * shared lock and the NFSXXX_LOCK flag permits an exclusive lock.  * The first argument is a pointer to an nfsv4lock structure.  * The second argument is 1 iff a blocking lock is wanted.  * If this argument is 0, the call waits until no thread either wants nor  * holds an exclusive lock.  * It returns 1 if the lock was acquired, 0 otherwise.  * If several processes call this function concurrently wanting the exclusive  * lock, one will get the lock and the rest will return without getting the  * lock. (If the caller must have the lock, it simply calls this function in a  *  loop until the function returns 1 to indicate the lock was acquired.)  * Any usecnt must be decremented by calling nfsv4_relref() before  * calling nfsv4_lock(). It was done this way, so nfsv4_lock() could  * be called in a loop.  * The isleptp argument is set to indicate if the call slept, iff not NULL  * and the mp argument indicates to check for a forced dismount, iff not  * NULL.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsv4_lock
parameter_list|(
name|struct
name|nfsv4lock
modifier|*
name|lp
parameter_list|,
name|int
name|iwantlock
parameter_list|,
name|int
modifier|*
name|isleptp
parameter_list|,
name|void
modifier|*
name|mutex
parameter_list|,
name|struct
name|mount
modifier|*
name|mp
parameter_list|)
block|{
if|if
condition|(
name|isleptp
condition|)
operator|*
name|isleptp
operator|=
literal|0
expr_stmt|;
comment|/* 	 * If a lock is wanted, loop around until the lock is acquired by 	 * someone and then released. If I want the lock, try to acquire it. 	 * For a lock to be issued, no lock must be in force and the usecnt 	 * must be zero. 	 */
if|if
condition|(
name|iwantlock
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|lp
operator|->
name|nfslock_lock
operator|&
name|NFSV4LOCK_LOCK
operator|)
operator|&&
name|lp
operator|->
name|nfslock_usecnt
operator|==
literal|0
condition|)
block|{
name|lp
operator|->
name|nfslock_lock
operator|&=
operator|~
name|NFSV4LOCK_LOCKWANTED
expr_stmt|;
name|lp
operator|->
name|nfslock_lock
operator||=
name|NFSV4LOCK_LOCK
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|lp
operator|->
name|nfslock_lock
operator||=
name|NFSV4LOCK_LOCKWANTED
expr_stmt|;
block|}
while|while
condition|(
name|lp
operator|->
name|nfslock_lock
operator|&
operator|(
name|NFSV4LOCK_LOCK
operator||
name|NFSV4LOCK_LOCKWANTED
operator|)
condition|)
block|{
if|if
condition|(
name|mp
operator|!=
name|NULL
operator|&&
operator|(
name|mp
operator|->
name|mnt_kern_flag
operator|&
name|MNTK_UNMOUNTF
operator|)
operator|!=
literal|0
condition|)
block|{
name|lp
operator|->
name|nfslock_lock
operator|&=
operator|~
name|NFSV4LOCK_LOCKWANTED
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|lp
operator|->
name|nfslock_lock
operator||=
name|NFSV4LOCK_WANTED
expr_stmt|;
if|if
condition|(
name|isleptp
condition|)
operator|*
name|isleptp
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|nfsmsleep
argument_list|(
operator|&
name|lp
operator|->
name|nfslock_lock
argument_list|,
name|mutex
argument_list|,
name|PZERO
operator|-
literal|1
argument_list|,
literal|"nfsv4lck"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|iwantlock
operator|&&
operator|!
operator|(
name|lp
operator|->
name|nfslock_lock
operator|&
name|NFSV4LOCK_LOCK
operator|)
operator|&&
name|lp
operator|->
name|nfslock_usecnt
operator|==
literal|0
condition|)
block|{
name|lp
operator|->
name|nfslock_lock
operator|&=
operator|~
name|NFSV4LOCK_LOCKWANTED
expr_stmt|;
name|lp
operator|->
name|nfslock_lock
operator||=
name|NFSV4LOCK_LOCK
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Release the lock acquired by nfsv4_lock().  * The second argument is set to 1 to indicate the nfslock_usecnt should be  * incremented, as well.  */
end_comment

begin_function
name|APPLESTATIC
name|void
name|nfsv4_unlock
parameter_list|(
name|struct
name|nfsv4lock
modifier|*
name|lp
parameter_list|,
name|int
name|incref
parameter_list|)
block|{
name|lp
operator|->
name|nfslock_lock
operator|&=
operator|~
name|NFSV4LOCK_LOCK
expr_stmt|;
if|if
condition|(
name|incref
condition|)
name|lp
operator|->
name|nfslock_usecnt
operator|++
expr_stmt|;
name|nfsv4_wanted
argument_list|(
name|lp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Release a reference cnt.  */
end_comment

begin_function
name|APPLESTATIC
name|void
name|nfsv4_relref
parameter_list|(
name|struct
name|nfsv4lock
modifier|*
name|lp
parameter_list|)
block|{
if|if
condition|(
name|lp
operator|->
name|nfslock_usecnt
operator|<=
literal|0
condition|)
name|panic
argument_list|(
literal|"nfsv4root ref cnt"
argument_list|)
expr_stmt|;
name|lp
operator|->
name|nfslock_usecnt
operator|--
expr_stmt|;
if|if
condition|(
name|lp
operator|->
name|nfslock_usecnt
operator|==
literal|0
condition|)
name|nfsv4_wanted
argument_list|(
name|lp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get a reference cnt.  * This function will wait for any exclusive lock to be released, but will  * not wait for threads that want the exclusive lock. If priority needs  * to be given to threads that need the exclusive lock, a call to nfsv4_lock()  * with the 2nd argument == 0 should be done before calling nfsv4_getref().  * If the mp argument is not NULL, check for MNTK_UNMOUNTF being set and  * return without getting a refcnt for that case.  */
end_comment

begin_function
name|APPLESTATIC
name|void
name|nfsv4_getref
parameter_list|(
name|struct
name|nfsv4lock
modifier|*
name|lp
parameter_list|,
name|int
modifier|*
name|isleptp
parameter_list|,
name|void
modifier|*
name|mutex
parameter_list|,
name|struct
name|mount
modifier|*
name|mp
parameter_list|)
block|{
if|if
condition|(
name|isleptp
condition|)
operator|*
name|isleptp
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Wait for a lock held. 	 */
while|while
condition|(
name|lp
operator|->
name|nfslock_lock
operator|&
name|NFSV4LOCK_LOCK
condition|)
block|{
if|if
condition|(
name|mp
operator|!=
name|NULL
operator|&&
operator|(
name|mp
operator|->
name|mnt_kern_flag
operator|&
name|MNTK_UNMOUNTF
operator|)
operator|!=
literal|0
condition|)
return|return;
name|lp
operator|->
name|nfslock_lock
operator||=
name|NFSV4LOCK_WANTED
expr_stmt|;
if|if
condition|(
name|isleptp
condition|)
operator|*
name|isleptp
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|nfsmsleep
argument_list|(
operator|&
name|lp
operator|->
name|nfslock_lock
argument_list|,
name|mutex
argument_list|,
name|PZERO
operator|-
literal|1
argument_list|,
literal|"nfsv4gr"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mp
operator|!=
name|NULL
operator|&&
operator|(
name|mp
operator|->
name|mnt_kern_flag
operator|&
name|MNTK_UNMOUNTF
operator|)
operator|!=
literal|0
condition|)
return|return;
name|lp
operator|->
name|nfslock_usecnt
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get a reference as above, but return failure instead of sleeping if  * an exclusive lock is held.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsv4_getref_nonblock
parameter_list|(
name|struct
name|nfsv4lock
modifier|*
name|lp
parameter_list|)
block|{
if|if
condition|(
operator|(
name|lp
operator|->
name|nfslock_lock
operator|&
name|NFSV4LOCK_LOCK
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|lp
operator|->
name|nfslock_usecnt
operator|++
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Test for a lock. Return 1 if locked, 0 otherwise.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsv4_testlock
parameter_list|(
name|struct
name|nfsv4lock
modifier|*
name|lp
parameter_list|)
block|{
if|if
condition|(
operator|(
name|lp
operator|->
name|nfslock_lock
operator|&
name|NFSV4LOCK_LOCK
operator|)
operator|==
literal|0
operator|&&
name|lp
operator|->
name|nfslock_usecnt
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Wake up anyone sleeping, waiting for this lock.  */
end_comment

begin_function
specifier|static
name|void
name|nfsv4_wanted
parameter_list|(
name|struct
name|nfsv4lock
modifier|*
name|lp
parameter_list|)
block|{
if|if
condition|(
name|lp
operator|->
name|nfslock_lock
operator|&
name|NFSV4LOCK_WANTED
condition|)
block|{
name|lp
operator|->
name|nfslock_lock
operator|&=
operator|~
name|NFSV4LOCK_WANTED
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|lp
operator|->
name|nfslock_lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Copy a string from an mbuf list into a character array.  * Return EBADRPC if there is an mbuf error,  * 0 otherwise.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrv_mtostr
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|,
name|char
modifier|*
name|str
parameter_list|,
name|int
name|siz
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|xfer
decl_stmt|,
name|len
decl_stmt|;
name|mbuf_t
name|mp
decl_stmt|;
name|int
name|rem
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|mp
operator|=
name|nd
operator|->
name|nd_md
expr_stmt|;
name|cp
operator|=
name|nd
operator|->
name|nd_dpos
expr_stmt|;
name|len
operator|=
name|NFSMTOD
argument_list|(
name|mp
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|mbuf_len
argument_list|(
name|mp
argument_list|)
operator|-
name|cp
expr_stmt|;
name|rem
operator|=
name|NFSM_RNDUP
argument_list|(
name|siz
argument_list|)
operator|-
name|siz
expr_stmt|;
while|while
condition|(
name|siz
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|len
operator|>
name|siz
condition|)
name|xfer
operator|=
name|siz
expr_stmt|;
else|else
name|xfer
operator|=
name|len
expr_stmt|;
name|NFSBCOPY
argument_list|(
name|cp
argument_list|,
name|str
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
name|str
operator|+=
name|xfer
expr_stmt|;
name|siz
operator|-=
name|xfer
expr_stmt|;
if|if
condition|(
name|siz
operator|>
literal|0
condition|)
block|{
name|mp
operator|=
name|mbuf_next
argument_list|(
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EBADRPC
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|cp
operator|=
name|NFSMTOD
argument_list|(
name|mp
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
name|len
operator|=
name|mbuf_len
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cp
operator|+=
name|xfer
expr_stmt|;
name|len
operator|-=
name|xfer
expr_stmt|;
block|}
block|}
operator|*
name|str
operator|=
literal|'\0'
expr_stmt|;
name|nd
operator|->
name|nd_dpos
operator|=
name|cp
expr_stmt|;
name|nd
operator|->
name|nd_md
operator|=
name|mp
expr_stmt|;
if|if
condition|(
name|rem
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|len
operator|<
name|rem
condition|)
name|error
operator|=
name|nfsm_advance
argument_list|(
name|nd
argument_list|,
name|rem
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
name|nd
operator|->
name|nd_dpos
operator|+=
name|rem
expr_stmt|;
block|}
name|out
label|:
name|NFSEXITCODE2
argument_list|(
name|error
argument_list|,
name|nd
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Fill in the attributes as marked by the bitmap (V4).  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsv4_fillattr
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|,
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|vnode_t
name|vp
parameter_list|,
name|NFSACL_T
modifier|*
name|saclp
parameter_list|,
name|struct
name|vattr
modifier|*
name|vap
parameter_list|,
name|fhandle_t
modifier|*
name|fhp
parameter_list|,
name|int
name|rderror
parameter_list|,
name|nfsattrbit_t
modifier|*
name|attrbitp
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|int
name|isdgram
parameter_list|,
name|int
name|reterr
parameter_list|,
name|int
name|supports_nfsv4acls
parameter_list|,
name|int
name|at_root
parameter_list|,
name|uint64_t
name|mounted_on_fileno
parameter_list|)
block|{
name|int
name|bitpos
decl_stmt|,
name|retnum
init|=
literal|0
decl_stmt|;
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|int
name|siz
decl_stmt|,
name|prefixnum
decl_stmt|,
name|error
decl_stmt|;
name|u_char
modifier|*
name|cp
decl_stmt|,
name|namestr
index|[
name|NFSV4_SMALLSTR
index|]
decl_stmt|;
name|nfsattrbit_t
name|attrbits
decl_stmt|,
name|retbits
decl_stmt|;
name|nfsattrbit_t
modifier|*
name|retbitp
init|=
operator|&
name|retbits
decl_stmt|;
name|u_int32_t
name|freenum
decl_stmt|,
modifier|*
name|retnump
decl_stmt|;
name|u_int64_t
name|uquad
decl_stmt|;
name|struct
name|statfs
name|fs
decl_stmt|;
name|struct
name|nfsfsinfo
name|fsinf
decl_stmt|;
name|struct
name|timespec
name|temptime
decl_stmt|;
name|NFSACL_T
modifier|*
name|aclp
decl_stmt|,
modifier|*
name|naclp
init|=
name|NULL
decl_stmt|;
ifdef|#
directive|ifdef
name|QUOTA
name|struct
name|dqblk
name|dqb
decl_stmt|;
name|uid_t
name|savuid
decl_stmt|;
endif|#
directive|endif
comment|/* 	 * First, set the bits that can be filled and get fsinfo. 	 */
name|NFSSET_ATTRBIT
argument_list|(
name|retbitp
argument_list|,
name|attrbitp
argument_list|)
expr_stmt|;
comment|/* 	 * If both p and cred are NULL, it is a client side setattr call. 	 * If both p and cred are not NULL, it is a server side reply call. 	 * If p is not NULL and cred is NULL, it is a client side callback 	 * reply call. 	 */
if|if
condition|(
name|p
operator|==
name|NULL
operator|&&
name|cred
operator|==
name|NULL
condition|)
block|{
name|NFSCLRNOTSETABLE_ATTRBIT
argument_list|(
name|retbitp
argument_list|)
expr_stmt|;
name|aclp
operator|=
name|saclp
expr_stmt|;
block|}
else|else
block|{
name|NFSCLRNOTFILLABLE_ATTRBIT
argument_list|(
name|retbitp
argument_list|)
expr_stmt|;
name|naclp
operator|=
name|acl_alloc
argument_list|(
name|M_WAITOK
argument_list|)
expr_stmt|;
name|aclp
operator|=
name|naclp
expr_stmt|;
block|}
name|nfsvno_getfs
argument_list|(
operator|&
name|fsinf
argument_list|,
name|isdgram
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|APPLE
comment|/* 	 * Get the VFS_STATFS(), since some attributes need them. 	 */
if|if
condition|(
name|NFSISSETSTATFS_ATTRBIT
argument_list|(
name|retbitp
argument_list|)
condition|)
block|{
name|error
operator|=
name|VFS_STATFS
argument_list|(
name|mp
argument_list|,
operator|&
name|fs
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|reterr
condition|)
block|{
name|nd
operator|->
name|nd_repstat
operator|=
name|NFSERR_ACCES
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|NFSCLRSTATFS_ATTRBIT
argument_list|(
name|retbitp
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* 	 * And the NFSv4 ACL... 	 */
if|if
condition|(
name|NFSISSET_ATTRBIT
argument_list|(
name|retbitp
argument_list|,
name|NFSATTRBIT_ACLSUPPORT
argument_list|)
operator|&&
operator|(
name|nfsrv_useacl
operator|==
literal|0
operator|||
operator|(
operator|(
name|cred
operator|!=
name|NULL
operator|||
name|p
operator|!=
name|NULL
operator|)
operator|&&
name|supports_nfsv4acls
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|NFSCLRBIT_ATTRBIT
argument_list|(
name|retbitp
argument_list|,
name|NFSATTRBIT_ACLSUPPORT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|NFSISSET_ATTRBIT
argument_list|(
name|retbitp
argument_list|,
name|NFSATTRBIT_ACL
argument_list|)
condition|)
block|{
if|if
condition|(
name|nfsrv_useacl
operator|==
literal|0
operator|||
operator|(
operator|(
name|cred
operator|!=
name|NULL
operator|||
name|p
operator|!=
name|NULL
operator|)
operator|&&
name|supports_nfsv4acls
operator|==
literal|0
operator|)
condition|)
block|{
name|NFSCLRBIT_ATTRBIT
argument_list|(
name|retbitp
argument_list|,
name|NFSATTRBIT_ACL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|naclp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|NFSVOPLOCK
argument_list|(
name|vp
argument_list|,
name|LK_SHARED
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|VOP_ACCESSX
argument_list|(
name|vp
argument_list|,
name|VREAD_ACL
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|VOP_GETACL
argument_list|(
name|vp
argument_list|,
name|ACL_TYPE_NFS4
argument_list|,
name|naclp
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|NFSVOPUNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
name|NFSERR_PERM
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|reterr
condition|)
block|{
name|nd
operator|->
name|nd_repstat
operator|=
name|NFSERR_ACCES
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|NFSCLRBIT_ATTRBIT
argument_list|(
name|retbitp
argument_list|,
name|NFSATTRBIT_ACL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Put out the attribute bitmap for the ones being filled in 	 * and get the field for the number of attributes returned. 	 */
name|prefixnum
operator|=
name|nfsrv_putattrbit
argument_list|(
name|nd
argument_list|,
name|retbitp
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|retnump
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|prefixnum
operator|+=
name|NFSX_UNSIGNED
expr_stmt|;
comment|/* 	 * Now, loop around filling in the attributes for each bit set. 	 */
for|for
control|(
name|bitpos
operator|=
literal|0
init|;
name|bitpos
operator|<
name|NFSATTRBIT_MAX
condition|;
name|bitpos
operator|++
control|)
block|{
if|if
condition|(
name|NFSISSET_ATTRBIT
argument_list|(
name|retbitp
argument_list|,
name|bitpos
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|bitpos
condition|)
block|{
case|case
name|NFSATTRBIT_SUPPORTEDATTRS
case|:
name|NFSSETSUPP_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|)
expr_stmt|;
if|if
condition|(
name|nfsrv_useacl
operator|==
literal|0
operator|||
operator|(
operator|(
name|cred
operator|!=
name|NULL
operator|||
name|p
operator|!=
name|NULL
operator|)
operator|&&
name|supports_nfsv4acls
operator|==
literal|0
operator|)
condition|)
block|{
name|NFSCLRBIT_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|,
name|NFSATTRBIT_ACLSUPPORT
argument_list|)
expr_stmt|;
name|NFSCLRBIT_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|,
name|NFSATTRBIT_ACL
argument_list|)
expr_stmt|;
block|}
name|retnum
operator|+=
name|nfsrv_putattrbit
argument_list|(
name|nd
argument_list|,
operator|&
name|attrbits
argument_list|)
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_TYPE
case|:
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|vtonfsv34_type
argument_list|(
name|vap
operator|->
name|va_type
argument_list|)
expr_stmt|;
name|retnum
operator|+=
name|NFSX_UNSIGNED
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_FHEXPIRETYPE
case|:
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4FHTYPE_PERSISTENT
argument_list|)
expr_stmt|;
name|retnum
operator|+=
name|NFSX_UNSIGNED
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_CHANGE
case|:
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_HYPER
argument_list|)
expr_stmt|;
name|txdr_hyper
argument_list|(
name|vap
operator|->
name|va_filerev
argument_list|,
name|tl
argument_list|)
expr_stmt|;
name|retnum
operator|+=
name|NFSX_HYPER
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_SIZE
case|:
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_HYPER
argument_list|)
expr_stmt|;
name|txdr_hyper
argument_list|(
name|vap
operator|->
name|va_size
argument_list|,
name|tl
argument_list|)
expr_stmt|;
name|retnum
operator|+=
name|NFSX_HYPER
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_LINKSUPPORT
case|:
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|fsinf
operator|.
name|fs_properties
operator|&
name|NFSV3FSINFO_LINK
condition|)
operator|*
name|tl
operator|=
name|newnfs_true
expr_stmt|;
else|else
operator|*
name|tl
operator|=
name|newnfs_false
expr_stmt|;
name|retnum
operator|+=
name|NFSX_UNSIGNED
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_SYMLINKSUPPORT
case|:
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|fsinf
operator|.
name|fs_properties
operator|&
name|NFSV3FSINFO_SYMLINK
condition|)
operator|*
name|tl
operator|=
name|newnfs_true
expr_stmt|;
else|else
operator|*
name|tl
operator|=
name|newnfs_false
expr_stmt|;
name|retnum
operator|+=
name|NFSX_UNSIGNED
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_NAMEDATTR
case|:
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|newnfs_false
expr_stmt|;
name|retnum
operator|+=
name|NFSX_UNSIGNED
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_FSID
case|:
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_V4FSID
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|mp
operator|->
name|mnt_stat
operator|.
name|f_fsid
operator|.
name|val
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|mp
operator|->
name|mnt_stat
operator|.
name|f_fsid
operator|.
name|val
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|retnum
operator|+=
name|NFSX_V4FSID
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_UNIQUEHANDLES
case|:
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|newnfs_true
expr_stmt|;
name|retnum
operator|+=
name|NFSX_UNSIGNED
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_LEASETIME
case|:
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|nfsrv_lease
argument_list|)
expr_stmt|;
name|retnum
operator|+=
name|NFSX_UNSIGNED
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_RDATTRERROR
case|:
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|rderror
argument_list|)
expr_stmt|;
name|retnum
operator|+=
name|NFSX_UNSIGNED
expr_stmt|;
break|break;
comment|/* 		 * Recommended Attributes. (Only the supported ones.) 		 */
case|case
name|NFSATTRBIT_ACL
case|:
name|retnum
operator|+=
name|nfsrv_buildacl
argument_list|(
name|nd
argument_list|,
name|aclp
argument_list|,
name|vnode_vtype
argument_list|(
name|vp
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_ACLSUPPORT
case|:
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4ACE_SUPTYPES
argument_list|)
expr_stmt|;
name|retnum
operator|+=
name|NFSX_UNSIGNED
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_CANSETTIME
case|:
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|fsinf
operator|.
name|fs_properties
operator|&
name|NFSV3FSINFO_CANSETTIME
condition|)
operator|*
name|tl
operator|=
name|newnfs_true
expr_stmt|;
else|else
operator|*
name|tl
operator|=
name|newnfs_false
expr_stmt|;
name|retnum
operator|+=
name|NFSX_UNSIGNED
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_CASEINSENSITIVE
case|:
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|newnfs_false
expr_stmt|;
name|retnum
operator|+=
name|NFSX_UNSIGNED
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_CASEPRESERVING
case|:
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|newnfs_true
expr_stmt|;
name|retnum
operator|+=
name|NFSX_UNSIGNED
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_CHOWNRESTRICTED
case|:
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|newnfs_true
expr_stmt|;
name|retnum
operator|+=
name|NFSX_UNSIGNED
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_FILEHANDLE
case|:
name|retnum
operator|+=
name|nfsm_fhtom
argument_list|(
name|nd
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
name|fhp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_FILEID
case|:
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_HYPER
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|vap
operator|->
name|va_fileid
argument_list|)
expr_stmt|;
name|retnum
operator|+=
name|NFSX_HYPER
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_FILESAVAIL
case|:
comment|/* 			 * Check quota and use min(quota, f_ffree). 			 */
name|freenum
operator|=
name|fs
operator|.
name|f_ffree
expr_stmt|;
ifdef|#
directive|ifdef
name|QUOTA
comment|/* 			 * ufs_quotactl() insists that the uid argument 			 * equal p_ruid for non-root quota access, so 			 * we'll just make sure that's the case. 			 */
name|savuid
operator|=
name|p
operator|->
name|p_cred
operator|->
name|p_ruid
expr_stmt|;
name|p
operator|->
name|p_cred
operator|->
name|p_ruid
operator|=
name|cred
operator|->
name|cr_uid
expr_stmt|;
if|if
condition|(
operator|!
name|VFS_QUOTACTL
argument_list|(
name|mp
argument_list|,
name|QCMD
argument_list|(
name|Q_GETQUOTA
argument_list|,
name|USRQUOTA
argument_list|)
argument_list|,
name|cred
operator|->
name|cr_uid
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|dqb
argument_list|)
condition|)
name|freenum
operator|=
name|min
argument_list|(
name|dqb
operator|.
name|dqb_isoftlimit
operator|-
name|dqb
operator|.
name|dqb_curinodes
argument_list|,
name|freenum
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_cred
operator|->
name|p_ruid
operator|=
name|savuid
expr_stmt|;
endif|#
directive|endif
comment|/* QUOTA */
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_HYPER
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|freenum
argument_list|)
expr_stmt|;
name|retnum
operator|+=
name|NFSX_HYPER
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_FILESFREE
case|:
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_HYPER
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|fs
operator|.
name|f_ffree
argument_list|)
expr_stmt|;
name|retnum
operator|+=
name|NFSX_HYPER
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_FILESTOTAL
case|:
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_HYPER
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|fs
operator|.
name|f_files
argument_list|)
expr_stmt|;
name|retnum
operator|+=
name|NFSX_HYPER
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_FSLOCATIONS
case|:
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|tl
operator|=
literal|0
expr_stmt|;
name|retnum
operator|+=
literal|2
operator|*
name|NFSX_UNSIGNED
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_HOMOGENEOUS
case|:
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|fsinf
operator|.
name|fs_properties
operator|&
name|NFSV3FSINFO_HOMOGENEOUS
condition|)
operator|*
name|tl
operator|=
name|newnfs_true
expr_stmt|;
else|else
operator|*
name|tl
operator|=
name|newnfs_false
expr_stmt|;
name|retnum
operator|+=
name|NFSX_UNSIGNED
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_MAXFILESIZE
case|:
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_HYPER
argument_list|)
expr_stmt|;
name|uquad
operator|=
name|NFSRV_MAXFILESIZE
expr_stmt|;
name|txdr_hyper
argument_list|(
name|uquad
argument_list|,
name|tl
argument_list|)
expr_stmt|;
name|retnum
operator|+=
name|NFSX_HYPER
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_MAXLINK
case|:
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|LINK_MAX
argument_list|)
expr_stmt|;
name|retnum
operator|+=
name|NFSX_UNSIGNED
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_MAXNAME
case|:
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFS_MAXNAMLEN
argument_list|)
expr_stmt|;
name|retnum
operator|+=
name|NFSX_UNSIGNED
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_MAXREAD
case|:
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_HYPER
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|fsinf
operator|.
name|fs_rtmax
argument_list|)
expr_stmt|;
name|retnum
operator|+=
name|NFSX_HYPER
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_MAXWRITE
case|:
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_HYPER
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|fsinf
operator|.
name|fs_wtmax
argument_list|)
expr_stmt|;
name|retnum
operator|+=
name|NFSX_HYPER
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_MODE
case|:
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|vtonfsv34_mode
argument_list|(
name|vap
operator|->
name|va_mode
argument_list|)
expr_stmt|;
name|retnum
operator|+=
name|NFSX_UNSIGNED
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_NOTRUNC
case|:
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|newnfs_true
expr_stmt|;
name|retnum
operator|+=
name|NFSX_UNSIGNED
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_NUMLINKS
case|:
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|vap
operator|->
name|va_nlink
argument_list|)
expr_stmt|;
name|retnum
operator|+=
name|NFSX_UNSIGNED
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_OWNER
case|:
name|cp
operator|=
name|namestr
expr_stmt|;
name|nfsv4_uidtostr
argument_list|(
name|vap
operator|->
name|va_uid
argument_list|,
operator|&
name|cp
argument_list|,
operator|&
name|siz
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|retnum
operator|+=
name|nfsm_strtom
argument_list|(
name|nd
argument_list|,
name|cp
argument_list|,
name|siz
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|namestr
condition|)
name|free
argument_list|(
name|cp
argument_list|,
name|M_NFSSTRING
argument_list|)
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_OWNERGROUP
case|:
name|cp
operator|=
name|namestr
expr_stmt|;
name|nfsv4_gidtostr
argument_list|(
name|vap
operator|->
name|va_gid
argument_list|,
operator|&
name|cp
argument_list|,
operator|&
name|siz
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|retnum
operator|+=
name|nfsm_strtom
argument_list|(
name|nd
argument_list|,
name|cp
argument_list|,
name|siz
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|namestr
condition|)
name|free
argument_list|(
name|cp
argument_list|,
name|M_NFSSTRING
argument_list|)
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_QUOTAHARD
case|:
if|if
condition|(
name|priv_check_cred
argument_list|(
name|cred
argument_list|,
name|PRIV_VFS_EXCEEDQUOTA
argument_list|,
literal|0
argument_list|)
condition|)
name|freenum
operator|=
name|fs
operator|.
name|f_bfree
expr_stmt|;
else|else
name|freenum
operator|=
name|fs
operator|.
name|f_bavail
expr_stmt|;
ifdef|#
directive|ifdef
name|QUOTA
comment|/* 			 * ufs_quotactl() insists that the uid argument 			 * equal p_ruid for non-root quota access, so 			 * we'll just make sure that's the case. 			 */
name|savuid
operator|=
name|p
operator|->
name|p_cred
operator|->
name|p_ruid
expr_stmt|;
name|p
operator|->
name|p_cred
operator|->
name|p_ruid
operator|=
name|cred
operator|->
name|cr_uid
expr_stmt|;
if|if
condition|(
operator|!
name|VFS_QUOTACTL
argument_list|(
name|mp
argument_list|,
name|QCMD
argument_list|(
name|Q_GETQUOTA
argument_list|,
name|USRQUOTA
argument_list|)
argument_list|,
name|cred
operator|->
name|cr_uid
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|dqb
argument_list|)
condition|)
name|freenum
operator|=
name|min
argument_list|(
name|dqb
operator|.
name|dqb_bhardlimit
argument_list|,
name|freenum
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_cred
operator|->
name|p_ruid
operator|=
name|savuid
expr_stmt|;
endif|#
directive|endif
comment|/* QUOTA */
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_HYPER
argument_list|)
expr_stmt|;
name|uquad
operator|=
operator|(
name|u_int64_t
operator|)
name|freenum
expr_stmt|;
name|NFSQUOTABLKTOBYTE
argument_list|(
name|uquad
argument_list|,
name|fs
operator|.
name|f_bsize
argument_list|)
expr_stmt|;
name|txdr_hyper
argument_list|(
name|uquad
argument_list|,
name|tl
argument_list|)
expr_stmt|;
name|retnum
operator|+=
name|NFSX_HYPER
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_QUOTASOFT
case|:
if|if
condition|(
name|priv_check_cred
argument_list|(
name|cred
argument_list|,
name|PRIV_VFS_EXCEEDQUOTA
argument_list|,
literal|0
argument_list|)
condition|)
name|freenum
operator|=
name|fs
operator|.
name|f_bfree
expr_stmt|;
else|else
name|freenum
operator|=
name|fs
operator|.
name|f_bavail
expr_stmt|;
ifdef|#
directive|ifdef
name|QUOTA
comment|/* 			 * ufs_quotactl() insists that the uid argument 			 * equal p_ruid for non-root quota access, so 			 * we'll just make sure that's the case. 			 */
name|savuid
operator|=
name|p
operator|->
name|p_cred
operator|->
name|p_ruid
expr_stmt|;
name|p
operator|->
name|p_cred
operator|->
name|p_ruid
operator|=
name|cred
operator|->
name|cr_uid
expr_stmt|;
if|if
condition|(
operator|!
name|VFS_QUOTACTL
argument_list|(
name|mp
argument_list|,
name|QCMD
argument_list|(
name|Q_GETQUOTA
argument_list|,
name|USRQUOTA
argument_list|)
argument_list|,
name|cred
operator|->
name|cr_uid
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|dqb
argument_list|)
condition|)
name|freenum
operator|=
name|min
argument_list|(
name|dqb
operator|.
name|dqb_bsoftlimit
argument_list|,
name|freenum
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_cred
operator|->
name|p_ruid
operator|=
name|savuid
expr_stmt|;
endif|#
directive|endif
comment|/* QUOTA */
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_HYPER
argument_list|)
expr_stmt|;
name|uquad
operator|=
operator|(
name|u_int64_t
operator|)
name|freenum
expr_stmt|;
name|NFSQUOTABLKTOBYTE
argument_list|(
name|uquad
argument_list|,
name|fs
operator|.
name|f_bsize
argument_list|)
expr_stmt|;
name|txdr_hyper
argument_list|(
name|uquad
argument_list|,
name|tl
argument_list|)
expr_stmt|;
name|retnum
operator|+=
name|NFSX_HYPER
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_QUOTAUSED
case|:
name|freenum
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|QUOTA
comment|/* 			 * ufs_quotactl() insists that the uid argument 			 * equal p_ruid for non-root quota access, so 			 * we'll just make sure that's the case. 			 */
name|savuid
operator|=
name|p
operator|->
name|p_cred
operator|->
name|p_ruid
expr_stmt|;
name|p
operator|->
name|p_cred
operator|->
name|p_ruid
operator|=
name|cred
operator|->
name|cr_uid
expr_stmt|;
if|if
condition|(
operator|!
name|VFS_QUOTACTL
argument_list|(
name|mp
argument_list|,
name|QCMD
argument_list|(
name|Q_GETQUOTA
argument_list|,
name|USRQUOTA
argument_list|)
argument_list|,
name|cred
operator|->
name|cr_uid
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|dqb
argument_list|)
condition|)
name|freenum
operator|=
name|dqb
operator|.
name|dqb_curblocks
expr_stmt|;
name|p
operator|->
name|p_cred
operator|->
name|p_ruid
operator|=
name|savuid
expr_stmt|;
endif|#
directive|endif
comment|/* QUOTA */
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_HYPER
argument_list|)
expr_stmt|;
name|uquad
operator|=
operator|(
name|u_int64_t
operator|)
name|freenum
expr_stmt|;
name|NFSQUOTABLKTOBYTE
argument_list|(
name|uquad
argument_list|,
name|fs
operator|.
name|f_bsize
argument_list|)
expr_stmt|;
name|txdr_hyper
argument_list|(
name|uquad
argument_list|,
name|tl
argument_list|)
expr_stmt|;
name|retnum
operator|+=
name|NFSX_HYPER
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_RAWDEV
case|:
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_V4SPECDATA
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|NFSMAJOR
argument_list|(
name|vap
operator|->
name|va_rdev
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSMINOR
argument_list|(
name|vap
operator|->
name|va_rdev
argument_list|)
argument_list|)
expr_stmt|;
name|retnum
operator|+=
name|NFSX_V4SPECDATA
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_SPACEAVAIL
case|:
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_HYPER
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv_check_cred
argument_list|(
name|cred
argument_list|,
name|PRIV_VFS_BLOCKRESERVE
argument_list|,
literal|0
argument_list|)
condition|)
name|uquad
operator|=
operator|(
name|u_int64_t
operator|)
name|fs
operator|.
name|f_bfree
expr_stmt|;
else|else
name|uquad
operator|=
operator|(
name|u_int64_t
operator|)
name|fs
operator|.
name|f_bavail
expr_stmt|;
name|uquad
operator|*=
name|fs
operator|.
name|f_bsize
expr_stmt|;
name|txdr_hyper
argument_list|(
name|uquad
argument_list|,
name|tl
argument_list|)
expr_stmt|;
name|retnum
operator|+=
name|NFSX_HYPER
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_SPACEFREE
case|:
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_HYPER
argument_list|)
expr_stmt|;
name|uquad
operator|=
operator|(
name|u_int64_t
operator|)
name|fs
operator|.
name|f_bfree
expr_stmt|;
name|uquad
operator|*=
name|fs
operator|.
name|f_bsize
expr_stmt|;
name|txdr_hyper
argument_list|(
name|uquad
argument_list|,
name|tl
argument_list|)
expr_stmt|;
name|retnum
operator|+=
name|NFSX_HYPER
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_SPACETOTAL
case|:
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_HYPER
argument_list|)
expr_stmt|;
name|uquad
operator|=
operator|(
name|u_int64_t
operator|)
name|fs
operator|.
name|f_blocks
expr_stmt|;
name|uquad
operator|*=
name|fs
operator|.
name|f_bsize
expr_stmt|;
name|txdr_hyper
argument_list|(
name|uquad
argument_list|,
name|tl
argument_list|)
expr_stmt|;
name|retnum
operator|+=
name|NFSX_HYPER
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_SPACEUSED
case|:
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_HYPER
argument_list|)
expr_stmt|;
name|txdr_hyper
argument_list|(
name|vap
operator|->
name|va_bytes
argument_list|,
name|tl
argument_list|)
expr_stmt|;
name|retnum
operator|+=
name|NFSX_HYPER
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_TIMEACCESS
case|:
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_V4TIME
argument_list|)
expr_stmt|;
name|txdr_nfsv4time
argument_list|(
operator|&
name|vap
operator|->
name|va_atime
argument_list|,
name|tl
argument_list|)
expr_stmt|;
name|retnum
operator|+=
name|NFSX_V4TIME
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_TIMEACCESSSET
case|:
if|if
condition|(
operator|(
name|vap
operator|->
name|va_vaflags
operator|&
name|VA_UTIMES_NULL
operator|)
operator|==
literal|0
condition|)
block|{
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_V4SETTIME
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4SATTRTIME_TOCLIENT
argument_list|)
expr_stmt|;
name|txdr_nfsv4time
argument_list|(
operator|&
name|vap
operator|->
name|va_atime
argument_list|,
name|tl
argument_list|)
expr_stmt|;
name|retnum
operator|+=
name|NFSX_V4SETTIME
expr_stmt|;
block|}
else|else
block|{
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4SATTRTIME_TOSERVER
argument_list|)
expr_stmt|;
name|retnum
operator|+=
name|NFSX_UNSIGNED
expr_stmt|;
block|}
break|break;
case|case
name|NFSATTRBIT_TIMEDELTA
case|:
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_V4TIME
argument_list|)
expr_stmt|;
name|temptime
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|temptime
operator|.
name|tv_nsec
operator|=
literal|1000000000
operator|/
name|hz
expr_stmt|;
name|txdr_nfsv4time
argument_list|(
operator|&
name|temptime
argument_list|,
name|tl
argument_list|)
expr_stmt|;
name|retnum
operator|+=
name|NFSX_V4TIME
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_TIMEMETADATA
case|:
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_V4TIME
argument_list|)
expr_stmt|;
name|txdr_nfsv4time
argument_list|(
operator|&
name|vap
operator|->
name|va_ctime
argument_list|,
name|tl
argument_list|)
expr_stmt|;
name|retnum
operator|+=
name|NFSX_V4TIME
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_TIMEMODIFY
case|:
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_V4TIME
argument_list|)
expr_stmt|;
name|txdr_nfsv4time
argument_list|(
operator|&
name|vap
operator|->
name|va_mtime
argument_list|,
name|tl
argument_list|)
expr_stmt|;
name|retnum
operator|+=
name|NFSX_V4TIME
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_TIMEMODIFYSET
case|:
if|if
condition|(
operator|(
name|vap
operator|->
name|va_vaflags
operator|&
name|VA_UTIMES_NULL
operator|)
operator|==
literal|0
condition|)
block|{
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_V4SETTIME
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4SATTRTIME_TOCLIENT
argument_list|)
expr_stmt|;
name|txdr_nfsv4time
argument_list|(
operator|&
name|vap
operator|->
name|va_mtime
argument_list|,
name|tl
argument_list|)
expr_stmt|;
name|retnum
operator|+=
name|NFSX_V4SETTIME
expr_stmt|;
block|}
else|else
block|{
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4SATTRTIME_TOSERVER
argument_list|)
expr_stmt|;
name|retnum
operator|+=
name|NFSX_UNSIGNED
expr_stmt|;
block|}
break|break;
case|case
name|NFSATTRBIT_MOUNTEDONFILEID
case|:
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_HYPER
argument_list|)
expr_stmt|;
if|if
condition|(
name|at_root
operator|!=
literal|0
condition|)
name|uquad
operator|=
name|mounted_on_fileno
expr_stmt|;
else|else
name|uquad
operator|=
operator|(
name|u_int64_t
operator|)
name|vap
operator|->
name|va_fileid
expr_stmt|;
name|txdr_hyper
argument_list|(
name|uquad
argument_list|,
name|tl
argument_list|)
expr_stmt|;
name|retnum
operator|+=
name|NFSX_HYPER
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_SUPPATTREXCLCREAT
case|:
name|NFSSETSUPP_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|)
expr_stmt|;
name|NFSCLRNOTSETABLE_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|)
expr_stmt|;
name|NFSCLRBIT_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|,
name|NFSATTRBIT_TIMEACCESSSET
argument_list|)
expr_stmt|;
name|retnum
operator|+=
name|nfsrv_putattrbit
argument_list|(
name|nd
argument_list|,
operator|&
name|attrbits
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"EEK! Bad V4 attribute bitpos=%d\n"
argument_list|,
name|bitpos
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
block|}
if|if
condition|(
name|naclp
operator|!=
name|NULL
condition|)
name|acl_free
argument_list|(
name|naclp
argument_list|)
expr_stmt|;
operator|*
name|retnump
operator|=
name|txdr_unsigned
argument_list|(
name|retnum
argument_list|)
expr_stmt|;
return|return
operator|(
name|retnum
operator|+
name|prefixnum
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Put the attribute bits onto an mbuf list.  * Return the number of bytes of output generated.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrv_putattrbit
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|,
name|nfsattrbit_t
modifier|*
name|attrbitp
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|int
name|cnt
decl_stmt|,
name|i
decl_stmt|,
name|bytesize
decl_stmt|;
for|for
control|(
name|cnt
operator|=
name|NFSATTRBIT_MAXWORDS
init|;
name|cnt
operator|>
literal|0
condition|;
name|cnt
operator|--
control|)
if|if
condition|(
name|attrbitp
operator|->
name|bits
index|[
name|cnt
operator|-
literal|1
index|]
condition|)
break|break;
name|bytesize
operator|=
operator|(
name|cnt
operator|+
literal|1
operator|)
operator|*
name|NFSX_UNSIGNED
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|bytesize
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|cnt
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|attrbitp
operator|->
name|bits
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|bytesize
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert a uid to a string.  * If the lookup fails, just output the digits.  * uid - the user id  * cpp - points to a buffer of size NFSV4_SMALLSTR  *       (malloc a larger one, as required)  * retlenp - pointer to length to be returned  */
end_comment

begin_function
name|APPLESTATIC
name|void
name|nfsv4_uidtostr
parameter_list|(
name|uid_t
name|uid
parameter_list|,
name|u_char
modifier|*
modifier|*
name|cpp
parameter_list|,
name|int
modifier|*
name|retlenp
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|nfsusrgrp
modifier|*
name|usrp
decl_stmt|;
name|u_char
modifier|*
name|cp
init|=
operator|*
name|cpp
decl_stmt|;
name|uid_t
name|tmp
decl_stmt|;
name|int
name|cnt
decl_stmt|,
name|hasampersand
decl_stmt|,
name|len
init|=
name|NFSV4_SMALLSTR
decl_stmt|,
name|ret
decl_stmt|;
name|struct
name|nfsrv_lughash
modifier|*
name|hp
decl_stmt|;
name|cnt
operator|=
literal|0
expr_stmt|;
name|tryagain
label|:
if|if
condition|(
name|nfsrv_dnsnamelen
operator|>
literal|0
condition|)
block|{
comment|/* 		 * Always map nfsrv_defaultuid to "nobody". 		 */
if|if
condition|(
name|uid
operator|==
name|nfsrv_defaultuid
condition|)
block|{
name|i
operator|=
name|nfsrv_dnsnamelen
operator|+
literal|7
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|len
condition|)
block|{
if|if
condition|(
name|len
operator|>
name|NFSV4_SMALLSTR
condition|)
name|free
argument_list|(
name|cp
argument_list|,
name|M_NFSSTRING
argument_list|)
expr_stmt|;
name|cp
operator|=
name|malloc
argument_list|(
name|i
argument_list|,
name|M_NFSSTRING
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
operator|*
name|cpp
operator|=
name|cp
expr_stmt|;
name|len
operator|=
name|i
expr_stmt|;
goto|goto
name|tryagain
goto|;
block|}
operator|*
name|retlenp
operator|=
name|i
expr_stmt|;
name|NFSBCOPY
argument_list|(
literal|"nobody@"
argument_list|,
name|cp
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|cp
operator|+=
literal|7
expr_stmt|;
name|NFSBCOPY
argument_list|(
name|nfsrv_dnsname
argument_list|,
name|cp
argument_list|,
name|nfsrv_dnsnamelen
argument_list|)
expr_stmt|;
return|return;
block|}
name|hasampersand
operator|=
literal|0
expr_stmt|;
name|hp
operator|=
name|NFSUSERHASH
argument_list|(
name|uid
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|hp
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|usrp
argument_list|,
argument|&hp->lughead
argument_list|,
argument|lug_numhash
argument_list|)
block|{
if|if
condition|(
name|usrp
operator|->
name|lug_uid
operator|==
name|uid
condition|)
block|{
if|if
condition|(
name|usrp
operator|->
name|lug_expiry
operator|<
name|NFSD_MONOSEC
condition|)
break|break;
comment|/* 				 * If the name doesn't already have an '@' 				 * in it, append @domainname to it. 				 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|usrp
operator|->
name|lug_namelen
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|usrp
operator|->
name|lug_name
index|[
name|i
index|]
operator|==
literal|'@'
condition|)
block|{
name|hasampersand
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|hasampersand
condition|)
name|i
operator|=
name|usrp
operator|->
name|lug_namelen
expr_stmt|;
else|else
name|i
operator|=
name|usrp
operator|->
name|lug_namelen
operator|+
name|nfsrv_dnsnamelen
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|len
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|hp
operator|->
name|mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|NFSV4_SMALLSTR
condition|)
name|free
argument_list|(
name|cp
argument_list|,
name|M_NFSSTRING
argument_list|)
expr_stmt|;
name|cp
operator|=
name|malloc
argument_list|(
name|i
argument_list|,
name|M_NFSSTRING
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
operator|*
name|cpp
operator|=
name|cp
expr_stmt|;
name|len
operator|=
name|i
expr_stmt|;
goto|goto
name|tryagain
goto|;
block|}
operator|*
name|retlenp
operator|=
name|i
expr_stmt|;
name|NFSBCOPY
argument_list|(
name|usrp
operator|->
name|lug_name
argument_list|,
name|cp
argument_list|,
name|usrp
operator|->
name|lug_namelen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hasampersand
condition|)
block|{
name|cp
operator|+=
name|usrp
operator|->
name|lug_namelen
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'@'
expr_stmt|;
name|NFSBCOPY
argument_list|(
name|nfsrv_dnsname
argument_list|,
name|cp
argument_list|,
name|nfsrv_dnsnamelen
argument_list|)
expr_stmt|;
block|}
name|TAILQ_REMOVE
argument_list|(
operator|&
name|hp
operator|->
name|lughead
argument_list|,
name|usrp
argument_list|,
name|lug_numhash
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|hp
operator|->
name|lughead
argument_list|,
name|usrp
argument_list|,
name|lug_numhash
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|hp
operator|->
name|mtx
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|hp
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
name|ret
operator|=
name|nfsrv_getuser
argument_list|(
name|RPCNFSUSERD_GETUID
argument_list|,
name|uid
argument_list|,
operator|(
name|gid_t
operator|)
literal|0
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
operator|&&
name|cnt
operator|<
literal|2
condition|)
goto|goto
name|tryagain
goto|;
block|}
comment|/* 	 * No match, just return a string of digits. 	 */
name|tmp
operator|=
name|uid
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|tmp
operator|||
name|i
operator|==
literal|0
condition|)
block|{
name|tmp
operator|/=
literal|10
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|len
operator|=
operator|(
name|i
operator|>
name|len
operator|)
condition|?
name|len
else|:
name|i
expr_stmt|;
operator|*
name|retlenp
operator|=
name|len
expr_stmt|;
name|cp
operator|+=
operator|(
name|len
operator|-
literal|1
operator|)
expr_stmt|;
name|tmp
operator|=
name|uid
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|cp
operator|--
operator|=
literal|'0'
operator|+
operator|(
name|tmp
operator|%
literal|10
operator|)
expr_stmt|;
name|tmp
operator|/=
literal|10
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * Get a credential for the uid with the server's group list.  * If none is found, just return the credential passed in after  * logging a warning message.  */
end_comment

begin_function
name|struct
name|ucred
modifier|*
name|nfsrv_getgrpscred
parameter_list|(
name|struct
name|ucred
modifier|*
name|oldcred
parameter_list|)
block|{
name|struct
name|nfsusrgrp
modifier|*
name|usrp
decl_stmt|;
name|struct
name|ucred
modifier|*
name|newcred
decl_stmt|;
name|int
name|cnt
decl_stmt|,
name|ret
decl_stmt|;
name|uid_t
name|uid
decl_stmt|;
name|struct
name|nfsrv_lughash
modifier|*
name|hp
decl_stmt|;
name|cnt
operator|=
literal|0
expr_stmt|;
name|uid
operator|=
name|oldcred
operator|->
name|cr_uid
expr_stmt|;
name|tryagain
label|:
if|if
condition|(
name|nfsrv_dnsnamelen
operator|>
literal|0
condition|)
block|{
name|hp
operator|=
name|NFSUSERHASH
argument_list|(
name|uid
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|hp
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|usrp
argument_list|,
argument|&hp->lughead
argument_list|,
argument|lug_numhash
argument_list|)
block|{
if|if
condition|(
name|usrp
operator|->
name|lug_uid
operator|==
name|uid
condition|)
block|{
if|if
condition|(
name|usrp
operator|->
name|lug_expiry
operator|<
name|NFSD_MONOSEC
condition|)
break|break;
if|if
condition|(
name|usrp
operator|->
name|lug_cred
operator|!=
name|NULL
condition|)
block|{
name|newcred
operator|=
name|crhold
argument_list|(
name|usrp
operator|->
name|lug_cred
argument_list|)
expr_stmt|;
name|crfree
argument_list|(
name|oldcred
argument_list|)
expr_stmt|;
block|}
else|else
name|newcred
operator|=
name|oldcred
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|hp
operator|->
name|lughead
argument_list|,
name|usrp
argument_list|,
name|lug_numhash
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|hp
operator|->
name|lughead
argument_list|,
name|usrp
argument_list|,
name|lug_numhash
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|hp
operator|->
name|mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|newcred
operator|)
return|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|hp
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
name|ret
operator|=
name|nfsrv_getuser
argument_list|(
name|RPCNFSUSERD_GETUID
argument_list|,
name|uid
argument_list|,
operator|(
name|gid_t
operator|)
literal|0
argument_list|,
name|NULL
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
operator|&&
name|cnt
operator|<
literal|2
condition|)
goto|goto
name|tryagain
goto|;
block|}
return|return
operator|(
name|oldcred
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert a string to a uid.  * If no conversion is possible return NFSERR_BADOWNER, otherwise  * return 0.  * If this is called from a client side mount using AUTH_SYS and the  * string is made up entirely of digits, just convert the string to  * a number.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsv4_strtouid
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|,
name|u_char
modifier|*
name|str
parameter_list|,
name|int
name|len
parameter_list|,
name|uid_t
modifier|*
name|uidp
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|endstr
decl_stmt|,
modifier|*
name|str0
decl_stmt|;
name|struct
name|nfsusrgrp
modifier|*
name|usrp
decl_stmt|;
name|int
name|cnt
decl_stmt|,
name|ret
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|uid_t
name|tuid
decl_stmt|;
name|struct
name|nfsrv_lughash
modifier|*
name|hp
decl_stmt|,
modifier|*
name|hp2
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|NFSERR_BADOWNER
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* If a string of digits and an AUTH_SYS mount, just convert it. */
name|str0
operator|=
name|str
expr_stmt|;
name|tuid
operator|=
operator|(
name|uid_t
operator|)
name|strtoul
argument_list|(
name|str0
argument_list|,
operator|&
name|endstr
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|endstr
operator|-
name|str0
operator|)
operator|==
name|len
condition|)
block|{
comment|/* A numeric string. */
if|if
condition|(
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_KERBV
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSCL
operator|)
operator|!=
literal|0
operator|||
name|nfsd_enable_stringtouid
operator|!=
literal|0
operator|)
condition|)
operator|*
name|uidp
operator|=
name|tuid
expr_stmt|;
else|else
name|error
operator|=
name|NFSERR_BADOWNER
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Look for an '@'. 	 */
name|cp
operator|=
name|strchr
argument_list|(
name|str0
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
name|i
operator|=
call|(
name|int
call|)
argument_list|(
name|cp
operator|++
operator|-
name|str0
argument_list|)
expr_stmt|;
else|else
name|i
operator|=
name|len
expr_stmt|;
name|cnt
operator|=
literal|0
expr_stmt|;
name|tryagain
label|:
if|if
condition|(
name|nfsrv_dnsnamelen
operator|>
literal|0
condition|)
block|{
comment|/* 		 * If an '@' is found and the domain name matches, search for 		 * the name with dns stripped off. 		 * Mixed case alpahbetics will match for the domain name, but 		 * all upper case will not. 		 */
if|if
condition|(
name|cnt
operator|==
literal|0
operator|&&
name|i
operator|<
name|len
operator|&&
name|i
operator|>
literal|0
operator|&&
operator|(
name|len
operator|-
literal|1
operator|-
name|i
operator|)
operator|==
name|nfsrv_dnsnamelen
operator|&&
operator|!
name|nfsrv_cmpmixedcase
argument_list|(
name|cp
argument_list|,
name|nfsrv_dnsname
argument_list|,
name|nfsrv_dnsnamelen
argument_list|)
condition|)
block|{
name|len
operator|-=
operator|(
name|nfsrv_dnsnamelen
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
operator|(
name|cp
operator|-
literal|1
operator|)
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* 		 * Check for the special case of "nobody". 		 */
if|if
condition|(
name|len
operator|==
literal|6
operator|&&
operator|!
name|NFSBCMP
argument_list|(
name|str
argument_list|,
literal|"nobody"
argument_list|,
literal|6
argument_list|)
condition|)
block|{
operator|*
name|uidp
operator|=
name|nfsrv_defaultuid
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|hp
operator|=
name|NFSUSERNAMEHASH
argument_list|(
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|hp
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|usrp
argument_list|,
argument|&hp->lughead
argument_list|,
argument|lug_namehash
argument_list|)
block|{
if|if
condition|(
name|usrp
operator|->
name|lug_namelen
operator|==
name|len
operator|&&
operator|!
name|NFSBCMP
argument_list|(
name|usrp
operator|->
name|lug_name
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
condition|)
block|{
if|if
condition|(
name|usrp
operator|->
name|lug_expiry
operator|<
name|NFSD_MONOSEC
condition|)
break|break;
name|hp2
operator|=
name|NFSUSERHASH
argument_list|(
name|usrp
operator|->
name|lug_uid
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|hp2
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|hp2
operator|->
name|lughead
argument_list|,
name|usrp
argument_list|,
name|lug_numhash
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|hp2
operator|->
name|lughead
argument_list|,
name|usrp
argument_list|,
name|lug_numhash
argument_list|)
expr_stmt|;
operator|*
name|uidp
operator|=
name|usrp
operator|->
name|lug_uid
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|hp2
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|hp
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|hp
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
name|ret
operator|=
name|nfsrv_getuser
argument_list|(
name|RPCNFSUSERD_GETUSER
argument_list|,
operator|(
name|uid_t
operator|)
literal|0
argument_list|,
operator|(
name|gid_t
operator|)
literal|0
argument_list|,
name|str
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
operator|&&
name|cnt
operator|<
literal|2
condition|)
goto|goto
name|tryagain
goto|;
block|}
name|error
operator|=
name|NFSERR_BADOWNER
expr_stmt|;
name|out
label|:
name|NFSEXITCODE
argument_list|(
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert a gid to a string.  * gid - the group id  * cpp - points to a buffer of size NFSV4_SMALLSTR  *       (malloc a larger one, as required)  * retlenp - pointer to length to be returned  */
end_comment

begin_function
name|APPLESTATIC
name|void
name|nfsv4_gidtostr
parameter_list|(
name|gid_t
name|gid
parameter_list|,
name|u_char
modifier|*
modifier|*
name|cpp
parameter_list|,
name|int
modifier|*
name|retlenp
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|nfsusrgrp
modifier|*
name|usrp
decl_stmt|;
name|u_char
modifier|*
name|cp
init|=
operator|*
name|cpp
decl_stmt|;
name|gid_t
name|tmp
decl_stmt|;
name|int
name|cnt
decl_stmt|,
name|hasampersand
decl_stmt|,
name|len
init|=
name|NFSV4_SMALLSTR
decl_stmt|,
name|ret
decl_stmt|;
name|struct
name|nfsrv_lughash
modifier|*
name|hp
decl_stmt|;
name|cnt
operator|=
literal|0
expr_stmt|;
name|tryagain
label|:
if|if
condition|(
name|nfsrv_dnsnamelen
operator|>
literal|0
condition|)
block|{
comment|/* 		 * Always map nfsrv_defaultgid to "nogroup". 		 */
if|if
condition|(
name|gid
operator|==
name|nfsrv_defaultgid
condition|)
block|{
name|i
operator|=
name|nfsrv_dnsnamelen
operator|+
literal|8
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|len
condition|)
block|{
if|if
condition|(
name|len
operator|>
name|NFSV4_SMALLSTR
condition|)
name|free
argument_list|(
name|cp
argument_list|,
name|M_NFSSTRING
argument_list|)
expr_stmt|;
name|cp
operator|=
name|malloc
argument_list|(
name|i
argument_list|,
name|M_NFSSTRING
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
operator|*
name|cpp
operator|=
name|cp
expr_stmt|;
name|len
operator|=
name|i
expr_stmt|;
goto|goto
name|tryagain
goto|;
block|}
operator|*
name|retlenp
operator|=
name|i
expr_stmt|;
name|NFSBCOPY
argument_list|(
literal|"nogroup@"
argument_list|,
name|cp
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|cp
operator|+=
literal|8
expr_stmt|;
name|NFSBCOPY
argument_list|(
name|nfsrv_dnsname
argument_list|,
name|cp
argument_list|,
name|nfsrv_dnsnamelen
argument_list|)
expr_stmt|;
return|return;
block|}
name|hasampersand
operator|=
literal|0
expr_stmt|;
name|hp
operator|=
name|NFSGROUPHASH
argument_list|(
name|gid
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|hp
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|usrp
argument_list|,
argument|&hp->lughead
argument_list|,
argument|lug_numhash
argument_list|)
block|{
if|if
condition|(
name|usrp
operator|->
name|lug_gid
operator|==
name|gid
condition|)
block|{
if|if
condition|(
name|usrp
operator|->
name|lug_expiry
operator|<
name|NFSD_MONOSEC
condition|)
break|break;
comment|/* 				 * If the name doesn't already have an '@' 				 * in it, append @domainname to it. 				 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|usrp
operator|->
name|lug_namelen
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|usrp
operator|->
name|lug_name
index|[
name|i
index|]
operator|==
literal|'@'
condition|)
block|{
name|hasampersand
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|hasampersand
condition|)
name|i
operator|=
name|usrp
operator|->
name|lug_namelen
expr_stmt|;
else|else
name|i
operator|=
name|usrp
operator|->
name|lug_namelen
operator|+
name|nfsrv_dnsnamelen
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|len
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|hp
operator|->
name|mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|NFSV4_SMALLSTR
condition|)
name|free
argument_list|(
name|cp
argument_list|,
name|M_NFSSTRING
argument_list|)
expr_stmt|;
name|cp
operator|=
name|malloc
argument_list|(
name|i
argument_list|,
name|M_NFSSTRING
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
operator|*
name|cpp
operator|=
name|cp
expr_stmt|;
name|len
operator|=
name|i
expr_stmt|;
goto|goto
name|tryagain
goto|;
block|}
operator|*
name|retlenp
operator|=
name|i
expr_stmt|;
name|NFSBCOPY
argument_list|(
name|usrp
operator|->
name|lug_name
argument_list|,
name|cp
argument_list|,
name|usrp
operator|->
name|lug_namelen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hasampersand
condition|)
block|{
name|cp
operator|+=
name|usrp
operator|->
name|lug_namelen
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'@'
expr_stmt|;
name|NFSBCOPY
argument_list|(
name|nfsrv_dnsname
argument_list|,
name|cp
argument_list|,
name|nfsrv_dnsnamelen
argument_list|)
expr_stmt|;
block|}
name|TAILQ_REMOVE
argument_list|(
operator|&
name|hp
operator|->
name|lughead
argument_list|,
name|usrp
argument_list|,
name|lug_numhash
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|hp
operator|->
name|lughead
argument_list|,
name|usrp
argument_list|,
name|lug_numhash
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|hp
operator|->
name|mtx
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|hp
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
name|ret
operator|=
name|nfsrv_getuser
argument_list|(
name|RPCNFSUSERD_GETGID
argument_list|,
operator|(
name|uid_t
operator|)
literal|0
argument_list|,
name|gid
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
operator|&&
name|cnt
operator|<
literal|2
condition|)
goto|goto
name|tryagain
goto|;
block|}
comment|/* 	 * No match, just return a string of digits. 	 */
name|tmp
operator|=
name|gid
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|tmp
operator|||
name|i
operator|==
literal|0
condition|)
block|{
name|tmp
operator|/=
literal|10
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|len
operator|=
operator|(
name|i
operator|>
name|len
operator|)
condition|?
name|len
else|:
name|i
expr_stmt|;
operator|*
name|retlenp
operator|=
name|len
expr_stmt|;
name|cp
operator|+=
operator|(
name|len
operator|-
literal|1
operator|)
expr_stmt|;
name|tmp
operator|=
name|gid
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|cp
operator|--
operator|=
literal|'0'
operator|+
operator|(
name|tmp
operator|%
literal|10
operator|)
expr_stmt|;
name|tmp
operator|/=
literal|10
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * Convert a string to a gid.  * If no conversion is possible return NFSERR_BADOWNER, otherwise  * return 0.  * If this is called from a client side mount using AUTH_SYS and the  * string is made up entirely of digits, just convert the string to  * a number.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsv4_strtogid
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|,
name|u_char
modifier|*
name|str
parameter_list|,
name|int
name|len
parameter_list|,
name|gid_t
modifier|*
name|gidp
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|endstr
decl_stmt|,
modifier|*
name|str0
decl_stmt|;
name|struct
name|nfsusrgrp
modifier|*
name|usrp
decl_stmt|;
name|int
name|cnt
decl_stmt|,
name|ret
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|gid_t
name|tgid
decl_stmt|;
name|struct
name|nfsrv_lughash
modifier|*
name|hp
decl_stmt|,
modifier|*
name|hp2
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|NFSERR_BADOWNER
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* If a string of digits and an AUTH_SYS mount, just convert it. */
name|str0
operator|=
name|str
expr_stmt|;
name|tgid
operator|=
operator|(
name|gid_t
operator|)
name|strtoul
argument_list|(
name|str0
argument_list|,
operator|&
name|endstr
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|endstr
operator|-
name|str0
operator|)
operator|==
name|len
condition|)
block|{
comment|/* A numeric string. */
if|if
condition|(
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_KERBV
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSCL
operator|)
operator|!=
literal|0
operator|||
name|nfsd_enable_stringtouid
operator|!=
literal|0
operator|)
condition|)
operator|*
name|gidp
operator|=
name|tgid
expr_stmt|;
else|else
name|error
operator|=
name|NFSERR_BADOWNER
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Look for an '@'. 	 */
name|cp
operator|=
name|strchr
argument_list|(
name|str0
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
name|i
operator|=
call|(
name|int
call|)
argument_list|(
name|cp
operator|++
operator|-
name|str0
argument_list|)
expr_stmt|;
else|else
name|i
operator|=
name|len
expr_stmt|;
name|cnt
operator|=
literal|0
expr_stmt|;
name|tryagain
label|:
if|if
condition|(
name|nfsrv_dnsnamelen
operator|>
literal|0
condition|)
block|{
comment|/* 		 * If an '@' is found and the dns name matches, search for the 		 * name with the dns stripped off. 		 */
if|if
condition|(
name|cnt
operator|==
literal|0
operator|&&
name|i
operator|<
name|len
operator|&&
name|i
operator|>
literal|0
operator|&&
operator|(
name|len
operator|-
literal|1
operator|-
name|i
operator|)
operator|==
name|nfsrv_dnsnamelen
operator|&&
operator|!
name|nfsrv_cmpmixedcase
argument_list|(
name|cp
argument_list|,
name|nfsrv_dnsname
argument_list|,
name|nfsrv_dnsnamelen
argument_list|)
condition|)
block|{
name|len
operator|-=
operator|(
name|nfsrv_dnsnamelen
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
operator|(
name|cp
operator|-
literal|1
operator|)
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* 		 * Check for the special case of "nogroup". 		 */
if|if
condition|(
name|len
operator|==
literal|7
operator|&&
operator|!
name|NFSBCMP
argument_list|(
name|str
argument_list|,
literal|"nogroup"
argument_list|,
literal|7
argument_list|)
condition|)
block|{
operator|*
name|gidp
operator|=
name|nfsrv_defaultgid
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|hp
operator|=
name|NFSGROUPNAMEHASH
argument_list|(
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|hp
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|usrp
argument_list|,
argument|&hp->lughead
argument_list|,
argument|lug_namehash
argument_list|)
block|{
if|if
condition|(
name|usrp
operator|->
name|lug_namelen
operator|==
name|len
operator|&&
operator|!
name|NFSBCMP
argument_list|(
name|usrp
operator|->
name|lug_name
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
condition|)
block|{
if|if
condition|(
name|usrp
operator|->
name|lug_expiry
operator|<
name|NFSD_MONOSEC
condition|)
break|break;
name|hp2
operator|=
name|NFSGROUPHASH
argument_list|(
name|usrp
operator|->
name|lug_gid
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|hp2
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|hp2
operator|->
name|lughead
argument_list|,
name|usrp
argument_list|,
name|lug_numhash
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|hp2
operator|->
name|lughead
argument_list|,
name|usrp
argument_list|,
name|lug_numhash
argument_list|)
expr_stmt|;
operator|*
name|gidp
operator|=
name|usrp
operator|->
name|lug_gid
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|hp2
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|hp
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|hp
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
name|ret
operator|=
name|nfsrv_getuser
argument_list|(
name|RPCNFSUSERD_GETGROUP
argument_list|,
operator|(
name|uid_t
operator|)
literal|0
argument_list|,
operator|(
name|gid_t
operator|)
literal|0
argument_list|,
name|str
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
operator|&&
name|cnt
operator|<
literal|2
condition|)
goto|goto
name|tryagain
goto|;
block|}
name|error
operator|=
name|NFSERR_BADOWNER
expr_stmt|;
name|out
label|:
name|NFSEXITCODE
argument_list|(
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Cmp len chars, allowing mixed case in the first argument to match lower  * case in the second, but not if the first argument is all upper case.  * Return 0 for a match, 1 otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|nfsrv_cmpmixedcase
parameter_list|(
name|u_char
modifier|*
name|cp
parameter_list|,
name|u_char
modifier|*
name|cp2
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u_char
name|tmp
decl_stmt|;
name|int
name|fndlower
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|>=
literal|'A'
operator|&&
operator|*
name|cp
operator|<=
literal|'Z'
condition|)
block|{
name|tmp
operator|=
operator|*
name|cp
operator|++
operator|+
operator|(
literal|'a'
operator|-
literal|'A'
operator|)
expr_stmt|;
block|}
else|else
block|{
name|tmp
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
if|if
condition|(
name|tmp
operator|>=
literal|'a'
operator|&&
name|tmp
operator|<=
literal|'z'
condition|)
name|fndlower
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|tmp
operator|!=
operator|*
name|cp2
operator|++
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|fndlower
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set the port for the nfsuserd.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrv_nfsuserdport
parameter_list|(
name|u_short
name|port
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|nfssockreq
modifier|*
name|rp
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|ad
decl_stmt|;
name|int
name|error
decl_stmt|;
name|NFSLOCKNAMEID
argument_list|()
expr_stmt|;
if|if
condition|(
name|nfsrv_nfsuserd
condition|)
block|{
name|NFSUNLOCKNAMEID
argument_list|()
expr_stmt|;
name|error
operator|=
name|EPERM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|nfsrv_nfsuserd
operator|=
literal|1
expr_stmt|;
name|NFSUNLOCKNAMEID
argument_list|()
expr_stmt|;
comment|/* 	 * Set up the socket record and connect. 	 */
name|rp
operator|=
operator|&
name|nfsrv_nfsuserdsock
expr_stmt|;
name|rp
operator|->
name|nr_client
operator|=
name|NULL
expr_stmt|;
name|rp
operator|->
name|nr_sotype
operator|=
name|SOCK_DGRAM
expr_stmt|;
name|rp
operator|->
name|nr_soproto
operator|=
name|IPPROTO_UDP
expr_stmt|;
name|rp
operator|->
name|nr_lock
operator|=
operator|(
name|NFSR_RESERVEDPORT
operator||
name|NFSR_LOCALHOST
operator|)
expr_stmt|;
name|rp
operator|->
name|nr_cred
operator|=
name|NULL
expr_stmt|;
name|NFSSOCKADDRALLOC
argument_list|(
name|rp
operator|->
name|nr_nam
argument_list|)
expr_stmt|;
name|NFSSOCKADDRSIZE
argument_list|(
name|rp
operator|->
name|nr_nam
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|)
expr_stmt|;
name|ad
operator|=
name|NFSSOCKADDR
argument_list|(
name|rp
operator|->
name|nr_nam
argument_list|,
expr|struct
name|sockaddr_in
operator|*
argument_list|)
expr_stmt|;
name|ad
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|ad
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
operator|(
name|u_int32_t
operator|)
literal|0x7f000001
argument_list|)
expr_stmt|;
comment|/* 127.0.0.1 */
name|ad
operator|->
name|sin_port
operator|=
name|port
expr_stmt|;
name|rp
operator|->
name|nr_prog
operator|=
name|RPCPROG_NFSUSERD
expr_stmt|;
name|rp
operator|->
name|nr_vers
operator|=
name|RPCNFSUSERD_VERS
expr_stmt|;
name|error
operator|=
name|newnfs_connect
argument_list|(
name|NULL
argument_list|,
name|rp
argument_list|,
name|NFSPROCCRED
argument_list|(
name|p
argument_list|)
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|NFSSOCKADDRFREE
argument_list|(
name|rp
operator|->
name|nr_nam
argument_list|)
expr_stmt|;
name|nfsrv_nfsuserd
operator|=
literal|0
expr_stmt|;
block|}
name|out
label|:
name|NFSEXITCODE
argument_list|(
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Delete the nfsuserd port.  */
end_comment

begin_function
name|APPLESTATIC
name|void
name|nfsrv_nfsuserddelport
parameter_list|(
name|void
parameter_list|)
block|{
name|NFSLOCKNAMEID
argument_list|()
expr_stmt|;
if|if
condition|(
name|nfsrv_nfsuserd
operator|==
literal|0
condition|)
block|{
name|NFSUNLOCKNAMEID
argument_list|()
expr_stmt|;
return|return;
block|}
name|nfsrv_nfsuserd
operator|=
literal|0
expr_stmt|;
name|NFSUNLOCKNAMEID
argument_list|()
expr_stmt|;
name|newnfs_disconnect
argument_list|(
operator|&
name|nfsrv_nfsuserdsock
argument_list|)
expr_stmt|;
name|NFSSOCKADDRFREE
argument_list|(
name|nfsrv_nfsuserdsock
operator|.
name|nr_nam
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Do upcalls to the nfsuserd, for cache misses of the owner/ownergroup  * name<-->id cache.  * Returns 0 upon success, non-zero otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|nfsrv_getuser
parameter_list|(
name|int
name|procnum
parameter_list|,
name|uid_t
name|uid
parameter_list|,
name|gid_t
name|gid
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|struct
name|nfsrv_descript
modifier|*
name|nd
decl_stmt|;
name|int
name|len
decl_stmt|;
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|int
name|error
decl_stmt|;
name|NFSLOCKNAMEID
argument_list|()
expr_stmt|;
if|if
condition|(
name|nfsrv_nfsuserd
operator|==
literal|0
condition|)
block|{
name|NFSUNLOCKNAMEID
argument_list|()
expr_stmt|;
name|error
operator|=
name|EPERM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|NFSUNLOCKNAMEID
argument_list|()
expr_stmt|;
name|nd
operator|=
operator|&
name|nfsd
expr_stmt|;
name|cred
operator|=
name|newnfs_getcred
argument_list|()
expr_stmt|;
name|nd
operator|->
name|nd_flag
operator|=
name|ND_GSSINITREPLY
expr_stmt|;
name|nfsrvd_rephead
argument_list|(
name|nd
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_procnum
operator|=
name|procnum
expr_stmt|;
if|if
condition|(
name|procnum
operator|==
name|RPCNFSUSERD_GETUID
operator|||
name|procnum
operator|==
name|RPCNFSUSERD_GETGID
condition|)
block|{
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|procnum
operator|==
name|RPCNFSUSERD_GETUID
condition|)
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|uid
argument_list|)
expr_stmt|;
else|else
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|gid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsm_strtom
argument_list|(
name|nd
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|newnfs_request
argument_list|(
name|nd
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|nfsrv_nfsuserdsock
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|cred
argument_list|,
name|RPCPROG_NFSUSERD
argument_list|,
name|RPCNFSUSERD_VERS
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|NFSFREECRED
argument_list|(
name|cred
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
block|}
name|out
label|:
name|NFSEXITCODE
argument_list|(
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This function is called from the nfssvc(2) system call, to update the  * kernel user/group name list(s) for the V4 owner and ownergroup attributes.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfssvc_idname
parameter_list|(
name|struct
name|nfsd_idargs
modifier|*
name|nidp
parameter_list|)
block|{
name|struct
name|nfsusrgrp
modifier|*
name|nusrp
decl_stmt|,
modifier|*
name|usrp
decl_stmt|,
modifier|*
name|newusrp
decl_stmt|;
name|struct
name|nfsrv_lughash
modifier|*
name|hp_name
decl_stmt|,
modifier|*
name|hp_idnum
decl_stmt|,
modifier|*
name|thp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|group_locked
decl_stmt|,
name|groupname_locked
decl_stmt|,
name|user_locked
decl_stmt|,
name|username_locked
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|u_char
modifier|*
name|cp
decl_stmt|;
name|gid_t
modifier|*
name|grps
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cr
decl_stmt|;
specifier|static
name|int
name|onethread
init|=
literal|0
decl_stmt|;
specifier|static
name|time_t
name|lasttime
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|nidp
operator|->
name|nid_namelen
operator|<=
literal|0
operator|||
name|nidp
operator|->
name|nid_namelen
operator|>
name|MAXHOSTNAMELEN
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|nidp
operator|->
name|nid_flag
operator|&
name|NFSID_INITIALIZE
condition|)
block|{
name|cp
operator|=
name|malloc
argument_list|(
name|nidp
operator|->
name|nid_namelen
operator|+
literal|1
argument_list|,
name|M_NFSSTRING
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|CAST_USER_ADDR_T
argument_list|(
name|nidp
operator|->
name|nid_name
argument_list|)
argument_list|,
name|cp
argument_list|,
name|nidp
operator|->
name|nid_namelen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|cp
argument_list|,
name|M_NFSSTRING
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|atomic_cmpset_acq_int
argument_list|(
operator|&
name|nfsrv_dnsnamelen
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Free up all the old stuff and reinitialize hash 			 * lists.  All mutexes for both lists must be locked, 			 * with the user/group name ones before the uid/gid 			 * ones, to avoid a LOR. 			 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfsrv_lughashsize
condition|;
name|i
operator|++
control|)
name|mtx_lock
argument_list|(
operator|&
name|nfsusernamehash
index|[
name|i
index|]
operator|.
name|mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfsrv_lughashsize
condition|;
name|i
operator|++
control|)
name|mtx_lock
argument_list|(
operator|&
name|nfsuserhash
index|[
name|i
index|]
operator|.
name|mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfsrv_lughashsize
condition|;
name|i
operator|++
control|)
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|usrp
argument_list|,
argument|&nfsuserhash[i].lughead
argument_list|,
argument|lug_numhash
argument_list|,
argument|nusrp
argument_list|)
name|nfsrv_removeuser
argument_list|(
name|usrp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfsrv_lughashsize
condition|;
name|i
operator|++
control|)
name|mtx_unlock
argument_list|(
operator|&
name|nfsuserhash
index|[
name|i
index|]
operator|.
name|mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfsrv_lughashsize
condition|;
name|i
operator|++
control|)
name|mtx_unlock
argument_list|(
operator|&
name|nfsusernamehash
index|[
name|i
index|]
operator|.
name|mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfsrv_lughashsize
condition|;
name|i
operator|++
control|)
name|mtx_lock
argument_list|(
operator|&
name|nfsgroupnamehash
index|[
name|i
index|]
operator|.
name|mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfsrv_lughashsize
condition|;
name|i
operator|++
control|)
name|mtx_lock
argument_list|(
operator|&
name|nfsgrouphash
index|[
name|i
index|]
operator|.
name|mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfsrv_lughashsize
condition|;
name|i
operator|++
control|)
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|usrp
argument_list|,
argument|&nfsgrouphash[i].lughead
argument_list|,
argument|lug_numhash
argument_list|,
argument|nusrp
argument_list|)
name|nfsrv_removeuser
argument_list|(
name|usrp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfsrv_lughashsize
condition|;
name|i
operator|++
control|)
name|mtx_unlock
argument_list|(
operator|&
name|nfsgrouphash
index|[
name|i
index|]
operator|.
name|mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfsrv_lughashsize
condition|;
name|i
operator|++
control|)
name|mtx_unlock
argument_list|(
operator|&
name|nfsgroupnamehash
index|[
name|i
index|]
operator|.
name|mtx
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nfsrv_dnsname
argument_list|,
name|M_NFSSTRING
argument_list|)
expr_stmt|;
name|nfsrv_dnsname
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|nfsuserhash
operator|==
name|NULL
condition|)
block|{
comment|/* Allocate the hash tables. */
name|nfsuserhash
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nfsrv_lughash
argument_list|)
operator|*
name|nfsrv_lughashsize
argument_list|,
name|M_NFSUSERGROUP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfsrv_lughashsize
condition|;
name|i
operator|++
control|)
name|mtx_init
argument_list|(
operator|&
name|nfsuserhash
index|[
name|i
index|]
operator|.
name|mtx
argument_list|,
literal|"nfsuidhash"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
operator||
name|MTX_DUPOK
argument_list|)
expr_stmt|;
name|nfsusernamehash
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nfsrv_lughash
argument_list|)
operator|*
name|nfsrv_lughashsize
argument_list|,
name|M_NFSUSERGROUP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfsrv_lughashsize
condition|;
name|i
operator|++
control|)
name|mtx_init
argument_list|(
operator|&
name|nfsusernamehash
index|[
name|i
index|]
operator|.
name|mtx
argument_list|,
literal|"nfsusrhash"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
operator||
name|MTX_DUPOK
argument_list|)
expr_stmt|;
name|nfsgrouphash
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nfsrv_lughash
argument_list|)
operator|*
name|nfsrv_lughashsize
argument_list|,
name|M_NFSUSERGROUP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfsrv_lughashsize
condition|;
name|i
operator|++
control|)
name|mtx_init
argument_list|(
operator|&
name|nfsgrouphash
index|[
name|i
index|]
operator|.
name|mtx
argument_list|,
literal|"nfsgidhash"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
operator||
name|MTX_DUPOK
argument_list|)
expr_stmt|;
name|nfsgroupnamehash
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nfsrv_lughash
argument_list|)
operator|*
name|nfsrv_lughashsize
argument_list|,
name|M_NFSUSERGROUP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfsrv_lughashsize
condition|;
name|i
operator|++
control|)
name|mtx_init
argument_list|(
operator|&
name|nfsgroupnamehash
index|[
name|i
index|]
operator|.
name|mtx
argument_list|,
literal|"nfsgrphash"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
operator||
name|MTX_DUPOK
argument_list|)
expr_stmt|;
block|}
comment|/* (Re)initialize the list heads. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfsrv_lughashsize
condition|;
name|i
operator|++
control|)
name|TAILQ_INIT
argument_list|(
operator|&
name|nfsuserhash
index|[
name|i
index|]
operator|.
name|lughead
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfsrv_lughashsize
condition|;
name|i
operator|++
control|)
name|TAILQ_INIT
argument_list|(
operator|&
name|nfsusernamehash
index|[
name|i
index|]
operator|.
name|lughead
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfsrv_lughashsize
condition|;
name|i
operator|++
control|)
name|TAILQ_INIT
argument_list|(
operator|&
name|nfsgrouphash
index|[
name|i
index|]
operator|.
name|lughead
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfsrv_lughashsize
condition|;
name|i
operator|++
control|)
name|TAILQ_INIT
argument_list|(
operator|&
name|nfsgroupnamehash
index|[
name|i
index|]
operator|.
name|lughead
argument_list|)
expr_stmt|;
comment|/* 		 * Put name in "DNS" string. 		 */
name|nfsrv_dnsname
operator|=
name|cp
expr_stmt|;
name|nfsrv_defaultuid
operator|=
name|nidp
operator|->
name|nid_uid
expr_stmt|;
name|nfsrv_defaultgid
operator|=
name|nidp
operator|->
name|nid_gid
expr_stmt|;
name|nfsrv_usercnt
operator|=
literal|0
expr_stmt|;
name|nfsrv_usermax
operator|=
name|nidp
operator|->
name|nid_usermax
expr_stmt|;
name|atomic_store_rel_int
argument_list|(
operator|&
name|nfsrv_dnsnamelen
argument_list|,
name|nidp
operator|->
name|nid_namelen
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * malloc the new one now, so any potential sleep occurs before 	 * manipulation of the lists. 	 */
name|newusrp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nfsusrgrp
argument_list|)
operator|+
name|nidp
operator|->
name|nid_namelen
argument_list|,
name|M_NFSUSERGROUP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|CAST_USER_ADDR_T
argument_list|(
name|nidp
operator|->
name|nid_name
argument_list|)
argument_list|,
name|newusrp
operator|->
name|lug_name
argument_list|,
name|nidp
operator|->
name|nid_namelen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|nidp
operator|->
name|nid_ngroup
operator|>
literal|0
operator|&&
operator|(
name|nidp
operator|->
name|nid_flag
operator|&
name|NFSID_ADDUID
operator|)
operator|!=
literal|0
condition|)
block|{
name|grps
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|gid_t
argument_list|)
operator|*
name|nidp
operator|->
name|nid_ngroup
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|CAST_USER_ADDR_T
argument_list|(
name|nidp
operator|->
name|nid_grps
argument_list|)
argument_list|,
name|grps
argument_list|,
sizeof|sizeof
argument_list|(
name|gid_t
argument_list|)
operator|*
name|nidp
operator|->
name|nid_ngroup
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Create a credential just like svc_getcred(), 			 * but using the group list provided. 			 */
name|cr
operator|=
name|crget
argument_list|()
expr_stmt|;
name|cr
operator|->
name|cr_uid
operator|=
name|cr
operator|->
name|cr_ruid
operator|=
name|cr
operator|->
name|cr_svuid
operator|=
name|nidp
operator|->
name|nid_uid
expr_stmt|;
name|crsetgroups
argument_list|(
name|cr
argument_list|,
name|nidp
operator|->
name|nid_ngroup
argument_list|,
name|grps
argument_list|)
expr_stmt|;
name|cr
operator|->
name|cr_rgid
operator|=
name|cr
operator|->
name|cr_svgid
operator|=
name|cr
operator|->
name|cr_groups
index|[
literal|0
index|]
expr_stmt|;
name|cr
operator|->
name|cr_prison
operator|=
operator|&
name|prison0
expr_stmt|;
name|prison_hold
argument_list|(
name|cr
operator|->
name|cr_prison
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|mac_cred_associate_nfsd
argument_list|(
name|cr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|newusrp
operator|->
name|lug_cred
operator|=
name|cr
expr_stmt|;
block|}
name|free
argument_list|(
name|grps
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|newusrp
argument_list|,
name|M_NFSUSERGROUP
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|newusrp
operator|->
name|lug_namelen
operator|=
name|nidp
operator|->
name|nid_namelen
expr_stmt|;
comment|/* 	 * The lock order is username[0]->[nfsrv_lughashsize - 1] followed 	 * by uid[0]->[nfsrv_lughashsize - 1], with the same for group. 	 * The flags user_locked, username_locked, group_locked and 	 * groupname_locked are set to indicate all of those hash lists are 	 * locked. hp_name != NULL  and hp_idnum != NULL indicates that 	 * the respective one mutex is locked. 	 */
name|user_locked
operator|=
name|username_locked
operator|=
name|group_locked
operator|=
name|groupname_locked
operator|=
literal|0
expr_stmt|;
name|hp_name
operator|=
name|hp_idnum
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Delete old entries, as required. 	 */
if|if
condition|(
name|nidp
operator|->
name|nid_flag
operator|&
operator|(
name|NFSID_DELUID
operator||
name|NFSID_ADDUID
operator|)
condition|)
block|{
comment|/* Must lock all username hash lists first, to avoid a LOR. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfsrv_lughashsize
condition|;
name|i
operator|++
control|)
name|mtx_lock
argument_list|(
operator|&
name|nfsusernamehash
index|[
name|i
index|]
operator|.
name|mtx
argument_list|)
expr_stmt|;
name|username_locked
operator|=
literal|1
expr_stmt|;
name|hp_idnum
operator|=
name|NFSUSERHASH
argument_list|(
name|nidp
operator|->
name|nid_uid
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|hp_idnum
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|usrp
argument_list|,
argument|&hp_idnum->lughead
argument_list|,
argument|lug_numhash
argument_list|,
argument|nusrp
argument_list|)
block|{
if|if
condition|(
name|usrp
operator|->
name|lug_uid
operator|==
name|nidp
operator|->
name|nid_uid
condition|)
name|nfsrv_removeuser
argument_list|(
name|usrp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|nidp
operator|->
name|nid_flag
operator|&
operator|(
name|NFSID_DELUSERNAME
operator||
name|NFSID_ADDUSERNAME
operator|)
condition|)
block|{
name|hp_name
operator|=
name|NFSUSERNAMEHASH
argument_list|(
name|newusrp
operator|->
name|lug_name
argument_list|,
name|newusrp
operator|->
name|lug_namelen
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|hp_name
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|usrp
argument_list|,
argument|&hp_name->lughead
argument_list|,
argument|lug_namehash
argument_list|,
argument|nusrp
argument_list|)
block|{
if|if
condition|(
name|usrp
operator|->
name|lug_namelen
operator|==
name|newusrp
operator|->
name|lug_namelen
operator|&&
operator|!
name|NFSBCMP
argument_list|(
name|usrp
operator|->
name|lug_name
argument_list|,
name|newusrp
operator|->
name|lug_name
argument_list|,
name|usrp
operator|->
name|lug_namelen
argument_list|)
condition|)
block|{
name|thp
operator|=
name|NFSUSERHASH
argument_list|(
name|usrp
operator|->
name|lug_uid
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|thp
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|nfsrv_removeuser
argument_list|(
name|usrp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|thp
operator|->
name|mtx
argument_list|)
expr_stmt|;
block|}
block|}
name|hp_idnum
operator|=
name|NFSUSERHASH
argument_list|(
name|nidp
operator|->
name|nid_uid
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|hp_idnum
operator|->
name|mtx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nidp
operator|->
name|nid_flag
operator|&
operator|(
name|NFSID_DELGID
operator||
name|NFSID_ADDGID
operator|)
condition|)
block|{
comment|/* Must lock all groupname hash lists first, to avoid a LOR. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfsrv_lughashsize
condition|;
name|i
operator|++
control|)
name|mtx_lock
argument_list|(
operator|&
name|nfsgroupnamehash
index|[
name|i
index|]
operator|.
name|mtx
argument_list|)
expr_stmt|;
name|groupname_locked
operator|=
literal|1
expr_stmt|;
name|hp_idnum
operator|=
name|NFSGROUPHASH
argument_list|(
name|nidp
operator|->
name|nid_gid
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|hp_idnum
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|usrp
argument_list|,
argument|&hp_idnum->lughead
argument_list|,
argument|lug_numhash
argument_list|,
argument|nusrp
argument_list|)
block|{
if|if
condition|(
name|usrp
operator|->
name|lug_gid
operator|==
name|nidp
operator|->
name|nid_gid
condition|)
name|nfsrv_removeuser
argument_list|(
name|usrp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|nidp
operator|->
name|nid_flag
operator|&
operator|(
name|NFSID_DELGROUPNAME
operator||
name|NFSID_ADDGROUPNAME
operator|)
condition|)
block|{
name|hp_name
operator|=
name|NFSGROUPNAMEHASH
argument_list|(
name|newusrp
operator|->
name|lug_name
argument_list|,
name|newusrp
operator|->
name|lug_namelen
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|hp_name
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|usrp
argument_list|,
argument|&hp_name->lughead
argument_list|,
argument|lug_namehash
argument_list|,
argument|nusrp
argument_list|)
block|{
if|if
condition|(
name|usrp
operator|->
name|lug_namelen
operator|==
name|newusrp
operator|->
name|lug_namelen
operator|&&
operator|!
name|NFSBCMP
argument_list|(
name|usrp
operator|->
name|lug_name
argument_list|,
name|newusrp
operator|->
name|lug_name
argument_list|,
name|usrp
operator|->
name|lug_namelen
argument_list|)
condition|)
block|{
name|thp
operator|=
name|NFSGROUPHASH
argument_list|(
name|usrp
operator|->
name|lug_gid
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|thp
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|nfsrv_removeuser
argument_list|(
name|usrp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|thp
operator|->
name|mtx
argument_list|)
expr_stmt|;
block|}
block|}
name|hp_idnum
operator|=
name|NFSGROUPHASH
argument_list|(
name|nidp
operator|->
name|nid_gid
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|hp_idnum
operator|->
name|mtx
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Now, we can add the new one. 	 */
if|if
condition|(
name|nidp
operator|->
name|nid_usertimeout
condition|)
name|newusrp
operator|->
name|lug_expiry
operator|=
name|NFSD_MONOSEC
operator|+
name|nidp
operator|->
name|nid_usertimeout
expr_stmt|;
else|else
name|newusrp
operator|->
name|lug_expiry
operator|=
name|NFSD_MONOSEC
operator|+
literal|5
expr_stmt|;
if|if
condition|(
name|nidp
operator|->
name|nid_flag
operator|&
operator|(
name|NFSID_ADDUID
operator||
name|NFSID_ADDUSERNAME
operator|)
condition|)
block|{
name|newusrp
operator|->
name|lug_uid
operator|=
name|nidp
operator|->
name|nid_uid
expr_stmt|;
name|thp
operator|=
name|NFSUSERHASH
argument_list|(
name|newusrp
operator|->
name|lug_uid
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|thp
operator|->
name|mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|thp
operator|->
name|lughead
argument_list|,
name|newusrp
argument_list|,
name|lug_numhash
argument_list|)
expr_stmt|;
name|thp
operator|=
name|NFSUSERNAMEHASH
argument_list|(
name|newusrp
operator|->
name|lug_name
argument_list|,
name|newusrp
operator|->
name|lug_namelen
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|thp
operator|->
name|mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|thp
operator|->
name|lughead
argument_list|,
name|newusrp
argument_list|,
name|lug_namehash
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|nfsrv_usercnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nidp
operator|->
name|nid_flag
operator|&
operator|(
name|NFSID_ADDGID
operator||
name|NFSID_ADDGROUPNAME
operator|)
condition|)
block|{
name|newusrp
operator|->
name|lug_gid
operator|=
name|nidp
operator|->
name|nid_gid
expr_stmt|;
name|thp
operator|=
name|NFSGROUPHASH
argument_list|(
name|newusrp
operator|->
name|lug_gid
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|thp
operator|->
name|mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|thp
operator|->
name|lughead
argument_list|,
name|newusrp
argument_list|,
name|lug_numhash
argument_list|)
expr_stmt|;
name|thp
operator|=
name|NFSGROUPNAMEHASH
argument_list|(
name|newusrp
operator|->
name|lug_name
argument_list|,
name|newusrp
operator|->
name|lug_namelen
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|thp
operator|->
name|mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|thp
operator|->
name|lughead
argument_list|,
name|newusrp
argument_list|,
name|lug_namehash
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|nfsrv_usercnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|newusrp
operator|->
name|lug_cred
operator|!=
name|NULL
condition|)
name|crfree
argument_list|(
name|newusrp
operator|->
name|lug_cred
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|newusrp
argument_list|,
name|M_NFSUSERGROUP
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Once per second, allow one thread to trim the cache. 	 */
if|if
condition|(
name|lasttime
operator|<
name|NFSD_MONOSEC
operator|&&
name|atomic_cmpset_acq_int
argument_list|(
operator|&
name|onethread
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * First, unlock the single mutexes, so that all entries 		 * can be locked and any LOR is avoided. 		 */
if|if
condition|(
name|hp_name
operator|!=
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|hp_name
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|hp_name
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|hp_idnum
operator|!=
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|hp_idnum
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|hp_idnum
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|nidp
operator|->
name|nid_flag
operator|&
operator|(
name|NFSID_DELUID
operator||
name|NFSID_ADDUID
operator||
name|NFSID_DELUSERNAME
operator||
name|NFSID_ADDUSERNAME
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|username_locked
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfsrv_lughashsize
condition|;
name|i
operator|++
control|)
name|mtx_lock
argument_list|(
operator|&
name|nfsusernamehash
index|[
name|i
index|]
operator|.
name|mtx
argument_list|)
expr_stmt|;
name|username_locked
operator|=
literal|1
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|user_locked
operator|==
literal|0
argument_list|,
operator|(
literal|"nfssvc_idname: user_locked"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfsrv_lughashsize
condition|;
name|i
operator|++
control|)
name|mtx_lock
argument_list|(
operator|&
name|nfsuserhash
index|[
name|i
index|]
operator|.
name|mtx
argument_list|)
expr_stmt|;
name|user_locked
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfsrv_lughashsize
condition|;
name|i
operator|++
control|)
block|{
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|usrp
argument_list|,
argument|&nfsuserhash[i].lughead
argument_list|,
argument|lug_numhash
argument_list|,
argument|nusrp
argument_list|)
if|if
condition|(
name|usrp
operator|->
name|lug_expiry
operator|<
name|NFSD_MONOSEC
condition|)
name|nfsrv_removeuser
argument_list|(
name|usrp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfsrv_lughashsize
condition|;
name|i
operator|++
control|)
block|{
comment|/* 				 * Trim the cache using an approximate LRU 				 * algorithm.  This code deletes the least 				 * recently used entry on each hash list. 				 */
if|if
condition|(
name|nfsrv_usercnt
operator|<=
name|nfsrv_usermax
condition|)
break|break;
name|usrp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|nfsuserhash
index|[
name|i
index|]
operator|.
name|lughead
argument_list|)
expr_stmt|;
if|if
condition|(
name|usrp
operator|!=
name|NULL
condition|)
name|nfsrv_removeuser
argument_list|(
name|usrp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|groupname_locked
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfsrv_lughashsize
condition|;
name|i
operator|++
control|)
name|mtx_lock
argument_list|(
operator|&
name|nfsgroupnamehash
index|[
name|i
index|]
operator|.
name|mtx
argument_list|)
expr_stmt|;
name|groupname_locked
operator|=
literal|1
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|group_locked
operator|==
literal|0
argument_list|,
operator|(
literal|"nfssvc_idname: group_locked"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfsrv_lughashsize
condition|;
name|i
operator|++
control|)
name|mtx_lock
argument_list|(
operator|&
name|nfsgrouphash
index|[
name|i
index|]
operator|.
name|mtx
argument_list|)
expr_stmt|;
name|group_locked
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfsrv_lughashsize
condition|;
name|i
operator|++
control|)
block|{
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|usrp
argument_list|,
argument|&nfsgrouphash[i].lughead
argument_list|,
argument|lug_numhash
argument_list|,
argument|nusrp
argument_list|)
if|if
condition|(
name|usrp
operator|->
name|lug_expiry
operator|<
name|NFSD_MONOSEC
condition|)
name|nfsrv_removeuser
argument_list|(
name|usrp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfsrv_lughashsize
condition|;
name|i
operator|++
control|)
block|{
comment|/* 				 * Trim the cache using an approximate LRU 				 * algorithm.  This code deletes the least 				 * recently user entry on each hash list. 				 */
if|if
condition|(
name|nfsrv_usercnt
operator|<=
name|nfsrv_usermax
condition|)
break|break;
name|usrp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|nfsgrouphash
index|[
name|i
index|]
operator|.
name|lughead
argument_list|)
expr_stmt|;
if|if
condition|(
name|usrp
operator|!=
name|NULL
condition|)
name|nfsrv_removeuser
argument_list|(
name|usrp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|lasttime
operator|=
name|NFSD_MONOSEC
expr_stmt|;
name|atomic_store_rel_int
argument_list|(
operator|&
name|onethread
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Now, unlock all locked mutexes. */
if|if
condition|(
name|hp_idnum
operator|!=
name|NULL
condition|)
name|mtx_unlock
argument_list|(
operator|&
name|hp_idnum
operator|->
name|mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp_name
operator|!=
name|NULL
condition|)
name|mtx_unlock
argument_list|(
operator|&
name|hp_name
operator|->
name|mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|user_locked
operator|!=
literal|0
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfsrv_lughashsize
condition|;
name|i
operator|++
control|)
name|mtx_unlock
argument_list|(
operator|&
name|nfsuserhash
index|[
name|i
index|]
operator|.
name|mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|username_locked
operator|!=
literal|0
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfsrv_lughashsize
condition|;
name|i
operator|++
control|)
name|mtx_unlock
argument_list|(
operator|&
name|nfsusernamehash
index|[
name|i
index|]
operator|.
name|mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|group_locked
operator|!=
literal|0
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfsrv_lughashsize
condition|;
name|i
operator|++
control|)
name|mtx_unlock
argument_list|(
operator|&
name|nfsgrouphash
index|[
name|i
index|]
operator|.
name|mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|groupname_locked
operator|!=
literal|0
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfsrv_lughashsize
condition|;
name|i
operator|++
control|)
name|mtx_unlock
argument_list|(
operator|&
name|nfsgroupnamehash
index|[
name|i
index|]
operator|.
name|mtx
argument_list|)
expr_stmt|;
name|out
label|:
name|NFSEXITCODE
argument_list|(
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove a user/group name element.  */
end_comment

begin_function
specifier|static
name|void
name|nfsrv_removeuser
parameter_list|(
name|struct
name|nfsusrgrp
modifier|*
name|usrp
parameter_list|,
name|int
name|isuser
parameter_list|)
block|{
name|struct
name|nfsrv_lughash
modifier|*
name|hp
decl_stmt|;
if|if
condition|(
name|isuser
operator|!=
literal|0
condition|)
block|{
name|hp
operator|=
name|NFSUSERHASH
argument_list|(
name|usrp
operator|->
name|lug_uid
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|hp
operator|->
name|mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|hp
operator|->
name|lughead
argument_list|,
name|usrp
argument_list|,
name|lug_numhash
argument_list|)
expr_stmt|;
name|hp
operator|=
name|NFSUSERNAMEHASH
argument_list|(
name|usrp
operator|->
name|lug_name
argument_list|,
name|usrp
operator|->
name|lug_namelen
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|hp
operator|->
name|mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|hp
operator|->
name|lughead
argument_list|,
name|usrp
argument_list|,
name|lug_namehash
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hp
operator|=
name|NFSGROUPHASH
argument_list|(
name|usrp
operator|->
name|lug_gid
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|hp
operator|->
name|mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|hp
operator|->
name|lughead
argument_list|,
name|usrp
argument_list|,
name|lug_numhash
argument_list|)
expr_stmt|;
name|hp
operator|=
name|NFSGROUPNAMEHASH
argument_list|(
name|usrp
operator|->
name|lug_name
argument_list|,
name|usrp
operator|->
name|lug_namelen
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|hp
operator|->
name|mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|hp
operator|->
name|lughead
argument_list|,
name|usrp
argument_list|,
name|lug_namehash
argument_list|)
expr_stmt|;
block|}
name|atomic_add_int
argument_list|(
operator|&
name|nfsrv_usercnt
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|usrp
operator|->
name|lug_cred
operator|!=
name|NULL
condition|)
name|crfree
argument_list|(
name|usrp
operator|->
name|lug_cred
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|usrp
argument_list|,
name|M_NFSUSERGROUP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free up all the allocations related to the name<-->id cache.  * This function should only be called when the nfsuserd daemon isn't  * running, since it doesn't do any locking.  * This function is meant to be used when the nfscommon module is unloaded.  */
end_comment

begin_function
name|APPLESTATIC
name|void
name|nfsrv_cleanusergroup
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|nfsrv_lughash
modifier|*
name|hp
decl_stmt|,
modifier|*
name|hp2
decl_stmt|;
name|struct
name|nfsusrgrp
modifier|*
name|nusrp
decl_stmt|,
modifier|*
name|usrp
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|nfsuserhash
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfsrv_lughashsize
condition|;
name|i
operator|++
control|)
block|{
name|hp
operator|=
operator|&
name|nfsuserhash
index|[
name|i
index|]
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|usrp
argument_list|,
argument|&hp->lughead
argument_list|,
argument|lug_numhash
argument_list|,
argument|nusrp
argument_list|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|hp
operator|->
name|lughead
argument_list|,
name|usrp
argument_list|,
name|lug_numhash
argument_list|)
expr_stmt|;
name|hp2
operator|=
name|NFSUSERNAMEHASH
argument_list|(
name|usrp
operator|->
name|lug_name
argument_list|,
name|usrp
operator|->
name|lug_namelen
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|hp2
operator|->
name|lughead
argument_list|,
name|usrp
argument_list|,
name|lug_namehash
argument_list|)
expr_stmt|;
if|if
condition|(
name|usrp
operator|->
name|lug_cred
operator|!=
name|NULL
condition|)
name|crfree
argument_list|(
name|usrp
operator|->
name|lug_cred
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|usrp
argument_list|,
name|M_NFSUSERGROUP
argument_list|)
expr_stmt|;
block|}
name|hp
operator|=
operator|&
name|nfsgrouphash
index|[
name|i
index|]
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|usrp
argument_list|,
argument|&hp->lughead
argument_list|,
argument|lug_numhash
argument_list|,
argument|nusrp
argument_list|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|hp
operator|->
name|lughead
argument_list|,
name|usrp
argument_list|,
name|lug_numhash
argument_list|)
expr_stmt|;
name|hp2
operator|=
name|NFSGROUPNAMEHASH
argument_list|(
name|usrp
operator|->
name|lug_name
argument_list|,
name|usrp
operator|->
name|lug_namelen
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|hp2
operator|->
name|lughead
argument_list|,
name|usrp
argument_list|,
name|lug_namehash
argument_list|)
expr_stmt|;
if|if
condition|(
name|usrp
operator|->
name|lug_cred
operator|!=
name|NULL
condition|)
name|crfree
argument_list|(
name|usrp
operator|->
name|lug_cred
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|usrp
argument_list|,
name|M_NFSUSERGROUP
argument_list|)
expr_stmt|;
block|}
name|mtx_destroy
argument_list|(
operator|&
name|nfsuserhash
index|[
name|i
index|]
operator|.
name|mtx
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|nfsusernamehash
index|[
name|i
index|]
operator|.
name|mtx
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|nfsgroupnamehash
index|[
name|i
index|]
operator|.
name|mtx
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|nfsgrouphash
index|[
name|i
index|]
operator|.
name|mtx
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|nfsuserhash
argument_list|,
name|M_NFSUSERGROUP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nfsusernamehash
argument_list|,
name|M_NFSUSERGROUP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nfsgrouphash
argument_list|,
name|M_NFSUSERGROUP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nfsgroupnamehash
argument_list|,
name|M_NFSUSERGROUP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nfsrv_dnsname
argument_list|,
name|M_NFSSTRING
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This function scans a byte string and checks for UTF-8 compliance.  * It returns 0 if it conforms and NFSERR_INVAL if not.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrv_checkutf8
parameter_list|(
name|u_int8_t
modifier|*
name|cp
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|u_int32_t
name|val
init|=
literal|0x0
decl_stmt|;
name|int
name|cnt
init|=
literal|0
decl_stmt|,
name|gotd
init|=
literal|0
decl_stmt|,
name|shift
init|=
literal|0
decl_stmt|;
name|u_int8_t
name|byte
decl_stmt|;
specifier|static
name|int
name|utf8_shift
index|[
literal|5
index|]
init|=
block|{
literal|7
block|,
literal|11
block|,
literal|16
block|,
literal|21
block|,
literal|26
block|}
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* 	 * Here are what the variables are used for: 	 * val - the calculated value of a multibyte char, used to check 	 *       that it was coded with the correct range 	 * cnt - the number of 10xxxxxx bytes to follow 	 * gotd - set for a char of Dxxx, so D800<->DFFF can be checked for 	 * shift - lower order bits of range (ie. "val>> shift" should 	 *       not be 0, in other words, dividing by the lower bound 	 *       of the range should get a non-zero value) 	 * byte - used to calculate cnt 	 */
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|cnt
operator|>
literal|0
condition|)
block|{
comment|/* This handles the 10xxxxxx bytes */
if|if
condition|(
operator|(
operator|*
name|cp
operator|&
literal|0xc0
operator|)
operator|!=
literal|0x80
operator|||
operator|(
name|gotd
operator|&&
operator|(
operator|*
name|cp
operator|&
literal|0x20
operator|)
operator|)
condition|)
block|{
name|error
operator|=
name|NFSERR_INVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|gotd
operator|=
literal|0
expr_stmt|;
name|val
operator|<<=
literal|6
expr_stmt|;
name|val
operator||=
operator|(
operator|*
name|cp
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|cnt
operator|--
expr_stmt|;
if|if
condition|(
name|cnt
operator|==
literal|0
operator|&&
operator|(
name|val
operator|>>
name|shift
operator|)
operator|==
literal|0x0
condition|)
block|{
name|error
operator|=
name|NFSERR_INVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|cp
operator|&
literal|0x80
condition|)
block|{
comment|/* first byte of multi byte char */
name|byte
operator|=
operator|*
name|cp
expr_stmt|;
while|while
condition|(
operator|(
name|byte
operator|&
literal|0x40
operator|)
operator|&&
name|cnt
operator|<
literal|6
condition|)
block|{
name|cnt
operator|++
expr_stmt|;
name|byte
operator|<<=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|cnt
operator|==
literal|0
operator|||
name|cnt
operator|==
literal|6
condition|)
block|{
name|error
operator|=
name|NFSERR_INVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|val
operator|=
operator|(
operator|*
name|cp
operator|&
operator|(
literal|0x3f
operator|>>
name|cnt
operator|)
operator|)
expr_stmt|;
name|shift
operator|=
name|utf8_shift
index|[
name|cnt
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|cnt
operator|==
literal|2
operator|&&
name|val
operator|==
literal|0xd
condition|)
comment|/* Check for the 0xd800-0xdfff case */
name|gotd
operator|=
literal|1
expr_stmt|;
block|}
name|cp
operator|++
expr_stmt|;
name|len
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|cnt
operator|>
literal|0
condition|)
name|error
operator|=
name|NFSERR_INVAL
expr_stmt|;
name|out
label|:
name|NFSEXITCODE
argument_list|(
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Parse the xdr for an NFSv4 FsLocations attribute. Return two malloc'd  * strings, one with the root path in it and the other with the list of  * locations. The list is in the same format as is found in nfr_refs.  * It is a "," separated list of entries, where each of them is of the  * form<server>:<rootpath>. For example  * "nfsv4-test:/sub2,nfsv4-test2:/user/mnt,nfsv4-test2:/user/mnt2"  * The nilp argument is set to 1 for the special case of a null fs_root  * and an empty server list.  * It returns NFSERR_BADXDR, if the xdr can't be parsed and returns the  * number of xdr bytes parsed in sump.  */
end_comment

begin_function
specifier|static
name|int
name|nfsrv_getrefstr
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|,
name|u_char
modifier|*
modifier|*
name|fsrootp
parameter_list|,
name|u_char
modifier|*
modifier|*
name|srvp
parameter_list|,
name|int
modifier|*
name|sump
parameter_list|,
name|int
modifier|*
name|nilp
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|u_char
modifier|*
name|cp
init|=
name|NULL
decl_stmt|,
modifier|*
name|cp2
init|=
name|NULL
decl_stmt|,
modifier|*
name|cp3
decl_stmt|,
modifier|*
name|str
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|len
decl_stmt|,
name|stringlen
decl_stmt|,
name|cnt
decl_stmt|,
name|slen
decl_stmt|,
name|siz
decl_stmt|,
name|xdrsum
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|,
name|nsrv
decl_stmt|;
struct|struct
name|list
block|{
name|SLIST_ENTRY
argument_list|(
argument|list
argument_list|)
name|next
expr_stmt|;
name|int
name|len
decl_stmt|;
name|u_char
name|host
index|[
literal|1
index|]
decl_stmt|;
block|}
modifier|*
name|lsp
struct|,
modifier|*
name|nlsp
struct|;
name|SLIST_HEAD
argument_list|(
argument_list|,
argument|list
argument_list|)
name|head
expr_stmt|;
operator|*
name|fsrootp
operator|=
name|NULL
expr_stmt|;
operator|*
name|srvp
operator|=
name|NULL
expr_stmt|;
operator|*
name|nilp
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Get the fs_root path and check for the special case of null path 	 * and 0 length server list. 	 */
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|len
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
operator|||
name|len
operator|>
literal|10240
condition|)
block|{
name|error
operator|=
name|NFSERR_BADXDR
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|tl
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|NFSERR_BADXDR
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
operator|*
name|nilp
operator|=
literal|1
expr_stmt|;
operator|*
name|sump
operator|=
literal|2
operator|*
name|NFSX_UNSIGNED
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
name|cp
operator|=
name|malloc
argument_list|(
name|len
operator|+
literal|1
argument_list|,
name|M_NFSSTRING
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfsrv_mtostr
argument_list|(
name|nd
argument_list|,
name|cp
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|cnt
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|<=
literal|0
condition|)
name|error
operator|=
name|NFSERR_BADXDR
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
comment|/* 	 * Now, loop through the location list and make up the srvlist. 	 */
name|xdrsum
operator|=
operator|(
literal|2
operator|*
name|NFSX_UNSIGNED
operator|)
operator|+
name|NFSM_RNDUP
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|cp2
operator|=
name|cp3
operator|=
name|malloc
argument_list|(
literal|1024
argument_list|,
name|M_NFSSTRING
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|slen
operator|=
literal|1024
expr_stmt|;
name|siz
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
block|{
name|SLIST_INIT
argument_list|(
operator|&
name|head
argument_list|)
expr_stmt|;
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|nsrv
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsrv
operator|<=
literal|0
condition|)
block|{
name|error
operator|=
name|NFSERR_BADXDR
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
comment|/* 		 * Handle the first server by putting it in the srvstr. 		 */
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|len
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
operator|||
name|len
operator|>
literal|1024
condition|)
block|{
name|error
operator|=
name|NFSERR_BADXDR
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
name|nfsrv_refstrbigenough
argument_list|(
name|siz
operator|+
name|len
operator|+
literal|3
argument_list|,
operator|&
name|cp2
argument_list|,
operator|&
name|cp3
argument_list|,
operator|&
name|slen
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp3
operator|!=
name|cp2
condition|)
block|{
operator|*
name|cp3
operator|++
operator|=
literal|','
expr_stmt|;
name|siz
operator|++
expr_stmt|;
block|}
name|error
operator|=
name|nfsrv_mtostr
argument_list|(
name|nd
argument_list|,
name|cp3
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
name|cp3
operator|+=
name|len
expr_stmt|;
operator|*
name|cp3
operator|++
operator|=
literal|':'
expr_stmt|;
name|siz
operator|+=
operator|(
name|len
operator|+
literal|1
operator|)
expr_stmt|;
name|xdrsum
operator|+=
operator|(
literal|2
operator|*
name|NFSX_UNSIGNED
operator|)
operator|+
name|NFSM_RNDUP
argument_list|(
name|len
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|nsrv
condition|;
name|j
operator|++
control|)
block|{
comment|/* 			 * Yuck, put them in an slist and process them later. 			 */
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|len
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
operator|||
name|len
operator|>
literal|1024
condition|)
block|{
name|error
operator|=
name|NFSERR_BADXDR
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
name|lsp
operator|=
operator|(
expr|struct
name|list
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|list
argument_list|)
operator|+
name|len
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfsrv_mtostr
argument_list|(
name|nd
argument_list|,
name|lsp
operator|->
name|host
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
name|xdrsum
operator|+=
name|NFSX_UNSIGNED
operator|+
name|NFSM_RNDUP
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|lsp
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|head
argument_list|,
name|lsp
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Finally, we can get the path. 		 */
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|len
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
operator|||
name|len
operator|>
literal|1024
condition|)
block|{
name|error
operator|=
name|NFSERR_BADXDR
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
name|nfsrv_refstrbigenough
argument_list|(
name|siz
operator|+
name|len
operator|+
literal|1
argument_list|,
operator|&
name|cp2
argument_list|,
operator|&
name|cp3
argument_list|,
operator|&
name|slen
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfsrv_mtostr
argument_list|(
name|nd
argument_list|,
name|cp3
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
name|xdrsum
operator|+=
name|NFSX_UNSIGNED
operator|+
name|NFSM_RNDUP
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|str
operator|=
name|cp3
expr_stmt|;
name|stringlen
operator|=
name|len
expr_stmt|;
name|cp3
operator|+=
name|len
expr_stmt|;
name|siz
operator|+=
name|len
expr_stmt|;
name|SLIST_FOREACH_SAFE
argument_list|(
argument|lsp
argument_list|,
argument|&head
argument_list|,
argument|next
argument_list|,
argument|nlsp
argument_list|)
block|{
name|nfsrv_refstrbigenough
argument_list|(
name|siz
operator|+
name|lsp
operator|->
name|len
operator|+
name|stringlen
operator|+
literal|3
argument_list|,
operator|&
name|cp2
argument_list|,
operator|&
name|cp3
argument_list|,
operator|&
name|slen
argument_list|)
expr_stmt|;
operator|*
name|cp3
operator|++
operator|=
literal|','
expr_stmt|;
name|NFSBCOPY
argument_list|(
name|lsp
operator|->
name|host
argument_list|,
name|cp3
argument_list|,
name|lsp
operator|->
name|len
argument_list|)
expr_stmt|;
name|cp3
operator|+=
name|lsp
operator|->
name|len
expr_stmt|;
operator|*
name|cp3
operator|++
operator|=
literal|':'
expr_stmt|;
name|NFSBCOPY
argument_list|(
name|str
argument_list|,
name|cp3
argument_list|,
name|stringlen
argument_list|)
expr_stmt|;
name|cp3
operator|+=
name|stringlen
expr_stmt|;
operator|*
name|cp3
operator|=
literal|'\0'
expr_stmt|;
name|siz
operator|+=
operator|(
name|lsp
operator|->
name|len
operator|+
name|stringlen
operator|+
literal|2
operator|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|lsp
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|fsrootp
operator|=
name|cp
expr_stmt|;
operator|*
name|srvp
operator|=
name|cp2
expr_stmt|;
operator|*
name|sump
operator|=
name|xdrsum
expr_stmt|;
name|NFSEXITCODE2
argument_list|(
literal|0
argument_list|,
name|nd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|nfsmout
label|:
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|cp
argument_list|,
name|M_NFSSTRING
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp2
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|cp2
argument_list|,
name|M_NFSSTRING
argument_list|)
expr_stmt|;
name|NFSEXITCODE2
argument_list|(
name|error
argument_list|,
name|nd
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Make the malloc'd space large enough. This is a pain, but the xdr  * doesn't set an upper bound on the side, so...  */
end_comment

begin_function
specifier|static
name|void
name|nfsrv_refstrbigenough
parameter_list|(
name|int
name|siz
parameter_list|,
name|u_char
modifier|*
modifier|*
name|cpp
parameter_list|,
name|u_char
modifier|*
modifier|*
name|cpp2
parameter_list|,
name|int
modifier|*
name|slenp
parameter_list|)
block|{
name|u_char
modifier|*
name|cp
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|siz
operator|<=
operator|*
name|slenp
condition|)
return|return;
name|cp
operator|=
name|malloc
argument_list|(
name|siz
operator|+
literal|1024
argument_list|,
name|M_NFSSTRING
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|NFSBCOPY
argument_list|(
operator|*
name|cpp
argument_list|,
name|cp
argument_list|,
operator|*
name|slenp
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|*
name|cpp
argument_list|,
name|M_NFSSTRING
argument_list|)
expr_stmt|;
name|i
operator|=
operator|*
name|cpp2
operator|-
operator|*
name|cpp
expr_stmt|;
operator|*
name|cpp
operator|=
name|cp
expr_stmt|;
operator|*
name|cpp2
operator|=
name|cp
operator|+
name|i
expr_stmt|;
operator|*
name|slenp
operator|=
name|siz
operator|+
literal|1024
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize the reply header data structures.  */
end_comment

begin_function
name|APPLESTATIC
name|void
name|nfsrvd_rephead
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|)
block|{
name|mbuf_t
name|mreq
decl_stmt|;
comment|/* 	 * If this is a big reply, use a cluster. 	 */
if|if
condition|(
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_GSSINITREPLY
operator|)
operator|==
literal|0
operator|&&
name|nfs_bigreply
index|[
name|nd
operator|->
name|nd_procnum
index|]
condition|)
block|{
name|NFSMCLGET
argument_list|(
name|mreq
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_mreq
operator|=
name|mreq
expr_stmt|;
name|nd
operator|->
name|nd_mb
operator|=
name|mreq
expr_stmt|;
block|}
else|else
block|{
name|NFSMGET
argument_list|(
name|mreq
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_mreq
operator|=
name|mreq
expr_stmt|;
name|nd
operator|->
name|nd_mb
operator|=
name|mreq
expr_stmt|;
block|}
name|nd
operator|->
name|nd_bpos
operator|=
name|NFSMTOD
argument_list|(
name|mreq
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
name|mbuf_setlen
argument_list|(
name|mreq
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_GSSINITREPLY
operator|)
operator|==
literal|0
condition|)
name|NFSM_BUILD
argument_list|(
name|nd
operator|->
name|nd_errp
argument_list|,
name|int
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Lock a socket against others.  * Currently used to serialize connect/disconnect attempts.  */
end_comment

begin_function
name|int
name|newnfs_sndlock
parameter_list|(
name|int
modifier|*
name|flagp
parameter_list|)
block|{
name|struct
name|timespec
name|ts
decl_stmt|;
name|NFSLOCKSOCK
argument_list|()
expr_stmt|;
while|while
condition|(
operator|*
name|flagp
operator|&
name|NFSR_SNDLOCK
condition|)
block|{
operator|*
name|flagp
operator||=
name|NFSR_WANTSND
expr_stmt|;
name|ts
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|ts
operator|.
name|tv_nsec
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|nfsmsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|flagp
argument_list|,
name|NFSSOCKMUTEXPTR
argument_list|,
name|PZERO
operator|-
literal|1
argument_list|,
literal|"nfsndlck"
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
block|}
operator|*
name|flagp
operator||=
name|NFSR_SNDLOCK
expr_stmt|;
name|NFSUNLOCKSOCK
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Unlock the stream socket for others.  */
end_comment

begin_function
name|void
name|newnfs_sndunlock
parameter_list|(
name|int
modifier|*
name|flagp
parameter_list|)
block|{
name|NFSLOCKSOCK
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|flagp
operator|&
name|NFSR_SNDLOCK
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"nfs sndunlock"
argument_list|)
expr_stmt|;
operator|*
name|flagp
operator|&=
operator|~
name|NFSR_SNDLOCK
expr_stmt|;
if|if
condition|(
operator|*
name|flagp
operator|&
name|NFSR_WANTSND
condition|)
block|{
operator|*
name|flagp
operator|&=
operator|~
name|NFSR_WANTSND
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|flagp
argument_list|)
expr_stmt|;
block|}
name|NFSUNLOCKSOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|APPLESTATIC
name|int
name|nfsv4_getipaddr
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|,
name|struct
name|sockaddr_storage
modifier|*
name|sa
parameter_list|,
name|int
modifier|*
name|isudp
parameter_list|)
block|{
name|struct
name|sockaddr_in
modifier|*
name|sad
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|sad6
decl_stmt|;
name|struct
name|in_addr
name|saddr
decl_stmt|;
name|uint32_t
name|portnum
decl_stmt|,
modifier|*
name|tl
decl_stmt|;
name|int
name|af
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|char
name|addr
index|[
literal|64
index|]
decl_stmt|,
name|protocol
index|[
literal|5
index|]
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|int
name|cantparse
init|=
literal|0
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|uint16_t
name|portv
decl_stmt|;
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|i
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|3
operator|&&
name|i
operator|<=
literal|4
condition|)
block|{
name|error
operator|=
name|nfsrv_mtostr
argument_list|(
name|nd
argument_list|,
name|protocol
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
if|if
condition|(
name|strcmp
argument_list|(
name|protocol
argument_list|,
literal|"tcp"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|af
operator|=
name|AF_INET
expr_stmt|;
operator|*
name|isudp
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|protocol
argument_list|,
literal|"udp"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|af
operator|=
name|AF_INET
expr_stmt|;
operator|*
name|isudp
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|protocol
argument_list|,
literal|"tcp6"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|af
operator|=
name|AF_INET6
expr_stmt|;
operator|*
name|isudp
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|protocol
argument_list|,
literal|"udp6"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|af
operator|=
name|AF_INET6
expr_stmt|;
operator|*
name|isudp
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|cantparse
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|cantparse
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|error
operator|=
name|nfsm_advance
argument_list|(
name|nd
argument_list|,
name|NFSM_RNDUP
argument_list|(
name|i
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
block|}
block|}
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|i
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|error
operator|=
name|NFSERR_BADXDR
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
elseif|else
if|if
condition|(
name|cantparse
operator|==
literal|0
operator|&&
name|i
operator|>=
literal|11
operator|&&
name|i
operator|<
literal|64
condition|)
block|{
comment|/* 		 * The shortest address is 11chars and the longest is< 64. 		 */
name|error
operator|=
name|nfsrv_mtostr
argument_list|(
name|nd
argument_list|,
name|addr
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
comment|/* Find the port# at the end and extract that. */
name|i
operator|=
name|strlen
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
operator|&
name|addr
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
comment|/* Count back two '.'s from end to get port# field. */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'.'
condition|)
block|{
name|k
operator|++
expr_stmt|;
if|if
condition|(
name|k
operator|==
literal|2
condition|)
break|break;
block|}
name|cp
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|k
operator|==
literal|2
condition|)
block|{
comment|/* 			 * The NFSv4 port# is appended as .N.N, where N is 			 * a decimal # in the range 0-255, just like an inet4 			 * address. Cheat and use inet_aton(), which will 			 * return a Class A address and then shift the high 			 * order 8bits over to convert it to the port#. 			 */
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|inet_aton
argument_list|(
name|cp
argument_list|,
operator|&
name|saddr
argument_list|)
operator|==
literal|1
condition|)
block|{
name|portnum
operator|=
name|ntohl
argument_list|(
name|saddr
operator|.
name|s_addr
argument_list|)
expr_stmt|;
name|portv
operator|=
call|(
name|uint16_t
call|)
argument_list|(
operator|(
name|portnum
operator|>>
literal|16
operator|)
operator||
operator|(
name|portnum
operator|&
literal|0xff
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
name|cantparse
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|cantparse
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|cantparse
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|af
operator|==
name|AF_INET
condition|)
block|{
name|sad
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sa
expr_stmt|;
if|if
condition|(
name|inet_pton
argument_list|(
name|af
argument_list|,
name|addr
argument_list|,
operator|&
name|sad
operator|->
name|sin_addr
argument_list|)
operator|==
literal|1
condition|)
block|{
name|sad
operator|->
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sad
argument_list|)
expr_stmt|;
name|sad
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sad
operator|->
name|sin_port
operator|=
name|htons
argument_list|(
name|portv
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
else|else
block|{
name|sad6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sa
expr_stmt|;
if|if
condition|(
name|inet_pton
argument_list|(
name|af
argument_list|,
name|addr
argument_list|,
operator|&
name|sad6
operator|->
name|sin6_addr
argument_list|)
operator|==
literal|1
condition|)
block|{
name|sad6
operator|->
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sad6
argument_list|)
expr_stmt|;
name|sad6
operator|->
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|sad6
operator|->
name|sin6_port
operator|=
name|htons
argument_list|(
name|portv
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|error
operator|=
name|nfsm_advance
argument_list|(
name|nd
argument_list|,
name|NFSM_RNDUP
argument_list|(
name|i
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
block|}
block|}
name|error
operator|=
name|EPERM
expr_stmt|;
name|nfsmout
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handle an NFSv4.1 Sequence request for the session.  * If reply != NULL, use it to return the cached reply, as required.  * The client gets a cached reply via this call for callbacks, however the  * server gets a cached reply via the nfsv4_seqsess_cachereply() call.  */
end_comment

begin_function
name|int
name|nfsv4_seqsession
parameter_list|(
name|uint32_t
name|seqid
parameter_list|,
name|uint32_t
name|slotid
parameter_list|,
name|uint32_t
name|highslot
parameter_list|,
name|struct
name|nfsslot
modifier|*
name|slots
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|reply
parameter_list|,
name|uint16_t
name|maxslot
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|reply
operator|!=
name|NULL
condition|)
operator|*
name|reply
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|slotid
operator|>
name|maxslot
condition|)
return|return
operator|(
name|NFSERR_BADSLOT
operator|)
return|;
if|if
condition|(
name|seqid
operator|==
name|slots
index|[
name|slotid
index|]
operator|.
name|nfssl_seq
condition|)
block|{
comment|/* A retry. */
if|if
condition|(
name|slots
index|[
name|slotid
index|]
operator|.
name|nfssl_inprog
operator|!=
literal|0
condition|)
name|error
operator|=
name|NFSERR_DELAY
expr_stmt|;
elseif|else
if|if
condition|(
name|slots
index|[
name|slotid
index|]
operator|.
name|nfssl_reply
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|reply
operator|!=
name|NULL
condition|)
block|{
operator|*
name|reply
operator|=
name|slots
index|[
name|slotid
index|]
operator|.
name|nfssl_reply
expr_stmt|;
name|slots
index|[
name|slotid
index|]
operator|.
name|nfssl_reply
operator|=
name|NULL
expr_stmt|;
block|}
name|slots
index|[
name|slotid
index|]
operator|.
name|nfssl_inprog
operator|=
literal|1
expr_stmt|;
name|error
operator|=
name|NFSERR_REPLYFROMCACHE
expr_stmt|;
block|}
else|else
comment|/* No reply cached, so just do it. */
name|slots
index|[
name|slotid
index|]
operator|.
name|nfssl_inprog
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|slots
index|[
name|slotid
index|]
operator|.
name|nfssl_seq
operator|+
literal|1
operator|)
operator|==
name|seqid
condition|)
block|{
if|if
condition|(
name|slots
index|[
name|slotid
index|]
operator|.
name|nfssl_reply
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|slots
index|[
name|slotid
index|]
operator|.
name|nfssl_reply
argument_list|)
expr_stmt|;
name|slots
index|[
name|slotid
index|]
operator|.
name|nfssl_reply
operator|=
name|NULL
expr_stmt|;
name|slots
index|[
name|slotid
index|]
operator|.
name|nfssl_inprog
operator|=
literal|1
expr_stmt|;
name|slots
index|[
name|slotid
index|]
operator|.
name|nfssl_seq
operator|++
expr_stmt|;
block|}
else|else
name|error
operator|=
name|NFSERR_SEQMISORDERED
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Cache this reply for the slot.  * Use the "rep" argument to return the cached reply if repstat is set to  * NFSERR_REPLYFROMCACHE. The client never sets repstat to this value.  */
end_comment

begin_function
name|void
name|nfsv4_seqsess_cacherep
parameter_list|(
name|uint32_t
name|slotid
parameter_list|,
name|struct
name|nfsslot
modifier|*
name|slots
parameter_list|,
name|int
name|repstat
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|rep
parameter_list|)
block|{
if|if
condition|(
name|repstat
operator|==
name|NFSERR_REPLYFROMCACHE
condition|)
block|{
operator|*
name|rep
operator|=
name|slots
index|[
name|slotid
index|]
operator|.
name|nfssl_reply
expr_stmt|;
name|slots
index|[
name|slotid
index|]
operator|.
name|nfssl_reply
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|slots
index|[
name|slotid
index|]
operator|.
name|nfssl_reply
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|slots
index|[
name|slotid
index|]
operator|.
name|nfssl_reply
argument_list|)
expr_stmt|;
name|slots
index|[
name|slotid
index|]
operator|.
name|nfssl_reply
operator|=
operator|*
name|rep
expr_stmt|;
block|}
name|slots
index|[
name|slotid
index|]
operator|.
name|nfssl_inprog
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Generate the xdr for an NFSv4.1 Sequence Operation.  */
end_comment

begin_function
name|APPLESTATIC
name|void
name|nfsv4_setsequence
parameter_list|(
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|,
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|,
name|struct
name|nfsclsession
modifier|*
name|sep
parameter_list|,
name|int
name|dont_replycache
parameter_list|)
block|{
name|uint32_t
modifier|*
name|tl
decl_stmt|,
name|slotseq
init|=
literal|0
decl_stmt|;
name|int
name|error
decl_stmt|,
name|maxslot
decl_stmt|,
name|slotpos
decl_stmt|;
name|uint8_t
name|sessionid
index|[
name|NFSX_V4SESSIONID
index|]
decl_stmt|;
name|error
operator|=
name|nfsv4_sequencelookup
argument_list|(
name|nmp
argument_list|,
name|sep
argument_list|,
operator|&
name|slotpos
argument_list|,
operator|&
name|maxslot
argument_list|,
operator|&
name|slotseq
argument_list|,
name|sessionid
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return;
name|KASSERT
argument_list|(
name|maxslot
operator|>=
literal|0
argument_list|,
operator|(
literal|"nfscl_setsequence neg maxslot"
operator|)
argument_list|)
expr_stmt|;
comment|/* Build the Sequence arguments. */
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|uint32_t
operator|*
argument_list|,
name|NFSX_V4SESSIONID
operator|+
literal|4
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|sessionid
argument_list|,
name|tl
argument_list|,
name|NFSX_V4SESSIONID
argument_list|)
expr_stmt|;
name|tl
operator|+=
name|NFSX_V4SESSIONID
operator|/
name|NFSX_UNSIGNED
expr_stmt|;
name|nd
operator|->
name|nd_slotseq
operator|=
name|tl
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|slotseq
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|slotpos
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|maxslot
argument_list|)
expr_stmt|;
if|if
condition|(
name|dont_replycache
operator|==
literal|0
condition|)
operator|*
name|tl
operator|=
name|newnfs_true
expr_stmt|;
else|else
operator|*
name|tl
operator|=
name|newnfs_false
expr_stmt|;
name|nd
operator|->
name|nd_flag
operator||=
name|ND_HASSEQUENCE
expr_stmt|;
block|}
end_function

begin_function
name|int
name|nfsv4_sequencelookup
parameter_list|(
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|,
name|struct
name|nfsclsession
modifier|*
name|sep
parameter_list|,
name|int
modifier|*
name|slotposp
parameter_list|,
name|int
modifier|*
name|maxslotp
parameter_list|,
name|uint32_t
modifier|*
name|slotseqp
parameter_list|,
name|uint8_t
modifier|*
name|sessionid
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|maxslot
decl_stmt|,
name|slotpos
decl_stmt|;
name|uint64_t
name|bitval
decl_stmt|;
comment|/* Find an unused slot. */
name|slotpos
operator|=
operator|-
literal|1
expr_stmt|;
name|maxslot
operator|=
operator|-
literal|1
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sep
operator|->
name|nfsess_mtx
argument_list|)
expr_stmt|;
do|do
block|{
name|bitval
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sep
operator|->
name|nfsess_foreslots
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|bitval
operator|&
name|sep
operator|->
name|nfsess_slots
operator|)
operator|==
literal|0
condition|)
block|{
name|slotpos
operator|=
name|i
expr_stmt|;
name|sep
operator|->
name|nfsess_slots
operator||=
name|bitval
expr_stmt|;
name|sep
operator|->
name|nfsess_slotseq
index|[
name|i
index|]
operator|++
expr_stmt|;
operator|*
name|slotseqp
operator|=
name|sep
operator|->
name|nfsess_slotseq
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
name|bitval
operator|<<=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|slotpos
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 			 * If a forced dismount is in progress, just return. 			 * This RPC attempt will fail when it calls 			 * newnfs_request(). 			 */
if|if
condition|(
name|nmp
operator|!=
name|NULL
operator|&&
operator|(
name|nmp
operator|->
name|nm_mountp
operator|->
name|mnt_kern_flag
operator|&
name|MNTK_UNMOUNTF
operator|)
operator|!=
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sep
operator|->
name|nfsess_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ESTALE
operator|)
return|;
block|}
comment|/* Wake up once/sec, to check for a forced dismount. */
operator|(
name|void
operator|)
name|mtx_sleep
argument_list|(
operator|&
name|sep
operator|->
name|nfsess_slots
argument_list|,
operator|&
name|sep
operator|->
name|nfsess_mtx
argument_list|,
name|PZERO
argument_list|,
literal|"nfsclseq"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|slotpos
operator|==
operator|-
literal|1
condition|)
do|;
comment|/* Now, find the highest slot in use. (nfsc_slots is 64bits) */
name|bitval
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|bitval
operator|&
name|sep
operator|->
name|nfsess_slots
operator|)
operator|!=
literal|0
condition|)
name|maxslot
operator|=
name|i
expr_stmt|;
name|bitval
operator|<<=
literal|1
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|sep
operator|->
name|nfsess_sessionid
argument_list|,
name|sessionid
argument_list|,
name|NFSX_V4SESSIONID
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sep
operator|->
name|nfsess_mtx
argument_list|)
expr_stmt|;
operator|*
name|slotposp
operator|=
name|slotpos
expr_stmt|;
operator|*
name|maxslotp
operator|=
name|maxslot
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free a session slot.  */
end_comment

begin_function
name|APPLESTATIC
name|void
name|nfsv4_freeslot
parameter_list|(
name|struct
name|nfsclsession
modifier|*
name|sep
parameter_list|,
name|int
name|slot
parameter_list|)
block|{
name|uint64_t
name|bitval
decl_stmt|;
name|bitval
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|slot
operator|>
literal|0
condition|)
name|bitval
operator|<<=
name|slot
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sep
operator|->
name|nfsess_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bitval
operator|&
name|sep
operator|->
name|nfsess_slots
operator|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"freeing free slot!!\n"
argument_list|)
expr_stmt|;
name|sep
operator|->
name|nfsess_slots
operator|&=
operator|~
name|bitval
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|sep
operator|->
name|nfsess_slots
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sep
operator|->
name|nfsess_mtx
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

