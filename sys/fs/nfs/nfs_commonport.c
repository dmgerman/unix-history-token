begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1989, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Rick Macklem at The University of Guelph.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Functions that need to be different for different versions of BSD  * kernel should be kept here, along with any global storage specific  * to this BSD variant.  */
end_comment

begin_include
include|#
directive|include
file|<fs/nfs/nfsport.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_decl_stmt
specifier|extern
name|int
name|nfscl_ticks
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|nfsrv_nfsuserd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|nfssockreq
name|nfsrv_nfsuserdsock
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|void
function_decl|(
modifier|*
name|nfsd_call_recall
function_decl|)
parameter_list|(
name|struct
name|vnode
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|ucred
modifier|*
parameter_list|,
name|struct
name|thread
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|int
name|nfsrv_useacl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mount
name|nfsv4root_mnt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|newnfs_numnfsd
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|nfsstatsv1
name|nfsstatsv1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nfs_numnfscbd
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nfscl_debuglevel
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|nfsv4_callbackaddr
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|callout
name|newnfsd_callout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nfsrv_lughashsize
init|=
literal|100
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
function_decl|(
modifier|*
name|nfsd_call_servertimer
function_decl|)
parameter_list|(
name|void
parameter_list|)
init|=
name|NULL
function_decl|;
end_function_decl

begin_function_decl
name|void
function_decl|(
modifier|*
name|ncl_call_invalcaches
function_decl|)
parameter_list|(
name|struct
name|vnode
modifier|*
parameter_list|)
init|=
name|NULL
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|nfs_realign_test
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfs_realign_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ext_nfsstats
name|oldnfsstats
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_vfs
argument_list|,
name|OID_AUTO
argument_list|,
name|nfs
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"NFS filesystem"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_nfs
argument_list|,
name|OID_AUTO
argument_list|,
name|realign_test
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|nfs_realign_test
argument_list|,
literal|0
argument_list|,
literal|"Number of realign tests done"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_nfs
argument_list|,
name|OID_AUTO
argument_list|,
name|realign_count
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|nfs_realign_count
argument_list|,
literal|0
argument_list|,
literal|"Number of mbuf realignments done"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_STRING
argument_list|(
name|_vfs_nfs
argument_list|,
name|OID_AUTO
argument_list|,
name|callback_addr
argument_list|,
name|CTLFLAG_RW
argument_list|,
name|nfsv4_callbackaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|nfsv4_callbackaddr
argument_list|)
argument_list|,
literal|"NFSv4 callback addr for server to use"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_nfs
argument_list|,
name|OID_AUTO
argument_list|,
name|debuglevel
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|nfscl_debuglevel
argument_list|,
literal|0
argument_list|,
literal|"Debug level for NFS client"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_nfs
argument_list|,
name|OID_AUTO
argument_list|,
name|userhashsize
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|nfsrv_lughashsize
argument_list|,
literal|0
argument_list|,
literal|"Size of hash tables for uid/name mapping"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Defines for malloc  * (Here for FreeBSD, since they allocate storage.)  */
end_comment

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_NEWNFSRVCACHE
argument_list|,
literal|"NFSD srvcache"
argument_list|,
literal|"NFSD Server Request Cache"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_NEWNFSDCLIENT
argument_list|,
literal|"NFSD V4client"
argument_list|,
literal|"NFSD V4 Client Id"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_NEWNFSDSTATE
argument_list|,
literal|"NFSD V4state"
argument_list|,
literal|"NFSD V4 State (Openowner, Open, Lockowner, Delegation"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_NEWNFSDLOCK
argument_list|,
literal|"NFSD V4lock"
argument_list|,
literal|"NFSD V4 byte range lock"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_NEWNFSDLOCKFILE
argument_list|,
literal|"NFSD lckfile"
argument_list|,
literal|"NFSD Open/Lock file"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_NEWNFSSTRING
argument_list|,
literal|"NFSD string"
argument_list|,
literal|"NFSD V4 long string"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_NEWNFSUSERGROUP
argument_list|,
literal|"NFSD usrgroup"
argument_list|,
literal|"NFSD V4 User/group map"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_NEWNFSDREQ
argument_list|,
literal|"NFS req"
argument_list|,
literal|"NFS request header"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_NEWNFSFH
argument_list|,
literal|"NFS fh"
argument_list|,
literal|"NFS file handle"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_NEWNFSCLOWNER
argument_list|,
literal|"NFSCL owner"
argument_list|,
literal|"NFSCL Open Owner"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_NEWNFSCLOPEN
argument_list|,
literal|"NFSCL open"
argument_list|,
literal|"NFSCL Open"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_NEWNFSCLDELEG
argument_list|,
literal|"NFSCL deleg"
argument_list|,
literal|"NFSCL Delegation"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_NEWNFSCLCLIENT
argument_list|,
literal|"NFSCL client"
argument_list|,
literal|"NFSCL Client"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_NEWNFSCLLOCKOWNER
argument_list|,
literal|"NFSCL lckown"
argument_list|,
literal|"NFSCL Lock Owner"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_NEWNFSCLLOCK
argument_list|,
literal|"NFSCL lck"
argument_list|,
literal|"NFSCL Lock"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_NEWNFSV4NODE
argument_list|,
literal|"NEWNFSnode"
argument_list|,
literal|"NFS vnode"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_NEWNFSDIRECTIO
argument_list|,
literal|"NEWdirectio"
argument_list|,
literal|"NFS Direct IO buffer"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_NEWNFSDIROFF
argument_list|,
literal|"NFSCL diroffdiroff"
argument_list|,
literal|"NFS directory offset data"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_NEWNFSDROLLBACK
argument_list|,
literal|"NFSD rollback"
argument_list|,
literal|"NFS local lock rollback"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_NEWNFSLAYOUT
argument_list|,
literal|"NFSCL layout"
argument_list|,
literal|"NFSv4.1 Layout"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_NEWNFSFLAYOUT
argument_list|,
literal|"NFSCL flayout"
argument_list|,
literal|"NFSv4.1 File Layout"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_NEWNFSDEVINFO
argument_list|,
literal|"NFSCL devinfo"
argument_list|,
literal|"NFSv4.1 Device Info"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_NEWNFSSOCKREQ
argument_list|,
literal|"NFSCL sockreq"
argument_list|,
literal|"NFS Sock Req"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_NEWNFSCLDS
argument_list|,
literal|"NFSCL session"
argument_list|,
literal|"NFSv4.1 Session"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_NEWNFSLAYRECALL
argument_list|,
literal|"NFSCL layrecall"
argument_list|,
literal|"NFSv4.1 Layout Recall"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_NEWNFSDSESSION
argument_list|,
literal|"NFSD session"
argument_list|,
literal|"NFSD Session for a client"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Definition of mutex locks.  * newnfsd_mtx is used in nfsrvd_nfsd() to protect the nfs socket list  * and assorted other nfsd structures.  */
end_comment

begin_decl_stmt
name|struct
name|mtx
name|newnfsd_mtx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mtx
name|nfs_sockl_mutex
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mtx
name|nfs_state_mutex
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mtx
name|nfs_nameid_mutex
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mtx
name|nfs_req_mutex
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mtx
name|nfs_slock_mutex
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mtx
name|nfs_clstate_mutex
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* local functions */
end_comment

begin_function_decl
specifier|static
name|int
name|nfssvc_call
parameter_list|(
name|struct
name|thread
modifier|*
parameter_list|,
name|struct
name|nfssvc_args
modifier|*
parameter_list|,
name|struct
name|ucred
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|__NO_STRICT_ALIGNMENT
end_ifdef

begin_comment
comment|/*  * These architectures don't need re-alignment, so just return.  */
end_comment

begin_function
name|int
name|newnfs_realign
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
name|pm
parameter_list|,
name|int
name|how
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !__NO_STRICT_ALIGNMENT */
end_comment

begin_comment
comment|/*  *	newnfs_realign:  *  *	Check for badly aligned mbuf data and realign by copying the unaligned  *	portion of the data into a new mbuf chain and freeing the portions  *	of the old chain that were replaced.  *  *	We cannot simply realign the data within the existing mbuf chain  *	because the underlying buffers may contain other rpc commands and  *	we cannot afford to overwrite them.  *  *	We would prefer to avoid this situation entirely.  The situation does  *	not occur with NFS/UDP and is supposed to only occasionally occur  *	with TCP.  Use vfs.nfs.realign_count and realign_test to check this.  *  */
end_comment

begin_function
name|int
name|newnfs_realign
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
name|pm
parameter_list|,
name|int
name|how
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|n
decl_stmt|;
name|int
name|off
decl_stmt|,
name|space
decl_stmt|;
operator|++
name|nfs_realign_test
expr_stmt|;
while|while
condition|(
operator|(
name|m
operator|=
operator|*
name|pm
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|->
name|m_len
operator|&
literal|0x3
operator|)
operator|||
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|intptr_t
argument_list|)
operator|&
literal|0x3
operator|)
condition|)
block|{
comment|/* 			 * NB: we can't depend on m_pkthdr.len to help us 			 * decide what to do here.  May not be worth doing 			 * the m_length calculation as m_copyback will 			 * expand the mbuf chain below as needed. 			 */
name|space
operator|=
name|m_length
argument_list|(
name|m
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|space
operator|>=
name|MINCLSIZE
condition|)
block|{
comment|/* NB: m_copyback handles space> MCLBYTES */
name|n
operator|=
name|m_getcl
argument_list|(
name|how
argument_list|,
name|MT_DATA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|n
operator|=
name|m_get
argument_list|(
name|how
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* 			 * Align the remainder of the mbuf chain. 			 */
name|n
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
name|off
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|m_copyback
argument_list|(
name|n
argument_list|,
name|off
argument_list|,
name|m
operator|->
name|m_len
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|)
expr_stmt|;
name|off
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
block|}
name|m_freem
argument_list|(
operator|*
name|pm
argument_list|)
expr_stmt|;
operator|*
name|pm
operator|=
name|n
expr_stmt|;
operator|++
name|nfs_realign_count
expr_stmt|;
break|break;
block|}
name|pm
operator|=
operator|&
name|m
operator|->
name|m_next
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __NO_STRICT_ALIGNMENT */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|notdef
end_ifdef

begin_function
specifier|static
name|void
name|nfsrv_object_create
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
if|if
condition|(
name|vp
operator|==
name|NULL
operator|||
name|vp
operator|->
name|v_type
operator|!=
name|VREG
condition|)
return|return;
operator|(
name|void
operator|)
name|vfs_object_create
argument_list|(
name|vp
argument_list|,
name|td
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Look up a file name. Basically just initialize stuff and call namei().  */
end_comment

begin_function
name|int
name|nfsrv_lookupfilename
parameter_list|(
name|struct
name|nameidata
modifier|*
name|ndp
parameter_list|,
name|char
modifier|*
name|fname
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|NDINIT
argument_list|(
name|ndp
argument_list|,
name|LOOKUP
argument_list|,
name|FOLLOW
operator||
name|LOCKLEAF
argument_list|,
name|UIO_USERSPACE
argument_list|,
name|fname
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|error
operator|=
name|namei
argument_list|(
name|ndp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|NDFREE
argument_list|(
name|ndp
argument_list|,
name|NDF_ONLY_PNBUF
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Copy NFS uid, gids to the cred structure.  */
end_comment

begin_function
name|void
name|newnfs_copycred
parameter_list|(
name|struct
name|nfscred
modifier|*
name|nfscr
parameter_list|,
name|struct
name|ucred
modifier|*
name|cr
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|nfscr
operator|->
name|nfsc_ngroups
operator|>=
literal|0
argument_list|,
operator|(
literal|"newnfs_copycred: negative nfsc_ngroups"
operator|)
argument_list|)
expr_stmt|;
name|cr
operator|->
name|cr_uid
operator|=
name|nfscr
operator|->
name|nfsc_uid
expr_stmt|;
name|crsetgroups
argument_list|(
name|cr
argument_list|,
name|nfscr
operator|->
name|nfsc_ngroups
argument_list|,
name|nfscr
operator|->
name|nfsc_groups
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Map args from nfsmsleep() to msleep().  */
end_comment

begin_function
name|int
name|nfsmsleep
parameter_list|(
name|void
modifier|*
name|chan
parameter_list|,
name|void
modifier|*
name|mutex
parameter_list|,
name|int
name|prio
parameter_list|,
specifier|const
name|char
modifier|*
name|wmesg
parameter_list|,
name|struct
name|timespec
modifier|*
name|ts
parameter_list|)
block|{
name|u_int64_t
name|nsecval
decl_stmt|;
name|int
name|error
decl_stmt|,
name|timeo
decl_stmt|;
if|if
condition|(
name|ts
condition|)
block|{
name|timeo
operator|=
name|hz
operator|*
name|ts
operator|->
name|tv_sec
expr_stmt|;
name|nsecval
operator|=
operator|(
name|u_int64_t
operator|)
name|ts
operator|->
name|tv_nsec
expr_stmt|;
name|nsecval
operator|=
operator|(
operator|(
name|nsecval
operator|*
operator|(
operator|(
name|u_int64_t
operator|)
name|hz
operator|)
operator|)
operator|+
literal|500000000
operator|)
operator|/
literal|1000000000
expr_stmt|;
name|timeo
operator|+=
operator|(
name|int
operator|)
name|nsecval
expr_stmt|;
block|}
else|else
block|{
name|timeo
operator|=
literal|0
expr_stmt|;
block|}
name|error
operator|=
name|msleep
argument_list|(
name|chan
argument_list|,
operator|(
expr|struct
name|mtx
operator|*
operator|)
name|mutex
argument_list|,
name|prio
argument_list|,
name|wmesg
argument_list|,
name|timeo
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get the file system info for the server. For now, just assume FFS.  */
end_comment

begin_function
name|void
name|nfsvno_getfs
parameter_list|(
name|struct
name|nfsfsinfo
modifier|*
name|sip
parameter_list|,
name|int
name|isdgram
parameter_list|)
block|{
name|int
name|pref
decl_stmt|;
comment|/* 	 * XXX 	 * There should be file system VFS OP(s) to get this information. 	 * For now, assume ufs. 	 */
if|if
condition|(
name|isdgram
condition|)
name|pref
operator|=
name|NFS_MAXDGRAMDATA
expr_stmt|;
else|else
name|pref
operator|=
name|NFS_SRVMAXIO
expr_stmt|;
name|sip
operator|->
name|fs_rtmax
operator|=
name|NFS_SRVMAXIO
expr_stmt|;
name|sip
operator|->
name|fs_rtpref
operator|=
name|pref
expr_stmt|;
name|sip
operator|->
name|fs_rtmult
operator|=
name|NFS_FABLKSIZE
expr_stmt|;
name|sip
operator|->
name|fs_wtmax
operator|=
name|NFS_SRVMAXIO
expr_stmt|;
name|sip
operator|->
name|fs_wtpref
operator|=
name|pref
expr_stmt|;
name|sip
operator|->
name|fs_wtmult
operator|=
name|NFS_FABLKSIZE
expr_stmt|;
name|sip
operator|->
name|fs_dtpref
operator|=
name|pref
expr_stmt|;
name|sip
operator|->
name|fs_maxfilesize
operator|=
literal|0xffffffffffffffffull
expr_stmt|;
name|sip
operator|->
name|fs_timedelta
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|sip
operator|->
name|fs_timedelta
operator|.
name|tv_nsec
operator|=
literal|1
expr_stmt|;
name|sip
operator|->
name|fs_properties
operator|=
operator|(
name|NFSV3FSINFO_LINK
operator||
name|NFSV3FSINFO_SYMLINK
operator||
name|NFSV3FSINFO_HOMOGENEOUS
operator||
name|NFSV3FSINFO_CANSETTIME
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Do the pathconf vnode op.  */
end_comment

begin_function
name|int
name|nfsvno_pathconf
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|int
name|flag
parameter_list|,
name|register_t
modifier|*
name|retf
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|thread
modifier|*
name|p
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|VOP_PATHCONF
argument_list|(
name|vp
argument_list|,
name|flag
argument_list|,
name|retf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EOPNOTSUPP
operator|||
name|error
operator|==
name|EINVAL
condition|)
block|{
comment|/* 		 * Some file systems return EINVAL for name arguments not 		 * supported and some return EOPNOTSUPP for this case. 		 * So the NFSv3 Pathconf RPC doesn't fail for these cases, 		 * just fake them. 		 */
switch|switch
condition|(
name|flag
condition|)
block|{
case|case
name|_PC_LINK_MAX
case|:
operator|*
name|retf
operator|=
name|LINK_MAX
expr_stmt|;
break|break;
case|case
name|_PC_NAME_MAX
case|:
operator|*
name|retf
operator|=
name|NAME_MAX
expr_stmt|;
break|break;
case|case
name|_PC_CHOWN_RESTRICTED
case|:
operator|*
name|retf
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|_PC_NO_TRUNC
case|:
operator|*
name|retf
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
comment|/* 			 * Only happens if a _PC_xxx is added to the server, 			 * but this isn't updated. 			 */
operator|*
name|retf
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"nfsrvd pathconf flag=%d not supp\n"
argument_list|,
name|flag
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
literal|0
expr_stmt|;
block|}
name|NFSEXITCODE
argument_list|(
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Fake nfsrv_atroot. Just return 0 */
end_comment

begin_function
name|int
name|nfsrv_atroot
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|long
modifier|*
name|retp
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set the credentials to refer to root.  * If only the various BSDen could agree on whether cr_gid is a separate  * field or cr_groups[0]...  */
end_comment

begin_function
name|void
name|newnfs_setroot
parameter_list|(
name|struct
name|ucred
modifier|*
name|cred
parameter_list|)
block|{
name|cred
operator|->
name|cr_uid
operator|=
literal|0
expr_stmt|;
name|cred
operator|->
name|cr_groups
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|cred
operator|->
name|cr_ngroups
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get the client credential. Used for Renew and recovery.  */
end_comment

begin_function
name|struct
name|ucred
modifier|*
name|newnfs_getcred
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|cred
operator|=
name|crdup
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|)
expr_stmt|;
name|newnfs_setroot
argument_list|(
name|cred
argument_list|)
expr_stmt|;
return|return
operator|(
name|cred
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Nfs timer routine  * Call the nfsd's timer function once/sec.  */
end_comment

begin_function
name|void
name|newnfs_timer
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
specifier|static
name|time_t
name|lasttime
init|=
literal|0
decl_stmt|;
comment|/* 	 * Call the server timer, if set up. 	 * The argument indicates if it is the next second and therefore 	 * leases should be checked. 	 */
if|if
condition|(
name|lasttime
operator|!=
name|NFSD_MONOSEC
condition|)
block|{
name|lasttime
operator|=
name|NFSD_MONOSEC
expr_stmt|;
if|if
condition|(
name|nfsd_call_servertimer
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|nfsd_call_servertimer
call|)
argument_list|()
expr_stmt|;
block|}
name|callout_reset
argument_list|(
operator|&
name|newnfsd_callout
argument_list|,
name|nfscl_ticks
argument_list|,
name|newnfs_timer
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Sleep for a short period of time unless errval == NFSERR_GRACE, where  * the sleep should be for 5 seconds.  * Since lbolt doesn't exist in FreeBSD-CURRENT, just use a timeout on  * an event that never gets a wakeup. Only return EINTR or 0.  */
end_comment

begin_function
name|int
name|nfs_catnap
parameter_list|(
name|int
name|prio
parameter_list|,
name|int
name|errval
parameter_list|,
specifier|const
name|char
modifier|*
name|wmesg
parameter_list|)
block|{
specifier|static
name|int
name|non_event
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|errval
operator|==
name|NFSERR_GRACE
condition|)
name|ret
operator|=
name|tsleep
argument_list|(
operator|&
name|non_event
argument_list|,
name|prio
argument_list|,
name|wmesg
argument_list|,
literal|5
operator|*
name|hz
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|tsleep
argument_list|(
operator|&
name|non_event
argument_list|,
name|prio
argument_list|,
name|wmesg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|EINTR
condition|)
name|ret
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get referral. For now, just fail.  */
end_comment

begin_function
name|struct
name|nfsreferral
modifier|*
name|nfsv4root_getreferral
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|struct
name|vnode
modifier|*
name|dvp
parameter_list|,
name|u_int32_t
name|fileno
parameter_list|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nfssvc_nfscommon
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|nfssvc_args
modifier|*
name|uap
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|nfssvc_call
argument_list|(
name|td
argument_list|,
name|uap
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|)
expr_stmt|;
name|NFSEXITCODE
argument_list|(
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nfssvc_call
parameter_list|(
name|struct
name|thread
modifier|*
name|p
parameter_list|,
name|struct
name|nfssvc_args
modifier|*
name|uap
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|)
block|{
name|int
name|error
init|=
name|EINVAL
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|nfsd_idargs
name|nid
decl_stmt|;
name|struct
name|nfsd_oidargs
name|onid
decl_stmt|;
struct|struct
block|{
name|int
name|vers
decl_stmt|;
comment|/* Just the first field of nfsstats. */
block|}
name|nfsstatver
struct|;
if|if
condition|(
name|uap
operator|->
name|flag
operator|&
name|NFSSVC_IDNAME
condition|)
block|{
if|if
condition|(
operator|(
name|uap
operator|->
name|flag
operator|&
name|NFSSVC_NEWSTRUCT
operator|)
operator|!=
literal|0
condition|)
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|argp
argument_list|,
operator|&
name|nid
argument_list|,
sizeof|sizeof
argument_list|(
name|nid
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|argp
argument_list|,
operator|&
name|onid
argument_list|,
sizeof|sizeof
argument_list|(
name|onid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|nid
operator|.
name|nid_flag
operator|=
name|onid
operator|.
name|nid_flag
expr_stmt|;
name|nid
operator|.
name|nid_uid
operator|=
name|onid
operator|.
name|nid_uid
expr_stmt|;
name|nid
operator|.
name|nid_gid
operator|=
name|onid
operator|.
name|nid_gid
expr_stmt|;
name|nid
operator|.
name|nid_usermax
operator|=
name|onid
operator|.
name|nid_usermax
expr_stmt|;
name|nid
operator|.
name|nid_usertimeout
operator|=
name|onid
operator|.
name|nid_usertimeout
expr_stmt|;
name|nid
operator|.
name|nid_name
operator|=
name|onid
operator|.
name|nid_name
expr_stmt|;
name|nid
operator|.
name|nid_namelen
operator|=
name|onid
operator|.
name|nid_namelen
expr_stmt|;
name|nid
operator|.
name|nid_ngroup
operator|=
literal|0
expr_stmt|;
name|nid
operator|.
name|nid_grps
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|error
operator|=
name|nfssvc_idname
argument_list|(
operator|&
name|nid
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
elseif|else
if|if
condition|(
name|uap
operator|->
name|flag
operator|&
name|NFSSVC_GETSTATS
condition|)
block|{
if|if
condition|(
operator|(
name|uap
operator|->
name|flag
operator|&
name|NFSSVC_NEWSTRUCT
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Copy fields to the old ext_nfsstat structure. */
name|oldnfsstats
operator|.
name|attrcache_hits
operator|=
name|nfsstatsv1
operator|.
name|attrcache_hits
expr_stmt|;
name|oldnfsstats
operator|.
name|attrcache_misses
operator|=
name|nfsstatsv1
operator|.
name|attrcache_misses
expr_stmt|;
name|oldnfsstats
operator|.
name|lookupcache_hits
operator|=
name|nfsstatsv1
operator|.
name|lookupcache_hits
expr_stmt|;
name|oldnfsstats
operator|.
name|lookupcache_misses
operator|=
name|nfsstatsv1
operator|.
name|lookupcache_misses
expr_stmt|;
name|oldnfsstats
operator|.
name|direofcache_hits
operator|=
name|nfsstatsv1
operator|.
name|direofcache_hits
expr_stmt|;
name|oldnfsstats
operator|.
name|direofcache_misses
operator|=
name|nfsstatsv1
operator|.
name|direofcache_misses
expr_stmt|;
name|oldnfsstats
operator|.
name|accesscache_hits
operator|=
name|nfsstatsv1
operator|.
name|accesscache_hits
expr_stmt|;
name|oldnfsstats
operator|.
name|accesscache_misses
operator|=
name|nfsstatsv1
operator|.
name|accesscache_misses
expr_stmt|;
name|oldnfsstats
operator|.
name|biocache_reads
operator|=
name|nfsstatsv1
operator|.
name|biocache_reads
expr_stmt|;
name|oldnfsstats
operator|.
name|read_bios
operator|=
name|nfsstatsv1
operator|.
name|read_bios
expr_stmt|;
name|oldnfsstats
operator|.
name|read_physios
operator|=
name|nfsstatsv1
operator|.
name|read_physios
expr_stmt|;
name|oldnfsstats
operator|.
name|biocache_writes
operator|=
name|nfsstatsv1
operator|.
name|biocache_writes
expr_stmt|;
name|oldnfsstats
operator|.
name|write_bios
operator|=
name|nfsstatsv1
operator|.
name|write_bios
expr_stmt|;
name|oldnfsstats
operator|.
name|write_physios
operator|=
name|nfsstatsv1
operator|.
name|write_physios
expr_stmt|;
name|oldnfsstats
operator|.
name|biocache_readlinks
operator|=
name|nfsstatsv1
operator|.
name|biocache_readlinks
expr_stmt|;
name|oldnfsstats
operator|.
name|readlink_bios
operator|=
name|nfsstatsv1
operator|.
name|readlink_bios
expr_stmt|;
name|oldnfsstats
operator|.
name|biocache_readdirs
operator|=
name|nfsstatsv1
operator|.
name|biocache_readdirs
expr_stmt|;
name|oldnfsstats
operator|.
name|readdir_bios
operator|=
name|nfsstatsv1
operator|.
name|readdir_bios
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NFSV4_NPROCS
condition|;
name|i
operator|++
control|)
name|oldnfsstats
operator|.
name|rpccnt
index|[
name|i
index|]
operator|=
name|nfsstatsv1
operator|.
name|rpccnt
index|[
name|i
index|]
expr_stmt|;
name|oldnfsstats
operator|.
name|rpcretries
operator|=
name|nfsstatsv1
operator|.
name|rpcretries
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NFSV4OP_NOPS
condition|;
name|i
operator|++
control|)
name|oldnfsstats
operator|.
name|srvrpccnt
index|[
name|i
index|]
operator|=
name|nfsstatsv1
operator|.
name|srvrpccnt
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|NFSV42_NOPS
operator|,
name|j
operator|=
name|NFSV4OP_NOPS
init|;
name|i
operator|<
name|NFSV42_NOPS
operator|+
name|NFSV4OP_FAKENOPS
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
name|oldnfsstats
operator|.
name|srvrpccnt
index|[
name|j
index|]
operator|=
name|nfsstatsv1
operator|.
name|srvrpccnt
index|[
name|i
index|]
expr_stmt|;
name|oldnfsstats
operator|.
name|srvrpc_errs
operator|=
name|nfsstatsv1
operator|.
name|srvrpc_errs
expr_stmt|;
name|oldnfsstats
operator|.
name|srv_errs
operator|=
name|nfsstatsv1
operator|.
name|srv_errs
expr_stmt|;
name|oldnfsstats
operator|.
name|rpcrequests
operator|=
name|nfsstatsv1
operator|.
name|rpcrequests
expr_stmt|;
name|oldnfsstats
operator|.
name|rpctimeouts
operator|=
name|nfsstatsv1
operator|.
name|rpctimeouts
expr_stmt|;
name|oldnfsstats
operator|.
name|rpcunexpected
operator|=
name|nfsstatsv1
operator|.
name|rpcunexpected
expr_stmt|;
name|oldnfsstats
operator|.
name|rpcinvalid
operator|=
name|nfsstatsv1
operator|.
name|rpcinvalid
expr_stmt|;
name|oldnfsstats
operator|.
name|srvcache_inproghits
operator|=
name|nfsstatsv1
operator|.
name|srvcache_inproghits
expr_stmt|;
name|oldnfsstats
operator|.
name|srvcache_idemdonehits
operator|=
name|nfsstatsv1
operator|.
name|srvcache_idemdonehits
expr_stmt|;
name|oldnfsstats
operator|.
name|srvcache_nonidemdonehits
operator|=
name|nfsstatsv1
operator|.
name|srvcache_nonidemdonehits
expr_stmt|;
name|oldnfsstats
operator|.
name|srvcache_misses
operator|=
name|nfsstatsv1
operator|.
name|srvcache_misses
expr_stmt|;
name|oldnfsstats
operator|.
name|srvcache_tcppeak
operator|=
name|nfsstatsv1
operator|.
name|srvcache_tcppeak
expr_stmt|;
name|oldnfsstats
operator|.
name|srvcache_size
operator|=
name|nfsstatsv1
operator|.
name|srvcache_size
expr_stmt|;
name|oldnfsstats
operator|.
name|srvclients
operator|=
name|nfsstatsv1
operator|.
name|srvclients
expr_stmt|;
name|oldnfsstats
operator|.
name|srvopenowners
operator|=
name|nfsstatsv1
operator|.
name|srvopenowners
expr_stmt|;
name|oldnfsstats
operator|.
name|srvopens
operator|=
name|nfsstatsv1
operator|.
name|srvopens
expr_stmt|;
name|oldnfsstats
operator|.
name|srvlockowners
operator|=
name|nfsstatsv1
operator|.
name|srvlockowners
expr_stmt|;
name|oldnfsstats
operator|.
name|srvlocks
operator|=
name|nfsstatsv1
operator|.
name|srvlocks
expr_stmt|;
name|oldnfsstats
operator|.
name|srvdelegates
operator|=
name|nfsstatsv1
operator|.
name|srvdelegates
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NFSV4OP_CBNOPS
condition|;
name|i
operator|++
control|)
name|oldnfsstats
operator|.
name|cbrpccnt
index|[
name|i
index|]
operator|=
name|nfsstatsv1
operator|.
name|cbrpccnt
index|[
name|i
index|]
expr_stmt|;
name|oldnfsstats
operator|.
name|clopenowners
operator|=
name|nfsstatsv1
operator|.
name|clopenowners
expr_stmt|;
name|oldnfsstats
operator|.
name|clopens
operator|=
name|nfsstatsv1
operator|.
name|clopens
expr_stmt|;
name|oldnfsstats
operator|.
name|cllockowners
operator|=
name|nfsstatsv1
operator|.
name|cllockowners
expr_stmt|;
name|oldnfsstats
operator|.
name|cllocks
operator|=
name|nfsstatsv1
operator|.
name|cllocks
expr_stmt|;
name|oldnfsstats
operator|.
name|cldelegates
operator|=
name|nfsstatsv1
operator|.
name|cldelegates
expr_stmt|;
name|oldnfsstats
operator|.
name|cllocalopenowners
operator|=
name|nfsstatsv1
operator|.
name|cllocalopenowners
expr_stmt|;
name|oldnfsstats
operator|.
name|cllocalopens
operator|=
name|nfsstatsv1
operator|.
name|cllocalopens
expr_stmt|;
name|oldnfsstats
operator|.
name|cllocallockowners
operator|=
name|nfsstatsv1
operator|.
name|cllocallockowners
expr_stmt|;
name|oldnfsstats
operator|.
name|cllocallocks
operator|=
name|nfsstatsv1
operator|.
name|cllocallocks
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|oldnfsstats
argument_list|,
name|uap
operator|->
name|argp
argument_list|,
sizeof|sizeof
argument_list|(
name|oldnfsstats
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|argp
argument_list|,
operator|&
name|nfsstatver
argument_list|,
sizeof|sizeof
argument_list|(
name|nfsstatver
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|nfsstatver
operator|.
name|vers
operator|!=
name|NFSSTATS_V1
condition|)
name|error
operator|=
name|EPERM
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|nfsstatsv1
argument_list|,
name|uap
operator|->
name|argp
argument_list|,
sizeof|sizeof
argument_list|(
name|nfsstatsv1
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|uap
operator|->
name|flag
operator|&
name|NFSSVC_ZEROCLTSTATS
operator|)
operator|!=
literal|0
condition|)
block|{
name|nfsstatsv1
operator|.
name|attrcache_hits
operator|=
literal|0
expr_stmt|;
name|nfsstatsv1
operator|.
name|attrcache_misses
operator|=
literal|0
expr_stmt|;
name|nfsstatsv1
operator|.
name|lookupcache_hits
operator|=
literal|0
expr_stmt|;
name|nfsstatsv1
operator|.
name|lookupcache_misses
operator|=
literal|0
expr_stmt|;
name|nfsstatsv1
operator|.
name|direofcache_hits
operator|=
literal|0
expr_stmt|;
name|nfsstatsv1
operator|.
name|direofcache_misses
operator|=
literal|0
expr_stmt|;
name|nfsstatsv1
operator|.
name|accesscache_hits
operator|=
literal|0
expr_stmt|;
name|nfsstatsv1
operator|.
name|accesscache_misses
operator|=
literal|0
expr_stmt|;
name|nfsstatsv1
operator|.
name|biocache_reads
operator|=
literal|0
expr_stmt|;
name|nfsstatsv1
operator|.
name|read_bios
operator|=
literal|0
expr_stmt|;
name|nfsstatsv1
operator|.
name|read_physios
operator|=
literal|0
expr_stmt|;
name|nfsstatsv1
operator|.
name|biocache_writes
operator|=
literal|0
expr_stmt|;
name|nfsstatsv1
operator|.
name|write_bios
operator|=
literal|0
expr_stmt|;
name|nfsstatsv1
operator|.
name|write_physios
operator|=
literal|0
expr_stmt|;
name|nfsstatsv1
operator|.
name|biocache_readlinks
operator|=
literal|0
expr_stmt|;
name|nfsstatsv1
operator|.
name|readlink_bios
operator|=
literal|0
expr_stmt|;
name|nfsstatsv1
operator|.
name|biocache_readdirs
operator|=
literal|0
expr_stmt|;
name|nfsstatsv1
operator|.
name|readdir_bios
operator|=
literal|0
expr_stmt|;
name|nfsstatsv1
operator|.
name|rpcretries
operator|=
literal|0
expr_stmt|;
name|nfsstatsv1
operator|.
name|rpcrequests
operator|=
literal|0
expr_stmt|;
name|nfsstatsv1
operator|.
name|rpctimeouts
operator|=
literal|0
expr_stmt|;
name|nfsstatsv1
operator|.
name|rpcunexpected
operator|=
literal|0
expr_stmt|;
name|nfsstatsv1
operator|.
name|rpcinvalid
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
name|nfsstatsv1
operator|.
name|rpccnt
argument_list|,
sizeof|sizeof
argument_list|(
name|nfsstatsv1
operator|.
name|rpccnt
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|uap
operator|->
name|flag
operator|&
name|NFSSVC_ZEROSRVSTATS
operator|)
operator|!=
literal|0
condition|)
block|{
name|nfsstatsv1
operator|.
name|srvrpc_errs
operator|=
literal|0
expr_stmt|;
name|nfsstatsv1
operator|.
name|srv_errs
operator|=
literal|0
expr_stmt|;
name|nfsstatsv1
operator|.
name|srvcache_inproghits
operator|=
literal|0
expr_stmt|;
name|nfsstatsv1
operator|.
name|srvcache_idemdonehits
operator|=
literal|0
expr_stmt|;
name|nfsstatsv1
operator|.
name|srvcache_nonidemdonehits
operator|=
literal|0
expr_stmt|;
name|nfsstatsv1
operator|.
name|srvcache_misses
operator|=
literal|0
expr_stmt|;
name|nfsstatsv1
operator|.
name|srvcache_tcppeak
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
name|nfsstatsv1
operator|.
name|srvrpccnt
argument_list|,
sizeof|sizeof
argument_list|(
name|nfsstatsv1
operator|.
name|srvrpccnt
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|nfsstatsv1
operator|.
name|cbrpccnt
argument_list|,
sizeof|sizeof
argument_list|(
name|nfsstatsv1
operator|.
name|cbrpccnt
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
goto|goto
name|out
goto|;
block|}
elseif|else
if|if
condition|(
name|uap
operator|->
name|flag
operator|&
name|NFSSVC_NFSUSERDPORT
condition|)
block|{
name|u_short
name|sockport
decl_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|argp
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|sockport
argument_list|,
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|nfsrv_nfsuserdport
argument_list|(
name|sockport
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|uap
operator|->
name|flag
operator|&
name|NFSSVC_NFSUSERDDELPORT
condition|)
block|{
name|nfsrv_nfsuserddelport
argument_list|()
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
name|out
label|:
name|NFSEXITCODE
argument_list|(
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * called by all three modevent routines, so that it gets things  * initialized soon enough.  */
end_comment

begin_function
name|void
name|newnfs_portinit
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|int
name|inited
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|inited
condition|)
return|return;
name|inited
operator|=
literal|1
expr_stmt|;
comment|/* Initialize SMP locks used by both client and server. */
name|mtx_init
argument_list|(
operator|&
name|newnfsd_mtx
argument_list|,
literal|"newnfsd_mtx"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|nfs_state_mutex
argument_list|,
literal|"nfs_state_mutex"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|nfs_clstate_mutex
argument_list|,
literal|"nfs_clstate_mutex"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Determine if the file system supports NFSv4 ACLs.  * Return 1 if it does, 0 otherwise.  */
end_comment

begin_function
name|int
name|nfs_supportsnfsv4acls
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|register_t
name|retval
decl_stmt|;
name|ASSERT_VOP_LOCKED
argument_list|(
name|vp
argument_list|,
literal|"nfs supports nfsv4acls"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nfsrv_useacl
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|error
operator|=
name|VOP_PATHCONF
argument_list|(
name|vp
argument_list|,
name|_PC_ACL_NFS4
argument_list|,
operator|&
name|retval
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|retval
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function_decl
specifier|extern
name|int
function_decl|(
modifier|*
name|nfsd_call_nfscommon
function_decl|)
parameter_list|(
name|struct
name|thread
modifier|*
parameter_list|,
name|struct
name|nfssvc_args
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Called once to initialize data structures...  */
end_comment

begin_function
specifier|static
name|int
name|nfscommon_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|loaded
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MOD_LOAD
case|:
if|if
condition|(
name|loaded
condition|)
goto|goto
name|out
goto|;
name|newnfs_portinit
argument_list|()
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|nfs_nameid_mutex
argument_list|,
literal|"nfs_nameid_mutex"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|nfs_sockl_mutex
argument_list|,
literal|"nfs_sockl_mutex"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|nfs_slock_mutex
argument_list|,
literal|"nfs_slock_mutex"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|nfs_req_mutex
argument_list|,
literal|"nfs_req_mutex"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|nfsrv_nfsuserdsock
operator|.
name|nr_mtx
argument_list|,
literal|"nfsuserd"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|newnfsd_callout
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|newnfs_init
argument_list|()
expr_stmt|;
name|nfsd_call_nfscommon
operator|=
name|nfssvc_nfscommon
expr_stmt|;
name|loaded
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
if|if
condition|(
name|newnfs_numnfsd
operator|!=
literal|0
operator|||
name|nfsrv_nfsuserd
operator|!=
literal|0
operator|||
name|nfs_numnfscbd
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
name|nfsd_call_nfscommon
operator|=
name|NULL
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|newnfsd_callout
argument_list|)
expr_stmt|;
comment|/* Clean out the name<-->id cache. */
name|nfsrv_cleanusergroup
argument_list|()
expr_stmt|;
comment|/* and get rid of the mutexes */
name|mtx_destroy
argument_list|(
operator|&
name|nfs_nameid_mutex
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|newnfsd_mtx
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|nfs_state_mutex
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|nfs_clstate_mutex
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|nfs_sockl_mutex
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|nfs_slock_mutex
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|nfs_req_mutex
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|nfsrv_nfsuserdsock
operator|.
name|nr_mtx
argument_list|)
expr_stmt|;
name|loaded
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
block|}
name|out
label|:
name|NFSEXITCODE
argument_list|(
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|moduledata_t
name|nfscommon_mod
init|=
block|{
literal|"nfscommon"
block|,
name|nfscommon_modevent
block|,
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|nfscommon
argument_list|,
name|nfscommon_mod
argument_list|,
name|SI_SUB_VFS
argument_list|,
name|SI_ORDER_ANY
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* So that loader and kldload(2) can find us, wherever we are.. */
end_comment

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|nfscommon
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|nfscommon
argument_list|,
name|nfssvc
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|nfscommon
argument_list|,
name|krpc
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

