begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2001, 2002 Scott Long<scottl@freebsd.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/* udf_vfsops.c */
end_comment

begin_comment
comment|/* Implement the VFS side of things */
end_comment

begin_comment
comment|/*  * Ok, here's how it goes.  The UDF specs are pretty clear on how each data  * structure is made up, but not very clear on how they relate to each other.  * Here is the skinny... This demostrates a filesystem with one file in the  * root directory.  Subdirectories are treated just as normal files, but they  * have File Id Descriptors of their children as their file data.  As for the  * Anchor Volume Descriptor Pointer, it can exist in two of the following three  * places: sector 256, sector n (the max sector of the disk), or sector  * n - 256.  It's a pretty good bet that one will exist at sector 256 though.  * One caveat is unclosed CD media.  For that, sector 256 cannot be written,  * so the Anchor Volume Descriptor Pointer can exist at sector 512 until the  * media is closed.  *  *  Sector:  *     256:  *       n: Anchor Volume Descriptor Pointer  * n - 256:	|  *		|  *		|-->Main Volume Descriptor Sequence  *			|	|  *			|	|  *			|	|-->Logical Volume Descriptor  *			|			  |  *			|-->Partition Descriptor  |  *				|		  |  *				|		  |  *				|-->Fileset Descriptor  *					|  *					|  *					|-->Root Dir File Entry  *						|  *						|  *						|-->File data:  *						    File Id Descriptor  *							|  *							|  *							|-->File Entry  *								|  *								|  *								|-->File data  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/dirent.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/iconv.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<geom/geom.h>
end_include

begin_include
include|#
directive|include
file|<geom/geom_vfs.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<fs/udf/ecma167-udf.h>
end_include

begin_include
include|#
directive|include
file|<fs/udf/osta.h>
end_include

begin_include
include|#
directive|include
file|<fs/udf/udf.h>
end_include

begin_include
include|#
directive|include
file|<fs/udf/udf_mount.h>
end_include

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_UDFMOUNT
argument_list|,
literal|"udf_mount"
argument_list|,
literal|"UDF mount structure"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_UDFFENTRY
argument_list|,
literal|"udf_fentry"
argument_list|,
literal|"UDF file entry structure"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|iconv_functions
modifier|*
name|udf_iconv
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Zones */
end_comment

begin_decl_stmt
name|uma_zone_t
name|udf_zone_trans
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uma_zone_t
name|udf_zone_node
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uma_zone_t
name|udf_zone_ds
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vfs_init_t
name|udf_init
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vfs_uninit_t
name|udf_uninit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vfs_mount_t
name|udf_mount
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vfs_root_t
name|udf_root
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vfs_statfs_t
name|udf_statfs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vfs_unmount_t
name|udf_unmount
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vfs_fhtovp_t
name|udf_fhtovp
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|udf_find_partmaps
parameter_list|(
name|struct
name|udf_mnt
modifier|*
parameter_list|,
name|struct
name|logvol_desc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|vfsops
name|udf_vfsops
init|=
block|{
operator|.
name|vfs_fhtovp
operator|=
name|udf_fhtovp
block|,
operator|.
name|vfs_init
operator|=
name|udf_init
block|,
operator|.
name|vfs_mount
operator|=
name|udf_mount
block|,
operator|.
name|vfs_root
operator|=
name|udf_root
block|,
operator|.
name|vfs_statfs
operator|=
name|udf_statfs
block|,
operator|.
name|vfs_uninit
operator|=
name|udf_uninit
block|,
operator|.
name|vfs_unmount
operator|=
name|udf_unmount
block|,
operator|.
name|vfs_vget
operator|=
name|udf_vget
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|VFS_SET
argument_list|(
name|udf_vfsops
argument_list|,
name|udf
argument_list|,
name|VFCF_READONLY
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|udf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|int
name|udf_mountfs
parameter_list|(
name|struct
name|vnode
modifier|*
parameter_list|,
name|struct
name|mount
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|udf_init
parameter_list|(
name|struct
name|vfsconf
modifier|*
name|foo
parameter_list|)
block|{
comment|/* 	 * This code used to pre-allocate a certain number of pages for each 	 * pool, reducing the need to grow the zones later on.  UMA doesn't 	 * advertise any such functionality, unfortunately =-< 	 */
name|udf_zone_trans
operator|=
name|uma_zcreate
argument_list|(
literal|"UDF translation buffer, zone"
argument_list|,
name|MAXNAMLEN
operator|*
sizeof|sizeof
argument_list|(
name|unicode_t
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|udf_zone_node
operator|=
name|uma_zcreate
argument_list|(
literal|"UDF Node zone"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|udf_node
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|udf_zone_ds
operator|=
name|uma_zcreate
argument_list|(
literal|"UDF Dirstream zone"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|udf_dirstream
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|udf_zone_node
operator|==
name|NULL
operator|)
operator|||
operator|(
name|udf_zone_trans
operator|==
name|NULL
operator|)
operator|||
operator|(
name|udf_zone_ds
operator|==
name|NULL
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"Cannot create allocation zones.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|udf_uninit
parameter_list|(
name|struct
name|vfsconf
modifier|*
name|foo
parameter_list|)
block|{
if|if
condition|(
name|udf_zone_trans
operator|!=
name|NULL
condition|)
block|{
name|uma_zdestroy
argument_list|(
name|udf_zone_trans
argument_list|)
expr_stmt|;
name|udf_zone_trans
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|udf_zone_node
operator|!=
name|NULL
condition|)
block|{
name|uma_zdestroy
argument_list|(
name|udf_zone_node
argument_list|)
expr_stmt|;
name|udf_zone_node
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|udf_zone_ds
operator|!=
name|NULL
condition|)
block|{
name|uma_zdestroy
argument_list|(
name|udf_zone_ds
argument_list|)
expr_stmt|;
name|udf_zone_ds
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|udf_mount
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|devvp
decl_stmt|;
comment|/* vnode of the mount device */
name|struct
name|udf_mnt
modifier|*
name|imp
init|=
literal|0
decl_stmt|;
name|struct
name|vfsoptlist
modifier|*
name|opts
decl_stmt|;
name|char
modifier|*
name|fspec
decl_stmt|,
modifier|*
name|cs_disk
decl_stmt|,
modifier|*
name|cs_local
decl_stmt|;
name|int
name|error
decl_stmt|,
name|len
decl_stmt|,
modifier|*
name|udf_flags
decl_stmt|;
name|struct
name|nameidata
name|nd
decl_stmt|,
modifier|*
name|ndp
init|=
operator|&
name|nd
decl_stmt|;
name|opts
operator|=
name|mp
operator|->
name|mnt_optnew
expr_stmt|;
comment|/* 	 * Unconditionally mount as read-only. 	 */
name|MNT_ILOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|mp
operator|->
name|mnt_flag
operator||=
name|MNT_RDONLY
expr_stmt|;
name|MNT_IUNLOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
comment|/* 	 * No root filesystem support.  Probably not a big deal, since the 	 * bootloader doesn't understand UDF. 	 */
if|if
condition|(
name|mp
operator|->
name|mnt_flag
operator|&
name|MNT_ROOTFS
condition|)
return|return
operator|(
name|ENOTSUP
operator|)
return|;
name|fspec
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|vfs_getopt
argument_list|(
name|opts
argument_list|,
literal|"from"
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|fspec
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
name|fspec
index|[
name|len
operator|-
literal|1
index|]
operator|!=
literal|'\0'
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|mp
operator|->
name|mnt_flag
operator|&
name|MNT_UPDATE
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Check that the mount device exists */
if|if
condition|(
name|fspec
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|NDINIT
argument_list|(
name|ndp
argument_list|,
name|LOOKUP
argument_list|,
name|FOLLOW
operator||
name|LOCKLEAF
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|fspec
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|namei
argument_list|(
name|ndp
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|NDFREE
argument_list|(
name|ndp
argument_list|,
name|NDF_ONLY_PNBUF
argument_list|)
expr_stmt|;
name|devvp
operator|=
name|ndp
operator|->
name|ni_vp
expr_stmt|;
if|if
condition|(
name|vn_isdisk
argument_list|(
name|devvp
argument_list|,
operator|&
name|error
argument_list|)
operator|==
literal|0
condition|)
block|{
name|vput
argument_list|(
name|devvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Check the access rights on the mount device */
name|error
operator|=
name|VOP_ACCESS
argument_list|(
name|devvp
argument_list|,
name|VREAD
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_VFS_MOUNT_PERM
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|vput
argument_list|(
name|devvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|udf_mountfs
argument_list|(
name|devvp
argument_list|,
name|mp
argument_list|)
operator|)
condition|)
block|{
name|vrele
argument_list|(
name|devvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|imp
operator|=
name|VFSTOUDFFS
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|udf_flags
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|vfs_getopt
argument_list|(
name|opts
argument_list|,
literal|"flags"
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|udf_flags
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|len
operator|!=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|imp
operator|->
name|im_flags
operator|=
operator|*
name|udf_flags
expr_stmt|;
if|if
condition|(
name|imp
operator|->
name|im_flags
operator|&
name|UDFMNT_KICONV
operator|&&
name|udf_iconv
condition|)
block|{
name|cs_disk
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|vfs_getopt
argument_list|(
name|opts
argument_list|,
literal|"cs_disk"
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|cs_disk
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
name|cs_disk
index|[
name|len
operator|-
literal|1
index|]
operator|!=
literal|'\0'
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|cs_local
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|vfs_getopt
argument_list|(
name|opts
argument_list|,
literal|"cs_local"
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|cs_local
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
name|cs_local
index|[
name|len
operator|-
literal|1
index|]
operator|!=
literal|'\0'
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|udf_iconv
operator|->
name|open
argument_list|(
name|cs_local
argument_list|,
name|cs_disk
argument_list|,
operator|&
name|imp
operator|->
name|im_d2l
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|udf_iconv->open(cs_disk, cs_local,&imp->im_l2d);
endif|#
directive|endif
block|}
name|vfs_mountedfrom
argument_list|(
name|mp
argument_list|,
name|fspec
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/*  * Check the descriptor tag for both the correct id and correct checksum.  * Return zero if all is good, EINVAL if not.  */
end_comment

begin_function
name|int
name|udf_checktag
parameter_list|(
name|struct
name|desc_tag
modifier|*
name|tag
parameter_list|,
name|uint16_t
name|id
parameter_list|)
block|{
name|uint8_t
modifier|*
name|itag
decl_stmt|;
name|uint8_t
name|i
decl_stmt|,
name|cksum
init|=
literal|0
decl_stmt|;
name|itag
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|tag
expr_stmt|;
if|if
condition|(
name|le16toh
argument_list|(
name|tag
operator|->
name|id
argument_list|)
operator|!=
name|id
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
name|cksum
operator|=
name|cksum
operator|+
name|itag
index|[
name|i
index|]
expr_stmt|;
name|cksum
operator|=
name|cksum
operator|-
name|itag
index|[
literal|4
index|]
expr_stmt|;
if|if
condition|(
name|cksum
operator|==
name|tag
operator|->
name|cksum
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|udf_mountfs
parameter_list|(
name|struct
name|vnode
modifier|*
name|devvp
parameter_list|,
name|struct
name|mount
modifier|*
name|mp
parameter_list|)
block|{
name|struct
name|buf
modifier|*
name|bp
init|=
name|NULL
decl_stmt|;
name|struct
name|cdev
modifier|*
name|dev
decl_stmt|;
name|struct
name|anchor_vdp
name|avdp
decl_stmt|;
name|struct
name|udf_mnt
modifier|*
name|udfmp
init|=
name|NULL
decl_stmt|;
name|struct
name|part_desc
modifier|*
name|pd
decl_stmt|;
name|struct
name|logvol_desc
modifier|*
name|lvd
decl_stmt|;
name|struct
name|fileset_desc
modifier|*
name|fsd
decl_stmt|;
name|struct
name|file_entry
modifier|*
name|root_fentry
decl_stmt|;
name|uint32_t
name|sector
decl_stmt|,
name|size
decl_stmt|,
name|mvds_start
decl_stmt|,
name|mvds_end
decl_stmt|;
name|uint32_t
name|logical_secsize
decl_stmt|;
name|uint32_t
name|fsd_offset
init|=
literal|0
decl_stmt|;
name|uint16_t
name|part_num
init|=
literal|0
decl_stmt|,
name|fsd_part
init|=
literal|0
decl_stmt|;
name|int
name|error
init|=
name|EINVAL
decl_stmt|;
name|int
name|logvol_found
init|=
literal|0
decl_stmt|,
name|part_found
init|=
literal|0
decl_stmt|,
name|fsd_found
init|=
literal|0
decl_stmt|;
name|int
name|bsize
decl_stmt|;
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|struct
name|bufobj
modifier|*
name|bo
decl_stmt|;
name|dev
operator|=
name|devvp
operator|->
name|v_rdev
expr_stmt|;
name|dev_ref
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DROP_GIANT
argument_list|()
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
name|error
operator|=
name|g_vfs_open
argument_list|(
name|devvp
argument_list|,
operator|&
name|cp
argument_list|,
literal|"udf"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|PICKUP_GIANT
argument_list|()
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|devvp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bail
goto|;
name|bo
operator|=
operator|&
name|devvp
operator|->
name|v_bufobj
expr_stmt|;
if|if
condition|(
name|devvp
operator|->
name|v_rdev
operator|->
name|si_iosize_max
operator|!=
literal|0
condition|)
name|mp
operator|->
name|mnt_iosize_max
operator|=
name|devvp
operator|->
name|v_rdev
operator|->
name|si_iosize_max
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|mnt_iosize_max
operator|>
name|MAXPHYS
condition|)
name|mp
operator|->
name|mnt_iosize_max
operator|=
name|MAXPHYS
expr_stmt|;
comment|/* XXX: should be M_WAITOK */
name|udfmp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|udf_mnt
argument_list|)
argument_list|,
name|M_UDFMOUNT
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|udfmp
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"Cannot allocate UDF mount struct\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bail
goto|;
block|}
name|mp
operator|->
name|mnt_data
operator|=
name|udfmp
expr_stmt|;
name|mp
operator|->
name|mnt_stat
operator|.
name|f_fsid
operator|.
name|val
index|[
literal|0
index|]
operator|=
name|dev2udev
argument_list|(
name|devvp
operator|->
name|v_rdev
argument_list|)
expr_stmt|;
name|mp
operator|->
name|mnt_stat
operator|.
name|f_fsid
operator|.
name|val
index|[
literal|1
index|]
operator|=
name|mp
operator|->
name|mnt_vfc
operator|->
name|vfc_typenum
expr_stmt|;
name|MNT_ILOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|mp
operator|->
name|mnt_flag
operator||=
name|MNT_LOCAL
expr_stmt|;
name|mp
operator|->
name|mnt_kern_flag
operator||=
name|MNTK_MPSAFE
operator||
name|MNTK_LOOKUP_SHARED
expr_stmt|;
name|MNT_IUNLOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|udfmp
operator|->
name|im_mountp
operator|=
name|mp
expr_stmt|;
name|udfmp
operator|->
name|im_dev
operator|=
name|dev
expr_stmt|;
name|udfmp
operator|->
name|im_devvp
operator|=
name|devvp
expr_stmt|;
name|udfmp
operator|->
name|im_d2l
operator|=
name|NULL
expr_stmt|;
name|udfmp
operator|->
name|im_cp
operator|=
name|cp
expr_stmt|;
name|udfmp
operator|->
name|im_bo
operator|=
name|bo
expr_stmt|;
if|#
directive|if
literal|0
block|udfmp->im_l2d = NULL;
endif|#
directive|endif
comment|/* 	 * The UDF specification defines a logical sectorsize of 2048 	 * for DVD media. 	 */
name|logical_secsize
operator|=
literal|2048
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|logical_secsize
operator|%
name|cp
operator|->
name|provider
operator|->
name|sectorsize
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|logical_secsize
operator|<
name|cp
operator|->
name|provider
operator|->
name|sectorsize
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bail
goto|;
block|}
name|bsize
operator|=
name|cp
operator|->
name|provider
operator|->
name|sectorsize
expr_stmt|;
comment|/*  	 * Get the Anchor Volume Descriptor Pointer from sector 256. 	 * XXX Should also check sector n - 256, n, and 512. 	 */
name|sector
operator|=
literal|256
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|bread
argument_list|(
name|devvp
argument_list|,
name|sector
operator|*
name|btodb
argument_list|(
name|logical_secsize
argument_list|)
argument_list|,
name|bsize
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|bp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|bail
goto|;
if|if
condition|(
operator|(
name|error
operator|=
name|udf_checktag
argument_list|(
operator|(
expr|struct
name|desc_tag
operator|*
operator|)
name|bp
operator|->
name|b_data
argument_list|,
name|TAGID_ANCHOR
argument_list|)
operator|)
condition|)
goto|goto
name|bail
goto|;
name|bcopy
argument_list|(
name|bp
operator|->
name|b_data
argument_list|,
operator|&
name|avdp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|anchor_vdp
argument_list|)
argument_list|)
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Extract the Partition Descriptor and Logical Volume Descriptor 	 * from the Volume Descriptor Sequence. 	 * XXX Should we care about the partition type right now? 	 * XXX What about multiple partitions? 	 */
name|mvds_start
operator|=
name|le32toh
argument_list|(
name|avdp
operator|.
name|main_vds_ex
operator|.
name|loc
argument_list|)
expr_stmt|;
name|mvds_end
operator|=
name|mvds_start
operator|+
operator|(
name|le32toh
argument_list|(
name|avdp
operator|.
name|main_vds_ex
operator|.
name|len
argument_list|)
operator|-
literal|1
operator|)
operator|/
name|bsize
expr_stmt|;
for|for
control|(
name|sector
operator|=
name|mvds_start
init|;
name|sector
operator|<
name|mvds_end
condition|;
name|sector
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|bread
argument_list|(
name|devvp
argument_list|,
name|sector
operator|*
name|btodb
argument_list|(
name|logical_secsize
argument_list|)
argument_list|,
name|bsize
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|bp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Can't read sector %d of VDS\n"
argument_list|,
name|sector
argument_list|)
expr_stmt|;
goto|goto
name|bail
goto|;
block|}
name|lvd
operator|=
operator|(
expr|struct
name|logvol_desc
operator|*
operator|)
name|bp
operator|->
name|b_data
expr_stmt|;
if|if
condition|(
operator|!
name|udf_checktag
argument_list|(
operator|&
name|lvd
operator|->
name|tag
argument_list|,
name|TAGID_LOGVOL
argument_list|)
condition|)
block|{
name|udfmp
operator|->
name|bsize
operator|=
name|le32toh
argument_list|(
name|lvd
operator|->
name|lb_size
argument_list|)
expr_stmt|;
name|udfmp
operator|->
name|bmask
operator|=
name|udfmp
operator|->
name|bsize
operator|-
literal|1
expr_stmt|;
name|udfmp
operator|->
name|bshift
operator|=
name|ffs
argument_list|(
name|udfmp
operator|->
name|bsize
argument_list|)
operator|-
literal|1
expr_stmt|;
name|fsd_part
operator|=
name|le16toh
argument_list|(
name|lvd
operator|->
name|_lvd_use
operator|.
name|fsd_loc
operator|.
name|loc
operator|.
name|part_num
argument_list|)
expr_stmt|;
name|fsd_offset
operator|=
name|le32toh
argument_list|(
name|lvd
operator|->
name|_lvd_use
operator|.
name|fsd_loc
operator|.
name|loc
operator|.
name|lb_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|udf_find_partmaps
argument_list|(
name|udfmp
argument_list|,
name|lvd
argument_list|)
condition|)
break|break;
name|logvol_found
operator|=
literal|1
expr_stmt|;
block|}
name|pd
operator|=
operator|(
expr|struct
name|part_desc
operator|*
operator|)
name|bp
operator|->
name|b_data
expr_stmt|;
if|if
condition|(
operator|!
name|udf_checktag
argument_list|(
operator|&
name|pd
operator|->
name|tag
argument_list|,
name|TAGID_PARTITION
argument_list|)
condition|)
block|{
name|part_found
operator|=
literal|1
expr_stmt|;
name|part_num
operator|=
name|le16toh
argument_list|(
name|pd
operator|->
name|part_num
argument_list|)
expr_stmt|;
name|udfmp
operator|->
name|part_len
operator|=
name|le32toh
argument_list|(
name|pd
operator|->
name|part_len
argument_list|)
expr_stmt|;
name|udfmp
operator|->
name|part_start
operator|=
name|le32toh
argument_list|(
name|pd
operator|->
name|start_loc
argument_list|)
expr_stmt|;
block|}
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|part_found
operator|)
operator|&&
operator|(
name|logvol_found
operator|)
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|part_found
operator|||
operator|!
name|logvol_found
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bail
goto|;
block|}
if|if
condition|(
name|fsd_part
operator|!=
name|part_num
condition|)
block|{
name|printf
argument_list|(
literal|"FSD does not lie within the partition!\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bail
goto|;
block|}
comment|/* 	 * Grab the Fileset Descriptor 	 * Thanks to Chuck McCrobie<mccrobie@cablespeed.com> for pointing 	 * me in the right direction here. 	 */
name|sector
operator|=
name|udfmp
operator|->
name|part_start
operator|+
name|fsd_offset
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|RDSECTOR
argument_list|(
name|devvp
argument_list|,
name|sector
argument_list|,
name|udfmp
operator|->
name|bsize
argument_list|,
operator|&
name|bp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Cannot read sector %d of FSD\n"
argument_list|,
name|sector
argument_list|)
expr_stmt|;
goto|goto
name|bail
goto|;
block|}
name|fsd
operator|=
operator|(
expr|struct
name|fileset_desc
operator|*
operator|)
name|bp
operator|->
name|b_data
expr_stmt|;
if|if
condition|(
operator|!
name|udf_checktag
argument_list|(
operator|&
name|fsd
operator|->
name|tag
argument_list|,
name|TAGID_FSD
argument_list|)
condition|)
block|{
name|fsd_found
operator|=
literal|1
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|fsd
operator|->
name|rootdir_icb
argument_list|,
operator|&
name|udfmp
operator|->
name|root_icb
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|long_ad
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|fsd_found
condition|)
block|{
name|printf
argument_list|(
literal|"Couldn't find the fsd\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bail
goto|;
block|}
comment|/* 	 * Find the file entry for the root directory. 	 */
name|sector
operator|=
name|le32toh
argument_list|(
name|udfmp
operator|->
name|root_icb
operator|.
name|loc
operator|.
name|lb_num
argument_list|)
operator|+
name|udfmp
operator|->
name|part_start
expr_stmt|;
name|size
operator|=
name|le32toh
argument_list|(
name|udfmp
operator|->
name|root_icb
operator|.
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|udf_readlblks
argument_list|(
name|udfmp
argument_list|,
name|sector
argument_list|,
name|size
argument_list|,
operator|&
name|bp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Cannot read sector %d\n"
argument_list|,
name|sector
argument_list|)
expr_stmt|;
goto|goto
name|bail
goto|;
block|}
name|root_fentry
operator|=
operator|(
expr|struct
name|file_entry
operator|*
operator|)
name|bp
operator|->
name|b_data
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|udf_checktag
argument_list|(
operator|&
name|root_fentry
operator|->
name|tag
argument_list|,
name|TAGID_FENTRY
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"Invalid root file entry!\n"
argument_list|)
expr_stmt|;
goto|goto
name|bail
goto|;
block|}
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
name|bail
label|:
if|if
condition|(
name|udfmp
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|udfmp
argument_list|,
name|M_UDFMOUNT
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
block|{
name|DROP_GIANT
argument_list|()
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
name|g_vfs_close
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|PICKUP_GIANT
argument_list|()
expr_stmt|;
block|}
name|dev_rel
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_function
specifier|static
name|int
name|udf_unmount
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|int
name|mntflags
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|udf_mnt
modifier|*
name|udfmp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|flags
init|=
literal|0
decl_stmt|;
name|udfmp
operator|=
name|VFSTOUDFFS
argument_list|(
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mntflags
operator|&
name|MNT_FORCE
condition|)
name|flags
operator||=
name|FORCECLOSE
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|vflush
argument_list|(
name|mp
argument_list|,
literal|0
argument_list|,
name|flags
argument_list|,
name|td
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|udfmp
operator|->
name|im_flags
operator|&
name|UDFMNT_KICONV
operator|&&
name|udf_iconv
condition|)
block|{
if|if
condition|(
name|udfmp
operator|->
name|im_d2l
condition|)
name|udf_iconv
operator|->
name|close
argument_list|(
name|udfmp
operator|->
name|im_d2l
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (udfmp->im_l2d) 			udf_iconv->close(udfmp->im_l2d);
endif|#
directive|endif
block|}
name|DROP_GIANT
argument_list|()
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
name|g_vfs_close
argument_list|(
name|udfmp
operator|->
name|im_cp
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|PICKUP_GIANT
argument_list|()
expr_stmt|;
name|vrele
argument_list|(
name|udfmp
operator|->
name|im_devvp
argument_list|)
expr_stmt|;
name|dev_rel
argument_list|(
name|udfmp
operator|->
name|im_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|udfmp
operator|->
name|s_table
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|udfmp
operator|->
name|s_table
argument_list|,
name|M_UDFMOUNT
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|udfmp
argument_list|,
name|M_UDFMOUNT
argument_list|)
expr_stmt|;
name|mp
operator|->
name|mnt_data
operator|=
name|NULL
expr_stmt|;
name|MNT_ILOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|mp
operator|->
name|mnt_flag
operator|&=
operator|~
name|MNT_LOCAL
expr_stmt|;
name|MNT_IUNLOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|udf_root
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|udf_mnt
modifier|*
name|udfmp
decl_stmt|;
name|ino_t
name|id
decl_stmt|;
name|udfmp
operator|=
name|VFSTOUDFFS
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|id
operator|=
name|udf_getid
argument_list|(
operator|&
name|udfmp
operator|->
name|root_icb
argument_list|)
expr_stmt|;
return|return
operator|(
name|udf_vget
argument_list|(
name|mp
argument_list|,
name|id
argument_list|,
name|flags
argument_list|,
name|vpp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|udf_statfs
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|struct
name|statfs
modifier|*
name|sbp
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|udf_mnt
modifier|*
name|udfmp
decl_stmt|;
name|udfmp
operator|=
name|VFSTOUDFFS
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|sbp
operator|->
name|f_bsize
operator|=
name|udfmp
operator|->
name|bsize
expr_stmt|;
name|sbp
operator|->
name|f_iosize
operator|=
name|udfmp
operator|->
name|bsize
expr_stmt|;
name|sbp
operator|->
name|f_blocks
operator|=
name|udfmp
operator|->
name|part_len
expr_stmt|;
name|sbp
operator|->
name|f_bfree
operator|=
literal|0
expr_stmt|;
name|sbp
operator|->
name|f_bavail
operator|=
literal|0
expr_stmt|;
name|sbp
operator|->
name|f_files
operator|=
literal|0
expr_stmt|;
name|sbp
operator|->
name|f_ffree
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|udf_vget
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|ino_t
name|ino
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
parameter_list|)
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|devvp
decl_stmt|;
name|struct
name|udf_mnt
modifier|*
name|udfmp
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|udf_node
modifier|*
name|unode
decl_stmt|;
name|struct
name|file_entry
modifier|*
name|fe
decl_stmt|;
name|int
name|error
decl_stmt|,
name|sector
decl_stmt|,
name|size
decl_stmt|;
name|error
operator|=
name|vfs_hash_get
argument_list|(
name|mp
argument_list|,
name|ino
argument_list|,
name|flags
argument_list|,
name|curthread
argument_list|,
name|vpp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|*
name|vpp
operator|!=
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * We must promote to an exclusive lock for vnode creation.  This 	 * can happen if lookup is passed LOCKSHARED.  	 */
if|if
condition|(
operator|(
name|flags
operator|&
name|LK_TYPE_MASK
operator|)
operator|==
name|LK_SHARED
condition|)
block|{
name|flags
operator|&=
operator|~
name|LK_TYPE_MASK
expr_stmt|;
name|flags
operator||=
name|LK_EXCLUSIVE
expr_stmt|;
block|}
comment|/* 	 * We do not lock vnode creation as it is believed to be too 	 * expensive for such rare case as simultaneous creation of vnode 	 * for same ino by different processes. We just allow them to race 	 * and check later to decide who wins. Let the race begin! 	 */
name|td
operator|=
name|curthread
expr_stmt|;
name|udfmp
operator|=
name|VFSTOUDFFS
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|unode
operator|=
name|uma_zalloc
argument_list|(
name|udf_zone_node
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|udf_allocv
argument_list|(
name|mp
argument_list|,
operator|&
name|vp
argument_list|,
name|td
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"Error from udf_allocv\n"
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|udf_zone_node
argument_list|,
name|unode
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|unode
operator|->
name|i_vnode
operator|=
name|vp
expr_stmt|;
name|unode
operator|->
name|hash_id
operator|=
name|ino
expr_stmt|;
name|unode
operator|->
name|udfmp
operator|=
name|udfmp
expr_stmt|;
name|vp
operator|->
name|v_data
operator|=
name|unode
expr_stmt|;
name|lockmgr
argument_list|(
name|vp
operator|->
name|v_vnlock
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|error
operator|=
name|insmntque
argument_list|(
name|vp
argument_list|,
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|uma_zfree
argument_list|(
name|udf_zone_node
argument_list|,
name|unode
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|vfs_hash_insert
argument_list|(
name|vp
argument_list|,
name|ino
argument_list|,
name|flags
argument_list|,
name|td
argument_list|,
name|vpp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|*
name|vpp
operator|!=
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * Copy in the file entry.  Per the spec, the size can only be 1 block. 	 */
name|sector
operator|=
name|ino
operator|+
name|udfmp
operator|->
name|part_start
expr_stmt|;
name|devvp
operator|=
name|udfmp
operator|->
name|im_devvp
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|RDSECTOR
argument_list|(
name|devvp
argument_list|,
name|sector
argument_list|,
name|udfmp
operator|->
name|bsize
argument_list|,
operator|&
name|bp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Cannot read sector %d\n"
argument_list|,
name|sector
argument_list|)
expr_stmt|;
name|vgone
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|fe
operator|=
operator|(
expr|struct
name|file_entry
operator|*
operator|)
name|bp
operator|->
name|b_data
expr_stmt|;
if|if
condition|(
name|udf_checktag
argument_list|(
operator|&
name|fe
operator|->
name|tag
argument_list|,
name|TAGID_FENTRY
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Invalid file entry!\n"
argument_list|)
expr_stmt|;
name|vgone
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|size
operator|=
name|UDF_FENTRY_SIZE
operator|+
name|le32toh
argument_list|(
name|fe
operator|->
name|l_ea
argument_list|)
operator|+
name|le32toh
argument_list|(
name|fe
operator|->
name|l_ad
argument_list|)
expr_stmt|;
name|unode
operator|->
name|fentry
operator|=
name|malloc
argument_list|(
name|size
argument_list|,
name|M_UDFFENTRY
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|unode
operator|->
name|fentry
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"Cannot allocate file entry block\n"
argument_list|)
expr_stmt|;
name|vgone
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bcopy
argument_list|(
name|bp
operator|->
name|b_data
argument_list|,
name|unode
operator|->
name|fentry
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|unode
operator|->
name|fentry
operator|->
name|icbtag
operator|.
name|file_type
condition|)
block|{
default|default:
name|vp
operator|->
name|v_type
operator|=
name|VBAD
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|vp
operator|->
name|v_type
operator|=
name|VDIR
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|vp
operator|->
name|v_type
operator|=
name|VREG
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|vp
operator|->
name|v_type
operator|=
name|VBLK
expr_stmt|;
break|break;
case|case
literal|7
case|:
name|vp
operator|->
name|v_type
operator|=
name|VCHR
expr_stmt|;
break|break;
case|case
literal|9
case|:
name|vp
operator|->
name|v_type
operator|=
name|VFIFO
expr_stmt|;
name|vp
operator|->
name|v_op
operator|=
operator|&
name|udf_fifoops
expr_stmt|;
break|break;
case|case
literal|10
case|:
name|vp
operator|->
name|v_type
operator|=
name|VSOCK
expr_stmt|;
break|break;
case|case
literal|12
case|:
name|vp
operator|->
name|v_type
operator|=
name|VLNK
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|VFIFO
condition|)
name|VN_LOCK_ASHARE
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ino
operator|==
name|udf_getid
argument_list|(
operator|&
name|udfmp
operator|->
name|root_icb
argument_list|)
condition|)
name|vp
operator|->
name|v_vflag
operator||=
name|VV_ROOT
expr_stmt|;
operator|*
name|vpp
operator|=
name|vp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|udf_fhtovp
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|struct
name|fid
modifier|*
name|fhp
parameter_list|,
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
parameter_list|)
block|{
name|struct
name|ifid
modifier|*
name|ifhp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|nvp
decl_stmt|;
name|struct
name|udf_node
modifier|*
name|np
decl_stmt|;
name|off_t
name|fsize
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ifhp
operator|=
operator|(
expr|struct
name|ifid
operator|*
operator|)
name|fhp
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|VFS_VGET
argument_list|(
name|mp
argument_list|,
name|ifhp
operator|->
name|ifid_ino
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
operator|&
name|nvp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|vpp
operator|=
name|NULLVP
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|np
operator|=
name|VTON
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
name|fsize
operator|=
name|le64toh
argument_list|(
name|np
operator|->
name|fentry
operator|->
name|inf_len
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|nvp
expr_stmt|;
name|vnode_create_vobject
argument_list|(
operator|*
name|vpp
argument_list|,
name|fsize
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|udf_find_partmaps
parameter_list|(
name|struct
name|udf_mnt
modifier|*
name|udfmp
parameter_list|,
name|struct
name|logvol_desc
modifier|*
name|lvd
parameter_list|)
block|{
name|struct
name|part_map_spare
modifier|*
name|pms
decl_stmt|;
name|struct
name|regid
modifier|*
name|pmap_id
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|unsigned
name|char
name|regid_id
index|[
name|UDF_REGID_ID_SIZE
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|k
decl_stmt|,
name|ptype
decl_stmt|,
name|psize
decl_stmt|,
name|error
decl_stmt|;
name|uint8_t
modifier|*
name|pmap
init|=
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|lvd
operator|->
name|maps
index|[
literal|0
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|le32toh
argument_list|(
name|lvd
operator|->
name|n_pm
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|ptype
operator|=
name|pmap
index|[
literal|0
index|]
expr_stmt|;
name|psize
operator|=
name|pmap
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|ptype
operator|!=
literal|1
operator|)
operator|&&
operator|(
name|ptype
operator|!=
literal|2
operator|)
operator|)
operator|||
operator|(
operator|(
name|psize
operator|!=
name|UDF_PMAP_TYPE1_SIZE
operator|)
operator|&&
operator|(
name|psize
operator|!=
name|UDF_PMAP_TYPE2_SIZE
operator|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"Invalid partition map found\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|ptype
operator|==
literal|1
condition|)
block|{
comment|/* Type 1 map.  We don't care */
name|pmap
operator|+=
name|UDF_PMAP_TYPE1_SIZE
expr_stmt|;
continue|continue;
block|}
comment|/* Type 2 map.  Gotta find out the details */
name|pmap_id
operator|=
operator|(
expr|struct
name|regid
operator|*
operator|)
operator|&
name|pmap
index|[
literal|4
index|]
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|regid_id
index|[
literal|0
index|]
argument_list|,
name|UDF_REGID_ID_SIZE
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|pmap_id
operator|->
name|id
index|[
literal|0
index|]
argument_list|,
operator|&
name|regid_id
index|[
literal|0
index|]
argument_list|,
name|UDF_REGID_ID_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
operator|&
name|regid_id
index|[
literal|0
index|]
argument_list|,
literal|"*UDF Sparable Partition"
argument_list|,
name|UDF_REGID_ID_SIZE
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Unsupported partition map: %s\n"
argument_list|,
operator|&
name|regid_id
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|pms
operator|=
operator|(
expr|struct
name|part_map_spare
operator|*
operator|)
name|pmap
expr_stmt|;
name|pmap
operator|+=
name|UDF_PMAP_TYPE2_SIZE
expr_stmt|;
name|udfmp
operator|->
name|s_table
operator|=
name|malloc
argument_list|(
name|le32toh
argument_list|(
name|pms
operator|->
name|st_size
argument_list|)
argument_list|,
name|M_UDFMOUNT
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|udfmp
operator|->
name|s_table
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* Calculate the number of sectors per packet. */
comment|/* XXX Logical or physical? */
name|udfmp
operator|->
name|p_sectors
operator|=
name|le16toh
argument_list|(
name|pms
operator|->
name|packet_len
argument_list|)
operator|/
name|udfmp
operator|->
name|bsize
expr_stmt|;
comment|/* 		 * XXX If reading the first Sparing Table fails, should look 		 * for another table. 		 */
if|if
condition|(
operator|(
name|error
operator|=
name|udf_readlblks
argument_list|(
name|udfmp
argument_list|,
name|le32toh
argument_list|(
name|pms
operator|->
name|st_loc
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|le32toh
argument_list|(
name|pms
operator|->
name|st_size
argument_list|)
argument_list|,
operator|&
name|bp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Failed to read Sparing Table at sector %d\n"
argument_list|,
name|le32toh
argument_list|(
name|pms
operator|->
name|st_loc
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|udfmp
operator|->
name|s_table
argument_list|,
name|M_UDFMOUNT
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|bcopy
argument_list|(
name|bp
operator|->
name|b_data
argument_list|,
name|udfmp
operator|->
name|s_table
argument_list|,
name|le32toh
argument_list|(
name|pms
operator|->
name|st_size
argument_list|)
argument_list|)
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|udf_checktag
argument_list|(
operator|&
name|udfmp
operator|->
name|s_table
operator|->
name|tag
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Invalid sparing table found\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|udfmp
operator|->
name|s_table
argument_list|,
name|M_UDFMOUNT
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* See how many valid entries there are here.  The list is 		 * supposed to be sorted. 0xfffffff0 and higher are not valid 		 */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|le16toh
argument_list|(
name|udfmp
operator|->
name|s_table
operator|->
name|rt_l
argument_list|)
condition|;
name|k
operator|++
control|)
block|{
name|udfmp
operator|->
name|s_table_entries
operator|=
name|k
expr_stmt|;
if|if
condition|(
name|le32toh
argument_list|(
name|udfmp
operator|->
name|s_table
operator|->
name|entries
index|[
name|k
index|]
operator|.
name|org
argument_list|)
operator|>=
literal|0xfffffff0
condition|)
break|break;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

