begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Various routines from the OSTA 2.01 specs.  Copyrights are included with  * each code segment.  Slight whitespace modifications have been made for  * formatting purposes.  Typos/bugs have been fixed.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<fs/udf/osta.h>
end_include

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/***********************************************************************  * OSTA compliant Unicode compression, uncompression routines.  * Copyright 1995 Micro Design International, Inc.  * Written by Jason M. Rinn.  * Micro Design International gives permission for the free use of the  * following source code.  */
end_comment

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_comment
comment|/***********************************************************************  * Takes an OSTA CS0 compressed unicode name, and converts  * it to Unicode.  * The Unicode output will be in the byte order  * that the local compiler uses for 16-bit values.  * NOTE: This routine only performs error checking on the compID.  * It is up to the user to ensure that the unicode buffer is large  * enough, and that the compressed unicode name is correct.  *  * RETURN VALUE  *  * The number of unicode characters which were uncompressed.  * A -1 is returned if the compression ID is invalid.  */
end_comment

begin_function
name|int
name|udf_UncompressUnicode
parameter_list|(
name|int
name|numberOfBytes
parameter_list|,
comment|/* (Input) number of bytes read from media. */
name|byte
modifier|*
name|UDFCompressed
parameter_list|,
comment|/* (Input) bytes read from media. */
name|unicode_t
modifier|*
name|unicode
parameter_list|)
comment|/* (Output) uncompressed unicode characters. */
block|{
name|unsigned
name|int
name|compID
decl_stmt|;
name|int
name|returnValue
decl_stmt|,
name|unicodeIndex
decl_stmt|,
name|byteIndex
decl_stmt|;
comment|/* Use UDFCompressed to store current byte being read. */
name|compID
operator|=
name|UDFCompressed
index|[
literal|0
index|]
expr_stmt|;
comment|/* First check for valid compID. */
if|if
condition|(
name|compID
operator|!=
literal|8
operator|&&
name|compID
operator|!=
literal|16
condition|)
block|{
name|returnValue
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|unicodeIndex
operator|=
literal|0
expr_stmt|;
name|byteIndex
operator|=
literal|1
expr_stmt|;
comment|/* Loop through all the bytes. */
while|while
condition|(
name|byteIndex
operator|<
name|numberOfBytes
condition|)
block|{
if|if
condition|(
name|compID
operator|==
literal|16
condition|)
block|{
comment|/* Move the first byte to the high bits of the 				 * unicode char. 				 */
name|unicode
index|[
name|unicodeIndex
index|]
operator|=
name|UDFCompressed
index|[
name|byteIndex
operator|++
index|]
operator|<<
literal|8
expr_stmt|;
block|}
else|else
block|{
name|unicode
index|[
name|unicodeIndex
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|byteIndex
operator|<
name|numberOfBytes
condition|)
block|{
comment|/*Then the next byte to the low bits. */
name|unicode
index|[
name|unicodeIndex
index|]
operator||=
name|UDFCompressed
index|[
name|byteIndex
operator|++
index|]
expr_stmt|;
block|}
name|unicodeIndex
operator|++
expr_stmt|;
block|}
name|returnValue
operator|=
name|unicodeIndex
expr_stmt|;
block|}
return|return
operator|(
name|returnValue
operator|)
return|;
block|}
end_function

begin_comment
comment|/***********************************************************************  * DESCRIPTION:  * Takes a string of unicode wide characters and returns an OSTA CS0  * compressed unicode string. The unicode MUST be in the byte order of  * the compiler in order to obtain correct results. Returns an error  * if the compression ID is invalid.  *  * NOTE: This routine assumes the implementation already knows, by  * the local environment, how many bits are appropriate and  * therefore does no checking to test if the input characters fit  * into that number of bits or not.  *  * RETURN VALUE  *  * The total number of bytes in the compressed OSTA CS0 string,  * including the compression ID.  * A -1 is returned if the compression ID is invalid.  */
end_comment

begin_function
name|int
name|udf_CompressUnicode
parameter_list|(
name|int
name|numberOfChars
parameter_list|,
comment|/* (Input) number of unicode characters. */
name|int
name|compID
parameter_list|,
comment|/* (Input) compression ID to be used. */
name|unicode_t
modifier|*
name|unicode
parameter_list|,
comment|/* (Input) unicode characters to compress. */
name|byte
modifier|*
name|UDFCompressed
parameter_list|)
comment|/* (Output) compressed string, as bytes. */
block|{
name|int
name|byteIndex
decl_stmt|,
name|unicodeIndex
decl_stmt|;
if|if
condition|(
name|compID
operator|!=
literal|8
operator|&&
name|compID
operator|!=
literal|16
condition|)
block|{
name|byteIndex
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Unsupported compression ID ! */
block|}
else|else
block|{
comment|/* Place compression code in first byte. */
name|UDFCompressed
index|[
literal|0
index|]
operator|=
name|compID
expr_stmt|;
name|byteIndex
operator|=
literal|1
expr_stmt|;
name|unicodeIndex
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|unicodeIndex
operator|<
name|numberOfChars
condition|)
block|{
if|if
condition|(
name|compID
operator|==
literal|16
condition|)
block|{
comment|/* First, place the high bits of the char 				 * into the byte stream. 				 */
name|UDFCompressed
index|[
name|byteIndex
operator|++
index|]
operator|=
operator|(
name|unicode
index|[
name|unicodeIndex
index|]
operator|&
literal|0xFF00
operator|)
operator|>>
literal|8
expr_stmt|;
block|}
comment|/*Then place the low bits into the stream. */
name|UDFCompressed
index|[
name|byteIndex
operator|++
index|]
operator|=
name|unicode
index|[
name|unicodeIndex
index|]
operator|&
literal|0x00FF
expr_stmt|;
name|unicodeIndex
operator|++
expr_stmt|;
block|}
block|}
return|return
operator|(
name|byteIndex
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  * CRC 010041  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|short
name|crc_table
index|[
literal|256
index|]
init|=
block|{
literal|0x0000
block|,
literal|0x1021
block|,
literal|0x2042
block|,
literal|0x3063
block|,
literal|0x4084
block|,
literal|0x50A5
block|,
literal|0x60C6
block|,
literal|0x70E7
block|,
literal|0x8108
block|,
literal|0x9129
block|,
literal|0xA14A
block|,
literal|0xB16B
block|,
literal|0xC18C
block|,
literal|0xD1AD
block|,
literal|0xE1CE
block|,
literal|0xF1EF
block|,
literal|0x1231
block|,
literal|0x0210
block|,
literal|0x3273
block|,
literal|0x2252
block|,
literal|0x52B5
block|,
literal|0x4294
block|,
literal|0x72F7
block|,
literal|0x62D6
block|,
literal|0x9339
block|,
literal|0x8318
block|,
literal|0xB37B
block|,
literal|0xA35A
block|,
literal|0xD3BD
block|,
literal|0xC39C
block|,
literal|0xF3FF
block|,
literal|0xE3DE
block|,
literal|0x2462
block|,
literal|0x3443
block|,
literal|0x0420
block|,
literal|0x1401
block|,
literal|0x64E6
block|,
literal|0x74C7
block|,
literal|0x44A4
block|,
literal|0x5485
block|,
literal|0xA56A
block|,
literal|0xB54B
block|,
literal|0x8528
block|,
literal|0x9509
block|,
literal|0xE5EE
block|,
literal|0xF5CF
block|,
literal|0xC5AC
block|,
literal|0xD58D
block|,
literal|0x3653
block|,
literal|0x2672
block|,
literal|0x1611
block|,
literal|0x0630
block|,
literal|0x76D7
block|,
literal|0x66F6
block|,
literal|0x5695
block|,
literal|0x46B4
block|,
literal|0xB75B
block|,
literal|0xA77A
block|,
literal|0x9719
block|,
literal|0x8738
block|,
literal|0xF7DF
block|,
literal|0xE7FE
block|,
literal|0xD79D
block|,
literal|0xC7BC
block|,
literal|0x48C4
block|,
literal|0x58E5
block|,
literal|0x6886
block|,
literal|0x78A7
block|,
literal|0x0840
block|,
literal|0x1861
block|,
literal|0x2802
block|,
literal|0x3823
block|,
literal|0xC9CC
block|,
literal|0xD9ED
block|,
literal|0xE98E
block|,
literal|0xF9AF
block|,
literal|0x8948
block|,
literal|0x9969
block|,
literal|0xA90A
block|,
literal|0xB92B
block|,
literal|0x5AF5
block|,
literal|0x4AD4
block|,
literal|0x7AB7
block|,
literal|0x6A96
block|,
literal|0x1A71
block|,
literal|0x0A50
block|,
literal|0x3A33
block|,
literal|0x2A12
block|,
literal|0xDBFD
block|,
literal|0xCBDC
block|,
literal|0xFBBF
block|,
literal|0xEB9E
block|,
literal|0x9B79
block|,
literal|0x8B58
block|,
literal|0xBB3B
block|,
literal|0xAB1A
block|,
literal|0x6CA6
block|,
literal|0x7C87
block|,
literal|0x4CE4
block|,
literal|0x5CC5
block|,
literal|0x2C22
block|,
literal|0x3C03
block|,
literal|0x0C60
block|,
literal|0x1C41
block|,
literal|0xEDAE
block|,
literal|0xFD8F
block|,
literal|0xCDEC
block|,
literal|0xDDCD
block|,
literal|0xAD2A
block|,
literal|0xBD0B
block|,
literal|0x8D68
block|,
literal|0x9D49
block|,
literal|0x7E97
block|,
literal|0x6EB6
block|,
literal|0x5ED5
block|,
literal|0x4EF4
block|,
literal|0x3E13
block|,
literal|0x2E32
block|,
literal|0x1E51
block|,
literal|0x0E70
block|,
literal|0xFF9F
block|,
literal|0xEFBE
block|,
literal|0xDFDD
block|,
literal|0xCFFC
block|,
literal|0xBF1B
block|,
literal|0xAF3A
block|,
literal|0x9F59
block|,
literal|0x8F78
block|,
literal|0x9188
block|,
literal|0x81A9
block|,
literal|0xB1CA
block|,
literal|0xA1EB
block|,
literal|0xD10C
block|,
literal|0xC12D
block|,
literal|0xF14E
block|,
literal|0xE16F
block|,
literal|0x1080
block|,
literal|0x00A1
block|,
literal|0x30C2
block|,
literal|0x20E3
block|,
literal|0x5004
block|,
literal|0x4025
block|,
literal|0x7046
block|,
literal|0x6067
block|,
literal|0x83B9
block|,
literal|0x9398
block|,
literal|0xA3FB
block|,
literal|0xB3DA
block|,
literal|0xC33D
block|,
literal|0xD31C
block|,
literal|0xE37F
block|,
literal|0xF35E
block|,
literal|0x02B1
block|,
literal|0x1290
block|,
literal|0x22F3
block|,
literal|0x32D2
block|,
literal|0x4235
block|,
literal|0x5214
block|,
literal|0x6277
block|,
literal|0x7256
block|,
literal|0xB5EA
block|,
literal|0xA5CB
block|,
literal|0x95A8
block|,
literal|0x8589
block|,
literal|0xF56E
block|,
literal|0xE54F
block|,
literal|0xD52C
block|,
literal|0xC50D
block|,
literal|0x34E2
block|,
literal|0x24C3
block|,
literal|0x14A0
block|,
literal|0x0481
block|,
literal|0x7466
block|,
literal|0x6447
block|,
literal|0x5424
block|,
literal|0x4405
block|,
literal|0xA7DB
block|,
literal|0xB7FA
block|,
literal|0x8799
block|,
literal|0x97B8
block|,
literal|0xE75F
block|,
literal|0xF77E
block|,
literal|0xC71D
block|,
literal|0xD73C
block|,
literal|0x26D3
block|,
literal|0x36F2
block|,
literal|0x0691
block|,
literal|0x16B0
block|,
literal|0x6657
block|,
literal|0x7676
block|,
literal|0x4615
block|,
literal|0x5634
block|,
literal|0xD94C
block|,
literal|0xC96D
block|,
literal|0xF90E
block|,
literal|0xE92F
block|,
literal|0x99C8
block|,
literal|0x89E9
block|,
literal|0xB98A
block|,
literal|0xA9AB
block|,
literal|0x5844
block|,
literal|0x4865
block|,
literal|0x7806
block|,
literal|0x6827
block|,
literal|0x18C0
block|,
literal|0x08E1
block|,
literal|0x3882
block|,
literal|0x28A3
block|,
literal|0xCB7D
block|,
literal|0xDB5C
block|,
literal|0xEB3F
block|,
literal|0xFB1E
block|,
literal|0x8BF9
block|,
literal|0x9BD8
block|,
literal|0xABBB
block|,
literal|0xBB9A
block|,
literal|0x4A75
block|,
literal|0x5A54
block|,
literal|0x6A37
block|,
literal|0x7A16
block|,
literal|0x0AF1
block|,
literal|0x1AD0
block|,
literal|0x2AB3
block|,
literal|0x3A92
block|,
literal|0xFD2E
block|,
literal|0xED0F
block|,
literal|0xDD6C
block|,
literal|0xCD4D
block|,
literal|0xBDAA
block|,
literal|0xAD8B
block|,
literal|0x9DE8
block|,
literal|0x8DC9
block|,
literal|0x7C26
block|,
literal|0x6C07
block|,
literal|0x5C64
block|,
literal|0x4C45
block|,
literal|0x3CA2
block|,
literal|0x2C83
block|,
literal|0x1CE0
block|,
literal|0x0CC1
block|,
literal|0xEF1F
block|,
literal|0xFF3E
block|,
literal|0xCF5D
block|,
literal|0xDF7C
block|,
literal|0xAF9B
block|,
literal|0xBFBA
block|,
literal|0x8FD9
block|,
literal|0x9FF8
block|,
literal|0x6E17
block|,
literal|0x7E36
block|,
literal|0x4E55
block|,
literal|0x5E74
block|,
literal|0x2E93
block|,
literal|0x3EB2
block|,
literal|0x0ED1
block|,
literal|0x1EF0
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|unsigned
name|short
name|udf_cksum
parameter_list|(
name|s
parameter_list|,
name|n
parameter_list|)
name|unsigned
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
name|unsigned
name|short
name|crc
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|n
operator|--
operator|>
literal|0
condition|)
name|crc
operator|=
name|crc_table
index|[
operator|(
name|crc
operator|>>
literal|8
operator|^
operator|*
name|s
operator|++
operator|)
operator|&
literal|0xff
index|]
operator|^
operator|(
name|crc
operator|<<
literal|8
operator|)
expr_stmt|;
return|return
name|crc
return|;
block|}
end_function

begin_comment
comment|/* UNICODE Checksum */
end_comment

begin_function
name|unsigned
name|short
name|udf_unicode_cksum
parameter_list|(
name|s
parameter_list|,
name|n
parameter_list|)
name|unsigned
name|short
modifier|*
name|s
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
name|unsigned
name|short
name|crc
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|n
operator|--
operator|>
literal|0
condition|)
block|{
comment|/* Take high order byte first--corresponds to a big endian 		 * byte stream. 		 */
name|crc
operator|=
name|crc_table
index|[
operator|(
name|crc
operator|>>
literal|8
operator|^
operator|(
operator|*
name|s
operator|>>
literal|8
operator|)
operator|)
operator|&
literal|0xff
index|]
operator|^
operator|(
name|crc
operator|<<
literal|8
operator|)
expr_stmt|;
name|crc
operator|=
name|crc_table
index|[
operator|(
name|crc
operator|>>
literal|8
operator|^
operator|(
operator|*
name|s
operator|++
operator|&
literal|0xff
operator|)
operator|)
operator|&
literal|0xff
index|]
operator|^
operator|(
name|crc
operator|<<
literal|8
operator|)
expr_stmt|;
block|}
return|return
name|crc
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|MAIN
end_ifdef

begin_decl_stmt
name|unsigned
name|char
name|bytes
index|[]
init|=
block|{
literal|0x70
block|,
literal|0x6A
block|,
literal|0x77
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|()
block|{
name|unsigned
name|short
name|x
decl_stmt|;
name|x
operator|=
name|cksum
argument_list|(
name|bytes
argument_list|,
sizeof|sizeof
name|bytes
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"checksum: calculated=%4.4x, correct=%4.4x\en"
argument_list|,
name|x
argument_list|,
literal|0x3299
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*****************************************************************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NEEDS_ISPRINT
end_ifdef

begin_comment
comment|/***********************************************************************  * OSTA UDF compliant file name translation routine for OS/2,  * Windows 95, Windows NT, Macintosh and UNIX.  * Copyright 1995 Micro Design International, Inc.  * Written by Jason M. Rinn.  * Micro Design International gives permission for the free use of the  * following source code.  */
end_comment

begin_comment
comment|/***********************************************************************  * To use these routines with different operating systems.  *  * OS/2  * Define OS2  * Define MAXLEN = 254  *  * Windows 95  * Define WIN_95  * Define MAXLEN = 255  *  * Windows NT  * Define WIN_NT  * Define MAXLEN = 255  *  * Macintosh:  * Define MAC.  * Define MAXLEN = 31.  *  * UNIX  * Define UNIX.  * Define MAXLEN as specified by unix version.  */
end_comment

begin_define
define|#
directive|define
name|ILLEGAL_CHAR_MARK
value|0x005F
end_define

begin_define
define|#
directive|define
name|CRC_MARK
value|0x0023
end_define

begin_define
define|#
directive|define
name|EXT_SIZE
value|5
end_define

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_define
define|#
directive|define
name|PERIOD
value|0x002E
end_define

begin_define
define|#
directive|define
name|SPACE
value|0x0020
end_define

begin_comment
comment|/*** PROTOTYPES ***/
end_comment

begin_function_decl
name|int
name|IsIllegal
parameter_list|(
name|unicode_t
name|ch
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Define a function or macro which determines if a Unicode character is  * printable under your implementation.  */
end_comment

begin_function_decl
name|int
name|UnicodeIsPrint
parameter_list|(
name|unicode_t
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/***********************************************************************  * Translates a long file name to one using a MAXLEN and an illegal  * char set in accord with the OSTA requirements. Assumes the name has  * already been translated to Unicode.  *  * RETURN VALUE  *  * Number of unicode characters in translated name.  */
end_comment

begin_function
name|int
name|UDFTransName
parameter_list|(
name|unicode_t
modifier|*
name|newName
parameter_list|,
comment|/* (Output)Translated name. Must be of length 				 * MAXLEN */
name|unicode_t
modifier|*
name|udfName
parameter_list|,
comment|/* (Input) Name from UDF volume.*/
name|int
name|udfLen
parameter_list|)
comment|/* (Input) Length of UDF Name. */
block|{
name|int
name|index
decl_stmt|,
name|newIndex
init|=
literal|0
decl_stmt|,
name|needsCRC
init|=
name|FALSE
decl_stmt|;
name|int
name|extIndex
init|=
literal|0
decl_stmt|,
name|newExtIndex
init|=
literal|0
decl_stmt|,
name|hasExt
init|=
name|FALSE
decl_stmt|;
if|#
directive|if
name|defined
name|OS2
operator|||
name|defined
name|WIN_95
operator|||
name|defined
name|WIN_NT
name|int
name|trailIndex
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|unsigned
name|short
name|valueCRC
decl_stmt|;
name|unicode_t
name|current
decl_stmt|;
specifier|const
name|char
name|hexChar
index|[]
init|=
literal|"0123456789ABCDEF"
decl_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|udfLen
condition|;
name|index
operator|++
control|)
block|{
name|current
operator|=
name|udfName
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
name|IsIllegal
argument_list|(
name|current
argument_list|)
operator|||
operator|!
name|UnicodeIsPrint
argument_list|(
name|current
argument_list|)
condition|)
block|{
name|needsCRC
operator|=
name|TRUE
expr_stmt|;
comment|/* Replace Illegal and non-displayable chars with 			 * underscore. 			 */
name|current
operator|=
name|ILLEGAL_CHAR_MARK
expr_stmt|;
comment|/* Skip any other illegal or non-displayable 			 * characters. 			 */
while|while
condition|(
name|index
operator|+
literal|1
operator|<
name|udfLen
operator|&&
operator|(
name|IsIllegal
argument_list|(
name|udfName
index|[
name|index
operator|+
literal|1
index|]
argument_list|)
operator|||
operator|!
name|UnicodeIsPrint
argument_list|(
name|udfName
index|[
name|index
operator|+
literal|1
index|]
argument_list|)
operator|)
condition|)
block|{
name|index
operator|++
expr_stmt|;
block|}
block|}
comment|/* Record position of extension, if one is found. */
if|if
condition|(
name|current
operator|==
name|PERIOD
operator|&&
operator|(
name|udfLen
operator|-
name|index
operator|-
literal|1
operator|)
operator|<=
name|EXT_SIZE
condition|)
block|{
if|if
condition|(
name|udfLen
operator|==
name|index
operator|+
literal|1
condition|)
block|{
comment|/* A trailing period is NOT an extension. */
name|hasExt
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|hasExt
operator|=
name|TRUE
expr_stmt|;
name|extIndex
operator|=
name|index
expr_stmt|;
name|newExtIndex
operator|=
name|newIndex
expr_stmt|;
block|}
block|}
if|#
directive|if
name|defined
name|OS2
operator|||
name|defined
name|WIN_95
operator|||
name|defined
name|WIN_NT
comment|/* Record position of last char which is NOT period or space. */
elseif|else
if|if
condition|(
name|current
operator|!=
name|PERIOD
operator|&&
name|current
operator|!=
name|SPACE
condition|)
block|{
name|trailIndex
operator|=
name|newIndex
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|newIndex
operator|<
name|MAXLEN
condition|)
block|{
name|newName
index|[
name|newIndex
operator|++
index|]
operator|=
name|current
expr_stmt|;
block|}
else|else
block|{
name|needsCRC
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|#
directive|if
name|defined
name|OS2
operator|||
name|defined
name|WIN_95
operator|||
name|defined
name|WIN_NT
comment|/* For OS2, 95& NT, truncate any trailing periods and\or spaces. */
if|if
condition|(
name|trailIndex
operator|!=
name|newIndex
operator|-
literal|1
condition|)
block|{
name|newIndex
operator|=
name|trailIndex
operator|+
literal|1
expr_stmt|;
name|needsCRC
operator|=
name|TRUE
expr_stmt|;
name|hasExt
operator|=
name|FALSE
expr_stmt|;
comment|/* Trailing period does not make an 				 * extension. */
block|}
endif|#
directive|endif
if|if
condition|(
name|needsCRC
condition|)
block|{
name|unicode_t
name|ext
index|[
name|EXT_SIZE
index|]
decl_stmt|;
name|int
name|localExtIndex
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|hasExt
condition|)
block|{
name|int
name|maxFilenameLen
decl_stmt|;
comment|/* Translate extension, and store it in ext. */
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|EXT_SIZE
operator|&&
name|extIndex
operator|+
name|index
operator|+
literal|1
operator|<
name|udfLen
condition|;
name|index
operator|++
control|)
block|{
name|current
operator|=
name|udfName
index|[
name|extIndex
operator|+
name|index
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|IsIllegal
argument_list|(
name|current
argument_list|)
operator|||
operator|!
name|UnicodeIsPrint
argument_list|(
name|current
argument_list|)
condition|)
block|{
name|needsCRC
operator|=
literal|1
expr_stmt|;
comment|/* Replace Illegal and non-displayable 					 * chars with underscore. 					 */
name|current
operator|=
name|ILLEGAL_CHAR_MARK
expr_stmt|;
comment|/* Skip any other illegal or 					 * non-displayable characters. 					 */
while|while
condition|(
name|index
operator|+
literal|1
operator|<
name|EXT_SIZE
operator|&&
operator|(
name|IsIllegal
argument_list|(
name|udfName
index|[
name|extIndex
operator|+
name|index
operator|+
literal|2
index|]
argument_list|)
operator|||
operator|!
name|isprint
argument_list|(
name|udfName
index|[
name|extIndex
operator|+
name|index
operator|+
literal|2
index|]
argument_list|)
operator|)
condition|)
block|{
name|index
operator|++
expr_stmt|;
block|}
block|}
name|ext
index|[
name|localExtIndex
operator|++
index|]
operator|=
name|current
expr_stmt|;
block|}
comment|/* Truncate filename to leave room for extension and 			 * CRC. 			 */
name|maxFilenameLen
operator|=
operator|(
operator|(
name|MAXLEN
operator|-
literal|5
operator|)
operator|-
name|localExtIndex
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|newIndex
operator|>
name|maxFilenameLen
condition|)
block|{
name|newIndex
operator|=
name|maxFilenameLen
expr_stmt|;
block|}
else|else
block|{
name|newIndex
operator|=
name|newExtIndex
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|newIndex
operator|>
name|MAXLEN
operator|-
literal|5
condition|)
block|{
comment|/*If no extension, make sure to leave room for CRC. */
name|newIndex
operator|=
name|MAXLEN
operator|-
literal|5
expr_stmt|;
block|}
name|newName
index|[
name|newIndex
operator|++
index|]
operator|=
name|CRC_MARK
expr_stmt|;
comment|/* Add mark for CRC. */
comment|/*Calculate CRC from original filename from FileIdentifier. */
name|valueCRC
operator|=
name|udf_unicode_cksum
argument_list|(
name|udfName
argument_list|,
name|udfLen
argument_list|)
expr_stmt|;
comment|/* Convert 16-bits of CRC to hex characters. */
name|newName
index|[
name|newIndex
operator|++
index|]
operator|=
name|hexChar
index|[
operator|(
name|valueCRC
operator|&
literal|0xf000
operator|)
operator|>>
literal|12
index|]
expr_stmt|;
name|newName
index|[
name|newIndex
operator|++
index|]
operator|=
name|hexChar
index|[
operator|(
name|valueCRC
operator|&
literal|0x0f00
operator|)
operator|>>
literal|8
index|]
expr_stmt|;
name|newName
index|[
name|newIndex
operator|++
index|]
operator|=
name|hexChar
index|[
operator|(
name|valueCRC
operator|&
literal|0x00f0
operator|)
operator|>>
literal|4
index|]
expr_stmt|;
name|newName
index|[
name|newIndex
operator|++
index|]
operator|=
name|hexChar
index|[
operator|(
name|valueCRC
operator|&
literal|0x000f
operator|)
index|]
expr_stmt|;
comment|/* Place a translated extension at end, if found. */
if|if
condition|(
name|hasExt
condition|)
block|{
name|newName
index|[
name|newIndex
operator|++
index|]
operator|=
name|PERIOD
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|localExtIndex
condition|;
name|index
operator|++
control|)
block|{
name|newName
index|[
name|newIndex
operator|++
index|]
operator|=
name|ext
index|[
name|index
index|]
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|newIndex
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
name|OS2
operator|||
name|defined
name|WIN_95
operator|||
name|defined
name|WIN_NT
end_if

begin_comment
comment|/***********************************************************************  * Decides if a Unicode character matches one of a list  * of ASCII characters.  * Used by OS2 version of IsIllegal for readability, since all of the  * illegal characters above 0x0020 are in the ASCII subset of Unicode.  * Works very similarly to the standard C function strchr().  *  * RETURN VALUE  *  * Non-zero if the Unicode character is in the given ASCII string.  */
end_comment

begin_function
name|int
name|UnicodeInString
parameter_list|(
name|unsigned
name|char
modifier|*
name|string
parameter_list|,
comment|/* (Input) String to search through. */
name|unicode_t
name|ch
parameter_list|)
comment|/* (Input) Unicode char to search for. */
block|{
name|int
name|found
init|=
name|FALSE
decl_stmt|;
while|while
condition|(
operator|*
name|string
operator|!=
literal|'\0'
operator|&&
name|found
operator|==
name|FALSE
condition|)
block|{
comment|/* These types should compare, since both are unsigned 		 * numbers. */
if|if
condition|(
operator|*
name|string
operator|==
name|ch
condition|)
block|{
name|found
operator|=
name|TRUE
expr_stmt|;
block|}
name|string
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|found
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OS2 */
end_comment

begin_comment
comment|/***********************************************************************  * Decides whether the given character is illegal for a given OS.  *  * RETURN VALUE  *  * Non-zero if char is illegal.  */
end_comment

begin_function
name|int
name|IsIllegal
parameter_list|(
name|unicode_t
name|ch
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|MAC
comment|/* Only illegal character on the MAC is the colon. */
if|if
condition|(
name|ch
operator|==
literal|0x003A
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
elif|#
directive|elif
name|defined
name|UNIX
comment|/* Illegal UNIX characters are NULL and slash. */
if|if
condition|(
name|ch
operator|==
literal|0x0000
operator|||
name|ch
operator|==
literal|0x002F
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
elif|#
directive|elif
name|defined
name|OS2
operator|||
name|defined
name|WIN_95
operator|||
name|defined
name|WIN_NT
comment|/* Illegal char's for OS/2 according to WARP toolkit. */
if|if
condition|(
name|ch
operator|<
literal|0x0020
operator|||
name|UnicodeInString
argument_list|(
literal|"\\/:*?\"<>|"
argument_list|,
name|ch
argument_list|)
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

