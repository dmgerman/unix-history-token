begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: tmpfs_vfsops.c,v 1.10 2005/12/11 12:24:29 christos Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright (c) 2005 The NetBSD Foundation, Inc.  * All rights reserved.  *  * This code is derived from software contributed to The NetBSD Foundation  * by Julio M. Merino Vidal, developed as part of Google's Summer of Code  * 2005 program.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *        This product includes software developed by the NetBSD  *        Foundation, Inc. and its contributors.  * 4. Neither the name of The NetBSD Foundation nor the names of its  *    contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Efficient memory file system.  *  * tmpfs is a file system that uses NetBSD's virtual memory sub-system  * (the well-known UVM) to store file data and metadata in an efficient  * way.  This means that it does not follow the structure of an on-disk  * file system because it simply does not need to.  Instead, it uses  * memory-specific data structures and algorithms to automatically  * allocate and release resources.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<fs/tmpfs/tmpfs.h>
end_include

begin_comment
comment|/*  * Default permission for root node  */
end_comment

begin_define
define|#
directive|define
name|TMPFS_DEFAULT_ROOT_MODE
value|(S_IRWXU|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH)
end_define

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_TMPFSMNT
argument_list|,
literal|"tmpfs mount"
argument_list|,
literal|"tmpfs mount structures"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_TMPFSNAME
argument_list|,
literal|"tmpfs name"
argument_list|,
literal|"tmpfs file names"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment

begin_function_decl
specifier|static
name|int
name|tmpfs_mount
parameter_list|(
name|struct
name|mount
modifier|*
parameter_list|,
name|struct
name|thread
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tmpfs_unmount
parameter_list|(
name|struct
name|mount
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|thread
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tmpfs_root
parameter_list|(
name|struct
name|mount
modifier|*
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|vnode
modifier|*
modifier|*
parameter_list|,
name|struct
name|thread
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tmpfs_fhtovp
parameter_list|(
name|struct
name|mount
modifier|*
parameter_list|,
name|struct
name|fid
modifier|*
parameter_list|,
name|struct
name|vnode
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tmpfs_statfs
parameter_list|(
name|struct
name|mount
modifier|*
parameter_list|,
name|struct
name|statfs
modifier|*
parameter_list|,
name|struct
name|thread
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|tmpfs_opts
index|[]
init|=
block|{
literal|"from"
block|,
literal|"size"
block|,
literal|"inodes"
block|,
literal|"uid"
block|,
literal|"gid"
block|,
literal|"mode"
block|,
literal|"export"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment

begin_define
define|#
directive|define
name|SWI_MAXMIB
value|3
end_define

begin_function
specifier|static
name|u_int
name|get_swpgtotal
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|xswdev
name|xsd
decl_stmt|;
name|char
modifier|*
name|sname
init|=
literal|"vm.swap_info"
decl_stmt|;
name|int
name|soid
index|[
name|SWI_MAXMIB
index|]
decl_stmt|,
name|oid
index|[
literal|2
index|]
decl_stmt|;
name|u_int
name|unswdev
decl_stmt|,
name|total
decl_stmt|,
name|dmmax
decl_stmt|,
name|nswapdev
decl_stmt|;
name|size_t
name|mibi
decl_stmt|,
name|len
decl_stmt|;
name|total
operator|=
literal|0
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|dmmax
argument_list|)
expr_stmt|;
if|if
condition|(
name|kernel_sysctlbyname
argument_list|(
name|curthread
argument_list|,
literal|"vm.dmmax"
argument_list|,
operator|&
name|dmmax
argument_list|,
operator|&
name|len
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|total
return|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|nswapdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|kernel_sysctlbyname
argument_list|(
name|curthread
argument_list|,
literal|"vm.nswapdev"
argument_list|,
operator|&
name|nswapdev
argument_list|,
operator|&
name|len
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|total
return|;
name|mibi
operator|=
operator|(
name|SWI_MAXMIB
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|oid
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|oid
index|[
literal|1
index|]
operator|=
literal|3
expr_stmt|;
if|if
condition|(
name|kernel_sysctl
argument_list|(
name|curthread
argument_list|,
name|oid
argument_list|,
literal|2
argument_list|,
name|soid
argument_list|,
operator|&
name|mibi
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sname
argument_list|,
name|strlen
argument_list|(
name|sname
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|total
return|;
name|mibi
operator|=
operator|(
name|SWI_MAXMIB
operator|-
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|unswdev
operator|=
literal|0
init|;
name|unswdev
operator|<
name|nswapdev
condition|;
operator|++
name|unswdev
control|)
block|{
name|soid
index|[
name|mibi
index|]
operator|=
name|unswdev
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|xswdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|kernel_sysctl
argument_list|(
name|curthread
argument_list|,
name|soid
argument_list|,
name|mibi
operator|+
literal|1
argument_list|,
operator|&
name|xsd
argument_list|,
operator|&
name|len
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|total
return|;
if|if
condition|(
name|len
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|xswdev
argument_list|)
condition|)
name|total
operator|+=
operator|(
name|xsd
operator|.
name|xsw_nblks
operator|-
name|dmmax
operator|)
expr_stmt|;
block|}
comment|/* Not Reached */
return|return
name|total
return|;
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment

begin_function
specifier|static
name|int
name|tmpfs_node_ctor
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|int
name|size
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|tmpfs_node
modifier|*
name|node
init|=
operator|(
expr|struct
name|tmpfs_node
operator|*
operator|)
name|mem
decl_stmt|;
name|node
operator|->
name|tn_gen
operator|++
expr_stmt|;
name|node
operator|->
name|tn_size
operator|=
literal|0
expr_stmt|;
name|node
operator|->
name|tn_status
operator|=
literal|0
expr_stmt|;
name|node
operator|->
name|tn_flags
operator|=
literal|0
expr_stmt|;
name|node
operator|->
name|tn_links
operator|=
literal|0
expr_stmt|;
name|node
operator|->
name|tn_lockf
operator|=
name|NULL
expr_stmt|;
name|node
operator|->
name|tn_vnode
operator|=
name|NULL
expr_stmt|;
name|node
operator|->
name|tn_vpstate
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|tmpfs_node_dtor
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|int
name|size
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|tmpfs_node
modifier|*
name|node
init|=
operator|(
expr|struct
name|tmpfs_node
operator|*
operator|)
name|mem
decl_stmt|;
name|node
operator|->
name|tn_type
operator|=
name|VNON
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|tmpfs_node_init
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|tmpfs_node
modifier|*
name|node
init|=
operator|(
expr|struct
name|tmpfs_node
operator|*
operator|)
name|mem
decl_stmt|;
name|node
operator|->
name|tn_id
operator|=
literal|0
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|node
operator|->
name|tn_interlock
argument_list|,
literal|"tmpfs node interlock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|node
operator|->
name|tn_gen
operator|=
name|arc4random
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|tmpfs_node_fini
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|struct
name|tmpfs_node
modifier|*
name|node
init|=
operator|(
expr|struct
name|tmpfs_node
operator|*
operator|)
name|mem
decl_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|node
operator|->
name|tn_interlock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|tmpfs_mount
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|tmpfs_mount
modifier|*
name|tmp
decl_stmt|;
name|struct
name|tmpfs_node
modifier|*
name|root
decl_stmt|;
name|size_t
name|pages
decl_stmt|,
name|mem_size
decl_stmt|;
name|ino_t
name|nodes
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Size counters. */
name|ino_t
name|nodes_max
decl_stmt|;
name|off_t
name|size_max
decl_stmt|;
comment|/* Root node attributes. */
name|uid_t
name|root_uid
decl_stmt|;
name|gid_t
name|root_gid
decl_stmt|;
name|mode_t
name|root_mode
decl_stmt|;
name|struct
name|vattr
name|va
decl_stmt|;
if|if
condition|(
name|vfs_filteropt
argument_list|(
name|mp
operator|->
name|mnt_optnew
argument_list|,
name|tmpfs_opts
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|mp
operator|->
name|mnt_flag
operator|&
name|MNT_UPDATE
condition|)
block|{
comment|/* XXX: There is no support yet to update file system 		 * settings.  Should be added. */
return|return
name|EOPNOTSUPP
return|;
block|}
name|printf
argument_list|(
literal|"WARNING: TMPFS is considered to be a highly experimental "
literal|"feature in FreeBSD.\n"
argument_list|)
expr_stmt|;
name|vn_lock
argument_list|(
name|mp
operator|->
name|mnt_vnodecovered
argument_list|,
name|LK_SHARED
operator||
name|LK_RETRY
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|mp
operator|->
name|mnt_vnodecovered
argument_list|,
operator|&
name|va
argument_list|,
name|mp
operator|->
name|mnt_cred
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|mp
operator|->
name|mnt_vnodecovered
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|mp
operator|->
name|mnt_cred
operator|->
name|cr_ruid
operator|!=
literal|0
operator|||
name|vfs_scanopt
argument_list|(
name|mp
operator|->
name|mnt_optnew
argument_list|,
literal|"gid"
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|root_gid
argument_list|)
operator|!=
literal|1
condition|)
name|root_gid
operator|=
name|va
operator|.
name|va_gid
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|mnt_cred
operator|->
name|cr_ruid
operator|!=
literal|0
operator|||
name|vfs_scanopt
argument_list|(
name|mp
operator|->
name|mnt_optnew
argument_list|,
literal|"uid"
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|root_uid
argument_list|)
operator|!=
literal|1
condition|)
name|root_uid
operator|=
name|va
operator|.
name|va_uid
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|mnt_cred
operator|->
name|cr_ruid
operator|!=
literal|0
operator|||
name|vfs_scanopt
argument_list|(
name|mp
operator|->
name|mnt_optnew
argument_list|,
literal|"mode"
argument_list|,
literal|"%ho"
argument_list|,
operator|&
name|root_mode
argument_list|)
operator|!=
literal|1
condition|)
name|root_mode
operator|=
name|va
operator|.
name|va_mode
expr_stmt|;
if|if
condition|(
name|vfs_scanopt
argument_list|(
name|mp
operator|->
name|mnt_optnew
argument_list|,
literal|"inodes"
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|nodes_max
argument_list|)
operator|!=
literal|1
condition|)
name|nodes_max
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vfs_scanopt
argument_list|(
name|mp
operator|->
name|mnt_optnew
argument_list|,
literal|"size"
argument_list|,
literal|"%qu"
argument_list|,
operator|&
name|size_max
argument_list|)
operator|!=
literal|1
condition|)
name|size_max
operator|=
literal|0
expr_stmt|;
comment|/* Do not allow mounts if we do not have enough memory to preserve 	 * the minimum reserved pages. */
name|mem_size
operator|=
name|cnt
operator|.
name|v_free_count
operator|+
name|cnt
operator|.
name|v_inactive_count
operator|+
name|get_swpgtotal
argument_list|()
expr_stmt|;
name|mem_size
operator|-=
name|mem_size
operator|>
name|cnt
operator|.
name|v_wire_count
condition|?
name|cnt
operator|.
name|v_wire_count
else|:
name|mem_size
expr_stmt|;
if|if
condition|(
name|mem_size
operator|<
name|TMPFS_PAGES_RESERVED
condition|)
return|return
name|ENOSPC
return|;
comment|/* Get the maximum number of memory pages this file system is 	 * allowed to use, based on the maximum size the user passed in 	 * the mount structure.  A value of zero is treated as if the 	 * maximum available space was requested. */
if|if
condition|(
name|size_max
operator|<
name|PAGE_SIZE
operator|||
name|size_max
operator|>=
name|SIZE_MAX
condition|)
name|pages
operator|=
name|SIZE_MAX
expr_stmt|;
else|else
name|pages
operator|=
name|howmany
argument_list|(
name|size_max
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|pages
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nodes_max
operator|<=
literal|3
condition|)
name|nodes
operator|=
literal|3
operator|+
name|pages
operator|*
name|PAGE_SIZE
operator|/
literal|1024
expr_stmt|;
else|else
name|nodes
operator|=
name|nodes_max
expr_stmt|;
name|MPASS
argument_list|(
name|nodes
operator|>=
literal|3
argument_list|)
expr_stmt|;
comment|/* Allocate the tmpfs mount structure and fill it. */
name|tmp
operator|=
operator|(
expr|struct
name|tmpfs_mount
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|tmpfs_mount
argument_list|)
argument_list|,
name|M_TMPFSMNT
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|tmp
operator|->
name|allnode_lock
argument_list|,
literal|"tmpfs allnode lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|tmp
operator|->
name|tm_nodes_max
operator|=
name|nodes
expr_stmt|;
name|tmp
operator|->
name|tm_nodes_inuse
operator|=
literal|0
expr_stmt|;
name|tmp
operator|->
name|tm_maxfilesize
operator|=
call|(
name|u_int64_t
call|)
argument_list|(
name|cnt
operator|.
name|v_page_count
operator|+
name|get_swpgtotal
argument_list|()
argument_list|)
operator|*
name|PAGE_SIZE
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|tmp
operator|->
name|tm_nodes_used
argument_list|)
expr_stmt|;
name|tmp
operator|->
name|tm_pages_max
operator|=
name|pages
expr_stmt|;
name|tmp
operator|->
name|tm_pages_used
operator|=
literal|0
expr_stmt|;
name|tmp
operator|->
name|tm_ino_unr
operator|=
name|new_unrhdr
argument_list|(
literal|2
argument_list|,
name|INT_MAX
argument_list|,
operator|&
name|tmp
operator|->
name|allnode_lock
argument_list|)
expr_stmt|;
name|tmp
operator|->
name|tm_dirent_pool
operator|=
name|uma_zcreate
argument_list|(
literal|"TMPFS dirent"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tmpfs_dirent
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tmp
operator|->
name|tm_node_pool
operator|=
name|uma_zcreate
argument_list|(
literal|"TMPFS node"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tmpfs_node
argument_list|)
argument_list|,
name|tmpfs_node_ctor
argument_list|,
name|tmpfs_node_dtor
argument_list|,
name|tmpfs_node_init
argument_list|,
name|tmpfs_node_fini
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Allocate the root node. */
name|error
operator|=
name|tmpfs_alloc_node
argument_list|(
name|tmp
argument_list|,
name|VDIR
argument_list|,
name|root_uid
argument_list|,
name|root_gid
argument_list|,
name|root_mode
operator|&
name|ALLPERMS
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|VNOVAL
argument_list|,
name|td
argument_list|,
operator|&
name|root
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|root
operator|==
name|NULL
condition|)
block|{
name|uma_zdestroy
argument_list|(
name|tmp
operator|->
name|tm_node_pool
argument_list|)
expr_stmt|;
name|uma_zdestroy
argument_list|(
name|tmp
operator|->
name|tm_dirent_pool
argument_list|)
expr_stmt|;
name|delete_unrhdr
argument_list|(
name|tmp
operator|->
name|tm_ino_unr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp
argument_list|,
name|M_TMPFSMNT
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|KASSERT
argument_list|(
name|root
operator|->
name|tn_id
operator|==
literal|2
argument_list|,
operator|(
literal|"tmpfs root with invalid ino: %d"
operator|,
name|root
operator|->
name|tn_id
operator|)
argument_list|)
expr_stmt|;
name|tmp
operator|->
name|tm_root
operator|=
name|root
expr_stmt|;
name|MNT_ILOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|mp
operator|->
name|mnt_flag
operator||=
name|MNT_LOCAL
expr_stmt|;
name|mp
operator|->
name|mnt_kern_flag
operator||=
name|MNTK_MPSAFE
expr_stmt|;
name|MNT_IUNLOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|mp
operator|->
name|mnt_data
operator|=
name|tmp
expr_stmt|;
name|mp
operator|->
name|mnt_stat
operator|.
name|f_namemax
operator|=
name|MAXNAMLEN
expr_stmt|;
name|vfs_getnewfsid
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|vfs_mountedfrom
argument_list|(
name|mp
argument_list|,
literal|"tmpfs"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* ARGSUSED2 */
end_comment

begin_function
specifier|static
name|int
name|tmpfs_unmount
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|int
name|mntflags
parameter_list|,
name|struct
name|thread
modifier|*
name|l
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|int
name|flags
init|=
literal|0
decl_stmt|;
name|struct
name|tmpfs_mount
modifier|*
name|tmp
decl_stmt|;
name|struct
name|tmpfs_node
modifier|*
name|node
decl_stmt|;
comment|/* Handle forced unmounts. */
if|if
condition|(
name|mntflags
operator|&
name|MNT_FORCE
condition|)
name|flags
operator||=
name|FORCECLOSE
expr_stmt|;
comment|/* Finalize all pending I/O. */
name|error
operator|=
name|vflush
argument_list|(
name|mp
argument_list|,
literal|0
argument_list|,
name|flags
argument_list|,
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|tmp
operator|=
name|VFS_TO_TMPFS
argument_list|(
name|mp
argument_list|)
expr_stmt|;
comment|/* Free all associated data.  The loop iterates over the linked list 	 * we have containing all used nodes.  For each of them that is 	 * a directory, we free all its directory entries.  Note that after 	 * freeing a node, it will automatically go to the available list, 	 * so we will later have to iterate over it to release its items. */
name|node
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|tmp
operator|->
name|tm_nodes_used
argument_list|)
expr_stmt|;
while|while
condition|(
name|node
operator|!=
name|NULL
condition|)
block|{
name|struct
name|tmpfs_node
modifier|*
name|next
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|tn_type
operator|==
name|VDIR
condition|)
block|{
name|struct
name|tmpfs_dirent
modifier|*
name|de
decl_stmt|;
name|de
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|node
operator|->
name|tn_dir
operator|.
name|tn_dirhead
argument_list|)
expr_stmt|;
while|while
condition|(
name|de
operator|!=
name|NULL
condition|)
block|{
name|struct
name|tmpfs_dirent
modifier|*
name|nde
decl_stmt|;
name|nde
operator|=
name|TAILQ_NEXT
argument_list|(
name|de
argument_list|,
name|td_entries
argument_list|)
expr_stmt|;
name|tmpfs_free_dirent
argument_list|(
name|tmp
argument_list|,
name|de
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|de
operator|=
name|nde
expr_stmt|;
name|node
operator|->
name|tn_size
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|tmpfs_dirent
argument_list|)
expr_stmt|;
block|}
block|}
name|next
operator|=
name|LIST_NEXT
argument_list|(
name|node
argument_list|,
name|tn_entries
argument_list|)
expr_stmt|;
name|tmpfs_free_node
argument_list|(
name|tmp
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|node
operator|=
name|next
expr_stmt|;
block|}
name|uma_zdestroy
argument_list|(
name|tmp
operator|->
name|tm_dirent_pool
argument_list|)
expr_stmt|;
name|uma_zdestroy
argument_list|(
name|tmp
operator|->
name|tm_node_pool
argument_list|)
expr_stmt|;
name|delete_unrhdr
argument_list|(
name|tmp
operator|->
name|tm_ino_unr
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|tmp
operator|->
name|allnode_lock
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|tmp
operator|->
name|tm_pages_used
operator|==
literal|0
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|tmp
operator|->
name|tm_nodes_inuse
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* Throw away the tmpfs_mount structure. */
name|free
argument_list|(
name|mp
operator|->
name|mnt_data
argument_list|,
name|M_TMPFSMNT
argument_list|)
expr_stmt|;
name|mp
operator|->
name|mnt_data
operator|=
name|NULL
expr_stmt|;
name|MNT_ILOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|mp
operator|->
name|mnt_flag
operator|&=
operator|~
name|MNT_LOCAL
expr_stmt|;
name|MNT_IUNLOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment

begin_function
specifier|static
name|int
name|tmpfs_root
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|tmpfs_alloc_vp
argument_list|(
name|mp
argument_list|,
name|VFS_TO_TMPFS
argument_list|(
name|mp
argument_list|)
operator|->
name|tm_root
argument_list|,
name|flags
argument_list|,
name|vpp
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
operator|(
operator|*
name|vpp
operator|)
operator|->
name|v_vflag
operator||=
name|VV_ROOT
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment

begin_function
specifier|static
name|int
name|tmpfs_fhtovp
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|struct
name|fid
modifier|*
name|fhp
parameter_list|,
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
parameter_list|)
block|{
name|boolean_t
name|found
decl_stmt|;
name|struct
name|tmpfs_fid
modifier|*
name|tfhp
decl_stmt|;
name|struct
name|tmpfs_mount
modifier|*
name|tmp
decl_stmt|;
name|struct
name|tmpfs_node
modifier|*
name|node
decl_stmt|;
name|tmp
operator|=
name|VFS_TO_TMPFS
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|tfhp
operator|=
operator|(
expr|struct
name|tmpfs_fid
operator|*
operator|)
name|fhp
expr_stmt|;
if|if
condition|(
name|tfhp
operator|->
name|tf_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|tmpfs_fid
argument_list|)
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|tfhp
operator|->
name|tf_id
operator|>=
name|tmp
operator|->
name|tm_nodes_max
condition|)
return|return
name|EINVAL
return|;
name|found
operator|=
name|FALSE
expr_stmt|;
name|TMPFS_LOCK
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|node
argument_list|,
argument|&tmp->tm_nodes_used
argument_list|,
argument|tn_entries
argument_list|)
block|{
if|if
condition|(
name|node
operator|->
name|tn_id
operator|==
name|tfhp
operator|->
name|tf_id
operator|&&
name|node
operator|->
name|tn_gen
operator|==
name|tfhp
operator|->
name|tf_gen
condition|)
block|{
name|found
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
name|TMPFS_UNLOCK
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
condition|)
return|return
operator|(
name|tmpfs_alloc_vp
argument_list|(
name|mp
argument_list|,
name|node
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
name|vpp
argument_list|,
name|curthread
argument_list|)
operator|)
return|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* ARGSUSED2 */
end_comment

begin_function
specifier|static
name|int
name|tmpfs_statfs
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|struct
name|statfs
modifier|*
name|sbp
parameter_list|,
name|struct
name|thread
modifier|*
name|l
parameter_list|)
block|{
name|fsfilcnt_t
name|freenodes
decl_stmt|;
name|struct
name|tmpfs_mount
modifier|*
name|tmp
decl_stmt|;
name|tmp
operator|=
name|VFS_TO_TMPFS
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|sbp
operator|->
name|f_iosize
operator|=
name|PAGE_SIZE
expr_stmt|;
name|sbp
operator|->
name|f_bsize
operator|=
name|PAGE_SIZE
expr_stmt|;
name|sbp
operator|->
name|f_blocks
operator|=
name|TMPFS_PAGES_MAX
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|sbp
operator|->
name|f_bavail
operator|=
name|sbp
operator|->
name|f_bfree
operator|=
name|TMPFS_PAGES_AVAIL
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|freenodes
operator|=
name|MIN
argument_list|(
name|tmp
operator|->
name|tm_nodes_max
operator|-
name|tmp
operator|->
name|tm_nodes_inuse
argument_list|,
name|TMPFS_PAGES_AVAIL
argument_list|(
name|tmp
argument_list|)
operator|*
name|PAGE_SIZE
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|tmpfs_node
argument_list|)
argument_list|)
expr_stmt|;
name|sbp
operator|->
name|f_files
operator|=
name|freenodes
operator|+
name|tmp
operator|->
name|tm_nodes_inuse
expr_stmt|;
name|sbp
operator|->
name|f_ffree
operator|=
name|freenodes
expr_stmt|;
comment|/* sbp->f_owner = tmp->tn_uid; */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment

begin_comment
comment|/*  * tmpfs vfs operations.  */
end_comment

begin_decl_stmt
name|struct
name|vfsops
name|tmpfs_vfsops
init|=
block|{
operator|.
name|vfs_mount
operator|=
name|tmpfs_mount
block|,
operator|.
name|vfs_unmount
operator|=
name|tmpfs_unmount
block|,
operator|.
name|vfs_root
operator|=
name|tmpfs_root
block|,
operator|.
name|vfs_statfs
operator|=
name|tmpfs_statfs
block|,
operator|.
name|vfs_fhtovp
operator|=
name|tmpfs_fhtovp
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|VFS_SET
argument_list|(
name|tmpfs_vfsops
argument_list|,
name|tmpfs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

