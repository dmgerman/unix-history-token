begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2001 Dag-Erling Coïdan Smørgrav  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer  *    in this position and unchanged.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_pseudofs.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/dirent.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<fs/pseudofs/pseudofs.h>
end_include

begin_include
include|#
directive|include
file|<fs/pseudofs/pseudofs_internal.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|PSEUDOFS_TRACE
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|pfs_trace
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_pfs
argument_list|,
name|OID_AUTO
argument_list|,
name|trace
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|pfs_trace
argument_list|,
literal|0
argument_list|,
literal|"enable tracing of pseudofs vnode operations"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|PFS_TRACE
parameter_list|(
name|foo
parameter_list|)
define|\
value|do { \ 		if (pfs_trace) { \ 			printf("%s(): line %d: ", __func__, __LINE__); \ 			printf foo ; \ 			printf("\n"); \ 		} \ 	} while (0)
end_define

begin_define
define|#
directive|define
name|PFS_RETURN
parameter_list|(
name|err
parameter_list|)
define|\
value|do { \ 		if (pfs_trace) { \ 			printf("%s(): line %d: returning %d\n", \ 			    __func__, __LINE__, err); \ 		} \ 		return (err); \ 	} while (0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PFS_TRACE
parameter_list|(
name|foo
parameter_list|)
define|\
value|do {
comment|/* nothing */
value|} while (0)
end_define

begin_define
define|#
directive|define
name|PFS_RETURN
parameter_list|(
name|err
parameter_list|)
define|\
value|return (err)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Returns non-zero if given file is visible to given process  */
end_comment

begin_function
specifier|static
name|int
name|pfs_visible
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|pfs_node
modifier|*
name|pn
parameter_list|,
name|pid_t
name|pid
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|proc
decl_stmt|;
name|int
name|r
decl_stmt|;
name|PFS_TRACE
argument_list|(
operator|(
literal|"%s (pid: %d, req: %d)"
operator|,
name|pn
operator|->
name|pn_name
operator|,
name|pid
operator|,
name|td
operator|->
name|td_proc
operator|->
name|p_pid
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pn
operator|->
name|pn_flags
operator|&
name|PFS_DISABLED
condition|)
name|PFS_RETURN
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|r
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|pid
operator|!=
name|NO_PID
condition|)
block|{
if|if
condition|(
operator|(
name|proc
operator|=
name|pfind
argument_list|(
name|pid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|PFS_RETURN
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_cansee
argument_list|(
name|td
argument_list|,
name|proc
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|pn
operator|->
name|pn_vis
operator|!=
name|NULL
operator|&&
operator|!
call|(
name|pn
operator|->
name|pn_vis
call|)
argument_list|(
name|td
argument_list|,
name|proc
argument_list|,
name|pn
argument_list|)
operator|)
condition|)
name|r
operator|=
literal|0
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|proc
argument_list|)
expr_stmt|;
block|}
name|PFS_RETURN
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Verify permissions  */
end_comment

begin_function
specifier|static
name|int
name|pfs_access
parameter_list|(
name|struct
name|vop_access_args
modifier|*
name|va
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vn
init|=
name|va
operator|->
name|a_vp
decl_stmt|;
name|struct
name|vattr
name|vattr
decl_stmt|;
name|int
name|error
decl_stmt|;
name|PFS_TRACE
argument_list|(
operator|(
operator|(
operator|(
expr|struct
name|pfs_vdata
operator|*
operator|)
name|vn
operator|->
name|v_data
operator|)
operator|->
name|pvd_pn
operator|->
name|pn_name
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|vn
argument_list|,
operator|&
name|vattr
argument_list|,
name|va
operator|->
name|a_cred
argument_list|,
name|va
operator|->
name|a_td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|PFS_RETURN
argument_list|(
name|error
argument_list|)
expr_stmt|;
name|error
operator|=
name|vaccess
argument_list|(
name|vn
operator|->
name|v_type
argument_list|,
name|vattr
operator|.
name|va_mode
argument_list|,
name|vattr
operator|.
name|va_uid
argument_list|,
name|vattr
operator|.
name|va_gid
argument_list|,
name|va
operator|->
name|a_mode
argument_list|,
name|va
operator|->
name|a_cred
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|PFS_RETURN
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Close a file or directory  */
end_comment

begin_function
specifier|static
name|int
name|pfs_close
parameter_list|(
name|struct
name|vop_close_args
modifier|*
name|va
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vn
init|=
name|va
operator|->
name|a_vp
decl_stmt|;
name|struct
name|pfs_vdata
modifier|*
name|pvd
init|=
operator|(
expr|struct
name|pfs_vdata
operator|*
operator|)
name|vn
operator|->
name|v_data
decl_stmt|;
name|struct
name|pfs_node
modifier|*
name|pn
init|=
name|pvd
operator|->
name|pvd_pn
decl_stmt|;
name|struct
name|proc
modifier|*
name|proc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|PFS_TRACE
argument_list|(
operator|(
name|pn
operator|->
name|pn_name
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Do nothing unless this is the last close and the node has a 	 * last-close handler. 	 */
if|if
condition|(
name|vrefcnt
argument_list|(
name|vn
argument_list|)
operator|>
literal|1
operator|||
name|pn
operator|->
name|pn_close
operator|==
name|NULL
condition|)
name|PFS_RETURN
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvd
operator|->
name|pvd_pid
operator|!=
name|NO_PID
condition|)
name|proc
operator|=
name|pfind
argument_list|(
name|pvd
operator|->
name|pvd_pid
argument_list|)
expr_stmt|;
else|else
name|proc
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
call|(
name|pn
operator|->
name|pn_close
call|)
argument_list|(
name|va
operator|->
name|a_td
argument_list|,
name|proc
argument_list|,
name|pn
argument_list|)
expr_stmt|;
if|if
condition|(
name|proc
operator|!=
name|NULL
condition|)
name|PROC_UNLOCK
argument_list|(
name|proc
argument_list|)
expr_stmt|;
name|PFS_RETURN
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get file attributes  */
end_comment

begin_function
specifier|static
name|int
name|pfs_getattr
parameter_list|(
name|struct
name|vop_getattr_args
modifier|*
name|va
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vn
init|=
name|va
operator|->
name|a_vp
decl_stmt|;
name|struct
name|pfs_vdata
modifier|*
name|pvd
init|=
operator|(
expr|struct
name|pfs_vdata
operator|*
operator|)
name|vn
operator|->
name|v_data
decl_stmt|;
name|struct
name|pfs_node
modifier|*
name|pn
init|=
name|pvd
operator|->
name|pvd_pn
decl_stmt|;
name|struct
name|vattr
modifier|*
name|vap
init|=
name|va
operator|->
name|a_vap
decl_stmt|;
name|struct
name|proc
modifier|*
name|proc
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|PFS_TRACE
argument_list|(
operator|(
name|pn
operator|->
name|pn_name
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pfs_visible
argument_list|(
name|curthread
argument_list|,
name|pn
argument_list|,
name|pvd
operator|->
name|pvd_pid
argument_list|)
condition|)
name|PFS_RETURN
argument_list|(
name|ENOENT
argument_list|)
expr_stmt|;
name|VATTR_NULL
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|vap
operator|->
name|va_type
operator|=
name|vn
operator|->
name|v_type
expr_stmt|;
name|vap
operator|->
name|va_fileid
operator|=
name|pn
operator|->
name|pn_fileno
expr_stmt|;
name|vap
operator|->
name|va_flags
operator|=
literal|0
expr_stmt|;
name|vap
operator|->
name|va_blocksize
operator|=
name|PAGE_SIZE
expr_stmt|;
name|vap
operator|->
name|va_bytes
operator|=
name|vap
operator|->
name|va_size
operator|=
literal|0
expr_stmt|;
name|vap
operator|->
name|va_fsid
operator|=
name|vn
operator|->
name|v_mount
operator|->
name|mnt_stat
operator|.
name|f_fsid
operator|.
name|val
index|[
literal|0
index|]
expr_stmt|;
name|vap
operator|->
name|va_nlink
operator|=
literal|1
expr_stmt|;
name|nanotime
argument_list|(
operator|&
name|vap
operator|->
name|va_ctime
argument_list|)
expr_stmt|;
name|vap
operator|->
name|va_atime
operator|=
name|vap
operator|->
name|va_mtime
operator|=
name|vap
operator|->
name|va_ctime
expr_stmt|;
switch|switch
condition|(
name|pn
operator|->
name|pn_type
condition|)
block|{
case|case
name|pfstype_procdir
case|:
case|case
name|pfstype_root
case|:
case|case
name|pfstype_dir
case|:
name|vap
operator|->
name|va_mode
operator|=
literal|0555
expr_stmt|;
break|break;
case|case
name|pfstype_file
case|:
case|case
name|pfstype_symlink
case|:
name|vap
operator|->
name|va_mode
operator|=
literal|0444
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"shouldn't be here!\n"
argument_list|)
expr_stmt|;
name|vap
operator|->
name|va_mode
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|pvd
operator|->
name|pvd_pid
operator|!=
name|NO_PID
condition|)
block|{
if|if
condition|(
operator|(
name|proc
operator|=
name|pfind
argument_list|(
name|pvd
operator|->
name|pvd_pid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|PFS_RETURN
argument_list|(
name|ENOENT
argument_list|)
expr_stmt|;
name|vap
operator|->
name|va_uid
operator|=
name|proc
operator|->
name|p_ucred
operator|->
name|cr_ruid
expr_stmt|;
name|vap
operator|->
name|va_gid
operator|=
name|proc
operator|->
name|p_ucred
operator|->
name|cr_rgid
expr_stmt|;
if|if
condition|(
name|pn
operator|->
name|pn_attr
operator|!=
name|NULL
condition|)
name|error
operator|=
call|(
name|pn
operator|->
name|pn_attr
call|)
argument_list|(
name|va
operator|->
name|a_td
argument_list|,
name|proc
argument_list|,
name|pn
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|proc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vap
operator|->
name|va_uid
operator|=
literal|0
expr_stmt|;
name|vap
operator|->
name|va_gid
operator|=
literal|0
expr_stmt|;
block|}
name|PFS_RETURN
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Perform an ioctl  */
end_comment

begin_function
specifier|static
name|int
name|pfs_ioctl
parameter_list|(
name|struct
name|vop_ioctl_args
modifier|*
name|va
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vn
init|=
name|va
operator|->
name|a_vp
decl_stmt|;
name|struct
name|pfs_vdata
modifier|*
name|pvd
init|=
operator|(
expr|struct
name|pfs_vdata
operator|*
operator|)
name|vn
operator|->
name|v_data
decl_stmt|;
name|struct
name|pfs_node
modifier|*
name|pn
init|=
name|pvd
operator|->
name|pvd_pn
decl_stmt|;
name|struct
name|proc
modifier|*
name|proc
init|=
name|NULL
decl_stmt|;
name|int
name|error
decl_stmt|;
name|PFS_TRACE
argument_list|(
operator|(
literal|"%s: %lx"
operator|,
name|pn
operator|->
name|pn_name
operator|,
name|va
operator|->
name|a_command
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vn
operator|->
name|v_type
operator|!=
name|VREG
condition|)
name|PFS_RETURN
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|pn
operator|->
name|pn_ioctl
operator|==
name|NULL
condition|)
name|PFS_RETURN
argument_list|(
name|ENOTTY
argument_list|)
expr_stmt|;
comment|/* 	 * This is necessary because process' privileges may 	 * have changed since the open() call. 	 */
if|if
condition|(
operator|!
name|pfs_visible
argument_list|(
name|curthread
argument_list|,
name|pn
argument_list|,
name|pvd
operator|->
name|pvd_pid
argument_list|)
condition|)
name|PFS_RETURN
argument_list|(
name|EIO
argument_list|)
expr_stmt|;
comment|/* XXX duplicates bits of pfs_visible() */
if|if
condition|(
name|pvd
operator|->
name|pvd_pid
operator|!=
name|NO_PID
condition|)
block|{
if|if
condition|(
operator|(
name|proc
operator|=
name|pfind
argument_list|(
name|pvd
operator|->
name|pvd_pid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|PFS_RETURN
argument_list|(
name|EIO
argument_list|)
expr_stmt|;
name|_PHOLD
argument_list|(
name|proc
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|proc
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
call|(
name|pn
operator|->
name|pn_ioctl
call|)
argument_list|(
name|curthread
argument_list|,
name|proc
argument_list|,
name|pn
argument_list|,
name|va
operator|->
name|a_command
argument_list|,
name|va
operator|->
name|a_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|proc
operator|!=
name|NULL
condition|)
name|PRELE
argument_list|(
name|proc
argument_list|)
expr_stmt|;
name|PFS_RETURN
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Perform getextattr  */
end_comment

begin_function
specifier|static
name|int
name|pfs_getextattr
parameter_list|(
name|struct
name|vop_getextattr_args
modifier|*
name|va
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vn
init|=
name|va
operator|->
name|a_vp
decl_stmt|;
name|struct
name|pfs_vdata
modifier|*
name|pvd
init|=
operator|(
expr|struct
name|pfs_vdata
operator|*
operator|)
name|vn
operator|->
name|v_data
decl_stmt|;
name|struct
name|pfs_node
modifier|*
name|pn
init|=
name|pvd
operator|->
name|pvd_pn
decl_stmt|;
name|struct
name|proc
modifier|*
name|proc
init|=
name|NULL
decl_stmt|;
name|int
name|error
decl_stmt|;
name|PFS_TRACE
argument_list|(
operator|(
name|pn
operator|->
name|pn_name
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pfs_visible
argument_list|(
name|curthread
argument_list|,
name|pn
argument_list|,
name|pvd
operator|->
name|pvd_pid
argument_list|)
condition|)
name|PFS_RETURN
argument_list|(
name|ENOENT
argument_list|)
expr_stmt|;
if|if
condition|(
name|pn
operator|->
name|pn_getextattr
operator|==
name|NULL
condition|)
name|PFS_RETURN
argument_list|(
name|EOPNOTSUPP
argument_list|)
expr_stmt|;
comment|/* 	 * This is necessary because either process' privileges may 	 * have changed since the open() call. 	 */
if|if
condition|(
operator|!
name|pfs_visible
argument_list|(
name|curthread
argument_list|,
name|pn
argument_list|,
name|pvd
operator|->
name|pvd_pid
argument_list|)
condition|)
name|PFS_RETURN
argument_list|(
name|EIO
argument_list|)
expr_stmt|;
comment|/* XXX duplicates bits of pfs_visible() */
if|if
condition|(
name|pvd
operator|->
name|pvd_pid
operator|!=
name|NO_PID
condition|)
block|{
if|if
condition|(
operator|(
name|proc
operator|=
name|pfind
argument_list|(
name|pvd
operator|->
name|pvd_pid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|PFS_RETURN
argument_list|(
name|EIO
argument_list|)
expr_stmt|;
name|_PHOLD
argument_list|(
name|proc
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|proc
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
call|(
name|pn
operator|->
name|pn_getextattr
call|)
argument_list|(
name|curthread
argument_list|,
name|proc
argument_list|,
name|pn
argument_list|,
name|va
operator|->
name|a_attrnamespace
argument_list|,
name|va
operator|->
name|a_name
argument_list|,
name|va
operator|->
name|a_uio
argument_list|,
name|va
operator|->
name|a_size
argument_list|,
name|va
operator|->
name|a_cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|proc
operator|!=
name|NULL
condition|)
name|PRELE
argument_list|(
name|proc
argument_list|)
expr_stmt|;
name|PFS_RETURN
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Look up a file or directory  *  * XXX NOTE!  pfs_lookup() has been hooked into vop_lookup_desc!  This  * will result in a lookup operation for a vnode which may already be  * cached, therefore we have to be careful to purge the VFS cache when  * reusing a vnode.  *  * This code will work, but is not really correct.  Normally we would hook  * vfs_cache_lookup() into vop_lookup_desc and hook pfs_lookup() into  * vop_cachedlookup_desc.  */
end_comment

begin_function
specifier|static
name|int
name|pfs_lookup
parameter_list|(
name|struct
name|vop_lookup_args
modifier|*
name|va
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vn
init|=
name|va
operator|->
name|a_dvp
decl_stmt|;
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
init|=
name|va
operator|->
name|a_vpp
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|va
operator|->
name|a_cnp
decl_stmt|;
name|struct
name|pfs_vdata
modifier|*
name|pvd
init|=
operator|(
expr|struct
name|pfs_vdata
operator|*
operator|)
name|vn
operator|->
name|v_data
decl_stmt|;
name|struct
name|pfs_node
modifier|*
name|pd
init|=
name|pvd
operator|->
name|pvd_pn
decl_stmt|;
name|struct
name|pfs_node
modifier|*
name|pn
decl_stmt|,
modifier|*
name|pdn
init|=
name|NULL
decl_stmt|;
name|pid_t
name|pid
init|=
name|pvd
operator|->
name|pvd_pid
decl_stmt|;
name|int
name|lockparent
decl_stmt|;
name|int
name|wantparent
decl_stmt|;
name|char
modifier|*
name|pname
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|namelen
decl_stmt|;
name|PFS_TRACE
argument_list|(
operator|(
literal|"%.*s"
operator|,
operator|(
name|int
operator|)
name|cnp
operator|->
name|cn_namelen
operator|,
name|cnp
operator|->
name|cn_nameptr
operator|)
argument_list|)
expr_stmt|;
name|cnp
operator|->
name|cn_flags
operator|&=
operator|~
name|PDIRUNLOCK
expr_stmt|;
if|if
condition|(
name|vn
operator|->
name|v_type
operator|!=
name|VDIR
condition|)
name|PFS_RETURN
argument_list|(
name|ENOTDIR
argument_list|)
expr_stmt|;
comment|/* 	 * Don't support DELETE or RENAME.  CREATE is supported so 	 * that O_CREAT will work, but the lookup will still fail if 	 * the file does not exist. 	 */
if|if
condition|(
name|cnp
operator|->
name|cn_nameiop
operator|==
name|DELETE
operator|||
name|cnp
operator|->
name|cn_nameiop
operator|==
name|RENAME
condition|)
name|PFS_RETURN
argument_list|(
name|EOPNOTSUPP
argument_list|)
expr_stmt|;
comment|/* shortcut: check if the name is too long */
if|if
condition|(
name|cnp
operator|->
name|cn_namelen
operator|>=
name|PFS_NAMELEN
condition|)
name|PFS_RETURN
argument_list|(
name|ENOENT
argument_list|)
expr_stmt|;
comment|/* check that parent directory is visisble... */
if|if
condition|(
operator|!
name|pfs_visible
argument_list|(
name|curthread
argument_list|,
name|pd
argument_list|,
name|pvd
operator|->
name|pvd_pid
argument_list|)
condition|)
name|PFS_RETURN
argument_list|(
name|ENOENT
argument_list|)
expr_stmt|;
name|lockparent
operator|=
name|cnp
operator|->
name|cn_flags
operator|&
name|LOCKPARENT
expr_stmt|;
name|wantparent
operator|=
name|cnp
operator|->
name|cn_flags
operator|&
operator|(
name|LOCKPARENT
operator||
name|WANTPARENT
operator|)
expr_stmt|;
comment|/* self */
name|namelen
operator|=
name|cnp
operator|->
name|cn_namelen
expr_stmt|;
name|pname
operator|=
name|cnp
operator|->
name|cn_nameptr
expr_stmt|;
if|if
condition|(
name|namelen
operator|==
literal|1
operator|&&
operator|*
name|pname
operator|==
literal|'.'
condition|)
block|{
name|pn
operator|=
name|pd
expr_stmt|;
operator|*
name|vpp
operator|=
name|vn
expr_stmt|;
name|VREF
argument_list|(
name|vn
argument_list|)
expr_stmt|;
name|PFS_RETURN
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* parent */
if|if
condition|(
name|cnp
operator|->
name|cn_flags
operator|&
name|ISDOTDOT
condition|)
block|{
if|if
condition|(
name|pd
operator|->
name|pn_type
operator|==
name|pfstype_root
condition|)
name|PFS_RETURN
argument_list|(
name|EIO
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|vn
argument_list|,
literal|0
argument_list|,
name|cnp
operator|->
name|cn_thread
argument_list|)
expr_stmt|;
name|cnp
operator|->
name|cn_flags
operator||=
name|PDIRUNLOCK
expr_stmt|;
name|KASSERT
argument_list|(
name|pd
operator|->
name|pn_parent
argument_list|,
operator|(
literal|"non-root directory has no parent"
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * This one is tricky.  Descendents of procdir nodes 		 * inherit their parent's process affinity, but 		 * there's no easy reverse mapping.  For simplicity, 		 * we assume that if this node is a procdir, its 		 * parent isn't (which is correct as long as 		 * descendents of procdir nodes are never procdir 		 * nodes themselves) 		 */
if|if
condition|(
name|pd
operator|->
name|pn_type
operator|==
name|pfstype_procdir
condition|)
name|pid
operator|=
name|NO_PID
expr_stmt|;
name|pn
operator|=
name|pd
operator|->
name|pn_parent
expr_stmt|;
goto|goto
name|got_pnode
goto|;
block|}
comment|/* named node */
for|for
control|(
name|pn
operator|=
name|pd
operator|->
name|pn_nodes
init|;
name|pn
operator|!=
name|NULL
condition|;
name|pn
operator|=
name|pn
operator|->
name|pn_next
control|)
if|if
condition|(
name|pn
operator|->
name|pn_type
operator|==
name|pfstype_procdir
condition|)
name|pdn
operator|=
name|pn
expr_stmt|;
elseif|else
if|if
condition|(
name|pn
operator|->
name|pn_name
index|[
name|namelen
index|]
operator|==
literal|'\0'
operator|&&
name|bcmp
argument_list|(
name|pname
argument_list|,
name|pn
operator|->
name|pn_name
argument_list|,
name|namelen
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|got_pnode
goto|;
comment|/* process dependent node */
if|if
condition|(
operator|(
name|pn
operator|=
name|pdn
operator|)
operator|!=
name|NULL
condition|)
block|{
name|pid
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|pid
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|namelen
operator|&&
name|isdigit
argument_list|(
name|pname
index|[
name|i
index|]
argument_list|)
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|(
name|pid
operator|=
name|pid
operator|*
literal|10
operator|+
name|pname
index|[
name|i
index|]
operator|-
literal|'0'
operator|)
operator|>
name|PID_MAX
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|cnp
operator|->
name|cn_namelen
condition|)
goto|goto
name|got_pnode
goto|;
block|}
name|PFS_RETURN
argument_list|(
name|ENOENT
argument_list|)
expr_stmt|;
name|got_pnode
label|:
if|if
condition|(
name|pn
operator|!=
name|pd
operator|->
name|pn_parent
operator|&&
operator|!
name|pn
operator|->
name|pn_parent
condition|)
name|pn
operator|->
name|pn_parent
operator|=
name|pd
expr_stmt|;
if|if
condition|(
operator|!
name|pfs_visible
argument_list|(
name|curthread
argument_list|,
name|pn
argument_list|,
name|pvd
operator|->
name|pvd_pid
argument_list|)
condition|)
name|PFS_RETURN
argument_list|(
name|ENOENT
argument_list|)
expr_stmt|;
name|error
operator|=
name|pfs_vncache_alloc
argument_list|(
name|vn
operator|->
name|v_mount
argument_list|,
name|vpp
argument_list|,
name|pn
argument_list|,
name|pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|PFS_RETURN
argument_list|(
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cnp
operator|->
name|cn_flags
operator|&
name|ISDOTDOT
operator|)
operator|&&
operator|(
name|cnp
operator|->
name|cn_flags
operator|&
name|ISLASTCN
operator|)
operator|&&
name|lockparent
condition|)
block|{
name|vn_lock
argument_list|(
name|vn
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|cnp
operator|->
name|cn_thread
argument_list|)
expr_stmt|;
name|cnp
operator|->
name|cn_flags
operator|&=
operator|~
name|PDIRUNLOCK
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
operator|(
name|lockparent
operator|&&
operator|(
name|cnp
operator|->
name|cn_flags
operator|&
name|ISLASTCN
operator|)
operator|)
operator|||
operator|(
name|cnp
operator|->
name|cn_flags
operator|&
name|ISDOTDOT
operator|)
operator|)
condition|)
name|VOP_UNLOCK
argument_list|(
name|vn
argument_list|,
literal|0
argument_list|,
name|cnp
operator|->
name|cn_thread
argument_list|)
expr_stmt|;
comment|/* 	 * XXX See comment at top of the routine. 	 */
if|if
condition|(
name|cnp
operator|->
name|cn_flags
operator|&
name|MAKEENTRY
condition|)
name|cache_enter
argument_list|(
name|vn
argument_list|,
operator|*
name|vpp
argument_list|,
name|cnp
argument_list|)
expr_stmt|;
name|PFS_RETURN
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Open a file or directory.  */
end_comment

begin_function
specifier|static
name|int
name|pfs_open
parameter_list|(
name|struct
name|vop_open_args
modifier|*
name|va
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vn
init|=
name|va
operator|->
name|a_vp
decl_stmt|;
name|struct
name|pfs_vdata
modifier|*
name|pvd
init|=
operator|(
expr|struct
name|pfs_vdata
operator|*
operator|)
name|vn
operator|->
name|v_data
decl_stmt|;
name|struct
name|pfs_node
modifier|*
name|pn
init|=
name|pvd
operator|->
name|pvd_pn
decl_stmt|;
name|int
name|mode
init|=
name|va
operator|->
name|a_mode
decl_stmt|;
name|PFS_TRACE
argument_list|(
operator|(
literal|"%s (mode 0x%x)"
operator|,
name|pn
operator|->
name|pn_name
operator|,
name|mode
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * check if the file is visible to the caller 	 * 	 * XXX Not sure if this is necessary, as the VFS system calls 	 * XXX pfs_lookup() and pfs_access() first, and pfs_lookup() 	 * XXX calls pfs_visible().  There's a race condition here, but 	 * XXX calling pfs_visible() from here doesn't really close it, 	 * XXX and the only consequence of that race is an EIO further 	 * XXX down the line. 	 */
if|if
condition|(
operator|!
name|pfs_visible
argument_list|(
name|va
operator|->
name|a_td
argument_list|,
name|pn
argument_list|,
name|pvd
operator|->
name|pvd_pid
argument_list|)
condition|)
name|PFS_RETURN
argument_list|(
name|ENOENT
argument_list|)
expr_stmt|;
comment|/* check if the requested mode is permitted */
if|if
condition|(
operator|(
operator|(
name|mode
operator|&
name|FREAD
operator|)
operator|&&
operator|!
operator|(
name|mode
operator|&
name|PFS_RD
operator|)
operator|)
operator|||
operator|(
operator|(
name|mode
operator|&
name|FWRITE
operator|)
operator|&&
operator|!
operator|(
name|mode
operator|&
name|PFS_WR
operator|)
operator|)
condition|)
name|PFS_RETURN
argument_list|(
name|EPERM
argument_list|)
expr_stmt|;
comment|/* we don't support locking */
if|if
condition|(
operator|(
name|mode
operator|&
name|O_SHLOCK
operator|)
operator|||
operator|(
name|mode
operator|&
name|O_EXLOCK
operator|)
condition|)
name|PFS_RETURN
argument_list|(
name|EOPNOTSUPP
argument_list|)
expr_stmt|;
name|PFS_RETURN
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Read from a file  */
end_comment

begin_function
specifier|static
name|int
name|pfs_read
parameter_list|(
name|struct
name|vop_read_args
modifier|*
name|va
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vn
init|=
name|va
operator|->
name|a_vp
decl_stmt|;
name|struct
name|pfs_vdata
modifier|*
name|pvd
init|=
operator|(
expr|struct
name|pfs_vdata
operator|*
operator|)
name|vn
operator|->
name|v_data
decl_stmt|;
name|struct
name|pfs_node
modifier|*
name|pn
init|=
name|pvd
operator|->
name|pvd_pn
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
init|=
name|va
operator|->
name|a_uio
decl_stmt|;
name|struct
name|proc
modifier|*
name|proc
init|=
name|NULL
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
init|=
name|NULL
decl_stmt|;
name|int
name|error
decl_stmt|;
name|unsigned
name|int
name|buflen
decl_stmt|,
name|offset
decl_stmt|,
name|resid
decl_stmt|;
name|PFS_TRACE
argument_list|(
operator|(
name|pn
operator|->
name|pn_name
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vn
operator|->
name|v_type
operator|!=
name|VREG
condition|)
name|PFS_RETURN
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|pn
operator|->
name|pn_flags
operator|&
name|PFS_RD
operator|)
condition|)
name|PFS_RETURN
argument_list|(
name|EBADF
argument_list|)
expr_stmt|;
if|if
condition|(
name|pn
operator|->
name|pn_func
operator|==
name|NULL
condition|)
name|PFS_RETURN
argument_list|(
name|EIO
argument_list|)
expr_stmt|;
comment|/* 	 * This is necessary because either process' privileges may 	 * have changed since the open() call. 	 */
if|if
condition|(
operator|!
name|pfs_visible
argument_list|(
name|curthread
argument_list|,
name|pn
argument_list|,
name|pvd
operator|->
name|pvd_pid
argument_list|)
condition|)
name|PFS_RETURN
argument_list|(
name|EIO
argument_list|)
expr_stmt|;
comment|/* XXX duplicates bits of pfs_visible() */
if|if
condition|(
name|pvd
operator|->
name|pvd_pid
operator|!=
name|NO_PID
condition|)
block|{
if|if
condition|(
operator|(
name|proc
operator|=
name|pfind
argument_list|(
name|pvd
operator|->
name|pvd_pid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|PFS_RETURN
argument_list|(
name|EIO
argument_list|)
expr_stmt|;
name|_PHOLD
argument_list|(
name|proc
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|proc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pn
operator|->
name|pn_flags
operator|&
name|PFS_RAWRD
condition|)
block|{
name|error
operator|=
call|(
name|pn
operator|->
name|pn_func
call|)
argument_list|(
name|curthread
argument_list|,
name|proc
argument_list|,
name|pn
argument_list|,
name|NULL
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|proc
operator|!=
name|NULL
condition|)
name|PRELE
argument_list|(
name|proc
argument_list|)
expr_stmt|;
name|PFS_RETURN
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
comment|/* Beaucoup sanity checks so we don't ask for bogus allocation. */
if|if
condition|(
name|uio
operator|->
name|uio_offset
operator|<
literal|0
operator|||
name|uio
operator|->
name|uio_resid
operator|<
literal|0
operator|||
operator|(
name|offset
operator|=
name|uio
operator|->
name|uio_offset
operator|)
operator|!=
name|uio
operator|->
name|uio_offset
operator|||
operator|(
name|resid
operator|=
name|uio
operator|->
name|uio_resid
operator|)
operator|!=
name|uio
operator|->
name|uio_resid
operator|||
operator|(
name|buflen
operator|=
name|offset
operator|+
name|resid
operator|)
operator|<
name|offset
operator|||
name|buflen
operator|>
name|INT_MAX
condition|)
block|{
if|if
condition|(
name|proc
operator|!=
name|NULL
condition|)
name|PRELE
argument_list|(
name|proc
argument_list|)
expr_stmt|;
name|PFS_RETURN
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|buflen
operator|>
name|MAXPHYS
condition|)
block|{
if|if
condition|(
name|proc
operator|!=
name|NULL
condition|)
name|PRELE
argument_list|(
name|proc
argument_list|)
expr_stmt|;
name|PFS_RETURN
argument_list|(
name|EIO
argument_list|)
expr_stmt|;
block|}
name|sb
operator|=
name|sbuf_new
argument_list|(
name|sb
argument_list|,
name|NULL
argument_list|,
name|buflen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|proc
operator|!=
name|NULL
condition|)
name|PRELE
argument_list|(
name|proc
argument_list|)
expr_stmt|;
name|PFS_RETURN
argument_list|(
name|EIO
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
call|(
name|pn
operator|->
name|pn_func
call|)
argument_list|(
name|curthread
argument_list|,
name|proc
argument_list|,
name|pn
argument_list|,
name|sb
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|proc
operator|!=
name|NULL
condition|)
name|PRELE
argument_list|(
name|proc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|PFS_RETURN
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|error
operator|=
name|uiomove_frombuf
argument_list|(
name|sbuf_data
argument_list|(
name|sb
argument_list|)
argument_list|,
name|sbuf_len
argument_list|(
name|sb
argument_list|)
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|PFS_RETURN
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Iterate through directory entries  */
end_comment

begin_function
specifier|static
name|int
name|pfs_iterate
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|pid_t
name|pid
parameter_list|,
name|struct
name|pfs_node
modifier|*
name|pd
parameter_list|,
name|struct
name|pfs_node
modifier|*
modifier|*
name|pn
parameter_list|,
name|struct
name|proc
modifier|*
modifier|*
name|p
parameter_list|)
block|{
name|sx_assert
argument_list|(
operator|&
name|allproc_lock
argument_list|,
name|SX_LOCKED
argument_list|)
expr_stmt|;
name|again
label|:
if|if
condition|(
operator|*
name|pn
operator|==
name|NULL
condition|)
block|{
comment|/* first node */
operator|*
name|pn
operator|=
name|pd
operator|->
name|pn_nodes
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|pn
operator|)
operator|->
name|pn_type
operator|!=
name|pfstype_procdir
condition|)
block|{
comment|/* next node */
operator|*
name|pn
operator|=
operator|(
operator|*
name|pn
operator|)
operator|->
name|pn_next
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|pn
operator|!=
name|NULL
operator|&&
operator|(
operator|*
name|pn
operator|)
operator|->
name|pn_type
operator|==
name|pfstype_procdir
condition|)
block|{
comment|/* next process */
if|if
condition|(
operator|*
name|p
operator|==
name|NULL
condition|)
operator|*
name|p
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|allproc
argument_list|)
expr_stmt|;
else|else
operator|*
name|p
operator|=
name|LIST_NEXT
argument_list|(
operator|*
name|p
argument_list|,
name|p_list
argument_list|)
expr_stmt|;
comment|/* out of processes: next node */
if|if
condition|(
operator|*
name|p
operator|==
name|NULL
condition|)
operator|*
name|pn
operator|=
operator|(
operator|*
name|pn
operator|)
operator|->
name|pn_next
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|pn
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|!
name|pfs_visible
argument_list|(
name|td
argument_list|,
operator|*
name|pn
argument_list|,
operator|*
name|p
condition|?
operator|(
operator|*
name|p
operator|)
operator|->
name|p_pid
else|:
name|pid
argument_list|)
condition|)
goto|goto
name|again
goto|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return directory entries.  */
end_comment

begin_function
specifier|static
name|int
name|pfs_readdir
parameter_list|(
name|struct
name|vop_readdir_args
modifier|*
name|va
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vn
init|=
name|va
operator|->
name|a_vp
decl_stmt|;
name|struct
name|pfs_info
modifier|*
name|pi
init|=
operator|(
expr|struct
name|pfs_info
operator|*
operator|)
name|vn
operator|->
name|v_mount
operator|->
name|mnt_data
decl_stmt|;
name|struct
name|pfs_vdata
modifier|*
name|pvd
init|=
operator|(
expr|struct
name|pfs_vdata
operator|*
operator|)
name|vn
operator|->
name|v_data
decl_stmt|;
name|struct
name|pfs_node
modifier|*
name|pd
init|=
name|pvd
operator|->
name|pvd_pn
decl_stmt|;
name|pid_t
name|pid
init|=
name|pvd
operator|->
name|pvd_pid
decl_stmt|;
name|struct
name|pfs_node
modifier|*
name|pn
decl_stmt|;
name|struct
name|dirent
name|entry
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|off_t
name|offset
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|resid
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|ent
decl_stmt|;
name|PFS_TRACE
argument_list|(
operator|(
name|pd
operator|->
name|pn_name
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vn
operator|->
name|v_type
operator|!=
name|VDIR
condition|)
name|PFS_RETURN
argument_list|(
name|ENOTDIR
argument_list|)
expr_stmt|;
name|uio
operator|=
name|va
operator|->
name|a_uio
expr_stmt|;
comment|/* check if the directory is visible to the caller */
if|if
condition|(
operator|!
name|pfs_visible
argument_list|(
name|curthread
argument_list|,
name|pd
argument_list|,
name|pid
argument_list|)
condition|)
name|PFS_RETURN
argument_list|(
name|ENOENT
argument_list|)
expr_stmt|;
comment|/* only allow reading entire entries */
name|offset
operator|=
name|uio
operator|->
name|uio_offset
expr_stmt|;
name|resid
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
operator|||
name|offset
operator|%
name|PFS_DELEN
operator|!=
literal|0
operator|||
operator|(
name|resid
operator|&&
name|resid
operator|<
name|PFS_DELEN
operator|)
condition|)
name|PFS_RETURN
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|resid
operator|==
literal|0
condition|)
name|PFS_RETURN
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* skip unwanted entries */
name|sx_slock
argument_list|(
operator|&
name|allproc_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|pn
operator|=
name|NULL
operator|,
name|p
operator|=
name|NULL
init|;
name|offset
operator|>
literal|0
condition|;
name|offset
operator|-=
name|PFS_DELEN
control|)
if|if
condition|(
name|pfs_iterate
argument_list|(
name|curthread
argument_list|,
name|pid
argument_list|,
name|pd
argument_list|,
operator|&
name|pn
argument_list|,
operator|&
name|p
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* nothing left... */
name|sx_sunlock
argument_list|(
operator|&
name|allproc_lock
argument_list|)
expr_stmt|;
name|PFS_RETURN
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* fill in entries */
name|ent
operator|=
name|buf
operator|=
name|malloc
argument_list|(
name|resid
argument_list|,
name|M_IOV
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|entry
operator|.
name|d_reclen
operator|=
name|PFS_DELEN
expr_stmt|;
while|while
condition|(
name|pfs_iterate
argument_list|(
name|curthread
argument_list|,
name|pid
argument_list|,
name|pd
argument_list|,
operator|&
name|pn
argument_list|,
operator|&
name|p
argument_list|)
operator|!=
operator|-
literal|1
operator|&&
name|resid
operator|>=
name|PFS_DELEN
condition|)
block|{
if|if
condition|(
operator|!
name|pn
operator|->
name|pn_parent
condition|)
name|pn
operator|->
name|pn_parent
operator|=
name|pd
expr_stmt|;
if|if
condition|(
operator|!
name|pn
operator|->
name|pn_fileno
condition|)
name|pfs_fileno_alloc
argument_list|(
name|pi
argument_list|,
name|pn
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|!=
name|NO_PID
condition|)
name|entry
operator|.
name|d_fileno
operator|=
name|pn
operator|->
name|pn_fileno
operator|*
name|NO_PID
operator|+
name|pid
expr_stmt|;
else|else
name|entry
operator|.
name|d_fileno
operator|=
name|pn
operator|->
name|pn_fileno
expr_stmt|;
comment|/* PFS_DELEN was picked to fit PFS_NAMLEN */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PFS_NAMELEN
operator|-
literal|1
operator|&&
name|pn
operator|->
name|pn_name
index|[
name|i
index|]
operator|!=
literal|'\0'
condition|;
operator|++
name|i
control|)
name|entry
operator|.
name|d_name
index|[
name|i
index|]
operator|=
name|pn
operator|->
name|pn_name
index|[
name|i
index|]
expr_stmt|;
name|entry
operator|.
name|d_name
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|entry
operator|.
name|d_namlen
operator|=
name|i
expr_stmt|;
switch|switch
condition|(
name|pn
operator|->
name|pn_type
condition|)
block|{
case|case
name|pfstype_procdir
case|:
name|KASSERT
argument_list|(
name|p
operator|!=
name|NULL
argument_list|,
operator|(
literal|"reached procdir node with p == NULL"
operator|)
argument_list|)
expr_stmt|;
name|entry
operator|.
name|d_fileno
operator|=
name|pn
operator|->
name|pn_fileno
operator|*
name|NO_PID
operator|+
name|p
operator|->
name|p_pid
expr_stmt|;
name|entry
operator|.
name|d_namlen
operator|=
name|snprintf
argument_list|(
name|entry
operator|.
name|d_name
argument_list|,
name|PFS_NAMELEN
argument_list|,
literal|"%d"
argument_list|,
name|p
operator|->
name|p_pid
argument_list|)
expr_stmt|;
comment|/* fall through */
case|case
name|pfstype_root
case|:
case|case
name|pfstype_dir
case|:
case|case
name|pfstype_this
case|:
case|case
name|pfstype_parent
case|:
name|entry
operator|.
name|d_type
operator|=
name|DT_DIR
expr_stmt|;
break|break;
case|case
name|pfstype_file
case|:
name|entry
operator|.
name|d_type
operator|=
name|DT_REG
expr_stmt|;
break|break;
case|case
name|pfstype_symlink
case|:
name|entry
operator|.
name|d_type
operator|=
name|DT_LNK
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"%s has unexpected node type: %d"
argument_list|,
name|pn
operator|->
name|pn_name
argument_list|,
name|pn
operator|->
name|pn_type
argument_list|)
expr_stmt|;
block|}
name|PFS_TRACE
argument_list|(
operator|(
name|entry
operator|.
name|d_name
operator|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|entry
argument_list|,
name|ent
argument_list|,
name|PFS_DELEN
argument_list|)
expr_stmt|;
comment|/* XXX waste of cycles */
name|offset
operator|+=
name|PFS_DELEN
expr_stmt|;
name|resid
operator|-=
name|PFS_DELEN
expr_stmt|;
name|ent
operator|+=
name|PFS_DELEN
expr_stmt|;
block|}
name|sx_sunlock
argument_list|(
operator|&
name|allproc_lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|uiomove
argument_list|(
name|buf
argument_list|,
name|ent
operator|-
name|buf
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|,
name|M_IOV
argument_list|)
expr_stmt|;
name|PFS_RETURN
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Read a symbolic link  */
end_comment

begin_function
specifier|static
name|int
name|pfs_readlink
parameter_list|(
name|struct
name|vop_readlink_args
modifier|*
name|va
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vn
init|=
name|va
operator|->
name|a_vp
decl_stmt|;
name|struct
name|pfs_vdata
modifier|*
name|pvd
init|=
operator|(
expr|struct
name|pfs_vdata
operator|*
operator|)
name|vn
operator|->
name|v_data
decl_stmt|;
name|struct
name|pfs_node
modifier|*
name|pn
init|=
name|pvd
operator|->
name|pvd_pn
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
init|=
name|va
operator|->
name|a_uio
decl_stmt|;
name|struct
name|proc
modifier|*
name|proc
init|=
name|NULL
decl_stmt|;
name|char
name|buf
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|struct
name|sbuf
name|sb
decl_stmt|;
name|int
name|error
decl_stmt|;
name|PFS_TRACE
argument_list|(
operator|(
name|pn
operator|->
name|pn_name
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vn
operator|->
name|v_type
operator|!=
name|VLNK
condition|)
name|PFS_RETURN
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|pn
operator|->
name|pn_func
operator|==
name|NULL
condition|)
name|PFS_RETURN
argument_list|(
name|EIO
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvd
operator|->
name|pvd_pid
operator|!=
name|NO_PID
condition|)
block|{
if|if
condition|(
operator|(
name|proc
operator|=
name|pfind
argument_list|(
name|pvd
operator|->
name|pvd_pid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|PFS_RETURN
argument_list|(
name|EIO
argument_list|)
expr_stmt|;
name|_PHOLD
argument_list|(
name|proc
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|proc
argument_list|)
expr_stmt|;
block|}
comment|/* sbuf_new() can't fail with a static buffer */
name|sbuf_new
argument_list|(
operator|&
name|sb
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
call|(
name|pn
operator|->
name|pn_func
call|)
argument_list|(
name|curthread
argument_list|,
name|proc
argument_list|,
name|pn
argument_list|,
operator|&
name|sb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|proc
operator|!=
name|NULL
condition|)
name|PRELE
argument_list|(
name|proc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|sbuf_delete
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|PFS_RETURN
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
name|sbuf_finish
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|error
operator|=
name|uiomove_frombuf
argument_list|(
name|sbuf_data
argument_list|(
operator|&
name|sb
argument_list|)
argument_list|,
name|sbuf_len
argument_list|(
operator|&
name|sb
argument_list|)
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|PFS_RETURN
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reclaim a vnode  */
end_comment

begin_function
specifier|static
name|int
name|pfs_reclaim
parameter_list|(
name|struct
name|vop_reclaim_args
modifier|*
name|va
parameter_list|)
block|{
name|PFS_TRACE
argument_list|(
operator|(
operator|(
operator|(
expr|struct
name|pfs_vdata
operator|*
operator|)
name|va
operator|->
name|a_vp
operator|->
name|v_data
operator|)
operator|->
name|pvd_pn
operator|->
name|pn_name
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|pfs_vncache_free
argument_list|(
name|va
operator|->
name|a_vp
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set attributes  */
end_comment

begin_function
specifier|static
name|int
name|pfs_setattr
parameter_list|(
name|struct
name|vop_setattr_args
modifier|*
name|va
parameter_list|)
block|{
name|PFS_TRACE
argument_list|(
operator|(
operator|(
operator|(
expr|struct
name|pfs_vdata
operator|*
operator|)
name|va
operator|->
name|a_vp
operator|->
name|v_data
operator|)
operator|->
name|pvd_pn
operator|->
name|pn_name
operator|)
argument_list|)
expr_stmt|;
name|PFS_RETURN
argument_list|(
name|EOPNOTSUPP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Read from a file  */
end_comment

begin_function
specifier|static
name|int
name|pfs_write
parameter_list|(
name|struct
name|vop_write_args
modifier|*
name|va
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vn
init|=
name|va
operator|->
name|a_vp
decl_stmt|;
name|struct
name|pfs_vdata
modifier|*
name|pvd
init|=
operator|(
expr|struct
name|pfs_vdata
operator|*
operator|)
name|vn
operator|->
name|v_data
decl_stmt|;
name|struct
name|pfs_node
modifier|*
name|pn
init|=
name|pvd
operator|->
name|pvd_pn
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
init|=
name|va
operator|->
name|a_uio
decl_stmt|;
name|struct
name|proc
modifier|*
name|proc
init|=
name|NULL
decl_stmt|;
name|struct
name|sbuf
name|sb
decl_stmt|;
name|int
name|error
decl_stmt|;
name|PFS_TRACE
argument_list|(
operator|(
name|pn
operator|->
name|pn_name
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vn
operator|->
name|v_type
operator|!=
name|VREG
condition|)
name|PFS_RETURN
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|pn
operator|->
name|pn_flags
operator|&
name|PFS_WR
operator|)
condition|)
name|PFS_RETURN
argument_list|(
name|EBADF
argument_list|)
expr_stmt|;
if|if
condition|(
name|pn
operator|->
name|pn_func
operator|==
name|NULL
condition|)
name|PFS_RETURN
argument_list|(
name|EIO
argument_list|)
expr_stmt|;
comment|/* 	 * This is necessary because either process' privileges may 	 * have changed since the open() call. 	 */
if|if
condition|(
operator|!
name|pfs_visible
argument_list|(
name|curthread
argument_list|,
name|pn
argument_list|,
name|pvd
operator|->
name|pvd_pid
argument_list|)
condition|)
name|PFS_RETURN
argument_list|(
name|EIO
argument_list|)
expr_stmt|;
comment|/* XXX duplicates bits of pfs_visible() */
if|if
condition|(
name|pvd
operator|->
name|pvd_pid
operator|!=
name|NO_PID
condition|)
block|{
if|if
condition|(
operator|(
name|proc
operator|=
name|pfind
argument_list|(
name|pvd
operator|->
name|pvd_pid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|PFS_RETURN
argument_list|(
name|EIO
argument_list|)
expr_stmt|;
name|_PHOLD
argument_list|(
name|proc
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|proc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pn
operator|->
name|pn_flags
operator|&
name|PFS_RAWWR
condition|)
block|{
name|error
operator|=
call|(
name|pn
operator|->
name|pn_func
call|)
argument_list|(
name|curthread
argument_list|,
name|proc
argument_list|,
name|pn
argument_list|,
name|NULL
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|proc
operator|!=
name|NULL
condition|)
name|PRELE
argument_list|(
name|proc
argument_list|)
expr_stmt|;
name|PFS_RETURN
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
name|sbuf_uionew
argument_list|(
operator|&
name|sb
argument_list|,
name|uio
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|PFS_RETURN
argument_list|(
name|error
argument_list|)
expr_stmt|;
name|error
operator|=
call|(
name|pn
operator|->
name|pn_func
call|)
argument_list|(
name|curthread
argument_list|,
name|proc
argument_list|,
name|pn
argument_list|,
operator|&
name|sb
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|proc
operator|!=
name|NULL
condition|)
name|PRELE
argument_list|(
name|proc
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|PFS_RETURN
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Vnode operations  */
end_comment

begin_decl_stmt
name|struct
name|vop_vector
name|pfs_vnodeops
init|=
block|{
operator|.
name|vop_default
operator|=
operator|&
name|default_vnodeops
block|,
operator|.
name|vop_access
operator|=
name|pfs_access
block|,
operator|.
name|vop_close
operator|=
name|pfs_close
block|,
operator|.
name|vop_create
operator|=
name|VOP_EOPNOTSUPP
block|,
operator|.
name|vop_getattr
operator|=
name|pfs_getattr
block|,
operator|.
name|vop_getextattr
operator|=
name|pfs_getextattr
block|,
operator|.
name|vop_ioctl
operator|=
name|pfs_ioctl
block|,
operator|.
name|vop_link
operator|=
name|VOP_EOPNOTSUPP
block|,
operator|.
name|vop_lookup
operator|=
name|pfs_lookup
block|,
operator|.
name|vop_mkdir
operator|=
name|VOP_EOPNOTSUPP
block|,
operator|.
name|vop_mknod
operator|=
name|VOP_EOPNOTSUPP
block|,
operator|.
name|vop_open
operator|=
name|pfs_open
block|,
operator|.
name|vop_read
operator|=
name|pfs_read
block|,
operator|.
name|vop_readdir
operator|=
name|pfs_readdir
block|,
operator|.
name|vop_readlink
operator|=
name|pfs_readlink
block|,
operator|.
name|vop_reclaim
operator|=
name|pfs_reclaim
block|,
operator|.
name|vop_remove
operator|=
name|VOP_EOPNOTSUPP
block|,
operator|.
name|vop_rename
operator|=
name|VOP_EOPNOTSUPP
block|,
operator|.
name|vop_rmdir
operator|=
name|VOP_EOPNOTSUPP
block|,
operator|.
name|vop_setattr
operator|=
name|pfs_setattr
block|,
operator|.
name|vop_symlink
operator|=
name|VOP_EOPNOTSUPP
block|,
operator|.
name|vop_write
operator|=
name|pfs_write
block|,
comment|/* XXX I've probably forgotten a few that need VOP_EOPNOTSUPP */
block|}
decl_stmt|;
end_decl_stmt

end_unit

