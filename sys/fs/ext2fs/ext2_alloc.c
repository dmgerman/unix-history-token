begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  *  modified for Lites 1.1  *  *  Aug 1995, Godmar Back (gback@cs.utah.edu)  *  University of Utah, Department of Computer Science  */
end_comment

begin_comment
comment|/*-  * Copyright (c) 1982, 1986, 1989, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)ffs_alloc.c	8.8 (Berkeley) 2/21/94  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<fs/ext2fs/fs.h>
end_include

begin_include
include|#
directive|include
file|<fs/ext2fs/inode.h>
end_include

begin_include
include|#
directive|include
file|<fs/ext2fs/ext2_mount.h>
end_include

begin_include
include|#
directive|include
file|<fs/ext2fs/ext2fs.h>
end_include

begin_include
include|#
directive|include
file|<fs/ext2fs/ext2_extern.h>
end_include

begin_function_decl
specifier|static
name|daddr_t
name|ext2_alloccg
parameter_list|(
name|struct
name|inode
modifier|*
parameter_list|,
name|int
parameter_list|,
name|daddr_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|daddr_t
name|ext2_clusteralloc
parameter_list|(
name|struct
name|inode
modifier|*
parameter_list|,
name|int
parameter_list|,
name|daddr_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_long
name|ext2_dirpref
parameter_list|(
name|struct
name|inode
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ext2_fserr
parameter_list|(
name|struct
name|m_ext2fs
modifier|*
parameter_list|,
name|uid_t
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_long
name|ext2_hashalloc
parameter_list|(
name|struct
name|inode
modifier|*
parameter_list|,
name|int
parameter_list|,
name|long
parameter_list|,
name|int
parameter_list|,
name|daddr_t
function_decl|(
modifier|*
function_decl|)
parameter_list|(
name|struct
name|inode
modifier|*
parameter_list|,
name|int
parameter_list|,
name|daddr_t
parameter_list|,
name|int
parameter_list|)
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|daddr_t
name|ext2_nodealloccg
parameter_list|(
name|struct
name|inode
modifier|*
parameter_list|,
name|int
parameter_list|,
name|daddr_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|daddr_t
name|ext2_mapsearch
parameter_list|(
name|struct
name|m_ext2fs
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|daddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Allocate a block in the filesystem.  *  * A preference may be optionally specified. If a preference is given  * the following hierarchy is used to allocate a block:  *   1) allocate the requested block.  *   2) allocate a rotationally optimal block in the same cylinder.  *   3) allocate a block in the same cylinder group.  *   4) quadradically rehash into other cylinder groups, until an  *        available block is located.  * If no block preference is given the following hierarchy is used  * to allocate a block:  *   1) allocate a block in the cylinder group that contains the  *        inode for the file.  *   2) quadradically rehash into other cylinder groups, until an  *        available block is located.  */
end_comment

begin_function
name|int
name|ext2_alloc
parameter_list|(
name|struct
name|inode
modifier|*
name|ip
parameter_list|,
name|daddr_t
name|lbn
parameter_list|,
name|e4fs_daddr_t
name|bpref
parameter_list|,
name|int
name|size
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|e4fs_daddr_t
modifier|*
name|bnp
parameter_list|)
block|{
name|struct
name|m_ext2fs
modifier|*
name|fs
decl_stmt|;
name|struct
name|ext2mount
modifier|*
name|ump
decl_stmt|;
name|int32_t
name|bno
decl_stmt|;
name|int
name|cg
decl_stmt|;
operator|*
name|bnp
operator|=
literal|0
expr_stmt|;
name|fs
operator|=
name|ip
operator|->
name|i_e2fs
expr_stmt|;
name|ump
operator|=
name|ip
operator|->
name|i_ump
expr_stmt|;
name|mtx_assert
argument_list|(
name|EXT2_MTX
argument_list|(
name|ump
argument_list|)
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
if|if
condition|(
operator|(
name|u_int
operator|)
name|size
operator|>
name|fs
operator|->
name|e2fs_bsize
operator|||
name|blkoff
argument_list|(
name|fs
argument_list|,
name|size
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|vn_printf
argument_list|(
name|ip
operator|->
name|i_devvp
argument_list|,
literal|"bsize = %lu, size = %d, fs = %s\n"
argument_list|,
operator|(
name|long
name|unsigned
name|int
operator|)
name|fs
operator|->
name|e2fs_bsize
argument_list|,
name|size
argument_list|,
name|fs
operator|->
name|e2fs_fsmnt
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"ext2_alloc: bad size"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cred
operator|==
name|NOCRED
condition|)
name|panic
argument_list|(
literal|"ext2_alloc: missing credential"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* INVARIANTS */
if|if
condition|(
name|size
operator|==
name|fs
operator|->
name|e2fs_bsize
operator|&&
name|fs
operator|->
name|e2fs
operator|->
name|e2fs_fbcount
operator|==
literal|0
condition|)
goto|goto
name|nospace
goto|;
if|if
condition|(
name|cred
operator|->
name|cr_uid
operator|!=
literal|0
operator|&&
name|fs
operator|->
name|e2fs
operator|->
name|e2fs_fbcount
operator|<
name|fs
operator|->
name|e2fs
operator|->
name|e2fs_rbcount
condition|)
goto|goto
name|nospace
goto|;
if|if
condition|(
name|bpref
operator|>=
name|fs
operator|->
name|e2fs
operator|->
name|e2fs_bcount
condition|)
name|bpref
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bpref
operator|==
literal|0
condition|)
name|cg
operator|=
name|ino_to_cg
argument_list|(
name|fs
argument_list|,
name|ip
operator|->
name|i_number
argument_list|)
expr_stmt|;
else|else
name|cg
operator|=
name|dtog
argument_list|(
name|fs
argument_list|,
name|bpref
argument_list|)
expr_stmt|;
name|bno
operator|=
operator|(
name|daddr_t
operator|)
name|ext2_hashalloc
argument_list|(
name|ip
argument_list|,
name|cg
argument_list|,
name|bpref
argument_list|,
name|fs
operator|->
name|e2fs_bsize
argument_list|,
name|ext2_alloccg
argument_list|)
expr_stmt|;
if|if
condition|(
name|bno
operator|>
literal|0
condition|)
block|{
comment|/* set next_alloc fields as done in block_getblk */
name|ip
operator|->
name|i_next_alloc_block
operator|=
name|lbn
expr_stmt|;
name|ip
operator|->
name|i_next_alloc_goal
operator|=
name|bno
expr_stmt|;
name|ip
operator|->
name|i_blocks
operator|+=
name|btodb
argument_list|(
name|fs
operator|->
name|e2fs_bsize
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_flag
operator||=
name|IN_CHANGE
operator||
name|IN_UPDATE
expr_stmt|;
operator|*
name|bnp
operator|=
name|bno
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|nospace
label|:
name|EXT2_UNLOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|ext2_fserr
argument_list|(
name|fs
argument_list|,
name|cred
operator|->
name|cr_uid
argument_list|,
literal|"filesystem full"
argument_list|)
expr_stmt|;
name|uprintf
argument_list|(
literal|"\n%s: write failed, filesystem is full\n"
argument_list|,
name|fs
operator|->
name|e2fs_fsmnt
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOSPC
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Reallocate a sequence of blocks into a contiguous sequence of blocks.  *  * The vnode and an array of buffer pointers for a range of sequential  * logical blocks to be made contiguous is given. The allocator attempts  * to find a range of sequential blocks starting as close as possible to  * an fs_rotdelay offset from the end of the allocation for the logical  * block immediately preceding the current range. If successful, the  * physical block numbers in the buffer pointers and in the inode are  * changed to reflect the new allocation. If unsuccessful, the allocation  * is left unchanged. The success in doing the reallocation is returned.  * Note that the error return is not reflected back to the user. Rather  * the previous block allocation will be used.  */
end_comment

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_vfs
argument_list|,
name|OID_AUTO
argument_list|,
name|ext2fs
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"EXT2FS filesystem"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|doasyncfree
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_ext2fs
argument_list|,
name|OID_AUTO
argument_list|,
name|doasyncfree
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|doasyncfree
argument_list|,
literal|0
argument_list|,
literal|"Use asychronous writes to update block pointers when freeing blocks"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|doreallocblks
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_ext2fs
argument_list|,
name|OID_AUTO
argument_list|,
name|doreallocblks
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|doreallocblks
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|ext2_reallocblks
parameter_list|(
name|struct
name|vop_reallocblks_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|m_ext2fs
modifier|*
name|fs
decl_stmt|;
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|buf
modifier|*
name|sbp
decl_stmt|,
modifier|*
name|ebp
decl_stmt|;
name|uint32_t
modifier|*
name|bap
decl_stmt|,
modifier|*
name|sbap
decl_stmt|,
modifier|*
name|ebap
decl_stmt|;
name|struct
name|ext2mount
modifier|*
name|ump
decl_stmt|;
name|struct
name|cluster_save
modifier|*
name|buflist
decl_stmt|;
name|struct
name|indir
name|start_ap
index|[
name|NIADDR
operator|+
literal|1
index|]
decl_stmt|,
name|end_ap
index|[
name|NIADDR
operator|+
literal|1
index|]
decl_stmt|,
modifier|*
name|idp
decl_stmt|;
name|e2fs_lbn_t
name|start_lbn
decl_stmt|,
name|end_lbn
decl_stmt|;
name|int
name|soff
decl_stmt|;
name|e2fs_daddr_t
name|newblk
decl_stmt|,
name|blkno
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
decl_stmt|,
name|start_lvl
decl_stmt|,
name|end_lvl
decl_stmt|,
name|pref
decl_stmt|,
name|ssize
decl_stmt|;
if|if
condition|(
name|doreallocblks
operator|==
literal|0
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
name|vp
operator|=
name|ap
operator|->
name|a_vp
expr_stmt|;
name|ip
operator|=
name|VTOI
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|fs
operator|=
name|ip
operator|->
name|i_e2fs
expr_stmt|;
name|ump
operator|=
name|ip
operator|->
name|i_ump
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|e2fs_contigsumsize
operator|<=
literal|0
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
name|buflist
operator|=
name|ap
operator|->
name|a_buflist
expr_stmt|;
name|len
operator|=
name|buflist
operator|->
name|bs_nchildren
expr_stmt|;
name|start_lbn
operator|=
name|buflist
operator|->
name|bs_children
index|[
literal|0
index|]
operator|->
name|b_lblkno
expr_stmt|;
name|end_lbn
operator|=
name|start_lbn
operator|+
name|len
operator|-
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|buflist
operator|->
name|bs_children
index|[
name|i
index|]
operator|->
name|b_lblkno
operator|!=
name|start_lbn
operator|+
name|i
condition|)
name|panic
argument_list|(
literal|"ext2_reallocblks: non-cluster"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * If the cluster crosses the boundary for the first indirect 	 * block, leave space for the indirect block. Indirect blocks 	 * are initially laid out in a position after the last direct 	 * block. Block reallocation would usually destroy locality by 	 * moving the indirect block out of the way to make room for 	 * data blocks if we didn't compensate here. We should also do 	 * this for other indirect block boundaries, but it is only 	 * important for the first one. 	 */
if|if
condition|(
name|start_lbn
operator|<
name|NDADDR
operator|&&
name|end_lbn
operator|>=
name|NDADDR
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
comment|/* 	 * If the latest allocation is in a new cylinder group, assume that 	 * the filesystem has decided to move and do not force it back to 	 * the previous cylinder group. 	 */
if|if
condition|(
name|dtog
argument_list|(
name|fs
argument_list|,
name|dbtofsb
argument_list|(
name|fs
argument_list|,
name|buflist
operator|->
name|bs_children
index|[
literal|0
index|]
operator|->
name|b_blkno
argument_list|)
argument_list|)
operator|!=
name|dtog
argument_list|(
name|fs
argument_list|,
name|dbtofsb
argument_list|(
name|fs
argument_list|,
name|buflist
operator|->
name|bs_children
index|[
name|len
operator|-
literal|1
index|]
operator|->
name|b_blkno
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
if|if
condition|(
name|ext2_getlbns
argument_list|(
name|vp
argument_list|,
name|start_lbn
argument_list|,
name|start_ap
argument_list|,
operator|&
name|start_lvl
argument_list|)
operator|||
name|ext2_getlbns
argument_list|(
name|vp
argument_list|,
name|end_lbn
argument_list|,
name|end_ap
argument_list|,
operator|&
name|end_lvl
argument_list|)
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
comment|/* 	 * Get the starting offset and block map for the first block. 	 */
if|if
condition|(
name|start_lvl
operator|==
literal|0
condition|)
block|{
name|sbap
operator|=
operator|&
name|ip
operator|->
name|i_db
index|[
literal|0
index|]
expr_stmt|;
name|soff
operator|=
name|start_lbn
expr_stmt|;
block|}
else|else
block|{
name|idp
operator|=
operator|&
name|start_ap
index|[
name|start_lvl
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|bread
argument_list|(
name|vp
argument_list|,
name|idp
operator|->
name|in_lbn
argument_list|,
operator|(
name|int
operator|)
name|fs
operator|->
name|e2fs_bsize
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|sbp
argument_list|)
condition|)
block|{
name|brelse
argument_list|(
name|sbp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOSPC
operator|)
return|;
block|}
name|sbap
operator|=
operator|(
name|u_int
operator|*
operator|)
name|sbp
operator|->
name|b_data
expr_stmt|;
name|soff
operator|=
name|idp
operator|->
name|in_off
expr_stmt|;
block|}
comment|/* 	 * If the block range spans two block maps, get the second map. 	 */
name|ebap
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|end_lvl
operator|==
literal|0
operator|||
operator|(
name|idp
operator|=
operator|&
name|end_ap
index|[
name|end_lvl
operator|-
literal|1
index|]
operator|)
operator|->
name|in_off
operator|+
literal|1
operator|>=
name|len
condition|)
block|{
name|ssize
operator|=
name|len
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
if|if
condition|(
name|start_ap
index|[
name|start_lvl
operator|-
literal|1
index|]
operator|.
name|in_lbn
operator|==
name|idp
operator|->
name|in_lbn
condition|)
name|panic
argument_list|(
literal|"ext2_reallocblks: start == end"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ssize
operator|=
name|len
operator|-
operator|(
name|idp
operator|->
name|in_off
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|bread
argument_list|(
name|vp
argument_list|,
name|idp
operator|->
name|in_lbn
argument_list|,
operator|(
name|int
operator|)
name|fs
operator|->
name|e2fs_bsize
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|ebp
argument_list|)
condition|)
goto|goto
name|fail
goto|;
name|ebap
operator|=
operator|(
name|u_int
operator|*
operator|)
name|ebp
operator|->
name|b_data
expr_stmt|;
block|}
comment|/* 	 * Find the preferred location for the cluster. 	 */
name|EXT2_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|pref
operator|=
name|ext2_blkpref
argument_list|(
name|ip
argument_list|,
name|start_lbn
argument_list|,
name|soff
argument_list|,
name|sbap
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Search the block map looking for an allocation of the desired size. 	 */
if|if
condition|(
operator|(
name|newblk
operator|=
operator|(
name|e2fs_daddr_t
operator|)
name|ext2_hashalloc
argument_list|(
name|ip
argument_list|,
name|dtog
argument_list|(
name|fs
argument_list|,
name|pref
argument_list|)
argument_list|,
name|pref
argument_list|,
name|len
argument_list|,
name|ext2_clusteralloc
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|EXT2_UNLOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* 	 * We have found a new contiguous block. 	 * 	 * First we have to replace the old block pointers with the new 	 * block pointers in the inode and indirect blocks associated 	 * with the file. 	 */
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"realloc: ino %ju, lbns %jd-%jd\n\told:"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|ip
operator|->
name|i_number
argument_list|,
operator|(
name|intmax_t
operator|)
name|start_lbn
argument_list|,
operator|(
name|intmax_t
operator|)
name|end_lbn
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|blkno
operator|=
name|newblk
expr_stmt|;
for|for
control|(
name|bap
operator|=
operator|&
name|sbap
index|[
name|soff
index|]
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
operator|,
name|blkno
operator|+=
name|fs
operator|->
name|e2fs_fpb
control|)
block|{
if|if
condition|(
name|i
operator|==
name|ssize
condition|)
block|{
name|bap
operator|=
name|ebap
expr_stmt|;
name|soff
operator|=
operator|-
name|i
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|INVARIANTS
if|if
condition|(
name|buflist
operator|->
name|bs_children
index|[
name|i
index|]
operator|->
name|b_blkno
operator|!=
name|fsbtodb
argument_list|(
name|fs
argument_list|,
operator|*
name|bap
argument_list|)
condition|)
name|panic
argument_list|(
literal|"ext2_reallocblks: alloc mismatch"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|" %d,"
argument_list|,
operator|*
name|bap
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
operator|*
name|bap
operator|++
operator|=
name|blkno
expr_stmt|;
block|}
comment|/* 	 * Next we must write out the modified inode and indirect blocks. 	 * For strict correctness, the writes should be synchronous since 	 * the old block values may have been written to disk. In practise 	 * they are almost never written, but if we are concerned about  	 * strict correctness, the `doasyncfree' flag should be set to zero. 	 * 	 * The test on `doasyncfree' should be changed to test a flag 	 * that shows whether the associated buffers and inodes have 	 * been written. The flag should be set when the cluster is 	 * started and cleared whenever the buffer or inode is flushed. 	 * We can then check below to see if it is set, and do the 	 * synchronous write only when it has been cleared. 	 */
if|if
condition|(
name|sbap
operator|!=
operator|&
name|ip
operator|->
name|i_db
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
name|doasyncfree
condition|)
name|bdwrite
argument_list|(
name|sbp
argument_list|)
expr_stmt|;
else|else
name|bwrite
argument_list|(
name|sbp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ip
operator|->
name|i_flag
operator||=
name|IN_CHANGE
operator||
name|IN_UPDATE
expr_stmt|;
if|if
condition|(
operator|!
name|doasyncfree
condition|)
name|ext2_update
argument_list|(
name|vp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ssize
operator|<
name|len
condition|)
block|{
if|if
condition|(
name|doasyncfree
condition|)
name|bdwrite
argument_list|(
name|ebp
argument_list|)
expr_stmt|;
else|else
name|bwrite
argument_list|(
name|ebp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Last, free the old blocks and assign the new blocks to the buffers. 	 */
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"\n\tnew:"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
for|for
control|(
name|blkno
operator|=
name|newblk
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
operator|,
name|blkno
operator|+=
name|fs
operator|->
name|e2fs_fpb
control|)
block|{
name|ext2_blkfree
argument_list|(
name|ip
argument_list|,
name|dbtofsb
argument_list|(
name|fs
argument_list|,
name|buflist
operator|->
name|bs_children
index|[
name|i
index|]
operator|->
name|b_blkno
argument_list|)
argument_list|,
name|fs
operator|->
name|e2fs_bsize
argument_list|)
expr_stmt|;
name|buflist
operator|->
name|bs_children
index|[
name|i
index|]
operator|->
name|b_blkno
operator|=
name|fsbtodb
argument_list|(
name|fs
argument_list|,
name|blkno
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|" %d,"
argument_list|,
name|blkno
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
if|if
condition|(
name|ssize
operator|<
name|len
condition|)
name|brelse
argument_list|(
name|ebp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sbap
operator|!=
operator|&
name|ip
operator|->
name|i_db
index|[
literal|0
index|]
condition|)
name|brelse
argument_list|(
name|sbp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOSPC
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate an inode in the filesystem.  *   */
end_comment

begin_function
name|int
name|ext2_valloc
parameter_list|(
name|struct
name|vnode
modifier|*
name|pvp
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
parameter_list|)
block|{
name|struct
name|timespec
name|ts
decl_stmt|;
name|struct
name|inode
modifier|*
name|pip
decl_stmt|;
name|struct
name|m_ext2fs
modifier|*
name|fs
decl_stmt|;
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
name|struct
name|ext2mount
modifier|*
name|ump
decl_stmt|;
name|ino_t
name|ino
decl_stmt|,
name|ipref
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|,
name|cg
decl_stmt|;
operator|*
name|vpp
operator|=
name|NULL
expr_stmt|;
name|pip
operator|=
name|VTOI
argument_list|(
name|pvp
argument_list|)
expr_stmt|;
name|fs
operator|=
name|pip
operator|->
name|i_e2fs
expr_stmt|;
name|ump
operator|=
name|pip
operator|->
name|i_ump
expr_stmt|;
name|EXT2_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|e2fs
operator|->
name|e2fs_ficount
operator|==
literal|0
condition|)
goto|goto
name|noinodes
goto|;
comment|/* 	 * If it is a directory then obtain a cylinder group based on 	 * ext2_dirpref else obtain it using ino_to_cg. The preferred inode is 	 * always the next inode. 	 */
if|if
condition|(
operator|(
name|mode
operator|&
name|IFMT
operator|)
operator|==
name|IFDIR
condition|)
block|{
name|cg
operator|=
name|ext2_dirpref
argument_list|(
name|pip
argument_list|)
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|e2fs_contigdirs
index|[
name|cg
index|]
operator|<
literal|255
condition|)
name|fs
operator|->
name|e2fs_contigdirs
index|[
name|cg
index|]
operator|++
expr_stmt|;
block|}
else|else
block|{
name|cg
operator|=
name|ino_to_cg
argument_list|(
name|fs
argument_list|,
name|pip
operator|->
name|i_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|e2fs_contigdirs
index|[
name|cg
index|]
operator|>
literal|0
condition|)
name|fs
operator|->
name|e2fs_contigdirs
index|[
name|cg
index|]
operator|--
expr_stmt|;
block|}
name|ipref
operator|=
name|cg
operator|*
name|fs
operator|->
name|e2fs
operator|->
name|e2fs_ipg
operator|+
literal|1
expr_stmt|;
name|ino
operator|=
operator|(
name|ino_t
operator|)
name|ext2_hashalloc
argument_list|(
name|pip
argument_list|,
name|cg
argument_list|,
operator|(
name|long
operator|)
name|ipref
argument_list|,
name|mode
argument_list|,
name|ext2_nodealloccg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ino
operator|==
literal|0
condition|)
goto|goto
name|noinodes
goto|;
name|error
operator|=
name|VFS_VGET
argument_list|(
name|pvp
operator|->
name|v_mount
argument_list|,
name|ino
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
name|vpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|ext2_vfree
argument_list|(
name|pvp
argument_list|,
name|ino
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|ip
operator|=
name|VTOI
argument_list|(
operator|*
name|vpp
argument_list|)
expr_stmt|;
comment|/* 	 * The question is whether using VGET was such good idea at all: 	 * Linux doesn't read the old inode in when it is allocating a 	 * new one. I will set at least i_size and i_blocks to zero. 	 */
name|ip
operator|->
name|i_flag
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|i_size
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|i_blocks
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|i_mode
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|i_flags
operator|=
literal|0
expr_stmt|;
comment|/* now we want to make sure that the block pointers are zeroed out */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NDADDR
condition|;
name|i
operator|++
control|)
name|ip
operator|->
name|i_db
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NIADDR
condition|;
name|i
operator|++
control|)
name|ip
operator|->
name|i_ib
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Set up a new generation number for this inode. 	 */
name|ip
operator|->
name|i_gen
operator|=
name|arc4random
argument_list|()
expr_stmt|;
name|vfs_timestamp
argument_list|(
operator|&
name|ts
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_birthtime
operator|=
name|ts
operator|.
name|tv_sec
expr_stmt|;
name|ip
operator|->
name|i_birthnsec
operator|=
name|ts
operator|.
name|tv_nsec
expr_stmt|;
comment|/* printf("ext2_valloc: allocated inode %d\n", ino); */
return|return
operator|(
literal|0
operator|)
return|;
name|noinodes
label|:
name|EXT2_UNLOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|ext2_fserr
argument_list|(
name|fs
argument_list|,
name|cred
operator|->
name|cr_uid
argument_list|,
literal|"out of inodes"
argument_list|)
expr_stmt|;
name|uprintf
argument_list|(
literal|"\n%s: create/symlink failed, no inodes free\n"
argument_list|,
name|fs
operator|->
name|e2fs_fsmnt
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOSPC
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find a cylinder to place a directory.  *  * The policy implemented by this algorithm is to allocate a  * directory inode in the same cylinder group as its parent  * directory, but also to reserve space for its files inodes  * and data. Restrict the number of directories which may be  * allocated one after another in the same cylinder group  * without intervening allocation of files.  *  * If we allocate a first level directory then force allocation  * in another cylinder group.  *  */
end_comment

begin_function
specifier|static
name|u_long
name|ext2_dirpref
parameter_list|(
name|struct
name|inode
modifier|*
name|pip
parameter_list|)
block|{
name|struct
name|m_ext2fs
modifier|*
name|fs
decl_stmt|;
name|int
name|cg
decl_stmt|,
name|prefcg
decl_stmt|,
name|cgsize
decl_stmt|;
name|u_int
name|avgifree
decl_stmt|,
name|avgbfree
decl_stmt|,
name|avgndir
decl_stmt|,
name|curdirsize
decl_stmt|;
name|u_int
name|minifree
decl_stmt|,
name|minbfree
decl_stmt|,
name|maxndir
decl_stmt|;
name|u_int
name|mincg
decl_stmt|,
name|minndir
decl_stmt|;
name|u_int
name|dirsize
decl_stmt|,
name|maxcontigdirs
decl_stmt|;
name|mtx_assert
argument_list|(
name|EXT2_MTX
argument_list|(
name|pip
operator|->
name|i_ump
argument_list|)
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|fs
operator|=
name|pip
operator|->
name|i_e2fs
expr_stmt|;
name|avgifree
operator|=
name|fs
operator|->
name|e2fs
operator|->
name|e2fs_ficount
operator|/
name|fs
operator|->
name|e2fs_gcount
expr_stmt|;
name|avgbfree
operator|=
name|fs
operator|->
name|e2fs
operator|->
name|e2fs_fbcount
operator|/
name|fs
operator|->
name|e2fs_gcount
expr_stmt|;
name|avgndir
operator|=
name|fs
operator|->
name|e2fs_total_dir
operator|/
name|fs
operator|->
name|e2fs_gcount
expr_stmt|;
comment|/* 	 * Force allocation in another cg if creating a first level dir. 	 */
name|ASSERT_VOP_LOCKED
argument_list|(
name|ITOV
argument_list|(
name|pip
argument_list|)
argument_list|,
literal|"ext2fs_dirpref"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ITOV
argument_list|(
name|pip
argument_list|)
operator|->
name|v_vflag
operator|&
name|VV_ROOT
condition|)
block|{
name|prefcg
operator|=
name|arc4random
argument_list|()
operator|%
name|fs
operator|->
name|e2fs_gcount
expr_stmt|;
name|mincg
operator|=
name|prefcg
expr_stmt|;
name|minndir
operator|=
name|fs
operator|->
name|e2fs_ipg
expr_stmt|;
for|for
control|(
name|cg
operator|=
name|prefcg
init|;
name|cg
operator|<
name|fs
operator|->
name|e2fs_gcount
condition|;
name|cg
operator|++
control|)
if|if
condition|(
name|fs
operator|->
name|e2fs_gd
index|[
name|cg
index|]
operator|.
name|ext2bgd_ndirs
operator|<
name|minndir
operator|&&
name|fs
operator|->
name|e2fs_gd
index|[
name|cg
index|]
operator|.
name|ext2bgd_nifree
operator|>=
name|avgifree
operator|&&
name|fs
operator|->
name|e2fs_gd
index|[
name|cg
index|]
operator|.
name|ext2bgd_nbfree
operator|>=
name|avgbfree
condition|)
block|{
name|mincg
operator|=
name|cg
expr_stmt|;
name|minndir
operator|=
name|fs
operator|->
name|e2fs_gd
index|[
name|cg
index|]
operator|.
name|ext2bgd_ndirs
expr_stmt|;
block|}
for|for
control|(
name|cg
operator|=
literal|0
init|;
name|cg
operator|<
name|prefcg
condition|;
name|cg
operator|++
control|)
if|if
condition|(
name|fs
operator|->
name|e2fs_gd
index|[
name|cg
index|]
operator|.
name|ext2bgd_ndirs
operator|<
name|minndir
operator|&&
name|fs
operator|->
name|e2fs_gd
index|[
name|cg
index|]
operator|.
name|ext2bgd_nifree
operator|>=
name|avgifree
operator|&&
name|fs
operator|->
name|e2fs_gd
index|[
name|cg
index|]
operator|.
name|ext2bgd_nbfree
operator|>=
name|avgbfree
condition|)
block|{
name|mincg
operator|=
name|cg
expr_stmt|;
name|minndir
operator|=
name|fs
operator|->
name|e2fs_gd
index|[
name|cg
index|]
operator|.
name|ext2bgd_ndirs
expr_stmt|;
block|}
return|return
operator|(
name|mincg
operator|)
return|;
block|}
comment|/* 	 * Count various limits which used for 	 * optimal allocation of a directory inode. 	 */
name|maxndir
operator|=
name|min
argument_list|(
name|avgndir
operator|+
name|fs
operator|->
name|e2fs_ipg
operator|/
literal|16
argument_list|,
name|fs
operator|->
name|e2fs_ipg
argument_list|)
expr_stmt|;
name|minifree
operator|=
name|avgifree
operator|-
name|avgifree
operator|/
literal|4
expr_stmt|;
if|if
condition|(
name|minifree
operator|<
literal|1
condition|)
name|minifree
operator|=
literal|1
expr_stmt|;
name|minbfree
operator|=
name|avgbfree
operator|-
name|avgbfree
operator|/
literal|4
expr_stmt|;
if|if
condition|(
name|minbfree
operator|<
literal|1
condition|)
name|minbfree
operator|=
literal|1
expr_stmt|;
name|cgsize
operator|=
name|fs
operator|->
name|e2fs_fsize
operator|*
name|fs
operator|->
name|e2fs_fpg
expr_stmt|;
name|dirsize
operator|=
name|AVGDIRSIZE
expr_stmt|;
name|curdirsize
operator|=
name|avgndir
condition|?
operator|(
name|cgsize
operator|-
name|avgbfree
operator|*
name|fs
operator|->
name|e2fs_bsize
operator|)
operator|/
name|avgndir
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|dirsize
operator|<
name|curdirsize
condition|)
name|dirsize
operator|=
name|curdirsize
expr_stmt|;
name|maxcontigdirs
operator|=
name|min
argument_list|(
operator|(
name|avgbfree
operator|*
name|fs
operator|->
name|e2fs_bsize
operator|)
operator|/
name|dirsize
argument_list|,
literal|255
argument_list|)
expr_stmt|;
name|maxcontigdirs
operator|=
name|min
argument_list|(
name|maxcontigdirs
argument_list|,
name|fs
operator|->
name|e2fs_ipg
operator|/
name|AFPDIR
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxcontigdirs
operator|==
literal|0
condition|)
name|maxcontigdirs
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Limit number of dirs in one cg and reserve space for  	 * regular files, but only if we have no deficit in 	 * inodes or space. 	 */
name|prefcg
operator|=
name|ino_to_cg
argument_list|(
name|fs
argument_list|,
name|pip
operator|->
name|i_number
argument_list|)
expr_stmt|;
for|for
control|(
name|cg
operator|=
name|prefcg
init|;
name|cg
operator|<
name|fs
operator|->
name|e2fs_gcount
condition|;
name|cg
operator|++
control|)
if|if
condition|(
name|fs
operator|->
name|e2fs_gd
index|[
name|cg
index|]
operator|.
name|ext2bgd_ndirs
operator|<
name|maxndir
operator|&&
name|fs
operator|->
name|e2fs_gd
index|[
name|cg
index|]
operator|.
name|ext2bgd_nifree
operator|>=
name|minifree
operator|&&
name|fs
operator|->
name|e2fs_gd
index|[
name|cg
index|]
operator|.
name|ext2bgd_nbfree
operator|>=
name|minbfree
condition|)
block|{
if|if
condition|(
name|fs
operator|->
name|e2fs_contigdirs
index|[
name|cg
index|]
operator|<
name|maxcontigdirs
condition|)
return|return
operator|(
name|cg
operator|)
return|;
block|}
for|for
control|(
name|cg
operator|=
literal|0
init|;
name|cg
operator|<
name|prefcg
condition|;
name|cg
operator|++
control|)
if|if
condition|(
name|fs
operator|->
name|e2fs_gd
index|[
name|cg
index|]
operator|.
name|ext2bgd_ndirs
operator|<
name|maxndir
operator|&&
name|fs
operator|->
name|e2fs_gd
index|[
name|cg
index|]
operator|.
name|ext2bgd_nifree
operator|>=
name|minifree
operator|&&
name|fs
operator|->
name|e2fs_gd
index|[
name|cg
index|]
operator|.
name|ext2bgd_nbfree
operator|>=
name|minbfree
condition|)
block|{
if|if
condition|(
name|fs
operator|->
name|e2fs_contigdirs
index|[
name|cg
index|]
operator|<
name|maxcontigdirs
condition|)
return|return
operator|(
name|cg
operator|)
return|;
block|}
comment|/* 	 * This is a backstop when we have deficit in space. 	 */
for|for
control|(
name|cg
operator|=
name|prefcg
init|;
name|cg
operator|<
name|fs
operator|->
name|e2fs_gcount
condition|;
name|cg
operator|++
control|)
if|if
condition|(
name|fs
operator|->
name|e2fs_gd
index|[
name|cg
index|]
operator|.
name|ext2bgd_nifree
operator|>=
name|avgifree
condition|)
return|return
operator|(
name|cg
operator|)
return|;
for|for
control|(
name|cg
operator|=
literal|0
init|;
name|cg
operator|<
name|prefcg
condition|;
name|cg
operator|++
control|)
if|if
condition|(
name|fs
operator|->
name|e2fs_gd
index|[
name|cg
index|]
operator|.
name|ext2bgd_nifree
operator|>=
name|avgifree
condition|)
break|break;
return|return
operator|(
name|cg
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Select the desired position for the next block in a file.    *  * we try to mimic what Remy does in inode_getblk/block_getblk  *  * we note: blocknr == 0 means that we're about to allocate either  * a direct block or a pointer block at the first level of indirection  * (In other words, stuff that will go in i_db[] or i_ib[])  *  * blocknr != 0 means that we're allocating a block that is none  * of the above. Then, blocknr tells us the number of the block  * that will hold the pointer  */
end_comment

begin_function
name|e4fs_daddr_t
name|ext2_blkpref
parameter_list|(
name|struct
name|inode
modifier|*
name|ip
parameter_list|,
name|e2fs_lbn_t
name|lbn
parameter_list|,
name|int
name|indx
parameter_list|,
name|e2fs_daddr_t
modifier|*
name|bap
parameter_list|,
name|e2fs_daddr_t
name|blocknr
parameter_list|)
block|{
name|int
name|tmp
decl_stmt|;
name|mtx_assert
argument_list|(
name|EXT2_MTX
argument_list|(
name|ip
operator|->
name|i_ump
argument_list|)
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* if the next block is actually what we thought it is, 	   then set the goal to what we thought it should be 	*/
if|if
condition|(
name|ip
operator|->
name|i_next_alloc_block
operator|==
name|lbn
operator|&&
name|ip
operator|->
name|i_next_alloc_goal
operator|!=
literal|0
condition|)
return|return
name|ip
operator|->
name|i_next_alloc_goal
return|;
comment|/* now check whether we were provided with an array that basically 	   tells us previous blocks to which we want to stay closeby 	*/
if|if
condition|(
name|bap
condition|)
for|for
control|(
name|tmp
operator|=
name|indx
operator|-
literal|1
init|;
name|tmp
operator|>=
literal|0
condition|;
name|tmp
operator|--
control|)
if|if
condition|(
name|bap
index|[
name|tmp
index|]
condition|)
return|return
name|bap
index|[
name|tmp
index|]
return|;
comment|/* else let's fall back to the blocknr, or, if there is none, 	   follow the rule that a block should be allocated near its inode 	*/
return|return
name|blocknr
condition|?
name|blocknr
else|:
call|(
name|e2fs_daddr_t
call|)
argument_list|(
name|ip
operator|->
name|i_block_group
operator|*
name|EXT2_BLOCKS_PER_GROUP
argument_list|(
name|ip
operator|->
name|i_e2fs
argument_list|)
argument_list|)
operator|+
name|ip
operator|->
name|i_e2fs
operator|->
name|e2fs
operator|->
name|e2fs_first_dblock
return|;
block|}
end_function

begin_comment
comment|/*  * Implement the cylinder overflow algorithm.  *  * The policy implemented by this algorithm is:  *   1) allocate the block in its requested cylinder group.  *   2) quadradically rehash on the cylinder group number.  *   3) brute force search for a free block.  */
end_comment

begin_function
specifier|static
name|u_long
name|ext2_hashalloc
parameter_list|(
name|struct
name|inode
modifier|*
name|ip
parameter_list|,
name|int
name|cg
parameter_list|,
name|long
name|pref
parameter_list|,
name|int
name|size
parameter_list|,
name|daddr_t
function_decl|(
modifier|*
name|allocator
function_decl|)
parameter_list|(
name|struct
name|inode
modifier|*
parameter_list|,
name|int
parameter_list|,
name|daddr_t
parameter_list|,
name|int
parameter_list|)
parameter_list|)
block|{
name|struct
name|m_ext2fs
modifier|*
name|fs
decl_stmt|;
name|ino_t
name|result
decl_stmt|;
name|int
name|i
decl_stmt|,
name|icg
init|=
name|cg
decl_stmt|;
name|mtx_assert
argument_list|(
name|EXT2_MTX
argument_list|(
name|ip
operator|->
name|i_ump
argument_list|)
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|fs
operator|=
name|ip
operator|->
name|i_e2fs
expr_stmt|;
comment|/* 	 * 1: preferred cylinder group 	 */
name|result
operator|=
call|(
modifier|*
name|allocator
call|)
argument_list|(
name|ip
argument_list|,
name|cg
argument_list|,
name|pref
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
return|return
operator|(
name|result
operator|)
return|;
comment|/* 	 * 2: quadratic rehash 	 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|fs
operator|->
name|e2fs_gcount
condition|;
name|i
operator|*=
literal|2
control|)
block|{
name|cg
operator|+=
name|i
expr_stmt|;
if|if
condition|(
name|cg
operator|>=
name|fs
operator|->
name|e2fs_gcount
condition|)
name|cg
operator|-=
name|fs
operator|->
name|e2fs_gcount
expr_stmt|;
name|result
operator|=
call|(
modifier|*
name|allocator
call|)
argument_list|(
name|ip
argument_list|,
name|cg
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
return|return
operator|(
name|result
operator|)
return|;
block|}
comment|/* 	 * 3: brute force search 	 * Note that we start at i == 2, since 0 was checked initially, 	 * and 1 is always checked in the quadratic rehash. 	 */
name|cg
operator|=
operator|(
name|icg
operator|+
literal|2
operator|)
operator|%
name|fs
operator|->
name|e2fs_gcount
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|fs
operator|->
name|e2fs_gcount
condition|;
name|i
operator|++
control|)
block|{
name|result
operator|=
call|(
modifier|*
name|allocator
call|)
argument_list|(
name|ip
argument_list|,
name|cg
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|cg
operator|++
expr_stmt|;
if|if
condition|(
name|cg
operator|==
name|fs
operator|->
name|e2fs_gcount
condition|)
name|cg
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Determine whether a block can be allocated.  *  * Check to see if a block of the appropriate size is available,  * and if it is, allocate it.  */
end_comment

begin_function
specifier|static
name|daddr_t
name|ext2_alloccg
parameter_list|(
name|struct
name|inode
modifier|*
name|ip
parameter_list|,
name|int
name|cg
parameter_list|,
name|daddr_t
name|bpref
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|struct
name|m_ext2fs
modifier|*
name|fs
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|ext2mount
modifier|*
name|ump
decl_stmt|;
name|daddr_t
name|bno
decl_stmt|,
name|runstart
decl_stmt|,
name|runlen
decl_stmt|;
name|int
name|bit
decl_stmt|,
name|loc
decl_stmt|,
name|end
decl_stmt|,
name|error
decl_stmt|,
name|start
decl_stmt|;
name|char
modifier|*
name|bbp
decl_stmt|;
comment|/* XXX ondisk32 */
name|fs
operator|=
name|ip
operator|->
name|i_e2fs
expr_stmt|;
name|ump
operator|=
name|ip
operator|->
name|i_ump
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|e2fs_gd
index|[
name|cg
index|]
operator|.
name|ext2bgd_nbfree
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|EXT2_UNLOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|error
operator|=
name|bread
argument_list|(
name|ip
operator|->
name|i_devvp
argument_list|,
name|fsbtodb
argument_list|(
name|fs
argument_list|,
name|fs
operator|->
name|e2fs_gd
index|[
name|cg
index|]
operator|.
name|ext2bgd_b_bitmap
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|fs
operator|->
name|e2fs_bsize
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|EXT2_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|fs
operator|->
name|e2fs_gd
index|[
name|cg
index|]
operator|.
name|ext2bgd_nbfree
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Another thread allocated the last block in this 		 * group while we were waiting for the buffer. 		 */
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|EXT2_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|bbp
operator|=
operator|(
name|char
operator|*
operator|)
name|bp
operator|->
name|b_data
expr_stmt|;
if|if
condition|(
name|dtog
argument_list|(
name|fs
argument_list|,
name|bpref
argument_list|)
operator|!=
name|cg
condition|)
name|bpref
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bpref
operator|!=
literal|0
condition|)
block|{
name|bpref
operator|=
name|dtogd
argument_list|(
name|fs
argument_list|,
name|bpref
argument_list|)
expr_stmt|;
comment|/* 		 * if the requested block is available, use it 		 */
if|if
condition|(
name|isclr
argument_list|(
name|bbp
argument_list|,
name|bpref
argument_list|)
condition|)
block|{
name|bno
operator|=
name|bpref
expr_stmt|;
goto|goto
name|gotit
goto|;
block|}
block|}
comment|/* 	 * no blocks in the requested cylinder, so take next 	 * available one in this cylinder group. 	 * first try to get 8 contigous blocks, then fall back to a single 	 * block. 	 */
if|if
condition|(
name|bpref
condition|)
name|start
operator|=
name|dtogd
argument_list|(
name|fs
argument_list|,
name|bpref
argument_list|)
operator|/
name|NBBY
expr_stmt|;
else|else
name|start
operator|=
literal|0
expr_stmt|;
name|end
operator|=
name|howmany
argument_list|(
name|fs
operator|->
name|e2fs
operator|->
name|e2fs_fpg
argument_list|,
name|NBBY
argument_list|)
operator|-
name|start
expr_stmt|;
name|retry
label|:
name|runlen
operator|=
literal|0
expr_stmt|;
name|runstart
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|loc
operator|=
name|start
init|;
name|loc
operator|<
name|end
condition|;
name|loc
operator|++
control|)
block|{
if|if
condition|(
name|bbp
index|[
name|loc
index|]
operator|==
operator|(
name|char
operator|)
literal|0xff
condition|)
block|{
name|runlen
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
comment|/* Start of a run, find the number of high clear bits. */
if|if
condition|(
name|runlen
operator|==
literal|0
condition|)
block|{
name|bit
operator|=
name|fls
argument_list|(
name|bbp
index|[
name|loc
index|]
argument_list|)
expr_stmt|;
name|runlen
operator|=
name|NBBY
operator|-
name|bit
expr_stmt|;
name|runstart
operator|=
name|loc
operator|*
name|NBBY
operator|+
name|bit
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bbp
index|[
name|loc
index|]
operator|==
literal|0
condition|)
block|{
comment|/* Continue a run. */
name|runlen
operator|+=
name|NBBY
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Finish the current run.  If it isn't long 			 * enough, start a new one. 			 */
name|bit
operator|=
name|ffs
argument_list|(
name|bbp
index|[
name|loc
index|]
argument_list|)
operator|-
literal|1
expr_stmt|;
name|runlen
operator|+=
name|bit
expr_stmt|;
if|if
condition|(
name|runlen
operator|>=
literal|8
condition|)
block|{
name|bno
operator|=
name|runstart
expr_stmt|;
goto|goto
name|gotit
goto|;
block|}
comment|/* Run was too short, start a new one. */
name|bit
operator|=
name|fls
argument_list|(
name|bbp
index|[
name|loc
index|]
argument_list|)
expr_stmt|;
name|runlen
operator|=
name|NBBY
operator|-
name|bit
expr_stmt|;
name|runstart
operator|=
name|loc
operator|*
name|NBBY
operator|+
name|bit
expr_stmt|;
block|}
comment|/* If the current run is long enough, use it. */
if|if
condition|(
name|runlen
operator|>=
literal|8
condition|)
block|{
name|bno
operator|=
name|runstart
expr_stmt|;
goto|goto
name|gotit
goto|;
block|}
block|}
if|if
condition|(
name|start
operator|!=
literal|0
condition|)
block|{
name|end
operator|=
name|start
expr_stmt|;
name|start
operator|=
literal|0
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|bno
operator|=
name|ext2_mapsearch
argument_list|(
name|fs
argument_list|,
name|bbp
argument_list|,
name|bpref
argument_list|)
expr_stmt|;
if|if
condition|(
name|bno
operator|<
literal|0
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|EXT2_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|gotit
label|:
ifdef|#
directive|ifdef
name|INVARIANTS
if|if
condition|(
name|isset
argument_list|(
name|bbp
argument_list|,
name|bno
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"ext2fs_alloccgblk: cg=%d bno=%jd fs=%s\n"
argument_list|,
name|cg
argument_list|,
operator|(
name|intmax_t
operator|)
name|bno
argument_list|,
name|fs
operator|->
name|e2fs_fsmnt
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"ext2fs_alloccg: dup alloc"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|setbit
argument_list|(
name|bbp
argument_list|,
name|bno
argument_list|)
expr_stmt|;
name|EXT2_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|ext2_clusteracct
argument_list|(
name|fs
argument_list|,
name|bbp
argument_list|,
name|cg
argument_list|,
name|bno
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fs
operator|->
name|e2fs
operator|->
name|e2fs_fbcount
operator|--
expr_stmt|;
name|fs
operator|->
name|e2fs_gd
index|[
name|cg
index|]
operator|.
name|ext2bgd_nbfree
operator|--
expr_stmt|;
name|fs
operator|->
name|e2fs_fmod
operator|=
literal|1
expr_stmt|;
name|EXT2_UNLOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|bdwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|cg
operator|*
name|fs
operator|->
name|e2fs
operator|->
name|e2fs_fpg
operator|+
name|fs
operator|->
name|e2fs
operator|->
name|e2fs_first_dblock
operator|+
name|bno
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Determine whether a cluster can be allocated.  */
end_comment

begin_function
specifier|static
name|daddr_t
name|ext2_clusteralloc
parameter_list|(
name|struct
name|inode
modifier|*
name|ip
parameter_list|,
name|int
name|cg
parameter_list|,
name|daddr_t
name|bpref
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|m_ext2fs
modifier|*
name|fs
decl_stmt|;
name|struct
name|ext2mount
modifier|*
name|ump
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|char
modifier|*
name|bbp
decl_stmt|;
name|int
name|bit
decl_stmt|,
name|error
decl_stmt|,
name|got
decl_stmt|,
name|i
decl_stmt|,
name|loc
decl_stmt|,
name|run
decl_stmt|;
name|int32_t
modifier|*
name|lp
decl_stmt|;
name|daddr_t
name|bno
decl_stmt|;
name|fs
operator|=
name|ip
operator|->
name|i_e2fs
expr_stmt|;
name|ump
operator|=
name|ip
operator|->
name|i_ump
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|e2fs_maxcluster
index|[
name|cg
index|]
operator|<
name|len
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|EXT2_UNLOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|error
operator|=
name|bread
argument_list|(
name|ip
operator|->
name|i_devvp
argument_list|,
name|fsbtodb
argument_list|(
name|fs
argument_list|,
name|fs
operator|->
name|e2fs_gd
index|[
name|cg
index|]
operator|.
name|ext2bgd_b_bitmap
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|fs
operator|->
name|e2fs_bsize
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|fail_lock
goto|;
name|bbp
operator|=
operator|(
name|char
operator|*
operator|)
name|bp
operator|->
name|b_data
expr_stmt|;
name|EXT2_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
comment|/* 	 * Check to see if a cluster of the needed size (or bigger) is 	 * available in this cylinder group. 	 */
name|lp
operator|=
operator|&
name|fs
operator|->
name|e2fs_clustersum
index|[
name|cg
index|]
operator|.
name|cs_sum
index|[
name|len
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|len
init|;
name|i
operator|<=
name|fs
operator|->
name|e2fs_contigsumsize
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|*
name|lp
operator|++
operator|>
literal|0
condition|)
break|break;
if|if
condition|(
name|i
operator|>
name|fs
operator|->
name|e2fs_contigsumsize
condition|)
block|{
comment|/* 		 * Update the cluster summary information to reflect 		 * the true maximum-sized cluster so that future cluster 		 * allocation requests can avoid reading the bitmap only 		 * to find no cluster. 		 */
name|lp
operator|=
operator|&
name|fs
operator|->
name|e2fs_clustersum
index|[
name|cg
index|]
operator|.
name|cs_sum
index|[
name|len
operator|-
literal|1
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|len
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
operator|*
name|lp
operator|--
operator|>
literal|0
condition|)
break|break;
name|fs
operator|->
name|e2fs_maxcluster
index|[
name|cg
index|]
operator|=
name|i
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|EXT2_UNLOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
comment|/* Search the bitmap to find a big enough cluster like in FFS. */
if|if
condition|(
name|dtog
argument_list|(
name|fs
argument_list|,
name|bpref
argument_list|)
operator|!=
name|cg
condition|)
name|bpref
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bpref
operator|!=
literal|0
condition|)
name|bpref
operator|=
name|dtogd
argument_list|(
name|fs
argument_list|,
name|bpref
argument_list|)
expr_stmt|;
name|loc
operator|=
name|bpref
operator|/
name|NBBY
expr_stmt|;
name|bit
operator|=
literal|1
operator|<<
operator|(
name|bpref
operator|%
name|NBBY
operator|)
expr_stmt|;
for|for
control|(
name|run
operator|=
literal|0
operator|,
name|got
operator|=
name|bpref
init|;
name|got
operator|<
name|fs
operator|->
name|e2fs
operator|->
name|e2fs_fpg
condition|;
name|got
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|bbp
index|[
name|loc
index|]
operator|&
name|bit
operator|)
operator|!=
literal|0
condition|)
name|run
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|run
operator|++
expr_stmt|;
if|if
condition|(
name|run
operator|==
name|len
condition|)
break|break;
block|}
if|if
condition|(
operator|(
name|got
operator|&
operator|(
name|NBBY
operator|-
literal|1
operator|)
operator|)
operator|!=
operator|(
name|NBBY
operator|-
literal|1
operator|)
condition|)
name|bit
operator|<<=
literal|1
expr_stmt|;
else|else
block|{
name|loc
operator|++
expr_stmt|;
name|bit
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|got
operator|>=
name|fs
operator|->
name|e2fs
operator|->
name|e2fs_fpg
condition|)
goto|goto
name|fail_lock
goto|;
comment|/* Allocate the cluster that we found. */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|isclr
argument_list|(
name|bbp
argument_list|,
name|got
operator|-
name|run
operator|+
name|i
argument_list|)
condition|)
name|panic
argument_list|(
literal|"ext2_clusteralloc: map mismatch"
argument_list|)
expr_stmt|;
name|bno
operator|=
name|got
operator|-
name|run
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|bno
operator|>=
name|fs
operator|->
name|e2fs
operator|->
name|e2fs_fpg
condition|)
name|panic
argument_list|(
literal|"ext2_clusteralloc: allocated out of group"
argument_list|)
expr_stmt|;
name|EXT2_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|+=
name|fs
operator|->
name|e2fs_fpb
control|)
block|{
name|setbit
argument_list|(
name|bbp
argument_list|,
name|bno
operator|+
name|i
argument_list|)
expr_stmt|;
name|ext2_clusteracct
argument_list|(
name|fs
argument_list|,
name|bbp
argument_list|,
name|cg
argument_list|,
name|bno
operator|+
name|i
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fs
operator|->
name|e2fs
operator|->
name|e2fs_fbcount
operator|--
expr_stmt|;
name|fs
operator|->
name|e2fs_gd
index|[
name|cg
index|]
operator|.
name|ext2bgd_nbfree
operator|--
expr_stmt|;
block|}
name|fs
operator|->
name|e2fs_fmod
operator|=
literal|1
expr_stmt|;
name|EXT2_UNLOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|bdwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|cg
operator|*
name|fs
operator|->
name|e2fs
operator|->
name|e2fs_fpg
operator|+
name|fs
operator|->
name|e2fs
operator|->
name|e2fs_first_dblock
operator|+
name|bno
operator|)
return|;
name|fail_lock
label|:
name|EXT2_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|fail
label|:
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Determine whether an inode can be allocated.  *  * Check to see if an inode is available, and if it is,  * allocate it using tode in the specified cylinder group.  */
end_comment

begin_function
specifier|static
name|daddr_t
name|ext2_nodealloccg
parameter_list|(
name|struct
name|inode
modifier|*
name|ip
parameter_list|,
name|int
name|cg
parameter_list|,
name|daddr_t
name|ipref
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|struct
name|m_ext2fs
modifier|*
name|fs
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|ext2mount
modifier|*
name|ump
decl_stmt|;
name|int
name|error
decl_stmt|,
name|start
decl_stmt|,
name|len
decl_stmt|;
name|char
modifier|*
name|ibp
decl_stmt|,
modifier|*
name|loc
decl_stmt|;
name|ipref
operator|--
expr_stmt|;
comment|/* to avoid a lot of (ipref -1) */
if|if
condition|(
name|ipref
operator|==
operator|-
literal|1
condition|)
name|ipref
operator|=
literal|0
expr_stmt|;
name|fs
operator|=
name|ip
operator|->
name|i_e2fs
expr_stmt|;
name|ump
operator|=
name|ip
operator|->
name|i_ump
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|e2fs_gd
index|[
name|cg
index|]
operator|.
name|ext2bgd_nifree
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|EXT2_UNLOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|error
operator|=
name|bread
argument_list|(
name|ip
operator|->
name|i_devvp
argument_list|,
name|fsbtodb
argument_list|(
name|fs
argument_list|,
name|fs
operator|->
name|e2fs_gd
index|[
name|cg
index|]
operator|.
name|ext2bgd_i_bitmap
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|fs
operator|->
name|e2fs_bsize
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|EXT2_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|fs
operator|->
name|e2fs_gd
index|[
name|cg
index|]
operator|.
name|ext2bgd_nifree
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Another thread allocated the last i-node in this 		 * group while we were waiting for the buffer. 		 */
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|EXT2_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ibp
operator|=
operator|(
name|char
operator|*
operator|)
name|bp
operator|->
name|b_data
expr_stmt|;
if|if
condition|(
name|ipref
condition|)
block|{
name|ipref
operator|%=
name|fs
operator|->
name|e2fs
operator|->
name|e2fs_ipg
expr_stmt|;
if|if
condition|(
name|isclr
argument_list|(
name|ibp
argument_list|,
name|ipref
argument_list|)
condition|)
goto|goto
name|gotit
goto|;
block|}
name|start
operator|=
name|ipref
operator|/
name|NBBY
expr_stmt|;
name|len
operator|=
name|howmany
argument_list|(
name|fs
operator|->
name|e2fs
operator|->
name|e2fs_ipg
operator|-
name|ipref
argument_list|,
name|NBBY
argument_list|)
expr_stmt|;
name|loc
operator|=
name|memcchr
argument_list|(
operator|&
name|ibp
index|[
name|start
index|]
argument_list|,
literal|0xff
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|loc
operator|==
name|NULL
condition|)
block|{
name|len
operator|=
name|start
operator|+
literal|1
expr_stmt|;
name|start
operator|=
literal|0
expr_stmt|;
name|loc
operator|=
name|memcchr
argument_list|(
operator|&
name|ibp
index|[
name|start
index|]
argument_list|,
literal|0xff
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|loc
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"cg = %d, ipref = %lld, fs = %s\n"
argument_list|,
name|cg
argument_list|,
operator|(
name|long
name|long
operator|)
name|ipref
argument_list|,
name|fs
operator|->
name|e2fs_fsmnt
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"ext2fs_nodealloccg: map corrupted"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
name|ipref
operator|=
operator|(
name|loc
operator|-
name|ibp
operator|)
operator|*
name|NBBY
operator|+
name|ffs
argument_list|(
operator|~
operator|*
name|loc
argument_list|)
operator|-
literal|1
expr_stmt|;
name|gotit
label|:
name|setbit
argument_list|(
name|ibp
argument_list|,
name|ipref
argument_list|)
expr_stmt|;
name|EXT2_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|fs
operator|->
name|e2fs_gd
index|[
name|cg
index|]
operator|.
name|ext2bgd_nifree
operator|--
expr_stmt|;
name|fs
operator|->
name|e2fs
operator|->
name|e2fs_ficount
operator|--
expr_stmt|;
name|fs
operator|->
name|e2fs_fmod
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|mode
operator|&
name|IFMT
operator|)
operator|==
name|IFDIR
condition|)
block|{
name|fs
operator|->
name|e2fs_gd
index|[
name|cg
index|]
operator|.
name|ext2bgd_ndirs
operator|++
expr_stmt|;
name|fs
operator|->
name|e2fs_total_dir
operator|++
expr_stmt|;
block|}
name|EXT2_UNLOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|bdwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|cg
operator|*
name|fs
operator|->
name|e2fs
operator|->
name|e2fs_ipg
operator|+
name|ipref
operator|+
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free a block or fragment.  *  */
end_comment

begin_function
name|void
name|ext2_blkfree
parameter_list|(
name|struct
name|inode
modifier|*
name|ip
parameter_list|,
name|e4fs_daddr_t
name|bno
parameter_list|,
name|long
name|size
parameter_list|)
block|{
name|struct
name|m_ext2fs
modifier|*
name|fs
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|ext2mount
modifier|*
name|ump
decl_stmt|;
name|int
name|cg
decl_stmt|,
name|error
decl_stmt|;
name|char
modifier|*
name|bbp
decl_stmt|;
name|fs
operator|=
name|ip
operator|->
name|i_e2fs
expr_stmt|;
name|ump
operator|=
name|ip
operator|->
name|i_ump
expr_stmt|;
name|cg
operator|=
name|dtog
argument_list|(
name|fs
argument_list|,
name|bno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|u_int
operator|)
name|bno
operator|>=
name|fs
operator|->
name|e2fs
operator|->
name|e2fs_bcount
condition|)
block|{
name|printf
argument_list|(
literal|"bad block %lld, ino %ju\n"
argument_list|,
operator|(
name|long
name|long
operator|)
name|bno
argument_list|,
operator|(
name|uintmax_t
operator|)
name|ip
operator|->
name|i_number
argument_list|)
expr_stmt|;
name|ext2_fserr
argument_list|(
name|fs
argument_list|,
name|ip
operator|->
name|i_uid
argument_list|,
literal|"bad block"
argument_list|)
expr_stmt|;
return|return;
block|}
name|error
operator|=
name|bread
argument_list|(
name|ip
operator|->
name|i_devvp
argument_list|,
name|fsbtodb
argument_list|(
name|fs
argument_list|,
name|fs
operator|->
name|e2fs_gd
index|[
name|cg
index|]
operator|.
name|ext2bgd_b_bitmap
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|fs
operator|->
name|e2fs_bsize
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
name|bbp
operator|=
operator|(
name|char
operator|*
operator|)
name|bp
operator|->
name|b_data
expr_stmt|;
name|bno
operator|=
name|dtogd
argument_list|(
name|fs
argument_list|,
name|bno
argument_list|)
expr_stmt|;
if|if
condition|(
name|isclr
argument_list|(
name|bbp
argument_list|,
name|bno
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"block = %lld, fs = %s\n"
argument_list|,
operator|(
name|long
name|long
operator|)
name|bno
argument_list|,
name|fs
operator|->
name|e2fs_fsmnt
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"ext2_blkfree: freeing free block"
argument_list|)
expr_stmt|;
block|}
name|clrbit
argument_list|(
name|bbp
argument_list|,
name|bno
argument_list|)
expr_stmt|;
name|EXT2_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|ext2_clusteracct
argument_list|(
name|fs
argument_list|,
name|bbp
argument_list|,
name|cg
argument_list|,
name|bno
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fs
operator|->
name|e2fs
operator|->
name|e2fs_fbcount
operator|++
expr_stmt|;
name|fs
operator|->
name|e2fs_gd
index|[
name|cg
index|]
operator|.
name|ext2bgd_nbfree
operator|++
expr_stmt|;
name|fs
operator|->
name|e2fs_fmod
operator|=
literal|1
expr_stmt|;
name|EXT2_UNLOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|bdwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free an inode.  *  */
end_comment

begin_function
name|int
name|ext2_vfree
parameter_list|(
name|struct
name|vnode
modifier|*
name|pvp
parameter_list|,
name|ino_t
name|ino
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|struct
name|m_ext2fs
modifier|*
name|fs
decl_stmt|;
name|struct
name|inode
modifier|*
name|pip
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|ext2mount
modifier|*
name|ump
decl_stmt|;
name|int
name|error
decl_stmt|,
name|cg
decl_stmt|;
name|char
modifier|*
name|ibp
decl_stmt|;
name|pip
operator|=
name|VTOI
argument_list|(
name|pvp
argument_list|)
expr_stmt|;
name|fs
operator|=
name|pip
operator|->
name|i_e2fs
expr_stmt|;
name|ump
operator|=
name|pip
operator|->
name|i_ump
expr_stmt|;
if|if
condition|(
operator|(
name|u_int
operator|)
name|ino
operator|>
name|fs
operator|->
name|e2fs_ipg
operator|*
name|fs
operator|->
name|e2fs_gcount
condition|)
name|panic
argument_list|(
literal|"ext2_vfree: range: devvp = %p, ino = %ju, fs = %s"
argument_list|,
name|pip
operator|->
name|i_devvp
argument_list|,
operator|(
name|uintmax_t
operator|)
name|ino
argument_list|,
name|fs
operator|->
name|e2fs_fsmnt
argument_list|)
expr_stmt|;
name|cg
operator|=
name|ino_to_cg
argument_list|(
name|fs
argument_list|,
name|ino
argument_list|)
expr_stmt|;
name|error
operator|=
name|bread
argument_list|(
name|pip
operator|->
name|i_devvp
argument_list|,
name|fsbtodb
argument_list|(
name|fs
argument_list|,
name|fs
operator|->
name|e2fs_gd
index|[
name|cg
index|]
operator|.
name|ext2bgd_i_bitmap
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|fs
operator|->
name|e2fs_bsize
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ibp
operator|=
operator|(
name|char
operator|*
operator|)
name|bp
operator|->
name|b_data
expr_stmt|;
name|ino
operator|=
operator|(
name|ino
operator|-
literal|1
operator|)
operator|%
name|fs
operator|->
name|e2fs
operator|->
name|e2fs_ipg
expr_stmt|;
if|if
condition|(
name|isclr
argument_list|(
name|ibp
argument_list|,
name|ino
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"ino = %llu, fs = %s\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|ino
argument_list|,
name|fs
operator|->
name|e2fs_fsmnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|e2fs_ronly
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"ext2_vfree: freeing free inode"
argument_list|)
expr_stmt|;
block|}
name|clrbit
argument_list|(
name|ibp
argument_list|,
name|ino
argument_list|)
expr_stmt|;
name|EXT2_LOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|fs
operator|->
name|e2fs
operator|->
name|e2fs_ficount
operator|++
expr_stmt|;
name|fs
operator|->
name|e2fs_gd
index|[
name|cg
index|]
operator|.
name|ext2bgd_nifree
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|mode
operator|&
name|IFMT
operator|)
operator|==
name|IFDIR
condition|)
block|{
name|fs
operator|->
name|e2fs_gd
index|[
name|cg
index|]
operator|.
name|ext2bgd_ndirs
operator|--
expr_stmt|;
name|fs
operator|->
name|e2fs_total_dir
operator|--
expr_stmt|;
block|}
name|fs
operator|->
name|e2fs_fmod
operator|=
literal|1
expr_stmt|;
name|EXT2_UNLOCK
argument_list|(
name|ump
argument_list|)
expr_stmt|;
name|bdwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find a block in the specified cylinder group.  *  * It is a panic if a request is made to find a block if none are  * available.  */
end_comment

begin_function
specifier|static
name|daddr_t
name|ext2_mapsearch
parameter_list|(
name|struct
name|m_ext2fs
modifier|*
name|fs
parameter_list|,
name|char
modifier|*
name|bbp
parameter_list|,
name|daddr_t
name|bpref
parameter_list|)
block|{
name|char
modifier|*
name|loc
decl_stmt|;
name|int
name|start
decl_stmt|,
name|len
decl_stmt|;
comment|/* 	 * find the fragment by searching through the free block 	 * map for an appropriate bit pattern 	 */
if|if
condition|(
name|bpref
condition|)
name|start
operator|=
name|dtogd
argument_list|(
name|fs
argument_list|,
name|bpref
argument_list|)
operator|/
name|NBBY
expr_stmt|;
else|else
name|start
operator|=
literal|0
expr_stmt|;
name|len
operator|=
name|howmany
argument_list|(
name|fs
operator|->
name|e2fs
operator|->
name|e2fs_fpg
argument_list|,
name|NBBY
argument_list|)
operator|-
name|start
expr_stmt|;
name|loc
operator|=
name|memcchr
argument_list|(
operator|&
name|bbp
index|[
name|start
index|]
argument_list|,
literal|0xff
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|loc
operator|==
name|NULL
condition|)
block|{
name|len
operator|=
name|start
operator|+
literal|1
expr_stmt|;
name|start
operator|=
literal|0
expr_stmt|;
name|loc
operator|=
name|memcchr
argument_list|(
operator|&
name|bbp
index|[
name|start
index|]
argument_list|,
literal|0xff
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|loc
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"start = %d, len = %d, fs = %s\n"
argument_list|,
name|start
argument_list|,
name|len
argument_list|,
name|fs
operator|->
name|e2fs_fsmnt
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"ext2_mapsearch: map corrupted"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
return|return
operator|(
operator|(
name|loc
operator|-
name|bbp
operator|)
operator|*
name|NBBY
operator|+
name|ffs
argument_list|(
operator|~
operator|*
name|loc
argument_list|)
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Fserr prints the name of a filesystem with an error diagnostic.  *   * The form of the error message is:  *	fs: error message  */
end_comment

begin_function
specifier|static
name|void
name|ext2_fserr
parameter_list|(
name|struct
name|m_ext2fs
modifier|*
name|fs
parameter_list|,
name|uid_t
name|uid
parameter_list|,
name|char
modifier|*
name|cp
parameter_list|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"uid %u on %s: %s\n"
argument_list|,
name|uid
argument_list|,
name|fs
operator|->
name|e2fs_fsmnt
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|cg_has_sb
parameter_list|(
name|int
name|i
parameter_list|)
block|{
name|int
name|a3
decl_stmt|,
name|a5
decl_stmt|,
name|a7
decl_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
operator|||
name|i
operator|==
literal|1
condition|)
return|return
literal|1
return|;
for|for
control|(
name|a3
operator|=
literal|3
operator|,
name|a5
operator|=
literal|5
operator|,
name|a7
operator|=
literal|7
init|;
name|a3
operator|<=
name|i
operator|||
name|a5
operator|<=
name|i
operator|||
name|a7
operator|<=
name|i
condition|;
name|a3
operator|*=
literal|3
operator|,
name|a5
operator|*=
literal|5
operator|,
name|a7
operator|*=
literal|7
control|)
if|if
condition|(
name|i
operator|==
name|a3
operator|||
name|i
operator|==
name|a5
operator|||
name|i
operator|==
name|a7
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

end_unit

