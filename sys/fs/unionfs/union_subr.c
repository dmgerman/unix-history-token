begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1994 Jan-Simon Pendry  * Copyright (c) 1994  *	The Regents of the University of California.  All rights reserved.  * Copyright (c) 2005, 2006 Masanori Ozawa<ozawa@ongs.co.jp>, ONGS Inc.  * Copyright (c) 2006 Daichi Goto<daichi@freebsd.org>  *  * This code is derived from software contributed to Berkeley by  * Jan-Simon Pendry.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)union_subr.c	8.20 (Berkeley) 5/20/95  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/dirent.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/filedesc.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|MAC
end_ifdef

begin_include
include|#
directive|include
file|<sys/mac.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<fs/unionfs/union.h>
end_include

begin_define
define|#
directive|define
name|NUNIONFSNODECACHE
value|32
end_define

begin_define
define|#
directive|define
name|UNIONFS_NHASH
parameter_list|(
name|upper
parameter_list|,
name|lower
parameter_list|)
define|\
value|(&unionfs_node_hashtbl[(((uintptr_t)upper + (uintptr_t)lower)>> 8)& unionfs_node_hash])
end_define

begin_expr_stmt
specifier|static
name|LIST_HEAD
argument_list|(
name|unionfs_node_hashhead
argument_list|,
name|unionfs_node
argument_list|)
operator|*
name|unionfs_node_hashtbl
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_long
name|unionfs_node_hash
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mtx
name|unionfs_hashmtx
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_UNIONFSHASH
argument_list|,
literal|"UNIONFS hash"
argument_list|,
literal|"UNIONFS hash table"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_UNIONFSNODE
argument_list|,
literal|"UNIONFS node"
argument_list|,
literal|"UNIONFS vnode private part"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_UNIONFSPATH
argument_list|,
literal|"UNIONFS path"
argument_list|,
literal|"UNIONFS path private part"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Initialize cache headers  */
end_comment

begin_function
name|int
name|unionfs_init
parameter_list|(
name|struct
name|vfsconf
modifier|*
name|vfsp
parameter_list|)
block|{
name|UNIONFSDEBUG
argument_list|(
literal|"unionfs_init\n"
argument_list|)
expr_stmt|;
comment|/* printed during system boot */
name|unionfs_node_hashtbl
operator|=
name|hashinit
argument_list|(
name|NUNIONFSNODECACHE
argument_list|,
name|M_UNIONFSHASH
argument_list|,
operator|&
name|unionfs_node_hash
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|unionfs_hashmtx
argument_list|,
literal|"unionfs"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Destroy cache headers  */
end_comment

begin_function
name|int
name|unionfs_uninit
parameter_list|(
name|struct
name|vfsconf
modifier|*
name|vfsp
parameter_list|)
block|{
name|mtx_destroy
argument_list|(
operator|&
name|unionfs_hashmtx
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|unionfs_node_hashtbl
argument_list|,
name|M_UNIONFSHASH
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return a VREF'ed alias for unionfs vnode if already exists, else 0.  */
end_comment

begin_function
specifier|static
name|struct
name|vnode
modifier|*
name|unionfs_hashget
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|struct
name|vnode
modifier|*
name|uppervp
parameter_list|,
name|struct
name|vnode
modifier|*
name|lowervp
parameter_list|,
name|struct
name|vnode
modifier|*
name|dvp
parameter_list|,
name|char
modifier|*
name|path
parameter_list|,
name|int
name|lkflags
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|unionfs_node_hashhead
modifier|*
name|hd
decl_stmt|;
name|struct
name|unionfs_node
modifier|*
name|unp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|lkflags
operator|&
name|LK_TYPE_MASK
condition|)
name|lkflags
operator||=
name|LK_RETRY
expr_stmt|;
name|hd
operator|=
name|UNIONFS_NHASH
argument_list|(
name|uppervp
argument_list|,
name|lowervp
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|unionfs_hashmtx
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|unp
argument_list|,
argument|hd
argument_list|,
argument|un_hash
argument_list|)
block|{
if|if
condition|(
name|unp
operator|->
name|un_uppervp
operator|==
name|uppervp
operator|&&
name|unp
operator|->
name|un_lowervp
operator|==
name|lowervp
operator|&&
name|unp
operator|->
name|un_dvp
operator|==
name|dvp
operator|&&
name|UNIONFSTOV
argument_list|(
name|unp
argument_list|)
operator|->
name|v_mount
operator|==
name|mp
operator|&&
operator|(
operator|!
name|path
operator|||
operator|!
operator|(
name|unp
operator|->
name|un_path
operator|)
operator|||
operator|!
name|strcmp
argument_list|(
name|unp
operator|->
name|un_path
argument_list|,
name|path
argument_list|)
operator|)
condition|)
block|{
name|vp
operator|=
name|UNIONFSTOV
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|VI_LOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|unionfs_hashmtx
argument_list|)
expr_stmt|;
comment|/* 			 * We need to clear the OWEINACT flag here as this 			 * may lead vget() to try to lock our vnode which is 			 * already locked via vp. 			 */
name|vp
operator|->
name|v_iflag
operator|&=
operator|~
name|VI_OWEINACT
expr_stmt|;
name|error
operator|=
name|vget
argument_list|(
name|vp
argument_list|,
name|LK_INTERLOCK
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"unionfs_hashget: vget error %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|lkflags
operator|&
name|LK_TYPE_MASK
condition|)
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|lkflags
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
operator|(
name|vp
operator|)
return|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|unionfs_hashmtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULLVP
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Act like unionfs_hashget, but add passed unionfs_node to hash if no existing  * node found.  */
end_comment

begin_function
specifier|static
name|struct
name|vnode
modifier|*
name|unionfs_hashins
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|struct
name|unionfs_node
modifier|*
name|uncp
parameter_list|,
name|char
modifier|*
name|path
parameter_list|,
name|int
name|lkflags
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|unionfs_node_hashhead
modifier|*
name|hd
decl_stmt|;
name|struct
name|unionfs_node
modifier|*
name|unp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|lkflags
operator|&
name|LK_TYPE_MASK
condition|)
name|lkflags
operator||=
name|LK_RETRY
expr_stmt|;
name|hd
operator|=
name|UNIONFS_NHASH
argument_list|(
name|uncp
operator|->
name|un_uppervp
argument_list|,
name|uncp
operator|->
name|un_lowervp
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|unionfs_hashmtx
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|unp
argument_list|,
argument|hd
argument_list|,
argument|un_hash
argument_list|)
block|{
if|if
condition|(
name|unp
operator|->
name|un_uppervp
operator|==
name|uncp
operator|->
name|un_uppervp
operator|&&
name|unp
operator|->
name|un_lowervp
operator|==
name|uncp
operator|->
name|un_lowervp
operator|&&
name|unp
operator|->
name|un_dvp
operator|==
name|uncp
operator|->
name|un_dvp
operator|&&
name|UNIONFSTOV
argument_list|(
name|unp
argument_list|)
operator|->
name|v_mount
operator|==
name|mp
operator|&&
operator|(
operator|!
name|path
operator|||
operator|!
operator|(
name|unp
operator|->
name|un_path
operator|)
operator|||
operator|!
name|strcmp
argument_list|(
name|unp
operator|->
name|un_path
argument_list|,
name|path
argument_list|)
operator|)
condition|)
block|{
name|vp
operator|=
name|UNIONFSTOV
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|VI_LOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|unionfs_hashmtx
argument_list|)
expr_stmt|;
name|vp
operator|->
name|v_iflag
operator|&=
operator|~
name|VI_OWEINACT
expr_stmt|;
name|error
operator|=
name|vget
argument_list|(
name|vp
argument_list|,
name|LK_INTERLOCK
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|panic
argument_list|(
literal|"unionfs_hashins: vget error %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|lkflags
operator|&
name|LK_TYPE_MASK
condition|)
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|lkflags
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
operator|(
name|vp
operator|)
return|;
block|}
block|}
name|LIST_INSERT_HEAD
argument_list|(
name|hd
argument_list|,
name|uncp
argument_list|,
name|un_hash
argument_list|)
expr_stmt|;
name|uncp
operator|->
name|un_flag
operator||=
name|UNIONFS_CACHED
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|unionfs_hashmtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULLVP
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Make a new or get existing unionfs node.  *   * uppervp and lowervp should be unlocked. Because if new unionfs vnode is  * locked, uppervp or lowervp is locked too. In order to prevent dead lock,  * you should not lock plurality simultaneously.  */
end_comment

begin_function
name|int
name|unionfs_nodeget
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|struct
name|vnode
modifier|*
name|uppervp
parameter_list|,
name|struct
name|vnode
modifier|*
name|lowervp
parameter_list|,
name|struct
name|vnode
modifier|*
name|dvp
parameter_list|,
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
parameter_list|,
name|struct
name|componentname
modifier|*
name|cnp
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|unionfs_mount
modifier|*
name|ump
decl_stmt|;
name|struct
name|unionfs_node
modifier|*
name|unp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|lkflags
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
name|ump
operator|=
name|MOUNTTOUNIONFSMOUNT
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|lkflags
operator|=
operator|(
name|cnp
condition|?
name|cnp
operator|->
name|cn_lkflags
else|:
literal|0
operator|)
expr_stmt|;
name|path
operator|=
operator|(
name|cnp
condition|?
name|cnp
operator|->
name|cn_nameptr
else|:
literal|""
operator|)
expr_stmt|;
if|if
condition|(
name|uppervp
operator|==
name|NULLVP
operator|&&
name|lowervp
operator|==
name|NULLVP
condition|)
name|panic
argument_list|(
literal|"unionfs_nodeget: upper and lower is null"
argument_list|)
expr_stmt|;
comment|/* If it has no ISLASTCN flag, path check is skipped. */
if|if
condition|(
operator|!
name|cnp
operator|||
operator|!
operator|(
name|cnp
operator|->
name|cn_flags
operator|&
name|ISLASTCN
operator|)
condition|)
name|path
operator|=
name|NULL
expr_stmt|;
comment|/* Lookup the hash first. */
operator|*
name|vpp
operator|=
name|unionfs_hashget
argument_list|(
name|mp
argument_list|,
name|uppervp
argument_list|,
name|lowervp
argument_list|,
name|dvp
argument_list|,
name|path
argument_list|,
name|lkflags
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|vpp
operator|!=
name|NULLVP
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|uppervp
operator|==
name|NULLVP
operator|||
name|ump
operator|->
name|um_uppervp
operator|!=
name|uppervp
operator|)
operator|||
operator|(
name|lowervp
operator|==
name|NULLVP
operator|||
name|ump
operator|->
name|um_lowervp
operator|!=
name|lowervp
operator|)
condition|)
block|{
if|if
condition|(
name|dvp
operator|==
name|NULLVP
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 	 * Do the MALLOC before the getnewvnode since doing so afterward 	 * might cause a bogus v_data pointer to get dereferenced elsewhere 	 * if MALLOC should block. 	 */
name|MALLOC
argument_list|(
name|unp
argument_list|,
expr|struct
name|unionfs_node
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|unionfs_node
argument_list|)
argument_list|,
name|M_UNIONFSNODE
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|error
operator|=
name|getnewvnode
argument_list|(
literal|"unionfs"
argument_list|,
name|mp
argument_list|,
operator|&
name|unionfs_vnodeops
argument_list|,
operator|&
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|FREE
argument_list|(
name|unp
argument_list|,
name|M_UNIONFSNODE
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|dvp
operator|!=
name|NULLVP
condition|)
name|vref
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|uppervp
operator|!=
name|NULLVP
condition|)
name|vref
argument_list|(
name|uppervp
argument_list|)
expr_stmt|;
if|if
condition|(
name|lowervp
operator|!=
name|NULLVP
condition|)
name|vref
argument_list|(
name|lowervp
argument_list|)
expr_stmt|;
name|unp
operator|->
name|un_vnode
operator|=
name|vp
expr_stmt|;
name|unp
operator|->
name|un_uppervp
operator|=
name|uppervp
expr_stmt|;
name|unp
operator|->
name|un_lowervp
operator|=
name|lowervp
expr_stmt|;
name|unp
operator|->
name|un_dvp
operator|=
name|dvp
expr_stmt|;
if|if
condition|(
name|uppervp
operator|!=
name|NULLVP
condition|)
name|vp
operator|->
name|v_vnlock
operator|=
name|uppervp
operator|->
name|v_vnlock
expr_stmt|;
else|else
name|vp
operator|->
name|v_vnlock
operator|=
name|lowervp
operator|->
name|v_vnlock
expr_stmt|;
if|if
condition|(
name|cnp
condition|)
block|{
name|unp
operator|->
name|un_path
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|cnp
operator|->
name|cn_namelen
operator|+
literal|1
argument_list|,
name|M_UNIONFSPATH
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|cnp
operator|->
name|cn_nameptr
argument_list|,
name|unp
operator|->
name|un_path
argument_list|,
name|cnp
operator|->
name|cn_namelen
argument_list|)
expr_stmt|;
name|unp
operator|->
name|un_path
index|[
name|cnp
operator|->
name|cn_namelen
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|vp
operator|->
name|v_type
operator|=
operator|(
name|uppervp
operator|!=
name|NULLVP
condition|?
name|uppervp
operator|->
name|v_type
else|:
name|lowervp
operator|->
name|v_type
operator|)
expr_stmt|;
name|vp
operator|->
name|v_data
operator|=
name|unp
expr_stmt|;
if|if
condition|(
operator|(
name|uppervp
operator|!=
name|NULLVP
operator|&&
name|ump
operator|->
name|um_uppervp
operator|==
name|uppervp
operator|)
operator|&&
operator|(
name|lowervp
operator|!=
name|NULLVP
operator|&&
name|ump
operator|->
name|um_lowervp
operator|==
name|lowervp
operator|)
condition|)
name|vp
operator|->
name|v_vflag
operator||=
name|VV_ROOT
expr_stmt|;
operator|*
name|vpp
operator|=
name|unionfs_hashins
argument_list|(
name|mp
argument_list|,
name|unp
argument_list|,
name|path
argument_list|,
name|lkflags
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|vpp
operator|!=
name|NULLVP
condition|)
block|{
if|if
condition|(
name|dvp
operator|!=
name|NULLVP
condition|)
name|vrele
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|uppervp
operator|!=
name|NULLVP
condition|)
name|vrele
argument_list|(
name|uppervp
argument_list|)
expr_stmt|;
if|if
condition|(
name|lowervp
operator|!=
name|NULLVP
condition|)
name|vrele
argument_list|(
name|lowervp
argument_list|)
expr_stmt|;
name|unp
operator|->
name|un_uppervp
operator|=
name|NULLVP
expr_stmt|;
name|unp
operator|->
name|un_lowervp
operator|=
name|NULLVP
expr_stmt|;
name|unp
operator|->
name|un_dvp
operator|=
name|NULLVP
expr_stmt|;
name|vrele
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|lkflags
operator|&
name|LK_TYPE_MASK
condition|)
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|lkflags
operator||
name|LK_RETRY
argument_list|,
name|td
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|vp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove node from hash.  */
end_comment

begin_function
name|void
name|unionfs_hashrem
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|vfslocked
decl_stmt|;
name|struct
name|unionfs_node
modifier|*
name|unp
decl_stmt|;
name|struct
name|unionfs_node_status
modifier|*
name|unsp
decl_stmt|,
modifier|*
name|unsp_tmp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|lvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|uvp
decl_stmt|;
comment|/* 	 * Use the interlock to protect the clearing of v_data to 	 * prevent faults in unionfs_lock(). 	 */
name|VI_LOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|unp
operator|=
name|VTOUNIONFS
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|lvp
operator|=
name|unp
operator|->
name|un_lowervp
expr_stmt|;
name|uvp
operator|=
name|unp
operator|->
name|un_uppervp
expr_stmt|;
name|unp
operator|->
name|un_lowervp
operator|=
name|unp
operator|->
name|un_uppervp
operator|=
name|NULLVP
expr_stmt|;
name|vp
operator|->
name|v_vnlock
operator|=
operator|&
operator|(
name|vp
operator|->
name|v_lock
operator|)
expr_stmt|;
name|vp
operator|->
name|v_data
operator|=
name|NULL
expr_stmt|;
name|lockmgr
argument_list|(
name|vp
operator|->
name|v_vnlock
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_INTERLOCK
argument_list|,
name|VI_MTX
argument_list|(
name|vp
argument_list|)
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|lvp
operator|!=
name|NULLVP
condition|)
name|VOP_UNLOCK
argument_list|(
name|lvp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|uvp
operator|!=
name|NULLVP
condition|)
name|VOP_UNLOCK
argument_list|(
name|uvp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|unionfs_hashmtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|unp
operator|->
name|un_flag
operator|&
name|UNIONFS_CACHED
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|unp
argument_list|,
name|un_hash
argument_list|)
expr_stmt|;
name|unp
operator|->
name|un_flag
operator|&=
operator|~
name|UNIONFS_CACHED
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|unionfs_hashmtx
argument_list|)
expr_stmt|;
name|vp
operator|->
name|v_object
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|lvp
operator|!=
name|NULLVP
condition|)
block|{
name|vfslocked
operator|=
name|VFS_LOCK_GIANT
argument_list|(
name|lvp
operator|->
name|v_mount
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|lvp
argument_list|)
expr_stmt|;
name|VFS_UNLOCK_GIANT
argument_list|(
name|vfslocked
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|uvp
operator|!=
name|NULLVP
condition|)
block|{
name|vfslocked
operator|=
name|VFS_LOCK_GIANT
argument_list|(
name|uvp
operator|->
name|v_mount
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|uvp
argument_list|)
expr_stmt|;
name|VFS_UNLOCK_GIANT
argument_list|(
name|vfslocked
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|unp
operator|->
name|un_dvp
operator|!=
name|NULLVP
condition|)
block|{
name|vfslocked
operator|=
name|VFS_LOCK_GIANT
argument_list|(
name|unp
operator|->
name|un_dvp
operator|->
name|v_mount
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|unp
operator|->
name|un_dvp
argument_list|)
expr_stmt|;
name|VFS_UNLOCK_GIANT
argument_list|(
name|vfslocked
argument_list|)
expr_stmt|;
name|unp
operator|->
name|un_dvp
operator|=
name|NULLVP
expr_stmt|;
block|}
if|if
condition|(
name|unp
operator|->
name|un_path
condition|)
block|{
name|free
argument_list|(
name|unp
operator|->
name|un_path
argument_list|,
name|M_UNIONFSPATH
argument_list|)
expr_stmt|;
name|unp
operator|->
name|un_path
operator|=
name|NULL
expr_stmt|;
block|}
name|LIST_FOREACH_SAFE
argument_list|(
argument|unsp
argument_list|,
argument|&(unp->un_unshead)
argument_list|,
argument|uns_list
argument_list|,
argument|unsp_tmp
argument_list|)
block|{
name|LIST_REMOVE
argument_list|(
name|unsp
argument_list|,
name|uns_list
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|unsp
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
name|FREE
argument_list|(
name|unp
argument_list|,
name|M_UNIONFSNODE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get the unionfs node status.  * You need exclusive lock this vnode.  */
end_comment

begin_function
name|void
name|unionfs_get_node_status
parameter_list|(
name|struct
name|unionfs_node
modifier|*
name|unp
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|unionfs_node_status
modifier|*
modifier|*
name|unspp
parameter_list|)
block|{
name|struct
name|unionfs_node_status
modifier|*
name|unsp
decl_stmt|;
name|KASSERT
argument_list|(
name|NULL
operator|!=
name|unspp
argument_list|,
operator|(
literal|"null pointer"
operator|)
argument_list|)
expr_stmt|;
name|ASSERT_VOP_ELOCKED
argument_list|(
name|UNIONFSTOV
argument_list|(
name|unp
argument_list|)
argument_list|,
literal|"unionfs_get_node_status"
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|unsp
argument_list|,
argument|&(unp->un_unshead)
argument_list|,
argument|uns_list
argument_list|)
block|{
if|if
condition|(
name|unsp
operator|->
name|uns_tid
operator|==
name|td
operator|->
name|td_tid
condition|)
block|{
operator|*
name|unspp
operator|=
name|unsp
expr_stmt|;
return|return;
block|}
block|}
comment|/* create a new unionfs node status */
name|MALLOC
argument_list|(
name|unsp
argument_list|,
expr|struct
name|unionfs_node_status
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|unionfs_node_status
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|unsp
operator|->
name|uns_tid
operator|=
name|td
operator|->
name|td_tid
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
operator|(
name|unp
operator|->
name|un_unshead
operator|)
argument_list|,
name|unsp
argument_list|,
name|uns_list
argument_list|)
expr_stmt|;
operator|*
name|unspp
operator|=
name|unsp
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove the unionfs node status, if you can.  * You need exclusive lock this vnode.  */
end_comment

begin_function
name|void
name|unionfs_tryrem_node_status
parameter_list|(
name|struct
name|unionfs_node
modifier|*
name|unp
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|unionfs_node_status
modifier|*
name|unsp
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|NULL
operator|!=
name|unsp
argument_list|,
operator|(
literal|"null pointer"
operator|)
argument_list|)
expr_stmt|;
name|ASSERT_VOP_ELOCKED
argument_list|(
name|UNIONFSTOV
argument_list|(
name|unp
argument_list|)
argument_list|,
literal|"unionfs_get_node_status"
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|<
name|unsp
operator|->
name|uns_lower_opencnt
operator|||
literal|0
operator|<
name|unsp
operator|->
name|uns_upper_opencnt
condition|)
return|return;
name|LIST_REMOVE
argument_list|(
name|unsp
argument_list|,
name|uns_list
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|unsp
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Create upper node attr.  */
end_comment

begin_function
name|void
name|unionfs_create_uppervattr_core
parameter_list|(
name|struct
name|unionfs_mount
modifier|*
name|ump
parameter_list|,
name|struct
name|vattr
modifier|*
name|lva
parameter_list|,
name|struct
name|vattr
modifier|*
name|uva
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|VATTR_NULL
argument_list|(
name|uva
argument_list|)
expr_stmt|;
name|uva
operator|->
name|va_type
operator|=
name|lva
operator|->
name|va_type
expr_stmt|;
name|uva
operator|->
name|va_atime
operator|=
name|lva
operator|->
name|va_atime
expr_stmt|;
name|uva
operator|->
name|va_mtime
operator|=
name|lva
operator|->
name|va_mtime
expr_stmt|;
name|uva
operator|->
name|va_ctime
operator|=
name|lva
operator|->
name|va_ctime
expr_stmt|;
switch|switch
condition|(
name|ump
operator|->
name|um_copymode
condition|)
block|{
case|case
name|UNIONFS_TRANSPARENT
case|:
name|uva
operator|->
name|va_mode
operator|=
name|lva
operator|->
name|va_mode
expr_stmt|;
name|uva
operator|->
name|va_uid
operator|=
name|lva
operator|->
name|va_uid
expr_stmt|;
name|uva
operator|->
name|va_gid
operator|=
name|lva
operator|->
name|va_gid
expr_stmt|;
break|break;
case|case
name|UNIONFS_MASQUERADE
case|:
if|if
condition|(
name|ump
operator|->
name|um_uid
operator|==
name|lva
operator|->
name|va_uid
condition|)
block|{
name|uva
operator|->
name|va_mode
operator|=
name|lva
operator|->
name|va_mode
operator|&
literal|077077
expr_stmt|;
name|uva
operator|->
name|va_mode
operator||=
operator|(
name|lva
operator|->
name|va_type
operator|==
name|VDIR
condition|?
name|ump
operator|->
name|um_udir
else|:
name|ump
operator|->
name|um_ufile
operator|)
operator|&
literal|0700
expr_stmt|;
name|uva
operator|->
name|va_uid
operator|=
name|lva
operator|->
name|va_uid
expr_stmt|;
name|uva
operator|->
name|va_gid
operator|=
name|lva
operator|->
name|va_gid
expr_stmt|;
block|}
else|else
block|{
name|uva
operator|->
name|va_mode
operator|=
operator|(
name|lva
operator|->
name|va_type
operator|==
name|VDIR
condition|?
name|ump
operator|->
name|um_udir
else|:
name|ump
operator|->
name|um_ufile
operator|)
expr_stmt|;
name|uva
operator|->
name|va_uid
operator|=
name|ump
operator|->
name|um_uid
expr_stmt|;
name|uva
operator|->
name|va_gid
operator|=
name|ump
operator|->
name|um_gid
expr_stmt|;
block|}
break|break;
default|default:
comment|/* UNIONFS_TRADITIONAL */
name|FILEDESC_LOCK_FAST
argument_list|(
name|td
operator|->
name|td_proc
operator|->
name|p_fd
argument_list|)
expr_stmt|;
name|uva
operator|->
name|va_mode
operator|=
literal|0777
operator|&
operator|~
name|td
operator|->
name|td_proc
operator|->
name|p_fd
operator|->
name|fd_cmask
expr_stmt|;
name|FILEDESC_UNLOCK_FAST
argument_list|(
name|td
operator|->
name|td_proc
operator|->
name|p_fd
argument_list|)
expr_stmt|;
name|uva
operator|->
name|va_uid
operator|=
name|ump
operator|->
name|um_uid
expr_stmt|;
name|uva
operator|->
name|va_gid
operator|=
name|ump
operator|->
name|um_gid
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Create upper node attr.  */
end_comment

begin_function
name|int
name|unionfs_create_uppervattr
parameter_list|(
name|struct
name|unionfs_mount
modifier|*
name|ump
parameter_list|,
name|struct
name|vnode
modifier|*
name|lvp
parameter_list|,
name|struct
name|vattr
modifier|*
name|uva
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|vattr
name|lva
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|lvp
argument_list|,
operator|&
name|lva
argument_list|,
name|cred
argument_list|,
name|td
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|unionfs_create_uppervattr_core
argument_list|(
name|ump
argument_list|,
operator|&
name|lva
argument_list|,
name|uva
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * relookup  *   * dvp should be locked on entry and will be locked on return.  *   * If an error is returned, *vpp will be invalid, otherwise it will hold a  * locked, referenced vnode. If *vpp == dvp then remember that only one  * LK_EXCLUSIVE lock is held.  */
end_comment

begin_function
specifier|static
name|int
name|unionfs_relookup
parameter_list|(
name|struct
name|vnode
modifier|*
name|dvp
parameter_list|,
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
parameter_list|,
name|struct
name|componentname
modifier|*
name|cnp
parameter_list|,
name|struct
name|componentname
modifier|*
name|cn
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|char
modifier|*
name|path
parameter_list|,
name|int
name|pathlen
parameter_list|,
name|u_long
name|nameiop
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|cn
operator|->
name|cn_namelen
operator|=
name|pathlen
expr_stmt|;
name|cn
operator|->
name|cn_pnbuf
operator|=
name|uma_zalloc
argument_list|(
name|namei_zone
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|path
argument_list|,
name|cn
operator|->
name|cn_pnbuf
argument_list|,
name|pathlen
argument_list|)
expr_stmt|;
name|cn
operator|->
name|cn_pnbuf
index|[
name|pathlen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|cn
operator|->
name|cn_nameiop
operator|=
name|nameiop
expr_stmt|;
name|cn
operator|->
name|cn_flags
operator|=
operator|(
name|LOCKPARENT
operator||
name|LOCKLEAF
operator||
name|HASBUF
operator||
name|SAVENAME
operator||
name|ISLASTCN
operator|)
expr_stmt|;
name|cn
operator|->
name|cn_lkflags
operator|=
name|LK_EXCLUSIVE
expr_stmt|;
name|cn
operator|->
name|cn_thread
operator|=
name|td
expr_stmt|;
name|cn
operator|->
name|cn_cred
operator|=
name|cnp
operator|->
name|cn_cred
expr_stmt|;
name|cn
operator|->
name|cn_nameptr
operator|=
name|cn
operator|->
name|cn_pnbuf
expr_stmt|;
name|cn
operator|->
name|cn_consume
operator|=
name|cnp
operator|->
name|cn_consume
expr_stmt|;
if|if
condition|(
name|nameiop
operator|==
name|DELETE
condition|)
name|cn
operator|->
name|cn_flags
operator||=
operator|(
name|cnp
operator|->
name|cn_flags
operator|&
operator|(
name|DOWHITEOUT
operator||
name|SAVESTART
operator|)
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|RENAME
operator|==
name|nameiop
condition|)
name|cn
operator|->
name|cn_flags
operator||=
operator|(
name|cnp
operator|->
name|cn_flags
operator|&
name|SAVESTART
operator|)
expr_stmt|;
name|vref
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|dvp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|relookup
argument_list|(
name|dvp
argument_list|,
name|vpp
argument_list|,
name|cn
argument_list|)
operator|)
condition|)
block|{
name|uma_zfree
argument_list|(
name|namei_zone
argument_list|,
name|cn
operator|->
name|cn_pnbuf
argument_list|)
expr_stmt|;
name|cn
operator|->
name|cn_flags
operator|&=
operator|~
name|HASBUF
expr_stmt|;
name|vn_lock
argument_list|(
name|dvp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
else|else
name|vrele
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * relookup for CREATE namei operation.  *  * dvp is unionfs vnode. dvp should be locked.  *  * If it called 'unionfs_copyfile' function by unionfs_link etc,  * VOP_LOOKUP information is broken.  * So it need relookup in order to create link etc.  */
end_comment

begin_function
name|int
name|unionfs_relookup_for_create
parameter_list|(
name|struct
name|vnode
modifier|*
name|dvp
parameter_list|,
name|struct
name|componentname
modifier|*
name|cnp
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|vnode
modifier|*
name|udvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|componentname
name|cn
decl_stmt|;
name|udvp
operator|=
name|UNIONFSVPTOUPPERVP
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|vp
operator|=
name|NULLVP
expr_stmt|;
name|error
operator|=
name|unionfs_relookup
argument_list|(
name|udvp
argument_list|,
operator|&
name|vp
argument_list|,
name|cnp
argument_list|,
operator|&
name|cn
argument_list|,
name|td
argument_list|,
name|cnp
operator|->
name|cn_nameptr
argument_list|,
name|strlen
argument_list|(
name|cnp
operator|->
name|cn_nameptr
argument_list|)
argument_list|,
name|CREATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|vp
operator|!=
name|NULLVP
condition|)
block|{
if|if
condition|(
name|udvp
operator|==
name|vp
condition|)
name|vrele
argument_list|(
name|vp
argument_list|)
expr_stmt|;
else|else
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|error
operator|=
name|EEXIST
expr_stmt|;
block|}
if|if
condition|(
name|cn
operator|.
name|cn_flags
operator|&
name|HASBUF
condition|)
block|{
name|uma_zfree
argument_list|(
name|namei_zone
argument_list|,
name|cn
operator|.
name|cn_pnbuf
argument_list|)
expr_stmt|;
name|cn
operator|.
name|cn_flags
operator|&=
operator|~
name|HASBUF
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|cn
operator|.
name|cn_flags
operator||=
operator|(
name|cnp
operator|->
name|cn_flags
operator|&
name|HASBUF
operator|)
expr_stmt|;
name|cnp
operator|->
name|cn_flags
operator|=
name|cn
operator|.
name|cn_flags
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * relookup for DELETE namei operation.  *  * dvp is unionfs vnode. dvp should be locked.  */
end_comment

begin_function
name|int
name|unionfs_relookup_for_delete
parameter_list|(
name|struct
name|vnode
modifier|*
name|dvp
parameter_list|,
name|struct
name|componentname
modifier|*
name|cnp
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|vnode
modifier|*
name|udvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|componentname
name|cn
decl_stmt|;
name|udvp
operator|=
name|UNIONFSVPTOUPPERVP
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|vp
operator|=
name|NULLVP
expr_stmt|;
name|error
operator|=
name|unionfs_relookup
argument_list|(
name|udvp
argument_list|,
operator|&
name|vp
argument_list|,
name|cnp
argument_list|,
operator|&
name|cn
argument_list|,
name|td
argument_list|,
name|cnp
operator|->
name|cn_nameptr
argument_list|,
name|strlen
argument_list|(
name|cnp
operator|->
name|cn_nameptr
argument_list|)
argument_list|,
name|DELETE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|vp
operator|==
name|NULLVP
condition|)
name|error
operator|=
name|ENOENT
expr_stmt|;
else|else
block|{
if|if
condition|(
name|udvp
operator|==
name|vp
condition|)
name|vrele
argument_list|(
name|vp
argument_list|)
expr_stmt|;
else|else
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cn
operator|.
name|cn_flags
operator|&
name|HASBUF
condition|)
block|{
name|uma_zfree
argument_list|(
name|namei_zone
argument_list|,
name|cn
operator|.
name|cn_pnbuf
argument_list|)
expr_stmt|;
name|cn
operator|.
name|cn_flags
operator|&=
operator|~
name|HASBUF
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|cn
operator|.
name|cn_flags
operator||=
operator|(
name|cnp
operator|->
name|cn_flags
operator|&
name|HASBUF
operator|)
expr_stmt|;
name|cnp
operator|->
name|cn_flags
operator|=
name|cn
operator|.
name|cn_flags
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * relookup for RENAME namei operation.  *  * dvp is unionfs vnode. dvp should be locked.  */
end_comment

begin_function
name|int
name|unionfs_relookup_for_rename
parameter_list|(
name|struct
name|vnode
modifier|*
name|dvp
parameter_list|,
name|struct
name|componentname
modifier|*
name|cnp
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|vnode
modifier|*
name|udvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|componentname
name|cn
decl_stmt|;
name|udvp
operator|=
name|UNIONFSVPTOUPPERVP
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|vp
operator|=
name|NULLVP
expr_stmt|;
name|error
operator|=
name|unionfs_relookup
argument_list|(
name|udvp
argument_list|,
operator|&
name|vp
argument_list|,
name|cnp
argument_list|,
operator|&
name|cn
argument_list|,
name|td
argument_list|,
name|cnp
operator|->
name|cn_nameptr
argument_list|,
name|strlen
argument_list|(
name|cnp
operator|->
name|cn_nameptr
argument_list|)
argument_list|,
name|RENAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|vp
operator|!=
name|NULLVP
condition|)
block|{
if|if
condition|(
name|udvp
operator|==
name|vp
condition|)
name|vrele
argument_list|(
name|vp
argument_list|)
expr_stmt|;
else|else
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cn
operator|.
name|cn_flags
operator|&
name|HASBUF
condition|)
block|{
name|uma_zfree
argument_list|(
name|namei_zone
argument_list|,
name|cn
operator|.
name|cn_pnbuf
argument_list|)
expr_stmt|;
name|cn
operator|.
name|cn_flags
operator|&=
operator|~
name|HASBUF
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|cn
operator|.
name|cn_flags
operator||=
operator|(
name|cnp
operator|->
name|cn_flags
operator|&
name|HASBUF
operator|)
expr_stmt|;
name|cnp
operator|->
name|cn_flags
operator|=
name|cn
operator|.
name|cn_flags
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Update the unionfs_node.  *   * uvp is new locked upper vnode. unionfs vnode's lock will be exchanged to the  * uvp's lock and lower's lock will be unlocked.  */
end_comment

begin_function
specifier|static
name|void
name|unionfs_node_update
parameter_list|(
name|struct
name|unionfs_node
modifier|*
name|unp
parameter_list|,
name|struct
name|vnode
modifier|*
name|uvp
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|count
decl_stmt|,
name|lockcnt
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|lvp
decl_stmt|;
name|vp
operator|=
name|UNIONFSTOV
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|lvp
operator|=
name|unp
operator|->
name|un_lowervp
expr_stmt|;
comment|/* 	 * lock update 	 */
name|VI_LOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|unp
operator|->
name|un_uppervp
operator|=
name|uvp
expr_stmt|;
name|vp
operator|->
name|v_vnlock
operator|=
name|uvp
operator|->
name|v_vnlock
expr_stmt|;
name|lockcnt
operator|=
name|lvp
operator|->
name|v_vnlock
operator|->
name|lk_exclusivecount
expr_stmt|;
if|if
condition|(
name|lockcnt
operator|<=
literal|0
condition|)
name|panic
argument_list|(
literal|"unionfs: no exclusive lock"
argument_list|)
expr_stmt|;
name|VI_UNLOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|1
init|;
name|count
operator|<
name|lockcnt
condition|;
name|count
operator|++
control|)
name|vn_lock
argument_list|(
name|uvp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_CANRECURSE
operator||
name|LK_RETRY
argument_list|,
name|td
argument_list|)
expr_stmt|;
comment|/* 	 * cache update 	 */
name|mtx_lock
argument_list|(
operator|&
name|unionfs_hashmtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|unp
operator|->
name|un_flag
operator|&
name|UNIONFS_CACHED
condition|)
name|LIST_REMOVE
argument_list|(
name|unp
argument_list|,
name|un_hash
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|UNIONFS_NHASH
argument_list|(
name|uvp
argument_list|,
name|lvp
argument_list|)
argument_list|,
name|unp
argument_list|,
name|un_hash
argument_list|)
expr_stmt|;
name|unp
operator|->
name|un_flag
operator||=
name|UNIONFS_CACHED
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|unionfs_hashmtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Create a new shadow dir.  *   * udvp should be locked on entry and will be locked on return.  *   * If no error returned, unp will be updated.  */
end_comment

begin_function
name|int
name|unionfs_mkshadowdir
parameter_list|(
name|struct
name|unionfs_mount
modifier|*
name|ump
parameter_list|,
name|struct
name|vnode
modifier|*
name|udvp
parameter_list|,
name|struct
name|unionfs_node
modifier|*
name|unp
parameter_list|,
name|struct
name|componentname
modifier|*
name|cnp
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|vnode
modifier|*
name|lvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|uvp
decl_stmt|;
name|struct
name|vattr
name|va
decl_stmt|;
name|struct
name|vattr
name|lva
decl_stmt|;
name|struct
name|componentname
name|cn
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|struct
name|ucred
modifier|*
name|credbk
decl_stmt|;
name|struct
name|uidinfo
modifier|*
name|rootinfo
decl_stmt|;
if|if
condition|(
name|unp
operator|->
name|un_uppervp
operator|!=
name|NULLVP
condition|)
return|return
operator|(
name|EEXIST
operator|)
return|;
name|lvp
operator|=
name|unp
operator|->
name|un_lowervp
expr_stmt|;
name|uvp
operator|=
name|NULLVP
expr_stmt|;
name|credbk
operator|=
name|cnp
operator|->
name|cn_cred
expr_stmt|;
comment|/* Authority change to root */
name|rootinfo
operator|=
name|uifind
argument_list|(
operator|(
name|uid_t
operator|)
literal|0
argument_list|)
expr_stmt|;
name|cred
operator|=
name|crdup
argument_list|(
name|cnp
operator|->
name|cn_cred
argument_list|)
expr_stmt|;
name|chgproccnt
argument_list|(
name|cred
operator|->
name|cr_ruidinfo
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|change_euid
argument_list|(
name|cred
argument_list|,
name|rootinfo
argument_list|)
expr_stmt|;
name|change_ruid
argument_list|(
name|cred
argument_list|,
name|rootinfo
argument_list|)
expr_stmt|;
name|change_svuid
argument_list|(
name|cred
argument_list|,
operator|(
name|uid_t
operator|)
literal|0
argument_list|)
expr_stmt|;
name|uifree
argument_list|(
name|rootinfo
argument_list|)
expr_stmt|;
name|cnp
operator|->
name|cn_cred
operator|=
name|cred
expr_stmt|;
name|memset
argument_list|(
operator|&
name|cn
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|lvp
argument_list|,
operator|&
name|lva
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|,
name|td
argument_list|)
operator|)
condition|)
goto|goto
name|unionfs_mkshadowdir_abort
goto|;
if|if
condition|(
operator|(
name|error
operator|=
name|unionfs_relookup
argument_list|(
name|udvp
argument_list|,
operator|&
name|uvp
argument_list|,
name|cnp
argument_list|,
operator|&
name|cn
argument_list|,
name|td
argument_list|,
name|cnp
operator|->
name|cn_nameptr
argument_list|,
name|cnp
operator|->
name|cn_namelen
argument_list|,
name|CREATE
argument_list|)
operator|)
condition|)
goto|goto
name|unionfs_mkshadowdir_abort
goto|;
if|if
condition|(
name|uvp
operator|!=
name|NULLVP
condition|)
block|{
if|if
condition|(
name|udvp
operator|==
name|uvp
condition|)
name|vrele
argument_list|(
name|uvp
argument_list|)
expr_stmt|;
else|else
name|vput
argument_list|(
name|uvp
argument_list|)
expr_stmt|;
name|error
operator|=
name|EEXIST
expr_stmt|;
goto|goto
name|unionfs_mkshadowdir_free_out
goto|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|vn_start_write
argument_list|(
name|udvp
argument_list|,
operator|&
name|mp
argument_list|,
name|V_WAIT
operator||
name|PCATCH
argument_list|)
operator|)
condition|)
goto|goto
name|unionfs_mkshadowdir_free_out
goto|;
if|if
condition|(
operator|(
name|error
operator|=
name|VOP_LEASE
argument_list|(
name|udvp
argument_list|,
name|td
argument_list|,
name|cn
operator|.
name|cn_cred
argument_list|,
name|LEASE_WRITE
argument_list|)
operator|)
condition|)
block|{
name|vn_finished_write
argument_list|(
name|mp
argument_list|)
expr_stmt|;
goto|goto
name|unionfs_mkshadowdir_free_out
goto|;
block|}
name|unionfs_create_uppervattr_core
argument_list|(
name|ump
argument_list|,
operator|&
name|lva
argument_list|,
operator|&
name|va
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_MKDIR
argument_list|(
name|udvp
argument_list|,
operator|&
name|uvp
argument_list|,
operator|&
name|cn
argument_list|,
operator|&
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|unionfs_node_update
argument_list|(
name|unp
argument_list|,
name|uvp
argument_list|,
name|td
argument_list|)
expr_stmt|;
comment|/* 		 * XXX The bug which cannot set uid/gid was corrected. 		 * Ignore errors. 		 */
name|va
operator|.
name|va_type
operator|=
name|VNON
expr_stmt|;
name|VOP_SETATTR
argument_list|(
name|uvp
argument_list|,
operator|&
name|va
argument_list|,
name|cn
operator|.
name|cn_cred
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
name|vn_finished_write
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|unionfs_mkshadowdir_free_out
label|:
if|if
condition|(
name|cn
operator|.
name|cn_flags
operator|&
name|HASBUF
condition|)
block|{
name|uma_zfree
argument_list|(
name|namei_zone
argument_list|,
name|cn
operator|.
name|cn_pnbuf
argument_list|)
expr_stmt|;
name|cn
operator|.
name|cn_flags
operator|&=
operator|~
name|HASBUF
expr_stmt|;
block|}
name|unionfs_mkshadowdir_abort
label|:
name|cnp
operator|->
name|cn_cred
operator|=
name|credbk
expr_stmt|;
name|chgproccnt
argument_list|(
name|cred
operator|->
name|cr_ruidinfo
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|crfree
argument_list|(
name|cred
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create a new whiteout.  *   * dvp should be locked on entry and will be locked on return.  */
end_comment

begin_function
name|int
name|unionfs_mkwhiteout
parameter_list|(
name|struct
name|vnode
modifier|*
name|dvp
parameter_list|,
name|struct
name|componentname
modifier|*
name|cnp
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|char
modifier|*
name|path
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|vnode
modifier|*
name|wvp
decl_stmt|;
name|struct
name|componentname
name|cn
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
name|path
operator|=
name|cnp
operator|->
name|cn_nameptr
expr_stmt|;
name|wvp
operator|=
name|NULLVP
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|unionfs_relookup
argument_list|(
name|dvp
argument_list|,
operator|&
name|wvp
argument_list|,
name|cnp
argument_list|,
operator|&
name|cn
argument_list|,
name|td
argument_list|,
name|path
argument_list|,
name|strlen
argument_list|(
name|path
argument_list|)
argument_list|,
name|CREATE
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|wvp
operator|!=
name|NULLVP
condition|)
block|{
if|if
condition|(
name|cn
operator|.
name|cn_flags
operator|&
name|HASBUF
condition|)
block|{
name|uma_zfree
argument_list|(
name|namei_zone
argument_list|,
name|cn
operator|.
name|cn_pnbuf
argument_list|)
expr_stmt|;
name|cn
operator|.
name|cn_flags
operator|&=
operator|~
name|HASBUF
expr_stmt|;
block|}
if|if
condition|(
name|dvp
operator|==
name|wvp
condition|)
name|vrele
argument_list|(
name|wvp
argument_list|)
expr_stmt|;
else|else
name|vput
argument_list|(
name|wvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EEXIST
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|vn_start_write
argument_list|(
name|dvp
argument_list|,
operator|&
name|mp
argument_list|,
name|V_WAIT
operator||
name|PCATCH
argument_list|)
operator|)
condition|)
goto|goto
name|unionfs_mkwhiteout_free_out
goto|;
if|if
condition|(
operator|!
operator|(
name|error
operator|=
name|VOP_LEASE
argument_list|(
name|dvp
argument_list|,
name|td
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|LEASE_WRITE
argument_list|)
operator|)
condition|)
name|error
operator|=
name|VOP_WHITEOUT
argument_list|(
name|dvp
argument_list|,
operator|&
name|cn
argument_list|,
name|CREATE
argument_list|)
expr_stmt|;
name|vn_finished_write
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|unionfs_mkwhiteout_free_out
label|:
if|if
condition|(
name|cn
operator|.
name|cn_flags
operator|&
name|HASBUF
condition|)
block|{
name|uma_zfree
argument_list|(
name|namei_zone
argument_list|,
name|cn
operator|.
name|cn_pnbuf
argument_list|)
expr_stmt|;
name|cn
operator|.
name|cn_flags
operator|&=
operator|~
name|HASBUF
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create a new vnode for create a new shadow file.  *   * If an error is returned, *vpp will be invalid, otherwise it will hold a  * locked, referenced and opened vnode.  *   * unp is never updated.  */
end_comment

begin_function
specifier|static
name|int
name|unionfs_vn_create_on_upper
parameter_list|(
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
parameter_list|,
name|struct
name|vnode
modifier|*
name|udvp
parameter_list|,
name|struct
name|unionfs_node
modifier|*
name|unp
parameter_list|,
name|struct
name|vattr
modifier|*
name|uvap
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|unionfs_mount
modifier|*
name|ump
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|lvp
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|struct
name|vattr
name|lva
decl_stmt|;
name|int
name|fmode
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|componentname
name|cn
decl_stmt|;
name|ump
operator|=
name|MOUNTTOUNIONFSMOUNT
argument_list|(
name|UNIONFSTOV
argument_list|(
name|unp
argument_list|)
operator|->
name|v_mount
argument_list|)
expr_stmt|;
name|vp
operator|=
name|NULLVP
expr_stmt|;
name|lvp
operator|=
name|unp
operator|->
name|un_lowervp
expr_stmt|;
name|cred
operator|=
name|td
operator|->
name|td_ucred
expr_stmt|;
name|fmode
operator|=
name|FFLAGS
argument_list|(
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
operator||
name|O_EXCL
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|lvp
argument_list|,
operator|&
name|lva
argument_list|,
name|cred
argument_list|,
name|td
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|unionfs_create_uppervattr_core
argument_list|(
name|ump
argument_list|,
operator|&
name|lva
argument_list|,
name|uvap
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|unp
operator|->
name|un_path
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"unionfs: un_path is null"
argument_list|)
expr_stmt|;
name|cn
operator|.
name|cn_namelen
operator|=
name|strlen
argument_list|(
name|unp
operator|->
name|un_path
argument_list|)
expr_stmt|;
name|cn
operator|.
name|cn_pnbuf
operator|=
name|uma_zalloc
argument_list|(
name|namei_zone
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|unp
operator|->
name|un_path
argument_list|,
name|cn
operator|.
name|cn_pnbuf
argument_list|,
name|cn
operator|.
name|cn_namelen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|cn
operator|.
name|cn_nameiop
operator|=
name|CREATE
expr_stmt|;
name|cn
operator|.
name|cn_flags
operator|=
operator|(
name|LOCKPARENT
operator||
name|LOCKLEAF
operator||
name|HASBUF
operator||
name|SAVENAME
operator||
name|ISLASTCN
operator|)
expr_stmt|;
name|cn
operator|.
name|cn_lkflags
operator|=
name|LK_EXCLUSIVE
expr_stmt|;
name|cn
operator|.
name|cn_thread
operator|=
name|td
expr_stmt|;
name|cn
operator|.
name|cn_cred
operator|=
name|cred
expr_stmt|;
name|cn
operator|.
name|cn_nameptr
operator|=
name|cn
operator|.
name|cn_pnbuf
expr_stmt|;
name|cn
operator|.
name|cn_consume
operator|=
literal|0
expr_stmt|;
name|vref
argument_list|(
name|udvp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|relookup
argument_list|(
name|udvp
argument_list|,
operator|&
name|vp
argument_list|,
operator|&
name|cn
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|unionfs_vn_create_on_upper_free_out2
goto|;
name|vrele
argument_list|(
name|udvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|!=
name|NULLVP
condition|)
block|{
if|if
condition|(
name|vp
operator|==
name|udvp
condition|)
name|vrele
argument_list|(
name|vp
argument_list|)
expr_stmt|;
else|else
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|error
operator|=
name|EEXIST
expr_stmt|;
goto|goto
name|unionfs_vn_create_on_upper_free_out1
goto|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|VOP_LEASE
argument_list|(
name|udvp
argument_list|,
name|td
argument_list|,
name|cred
argument_list|,
name|LEASE_WRITE
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|unionfs_vn_create_on_upper_free_out1
goto|;
if|if
condition|(
operator|(
name|error
operator|=
name|VOP_CREATE
argument_list|(
name|udvp
argument_list|,
operator|&
name|vp
argument_list|,
operator|&
name|cn
argument_list|,
name|uvap
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|unionfs_vn_create_on_upper_free_out1
goto|;
if|if
condition|(
operator|(
name|error
operator|=
name|VOP_OPEN
argument_list|(
name|vp
argument_list|,
name|fmode
argument_list|,
name|cred
argument_list|,
name|td
argument_list|,
operator|-
literal|1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
goto|goto
name|unionfs_vn_create_on_upper_free_out1
goto|;
block|}
name|vp
operator|->
name|v_writecount
operator|++
expr_stmt|;
operator|*
name|vpp
operator|=
name|vp
expr_stmt|;
name|unionfs_vn_create_on_upper_free_out1
label|:
name|VOP_UNLOCK
argument_list|(
name|udvp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|unionfs_vn_create_on_upper_free_out2
label|:
if|if
condition|(
name|cn
operator|.
name|cn_flags
operator|&
name|HASBUF
condition|)
block|{
name|uma_zfree
argument_list|(
name|namei_zone
argument_list|,
name|cn
operator|.
name|cn_pnbuf
argument_list|)
expr_stmt|;
name|cn
operator|.
name|cn_flags
operator|&=
operator|~
name|HASBUF
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Copy from lvp to uvp.  *   * lvp and uvp should be locked and opened on entry and will be locked and  * opened on return.  */
end_comment

begin_function
specifier|static
name|int
name|unionfs_copyfile_core
parameter_list|(
name|struct
name|vnode
modifier|*
name|lvp
parameter_list|,
name|struct
name|vnode
modifier|*
name|uvp
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|off_t
name|offset
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|bufoffset
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|struct
name|uio
name|uio
decl_stmt|;
name|struct
name|iovec
name|iov
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|&
name|uio
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|uio
argument_list|)
argument_list|)
expr_stmt|;
name|uio
operator|.
name|uio_td
operator|=
name|td
expr_stmt|;
name|uio
operator|.
name|uio_segflg
operator|=
name|UIO_SYSSPACE
expr_stmt|;
name|uio
operator|.
name|uio_offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|VOP_LEASE
argument_list|(
name|lvp
argument_list|,
name|td
argument_list|,
name|cred
argument_list|,
name|LEASE_READ
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|VOP_LEASE
argument_list|(
name|uvp
argument_list|,
name|td
argument_list|,
name|cred
argument_list|,
name|LEASE_WRITE
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|buf
operator|=
name|malloc
argument_list|(
name|MAXBSIZE
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
while|while
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|offset
operator|=
name|uio
operator|.
name|uio_offset
expr_stmt|;
name|uio
operator|.
name|uio_iov
operator|=
operator|&
name|iov
expr_stmt|;
name|uio
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|iov
operator|.
name|iov_base
operator|=
name|buf
expr_stmt|;
name|iov
operator|.
name|iov_len
operator|=
name|MAXBSIZE
expr_stmt|;
name|uio
operator|.
name|uio_resid
operator|=
name|iov
operator|.
name|iov_len
expr_stmt|;
name|uio
operator|.
name|uio_rw
operator|=
name|UIO_READ
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|VOP_READ
argument_list|(
name|lvp
argument_list|,
operator|&
name|uio
argument_list|,
literal|0
argument_list|,
name|cred
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
operator|(
name|count
operator|=
name|MAXBSIZE
operator|-
name|uio
operator|.
name|uio_resid
operator|)
operator|==
literal|0
condition|)
break|break;
name|bufoffset
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|bufoffset
operator|<
name|count
condition|)
block|{
name|uio
operator|.
name|uio_iov
operator|=
operator|&
name|iov
expr_stmt|;
name|uio
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|iov
operator|.
name|iov_base
operator|=
name|buf
operator|+
name|bufoffset
expr_stmt|;
name|iov
operator|.
name|iov_len
operator|=
name|count
operator|-
name|bufoffset
expr_stmt|;
name|uio
operator|.
name|uio_offset
operator|=
name|offset
operator|+
name|bufoffset
expr_stmt|;
name|uio
operator|.
name|uio_resid
operator|=
name|iov
operator|.
name|iov_len
expr_stmt|;
name|uio
operator|.
name|uio_rw
operator|=
name|UIO_WRITE
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|VOP_WRITE
argument_list|(
name|uvp
argument_list|,
operator|&
name|uio
argument_list|,
literal|0
argument_list|,
name|cred
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
name|bufoffset
operator|+=
operator|(
name|count
operator|-
name|bufoffset
operator|)
operator|-
name|uio
operator|.
name|uio_resid
expr_stmt|;
block|}
name|uio
operator|.
name|uio_offset
operator|=
name|offset
operator|+
name|bufoffset
expr_stmt|;
block|}
name|free
argument_list|(
name|buf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Copy file from lower to upper.  *   * If you need copy of the contents, set 1 to docopy. Otherwise, set 0 to  * docopy.  *   * If no error returned, unp will be updated.  */
end_comment

begin_function
name|int
name|unionfs_copyfile
parameter_list|(
name|struct
name|unionfs_node
modifier|*
name|unp
parameter_list|,
name|int
name|docopy
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|udvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|lvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|uvp
decl_stmt|;
name|struct
name|vattr
name|uva
decl_stmt|;
name|lvp
operator|=
name|unp
operator|->
name|un_lowervp
expr_stmt|;
name|uvp
operator|=
name|NULLVP
expr_stmt|;
if|if
condition|(
operator|(
name|UNIONFSTOV
argument_list|(
name|unp
argument_list|)
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
operator|)
condition|)
return|return
operator|(
name|EROFS
operator|)
return|;
if|if
condition|(
name|unp
operator|->
name|un_dvp
operator|==
name|NULLVP
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|unp
operator|->
name|un_uppervp
operator|!=
name|NULLVP
condition|)
return|return
operator|(
name|EEXIST
operator|)
return|;
name|udvp
operator|=
name|VTOUNIONFS
argument_list|(
name|unp
operator|->
name|un_dvp
argument_list|)
operator|->
name|un_uppervp
expr_stmt|;
if|if
condition|(
name|udvp
operator|==
name|NULLVP
condition|)
return|return
operator|(
name|EROFS
operator|)
return|;
if|if
condition|(
operator|(
name|udvp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
operator|)
condition|)
return|return
operator|(
name|EROFS
operator|)
return|;
name|error
operator|=
name|VOP_ACCESS
argument_list|(
name|lvp
argument_list|,
name|VREAD
argument_list|,
name|cred
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|vn_start_write
argument_list|(
name|udvp
argument_list|,
operator|&
name|mp
argument_list|,
name|V_WAIT
operator||
name|PCATCH
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|unionfs_vn_create_on_upper
argument_list|(
operator|&
name|uvp
argument_list|,
name|udvp
argument_list|,
name|unp
argument_list|,
operator|&
name|uva
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|vn_finished_write
argument_list|(
name|mp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|docopy
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|VOP_OPEN
argument_list|(
name|lvp
argument_list|,
name|FREAD
argument_list|,
name|cred
argument_list|,
name|td
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|unionfs_copyfile_core
argument_list|(
name|lvp
argument_list|,
name|uvp
argument_list|,
name|cred
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|VOP_CLOSE
argument_list|(
name|lvp
argument_list|,
name|FREAD
argument_list|,
name|cred
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
block|}
name|VOP_CLOSE
argument_list|(
name|uvp
argument_list|,
name|FWRITE
argument_list|,
name|cred
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|uvp
operator|->
name|v_writecount
operator|--
expr_stmt|;
name|vn_finished_write
argument_list|(
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
comment|/* Reset the attributes. Ignore errors. */
name|uva
operator|.
name|va_type
operator|=
name|VNON
expr_stmt|;
name|VOP_SETATTR
argument_list|(
name|uvp
argument_list|,
operator|&
name|uva
argument_list|,
name|cred
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
name|unionfs_node_update
argument_list|(
name|unp
argument_list|,
name|uvp
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * It checks whether vp can rmdir. (check empty)  *  * vp is unionfs vnode.  * vp should be locked.  */
end_comment

begin_function
name|int
name|unionfs_check_rmdir
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|int
name|eofflag
decl_stmt|;
name|int
name|lookuperr
decl_stmt|;
name|struct
name|vnode
modifier|*
name|uvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|lvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|tvp
decl_stmt|;
name|struct
name|vattr
name|va
decl_stmt|;
name|struct
name|componentname
name|cn
decl_stmt|;
comment|/* 	 * The size of buf needs to be larger than DIRBLKSIZ. 	 */
name|char
name|buf
index|[
literal|256
operator|*
literal|6
index|]
decl_stmt|;
name|struct
name|dirent
modifier|*
name|dp
decl_stmt|;
name|struct
name|dirent
modifier|*
name|edp
decl_stmt|;
name|struct
name|uio
name|uio
decl_stmt|;
name|struct
name|iovec
name|iov
decl_stmt|;
name|ASSERT_VOP_ELOCKED
argument_list|(
name|vp
argument_list|,
literal|"unionfs_check_rmdir"
argument_list|)
expr_stmt|;
name|eofflag
operator|=
literal|0
expr_stmt|;
name|uvp
operator|=
name|UNIONFSVPTOUPPERVP
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|lvp
operator|=
name|UNIONFSVPTOLOWERVP
argument_list|(
name|vp
argument_list|)
expr_stmt|;
comment|/* check opaque */
if|if
condition|(
operator|(
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|uvp
argument_list|,
operator|&
name|va
argument_list|,
name|cred
argument_list|,
name|td
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|va
operator|.
name|va_flags
operator|&
name|OPAQUE
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* open vnode */
if|if
condition|(
operator|(
name|error
operator|=
name|VOP_OPEN
argument_list|(
name|vp
argument_list|,
name|FREAD
argument_list|,
name|cred
argument_list|,
name|td
argument_list|,
operator|-
literal|1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|uio
operator|.
name|uio_rw
operator|=
name|UIO_READ
expr_stmt|;
name|uio
operator|.
name|uio_segflg
operator|=
name|UIO_SYSSPACE
expr_stmt|;
name|uio
operator|.
name|uio_td
operator|=
name|td
expr_stmt|;
name|uio
operator|.
name|uio_offset
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|error
operator|=
name|mac_check_vnode_readdir
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
name|lvp
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
operator|!
name|error
operator|&&
operator|!
name|eofflag
condition|)
block|{
name|iov
operator|.
name|iov_base
operator|=
name|buf
expr_stmt|;
name|iov
operator|.
name|iov_len
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|uio
operator|.
name|uio_iov
operator|=
operator|&
name|iov
expr_stmt|;
name|uio
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|uio
operator|.
name|uio_resid
operator|=
name|iov
operator|.
name|iov_len
expr_stmt|;
name|error
operator|=
name|VOP_READDIR
argument_list|(
name|lvp
argument_list|,
operator|&
name|uio
argument_list|,
name|cred
argument_list|,
operator|&
name|eofflag
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|edp
operator|=
operator|(
expr|struct
name|dirent
operator|*
operator|)
operator|&
name|buf
index|[
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
name|uio
operator|.
name|uio_resid
index|]
expr_stmt|;
for|for
control|(
name|dp
operator|=
operator|(
expr|struct
name|dirent
operator|*
operator|)
name|buf
init|;
operator|!
name|error
operator|&&
name|dp
operator|<
name|edp
condition|;
name|dp
operator|=
operator|(
expr|struct
name|dirent
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|dp
operator|+
name|dp
operator|->
name|d_reclen
operator|)
control|)
block|{
if|if
condition|(
name|dp
operator|->
name|d_type
operator|==
name|DT_WHT
operator|||
operator|(
name|dp
operator|->
name|d_namlen
operator|==
literal|1
operator|&&
name|dp
operator|->
name|d_name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|)
operator|||
operator|(
name|dp
operator|->
name|d_namlen
operator|==
literal|2
operator|&&
operator|!
name|bcmp
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
literal|".."
argument_list|,
literal|2
argument_list|)
operator|)
condition|)
continue|continue;
name|cn
operator|.
name|cn_namelen
operator|=
name|dp
operator|->
name|d_namlen
expr_stmt|;
name|cn
operator|.
name|cn_pnbuf
operator|=
name|NULL
expr_stmt|;
name|cn
operator|.
name|cn_nameptr
operator|=
name|dp
operator|->
name|d_name
expr_stmt|;
name|cn
operator|.
name|cn_nameiop
operator|=
name|LOOKUP
expr_stmt|;
name|cn
operator|.
name|cn_flags
operator|=
operator|(
name|LOCKPARENT
operator||
name|LOCKLEAF
operator||
name|SAVENAME
operator||
name|RDONLY
operator||
name|ISLASTCN
operator|)
expr_stmt|;
name|cn
operator|.
name|cn_lkflags
operator|=
name|LK_EXCLUSIVE
expr_stmt|;
name|cn
operator|.
name|cn_thread
operator|=
name|td
expr_stmt|;
name|cn
operator|.
name|cn_cred
operator|=
name|cred
expr_stmt|;
name|cn
operator|.
name|cn_consume
operator|=
literal|0
expr_stmt|;
comment|/* 			 * check entry in lower. 			 * Sometimes, readdir function returns 			 * wrong entry. 			 */
name|lookuperr
operator|=
name|VOP_LOOKUP
argument_list|(
name|lvp
argument_list|,
operator|&
name|tvp
argument_list|,
operator|&
name|cn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lookuperr
condition|)
name|vput
argument_list|(
name|tvp
argument_list|)
expr_stmt|;
else|else
continue|continue;
comment|/* skip entry */
comment|/* 			 * check entry 			 * If it has no exist/whiteout entry in upper, 			 * directory is not empty. 			 */
name|cn
operator|.
name|cn_flags
operator|=
operator|(
name|LOCKPARENT
operator||
name|LOCKLEAF
operator||
name|SAVENAME
operator||
name|RDONLY
operator||
name|ISLASTCN
operator|)
expr_stmt|;
name|lookuperr
operator|=
name|VOP_LOOKUP
argument_list|(
name|uvp
argument_list|,
operator|&
name|tvp
argument_list|,
operator|&
name|cn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lookuperr
condition|)
name|vput
argument_list|(
name|tvp
argument_list|)
expr_stmt|;
comment|/* ignore exist or whiteout entry */
if|if
condition|(
operator|!
name|lookuperr
operator|||
operator|(
name|lookuperr
operator|==
name|ENOENT
operator|&&
operator|(
name|cn
operator|.
name|cn_flags
operator|&
name|ISWHITEOUT
operator|)
operator|)
condition|)
continue|continue;
name|error
operator|=
name|ENOTEMPTY
expr_stmt|;
block|}
block|}
comment|/* close vnode */
name|VOP_CLOSE
argument_list|(
name|vp
argument_list|,
name|FREAD
argument_list|,
name|cred
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DIAGNOSTIC
end_ifdef

begin_function
name|struct
name|vnode
modifier|*
name|unionfs_checkuppervp
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|char
modifier|*
name|fil
parameter_list|,
name|int
name|lno
parameter_list|)
block|{
name|struct
name|unionfs_node
modifier|*
name|unp
decl_stmt|;
name|unp
operator|=
name|VTOUNIONFS
argument_list|(
name|vp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
if|if
condition|(
name|vp
operator|->
name|v_op
operator|!=
name|unionfs_vnodeop_p
condition|)
block|{
name|printf
argument_list|(
literal|"unionfs_checkuppervp: on non-unionfs-node.\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KDB
name|kdb_enter
argument_list|(
literal|"unionfs_checkuppervp: on non-unionfs-node.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|panic
argument_list|(
literal|"unionfs_checkuppervp"
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
endif|#
directive|endif
return|return
operator|(
name|unp
operator|->
name|un_uppervp
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|vnode
modifier|*
name|unionfs_checklowervp
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|char
modifier|*
name|fil
parameter_list|,
name|int
name|lno
parameter_list|)
block|{
name|struct
name|unionfs_node
modifier|*
name|unp
decl_stmt|;
name|unp
operator|=
name|VTOUNIONFS
argument_list|(
name|vp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
if|if
condition|(
name|vp
operator|->
name|v_op
operator|!=
name|unionfs_vnodeop_p
condition|)
block|{
name|printf
argument_list|(
literal|"unionfs_checklowervp: on non-unionfs-node.\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KDB
name|kdb_enter
argument_list|(
literal|"unionfs_checklowervp: on non-unionfs-node.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|panic
argument_list|(
literal|"unionfs_checklowervp"
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
endif|#
directive|endif
return|return
operator|(
name|unp
operator|->
name|un_lowervp
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

