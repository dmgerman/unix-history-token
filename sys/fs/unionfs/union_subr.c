begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1994 Jan-Simon Pendry  * Copyright (c) 1994  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Jan-Simon Pendry.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)union_subr.c	8.4 (Berkeley) 2/17/94  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/filedesc.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<miscfs/union/union.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_decl_stmt
specifier|extern
name|int
name|union_init
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* must be power of two, otherwise change UNION_HASH() */
end_comment

begin_define
define|#
directive|define
name|NHASH
value|32
end_define

begin_comment
comment|/* unsigned int ... */
end_comment

begin_define
define|#
directive|define
name|UNION_HASH
parameter_list|(
name|u
parameter_list|,
name|l
parameter_list|)
define|\
value|(((((unsigned long) (u)) + ((unsigned long) l))>> 8)& (NHASH-1))
end_define

begin_expr_stmt
specifier|static
name|LIST_HEAD
argument_list|(
argument|unhead
argument_list|,
argument|union_node
argument_list|)
name|unhead
index|[
name|NHASH
index|]
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|unvplock
index|[
name|NHASH
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_list_lock
name|__P
argument_list|(
operator|(
name|int
name|ix
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|union_list_unlock
name|__P
argument_list|(
operator|(
name|int
name|ix
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|union_updatevp
name|__P
argument_list|(
operator|(
expr|struct
name|union_node
operator|*
name|un
operator|,
expr|struct
name|vnode
operator|*
name|uppervp
operator|,
expr|struct
name|vnode
operator|*
name|lowervp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|union_init
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NHASH
condition|;
name|i
operator|++
control|)
name|LIST_INIT
argument_list|(
operator|&
name|unhead
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|unvplock
argument_list|,
sizeof|sizeof
argument_list|(
name|unvplock
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|union_list_lock
parameter_list|(
name|ix
parameter_list|)
name|int
name|ix
decl_stmt|;
block|{
if|if
condition|(
name|unvplock
index|[
name|ix
index|]
operator|&
name|UN_LOCKED
condition|)
block|{
name|unvplock
index|[
name|ix
index|]
operator||=
name|UN_WANT
expr_stmt|;
operator|(
name|void
operator|)
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|unvplock
index|[
name|ix
index|]
argument_list|,
name|PINOD
argument_list|,
literal|"unllck"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|unvplock
index|[
name|ix
index|]
operator||=
name|UN_LOCKED
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|union_list_unlock
parameter_list|(
name|ix
parameter_list|)
name|int
name|ix
decl_stmt|;
block|{
name|unvplock
index|[
name|ix
index|]
operator|&=
operator|~
name|UN_LOCKED
expr_stmt|;
if|if
condition|(
name|unvplock
index|[
name|ix
index|]
operator|&
name|UN_WANT
condition|)
block|{
name|unvplock
index|[
name|ix
index|]
operator|&=
operator|~
name|UN_WANT
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|unvplock
index|[
name|ix
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|union_updatevp
parameter_list|(
name|un
parameter_list|,
name|uppervp
parameter_list|,
name|lowervp
parameter_list|)
name|struct
name|union_node
modifier|*
name|un
decl_stmt|;
name|struct
name|vnode
modifier|*
name|uppervp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|lowervp
decl_stmt|;
block|{
name|int
name|ohash
init|=
name|UNION_HASH
argument_list|(
name|un
operator|->
name|un_uppervp
argument_list|,
name|un
operator|->
name|un_lowervp
argument_list|)
decl_stmt|;
name|int
name|nhash
init|=
name|UNION_HASH
argument_list|(
name|uppervp
argument_list|,
name|lowervp
argument_list|)
decl_stmt|;
if|if
condition|(
name|ohash
operator|!=
name|nhash
condition|)
block|{
comment|/* 		 * Ensure locking is ordered from lower to higher 		 * to avoid deadlocks. 		 */
if|if
condition|(
name|nhash
operator|<
name|ohash
condition|)
block|{
name|int
name|t
init|=
name|ohash
decl_stmt|;
name|ohash
operator|=
name|nhash
expr_stmt|;
name|nhash
operator|=
name|t
expr_stmt|;
block|}
while|while
condition|(
name|union_list_lock
argument_list|(
name|ohash
argument_list|)
condition|)
continue|continue;
while|while
condition|(
name|union_list_lock
argument_list|(
name|nhash
argument_list|)
condition|)
continue|continue;
name|LIST_REMOVE
argument_list|(
name|un
argument_list|,
name|un_cache
argument_list|)
expr_stmt|;
name|union_list_unlock
argument_list|(
name|ohash
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|union_list_lock
argument_list|(
name|nhash
argument_list|)
condition|)
continue|continue;
block|}
if|if
condition|(
name|un
operator|->
name|un_lowervp
operator|!=
name|lowervp
condition|)
block|{
if|if
condition|(
name|un
operator|->
name|un_lowervp
condition|)
block|{
name|vrele
argument_list|(
name|un
operator|->
name|un_lowervp
argument_list|)
expr_stmt|;
if|if
condition|(
name|un
operator|->
name|un_path
condition|)
block|{
name|free
argument_list|(
name|un
operator|->
name|un_path
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|un
operator|->
name|un_path
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|un
operator|->
name|un_dirvp
condition|)
block|{
name|vrele
argument_list|(
name|un
operator|->
name|un_dirvp
argument_list|)
expr_stmt|;
name|un
operator|->
name|un_dirvp
operator|=
name|NULLVP
expr_stmt|;
block|}
block|}
name|un
operator|->
name|un_lowervp
operator|=
name|lowervp
expr_stmt|;
block|}
if|if
condition|(
name|un
operator|->
name|un_uppervp
operator|!=
name|uppervp
condition|)
block|{
if|if
condition|(
name|un
operator|->
name|un_uppervp
condition|)
name|vrele
argument_list|(
name|un
operator|->
name|un_uppervp
argument_list|)
expr_stmt|;
name|un
operator|->
name|un_uppervp
operator|=
name|uppervp
expr_stmt|;
block|}
if|if
condition|(
name|ohash
operator|!=
name|nhash
condition|)
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|unhead
index|[
name|nhash
index|]
argument_list|,
name|un
argument_list|,
name|un_cache
argument_list|)
expr_stmt|;
name|union_list_unlock
argument_list|(
name|nhash
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|union_newlower
parameter_list|(
name|un
parameter_list|,
name|lowervp
parameter_list|)
name|struct
name|union_node
modifier|*
name|un
decl_stmt|;
name|struct
name|vnode
modifier|*
name|lowervp
decl_stmt|;
block|{
name|union_updatevp
argument_list|(
name|un
argument_list|,
name|un
operator|->
name|un_uppervp
argument_list|,
name|lowervp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|union_newupper
parameter_list|(
name|un
parameter_list|,
name|uppervp
parameter_list|)
name|struct
name|union_node
modifier|*
name|un
decl_stmt|;
name|struct
name|vnode
modifier|*
name|uppervp
decl_stmt|;
block|{
name|union_updatevp
argument_list|(
name|un
argument_list|,
name|uppervp
argument_list|,
name|un
operator|->
name|un_lowervp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * allocate a union_node/vnode pair.  the vnode is  * referenced and locked.  the new vnode is returned  * via (vpp).  (mp) is the mountpoint of the union filesystem,  * (dvp) is the parent directory where the upper layer object  * should exist (but doesn't) and (cnp) is the componentname  * information which is partially copied to allow the upper  * layer object to be created at a later time.  (uppervp)  * and (lowervp) reference the upper and lower layer objects  * being mapped.  either, but not both, can be nil.  * if supplied, (uppervp) is locked.  * the reference is either maintained in the new union_node  * object which is allocated, or they are vrele'd.  *  * all union_nodes are maintained on a singly-linked  * list.  new nodes are only allocated when they cannot  * be found on this list.  entries on the list are  * removed when the vfs reclaim entry is called.  *  * a single lock is kept for the entire list.  this is  * needed because the getnewvnode() function can block  * waiting for a vnode to become free, in which case there  * may be more than one process trying to get the same  * vnode.  this lock is only taken if we are going to  * call getnewvnode, since the kernel itself is single-threaded.  *  * if an entry is found on the list, then call vget() to  * take a reference.  this is done because there may be  * zero references to it and so it needs to removed from  * the vnode free list.  */
end_comment

begin_function
name|int
name|union_allocvp
parameter_list|(
name|vpp
parameter_list|,
name|mp
parameter_list|,
name|undvp
parameter_list|,
name|dvp
parameter_list|,
name|cnp
parameter_list|,
name|uppervp
parameter_list|,
name|lowervp
parameter_list|)
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|undvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|dvp
decl_stmt|;
comment|/* may be null */
name|struct
name|componentname
modifier|*
name|cnp
decl_stmt|;
comment|/* may be null */
name|struct
name|vnode
modifier|*
name|uppervp
decl_stmt|;
comment|/* may be null */
name|struct
name|vnode
modifier|*
name|lowervp
decl_stmt|;
comment|/* may be null */
block|{
name|int
name|error
decl_stmt|;
name|struct
name|union_node
modifier|*
name|un
init|=
literal|0
decl_stmt|;
name|struct
name|vnode
modifier|*
name|xlowervp
init|=
name|NULLVP
decl_stmt|;
name|int
name|hash
init|=
literal|0
decl_stmt|;
name|int
name|try
decl_stmt|;
if|if
condition|(
name|uppervp
operator|==
name|NULLVP
operator|&&
name|lowervp
operator|==
name|NULLVP
condition|)
name|panic
argument_list|(
literal|"union: unidentifiable allocation"
argument_list|)
expr_stmt|;
if|if
condition|(
name|uppervp
operator|&&
name|lowervp
operator|&&
operator|(
name|uppervp
operator|->
name|v_type
operator|!=
name|lowervp
operator|->
name|v_type
operator|)
condition|)
block|{
name|xlowervp
operator|=
name|lowervp
expr_stmt|;
name|lowervp
operator|=
name|NULLVP
expr_stmt|;
block|}
name|loop
label|:
for|for
control|(
name|try
operator|=
literal|0
init|;
name|try
operator|<
literal|3
condition|;
name|try
operator|++
control|)
block|{
switch|switch
condition|(
name|try
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
name|lowervp
operator|==
name|NULLVP
condition|)
continue|continue;
name|hash
operator|=
name|UNION_HASH
argument_list|(
name|uppervp
argument_list|,
name|lowervp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
if|if
condition|(
name|uppervp
operator|==
name|NULLVP
condition|)
continue|continue;
name|hash
operator|=
name|UNION_HASH
argument_list|(
name|uppervp
argument_list|,
name|NULLVP
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
if|if
condition|(
name|lowervp
operator|==
name|NULLVP
condition|)
continue|continue;
name|hash
operator|=
name|UNION_HASH
argument_list|(
name|NULLVP
argument_list|,
name|lowervp
argument_list|)
expr_stmt|;
break|break;
block|}
while|while
condition|(
name|union_list_lock
argument_list|(
name|hash
argument_list|)
condition|)
continue|continue;
for|for
control|(
name|un
operator|=
name|unhead
index|[
name|hash
index|]
operator|.
name|lh_first
init|;
name|un
operator|!=
literal|0
condition|;
name|un
operator|=
name|un
operator|->
name|un_cache
operator|.
name|le_next
control|)
block|{
if|if
condition|(
operator|(
name|un
operator|->
name|un_lowervp
operator|==
name|lowervp
operator|||
name|un
operator|->
name|un_lowervp
operator|==
name|NULLVP
operator|)
operator|&&
operator|(
name|un
operator|->
name|un_uppervp
operator|==
name|uppervp
operator|||
name|un
operator|->
name|un_uppervp
operator|==
name|NULLVP
operator|)
operator|&&
operator|(
name|UNIONTOV
argument_list|(
name|un
argument_list|)
operator|->
name|v_mount
operator|==
name|mp
operator|)
condition|)
block|{
if|if
condition|(
name|vget
argument_list|(
name|UNIONTOV
argument_list|(
name|un
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|union_list_unlock
argument_list|(
name|hash
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
break|break;
block|}
block|}
name|union_list_unlock
argument_list|(
name|hash
argument_list|)
expr_stmt|;
if|if
condition|(
name|un
condition|)
break|break;
block|}
if|if
condition|(
name|un
condition|)
block|{
comment|/* 		 * Obtain a lock on the union_node. 		 * uppervp is locked, though un->un_uppervp 		 * may not be.  this doesn't break the locking 		 * hierarchy since in the case that un->un_uppervp 		 * is not yet locked it will be vrele'd and replaced 		 * with uppervp. 		 */
if|if
condition|(
operator|(
name|dvp
operator|!=
name|NULLVP
operator|)
operator|&&
operator|(
name|uppervp
operator|==
name|dvp
operator|)
condition|)
block|{
comment|/* 			 * Access ``.'', so (un) will already 			 * be locked.  Since this process has 			 * the lock on (uppervp) no other 			 * process can hold the lock on (un). 			 */
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
operator|(
name|un
operator|->
name|un_flags
operator|&
name|UN_LOCKED
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"union: . not locked"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|curproc
operator|&&
name|un
operator|->
name|un_pid
operator|!=
name|curproc
operator|->
name|p_pid
operator|&&
name|un
operator|->
name|un_pid
operator|>
operator|-
literal|1
operator|&&
name|curproc
operator|->
name|p_pid
operator|>
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"union: allocvp not lock owner"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
if|if
condition|(
name|un
operator|->
name|un_flags
operator|&
name|UN_LOCKED
condition|)
block|{
name|vrele
argument_list|(
name|UNIONTOV
argument_list|(
name|un
argument_list|)
argument_list|)
expr_stmt|;
name|un
operator|->
name|un_flags
operator||=
name|UN_WANT
expr_stmt|;
operator|(
name|void
operator|)
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|un
operator|->
name|un_flags
argument_list|,
name|PINOD
argument_list|,
literal|"unalvp"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
name|un
operator|->
name|un_flags
operator||=
name|UN_LOCKED
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|curproc
condition|)
name|un
operator|->
name|un_pid
operator|=
name|curproc
operator|->
name|p_pid
expr_stmt|;
else|else
name|un
operator|->
name|un_pid
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 		 * At this point, the union_node is locked, 		 * un->un_uppervp may not be locked, and uppervp 		 * is locked or nil. 		 */
comment|/* 		 * Save information about the upper layer. 		 */
if|if
condition|(
name|uppervp
operator|!=
name|un
operator|->
name|un_uppervp
condition|)
block|{
name|union_newupper
argument_list|(
name|un
argument_list|,
name|uppervp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|uppervp
condition|)
block|{
name|vrele
argument_list|(
name|uppervp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|un
operator|->
name|un_uppervp
condition|)
block|{
name|un
operator|->
name|un_flags
operator||=
name|UN_ULOCK
expr_stmt|;
name|un
operator|->
name|un_flags
operator|&=
operator|~
name|UN_KLOCK
expr_stmt|;
block|}
comment|/* 		 * Save information about the lower layer. 		 * This needs to keep track of pathname 		 * and directory information which union_vn_create 		 * might need. 		 */
if|if
condition|(
name|lowervp
operator|!=
name|un
operator|->
name|un_lowervp
condition|)
block|{
name|union_newlower
argument_list|(
name|un
argument_list|,
name|lowervp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnp
operator|&&
operator|(
name|lowervp
operator|!=
name|NULLVP
operator|)
operator|&&
operator|(
name|lowervp
operator|->
name|v_type
operator|==
name|VREG
operator|)
condition|)
block|{
name|un
operator|->
name|un_hash
operator|=
name|cnp
operator|->
name|cn_hash
expr_stmt|;
name|un
operator|->
name|un_path
operator|=
name|malloc
argument_list|(
name|cnp
operator|->
name|cn_namelen
operator|+
literal|1
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|cnp
operator|->
name|cn_nameptr
argument_list|,
name|un
operator|->
name|un_path
argument_list|,
name|cnp
operator|->
name|cn_namelen
argument_list|)
expr_stmt|;
name|un
operator|->
name|un_path
index|[
name|cnp
operator|->
name|cn_namelen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|VREF
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|un
operator|->
name|un_dirvp
operator|=
name|dvp
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|lowervp
condition|)
block|{
name|vrele
argument_list|(
name|lowervp
argument_list|)
expr_stmt|;
block|}
operator|*
name|vpp
operator|=
name|UNIONTOV
argument_list|(
name|un
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * otherwise lock the vp list while we call getnewvnode 	 * since that can block. 	 */
name|hash
operator|=
name|UNION_HASH
argument_list|(
name|uppervp
argument_list|,
name|lowervp
argument_list|)
expr_stmt|;
if|if
condition|(
name|union_list_lock
argument_list|(
name|hash
argument_list|)
condition|)
goto|goto
name|loop
goto|;
name|error
operator|=
name|getnewvnode
argument_list|(
name|VT_UNION
argument_list|,
name|mp
argument_list|,
name|union_vnodeop_p
argument_list|,
name|vpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|uppervp
condition|)
block|{
if|if
condition|(
name|dvp
operator|==
name|uppervp
condition|)
name|vrele
argument_list|(
name|uppervp
argument_list|)
expr_stmt|;
else|else
name|vput
argument_list|(
name|uppervp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lowervp
condition|)
name|vrele
argument_list|(
name|lowervp
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|MALLOC
argument_list|(
operator|(
operator|*
name|vpp
operator|)
operator|->
name|v_data
argument_list|,
name|void
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|union_node
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|uppervp
condition|)
operator|(
operator|*
name|vpp
operator|)
operator|->
name|v_type
operator|=
name|uppervp
operator|->
name|v_type
expr_stmt|;
else|else
operator|(
operator|*
name|vpp
operator|)
operator|->
name|v_type
operator|=
name|lowervp
operator|->
name|v_type
expr_stmt|;
name|un
operator|=
name|VTOUNION
argument_list|(
operator|*
name|vpp
argument_list|)
expr_stmt|;
name|un
operator|->
name|un_vnode
operator|=
operator|*
name|vpp
expr_stmt|;
name|un
operator|->
name|un_uppervp
operator|=
name|uppervp
expr_stmt|;
name|un
operator|->
name|un_lowervp
operator|=
name|lowervp
expr_stmt|;
name|un
operator|->
name|un_openl
operator|=
literal|0
expr_stmt|;
name|un
operator|->
name|un_flags
operator|=
name|UN_LOCKED
expr_stmt|;
if|if
condition|(
name|un
operator|->
name|un_uppervp
condition|)
name|un
operator|->
name|un_flags
operator||=
name|UN_ULOCK
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|curproc
condition|)
name|un
operator|->
name|un_pid
operator|=
name|curproc
operator|->
name|p_pid
expr_stmt|;
else|else
name|un
operator|->
name|un_pid
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|cnp
operator|&&
operator|(
name|lowervp
operator|!=
name|NULLVP
operator|)
operator|&&
operator|(
name|lowervp
operator|->
name|v_type
operator|==
name|VREG
operator|)
condition|)
block|{
name|un
operator|->
name|un_hash
operator|=
name|cnp
operator|->
name|cn_hash
expr_stmt|;
name|un
operator|->
name|un_path
operator|=
name|malloc
argument_list|(
name|cnp
operator|->
name|cn_namelen
operator|+
literal|1
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|cnp
operator|->
name|cn_nameptr
argument_list|,
name|un
operator|->
name|un_path
argument_list|,
name|cnp
operator|->
name|cn_namelen
argument_list|)
expr_stmt|;
name|un
operator|->
name|un_path
index|[
name|cnp
operator|->
name|cn_namelen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|VREF
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|un
operator|->
name|un_dirvp
operator|=
name|dvp
expr_stmt|;
block|}
else|else
block|{
name|un
operator|->
name|un_hash
operator|=
literal|0
expr_stmt|;
name|un
operator|->
name|un_path
operator|=
literal|0
expr_stmt|;
name|un
operator|->
name|un_dirvp
operator|=
literal|0
expr_stmt|;
block|}
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|unhead
index|[
name|hash
index|]
argument_list|,
name|un
argument_list|,
name|un_cache
argument_list|)
expr_stmt|;
if|if
condition|(
name|xlowervp
condition|)
name|vrele
argument_list|(
name|xlowervp
argument_list|)
expr_stmt|;
name|out
label|:
name|union_list_unlock
argument_list|(
name|hash
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|union_freevp
parameter_list|(
name|vp
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
block|{
name|struct
name|union_node
modifier|*
name|un
init|=
name|VTOUNION
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|LIST_REMOVE
argument_list|(
name|un
argument_list|,
name|un_cache
argument_list|)
expr_stmt|;
if|if
condition|(
name|un
operator|->
name|un_uppervp
condition|)
name|vrele
argument_list|(
name|un
operator|->
name|un_uppervp
argument_list|)
expr_stmt|;
if|if
condition|(
name|un
operator|->
name|un_lowervp
condition|)
name|vrele
argument_list|(
name|un
operator|->
name|un_lowervp
argument_list|)
expr_stmt|;
if|if
condition|(
name|un
operator|->
name|un_dirvp
condition|)
name|vrele
argument_list|(
name|un
operator|->
name|un_dirvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|un
operator|->
name|un_path
condition|)
name|free
argument_list|(
name|un
operator|->
name|un_path
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|vp
operator|->
name|v_data
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|vp
operator|->
name|v_data
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * copyfile.  copy the vnode (fvp) to the vnode (tvp)  * using a sequence of reads and writes.  both (fvp)  * and (tvp) are locked on entry and exit.  */
end_comment

begin_function
name|int
name|union_copyfile
parameter_list|(
name|p
parameter_list|,
name|cred
parameter_list|,
name|fvp
parameter_list|,
name|tvp
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|struct
name|vnode
modifier|*
name|fvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|tvp
decl_stmt|;
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|struct
name|uio
name|uio
decl_stmt|;
name|struct
name|iovec
name|iov
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* 	 * strategy: 	 * allocate a buffer of size MAXBSIZE. 	 * loop doing reads and writes, keeping track 	 * of the current uio offset. 	 * give up at the first sign of trouble. 	 */
name|uio
operator|.
name|uio_procp
operator|=
name|p
expr_stmt|;
name|uio
operator|.
name|uio_segflg
operator|=
name|UIO_SYSSPACE
expr_stmt|;
name|uio
operator|.
name|uio_offset
operator|=
literal|0
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|fvp
argument_list|)
expr_stmt|;
comment|/* XXX */
name|LEASE_CHECK
argument_list|(
name|fvp
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|LEASE_READ
argument_list|)
expr_stmt|;
name|VOP_LOCK
argument_list|(
name|fvp
argument_list|)
expr_stmt|;
comment|/* XXX */
name|VOP_UNLOCK
argument_list|(
name|tvp
argument_list|)
expr_stmt|;
comment|/* XXX */
name|LEASE_CHECK
argument_list|(
name|tvp
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|LEASE_WRITE
argument_list|)
expr_stmt|;
name|VOP_LOCK
argument_list|(
name|tvp
argument_list|)
expr_stmt|;
comment|/* XXX */
name|buf
operator|=
name|malloc
argument_list|(
name|MAXBSIZE
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
comment|/* ugly loop follows... */
do|do
block|{
name|off_t
name|offset
init|=
name|uio
operator|.
name|uio_offset
decl_stmt|;
name|uio
operator|.
name|uio_iov
operator|=
operator|&
name|iov
expr_stmt|;
name|uio
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|iov
operator|.
name|iov_base
operator|=
name|buf
expr_stmt|;
name|iov
operator|.
name|iov_len
operator|=
name|MAXBSIZE
expr_stmt|;
name|uio
operator|.
name|uio_resid
operator|=
name|iov
operator|.
name|iov_len
expr_stmt|;
name|uio
operator|.
name|uio_rw
operator|=
name|UIO_READ
expr_stmt|;
name|error
operator|=
name|VOP_READ
argument_list|(
name|fvp
argument_list|,
operator|&
name|uio
argument_list|,
literal|0
argument_list|,
name|cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|uio
operator|.
name|uio_iov
operator|=
operator|&
name|iov
expr_stmt|;
name|uio
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|iov
operator|.
name|iov_base
operator|=
name|buf
expr_stmt|;
name|iov
operator|.
name|iov_len
operator|=
name|MAXBSIZE
operator|-
name|uio
operator|.
name|uio_resid
expr_stmt|;
name|uio
operator|.
name|uio_offset
operator|=
name|offset
expr_stmt|;
name|uio
operator|.
name|uio_rw
operator|=
name|UIO_WRITE
expr_stmt|;
name|uio
operator|.
name|uio_resid
operator|=
name|iov
operator|.
name|iov_len
expr_stmt|;
if|if
condition|(
name|uio
operator|.
name|uio_resid
operator|==
literal|0
condition|)
break|break;
do|do
block|{
name|error
operator|=
name|VOP_WRITE
argument_list|(
name|tvp
argument_list|,
operator|&
name|uio
argument_list|,
literal|0
argument_list|,
name|cred
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|uio
operator|.
name|uio_resid
operator|>
literal|0
operator|)
operator|&&
operator|(
name|error
operator|==
literal|0
operator|)
condition|)
do|;
block|}
block|}
do|while
condition|(
name|error
operator|==
literal|0
condition|)
do|;
name|free
argument_list|(
name|buf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create a shadow directory in the upper layer.  * The new vnode is returned locked.  *  * (um) points to the union mount structure for access to the  * the mounting process's credentials.  * (dvp) is the directory in which to create the shadow directory.  * it is unlocked on entry and exit.  * (cnp) is the componentname to be created.  * (vpp) is the returned newly created shadow directory, which  * is returned locked.  */
end_comment

begin_function
name|int
name|union_mkshadow
parameter_list|(
name|um
parameter_list|,
name|dvp
parameter_list|,
name|cnp
parameter_list|,
name|vpp
parameter_list|)
name|struct
name|union_mount
modifier|*
name|um
decl_stmt|;
name|struct
name|vnode
modifier|*
name|dvp
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
decl_stmt|;
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|struct
name|vattr
name|va
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|cnp
operator|->
name|cn_proc
decl_stmt|;
name|struct
name|componentname
name|cn
decl_stmt|;
comment|/* 	 * policy: when creating the shadow directory in the 	 * upper layer, create it owned by the user who did 	 * the mount, group from parent directory, and mode 	 * 777 modified by umask (ie mostly identical to the 	 * mkdir syscall).  (jsp, kb) 	 */
comment|/* 	 * A new componentname structure must be faked up because 	 * there is no way to know where the upper level cnp came 	 * from or what it is being used for.  This must duplicate 	 * some of the work done by NDINIT, some of the work done 	 * by namei, some of the work done by lookup and some of 	 * the work done by VOP_LOOKUP when given a CREATE flag. 	 * Conclusion: Horrible. 	 * 	 * The pathname buffer will be FREEed by VOP_MKDIR. 	 */
name|cn
operator|.
name|cn_pnbuf
operator|=
name|malloc
argument_list|(
name|cnp
operator|->
name|cn_namelen
operator|+
literal|1
argument_list|,
name|M_NAMEI
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|cnp
operator|->
name|cn_nameptr
argument_list|,
name|cn
operator|.
name|cn_pnbuf
argument_list|,
name|cnp
operator|->
name|cn_namelen
argument_list|)
expr_stmt|;
name|cn
operator|.
name|cn_pnbuf
index|[
name|cnp
operator|->
name|cn_namelen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|cn
operator|.
name|cn_nameiop
operator|=
name|CREATE
expr_stmt|;
name|cn
operator|.
name|cn_flags
operator|=
operator|(
name|LOCKPARENT
operator||
name|HASBUF
operator||
name|SAVENAME
operator||
name|SAVESTART
operator||
name|ISLASTCN
operator|)
expr_stmt|;
name|cn
operator|.
name|cn_proc
operator|=
name|cnp
operator|->
name|cn_proc
expr_stmt|;
if|if
condition|(
name|um
operator|->
name|um_op
operator|==
name|UNMNT_ABOVE
condition|)
name|cn
operator|.
name|cn_cred
operator|=
name|cnp
operator|->
name|cn_cred
expr_stmt|;
else|else
name|cn
operator|.
name|cn_cred
operator|=
name|um
operator|->
name|um_cred
expr_stmt|;
name|cn
operator|.
name|cn_nameptr
operator|=
name|cn
operator|.
name|cn_pnbuf
expr_stmt|;
name|cn
operator|.
name|cn_namelen
operator|=
name|cnp
operator|->
name|cn_namelen
expr_stmt|;
name|cn
operator|.
name|cn_hash
operator|=
name|cnp
operator|->
name|cn_hash
expr_stmt|;
name|cn
operator|.
name|cn_consume
operator|=
name|cnp
operator|->
name|cn_consume
expr_stmt|;
name|VREF
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|error
operator|=
name|relookup
argument_list|(
name|dvp
argument_list|,
name|vpp
argument_list|,
operator|&
name|cn
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|vrele
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|vpp
condition|)
block|{
name|VOP_ABORTOP
argument_list|(
name|dvp
argument_list|,
operator|&
name|cn
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
operator|*
name|vpp
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|NULLVP
expr_stmt|;
return|return
operator|(
name|EEXIST
operator|)
return|;
block|}
name|VATTR_NULL
argument_list|(
operator|&
name|va
argument_list|)
expr_stmt|;
name|va
operator|.
name|va_type
operator|=
name|VDIR
expr_stmt|;
name|va
operator|.
name|va_mode
operator|=
name|um
operator|->
name|um_cmode
expr_stmt|;
comment|/* LEASE_CHECK: dvp is locked */
name|LEASE_CHECK
argument_list|(
name|dvp
argument_list|,
name|p
argument_list|,
name|p
operator|->
name|p_ucred
argument_list|,
name|LEASE_WRITE
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_MKDIR
argument_list|(
name|dvp
argument_list|,
name|vpp
argument_list|,
operator|&
name|cn
argument_list|,
operator|&
name|va
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * union_vn_create: creates and opens a new shadow file  * on the upper union layer.  this function is similar  * in spirit to calling vn_open but it avoids calling namei().  * the problem with calling namei is that a) it locks too many  * things, and b) it doesn't start at the "right" directory,  * whereas relookup is told where to start.  */
end_comment

begin_function
name|int
name|union_vn_create
parameter_list|(
name|vpp
parameter_list|,
name|un
parameter_list|,
name|p
parameter_list|)
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
decl_stmt|;
name|struct
name|union_node
modifier|*
name|un
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|p
operator|->
name|p_ucred
decl_stmt|;
name|struct
name|vattr
name|vat
decl_stmt|;
name|struct
name|vattr
modifier|*
name|vap
init|=
operator|&
name|vat
decl_stmt|;
name|int
name|fmode
init|=
name|FFLAGS
argument_list|(
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
operator||
name|O_EXCL
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|cmode
init|=
name|UN_FILEMODE
operator|&
operator|~
name|p
operator|->
name|p_fd
operator|->
name|fd_cmask
decl_stmt|;
name|struct
name|componentname
name|cn
decl_stmt|;
operator|*
name|vpp
operator|=
name|NULLVP
expr_stmt|;
comment|/* 	 * Build a new componentname structure (for the same 	 * reasons outlines in union_mkshadow). 	 * The difference here is that the file is owned by 	 * the current user, rather than by the person who 	 * did the mount, since the current user needs to be 	 * able to write the file (that's why it is being 	 * copied in the first place). 	 */
name|cn
operator|.
name|cn_namelen
operator|=
name|strlen
argument_list|(
name|un
operator|->
name|un_path
argument_list|)
expr_stmt|;
name|cn
operator|.
name|cn_pnbuf
operator|=
operator|(
name|caddr_t
operator|)
name|malloc
argument_list|(
name|cn
operator|.
name|cn_namelen
argument_list|,
name|M_NAMEI
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|un
operator|->
name|un_path
argument_list|,
name|cn
operator|.
name|cn_pnbuf
argument_list|,
name|cn
operator|.
name|cn_namelen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|cn
operator|.
name|cn_nameiop
operator|=
name|CREATE
expr_stmt|;
name|cn
operator|.
name|cn_flags
operator|=
operator|(
name|LOCKPARENT
operator||
name|HASBUF
operator||
name|SAVENAME
operator||
name|SAVESTART
operator||
name|ISLASTCN
operator|)
expr_stmt|;
name|cn
operator|.
name|cn_proc
operator|=
name|p
expr_stmt|;
name|cn
operator|.
name|cn_cred
operator|=
name|p
operator|->
name|p_ucred
expr_stmt|;
name|cn
operator|.
name|cn_nameptr
operator|=
name|cn
operator|.
name|cn_pnbuf
expr_stmt|;
name|cn
operator|.
name|cn_hash
operator|=
name|un
operator|->
name|un_hash
expr_stmt|;
name|cn
operator|.
name|cn_consume
operator|=
literal|0
expr_stmt|;
name|VREF
argument_list|(
name|un
operator|->
name|un_dirvp
argument_list|)
expr_stmt|;
name|error
operator|=
name|relookup
argument_list|(
name|un
operator|->
name|un_dirvp
argument_list|,
operator|&
name|vp
argument_list|,
operator|&
name|cn
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|vrele
argument_list|(
name|un
operator|->
name|un_dirvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
condition|)
block|{
name|VOP_ABORTOP
argument_list|(
name|un
operator|->
name|un_dirvp
argument_list|,
operator|&
name|cn
argument_list|)
expr_stmt|;
if|if
condition|(
name|un
operator|->
name|un_dirvp
operator|==
name|vp
condition|)
name|vrele
argument_list|(
name|un
operator|->
name|un_dirvp
argument_list|)
expr_stmt|;
else|else
name|vput
argument_list|(
name|un
operator|->
name|un_dirvp
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EEXIST
operator|)
return|;
block|}
comment|/* 	 * Good - there was no race to create the file 	 * so go ahead and create it.  The permissions 	 * on the file will be 0666 modified by the 	 * current user's umask.  Access to the file, while 	 * it is unioned, will require access to the top *and* 	 * bottom files.  Access when not unioned will simply 	 * require access to the top-level file. 	 * TODO: confirm choice of access permissions. 	 */
name|VATTR_NULL
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|vap
operator|->
name|va_type
operator|=
name|VREG
expr_stmt|;
name|vap
operator|->
name|va_mode
operator|=
name|cmode
expr_stmt|;
name|LEASE_CHECK
argument_list|(
name|un
operator|->
name|un_dirvp
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|LEASE_WRITE
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_CREATE
argument_list|(
name|un
operator|->
name|un_dirvp
argument_list|,
operator|&
name|vp
argument_list|,
operator|&
name|cn
argument_list|,
name|vap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|VOP_OPEN
argument_list|(
name|vp
argument_list|,
name|fmode
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|vp
operator|->
name|v_writecount
operator|++
expr_stmt|;
operator|*
name|vpp
operator|=
name|vp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|union_vn_close
parameter_list|(
name|vp
parameter_list|,
name|fmode
parameter_list|,
name|cred
parameter_list|,
name|p
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|int
name|fmode
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
if|if
condition|(
name|fmode
operator|&
name|FWRITE
condition|)
operator|--
name|vp
operator|->
name|v_writecount
expr_stmt|;
return|return
operator|(
name|VOP_CLOSE
argument_list|(
name|vp
argument_list|,
name|fmode
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|union_removed_upper
parameter_list|(
name|un
parameter_list|)
name|struct
name|union_node
modifier|*
name|un
decl_stmt|;
block|{
if|if
condition|(
name|un
operator|->
name|un_flags
operator|&
name|UN_ULOCK
condition|)
block|{
name|un
operator|->
name|un_flags
operator|&=
operator|~
name|UN_ULOCK
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|un
operator|->
name|un_uppervp
argument_list|)
expr_stmt|;
block|}
name|union_newupper
argument_list|(
name|un
argument_list|,
name|NULLVP
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|vnode
modifier|*
name|union_lowervp
parameter_list|(
name|vp
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
block|{
name|struct
name|union_node
modifier|*
name|un
init|=
name|VTOUNION
argument_list|(
name|vp
argument_list|)
decl_stmt|;
if|if
condition|(
name|un
operator|->
name|un_lowervp
operator|&&
operator|(
name|vp
operator|->
name|v_type
operator|==
name|un
operator|->
name|un_lowervp
operator|->
name|v_type
operator|)
condition|)
block|{
if|if
condition|(
name|vget
argument_list|(
name|un
operator|->
name|un_lowervp
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
name|NULLVP
operator|)
return|;
block|}
return|return
operator|(
name|un
operator|->
name|un_lowervp
operator|)
return|;
block|}
end_function

end_unit

