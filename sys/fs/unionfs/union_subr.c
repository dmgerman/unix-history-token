begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1994 Jan-Simon Pendry  * Copyright (c) 1994  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Jan-Simon Pendry.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)union_subr.c	8.20 (Berkeley) 5/20/95  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/filedesc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_comment
comment|/* for vnode_pager_setsize */
end_comment

begin_include
include|#
directive|include
file|<vm/vm_zone.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_comment
comment|/* for vm cache coherency */
end_comment

begin_include
include|#
directive|include
file|<fs/unionfs/union.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_decl_stmt
specifier|extern
name|int
name|union_init
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* must be power of two, otherwise change UNION_HASH() */
end_comment

begin_define
define|#
directive|define
name|NHASH
value|32
end_define

begin_comment
comment|/* unsigned int ... */
end_comment

begin_define
define|#
directive|define
name|UNION_HASH
parameter_list|(
name|u
parameter_list|,
name|l
parameter_list|)
define|\
value|(((((uintptr_t) (u)) + ((uintptr_t) l))>> 8)& (NHASH-1))
end_define

begin_expr_stmt
specifier|static
name|LIST_HEAD
argument_list|(
argument|unhead
argument_list|,
argument|union_node
argument_list|)
name|unhead
index|[
name|NHASH
index|]
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|unvplock
index|[
name|NHASH
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|union_dircache_r
name|__P
argument_list|(
operator|(
expr|struct
name|vnode
operator|*
name|vp
operator|,
expr|struct
name|vnode
operator|*
operator|*
operator|*
name|vppp
operator|,
name|int
operator|*
name|cntp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_list_lock
name|__P
argument_list|(
operator|(
name|int
name|ix
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|union_list_unlock
name|__P
argument_list|(
operator|(
name|int
name|ix
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_relookup
name|__P
argument_list|(
operator|(
expr|struct
name|union_mount
operator|*
name|um
operator|,
expr|struct
name|vnode
operator|*
name|dvp
operator|,
expr|struct
name|vnode
operator|*
operator|*
name|vpp
operator|,
expr|struct
name|componentname
operator|*
name|cnp
operator|,
expr|struct
name|componentname
operator|*
name|cn
operator|,
name|char
operator|*
name|path
operator|,
name|int
name|pathlen
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|union_updatevp
name|__P
argument_list|(
operator|(
expr|struct
name|union_node
operator|*
name|un
operator|,
expr|struct
name|vnode
operator|*
name|uppervp
operator|,
expr|struct
name|vnode
operator|*
name|lowervp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|union_newlower
name|__P
argument_list|(
operator|(
expr|struct
name|union_node
operator|*
operator|,
expr|struct
name|vnode
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|union_newupper
name|__P
argument_list|(
operator|(
expr|struct
name|union_node
operator|*
operator|,
expr|struct
name|vnode
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_copyfile
name|__P
argument_list|(
operator|(
expr|struct
name|vnode
operator|*
operator|,
expr|struct
name|vnode
operator|*
operator|,
expr|struct
name|ucred
operator|*
operator|,
expr|struct
name|thread
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_vn_create
name|__P
argument_list|(
operator|(
expr|struct
name|vnode
operator|*
operator|*
operator|,
expr|struct
name|union_node
operator|*
operator|,
expr|struct
name|thread
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_vn_close
name|__P
argument_list|(
operator|(
expr|struct
name|vnode
operator|*
operator|,
name|int
operator|,
expr|struct
name|ucred
operator|*
operator|,
expr|struct
name|thread
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|union_init
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NHASH
condition|;
name|i
operator|++
control|)
name|LIST_INIT
argument_list|(
operator|&
name|unhead
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|unvplock
argument_list|,
sizeof|sizeof
argument_list|(
name|unvplock
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|union_list_lock
parameter_list|(
name|ix
parameter_list|)
name|int
name|ix
decl_stmt|;
block|{
if|if
condition|(
name|unvplock
index|[
name|ix
index|]
operator|&
name|UNVP_LOCKED
condition|)
block|{
name|unvplock
index|[
name|ix
index|]
operator||=
name|UNVP_WANT
expr_stmt|;
operator|(
name|void
operator|)
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|unvplock
index|[
name|ix
index|]
argument_list|,
name|PINOD
argument_list|,
literal|"unllck"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|unvplock
index|[
name|ix
index|]
operator||=
name|UNVP_LOCKED
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|union_list_unlock
parameter_list|(
name|ix
parameter_list|)
name|int
name|ix
decl_stmt|;
block|{
name|unvplock
index|[
name|ix
index|]
operator|&=
operator|~
name|UNVP_LOCKED
expr_stmt|;
if|if
condition|(
name|unvplock
index|[
name|ix
index|]
operator|&
name|UNVP_WANT
condition|)
block|{
name|unvplock
index|[
name|ix
index|]
operator|&=
operator|~
name|UNVP_WANT
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|unvplock
index|[
name|ix
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *	union_updatevp:  *  *	The uppervp, if not NULL, must be referenced and not locked by us  *	The lowervp, if not NULL, must be referenced.  *  *	if uppervp and lowervp match pointers already installed, nothing  *	happens. The passed vp's (when matching) are not adjusted.  This  *	routine may only be called by union_newupper() and union_newlower().  */
end_comment

begin_function
specifier|static
name|void
name|union_updatevp
parameter_list|(
name|un
parameter_list|,
name|uppervp
parameter_list|,
name|lowervp
parameter_list|)
name|struct
name|union_node
modifier|*
name|un
decl_stmt|;
name|struct
name|vnode
modifier|*
name|uppervp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|lowervp
decl_stmt|;
block|{
name|int
name|ohash
init|=
name|UNION_HASH
argument_list|(
name|un
operator|->
name|un_uppervp
argument_list|,
name|un
operator|->
name|un_lowervp
argument_list|)
decl_stmt|;
name|int
name|nhash
init|=
name|UNION_HASH
argument_list|(
name|uppervp
argument_list|,
name|lowervp
argument_list|)
decl_stmt|;
name|int
name|docache
init|=
operator|(
name|lowervp
operator|!=
name|NULLVP
operator|||
name|uppervp
operator|!=
name|NULLVP
operator|)
decl_stmt|;
name|int
name|lhash
decl_stmt|,
name|uhash
decl_stmt|;
comment|/* 	 * Ensure locking is ordered from lower to higher 	 * to avoid deadlocks. 	 */
if|if
condition|(
name|nhash
operator|<
name|ohash
condition|)
block|{
name|lhash
operator|=
name|nhash
expr_stmt|;
name|uhash
operator|=
name|ohash
expr_stmt|;
block|}
else|else
block|{
name|lhash
operator|=
name|ohash
expr_stmt|;
name|uhash
operator|=
name|nhash
expr_stmt|;
block|}
if|if
condition|(
name|lhash
operator|!=
name|uhash
condition|)
block|{
while|while
condition|(
name|union_list_lock
argument_list|(
name|lhash
argument_list|)
condition|)
continue|continue;
block|}
while|while
condition|(
name|union_list_lock
argument_list|(
name|uhash
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|ohash
operator|!=
name|nhash
operator|||
operator|!
name|docache
condition|)
block|{
if|if
condition|(
name|un
operator|->
name|un_flags
operator|&
name|UN_CACHED
condition|)
block|{
name|un
operator|->
name|un_flags
operator|&=
operator|~
name|UN_CACHED
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|un
argument_list|,
name|un_cache
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ohash
operator|!=
name|nhash
condition|)
name|union_list_unlock
argument_list|(
name|ohash
argument_list|)
expr_stmt|;
if|if
condition|(
name|un
operator|->
name|un_lowervp
operator|!=
name|lowervp
condition|)
block|{
if|if
condition|(
name|un
operator|->
name|un_lowervp
condition|)
block|{
name|vrele
argument_list|(
name|un
operator|->
name|un_lowervp
argument_list|)
expr_stmt|;
if|if
condition|(
name|un
operator|->
name|un_path
condition|)
block|{
name|free
argument_list|(
name|un
operator|->
name|un_path
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|un
operator|->
name|un_path
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|un
operator|->
name|un_lowervp
operator|=
name|lowervp
expr_stmt|;
name|un
operator|->
name|un_lowersz
operator|=
name|VNOVAL
expr_stmt|;
block|}
if|if
condition|(
name|un
operator|->
name|un_uppervp
operator|!=
name|uppervp
condition|)
block|{
if|if
condition|(
name|un
operator|->
name|un_uppervp
condition|)
name|vrele
argument_list|(
name|un
operator|->
name|un_uppervp
argument_list|)
expr_stmt|;
name|un
operator|->
name|un_uppervp
operator|=
name|uppervp
expr_stmt|;
name|un
operator|->
name|un_uppersz
operator|=
name|VNOVAL
expr_stmt|;
block|}
if|if
condition|(
name|docache
operator|&&
operator|(
name|ohash
operator|!=
name|nhash
operator|)
condition|)
block|{
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|unhead
index|[
name|nhash
index|]
argument_list|,
name|un
argument_list|,
name|un_cache
argument_list|)
expr_stmt|;
name|un
operator|->
name|un_flags
operator||=
name|UN_CACHED
expr_stmt|;
block|}
name|union_list_unlock
argument_list|(
name|nhash
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set a new lowervp.  The passed lowervp must be referenced and will be  * stored in the vp in a referenced state.   */
end_comment

begin_function
specifier|static
name|void
name|union_newlower
parameter_list|(
name|un
parameter_list|,
name|lowervp
parameter_list|)
name|struct
name|union_node
modifier|*
name|un
decl_stmt|;
name|struct
name|vnode
modifier|*
name|lowervp
decl_stmt|;
block|{
name|union_updatevp
argument_list|(
name|un
argument_list|,
name|un
operator|->
name|un_uppervp
argument_list|,
name|lowervp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set a new uppervp.  The passed uppervp must be locked and will be   * stored in the vp in a locked state.  The caller should not unlock  * uppervp.  */
end_comment

begin_function
specifier|static
name|void
name|union_newupper
parameter_list|(
name|un
parameter_list|,
name|uppervp
parameter_list|)
name|struct
name|union_node
modifier|*
name|un
decl_stmt|;
name|struct
name|vnode
modifier|*
name|uppervp
decl_stmt|;
block|{
name|union_updatevp
argument_list|(
name|un
argument_list|,
name|uppervp
argument_list|,
name|un
operator|->
name|un_lowervp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Keep track of size changes in the underlying vnodes.  * If the size changes, then callback to the vm layer  * giving priority to the upper layer size.  */
end_comment

begin_function
name|void
name|union_newsize
parameter_list|(
name|vp
parameter_list|,
name|uppersz
parameter_list|,
name|lowersz
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|off_t
name|uppersz
decl_stmt|,
name|lowersz
decl_stmt|;
block|{
name|struct
name|union_node
modifier|*
name|un
decl_stmt|;
name|off_t
name|sz
decl_stmt|;
comment|/* only interested in regular files */
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|VREG
condition|)
return|return;
name|un
operator|=
name|VTOUNION
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|sz
operator|=
name|VNOVAL
expr_stmt|;
if|if
condition|(
operator|(
name|uppersz
operator|!=
name|VNOVAL
operator|)
operator|&&
operator|(
name|un
operator|->
name|un_uppersz
operator|!=
name|uppersz
operator|)
condition|)
block|{
name|un
operator|->
name|un_uppersz
operator|=
name|uppersz
expr_stmt|;
if|if
condition|(
name|sz
operator|==
name|VNOVAL
condition|)
name|sz
operator|=
name|un
operator|->
name|un_uppersz
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|lowersz
operator|!=
name|VNOVAL
operator|)
operator|&&
operator|(
name|un
operator|->
name|un_lowersz
operator|!=
name|lowersz
operator|)
condition|)
block|{
name|un
operator|->
name|un_lowersz
operator|=
name|lowersz
expr_stmt|;
if|if
condition|(
name|sz
operator|==
name|VNOVAL
condition|)
name|sz
operator|=
name|un
operator|->
name|un_lowersz
expr_stmt|;
block|}
if|if
condition|(
name|sz
operator|!=
name|VNOVAL
condition|)
block|{
name|UDEBUG
argument_list|(
operator|(
literal|"union: %s size now %ld\n"
operator|,
operator|(
name|uppersz
operator|!=
name|VNOVAL
condition|?
literal|"upper"
else|:
literal|"lower"
operator|)
operator|,
operator|(
name|long
operator|)
name|sz
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * There is no need to change size of non-existent object 		 */
comment|/* vnode_pager_setsize(vp, sz); */
block|}
block|}
end_function

begin_comment
comment|/*  *	union_allocvp:	allocate a union_node and associate it with a  *			parent union_node and one or two vnodes.  *  *	vpp	Holds the returned vnode locked and referenced if no   *		error occurs.  *  *	mp	Holds the mount point.  mp may or may not be busied.   *		allocvp makes no changes to mp.  *  *	dvp	Holds the parent union_node to the one we wish to create.  *		XXX may only be used to traverse an uncopied lowervp-based  *		tree?  XXX  *  *		dvp may or may not be locked.  allocvp makes no changes  *		to dvp.  *  *	upperdvp Holds the parent vnode to uppervp, generally used along  *		with path component information to create a shadow of  *		lowervp when uppervp does not exist.  *  *		upperdvp is referenced but unlocked on entry, and will be  *		dereferenced on return.  *  *	uppervp	Holds the new uppervp vnode to be stored in the   *		union_node we are allocating.  uppervp is referenced but  *		not locked, and will be dereferenced on return.  *  *	lowervp	Holds the new lowervp vnode to be stored in the  *		union_node we are allocating.  lowervp is referenced but  *		not locked, and will be dereferenced on return.  *   *	cnp	Holds path component information to be coupled with  *		lowervp and upperdvp to allow unionfs to create an uppervp  *		later on.  Only used if lowervp is valid.  The conents  *		of cnp is only valid for the duration of the call.  *  *	docache	Determine whether this node should be entered in the  *		cache or whether it should be destroyed as soon as possible.  *  * all union_nodes are maintained on a singly-linked  * list.  new nodes are only allocated when they cannot  * be found on this list.  entries on the list are  * removed when the vfs reclaim entry is called.  *  * a single lock is kept for the entire list.  this is  * needed because the getnewvnode() function can block  * waiting for a vnode to become free, in which case there  * may be more than one process trying to get the same  * vnode.  this lock is only taken if we are going to  * call getnewvnode, since the kernel itself is single-threaded.  *  * if an entry is found on the list, then call vget() to  * take a reference.  this is done because there may be  * zero references to it and so it needs to removed from  * the vnode free list.  */
end_comment

begin_function
name|int
name|union_allocvp
parameter_list|(
name|vpp
parameter_list|,
name|mp
parameter_list|,
name|dvp
parameter_list|,
name|upperdvp
parameter_list|,
name|cnp
parameter_list|,
name|uppervp
parameter_list|,
name|lowervp
parameter_list|,
name|docache
parameter_list|)
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|dvp
decl_stmt|;
comment|/* parent union vnode */
name|struct
name|vnode
modifier|*
name|upperdvp
decl_stmt|;
comment|/* parent vnode of uppervp */
name|struct
name|componentname
modifier|*
name|cnp
decl_stmt|;
comment|/* may be null */
name|struct
name|vnode
modifier|*
name|uppervp
decl_stmt|;
comment|/* may be null */
name|struct
name|vnode
modifier|*
name|lowervp
decl_stmt|;
comment|/* may be null */
name|int
name|docache
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|struct
name|union_node
modifier|*
name|un
init|=
literal|0
decl_stmt|;
name|struct
name|union_mount
modifier|*
name|um
init|=
name|MOUNTTOUNIONMOUNT
argument_list|(
name|mp
argument_list|)
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
operator|(
name|cnp
operator|)
condition|?
name|cnp
operator|->
name|cn_thread
else|:
name|curthread
decl_stmt|;
name|int
name|hash
init|=
literal|0
decl_stmt|;
name|int
name|vflag
decl_stmt|;
name|int
name|try
decl_stmt|;
if|if
condition|(
name|uppervp
operator|==
name|NULLVP
operator|&&
name|lowervp
operator|==
name|NULLVP
condition|)
name|panic
argument_list|(
literal|"union: unidentifiable allocation"
argument_list|)
expr_stmt|;
if|if
condition|(
name|uppervp
operator|&&
name|lowervp
operator|&&
operator|(
name|uppervp
operator|->
name|v_type
operator|!=
name|lowervp
operator|->
name|v_type
operator|)
condition|)
block|{
name|vrele
argument_list|(
name|lowervp
argument_list|)
expr_stmt|;
name|lowervp
operator|=
name|NULLVP
expr_stmt|;
block|}
comment|/* detect the root vnode (and aliases) */
name|vflag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|uppervp
operator|==
name|um
operator|->
name|um_uppervp
operator|)
operator|&&
operator|(
operator|(
name|lowervp
operator|==
name|NULLVP
operator|)
operator|||
name|lowervp
operator|==
name|um
operator|->
name|um_lowervp
operator|)
condition|)
block|{
if|if
condition|(
name|lowervp
operator|==
name|NULLVP
condition|)
block|{
name|lowervp
operator|=
name|um
operator|->
name|um_lowervp
expr_stmt|;
if|if
condition|(
name|lowervp
operator|!=
name|NULLVP
condition|)
name|VREF
argument_list|(
name|lowervp
argument_list|)
expr_stmt|;
block|}
name|vflag
operator|=
name|VROOT
expr_stmt|;
block|}
name|loop
label|:
if|if
condition|(
operator|!
name|docache
condition|)
block|{
name|un
operator|=
literal|0
expr_stmt|;
block|}
else|else
for|for
control|(
name|try
operator|=
literal|0
init|;
name|try
operator|<
literal|3
condition|;
name|try
operator|++
control|)
block|{
switch|switch
condition|(
name|try
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
name|lowervp
operator|==
name|NULLVP
condition|)
continue|continue;
name|hash
operator|=
name|UNION_HASH
argument_list|(
name|uppervp
argument_list|,
name|lowervp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
if|if
condition|(
name|uppervp
operator|==
name|NULLVP
condition|)
continue|continue;
name|hash
operator|=
name|UNION_HASH
argument_list|(
name|uppervp
argument_list|,
name|NULLVP
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
if|if
condition|(
name|lowervp
operator|==
name|NULLVP
condition|)
continue|continue;
name|hash
operator|=
name|UNION_HASH
argument_list|(
name|NULLVP
argument_list|,
name|lowervp
argument_list|)
expr_stmt|;
break|break;
block|}
while|while
condition|(
name|union_list_lock
argument_list|(
name|hash
argument_list|)
condition|)
continue|continue;
name|LIST_FOREACH
argument_list|(
argument|un
argument_list|,
argument|&unhead[hash]
argument_list|,
argument|un_cache
argument_list|)
block|{
if|if
condition|(
operator|(
name|un
operator|->
name|un_lowervp
operator|==
name|lowervp
operator|||
name|un
operator|->
name|un_lowervp
operator|==
name|NULLVP
operator|)
operator|&&
operator|(
name|un
operator|->
name|un_uppervp
operator|==
name|uppervp
operator|||
name|un
operator|->
name|un_uppervp
operator|==
name|NULLVP
operator|)
operator|&&
operator|(
name|UNIONTOV
argument_list|(
name|un
argument_list|)
operator|->
name|v_mount
operator|==
name|mp
operator|)
condition|)
block|{
if|if
condition|(
name|vget
argument_list|(
name|UNIONTOV
argument_list|(
name|un
argument_list|)
argument_list|,
literal|0
argument_list|,
name|cnp
condition|?
name|cnp
operator|->
name|cn_thread
else|:
name|NULL
argument_list|)
condition|)
block|{
name|union_list_unlock
argument_list|(
name|hash
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
break|break;
block|}
block|}
name|union_list_unlock
argument_list|(
name|hash
argument_list|)
expr_stmt|;
if|if
condition|(
name|un
condition|)
break|break;
block|}
if|if
condition|(
name|un
condition|)
block|{
comment|/* 		 * Obtain a lock on the union_node.  Everything is unlocked 		 * except for dvp, so check that case.  If they match, our 		 * new un is already locked.  Otherwise we have to lock our 		 * new un. 		 * 		 * A potential deadlock situation occurs when we are holding 		 * one lock while trying to get another.  We must follow  		 * strict ordering rules to avoid it.  We try to locate dvp 		 * by scanning up from un_vnode, since the most likely  		 * scenario is un being under dvp. 		 */
if|if
condition|(
name|dvp
operator|&&
name|un
operator|->
name|un_vnode
operator|!=
name|dvp
condition|)
block|{
name|struct
name|vnode
modifier|*
name|scan
init|=
name|un
operator|->
name|un_vnode
decl_stmt|;
do|do
block|{
name|scan
operator|=
name|VTOUNION
argument_list|(
name|scan
argument_list|)
operator|->
name|un_pvp
expr_stmt|;
block|}
do|while
condition|(
name|scan
operator|&&
name|scan
operator|->
name|v_tag
operator|==
name|VT_UNION
operator|&&
name|scan
operator|!=
name|dvp
condition|)
do|;
if|if
condition|(
name|scan
operator|!=
name|dvp
condition|)
block|{
comment|/* 				 * our new un is above dvp (we never saw dvp 				 * while moving up the tree). 				 */
name|VREF
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|dvp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|error
operator|=
name|vn_lock
argument_list|(
name|un
operator|->
name|un_vnode
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|vn_lock
argument_list|(
name|dvp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * our new un is under dvp 				 */
name|error
operator|=
name|vn_lock
argument_list|(
name|un
operator|->
name|un_vnode
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|dvp
operator|==
name|NULLVP
condition|)
block|{
comment|/* 			 * dvp is NULL, we need to lock un. 			 */
name|error
operator|=
name|vn_lock
argument_list|(
name|un
operator|->
name|un_vnode
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * dvp == un->un_vnode, we are already locked. 			 */
name|error
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
goto|goto
name|loop
goto|;
comment|/* 		 * At this point, the union_node is locked and referenced. 		 * 		 * uppervp is locked and referenced or NULL, lowervp is 		 * referenced or NULL. 		 */
name|UDEBUG
argument_list|(
operator|(
literal|"Modify existing un %p vn %p upper %p(refs %d) -> %p(refs %d)\n"
operator|,
name|un
operator|,
name|un
operator|->
name|un_vnode
operator|,
name|un
operator|->
name|un_uppervp
operator|,
operator|(
name|un
operator|->
name|un_uppervp
condition|?
name|un
operator|->
name|un_uppervp
operator|->
name|v_usecount
else|:
operator|-
literal|99
operator|)
operator|,
name|uppervp
operator|,
operator|(
name|uppervp
condition|?
name|uppervp
operator|->
name|v_usecount
else|:
operator|-
literal|99
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|uppervp
operator|!=
name|un
operator|->
name|un_uppervp
condition|)
block|{
name|KASSERT
argument_list|(
name|uppervp
operator|==
name|NULL
operator|||
name|uppervp
operator|->
name|v_usecount
operator|>
literal|0
argument_list|,
operator|(
literal|"union_allocvp: too few refs %d (at least 1 required) on uppervp"
operator|,
name|uppervp
operator|->
name|v_usecount
operator|)
argument_list|)
expr_stmt|;
name|union_newupper
argument_list|(
name|un
argument_list|,
name|uppervp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|uppervp
condition|)
block|{
name|KASSERT
argument_list|(
name|uppervp
operator|->
name|v_usecount
operator|>
literal|1
argument_list|,
operator|(
literal|"union_allocvp: too few refs %d (at least 2 required) on uppervp"
operator|,
name|uppervp
operator|->
name|v_usecount
operator|)
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|uppervp
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Save information about the lower layer. 		 * This needs to keep track of pathname 		 * and directory information which union_vn_create 		 * might need. 		 */
if|if
condition|(
name|lowervp
operator|!=
name|un
operator|->
name|un_lowervp
condition|)
block|{
name|union_newlower
argument_list|(
name|un
argument_list|,
name|lowervp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnp
operator|&&
operator|(
name|lowervp
operator|!=
name|NULLVP
operator|)
condition|)
block|{
name|un
operator|->
name|un_path
operator|=
name|malloc
argument_list|(
name|cnp
operator|->
name|cn_namelen
operator|+
literal|1
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|cnp
operator|->
name|cn_nameptr
argument_list|,
name|un
operator|->
name|un_path
argument_list|,
name|cnp
operator|->
name|cn_namelen
argument_list|)
expr_stmt|;
name|un
operator|->
name|un_path
index|[
name|cnp
operator|->
name|cn_namelen
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|lowervp
condition|)
block|{
name|vrele
argument_list|(
name|lowervp
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * and upperdvp 		 */
if|if
condition|(
name|upperdvp
operator|!=
name|un
operator|->
name|un_dirvp
condition|)
block|{
if|if
condition|(
name|un
operator|->
name|un_dirvp
condition|)
name|vrele
argument_list|(
name|un
operator|->
name|un_dirvp
argument_list|)
expr_stmt|;
name|un
operator|->
name|un_dirvp
operator|=
name|upperdvp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|upperdvp
condition|)
block|{
name|vrele
argument_list|(
name|upperdvp
argument_list|)
expr_stmt|;
block|}
operator|*
name|vpp
operator|=
name|UNIONTOV
argument_list|(
name|un
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|docache
condition|)
block|{
comment|/* 		 * otherwise lock the vp list while we call getnewvnode 		 * since that can block. 		 */
name|hash
operator|=
name|UNION_HASH
argument_list|(
name|uppervp
argument_list|,
name|lowervp
argument_list|)
expr_stmt|;
if|if
condition|(
name|union_list_lock
argument_list|(
name|hash
argument_list|)
condition|)
goto|goto
name|loop
goto|;
block|}
comment|/* 	 * Create new node rather then replace old node 	 */
name|error
operator|=
name|getnewvnode
argument_list|(
name|VT_UNION
argument_list|,
name|mp
argument_list|,
name|union_vnodeop_p
argument_list|,
name|vpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* 		 * If an error occurs clear out vnodes. 		 */
if|if
condition|(
name|lowervp
condition|)
name|vrele
argument_list|(
name|lowervp
argument_list|)
expr_stmt|;
if|if
condition|(
name|uppervp
condition|)
name|vrele
argument_list|(
name|uppervp
argument_list|)
expr_stmt|;
if|if
condition|(
name|upperdvp
condition|)
name|vrele
argument_list|(
name|upperdvp
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|NULL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|MALLOC
argument_list|(
operator|(
operator|*
name|vpp
operator|)
operator|->
name|v_data
argument_list|,
name|void
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|union_node
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
operator|(
operator|*
name|vpp
operator|)
operator|->
name|v_flag
operator||=
name|vflag
expr_stmt|;
if|if
condition|(
name|uppervp
condition|)
operator|(
operator|*
name|vpp
operator|)
operator|->
name|v_type
operator|=
name|uppervp
operator|->
name|v_type
expr_stmt|;
else|else
operator|(
operator|*
name|vpp
operator|)
operator|->
name|v_type
operator|=
name|lowervp
operator|->
name|v_type
expr_stmt|;
name|un
operator|=
name|VTOUNION
argument_list|(
operator|*
name|vpp
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|un
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|un
argument_list|)
argument_list|)
expr_stmt|;
name|lockinit
argument_list|(
operator|&
name|un
operator|->
name|un_lock
argument_list|,
name|PVFS
argument_list|,
literal|"unlock"
argument_list|,
name|VLKTIMEOUT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vn_lock
argument_list|(
operator|*
name|vpp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|un
operator|->
name|un_vnode
operator|=
operator|*
name|vpp
expr_stmt|;
name|un
operator|->
name|un_uppervp
operator|=
name|uppervp
expr_stmt|;
name|un
operator|->
name|un_uppersz
operator|=
name|VNOVAL
expr_stmt|;
name|un
operator|->
name|un_lowervp
operator|=
name|lowervp
expr_stmt|;
name|un
operator|->
name|un_lowersz
operator|=
name|VNOVAL
expr_stmt|;
name|un
operator|->
name|un_dirvp
operator|=
name|upperdvp
expr_stmt|;
name|un
operator|->
name|un_pvp
operator|=
name|dvp
expr_stmt|;
comment|/* only parent dir in new allocation */
if|if
condition|(
name|dvp
operator|!=
name|NULLVP
condition|)
name|VREF
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|un
operator|->
name|un_dircache
operator|=
literal|0
expr_stmt|;
name|un
operator|->
name|un_openl
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cnp
operator|&&
operator|(
name|lowervp
operator|!=
name|NULLVP
operator|)
condition|)
block|{
name|un
operator|->
name|un_path
operator|=
name|malloc
argument_list|(
name|cnp
operator|->
name|cn_namelen
operator|+
literal|1
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|cnp
operator|->
name|cn_nameptr
argument_list|,
name|un
operator|->
name|un_path
argument_list|,
name|cnp
operator|->
name|cn_namelen
argument_list|)
expr_stmt|;
name|un
operator|->
name|un_path
index|[
name|cnp
operator|->
name|cn_namelen
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|un
operator|->
name|un_path
operator|=
literal|0
expr_stmt|;
name|un
operator|->
name|un_dirvp
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|docache
condition|)
block|{
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|unhead
index|[
name|hash
index|]
argument_list|,
name|un
argument_list|,
name|un_cache
argument_list|)
expr_stmt|;
name|un
operator|->
name|un_flags
operator||=
name|UN_CACHED
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|docache
condition|)
name|union_list_unlock
argument_list|(
name|hash
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|union_freevp
parameter_list|(
name|vp
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
block|{
name|struct
name|union_node
modifier|*
name|un
init|=
name|VTOUNION
argument_list|(
name|vp
argument_list|)
decl_stmt|;
if|if
condition|(
name|un
operator|->
name|un_flags
operator|&
name|UN_CACHED
condition|)
block|{
name|un
operator|->
name|un_flags
operator|&=
operator|~
name|UN_CACHED
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|un
argument_list|,
name|un_cache
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|un
operator|->
name|un_pvp
operator|!=
name|NULLVP
condition|)
block|{
name|vrele
argument_list|(
name|un
operator|->
name|un_pvp
argument_list|)
expr_stmt|;
name|un
operator|->
name|un_pvp
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|un
operator|->
name|un_uppervp
operator|!=
name|NULLVP
condition|)
block|{
name|vrele
argument_list|(
name|un
operator|->
name|un_uppervp
argument_list|)
expr_stmt|;
name|un
operator|->
name|un_uppervp
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|un
operator|->
name|un_lowervp
operator|!=
name|NULLVP
condition|)
block|{
name|vrele
argument_list|(
name|un
operator|->
name|un_lowervp
argument_list|)
expr_stmt|;
name|un
operator|->
name|un_lowervp
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|un
operator|->
name|un_dirvp
operator|!=
name|NULLVP
condition|)
block|{
name|vrele
argument_list|(
name|un
operator|->
name|un_dirvp
argument_list|)
expr_stmt|;
name|un
operator|->
name|un_dirvp
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|un
operator|->
name|un_path
condition|)
block|{
name|free
argument_list|(
name|un
operator|->
name|un_path
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|un
operator|->
name|un_path
operator|=
name|NULL
expr_stmt|;
block|}
name|lockdestroy
argument_list|(
operator|&
name|un
operator|->
name|un_lock
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|vp
operator|->
name|v_data
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|vp
operator|->
name|v_data
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * copyfile.  copy the vnode (fvp) to the vnode (tvp)  * using a sequence of reads and writes.  both (fvp)  * and (tvp) are locked on entry and exit.  *  * fvp and tvp are both exclusive locked on call, but their refcount's  * haven't been bumped at all.  */
end_comment

begin_function
specifier|static
name|int
name|union_copyfile
parameter_list|(
name|fvp
parameter_list|,
name|tvp
parameter_list|,
name|cred
parameter_list|,
name|td
parameter_list|)
name|struct
name|vnode
modifier|*
name|fvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|tvp
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|struct
name|uio
name|uio
decl_stmt|;
name|struct
name|iovec
name|iov
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* 	 * strategy: 	 * allocate a buffer of size MAXBSIZE. 	 * loop doing reads and writes, keeping track 	 * of the current uio offset. 	 * give up at the first sign of trouble. 	 */
name|bzero
argument_list|(
operator|&
name|uio
argument_list|,
sizeof|sizeof
argument_list|(
name|uio
argument_list|)
argument_list|)
expr_stmt|;
name|uio
operator|.
name|uio_td
operator|=
name|td
expr_stmt|;
name|uio
operator|.
name|uio_segflg
operator|=
name|UIO_SYSSPACE
expr_stmt|;
name|uio
operator|.
name|uio_offset
operator|=
literal|0
expr_stmt|;
name|VOP_LEASE
argument_list|(
name|fvp
argument_list|,
name|td
argument_list|,
name|cred
argument_list|,
name|LEASE_READ
argument_list|)
expr_stmt|;
name|VOP_LEASE
argument_list|(
name|tvp
argument_list|,
name|td
argument_list|,
name|cred
argument_list|,
name|LEASE_WRITE
argument_list|)
expr_stmt|;
name|buf
operator|=
name|malloc
argument_list|(
name|MAXBSIZE
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
comment|/* ugly loop follows... */
do|do
block|{
name|off_t
name|offset
init|=
name|uio
operator|.
name|uio_offset
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|bufoffset
decl_stmt|;
comment|/* 		 * Setup for big read 		 */
name|uio
operator|.
name|uio_iov
operator|=
operator|&
name|iov
expr_stmt|;
name|uio
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|iov
operator|.
name|iov_base
operator|=
name|buf
expr_stmt|;
name|iov
operator|.
name|iov_len
operator|=
name|MAXBSIZE
expr_stmt|;
name|uio
operator|.
name|uio_resid
operator|=
name|iov
operator|.
name|iov_len
expr_stmt|;
name|uio
operator|.
name|uio_rw
operator|=
name|UIO_READ
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|VOP_READ
argument_list|(
name|fvp
argument_list|,
operator|&
name|uio
argument_list|,
literal|0
argument_list|,
name|cred
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
comment|/* 		 * Get bytes read, handle read eof case and setup for 		 * write loop 		 */
if|if
condition|(
operator|(
name|count
operator|=
name|MAXBSIZE
operator|-
name|uio
operator|.
name|uio_resid
operator|)
operator|==
literal|0
condition|)
break|break;
name|bufoffset
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Write until an error occurs or our buffer has been 		 * exhausted, then update the offset for the next read. 		 */
while|while
condition|(
name|bufoffset
operator|<
name|count
condition|)
block|{
name|uio
operator|.
name|uio_iov
operator|=
operator|&
name|iov
expr_stmt|;
name|uio
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|iov
operator|.
name|iov_base
operator|=
name|buf
operator|+
name|bufoffset
expr_stmt|;
name|iov
operator|.
name|iov_len
operator|=
name|count
operator|-
name|bufoffset
expr_stmt|;
name|uio
operator|.
name|uio_offset
operator|=
name|offset
operator|+
name|bufoffset
expr_stmt|;
name|uio
operator|.
name|uio_rw
operator|=
name|UIO_WRITE
expr_stmt|;
name|uio
operator|.
name|uio_resid
operator|=
name|iov
operator|.
name|iov_len
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|VOP_WRITE
argument_list|(
name|tvp
argument_list|,
operator|&
name|uio
argument_list|,
literal|0
argument_list|,
name|cred
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
name|bufoffset
operator|+=
operator|(
name|count
operator|-
name|bufoffset
operator|)
operator|-
name|uio
operator|.
name|uio_resid
expr_stmt|;
block|}
name|uio
operator|.
name|uio_offset
operator|=
name|offset
operator|+
name|bufoffset
expr_stmt|;
block|}
do|while
condition|(
name|error
operator|==
literal|0
condition|)
do|;
name|free
argument_list|(
name|buf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  * un's vnode is assumed to be locked on entry and remains locked on exit.  */
end_comment

begin_function
name|int
name|union_copyup
parameter_list|(
name|un
parameter_list|,
name|docopy
parameter_list|,
name|cred
parameter_list|,
name|td
parameter_list|)
name|struct
name|union_node
modifier|*
name|un
decl_stmt|;
name|int
name|docopy
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|lvp
decl_stmt|,
modifier|*
name|uvp
decl_stmt|;
comment|/* 	 * If the user does not have read permission, the vnode should not 	 * be copied to upper layer. 	 */
name|vn_lock
argument_list|(
name|un
operator|->
name|un_lowervp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_ACCESS
argument_list|(
name|un
operator|->
name|un_lowervp
argument_list|,
name|VREAD
argument_list|,
name|cred
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|un
operator|->
name|un_lowervp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|vn_start_write
argument_list|(
name|un
operator|->
name|un_dirvp
argument_list|,
operator|&
name|mp
argument_list|,
name|V_WAIT
operator||
name|PCATCH
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|union_vn_create
argument_list|(
operator|&
name|uvp
argument_list|,
name|un
argument_list|,
name|td
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|vn_finished_write
argument_list|(
name|mp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|lvp
operator|=
name|un
operator|->
name|un_lowervp
expr_stmt|;
name|KASSERT
argument_list|(
name|uvp
operator|->
name|v_usecount
operator|>
literal|0
argument_list|,
operator|(
literal|"copy: uvp refcount 0: %d"
operator|,
name|uvp
operator|->
name|v_usecount
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|docopy
condition|)
block|{
comment|/* 		 * XX - should not ignore errors 		 * from VOP_CLOSE 		 */
name|vn_lock
argument_list|(
name|lvp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_OPEN
argument_list|(
name|lvp
argument_list|,
name|FREAD
argument_list|,
name|cred
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|vn_canvmio
argument_list|(
name|lvp
argument_list|)
operator|==
name|TRUE
condition|)
name|error
operator|=
name|vfs_object_create
argument_list|(
name|lvp
argument_list|,
name|td
argument_list|,
name|cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|union_copyfile
argument_list|(
name|lvp
argument_list|,
name|uvp
argument_list|,
name|cred
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|lvp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|VOP_CLOSE
argument_list|(
name|lvp
argument_list|,
name|FREAD
argument_list|,
name|cred
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|UDEBUG
argument_list|(
operator|(
literal|"union: copied up %s\n"
operator|,
name|un
operator|->
name|un_path
operator|)
argument_list|)
expr_stmt|;
block|}
name|VOP_UNLOCK
argument_list|(
name|uvp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|vn_finished_write
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|union_newupper
argument_list|(
name|un
argument_list|,
name|uvp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|uvp
operator|->
name|v_usecount
operator|>
literal|0
argument_list|,
operator|(
literal|"copy: uvp refcount 0: %d"
operator|,
name|uvp
operator|->
name|v_usecount
operator|)
argument_list|)
expr_stmt|;
name|union_vn_close
argument_list|(
name|uvp
argument_list|,
name|FWRITE
argument_list|,
name|cred
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|uvp
operator|->
name|v_usecount
operator|>
literal|0
argument_list|,
operator|(
literal|"copy: uvp refcount 0: %d"
operator|,
name|uvp
operator|->
name|v_usecount
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Subsequent IOs will go to the top layer, so 	 * call close on the lower vnode and open on the 	 * upper vnode to ensure that the filesystem keeps 	 * its references counts right.  This doesn't do 	 * the right thing with (cred) and (FREAD) though. 	 * Ignoring error returns is not right, either. 	 */
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|un
operator|->
name|un_openl
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|VOP_CLOSE
argument_list|(
name|lvp
argument_list|,
name|FREAD
argument_list|,
name|cred
argument_list|,
name|td
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|VOP_OPEN
argument_list|(
name|uvp
argument_list|,
name|FREAD
argument_list|,
name|cred
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|un
operator|->
name|un_openl
condition|)
block|{
if|if
condition|(
name|vn_canvmio
argument_list|(
name|uvp
argument_list|)
operator|==
name|TRUE
condition|)
name|error
operator|=
name|vfs_object_create
argument_list|(
name|uvp
argument_list|,
name|td
argument_list|,
name|cred
argument_list|)
expr_stmt|;
block|}
name|un
operator|->
name|un_openl
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	union_relookup:  *  *	dvp should be locked on entry and will be locked on return.  No  *	net change in the ref count will occur.  *  *	If an error is returned, *vpp will be invalid, otherwise it  *	will hold a locked, referenced vnode.  If *vpp == dvp then  *	remember that only one exclusive lock is held.  */
end_comment

begin_function
specifier|static
name|int
name|union_relookup
parameter_list|(
name|um
parameter_list|,
name|dvp
parameter_list|,
name|vpp
parameter_list|,
name|cnp
parameter_list|,
name|cn
parameter_list|,
name|path
parameter_list|,
name|pathlen
parameter_list|)
name|struct
name|union_mount
modifier|*
name|um
decl_stmt|;
name|struct
name|vnode
modifier|*
name|dvp
decl_stmt|;
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cn
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
name|int
name|pathlen
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
comment|/* 	 * A new componentname structure must be faked up because 	 * there is no way to know where the upper level cnp came 	 * from or what it is being used for.  This must duplicate 	 * some of the work done by NDINIT, some of the work done 	 * by namei, some of the work done by lookup and some of 	 * the work done by VOP_LOOKUP when given a CREATE flag. 	 * Conclusion: Horrible. 	 */
name|cn
operator|->
name|cn_namelen
operator|=
name|pathlen
expr_stmt|;
name|cn
operator|->
name|cn_pnbuf
operator|=
name|zalloc
argument_list|(
name|namei_zone
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|path
argument_list|,
name|cn
operator|->
name|cn_pnbuf
argument_list|,
name|cn
operator|->
name|cn_namelen
argument_list|)
expr_stmt|;
name|cn
operator|->
name|cn_pnbuf
index|[
name|cn
operator|->
name|cn_namelen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|cn
operator|->
name|cn_nameiop
operator|=
name|CREATE
expr_stmt|;
name|cn
operator|->
name|cn_flags
operator|=
operator|(
name|LOCKPARENT
operator||
name|LOCKLEAF
operator||
name|HASBUF
operator||
name|SAVENAME
operator||
name|ISLASTCN
operator|)
expr_stmt|;
name|cn
operator|->
name|cn_thread
operator|=
name|cnp
operator|->
name|cn_thread
expr_stmt|;
if|if
condition|(
name|um
operator|->
name|um_op
operator|==
name|UNMNT_ABOVE
condition|)
name|cn
operator|->
name|cn_cred
operator|=
name|cnp
operator|->
name|cn_cred
expr_stmt|;
else|else
name|cn
operator|->
name|cn_cred
operator|=
name|um
operator|->
name|um_cred
expr_stmt|;
name|cn
operator|->
name|cn_nameptr
operator|=
name|cn
operator|->
name|cn_pnbuf
expr_stmt|;
name|cn
operator|->
name|cn_consume
operator|=
name|cnp
operator|->
name|cn_consume
expr_stmt|;
name|VREF
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|dvp
argument_list|,
literal|0
argument_list|,
name|cnp
operator|->
name|cn_thread
argument_list|)
expr_stmt|;
comment|/* 	 * Pass dvp unlocked and referenced on call to relookup(). 	 * 	 * If an error occurs, dvp will be returned unlocked and dereferenced. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|relookup
argument_list|(
name|dvp
argument_list|,
name|vpp
argument_list|,
name|cn
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|vn_lock
argument_list|(
name|dvp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|cnp
operator|->
name|cn_thread
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * If no error occurs, dvp will be returned locked with the reference 	 * left as before, and vpp will be returned referenced and locked. 	 * 	 * We want to return with dvp as it was passed to us, so we get 	 * rid of our reference. 	 */
name|vrele
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create a shadow directory in the upper layer.  * The new vnode is returned locked.  *  * (um) points to the union mount structure for access to the  * the mounting process's credentials.  * (dvp) is the directory in which to create the shadow directory,  * it is locked (but not ref'd) on entry and return.  * (cnp) is the componentname to be created.  * (vpp) is the returned newly created shadow directory, which  * is returned locked and ref'd  */
end_comment

begin_function
name|int
name|union_mkshadow
parameter_list|(
name|um
parameter_list|,
name|dvp
parameter_list|,
name|cnp
parameter_list|,
name|vpp
parameter_list|)
name|struct
name|union_mount
modifier|*
name|um
decl_stmt|;
name|struct
name|vnode
modifier|*
name|dvp
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
decl_stmt|;
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|struct
name|vattr
name|va
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|cnp
operator|->
name|cn_thread
decl_stmt|;
name|struct
name|componentname
name|cn
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|vn_start_write
argument_list|(
name|dvp
argument_list|,
operator|&
name|mp
argument_list|,
name|V_WAIT
operator||
name|PCATCH
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|union_relookup
argument_list|(
name|um
argument_list|,
name|dvp
argument_list|,
name|vpp
argument_list|,
name|cnp
argument_list|,
operator|&
name|cn
argument_list|,
name|cnp
operator|->
name|cn_nameptr
argument_list|,
name|cnp
operator|->
name|cn_namelen
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|vn_finished_write
argument_list|(
name|mp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|vpp
condition|)
block|{
if|if
condition|(
name|cn
operator|.
name|cn_flags
operator|&
name|HASBUF
condition|)
block|{
name|zfree
argument_list|(
name|namei_zone
argument_list|,
name|cn
operator|.
name|cn_pnbuf
argument_list|)
expr_stmt|;
name|cn
operator|.
name|cn_flags
operator|&=
operator|~
name|HASBUF
expr_stmt|;
block|}
if|if
condition|(
name|dvp
operator|==
operator|*
name|vpp
condition|)
name|vrele
argument_list|(
operator|*
name|vpp
argument_list|)
expr_stmt|;
else|else
name|vput
argument_list|(
operator|*
name|vpp
argument_list|)
expr_stmt|;
name|vn_finished_write
argument_list|(
name|mp
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|NULLVP
expr_stmt|;
return|return
operator|(
name|EEXIST
operator|)
return|;
block|}
comment|/* 	 * policy: when creating the shadow directory in the 	 * upper layer, create it owned by the user who did 	 * the mount, group from parent directory, and mode 	 * 777 modified by umask (ie mostly identical to the 	 * mkdir syscall).  (jsp, kb) 	 */
name|VATTR_NULL
argument_list|(
operator|&
name|va
argument_list|)
expr_stmt|;
name|va
operator|.
name|va_type
operator|=
name|VDIR
expr_stmt|;
name|va
operator|.
name|va_mode
operator|=
name|um
operator|->
name|um_cmode
expr_stmt|;
comment|/* VOP_LEASE: dvp is locked */
name|VOP_LEASE
argument_list|(
name|dvp
argument_list|,
name|td
argument_list|,
name|cn
operator|.
name|cn_cred
argument_list|,
name|LEASE_WRITE
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_MKDIR
argument_list|(
name|dvp
argument_list|,
name|vpp
argument_list|,
operator|&
name|cn
argument_list|,
operator|&
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|cn
operator|.
name|cn_flags
operator|&
name|HASBUF
condition|)
block|{
name|zfree
argument_list|(
name|namei_zone
argument_list|,
name|cn
operator|.
name|cn_pnbuf
argument_list|)
expr_stmt|;
name|cn
operator|.
name|cn_flags
operator|&=
operator|~
name|HASBUF
expr_stmt|;
block|}
comment|/*vput(dvp);*/
name|vn_finished_write
argument_list|(
name|mp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create a whiteout entry in the upper layer.  *  * (um) points to the union mount structure for access to the  * the mounting process's credentials.  * (dvp) is the directory in which to create the whiteout.  * it is locked on entry and return.  * (cnp) is the componentname to be created.  */
end_comment

begin_function
name|int
name|union_mkwhiteout
parameter_list|(
name|um
parameter_list|,
name|dvp
parameter_list|,
name|cnp
parameter_list|,
name|path
parameter_list|)
name|struct
name|union_mount
modifier|*
name|um
decl_stmt|;
name|struct
name|vnode
modifier|*
name|dvp
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|cnp
operator|->
name|cn_thread
decl_stmt|;
name|struct
name|vnode
modifier|*
name|wvp
decl_stmt|;
name|struct
name|componentname
name|cn
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|vn_start_write
argument_list|(
name|dvp
argument_list|,
operator|&
name|mp
argument_list|,
name|V_WAIT
operator||
name|PCATCH
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|union_relookup
argument_list|(
name|um
argument_list|,
name|dvp
argument_list|,
operator|&
name|wvp
argument_list|,
name|cnp
argument_list|,
operator|&
name|cn
argument_list|,
name|path
argument_list|,
name|strlen
argument_list|(
name|path
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|vn_finished_write
argument_list|(
name|mp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|wvp
condition|)
block|{
if|if
condition|(
name|cn
operator|.
name|cn_flags
operator|&
name|HASBUF
condition|)
block|{
name|zfree
argument_list|(
name|namei_zone
argument_list|,
name|cn
operator|.
name|cn_pnbuf
argument_list|)
expr_stmt|;
name|cn
operator|.
name|cn_flags
operator|&=
operator|~
name|HASBUF
expr_stmt|;
block|}
if|if
condition|(
name|wvp
operator|==
name|dvp
condition|)
name|vrele
argument_list|(
name|wvp
argument_list|)
expr_stmt|;
else|else
name|vput
argument_list|(
name|wvp
argument_list|)
expr_stmt|;
name|vn_finished_write
argument_list|(
name|mp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EEXIST
operator|)
return|;
block|}
comment|/* VOP_LEASE: dvp is locked */
name|VOP_LEASE
argument_list|(
name|dvp
argument_list|,
name|td
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|LEASE_WRITE
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_WHITEOUT
argument_list|(
name|dvp
argument_list|,
operator|&
name|cn
argument_list|,
name|CREATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|cn
operator|.
name|cn_flags
operator|&
name|HASBUF
condition|)
block|{
name|zfree
argument_list|(
name|namei_zone
argument_list|,
name|cn
operator|.
name|cn_pnbuf
argument_list|)
expr_stmt|;
name|cn
operator|.
name|cn_flags
operator|&=
operator|~
name|HASBUF
expr_stmt|;
block|}
name|vn_finished_write
argument_list|(
name|mp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * union_vn_create: creates and opens a new shadow file  * on the upper union layer.  this function is similar  * in spirit to calling vn_open but it avoids calling namei().  * the problem with calling namei is that a) it locks too many  * things, and b) it doesn't start at the "right" directory,  * whereas relookup is told where to start.  *  * On entry, the vnode associated with un is locked.  It remains locked  * on return.  *  * If no error occurs, *vpp contains a locked referenced vnode for your  * use.  If an error occurs *vpp iis undefined.  */
end_comment

begin_function
specifier|static
name|int
name|union_vn_create
parameter_list|(
name|vpp
parameter_list|,
name|un
parameter_list|,
name|td
parameter_list|)
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
decl_stmt|;
name|struct
name|union_node
modifier|*
name|un
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
block|{
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|td
operator|->
name|td_ucred
decl_stmt|;
name|struct
name|vattr
name|vat
decl_stmt|;
name|struct
name|vattr
modifier|*
name|vap
init|=
operator|&
name|vat
decl_stmt|;
name|int
name|fmode
init|=
name|FFLAGS
argument_list|(
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
operator||
name|O_EXCL
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|cmode
decl_stmt|;
name|struct
name|componentname
name|cn
decl_stmt|;
operator|*
name|vpp
operator|=
name|NULLVP
expr_stmt|;
name|FILEDESC_LOCK
argument_list|(
name|td
operator|->
name|td_proc
operator|->
name|p_fd
argument_list|)
expr_stmt|;
name|cmode
operator|=
name|UN_FILEMODE
operator|&
operator|~
name|td
operator|->
name|td_proc
operator|->
name|p_fd
operator|->
name|fd_cmask
expr_stmt|;
name|FILEDESC_UNLOCK
argument_list|(
name|td
operator|->
name|td_proc
operator|->
name|p_fd
argument_list|)
expr_stmt|;
comment|/* 	 * Build a new componentname structure (for the same 	 * reasons outlines in union_mkshadow). 	 * The difference here is that the file is owned by 	 * the current user, rather than by the person who 	 * did the mount, since the current user needs to be 	 * able to write the file (that's why it is being 	 * copied in the first place). 	 */
name|cn
operator|.
name|cn_namelen
operator|=
name|strlen
argument_list|(
name|un
operator|->
name|un_path
argument_list|)
expr_stmt|;
name|cn
operator|.
name|cn_pnbuf
operator|=
name|zalloc
argument_list|(
name|namei_zone
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|un
operator|->
name|un_path
argument_list|,
name|cn
operator|.
name|cn_pnbuf
argument_list|,
name|cn
operator|.
name|cn_namelen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|cn
operator|.
name|cn_nameiop
operator|=
name|CREATE
expr_stmt|;
name|cn
operator|.
name|cn_flags
operator|=
operator|(
name|LOCKPARENT
operator||
name|LOCKLEAF
operator||
name|HASBUF
operator||
name|SAVENAME
operator||
name|ISLASTCN
operator|)
expr_stmt|;
name|cn
operator|.
name|cn_thread
operator|=
name|td
expr_stmt|;
name|cn
operator|.
name|cn_cred
operator|=
name|td
operator|->
name|td_ucred
expr_stmt|;
name|cn
operator|.
name|cn_nameptr
operator|=
name|cn
operator|.
name|cn_pnbuf
expr_stmt|;
name|cn
operator|.
name|cn_consume
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Pass dvp unlocked and referenced on call to relookup(). 	 * 	 * If an error occurs, dvp will be returned unlocked and dereferenced. 	 */
name|VREF
argument_list|(
name|un
operator|->
name|un_dirvp
argument_list|)
expr_stmt|;
name|error
operator|=
name|relookup
argument_list|(
name|un
operator|->
name|un_dirvp
argument_list|,
operator|&
name|vp
argument_list|,
operator|&
name|cn
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * If no error occurs, dvp will be returned locked with the reference 	 * left as before, and vpp will be returned referenced and locked. 	 */
if|if
condition|(
name|vp
condition|)
block|{
name|vput
argument_list|(
name|un
operator|->
name|un_dirvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cn
operator|.
name|cn_flags
operator|&
name|HASBUF
condition|)
block|{
name|zfree
argument_list|(
name|namei_zone
argument_list|,
name|cn
operator|.
name|cn_pnbuf
argument_list|)
expr_stmt|;
name|cn
operator|.
name|cn_flags
operator|&=
operator|~
name|HASBUF
expr_stmt|;
block|}
if|if
condition|(
name|vp
operator|==
name|un
operator|->
name|un_dirvp
condition|)
name|vrele
argument_list|(
name|vp
argument_list|)
expr_stmt|;
else|else
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EEXIST
operator|)
return|;
block|}
comment|/* 	 * Good - there was no race to create the file 	 * so go ahead and create it.  The permissions 	 * on the file will be 0666 modified by the 	 * current user's umask.  Access to the file, while 	 * it is unioned, will require access to the top *and* 	 * bottom files.  Access when not unioned will simply 	 * require access to the top-level file. 	 * TODO: confirm choice of access permissions. 	 */
name|VATTR_NULL
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|vap
operator|->
name|va_type
operator|=
name|VREG
expr_stmt|;
name|vap
operator|->
name|va_mode
operator|=
name|cmode
expr_stmt|;
name|VOP_LEASE
argument_list|(
name|un
operator|->
name|un_dirvp
argument_list|,
name|td
argument_list|,
name|cred
argument_list|,
name|LEASE_WRITE
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_CREATE
argument_list|(
name|un
operator|->
name|un_dirvp
argument_list|,
operator|&
name|vp
argument_list|,
operator|&
name|cn
argument_list|,
name|vap
argument_list|)
expr_stmt|;
if|if
condition|(
name|cn
operator|.
name|cn_flags
operator|&
name|HASBUF
condition|)
block|{
name|zfree
argument_list|(
name|namei_zone
argument_list|,
name|cn
operator|.
name|cn_pnbuf
argument_list|)
expr_stmt|;
name|cn
operator|.
name|cn_flags
operator|&=
operator|~
name|HASBUF
expr_stmt|;
block|}
name|vput
argument_list|(
name|un
operator|->
name|un_dirvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|VOP_OPEN
argument_list|(
name|vp
argument_list|,
name|fmode
argument_list|,
name|cred
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|vn_canvmio
argument_list|(
name|vp
argument_list|)
operator|==
name|TRUE
condition|)
name|error
operator|=
name|vfs_object_create
argument_list|(
name|vp
argument_list|,
name|td
argument_list|,
name|cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|vp
operator|->
name|v_writecount
operator|++
expr_stmt|;
operator|*
name|vpp
operator|=
name|vp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|union_vn_close
parameter_list|(
name|vp
parameter_list|,
name|fmode
parameter_list|,
name|cred
parameter_list|,
name|td
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|int
name|fmode
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
block|{
if|if
condition|(
name|fmode
operator|&
name|FWRITE
condition|)
operator|--
name|vp
operator|->
name|v_writecount
expr_stmt|;
return|return
operator|(
name|VOP_CLOSE
argument_list|(
name|vp
argument_list|,
name|fmode
argument_list|,
name|cred
argument_list|,
name|td
argument_list|)
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*  *	union_removed_upper:  *  *	called with union_node unlocked. XXX  */
end_comment

begin_comment
unit|void union_removed_upper(un) 	struct union_node *un; { 	struct thread *td = curthread;
comment|/* XXX */
end_comment

begin_comment
unit|struct vnode **vpp;
comment|/* 	 * Do not set the uppervp to NULLVP.  If lowervp is NULLVP, 	 * union node will have neither uppervp nor lowervp.  We remove 	 * the union node from cache, so that it will not be referrenced. 	 */
end_comment

begin_endif
unit|union_newupper(un, NULLVP); 	if (un->un_dircache != 0) { 		for (vpp = un->un_dircache; *vpp != NULLVP; vpp++) 			vrele(*vpp); 		free(un->un_dircache, M_TEMP); 		un->un_dircache = 0; 	}  	if (un->un_flags& UN_CACHED) { 		un->un_flags&= ~UN_CACHED; 		LIST_REMOVE(un, un_cache); 	} }
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * determine whether a whiteout is needed  * during a remove/rmdir operation.  */
end_comment

begin_function
name|int
name|union_dowhiteout
parameter_list|(
name|un
parameter_list|,
name|cred
parameter_list|,
name|td
parameter_list|)
name|struct
name|union_node
modifier|*
name|un
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
block|{
name|struct
name|vattr
name|va
decl_stmt|;
if|if
condition|(
name|un
operator|->
name|un_lowervp
operator|!=
name|NULLVP
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|VOP_GETATTR
argument_list|(
name|un
operator|->
name|un_uppervp
argument_list|,
operator|&
name|va
argument_list|,
name|cred
argument_list|,
name|td
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|va
operator|.
name|va_flags
operator|&
name|OPAQUE
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|union_dircache_r
parameter_list|(
name|vp
parameter_list|,
name|vppp
parameter_list|,
name|cntp
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|vnode
modifier|*
modifier|*
modifier|*
name|vppp
decl_stmt|;
name|int
modifier|*
name|cntp
decl_stmt|;
block|{
name|struct
name|union_node
modifier|*
name|un
decl_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_op
operator|!=
name|union_vnodeop_p
condition|)
block|{
if|if
condition|(
name|vppp
condition|)
block|{
name|VREF
argument_list|(
name|vp
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|*
name|vppp
operator|)
operator|++
operator|=
name|vp
expr_stmt|;
if|if
condition|(
operator|--
operator|(
operator|*
name|cntp
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"union: dircache table too small"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
operator|*
name|cntp
operator|)
operator|++
expr_stmt|;
block|}
return|return;
block|}
name|un
operator|=
name|VTOUNION
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|un
operator|->
name|un_uppervp
operator|!=
name|NULLVP
condition|)
name|union_dircache_r
argument_list|(
name|un
operator|->
name|un_uppervp
argument_list|,
name|vppp
argument_list|,
name|cntp
argument_list|)
expr_stmt|;
if|if
condition|(
name|un
operator|->
name|un_lowervp
operator|!=
name|NULLVP
condition|)
name|union_dircache_r
argument_list|(
name|un
operator|->
name|un_lowervp
argument_list|,
name|vppp
argument_list|,
name|cntp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|vnode
modifier|*
name|union_dircache
parameter_list|(
name|vp
parameter_list|,
name|td
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
block|{
name|int
name|cnt
decl_stmt|;
name|struct
name|vnode
modifier|*
name|nvp
decl_stmt|;
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
decl_stmt|;
name|struct
name|vnode
modifier|*
modifier|*
name|dircache
decl_stmt|;
name|struct
name|union_node
modifier|*
name|un
decl_stmt|;
name|int
name|error
decl_stmt|;
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|dircache
operator|=
name|VTOUNION
argument_list|(
name|vp
argument_list|)
operator|->
name|un_dircache
expr_stmt|;
name|nvp
operator|=
name|NULLVP
expr_stmt|;
if|if
condition|(
name|dircache
operator|==
name|NULL
condition|)
block|{
name|cnt
operator|=
literal|0
expr_stmt|;
name|union_dircache_r
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
operator|&
name|cnt
argument_list|)
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
name|dircache
operator|=
name|malloc
argument_list|(
name|cnt
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|vnode
operator|*
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|vpp
operator|=
name|dircache
expr_stmt|;
name|union_dircache_r
argument_list|(
name|vp
argument_list|,
operator|&
name|vpp
argument_list|,
operator|&
name|cnt
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|NULLVP
expr_stmt|;
name|vpp
operator|=
name|dircache
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|vpp
operator|=
name|dircache
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|*
name|vpp
operator|++
operator|==
name|VTOUNION
argument_list|(
name|vp
argument_list|)
operator|->
name|un_uppervp
condition|)
break|break;
block|}
do|while
condition|(
operator|*
name|vpp
operator|!=
name|NULLVP
condition|)
do|;
block|}
if|if
condition|(
operator|*
name|vpp
operator|==
name|NULLVP
condition|)
goto|goto
name|out
goto|;
comment|/*vn_lock(*vpp, LK_EXCLUSIVE | LK_RETRY, td);*/
name|UDEBUG
argument_list|(
operator|(
literal|"ALLOCVP-3 %p ref %d\n"
operator|,
operator|*
name|vpp
operator|,
operator|(
operator|*
name|vpp
condition|?
operator|(
operator|*
name|vpp
operator|)
operator|->
name|v_usecount
else|:
operator|-
literal|99
operator|)
operator|)
argument_list|)
expr_stmt|;
name|VREF
argument_list|(
operator|*
name|vpp
argument_list|)
expr_stmt|;
name|error
operator|=
name|union_allocvp
argument_list|(
operator|&
name|nvp
argument_list|,
name|vp
operator|->
name|v_mount
argument_list|,
name|NULLVP
argument_list|,
name|NULLVP
argument_list|,
name|NULL
argument_list|,
operator|*
name|vpp
argument_list|,
name|NULLVP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|UDEBUG
argument_list|(
operator|(
literal|"ALLOCVP-3B %p ref %d\n"
operator|,
name|nvp
operator|,
operator|(
operator|*
name|vpp
condition|?
operator|(
operator|*
name|vpp
operator|)
operator|->
name|v_usecount
else|:
operator|-
literal|99
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|VTOUNION
argument_list|(
name|vp
argument_list|)
operator|->
name|un_dircache
operator|=
literal|0
expr_stmt|;
name|un
operator|=
name|VTOUNION
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
name|un
operator|->
name|un_dircache
operator|=
name|dircache
expr_stmt|;
name|out
label|:
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
operator|(
name|nvp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Module glue to remove #ifdef UNION from vfs_syscalls.c  */
end_comment

begin_function
specifier|static
name|int
name|union_dircheck
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|vnode
modifier|*
modifier|*
name|vp
parameter_list|,
name|struct
name|file
modifier|*
name|fp
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|vp
operator|)
operator|->
name|v_op
operator|==
name|union_vnodeop_p
condition|)
block|{
name|struct
name|vnode
modifier|*
name|lvp
decl_stmt|;
name|lvp
operator|=
name|union_dircache
argument_list|(
operator|*
name|vp
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|lvp
operator|!=
name|NULLVP
condition|)
block|{
name|struct
name|vattr
name|va
decl_stmt|;
comment|/* 			 * If the directory is opaque, 			 * then don't show lower entries 			 */
name|error
operator|=
name|VOP_GETATTR
argument_list|(
operator|*
name|vp
argument_list|,
operator|&
name|va
argument_list|,
name|fp
operator|->
name|f_cred
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|va
operator|.
name|va_flags
operator|&
name|OPAQUE
condition|)
block|{
name|vput
argument_list|(
name|lvp
argument_list|)
expr_stmt|;
name|lvp
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|lvp
operator|!=
name|NULLVP
condition|)
block|{
name|error
operator|=
name|VOP_OPEN
argument_list|(
name|lvp
argument_list|,
name|FREAD
argument_list|,
name|fp
operator|->
name|f_cred
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|vn_canvmio
argument_list|(
name|lvp
argument_list|)
operator|==
name|TRUE
condition|)
name|error
operator|=
name|vfs_object_create
argument_list|(
name|lvp
argument_list|,
name|td
argument_list|,
name|fp
operator|->
name|f_cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|vput
argument_list|(
name|lvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|VOP_UNLOCK
argument_list|(
name|lvp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|FILE_LOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fp
operator|->
name|f_data
operator|=
operator|(
name|caddr_t
operator|)
name|lvp
expr_stmt|;
name|fp
operator|->
name|f_offset
operator|=
literal|0
expr_stmt|;
name|FILE_UNLOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|error
operator|=
name|vn_close
argument_list|(
operator|*
name|vp
argument_list|,
name|FREAD
argument_list|,
name|fp
operator|->
name|f_cred
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
operator|*
name|vp
operator|=
name|lvp
expr_stmt|;
return|return
operator|-
literal|1
return|;
comment|/* goto unionread */
block|}
block|}
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|union_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|union_dircheckp
operator|=
name|union_dircheck
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
name|union_dircheckp
operator|=
name|NULL
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|moduledata_t
name|union_mod
init|=
block|{
literal|"union_dircheck"
block|,
name|union_modevent
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|union_dircheck
argument_list|,
name|union_mod
argument_list|,
name|SI_SUB_VFS
argument_list|,
name|SI_ORDER_ANY
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

