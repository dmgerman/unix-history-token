begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1994, 1995 The Regents of the University of California.  * Copyright (c) 1994, 1995 Jan-Simon Pendry.  * Copyright (c) 2005, 2006 Masanori Ozawa<ozawa@ongs.co.jp>, ONGS Inc.  * Copyright (c) 2006 Daichi Goto<daichi@freebsd.org>  * All rights reserved.  *  * This code is derived from software donated to Berkeley by  * Jan-Simon Pendry.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)union_vfsops.c	8.20 (Berkeley) 5/20/95  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kdb.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<fs/unionfs/union.h>
end_include

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_UNIONFSMNT
argument_list|,
literal|"UNIONFS mount"
argument_list|,
literal|"UNIONFS mount structure"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|vfs_fhtovp_t
name|unionfs_fhtovp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vfs_checkexp_t
name|unionfs_checkexp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vfs_mount_t
name|unionfs_domount
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vfs_quotactl_t
name|unionfs_quotactl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vfs_root_t
name|unionfs_root
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vfs_sync_t
name|unionfs_sync
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vfs_statfs_t
name|unionfs_statfs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vfs_unmount_t
name|unionfs_unmount
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vfs_vget_t
name|unionfs_vget
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vfs_extattrctl_t
name|unionfs_extattrctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|vfsops
name|unionfs_vfsops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Exchange from userland file mode to vmode.  */
end_comment

begin_function
specifier|static
name|u_short
name|mode2vmode
parameter_list|(
name|mode_t
name|mode
parameter_list|)
block|{
name|u_short
name|ret
decl_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
comment|/* other */
if|if
condition|(
name|mode
operator|&
name|S_IXOTH
condition|)
name|ret
operator||=
name|VEXEC
operator|>>
literal|6
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|S_IWOTH
condition|)
name|ret
operator||=
name|VWRITE
operator|>>
literal|6
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|S_IROTH
condition|)
name|ret
operator||=
name|VREAD
operator|>>
literal|6
expr_stmt|;
comment|/* group */
if|if
condition|(
name|mode
operator|&
name|S_IXGRP
condition|)
name|ret
operator||=
name|VEXEC
operator|>>
literal|3
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|S_IWGRP
condition|)
name|ret
operator||=
name|VWRITE
operator|>>
literal|3
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|S_IRGRP
condition|)
name|ret
operator||=
name|VREAD
operator|>>
literal|3
expr_stmt|;
comment|/* owner */
if|if
condition|(
name|mode
operator|&
name|S_IXUSR
condition|)
name|ret
operator||=
name|VEXEC
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|S_IWUSR
condition|)
name|ret
operator||=
name|VWRITE
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|S_IRUSR
condition|)
name|ret
operator||=
name|VREAD
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Mount unionfs layer.  */
end_comment

begin_function
specifier|static
name|int
name|unionfs_domount
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|vnode
modifier|*
name|lowerrootvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|upperrootvp
decl_stmt|;
name|struct
name|unionfs_mount
modifier|*
name|ump
decl_stmt|;
name|char
modifier|*
name|target
decl_stmt|;
name|char
modifier|*
name|tmp
decl_stmt|;
name|char
modifier|*
name|ep
decl_stmt|;
name|int
name|len
decl_stmt|;
name|size_t
name|done
decl_stmt|;
name|int
name|below
decl_stmt|;
name|uid_t
name|uid
decl_stmt|;
name|gid_t
name|gid
decl_stmt|;
name|u_short
name|udir
decl_stmt|;
name|u_short
name|ufile
decl_stmt|;
name|unionfs_copymode
name|copymode
decl_stmt|;
name|struct
name|componentname
name|fakecn
decl_stmt|;
name|struct
name|nameidata
name|nd
decl_stmt|,
modifier|*
name|ndp
decl_stmt|;
name|struct
name|vattr
name|va
decl_stmt|;
name|UNIONFSDEBUG
argument_list|(
literal|"unionfs_mount(mp = %p)\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|mp
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|below
operator|=
literal|0
expr_stmt|;
name|uid
operator|=
literal|0
expr_stmt|;
name|gid
operator|=
literal|0
expr_stmt|;
name|udir
operator|=
literal|0
expr_stmt|;
name|ufile
operator|=
literal|0
expr_stmt|;
name|copymode
operator|=
name|UNIONFS_TRADITIONAL
expr_stmt|;
comment|/* default */
name|ndp
operator|=
operator|&
name|nd
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|mnt_flag
operator|&
name|MNT_ROOTFS
condition|)
block|{
name|vfs_mount_error
argument_list|(
name|mp
argument_list|,
literal|"Cannot union mount root filesystem"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
comment|/* 	 * Update is a no operation. 	 */
if|if
condition|(
name|mp
operator|->
name|mnt_flag
operator|&
name|MNT_UPDATE
condition|)
block|{
name|vfs_mount_error
argument_list|(
name|mp
argument_list|,
literal|"unionfs does not support mount update"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
comment|/* 	 * Get argument 	 */
name|error
operator|=
name|vfs_getopt
argument_list|(
name|mp
operator|->
name|mnt_optnew
argument_list|,
literal|"target"
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|target
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|error
operator|=
name|vfs_getopt
argument_list|(
name|mp
operator|->
name|mnt_optnew
argument_list|,
literal|"from"
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|target
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|target
index|[
name|len
operator|-
literal|1
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|vfs_mount_error
argument_list|(
name|mp
argument_list|,
literal|"Invalid target"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|vfs_getopt
argument_list|(
name|mp
operator|->
name|mnt_optnew
argument_list|,
literal|"below"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
name|below
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|vfs_getopt
argument_list|(
name|mp
operator|->
name|mnt_optnew
argument_list|,
literal|"udir"
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|tmp
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|tmp
operator|!=
name|NULL
condition|)
name|udir
operator|=
operator|(
name|mode_t
operator|)
name|strtol
argument_list|(
name|tmp
argument_list|,
operator|&
name|ep
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL
operator|||
operator|*
name|ep
condition|)
block|{
name|vfs_mount_error
argument_list|(
name|mp
argument_list|,
literal|"Invalid udir"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|udir
operator|=
name|mode2vmode
argument_list|(
name|udir
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vfs_getopt
argument_list|(
name|mp
operator|->
name|mnt_optnew
argument_list|,
literal|"ufile"
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|tmp
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|tmp
operator|!=
name|NULL
condition|)
name|ufile
operator|=
operator|(
name|mode_t
operator|)
name|strtol
argument_list|(
name|tmp
argument_list|,
operator|&
name|ep
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL
operator|||
operator|*
name|ep
condition|)
block|{
name|vfs_mount_error
argument_list|(
name|mp
argument_list|,
literal|"Invalid ufile"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|ufile
operator|=
name|mode2vmode
argument_list|(
name|ufile
argument_list|)
expr_stmt|;
block|}
comment|/* check umask, uid and gid */
if|if
condition|(
name|udir
operator|==
literal|0
operator|&&
name|ufile
operator|!=
literal|0
condition|)
name|udir
operator|=
name|ufile
expr_stmt|;
if|if
condition|(
name|ufile
operator|==
literal|0
operator|&&
name|udir
operator|!=
literal|0
condition|)
name|ufile
operator|=
name|udir
expr_stmt|;
name|vn_lock
argument_list|(
name|mp
operator|->
name|mnt_vnodecovered
argument_list|,
name|LK_SHARED
operator||
name|LK_RETRY
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|mp
operator|->
name|mnt_vnodecovered
argument_list|,
operator|&
name|va
argument_list|,
name|mp
operator|->
name|mnt_cred
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
if|if
condition|(
name|udir
operator|==
literal|0
condition|)
name|udir
operator|=
name|va
operator|.
name|va_mode
expr_stmt|;
if|if
condition|(
name|ufile
operator|==
literal|0
condition|)
name|ufile
operator|=
name|va
operator|.
name|va_mode
expr_stmt|;
name|uid
operator|=
name|va
operator|.
name|va_uid
expr_stmt|;
name|gid
operator|=
name|va
operator|.
name|va_gid
expr_stmt|;
block|}
name|VOP_UNLOCK
argument_list|(
name|mp
operator|->
name|mnt_vnodecovered
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|mp
operator|->
name|mnt_cred
operator|->
name|cr_ruid
operator|==
literal|0
condition|)
block|{
comment|/* root only */
if|if
condition|(
name|vfs_getopt
argument_list|(
name|mp
operator|->
name|mnt_optnew
argument_list|,
literal|"uid"
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|tmp
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|tmp
operator|!=
name|NULL
condition|)
name|uid
operator|=
operator|(
name|uid_t
operator|)
name|strtol
argument_list|(
name|tmp
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL
operator|||
operator|*
name|ep
condition|)
block|{
name|vfs_mount_error
argument_list|(
name|mp
argument_list|,
literal|"Invalid uid"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
if|if
condition|(
name|vfs_getopt
argument_list|(
name|mp
operator|->
name|mnt_optnew
argument_list|,
literal|"gid"
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|tmp
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|tmp
operator|!=
name|NULL
condition|)
name|gid
operator|=
operator|(
name|gid_t
operator|)
name|strtol
argument_list|(
name|tmp
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL
operator|||
operator|*
name|ep
condition|)
block|{
name|vfs_mount_error
argument_list|(
name|mp
argument_list|,
literal|"Invalid gid"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
if|if
condition|(
name|vfs_getopt
argument_list|(
name|mp
operator|->
name|mnt_optnew
argument_list|,
literal|"copymode"
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|tmp
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|tmp
operator|==
name|NULL
condition|)
block|{
name|vfs_mount_error
argument_list|(
name|mp
argument_list|,
literal|"Invalid copymode"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|tmp
argument_list|,
literal|"traditional"
argument_list|)
operator|==
literal|0
condition|)
name|copymode
operator|=
name|UNIONFS_TRADITIONAL
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|tmp
argument_list|,
literal|"transparent"
argument_list|)
operator|==
literal|0
condition|)
name|copymode
operator|=
name|UNIONFS_TRANSPARENT
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|tmp
argument_list|,
literal|"masquerade"
argument_list|)
operator|==
literal|0
condition|)
name|copymode
operator|=
name|UNIONFS_MASQUERADE
expr_stmt|;
else|else
block|{
name|vfs_mount_error
argument_list|(
name|mp
argument_list|,
literal|"Invalid copymode"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
block|}
comment|/* If copymode is UNIONFS_TRADITIONAL, uid/gid is mounted user. */
if|if
condition|(
name|copymode
operator|==
name|UNIONFS_TRADITIONAL
condition|)
block|{
name|uid
operator|=
name|mp
operator|->
name|mnt_cred
operator|->
name|cr_ruid
expr_stmt|;
name|gid
operator|=
name|mp
operator|->
name|mnt_cred
operator|->
name|cr_rgid
expr_stmt|;
block|}
name|UNIONFSDEBUG
argument_list|(
literal|"unionfs_mount: uid=%d, gid=%d\n"
argument_list|,
name|uid
argument_list|,
name|gid
argument_list|)
expr_stmt|;
name|UNIONFSDEBUG
argument_list|(
literal|"unionfs_mount: udir=0%03o, ufile=0%03o\n"
argument_list|,
name|udir
argument_list|,
name|ufile
argument_list|)
expr_stmt|;
name|UNIONFSDEBUG
argument_list|(
literal|"unionfs_mount: copymode=%d\n"
argument_list|,
name|copymode
argument_list|)
expr_stmt|;
comment|/* 	 * Find upper node 	 */
name|NDINIT
argument_list|(
name|ndp
argument_list|,
name|LOOKUP
argument_list|,
name|FOLLOW
operator||
name|WANTPARENT
operator||
name|LOCKLEAF
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|target
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|namei
argument_list|(
name|ndp
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|NDFREE
argument_list|(
name|ndp
argument_list|,
name|NDF_ONLY_PNBUF
argument_list|)
expr_stmt|;
comment|/* get root vnodes */
name|lowerrootvp
operator|=
name|mp
operator|->
name|mnt_vnodecovered
expr_stmt|;
name|upperrootvp
operator|=
name|ndp
operator|->
name|ni_vp
expr_stmt|;
name|vrele
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|)
expr_stmt|;
name|ndp
operator|->
name|ni_dvp
operator|=
name|NULLVP
expr_stmt|;
comment|/* create unionfs_mount */
name|ump
operator|=
operator|(
expr|struct
name|unionfs_mount
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|unionfs_mount
argument_list|)
argument_list|,
name|M_UNIONFSMNT
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
comment|/* 	 * Save reference 	 */
if|if
condition|(
name|below
condition|)
block|{
name|VOP_UNLOCK
argument_list|(
name|upperrootvp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|vn_lock
argument_list|(
name|lowerrootvp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|ump
operator|->
name|um_lowervp
operator|=
name|upperrootvp
expr_stmt|;
name|ump
operator|->
name|um_uppervp
operator|=
name|lowerrootvp
expr_stmt|;
block|}
else|else
block|{
name|ump
operator|->
name|um_lowervp
operator|=
name|lowerrootvp
expr_stmt|;
name|ump
operator|->
name|um_uppervp
operator|=
name|upperrootvp
expr_stmt|;
block|}
name|ump
operator|->
name|um_rootvp
operator|=
name|NULLVP
expr_stmt|;
name|ump
operator|->
name|um_uid
operator|=
name|uid
expr_stmt|;
name|ump
operator|->
name|um_gid
operator|=
name|gid
expr_stmt|;
name|ump
operator|->
name|um_udir
operator|=
name|udir
expr_stmt|;
name|ump
operator|->
name|um_ufile
operator|=
name|ufile
expr_stmt|;
name|ump
operator|->
name|um_copymode
operator|=
name|copymode
expr_stmt|;
name|MNT_ILOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lowerrootvp
operator|->
name|v_mount
operator|->
name|mnt_kern_flag
operator|&
name|MNTK_MPSAFE
operator|)
operator|&&
operator|(
name|upperrootvp
operator|->
name|v_mount
operator|->
name|mnt_kern_flag
operator|&
name|MNTK_MPSAFE
operator|)
condition|)
name|mp
operator|->
name|mnt_kern_flag
operator||=
name|MNTK_MPSAFE
expr_stmt|;
name|MNT_IUNLOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|mp
operator|->
name|mnt_data
operator|=
operator|(
name|qaddr_t
operator|)
name|ump
expr_stmt|;
comment|/* 	 * Copy upper layer's RDONLY flag. 	 */
name|mp
operator|->
name|mnt_flag
operator||=
name|ump
operator|->
name|um_uppervp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
expr_stmt|;
comment|/* 	 * Check whiteout 	 */
if|if
condition|(
operator|(
name|mp
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
operator|)
operator|==
literal|0
condition|)
block|{
name|memset
argument_list|(
operator|&
name|fakecn
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|fakecn
argument_list|)
argument_list|)
expr_stmt|;
name|fakecn
operator|.
name|cn_nameiop
operator|=
name|LOOKUP
expr_stmt|;
name|fakecn
operator|.
name|cn_thread
operator|=
name|td
expr_stmt|;
name|error
operator|=
name|VOP_WHITEOUT
argument_list|(
name|ump
operator|->
name|um_uppervp
argument_list|,
operator|&
name|fakecn
argument_list|,
name|LOOKUP
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|below
condition|)
block|{
name|VOP_UNLOCK
argument_list|(
name|ump
operator|->
name|um_uppervp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|upperrootvp
argument_list|)
expr_stmt|;
block|}
else|else
name|vput
argument_list|(
name|ump
operator|->
name|um_uppervp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ump
argument_list|,
name|M_UNIONFSMNT
argument_list|)
expr_stmt|;
name|mp
operator|->
name|mnt_data
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
comment|/* 	 * Unlock the node 	 */
name|VOP_UNLOCK
argument_list|(
name|ump
operator|->
name|um_uppervp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
comment|/* 	 * Get the unionfs root vnode. 	 */
name|error
operator|=
name|unionfs_nodeget
argument_list|(
name|mp
argument_list|,
name|ump
operator|->
name|um_uppervp
argument_list|,
name|ump
operator|->
name|um_lowervp
argument_list|,
name|NULLVP
argument_list|,
operator|&
operator|(
name|ump
operator|->
name|um_rootvp
operator|)
argument_list|,
name|NULL
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|vrele
argument_list|(
name|upperrootvp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ump
argument_list|,
name|M_UNIONFSMNT
argument_list|)
expr_stmt|;
name|mp
operator|->
name|mnt_data
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Check mnt_flag 	 */
if|if
condition|(
operator|(
name|ump
operator|->
name|um_lowervp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_LOCAL
operator|)
operator|&&
operator|(
name|ump
operator|->
name|um_uppervp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_LOCAL
operator|)
condition|)
name|mp
operator|->
name|mnt_flag
operator||=
name|MNT_LOCAL
expr_stmt|;
comment|/* 	 * Get new fsid 	 */
name|vfs_getnewfsid
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|len
operator|=
name|MNAMELEN
operator|-
literal|1
expr_stmt|;
name|tmp
operator|=
name|mp
operator|->
name|mnt_stat
operator|.
name|f_mntfromname
expr_stmt|;
name|copystr
argument_list|(
operator|(
name|below
condition|?
literal|"<below>:"
else|:
literal|"<above>:"
operator|)
argument_list|,
name|tmp
argument_list|,
name|len
argument_list|,
operator|&
name|done
argument_list|)
expr_stmt|;
name|len
operator|-=
name|done
operator|-
literal|1
expr_stmt|;
name|tmp
operator|+=
name|done
operator|-
literal|1
expr_stmt|;
name|copystr
argument_list|(
name|target
argument_list|,
name|tmp
argument_list|,
name|len
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|UNIONFSDEBUG
argument_list|(
literal|"unionfs_mount: from %s, on %s\n"
argument_list|,
name|mp
operator|->
name|mnt_stat
operator|.
name|f_mntfromname
argument_list|,
name|mp
operator|->
name|mnt_stat
operator|.
name|f_mntonname
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free reference to unionfs layer  */
end_comment

begin_function
specifier|static
name|int
name|unionfs_unmount
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|int
name|mntflags
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|unionfs_mount
modifier|*
name|ump
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|num
decl_stmt|;
name|int
name|freeing
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|UNIONFSDEBUG
argument_list|(
literal|"unionfs_unmount: mp = %p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|mp
argument_list|)
expr_stmt|;
name|ump
operator|=
name|MOUNTTOUNIONFSMOUNT
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mntflags
operator|&
name|MNT_FORCE
condition|)
name|flags
operator||=
name|FORCECLOSE
expr_stmt|;
comment|/* vflush (no need to call vrele) */
for|for
control|(
name|freeing
operator|=
literal|0
init|;
operator|(
name|error
operator|=
name|vflush
argument_list|(
name|mp
argument_list|,
literal|1
argument_list|,
name|flags
argument_list|,
name|td
argument_list|)
operator|)
operator|!=
literal|0
condition|;
control|)
block|{
name|num
operator|=
name|mp
operator|->
name|mnt_nvnodelistsize
expr_stmt|;
if|if
condition|(
name|num
operator|==
name|freeing
condition|)
break|break;
name|freeing
operator|=
name|num
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|free
argument_list|(
name|ump
argument_list|,
name|M_UNIONFSMNT
argument_list|)
expr_stmt|;
name|mp
operator|->
name|mnt_data
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unionfs_root
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|unionfs_mount
modifier|*
name|ump
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|ump
operator|=
name|MOUNTTOUNIONFSMOUNT
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|vp
operator|=
name|ump
operator|->
name|um_rootvp
expr_stmt|;
name|UNIONFSDEBUG
argument_list|(
literal|"unionfs_root: rootvp=%p locked=%x\n"
argument_list|,
name|vp
argument_list|,
name|VOP_ISLOCKED
argument_list|(
name|vp
argument_list|,
name|td
argument_list|)
argument_list|)
expr_stmt|;
name|vref
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|LK_TYPE_MASK
condition|)
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|flags
argument_list|,
name|td
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|vp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unionfs_quotactl
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|int
name|cmd
parameter_list|,
name|uid_t
name|uid
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|unionfs_mount
modifier|*
name|ump
decl_stmt|;
name|ump
operator|=
name|MOUNTTOUNIONFSMOUNT
argument_list|(
name|mp
argument_list|)
expr_stmt|;
comment|/* 	 * Writing is always performed to upper vnode. 	 */
return|return
operator|(
name|VFS_QUOTACTL
argument_list|(
name|ump
operator|->
name|um_uppervp
operator|->
name|v_mount
argument_list|,
name|cmd
argument_list|,
name|uid
argument_list|,
name|arg
argument_list|,
name|td
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unionfs_statfs
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|struct
name|statfs
modifier|*
name|sbp
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|unionfs_mount
modifier|*
name|ump
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|statfs
name|mstat
decl_stmt|;
name|uint64_t
name|lbsize
decl_stmt|;
name|ump
operator|=
name|MOUNTTOUNIONFSMOUNT
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|UNIONFSDEBUG
argument_list|(
literal|"unionfs_statfs(mp = %p, lvp = %p, uvp = %p)\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|mp
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ump
operator|->
name|um_lowervp
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ump
operator|->
name|um_uppervp
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|mstat
argument_list|,
sizeof|sizeof
argument_list|(
name|mstat
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|VFS_STATFS
argument_list|(
name|ump
operator|->
name|um_lowervp
operator|->
name|v_mount
argument_list|,
operator|&
name|mstat
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* now copy across the "interesting" information and fake the rest */
name|sbp
operator|->
name|f_blocks
operator|=
name|mstat
operator|.
name|f_blocks
expr_stmt|;
name|sbp
operator|->
name|f_files
operator|=
name|mstat
operator|.
name|f_files
expr_stmt|;
name|lbsize
operator|=
name|mstat
operator|.
name|f_bsize
expr_stmt|;
name|error
operator|=
name|VFS_STATFS
argument_list|(
name|ump
operator|->
name|um_uppervp
operator|->
name|v_mount
argument_list|,
operator|&
name|mstat
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * The FS type etc is copy from upper vfs. 	 * (write able vfs have priority) 	 */
name|sbp
operator|->
name|f_type
operator|=
name|mstat
operator|.
name|f_type
expr_stmt|;
name|sbp
operator|->
name|f_flags
operator|=
name|mstat
operator|.
name|f_flags
expr_stmt|;
name|sbp
operator|->
name|f_bsize
operator|=
name|mstat
operator|.
name|f_bsize
expr_stmt|;
name|sbp
operator|->
name|f_iosize
operator|=
name|mstat
operator|.
name|f_iosize
expr_stmt|;
if|if
condition|(
name|mstat
operator|.
name|f_bsize
operator|!=
name|lbsize
condition|)
name|sbp
operator|->
name|f_blocks
operator|=
operator|(
operator|(
name|off_t
operator|)
name|sbp
operator|->
name|f_blocks
operator|*
name|lbsize
operator|)
operator|/
name|mstat
operator|.
name|f_bsize
expr_stmt|;
name|sbp
operator|->
name|f_blocks
operator|+=
name|mstat
operator|.
name|f_blocks
expr_stmt|;
name|sbp
operator|->
name|f_bfree
operator|=
name|mstat
operator|.
name|f_bfree
expr_stmt|;
name|sbp
operator|->
name|f_bavail
operator|=
name|mstat
operator|.
name|f_bavail
expr_stmt|;
name|sbp
operator|->
name|f_files
operator|+=
name|mstat
operator|.
name|f_files
expr_stmt|;
name|sbp
operator|->
name|f_ffree
operator|=
name|mstat
operator|.
name|f_ffree
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unionfs_sync
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|int
name|waitfor
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
comment|/* nothing to do */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unionfs_vget
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|ino_t
name|ino
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
parameter_list|)
block|{
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unionfs_fhtovp
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|struct
name|fid
modifier|*
name|fidp
parameter_list|,
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
parameter_list|)
block|{
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unionfs_checkexp
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|,
name|int
modifier|*
name|extflagsp
parameter_list|,
name|struct
name|ucred
modifier|*
modifier|*
name|credanonp
parameter_list|)
block|{
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unionfs_extattrctl
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|int
name|cmd
parameter_list|,
name|struct
name|vnode
modifier|*
name|filename_vp
parameter_list|,
name|int
name|namespace
parameter_list|,
specifier|const
name|char
modifier|*
name|attrname
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|unionfs_mount
modifier|*
name|ump
decl_stmt|;
name|struct
name|unionfs_node
modifier|*
name|unp
decl_stmt|;
name|ump
operator|=
name|MOUNTTOUNIONFSMOUNT
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|unp
operator|=
name|VTOUNIONFS
argument_list|(
name|filename_vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|unp
operator|->
name|un_uppervp
operator|!=
name|NULLVP
condition|)
block|{
return|return
operator|(
name|VFS_EXTATTRCTL
argument_list|(
name|ump
operator|->
name|um_uppervp
operator|->
name|v_mount
argument_list|,
name|cmd
argument_list|,
name|unp
operator|->
name|un_uppervp
argument_list|,
name|namespace
argument_list|,
name|attrname
argument_list|,
name|td
argument_list|)
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|VFS_EXTATTRCTL
argument_list|(
name|ump
operator|->
name|um_lowervp
operator|->
name|v_mount
argument_list|,
name|cmd
argument_list|,
name|unp
operator|->
name|un_lowervp
argument_list|,
name|namespace
argument_list|,
name|attrname
argument_list|,
name|td
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|vfsops
name|unionfs_vfsops
init|=
block|{
operator|.
name|vfs_checkexp
operator|=
name|unionfs_checkexp
block|,
operator|.
name|vfs_extattrctl
operator|=
name|unionfs_extattrctl
block|,
operator|.
name|vfs_fhtovp
operator|=
name|unionfs_fhtovp
block|,
operator|.
name|vfs_init
operator|=
name|unionfs_init
block|,
operator|.
name|vfs_mount
operator|=
name|unionfs_domount
block|,
operator|.
name|vfs_quotactl
operator|=
name|unionfs_quotactl
block|,
operator|.
name|vfs_root
operator|=
name|unionfs_root
block|,
operator|.
name|vfs_statfs
operator|=
name|unionfs_statfs
block|,
operator|.
name|vfs_sync
operator|=
name|unionfs_sync
block|,
operator|.
name|vfs_uninit
operator|=
name|unionfs_uninit
block|,
operator|.
name|vfs_unmount
operator|=
name|unionfs_unmount
block|,
operator|.
name|vfs_vget
operator|=
name|unionfs_vget
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|VFS_SET
argument_list|(
name|unionfs_vfsops
argument_list|,
name|unionfs
argument_list|,
name|VFCF_LOOPBACK
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

