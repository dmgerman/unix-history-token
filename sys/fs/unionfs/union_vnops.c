begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992, 1993, 1994, 1995 Jan-Simon Pendry.  * Copyright (c) 1992, 1993, 1994, 1995  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Jan-Simon Pendry.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)union_vnops.c	8.32 (Berkeley) 6/23/95  * $Id: union_vnops.c,v 1.42 1997/09/14 02:58:04 peter Exp $  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<miscfs/union/union.h>
end_include

begin_define
define|#
directive|define
name|FIXUP
parameter_list|(
name|un
parameter_list|,
name|p
parameter_list|)
value|{ \ 	if (((un)->un_flags& UN_ULOCK) == 0) { \ 		union_fixup(un, p); \ 	} \ }
end_define

begin_define
define|#
directive|define
name|SETKLOCK
parameter_list|(
name|un
parameter_list|)
value|(un)->un_flags |= UN_KLOCK
end_define

begin_define
define|#
directive|define
name|CLEARKLOCK
parameter_list|(
name|un
parameter_list|)
value|(un)->un_flags&= ~UN_KLOCK
end_define

begin_decl_stmt
specifier|static
name|int
name|union_abortop
name|__P
argument_list|(
operator|(
expr|struct
name|vop_abortop_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_access
name|__P
argument_list|(
operator|(
expr|struct
name|vop_access_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_advlock
name|__P
argument_list|(
operator|(
expr|struct
name|vop_advlock_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_bmap
name|__P
argument_list|(
operator|(
expr|struct
name|vop_bmap_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_close
name|__P
argument_list|(
operator|(
expr|struct
name|vop_close_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_create
name|__P
argument_list|(
operator|(
expr|struct
name|vop_create_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|union_fixup
name|__P
argument_list|(
operator|(
expr|struct
name|union_node
operator|*
name|un
operator|,
expr|struct
name|proc
operator|*
name|p
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_fsync
name|__P
argument_list|(
operator|(
expr|struct
name|vop_fsync_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_getattr
name|__P
argument_list|(
operator|(
expr|struct
name|vop_getattr_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_inactive
name|__P
argument_list|(
operator|(
expr|struct
name|vop_inactive_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_ioctl
name|__P
argument_list|(
operator|(
expr|struct
name|vop_ioctl_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_islocked
name|__P
argument_list|(
operator|(
expr|struct
name|vop_islocked_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_lease
name|__P
argument_list|(
operator|(
expr|struct
name|vop_lease_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_link
name|__P
argument_list|(
operator|(
expr|struct
name|vop_link_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_lock
name|__P
argument_list|(
operator|(
expr|struct
name|vop_lock_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_lookup
name|__P
argument_list|(
operator|(
expr|struct
name|vop_lookup_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_lookup1
name|__P
argument_list|(
operator|(
expr|struct
name|vnode
operator|*
name|udvp
operator|,
expr|struct
name|vnode
operator|*
operator|*
name|dvpp
operator|,
expr|struct
name|vnode
operator|*
operator|*
name|vpp
operator|,
expr|struct
name|componentname
operator|*
name|cnp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_mkdir
name|__P
argument_list|(
operator|(
expr|struct
name|vop_mkdir_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_mknod
name|__P
argument_list|(
operator|(
expr|struct
name|vop_mknod_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_mmap
name|__P
argument_list|(
operator|(
expr|struct
name|vop_mmap_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_open
name|__P
argument_list|(
operator|(
expr|struct
name|vop_open_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_pathconf
name|__P
argument_list|(
operator|(
expr|struct
name|vop_pathconf_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_print
name|__P
argument_list|(
operator|(
expr|struct
name|vop_print_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_read
name|__P
argument_list|(
operator|(
expr|struct
name|vop_read_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_readdir
name|__P
argument_list|(
operator|(
expr|struct
name|vop_readdir_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_readlink
name|__P
argument_list|(
operator|(
expr|struct
name|vop_readlink_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_reclaim
name|__P
argument_list|(
operator|(
expr|struct
name|vop_reclaim_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_remove
name|__P
argument_list|(
operator|(
expr|struct
name|vop_remove_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_rename
name|__P
argument_list|(
operator|(
expr|struct
name|vop_rename_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_revoke
name|__P
argument_list|(
operator|(
expr|struct
name|vop_revoke_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_rmdir
name|__P
argument_list|(
operator|(
expr|struct
name|vop_rmdir_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_seek
name|__P
argument_list|(
operator|(
expr|struct
name|vop_seek_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_poll
name|__P
argument_list|(
operator|(
expr|struct
name|vop_poll_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_setattr
name|__P
argument_list|(
operator|(
expr|struct
name|vop_setattr_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_strategy
name|__P
argument_list|(
operator|(
expr|struct
name|vop_strategy_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_symlink
name|__P
argument_list|(
operator|(
expr|struct
name|vop_symlink_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_unlock
name|__P
argument_list|(
operator|(
expr|struct
name|vop_unlock_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_whiteout
name|__P
argument_list|(
operator|(
expr|struct
name|vop_whiteout_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|union_write
name|__P
argument_list|(
operator|(
expr|struct
name|vop_read_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|union_fixup
parameter_list|(
name|un
parameter_list|,
name|p
parameter_list|)
name|struct
name|union_node
modifier|*
name|un
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|vn_lock
argument_list|(
name|un
operator|->
name|un_uppervp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|un
operator|->
name|un_flags
operator||=
name|UN_ULOCK
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|union_lookup1
parameter_list|(
name|udvp
parameter_list|,
name|dvpp
parameter_list|,
name|vpp
parameter_list|,
name|cnp
parameter_list|)
name|struct
name|vnode
modifier|*
name|udvp
decl_stmt|;
name|struct
name|vnode
modifier|*
modifier|*
name|dvpp
decl_stmt|;
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|cnp
operator|->
name|cn_proc
decl_stmt|;
name|struct
name|vnode
modifier|*
name|tdvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|dvp
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|dvp
operator|=
operator|*
name|dvpp
expr_stmt|;
comment|/* 	 * If stepping up the directory tree, check for going 	 * back across the mount point, in which case do what 	 * lookup would do by stepping back down the mount 	 * hierarchy. 	 */
if|if
condition|(
name|cnp
operator|->
name|cn_flags
operator|&
name|ISDOTDOT
condition|)
block|{
while|while
condition|(
operator|(
name|dvp
operator|!=
name|udvp
operator|)
operator|&&
operator|(
name|dvp
operator|->
name|v_flag
operator|&
name|VROOT
operator|)
condition|)
block|{
comment|/* 			 * Don't do the NOCROSSMOUNT check 			 * at this level.  By definition, 			 * union fs deals with namespaces, not 			 * filesystems. 			 */
name|tdvp
operator|=
name|dvp
expr_stmt|;
operator|*
name|dvpp
operator|=
name|dvp
operator|=
name|dvp
operator|->
name|v_mount
operator|->
name|mnt_vnodecovered
expr_stmt|;
name|vput
argument_list|(
name|tdvp
argument_list|)
expr_stmt|;
name|VREF
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|vn_lock
argument_list|(
name|dvp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
name|error
operator|=
name|VOP_LOOKUP
argument_list|(
name|dvp
argument_list|,
operator|&
name|tdvp
argument_list|,
name|cnp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * The parent directory will have been unlocked, unless lookup 	 * found the last component.  In which case, re-lock the node 	 * here to allow it to be unlocked again (phew) in union_lookup. 	 */
if|if
condition|(
name|dvp
operator|!=
name|tdvp
operator|&&
operator|!
operator|(
name|cnp
operator|->
name|cn_flags
operator|&
name|ISLASTCN
operator|)
condition|)
name|vn_lock
argument_list|(
name|dvp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|dvp
operator|=
name|tdvp
expr_stmt|;
comment|/* 	 * Lastly check if the current node is a mount point in 	 * which case walk up the mount hierarchy making sure not to 	 * bump into the root of the mount tree (ie. dvp != udvp). 	 */
while|while
condition|(
name|dvp
operator|!=
name|udvp
operator|&&
operator|(
name|dvp
operator|->
name|v_type
operator|==
name|VDIR
operator|)
operator|&&
operator|(
name|mp
operator|=
name|dvp
operator|->
name|v_mountedhere
operator|)
condition|)
block|{
if|if
condition|(
name|vfs_busy
argument_list|(
name|mp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
condition|)
continue|continue;
name|error
operator|=
name|VFS_ROOT
argument_list|(
name|mp
argument_list|,
operator|&
name|tdvp
argument_list|)
expr_stmt|;
name|vfs_unbusy
argument_list|(
name|mp
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|vput
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|vput
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|dvp
operator|=
name|tdvp
expr_stmt|;
block|}
operator|*
name|vpp
operator|=
name|dvp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|union_lookup
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_lookup_args
comment|/* { 		struct vnodeop_desc *a_desc; 		struct vnode *a_dvp; 		struct vnode **a_vpp; 		struct componentname *a_cnp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|int
name|uerror
decl_stmt|,
name|lerror
decl_stmt|;
name|struct
name|vnode
modifier|*
name|uppervp
decl_stmt|,
modifier|*
name|lowervp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|upperdvp
decl_stmt|,
modifier|*
name|lowerdvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|dvp
init|=
name|ap
operator|->
name|a_dvp
decl_stmt|;
name|struct
name|union_node
modifier|*
name|dun
init|=
name|VTOUNION
argument_list|(
name|dvp
argument_list|)
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|cnp
operator|->
name|cn_proc
decl_stmt|;
name|int
name|lockparent
init|=
name|cnp
operator|->
name|cn_flags
operator|&
name|LOCKPARENT
decl_stmt|;
name|struct
name|union_mount
modifier|*
name|um
init|=
name|MOUNTTOUNIONMOUNT
argument_list|(
name|dvp
operator|->
name|v_mount
argument_list|)
decl_stmt|;
name|struct
name|ucred
modifier|*
name|saved_cred
decl_stmt|;
name|int
name|iswhiteout
decl_stmt|;
name|struct
name|vattr
name|va
decl_stmt|;
comment|/* 	 * Disallow write attemps to the filesystem mounted read-only. 	 */
if|if
condition|(
operator|(
name|cnp
operator|->
name|cn_flags
operator|&
name|ISLASTCN
operator|)
operator|&&
operator|(
name|dvp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
operator|)
operator|&&
operator|(
name|cnp
operator|->
name|cn_nameiop
operator|==
name|DELETE
operator|||
name|cnp
operator|->
name|cn_nameiop
operator|==
name|RENAME
operator|)
condition|)
return|return
operator|(
name|EROFS
operator|)
return|;
ifdef|#
directive|ifdef
name|notyet
if|if
condition|(
name|cnp
operator|->
name|cn_namelen
operator|==
literal|3
operator|&&
name|cnp
operator|->
name|cn_nameptr
index|[
literal|2
index|]
operator|==
literal|'.'
operator|&&
name|cnp
operator|->
name|cn_nameptr
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|cnp
operator|->
name|cn_nameptr
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
block|{
name|dvp
operator|=
operator|*
name|ap
operator|->
name|a_vpp
operator|=
name|LOWERVP
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dvp
operator|==
name|NULLVP
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
name|VREF
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|vn_lock
argument_list|(
name|dvp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lockparent
operator|||
operator|!
operator|(
name|cnp
operator|->
name|cn_flags
operator|&
name|ISLASTCN
operator|)
condition|)
name|VOP_UNLOCK
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
name|cnp
operator|->
name|cn_flags
operator||=
name|LOCKPARENT
expr_stmt|;
name|upperdvp
operator|=
name|dun
operator|->
name|un_uppervp
expr_stmt|;
name|lowerdvp
operator|=
name|dun
operator|->
name|un_lowervp
expr_stmt|;
name|uppervp
operator|=
name|NULLVP
expr_stmt|;
name|lowervp
operator|=
name|NULLVP
expr_stmt|;
name|iswhiteout
operator|=
literal|0
expr_stmt|;
comment|/* 	 * do the lookup in the upper level. 	 * if that level comsumes additional pathnames, 	 * then assume that something special is going 	 * on and just return that vnode. 	 */
if|if
condition|(
name|upperdvp
operator|!=
name|NULLVP
condition|)
block|{
name|FIXUP
argument_list|(
name|dun
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* 		 * If we're doing `..' in the underlying filesystem, 		 * we must drop our lock on the union node before 		 * going up the tree in the lower file system--if we block 		 * on the lowervp lock, and that's held by someone else 		 * coming down the tree and who's waiting for our lock, 		 * we would be hosed. 		 */
if|if
condition|(
name|cnp
operator|->
name|cn_flags
operator|&
name|ISDOTDOT
condition|)
block|{
comment|/* retain lock on underlying VP: */
name|SETKLOCK
argument_list|(
name|dun
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|dvp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|CLEARKLOCK
argument_list|(
name|dun
argument_list|)
expr_stmt|;
block|}
name|uerror
operator|=
name|union_lookup1
argument_list|(
name|um
operator|->
name|um_uppervp
argument_list|,
operator|&
name|upperdvp
argument_list|,
operator|&
name|uppervp
argument_list|,
name|cnp
argument_list|)
expr_stmt|;
comment|/* 		 * Disallow write attemps to the filesystem mounted read-only. 		 */
if|if
condition|(
name|uerror
operator|==
name|EJUSTRETURN
operator|&&
operator|(
name|cnp
operator|->
name|cn_flags
operator|&
name|ISLASTCN
operator|)
operator|&&
operator|(
name|dvp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
operator|)
operator|&&
operator|(
name|cnp
operator|->
name|cn_nameiop
operator|==
name|CREATE
operator|||
name|cnp
operator|->
name|cn_nameiop
operator|==
name|RENAME
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|lockparent
condition|)
name|cnp
operator|->
name|cn_flags
operator|&=
operator|~
name|LOCKPARENT
expr_stmt|;
return|return
operator|(
name|EROFS
operator|)
return|;
block|}
if|if
condition|(
name|cnp
operator|->
name|cn_flags
operator|&
name|ISDOTDOT
condition|)
block|{
if|if
condition|(
name|dun
operator|->
name|un_uppervp
operator|==
name|upperdvp
condition|)
block|{
comment|/* 				 * We got the underlying bugger back locked... 				 * now take back the union node lock.  Since we 				 * hold the uppervp lock, we can diddle union 				 * locking flags at will. :) 				 */
name|dun
operator|->
name|un_flags
operator||=
name|UN_ULOCK
expr_stmt|;
block|}
comment|/* 			 * If upperdvp got swapped out, it means we did 			 * some mount point magic, and we do not have 			 * dun->un_uppervp locked currently--so we get it 			 * locked here (don't set the UN_ULOCK flag). 			 */
name|vn_lock
argument_list|(
name|dvp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
comment|/*if (uppervp == upperdvp) 			dun->un_flags |= UN_KLOCK;*/
if|if
condition|(
name|cnp
operator|->
name|cn_consume
operator|!=
literal|0
condition|)
block|{
operator|*
name|ap
operator|->
name|a_vpp
operator|=
name|uppervp
expr_stmt|;
if|if
condition|(
operator|!
name|lockparent
condition|)
name|cnp
operator|->
name|cn_flags
operator|&=
operator|~
name|LOCKPARENT
expr_stmt|;
return|return
operator|(
name|uerror
operator|)
return|;
block|}
if|if
condition|(
name|uerror
operator|==
name|ENOENT
operator|||
name|uerror
operator|==
name|EJUSTRETURN
condition|)
block|{
if|if
condition|(
name|cnp
operator|->
name|cn_flags
operator|&
name|ISWHITEOUT
condition|)
block|{
name|iswhiteout
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lowerdvp
operator|!=
name|NULLVP
condition|)
block|{
name|lerror
operator|=
name|VOP_GETATTR
argument_list|(
name|upperdvp
argument_list|,
operator|&
name|va
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|,
name|cnp
operator|->
name|cn_proc
argument_list|)
expr_stmt|;
if|if
condition|(
name|lerror
operator|==
literal|0
operator|&&
operator|(
name|va
operator|.
name|va_flags
operator|&
name|OPAQUE
operator|)
condition|)
name|iswhiteout
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|uerror
operator|=
name|ENOENT
expr_stmt|;
block|}
comment|/* 	 * in a similar way to the upper layer, do the lookup 	 * in the lower layer.   this time, if there is some 	 * component magic going on, then vput whatever we got 	 * back from the upper layer and return the lower vnode 	 * instead. 	 */
if|if
condition|(
name|lowerdvp
operator|!=
name|NULLVP
operator|&&
operator|!
name|iswhiteout
condition|)
block|{
name|int
name|nameiop
decl_stmt|;
name|vn_lock
argument_list|(
name|lowerdvp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* 		 * Only do a LOOKUP on the bottom node, since 		 * we won't be making changes to it anyway. 		 */
name|nameiop
operator|=
name|cnp
operator|->
name|cn_nameiop
expr_stmt|;
name|cnp
operator|->
name|cn_nameiop
operator|=
name|LOOKUP
expr_stmt|;
if|if
condition|(
name|um
operator|->
name|um_op
operator|==
name|UNMNT_BELOW
condition|)
block|{
name|saved_cred
operator|=
name|cnp
operator|->
name|cn_cred
expr_stmt|;
name|cnp
operator|->
name|cn_cred
operator|=
name|um
operator|->
name|um_cred
expr_stmt|;
block|}
comment|/* 		 * We shouldn't have to worry about locking interactions 		 * between the lower layer and our union layer (w.r.t. 		 * `..' processing) because we don't futz with lowervp 		 * locks in the union-node instantiation code path. 		 */
name|lerror
operator|=
name|union_lookup1
argument_list|(
name|um
operator|->
name|um_lowervp
argument_list|,
operator|&
name|lowerdvp
argument_list|,
operator|&
name|lowervp
argument_list|,
name|cnp
argument_list|)
expr_stmt|;
if|if
condition|(
name|um
operator|->
name|um_op
operator|==
name|UNMNT_BELOW
condition|)
name|cnp
operator|->
name|cn_cred
operator|=
name|saved_cred
expr_stmt|;
name|cnp
operator|->
name|cn_nameiop
operator|=
name|nameiop
expr_stmt|;
if|if
condition|(
name|lowervp
operator|!=
name|lowerdvp
condition|)
name|VOP_UNLOCK
argument_list|(
name|lowerdvp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnp
operator|->
name|cn_consume
operator|!=
literal|0
operator|||
name|lerror
operator|==
name|EACCES
condition|)
block|{
if|if
condition|(
name|lerror
operator|==
name|EACCES
condition|)
name|lowervp
operator|=
name|NULLVP
expr_stmt|;
if|if
condition|(
name|uppervp
operator|!=
name|NULLVP
condition|)
block|{
if|if
condition|(
name|uppervp
operator|==
name|upperdvp
condition|)
name|vrele
argument_list|(
name|uppervp
argument_list|)
expr_stmt|;
else|else
name|vput
argument_list|(
name|uppervp
argument_list|)
expr_stmt|;
name|uppervp
operator|=
name|NULLVP
expr_stmt|;
block|}
operator|*
name|ap
operator|->
name|a_vpp
operator|=
name|lowervp
expr_stmt|;
if|if
condition|(
operator|!
name|lockparent
condition|)
name|cnp
operator|->
name|cn_flags
operator|&=
operator|~
name|LOCKPARENT
expr_stmt|;
return|return
operator|(
name|lerror
operator|)
return|;
block|}
block|}
else|else
block|{
name|lerror
operator|=
name|ENOENT
expr_stmt|;
if|if
condition|(
operator|(
name|cnp
operator|->
name|cn_flags
operator|&
name|ISDOTDOT
operator|)
operator|&&
name|dun
operator|->
name|un_pvp
operator|!=
name|NULLVP
condition|)
block|{
name|lowervp
operator|=
name|LOWERVP
argument_list|(
name|dun
operator|->
name|un_pvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|lowervp
operator|!=
name|NULLVP
condition|)
block|{
name|VREF
argument_list|(
name|lowervp
argument_list|)
expr_stmt|;
name|vn_lock
argument_list|(
name|lowervp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|lerror
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|lockparent
condition|)
name|cnp
operator|->
name|cn_flags
operator|&=
operator|~
name|LOCKPARENT
expr_stmt|;
comment|/* 	 * at this point, we have uerror and lerror indicating 	 * possible errors with the lookups in the upper and lower 	 * layers.  additionally, uppervp and lowervp are (locked) 	 * references to existing vnodes in the upper and lower layers. 	 * 	 * there are now three cases to consider. 	 * 1. if both layers returned an error, then return whatever 	 *    error the upper layer generated. 	 * 	 * 2. if the top layer failed and the bottom layer succeeded 	 *    then two subcases occur. 	 *    a.  the bottom vnode is not a directory, in which 	 *	  case just return a new union vnode referencing 	 *	  an empty top layer and the existing bottom layer. 	 *    b.  the bottom vnode is a directory, in which case 	 *	  create a new directory in the top-level and 	 *	  continue as in case 3. 	 * 	 * 3. if the top layer succeeded then return a new union 	 *    vnode referencing whatever the new top layer and 	 *    whatever the bottom layer returned. 	 */
operator|*
name|ap
operator|->
name|a_vpp
operator|=
name|NULLVP
expr_stmt|;
comment|/* case 1. */
if|if
condition|(
operator|(
name|uerror
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|lerror
operator|!=
literal|0
operator|)
condition|)
block|{
return|return
operator|(
name|uerror
operator|)
return|;
block|}
comment|/* case 2. */
if|if
condition|(
name|uerror
operator|!=
literal|0
comment|/*&& (lerror == 0) */
condition|)
block|{
if|if
condition|(
name|lowervp
operator|->
name|v_type
operator|==
name|VDIR
condition|)
block|{
comment|/* case 2b. */
name|dun
operator|->
name|un_flags
operator|&=
operator|~
name|UN_ULOCK
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|upperdvp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|uerror
operator|=
name|union_mkshadow
argument_list|(
name|um
argument_list|,
name|upperdvp
argument_list|,
name|cnp
argument_list|,
operator|&
name|uppervp
argument_list|)
expr_stmt|;
name|vn_lock
argument_list|(
name|upperdvp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|dun
operator|->
name|un_flags
operator||=
name|UN_ULOCK
expr_stmt|;
if|if
condition|(
name|uerror
condition|)
block|{
if|if
condition|(
name|lowervp
operator|!=
name|NULLVP
condition|)
block|{
name|vput
argument_list|(
name|lowervp
argument_list|)
expr_stmt|;
name|lowervp
operator|=
name|NULLVP
expr_stmt|;
block|}
return|return
operator|(
name|uerror
operator|)
return|;
block|}
block|}
block|}
if|if
condition|(
name|lowervp
operator|!=
name|NULLVP
condition|)
name|VOP_UNLOCK
argument_list|(
name|lowervp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|error
operator|=
name|union_allocvp
argument_list|(
name|ap
operator|->
name|a_vpp
argument_list|,
name|dvp
operator|->
name|v_mount
argument_list|,
name|dvp
argument_list|,
name|upperdvp
argument_list|,
name|cnp
argument_list|,
name|uppervp
argument_list|,
name|lowervp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|uppervp
operator|!=
name|NULLVP
condition|)
name|vput
argument_list|(
name|uppervp
argument_list|)
expr_stmt|;
if|if
condition|(
name|lowervp
operator|!=
name|NULLVP
condition|)
name|vrele
argument_list|(
name|lowervp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|ap
operator|->
name|a_vpp
operator|!=
name|dvp
condition|)
if|if
condition|(
operator|!
name|lockparent
operator|||
operator|!
operator|(
name|cnp
operator|->
name|cn_flags
operator|&
name|ISLASTCN
operator|)
condition|)
name|VOP_UNLOCK
argument_list|(
name|dvp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|cnp
operator|->
name|cn_namelen
operator|==
literal|1
operator|&&
name|cnp
operator|->
name|cn_nameptr
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
operator|*
name|ap
operator|->
name|a_vpp
operator|!=
name|dvp
condition|)
block|{
name|panic
argument_list|(
literal|"union_lookup returning . (%p) not same as startdir (%p)"
argument_list|,
name|ap
operator|->
name|a_vpp
argument_list|,
name|dvp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|union_create
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_create_args
comment|/* { 		struct vnode *a_dvp; 		struct vnode **a_vpp; 		struct componentname *a_cnp; 		struct vattr *a_vap; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|union_node
modifier|*
name|un
init|=
name|VTOUNION
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
decl_stmt|;
name|struct
name|vnode
modifier|*
name|dvp
init|=
name|un
operator|->
name|un_uppervp
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|cnp
operator|->
name|cn_proc
decl_stmt|;
if|if
condition|(
name|dvp
operator|!=
name|NULLVP
condition|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|FIXUP
argument_list|(
name|un
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|VREF
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|SETKLOCK
argument_list|(
name|un
argument_list|)
expr_stmt|;
name|mp
operator|=
name|ap
operator|->
name|a_dvp
operator|->
name|v_mount
expr_stmt|;
name|vput
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
expr_stmt|;
name|CLEARKLOCK
argument_list|(
name|un
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_CREATE
argument_list|(
name|dvp
argument_list|,
operator|&
name|vp
argument_list|,
name|cnp
argument_list|,
name|ap
operator|->
name|a_vap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|union_allocvp
argument_list|(
name|ap
operator|->
name|a_vpp
argument_list|,
name|mp
argument_list|,
name|NULLVP
argument_list|,
name|NULLVP
argument_list|,
name|cnp
argument_list|,
name|vp
argument_list|,
name|NULLVP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|vput
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EROFS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|union_whiteout
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_whiteout_args
comment|/* { 		struct vnode *a_dvp; 		struct componentname *a_cnp; 		int a_flags; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|union_node
modifier|*
name|un
init|=
name|VTOUNION
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|cnp
operator|->
name|cn_proc
decl_stmt|;
if|if
condition|(
name|un
operator|->
name|un_uppervp
operator|==
name|NULLVP
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
name|FIXUP
argument_list|(
name|un
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|VOP_WHITEOUT
argument_list|(
name|un
operator|->
name|un_uppervp
argument_list|,
name|cnp
argument_list|,
name|ap
operator|->
name|a_flags
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|union_mknod
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_mknod_args
comment|/* { 		struct vnode *a_dvp; 		struct vnode **a_vpp; 		struct componentname *a_cnp; 		struct vattr *a_vap; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|union_node
modifier|*
name|un
init|=
name|VTOUNION
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
decl_stmt|;
name|struct
name|vnode
modifier|*
name|dvp
init|=
name|un
operator|->
name|un_uppervp
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|cnp
operator|->
name|cn_proc
decl_stmt|;
if|if
condition|(
name|dvp
operator|!=
name|NULLVP
condition|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|FIXUP
argument_list|(
name|un
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|VREF
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|SETKLOCK
argument_list|(
name|un
argument_list|)
expr_stmt|;
name|mp
operator|=
name|ap
operator|->
name|a_dvp
operator|->
name|v_mount
expr_stmt|;
name|vput
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
expr_stmt|;
name|CLEARKLOCK
argument_list|(
name|un
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_MKNOD
argument_list|(
name|dvp
argument_list|,
operator|&
name|vp
argument_list|,
name|cnp
argument_list|,
name|ap
operator|->
name|a_vap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|vp
operator|!=
name|NULLVP
condition|)
block|{
name|error
operator|=
name|union_allocvp
argument_list|(
name|ap
operator|->
name|a_vpp
argument_list|,
name|mp
argument_list|,
name|NULLVP
argument_list|,
name|NULLVP
argument_list|,
name|cnp
argument_list|,
name|vp
argument_list|,
name|NULLVP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
name|vput
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EROFS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|union_open
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_open_args
comment|/* { 		struct vnodeop_desc *a_desc; 		struct vnode *a_vp; 		int a_mode; 		struct ucred *a_cred; 		struct proc *a_p; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|union_node
modifier|*
name|un
init|=
name|VTOUNION
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|struct
name|vnode
modifier|*
name|tvp
decl_stmt|;
name|int
name|mode
init|=
name|ap
operator|->
name|a_mode
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|ap
operator|->
name|a_cred
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|ap
operator|->
name|a_p
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * If there is an existing upper vp then simply open that. 	 */
name|tvp
operator|=
name|un
operator|->
name|un_uppervp
expr_stmt|;
if|if
condition|(
name|tvp
operator|==
name|NULLVP
condition|)
block|{
comment|/* 		 * If the lower vnode is being opened for writing, then 		 * copy the file contents to the upper vnode and open that, 		 * otherwise can simply open the lower vnode. 		 */
name|tvp
operator|=
name|un
operator|->
name|un_lowervp
expr_stmt|;
if|if
condition|(
operator|(
name|ap
operator|->
name|a_mode
operator|&
name|FWRITE
operator|)
operator|&&
operator|(
name|tvp
operator|->
name|v_type
operator|==
name|VREG
operator|)
condition|)
block|{
name|error
operator|=
name|union_copyup
argument_list|(
name|un
argument_list|,
operator|(
name|mode
operator|&
name|O_TRUNC
operator|)
operator|==
literal|0
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|VOP_OPEN
argument_list|(
name|un
operator|->
name|un_uppervp
argument_list|,
name|mode
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 		 * Just open the lower vnode 		 */
name|un
operator|->
name|un_openl
operator|++
expr_stmt|;
name|vn_lock
argument_list|(
name|tvp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_OPEN
argument_list|(
name|tvp
argument_list|,
name|mode
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|tvp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|FIXUP
argument_list|(
name|un
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_OPEN
argument_list|(
name|tvp
argument_list|,
name|mode
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|union_close
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_close_args
comment|/* { 		struct vnode *a_vp; 		int  a_fflag; 		struct ucred *a_cred; 		struct proc *a_p; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|union_node
modifier|*
name|un
init|=
name|VTOUNION
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
if|if
condition|(
operator|(
name|vp
operator|=
name|un
operator|->
name|un_uppervp
operator|)
operator|==
name|NULLVP
condition|)
block|{
ifdef|#
directive|ifdef
name|UNION_DIAGNOSTIC
if|if
condition|(
name|un
operator|->
name|un_openl
operator|<=
literal|0
condition|)
name|panic
argument_list|(
literal|"union: un_openl cnt"
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|--
name|un
operator|->
name|un_openl
expr_stmt|;
name|vp
operator|=
name|un
operator|->
name|un_lowervp
expr_stmt|;
block|}
name|ap
operator|->
name|a_vp
operator|=
name|vp
expr_stmt|;
return|return
operator|(
name|VCALL
argument_list|(
name|vp
argument_list|,
name|VOFFSET
argument_list|(
name|vop_close
argument_list|)
argument_list|,
name|ap
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check access permission on the union vnode.  * The access check being enforced is to check  * against both the underlying vnode, and any  * copied vnode.  This ensures that no additional  * file permissions are given away simply because  * the user caused an implicit file copy.  */
end_comment

begin_function
specifier|static
name|int
name|union_access
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_access_args
comment|/* { 		struct vnodeop_desc *a_desc; 		struct vnode *a_vp; 		int a_mode; 		struct ucred *a_cred; 		struct proc *a_p; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|union_node
modifier|*
name|un
init|=
name|VTOUNION
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|ap
operator|->
name|a_p
decl_stmt|;
name|int
name|error
init|=
name|EACCES
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|savedvp
decl_stmt|;
comment|/* 	 * Disallow write attempts on filesystems mounted read-only. 	 */
if|if
condition|(
name|ap
operator|->
name|a_mode
operator|&
name|VWRITE
operator|&&
operator|(
name|ap
operator|->
name|a_vp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
operator|)
condition|)
block|{
switch|switch
condition|(
name|ap
operator|->
name|a_vp
operator|->
name|v_type
condition|)
block|{
case|case
name|VREG
case|:
case|case
name|VDIR
case|:
case|case
name|VLNK
case|:
return|return
operator|(
name|EROFS
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|(
name|vp
operator|=
name|un
operator|->
name|un_uppervp
operator|)
operator|!=
name|NULLVP
condition|)
block|{
name|FIXUP
argument_list|(
name|un
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|ap
operator|->
name|a_vp
operator|=
name|vp
expr_stmt|;
return|return
operator|(
name|VCALL
argument_list|(
name|vp
argument_list|,
name|VOFFSET
argument_list|(
name|vop_access
argument_list|)
argument_list|,
name|ap
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|vp
operator|=
name|un
operator|->
name|un_lowervp
operator|)
operator|!=
name|NULLVP
condition|)
block|{
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|savedvp
operator|=
name|ap
operator|->
name|a_vp
expr_stmt|;
name|ap
operator|->
name|a_vp
operator|=
name|vp
expr_stmt|;
name|error
operator|=
name|VCALL
argument_list|(
name|vp
argument_list|,
name|VOFFSET
argument_list|(
name|vop_access
argument_list|)
argument_list|,
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|struct
name|union_mount
modifier|*
name|um
init|=
name|MOUNTTOUNIONMOUNT
argument_list|(
name|savedvp
operator|->
name|v_mount
argument_list|)
decl_stmt|;
if|if
condition|(
name|um
operator|->
name|um_op
operator|==
name|UNMNT_BELOW
condition|)
block|{
name|ap
operator|->
name|a_cred
operator|=
name|um
operator|->
name|um_cred
expr_stmt|;
name|error
operator|=
name|VCALL
argument_list|(
name|vp
argument_list|,
name|VOFFSET
argument_list|(
name|vop_access
argument_list|)
argument_list|,
name|ap
argument_list|)
expr_stmt|;
block|}
block|}
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * We handle getattr only to change the fsid and  * track object sizes  */
end_comment

begin_function
specifier|static
name|int
name|union_getattr
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_getattr_args
comment|/* { 		struct vnode *a_vp; 		struct vattr *a_vap; 		struct ucred *a_cred; 		struct proc *a_p; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|struct
name|union_node
modifier|*
name|un
init|=
name|VTOUNION
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
init|=
name|un
operator|->
name|un_uppervp
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|ap
operator|->
name|a_p
decl_stmt|;
name|struct
name|vattr
modifier|*
name|vap
decl_stmt|;
name|struct
name|vattr
name|va
decl_stmt|;
comment|/* 	 * Some programs walk the filesystem hierarchy by counting 	 * links to directories to avoid stat'ing all the time. 	 * This means the link count on directories needs to be "correct". 	 * The only way to do that is to call getattr on both layers 	 * and fix up the link count.  The link count will not necessarily 	 * be accurate but will be large enough to defeat the tree walkers. 	 */
name|vap
operator|=
name|ap
operator|->
name|a_vap
expr_stmt|;
name|vp
operator|=
name|un
operator|->
name|un_uppervp
expr_stmt|;
if|if
condition|(
name|vp
operator|!=
name|NULLVP
condition|)
block|{
comment|/* 		 * It's not clear whether VOP_GETATTR is to be 		 * called with the vnode locked or not.  stat() calls 		 * it with (vp) locked, and fstat calls it with 		 * (vp) unlocked. 		 * In the mean time, compensate here by checking 		 * the union_node's lock flag. 		 */
if|if
condition|(
name|un
operator|->
name|un_flags
operator|&
name|UN_LOCKED
condition|)
name|FIXUP
argument_list|(
name|un
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|vp
argument_list|,
name|vap
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|union_newsize
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|vap
operator|->
name|va_size
argument_list|,
name|VNOVAL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vp
operator|==
name|NULLVP
condition|)
block|{
name|vp
operator|=
name|un
operator|->
name|un_lowervp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VDIR
condition|)
block|{
name|vp
operator|=
name|un
operator|->
name|un_lowervp
expr_stmt|;
name|vap
operator|=
operator|&
name|va
expr_stmt|;
block|}
else|else
block|{
name|vp
operator|=
name|NULLVP
expr_stmt|;
block|}
if|if
condition|(
name|vp
operator|!=
name|NULLVP
condition|)
block|{
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|vp
argument_list|,
name|vap
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|union_newsize
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|VNOVAL
argument_list|,
name|vap
operator|->
name|va_size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|vap
operator|!=
name|ap
operator|->
name|a_vap
operator|)
operator|&&
operator|(
name|vap
operator|->
name|va_type
operator|==
name|VDIR
operator|)
condition|)
name|ap
operator|->
name|a_vap
operator|->
name|va_nlink
operator|+=
name|vap
operator|->
name|va_nlink
expr_stmt|;
name|ap
operator|->
name|a_vap
operator|->
name|va_fsid
operator|=
name|ap
operator|->
name|a_vp
operator|->
name|v_mount
operator|->
name|mnt_stat
operator|.
name|f_fsid
operator|.
name|val
index|[
literal|0
index|]
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|union_setattr
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_setattr_args
comment|/* { 		struct vnode *a_vp; 		struct vattr *a_vap; 		struct ucred *a_cred; 		struct proc *a_p; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|union_node
modifier|*
name|un
init|=
name|VTOUNION
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|ap
operator|->
name|a_p
decl_stmt|;
name|struct
name|vattr
modifier|*
name|vap
init|=
name|ap
operator|->
name|a_vap
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * Disallow write attempts on filesystems mounted read-only. 	 */
if|if
condition|(
operator|(
name|ap
operator|->
name|a_vp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
operator|)
operator|&&
operator|(
name|vap
operator|->
name|va_flags
operator|!=
name|VNOVAL
operator|||
name|vap
operator|->
name|va_uid
operator|!=
operator|(
name|uid_t
operator|)
name|VNOVAL
operator|||
name|vap
operator|->
name|va_gid
operator|!=
operator|(
name|gid_t
operator|)
name|VNOVAL
operator|||
name|vap
operator|->
name|va_atime
operator|.
name|tv_sec
operator|!=
name|VNOVAL
operator|||
name|vap
operator|->
name|va_mtime
operator|.
name|tv_sec
operator|!=
name|VNOVAL
operator|||
name|vap
operator|->
name|va_mode
operator|!=
operator|(
name|mode_t
operator|)
name|VNOVAL
operator|)
condition|)
return|return
operator|(
name|EROFS
operator|)
return|;
comment|/* 	 * Handle case of truncating lower object to zero size, 	 * by creating a zero length upper object.  This is to 	 * handle the case of open with O_TRUNC and O_CREAT. 	 */
if|if
condition|(
operator|(
name|un
operator|->
name|un_uppervp
operator|==
name|NULLVP
operator|)
operator|&&
comment|/* assert(un->un_lowervp != NULLVP) */
operator|(
name|un
operator|->
name|un_lowervp
operator|->
name|v_type
operator|==
name|VREG
operator|)
condition|)
block|{
name|error
operator|=
name|union_copyup
argument_list|(
name|un
argument_list|,
operator|(
name|ap
operator|->
name|a_vap
operator|->
name|va_size
operator|!=
literal|0
operator|)
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Try to set attributes in upper layer, 	 * otherwise return read-only filesystem error. 	 */
if|if
condition|(
name|un
operator|->
name|un_uppervp
operator|!=
name|NULLVP
condition|)
block|{
name|FIXUP
argument_list|(
name|un
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_SETATTR
argument_list|(
name|un
operator|->
name|un_uppervp
argument_list|,
name|ap
operator|->
name|a_vap
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|==
literal|0
operator|)
operator|&&
operator|(
name|ap
operator|->
name|a_vap
operator|->
name|va_size
operator|!=
name|VNOVAL
operator|)
condition|)
name|union_newsize
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|ap
operator|->
name|a_vap
operator|->
name|va_size
argument_list|,
name|VNOVAL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|EROFS
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|union_read
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_read_args
comment|/* { 		struct vnode *a_vp; 		struct uio *a_uio; 		int  a_ioflag; 		struct ucred *a_cred; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|ap
operator|->
name|a_uio
operator|->
name|uio_procp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
init|=
name|OTHERVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|int
name|dolock
init|=
operator|(
name|vp
operator|==
name|LOWERVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|dolock
condition|)
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|p
argument_list|)
expr_stmt|;
else|else
name|FIXUP
argument_list|(
name|VTOUNION
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_READ
argument_list|(
name|vp
argument_list|,
name|ap
operator|->
name|a_uio
argument_list|,
name|ap
operator|->
name|a_ioflag
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|dolock
condition|)
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* 	 * XXX 	 * perhaps the size of the underlying object has changed under 	 * our feet.  take advantage of the offset information present 	 * in the uio structure. 	 */
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|struct
name|union_node
modifier|*
name|un
init|=
name|VTOUNION
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|off_t
name|cur
init|=
name|ap
operator|->
name|a_uio
operator|->
name|uio_offset
decl_stmt|;
if|if
condition|(
name|vp
operator|==
name|un
operator|->
name|un_uppervp
condition|)
block|{
if|if
condition|(
name|cur
operator|>
name|un
operator|->
name|un_uppersz
condition|)
name|union_newsize
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|cur
argument_list|,
name|VNOVAL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cur
operator|>
name|un
operator|->
name|un_lowersz
condition|)
name|union_newsize
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|VNOVAL
argument_list|,
name|cur
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|union_write
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_read_args
comment|/* { 		struct vnode *a_vp; 		struct uio *a_uio; 		int  a_ioflag; 		struct ucred *a_cred; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|union_node
modifier|*
name|un
init|=
name|VTOUNION
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|ap
operator|->
name|a_uio
operator|->
name|uio_procp
decl_stmt|;
name|vp
operator|=
name|UPPERVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|==
name|NULLVP
condition|)
name|panic
argument_list|(
literal|"union: missing upper layer in write"
argument_list|)
expr_stmt|;
name|FIXUP
argument_list|(
name|un
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_WRITE
argument_list|(
name|vp
argument_list|,
name|ap
operator|->
name|a_uio
argument_list|,
name|ap
operator|->
name|a_ioflag
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|)
expr_stmt|;
comment|/* 	 * the size of the underlying object may be changed by the 	 * write. 	 */
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|off_t
name|cur
init|=
name|ap
operator|->
name|a_uio
operator|->
name|uio_offset
decl_stmt|;
if|if
condition|(
name|cur
operator|>
name|un
operator|->
name|un_uppersz
condition|)
name|union_newsize
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|cur
argument_list|,
name|VNOVAL
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|union_lease
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_lease_args
comment|/* { 		struct vnode *a_vp; 		struct proc *a_p; 		struct ucred *a_cred; 		int a_flag; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
specifier|register
name|struct
name|vnode
modifier|*
name|ovp
init|=
name|OTHERVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|ap
operator|->
name|a_vp
operator|=
name|ovp
expr_stmt|;
return|return
operator|(
name|VCALL
argument_list|(
name|ovp
argument_list|,
name|VOFFSET
argument_list|(
name|vop_lease
argument_list|)
argument_list|,
name|ap
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|union_ioctl
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_ioctl_args
comment|/* { 		struct vnode *a_vp; 		int  a_command; 		caddr_t  a_data; 		int  a_fflag; 		struct ucred *a_cred; 		struct proc *a_p; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
specifier|register
name|struct
name|vnode
modifier|*
name|ovp
init|=
name|OTHERVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|ap
operator|->
name|a_vp
operator|=
name|ovp
expr_stmt|;
return|return
operator|(
name|VCALL
argument_list|(
name|ovp
argument_list|,
name|VOFFSET
argument_list|(
name|vop_ioctl
argument_list|)
argument_list|,
name|ap
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|union_poll
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_poll_args
comment|/* { 		struct vnode *a_vp; 		int  a_events; 		struct ucred *a_cred; 		struct proc *a_p; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
specifier|register
name|struct
name|vnode
modifier|*
name|ovp
init|=
name|OTHERVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|ap
operator|->
name|a_vp
operator|=
name|ovp
expr_stmt|;
return|return
operator|(
name|VCALL
argument_list|(
name|ovp
argument_list|,
name|VOFFSET
argument_list|(
name|vop_poll
argument_list|)
argument_list|,
name|ap
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|union_revoke
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_revoke_args
comment|/* { 		struct vnode *a_vp; 		int a_flags; 		struct proc *a_p; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
if|if
condition|(
name|UPPERVP
argument_list|(
name|vp
argument_list|)
condition|)
name|VOP_REVOKE
argument_list|(
name|UPPERVP
argument_list|(
name|vp
argument_list|)
argument_list|,
name|ap
operator|->
name|a_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOWERVP
argument_list|(
name|vp
argument_list|)
condition|)
name|VOP_REVOKE
argument_list|(
name|LOWERVP
argument_list|(
name|vp
argument_list|)
argument_list|,
name|ap
operator|->
name|a_flags
argument_list|)
expr_stmt|;
name|vgone
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|union_mmap
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_mmap_args
comment|/* { 		struct vnode *a_vp; 		int  a_fflags; 		struct ucred *a_cred; 		struct proc *a_p; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
specifier|register
name|struct
name|vnode
modifier|*
name|ovp
init|=
name|OTHERVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|ap
operator|->
name|a_vp
operator|=
name|ovp
expr_stmt|;
return|return
operator|(
name|VCALL
argument_list|(
name|ovp
argument_list|,
name|VOFFSET
argument_list|(
name|vop_mmap
argument_list|)
argument_list|,
name|ap
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|union_fsync
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_fsync_args
comment|/* { 		struct vnode *a_vp; 		struct ucred *a_cred; 		int  a_waitfor; 		struct proc *a_p; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|ap
operator|->
name|a_p
decl_stmt|;
name|struct
name|vnode
modifier|*
name|targetvp
init|=
name|OTHERVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|struct
name|union_node
modifier|*
name|un
decl_stmt|;
name|int
name|isupperlocked
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|targetvp
operator|!=
name|NULLVP
condition|)
block|{
name|int
name|dolock
init|=
operator|(
name|targetvp
operator|==
name|LOWERVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
operator|)
decl_stmt|;
name|un
operator|=
name|VTOUNION
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dolock
condition|)
name|vn_lock
argument_list|(
name|targetvp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|p
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|un
operator|->
name|un_flags
operator|&
name|UN_ULOCK
operator|)
operator|==
literal|0
operator|&&
name|VOP_ISLOCKED
argument_list|(
name|targetvp
argument_list|)
operator|==
literal|0
condition|)
block|{
name|isupperlocked
operator|=
literal|1
expr_stmt|;
name|vn_lock
argument_list|(
name|targetvp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|un
operator|->
name|un_flags
operator||=
name|UN_ULOCK
expr_stmt|;
block|}
name|error
operator|=
name|VOP_FSYNC
argument_list|(
name|targetvp
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_waitfor
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|dolock
condition|)
name|VOP_UNLOCK
argument_list|(
name|targetvp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|isupperlocked
condition|)
block|{
name|un
operator|->
name|un_flags
operator|&=
operator|~
name|UN_ULOCK
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|targetvp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|union_seek
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_seek_args
comment|/* { 		struct vnode *a_vp; 		off_t  a_oldoff; 		off_t  a_newoff; 		struct ucred *a_cred; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
specifier|register
name|struct
name|vnode
modifier|*
name|ovp
init|=
name|OTHERVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|ap
operator|->
name|a_vp
operator|=
name|ovp
expr_stmt|;
return|return
operator|(
name|VCALL
argument_list|(
name|ovp
argument_list|,
name|VOFFSET
argument_list|(
name|vop_seek
argument_list|)
argument_list|,
name|ap
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|union_remove
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_remove_args
comment|/* { 		struct vnode *a_dvp; 		struct vnode *a_vp; 		struct componentname *a_cnp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|struct
name|union_node
modifier|*
name|dun
init|=
name|VTOUNION
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
decl_stmt|;
name|struct
name|union_node
modifier|*
name|un
init|=
name|VTOUNION
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|cnp
operator|->
name|cn_proc
decl_stmt|;
if|if
condition|(
name|dun
operator|->
name|un_uppervp
operator|==
name|NULLVP
condition|)
name|panic
argument_list|(
literal|"union remove: null upper vnode"
argument_list|)
expr_stmt|;
if|if
condition|(
name|un
operator|->
name|un_uppervp
operator|!=
name|NULLVP
condition|)
block|{
name|struct
name|vnode
modifier|*
name|dvp
init|=
name|dun
operator|->
name|un_uppervp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
init|=
name|un
operator|->
name|un_uppervp
decl_stmt|;
name|FIXUP
argument_list|(
name|dun
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|VREF
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|SETKLOCK
argument_list|(
name|dun
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
expr_stmt|;
name|CLEARKLOCK
argument_list|(
name|dun
argument_list|)
expr_stmt|;
name|FIXUP
argument_list|(
name|un
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|VREF
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|SETKLOCK
argument_list|(
name|un
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
name|CLEARKLOCK
argument_list|(
name|un
argument_list|)
expr_stmt|;
if|if
condition|(
name|union_dowhiteout
argument_list|(
name|un
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|,
name|cnp
operator|->
name|cn_proc
argument_list|)
condition|)
name|cnp
operator|->
name|cn_flags
operator||=
name|DOWHITEOUT
expr_stmt|;
name|error
operator|=
name|VOP_REMOVE
argument_list|(
name|dvp
argument_list|,
name|vp
argument_list|,
name|cnp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|union_removed_upper
argument_list|(
name|un
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|FIXUP
argument_list|(
name|dun
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|error
operator|=
name|union_mkwhiteout
argument_list|(
name|MOUNTTOUNIONMOUNT
argument_list|(
name|UNIONTOV
argument_list|(
name|dun
argument_list|)
operator|->
name|v_mount
argument_list|)
argument_list|,
name|dun
operator|->
name|un_uppervp
argument_list|,
name|ap
operator|->
name|a_cnp
argument_list|,
name|un
operator|->
name|un_path
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|union_link
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_link_args
comment|/* { 		struct vnode *a_tdvp; 		struct vnode *a_vp; 		struct componentname *a_cnp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|cnp
operator|->
name|cn_proc
decl_stmt|;
name|struct
name|union_node
modifier|*
name|un
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|tdvp
decl_stmt|;
name|un
operator|=
name|VTOUNION
argument_list|(
name|ap
operator|->
name|a_tdvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|a_tdvp
operator|->
name|v_op
operator|!=
name|ap
operator|->
name|a_vp
operator|->
name|v_op
condition|)
block|{
name|vp
operator|=
name|ap
operator|->
name|a_vp
expr_stmt|;
block|}
else|else
block|{
name|struct
name|union_node
modifier|*
name|tun
init|=
name|VTOUNION
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
if|if
condition|(
name|tun
operator|->
name|un_uppervp
operator|==
name|NULLVP
condition|)
block|{
name|vn_lock
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|un
operator|->
name|un_uppervp
operator|==
name|tun
operator|->
name|un_dirvp
condition|)
block|{
name|un
operator|->
name|un_flags
operator|&=
operator|~
name|UN_ULOCK
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|un
operator|->
name|un_uppervp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|union_copyup
argument_list|(
name|tun
argument_list|,
literal|1
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|un
operator|->
name|un_uppervp
operator|==
name|tun
operator|->
name|un_dirvp
condition|)
block|{
name|vn_lock
argument_list|(
name|un
operator|->
name|un_uppervp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|un
operator|->
name|un_flags
operator||=
name|UN_ULOCK
expr_stmt|;
block|}
name|VOP_UNLOCK
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
name|vp
operator|=
name|tun
operator|->
name|un_uppervp
expr_stmt|;
block|}
name|tdvp
operator|=
name|un
operator|->
name|un_uppervp
expr_stmt|;
if|if
condition|(
name|tdvp
operator|==
name|NULLVP
condition|)
name|error
operator|=
name|EROFS
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|vput
argument_list|(
name|ap
operator|->
name|a_tdvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|FIXUP
argument_list|(
name|un
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|VREF
argument_list|(
name|tdvp
argument_list|)
expr_stmt|;
name|SETKLOCK
argument_list|(
name|un
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|ap
operator|->
name|a_tdvp
argument_list|)
expr_stmt|;
name|CLEARKLOCK
argument_list|(
name|un
argument_list|)
expr_stmt|;
return|return
operator|(
name|VOP_LINK
argument_list|(
name|tdvp
argument_list|,
name|vp
argument_list|,
name|cnp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|union_rename
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_rename_args
comment|/* { 		struct vnode *a_fdvp; 		struct vnode *a_fvp; 		struct componentname *a_fcnp; 		struct vnode *a_tdvp; 		struct vnode *a_tvp; 		struct componentname *a_tcnp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|struct
name|vnode
modifier|*
name|fdvp
init|=
name|ap
operator|->
name|a_fdvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|fvp
init|=
name|ap
operator|->
name|a_fvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|tdvp
init|=
name|ap
operator|->
name|a_tdvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|tvp
init|=
name|ap
operator|->
name|a_tvp
decl_stmt|;
name|int
name|isklockset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|fdvp
operator|->
name|v_op
operator|==
name|union_vnodeop_p
condition|)
block|{
comment|/* always true */
name|struct
name|union_node
modifier|*
name|un
init|=
name|VTOUNION
argument_list|(
name|fdvp
argument_list|)
decl_stmt|;
if|if
condition|(
name|un
operator|->
name|un_uppervp
operator|==
name|NULLVP
condition|)
block|{
comment|/* 			 * this should never happen in normal 			 * operation but might if there was 			 * a problem creating the top-level shadow 			 * directory. 			 */
name|error
operator|=
name|EXDEV
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|fdvp
operator|=
name|un
operator|->
name|un_uppervp
expr_stmt|;
name|VREF
argument_list|(
name|fdvp
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|ap
operator|->
name|a_fdvp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fvp
operator|->
name|v_op
operator|==
name|union_vnodeop_p
condition|)
block|{
comment|/* always true */
name|struct
name|union_node
modifier|*
name|un
init|=
name|VTOUNION
argument_list|(
name|fvp
argument_list|)
decl_stmt|;
if|if
condition|(
name|un
operator|->
name|un_uppervp
operator|==
name|NULLVP
condition|)
block|{
comment|/* XXX: should do a copyup */
name|error
operator|=
name|EXDEV
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|un
operator|->
name|un_lowervp
operator|!=
name|NULLVP
condition|)
name|ap
operator|->
name|a_fcnp
operator|->
name|cn_flags
operator||=
name|DOWHITEOUT
expr_stmt|;
name|fvp
operator|=
name|un
operator|->
name|un_uppervp
expr_stmt|;
name|VREF
argument_list|(
name|fvp
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|ap
operator|->
name|a_fvp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tdvp
operator|->
name|v_op
operator|==
name|union_vnodeop_p
condition|)
block|{
name|struct
name|union_node
modifier|*
name|un
init|=
name|VTOUNION
argument_list|(
name|tdvp
argument_list|)
decl_stmt|;
if|if
condition|(
name|un
operator|->
name|un_uppervp
operator|==
name|NULLVP
condition|)
block|{
comment|/* 			 * this should never happen in normal 			 * operation but might if there was 			 * a problem creating the top-level shadow 			 * directory. 			 */
name|error
operator|=
name|EXDEV
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|tdvp
operator|=
name|un
operator|->
name|un_uppervp
expr_stmt|;
name|VREF
argument_list|(
name|tdvp
argument_list|)
expr_stmt|;
name|SETKLOCK
argument_list|(
name|un
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|ap
operator|->
name|a_tdvp
argument_list|)
expr_stmt|;
name|CLEARKLOCK
argument_list|(
name|un
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tvp
operator|!=
name|NULLVP
operator|&&
name|tvp
operator|->
name|v_op
operator|==
name|union_vnodeop_p
condition|)
block|{
name|struct
name|union_node
modifier|*
name|un
init|=
name|VTOUNION
argument_list|(
name|tvp
argument_list|)
decl_stmt|;
name|tvp
operator|=
name|un
operator|->
name|un_uppervp
expr_stmt|;
if|if
condition|(
name|tvp
operator|!=
name|NULLVP
condition|)
block|{
name|VREF
argument_list|(
name|tvp
argument_list|)
expr_stmt|;
name|SETKLOCK
argument_list|(
name|un
argument_list|)
expr_stmt|;
name|isklockset
operator|=
literal|1
expr_stmt|;
block|}
name|vput
argument_list|(
name|ap
operator|->
name|a_tvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|isklockset
condition|)
name|CLEARKLOCK
argument_list|(
name|un
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|VOP_RENAME
argument_list|(
name|fdvp
argument_list|,
name|fvp
argument_list|,
name|ap
operator|->
name|a_fcnp
argument_list|,
name|tdvp
argument_list|,
name|tvp
argument_list|,
name|ap
operator|->
name|a_tcnp
argument_list|)
operator|)
return|;
name|bad
label|:
name|vrele
argument_list|(
name|fdvp
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|fvp
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|tdvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tvp
operator|!=
name|NULLVP
condition|)
name|vput
argument_list|(
name|tvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|union_mkdir
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_mkdir_args
comment|/* { 		struct vnode *a_dvp; 		struct vnode **a_vpp; 		struct componentname *a_cnp; 		struct vattr *a_vap; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|union_node
modifier|*
name|un
init|=
name|VTOUNION
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
decl_stmt|;
name|struct
name|vnode
modifier|*
name|dvp
init|=
name|un
operator|->
name|un_uppervp
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|cnp
operator|->
name|cn_proc
decl_stmt|;
if|if
condition|(
name|dvp
operator|!=
name|NULLVP
condition|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|FIXUP
argument_list|(
name|un
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|VREF
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|SETKLOCK
argument_list|(
name|un
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|CLEARKLOCK
argument_list|(
name|un
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_MKDIR
argument_list|(
name|dvp
argument_list|,
operator|&
name|vp
argument_list|,
name|cnp
argument_list|,
name|ap
operator|->
name|a_vap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|vrele
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|union_allocvp
argument_list|(
name|ap
operator|->
name|a_vpp
argument_list|,
name|ap
operator|->
name|a_dvp
operator|->
name|v_mount
argument_list|,
name|ap
operator|->
name|a_dvp
argument_list|,
name|NULLVP
argument_list|,
name|cnp
argument_list|,
name|vp
argument_list|,
name|NULLVP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|vput
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EROFS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|union_rmdir
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_rmdir_args
comment|/* { 		struct vnode *a_dvp; 		struct vnode *a_vp; 		struct componentname *a_cnp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|struct
name|union_node
modifier|*
name|dun
init|=
name|VTOUNION
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
decl_stmt|;
name|struct
name|union_node
modifier|*
name|un
init|=
name|VTOUNION
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|cnp
operator|->
name|cn_proc
decl_stmt|;
if|if
condition|(
name|dun
operator|->
name|un_uppervp
operator|==
name|NULLVP
condition|)
name|panic
argument_list|(
literal|"union rmdir: null upper vnode"
argument_list|)
expr_stmt|;
if|if
condition|(
name|un
operator|->
name|un_uppervp
operator|!=
name|NULLVP
condition|)
block|{
name|struct
name|vnode
modifier|*
name|dvp
init|=
name|dun
operator|->
name|un_uppervp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
init|=
name|un
operator|->
name|un_uppervp
decl_stmt|;
name|FIXUP
argument_list|(
name|dun
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|VREF
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|SETKLOCK
argument_list|(
name|dun
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
expr_stmt|;
name|CLEARKLOCK
argument_list|(
name|dun
argument_list|)
expr_stmt|;
name|FIXUP
argument_list|(
name|un
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|VREF
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|SETKLOCK
argument_list|(
name|un
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
name|CLEARKLOCK
argument_list|(
name|un
argument_list|)
expr_stmt|;
if|if
condition|(
name|union_dowhiteout
argument_list|(
name|un
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|,
name|cnp
operator|->
name|cn_proc
argument_list|)
condition|)
name|cnp
operator|->
name|cn_flags
operator||=
name|DOWHITEOUT
expr_stmt|;
name|error
operator|=
name|VOP_RMDIR
argument_list|(
name|dvp
argument_list|,
name|vp
argument_list|,
name|ap
operator|->
name|a_cnp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|union_removed_upper
argument_list|(
name|un
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|FIXUP
argument_list|(
name|dun
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|error
operator|=
name|union_mkwhiteout
argument_list|(
name|MOUNTTOUNIONMOUNT
argument_list|(
name|UNIONTOV
argument_list|(
name|dun
argument_list|)
operator|->
name|v_mount
argument_list|)
argument_list|,
name|dun
operator|->
name|un_uppervp
argument_list|,
name|ap
operator|->
name|a_cnp
argument_list|,
name|un
operator|->
name|un_path
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|union_symlink
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_symlink_args
comment|/* { 		struct vnode *a_dvp; 		struct vnode **a_vpp; 		struct componentname *a_cnp; 		struct vattr *a_vap; 		char *a_target; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|union_node
modifier|*
name|un
init|=
name|VTOUNION
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
decl_stmt|;
name|struct
name|vnode
modifier|*
name|dvp
init|=
name|un
operator|->
name|un_uppervp
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|cnp
operator|->
name|cn_proc
decl_stmt|;
if|if
condition|(
name|dvp
operator|!=
name|NULLVP
condition|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|FIXUP
argument_list|(
name|un
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|VREF
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|SETKLOCK
argument_list|(
name|un
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
expr_stmt|;
name|CLEARKLOCK
argument_list|(
name|un
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_SYMLINK
argument_list|(
name|dvp
argument_list|,
operator|&
name|vp
argument_list|,
name|cnp
argument_list|,
name|ap
operator|->
name|a_vap
argument_list|,
name|ap
operator|->
name|a_target
argument_list|)
expr_stmt|;
operator|*
name|ap
operator|->
name|a_vpp
operator|=
name|NULLVP
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|vput
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EROFS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * union_readdir works in concert with getdirentries and  * readdir(3) to provide a list of entries in the unioned  * directories.  getdirentries is responsible for walking  * down the union stack.  readdir(3) is responsible for  * eliminating duplicate names from the returned data stream.  */
end_comment

begin_function
specifier|static
name|int
name|union_readdir
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_readdir_args
comment|/* { 		struct vnode *a_vp; 		struct uio *a_uio; 		struct ucred *a_cred; 		int *a_eofflag; 		u_long *a_cookies; 		int a_ncookies; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|union_node
modifier|*
name|un
init|=
name|VTOUNION
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|struct
name|vnode
modifier|*
name|uvp
init|=
name|un
operator|->
name|un_uppervp
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|ap
operator|->
name|a_uio
operator|->
name|uio_procp
decl_stmt|;
if|if
condition|(
name|uvp
operator|==
name|NULLVP
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|FIXUP
argument_list|(
name|un
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|ap
operator|->
name|a_vp
operator|=
name|uvp
expr_stmt|;
return|return
operator|(
name|VCALL
argument_list|(
name|uvp
argument_list|,
name|VOFFSET
argument_list|(
name|vop_readdir
argument_list|)
argument_list|,
name|ap
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|union_readlink
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_readlink_args
comment|/* { 		struct vnode *a_vp; 		struct uio *a_uio; 		struct ucred *a_cred; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
init|=
name|ap
operator|->
name|a_uio
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|uio
operator|->
name|uio_procp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
init|=
name|OTHERVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|int
name|dolock
init|=
operator|(
name|vp
operator|==
name|LOWERVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|dolock
condition|)
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|p
argument_list|)
expr_stmt|;
else|else
name|FIXUP
argument_list|(
name|VTOUNION
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|ap
operator|->
name|a_vp
operator|=
name|vp
expr_stmt|;
name|error
operator|=
name|VCALL
argument_list|(
name|vp
argument_list|,
name|VOFFSET
argument_list|(
name|vop_readlink
argument_list|)
argument_list|,
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|dolock
condition|)
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|union_abortop
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_abortop_args
comment|/* { 		struct vnode *a_dvp; 		struct componentname *a_cnp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|cnp
operator|->
name|cn_proc
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
init|=
name|OTHERVP
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
decl_stmt|;
name|struct
name|union_node
modifier|*
name|un
init|=
name|VTOUNION
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
decl_stmt|;
name|int
name|islocked
init|=
name|un
operator|->
name|un_flags
operator|&
name|UN_LOCKED
decl_stmt|;
name|int
name|dolock
init|=
operator|(
name|vp
operator|==
name|LOWERVP
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|islocked
condition|)
block|{
if|if
condition|(
name|dolock
condition|)
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|p
argument_list|)
expr_stmt|;
else|else
name|FIXUP
argument_list|(
name|VTOUNION
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
name|ap
operator|->
name|a_dvp
operator|=
name|vp
expr_stmt|;
name|error
operator|=
name|VCALL
argument_list|(
name|vp
argument_list|,
name|VOFFSET
argument_list|(
name|vop_abortop
argument_list|)
argument_list|,
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|islocked
operator|&&
name|dolock
condition|)
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|union_inactive
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_inactive_args
comment|/* { 		struct vnode *a_vp; 		struct proc *a_p; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|ap
operator|->
name|a_p
decl_stmt|;
name|struct
name|union_node
modifier|*
name|un
init|=
name|VTOUNION
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
decl_stmt|;
comment|/* 	 * Do nothing (and _don't_ bypass). 	 * Wait to vrele lowervp until reclaim, 	 * so that until then our union_node is in the 	 * cache and reusable. 	 * 	 * NEEDSWORK: Someday, consider inactive'ing 	 * the lowervp and then trying to reactivate it 	 * with capabilities (v_id) 	 * like they do in the name lookup cache code. 	 * That's too much work for now. 	 */
if|if
condition|(
name|un
operator|->
name|un_dircache
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|vpp
operator|=
name|un
operator|->
name|un_dircache
init|;
operator|*
name|vpp
operator|!=
name|NULLVP
condition|;
name|vpp
operator|++
control|)
name|vrele
argument_list|(
operator|*
name|vpp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|un
operator|->
name|un_dircache
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|un
operator|->
name|un_dircache
operator|=
literal|0
expr_stmt|;
block|}
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|un
operator|->
name|un_flags
operator|&
name|UN_CACHED
operator|)
operator|==
literal|0
condition|)
name|vgone
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|union_reclaim
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_reclaim_args
comment|/* { 		struct vnode *a_vp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|union_freevp
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|union_lock
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_lock_args
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|ap
operator|->
name|a_p
decl_stmt|;
name|int
name|flags
init|=
name|ap
operator|->
name|a_flags
decl_stmt|;
name|struct
name|union_node
modifier|*
name|un
decl_stmt|;
name|int
name|error
decl_stmt|;
name|vop_nolock
argument_list|(
name|ap
argument_list|)
expr_stmt|;
comment|/* 	 * Need to do real lockmgr-style locking here. 	 * in the mean time, draining won't work quite right, 	 * which could lead to a few race conditions. 	 * the following test was here, but is not quite right, we 	 * still need to take the lock: 	if ((flags& LK_TYPE_MASK) == LK_DRAIN) 		return (0); 	 */
name|flags
operator|&=
operator|~
name|LK_INTERLOCK
expr_stmt|;
name|start
label|:
name|un
operator|=
name|VTOUNION
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|un
operator|->
name|un_uppervp
operator|!=
name|NULLVP
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|un
operator|->
name|un_flags
operator|&
operator|(
name|UN_ULOCK
operator||
name|UN_KLOCK
operator|)
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|vp
operator|->
name|v_usecount
operator|!=
literal|0
operator|)
condition|)
block|{
name|error
operator|=
name|vn_lock
argument_list|(
name|un
operator|->
name|un_uppervp
argument_list|,
name|flags
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|un
operator|->
name|un_flags
operator||=
name|UN_ULOCK
expr_stmt|;
block|}
block|}
if|if
condition|(
name|un
operator|->
name|un_flags
operator|&
name|UN_LOCKED
condition|)
block|{
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|curproc
operator|&&
name|un
operator|->
name|un_pid
operator|==
name|curproc
operator|->
name|p_pid
operator|&&
name|un
operator|->
name|un_pid
operator|>
operator|-
literal|1
operator|&&
name|curproc
operator|->
name|p_pid
operator|>
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"union: locking against myself"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|un
operator|->
name|un_flags
operator||=
name|UN_WANT
expr_stmt|;
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|un
operator|->
name|un_flags
argument_list|,
name|PINOD
argument_list|,
literal|"unionlk2"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|start
goto|;
block|}
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|curproc
condition|)
name|un
operator|->
name|un_pid
operator|=
name|curproc
operator|->
name|p_pid
expr_stmt|;
else|else
name|un
operator|->
name|un_pid
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
name|un
operator|->
name|un_flags
operator||=
name|UN_LOCKED
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * When operations want to vput() a union node yet retain a lock on  * the upper vnode (say, to do some further operations like link(),  * mkdir(), ...), they set UN_KLOCK on the union node, then call  * vput() which calls VOP_UNLOCK() and comes here.  union_unlock()  * unlocks the union node (leaving the upper vnode alone), clears the  * KLOCK flag, and then returns to vput().  The caller then does whatever  * is left to do with the upper vnode, and ensures that it gets unlocked.  *  * If UN_KLOCK isn't set, then the upper vnode is unlocked here.  */
end_comment

begin_function
specifier|static
name|int
name|union_unlock
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_unlock_args
comment|/* { 		struct vnode *a_vp; 		int a_flags; 		struct proc *a_p; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|union_node
modifier|*
name|un
init|=
name|VTOUNION
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|ap
operator|->
name|a_p
decl_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
operator|(
name|un
operator|->
name|un_flags
operator|&
name|UN_LOCKED
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"union: unlock unlocked node"
argument_list|)
expr_stmt|;
if|if
condition|(
name|curproc
operator|&&
name|un
operator|->
name|un_pid
operator|!=
name|curproc
operator|->
name|p_pid
operator|&&
name|curproc
operator|->
name|p_pid
operator|>
operator|-
literal|1
operator|&&
name|un
operator|->
name|un_pid
operator|>
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"union: unlocking other process's union node"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|un
operator|->
name|un_flags
operator|&=
operator|~
name|UN_LOCKED
expr_stmt|;
if|if
condition|(
operator|(
name|un
operator|->
name|un_flags
operator|&
operator|(
name|UN_ULOCK
operator||
name|UN_KLOCK
operator|)
operator|)
operator|==
name|UN_ULOCK
condition|)
name|VOP_UNLOCK
argument_list|(
name|un
operator|->
name|un_uppervp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|un
operator|->
name|un_flags
operator|&=
operator|~
name|UN_ULOCK
expr_stmt|;
if|if
condition|(
name|un
operator|->
name|un_flags
operator|&
name|UN_WANT
condition|)
block|{
name|un
operator|->
name|un_flags
operator|&=
operator|~
name|UN_WANT
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|un
operator|->
name|un_flags
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|un
operator|->
name|un_pid
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|vop_nounlock
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|union_bmap
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_bmap_args
comment|/* { 		struct vnode *a_vp; 		daddr_t  a_bn; 		struct vnode **a_vpp; 		daddr_t *a_bnp; 		int *a_runp; 		int *a_runb; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|curproc
decl_stmt|;
comment|/* XXX */
name|struct
name|vnode
modifier|*
name|vp
init|=
name|OTHERVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|int
name|dolock
init|=
operator|(
name|vp
operator|==
name|LOWERVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|dolock
condition|)
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|p
argument_list|)
expr_stmt|;
else|else
name|FIXUP
argument_list|(
name|VTOUNION
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|ap
operator|->
name|a_vp
operator|=
name|vp
expr_stmt|;
name|error
operator|=
name|VCALL
argument_list|(
name|vp
argument_list|,
name|VOFFSET
argument_list|(
name|vop_bmap
argument_list|)
argument_list|,
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|dolock
condition|)
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|union_print
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_print_args
comment|/* { 		struct vnode *a_vp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|printf
argument_list|(
literal|"\ttag VT_UNION, vp=%p, uppervp=%p, lowervp=%p\n"
argument_list|,
name|vp
argument_list|,
name|UPPERVP
argument_list|(
name|vp
argument_list|)
argument_list|,
name|LOWERVP
argument_list|(
name|vp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|UPPERVP
argument_list|(
name|vp
argument_list|)
operator|!=
name|NULLVP
condition|)
name|vprint
argument_list|(
literal|"union: upper"
argument_list|,
name|UPPERVP
argument_list|(
name|vp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOWERVP
argument_list|(
name|vp
argument_list|)
operator|!=
name|NULLVP
condition|)
name|vprint
argument_list|(
literal|"union: lower"
argument_list|,
name|LOWERVP
argument_list|(
name|vp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|union_islocked
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_islocked_args
comment|/* { 		struct vnode *a_vp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|VTOUNION
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
operator|->
name|un_flags
operator|&
name|UN_LOCKED
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|union_pathconf
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_pathconf_args
comment|/* { 		struct vnode *a_vp; 		int a_name; 		int *a_retval; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|curproc
decl_stmt|;
comment|/* XXX */
name|struct
name|vnode
modifier|*
name|vp
init|=
name|OTHERVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|int
name|dolock
init|=
operator|(
name|vp
operator|==
name|LOWERVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|dolock
condition|)
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|p
argument_list|)
expr_stmt|;
else|else
name|FIXUP
argument_list|(
name|VTOUNION
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|ap
operator|->
name|a_vp
operator|=
name|vp
expr_stmt|;
name|error
operator|=
name|VCALL
argument_list|(
name|vp
argument_list|,
name|VOFFSET
argument_list|(
name|vop_pathconf
argument_list|)
argument_list|,
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|dolock
condition|)
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|union_advlock
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_advlock_args
comment|/* { 		struct vnode *a_vp; 		caddr_t  a_id; 		int  a_op; 		struct flock *a_fl; 		int  a_flags; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
specifier|register
name|struct
name|vnode
modifier|*
name|ovp
init|=
name|OTHERVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|ap
operator|->
name|a_vp
operator|=
name|ovp
expr_stmt|;
return|return
operator|(
name|VCALL
argument_list|(
name|ovp
argument_list|,
name|VOFFSET
argument_list|(
name|vop_advlock
argument_list|)
argument_list|,
name|ap
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * XXX - vop_strategy must be hand coded because it has no  * vnode in its arguments.  * This goes away with a merged VM/buffer cache.  */
end_comment

begin_function
specifier|static
name|int
name|union_strategy
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_strategy_args
comment|/* { 		struct buf *a_bp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|buf
modifier|*
name|bp
init|=
name|ap
operator|->
name|a_bp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|vnode
modifier|*
name|savedvp
decl_stmt|;
name|savedvp
operator|=
name|bp
operator|->
name|b_vp
expr_stmt|;
name|bp
operator|->
name|b_vp
operator|=
name|OTHERVP
argument_list|(
name|bp
operator|->
name|b_vp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|bp
operator|->
name|b_vp
operator|==
name|NULLVP
condition|)
name|panic
argument_list|(
literal|"union_strategy: nil vp"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|bp
operator|->
name|b_vp
operator|==
name|LOWERVP
argument_list|(
name|savedvp
argument_list|)
operator|)
condition|)
name|panic
argument_list|(
literal|"union_strategy: writing to lowervp"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|error
operator|=
name|VOP_STRATEGY
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_vp
operator|=
name|savedvp
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Global vfs data structures  */
end_comment

begin_decl_stmt
name|vop_t
modifier|*
modifier|*
name|union_vnodeop_p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|vnodeopv_entry_desc
name|union_vnodeop_entries
index|[]
init|=
block|{
block|{
operator|&
name|vop_default_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|vn_default_error
block|}
block|,
block|{
operator|&
name|vop_abortop_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|union_abortop
block|}
block|,
block|{
operator|&
name|vop_access_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|union_access
block|}
block|,
block|{
operator|&
name|vop_advlock_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|union_advlock
block|}
block|,
block|{
operator|&
name|vop_bmap_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|union_bmap
block|}
block|,
block|{
operator|&
name|vop_close_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|union_close
block|}
block|,
block|{
operator|&
name|vop_create_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|union_create
block|}
block|,
block|{
operator|&
name|vop_fsync_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|union_fsync
block|}
block|,
block|{
operator|&
name|vop_getattr_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|union_getattr
block|}
block|,
block|{
operator|&
name|vop_inactive_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|union_inactive
block|}
block|,
block|{
operator|&
name|vop_ioctl_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|union_ioctl
block|}
block|,
block|{
operator|&
name|vop_islocked_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|union_islocked
block|}
block|,
block|{
operator|&
name|vop_lease_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|union_lease
block|}
block|,
block|{
operator|&
name|vop_link_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|union_link
block|}
block|,
block|{
operator|&
name|vop_lock_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|union_lock
block|}
block|,
block|{
operator|&
name|vop_lookup_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|union_lookup
block|}
block|,
block|{
operator|&
name|vop_mkdir_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|union_mkdir
block|}
block|,
block|{
operator|&
name|vop_mknod_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|union_mknod
block|}
block|,
block|{
operator|&
name|vop_mmap_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|union_mmap
block|}
block|,
block|{
operator|&
name|vop_open_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|union_open
block|}
block|,
block|{
operator|&
name|vop_pathconf_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|union_pathconf
block|}
block|,
block|{
operator|&
name|vop_poll_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|union_poll
block|}
block|,
block|{
operator|&
name|vop_print_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|union_print
block|}
block|,
block|{
operator|&
name|vop_read_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|union_read
block|}
block|,
block|{
operator|&
name|vop_readdir_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|union_readdir
block|}
block|,
block|{
operator|&
name|vop_readlink_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|union_readlink
block|}
block|,
block|{
operator|&
name|vop_reclaim_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|union_reclaim
block|}
block|,
block|{
operator|&
name|vop_remove_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|union_remove
block|}
block|,
block|{
operator|&
name|vop_rename_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|union_rename
block|}
block|,
block|{
operator|&
name|vop_revoke_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|union_revoke
block|}
block|,
block|{
operator|&
name|vop_rmdir_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|union_rmdir
block|}
block|,
block|{
operator|&
name|vop_seek_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|union_seek
block|}
block|,
block|{
operator|&
name|vop_setattr_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|union_setattr
block|}
block|,
block|{
operator|&
name|vop_strategy_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|union_strategy
block|}
block|,
block|{
operator|&
name|vop_symlink_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|union_symlink
block|}
block|,
block|{
operator|&
name|vop_unlock_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|union_unlock
block|}
block|,
block|{
operator|&
name|vop_whiteout_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|union_whiteout
block|}
block|,
block|{
operator|&
name|vop_write_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|union_write
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|vnodeopv_desc
name|union_vnodeop_opv_desc
init|=
block|{
operator|&
name|union_vnodeop_p
block|,
name|union_vnodeop_entries
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|VNODEOP_SET
argument_list|(
name|union_vnodeop_opv_desc
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

