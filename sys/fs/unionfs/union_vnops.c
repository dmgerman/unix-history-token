begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992, 1993, 1994, 1995 Jan-Simon Pendry.  * Copyright (c) 1992, 1993, 1994, 1995  *      The Regents of the University of California.  * Copyright (c) 2005, 2006, 2012 Masanori Ozawa<ozawa@ongs.co.jp>, ONGS Inc.  * Copyright (c) 2006, 2012 Daichi Goto<daichi@freebsd.org>  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Jan-Simon Pendry.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)union_vnops.c	8.32 (Berkeley) 6/23/95  * $FreeBSD$  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/kdb.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/dirent.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<fs/unionfs/union.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vnode_pager.h>
end_include

begin_if
if|#
directive|if
literal|0
end_if

begin_define
define|#
directive|define
name|UNIONFS_INTERNAL_DEBUG
parameter_list|(
name|msg
parameter_list|,
name|args
modifier|...
parameter_list|)
value|printf(msg, ## args)
end_define

begin_define
define|#
directive|define
name|UNIONFS_IDBG_RENAME
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|UNIONFS_INTERNAL_DEBUG
parameter_list|(
name|msg
parameter_list|,
name|args
modifier|...
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|KASSERT_UNIONFS_VNODE
parameter_list|(
name|vp
parameter_list|)
define|\
value|KASSERT(((vp)->v_op ==&unionfs_vnodeops), \ 	    ("unionfs: it is not unionfs-vnode"))
end_define

begin_function
specifier|static
name|int
name|unionfs_lookup
parameter_list|(
name|struct
name|vop_cachedlookup_args
modifier|*
name|ap
parameter_list|)
block|{
name|int
name|iswhiteout
decl_stmt|;
name|int
name|lockflag
decl_stmt|;
name|int
name|error
decl_stmt|,
name|uerror
decl_stmt|,
name|lerror
decl_stmt|;
name|u_long
name|nameiop
decl_stmt|;
name|u_long
name|cnflags
decl_stmt|,
name|cnflagsbk
decl_stmt|;
name|struct
name|unionfs_node
modifier|*
name|dunp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|dvp
decl_stmt|,
modifier|*
name|udvp
decl_stmt|,
modifier|*
name|ldvp
decl_stmt|,
modifier|*
name|vp
decl_stmt|,
modifier|*
name|uvp
decl_stmt|,
modifier|*
name|lvp
decl_stmt|,
modifier|*
name|dtmpvp
decl_stmt|;
name|struct
name|vattr
name|va
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|iswhiteout
operator|=
literal|0
expr_stmt|;
name|lockflag
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|uerror
operator|=
name|lerror
operator|=
name|ENOENT
expr_stmt|;
name|cnp
operator|=
name|ap
operator|->
name|a_cnp
expr_stmt|;
name|nameiop
operator|=
name|cnp
operator|->
name|cn_nameiop
expr_stmt|;
name|cnflags
operator|=
name|cnp
operator|->
name|cn_flags
expr_stmt|;
name|dvp
operator|=
name|ap
operator|->
name|a_dvp
expr_stmt|;
name|dunp
operator|=
name|VTOUNIONFS
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|udvp
operator|=
name|dunp
operator|->
name|un_uppervp
expr_stmt|;
name|ldvp
operator|=
name|dunp
operator|->
name|un_lowervp
expr_stmt|;
name|vp
operator|=
name|uvp
operator|=
name|lvp
operator|=
name|NULLVP
expr_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
operator|*
operator|(
name|ap
operator|->
name|a_vpp
operator|)
operator|=
name|NULLVP
expr_stmt|;
name|UNIONFS_INTERNAL_DEBUG
argument_list|(
literal|"unionfs_lookup: enter: nameiop=%ld, flags=%lx, path=%s\n"
argument_list|,
name|nameiop
argument_list|,
name|cnflags
argument_list|,
name|cnp
operator|->
name|cn_nameptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|dvp
operator|->
name|v_type
operator|!=
name|VDIR
condition|)
return|return
operator|(
name|ENOTDIR
operator|)
return|;
comment|/* 	 * If read-only and op is not LOOKUP, will return EROFS. 	 */
if|if
condition|(
operator|(
name|cnflags
operator|&
name|ISLASTCN
operator|)
operator|&&
operator|(
name|dvp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
operator|)
operator|&&
name|LOOKUP
operator|!=
name|nameiop
condition|)
return|return
operator|(
name|EROFS
operator|)
return|;
comment|/* 	 * lookup dotdot 	 */
if|if
condition|(
name|cnflags
operator|&
name|ISDOTDOT
condition|)
block|{
if|if
condition|(
name|LOOKUP
operator|!=
name|nameiop
operator|&&
name|udvp
operator|==
name|NULLVP
condition|)
return|return
operator|(
name|EROFS
operator|)
return|;
if|if
condition|(
name|udvp
operator|!=
name|NULLVP
condition|)
block|{
name|dtmpvp
operator|=
name|udvp
expr_stmt|;
if|if
condition|(
name|ldvp
operator|!=
name|NULLVP
condition|)
name|VOP_UNLOCK
argument_list|(
name|ldvp
argument_list|,
name|LK_RELEASE
argument_list|)
expr_stmt|;
block|}
else|else
name|dtmpvp
operator|=
name|ldvp
expr_stmt|;
name|error
operator|=
name|VOP_LOOKUP
argument_list|(
name|dtmpvp
argument_list|,
operator|&
name|vp
argument_list|,
name|cnp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtmpvp
operator|==
name|udvp
operator|&&
name|ldvp
operator|!=
name|NULLVP
condition|)
block|{
name|VOP_UNLOCK
argument_list|(
name|udvp
argument_list|,
name|LK_RELEASE
argument_list|)
expr_stmt|;
name|vn_lock
argument_list|(
name|dvp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Exchange lock and reference from vp to 			 * dunp->un_dvp. vp is upper/lower vnode, but it 			 * will need to return the unionfs vnode. 			 */
if|if
condition|(
name|nameiop
operator|==
name|DELETE
operator|||
name|nameiop
operator|==
name|RENAME
operator|||
operator|(
name|cnp
operator|->
name|cn_lkflags
operator|&
name|LK_TYPE_MASK
operator|)
condition|)
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
name|LK_RELEASE
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|dvp
argument_list|,
name|LK_RELEASE
argument_list|)
expr_stmt|;
operator|*
operator|(
name|ap
operator|->
name|a_vpp
operator|)
operator|=
name|dunp
operator|->
name|un_dvp
expr_stmt|;
name|vref
argument_list|(
name|dunp
operator|->
name|un_dvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nameiop
operator|==
name|DELETE
operator|||
name|nameiop
operator|==
name|RENAME
condition|)
name|vn_lock
argument_list|(
name|dunp
operator|->
name|un_dvp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cnp
operator|->
name|cn_lkflags
operator|&
name|LK_TYPE_MASK
condition|)
name|vn_lock
argument_list|(
name|dunp
operator|->
name|un_dvp
argument_list|,
name|cnp
operator|->
name|cn_lkflags
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
name|vn_lock
argument_list|(
name|dvp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|error
operator|==
name|ENOENT
operator|&&
operator|(
name|cnflags
operator|&
name|MAKEENTRY
operator|)
operator|&&
name|nameiop
operator|!=
name|CREATE
condition|)
name|cache_enter
argument_list|(
name|dvp
argument_list|,
name|NULLVP
argument_list|,
name|cnp
argument_list|)
expr_stmt|;
name|UNIONFS_INTERNAL_DEBUG
argument_list|(
literal|"unionfs_lookup: leave (%d)\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * lookup upper layer 	 */
if|if
condition|(
name|udvp
operator|!=
name|NULLVP
condition|)
block|{
name|uerror
operator|=
name|VOP_LOOKUP
argument_list|(
name|udvp
argument_list|,
operator|&
name|uvp
argument_list|,
name|cnp
argument_list|)
expr_stmt|;
if|if
condition|(
name|uerror
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|udvp
operator|==
name|uvp
condition|)
block|{
comment|/* is dot */
name|vrele
argument_list|(
name|uvp
argument_list|)
expr_stmt|;
operator|*
operator|(
name|ap
operator|->
name|a_vpp
operator|)
operator|=
name|dvp
expr_stmt|;
name|vref
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|UNIONFS_INTERNAL_DEBUG
argument_list|(
literal|"unionfs_lookup: leave (%d)\n"
argument_list|,
name|uerror
argument_list|)
expr_stmt|;
return|return
operator|(
name|uerror
operator|)
return|;
block|}
if|if
condition|(
name|nameiop
operator|==
name|DELETE
operator|||
name|nameiop
operator|==
name|RENAME
operator|||
operator|(
name|cnp
operator|->
name|cn_lkflags
operator|&
name|LK_TYPE_MASK
operator|)
condition|)
name|VOP_UNLOCK
argument_list|(
name|uvp
argument_list|,
name|LK_RELEASE
argument_list|)
expr_stmt|;
block|}
comment|/* check whiteout */
if|if
condition|(
name|uerror
operator|==
name|ENOENT
operator|||
name|uerror
operator|==
name|EJUSTRETURN
condition|)
if|if
condition|(
name|cnp
operator|->
name|cn_flags
operator|&
name|ISWHITEOUT
condition|)
name|iswhiteout
operator|=
literal|1
expr_stmt|;
comment|/* don't lookup lower */
if|if
condition|(
name|iswhiteout
operator|==
literal|0
operator|&&
name|ldvp
operator|!=
name|NULLVP
condition|)
if|if
condition|(
operator|!
name|VOP_GETATTR
argument_list|(
name|udvp
argument_list|,
operator|&
name|va
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|)
operator|&&
operator|(
name|va
operator|.
name|va_flags
operator|&
name|OPAQUE
operator|)
condition|)
name|iswhiteout
operator|=
literal|1
expr_stmt|;
comment|/* don't lookup lower */
if|#
directive|if
literal|0
block|UNIONFS_INTERNAL_DEBUG("unionfs_lookup: debug: whiteout=%d, path=%s\n", iswhiteout, cnp->cn_nameptr);
endif|#
directive|endif
block|}
comment|/* 	 * lookup lower layer 	 */
if|if
condition|(
name|ldvp
operator|!=
name|NULLVP
operator|&&
operator|!
operator|(
name|cnflags
operator|&
name|DOWHITEOUT
operator|)
operator|&&
name|iswhiteout
operator|==
literal|0
condition|)
block|{
comment|/* always op is LOOKUP */
name|cnp
operator|->
name|cn_nameiop
operator|=
name|LOOKUP
expr_stmt|;
name|cnflagsbk
operator|=
name|cnp
operator|->
name|cn_flags
expr_stmt|;
name|cnp
operator|->
name|cn_flags
operator|=
name|cnflags
expr_stmt|;
name|lerror
operator|=
name|VOP_LOOKUP
argument_list|(
name|ldvp
argument_list|,
operator|&
name|lvp
argument_list|,
name|cnp
argument_list|)
expr_stmt|;
name|cnp
operator|->
name|cn_nameiop
operator|=
name|nameiop
expr_stmt|;
if|if
condition|(
name|udvp
operator|!=
name|NULLVP
operator|&&
operator|(
name|uerror
operator|==
literal|0
operator|||
name|uerror
operator|==
name|EJUSTRETURN
operator|)
condition|)
name|cnp
operator|->
name|cn_flags
operator|=
name|cnflagsbk
expr_stmt|;
if|if
condition|(
name|lerror
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ldvp
operator|==
name|lvp
condition|)
block|{
comment|/* is dot */
if|if
condition|(
name|uvp
operator|!=
name|NULLVP
condition|)
name|vrele
argument_list|(
name|uvp
argument_list|)
expr_stmt|;
comment|/* no need? */
name|vrele
argument_list|(
name|lvp
argument_list|)
expr_stmt|;
operator|*
operator|(
name|ap
operator|->
name|a_vpp
operator|)
operator|=
name|dvp
expr_stmt|;
name|vref
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|UNIONFS_INTERNAL_DEBUG
argument_list|(
literal|"unionfs_lookup: leave (%d)\n"
argument_list|,
name|lerror
argument_list|)
expr_stmt|;
return|return
operator|(
name|lerror
operator|)
return|;
block|}
if|if
condition|(
name|cnp
operator|->
name|cn_lkflags
operator|&
name|LK_TYPE_MASK
condition|)
name|VOP_UNLOCK
argument_list|(
name|lvp
argument_list|,
name|LK_RELEASE
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * check lookup result 	 */
if|if
condition|(
name|uvp
operator|==
name|NULLVP
operator|&&
name|lvp
operator|==
name|NULLVP
condition|)
block|{
name|UNIONFS_INTERNAL_DEBUG
argument_list|(
literal|"unionfs_lookup: leave (%d)\n"
argument_list|,
operator|(
name|udvp
operator|!=
name|NULLVP
condition|?
name|uerror
else|:
name|lerror
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|udvp
operator|!=
name|NULLVP
condition|?
name|uerror
else|:
name|lerror
operator|)
return|;
block|}
comment|/* 	 * check vnode type 	 */
if|if
condition|(
name|uvp
operator|!=
name|NULLVP
operator|&&
name|lvp
operator|!=
name|NULLVP
operator|&&
name|uvp
operator|->
name|v_type
operator|!=
name|lvp
operator|->
name|v_type
condition|)
block|{
name|vrele
argument_list|(
name|lvp
argument_list|)
expr_stmt|;
name|lvp
operator|=
name|NULLVP
expr_stmt|;
block|}
comment|/* 	 * check shadow dir 	 */
if|if
condition|(
name|uerror
operator|!=
literal|0
operator|&&
name|uerror
operator|!=
name|EJUSTRETURN
operator|&&
name|udvp
operator|!=
name|NULLVP
operator|&&
name|lerror
operator|==
literal|0
operator|&&
name|lvp
operator|!=
name|NULLVP
operator|&&
name|lvp
operator|->
name|v_type
operator|==
name|VDIR
operator|&&
operator|!
operator|(
name|dvp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
operator|)
operator|&&
operator|(
literal|1
operator|<
name|cnp
operator|->
name|cn_namelen
operator|||
literal|'.'
operator|!=
operator|*
operator|(
name|cnp
operator|->
name|cn_nameptr
operator|)
operator|)
condition|)
block|{
comment|/* get unionfs vnode in order to create a new shadow dir. */
name|error
operator|=
name|unionfs_nodeget
argument_list|(
name|dvp
operator|->
name|v_mount
argument_list|,
name|NULLVP
argument_list|,
name|lvp
argument_list|,
name|dvp
argument_list|,
operator|&
name|vp
argument_list|,
name|cnp
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|unionfs_lookup_out
goto|;
if|if
condition|(
name|LK_SHARED
operator|==
operator|(
name|cnp
operator|->
name|cn_lkflags
operator|&
name|LK_TYPE_MASK
operator|)
condition|)
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
name|LK_RELEASE
argument_list|)
expr_stmt|;
if|if
condition|(
name|LK_EXCLUSIVE
operator|!=
name|VOP_ISLOCKED
argument_list|(
name|vp
argument_list|)
condition|)
block|{
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
name|lockflag
operator|=
literal|1
expr_stmt|;
block|}
name|error
operator|=
name|unionfs_mkshadowdir
argument_list|(
name|MOUNTTOUNIONFSMOUNT
argument_list|(
name|dvp
operator|->
name|v_mount
argument_list|)
argument_list|,
name|udvp
argument_list|,
name|VTOUNIONFS
argument_list|(
name|vp
argument_list|)
argument_list|,
name|cnp
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|lockflag
operator|!=
literal|0
condition|)
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
name|LK_RELEASE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|UNIONFSDEBUG
argument_list|(
literal|"unionfs_lookup: Unable to create shadow dir."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cnp
operator|->
name|cn_lkflags
operator|&
name|LK_TYPE_MASK
operator|)
operator|==
name|LK_EXCLUSIVE
condition|)
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
else|else
name|vrele
argument_list|(
name|vp
argument_list|)
expr_stmt|;
goto|goto
name|unionfs_lookup_out
goto|;
block|}
if|if
condition|(
operator|(
name|cnp
operator|->
name|cn_lkflags
operator|&
name|LK_TYPE_MASK
operator|)
operator|==
name|LK_SHARED
condition|)
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_SHARED
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * get unionfs vnode. 	 */
else|else
block|{
if|if
condition|(
name|uvp
operator|!=
name|NULLVP
condition|)
name|error
operator|=
name|uerror
expr_stmt|;
else|else
name|error
operator|=
name|lerror
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|unionfs_lookup_out
goto|;
comment|/* 		 * get socket vnode. 		 */
if|if
condition|(
name|uvp
operator|!=
name|NULLVP
operator|&&
name|uvp
operator|->
name|v_type
operator|==
name|VSOCK
condition|)
block|{
name|vp
operator|=
name|uvp
expr_stmt|;
name|vref
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnp
operator|->
name|cn_lkflags
operator|&
name|LK_TYPE_MASK
condition|)
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|cnp
operator|->
name|cn_lkflags
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lvp
operator|!=
name|NULLVP
operator|&&
name|lvp
operator|->
name|v_type
operator|==
name|VSOCK
condition|)
block|{
name|vp
operator|=
name|lvp
expr_stmt|;
name|vref
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnp
operator|->
name|cn_lkflags
operator|&
name|LK_TYPE_MASK
condition|)
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|cnp
operator|->
name|cn_lkflags
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * get unionfs vnode. 		 */
else|else
name|error
operator|=
name|unionfs_nodeget
argument_list|(
name|dvp
operator|->
name|v_mount
argument_list|,
name|uvp
argument_list|,
name|lvp
argument_list|,
name|dvp
argument_list|,
operator|&
name|vp
argument_list|,
name|cnp
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|UNIONFSDEBUG
argument_list|(
literal|"unionfs_lookup: Unable to create unionfs vnode."
argument_list|)
expr_stmt|;
goto|goto
name|unionfs_lookup_out
goto|;
block|}
if|if
condition|(
operator|(
name|nameiop
operator|==
name|DELETE
operator|||
name|nameiop
operator|==
name|RENAME
operator|)
operator|&&
operator|(
name|cnp
operator|->
name|cn_lkflags
operator|&
name|LK_TYPE_MASK
operator|)
operator|==
literal|0
condition|)
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
block|}
operator|*
operator|(
name|ap
operator|->
name|a_vpp
operator|)
operator|=
name|vp
expr_stmt|;
if|if
condition|(
operator|(
name|cnflags
operator|&
name|MAKEENTRY
operator|)
operator|&&
name|vp
operator|->
name|v_type
operator|!=
name|VSOCK
condition|)
name|cache_enter
argument_list|(
name|dvp
argument_list|,
name|vp
argument_list|,
name|cnp
argument_list|)
expr_stmt|;
name|unionfs_lookup_out
label|:
if|if
condition|(
name|uvp
operator|!=
name|NULLVP
condition|)
name|vrele
argument_list|(
name|uvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|lvp
operator|!=
name|NULLVP
condition|)
name|vrele
argument_list|(
name|lvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOENT
operator|&&
operator|(
name|cnflags
operator|&
name|MAKEENTRY
operator|)
operator|&&
name|nameiop
operator|!=
name|CREATE
condition|)
name|cache_enter
argument_list|(
name|dvp
argument_list|,
name|NULLVP
argument_list|,
name|cnp
argument_list|)
expr_stmt|;
name|UNIONFS_INTERNAL_DEBUG
argument_list|(
literal|"unionfs_lookup: leave (%d)\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unionfs_create
parameter_list|(
name|struct
name|vop_create_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|unionfs_node
modifier|*
name|dunp
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|udvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|UNIONFS_INTERNAL_DEBUG
argument_list|(
literal|"unionfs_create: enter\n"
argument_list|)
expr_stmt|;
name|KASSERT_UNIONFS_VNODE
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
expr_stmt|;
name|dunp
operator|=
name|VTOUNIONFS
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
expr_stmt|;
name|cnp
operator|=
name|ap
operator|->
name|a_cnp
expr_stmt|;
name|udvp
operator|=
name|dunp
operator|->
name|un_uppervp
expr_stmt|;
name|error
operator|=
name|EROFS
expr_stmt|;
if|if
condition|(
name|udvp
operator|!=
name|NULLVP
condition|)
block|{
name|error
operator|=
name|VOP_CREATE
argument_list|(
name|udvp
argument_list|,
operator|&
name|vp
argument_list|,
name|cnp
argument_list|,
name|ap
operator|->
name|a_vap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|unionfs_create_abort
goto|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VSOCK
condition|)
operator|*
operator|(
name|ap
operator|->
name|a_vpp
operator|)
operator|=
name|vp
expr_stmt|;
else|else
block|{
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
name|LK_RELEASE
argument_list|)
expr_stmt|;
name|error
operator|=
name|unionfs_nodeget
argument_list|(
name|ap
operator|->
name|a_dvp
operator|->
name|v_mount
argument_list|,
name|vp
argument_list|,
name|NULLVP
argument_list|,
name|ap
operator|->
name|a_dvp
argument_list|,
name|ap
operator|->
name|a_vpp
argument_list|,
name|cnp
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
block|}
name|unionfs_create_abort
label|:
name|UNIONFS_INTERNAL_DEBUG
argument_list|(
literal|"unionfs_create: leave (%d)\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unionfs_whiteout
parameter_list|(
name|struct
name|vop_whiteout_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|unionfs_node
modifier|*
name|dunp
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|udvp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|UNIONFS_INTERNAL_DEBUG
argument_list|(
literal|"unionfs_whiteout: enter\n"
argument_list|)
expr_stmt|;
name|KASSERT_UNIONFS_VNODE
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
expr_stmt|;
name|dunp
operator|=
name|VTOUNIONFS
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
expr_stmt|;
name|cnp
operator|=
name|ap
operator|->
name|a_cnp
expr_stmt|;
name|udvp
operator|=
name|dunp
operator|->
name|un_uppervp
expr_stmt|;
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
if|if
condition|(
name|udvp
operator|!=
name|NULLVP
condition|)
block|{
switch|switch
condition|(
name|ap
operator|->
name|a_flags
condition|)
block|{
case|case
name|CREATE
case|:
case|case
name|DELETE
case|:
case|case
name|LOOKUP
case|:
name|error
operator|=
name|VOP_WHITEOUT
argument_list|(
name|udvp
argument_list|,
name|cnp
argument_list|,
name|ap
operator|->
name|a_flags
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
block|}
name|UNIONFS_INTERNAL_DEBUG
argument_list|(
literal|"unionfs_whiteout: leave (%d)\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unionfs_mknod
parameter_list|(
name|struct
name|vop_mknod_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|unionfs_node
modifier|*
name|dunp
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|udvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|UNIONFS_INTERNAL_DEBUG
argument_list|(
literal|"unionfs_mknod: enter\n"
argument_list|)
expr_stmt|;
name|KASSERT_UNIONFS_VNODE
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
expr_stmt|;
name|dunp
operator|=
name|VTOUNIONFS
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
expr_stmt|;
name|cnp
operator|=
name|ap
operator|->
name|a_cnp
expr_stmt|;
name|udvp
operator|=
name|dunp
operator|->
name|un_uppervp
expr_stmt|;
name|error
operator|=
name|EROFS
expr_stmt|;
if|if
condition|(
name|udvp
operator|!=
name|NULLVP
condition|)
block|{
name|error
operator|=
name|VOP_MKNOD
argument_list|(
name|udvp
argument_list|,
operator|&
name|vp
argument_list|,
name|cnp
argument_list|,
name|ap
operator|->
name|a_vap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|unionfs_mknod_abort
goto|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VSOCK
condition|)
operator|*
operator|(
name|ap
operator|->
name|a_vpp
operator|)
operator|=
name|vp
expr_stmt|;
else|else
block|{
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
name|LK_RELEASE
argument_list|)
expr_stmt|;
name|error
operator|=
name|unionfs_nodeget
argument_list|(
name|ap
operator|->
name|a_dvp
operator|->
name|v_mount
argument_list|,
name|vp
argument_list|,
name|NULLVP
argument_list|,
name|ap
operator|->
name|a_dvp
argument_list|,
name|ap
operator|->
name|a_vpp
argument_list|,
name|cnp
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
block|}
name|unionfs_mknod_abort
label|:
name|UNIONFS_INTERNAL_DEBUG
argument_list|(
literal|"unionfs_mknod: leave (%d)\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unionfs_open
parameter_list|(
name|struct
name|vop_open_args
modifier|*
name|ap
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|unionfs_node
modifier|*
name|unp
decl_stmt|;
name|struct
name|unionfs_node_status
modifier|*
name|unsp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|uvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|lvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|targetvp
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|UNIONFS_INTERNAL_DEBUG
argument_list|(
literal|"unionfs_open: enter\n"
argument_list|)
expr_stmt|;
name|KASSERT_UNIONFS_VNODE
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|unp
operator|=
name|VTOUNIONFS
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
name|uvp
operator|=
name|unp
operator|->
name|un_uppervp
expr_stmt|;
name|lvp
operator|=
name|unp
operator|->
name|un_lowervp
expr_stmt|;
name|targetvp
operator|=
name|NULLVP
expr_stmt|;
name|cred
operator|=
name|ap
operator|->
name|a_cred
expr_stmt|;
name|td
operator|=
name|ap
operator|->
name|a_td
expr_stmt|;
name|unionfs_get_node_status
argument_list|(
name|unp
argument_list|,
name|td
argument_list|,
operator|&
name|unsp
argument_list|)
expr_stmt|;
if|if
condition|(
name|unsp
operator|->
name|uns_lower_opencnt
operator|>
literal|0
operator|||
name|unsp
operator|->
name|uns_upper_opencnt
operator|>
literal|0
condition|)
block|{
comment|/* vnode is already opend. */
if|if
condition|(
name|unsp
operator|->
name|uns_upper_opencnt
operator|>
literal|0
condition|)
name|targetvp
operator|=
name|uvp
expr_stmt|;
else|else
name|targetvp
operator|=
name|lvp
expr_stmt|;
if|if
condition|(
name|targetvp
operator|==
name|lvp
operator|&&
operator|(
name|ap
operator|->
name|a_mode
operator|&
name|FWRITE
operator|)
operator|&&
name|lvp
operator|->
name|v_type
operator|==
name|VREG
condition|)
name|targetvp
operator|=
name|NULLVP
expr_stmt|;
block|}
if|if
condition|(
name|targetvp
operator|==
name|NULLVP
condition|)
block|{
if|if
condition|(
name|uvp
operator|==
name|NULLVP
condition|)
block|{
if|if
condition|(
operator|(
name|ap
operator|->
name|a_mode
operator|&
name|FWRITE
operator|)
operator|&&
name|lvp
operator|->
name|v_type
operator|==
name|VREG
condition|)
block|{
name|error
operator|=
name|unionfs_copyfile
argument_list|(
name|unp
argument_list|,
operator|!
operator|(
name|ap
operator|->
name|a_mode
operator|&
name|O_TRUNC
operator|)
argument_list|,
name|cred
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|unionfs_open_abort
goto|;
name|targetvp
operator|=
name|uvp
operator|=
name|unp
operator|->
name|un_uppervp
expr_stmt|;
block|}
else|else
name|targetvp
operator|=
name|lvp
expr_stmt|;
block|}
else|else
name|targetvp
operator|=
name|uvp
expr_stmt|;
block|}
name|error
operator|=
name|VOP_OPEN
argument_list|(
name|targetvp
argument_list|,
name|ap
operator|->
name|a_mode
argument_list|,
name|cred
argument_list|,
name|td
argument_list|,
name|ap
operator|->
name|a_fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|targetvp
operator|==
name|uvp
condition|)
block|{
if|if
condition|(
name|uvp
operator|->
name|v_type
operator|==
name|VDIR
operator|&&
name|lvp
operator|!=
name|NULLVP
operator|&&
name|unsp
operator|->
name|uns_lower_opencnt
operator|<=
literal|0
condition|)
block|{
comment|/* open lower for readdir */
name|error
operator|=
name|VOP_OPEN
argument_list|(
name|lvp
argument_list|,
name|FREAD
argument_list|,
name|cred
argument_list|,
name|td
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|VOP_CLOSE
argument_list|(
name|uvp
argument_list|,
name|ap
operator|->
name|a_mode
argument_list|,
name|cred
argument_list|,
name|td
argument_list|)
expr_stmt|;
goto|goto
name|unionfs_open_abort
goto|;
block|}
name|unsp
operator|->
name|uns_node_flag
operator||=
name|UNS_OPENL_4_READDIR
expr_stmt|;
name|unsp
operator|->
name|uns_lower_opencnt
operator|++
expr_stmt|;
block|}
name|unsp
operator|->
name|uns_upper_opencnt
operator|++
expr_stmt|;
block|}
else|else
block|{
name|unsp
operator|->
name|uns_lower_opencnt
operator|++
expr_stmt|;
name|unsp
operator|->
name|uns_lower_openmode
operator|=
name|ap
operator|->
name|a_mode
expr_stmt|;
block|}
name|ap
operator|->
name|a_vp
operator|->
name|v_object
operator|=
name|targetvp
operator|->
name|v_object
expr_stmt|;
block|}
name|unionfs_open_abort
label|:
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|unionfs_tryrem_node_status
argument_list|(
name|unp
argument_list|,
name|unsp
argument_list|)
expr_stmt|;
name|UNIONFS_INTERNAL_DEBUG
argument_list|(
literal|"unionfs_open: leave (%d)\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unionfs_close
parameter_list|(
name|struct
name|vop_close_args
modifier|*
name|ap
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|int
name|locked
decl_stmt|;
name|struct
name|unionfs_node
modifier|*
name|unp
decl_stmt|;
name|struct
name|unionfs_node_status
modifier|*
name|unsp
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|ovp
decl_stmt|;
name|UNIONFS_INTERNAL_DEBUG
argument_list|(
literal|"unionfs_close: enter\n"
argument_list|)
expr_stmt|;
name|KASSERT_UNIONFS_VNODE
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
name|locked
operator|=
literal|0
expr_stmt|;
name|vp
operator|=
name|ap
operator|->
name|a_vp
expr_stmt|;
name|unp
operator|=
name|VTOUNIONFS
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|cred
operator|=
name|ap
operator|->
name|a_cred
expr_stmt|;
name|td
operator|=
name|ap
operator|->
name|a_td
expr_stmt|;
if|if
condition|(
name|VOP_ISLOCKED
argument_list|(
name|vp
argument_list|)
operator|!=
name|LK_EXCLUSIVE
condition|)
block|{
if|if
condition|(
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_UPGRADE
argument_list|)
operator|!=
literal|0
condition|)
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
name|locked
operator|=
literal|1
expr_stmt|;
block|}
name|unionfs_get_node_status
argument_list|(
name|unp
argument_list|,
name|td
argument_list|,
operator|&
name|unsp
argument_list|)
expr_stmt|;
if|if
condition|(
name|unsp
operator|->
name|uns_lower_opencnt
operator|<=
literal|0
operator|&&
name|unsp
operator|->
name|uns_upper_opencnt
operator|<=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|printf
argument_list|(
literal|"unionfs_close: warning: open count is 0\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|unp
operator|->
name|un_uppervp
operator|!=
name|NULLVP
condition|)
name|ovp
operator|=
name|unp
operator|->
name|un_uppervp
expr_stmt|;
else|else
name|ovp
operator|=
name|unp
operator|->
name|un_lowervp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|unsp
operator|->
name|uns_upper_opencnt
operator|>
literal|0
condition|)
name|ovp
operator|=
name|unp
operator|->
name|un_uppervp
expr_stmt|;
else|else
name|ovp
operator|=
name|unp
operator|->
name|un_lowervp
expr_stmt|;
name|error
operator|=
name|VOP_CLOSE
argument_list|(
name|ovp
argument_list|,
name|ap
operator|->
name|a_fflag
argument_list|,
name|cred
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|unionfs_close_abort
goto|;
name|vp
operator|->
name|v_object
operator|=
name|ovp
operator|->
name|v_object
expr_stmt|;
if|if
condition|(
name|ovp
operator|==
name|unp
operator|->
name|un_uppervp
condition|)
block|{
name|unsp
operator|->
name|uns_upper_opencnt
operator|--
expr_stmt|;
if|if
condition|(
name|unsp
operator|->
name|uns_upper_opencnt
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|unsp
operator|->
name|uns_node_flag
operator|&
name|UNS_OPENL_4_READDIR
condition|)
block|{
name|VOP_CLOSE
argument_list|(
name|unp
operator|->
name|un_lowervp
argument_list|,
name|FREAD
argument_list|,
name|cred
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|unsp
operator|->
name|uns_node_flag
operator|&=
operator|~
name|UNS_OPENL_4_READDIR
expr_stmt|;
name|unsp
operator|->
name|uns_lower_opencnt
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|unsp
operator|->
name|uns_lower_opencnt
operator|>
literal|0
condition|)
name|vp
operator|->
name|v_object
operator|=
name|unp
operator|->
name|un_lowervp
operator|->
name|v_object
expr_stmt|;
block|}
block|}
else|else
name|unsp
operator|->
name|uns_lower_opencnt
operator|--
expr_stmt|;
name|unionfs_close_abort
label|:
name|unionfs_tryrem_node_status
argument_list|(
name|unp
argument_list|,
name|unsp
argument_list|)
expr_stmt|;
if|if
condition|(
name|locked
operator|!=
literal|0
condition|)
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_DOWNGRADE
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
name|UNIONFS_INTERNAL_DEBUG
argument_list|(
literal|"unionfs_close: leave (%d)\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check the access mode toward shadow file/dir.  */
end_comment

begin_function
specifier|static
name|int
name|unionfs_check_corrected_access
parameter_list|(
name|accmode_t
name|accmode
parameter_list|,
name|struct
name|vattr
modifier|*
name|va
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|)
block|{
name|int
name|count
decl_stmt|;
name|uid_t
name|uid
decl_stmt|;
comment|/* upper side vnode's uid */
name|gid_t
name|gid
decl_stmt|;
comment|/* upper side vnode's gid */
name|u_short
name|vmode
decl_stmt|;
comment|/* upper side vnode's mode */
name|u_short
name|mask
decl_stmt|;
name|mask
operator|=
literal|0
expr_stmt|;
name|uid
operator|=
name|va
operator|->
name|va_uid
expr_stmt|;
name|gid
operator|=
name|va
operator|->
name|va_gid
expr_stmt|;
name|vmode
operator|=
name|va
operator|->
name|va_mode
expr_stmt|;
comment|/* check owner */
if|if
condition|(
name|cred
operator|->
name|cr_uid
operator|==
name|uid
condition|)
block|{
if|if
condition|(
name|accmode
operator|&
name|VEXEC
condition|)
name|mask
operator||=
name|S_IXUSR
expr_stmt|;
if|if
condition|(
name|accmode
operator|&
name|VREAD
condition|)
name|mask
operator||=
name|S_IRUSR
expr_stmt|;
if|if
condition|(
name|accmode
operator|&
name|VWRITE
condition|)
name|mask
operator||=
name|S_IWUSR
expr_stmt|;
return|return
operator|(
operator|(
name|vmode
operator|&
name|mask
operator|)
operator|==
name|mask
condition|?
literal|0
else|:
name|EACCES
operator|)
return|;
block|}
comment|/* check group */
name|count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|groupmember
argument_list|(
name|gid
argument_list|,
name|cred
argument_list|)
condition|)
block|{
if|if
condition|(
name|accmode
operator|&
name|VEXEC
condition|)
name|mask
operator||=
name|S_IXGRP
expr_stmt|;
if|if
condition|(
name|accmode
operator|&
name|VREAD
condition|)
name|mask
operator||=
name|S_IRGRP
expr_stmt|;
if|if
condition|(
name|accmode
operator|&
name|VWRITE
condition|)
name|mask
operator||=
name|S_IWGRP
expr_stmt|;
return|return
operator|(
operator|(
name|vmode
operator|&
name|mask
operator|)
operator|==
name|mask
condition|?
literal|0
else|:
name|EACCES
operator|)
return|;
block|}
comment|/* check other */
if|if
condition|(
name|accmode
operator|&
name|VEXEC
condition|)
name|mask
operator||=
name|S_IXOTH
expr_stmt|;
if|if
condition|(
name|accmode
operator|&
name|VREAD
condition|)
name|mask
operator||=
name|S_IROTH
expr_stmt|;
if|if
condition|(
name|accmode
operator|&
name|VWRITE
condition|)
name|mask
operator||=
name|S_IWOTH
expr_stmt|;
return|return
operator|(
operator|(
name|vmode
operator|&
name|mask
operator|)
operator|==
name|mask
condition|?
literal|0
else|:
name|EACCES
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unionfs_access
parameter_list|(
name|struct
name|vop_access_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|unionfs_mount
modifier|*
name|ump
decl_stmt|;
name|struct
name|unionfs_node
modifier|*
name|unp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|uvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|lvp
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|vattr
name|va
decl_stmt|;
name|accmode_t
name|accmode
decl_stmt|;
name|int
name|error
decl_stmt|;
name|UNIONFS_INTERNAL_DEBUG
argument_list|(
literal|"unionfs_access: enter\n"
argument_list|)
expr_stmt|;
name|KASSERT_UNIONFS_VNODE
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
name|ump
operator|=
name|MOUNTTOUNIONFSMOUNT
argument_list|(
name|ap
operator|->
name|a_vp
operator|->
name|v_mount
argument_list|)
expr_stmt|;
name|unp
operator|=
name|VTOUNIONFS
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
name|uvp
operator|=
name|unp
operator|->
name|un_uppervp
expr_stmt|;
name|lvp
operator|=
name|unp
operator|->
name|un_lowervp
expr_stmt|;
name|td
operator|=
name|ap
operator|->
name|a_td
expr_stmt|;
name|accmode
operator|=
name|ap
operator|->
name|a_accmode
expr_stmt|;
name|error
operator|=
name|EACCES
expr_stmt|;
if|if
condition|(
operator|(
name|accmode
operator|&
name|VWRITE
operator|)
operator|&&
operator|(
name|ap
operator|->
name|a_vp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
operator|)
condition|)
block|{
switch|switch
condition|(
name|ap
operator|->
name|a_vp
operator|->
name|v_type
condition|)
block|{
case|case
name|VREG
case|:
case|case
name|VDIR
case|:
case|case
name|VLNK
case|:
return|return
operator|(
name|EROFS
operator|)
return|;
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|uvp
operator|!=
name|NULLVP
condition|)
block|{
name|error
operator|=
name|VOP_ACCESS
argument_list|(
name|uvp
argument_list|,
name|accmode
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|UNIONFS_INTERNAL_DEBUG
argument_list|(
literal|"unionfs_access: leave (%d)\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|lvp
operator|!=
name|NULLVP
condition|)
block|{
if|if
condition|(
name|accmode
operator|&
name|VWRITE
condition|)
block|{
if|if
condition|(
name|ump
operator|->
name|um_uppervp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
condition|)
block|{
switch|switch
condition|(
name|ap
operator|->
name|a_vp
operator|->
name|v_type
condition|)
block|{
case|case
name|VREG
case|:
case|case
name|VDIR
case|:
case|case
name|VLNK
case|:
return|return
operator|(
name|EROFS
operator|)
return|;
default|default:
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|ap
operator|->
name|a_vp
operator|->
name|v_type
operator|==
name|VREG
operator|||
name|ap
operator|->
name|a_vp
operator|->
name|v_type
operator|==
name|VDIR
condition|)
block|{
comment|/* check shadow file/dir */
if|if
condition|(
name|ump
operator|->
name|um_copymode
operator|!=
name|UNIONFS_TRANSPARENT
condition|)
block|{
name|error
operator|=
name|unionfs_create_uppervattr
argument_list|(
name|ump
argument_list|,
name|lvp
argument_list|,
operator|&
name|va
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|unionfs_check_corrected_access
argument_list|(
name|accmode
argument_list|,
operator|&
name|va
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
name|accmode
operator|&=
operator|~
operator|(
name|VWRITE
operator||
name|VAPPEND
operator|)
expr_stmt|;
name|accmode
operator||=
name|VREAD
expr_stmt|;
comment|/* will copy to upper */
block|}
name|error
operator|=
name|VOP_ACCESS
argument_list|(
name|lvp
argument_list|,
name|accmode
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
name|UNIONFS_INTERNAL_DEBUG
argument_list|(
literal|"unionfs_access: leave (%d)\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unionfs_getattr
parameter_list|(
name|struct
name|vop_getattr_args
modifier|*
name|ap
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|unionfs_node
modifier|*
name|unp
decl_stmt|;
name|struct
name|unionfs_mount
modifier|*
name|ump
decl_stmt|;
name|struct
name|vnode
modifier|*
name|uvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|lvp
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|vattr
name|va
decl_stmt|;
name|UNIONFS_INTERNAL_DEBUG
argument_list|(
literal|"unionfs_getattr: enter\n"
argument_list|)
expr_stmt|;
name|KASSERT_UNIONFS_VNODE
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
name|unp
operator|=
name|VTOUNIONFS
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
name|ump
operator|=
name|MOUNTTOUNIONFSMOUNT
argument_list|(
name|ap
operator|->
name|a_vp
operator|->
name|v_mount
argument_list|)
expr_stmt|;
name|uvp
operator|=
name|unp
operator|->
name|un_uppervp
expr_stmt|;
name|lvp
operator|=
name|unp
operator|->
name|un_lowervp
expr_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
if|if
condition|(
name|uvp
operator|!=
name|NULLVP
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|uvp
argument_list|,
name|ap
operator|->
name|a_vap
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|ap
operator|->
name|a_vap
operator|->
name|va_fsid
operator|=
name|ap
operator|->
name|a_vp
operator|->
name|v_mount
operator|->
name|mnt_stat
operator|.
name|f_fsid
operator|.
name|val
index|[
literal|0
index|]
expr_stmt|;
name|UNIONFS_INTERNAL_DEBUG
argument_list|(
literal|"unionfs_getattr: leave mode=%o, uid=%d, gid=%d (%d)\n"
argument_list|,
name|ap
operator|->
name|a_vap
operator|->
name|va_mode
argument_list|,
name|ap
operator|->
name|a_vap
operator|->
name|va_uid
argument_list|,
name|ap
operator|->
name|a_vap
operator|->
name|va_gid
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|lvp
argument_list|,
name|ap
operator|->
name|a_vap
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
operator|!
operator|(
name|ump
operator|->
name|um_uppervp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
operator|)
condition|)
block|{
comment|/* correct the attr toward shadow file/dir. */
if|if
condition|(
name|ap
operator|->
name|a_vp
operator|->
name|v_type
operator|==
name|VREG
operator|||
name|ap
operator|->
name|a_vp
operator|->
name|v_type
operator|==
name|VDIR
condition|)
block|{
name|unionfs_create_uppervattr_core
argument_list|(
name|ump
argument_list|,
name|ap
operator|->
name|a_vap
argument_list|,
operator|&
name|va
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|ap
operator|->
name|a_vap
operator|->
name|va_mode
operator|=
name|va
operator|.
name|va_mode
expr_stmt|;
name|ap
operator|->
name|a_vap
operator|->
name|va_uid
operator|=
name|va
operator|.
name|va_uid
expr_stmt|;
name|ap
operator|->
name|a_vap
operator|->
name|va_gid
operator|=
name|va
operator|.
name|va_gid
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|ap
operator|->
name|a_vap
operator|->
name|va_fsid
operator|=
name|ap
operator|->
name|a_vp
operator|->
name|v_mount
operator|->
name|mnt_stat
operator|.
name|f_fsid
operator|.
name|val
index|[
literal|0
index|]
expr_stmt|;
name|UNIONFS_INTERNAL_DEBUG
argument_list|(
literal|"unionfs_getattr: leave mode=%o, uid=%d, gid=%d (%d)\n"
argument_list|,
name|ap
operator|->
name|a_vap
operator|->
name|va_mode
argument_list|,
name|ap
operator|->
name|a_vap
operator|->
name|va_uid
argument_list|,
name|ap
operator|->
name|a_vap
operator|->
name|va_gid
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unionfs_setattr
parameter_list|(
name|struct
name|vop_setattr_args
modifier|*
name|ap
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|unionfs_node
modifier|*
name|unp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|uvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|lvp
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|vattr
modifier|*
name|vap
decl_stmt|;
name|UNIONFS_INTERNAL_DEBUG
argument_list|(
literal|"unionfs_setattr: enter\n"
argument_list|)
expr_stmt|;
name|KASSERT_UNIONFS_VNODE
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
name|error
operator|=
name|EROFS
expr_stmt|;
name|unp
operator|=
name|VTOUNIONFS
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
name|uvp
operator|=
name|unp
operator|->
name|un_uppervp
expr_stmt|;
name|lvp
operator|=
name|unp
operator|->
name|un_lowervp
expr_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
name|vap
operator|=
name|ap
operator|->
name|a_vap
expr_stmt|;
if|if
condition|(
operator|(
name|ap
operator|->
name|a_vp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
operator|)
operator|&&
operator|(
name|vap
operator|->
name|va_flags
operator|!=
name|VNOVAL
operator|||
name|vap
operator|->
name|va_uid
operator|!=
operator|(
name|uid_t
operator|)
name|VNOVAL
operator|||
name|vap
operator|->
name|va_gid
operator|!=
operator|(
name|gid_t
operator|)
name|VNOVAL
operator|||
name|vap
operator|->
name|va_atime
operator|.
name|tv_sec
operator|!=
name|VNOVAL
operator|||
name|vap
operator|->
name|va_mtime
operator|.
name|tv_sec
operator|!=
name|VNOVAL
operator|||
name|vap
operator|->
name|va_mode
operator|!=
operator|(
name|mode_t
operator|)
name|VNOVAL
operator|)
condition|)
return|return
operator|(
name|EROFS
operator|)
return|;
if|if
condition|(
name|uvp
operator|==
name|NULLVP
operator|&&
name|lvp
operator|->
name|v_type
operator|==
name|VREG
condition|)
block|{
name|error
operator|=
name|unionfs_copyfile
argument_list|(
name|unp
argument_list|,
operator|(
name|vap
operator|->
name|va_size
operator|!=
literal|0
operator|)
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|uvp
operator|=
name|unp
operator|->
name|un_uppervp
expr_stmt|;
block|}
if|if
condition|(
name|uvp
operator|!=
name|NULLVP
condition|)
name|error
operator|=
name|VOP_SETATTR
argument_list|(
name|uvp
argument_list|,
name|vap
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|)
expr_stmt|;
name|UNIONFS_INTERNAL_DEBUG
argument_list|(
literal|"unionfs_setattr: leave (%d)\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unionfs_read
parameter_list|(
name|struct
name|vop_read_args
modifier|*
name|ap
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|unionfs_node
modifier|*
name|unp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|tvp
decl_stmt|;
comment|/* UNIONFS_INTERNAL_DEBUG("unionfs_read: enter\n"); */
name|KASSERT_UNIONFS_VNODE
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
name|unp
operator|=
name|VTOUNIONFS
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
name|tvp
operator|=
operator|(
name|unp
operator|->
name|un_uppervp
operator|!=
name|NULLVP
condition|?
name|unp
operator|->
name|un_uppervp
else|:
name|unp
operator|->
name|un_lowervp
operator|)
expr_stmt|;
name|error
operator|=
name|VOP_READ
argument_list|(
name|tvp
argument_list|,
name|ap
operator|->
name|a_uio
argument_list|,
name|ap
operator|->
name|a_ioflag
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|)
expr_stmt|;
comment|/* UNIONFS_INTERNAL_DEBUG("unionfs_read: leave (%d)\n", error); */
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unionfs_write
parameter_list|(
name|struct
name|vop_write_args
modifier|*
name|ap
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|unionfs_node
modifier|*
name|unp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|tvp
decl_stmt|;
comment|/* UNIONFS_INTERNAL_DEBUG("unionfs_write: enter\n"); */
name|KASSERT_UNIONFS_VNODE
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
name|unp
operator|=
name|VTOUNIONFS
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
name|tvp
operator|=
operator|(
name|unp
operator|->
name|un_uppervp
operator|!=
name|NULLVP
condition|?
name|unp
operator|->
name|un_uppervp
else|:
name|unp
operator|->
name|un_lowervp
operator|)
expr_stmt|;
name|error
operator|=
name|VOP_WRITE
argument_list|(
name|tvp
argument_list|,
name|ap
operator|->
name|a_uio
argument_list|,
name|ap
operator|->
name|a_ioflag
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|)
expr_stmt|;
comment|/* UNIONFS_INTERNAL_DEBUG("unionfs_write: leave (%d)\n", error); */
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unionfs_ioctl
parameter_list|(
name|struct
name|vop_ioctl_args
modifier|*
name|ap
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|unionfs_node
modifier|*
name|unp
decl_stmt|;
name|struct
name|unionfs_node_status
modifier|*
name|unsp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|ovp
decl_stmt|;
name|UNIONFS_INTERNAL_DEBUG
argument_list|(
literal|"unionfs_ioctl: enter\n"
argument_list|)
expr_stmt|;
name|KASSERT_UNIONFS_VNODE
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
name|vn_lock
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
name|unp
operator|=
name|VTOUNIONFS
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
name|unionfs_get_node_status
argument_list|(
name|unp
argument_list|,
name|ap
operator|->
name|a_td
argument_list|,
operator|&
name|unsp
argument_list|)
expr_stmt|;
name|ovp
operator|=
operator|(
name|unsp
operator|->
name|uns_upper_opencnt
condition|?
name|unp
operator|->
name|un_uppervp
else|:
name|unp
operator|->
name|un_lowervp
operator|)
expr_stmt|;
name|unionfs_tryrem_node_status
argument_list|(
name|unp
argument_list|,
name|unsp
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|LK_RELEASE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ovp
operator|==
name|NULLVP
condition|)
return|return
operator|(
name|EBADF
operator|)
return|;
name|error
operator|=
name|VOP_IOCTL
argument_list|(
name|ovp
argument_list|,
name|ap
operator|->
name|a_command
argument_list|,
name|ap
operator|->
name|a_data
argument_list|,
name|ap
operator|->
name|a_fflag
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_td
argument_list|)
expr_stmt|;
name|UNIONFS_INTERNAL_DEBUG
argument_list|(
literal|"unionfs_ioctl: leave (%d)\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unionfs_poll
parameter_list|(
name|struct
name|vop_poll_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|unionfs_node
modifier|*
name|unp
decl_stmt|;
name|struct
name|unionfs_node_status
modifier|*
name|unsp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|ovp
decl_stmt|;
name|KASSERT_UNIONFS_VNODE
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
name|vn_lock
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
name|unp
operator|=
name|VTOUNIONFS
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
name|unionfs_get_node_status
argument_list|(
name|unp
argument_list|,
name|ap
operator|->
name|a_td
argument_list|,
operator|&
name|unsp
argument_list|)
expr_stmt|;
name|ovp
operator|=
operator|(
name|unsp
operator|->
name|uns_upper_opencnt
condition|?
name|unp
operator|->
name|un_uppervp
else|:
name|unp
operator|->
name|un_lowervp
operator|)
expr_stmt|;
name|unionfs_tryrem_node_status
argument_list|(
name|unp
argument_list|,
name|unsp
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|LK_RELEASE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ovp
operator|==
name|NULLVP
condition|)
return|return
operator|(
name|EBADF
operator|)
return|;
return|return
operator|(
name|VOP_POLL
argument_list|(
name|ovp
argument_list|,
name|ap
operator|->
name|a_events
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_td
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unionfs_fsync
parameter_list|(
name|struct
name|vop_fsync_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|unionfs_node
modifier|*
name|unp
decl_stmt|;
name|struct
name|unionfs_node_status
modifier|*
name|unsp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|ovp
decl_stmt|;
name|KASSERT_UNIONFS_VNODE
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
name|unp
operator|=
name|VTOUNIONFS
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
name|unionfs_get_node_status
argument_list|(
name|unp
argument_list|,
name|ap
operator|->
name|a_td
argument_list|,
operator|&
name|unsp
argument_list|)
expr_stmt|;
name|ovp
operator|=
operator|(
name|unsp
operator|->
name|uns_upper_opencnt
condition|?
name|unp
operator|->
name|un_uppervp
else|:
name|unp
operator|->
name|un_lowervp
operator|)
expr_stmt|;
name|unionfs_tryrem_node_status
argument_list|(
name|unp
argument_list|,
name|unsp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ovp
operator|==
name|NULLVP
condition|)
return|return
operator|(
name|EBADF
operator|)
return|;
return|return
operator|(
name|VOP_FSYNC
argument_list|(
name|ovp
argument_list|,
name|ap
operator|->
name|a_waitfor
argument_list|,
name|ap
operator|->
name|a_td
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unionfs_remove
parameter_list|(
name|struct
name|vop_remove_args
modifier|*
name|ap
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
name|struct
name|unionfs_node
modifier|*
name|dunp
decl_stmt|;
name|struct
name|unionfs_node
modifier|*
name|unp
decl_stmt|;
name|struct
name|unionfs_mount
modifier|*
name|ump
decl_stmt|;
name|struct
name|vnode
modifier|*
name|udvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|uvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|lvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
decl_stmt|;
name|struct
name|componentname
name|cn
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|UNIONFS_INTERNAL_DEBUG
argument_list|(
literal|"unionfs_remove: enter\n"
argument_list|)
expr_stmt|;
name|KASSERT_UNIONFS_VNODE
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|dunp
operator|=
name|VTOUNIONFS
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
expr_stmt|;
name|udvp
operator|=
name|dunp
operator|->
name|un_uppervp
expr_stmt|;
name|cnp
operator|=
name|ap
operator|->
name|a_cnp
expr_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|a_vp
operator|->
name|v_op
operator|!=
operator|&
name|unionfs_vnodeops
condition|)
block|{
if|if
condition|(
name|ap
operator|->
name|a_vp
operator|->
name|v_type
operator|!=
name|VSOCK
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ump
operator|=
name|NULL
expr_stmt|;
name|vp
operator|=
name|uvp
operator|=
name|lvp
operator|=
name|NULLVP
expr_stmt|;
comment|/* search vnode */
name|VOP_UNLOCK
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|LK_RELEASE
argument_list|)
expr_stmt|;
name|error
operator|=
name|unionfs_relookup
argument_list|(
name|udvp
argument_list|,
operator|&
name|vp
argument_list|,
name|cnp
argument_list|,
operator|&
name|cn
argument_list|,
name|td
argument_list|,
name|cnp
operator|->
name|cn_nameptr
argument_list|,
name|strlen
argument_list|(
name|cnp
operator|->
name|cn_nameptr
argument_list|)
argument_list|,
name|DELETE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|error
operator|!=
name|ENOENT
condition|)
block|{
name|vn_lock
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|vp
operator|==
name|ap
operator|->
name|a_vp
condition|)
block|{
comment|/* target vnode in upper */
name|uvp
operator|=
name|vp
expr_stmt|;
name|vrele
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|path
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* target vnode in lower */
if|if
condition|(
name|vp
operator|!=
name|NULLVP
condition|)
block|{
if|if
condition|(
name|udvp
operator|==
name|vp
condition|)
name|vrele
argument_list|(
name|vp
argument_list|)
expr_stmt|;
else|else
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
name|vn_lock
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
name|lvp
operator|=
name|ap
operator|->
name|a_vp
expr_stmt|;
name|path
operator|=
name|ap
operator|->
name|a_cnp
operator|->
name|cn_nameptr
expr_stmt|;
block|}
block|}
else|else
block|{
name|ump
operator|=
name|MOUNTTOUNIONFSMOUNT
argument_list|(
name|ap
operator|->
name|a_vp
operator|->
name|v_mount
argument_list|)
expr_stmt|;
name|unp
operator|=
name|VTOUNIONFS
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
name|uvp
operator|=
name|unp
operator|->
name|un_uppervp
expr_stmt|;
name|lvp
operator|=
name|unp
operator|->
name|un_lowervp
expr_stmt|;
name|path
operator|=
name|unp
operator|->
name|un_path
expr_stmt|;
block|}
if|if
condition|(
name|udvp
operator|==
name|NULLVP
condition|)
return|return
operator|(
name|EROFS
operator|)
return|;
if|if
condition|(
name|uvp
operator|!=
name|NULLVP
condition|)
block|{
comment|/* 		 * XXX: if the vnode type is VSOCK, it will create whiteout 		 *      after remove. 		 */
if|if
condition|(
name|ump
operator|==
name|NULL
operator|||
name|ump
operator|->
name|um_whitemode
operator|==
name|UNIONFS_WHITE_ALWAYS
operator|||
name|lvp
operator|!=
name|NULLVP
condition|)
name|cnp
operator|->
name|cn_flags
operator||=
name|DOWHITEOUT
expr_stmt|;
name|error
operator|=
name|VOP_REMOVE
argument_list|(
name|udvp
argument_list|,
name|uvp
argument_list|,
name|cnp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lvp
operator|!=
name|NULLVP
condition|)
name|error
operator|=
name|unionfs_mkwhiteout
argument_list|(
name|udvp
argument_list|,
name|cnp
argument_list|,
name|td
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|UNIONFS_INTERNAL_DEBUG
argument_list|(
literal|"unionfs_remove: leave (%d)\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unionfs_link
parameter_list|(
name|struct
name|vop_link_args
modifier|*
name|ap
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|int
name|needrelookup
decl_stmt|;
name|struct
name|unionfs_node
modifier|*
name|dunp
decl_stmt|;
name|struct
name|unionfs_node
modifier|*
name|unp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|udvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|uvp
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|UNIONFS_INTERNAL_DEBUG
argument_list|(
literal|"unionfs_link: enter\n"
argument_list|)
expr_stmt|;
name|KASSERT_UNIONFS_VNODE
argument_list|(
name|ap
operator|->
name|a_tdvp
argument_list|)
expr_stmt|;
name|KASSERT_UNIONFS_VNODE
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|needrelookup
operator|=
literal|0
expr_stmt|;
name|dunp
operator|=
name|VTOUNIONFS
argument_list|(
name|ap
operator|->
name|a_tdvp
argument_list|)
expr_stmt|;
name|unp
operator|=
name|NULL
expr_stmt|;
name|udvp
operator|=
name|dunp
operator|->
name|un_uppervp
expr_stmt|;
name|uvp
operator|=
name|NULLVP
expr_stmt|;
name|cnp
operator|=
name|ap
operator|->
name|a_cnp
expr_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
if|if
condition|(
name|udvp
operator|==
name|NULLVP
condition|)
return|return
operator|(
name|EROFS
operator|)
return|;
if|if
condition|(
name|ap
operator|->
name|a_vp
operator|->
name|v_op
operator|!=
operator|&
name|unionfs_vnodeops
condition|)
name|uvp
operator|=
name|ap
operator|->
name|a_vp
expr_stmt|;
else|else
block|{
name|unp
operator|=
name|VTOUNIONFS
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|unp
operator|->
name|un_uppervp
operator|==
name|NULLVP
condition|)
block|{
if|if
condition|(
name|ap
operator|->
name|a_vp
operator|->
name|v_type
operator|!=
name|VREG
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
name|error
operator|=
name|unionfs_copyfile
argument_list|(
name|unp
argument_list|,
literal|1
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|needrelookup
operator|=
literal|1
expr_stmt|;
block|}
name|uvp
operator|=
name|unp
operator|->
name|un_uppervp
expr_stmt|;
block|}
if|if
condition|(
name|needrelookup
operator|!=
literal|0
condition|)
name|error
operator|=
name|unionfs_relookup_for_create
argument_list|(
name|ap
operator|->
name|a_tdvp
argument_list|,
name|cnp
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|VOP_LINK
argument_list|(
name|udvp
argument_list|,
name|uvp
argument_list|,
name|cnp
argument_list|)
expr_stmt|;
name|UNIONFS_INTERNAL_DEBUG
argument_list|(
literal|"unionfs_link: leave (%d)\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unionfs_rename
parameter_list|(
name|struct
name|vop_rename_args
modifier|*
name|ap
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|vnode
modifier|*
name|fdvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|fvp
decl_stmt|;
name|struct
name|componentname
modifier|*
name|fcnp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|tdvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|tvp
decl_stmt|;
name|struct
name|componentname
modifier|*
name|tcnp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|ltdvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|ltvp
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
comment|/* rename target vnodes */
name|struct
name|vnode
modifier|*
name|rfdvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|rfvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|rtdvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|rtvp
decl_stmt|;
name|int
name|needrelookup
decl_stmt|;
name|struct
name|unionfs_mount
modifier|*
name|ump
decl_stmt|;
name|struct
name|unionfs_node
modifier|*
name|unp
decl_stmt|;
name|UNIONFS_INTERNAL_DEBUG
argument_list|(
literal|"unionfs_rename: enter\n"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|fdvp
operator|=
name|ap
operator|->
name|a_fdvp
expr_stmt|;
name|fvp
operator|=
name|ap
operator|->
name|a_fvp
expr_stmt|;
name|fcnp
operator|=
name|ap
operator|->
name|a_fcnp
expr_stmt|;
name|tdvp
operator|=
name|ap
operator|->
name|a_tdvp
expr_stmt|;
name|tvp
operator|=
name|ap
operator|->
name|a_tvp
expr_stmt|;
name|tcnp
operator|=
name|ap
operator|->
name|a_tcnp
expr_stmt|;
name|ltdvp
operator|=
name|NULLVP
expr_stmt|;
name|ltvp
operator|=
name|NULLVP
expr_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
name|rfdvp
operator|=
name|fdvp
expr_stmt|;
name|rfvp
operator|=
name|fvp
expr_stmt|;
name|rtdvp
operator|=
name|tdvp
expr_stmt|;
name|rtvp
operator|=
name|tvp
expr_stmt|;
name|needrelookup
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
operator|!
operator|(
name|fcnp
operator|->
name|cn_flags
operator|&
name|HASBUF
operator|)
operator|||
operator|!
operator|(
name|tcnp
operator|->
name|cn_flags
operator|&
name|HASBUF
operator|)
condition|)
name|panic
argument_list|(
literal|"unionfs_rename: no name"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* check for cross device rename */
if|if
condition|(
name|fvp
operator|->
name|v_mount
operator|!=
name|tdvp
operator|->
name|v_mount
operator|||
operator|(
name|tvp
operator|!=
name|NULLVP
operator|&&
name|fvp
operator|->
name|v_mount
operator|!=
name|tvp
operator|->
name|v_mount
operator|)
condition|)
block|{
if|if
condition|(
name|fvp
operator|->
name|v_op
operator|!=
operator|&
name|unionfs_vnodeops
condition|)
name|error
operator|=
name|ENODEV
expr_stmt|;
else|else
name|error
operator|=
name|EXDEV
expr_stmt|;
goto|goto
name|unionfs_rename_abort
goto|;
block|}
comment|/* Renaming a file to itself has no effect. */
if|if
condition|(
name|fvp
operator|==
name|tvp
condition|)
goto|goto
name|unionfs_rename_abort
goto|;
comment|/* 	 * from/to vnode is unionfs node. 	 */
name|KASSERT_UNIONFS_VNODE
argument_list|(
name|fdvp
argument_list|)
expr_stmt|;
name|KASSERT_UNIONFS_VNODE
argument_list|(
name|fvp
argument_list|)
expr_stmt|;
name|KASSERT_UNIONFS_VNODE
argument_list|(
name|tdvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tvp
operator|!=
name|NULLVP
condition|)
name|KASSERT_UNIONFS_VNODE
argument_list|(
name|tvp
argument_list|)
expr_stmt|;
name|unp
operator|=
name|VTOUNIONFS
argument_list|(
name|fdvp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UNIONFS_IDBG_RENAME
name|UNIONFS_INTERNAL_DEBUG
argument_list|(
literal|"fdvp=%p, ufdvp=%p, lfdvp=%p\n"
argument_list|,
name|fdvp
argument_list|,
name|unp
operator|->
name|un_uppervp
argument_list|,
name|unp
operator|->
name|un_lowervp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|unp
operator|->
name|un_uppervp
operator|==
name|NULLVP
condition|)
block|{
name|error
operator|=
name|ENODEV
expr_stmt|;
goto|goto
name|unionfs_rename_abort
goto|;
block|}
name|rfdvp
operator|=
name|unp
operator|->
name|un_uppervp
expr_stmt|;
name|vref
argument_list|(
name|rfdvp
argument_list|)
expr_stmt|;
name|unp
operator|=
name|VTOUNIONFS
argument_list|(
name|fvp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UNIONFS_IDBG_RENAME
name|UNIONFS_INTERNAL_DEBUG
argument_list|(
literal|"fvp=%p, ufvp=%p, lfvp=%p\n"
argument_list|,
name|fvp
argument_list|,
name|unp
operator|->
name|un_uppervp
argument_list|,
name|unp
operator|->
name|un_lowervp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ump
operator|=
name|MOUNTTOUNIONFSMOUNT
argument_list|(
name|fvp
operator|->
name|v_mount
argument_list|)
expr_stmt|;
if|if
condition|(
name|unp
operator|->
name|un_uppervp
operator|==
name|NULLVP
condition|)
block|{
switch|switch
condition|(
name|fvp
operator|->
name|v_type
condition|)
block|{
case|case
name|VREG
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|vn_lock
argument_list|(
name|fvp
argument_list|,
name|LK_EXCLUSIVE
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|unionfs_rename_abort
goto|;
name|error
operator|=
name|unionfs_copyfile
argument_list|(
name|unp
argument_list|,
literal|1
argument_list|,
name|fcnp
operator|->
name|cn_cred
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|fvp
argument_list|,
name|LK_RELEASE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|unionfs_rename_abort
goto|;
break|break;
case|case
name|VDIR
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|vn_lock
argument_list|(
name|fvp
argument_list|,
name|LK_EXCLUSIVE
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|unionfs_rename_abort
goto|;
name|error
operator|=
name|unionfs_mkshadowdir
argument_list|(
name|ump
argument_list|,
name|rfdvp
argument_list|,
name|unp
argument_list|,
name|fcnp
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|fvp
argument_list|,
name|LK_RELEASE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|unionfs_rename_abort
goto|;
break|break;
default|default:
name|error
operator|=
name|ENODEV
expr_stmt|;
goto|goto
name|unionfs_rename_abort
goto|;
block|}
name|needrelookup
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|unp
operator|->
name|un_lowervp
operator|!=
name|NULLVP
condition|)
name|fcnp
operator|->
name|cn_flags
operator||=
name|DOWHITEOUT
expr_stmt|;
name|rfvp
operator|=
name|unp
operator|->
name|un_uppervp
expr_stmt|;
name|vref
argument_list|(
name|rfvp
argument_list|)
expr_stmt|;
name|unp
operator|=
name|VTOUNIONFS
argument_list|(
name|tdvp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UNIONFS_IDBG_RENAME
name|UNIONFS_INTERNAL_DEBUG
argument_list|(
literal|"tdvp=%p, utdvp=%p, ltdvp=%p\n"
argument_list|,
name|tdvp
argument_list|,
name|unp
operator|->
name|un_uppervp
argument_list|,
name|unp
operator|->
name|un_lowervp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|unp
operator|->
name|un_uppervp
operator|==
name|NULLVP
condition|)
block|{
name|error
operator|=
name|ENODEV
expr_stmt|;
goto|goto
name|unionfs_rename_abort
goto|;
block|}
name|rtdvp
operator|=
name|unp
operator|->
name|un_uppervp
expr_stmt|;
name|ltdvp
operator|=
name|unp
operator|->
name|un_lowervp
expr_stmt|;
name|vref
argument_list|(
name|rtdvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdvp
operator|==
name|tvp
condition|)
block|{
name|rtvp
operator|=
name|rtdvp
expr_stmt|;
name|vref
argument_list|(
name|rtvp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tvp
operator|!=
name|NULLVP
condition|)
block|{
name|unp
operator|=
name|VTOUNIONFS
argument_list|(
name|tvp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UNIONFS_IDBG_RENAME
name|UNIONFS_INTERNAL_DEBUG
argument_list|(
literal|"tvp=%p, utvp=%p, ltvp=%p\n"
argument_list|,
name|tvp
argument_list|,
name|unp
operator|->
name|un_uppervp
argument_list|,
name|unp
operator|->
name|un_lowervp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|unp
operator|->
name|un_uppervp
operator|==
name|NULLVP
condition|)
name|rtvp
operator|=
name|NULLVP
expr_stmt|;
else|else
block|{
if|if
condition|(
name|tvp
operator|->
name|v_type
operator|==
name|VDIR
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|unionfs_rename_abort
goto|;
block|}
name|rtvp
operator|=
name|unp
operator|->
name|un_uppervp
expr_stmt|;
name|ltvp
operator|=
name|unp
operator|->
name|un_lowervp
expr_stmt|;
name|vref
argument_list|(
name|rtvp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rfvp
operator|==
name|rtvp
condition|)
goto|goto
name|unionfs_rename_abort
goto|;
if|if
condition|(
name|needrelookup
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|vn_lock
argument_list|(
name|fdvp
argument_list|,
name|LK_EXCLUSIVE
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|unionfs_rename_abort
goto|;
name|error
operator|=
name|unionfs_relookup_for_delete
argument_list|(
name|fdvp
argument_list|,
name|fcnp
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|fdvp
argument_list|,
name|LK_RELEASE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|unionfs_rename_abort
goto|;
comment|/* Locke of tvp is canceled in order to avoid recursive lock. */
if|if
condition|(
name|tvp
operator|!=
name|NULLVP
operator|&&
name|tvp
operator|!=
name|tdvp
condition|)
name|VOP_UNLOCK
argument_list|(
name|tvp
argument_list|,
name|LK_RELEASE
argument_list|)
expr_stmt|;
name|error
operator|=
name|unionfs_relookup_for_rename
argument_list|(
name|tdvp
argument_list|,
name|tcnp
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|tvp
operator|!=
name|NULLVP
operator|&&
name|tvp
operator|!=
name|tdvp
condition|)
name|vn_lock
argument_list|(
name|tvp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|unionfs_rename_abort
goto|;
block|}
name|error
operator|=
name|VOP_RENAME
argument_list|(
name|rfdvp
argument_list|,
name|rfvp
argument_list|,
name|fcnp
argument_list|,
name|rtdvp
argument_list|,
name|rtvp
argument_list|,
name|tcnp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|rtvp
operator|!=
name|NULLVP
operator|&&
name|rtvp
operator|->
name|v_type
operator|==
name|VDIR
condition|)
name|cache_purge
argument_list|(
name|tdvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fvp
operator|->
name|v_type
operator|==
name|VDIR
operator|&&
name|fdvp
operator|!=
name|tdvp
condition|)
name|cache_purge
argument_list|(
name|fdvp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ltdvp
operator|!=
name|NULLVP
condition|)
name|VOP_UNLOCK
argument_list|(
name|ltdvp
argument_list|,
name|LK_RELEASE
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdvp
operator|!=
name|rtdvp
condition|)
name|vrele
argument_list|(
name|tdvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ltvp
operator|!=
name|NULLVP
condition|)
name|VOP_UNLOCK
argument_list|(
name|ltvp
argument_list|,
name|LK_RELEASE
argument_list|)
expr_stmt|;
if|if
condition|(
name|tvp
operator|!=
name|rtvp
operator|&&
name|tvp
operator|!=
name|NULLVP
condition|)
block|{
if|if
condition|(
name|rtvp
operator|==
name|NULLVP
condition|)
name|vput
argument_list|(
name|tvp
argument_list|)
expr_stmt|;
else|else
name|vrele
argument_list|(
name|tvp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fdvp
operator|!=
name|rfdvp
condition|)
name|vrele
argument_list|(
name|fdvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fvp
operator|!=
name|rfvp
condition|)
name|vrele
argument_list|(
name|fvp
argument_list|)
expr_stmt|;
name|UNIONFS_INTERNAL_DEBUG
argument_list|(
literal|"unionfs_rename: leave (%d)\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
name|unionfs_rename_abort
label|:
name|vput
argument_list|(
name|tdvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdvp
operator|!=
name|rtdvp
condition|)
name|vrele
argument_list|(
name|rtdvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tvp
operator|!=
name|NULLVP
condition|)
block|{
if|if
condition|(
name|tdvp
operator|!=
name|tvp
condition|)
name|vput
argument_list|(
name|tvp
argument_list|)
expr_stmt|;
else|else
name|vrele
argument_list|(
name|tvp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tvp
operator|!=
name|rtvp
operator|&&
name|rtvp
operator|!=
name|NULLVP
condition|)
name|vrele
argument_list|(
name|rtvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdvp
operator|!=
name|rfdvp
condition|)
name|vrele
argument_list|(
name|rfdvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fvp
operator|!=
name|rfvp
condition|)
name|vrele
argument_list|(
name|rfvp
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|fdvp
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|fvp
argument_list|)
expr_stmt|;
name|UNIONFS_INTERNAL_DEBUG
argument_list|(
literal|"unionfs_rename: leave (%d)\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unionfs_mkdir
parameter_list|(
name|struct
name|vop_mkdir_args
modifier|*
name|ap
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|int
name|lkflags
decl_stmt|;
name|struct
name|unionfs_node
modifier|*
name|dunp
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|vnode
modifier|*
name|udvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|uvp
decl_stmt|;
name|struct
name|vattr
name|va
decl_stmt|;
name|UNIONFS_INTERNAL_DEBUG
argument_list|(
literal|"unionfs_mkdir: enter\n"
argument_list|)
expr_stmt|;
name|KASSERT_UNIONFS_VNODE
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
expr_stmt|;
name|error
operator|=
name|EROFS
expr_stmt|;
name|dunp
operator|=
name|VTOUNIONFS
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
expr_stmt|;
name|cnp
operator|=
name|ap
operator|->
name|a_cnp
expr_stmt|;
name|lkflags
operator|=
name|cnp
operator|->
name|cn_lkflags
expr_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
name|udvp
operator|=
name|dunp
operator|->
name|un_uppervp
expr_stmt|;
if|if
condition|(
name|udvp
operator|!=
name|NULLVP
condition|)
block|{
comment|/* check opaque */
if|if
condition|(
operator|!
operator|(
name|cnp
operator|->
name|cn_flags
operator|&
name|ISWHITEOUT
operator|)
condition|)
block|{
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|udvp
argument_list|,
operator|&
name|va
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|va
operator|.
name|va_flags
operator|&
name|OPAQUE
condition|)
name|cnp
operator|->
name|cn_flags
operator||=
name|ISWHITEOUT
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|VOP_MKDIR
argument_list|(
name|udvp
argument_list|,
operator|&
name|uvp
argument_list|,
name|cnp
argument_list|,
name|ap
operator|->
name|a_vap
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|VOP_UNLOCK
argument_list|(
name|uvp
argument_list|,
name|LK_RELEASE
argument_list|)
expr_stmt|;
name|cnp
operator|->
name|cn_lkflags
operator|=
name|LK_EXCLUSIVE
expr_stmt|;
name|error
operator|=
name|unionfs_nodeget
argument_list|(
name|ap
operator|->
name|a_dvp
operator|->
name|v_mount
argument_list|,
name|uvp
argument_list|,
name|NULLVP
argument_list|,
name|ap
operator|->
name|a_dvp
argument_list|,
name|ap
operator|->
name|a_vpp
argument_list|,
name|cnp
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|cnp
operator|->
name|cn_lkflags
operator|=
name|lkflags
expr_stmt|;
name|vrele
argument_list|(
name|uvp
argument_list|)
expr_stmt|;
block|}
block|}
name|UNIONFS_INTERNAL_DEBUG
argument_list|(
literal|"unionfs_mkdir: leave (%d)\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unionfs_rmdir
parameter_list|(
name|struct
name|vop_rmdir_args
modifier|*
name|ap
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|unionfs_node
modifier|*
name|dunp
decl_stmt|;
name|struct
name|unionfs_node
modifier|*
name|unp
decl_stmt|;
name|struct
name|unionfs_mount
modifier|*
name|ump
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|vnode
modifier|*
name|udvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|uvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|lvp
decl_stmt|;
name|UNIONFS_INTERNAL_DEBUG
argument_list|(
literal|"unionfs_rmdir: enter\n"
argument_list|)
expr_stmt|;
name|KASSERT_UNIONFS_VNODE
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
expr_stmt|;
name|KASSERT_UNIONFS_VNODE
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|dunp
operator|=
name|VTOUNIONFS
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
expr_stmt|;
name|unp
operator|=
name|VTOUNIONFS
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
name|cnp
operator|=
name|ap
operator|->
name|a_cnp
expr_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
name|udvp
operator|=
name|dunp
operator|->
name|un_uppervp
expr_stmt|;
name|uvp
operator|=
name|unp
operator|->
name|un_uppervp
expr_stmt|;
name|lvp
operator|=
name|unp
operator|->
name|un_lowervp
expr_stmt|;
if|if
condition|(
name|udvp
operator|==
name|NULLVP
condition|)
return|return
operator|(
name|EROFS
operator|)
return|;
if|if
condition|(
name|udvp
operator|==
name|uvp
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
if|if
condition|(
name|uvp
operator|!=
name|NULLVP
condition|)
block|{
if|if
condition|(
name|lvp
operator|!=
name|NULLVP
condition|)
block|{
name|error
operator|=
name|unionfs_check_rmdir
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
name|ump
operator|=
name|MOUNTTOUNIONFSMOUNT
argument_list|(
name|ap
operator|->
name|a_vp
operator|->
name|v_mount
argument_list|)
expr_stmt|;
if|if
condition|(
name|ump
operator|->
name|um_whitemode
operator|==
name|UNIONFS_WHITE_ALWAYS
operator|||
name|lvp
operator|!=
name|NULLVP
condition|)
name|cnp
operator|->
name|cn_flags
operator||=
name|DOWHITEOUT
expr_stmt|;
name|error
operator|=
name|unionfs_relookup_for_delete
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|,
name|cnp
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|VOP_RMDIR
argument_list|(
name|udvp
argument_list|,
name|uvp
argument_list|,
name|cnp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lvp
operator|!=
name|NULLVP
condition|)
name|error
operator|=
name|unionfs_mkwhiteout
argument_list|(
name|udvp
argument_list|,
name|cnp
argument_list|,
name|td
argument_list|,
name|unp
operator|->
name|un_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|cache_purge
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
expr_stmt|;
name|cache_purge
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
block|}
name|UNIONFS_INTERNAL_DEBUG
argument_list|(
literal|"unionfs_rmdir: leave (%d)\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unionfs_symlink
parameter_list|(
name|struct
name|vop_symlink_args
modifier|*
name|ap
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|int
name|lkflags
decl_stmt|;
name|struct
name|unionfs_node
modifier|*
name|dunp
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|vnode
modifier|*
name|udvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|uvp
decl_stmt|;
name|UNIONFS_INTERNAL_DEBUG
argument_list|(
literal|"unionfs_symlink: enter\n"
argument_list|)
expr_stmt|;
name|KASSERT_UNIONFS_VNODE
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
expr_stmt|;
name|error
operator|=
name|EROFS
expr_stmt|;
name|dunp
operator|=
name|VTOUNIONFS
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
expr_stmt|;
name|cnp
operator|=
name|ap
operator|->
name|a_cnp
expr_stmt|;
name|lkflags
operator|=
name|cnp
operator|->
name|cn_lkflags
expr_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
name|udvp
operator|=
name|dunp
operator|->
name|un_uppervp
expr_stmt|;
if|if
condition|(
name|udvp
operator|!=
name|NULLVP
condition|)
block|{
name|error
operator|=
name|VOP_SYMLINK
argument_list|(
name|udvp
argument_list|,
operator|&
name|uvp
argument_list|,
name|cnp
argument_list|,
name|ap
operator|->
name|a_vap
argument_list|,
name|ap
operator|->
name|a_target
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|VOP_UNLOCK
argument_list|(
name|uvp
argument_list|,
name|LK_RELEASE
argument_list|)
expr_stmt|;
name|cnp
operator|->
name|cn_lkflags
operator|=
name|LK_EXCLUSIVE
expr_stmt|;
name|error
operator|=
name|unionfs_nodeget
argument_list|(
name|ap
operator|->
name|a_dvp
operator|->
name|v_mount
argument_list|,
name|uvp
argument_list|,
name|NULLVP
argument_list|,
name|ap
operator|->
name|a_dvp
argument_list|,
name|ap
operator|->
name|a_vpp
argument_list|,
name|cnp
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|cnp
operator|->
name|cn_lkflags
operator|=
name|lkflags
expr_stmt|;
name|vrele
argument_list|(
name|uvp
argument_list|)
expr_stmt|;
block|}
block|}
name|UNIONFS_INTERNAL_DEBUG
argument_list|(
literal|"unionfs_symlink: leave (%d)\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unionfs_readdir
parameter_list|(
name|struct
name|vop_readdir_args
modifier|*
name|ap
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|int
name|eofflag
decl_stmt|;
name|int
name|locked
decl_stmt|;
name|int
name|uio_offset_bk
decl_stmt|;
name|struct
name|unionfs_node
modifier|*
name|unp
decl_stmt|;
name|struct
name|unionfs_node_status
modifier|*
name|unsp
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|uvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|lvp
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|vattr
name|va
decl_stmt|;
name|int
name|ncookies_bk
decl_stmt|;
name|u_long
modifier|*
name|cookies_bk
decl_stmt|;
name|UNIONFS_INTERNAL_DEBUG
argument_list|(
literal|"unionfs_readdir: enter\n"
argument_list|)
expr_stmt|;
name|KASSERT_UNIONFS_VNODE
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|eofflag
operator|=
literal|0
expr_stmt|;
name|locked
operator|=
literal|0
expr_stmt|;
name|uio_offset_bk
operator|=
literal|0
expr_stmt|;
name|uio
operator|=
name|ap
operator|->
name|a_uio
expr_stmt|;
name|uvp
operator|=
name|NULLVP
expr_stmt|;
name|lvp
operator|=
name|NULLVP
expr_stmt|;
name|td
operator|=
name|uio
operator|->
name|uio_td
expr_stmt|;
name|ncookies_bk
operator|=
literal|0
expr_stmt|;
name|cookies_bk
operator|=
name|NULL
expr_stmt|;
name|vp
operator|=
name|ap
operator|->
name|a_vp
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|VDIR
condition|)
return|return
operator|(
name|ENOTDIR
operator|)
return|;
comment|/* check the open count. unionfs needs to open before readdir. */
if|if
condition|(
name|VOP_ISLOCKED
argument_list|(
name|vp
argument_list|)
operator|!=
name|LK_EXCLUSIVE
condition|)
block|{
if|if
condition|(
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_UPGRADE
argument_list|)
operator|!=
literal|0
condition|)
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
name|locked
operator|=
literal|1
expr_stmt|;
block|}
name|unp
operator|=
name|VTOUNIONFS
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|unp
operator|==
name|NULL
condition|)
name|error
operator|=
name|EBADF
expr_stmt|;
else|else
block|{
name|uvp
operator|=
name|unp
operator|->
name|un_uppervp
expr_stmt|;
name|lvp
operator|=
name|unp
operator|->
name|un_lowervp
expr_stmt|;
name|unionfs_get_node_status
argument_list|(
name|unp
argument_list|,
name|td
argument_list|,
operator|&
name|unsp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|uvp
operator|!=
name|NULLVP
operator|&&
name|unsp
operator|->
name|uns_upper_opencnt
operator|<=
literal|0
operator|)
operator|||
operator|(
name|lvp
operator|!=
name|NULLVP
operator|&&
name|unsp
operator|->
name|uns_lower_opencnt
operator|<=
literal|0
operator|)
condition|)
block|{
name|unionfs_tryrem_node_status
argument_list|(
name|unp
argument_list|,
name|unsp
argument_list|)
expr_stmt|;
name|error
operator|=
name|EBADF
expr_stmt|;
block|}
block|}
if|if
condition|(
name|locked
condition|)
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_DOWNGRADE
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|unionfs_readdir_exit
goto|;
comment|/* check opaque */
if|if
condition|(
name|uvp
operator|!=
name|NULLVP
operator|&&
name|lvp
operator|!=
name|NULLVP
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|uvp
argument_list|,
operator|&
name|va
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|unionfs_readdir_exit
goto|;
if|if
condition|(
name|va
operator|.
name|va_flags
operator|&
name|OPAQUE
condition|)
name|lvp
operator|=
name|NULLVP
expr_stmt|;
block|}
comment|/* upper only */
if|if
condition|(
name|uvp
operator|!=
name|NULLVP
operator|&&
name|lvp
operator|==
name|NULLVP
condition|)
block|{
name|error
operator|=
name|VOP_READDIR
argument_list|(
name|uvp
argument_list|,
name|uio
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_eofflag
argument_list|,
name|ap
operator|->
name|a_ncookies
argument_list|,
name|ap
operator|->
name|a_cookies
argument_list|)
expr_stmt|;
name|unsp
operator|->
name|uns_readdir_status
operator|=
literal|0
expr_stmt|;
goto|goto
name|unionfs_readdir_exit
goto|;
block|}
comment|/* lower only */
if|if
condition|(
name|uvp
operator|==
name|NULLVP
operator|&&
name|lvp
operator|!=
name|NULLVP
condition|)
block|{
name|error
operator|=
name|VOP_READDIR
argument_list|(
name|lvp
argument_list|,
name|uio
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_eofflag
argument_list|,
name|ap
operator|->
name|a_ncookies
argument_list|,
name|ap
operator|->
name|a_cookies
argument_list|)
expr_stmt|;
name|unsp
operator|->
name|uns_readdir_status
operator|=
literal|2
expr_stmt|;
goto|goto
name|unionfs_readdir_exit
goto|;
block|}
comment|/* 	 * readdir upper and lower 	 */
name|KASSERT
argument_list|(
name|uvp
operator|!=
name|NULLVP
argument_list|,
operator|(
literal|"unionfs_readdir: null upper vp"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|lvp
operator|!=
name|NULLVP
argument_list|,
operator|(
literal|"unionfs_readdir: null lower vp"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|uio
operator|->
name|uio_offset
operator|==
literal|0
condition|)
name|unsp
operator|->
name|uns_readdir_status
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|unsp
operator|->
name|uns_readdir_status
operator|==
literal|0
condition|)
block|{
comment|/* read upper */
name|error
operator|=
name|VOP_READDIR
argument_list|(
name|uvp
argument_list|,
name|uio
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
operator|&
name|eofflag
argument_list|,
name|ap
operator|->
name|a_ncookies
argument_list|,
name|ap
operator|->
name|a_cookies
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|eofflag
operator|==
literal|0
condition|)
goto|goto
name|unionfs_readdir_exit
goto|;
name|unsp
operator|->
name|uns_readdir_status
operator|=
literal|1
expr_stmt|;
comment|/* 		 * UFS(and other FS) needs size of uio_resid larger than 		 * DIRBLKSIZ. 		 * size of DIRBLKSIZ equals DEV_BSIZE. 		 * (see: ufs/ufs/ufs_vnops.c ufs_readdir func , ufs/ufs/dir.h) 		 */
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|<=
operator|(
name|uio
operator|->
name|uio_resid
operator|&
operator|(
name|DEV_BSIZE
operator|-
literal|1
operator|)
operator|)
condition|)
goto|goto
name|unionfs_readdir_exit
goto|;
comment|/* 		 * Backup cookies. 		 * It prepares to readdir in lower. 		 */
if|if
condition|(
name|ap
operator|->
name|a_ncookies
operator|!=
name|NULL
condition|)
block|{
name|ncookies_bk
operator|=
operator|*
operator|(
name|ap
operator|->
name|a_ncookies
operator|)
expr_stmt|;
operator|*
operator|(
name|ap
operator|->
name|a_ncookies
operator|)
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ap
operator|->
name|a_cookies
operator|!=
name|NULL
condition|)
block|{
name|cookies_bk
operator|=
operator|*
operator|(
name|ap
operator|->
name|a_cookies
operator|)
expr_stmt|;
operator|*
operator|(
name|ap
operator|->
name|a_cookies
operator|)
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* initialize for readdir in lower */
if|if
condition|(
name|unsp
operator|->
name|uns_readdir_status
operator|==
literal|1
condition|)
block|{
name|unsp
operator|->
name|uns_readdir_status
operator|=
literal|2
expr_stmt|;
comment|/* 		 * Backup uio_offset. See the comment after the 		 * VOP_READDIR call on the lower layer. 		 */
name|uio_offset_bk
operator|=
name|uio
operator|->
name|uio_offset
expr_stmt|;
name|uio
operator|->
name|uio_offset
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|lvp
operator|==
name|NULLVP
condition|)
block|{
name|error
operator|=
name|EBADF
expr_stmt|;
goto|goto
name|unionfs_readdir_exit
goto|;
block|}
comment|/* read lower */
name|error
operator|=
name|VOP_READDIR
argument_list|(
name|lvp
argument_list|,
name|uio
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_eofflag
argument_list|,
name|ap
operator|->
name|a_ncookies
argument_list|,
name|ap
operator|->
name|a_cookies
argument_list|)
expr_stmt|;
comment|/* 	 * We can't return an uio_offset of 0: this would trigger an 	 * infinite loop, because the next call to unionfs_readdir would 	 * always restart with the upper layer (uio_offset == 0) and 	 * always return some data. 	 * 	 * This happens when the lower layer root directory is removed. 	 * (A root directory deleting of unionfs should not be permitted. 	 *  But current VFS can not do it.) 	 */
if|if
condition|(
name|uio
operator|->
name|uio_offset
operator|==
literal|0
condition|)
name|uio
operator|->
name|uio_offset
operator|=
name|uio_offset_bk
expr_stmt|;
if|if
condition|(
name|cookies_bk
operator|!=
name|NULL
condition|)
block|{
comment|/* merge cookies */
name|int
name|size
decl_stmt|;
name|u_long
modifier|*
name|newcookies
decl_stmt|,
modifier|*
name|pos
decl_stmt|;
name|size
operator|=
operator|*
operator|(
name|ap
operator|->
name|a_ncookies
operator|)
operator|+
name|ncookies_bk
expr_stmt|;
name|newcookies
operator|=
operator|(
name|u_long
operator|*
operator|)
name|malloc
argument_list|(
name|size
operator|*
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|pos
operator|=
name|newcookies
expr_stmt|;
name|memcpy
argument_list|(
name|pos
argument_list|,
name|cookies_bk
argument_list|,
name|ncookies_bk
operator|*
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|ncookies_bk
expr_stmt|;
name|memcpy
argument_list|(
name|pos
argument_list|,
operator|*
operator|(
name|ap
operator|->
name|a_cookies
operator|)
argument_list|,
operator|*
operator|(
name|ap
operator|->
name|a_ncookies
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cookies_bk
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|*
operator|(
name|ap
operator|->
name|a_cookies
operator|)
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
operator|*
operator|(
name|ap
operator|->
name|a_ncookies
operator|)
operator|=
name|size
expr_stmt|;
operator|*
operator|(
name|ap
operator|->
name|a_cookies
operator|)
operator|=
name|newcookies
expr_stmt|;
block|}
name|unionfs_readdir_exit
label|:
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|ap
operator|->
name|a_eofflag
operator|!=
name|NULL
condition|)
operator|*
operator|(
name|ap
operator|->
name|a_eofflag
operator|)
operator|=
literal|1
expr_stmt|;
name|UNIONFS_INTERNAL_DEBUG
argument_list|(
literal|"unionfs_readdir: leave (%d)\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unionfs_readlink
parameter_list|(
name|struct
name|vop_readlink_args
modifier|*
name|ap
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|unionfs_node
modifier|*
name|unp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|UNIONFS_INTERNAL_DEBUG
argument_list|(
literal|"unionfs_readlink: enter\n"
argument_list|)
expr_stmt|;
name|KASSERT_UNIONFS_VNODE
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
name|unp
operator|=
name|VTOUNIONFS
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
name|vp
operator|=
operator|(
name|unp
operator|->
name|un_uppervp
operator|!=
name|NULLVP
condition|?
name|unp
operator|->
name|un_uppervp
else|:
name|unp
operator|->
name|un_lowervp
operator|)
expr_stmt|;
name|error
operator|=
name|VOP_READLINK
argument_list|(
name|vp
argument_list|,
name|ap
operator|->
name|a_uio
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|)
expr_stmt|;
name|UNIONFS_INTERNAL_DEBUG
argument_list|(
literal|"unionfs_readlink: leave (%d)\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unionfs_getwritemount
parameter_list|(
name|struct
name|vop_getwritemount_args
modifier|*
name|ap
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|vnode
modifier|*
name|uvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|UNIONFS_INTERNAL_DEBUG
argument_list|(
literal|"unionfs_getwritemount: enter\n"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|vp
operator|=
name|ap
operator|->
name|a_vp
expr_stmt|;
if|if
condition|(
name|vp
operator|==
name|NULLVP
operator|||
operator|(
name|vp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
operator|)
condition|)
return|return
operator|(
name|EACCES
operator|)
return|;
name|KASSERT_UNIONFS_VNODE
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|uvp
operator|=
name|UNIONFSVPTOUPPERVP
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|uvp
operator|==
name|NULLVP
operator|&&
name|VREG
operator|==
name|vp
operator|->
name|v_type
condition|)
name|uvp
operator|=
name|UNIONFSVPTOUPPERVP
argument_list|(
name|VTOUNIONFS
argument_list|(
name|vp
argument_list|)
operator|->
name|un_dvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|uvp
operator|!=
name|NULLVP
condition|)
name|error
operator|=
name|VOP_GETWRITEMOUNT
argument_list|(
name|uvp
argument_list|,
name|ap
operator|->
name|a_mpp
argument_list|)
expr_stmt|;
else|else
block|{
name|VI_LOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_iflag
operator|&
name|VI_FREE
condition|)
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
else|else
name|error
operator|=
name|EACCES
expr_stmt|;
name|VI_UNLOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
name|UNIONFS_INTERNAL_DEBUG
argument_list|(
literal|"unionfs_getwritemount: leave (%d)\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unionfs_inactive
parameter_list|(
name|struct
name|vop_inactive_args
modifier|*
name|ap
parameter_list|)
block|{
name|ap
operator|->
name|a_vp
operator|->
name|v_object
operator|=
name|NULL
expr_stmt|;
name|vrecycle
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unionfs_reclaim
parameter_list|(
name|struct
name|vop_reclaim_args
modifier|*
name|ap
parameter_list|)
block|{
comment|/* UNIONFS_INTERNAL_DEBUG("unionfs_reclaim: enter\n"); */
name|unionfs_noderem
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|ap
operator|->
name|a_td
argument_list|)
expr_stmt|;
comment|/* UNIONFS_INTERNAL_DEBUG("unionfs_reclaim: leave\n"); */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unionfs_print
parameter_list|(
name|struct
name|vop_print_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|unionfs_node
modifier|*
name|unp
decl_stmt|;
comment|/* struct unionfs_node_status *unsp; */
name|unp
operator|=
name|VTOUNIONFS
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
comment|/* unionfs_get_node_status(unp, curthread,&unsp); */
name|printf
argument_list|(
literal|"unionfs_vp=%p, uppervp=%p, lowervp=%p\n"
argument_list|,
name|ap
operator|->
name|a_vp
argument_list|,
name|unp
operator|->
name|un_uppervp
argument_list|,
name|unp
operator|->
name|un_lowervp
argument_list|)
expr_stmt|;
comment|/* 	printf("unionfs opencnt: uppervp=%d, lowervp=%d\n", 	    unsp->uns_upper_opencnt, unsp->uns_lower_opencnt); 	*/
if|if
condition|(
name|unp
operator|->
name|un_uppervp
operator|!=
name|NULLVP
condition|)
name|vprint
argument_list|(
literal|"unionfs: upper"
argument_list|,
name|unp
operator|->
name|un_uppervp
argument_list|)
expr_stmt|;
if|if
condition|(
name|unp
operator|->
name|un_lowervp
operator|!=
name|NULLVP
condition|)
name|vprint
argument_list|(
literal|"unionfs: lower"
argument_list|,
name|unp
operator|->
name|un_lowervp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unionfs_islocked
parameter_list|(
name|struct
name|vop_islocked_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|unionfs_node
modifier|*
name|unp
decl_stmt|;
name|KASSERT_UNIONFS_VNODE
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
name|unp
operator|=
name|VTOUNIONFS
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|unp
operator|==
name|NULL
condition|)
return|return
operator|(
name|vop_stdislocked
argument_list|(
name|ap
argument_list|)
operator|)
return|;
if|if
condition|(
name|unp
operator|->
name|un_uppervp
operator|!=
name|NULLVP
condition|)
return|return
operator|(
name|VOP_ISLOCKED
argument_list|(
name|unp
operator|->
name|un_uppervp
argument_list|)
operator|)
return|;
if|if
condition|(
name|unp
operator|->
name|un_lowervp
operator|!=
name|NULLVP
condition|)
return|return
operator|(
name|VOP_ISLOCKED
argument_list|(
name|unp
operator|->
name|un_lowervp
argument_list|)
operator|)
return|;
return|return
operator|(
name|vop_stdislocked
argument_list|(
name|ap
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unionfs_get_llt_revlock
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|revlock
decl_stmt|;
name|revlock
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|flags
operator|&
name|LK_TYPE_MASK
condition|)
block|{
case|case
name|LK_SHARED
case|:
if|if
condition|(
name|VOP_ISLOCKED
argument_list|(
name|vp
argument_list|)
operator|==
name|LK_EXCLUSIVE
condition|)
name|revlock
operator|=
name|LK_UPGRADE
expr_stmt|;
else|else
name|revlock
operator|=
name|LK_RELEASE
expr_stmt|;
break|break;
case|case
name|LK_EXCLUSIVE
case|:
case|case
name|LK_UPGRADE
case|:
name|revlock
operator|=
name|LK_RELEASE
expr_stmt|;
break|break;
case|case
name|LK_DOWNGRADE
case|:
name|revlock
operator|=
name|LK_UPGRADE
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
operator|(
name|revlock
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The state of an acquired lock is adjusted similarly to  * the time of error generating.   * flags: LK_RELEASE or LK_UPGRADE  */
end_comment

begin_function
specifier|static
name|void
name|unionfs_revlock
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
if|if
condition|(
name|flags
operator|&
name|LK_RELEASE
condition|)
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
name|flags
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* UPGRADE */
if|if
condition|(
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|flags
argument_list|)
operator|!=
literal|0
condition|)
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|unionfs_lock
parameter_list|(
name|struct
name|vop_lock1_args
modifier|*
name|ap
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|revlock
decl_stmt|;
name|int
name|interlock
decl_stmt|;
name|int
name|uhold
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|struct
name|unionfs_mount
modifier|*
name|ump
decl_stmt|;
name|struct
name|unionfs_node
modifier|*
name|unp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|uvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|lvp
decl_stmt|;
name|KASSERT_UNIONFS_VNODE
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|interlock
operator|=
literal|1
expr_stmt|;
name|uhold
operator|=
literal|0
expr_stmt|;
name|flags
operator|=
name|ap
operator|->
name|a_flags
expr_stmt|;
name|vp
operator|=
name|ap
operator|->
name|a_vp
expr_stmt|;
if|if
condition|(
name|LK_RELEASE
operator|==
operator|(
name|flags
operator|&
name|LK_TYPE_MASK
operator|)
operator|||
operator|!
operator|(
name|flags
operator|&
name|LK_TYPE_MASK
operator|)
condition|)
return|return
operator|(
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
name|flags
operator||
name|LK_RELEASE
argument_list|)
operator|)
return|;
if|if
condition|(
operator|(
name|flags
operator|&
name|LK_INTERLOCK
operator|)
operator|==
literal|0
condition|)
name|VI_LOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|mp
operator|=
name|vp
operator|->
name|v_mount
expr_stmt|;
if|if
condition|(
name|mp
operator|==
name|NULL
condition|)
goto|goto
name|unionfs_lock_null_vnode
goto|;
name|ump
operator|=
name|MOUNTTOUNIONFSMOUNT
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|unp
operator|=
name|VTOUNIONFS
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ump
operator|==
name|NULL
operator|||
name|unp
operator|==
name|NULL
condition|)
goto|goto
name|unionfs_lock_null_vnode
goto|;
name|lvp
operator|=
name|unp
operator|->
name|un_lowervp
expr_stmt|;
name|uvp
operator|=
name|unp
operator|->
name|un_uppervp
expr_stmt|;
if|if
condition|(
operator|(
name|revlock
operator|=
name|unionfs_get_llt_revlock
argument_list|(
name|vp
argument_list|,
name|flags
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"unknown lock type: 0x%x"
argument_list|,
name|flags
operator|&
name|LK_TYPE_MASK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mp
operator|->
name|mnt_kern_flag
operator|&
name|MNTK_MPSAFE
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|vp
operator|->
name|v_iflag
operator|&
name|VI_OWEINACT
operator|)
operator|!=
literal|0
condition|)
name|flags
operator||=
name|LK_NOWAIT
expr_stmt|;
comment|/* 	 * Sometimes, lower or upper is already exclusive locked. 	 * (ex. vfs_domount: mounted vnode is already locked.) 	 */
if|if
condition|(
operator|(
name|flags
operator|&
name|LK_TYPE_MASK
operator|)
operator|==
name|LK_EXCLUSIVE
operator|&&
name|vp
operator|==
name|ump
operator|->
name|um_rootvp
condition|)
name|flags
operator||=
name|LK_CANRECURSE
expr_stmt|;
if|if
condition|(
name|lvp
operator|!=
name|NULLVP
condition|)
block|{
if|if
condition|(
name|uvp
operator|!=
name|NULLVP
operator|&&
name|flags
operator|&
name|LK_UPGRADE
condition|)
block|{
comment|/* Share Lock is once released and a deadlock is avoided.  */
name|VI_LOCK_FLAGS
argument_list|(
name|uvp
argument_list|,
name|MTX_DUPOK
argument_list|)
expr_stmt|;
name|vholdl
argument_list|(
name|uvp
argument_list|)
expr_stmt|;
name|uhold
operator|=
literal|1
expr_stmt|;
name|VI_UNLOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|uvp
argument_list|,
name|LK_RELEASE
operator||
name|LK_INTERLOCK
argument_list|)
expr_stmt|;
name|VI_LOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|unp
operator|=
name|VTOUNIONFS
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|unp
operator|==
name|NULL
condition|)
block|{
comment|/* vnode is released. */
name|VI_UNLOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|lvp
argument_list|,
name|LK_RELEASE
argument_list|)
expr_stmt|;
name|vdrop
argument_list|(
name|uvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
block|}
name|VI_LOCK_FLAGS
argument_list|(
name|lvp
argument_list|,
name|MTX_DUPOK
argument_list|)
expr_stmt|;
name|flags
operator||=
name|LK_INTERLOCK
expr_stmt|;
name|vholdl
argument_list|(
name|lvp
argument_list|)
expr_stmt|;
name|VI_UNLOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|ap
operator|->
name|a_flags
operator|&=
operator|~
name|LK_INTERLOCK
expr_stmt|;
name|error
operator|=
name|VOP_LOCK
argument_list|(
name|lvp
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|VI_LOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|unp
operator|=
name|VTOUNIONFS
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|unp
operator|==
name|NULL
condition|)
block|{
comment|/* vnode is released. */
name|VI_UNLOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|VOP_UNLOCK
argument_list|(
name|lvp
argument_list|,
name|LK_RELEASE
argument_list|)
expr_stmt|;
name|vdrop
argument_list|(
name|lvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|uhold
operator|!=
literal|0
condition|)
name|vdrop
argument_list|(
name|uvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|vop_stdlock
argument_list|(
name|ap
argument_list|)
operator|)
return|;
block|}
block|}
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|uvp
operator|!=
name|NULLVP
condition|)
block|{
if|if
condition|(
name|uhold
operator|&&
name|flags
operator|&
name|LK_UPGRADE
condition|)
block|{
name|flags
operator|&=
operator|~
name|LK_TYPE_MASK
expr_stmt|;
name|flags
operator||=
name|LK_EXCLUSIVE
expr_stmt|;
block|}
name|VI_LOCK_FLAGS
argument_list|(
name|uvp
argument_list|,
name|MTX_DUPOK
argument_list|)
expr_stmt|;
name|flags
operator||=
name|LK_INTERLOCK
expr_stmt|;
if|if
condition|(
name|uhold
operator|==
literal|0
condition|)
block|{
name|vholdl
argument_list|(
name|uvp
argument_list|)
expr_stmt|;
name|uhold
operator|=
literal|1
expr_stmt|;
block|}
name|VI_UNLOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|ap
operator|->
name|a_flags
operator|&=
operator|~
name|LK_INTERLOCK
expr_stmt|;
name|error
operator|=
name|VOP_LOCK
argument_list|(
name|uvp
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|VI_LOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|unp
operator|=
name|VTOUNIONFS
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|unp
operator|==
name|NULL
condition|)
block|{
comment|/* vnode is released. */
name|VI_UNLOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|VOP_UNLOCK
argument_list|(
name|uvp
argument_list|,
name|LK_RELEASE
argument_list|)
expr_stmt|;
name|vdrop
argument_list|(
name|uvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|lvp
operator|!=
name|NULLVP
condition|)
block|{
name|VOP_UNLOCK
argument_list|(
name|lvp
argument_list|,
name|LK_RELEASE
argument_list|)
expr_stmt|;
name|vdrop
argument_list|(
name|lvp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|vop_stdlock
argument_list|(
name|ap
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|lvp
operator|!=
name|NULLVP
condition|)
block|{
comment|/* rollback */
name|VI_UNLOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|unionfs_revlock
argument_list|(
name|lvp
argument_list|,
name|revlock
argument_list|)
expr_stmt|;
name|interlock
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|interlock
condition|)
name|VI_UNLOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|lvp
operator|!=
name|NULLVP
condition|)
name|vdrop
argument_list|(
name|lvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|uhold
operator|!=
literal|0
condition|)
name|vdrop
argument_list|(
name|uvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
name|unionfs_lock_null_vnode
label|:
name|ap
operator|->
name|a_flags
operator||=
name|LK_INTERLOCK
expr_stmt|;
return|return
operator|(
name|vop_stdlock
argument_list|(
name|ap
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unionfs_unlock
parameter_list|(
name|struct
name|vop_unlock_args
modifier|*
name|ap
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|mtxlkflag
decl_stmt|;
name|int
name|uhold
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|lvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|uvp
decl_stmt|;
name|struct
name|unionfs_node
modifier|*
name|unp
decl_stmt|;
name|KASSERT_UNIONFS_VNODE
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|mtxlkflag
operator|=
literal|0
expr_stmt|;
name|uhold
operator|=
literal|0
expr_stmt|;
name|flags
operator|=
name|ap
operator|->
name|a_flags
operator||
name|LK_RELEASE
expr_stmt|;
name|vp
operator|=
name|ap
operator|->
name|a_vp
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|LK_INTERLOCK
operator|)
operator|!=
literal|0
condition|)
name|mtxlkflag
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|mtx_owned
argument_list|(
name|VI_MTX
argument_list|(
name|vp
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|VI_LOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|mtxlkflag
operator|=
literal|2
expr_stmt|;
block|}
name|unp
operator|=
name|VTOUNIONFS
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|unp
operator|==
name|NULL
condition|)
goto|goto
name|unionfs_unlock_null_vnode
goto|;
name|lvp
operator|=
name|unp
operator|->
name|un_lowervp
expr_stmt|;
name|uvp
operator|=
name|unp
operator|->
name|un_uppervp
expr_stmt|;
if|if
condition|(
name|lvp
operator|!=
name|NULLVP
condition|)
block|{
name|VI_LOCK_FLAGS
argument_list|(
name|lvp
argument_list|,
name|MTX_DUPOK
argument_list|)
expr_stmt|;
name|flags
operator||=
name|LK_INTERLOCK
expr_stmt|;
name|vholdl
argument_list|(
name|lvp
argument_list|)
expr_stmt|;
name|VI_UNLOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|ap
operator|->
name|a_flags
operator|&=
operator|~
name|LK_INTERLOCK
expr_stmt|;
name|error
operator|=
name|VOP_UNLOCK
argument_list|(
name|lvp
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|VI_LOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|uvp
operator|!=
name|NULLVP
condition|)
block|{
name|VI_LOCK_FLAGS
argument_list|(
name|uvp
argument_list|,
name|MTX_DUPOK
argument_list|)
expr_stmt|;
name|flags
operator||=
name|LK_INTERLOCK
expr_stmt|;
name|vholdl
argument_list|(
name|uvp
argument_list|)
expr_stmt|;
name|uhold
operator|=
literal|1
expr_stmt|;
name|VI_UNLOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|ap
operator|->
name|a_flags
operator|&=
operator|~
name|LK_INTERLOCK
expr_stmt|;
name|error
operator|=
name|VOP_UNLOCK
argument_list|(
name|uvp
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|VI_LOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
name|VI_UNLOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|lvp
operator|!=
name|NULLVP
condition|)
name|vdrop
argument_list|(
name|lvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|uhold
operator|!=
literal|0
condition|)
name|vdrop
argument_list|(
name|uvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtxlkflag
operator|==
literal|0
condition|)
name|VI_LOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
name|unionfs_unlock_null_vnode
label|:
if|if
condition|(
name|mtxlkflag
operator|==
literal|2
condition|)
name|VI_UNLOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
name|vop_stdunlock
argument_list|(
name|ap
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unionfs_pathconf
parameter_list|(
name|struct
name|vop_pathconf_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|unionfs_node
modifier|*
name|unp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|KASSERT_UNIONFS_VNODE
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
name|unp
operator|=
name|VTOUNIONFS
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
name|vp
operator|=
operator|(
name|unp
operator|->
name|un_uppervp
operator|!=
name|NULLVP
condition|?
name|unp
operator|->
name|un_uppervp
else|:
name|unp
operator|->
name|un_lowervp
operator|)
expr_stmt|;
return|return
operator|(
name|VOP_PATHCONF
argument_list|(
name|vp
argument_list|,
name|ap
operator|->
name|a_name
argument_list|,
name|ap
operator|->
name|a_retval
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unionfs_advlock
parameter_list|(
name|struct
name|vop_advlock_args
modifier|*
name|ap
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|unionfs_node
modifier|*
name|unp
decl_stmt|;
name|struct
name|unionfs_node_status
modifier|*
name|unsp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|uvp
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|UNIONFS_INTERNAL_DEBUG
argument_list|(
literal|"unionfs_advlock: enter\n"
argument_list|)
expr_stmt|;
name|KASSERT_UNIONFS_VNODE
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
name|vp
operator|=
name|ap
operator|->
name|a_vp
expr_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
name|unp
operator|=
name|VTOUNIONFS
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
name|uvp
operator|=
name|unp
operator|->
name|un_uppervp
expr_stmt|;
if|if
condition|(
name|uvp
operator|==
name|NULLVP
condition|)
block|{
name|error
operator|=
name|unionfs_copyfile
argument_list|(
name|unp
argument_list|,
literal|1
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|unionfs_advlock_abort
goto|;
name|uvp
operator|=
name|unp
operator|->
name|un_uppervp
expr_stmt|;
name|unionfs_get_node_status
argument_list|(
name|unp
argument_list|,
name|td
argument_list|,
operator|&
name|unsp
argument_list|)
expr_stmt|;
if|if
condition|(
name|unsp
operator|->
name|uns_lower_opencnt
operator|>
literal|0
condition|)
block|{
comment|/* try reopen the vnode */
name|error
operator|=
name|VOP_OPEN
argument_list|(
name|uvp
argument_list|,
name|unsp
operator|->
name|uns_lower_openmode
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|td
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|unionfs_advlock_abort
goto|;
name|unsp
operator|->
name|uns_upper_opencnt
operator|++
expr_stmt|;
name|VOP_CLOSE
argument_list|(
name|unp
operator|->
name|un_lowervp
argument_list|,
name|unsp
operator|->
name|uns_lower_openmode
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|unsp
operator|->
name|uns_lower_opencnt
operator|--
expr_stmt|;
block|}
else|else
name|unionfs_tryrem_node_status
argument_list|(
name|unp
argument_list|,
name|unsp
argument_list|)
expr_stmt|;
block|}
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
name|LK_RELEASE
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_ADVLOCK
argument_list|(
name|uvp
argument_list|,
name|ap
operator|->
name|a_id
argument_list|,
name|ap
operator|->
name|a_op
argument_list|,
name|ap
operator|->
name|a_fl
argument_list|,
name|ap
operator|->
name|a_flags
argument_list|)
expr_stmt|;
name|UNIONFS_INTERNAL_DEBUG
argument_list|(
literal|"unionfs_advlock: leave (%d)\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
name|unionfs_advlock_abort
label|:
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
name|LK_RELEASE
argument_list|)
expr_stmt|;
name|UNIONFS_INTERNAL_DEBUG
argument_list|(
literal|"unionfs_advlock: leave (%d)\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unionfs_strategy
parameter_list|(
name|struct
name|vop_strategy_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|unionfs_node
modifier|*
name|unp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|KASSERT_UNIONFS_VNODE
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
name|unp
operator|=
name|VTOUNIONFS
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
name|vp
operator|=
operator|(
name|unp
operator|->
name|un_uppervp
operator|!=
name|NULLVP
condition|?
name|unp
operator|->
name|un_uppervp
else|:
name|unp
operator|->
name|un_lowervp
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|vp
operator|==
name|NULLVP
condition|)
name|panic
argument_list|(
literal|"unionfs_strategy: nullvp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|a_bp
operator|->
name|b_iocmd
operator|==
name|BIO_WRITE
operator|&&
name|vp
operator|==
name|unp
operator|->
name|un_lowervp
condition|)
name|panic
argument_list|(
literal|"unionfs_strategy: writing to lowervp"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|VOP_STRATEGY
argument_list|(
name|vp
argument_list|,
name|ap
operator|->
name|a_bp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unionfs_getacl
parameter_list|(
name|struct
name|vop_getacl_args
modifier|*
name|ap
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|unionfs_node
modifier|*
name|unp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|KASSERT_UNIONFS_VNODE
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
name|unp
operator|=
name|VTOUNIONFS
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
name|vp
operator|=
operator|(
name|unp
operator|->
name|un_uppervp
operator|!=
name|NULLVP
condition|?
name|unp
operator|->
name|un_uppervp
else|:
name|unp
operator|->
name|un_lowervp
operator|)
expr_stmt|;
name|UNIONFS_INTERNAL_DEBUG
argument_list|(
literal|"unionfs_getacl: enter\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_GETACL
argument_list|(
name|vp
argument_list|,
name|ap
operator|->
name|a_type
argument_list|,
name|ap
operator|->
name|a_aclp
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_td
argument_list|)
expr_stmt|;
name|UNIONFS_INTERNAL_DEBUG
argument_list|(
literal|"unionfs_getacl: leave (%d)\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unionfs_setacl
parameter_list|(
name|struct
name|vop_setacl_args
modifier|*
name|ap
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|unionfs_node
modifier|*
name|unp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|uvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|lvp
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|UNIONFS_INTERNAL_DEBUG
argument_list|(
literal|"unionfs_setacl: enter\n"
argument_list|)
expr_stmt|;
name|KASSERT_UNIONFS_VNODE
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
name|error
operator|=
name|EROFS
expr_stmt|;
name|unp
operator|=
name|VTOUNIONFS
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
name|uvp
operator|=
name|unp
operator|->
name|un_uppervp
expr_stmt|;
name|lvp
operator|=
name|unp
operator|->
name|un_lowervp
expr_stmt|;
name|td
operator|=
name|ap
operator|->
name|a_td
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|a_vp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
condition|)
return|return
operator|(
name|EROFS
operator|)
return|;
if|if
condition|(
name|uvp
operator|==
name|NULLVP
operator|&&
name|lvp
operator|->
name|v_type
operator|==
name|VREG
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|unionfs_copyfile
argument_list|(
name|unp
argument_list|,
literal|1
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|td
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|uvp
operator|=
name|unp
operator|->
name|un_uppervp
expr_stmt|;
block|}
if|if
condition|(
name|uvp
operator|!=
name|NULLVP
condition|)
name|error
operator|=
name|VOP_SETACL
argument_list|(
name|uvp
argument_list|,
name|ap
operator|->
name|a_type
argument_list|,
name|ap
operator|->
name|a_aclp
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|UNIONFS_INTERNAL_DEBUG
argument_list|(
literal|"unionfs_setacl: leave (%d)\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unionfs_aclcheck
parameter_list|(
name|struct
name|vop_aclcheck_args
modifier|*
name|ap
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|unionfs_node
modifier|*
name|unp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|UNIONFS_INTERNAL_DEBUG
argument_list|(
literal|"unionfs_aclcheck: enter\n"
argument_list|)
expr_stmt|;
name|KASSERT_UNIONFS_VNODE
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
name|unp
operator|=
name|VTOUNIONFS
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
name|vp
operator|=
operator|(
name|unp
operator|->
name|un_uppervp
operator|!=
name|NULLVP
condition|?
name|unp
operator|->
name|un_uppervp
else|:
name|unp
operator|->
name|un_lowervp
operator|)
expr_stmt|;
name|error
operator|=
name|VOP_ACLCHECK
argument_list|(
name|vp
argument_list|,
name|ap
operator|->
name|a_type
argument_list|,
name|ap
operator|->
name|a_aclp
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_td
argument_list|)
expr_stmt|;
name|UNIONFS_INTERNAL_DEBUG
argument_list|(
literal|"unionfs_aclcheck: leave (%d)\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unionfs_openextattr
parameter_list|(
name|struct
name|vop_openextattr_args
modifier|*
name|ap
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|unionfs_node
modifier|*
name|unp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|tvp
decl_stmt|;
name|KASSERT_UNIONFS_VNODE
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
name|vp
operator|=
name|ap
operator|->
name|a_vp
expr_stmt|;
name|unp
operator|=
name|VTOUNIONFS
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|tvp
operator|=
operator|(
name|unp
operator|->
name|un_uppervp
operator|!=
name|NULLVP
condition|?
name|unp
operator|->
name|un_uppervp
else|:
name|unp
operator|->
name|un_lowervp
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|tvp
operator|==
name|unp
operator|->
name|un_uppervp
operator|&&
operator|(
name|unp
operator|->
name|un_flag
operator|&
name|UNIONFS_OPENEXTU
operator|)
operator|)
operator|||
operator|(
name|tvp
operator|==
name|unp
operator|->
name|un_lowervp
operator|&&
operator|(
name|unp
operator|->
name|un_flag
operator|&
name|UNIONFS_OPENEXTL
operator|)
operator|)
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|error
operator|=
name|VOP_OPENEXTATTR
argument_list|(
name|tvp
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_UPGRADE
argument_list|)
operator|!=
literal|0
condition|)
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
if|if
condition|(
name|tvp
operator|==
name|unp
operator|->
name|un_uppervp
condition|)
name|unp
operator|->
name|un_flag
operator||=
name|UNIONFS_OPENEXTU
expr_stmt|;
else|else
name|unp
operator|->
name|un_flag
operator||=
name|UNIONFS_OPENEXTL
expr_stmt|;
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_DOWNGRADE
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unionfs_closeextattr
parameter_list|(
name|struct
name|vop_closeextattr_args
modifier|*
name|ap
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|unionfs_node
modifier|*
name|unp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|tvp
decl_stmt|;
name|KASSERT_UNIONFS_VNODE
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
name|vp
operator|=
name|ap
operator|->
name|a_vp
expr_stmt|;
name|unp
operator|=
name|VTOUNIONFS
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|tvp
operator|=
name|NULLVP
expr_stmt|;
if|if
condition|(
name|unp
operator|->
name|un_flag
operator|&
name|UNIONFS_OPENEXTU
condition|)
name|tvp
operator|=
name|unp
operator|->
name|un_uppervp
expr_stmt|;
elseif|else
if|if
condition|(
name|unp
operator|->
name|un_flag
operator|&
name|UNIONFS_OPENEXTL
condition|)
name|tvp
operator|=
name|unp
operator|->
name|un_lowervp
expr_stmt|;
if|if
condition|(
name|tvp
operator|==
name|NULLVP
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
name|error
operator|=
name|VOP_CLOSEEXTATTR
argument_list|(
name|tvp
argument_list|,
name|ap
operator|->
name|a_commit
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_UPGRADE
argument_list|)
operator|!=
literal|0
condition|)
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
if|if
condition|(
name|tvp
operator|==
name|unp
operator|->
name|un_uppervp
condition|)
name|unp
operator|->
name|un_flag
operator|&=
operator|~
name|UNIONFS_OPENEXTU
expr_stmt|;
else|else
name|unp
operator|->
name|un_flag
operator|&=
operator|~
name|UNIONFS_OPENEXTL
expr_stmt|;
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_DOWNGRADE
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unionfs_getextattr
parameter_list|(
name|struct
name|vop_getextattr_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|unionfs_node
modifier|*
name|unp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|KASSERT_UNIONFS_VNODE
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
name|unp
operator|=
name|VTOUNIONFS
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
name|vp
operator|=
name|NULLVP
expr_stmt|;
if|if
condition|(
name|unp
operator|->
name|un_flag
operator|&
name|UNIONFS_OPENEXTU
condition|)
name|vp
operator|=
name|unp
operator|->
name|un_uppervp
expr_stmt|;
elseif|else
if|if
condition|(
name|unp
operator|->
name|un_flag
operator|&
name|UNIONFS_OPENEXTL
condition|)
name|vp
operator|=
name|unp
operator|->
name|un_lowervp
expr_stmt|;
if|if
condition|(
name|vp
operator|==
name|NULLVP
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
return|return
operator|(
name|VOP_GETEXTATTR
argument_list|(
name|vp
argument_list|,
name|ap
operator|->
name|a_attrnamespace
argument_list|,
name|ap
operator|->
name|a_name
argument_list|,
name|ap
operator|->
name|a_uio
argument_list|,
name|ap
operator|->
name|a_size
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_td
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unionfs_setextattr
parameter_list|(
name|struct
name|vop_setextattr_args
modifier|*
name|ap
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|unionfs_node
modifier|*
name|unp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|uvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|lvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|ovp
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|KASSERT_UNIONFS_VNODE
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
name|error
operator|=
name|EROFS
expr_stmt|;
name|unp
operator|=
name|VTOUNIONFS
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
name|uvp
operator|=
name|unp
operator|->
name|un_uppervp
expr_stmt|;
name|lvp
operator|=
name|unp
operator|->
name|un_lowervp
expr_stmt|;
name|ovp
operator|=
name|NULLVP
expr_stmt|;
name|cred
operator|=
name|ap
operator|->
name|a_cred
expr_stmt|;
name|td
operator|=
name|ap
operator|->
name|a_td
expr_stmt|;
name|UNIONFS_INTERNAL_DEBUG
argument_list|(
literal|"unionfs_setextattr: enter (un_flag=%x)\n"
argument_list|,
name|unp
operator|->
name|un_flag
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|a_vp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
condition|)
return|return
operator|(
name|EROFS
operator|)
return|;
if|if
condition|(
name|unp
operator|->
name|un_flag
operator|&
name|UNIONFS_OPENEXTU
condition|)
name|ovp
operator|=
name|unp
operator|->
name|un_uppervp
expr_stmt|;
elseif|else
if|if
condition|(
name|unp
operator|->
name|un_flag
operator|&
name|UNIONFS_OPENEXTL
condition|)
name|ovp
operator|=
name|unp
operator|->
name|un_lowervp
expr_stmt|;
if|if
condition|(
name|ovp
operator|==
name|NULLVP
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
if|if
condition|(
name|ovp
operator|==
name|lvp
operator|&&
name|lvp
operator|->
name|v_type
operator|==
name|VREG
condition|)
block|{
name|VOP_CLOSEEXTATTR
argument_list|(
name|lvp
argument_list|,
literal|0
argument_list|,
name|cred
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|uvp
operator|==
name|NULLVP
operator|&&
operator|(
name|error
operator|=
name|unionfs_copyfile
argument_list|(
name|unp
argument_list|,
literal|1
argument_list|,
name|cred
argument_list|,
name|td
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|unionfs_setextattr_reopen
label|:
if|if
condition|(
operator|(
name|unp
operator|->
name|un_flag
operator|&
name|UNIONFS_OPENEXTL
operator|)
operator|&&
name|VOP_OPENEXTATTR
argument_list|(
name|lvp
argument_list|,
name|cred
argument_list|,
name|td
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|panic
argument_list|(
literal|"unionfs: VOP_OPENEXTATTR failed"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|unp
operator|->
name|un_flag
operator|&=
operator|~
name|UNIONFS_OPENEXTL
expr_stmt|;
block|}
goto|goto
name|unionfs_setextattr_abort
goto|;
block|}
name|uvp
operator|=
name|unp
operator|->
name|un_uppervp
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|VOP_OPENEXTATTR
argument_list|(
name|uvp
argument_list|,
name|cred
argument_list|,
name|td
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|unionfs_setextattr_reopen
goto|;
name|unp
operator|->
name|un_flag
operator|&=
operator|~
name|UNIONFS_OPENEXTL
expr_stmt|;
name|unp
operator|->
name|un_flag
operator||=
name|UNIONFS_OPENEXTU
expr_stmt|;
name|ovp
operator|=
name|uvp
expr_stmt|;
block|}
if|if
condition|(
name|ovp
operator|==
name|uvp
condition|)
name|error
operator|=
name|VOP_SETEXTATTR
argument_list|(
name|ovp
argument_list|,
name|ap
operator|->
name|a_attrnamespace
argument_list|,
name|ap
operator|->
name|a_name
argument_list|,
name|ap
operator|->
name|a_uio
argument_list|,
name|cred
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|unionfs_setextattr_abort
label|:
name|UNIONFS_INTERNAL_DEBUG
argument_list|(
literal|"unionfs_setextattr: leave (%d)\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unionfs_listextattr
parameter_list|(
name|struct
name|vop_listextattr_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|unionfs_node
modifier|*
name|unp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|KASSERT_UNIONFS_VNODE
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
name|unp
operator|=
name|VTOUNIONFS
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
name|vp
operator|=
name|NULLVP
expr_stmt|;
if|if
condition|(
name|unp
operator|->
name|un_flag
operator|&
name|UNIONFS_OPENEXTU
condition|)
name|vp
operator|=
name|unp
operator|->
name|un_uppervp
expr_stmt|;
elseif|else
if|if
condition|(
name|unp
operator|->
name|un_flag
operator|&
name|UNIONFS_OPENEXTL
condition|)
name|vp
operator|=
name|unp
operator|->
name|un_lowervp
expr_stmt|;
if|if
condition|(
name|vp
operator|==
name|NULLVP
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
return|return
operator|(
name|VOP_LISTEXTATTR
argument_list|(
name|vp
argument_list|,
name|ap
operator|->
name|a_attrnamespace
argument_list|,
name|ap
operator|->
name|a_uio
argument_list|,
name|ap
operator|->
name|a_size
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_td
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unionfs_deleteextattr
parameter_list|(
name|struct
name|vop_deleteextattr_args
modifier|*
name|ap
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|unionfs_node
modifier|*
name|unp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|uvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|lvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|ovp
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|KASSERT_UNIONFS_VNODE
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
name|error
operator|=
name|EROFS
expr_stmt|;
name|unp
operator|=
name|VTOUNIONFS
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
name|uvp
operator|=
name|unp
operator|->
name|un_uppervp
expr_stmt|;
name|lvp
operator|=
name|unp
operator|->
name|un_lowervp
expr_stmt|;
name|ovp
operator|=
name|NULLVP
expr_stmt|;
name|cred
operator|=
name|ap
operator|->
name|a_cred
expr_stmt|;
name|td
operator|=
name|ap
operator|->
name|a_td
expr_stmt|;
name|UNIONFS_INTERNAL_DEBUG
argument_list|(
literal|"unionfs_deleteextattr: enter (un_flag=%x)\n"
argument_list|,
name|unp
operator|->
name|un_flag
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|a_vp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
condition|)
return|return
operator|(
name|EROFS
operator|)
return|;
if|if
condition|(
name|unp
operator|->
name|un_flag
operator|&
name|UNIONFS_OPENEXTU
condition|)
name|ovp
operator|=
name|unp
operator|->
name|un_uppervp
expr_stmt|;
elseif|else
if|if
condition|(
name|unp
operator|->
name|un_flag
operator|&
name|UNIONFS_OPENEXTL
condition|)
name|ovp
operator|=
name|unp
operator|->
name|un_lowervp
expr_stmt|;
if|if
condition|(
name|ovp
operator|==
name|NULLVP
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
if|if
condition|(
name|ovp
operator|==
name|lvp
operator|&&
name|lvp
operator|->
name|v_type
operator|==
name|VREG
condition|)
block|{
name|VOP_CLOSEEXTATTR
argument_list|(
name|lvp
argument_list|,
literal|0
argument_list|,
name|cred
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|uvp
operator|==
name|NULLVP
operator|&&
operator|(
name|error
operator|=
name|unionfs_copyfile
argument_list|(
name|unp
argument_list|,
literal|1
argument_list|,
name|cred
argument_list|,
name|td
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|unionfs_deleteextattr_reopen
label|:
if|if
condition|(
operator|(
name|unp
operator|->
name|un_flag
operator|&
name|UNIONFS_OPENEXTL
operator|)
operator|&&
name|VOP_OPENEXTATTR
argument_list|(
name|lvp
argument_list|,
name|cred
argument_list|,
name|td
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|panic
argument_list|(
literal|"unionfs: VOP_OPENEXTATTR failed"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|unp
operator|->
name|un_flag
operator|&=
operator|~
name|UNIONFS_OPENEXTL
expr_stmt|;
block|}
goto|goto
name|unionfs_deleteextattr_abort
goto|;
block|}
name|uvp
operator|=
name|unp
operator|->
name|un_uppervp
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|VOP_OPENEXTATTR
argument_list|(
name|uvp
argument_list|,
name|cred
argument_list|,
name|td
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|unionfs_deleteextattr_reopen
goto|;
name|unp
operator|->
name|un_flag
operator|&=
operator|~
name|UNIONFS_OPENEXTL
expr_stmt|;
name|unp
operator|->
name|un_flag
operator||=
name|UNIONFS_OPENEXTU
expr_stmt|;
name|ovp
operator|=
name|uvp
expr_stmt|;
block|}
if|if
condition|(
name|ovp
operator|==
name|uvp
condition|)
name|error
operator|=
name|VOP_DELETEEXTATTR
argument_list|(
name|ovp
argument_list|,
name|ap
operator|->
name|a_attrnamespace
argument_list|,
name|ap
operator|->
name|a_name
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_td
argument_list|)
expr_stmt|;
name|unionfs_deleteextattr_abort
label|:
name|UNIONFS_INTERNAL_DEBUG
argument_list|(
literal|"unionfs_deleteextattr: leave (%d)\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unionfs_setlabel
parameter_list|(
name|struct
name|vop_setlabel_args
modifier|*
name|ap
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|unionfs_node
modifier|*
name|unp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|uvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|lvp
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|UNIONFS_INTERNAL_DEBUG
argument_list|(
literal|"unionfs_setlabel: enter\n"
argument_list|)
expr_stmt|;
name|KASSERT_UNIONFS_VNODE
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
name|error
operator|=
name|EROFS
expr_stmt|;
name|unp
operator|=
name|VTOUNIONFS
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
name|uvp
operator|=
name|unp
operator|->
name|un_uppervp
expr_stmt|;
name|lvp
operator|=
name|unp
operator|->
name|un_lowervp
expr_stmt|;
name|td
operator|=
name|ap
operator|->
name|a_td
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|a_vp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
condition|)
return|return
operator|(
name|EROFS
operator|)
return|;
if|if
condition|(
name|uvp
operator|==
name|NULLVP
operator|&&
name|lvp
operator|->
name|v_type
operator|==
name|VREG
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|unionfs_copyfile
argument_list|(
name|unp
argument_list|,
literal|1
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|td
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|uvp
operator|=
name|unp
operator|->
name|un_uppervp
expr_stmt|;
block|}
if|if
condition|(
name|uvp
operator|!=
name|NULLVP
condition|)
name|error
operator|=
name|VOP_SETLABEL
argument_list|(
name|uvp
argument_list|,
name|ap
operator|->
name|a_label
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|UNIONFS_INTERNAL_DEBUG
argument_list|(
literal|"unionfs_setlabel: leave (%d)\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unionfs_vptofh
parameter_list|(
name|struct
name|vop_vptofh_args
modifier|*
name|ap
parameter_list|)
block|{
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|vop_vector
name|unionfs_vnodeops
init|=
block|{
operator|.
name|vop_default
operator|=
operator|&
name|default_vnodeops
block|,
operator|.
name|vop_access
operator|=
name|unionfs_access
block|,
operator|.
name|vop_aclcheck
operator|=
name|unionfs_aclcheck
block|,
operator|.
name|vop_advlock
operator|=
name|unionfs_advlock
block|,
operator|.
name|vop_bmap
operator|=
name|VOP_EOPNOTSUPP
block|,
operator|.
name|vop_cachedlookup
operator|=
name|unionfs_lookup
block|,
operator|.
name|vop_close
operator|=
name|unionfs_close
block|,
operator|.
name|vop_closeextattr
operator|=
name|unionfs_closeextattr
block|,
operator|.
name|vop_create
operator|=
name|unionfs_create
block|,
operator|.
name|vop_deleteextattr
operator|=
name|unionfs_deleteextattr
block|,
operator|.
name|vop_fsync
operator|=
name|unionfs_fsync
block|,
operator|.
name|vop_getacl
operator|=
name|unionfs_getacl
block|,
operator|.
name|vop_getattr
operator|=
name|unionfs_getattr
block|,
operator|.
name|vop_getextattr
operator|=
name|unionfs_getextattr
block|,
operator|.
name|vop_getwritemount
operator|=
name|unionfs_getwritemount
block|,
operator|.
name|vop_inactive
operator|=
name|unionfs_inactive
block|,
operator|.
name|vop_islocked
operator|=
name|unionfs_islocked
block|,
operator|.
name|vop_ioctl
operator|=
name|unionfs_ioctl
block|,
operator|.
name|vop_link
operator|=
name|unionfs_link
block|,
operator|.
name|vop_listextattr
operator|=
name|unionfs_listextattr
block|,
operator|.
name|vop_lock1
operator|=
name|unionfs_lock
block|,
operator|.
name|vop_lookup
operator|=
name|vfs_cache_lookup
block|,
operator|.
name|vop_mkdir
operator|=
name|unionfs_mkdir
block|,
operator|.
name|vop_mknod
operator|=
name|unionfs_mknod
block|,
operator|.
name|vop_open
operator|=
name|unionfs_open
block|,
operator|.
name|vop_openextattr
operator|=
name|unionfs_openextattr
block|,
operator|.
name|vop_pathconf
operator|=
name|unionfs_pathconf
block|,
operator|.
name|vop_poll
operator|=
name|unionfs_poll
block|,
operator|.
name|vop_print
operator|=
name|unionfs_print
block|,
operator|.
name|vop_read
operator|=
name|unionfs_read
block|,
operator|.
name|vop_readdir
operator|=
name|unionfs_readdir
block|,
operator|.
name|vop_readlink
operator|=
name|unionfs_readlink
block|,
operator|.
name|vop_reclaim
operator|=
name|unionfs_reclaim
block|,
operator|.
name|vop_remove
operator|=
name|unionfs_remove
block|,
operator|.
name|vop_rename
operator|=
name|unionfs_rename
block|,
operator|.
name|vop_rmdir
operator|=
name|unionfs_rmdir
block|,
operator|.
name|vop_setacl
operator|=
name|unionfs_setacl
block|,
operator|.
name|vop_setattr
operator|=
name|unionfs_setattr
block|,
operator|.
name|vop_setextattr
operator|=
name|unionfs_setextattr
block|,
operator|.
name|vop_setlabel
operator|=
name|unionfs_setlabel
block|,
operator|.
name|vop_strategy
operator|=
name|unionfs_strategy
block|,
operator|.
name|vop_symlink
operator|=
name|unionfs_symlink
block|,
operator|.
name|vop_unlock
operator|=
name|unionfs_unlock
block|,
operator|.
name|vop_whiteout
operator|=
name|unionfs_whiteout
block|,
operator|.
name|vop_write
operator|=
name|unionfs_write
block|,
operator|.
name|vop_vptofh
operator|=
name|unionfs_vptofh
block|, }
decl_stmt|;
end_decl_stmt

end_unit

