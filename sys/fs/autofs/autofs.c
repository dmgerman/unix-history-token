begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2014 The FreeBSD Foundation  * All rights reserved.  *  * This software was developed by Edward Tomasz Napierala under sponsorship  * from the FreeBSD Foundation.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_comment
comment|/*-  * Copyright (c) 1989, 1991, 1993, 1995  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Rick Macklem at The University of Guelph.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/dirent.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioccom.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/refcount.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/syscallsubr.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<machine/atomic.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<fs/autofs/autofs.h>
end_include

begin_include
include|#
directive|include
file|<fs/autofs/autofs_ioctl.h>
end_include

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_AUTOFS
argument_list|,
literal|"autofs"
argument_list|,
literal|"Automounter filesystem"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|uma_zone_t
name|autofs_request_zone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uma_zone_t
name|autofs_node_zone
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|autofs_open
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|autofs_close
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|autofs_ioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|autofs_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_open
operator|=
name|autofs_open
block|,
operator|.
name|d_close
operator|=
name|autofs_close
block|,
operator|.
name|d_ioctl
operator|=
name|autofs_ioctl
block|,
operator|.
name|d_name
operator|=
literal|"autofs"
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * List of signals that can interrupt an autofs trigger.  Might be a good  * idea to keep it synchronised with list in sys/fs/nfs/nfs_commonkrpc.c.  */
end_comment

begin_decl_stmt
name|int
name|autofs_sig_set
index|[]
init|=
block|{
name|SIGINT
block|,
name|SIGTERM
block|,
name|SIGHUP
block|,
name|SIGKILL
block|,
name|SIGQUIT
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|autofs_softc
modifier|*
name|autofs_softc
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_vfs
argument_list|,
name|OID_AUTO
argument_list|,
name|autofs
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"Automounter filesystem"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|autofs_debug
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"vfs.autofs.debug"
argument_list|,
operator|&
name|autofs_debug
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_autofs
argument_list|,
name|OID_AUTO
argument_list|,
name|debug
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|autofs_debug
argument_list|,
literal|1
argument_list|,
literal|"Enable debug messages"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|autofs_mount_on_stat
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"vfs.autofs.mount_on_stat"
argument_list|,
operator|&
name|autofs_mount_on_stat
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_autofs
argument_list|,
name|OID_AUTO
argument_list|,
name|mount_on_stat
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|autofs_mount_on_stat
argument_list|,
literal|0
argument_list|,
literal|"Trigger mount on stat(2) on mountpoint"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|autofs_timeout
init|=
literal|30
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"vfs.autofs.timeout"
argument_list|,
operator|&
name|autofs_timeout
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_autofs
argument_list|,
name|OID_AUTO
argument_list|,
name|timeout
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|autofs_timeout
argument_list|,
literal|30
argument_list|,
literal|"Number of seconds to wait for automountd(8)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|autofs_cache
init|=
literal|600
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"vfs.autofs.cache"
argument_list|,
operator|&
name|autofs_cache
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_autofs
argument_list|,
name|OID_AUTO
argument_list|,
name|cache
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|autofs_cache
argument_list|,
literal|600
argument_list|,
literal|"Number of seconds to wait before reinvoking "
literal|"automountd(8) for any given file or directory"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|autofs_retry_attempts
init|=
literal|3
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"vfs.autofs.retry_attempts"
argument_list|,
operator|&
name|autofs_retry_attempts
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_autofs
argument_list|,
name|OID_AUTO
argument_list|,
name|retry_attempts
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|autofs_retry_attempts
argument_list|,
literal|3
argument_list|,
literal|"Number of attempts before failing mount"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|autofs_retry_delay
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"vfs.autofs.retry_delay"
argument_list|,
operator|&
name|autofs_retry_delay
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_autofs
argument_list|,
name|OID_AUTO
argument_list|,
name|retry_delay
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|autofs_retry_delay
argument_list|,
literal|1
argument_list|,
literal|"Number of seconds before retrying"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|autofs_interruptible
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"vfs.autofs.interruptible"
argument_list|,
operator|&
name|autofs_interruptible
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_autofs
argument_list|,
name|OID_AUTO
argument_list|,
name|interruptible
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|autofs_interruptible
argument_list|,
literal|1
argument_list|,
literal|"Allow requests to be interrupted by signal"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|autofs_init
parameter_list|(
name|struct
name|vfsconf
modifier|*
name|vfsp
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|KASSERT
argument_list|(
name|autofs_softc
operator|==
name|NULL
argument_list|,
operator|(
literal|"softc %p, should be NULL"
operator|,
name|autofs_softc
operator|)
argument_list|)
expr_stmt|;
name|autofs_softc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|autofs_softc
argument_list|)
argument_list|,
name|M_AUTOFS
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|autofs_request_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"autofs_request"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|autofs_request
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|autofs_node_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"autofs_node"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|autofs_node
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|autofs_softc
operator|->
name|sc_requests
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|autofs_softc
operator|->
name|sc_cv
argument_list|,
literal|"autofscv"
argument_list|)
expr_stmt|;
name|sx_init
argument_list|(
operator|&
name|autofs_softc
operator|->
name|sc_lock
argument_list|,
literal|"autofslk"
argument_list|)
expr_stmt|;
name|error
operator|=
name|make_dev_p
argument_list|(
name|MAKEDEV_CHECKNAME
argument_list|,
operator|&
name|autofs_softc
operator|->
name|sc_cdev
argument_list|,
operator|&
name|autofs_cdevsw
argument_list|,
name|NULL
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0600
argument_list|,
literal|"autofs"
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|AUTOFS_WARN
argument_list|(
literal|"failed to create device node, error %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|uma_zdestroy
argument_list|(
name|autofs_request_zone
argument_list|)
expr_stmt|;
name|uma_zdestroy
argument_list|(
name|autofs_node_zone
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|autofs_softc
argument_list|,
name|M_AUTOFS
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|autofs_softc
operator|->
name|sc_cdev
operator|->
name|si_drv1
operator|=
name|autofs_softc
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|autofs_uninit
parameter_list|(
name|struct
name|vfsconf
modifier|*
name|vfsp
parameter_list|)
block|{
name|sx_xlock
argument_list|(
operator|&
name|autofs_softc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|autofs_softc
operator|->
name|sc_dev_opened
condition|)
block|{
name|sx_xunlock
argument_list|(
operator|&
name|autofs_softc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
if|if
condition|(
name|autofs_softc
operator|->
name|sc_cdev
operator|!=
name|NULL
condition|)
name|destroy_dev
argument_list|(
name|autofs_softc
operator|->
name|sc_cdev
argument_list|)
expr_stmt|;
name|uma_zdestroy
argument_list|(
name|autofs_request_zone
argument_list|)
expr_stmt|;
name|uma_zdestroy
argument_list|(
name|autofs_node_zone
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|autofs_softc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
comment|/* 	 * XXX: Race with open? 	 */
name|free
argument_list|(
name|autofs_softc
argument_list|,
name|M_AUTOFS
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|bool
name|autofs_ignore_thread
parameter_list|(
specifier|const
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
if|if
condition|(
name|autofs_softc
operator|->
name|sc_dev_opened
operator|==
name|false
condition|)
return|return
operator|(
name|false
operator|)
return|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_session
operator|->
name|s_sid
operator|==
name|autofs_softc
operator|->
name|sc_dev_sid
condition|)
block|{
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|autofs_path
parameter_list|(
name|struct
name|autofs_node
modifier|*
name|anp
parameter_list|)
block|{
name|struct
name|autofs_mount
modifier|*
name|amp
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|amp
operator|=
name|anp
operator|->
name|an_mount
expr_stmt|;
name|path
operator|=
name|strdup
argument_list|(
literal|""
argument_list|,
name|M_AUTOFS
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|anp
operator|->
name|an_parent
operator|!=
name|NULL
condition|;
name|anp
operator|=
name|anp
operator|->
name|an_parent
control|)
block|{
name|tmp
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|anp
operator|->
name|an_name
argument_list|)
operator|+
name|strlen
argument_list|(
name|path
argument_list|)
operator|+
literal|2
argument_list|,
name|M_AUTOFS
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|tmp
argument_list|,
name|anp
operator|->
name|an_name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmp
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmp
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|path
argument_list|,
name|M_AUTOFS
argument_list|)
expr_stmt|;
name|path
operator|=
name|tmp
expr_stmt|;
block|}
name|tmp
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|amp
operator|->
name|am_mountpoint
argument_list|)
operator|+
name|strlen
argument_list|(
name|path
argument_list|)
operator|+
literal|2
argument_list|,
name|M_AUTOFS
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|tmp
argument_list|,
name|amp
operator|->
name|am_mountpoint
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmp
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmp
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|path
argument_list|,
name|M_AUTOFS
argument_list|)
expr_stmt|;
name|path
operator|=
name|tmp
expr_stmt|;
return|return
operator|(
name|path
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|autofs_task
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|autofs_request
modifier|*
name|ar
decl_stmt|;
name|ar
operator|=
name|context
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|autofs_softc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|AUTOFS_WARN
argument_list|(
literal|"request %d for %s timed out after %d seconds"
argument_list|,
name|ar
operator|->
name|ar_id
argument_list|,
name|ar
operator|->
name|ar_path
argument_list|,
name|autofs_timeout
argument_list|)
expr_stmt|;
comment|/* 	 * XXX: EIO perhaps? 	 */
name|ar
operator|->
name|ar_error
operator|=
name|ETIMEDOUT
expr_stmt|;
name|ar
operator|->
name|ar_done
operator|=
name|true
expr_stmt|;
name|ar
operator|->
name|ar_in_progress
operator|=
name|false
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|autofs_softc
operator|->
name|sc_cv
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|autofs_softc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|bool
name|autofs_cached
parameter_list|(
name|struct
name|autofs_node
modifier|*
name|anp
parameter_list|,
specifier|const
name|char
modifier|*
name|component
parameter_list|,
name|int
name|componentlen
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|autofs_mount
modifier|*
name|amp
decl_stmt|;
name|amp
operator|=
name|anp
operator|->
name|an_mount
expr_stmt|;
name|AUTOFS_ASSERT_UNLOCKED
argument_list|(
name|amp
argument_list|)
expr_stmt|;
comment|/* 	 * For top-level nodes we need to request automountd(8) 	 * assistance even if the node is marked as cached, 	 * but the requested subdirectory does not exist.  This 	 * is necessary for wildcard indirect map keys to work. 	 */
if|if
condition|(
name|anp
operator|->
name|an_parent
operator|==
name|NULL
operator|&&
name|componentlen
operator|!=
literal|0
condition|)
block|{
name|AUTOFS_SLOCK
argument_list|(
name|amp
argument_list|)
expr_stmt|;
name|error
operator|=
name|autofs_node_find
argument_list|(
name|anp
argument_list|,
name|component
argument_list|,
name|componentlen
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|AUTOFS_SUNLOCK
argument_list|(
name|amp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|false
operator|)
return|;
block|}
return|return
operator|(
name|anp
operator|->
name|an_cached
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|autofs_cache_callout
parameter_list|(
name|void
modifier|*
name|context
parameter_list|)
block|{
name|struct
name|autofs_node
modifier|*
name|anp
decl_stmt|;
name|anp
operator|=
name|context
expr_stmt|;
name|anp
operator|->
name|an_cached
operator|=
name|false
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The set/restore sigmask functions are used to (temporarily) overwrite  * the thread td_sigmask during triggering.  */
end_comment

begin_function
specifier|static
name|void
name|autofs_set_sigmask
parameter_list|(
name|sigset_t
modifier|*
name|oldset
parameter_list|)
block|{
name|sigset_t
name|newset
decl_stmt|;
name|int
name|i
decl_stmt|;
name|SIGFILLSET
argument_list|(
name|newset
argument_list|)
expr_stmt|;
comment|/* Remove the autofs set of signals from newset */
name|PROC_LOCK
argument_list|(
name|curproc
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|curproc
operator|->
name|p_sigacts
operator|->
name|ps_mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|autofs_sig_set
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * But make sure we leave the ones already masked 		 * by the process, i.e. remove the signal from the 		 * temporary signalmask only if it wasn't already 		 * in p_sigmask. 		 */
if|if
condition|(
operator|!
name|SIGISMEMBER
argument_list|(
name|curthread
operator|->
name|td_sigmask
argument_list|,
name|autofs_sig_set
index|[
name|i
index|]
argument_list|)
operator|&&
operator|!
name|SIGISMEMBER
argument_list|(
name|curproc
operator|->
name|p_sigacts
operator|->
name|ps_sigignore
argument_list|,
name|autofs_sig_set
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|SIGDELSET
argument_list|(
name|newset
argument_list|,
name|autofs_sig_set
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|curproc
operator|->
name|p_sigacts
operator|->
name|ps_mtx
argument_list|)
expr_stmt|;
name|kern_sigprocmask
argument_list|(
name|curthread
argument_list|,
name|SIG_SETMASK
argument_list|,
operator|&
name|newset
argument_list|,
name|oldset
argument_list|,
name|SIGPROCMASK_PROC_LOCKED
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|curproc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|autofs_restore_sigmask
parameter_list|(
name|sigset_t
modifier|*
name|set
parameter_list|)
block|{
name|kern_sigprocmask
argument_list|(
name|curthread
argument_list|,
name|SIG_SETMASK
argument_list|,
name|set
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|autofs_trigger_one
parameter_list|(
name|struct
name|autofs_node
modifier|*
name|anp
parameter_list|,
specifier|const
name|char
modifier|*
name|component
parameter_list|,
name|int
name|componentlen
parameter_list|)
block|{
name|sigset_t
name|oldset
decl_stmt|;
name|struct
name|autofs_mount
modifier|*
name|amp
decl_stmt|;
name|struct
name|autofs_node
modifier|*
name|firstanp
decl_stmt|;
name|struct
name|autofs_request
modifier|*
name|ar
decl_stmt|;
name|char
modifier|*
name|key
decl_stmt|,
modifier|*
name|path
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|request_error
decl_stmt|,
name|last
decl_stmt|;
name|amp
operator|=
name|anp
operator|->
name|an_mount
expr_stmt|;
name|sx_assert
argument_list|(
operator|&
name|autofs_softc
operator|->
name|sc_lock
argument_list|,
name|SA_XLOCKED
argument_list|)
expr_stmt|;
if|if
condition|(
name|anp
operator|->
name|an_parent
operator|==
name|NULL
condition|)
block|{
name|key
operator|=
name|strndup
argument_list|(
name|component
argument_list|,
name|componentlen
argument_list|,
name|M_AUTOFS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|firstanp
operator|=
name|anp
init|;
name|firstanp
operator|->
name|an_parent
operator|->
name|an_parent
operator|!=
name|NULL
condition|;
name|firstanp
operator|=
name|firstanp
operator|->
name|an_parent
control|)
continue|continue;
name|key
operator|=
name|strdup
argument_list|(
name|firstanp
operator|->
name|an_name
argument_list|,
name|M_AUTOFS
argument_list|)
expr_stmt|;
block|}
name|path
operator|=
name|autofs_path
argument_list|(
name|anp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ar
argument_list|,
argument|&autofs_softc->sc_requests
argument_list|,
argument|ar_next
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|ar
operator|->
name|ar_path
argument_list|,
name|path
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|ar
operator|->
name|ar_key
argument_list|,
name|key
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
name|KASSERT
argument_list|(
name|strcmp
argument_list|(
name|ar
operator|->
name|ar_from
argument_list|,
name|amp
operator|->
name|am_from
argument_list|)
operator|==
literal|0
argument_list|,
operator|(
literal|"from changed; %s != %s"
operator|,
name|ar
operator|->
name|ar_from
operator|,
name|amp
operator|->
name|am_from
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|strcmp
argument_list|(
name|ar
operator|->
name|ar_prefix
argument_list|,
name|amp
operator|->
name|am_prefix
argument_list|)
operator|==
literal|0
argument_list|,
operator|(
literal|"prefix changed; %s != %s"
operator|,
name|ar
operator|->
name|ar_prefix
operator|,
name|amp
operator|->
name|am_prefix
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|strcmp
argument_list|(
name|ar
operator|->
name|ar_options
argument_list|,
name|amp
operator|->
name|am_options
argument_list|)
operator|==
literal|0
argument_list|,
operator|(
literal|"options changed; %s != %s"
operator|,
name|ar
operator|->
name|ar_options
operator|,
name|amp
operator|->
name|am_options
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ar
operator|!=
name|NULL
condition|)
block|{
name|refcount_acquire
argument_list|(
operator|&
name|ar
operator|->
name|ar_refcount
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ar
operator|=
name|uma_zalloc
argument_list|(
name|autofs_request_zone
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|ar
operator|->
name|ar_mount
operator|=
name|amp
expr_stmt|;
name|ar
operator|->
name|ar_id
operator|=
name|atomic_fetchadd_int
argument_list|(
operator|&
name|autofs_softc
operator|->
name|sc_last_request_id
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|ar
operator|->
name|ar_from
argument_list|,
name|amp
operator|->
name|am_from
argument_list|,
sizeof|sizeof
argument_list|(
name|ar
operator|->
name|ar_from
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|ar
operator|->
name|ar_path
argument_list|,
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|ar
operator|->
name|ar_path
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|ar
operator|->
name|ar_prefix
argument_list|,
name|amp
operator|->
name|am_prefix
argument_list|,
sizeof|sizeof
argument_list|(
name|ar
operator|->
name|ar_prefix
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|ar
operator|->
name|ar_key
argument_list|,
name|key
argument_list|,
sizeof|sizeof
argument_list|(
name|ar
operator|->
name|ar_key
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|ar
operator|->
name|ar_options
argument_list|,
name|amp
operator|->
name|am_options
argument_list|,
sizeof|sizeof
argument_list|(
name|ar
operator|->
name|ar_options
argument_list|)
argument_list|)
expr_stmt|;
name|TIMEOUT_TASK_INIT
argument_list|(
name|taskqueue_thread
argument_list|,
operator|&
name|ar
operator|->
name|ar_task
argument_list|,
literal|0
argument_list|,
name|autofs_task
argument_list|,
name|ar
argument_list|)
expr_stmt|;
name|error
operator|=
name|taskqueue_enqueue_timeout
argument_list|(
name|taskqueue_thread
argument_list|,
operator|&
name|ar
operator|->
name|ar_task
argument_list|,
name|autofs_timeout
operator|*
name|hz
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|AUTOFS_WARN
argument_list|(
literal|"taskqueue_enqueue_timeout() failed "
literal|"with error %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|refcount_init
argument_list|(
operator|&
name|ar
operator|->
name|ar_refcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|autofs_softc
operator|->
name|sc_requests
argument_list|,
name|ar
argument_list|,
name|ar_next
argument_list|)
expr_stmt|;
block|}
name|cv_broadcast
argument_list|(
operator|&
name|autofs_softc
operator|->
name|sc_cv
argument_list|)
expr_stmt|;
while|while
condition|(
name|ar
operator|->
name|ar_done
operator|==
name|false
condition|)
block|{
if|if
condition|(
name|autofs_interruptible
operator|!=
literal|0
condition|)
block|{
name|autofs_set_sigmask
argument_list|(
operator|&
name|oldset
argument_list|)
expr_stmt|;
name|error
operator|=
name|cv_wait_sig
argument_list|(
operator|&
name|autofs_softc
operator|->
name|sc_cv
argument_list|,
operator|&
name|autofs_softc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|autofs_restore_sigmask
argument_list|(
operator|&
name|oldset
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|AUTOFS_WARN
argument_list|(
literal|"cv_wait_sig for %s failed "
literal|"with error %d"
argument_list|,
name|ar
operator|->
name|ar_path
argument_list|,
name|error
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|cv_wait
argument_list|(
operator|&
name|autofs_softc
operator|->
name|sc_cv
argument_list|,
operator|&
name|autofs_softc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
block|}
block|}
name|request_error
operator|=
name|ar
operator|->
name|ar_error
expr_stmt|;
if|if
condition|(
name|request_error
operator|!=
literal|0
condition|)
block|{
name|AUTOFS_WARN
argument_list|(
literal|"request for %s completed with error %d"
argument_list|,
name|ar
operator|->
name|ar_path
argument_list|,
name|request_error
argument_list|)
expr_stmt|;
block|}
name|last
operator|=
name|refcount_release
argument_list|(
operator|&
name|ar
operator|->
name|ar_refcount
argument_list|)
expr_stmt|;
if|if
condition|(
name|last
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|autofs_softc
operator|->
name|sc_requests
argument_list|,
name|ar
argument_list|,
name|ar_next
argument_list|)
expr_stmt|;
comment|/* 		 * Unlock the sc_lock, so that autofs_task() can complete. 		 */
name|sx_xunlock
argument_list|(
operator|&
name|autofs_softc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|taskqueue_cancel_timeout
argument_list|(
name|taskqueue_thread
argument_list|,
operator|&
name|ar
operator|->
name|ar_task
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|taskqueue_drain_timeout
argument_list|(
name|taskqueue_thread
argument_list|,
operator|&
name|ar
operator|->
name|ar_task
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|autofs_request_zone
argument_list|,
name|ar
argument_list|)
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|autofs_softc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Note that we do not do negative caching on purpose.  This 	 * way the user can retry access at any time, e.g. after fixing 	 * the failure reason, without waiting for cache timer to expire. 	 */
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|request_error
operator|==
literal|0
operator|&&
name|autofs_cache
operator|>
literal|0
condition|)
block|{
name|anp
operator|->
name|an_cached
operator|=
name|true
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|anp
operator|->
name|an_callout
argument_list|,
name|autofs_cache
operator|*
name|hz
argument_list|,
name|autofs_cache_callout
argument_list|,
name|anp
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|key
argument_list|,
name|M_AUTOFS
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|path
argument_list|,
name|M_AUTOFS
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
name|request_error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Send request to automountd(8) and wait for completion.  */
end_comment

begin_function
name|int
name|autofs_trigger
parameter_list|(
name|struct
name|autofs_node
modifier|*
name|anp
parameter_list|,
specifier|const
name|char
modifier|*
name|component
parameter_list|,
name|int
name|componentlen
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|error
operator|=
name|autofs_trigger_one
argument_list|(
name|anp
argument_list|,
name|component
argument_list|,
name|componentlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|anp
operator|->
name|an_retries
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|error
operator|==
name|EINTR
operator|||
name|error
operator|==
name|ERESTART
condition|)
block|{
name|AUTOFS_DEBUG
argument_list|(
literal|"trigger interrupted by signal, "
literal|"not retrying"
argument_list|)
expr_stmt|;
name|anp
operator|->
name|an_retries
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|anp
operator|->
name|an_retries
operator|++
expr_stmt|;
if|if
condition|(
name|anp
operator|->
name|an_retries
operator|>=
name|autofs_retry_attempts
condition|)
block|{
name|AUTOFS_DEBUG
argument_list|(
literal|"trigger failed %d times; returning "
literal|"error %d"
argument_list|,
name|anp
operator|->
name|an_retries
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|anp
operator|->
name|an_retries
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|AUTOFS_DEBUG
argument_list|(
literal|"trigger failed with error %d; will retry in "
literal|"%d seconds, %d attempts left"
argument_list|,
name|error
argument_list|,
name|autofs_retry_delay
argument_list|,
name|autofs_retry_attempts
operator|-
name|anp
operator|->
name|an_retries
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|autofs_softc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|pause
argument_list|(
literal|"autofs_retry"
argument_list|,
name|autofs_retry_delay
operator|*
name|hz
argument_list|)
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|autofs_softc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|autofs_ioctl_request
parameter_list|(
name|struct
name|autofs_daemon_request
modifier|*
name|adr
parameter_list|)
block|{
name|struct
name|autofs_request
modifier|*
name|ar
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|autofs_softc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|ar
argument_list|,
argument|&autofs_softc->sc_requests
argument_list|,
argument|ar_next
argument_list|)
block|{
if|if
condition|(
name|ar
operator|->
name|ar_done
condition|)
continue|continue;
if|if
condition|(
name|ar
operator|->
name|ar_in_progress
condition|)
continue|continue;
break|break;
block|}
if|if
condition|(
name|ar
operator|!=
name|NULL
condition|)
break|break;
name|error
operator|=
name|cv_wait_sig
argument_list|(
operator|&
name|autofs_softc
operator|->
name|sc_cv
argument_list|,
operator|&
name|autofs_softc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|sx_xunlock
argument_list|(
operator|&
name|autofs_softc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|AUTOFS_DEBUG
argument_list|(
literal|"failed with error %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
name|ar
operator|->
name|ar_in_progress
operator|=
name|true
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|autofs_softc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|adr
operator|->
name|adr_id
operator|=
name|ar
operator|->
name|ar_id
expr_stmt|;
name|strlcpy
argument_list|(
name|adr
operator|->
name|adr_from
argument_list|,
name|ar
operator|->
name|ar_from
argument_list|,
sizeof|sizeof
argument_list|(
name|adr
operator|->
name|adr_from
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|adr
operator|->
name|adr_path
argument_list|,
name|ar
operator|->
name|ar_path
argument_list|,
sizeof|sizeof
argument_list|(
name|adr
operator|->
name|adr_path
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|adr
operator|->
name|adr_prefix
argument_list|,
name|ar
operator|->
name|ar_prefix
argument_list|,
sizeof|sizeof
argument_list|(
name|adr
operator|->
name|adr_prefix
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|adr
operator|->
name|adr_key
argument_list|,
name|ar
operator|->
name|ar_key
argument_list|,
sizeof|sizeof
argument_list|(
name|adr
operator|->
name|adr_key
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|adr
operator|->
name|adr_options
argument_list|,
name|ar
operator|->
name|ar_options
argument_list|,
sizeof|sizeof
argument_list|(
name|adr
operator|->
name|adr_options
argument_list|)
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|curproc
argument_list|)
expr_stmt|;
name|autofs_softc
operator|->
name|sc_dev_sid
operator|=
name|curproc
operator|->
name|p_session
operator|->
name|s_sid
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|curproc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|autofs_ioctl_done
parameter_list|(
name|struct
name|autofs_daemon_done
modifier|*
name|add
parameter_list|)
block|{
name|struct
name|autofs_request
modifier|*
name|ar
decl_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|autofs_softc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ar
argument_list|,
argument|&autofs_softc->sc_requests
argument_list|,
argument|ar_next
argument_list|)
block|{
if|if
condition|(
name|ar
operator|->
name|ar_id
operator|==
name|add
operator|->
name|add_id
condition|)
break|break;
block|}
if|if
condition|(
name|ar
operator|==
name|NULL
condition|)
block|{
name|sx_xunlock
argument_list|(
operator|&
name|autofs_softc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|AUTOFS_DEBUG
argument_list|(
literal|"id %d not found"
argument_list|,
name|add
operator|->
name|add_id
argument_list|)
expr_stmt|;
return|return
operator|(
name|ESRCH
operator|)
return|;
block|}
name|ar
operator|->
name|ar_error
operator|=
name|add
operator|->
name|add_error
expr_stmt|;
name|ar
operator|->
name|ar_done
operator|=
name|true
expr_stmt|;
name|ar
operator|->
name|ar_in_progress
operator|=
name|false
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|autofs_softc
operator|->
name|sc_cv
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|autofs_softc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|autofs_open
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|sx_xlock
argument_list|(
operator|&
name|autofs_softc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
comment|/* 	 * We must never block automountd(8) and its descendants, and we use 	 * session ID to determine that: we store session id of the process 	 * that opened the device, and then compare it with session ids 	 * of triggering processes.  This means running a second automountd(8) 	 * instance would break the previous one.  The check below prevents 	 * it from happening. 	 */
if|if
condition|(
name|autofs_softc
operator|->
name|sc_dev_opened
condition|)
block|{
name|sx_xunlock
argument_list|(
operator|&
name|autofs_softc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|autofs_softc
operator|->
name|sc_dev_opened
operator|=
name|true
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|autofs_softc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|autofs_close
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|sx_xlock
argument_list|(
operator|&
name|autofs_softc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|autofs_softc
operator|->
name|sc_dev_opened
argument_list|,
operator|(
literal|"not opened?"
operator|)
argument_list|)
expr_stmt|;
name|autofs_softc
operator|->
name|sc_dev_opened
operator|=
name|false
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|autofs_softc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|autofs_ioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|autofs_softc
operator|->
name|sc_dev_opened
argument_list|,
operator|(
literal|"not opened?"
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|AUTOFSREQUEST
case|:
return|return
operator|(
name|autofs_ioctl_request
argument_list|(
operator|(
expr|struct
name|autofs_daemon_request
operator|*
operator|)
name|arg
argument_list|)
operator|)
return|;
case|case
name|AUTOFSDONE
case|:
return|return
operator|(
name|autofs_ioctl_done
argument_list|(
operator|(
expr|struct
name|autofs_daemon_done
operator|*
operator|)
name|arg
argument_list|)
operator|)
return|;
default|default:
name|AUTOFS_DEBUG
argument_list|(
literal|"invalid cmd %lx"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
end_function

end_unit

