begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2007-2009 Google Inc. and Amit Singh  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  * * Redistributions of source code must retain the above copyright  *   notice, this list of conditions and the following disclaimer.  * * Redistributions in binary form must reproduce the above  *   copyright notice, this list of conditions and the following disclaimer  *   in the documentation and/or other materials provided with the  *   distribution.  * * Neither the name of Google Inc. nor the names of its  *   contributors may be used to endorse or promote products derived from  *   this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * Copyright (C) 2005 Csaba Henk.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/fnv_hash.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<security/mac/mac_framework.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|"fuse.h"
end_include

begin_include
include|#
directive|include
file|"fuse_node.h"
end_include

begin_include
include|#
directive|include
file|"fuse_internal.h"
end_include

begin_include
include|#
directive|include
file|"fuse_io.h"
end_include

begin_include
include|#
directive|include
file|"fuse_ipc.h"
end_include

begin_define
define|#
directive|define
name|FUSE_DEBUG_MODULE
value|VNOPS
end_define

begin_include
include|#
directive|include
file|"fuse_debug.h"
end_include

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_FUSEVN
argument_list|,
literal|"fuse_vnode"
argument_list|,
literal|"fuse vnode private data"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|fuse_node_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_fuse
argument_list|,
name|OID_AUTO
argument_list|,
name|node_count
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|fuse_node_count
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|fuse_data_cache_enable
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_fuse
argument_list|,
name|OID_AUTO
argument_list|,
name|data_cache_enable
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|fuse_data_cache_enable
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|fuse_data_cache_invalidate
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_fuse
argument_list|,
name|OID_AUTO
argument_list|,
name|data_cache_invalidate
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|fuse_data_cache_invalidate
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|fuse_mmap_enable
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_fuse
argument_list|,
name|OID_AUTO
argument_list|,
name|mmap_enable
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|fuse_mmap_enable
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|fuse_refresh_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_fuse
argument_list|,
name|OID_AUTO
argument_list|,
name|refresh_size
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|fuse_refresh_size
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|fuse_sync_resize
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_fuse
argument_list|,
name|OID_AUTO
argument_list|,
name|sync_resize
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|fuse_sync_resize
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|fuse_fix_broken_io
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_fuse
argument_list|,
name|OID_AUTO
argument_list|,
name|fix_broken_io
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|fuse_fix_broken_io
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|fuse_vnode_init
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|struct
name|fuse_vnode_data
modifier|*
name|fvdat
parameter_list|,
name|uint64_t
name|nodeid
parameter_list|,
name|enum
name|vtype
name|vtyp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|fvdat
operator|->
name|nid
operator|=
name|nodeid
expr_stmt|;
if|if
condition|(
name|nodeid
operator|==
name|FUSE_ROOT_ID
condition|)
block|{
name|vp
operator|->
name|v_vflag
operator||=
name|VV_ROOT
expr_stmt|;
block|}
name|vp
operator|->
name|v_type
operator|=
name|vtyp
expr_stmt|;
name|vp
operator|->
name|v_data
operator|=
name|fvdat
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FUFH_MAXTYPE
condition|;
name|i
operator|++
control|)
name|fvdat
operator|->
name|fufh
index|[
name|i
index|]
operator|.
name|fh_type
operator|=
name|FUFH_INVALID
expr_stmt|;
name|atomic_add_acq_int
argument_list|(
operator|&
name|fuse_node_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fuse_vnode_destroy
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|)
block|{
name|struct
name|fuse_vnode_data
modifier|*
name|fvdat
init|=
name|vp
operator|->
name|v_data
decl_stmt|;
name|vp
operator|->
name|v_data
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|fvdat
argument_list|,
name|M_FUSEVN
argument_list|)
expr_stmt|;
name|atomic_subtract_acq_int
argument_list|(
operator|&
name|fuse_node_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|fuse_vnode_cmp
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|void
modifier|*
name|nidp
parameter_list|)
block|{
return|return
operator|(
name|VTOI
argument_list|(
name|vp
argument_list|)
operator|!=
operator|*
operator|(
operator|(
name|uint64_t
operator|*
operator|)
name|nidp
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|__inline
name|fuse_vnode_hash
parameter_list|(
name|uint64_t
name|id
parameter_list|)
block|{
return|return
operator|(
name|fnv_32_buf
argument_list|(
operator|&
name|id
argument_list|,
sizeof|sizeof
argument_list|(
name|id
argument_list|)
argument_list|,
name|FNV1_32_INIT
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fuse_vnode_alloc
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|uint64_t
name|nodeid
parameter_list|,
name|enum
name|vtype
name|vtyp
parameter_list|,
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
parameter_list|)
block|{
name|struct
name|fuse_vnode_data
modifier|*
name|fvdat
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp2
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|FS_DEBUG
argument_list|(
literal|"been asked for vno #%ju\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|nodeid
argument_list|)
expr_stmt|;
if|if
condition|(
name|vtyp
operator|==
name|VNON
condition|)
block|{
return|return
name|EINVAL
return|;
block|}
operator|*
name|vpp
operator|=
name|NULL
expr_stmt|;
name|err
operator|=
name|vfs_hash_get
argument_list|(
name|mp
argument_list|,
name|fuse_vnode_hash
argument_list|(
name|nodeid
argument_list|)
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
name|td
argument_list|,
name|vpp
argument_list|,
name|fuse_vnode_cmp
argument_list|,
operator|&
name|nodeid
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
operator|*
name|vpp
condition|)
block|{
name|MPASS
argument_list|(
operator|(
operator|*
name|vpp
operator|)
operator|->
name|v_type
operator|==
name|vtyp
operator|&&
operator|(
operator|*
name|vpp
operator|)
operator|->
name|v_data
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|FS_DEBUG
argument_list|(
literal|"vnode taken from hash\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|fvdat
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|fvdat
argument_list|)
argument_list|,
name|M_FUSEVN
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|err
operator|=
name|getnewvnode
argument_list|(
literal|"fuse"
argument_list|,
name|mp
argument_list|,
operator|&
name|fuse_vnops
argument_list|,
name|vpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|free
argument_list|(
name|fvdat
argument_list|,
name|M_FUSEVN
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|lockmgr
argument_list|(
operator|(
operator|*
name|vpp
operator|)
operator|->
name|v_vnlock
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fuse_vnode_init
argument_list|(
operator|*
name|vpp
argument_list|,
name|fvdat
argument_list|,
name|nodeid
argument_list|,
name|vtyp
argument_list|)
expr_stmt|;
name|err
operator|=
name|insmntque
argument_list|(
operator|*
name|vpp
argument_list|,
name|mp
argument_list|)
expr_stmt|;
name|ASSERT_VOP_ELOCKED
argument_list|(
operator|*
name|vpp
argument_list|,
literal|"fuse_vnode_alloc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|free
argument_list|(
name|fvdat
argument_list|,
name|M_FUSEVN
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|err
operator|=
name|vfs_hash_insert
argument_list|(
operator|*
name|vpp
argument_list|,
name|fuse_vnode_hash
argument_list|(
name|nodeid
argument_list|)
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
name|td
argument_list|,
operator|&
name|vp2
argument_list|,
name|fuse_vnode_cmp
argument_list|,
operator|&
name|nodeid
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
name|vp2
operator|!=
name|NULL
condition|)
block|{
operator|*
name|vpp
operator|=
name|vp2
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ASSERT_VOP_ELOCKED
argument_list|(
operator|*
name|vpp
argument_list|,
literal|"fuse_vnode_alloc"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|fuse_vnode_get
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|uint64_t
name|nodeid
parameter_list|,
name|struct
name|vnode
modifier|*
name|dvp
parameter_list|,
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
parameter_list|,
name|struct
name|componentname
modifier|*
name|cnp
parameter_list|,
name|enum
name|vtype
name|vtyp
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
init|=
operator|(
name|cnp
operator|!=
name|NULL
condition|?
name|cnp
operator|->
name|cn_thread
else|:
name|curthread
operator|)
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|debug_printf
argument_list|(
literal|"dvp=%p\n"
argument_list|,
name|dvp
argument_list|)
expr_stmt|;
name|err
operator|=
name|fuse_vnode_alloc
argument_list|(
name|mp
argument_list|,
name|td
argument_list|,
name|nodeid
argument_list|,
name|vtyp
argument_list|,
name|vpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
return|return
name|err
return|;
block|}
if|if
condition|(
name|dvp
operator|!=
name|NULL
condition|)
block|{
name|MPASS
argument_list|(
operator|(
name|cnp
operator|->
name|cn_flags
operator|&
name|ISDOTDOT
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
operator|!
operator|(
name|cnp
operator|->
name|cn_namelen
operator|==
literal|1
operator|&&
name|cnp
operator|->
name|cn_nameptr
index|[
literal|0
index|]
operator|==
literal|'.'
operator|)
argument_list|)
expr_stmt|;
name|fuse_vnode_setparent
argument_list|(
operator|*
name|vpp
argument_list|,
name|dvp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dvp
operator|!=
name|NULL
operator|&&
name|cnp
operator|!=
name|NULL
operator|&&
operator|(
name|cnp
operator|->
name|cn_flags
operator|&
name|MAKEENTRY
operator|)
operator|!=
literal|0
condition|)
block|{
name|ASSERT_VOP_LOCKED
argument_list|(
operator|*
name|vpp
argument_list|,
literal|"fuse_vnode_get"
argument_list|)
expr_stmt|;
name|ASSERT_VOP_LOCKED
argument_list|(
name|dvp
argument_list|,
literal|"fuse_vnode_get"
argument_list|)
expr_stmt|;
name|cache_enter
argument_list|(
name|dvp
argument_list|,
operator|*
name|vpp
argument_list|,
name|cnp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * In userland, libfuse uses cached lookups for dot and dotdot entries, 	 * thus it does not really bump the nlookup counter for forget. 	 * Follow the same semantic and avoid tu bump it in order to keep 	 * nlookup counters consistent. 	 */
if|if
condition|(
name|cnp
operator|==
name|NULL
operator|||
operator|(
operator|(
name|cnp
operator|->
name|cn_flags
operator|&
name|ISDOTDOT
operator|)
operator|==
literal|0
operator|&&
operator|(
name|cnp
operator|->
name|cn_namelen
operator|!=
literal|1
operator|||
name|cnp
operator|->
name|cn_nameptr
index|[
literal|0
index|]
operator|!=
literal|'.'
operator|)
operator|)
condition|)
name|VTOFUD
argument_list|(
operator|*
name|vpp
argument_list|)
operator|->
name|nlookup
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|fuse_vnode_open
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|int32_t
name|fuse_open_flags
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
comment|/* 	 * Funcation is called for every vnode open. 	 * Merge fuse_open_flags it may be 0 	 */
comment|/* 	 * Ideally speaking, direct io should be enabled on 	 * fd's but do not see of any way of providing that 	 * this implementation. 	 * 	 * Also cannot think of a reason why would two 	 * different fd's on same vnode would like 	 * have DIRECT_IO turned on and off. But linux 	 * based implementation works on an fd not an 	 * inode and provides such a feature. 	 * 	 * XXXIP: Handle fd based DIRECT_IO 	 */
if|if
condition|(
name|fuse_open_flags
operator|&
name|FOPEN_DIRECT_IO
condition|)
block|{
name|ASSERT_VOP_ELOCKED
argument_list|(
name|vp
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|VTOFUD
argument_list|(
name|vp
argument_list|)
operator|->
name|flag
operator||=
name|FN_DIRECTIO
expr_stmt|;
name|fuse_io_invalbuf
argument_list|(
name|vp
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|fuse_open_flags
operator|&
name|FOPEN_KEEP_CACHE
operator|)
operator|==
literal|0
condition|)
name|fuse_io_invalbuf
argument_list|(
name|vp
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|VTOFUD
argument_list|(
name|vp
argument_list|)
operator|->
name|flag
operator|&=
operator|~
name|FN_DIRECTIO
expr_stmt|;
block|}
if|if
condition|(
name|vnode_vtype
argument_list|(
name|vp
argument_list|)
operator|==
name|VREG
condition|)
block|{
comment|/* XXXIP prevent getattr, by using cached node size */
name|vnode_create_vobject
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|fuse_vnode_savesize
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|)
block|{
name|struct
name|fuse_vnode_data
modifier|*
name|fvdat
init|=
name|VTOFUD
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|struct
name|fuse_filehandle
modifier|*
name|fufh
init|=
name|NULL
decl_stmt|;
name|struct
name|fuse_dispatcher
name|fdi
decl_stmt|;
name|struct
name|fuse_setattr_in
modifier|*
name|fsai
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|FS_DEBUG
argument_list|(
literal|"inode=%ju size=%ju\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|VTOI
argument_list|(
name|vp
argument_list|)
argument_list|,
operator|(
name|uintmax_t
operator|)
name|fvdat
operator|->
name|filesize
argument_list|)
expr_stmt|;
name|ASSERT_VOP_ELOCKED
argument_list|(
name|vp
argument_list|,
literal|"fuse_io_extend"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fuse_isdeadfs
argument_list|(
name|vp
argument_list|)
condition|)
block|{
return|return
name|EBADF
return|;
block|}
if|if
condition|(
name|vnode_vtype
argument_list|(
name|vp
argument_list|)
operator|==
name|VDIR
condition|)
block|{
return|return
name|EISDIR
return|;
block|}
if|if
condition|(
name|vfs_isrdonly
argument_list|(
name|vnode_mount
argument_list|(
name|vp
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|EROFS
return|;
block|}
if|if
condition|(
name|cred
operator|==
name|NULL
condition|)
block|{
name|cred
operator|=
name|td
operator|->
name|td_ucred
expr_stmt|;
block|}
name|fdisp_init
argument_list|(
operator|&
name|fdi
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fsai
argument_list|)
argument_list|)
expr_stmt|;
name|fdisp_make_vp
argument_list|(
operator|&
name|fdi
argument_list|,
name|FUSE_SETATTR
argument_list|,
name|vp
argument_list|,
name|td
argument_list|,
name|cred
argument_list|)
expr_stmt|;
name|fsai
operator|=
name|fdi
operator|.
name|indata
expr_stmt|;
name|fsai
operator|->
name|valid
operator|=
literal|0
expr_stmt|;
comment|/* Truncate to a new value. */
name|fsai
operator|->
name|size
operator|=
name|fvdat
operator|->
name|filesize
expr_stmt|;
name|fsai
operator|->
name|valid
operator||=
name|FATTR_SIZE
expr_stmt|;
name|fuse_filehandle_getrw
argument_list|(
name|vp
argument_list|,
name|FUFH_WRONLY
argument_list|,
operator|&
name|fufh
argument_list|)
expr_stmt|;
if|if
condition|(
name|fufh
condition|)
block|{
name|fsai
operator|->
name|fh
operator|=
name|fufh
operator|->
name|fh_id
expr_stmt|;
name|fsai
operator|->
name|valid
operator||=
name|FATTR_FH
expr_stmt|;
block|}
name|err
operator|=
name|fdisp_wait_answ
argument_list|(
operator|&
name|fdi
argument_list|)
expr_stmt|;
name|fdisp_destroy
argument_list|(
operator|&
name|fdi
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
name|fvdat
operator|->
name|flag
operator|&=
operator|~
name|FN_SIZECHANGE
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|void
name|fuse_vnode_refreshsize
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|)
block|{
name|struct
name|fuse_vnode_data
modifier|*
name|fvdat
init|=
name|VTOFUD
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|vattr
name|va
decl_stmt|;
if|if
condition|(
operator|(
name|fvdat
operator|->
name|flag
operator|&
name|FN_SIZECHANGE
operator|)
operator|!=
literal|0
operator|||
operator|(
name|fuse_refresh_size
operator|==
literal|0
operator|&&
name|fvdat
operator|->
name|filesize
operator|!=
literal|0
operator|)
condition|)
return|return;
name|VOP_GETATTR
argument_list|(
name|vp
argument_list|,
operator|&
name|va
argument_list|,
name|cred
argument_list|)
expr_stmt|;
name|FS_DEBUG
argument_list|(
literal|"refreshed file size: %jd\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|VTOFUD
argument_list|(
name|vp
argument_list|)
operator|->
name|filesize
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|fuse_vnode_setsize
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|off_t
name|newsize
parameter_list|)
block|{
name|struct
name|fuse_vnode_data
modifier|*
name|fvdat
init|=
name|VTOFUD
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|off_t
name|oldsize
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|FS_DEBUG
argument_list|(
literal|"inode=%ju oldsize=%ju newsize=%ju\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|VTOI
argument_list|(
name|vp
argument_list|)
argument_list|,
operator|(
name|uintmax_t
operator|)
name|fvdat
operator|->
name|filesize
argument_list|,
operator|(
name|uintmax_t
operator|)
name|newsize
argument_list|)
expr_stmt|;
name|ASSERT_VOP_ELOCKED
argument_list|(
name|vp
argument_list|,
literal|"fuse_vnode_setsize"
argument_list|)
expr_stmt|;
name|oldsize
operator|=
name|fvdat
operator|->
name|filesize
expr_stmt|;
name|fvdat
operator|->
name|filesize
operator|=
name|newsize
expr_stmt|;
name|fvdat
operator|->
name|flag
operator||=
name|FN_SIZECHANGE
expr_stmt|;
if|if
condition|(
name|newsize
operator|<
name|oldsize
condition|)
block|{
name|err
operator|=
name|vtruncbuf
argument_list|(
name|vp
argument_list|,
name|cred
argument_list|,
name|newsize
argument_list|,
name|fuse_iosize
argument_list|(
name|vp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|vnode_pager_setsize
argument_list|(
name|vp
argument_list|,
name|newsize
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

end_unit

