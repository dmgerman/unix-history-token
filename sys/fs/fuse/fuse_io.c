begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2007-2009 Google Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  * * Redistributions of source code must retain the above copyright  *   notice, this list of conditions and the following disclaimer.  * * Redistributions in binary form must reproduce the above  *   copyright notice, this list of conditions and the following disclaimer  *   in the documentation and/or other materials provided with the  *   distribution.  * * Neither the name of Google Inc. nor the names of its  *   contributors may be used to endorse or promote products derived from  *   this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * Copyright (C) 2005 Csaba Henk.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/filedesc.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pager.h>
end_include

begin_include
include|#
directive|include
file|<vm/vnode_pager.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|"fuse.h"
end_include

begin_include
include|#
directive|include
file|"fuse_file.h"
end_include

begin_include
include|#
directive|include
file|"fuse_node.h"
end_include

begin_include
include|#
directive|include
file|"fuse_internal.h"
end_include

begin_include
include|#
directive|include
file|"fuse_ipc.h"
end_include

begin_include
include|#
directive|include
file|"fuse_io.h"
end_include

begin_define
define|#
directive|define
name|FUSE_DEBUG_MODULE
value|IO
end_define

begin_include
include|#
directive|include
file|"fuse_debug.h"
end_include

begin_function_decl
specifier|static
name|int
name|fuse_read_directbackend
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|fuse_filehandle
modifier|*
name|fufh
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fuse_read_biobackend
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|fuse_filehandle
modifier|*
name|fufh
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fuse_write_directbackend
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|fuse_filehandle
modifier|*
name|fufh
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fuse_write_biobackend
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|fuse_filehandle
modifier|*
name|fufh
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|fuse_io_dispatch
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|)
block|{
name|struct
name|fuse_filehandle
modifier|*
name|fufh
decl_stmt|;
name|int
name|err
decl_stmt|,
name|directio
decl_stmt|;
name|MPASS
argument_list|(
name|vp
operator|->
name|v_type
operator|==
name|VREG
argument_list|)
expr_stmt|;
name|err
operator|=
name|fuse_filehandle_getrw
argument_list|(
name|vp
argument_list|,
operator|(
name|uio
operator|->
name|uio_rw
operator|==
name|UIO_READ
operator|)
condition|?
name|FUFH_RDONLY
else|:
name|FUFH_WRONLY
argument_list|,
operator|&
name|fufh
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|printf
argument_list|(
literal|"FUSE: io dispatch: filehandles are closed\n"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
comment|/*          * Ideally, when the daemon asks for direct io at open time, the          * standard file flag should be set according to this, so that would          * just change the default mode, which later on could be changed via          * fcntl(2).          * But this doesn't work, the O_DIRECT flag gets cleared at some point          * (don't know where). So to make any use of the Fuse direct_io option,          * we hardwire it into the file's private data (similarly to Linux,          * btw.).          */
name|directio
operator|=
operator|(
name|ioflag
operator|&
name|IO_DIRECT
operator|)
operator|||
operator|!
name|fsess_opt_datacache
argument_list|(
name|vnode_mount
argument_list|(
name|vp
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|uio
operator|->
name|uio_rw
condition|)
block|{
case|case
name|UIO_READ
case|:
if|if
condition|(
name|directio
condition|)
block|{
name|DEBUG
argument_list|(
literal|"direct read of vnode %ju via file handle %ju\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|VTOILLU
argument_list|(
name|vp
argument_list|)
argument_list|,
operator|(
name|uintmax_t
operator|)
name|fufh
operator|->
name|fh_id
argument_list|)
expr_stmt|;
name|err
operator|=
name|fuse_read_directbackend
argument_list|(
name|vp
argument_list|,
name|uio
argument_list|,
name|cred
argument_list|,
name|fufh
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DEBUG
argument_list|(
literal|"buffered read of vnode %ju\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|VTOILLU
argument_list|(
name|vp
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|fuse_read_biobackend
argument_list|(
name|vp
argument_list|,
name|uio
argument_list|,
name|cred
argument_list|,
name|fufh
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|UIO_WRITE
case|:
if|if
condition|(
name|directio
condition|)
block|{
name|DEBUG
argument_list|(
literal|"direct write of vnode %ju via file handle %ju\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|VTOILLU
argument_list|(
name|vp
argument_list|)
argument_list|,
operator|(
name|uintmax_t
operator|)
name|fufh
operator|->
name|fh_id
argument_list|)
expr_stmt|;
name|err
operator|=
name|fuse_write_directbackend
argument_list|(
name|vp
argument_list|,
name|uio
argument_list|,
name|cred
argument_list|,
name|fufh
argument_list|)
expr_stmt|;
name|fuse_invalidate_attr
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DEBUG
argument_list|(
literal|"buffered write of vnode %ju\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|VTOILLU
argument_list|(
name|vp
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|fuse_write_biobackend
argument_list|(
name|vp
argument_list|,
name|uio
argument_list|,
name|cred
argument_list|,
name|fufh
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|panic
argument_list|(
literal|"uninterpreted mode passed to fuse_io_dispatch"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fuse_read_biobackend
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|fuse_filehandle
modifier|*
name|fufh
parameter_list|)
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|daddr_t
name|lbn
decl_stmt|;
name|int
name|bcount
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|,
name|n
init|=
literal|0
decl_stmt|,
name|on
init|=
literal|0
decl_stmt|;
name|off_t
name|filesize
decl_stmt|;
specifier|const
name|int
name|biosize
init|=
name|fuse_iosize
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|DEBUG
argument_list|(
literal|"resid=%zx offset=%jx fsize=%jx\n"
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|,
name|uio
operator|->
name|uio_offset
argument_list|,
name|VTOFUD
argument_list|(
name|vp
argument_list|)
operator|->
name|filesize
argument_list|)
expr_stmt|;
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|uio
operator|->
name|uio_offset
operator|<
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|bcount
operator|=
name|MIN
argument_list|(
name|MAXBSIZE
argument_list|,
name|biosize
argument_list|)
expr_stmt|;
name|filesize
operator|=
name|VTOFUD
argument_list|(
name|vp
argument_list|)
operator|->
name|filesize
expr_stmt|;
do|do
block|{
if|if
condition|(
name|fuse_isdeadfs
argument_list|(
name|vp
argument_list|)
condition|)
block|{
name|err
operator|=
name|ENXIO
expr_stmt|;
break|break;
block|}
name|lbn
operator|=
name|uio
operator|->
name|uio_offset
operator|/
name|biosize
expr_stmt|;
name|on
operator|=
name|uio
operator|->
name|uio_offset
operator|&
operator|(
name|biosize
operator|-
literal|1
operator|)
expr_stmt|;
name|DEBUG2G
argument_list|(
literal|"biosize %d, lbn %d, on %d\n"
argument_list|,
name|biosize
argument_list|,
operator|(
name|int
operator|)
name|lbn
argument_list|,
name|on
argument_list|)
expr_stmt|;
comment|/* 	         * Obtain the buffer cache block.  Figure out the buffer size 	         * when we are at EOF.  If we are modifying the size of the 	         * buffer based on an EOF condition we need to hold 	         * nfs_rslock() through obtaining the buffer to prevent 	         * a potential writer-appender from messing with n_size. 	         * Otherwise we may accidently truncate the buffer and 	         * lose dirty data. 	         * 	         * Note that bcount is *not* DEV_BSIZE aligned. 	         */
if|if
condition|(
operator|(
name|off_t
operator|)
name|lbn
operator|*
name|biosize
operator|>=
name|filesize
condition|)
block|{
name|bcount
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
call|(
name|off_t
call|)
argument_list|(
name|lbn
operator|+
literal|1
argument_list|)
operator|*
name|biosize
operator|>
name|filesize
condition|)
block|{
name|bcount
operator|=
name|filesize
operator|-
operator|(
name|off_t
operator|)
name|lbn
operator|*
name|biosize
expr_stmt|;
block|}
name|bp
operator|=
name|getblk
argument_list|(
name|vp
argument_list|,
name|lbn
argument_list|,
name|bcount
argument_list|,
name|PCATCH
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bp
condition|)
return|return
operator|(
name|EINTR
operator|)
return|;
comment|/* 	         * If B_CACHE is not set, we must issue the read.  If this 	         * fails, we return an error. 	         */
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_CACHE
operator|)
operator|==
literal|0
condition|)
block|{
name|bp
operator|->
name|b_iocmd
operator|=
name|BIO_READ
expr_stmt|;
name|vfs_busy_pages
argument_list|(
name|bp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|err
operator|=
name|fuse_io_strategy
argument_list|(
name|vp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
block|}
comment|/* 	         * on is the offset into the current bp.  Figure out how many 	         * bytes we can copy out of the bp.  Note that bcount is 	         * NOT DEV_BSIZE aligned. 	         * 	         * Then figure out how many bytes we can copy into the uio. 	         */
name|n
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|on
operator|<
name|bcount
condition|)
name|n
operator|=
name|MIN
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|bcount
operator|-
name|on
argument_list|)
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|DEBUG2G
argument_list|(
literal|"feeding buffeater with %d bytes of buffer %p,"
literal|" saying %d was asked for\n"
argument_list|,
name|n
argument_list|,
name|bp
operator|->
name|b_data
operator|+
name|on
argument_list|,
name|n
operator|+
operator|(
name|int
operator|)
name|bp
operator|->
name|b_resid
argument_list|)
expr_stmt|;
name|err
operator|=
name|uiomove
argument_list|(
name|bp
operator|->
name|b_data
operator|+
name|on
argument_list|,
name|n
argument_list|,
name|uio
argument_list|)
expr_stmt|;
block|}
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|DEBUG2G
argument_list|(
literal|"end of turn, err %d, uio->uio_resid %zd, n %d\n"
argument_list|,
name|err
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|err
operator|==
literal|0
operator|&&
name|uio
operator|->
name|uio_resid
operator|>
literal|0
operator|&&
name|n
operator|>
literal|0
condition|)
do|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fuse_read_directbackend
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|fuse_filehandle
modifier|*
name|fufh
parameter_list|)
block|{
name|struct
name|fuse_dispatcher
name|fdi
decl_stmt|;
name|struct
name|fuse_read_in
modifier|*
name|fri
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|fdisp_init
argument_list|(
operator|&
name|fdi
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*          * XXX In "normal" case we use an intermediate kernel buffer for          * transmitting data from daemon's context to ours. Eventually, we should          * get rid of this. Anyway, if the target uio lives in sysspace (we are          * called from pageops), and the input data doesn't need kernel-side          * processing (we are not called from readdir) we can already invoke          * an optimized, "peer-to-peer" I/O routine.          */
while|while
condition|(
name|uio
operator|->
name|uio_resid
operator|>
literal|0
condition|)
block|{
name|fdi
operator|.
name|iosize
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|fri
argument_list|)
expr_stmt|;
name|fdisp_make_vp
argument_list|(
operator|&
name|fdi
argument_list|,
name|FUSE_READ
argument_list|,
name|vp
argument_list|,
name|uio
operator|->
name|uio_td
argument_list|,
name|cred
argument_list|)
expr_stmt|;
name|fri
operator|=
name|fdi
operator|.
name|indata
expr_stmt|;
name|fri
operator|->
name|fh
operator|=
name|fufh
operator|->
name|fh_id
expr_stmt|;
name|fri
operator|->
name|offset
operator|=
name|uio
operator|->
name|uio_offset
expr_stmt|;
name|fri
operator|->
name|size
operator|=
name|MIN
argument_list|(
name|uio
operator|->
name|uio_resid
argument_list|,
name|fuse_get_mpdata
argument_list|(
name|vp
operator|->
name|v_mount
argument_list|)
operator|->
name|max_read
argument_list|)
expr_stmt|;
name|DEBUG2G
argument_list|(
literal|"fri->fh %ju, fri->offset %ju, fri->size %ju\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|fri
operator|->
name|fh
argument_list|,
operator|(
name|uintmax_t
operator|)
name|fri
operator|->
name|offset
argument_list|,
operator|(
name|uintmax_t
operator|)
name|fri
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|fdisp_wait_answ
argument_list|(
operator|&
name|fdi
argument_list|)
operator|)
condition|)
goto|goto
name|out
goto|;
name|DEBUG2G
argument_list|(
literal|"complete: got iosize=%d, requested fri.size=%zd; "
literal|"resid=%zd offset=%ju\n"
argument_list|,
name|fri
operator|->
name|size
argument_list|,
name|fdi
operator|.
name|iosize
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|,
operator|(
name|uintmax_t
operator|)
name|uio
operator|->
name|uio_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|uiomove
argument_list|(
name|fdi
operator|.
name|answ
argument_list|,
name|MIN
argument_list|(
name|fri
operator|->
name|size
argument_list|,
name|fdi
operator|.
name|iosize
argument_list|)
argument_list|,
name|uio
argument_list|)
operator|)
condition|)
break|break;
if|if
condition|(
name|fdi
operator|.
name|iosize
operator|<
name|fri
operator|->
name|size
condition|)
break|break;
block|}
name|out
label|:
name|fdisp_destroy
argument_list|(
operator|&
name|fdi
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fuse_write_directbackend
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|fuse_filehandle
modifier|*
name|fufh
parameter_list|)
block|{
name|struct
name|fuse_vnode_data
modifier|*
name|fvdat
init|=
name|VTOFUD
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|fuse_write_in
modifier|*
name|fwi
decl_stmt|;
name|struct
name|fuse_dispatcher
name|fdi
decl_stmt|;
name|size_t
name|chunksize
decl_stmt|;
name|int
name|diff
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|uio
operator|->
name|uio_resid
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|fdisp_init
argument_list|(
operator|&
name|fdi
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|uio
operator|->
name|uio_resid
operator|>
literal|0
condition|)
block|{
name|chunksize
operator|=
name|MIN
argument_list|(
name|uio
operator|->
name|uio_resid
argument_list|,
name|fuse_get_mpdata
argument_list|(
name|vp
operator|->
name|v_mount
argument_list|)
operator|->
name|max_write
argument_list|)
expr_stmt|;
name|fdi
operator|.
name|iosize
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|fwi
argument_list|)
operator|+
name|chunksize
expr_stmt|;
name|fdisp_make_vp
argument_list|(
operator|&
name|fdi
argument_list|,
name|FUSE_WRITE
argument_list|,
name|vp
argument_list|,
name|uio
operator|->
name|uio_td
argument_list|,
name|cred
argument_list|)
expr_stmt|;
name|fwi
operator|=
name|fdi
operator|.
name|indata
expr_stmt|;
name|fwi
operator|->
name|fh
operator|=
name|fufh
operator|->
name|fh_id
expr_stmt|;
name|fwi
operator|->
name|offset
operator|=
name|uio
operator|->
name|uio_offset
expr_stmt|;
name|fwi
operator|->
name|size
operator|=
name|chunksize
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|uiomove
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fdi
operator|.
name|indata
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|fwi
argument_list|)
argument_list|,
name|chunksize
argument_list|,
name|uio
argument_list|)
operator|)
condition|)
break|break;
if|if
condition|(
operator|(
name|err
operator|=
name|fdisp_wait_answ
argument_list|(
operator|&
name|fdi
argument_list|)
operator|)
condition|)
break|break;
name|diff
operator|=
name|chunksize
operator|-
operator|(
operator|(
expr|struct
name|fuse_write_out
operator|*
operator|)
name|fdi
operator|.
name|answ
operator|)
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|diff
operator|<
literal|0
condition|)
block|{
name|err
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|uio
operator|->
name|uio_resid
operator|+=
name|diff
expr_stmt|;
name|uio
operator|->
name|uio_offset
operator|-=
name|diff
expr_stmt|;
if|if
condition|(
name|uio
operator|->
name|uio_offset
operator|>
name|fvdat
operator|->
name|filesize
condition|)
name|fuse_vnode_setsize
argument_list|(
name|vp
argument_list|,
name|cred
argument_list|,
name|uio
operator|->
name|uio_offset
argument_list|)
expr_stmt|;
block|}
name|fdisp_destroy
argument_list|(
operator|&
name|fdi
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fuse_write_biobackend
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|fuse_filehandle
modifier|*
name|fufh
parameter_list|)
block|{
name|struct
name|fuse_vnode_data
modifier|*
name|fvdat
init|=
name|VTOFUD
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|daddr_t
name|lbn
decl_stmt|;
name|int
name|bcount
decl_stmt|;
name|int
name|n
decl_stmt|,
name|on
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|;
specifier|const
name|int
name|biosize
init|=
name|fuse_iosize
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|KASSERT
argument_list|(
name|uio
operator|->
name|uio_rw
operator|==
name|UIO_WRITE
argument_list|,
operator|(
literal|"ncl_write mode"
operator|)
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|"resid=%zx offset=%jx fsize=%jx\n"
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|,
name|uio
operator|->
name|uio_offset
argument_list|,
name|fvdat
operator|->
name|filesize
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|VREG
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
if|if
condition|(
name|uio
operator|->
name|uio_offset
operator|<
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/*          * Find all of this file's B_NEEDCOMMIT buffers.  If our writes          * would exceed the local maximum per-file write commit size when          * combined with those, we must decide whether to flush,          * go synchronous, or return err.  We don't bother checking          * IO_UNIT -- we just make all writes atomic anyway, as there's          * no point optimizing for something that really won't ever happen.          */
do|do
block|{
if|if
condition|(
name|fuse_isdeadfs
argument_list|(
name|vp
argument_list|)
condition|)
block|{
name|err
operator|=
name|ENXIO
expr_stmt|;
break|break;
block|}
name|lbn
operator|=
name|uio
operator|->
name|uio_offset
operator|/
name|biosize
expr_stmt|;
name|on
operator|=
name|uio
operator|->
name|uio_offset
operator|&
operator|(
name|biosize
operator|-
literal|1
operator|)
expr_stmt|;
name|n
operator|=
name|MIN
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|biosize
operator|-
name|on
argument_list|)
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|)
expr_stmt|;
name|DEBUG2G
argument_list|(
literal|"lbn %ju, on %d, n %d, uio offset %ju, uio resid %zd\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|lbn
argument_list|,
name|on
argument_list|,
name|n
argument_list|,
operator|(
name|uintmax_t
operator|)
name|uio
operator|->
name|uio_offset
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|)
expr_stmt|;
name|again
label|:
comment|/* 	         * Handle direct append and file extension cases, calculate 	         * unaligned buffer size. 	         */
if|if
condition|(
name|uio
operator|->
name|uio_offset
operator|==
name|fvdat
operator|->
name|filesize
operator|&&
name|n
condition|)
block|{
comment|/* 	                 * Get the buffer (in its pre-append state to maintain 	                 * B_CACHE if it was previously set).  Resize the 	                 * nfsnode after we have locked the buffer to prevent 	                 * readers from reading garbage. 	                 */
name|bcount
operator|=
name|on
expr_stmt|;
name|DEBUG
argument_list|(
literal|"getting block from OS, bcount %d\n"
argument_list|,
name|bcount
argument_list|)
expr_stmt|;
name|bp
operator|=
name|getblk
argument_list|(
name|vp
argument_list|,
name|lbn
argument_list|,
name|bcount
argument_list|,
name|PCATCH
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
block|{
name|long
name|save
decl_stmt|;
name|err
operator|=
name|fuse_vnode_setsize
argument_list|(
name|vp
argument_list|,
name|cred
argument_list|,
name|uio
operator|->
name|uio_offset
operator|+
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
break|break;
block|}
name|save
operator|=
name|bp
operator|->
name|b_flags
operator|&
name|B_CACHE
expr_stmt|;
name|bcount
operator|+=
name|n
expr_stmt|;
name|allocbuf
argument_list|(
name|bp
argument_list|,
name|bcount
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|save
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 	                 * Obtain the locked cache block first, and then 	                 * adjust the file's size as appropriate. 	                 */
name|bcount
operator|=
name|on
operator|+
name|n
expr_stmt|;
if|if
condition|(
operator|(
name|off_t
operator|)
name|lbn
operator|*
name|biosize
operator|+
name|bcount
operator|<
name|fvdat
operator|->
name|filesize
condition|)
block|{
if|if
condition|(
call|(
name|off_t
call|)
argument_list|(
name|lbn
operator|+
literal|1
argument_list|)
operator|*
name|biosize
operator|<
name|fvdat
operator|->
name|filesize
condition|)
name|bcount
operator|=
name|biosize
expr_stmt|;
else|else
name|bcount
operator|=
name|fvdat
operator|->
name|filesize
operator|-
operator|(
name|off_t
operator|)
name|lbn
operator|*
name|biosize
expr_stmt|;
block|}
name|DEBUG
argument_list|(
literal|"getting block from OS, bcount %d\n"
argument_list|,
name|bcount
argument_list|)
expr_stmt|;
name|bp
operator|=
name|getblk
argument_list|(
name|vp
argument_list|,
name|lbn
argument_list|,
name|bcount
argument_list|,
name|PCATCH
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|&&
name|uio
operator|->
name|uio_offset
operator|+
name|n
operator|>
name|fvdat
operator|->
name|filesize
condition|)
block|{
name|err
operator|=
name|fuse_vnode_setsize
argument_list|(
name|vp
argument_list|,
name|cred
argument_list|,
name|uio
operator|->
name|uio_offset
operator|+
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|bp
condition|)
block|{
name|err
operator|=
name|EINTR
expr_stmt|;
break|break;
block|}
comment|/* 	         * Issue a READ if B_CACHE is not set.  In special-append 	         * mode, B_CACHE is based on the buffer prior to the write 	         * op and is typically set, avoiding the read.  If a read 	         * is required in special append mode, the server will 	         * probably send us a short-read since we extended the file 	         * on our end, resulting in b_resid == 0 and, thusly, 	         * B_CACHE getting set. 	         * 	         * We can also avoid issuing the read if the write covers 	         * the entire buffer.  We have to make sure the buffer state 	         * is reasonable in this case since we will not be initiating 	         * I/O.  See the comments in kern/vfs_bio.c's getblk() for 	         * more information. 	         * 	         * B_CACHE may also be set due to the buffer being cached 	         * normally. 	         */
if|if
condition|(
name|on
operator|==
literal|0
operator|&&
name|n
operator|==
name|bcount
condition|)
block|{
name|bp
operator|->
name|b_flags
operator||=
name|B_CACHE
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_INVAL
expr_stmt|;
name|bp
operator|->
name|b_ioflags
operator|&=
operator|~
name|BIO_ERROR
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_CACHE
operator|)
operator|==
literal|0
condition|)
block|{
name|bp
operator|->
name|b_iocmd
operator|=
name|BIO_READ
expr_stmt|;
name|vfs_busy_pages
argument_list|(
name|bp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fuse_io_strategy
argument_list|(
name|vp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|bp
operator|->
name|b_error
operator|)
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|bp
operator|->
name|b_wcred
operator|==
name|NOCRED
condition|)
name|bp
operator|->
name|b_wcred
operator|=
name|crhold
argument_list|(
name|cred
argument_list|)
expr_stmt|;
comment|/* 	         * If dirtyend exceeds file size, chop it down.  This should 	         * not normally occur but there is an append race where it 	         * might occur XXX, so we log it. 	         * 	         * If the chopping creates a reverse-indexed or degenerate 	         * situation with dirtyoff/end, we 0 both of them. 	         */
if|if
condition|(
name|bp
operator|->
name|b_dirtyend
operator|>
name|bcount
condition|)
block|{
name|DEBUG
argument_list|(
literal|"FUSE append race @%lx:%d\n"
argument_list|,
operator|(
name|long
operator|)
name|bp
operator|->
name|b_blkno
operator|*
name|biosize
argument_list|,
name|bp
operator|->
name|b_dirtyend
operator|-
name|bcount
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_dirtyend
operator|=
name|bcount
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|->
name|b_dirtyoff
operator|>=
name|bp
operator|->
name|b_dirtyend
condition|)
name|bp
operator|->
name|b_dirtyoff
operator|=
name|bp
operator|->
name|b_dirtyend
operator|=
literal|0
expr_stmt|;
comment|/* 	         * If the new write will leave a contiguous dirty 	         * area, just update the b_dirtyoff and b_dirtyend, 	         * otherwise force a write rpc of the old dirty area. 	         * 	         * While it is possible to merge discontiguous writes due to 	         * our having a B_CACHE buffer ( and thus valid read data 	         * for the hole), we don't because it could lead to 	         * significant cache coherency problems with multiple clients, 	         * especially if locking is implemented later on. 	         * 	         * as an optimization we could theoretically maintain 	         * a linked list of discontinuous areas, but we would still 	         * have to commit them separately so there isn't much 	         * advantage to it except perhaps a bit of asynchronization. 	         */
if|if
condition|(
name|bp
operator|->
name|b_dirtyend
operator|>
literal|0
operator|&&
operator|(
name|on
operator|>
name|bp
operator|->
name|b_dirtyend
operator|||
operator|(
name|on
operator|+
name|n
operator|)
operator|<
name|bp
operator|->
name|b_dirtyoff
operator|)
condition|)
block|{
comment|/* 	                 * Yes, we mean it. Write out everything to "storage" 	                 * immediatly, without hesitation. (Apart from other 	                 * reasons: the only way to know if a write is valid 	                 * if its actually written out.) 	                 */
name|bwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_error
operator|==
name|EINTR
condition|)
block|{
name|err
operator|=
name|EINTR
expr_stmt|;
break|break;
block|}
goto|goto
name|again
goto|;
block|}
name|err
operator|=
name|uiomove
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bp
operator|->
name|b_data
operator|+
name|on
argument_list|,
name|n
argument_list|,
name|uio
argument_list|)
expr_stmt|;
comment|/* 	         * Since this block is being modified, it must be written 	         * again and not just committed.  Since write clustering does 	         * not work for the stage 1 data write, only the stage 2 	         * commit rpc, we have to clear B_CLUSTEROK as well. 	         */
name|bp
operator|->
name|b_flags
operator|&=
operator|~
operator|(
name|B_NEEDCOMMIT
operator||
name|B_CLUSTEROK
operator|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|bp
operator|->
name|b_ioflags
operator||=
name|BIO_ERROR
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|err
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 	         * Only update dirtyoff/dirtyend if not a degenerate 	         * condition. 	         */
if|if
condition|(
name|n
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|b_dirtyend
operator|>
literal|0
condition|)
block|{
name|bp
operator|->
name|b_dirtyoff
operator|=
name|MIN
argument_list|(
name|on
argument_list|,
name|bp
operator|->
name|b_dirtyoff
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_dirtyend
operator|=
name|MAX
argument_list|(
operator|(
name|on
operator|+
name|n
operator|)
argument_list|,
name|bp
operator|->
name|b_dirtyend
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bp
operator|->
name|b_dirtyoff
operator|=
name|on
expr_stmt|;
name|bp
operator|->
name|b_dirtyend
operator|=
name|on
operator|+
name|n
expr_stmt|;
block|}
name|vfs_bio_set_valid
argument_list|(
name|bp
argument_list|,
name|on
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|bwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
break|break;
block|}
do|while
condition|(
name|uio
operator|->
name|uio_resid
operator|>
literal|0
operator|&&
name|n
operator|>
literal|0
condition|)
do|;
if|if
condition|(
name|fuse_sync_resize
operator|&&
operator|(
name|fvdat
operator|->
name|flag
operator|&
name|FN_SIZECHANGE
operator|)
operator|!=
literal|0
condition|)
name|fuse_vnode_savesize
argument_list|(
name|vp
argument_list|,
name|cred
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|fuse_io_strategy
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|fuse_filehandle
modifier|*
name|fufh
decl_stmt|;
name|struct
name|fuse_vnode_data
modifier|*
name|fvdat
init|=
name|VTOFUD
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|struct
name|uio
modifier|*
name|uiop
decl_stmt|;
name|struct
name|uio
name|uio
decl_stmt|;
name|struct
name|iovec
name|io
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
specifier|const
name|int
name|biosize
init|=
name|fuse_iosize
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|MPASS
argument_list|(
name|vp
operator|->
name|v_type
operator|==
name|VREG
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|bp
operator|->
name|b_iocmd
operator|==
name|BIO_READ
operator|||
name|bp
operator|->
name|b_iocmd
operator|==
name|BIO_WRITE
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|"inode=%ju offset=%jd resid=%ld\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|VTOI
argument_list|(
name|vp
argument_list|)
argument_list|,
call|(
name|intmax_t
call|)
argument_list|(
operator|(
operator|(
name|off_t
operator|)
name|bp
operator|->
name|b_blkno
operator|)
operator|*
name|biosize
argument_list|)
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|)
expr_stmt|;
name|error
operator|=
name|fuse_filehandle_getrw
argument_list|(
name|vp
argument_list|,
operator|(
name|bp
operator|->
name|b_iocmd
operator|==
name|BIO_READ
operator|)
condition|?
name|FUFH_RDONLY
else|:
name|FUFH_WRONLY
argument_list|,
operator|&
name|fufh
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"FUSE: strategy: filehandles are closed\n"
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_ioflags
operator||=
name|BIO_ERROR
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|error
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|cred
operator|=
name|bp
operator|->
name|b_iocmd
operator|==
name|BIO_READ
condition|?
name|bp
operator|->
name|b_rcred
else|:
name|bp
operator|->
name|b_wcred
expr_stmt|;
name|uiop
operator|=
operator|&
name|uio
expr_stmt|;
name|uiop
operator|->
name|uio_iov
operator|=
operator|&
name|io
expr_stmt|;
name|uiop
operator|->
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|uiop
operator|->
name|uio_segflg
operator|=
name|UIO_SYSSPACE
expr_stmt|;
name|uiop
operator|->
name|uio_td
operator|=
name|curthread
expr_stmt|;
comment|/*          * clear BIO_ERROR and B_INVAL state prior to initiating the I/O.  We          * do this here so we do not have to do it in all the code that          * calls us.          */
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_INVAL
expr_stmt|;
name|bp
operator|->
name|b_ioflags
operator|&=
operator|~
name|BIO_ERROR
expr_stmt|;
name|KASSERT
argument_list|(
operator|!
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_DONE
operator|)
argument_list|,
operator|(
literal|"fuse_io_strategy: bp %p already marked done"
operator|,
name|bp
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_iocmd
operator|==
name|BIO_READ
condition|)
block|{
name|io
operator|.
name|iov_len
operator|=
name|uiop
operator|->
name|uio_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|io
operator|.
name|iov_base
operator|=
name|bp
operator|->
name|b_data
expr_stmt|;
name|uiop
operator|->
name|uio_rw
operator|=
name|UIO_READ
expr_stmt|;
name|uiop
operator|->
name|uio_offset
operator|=
operator|(
operator|(
name|off_t
operator|)
name|bp
operator|->
name|b_blkno
operator|)
operator|*
name|biosize
expr_stmt|;
name|error
operator|=
name|fuse_read_directbackend
argument_list|(
name|vp
argument_list|,
name|uiop
argument_list|,
name|cred
argument_list|,
name|fufh
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|error
operator|&&
name|uiop
operator|->
name|uio_resid
operator|)
operator|||
operator|(
name|fsess_opt_brokenio
argument_list|(
name|vnode_mount
argument_list|(
name|vp
argument_list|)
argument_list|)
operator|&&
name|error
operator|==
name|EIO
operator|&&
name|uiop
operator|->
name|uio_offset
operator|<
name|fvdat
operator|->
name|filesize
operator|&&
name|fvdat
operator|->
name|filesize
operator|>
literal|0
operator|&&
name|uiop
operator|->
name|uio_offset
operator|>=
name|fvdat
operator|->
name|cached_attrs
operator|.
name|va_size
operator|)
condition|)
block|{
comment|/* 	                 * If we had a short read with no error, we must have 	                 * hit a file hole.  We should zero-fill the remainder. 	                 * This can also occur if the server hits the file EOF. 	                 * 	                 * Holes used to be able to occur due to pending 	                 * writes, but that is not possible any longer. 	                 */
name|int
name|nread
init|=
name|bp
operator|->
name|b_bcount
operator|-
name|uiop
operator|->
name|uio_resid
decl_stmt|;
name|int
name|left
init|=
name|uiop
operator|->
name|uio_resid
decl_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"FUSE: Fix broken io: offset %ju, "
literal|" resid %zd, file size %ju/%ju\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|uiop
operator|->
name|uio_offset
argument_list|,
name|uiop
operator|->
name|uio_resid
argument_list|,
name|fvdat
operator|->
name|filesize
argument_list|,
name|fvdat
operator|->
name|cached_attrs
operator|.
name|va_size
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|left
operator|>
literal|0
condition|)
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bp
operator|->
name|b_data
operator|+
name|nread
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|uiop
operator|->
name|uio_resid
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|bp
operator|->
name|b_ioflags
operator||=
name|BIO_ERROR
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|error
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 	         * If we only need to commit, try to commit 	         */
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_NEEDCOMMIT
condition|)
block|{
name|DEBUG
argument_list|(
literal|"write: B_NEEDCOMMIT flags set\n"
argument_list|)
expr_stmt|;
block|}
comment|/* 	         * Setup for actual write 	         */
if|if
condition|(
operator|(
name|off_t
operator|)
name|bp
operator|->
name|b_blkno
operator|*
name|biosize
operator|+
name|bp
operator|->
name|b_dirtyend
operator|>
name|fvdat
operator|->
name|filesize
condition|)
name|bp
operator|->
name|b_dirtyend
operator|=
name|fvdat
operator|->
name|filesize
operator|-
operator|(
name|off_t
operator|)
name|bp
operator|->
name|b_blkno
operator|*
name|biosize
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_dirtyend
operator|>
name|bp
operator|->
name|b_dirtyoff
condition|)
block|{
name|io
operator|.
name|iov_len
operator|=
name|uiop
operator|->
name|uio_resid
operator|=
name|bp
operator|->
name|b_dirtyend
operator|-
name|bp
operator|->
name|b_dirtyoff
expr_stmt|;
name|uiop
operator|->
name|uio_offset
operator|=
operator|(
name|off_t
operator|)
name|bp
operator|->
name|b_blkno
operator|*
name|biosize
operator|+
name|bp
operator|->
name|b_dirtyoff
expr_stmt|;
name|io
operator|.
name|iov_base
operator|=
operator|(
name|char
operator|*
operator|)
name|bp
operator|->
name|b_data
operator|+
name|bp
operator|->
name|b_dirtyoff
expr_stmt|;
name|uiop
operator|->
name|uio_rw
operator|=
name|UIO_WRITE
expr_stmt|;
name|error
operator|=
name|fuse_write_directbackend
argument_list|(
name|vp
argument_list|,
name|uiop
argument_list|,
name|cred
argument_list|,
name|fufh
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EINTR
operator|||
name|error
operator|==
name|ETIMEDOUT
operator|||
operator|(
operator|!
name|error
operator|&&
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_NEEDCOMMIT
operator|)
operator|)
condition|)
block|{
name|bp
operator|->
name|b_flags
operator|&=
operator|~
operator|(
name|B_INVAL
operator||
name|B_NOCACHE
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_PAGING
operator|)
operator|==
literal|0
condition|)
block|{
name|bdirty
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_DONE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|error
operator|==
name|EINTR
operator|||
name|error
operator|==
name|ETIMEDOUT
operator|)
operator|&&
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_ASYNC
operator|)
operator|==
literal|0
condition|)
name|bp
operator|->
name|b_flags
operator||=
name|B_EINTR
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|error
condition|)
block|{
name|bp
operator|->
name|b_ioflags
operator||=
name|BIO_ERROR
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_INVAL
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|error
expr_stmt|;
block|}
name|bp
operator|->
name|b_dirtyoff
operator|=
name|bp
operator|->
name|b_dirtyend
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|bp
operator|->
name|b_resid
operator|=
literal|0
expr_stmt|;
name|bufdone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|bp
operator|->
name|b_resid
operator|=
name|uiop
operator|->
name|uio_resid
expr_stmt|;
name|bufdone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|fuse_io_flushbuf
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|int
name|waitfor
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|vop_fsync_args
name|a
init|=
block|{
operator|.
name|a_vp
operator|=
name|vp
block|,
operator|.
name|a_waitfor
operator|=
name|waitfor
block|,
operator|.
name|a_td
operator|=
name|td
block|, 	}
decl_stmt|;
return|return
operator|(
name|vop_stdfsync
argument_list|(
operator|&
name|a
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Flush and invalidate all dirty buffers. If another process is already  * doing the flush, just wait for completion.  */
end_comment

begin_function
name|int
name|fuse_io_invalbuf
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|fuse_vnode_data
modifier|*
name|fvdat
init|=
name|VTOFUD
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_iflag
operator|&
name|VI_DOOMED
condition|)
return|return
literal|0
return|;
name|ASSERT_VOP_ELOCKED
argument_list|(
name|vp
argument_list|,
literal|"fuse_io_invalbuf"
argument_list|)
expr_stmt|;
while|while
condition|(
name|fvdat
operator|->
name|flag
operator|&
name|FN_FLUSHINPROG
condition|)
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_mount
operator|->
name|mnt_kern_flag
operator|&
name|MNTK_UNMOUNTF
condition|)
return|return
name|EIO
return|;
name|fvdat
operator|->
name|flag
operator||=
name|FN_FLUSHWANT
expr_stmt|;
name|tsleep
argument_list|(
operator|&
name|fvdat
operator|->
name|flag
argument_list|,
name|PRIBIO
operator|+
literal|2
argument_list|,
literal|"fusevinv"
argument_list|,
literal|2
operator|*
name|hz
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|SIGNOTEMPTY
argument_list|(
name|p
operator|->
name|p_siglist
argument_list|)
operator|||
name|SIGNOTEMPTY
argument_list|(
name|td
operator|->
name|td_siglist
argument_list|)
condition|)
name|error
operator|=
name|EINTR
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
name|EINTR
condition|)
return|return
name|EINTR
return|;
block|}
name|fvdat
operator|->
name|flag
operator||=
name|FN_FLUSHINPROG
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_bufobj
operator|.
name|bo_object
operator|!=
name|NULL
condition|)
block|{
name|VM_OBJECT_LOCK
argument_list|(
name|vp
operator|->
name|v_bufobj
operator|.
name|bo_object
argument_list|)
expr_stmt|;
name|vm_object_page_clean
argument_list|(
name|vp
operator|->
name|v_bufobj
operator|.
name|bo_object
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|OBJPC_SYNC
argument_list|)
expr_stmt|;
name|VM_OBJECT_UNLOCK
argument_list|(
name|vp
operator|->
name|v_bufobj
operator|.
name|bo_object
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|vinvalbuf
argument_list|(
name|vp
argument_list|,
name|V_SAVE
argument_list|,
name|PCATCH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|ERESTART
operator|||
name|error
operator|==
name|EINTR
condition|)
block|{
name|fvdat
operator|->
name|flag
operator|&=
operator|~
name|FN_FLUSHINPROG
expr_stmt|;
if|if
condition|(
name|fvdat
operator|->
name|flag
operator|&
name|FN_FLUSHWANT
condition|)
block|{
name|fvdat
operator|->
name|flag
operator|&=
operator|~
name|FN_FLUSHWANT
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|fvdat
operator|->
name|flag
argument_list|)
expr_stmt|;
block|}
return|return
name|EINTR
return|;
block|}
name|error
operator|=
name|vinvalbuf
argument_list|(
name|vp
argument_list|,
name|V_SAVE
argument_list|,
name|PCATCH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|fvdat
operator|->
name|flag
operator|&=
operator|~
name|FN_FLUSHINPROG
expr_stmt|;
if|if
condition|(
name|fvdat
operator|->
name|flag
operator|&
name|FN_FLUSHWANT
condition|)
block|{
name|fvdat
operator|->
name|flag
operator|&=
operator|~
name|FN_FLUSHWANT
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|fvdat
operator|->
name|flag
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

