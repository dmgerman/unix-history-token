begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2007-2009 Google Inc. and Amit Singh  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  * * Redistributions of source code must retain the above copyright  *   notice, this list of conditions and the following disclaimer.  * * Redistributions in binary form must reproduce the above  *   copyright notice, this list of conditions and the following disclaimer  *   in the documentation and/or other materials provided with the  *   distribution.  * * Neither the name of Google Inc. nor the names of its  *   contributors may be used to endorse or promote products derived from  *   this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * Copyright (C) 2005 Csaba Henk.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/rwlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/filedesc.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/dirent.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmmeter.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pager.h>
end_include

begin_include
include|#
directive|include
file|<vm/vnode_pager.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|"fuse.h"
end_include

begin_include
include|#
directive|include
file|"fuse_file.h"
end_include

begin_include
include|#
directive|include
file|"fuse_internal.h"
end_include

begin_include
include|#
directive|include
file|"fuse_ipc.h"
end_include

begin_include
include|#
directive|include
file|"fuse_node.h"
end_include

begin_include
include|#
directive|include
file|"fuse_param.h"
end_include

begin_include
include|#
directive|include
file|"fuse_io.h"
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_define
define|#
directive|define
name|FUSE_DEBUG_MODULE
value|VNOPS
end_define

begin_include
include|#
directive|include
file|"fuse_debug.h"
end_include

begin_comment
comment|/* vnode ops */
end_comment

begin_decl_stmt
specifier|static
name|vop_access_t
name|fuse_vnop_access
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_close_t
name|fuse_vnop_close
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_create_t
name|fuse_vnop_create
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_fsync_t
name|fuse_vnop_fsync
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_getattr_t
name|fuse_vnop_getattr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_inactive_t
name|fuse_vnop_inactive
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_link_t
name|fuse_vnop_link
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_lookup_t
name|fuse_vnop_lookup
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_mkdir_t
name|fuse_vnop_mkdir
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_mknod_t
name|fuse_vnop_mknod
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_open_t
name|fuse_vnop_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_read_t
name|fuse_vnop_read
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_readdir_t
name|fuse_vnop_readdir
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_readlink_t
name|fuse_vnop_readlink
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_reclaim_t
name|fuse_vnop_reclaim
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_remove_t
name|fuse_vnop_remove
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_rename_t
name|fuse_vnop_rename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_rmdir_t
name|fuse_vnop_rmdir
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_setattr_t
name|fuse_vnop_setattr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_strategy_t
name|fuse_vnop_strategy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_symlink_t
name|fuse_vnop_symlink
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_write_t
name|fuse_vnop_write
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_getpages_t
name|fuse_vnop_getpages
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_putpages_t
name|fuse_vnop_putpages
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_print_t
name|fuse_vnop_print
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vop_vector
name|fuse_vnops
init|=
block|{
operator|.
name|vop_default
operator|=
operator|&
name|default_vnodeops
block|,
operator|.
name|vop_access
operator|=
name|fuse_vnop_access
block|,
operator|.
name|vop_close
operator|=
name|fuse_vnop_close
block|,
operator|.
name|vop_create
operator|=
name|fuse_vnop_create
block|,
operator|.
name|vop_fsync
operator|=
name|fuse_vnop_fsync
block|,
operator|.
name|vop_getattr
operator|=
name|fuse_vnop_getattr
block|,
operator|.
name|vop_inactive
operator|=
name|fuse_vnop_inactive
block|,
operator|.
name|vop_link
operator|=
name|fuse_vnop_link
block|,
operator|.
name|vop_lookup
operator|=
name|fuse_vnop_lookup
block|,
operator|.
name|vop_mkdir
operator|=
name|fuse_vnop_mkdir
block|,
operator|.
name|vop_mknod
operator|=
name|fuse_vnop_mknod
block|,
operator|.
name|vop_open
operator|=
name|fuse_vnop_open
block|,
operator|.
name|vop_pathconf
operator|=
name|vop_stdpathconf
block|,
operator|.
name|vop_read
operator|=
name|fuse_vnop_read
block|,
operator|.
name|vop_readdir
operator|=
name|fuse_vnop_readdir
block|,
operator|.
name|vop_readlink
operator|=
name|fuse_vnop_readlink
block|,
operator|.
name|vop_reclaim
operator|=
name|fuse_vnop_reclaim
block|,
operator|.
name|vop_remove
operator|=
name|fuse_vnop_remove
block|,
operator|.
name|vop_rename
operator|=
name|fuse_vnop_rename
block|,
operator|.
name|vop_rmdir
operator|=
name|fuse_vnop_rmdir
block|,
operator|.
name|vop_setattr
operator|=
name|fuse_vnop_setattr
block|,
operator|.
name|vop_strategy
operator|=
name|fuse_vnop_strategy
block|,
operator|.
name|vop_symlink
operator|=
name|fuse_vnop_symlink
block|,
operator|.
name|vop_write
operator|=
name|fuse_vnop_write
block|,
operator|.
name|vop_getpages
operator|=
name|fuse_vnop_getpages
block|,
operator|.
name|vop_putpages
operator|=
name|fuse_vnop_putpages
block|,
operator|.
name|vop_print
operator|=
name|fuse_vnop_print
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_long
name|fuse_lookup_cache_hits
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_ULONG
argument_list|(
name|_vfs_fuse
argument_list|,
name|OID_AUTO
argument_list|,
name|lookup_cache_hits
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|fuse_lookup_cache_hits
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_long
name|fuse_lookup_cache_misses
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_ULONG
argument_list|(
name|_vfs_fuse
argument_list|,
name|OID_AUTO
argument_list|,
name|lookup_cache_misses
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|fuse_lookup_cache_misses
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|fuse_lookup_cache_enable
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_fuse
argument_list|,
name|OID_AUTO
argument_list|,
name|lookup_cache_enable
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|fuse_lookup_cache_enable
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * XXX: This feature is highly experimental and can bring to instabilities,  * needs revisiting before to be enabled by default.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|fuse_reclaim_revoked
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_fuse
argument_list|,
name|OID_AUTO
argument_list|,
name|reclaim_revoked
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|fuse_reclaim_revoked
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|fuse_pbuf_freecnt
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|fuse_vm_page_lock
parameter_list|(
name|m
parameter_list|)
value|vm_page_lock((m));
end_define

begin_define
define|#
directive|define
name|fuse_vm_page_unlock
parameter_list|(
name|m
parameter_list|)
value|vm_page_unlock((m));
end_define

begin_define
define|#
directive|define
name|fuse_vm_page_lock_queues
parameter_list|()
value|((void)0)
end_define

begin_define
define|#
directive|define
name|fuse_vm_page_unlock_queues
parameter_list|()
value|((void)0)
end_define

begin_comment
comment|/*     struct vnop_access_args {         struct vnode *a_vp; #if VOP_ACCESS_TAKES_ACCMODE_T         accmode_t a_accmode; #else         int a_mode; #endif         struct ucred *a_cred;         struct thread *a_td;     }; */
end_comment

begin_function
specifier|static
name|int
name|fuse_vnop_access
parameter_list|(
name|struct
name|vop_access_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|int
name|accmode
init|=
name|ap
operator|->
name|a_accmode
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|ap
operator|->
name|a_cred
decl_stmt|;
name|struct
name|fuse_access_param
name|facp
decl_stmt|;
name|struct
name|fuse_data
modifier|*
name|data
init|=
name|fuse_get_mpdata
argument_list|(
name|vnode_mount
argument_list|(
name|vp
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|err
decl_stmt|;
name|FS_DEBUG2G
argument_list|(
literal|"inode=%ju\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|VTOI
argument_list|(
name|vp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fuse_isdeadfs
argument_list|(
name|vp
argument_list|)
condition|)
block|{
if|if
condition|(
name|vnode_isvroot
argument_list|(
name|vp
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
name|ENXIO
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|data
operator|->
name|dataflags
operator|&
name|FSESS_INITED
operator|)
condition|)
block|{
if|if
condition|(
name|vnode_isvroot
argument_list|(
name|vp
argument_list|)
condition|)
block|{
if|if
condition|(
name|priv_check_cred
argument_list|(
name|cred
argument_list|,
name|PRIV_VFS_ADMIN
argument_list|,
literal|0
argument_list|)
operator|||
operator|(
name|fuse_match_cred
argument_list|(
name|data
operator|->
name|daemoncred
argument_list|,
name|cred
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
return|return
literal|0
return|;
block|}
block|}
return|return
name|EBADF
return|;
block|}
if|if
condition|(
name|vnode_islnk
argument_list|(
name|vp
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
name|bzero
argument_list|(
operator|&
name|facp
argument_list|,
sizeof|sizeof
argument_list|(
name|facp
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|fuse_internal_access
argument_list|(
name|vp
argument_list|,
name|accmode
argument_list|,
operator|&
name|facp
argument_list|,
name|ap
operator|->
name|a_td
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|)
expr_stmt|;
name|FS_DEBUG2G
argument_list|(
literal|"err=%d accmode=0x%x\n"
argument_list|,
name|err
argument_list|,
name|accmode
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/*     struct vnop_close_args { 	struct vnode *a_vp; 	int  a_fflag; 	struct ucred *a_cred; 	struct thread *a_td;     }; */
end_comment

begin_function
specifier|static
name|int
name|fuse_vnop_close
parameter_list|(
name|struct
name|vop_close_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|ap
operator|->
name|a_cred
decl_stmt|;
name|int
name|fflag
init|=
name|ap
operator|->
name|a_fflag
decl_stmt|;
name|fufh_type_t
name|fufh_type
decl_stmt|;
name|fuse_trace_printf_vnop
argument_list|()
expr_stmt|;
if|if
condition|(
name|fuse_isdeadfs
argument_list|(
name|vp
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
name|vnode_isdir
argument_list|(
name|vp
argument_list|)
condition|)
block|{
if|if
condition|(
name|fuse_filehandle_valid
argument_list|(
name|vp
argument_list|,
name|FUFH_RDONLY
argument_list|)
condition|)
block|{
name|fuse_filehandle_close
argument_list|(
name|vp
argument_list|,
name|FUFH_RDONLY
argument_list|,
name|NULL
argument_list|,
name|cred
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
if|if
condition|(
name|fflag
operator|&
name|IO_NDELAY
condition|)
block|{
return|return
literal|0
return|;
block|}
name|fufh_type
operator|=
name|fuse_filehandle_xlate_from_fflags
argument_list|(
name|fflag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fuse_filehandle_valid
argument_list|(
name|vp
argument_list|,
name|fufh_type
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FUFH_MAXTYPE
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|fuse_filehandle_valid
argument_list|(
name|vp
argument_list|,
name|i
argument_list|)
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|FUFH_MAXTYPE
condition|)
name|panic
argument_list|(
literal|"FUSE: fufh type %d found to be invalid in close"
literal|" (fflag=0x%x)\n"
argument_list|,
name|fufh_type
argument_list|,
name|fflag
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|VTOFUD
argument_list|(
name|vp
argument_list|)
operator|->
name|flag
operator|&
name|FN_SIZECHANGE
operator|)
operator|!=
literal|0
condition|)
block|{
name|fuse_vnode_savesize
argument_list|(
name|vp
argument_list|,
name|cred
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*     struct vnop_create_args { 	struct vnode *a_dvp; 	struct vnode **a_vpp; 	struct componentname *a_cnp; 	struct vattr *a_vap;     }; */
end_comment

begin_function
specifier|static
name|int
name|fuse_vnop_create
parameter_list|(
name|struct
name|vop_create_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|dvp
init|=
name|ap
operator|->
name|a_dvp
decl_stmt|;
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
init|=
name|ap
operator|->
name|a_vpp
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
name|struct
name|vattr
modifier|*
name|vap
init|=
name|ap
operator|->
name|a_vap
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|cnp
operator|->
name|cn_thread
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|cnp
operator|->
name|cn_cred
decl_stmt|;
name|struct
name|fuse_open_in
modifier|*
name|foi
decl_stmt|;
name|struct
name|fuse_entry_out
modifier|*
name|feo
decl_stmt|;
name|struct
name|fuse_dispatcher
name|fdi
decl_stmt|;
name|struct
name|fuse_dispatcher
modifier|*
name|fdip
init|=
operator|&
name|fdi
decl_stmt|;
name|int
name|err
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
init|=
name|vnode_mount
argument_list|(
name|dvp
argument_list|)
decl_stmt|;
name|uint64_t
name|parentnid
init|=
name|VTOFUD
argument_list|(
name|dvp
argument_list|)
operator|->
name|nid
decl_stmt|;
name|mode_t
name|mode
init|=
name|MAKEIMODE
argument_list|(
name|vap
operator|->
name|va_type
argument_list|,
name|vap
operator|->
name|va_mode
argument_list|)
decl_stmt|;
name|uint64_t
name|x_fh_id
decl_stmt|;
name|uint32_t
name|x_open_flags
decl_stmt|;
name|fuse_trace_printf_vnop
argument_list|()
expr_stmt|;
if|if
condition|(
name|fuse_isdeadfs
argument_list|(
name|dvp
argument_list|)
condition|)
block|{
return|return
name|ENXIO
return|;
block|}
name|bzero
argument_list|(
operator|&
name|fdi
argument_list|,
sizeof|sizeof
argument_list|(
name|fdi
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX:	Will we ever want devices ? */
if|if
condition|(
operator|(
name|vap
operator|->
name|va_type
operator|!=
name|VREG
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"fuse_vnop_create: unsupported va_type %d\n"
argument_list|,
name|vap
operator|->
name|va_type
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|debug_printf
argument_list|(
literal|"parent nid = %ju, mode = %x\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|parentnid
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|fdisp_init
argument_list|(
name|fdip
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|foi
argument_list|)
operator|+
name|cnp
operator|->
name|cn_namelen
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fsess_isimpl
argument_list|(
name|mp
argument_list|,
name|FUSE_CREATE
argument_list|)
condition|)
block|{
name|debug_printf
argument_list|(
literal|"eh, daemon doesn't implement create?\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|fdisp_make
argument_list|(
name|fdip
argument_list|,
name|FUSE_CREATE
argument_list|,
name|vnode_mount
argument_list|(
name|dvp
argument_list|)
argument_list|,
name|parentnid
argument_list|,
name|td
argument_list|,
name|cred
argument_list|)
expr_stmt|;
name|foi
operator|=
name|fdip
operator|->
name|indata
expr_stmt|;
name|foi
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
name|foi
operator|->
name|flags
operator|=
name|O_CREAT
operator||
name|O_RDWR
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fdip
operator|->
name|indata
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|foi
argument_list|)
argument_list|,
name|cnp
operator|->
name|cn_nameptr
argument_list|,
name|cnp
operator|->
name|cn_namelen
argument_list|)
expr_stmt|;
operator|(
operator|(
name|char
operator|*
operator|)
name|fdip
operator|->
name|indata
operator|)
index|[
sizeof|sizeof
argument_list|(
operator|*
name|foi
argument_list|)
operator|+
name|cnp
operator|->
name|cn_namelen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|err
operator|=
name|fdisp_wait_answ
argument_list|(
name|fdip
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|==
name|ENOSYS
condition|)
name|fsess_set_notimpl
argument_list|(
name|mp
argument_list|,
name|FUSE_CREATE
argument_list|)
expr_stmt|;
name|debug_printf
argument_list|(
literal|"create: got err=%d from daemon\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|feo
operator|=
name|fdip
operator|->
name|answ
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|fuse_internal_checkentry
argument_list|(
name|feo
argument_list|,
name|VREG
argument_list|)
operator|)
condition|)
block|{
goto|goto
name|out
goto|;
block|}
name|err
operator|=
name|fuse_vnode_get
argument_list|(
name|mp
argument_list|,
name|feo
operator|->
name|nodeid
argument_list|,
name|dvp
argument_list|,
name|vpp
argument_list|,
name|cnp
argument_list|,
name|VREG
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|struct
name|fuse_release_in
modifier|*
name|fri
decl_stmt|;
name|uint64_t
name|nodeid
init|=
name|feo
operator|->
name|nodeid
decl_stmt|;
name|uint64_t
name|fh_id
init|=
operator|(
operator|(
expr|struct
name|fuse_open_out
operator|*
operator|)
operator|(
name|feo
operator|+
literal|1
operator|)
operator|)
operator|->
name|fh
decl_stmt|;
name|fdisp_init
argument_list|(
name|fdip
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fri
argument_list|)
argument_list|)
expr_stmt|;
name|fdisp_make
argument_list|(
name|fdip
argument_list|,
name|FUSE_RELEASE
argument_list|,
name|mp
argument_list|,
name|nodeid
argument_list|,
name|td
argument_list|,
name|cred
argument_list|)
expr_stmt|;
name|fri
operator|=
name|fdip
operator|->
name|indata
expr_stmt|;
name|fri
operator|->
name|fh
operator|=
name|fh_id
expr_stmt|;
name|fri
operator|->
name|flags
operator|=
name|OFLAGS
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|fuse_insert_callback
argument_list|(
name|fdip
operator|->
name|tick
argument_list|,
name|fuse_internal_forget_callback
argument_list|)
expr_stmt|;
name|fuse_insert_message
argument_list|(
name|fdip
operator|->
name|tick
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|ASSERT_VOP_ELOCKED
argument_list|(
operator|*
name|vpp
argument_list|,
literal|"fuse_vnop_create"
argument_list|)
expr_stmt|;
name|fdip
operator|->
name|answ
operator|=
name|feo
operator|+
literal|1
expr_stmt|;
name|x_fh_id
operator|=
operator|(
operator|(
expr|struct
name|fuse_open_out
operator|*
operator|)
operator|(
name|feo
operator|+
literal|1
operator|)
operator|)
operator|->
name|fh
expr_stmt|;
name|x_open_flags
operator|=
operator|(
operator|(
expr|struct
name|fuse_open_out
operator|*
operator|)
operator|(
name|feo
operator|+
literal|1
operator|)
operator|)
operator|->
name|open_flags
expr_stmt|;
name|fuse_filehandle_init
argument_list|(
operator|*
name|vpp
argument_list|,
name|FUFH_RDWR
argument_list|,
name|NULL
argument_list|,
name|x_fh_id
argument_list|)
expr_stmt|;
name|fuse_vnode_open
argument_list|(
operator|*
name|vpp
argument_list|,
name|x_open_flags
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|cache_purge_negative
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|out
label|:
name|fdisp_destroy
argument_list|(
name|fdip
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/*  * Our vnop_fsync roughly corresponds to the FUSE_FSYNC method. The Linux  * version of FUSE also has a FUSE_FLUSH method.  *  * On Linux, fsync() synchronizes a file's complete in-core state with that  * on disk. The call is not supposed to return until the system has completed  * that action or until an error is detected.  *  * Linux also has an fdatasync() call that is similar to fsync() but is not  * required to update the metadata such as access time and modification time.  */
end_comment

begin_comment
comment|/*     struct vnop_fsync_args { 	struct vnodeop_desc *a_desc; 	struct vnode * a_vp; 	struct ucred * a_cred; 	int  a_waitfor; 	struct thread * a_td;     }; */
end_comment

begin_function
specifier|static
name|int
name|fuse_vnop_fsync
parameter_list|(
name|struct
name|vop_fsync_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|ap
operator|->
name|a_td
decl_stmt|;
name|struct
name|fuse_filehandle
modifier|*
name|fufh
decl_stmt|;
name|struct
name|fuse_vnode_data
modifier|*
name|fvdat
init|=
name|VTOFUD
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|int
name|type
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|;
name|fuse_trace_printf_vnop
argument_list|()
expr_stmt|;
if|if
condition|(
name|fuse_isdeadfs
argument_list|(
name|vp
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
name|err
operator|=
name|vop_stdfsync
argument_list|(
name|ap
argument_list|)
operator|)
condition|)
return|return
name|err
return|;
if|if
condition|(
operator|!
name|fsess_isimpl
argument_list|(
name|vnode_mount
argument_list|(
name|vp
argument_list|)
argument_list|,
operator|(
name|vnode_vtype
argument_list|(
name|vp
argument_list|)
operator|==
name|VDIR
condition|?
name|FUSE_FSYNCDIR
else|:
name|FUSE_FSYNC
operator|)
argument_list|)
condition|)
block|{
goto|goto
name|out
goto|;
block|}
for|for
control|(
name|type
operator|=
literal|0
init|;
name|type
operator|<
name|FUFH_MAXTYPE
condition|;
name|type
operator|++
control|)
block|{
name|fufh
operator|=
operator|&
operator|(
name|fvdat
operator|->
name|fufh
index|[
name|type
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|FUFH_IS_VALID
argument_list|(
name|fufh
argument_list|)
condition|)
block|{
name|fuse_internal_fsync
argument_list|(
name|vp
argument_list|,
name|td
argument_list|,
name|NULL
argument_list|,
name|fufh
argument_list|)
expr_stmt|;
block|}
block|}
name|out
label|:
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*     struct vnop_getattr_args { 	struct vnode *a_vp; 	struct vattr *a_vap; 	struct ucred *a_cred; 	struct thread *a_td;     }; */
end_comment

begin_function
specifier|static
name|int
name|fuse_vnop_getattr
parameter_list|(
name|struct
name|vop_getattr_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|vattr
modifier|*
name|vap
init|=
name|ap
operator|->
name|a_vap
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|ap
operator|->
name|a_cred
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|struct
name|fuse_vnode_data
modifier|*
name|fvdat
init|=
name|VTOFUD
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|int
name|dataflags
decl_stmt|;
name|struct
name|fuse_dispatcher
name|fdi
decl_stmt|;
name|FS_DEBUG2G
argument_list|(
literal|"inode=%ju\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|VTOI
argument_list|(
name|vp
argument_list|)
argument_list|)
expr_stmt|;
name|dataflags
operator|=
name|fuse_get_mpdata
argument_list|(
name|vnode_mount
argument_list|(
name|vp
argument_list|)
argument_list|)
operator|->
name|dataflags
expr_stmt|;
comment|/* Note that we are not bailing out on a dead file system just yet. */
if|if
condition|(
operator|!
operator|(
name|dataflags
operator|&
name|FSESS_INITED
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|vnode_isvroot
argument_list|(
name|vp
argument_list|)
condition|)
block|{
name|fdata_set_dead
argument_list|(
name|fuse_get_mpdata
argument_list|(
name|vnode_mount
argument_list|(
name|vp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENOTCONN
expr_stmt|;
name|debug_printf
argument_list|(
literal|"fuse_getattr b: returning ENOTCONN\n"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
else|else
block|{
goto|goto
name|fake
goto|;
block|}
block|}
name|fdisp_init
argument_list|(
operator|&
name|fdi
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|fdisp_simple_putget_vp
argument_list|(
operator|&
name|fdi
argument_list|,
name|FUSE_GETATTR
argument_list|,
name|vp
argument_list|,
name|td
argument_list|,
name|cred
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|err
operator|==
name|ENOTCONN
operator|)
operator|&&
name|vnode_isvroot
argument_list|(
name|vp
argument_list|)
condition|)
block|{
comment|/* see comment at similar place in fuse_statfs() */
name|fdisp_destroy
argument_list|(
operator|&
name|fdi
argument_list|)
expr_stmt|;
goto|goto
name|fake
goto|;
block|}
if|if
condition|(
name|err
operator|==
name|ENOENT
condition|)
block|{
name|fuse_internal_vnode_disappear
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
goto|goto
name|out
goto|;
block|}
name|cache_attrs
argument_list|(
name|vp
argument_list|,
operator|(
expr|struct
name|fuse_attr_out
operator|*
operator|)
name|fdi
operator|.
name|answ
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|!=
name|VTOVA
argument_list|(
name|vp
argument_list|)
condition|)
block|{
name|memcpy
argument_list|(
name|vap
argument_list|,
name|VTOVA
argument_list|(
name|vp
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|vap
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vap
operator|->
name|va_type
operator|!=
name|vnode_vtype
argument_list|(
name|vp
argument_list|)
condition|)
block|{
name|fuse_internal_vnode_disappear
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|fvdat
operator|->
name|flag
operator|&
name|FN_SIZECHANGE
operator|)
operator|!=
literal|0
condition|)
name|vap
operator|->
name|va_size
operator|=
name|fvdat
operator|->
name|filesize
expr_stmt|;
if|if
condition|(
name|vnode_isreg
argument_list|(
name|vp
argument_list|)
operator|&&
operator|(
name|fvdat
operator|->
name|flag
operator|&
name|FN_SIZECHANGE
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 	         * This is for those cases when the file size changed without us 	         * knowing, and we want to catch up. 	         */
name|off_t
name|new_filesize
init|=
operator|(
operator|(
expr|struct
name|fuse_attr_out
operator|*
operator|)
name|fdi
operator|.
name|answ
operator|)
operator|->
name|attr
operator|.
name|size
decl_stmt|;
if|if
condition|(
name|fvdat
operator|->
name|filesize
operator|!=
name|new_filesize
condition|)
block|{
name|fuse_vnode_setsize
argument_list|(
name|vp
argument_list|,
name|cred
argument_list|,
name|new_filesize
argument_list|)
expr_stmt|;
block|}
block|}
name|debug_printf
argument_list|(
literal|"fuse_getattr e: returning 0\n"
argument_list|)
expr_stmt|;
name|out
label|:
name|fdisp_destroy
argument_list|(
operator|&
name|fdi
argument_list|)
expr_stmt|;
return|return
name|err
return|;
name|fake
label|:
name|bzero
argument_list|(
name|vap
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|vap
argument_list|)
argument_list|)
expr_stmt|;
name|vap
operator|->
name|va_type
operator|=
name|vnode_vtype
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*     struct vnop_inactive_args { 	struct vnode *a_vp; 	struct thread *a_td;     }; */
end_comment

begin_function
specifier|static
name|int
name|fuse_vnop_inactive
parameter_list|(
name|struct
name|vop_inactive_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|ap
operator|->
name|a_td
decl_stmt|;
name|struct
name|fuse_vnode_data
modifier|*
name|fvdat
init|=
name|VTOFUD
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|fuse_filehandle
modifier|*
name|fufh
init|=
name|NULL
decl_stmt|;
name|int
name|type
decl_stmt|,
name|need_flush
init|=
literal|1
decl_stmt|;
name|FS_DEBUG
argument_list|(
literal|"inode=%ju\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|VTOI
argument_list|(
name|vp
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|type
operator|=
literal|0
init|;
name|type
operator|<
name|FUFH_MAXTYPE
condition|;
name|type
operator|++
control|)
block|{
name|fufh
operator|=
operator|&
operator|(
name|fvdat
operator|->
name|fufh
index|[
name|type
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|FUFH_IS_VALID
argument_list|(
name|fufh
argument_list|)
condition|)
block|{
if|if
condition|(
name|need_flush
operator|&&
name|vp
operator|->
name|v_type
operator|==
name|VREG
condition|)
block|{
if|if
condition|(
operator|(
name|VTOFUD
argument_list|(
name|vp
argument_list|)
operator|->
name|flag
operator|&
name|FN_SIZECHANGE
operator|)
operator|!=
literal|0
condition|)
block|{
name|fuse_vnode_savesize
argument_list|(
name|vp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fuse_data_cache_invalidate
operator|||
operator|(
name|fvdat
operator|->
name|flag
operator|&
name|FN_REVOKED
operator|)
operator|!=
literal|0
condition|)
name|fuse_io_invalbuf
argument_list|(
name|vp
argument_list|,
name|td
argument_list|)
expr_stmt|;
else|else
name|fuse_io_flushbuf
argument_list|(
name|vp
argument_list|,
name|MNT_WAIT
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|need_flush
operator|=
literal|0
expr_stmt|;
block|}
name|fuse_filehandle_close
argument_list|(
name|vp
argument_list|,
name|type
argument_list|,
name|td
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|fvdat
operator|->
name|flag
operator|&
name|FN_REVOKED
operator|)
operator|!=
literal|0
operator|&&
name|fuse_reclaim_revoked
condition|)
block|{
name|vrecycle
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*     struct vnop_link_args { 	struct vnode *a_tdvp; 	struct vnode *a_vp; 	struct componentname *a_cnp;     }; */
end_comment

begin_function
specifier|static
name|int
name|fuse_vnop_link
parameter_list|(
name|struct
name|vop_link_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|tdvp
init|=
name|ap
operator|->
name|a_tdvp
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
name|struct
name|vattr
modifier|*
name|vap
init|=
name|VTOVA
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|fuse_dispatcher
name|fdi
decl_stmt|;
name|struct
name|fuse_entry_out
modifier|*
name|feo
decl_stmt|;
name|struct
name|fuse_link_in
name|fli
decl_stmt|;
name|int
name|err
decl_stmt|;
name|fuse_trace_printf_vnop
argument_list|()
expr_stmt|;
if|if
condition|(
name|fuse_isdeadfs
argument_list|(
name|vp
argument_list|)
condition|)
block|{
return|return
name|ENXIO
return|;
block|}
if|if
condition|(
name|vnode_mount
argument_list|(
name|tdvp
argument_list|)
operator|!=
name|vnode_mount
argument_list|(
name|vp
argument_list|)
condition|)
block|{
return|return
name|EXDEV
return|;
block|}
if|if
condition|(
name|vap
operator|->
name|va_nlink
operator|>=
name|FUSE_LINK_MAX
condition|)
block|{
return|return
name|EMLINK
return|;
block|}
name|fli
operator|.
name|oldnodeid
operator|=
name|VTOI
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|fdisp_init
argument_list|(
operator|&
name|fdi
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fuse_internal_newentry_makerequest
argument_list|(
name|vnode_mount
argument_list|(
name|tdvp
argument_list|)
argument_list|,
name|VTOI
argument_list|(
name|tdvp
argument_list|)
argument_list|,
name|cnp
argument_list|,
name|FUSE_LINK
argument_list|,
operator|&
name|fli
argument_list|,
sizeof|sizeof
argument_list|(
name|fli
argument_list|)
argument_list|,
operator|&
name|fdi
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|fdisp_wait_answ
argument_list|(
operator|&
name|fdi
argument_list|)
operator|)
condition|)
block|{
goto|goto
name|out
goto|;
block|}
name|feo
operator|=
name|fdi
operator|.
name|answ
expr_stmt|;
name|err
operator|=
name|fuse_internal_checkentry
argument_list|(
name|feo
argument_list|,
name|vnode_vtype
argument_list|(
name|vp
argument_list|)
argument_list|)
expr_stmt|;
name|out
label|:
name|fdisp_destroy
argument_list|(
operator|&
name|fdi
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/*     struct vnop_lookup_args { 	struct vnodeop_desc *a_desc; 	struct vnode *a_dvp; 	struct vnode **a_vpp; 	struct componentname *a_cnp;     }; */
end_comment

begin_function
name|int
name|fuse_vnop_lookup
parameter_list|(
name|struct
name|vop_lookup_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|dvp
init|=
name|ap
operator|->
name|a_dvp
decl_stmt|;
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
init|=
name|ap
operator|->
name|a_vpp
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|cnp
operator|->
name|cn_thread
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|cnp
operator|->
name|cn_cred
decl_stmt|;
name|int
name|nameiop
init|=
name|cnp
operator|->
name|cn_nameiop
decl_stmt|;
name|int
name|flags
init|=
name|cnp
operator|->
name|cn_flags
decl_stmt|;
name|int
name|wantparent
init|=
name|flags
operator|&
operator|(
name|LOCKPARENT
operator||
name|WANTPARENT
operator|)
decl_stmt|;
name|int
name|islastcn
init|=
name|flags
operator|&
name|ISLASTCN
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
init|=
name|vnode_mount
argument_list|(
name|dvp
argument_list|)
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|int
name|lookup_err
init|=
literal|0
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
init|=
name|NULL
decl_stmt|;
name|struct
name|fuse_dispatcher
name|fdi
decl_stmt|;
name|enum
name|fuse_opcode
name|op
decl_stmt|;
name|uint64_t
name|nid
decl_stmt|;
name|struct
name|fuse_access_param
name|facp
decl_stmt|;
name|FS_DEBUG2G
argument_list|(
literal|"parent_inode=%ju - %*s\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|VTOI
argument_list|(
name|dvp
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|cnp
operator|->
name|cn_namelen
argument_list|,
name|cnp
operator|->
name|cn_nameptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|fuse_isdeadfs
argument_list|(
name|dvp
argument_list|)
condition|)
block|{
operator|*
name|vpp
operator|=
name|NULL
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
if|if
condition|(
operator|!
name|vnode_isdir
argument_list|(
name|dvp
argument_list|)
condition|)
block|{
return|return
name|ENOTDIR
return|;
block|}
if|if
condition|(
name|islastcn
operator|&&
name|vfs_isrdonly
argument_list|(
name|mp
argument_list|)
operator|&&
operator|(
name|nameiop
operator|!=
name|LOOKUP
operator|)
condition|)
block|{
return|return
name|EROFS
return|;
block|}
comment|/*          * We do access check prior to doing anything else only in the case          * when we are at fs root (we'd like to say, "we are at the first          * component", but that's not exactly the same... nevermind).          * See further comments at further access checks.          */
name|bzero
argument_list|(
operator|&
name|facp
argument_list|,
sizeof|sizeof
argument_list|(
name|facp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vnode_isvroot
argument_list|(
name|dvp
argument_list|)
condition|)
block|{
comment|/* early permission check hack */
if|if
condition|(
operator|(
name|err
operator|=
name|fuse_internal_access
argument_list|(
name|dvp
argument_list|,
name|VEXEC
argument_list|,
operator|&
name|facp
argument_list|,
name|td
argument_list|,
name|cred
argument_list|)
operator|)
condition|)
block|{
return|return
name|err
return|;
block|}
block|}
if|if
condition|(
name|flags
operator|&
name|ISDOTDOT
condition|)
block|{
name|nid
operator|=
name|VTOFUD
argument_list|(
name|dvp
argument_list|)
operator|->
name|parent_nid
expr_stmt|;
if|if
condition|(
name|nid
operator|==
literal|0
condition|)
block|{
return|return
name|ENOENT
return|;
block|}
name|fdisp_init
argument_list|(
operator|&
name|fdi
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op
operator|=
name|FUSE_GETATTR
expr_stmt|;
goto|goto
name|calldaemon
goto|;
block|}
elseif|else
if|if
condition|(
name|cnp
operator|->
name|cn_namelen
operator|==
literal|1
operator|&&
operator|*
operator|(
name|cnp
operator|->
name|cn_nameptr
operator|)
operator|==
literal|'.'
condition|)
block|{
name|nid
operator|=
name|VTOI
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|fdisp_init
argument_list|(
operator|&
name|fdi
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op
operator|=
name|FUSE_GETATTR
expr_stmt|;
goto|goto
name|calldaemon
goto|;
block|}
elseif|else
if|if
condition|(
name|fuse_lookup_cache_enable
condition|)
block|{
name|err
operator|=
name|cache_lookup
argument_list|(
name|dvp
argument_list|,
name|vpp
argument_list|,
name|cnp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|err
condition|)
block|{
case|case
operator|-
literal|1
case|:
comment|/* positive match */
name|atomic_add_acq_long
argument_list|(
operator|&
name|fuse_lookup_cache_hits
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
literal|0
case|:
comment|/* no match in cache */
name|atomic_add_acq_long
argument_list|(
operator|&
name|fuse_lookup_cache_misses
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENOENT
case|:
comment|/* negative match */
comment|/* fall through */
default|default:
return|return
name|err
return|;
block|}
block|}
name|nid
operator|=
name|VTOI
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|fdisp_init
argument_list|(
operator|&
name|fdi
argument_list|,
name|cnp
operator|->
name|cn_namelen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|op
operator|=
name|FUSE_LOOKUP
expr_stmt|;
name|calldaemon
label|:
name|fdisp_make
argument_list|(
operator|&
name|fdi
argument_list|,
name|op
argument_list|,
name|mp
argument_list|,
name|nid
argument_list|,
name|td
argument_list|,
name|cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|FUSE_LOOKUP
condition|)
block|{
name|memcpy
argument_list|(
name|fdi
operator|.
name|indata
argument_list|,
name|cnp
operator|->
name|cn_nameptr
argument_list|,
name|cnp
operator|->
name|cn_namelen
argument_list|)
expr_stmt|;
operator|(
operator|(
name|char
operator|*
operator|)
name|fdi
operator|.
name|indata
operator|)
index|[
name|cnp
operator|->
name|cn_namelen
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|lookup_err
operator|=
name|fdisp_wait_answ
argument_list|(
operator|&
name|fdi
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|op
operator|==
name|FUSE_LOOKUP
operator|)
operator|&&
operator|!
name|lookup_err
condition|)
block|{
comment|/* lookup call succeeded */
name|nid
operator|=
operator|(
operator|(
expr|struct
name|fuse_entry_out
operator|*
operator|)
name|fdi
operator|.
name|answ
operator|)
operator|->
name|nodeid
expr_stmt|;
if|if
condition|(
operator|!
name|nid
condition|)
block|{
comment|/* 	                 * zero nodeid is the same as "not found", 	                 * but it's also cacheable (which we keep 	                 * keep on doing not as of writing this) 	                 */
name|lookup_err
operator|=
name|ENOENT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nid
operator|==
name|FUSE_ROOT_ID
condition|)
block|{
name|lookup_err
operator|=
name|EINVAL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|lookup_err
operator|&&
operator|(
operator|!
name|fdi
operator|.
name|answ_stat
operator|||
name|lookup_err
operator|!=
name|ENOENT
operator|||
name|op
operator|!=
name|FUSE_LOOKUP
operator|)
condition|)
block|{
name|fdisp_destroy
argument_list|(
operator|&
name|fdi
argument_list|)
expr_stmt|;
return|return
name|lookup_err
return|;
block|}
comment|/* lookup_err, if non-zero, must be ENOENT at this point */
if|if
condition|(
name|lookup_err
condition|)
block|{
if|if
condition|(
operator|(
name|nameiop
operator|==
name|CREATE
operator|||
name|nameiop
operator|==
name|RENAME
operator|)
operator|&&
name|islastcn
comment|/*&& directory dvp has not been removed */
condition|)
block|{
if|if
condition|(
name|vfs_isrdonly
argument_list|(
name|mp
argument_list|)
condition|)
block|{
name|err
operator|=
name|EROFS
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|#
directive|if
literal|0
comment|/* THINK_ABOUT_THIS */
block|if ((err = fuse_internal_access(dvp, VWRITE, cred, td,&facp))) { 				goto out; 			}
endif|#
directive|endif
comment|/* 	                 * Possibly record the position of a slot in the 	                 * directory large enough for the new component name. 	                 * This can be recorded in the vnode private data for 	                 * dvp. Set the SAVENAME flag to hold onto the 	                 * pathname for use later in VOP_CREATE or VOP_RENAME. 	                 */
name|cnp
operator|->
name|cn_flags
operator||=
name|SAVENAME
expr_stmt|;
name|err
operator|=
name|EJUSTRETURN
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Consider inserting name into cache. */
comment|/* 	         * No we can't use negative caching, as the fs 	         * changes are out of our control. 	         * False positives' falseness turns out just as things 	         * go by, but false negatives' falseness doesn't. 	         * (and aiding the caching mechanism with extra control 	         * mechanisms comes quite close to beating the whole purpose 	         * caching...) 	         */
if|#
directive|if
literal|0
block|if ((cnp->cn_flags& MAKEENTRY) != 0) { 			FS_DEBUG("inserting NULL into cache\n"); 			cache_enter(dvp, NULL, cnp); 		}
endif|#
directive|endif
name|err
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
else|else
block|{
comment|/* !lookup_err */
name|struct
name|fuse_entry_out
modifier|*
name|feo
init|=
name|NULL
decl_stmt|;
name|struct
name|fuse_attr
modifier|*
name|fattr
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|op
operator|==
name|FUSE_GETATTR
condition|)
block|{
name|fattr
operator|=
operator|&
operator|(
operator|(
expr|struct
name|fuse_attr_out
operator|*
operator|)
name|fdi
operator|.
name|answ
operator|)
operator|->
name|attr
expr_stmt|;
block|}
else|else
block|{
name|feo
operator|=
operator|(
expr|struct
name|fuse_entry_out
operator|*
operator|)
name|fdi
operator|.
name|answ
expr_stmt|;
name|fattr
operator|=
operator|&
operator|(
name|feo
operator|->
name|attr
operator|)
expr_stmt|;
block|}
comment|/* 	         * If deleting, and at end of pathname, return parameters 	         * which can be used to remove file.  If the wantparent flag 	         * isn't set, we return only the directory, otherwise we go on 	         * and lock the inode, being careful with ".". 	         */
if|if
condition|(
name|nameiop
operator|==
name|DELETE
operator|&&
name|islastcn
condition|)
block|{
comment|/* 	                 * Check for write access on directory. 	                 */
name|facp
operator|.
name|xuid
operator|=
name|fattr
operator|->
name|uid
expr_stmt|;
name|facp
operator|.
name|facc_flags
operator||=
name|FACCESS_STICKY
expr_stmt|;
name|err
operator|=
name|fuse_internal_access
argument_list|(
name|dvp
argument_list|,
name|VWRITE
argument_list|,
operator|&
name|facp
argument_list|,
name|td
argument_list|,
name|cred
argument_list|)
expr_stmt|;
name|facp
operator|.
name|facc_flags
operator|&=
operator|~
name|FACCESS_XQUERIES
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|nid
operator|==
name|VTOI
argument_list|(
name|dvp
argument_list|)
condition|)
block|{
name|vref
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|dvp
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|fuse_vnode_get
argument_list|(
name|dvp
operator|->
name|v_mount
argument_list|,
name|nid
argument_list|,
name|dvp
argument_list|,
operator|&
name|vp
argument_list|,
name|cnp
argument_list|,
name|IFTOVT
argument_list|(
name|fattr
operator|->
name|mode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
operator|*
name|vpp
operator|=
name|vp
expr_stmt|;
block|}
comment|/* 			 * Save the name for use in VOP_RMDIR and VOP_REMOVE 			 * later. 			 */
name|cnp
operator|->
name|cn_flags
operator||=
name|SAVENAME
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	         * If rewriting (RENAME), return the inode and the 	         * information required to rewrite the present directory 	         * Must get inode of directory entry to verify it's a 	         * regular file, or empty directory. 	         */
if|if
condition|(
name|nameiop
operator|==
name|RENAME
operator|&&
name|wantparent
operator|&&
name|islastcn
condition|)
block|{
if|#
directive|if
literal|0
comment|/* THINK_ABOUT_THIS */
block|if ((err = fuse_internal_access(dvp, VWRITE, cred, td,&facp))) { 				goto out; 			}
endif|#
directive|endif
comment|/* 	                 * Check for "." 	                 */
if|if
condition|(
name|nid
operator|==
name|VTOI
argument_list|(
name|dvp
argument_list|)
condition|)
block|{
name|err
operator|=
name|EISDIR
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|err
operator|=
name|fuse_vnode_get
argument_list|(
name|vnode_mount
argument_list|(
name|dvp
argument_list|)
argument_list|,
name|nid
argument_list|,
name|dvp
argument_list|,
operator|&
name|vp
argument_list|,
name|cnp
argument_list|,
name|IFTOVT
argument_list|(
name|fattr
operator|->
name|mode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
goto|goto
name|out
goto|;
block|}
operator|*
name|vpp
operator|=
name|vp
expr_stmt|;
comment|/* 	                 * Save the name for use in VOP_RENAME later. 	                 */
name|cnp
operator|->
name|cn_flags
operator||=
name|SAVENAME
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|flags
operator|&
name|ISDOTDOT
condition|)
block|{
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|int
name|ltype
decl_stmt|;
comment|/* 			 * Expanded copy of vn_vget_ino() so that 			 * fuse_vnode_get() can be used. 			 */
name|mp
operator|=
name|dvp
operator|->
name|v_mount
expr_stmt|;
name|ltype
operator|=
name|VOP_ISLOCKED
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|err
operator|=
name|vfs_busy
argument_list|(
name|mp
argument_list|,
name|MBF_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|vfs_ref
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|dvp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|err
operator|=
name|vfs_busy
argument_list|(
name|mp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vn_lock
argument_list|(
name|dvp
argument_list|,
name|ltype
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
name|vfs_rel
argument_list|(
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|(
name|dvp
operator|->
name|v_iflag
operator|&
name|VI_DOOMED
operator|)
operator|!=
literal|0
condition|)
block|{
name|err
operator|=
name|ENOENT
expr_stmt|;
name|vfs_unbusy
argument_list|(
name|mp
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|VOP_UNLOCK
argument_list|(
name|dvp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|err
operator|=
name|fuse_vnode_get
argument_list|(
name|vnode_mount
argument_list|(
name|dvp
argument_list|)
argument_list|,
name|nid
argument_list|,
name|NULL
argument_list|,
operator|&
name|vp
argument_list|,
name|cnp
argument_list|,
name|IFTOVT
argument_list|(
name|fattr
operator|->
name|mode
argument_list|)
argument_list|)
expr_stmt|;
name|vfs_unbusy
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|vn_lock
argument_list|(
name|dvp
argument_list|,
name|ltype
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dvp
operator|->
name|v_iflag
operator|&
name|VI_DOOMED
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|err
operator|==
literal|0
condition|)
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENOENT
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
operator|*
name|vpp
operator|=
name|vp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nid
operator|==
name|VTOI
argument_list|(
name|dvp
argument_list|)
condition|)
block|{
name|vref
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|dvp
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|fuse_vnode_get
argument_list|(
name|vnode_mount
argument_list|(
name|dvp
argument_list|)
argument_list|,
name|nid
argument_list|,
name|dvp
argument_list|,
operator|&
name|vp
argument_list|,
name|cnp
argument_list|,
name|IFTOVT
argument_list|(
name|fattr
operator|->
name|mode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
goto|goto
name|out
goto|;
block|}
name|fuse_vnode_setparent
argument_list|(
name|vp
argument_list|,
name|dvp
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|vp
expr_stmt|;
block|}
if|if
condition|(
name|op
operator|==
name|FUSE_GETATTR
condition|)
block|{
name|cache_attrs
argument_list|(
operator|*
name|vpp
argument_list|,
operator|(
expr|struct
name|fuse_attr_out
operator|*
operator|)
name|fdi
operator|.
name|answ
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cache_attrs
argument_list|(
operator|*
name|vpp
argument_list|,
operator|(
expr|struct
name|fuse_entry_out
operator|*
operator|)
name|fdi
operator|.
name|answ
argument_list|)
expr_stmt|;
block|}
comment|/* Insert name into cache if appropriate. */
comment|/* 	         * Nooo, caching is evil. With caching, we can't avoid stale 	         * information taking over the playground (cached info is not 	         * just positive/negative, it does have qualitative aspects, 	         * too). And a (VOP/FUSE)_GETATTR is always thrown anyway, when 	         * walking down along cached path components, and that's not 	         * any cheaper than FUSE_LOOKUP. This might change with 	         * implementing kernel side attr caching, but... In Linux, 	         * lookup results are not cached, and the daemon is bombarded 	         * with FUSE_LOOKUPS on and on. This shows that by design, the 	         * daemon is expected to handle frequent lookup queries 	         * efficiently, do its caching in userspace, and so on. 	         * 	         * So just leave the name cache alone. 	         */
comment|/* 	         * Well, now I know, Linux caches lookups, but with a 	         * timeout... So it's the same thing as attribute caching: 	         * we can deal with it when implement timeouts. 	         */
if|#
directive|if
literal|0
block|if (cnp->cn_flags& MAKEENTRY) { 			cache_enter(dvp, *vpp, cnp); 		}
endif|#
directive|endif
block|}
name|out
label|:
if|if
condition|(
operator|!
name|lookup_err
condition|)
block|{
comment|/* No lookup error; need to clean up. */
if|if
condition|(
name|err
condition|)
block|{
comment|/* Found inode; exit with no vnode. */
if|if
condition|(
name|op
operator|==
name|FUSE_LOOKUP
condition|)
block|{
name|fuse_internal_forget_send
argument_list|(
name|vnode_mount
argument_list|(
name|dvp
argument_list|)
argument_list|,
name|td
argument_list|,
name|cred
argument_list|,
name|nid
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|fdisp_destroy
argument_list|(
operator|&
name|fdi
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
else|else
block|{
ifndef|#
directive|ifndef
name|NO_EARLY_PERM_CHECK_HACK
if|if
condition|(
operator|!
name|islastcn
condition|)
block|{
comment|/* 				 * We have the attributes of the next item 				 * *now*, and it's a fact, and we do not 				 * have to do extra work for it (ie, beg the 				 * daemon), and it neither depends on such 				 * accidental things like attr caching. So 				 * the big idea: check credentials *now*, 				 * not at the beginning of the next call to 				 * lookup. 				 *  				 * The first item of the lookup chain (fs root) 				 * won't be checked then here, of course, as 				 * its never "the next". But go and see that 				 * the root is taken care about at the very 				 * beginning of this function. 				 *  				 * Now, given we want to do the access check 				 * this way, one might ask: so then why not 				 * do the access check just after fetching 				 * the inode and its attributes from the 				 * daemon? Why bother with producing the 				 * corresponding vnode at all if something 				 * is not OK? We know what's the deal as 				 * soon as we get those attrs... There is 				 * one bit of info though not given us by 				 * the daemon: whether his response is 				 * authoritative or not... His response should 				 * be ignored if something is mounted over 				 * the dir in question. But that can be 				 * known only by having the vnode... 				 */
name|int
name|tmpvtype
init|=
name|vnode_vtype
argument_list|(
operator|*
name|vpp
argument_list|)
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|facp
argument_list|,
sizeof|sizeof
argument_list|(
name|facp
argument_list|)
argument_list|)
expr_stmt|;
comment|/*the early perm check hack */
name|facp
operator|.
name|facc_flags
operator||=
name|FACCESS_VA_VALID
expr_stmt|;
if|if
condition|(
operator|(
name|tmpvtype
operator|!=
name|VDIR
operator|)
operator|&&
operator|(
name|tmpvtype
operator|!=
name|VLNK
operator|)
condition|)
block|{
name|err
operator|=
name|ENOTDIR
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|err
operator|&&
operator|!
name|vnode_mountedhere
argument_list|(
operator|*
name|vpp
argument_list|)
condition|)
block|{
name|err
operator|=
name|fuse_internal_access
argument_list|(
operator|*
name|vpp
argument_list|,
name|VEXEC
argument_list|,
operator|&
name|facp
argument_list|,
name|td
argument_list|,
name|cred
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|tmpvtype
operator|==
name|VLNK
condition|)
name|FS_DEBUG
argument_list|(
literal|"weird, permission error with a symlink?\n"
argument_list|)
expr_stmt|;
name|vput
argument_list|(
operator|*
name|vpp
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|NULL
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
block|}
name|fdisp_destroy
argument_list|(
operator|&
name|fdi
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/*     struct vnop_mkdir_args { 	struct vnode *a_dvp; 	struct vnode **a_vpp; 	struct componentname *a_cnp; 	struct vattr *a_vap;     }; */
end_comment

begin_function
specifier|static
name|int
name|fuse_vnop_mkdir
parameter_list|(
name|struct
name|vop_mkdir_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|dvp
init|=
name|ap
operator|->
name|a_dvp
decl_stmt|;
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
init|=
name|ap
operator|->
name|a_vpp
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
name|struct
name|vattr
modifier|*
name|vap
init|=
name|ap
operator|->
name|a_vap
decl_stmt|;
name|struct
name|fuse_mkdir_in
name|fmdi
decl_stmt|;
name|fuse_trace_printf_vnop
argument_list|()
expr_stmt|;
if|if
condition|(
name|fuse_isdeadfs
argument_list|(
name|dvp
argument_list|)
condition|)
block|{
return|return
name|ENXIO
return|;
block|}
name|fmdi
operator|.
name|mode
operator|=
name|MAKEIMODE
argument_list|(
name|vap
operator|->
name|va_type
argument_list|,
name|vap
operator|->
name|va_mode
argument_list|)
expr_stmt|;
return|return
operator|(
name|fuse_internal_newentry
argument_list|(
name|dvp
argument_list|,
name|vpp
argument_list|,
name|cnp
argument_list|,
name|FUSE_MKDIR
argument_list|,
operator|&
name|fmdi
argument_list|,
sizeof|sizeof
argument_list|(
name|fmdi
argument_list|)
argument_list|,
name|VDIR
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*     struct vnop_mknod_args { 	struct vnode *a_dvp; 	struct vnode **a_vpp; 	struct componentname *a_cnp; 	struct vattr *a_vap;     }; */
end_comment

begin_function
specifier|static
name|int
name|fuse_vnop_mknod
parameter_list|(
name|struct
name|vop_mknod_args
modifier|*
name|ap
parameter_list|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*     struct vnop_open_args { 	struct vnode *a_vp; 	int  a_mode; 	struct ucred *a_cred; 	struct thread *a_td; 	int a_fdidx; / struct file *a_fp;     }; */
end_comment

begin_function
specifier|static
name|int
name|fuse_vnop_open
parameter_list|(
name|struct
name|vop_open_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|int
name|mode
init|=
name|ap
operator|->
name|a_mode
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|ap
operator|->
name|a_td
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|ap
operator|->
name|a_cred
decl_stmt|;
name|fufh_type_t
name|fufh_type
decl_stmt|;
name|struct
name|fuse_vnode_data
modifier|*
name|fvdat
decl_stmt|;
name|int
name|error
decl_stmt|,
name|isdir
init|=
literal|0
decl_stmt|;
name|int32_t
name|fuse_open_flags
decl_stmt|;
name|FS_DEBUG2G
argument_list|(
literal|"inode=%ju mode=0x%x\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|VTOI
argument_list|(
name|vp
argument_list|)
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|fuse_isdeadfs
argument_list|(
name|vp
argument_list|)
condition|)
block|{
return|return
name|ENXIO
return|;
block|}
name|fvdat
operator|=
name|VTOFUD
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|vnode_isdir
argument_list|(
name|vp
argument_list|)
condition|)
block|{
name|isdir
operator|=
literal|1
expr_stmt|;
block|}
name|fuse_open_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|isdir
condition|)
block|{
name|fufh_type
operator|=
name|FUFH_RDONLY
expr_stmt|;
block|}
else|else
block|{
name|fufh_type
operator|=
name|fuse_filehandle_xlate_from_fflags
argument_list|(
name|mode
argument_list|)
expr_stmt|;
comment|/* 		 * For WRONLY opens, force DIRECT_IO.  This is necessary 		 * since writing a partial block through the buffer cache 		 * will result in a read of the block and that read won't 		 * be allowed by the WRONLY open. 		 */
if|if
condition|(
name|fufh_type
operator|==
name|FUFH_WRONLY
operator|||
operator|(
name|fvdat
operator|->
name|flag
operator|&
name|FN_DIRECTIO
operator|)
operator|!=
literal|0
condition|)
name|fuse_open_flags
operator|=
name|FOPEN_DIRECT_IO
expr_stmt|;
block|}
if|if
condition|(
name|fuse_filehandle_validrw
argument_list|(
name|vp
argument_list|,
name|fufh_type
argument_list|)
operator|!=
name|FUFH_INVALID
condition|)
block|{
name|fuse_vnode_open
argument_list|(
name|vp
argument_list|,
name|fuse_open_flags
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|error
operator|=
name|fuse_filehandle_open
argument_list|(
name|vp
argument_list|,
name|fufh_type
argument_list|,
name|NULL
argument_list|,
name|td
argument_list|,
name|cred
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*     struct vnop_read_args { 	struct vnode *a_vp; 	struct uio *a_uio; 	int  a_ioflag; 	struct ucred *a_cred;     }; */
end_comment

begin_function
specifier|static
name|int
name|fuse_vnop_read
parameter_list|(
name|struct
name|vop_read_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
init|=
name|ap
operator|->
name|a_uio
decl_stmt|;
name|int
name|ioflag
init|=
name|ap
operator|->
name|a_ioflag
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|ap
operator|->
name|a_cred
decl_stmt|;
name|FS_DEBUG2G
argument_list|(
literal|"inode=%ju offset=%jd resid=%zd\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|VTOI
argument_list|(
name|vp
argument_list|)
argument_list|,
name|uio
operator|->
name|uio_offset
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|)
expr_stmt|;
if|if
condition|(
name|fuse_isdeadfs
argument_list|(
name|vp
argument_list|)
condition|)
block|{
return|return
name|ENXIO
return|;
block|}
if|if
condition|(
name|VTOFUD
argument_list|(
name|vp
argument_list|)
operator|->
name|flag
operator|&
name|FN_DIRECTIO
condition|)
block|{
name|ioflag
operator||=
name|IO_DIRECT
expr_stmt|;
block|}
return|return
name|fuse_io_dispatch
argument_list|(
name|vp
argument_list|,
name|uio
argument_list|,
name|ioflag
argument_list|,
name|cred
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*     struct vnop_readdir_args { 	struct vnode *a_vp; 	struct uio *a_uio; 	struct ucred *a_cred; 	int *a_eofflag; 	int *ncookies; 	u_long **a_cookies;     }; */
end_comment

begin_function
specifier|static
name|int
name|fuse_vnop_readdir
parameter_list|(
name|struct
name|vop_readdir_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
init|=
name|ap
operator|->
name|a_uio
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|ap
operator|->
name|a_cred
decl_stmt|;
name|struct
name|fuse_filehandle
modifier|*
name|fufh
init|=
name|NULL
decl_stmt|;
name|struct
name|fuse_vnode_data
modifier|*
name|fvdat
decl_stmt|;
name|struct
name|fuse_iov
name|cookediov
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|int
name|freefufh
init|=
literal|0
decl_stmt|;
name|FS_DEBUG2G
argument_list|(
literal|"inode=%ju\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|VTOI
argument_list|(
name|vp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fuse_isdeadfs
argument_list|(
name|vp
argument_list|)
condition|)
block|{
return|return
name|ENXIO
return|;
block|}
if|if
condition|(
comment|/* XXXIP ((uio_iovcnt(uio)> 1)) || */
operator|(
name|uio_resid
argument_list|(
name|uio
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|dirent
argument_list|)
operator|)
condition|)
block|{
return|return
name|EINVAL
return|;
block|}
name|fvdat
operator|=
name|VTOFUD
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fuse_filehandle_valid
argument_list|(
name|vp
argument_list|,
name|FUFH_RDONLY
argument_list|)
condition|)
block|{
name|FS_DEBUG
argument_list|(
literal|"calling readdir() before open()"
argument_list|)
expr_stmt|;
name|err
operator|=
name|fuse_filehandle_open
argument_list|(
name|vp
argument_list|,
name|FUFH_RDONLY
argument_list|,
operator|&
name|fufh
argument_list|,
name|NULL
argument_list|,
name|cred
argument_list|)
expr_stmt|;
name|freefufh
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|fuse_filehandle_get
argument_list|(
name|vp
argument_list|,
name|FUFH_RDONLY
argument_list|,
operator|&
name|fufh
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
block|{
return|return
operator|(
name|err
operator|)
return|;
block|}
define|#
directive|define
name|DIRCOOKEDSIZE
value|FUSE_DIRENT_ALIGN(FUSE_NAME_OFFSET + MAXNAMLEN + 1)
name|fiov_init
argument_list|(
operator|&
name|cookediov
argument_list|,
name|DIRCOOKEDSIZE
argument_list|)
expr_stmt|;
name|err
operator|=
name|fuse_internal_readdir
argument_list|(
name|vp
argument_list|,
name|uio
argument_list|,
name|fufh
argument_list|,
operator|&
name|cookediov
argument_list|)
expr_stmt|;
name|fiov_teardown
argument_list|(
operator|&
name|cookediov
argument_list|)
expr_stmt|;
if|if
condition|(
name|freefufh
condition|)
block|{
name|fuse_filehandle_close
argument_list|(
name|vp
argument_list|,
name|FUFH_RDONLY
argument_list|,
name|NULL
argument_list|,
name|cred
argument_list|)
expr_stmt|;
block|}
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/*     struct vnop_readlink_args { 	struct vnode *a_vp; 	struct uio *a_uio; 	struct ucred *a_cred;     }; */
end_comment

begin_function
specifier|static
name|int
name|fuse_vnop_readlink
parameter_list|(
name|struct
name|vop_readlink_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
init|=
name|ap
operator|->
name|a_uio
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|ap
operator|->
name|a_cred
decl_stmt|;
name|struct
name|fuse_dispatcher
name|fdi
decl_stmt|;
name|int
name|err
decl_stmt|;
name|FS_DEBUG2G
argument_list|(
literal|"inode=%ju\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|VTOI
argument_list|(
name|vp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fuse_isdeadfs
argument_list|(
name|vp
argument_list|)
condition|)
block|{
return|return
name|ENXIO
return|;
block|}
if|if
condition|(
operator|!
name|vnode_islnk
argument_list|(
name|vp
argument_list|)
condition|)
block|{
return|return
name|EINVAL
return|;
block|}
name|fdisp_init
argument_list|(
operator|&
name|fdi
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|err
operator|=
name|fdisp_simple_putget_vp
argument_list|(
operator|&
name|fdi
argument_list|,
name|FUSE_READLINK
argument_list|,
name|vp
argument_list|,
name|curthread
argument_list|,
name|cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
operator|(
name|char
operator|*
operator|)
name|fdi
operator|.
name|answ
operator|)
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
name|fuse_get_mpdata
argument_list|(
name|vnode_mount
argument_list|(
name|vp
argument_list|)
argument_list|)
operator|->
name|dataflags
operator|&
name|FSESS_PUSH_SYMLINKS_IN
condition|)
block|{
name|char
modifier|*
name|mpth
init|=
name|vnode_mount
argument_list|(
name|vp
argument_list|)
operator|->
name|mnt_stat
operator|.
name|f_mntonname
decl_stmt|;
name|err
operator|=
name|uiomove
argument_list|(
name|mpth
argument_list|,
name|strlen
argument_list|(
name|mpth
argument_list|)
argument_list|,
name|uio
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|err
condition|)
block|{
name|err
operator|=
name|uiomove
argument_list|(
name|fdi
operator|.
name|answ
argument_list|,
name|fdi
operator|.
name|iosize
argument_list|,
name|uio
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|fdisp_destroy
argument_list|(
operator|&
name|fdi
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/*     struct vnop_reclaim_args { 	struct vnode *a_vp; 	struct thread *a_td;     }; */
end_comment

begin_function
specifier|static
name|int
name|fuse_vnop_reclaim
parameter_list|(
name|struct
name|vop_reclaim_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|ap
operator|->
name|a_td
decl_stmt|;
name|struct
name|fuse_vnode_data
modifier|*
name|fvdat
init|=
name|VTOFUD
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|fuse_filehandle
modifier|*
name|fufh
init|=
name|NULL
decl_stmt|;
name|int
name|type
decl_stmt|;
if|if
condition|(
operator|!
name|fvdat
condition|)
block|{
name|panic
argument_list|(
literal|"FUSE: no vnode data during recycling"
argument_list|)
expr_stmt|;
block|}
name|FS_DEBUG
argument_list|(
literal|"inode=%ju\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|VTOI
argument_list|(
name|vp
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|type
operator|=
literal|0
init|;
name|type
operator|<
name|FUFH_MAXTYPE
condition|;
name|type
operator|++
control|)
block|{
name|fufh
operator|=
operator|&
operator|(
name|fvdat
operator|->
name|fufh
index|[
name|type
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|FUFH_IS_VALID
argument_list|(
name|fufh
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"FUSE: vnode being reclaimed but fufh (type=%d) is valid"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|fuse_filehandle_close
argument_list|(
name|vp
argument_list|,
name|type
argument_list|,
name|td
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
operator|!
name|fuse_isdeadfs
argument_list|(
name|vp
argument_list|)
operator|)
operator|&&
operator|(
name|fvdat
operator|->
name|nlookup
operator|)
condition|)
block|{
name|fuse_internal_forget_send
argument_list|(
name|vnode_mount
argument_list|(
name|vp
argument_list|)
argument_list|,
name|td
argument_list|,
name|NULL
argument_list|,
name|VTOI
argument_list|(
name|vp
argument_list|)
argument_list|,
name|fvdat
operator|->
name|nlookup
argument_list|)
expr_stmt|;
block|}
name|fuse_vnode_setparent
argument_list|(
name|vp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cache_purge
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|vfs_hash_remove
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|vnode_destroy_vobject
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|fuse_vnode_destroy
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*     struct vnop_remove_args { 	struct vnode *a_dvp; 	struct vnode *a_vp; 	struct componentname *a_cnp;     }; */
end_comment

begin_function
specifier|static
name|int
name|fuse_vnop_remove
parameter_list|(
name|struct
name|vop_remove_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|dvp
init|=
name|ap
operator|->
name|a_dvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
name|int
name|err
decl_stmt|;
name|FS_DEBUG2G
argument_list|(
literal|"inode=%ju name=%*s\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|VTOI
argument_list|(
name|vp
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|cnp
operator|->
name|cn_namelen
argument_list|,
name|cnp
operator|->
name|cn_nameptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|fuse_isdeadfs
argument_list|(
name|vp
argument_list|)
condition|)
block|{
return|return
name|ENXIO
return|;
block|}
if|if
condition|(
name|vnode_isdir
argument_list|(
name|vp
argument_list|)
condition|)
block|{
return|return
name|EPERM
return|;
block|}
name|cache_purge
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|err
operator|=
name|fuse_internal_remove
argument_list|(
name|dvp
argument_list|,
name|vp
argument_list|,
name|cnp
argument_list|,
name|FUSE_UNLINK
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
name|fuse_internal_vnode_disappear
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/*     struct vnop_rename_args { 	struct vnode *a_fdvp; 	struct vnode *a_fvp; 	struct componentname *a_fcnp; 	struct vnode *a_tdvp; 	struct vnode *a_tvp; 	struct componentname *a_tcnp;     }; */
end_comment

begin_function
specifier|static
name|int
name|fuse_vnop_rename
parameter_list|(
name|struct
name|vop_rename_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|fdvp
init|=
name|ap
operator|->
name|a_fdvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|fvp
init|=
name|ap
operator|->
name|a_fvp
decl_stmt|;
name|struct
name|componentname
modifier|*
name|fcnp
init|=
name|ap
operator|->
name|a_fcnp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|tdvp
init|=
name|ap
operator|->
name|a_tdvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|tvp
init|=
name|ap
operator|->
name|a_tvp
decl_stmt|;
name|struct
name|componentname
modifier|*
name|tcnp
init|=
name|ap
operator|->
name|a_tcnp
decl_stmt|;
name|struct
name|fuse_data
modifier|*
name|data
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|FS_DEBUG2G
argument_list|(
literal|"from: inode=%ju name=%*s -> to: inode=%ju name=%*s\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|VTOI
argument_list|(
name|fvp
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|fcnp
operator|->
name|cn_namelen
argument_list|,
name|fcnp
operator|->
name|cn_nameptr
argument_list|,
call|(
name|uintmax_t
call|)
argument_list|(
name|tvp
operator|==
name|NULL
condition|?
operator|-
literal|1
else|:
name|VTOI
argument_list|(
name|tvp
argument_list|)
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|tcnp
operator|->
name|cn_namelen
argument_list|,
name|tcnp
operator|->
name|cn_nameptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|fuse_isdeadfs
argument_list|(
name|fdvp
argument_list|)
condition|)
block|{
return|return
name|ENXIO
return|;
block|}
if|if
condition|(
name|fvp
operator|->
name|v_mount
operator|!=
name|tdvp
operator|->
name|v_mount
operator|||
operator|(
name|tvp
operator|&&
name|fvp
operator|->
name|v_mount
operator|!=
name|tvp
operator|->
name|v_mount
operator|)
condition|)
block|{
name|FS_DEBUG
argument_list|(
literal|"cross-device rename: %s -> %s\n"
argument_list|,
name|fcnp
operator|->
name|cn_nameptr
argument_list|,
operator|(
name|tcnp
operator|!=
name|NULL
condition|?
name|tcnp
operator|->
name|cn_nameptr
else|:
literal|"(NULL)"
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|EXDEV
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|cache_purge
argument_list|(
name|fvp
argument_list|)
expr_stmt|;
comment|/*          * FUSE library is expected to check if target directory is not          * under the source directory in the file system tree.          * Linux performs this check at VFS level.          */
name|data
operator|=
name|fuse_get_mpdata
argument_list|(
name|vnode_mount
argument_list|(
name|tdvp
argument_list|)
argument_list|)
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|data
operator|->
name|rename_lock
argument_list|)
expr_stmt|;
name|err
operator|=
name|fuse_internal_rename
argument_list|(
name|fdvp
argument_list|,
name|fcnp
argument_list|,
name|tdvp
argument_list|,
name|tcnp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|tdvp
operator|!=
name|fdvp
condition|)
name|fuse_vnode_setparent
argument_list|(
name|fvp
argument_list|,
name|tdvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tvp
operator|!=
name|NULL
condition|)
name|fuse_vnode_setparent
argument_list|(
name|tvp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|sx_unlock
argument_list|(
operator|&
name|data
operator|->
name|rename_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|tvp
operator|!=
name|NULL
operator|&&
name|tvp
operator|!=
name|fvp
condition|)
block|{
name|cache_purge
argument_list|(
name|tvp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vnode_isdir
argument_list|(
name|fvp
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|tvp
operator|!=
name|NULL
operator|)
operator|&&
name|vnode_isdir
argument_list|(
name|tvp
argument_list|)
condition|)
block|{
name|cache_purge
argument_list|(
name|tdvp
argument_list|)
expr_stmt|;
block|}
name|cache_purge
argument_list|(
name|fdvp
argument_list|)
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|tdvp
operator|==
name|tvp
condition|)
block|{
name|vrele
argument_list|(
name|tdvp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vput
argument_list|(
name|tdvp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tvp
operator|!=
name|NULL
condition|)
block|{
name|vput
argument_list|(
name|tvp
argument_list|)
expr_stmt|;
block|}
name|vrele
argument_list|(
name|fdvp
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|fvp
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/*     struct vnop_rmdir_args { 	    struct vnode *a_dvp; 	    struct vnode *a_vp; 	    struct componentname *a_cnp;     } *ap; */
end_comment

begin_function
specifier|static
name|int
name|fuse_vnop_rmdir
parameter_list|(
name|struct
name|vop_rmdir_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|dvp
init|=
name|ap
operator|->
name|a_dvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|int
name|err
decl_stmt|;
name|FS_DEBUG2G
argument_list|(
literal|"inode=%ju\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|VTOI
argument_list|(
name|vp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fuse_isdeadfs
argument_list|(
name|vp
argument_list|)
condition|)
block|{
return|return
name|ENXIO
return|;
block|}
if|if
condition|(
name|VTOFUD
argument_list|(
name|vp
argument_list|)
operator|==
name|VTOFUD
argument_list|(
name|dvp
argument_list|)
condition|)
block|{
return|return
name|EINVAL
return|;
block|}
name|err
operator|=
name|fuse_internal_remove
argument_list|(
name|dvp
argument_list|,
name|vp
argument_list|,
name|ap
operator|->
name|a_cnp
argument_list|,
name|FUSE_RMDIR
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
name|fuse_internal_vnode_disappear
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/*     struct vnop_setattr_args { 	struct vnode *a_vp; 	struct vattr *a_vap; 	struct ucred *a_cred; 	struct thread *a_td;     }; */
end_comment

begin_function
specifier|static
name|int
name|fuse_vnop_setattr
parameter_list|(
name|struct
name|vop_setattr_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|vattr
modifier|*
name|vap
init|=
name|ap
operator|->
name|a_vap
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|ap
operator|->
name|a_cred
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|struct
name|fuse_dispatcher
name|fdi
decl_stmt|;
name|struct
name|fuse_setattr_in
modifier|*
name|fsai
decl_stmt|;
name|struct
name|fuse_access_param
name|facp
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|enum
name|vtype
name|vtyp
decl_stmt|;
name|int
name|sizechanged
init|=
literal|0
decl_stmt|;
name|uint64_t
name|newsize
init|=
literal|0
decl_stmt|;
name|FS_DEBUG2G
argument_list|(
literal|"inode=%ju\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|VTOI
argument_list|(
name|vp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fuse_isdeadfs
argument_list|(
name|vp
argument_list|)
condition|)
block|{
return|return
name|ENXIO
return|;
block|}
name|fdisp_init
argument_list|(
operator|&
name|fdi
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fsai
argument_list|)
argument_list|)
expr_stmt|;
name|fdisp_make_vp
argument_list|(
operator|&
name|fdi
argument_list|,
name|FUSE_SETATTR
argument_list|,
name|vp
argument_list|,
name|td
argument_list|,
name|cred
argument_list|)
expr_stmt|;
name|fsai
operator|=
name|fdi
operator|.
name|indata
expr_stmt|;
name|fsai
operator|->
name|valid
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|facp
argument_list|,
sizeof|sizeof
argument_list|(
name|facp
argument_list|)
argument_list|)
expr_stmt|;
name|facp
operator|.
name|xuid
operator|=
name|vap
operator|->
name|va_uid
expr_stmt|;
name|facp
operator|.
name|xgid
operator|=
name|vap
operator|->
name|va_gid
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|va_uid
operator|!=
operator|(
name|uid_t
operator|)
name|VNOVAL
condition|)
block|{
name|facp
operator|.
name|facc_flags
operator||=
name|FACCESS_CHOWN
expr_stmt|;
name|fsai
operator|->
name|uid
operator|=
name|vap
operator|->
name|va_uid
expr_stmt|;
name|fsai
operator|->
name|valid
operator||=
name|FATTR_UID
expr_stmt|;
block|}
if|if
condition|(
name|vap
operator|->
name|va_gid
operator|!=
operator|(
name|gid_t
operator|)
name|VNOVAL
condition|)
block|{
name|facp
operator|.
name|facc_flags
operator||=
name|FACCESS_CHOWN
expr_stmt|;
name|fsai
operator|->
name|gid
operator|=
name|vap
operator|->
name|va_gid
expr_stmt|;
name|fsai
operator|->
name|valid
operator||=
name|FATTR_GID
expr_stmt|;
block|}
if|if
condition|(
name|vap
operator|->
name|va_size
operator|!=
name|VNOVAL
condition|)
block|{
name|struct
name|fuse_filehandle
modifier|*
name|fufh
init|=
name|NULL
decl_stmt|;
comment|/*Truncate to a new value. */
name|fsai
operator|->
name|size
operator|=
name|vap
operator|->
name|va_size
expr_stmt|;
name|sizechanged
operator|=
literal|1
expr_stmt|;
name|newsize
operator|=
name|vap
operator|->
name|va_size
expr_stmt|;
name|fsai
operator|->
name|valid
operator||=
name|FATTR_SIZE
expr_stmt|;
name|fuse_filehandle_getrw
argument_list|(
name|vp
argument_list|,
name|FUFH_WRONLY
argument_list|,
operator|&
name|fufh
argument_list|)
expr_stmt|;
if|if
condition|(
name|fufh
condition|)
block|{
name|fsai
operator|->
name|fh
operator|=
name|fufh
operator|->
name|fh_id
expr_stmt|;
name|fsai
operator|->
name|valid
operator||=
name|FATTR_FH
expr_stmt|;
block|}
block|}
if|if
condition|(
name|vap
operator|->
name|va_atime
operator|.
name|tv_sec
operator|!=
name|VNOVAL
condition|)
block|{
name|fsai
operator|->
name|atime
operator|=
name|vap
operator|->
name|va_atime
operator|.
name|tv_sec
expr_stmt|;
name|fsai
operator|->
name|atimensec
operator|=
name|vap
operator|->
name|va_atime
operator|.
name|tv_nsec
expr_stmt|;
name|fsai
operator|->
name|valid
operator||=
name|FATTR_ATIME
expr_stmt|;
block|}
if|if
condition|(
name|vap
operator|->
name|va_mtime
operator|.
name|tv_sec
operator|!=
name|VNOVAL
condition|)
block|{
name|fsai
operator|->
name|mtime
operator|=
name|vap
operator|->
name|va_mtime
operator|.
name|tv_sec
expr_stmt|;
name|fsai
operator|->
name|mtimensec
operator|=
name|vap
operator|->
name|va_mtime
operator|.
name|tv_nsec
expr_stmt|;
name|fsai
operator|->
name|valid
operator||=
name|FATTR_MTIME
expr_stmt|;
block|}
if|if
condition|(
name|vap
operator|->
name|va_mode
operator|!=
operator|(
name|mode_t
operator|)
name|VNOVAL
condition|)
block|{
name|fsai
operator|->
name|mode
operator|=
name|vap
operator|->
name|va_mode
operator|&
name|ALLPERMS
expr_stmt|;
name|fsai
operator|->
name|valid
operator||=
name|FATTR_MODE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|fsai
operator|->
name|valid
condition|)
block|{
goto|goto
name|out
goto|;
block|}
name|vtyp
operator|=
name|vnode_vtype
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fsai
operator|->
name|valid
operator|&
name|FATTR_SIZE
operator|&&
name|vtyp
operator|==
name|VDIR
condition|)
block|{
name|err
operator|=
name|EISDIR
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|vfs_isrdonly
argument_list|(
name|vnode_mount
argument_list|(
name|vp
argument_list|)
argument_list|)
operator|&&
operator|(
name|fsai
operator|->
name|valid
operator|&
operator|~
name|FATTR_SIZE
operator|||
name|vtyp
operator|==
name|VREG
operator|)
condition|)
block|{
name|err
operator|=
name|EROFS
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|fsai
operator|->
name|valid
operator|&
operator|~
name|FATTR_SIZE
condition|)
block|{
comment|/*err = fuse_internal_access(vp, VADMIN, context,&facp); */
comment|/*XXX */
name|err
operator|=
literal|0
expr_stmt|;
block|}
name|facp
operator|.
name|facc_flags
operator|&=
operator|~
name|FACCESS_XQUERIES
expr_stmt|;
if|if
condition|(
name|err
operator|&&
operator|!
operator|(
name|fsai
operator|->
name|valid
operator|&
operator|~
operator|(
name|FATTR_ATIME
operator||
name|FATTR_MTIME
operator|)
operator|)
operator|&&
name|vap
operator|->
name|va_vaflags
operator|&
name|VA_UTIMES_NULL
condition|)
block|{
name|err
operator|=
name|fuse_internal_access
argument_list|(
name|vp
argument_list|,
name|VWRITE
argument_list|,
operator|&
name|facp
argument_list|,
name|td
argument_list|,
name|cred
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|(
name|err
operator|=
name|fdisp_wait_answ
argument_list|(
operator|&
name|fdi
argument_list|)
operator|)
condition|)
goto|goto
name|out
goto|;
name|vtyp
operator|=
name|IFTOVT
argument_list|(
operator|(
operator|(
expr|struct
name|fuse_attr_out
operator|*
operator|)
name|fdi
operator|.
name|answ
operator|)
operator|->
name|attr
operator|.
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|vnode_vtype
argument_list|(
name|vp
argument_list|)
operator|!=
name|vtyp
condition|)
block|{
if|if
condition|(
name|vnode_vtype
argument_list|(
name|vp
argument_list|)
operator|==
name|VNON
operator|&&
name|vtyp
operator|!=
name|VNON
condition|)
block|{
name|debug_printf
argument_list|(
literal|"FUSE: Dang! vnode_vtype is VNON and vtype isn't.\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 	                 * STALE vnode, ditch 	                 * 	                 * The vnode has changed its type "behind our back". There's 	                 * nothing really we can do, so let us just force an internal 	                 * revocation and tell the caller to try again, if interested. 	                 */
name|fuse_internal_vnode_disappear
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|err
operator|=
name|EAGAIN
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|err
operator|&&
operator|!
name|sizechanged
condition|)
block|{
name|cache_attrs
argument_list|(
name|vp
argument_list|,
operator|(
expr|struct
name|fuse_attr_out
operator|*
operator|)
name|fdi
operator|.
name|answ
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|fdisp_destroy
argument_list|(
operator|&
name|fdi
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
operator|&&
name|sizechanged
condition|)
block|{
name|fuse_vnode_setsize
argument_list|(
name|vp
argument_list|,
name|cred
argument_list|,
name|newsize
argument_list|)
expr_stmt|;
name|VTOFUD
argument_list|(
name|vp
argument_list|)
operator|->
name|flag
operator|&=
operator|~
name|FN_SIZECHANGE
expr_stmt|;
block|}
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/*     struct vnop_strategy_args { 	struct vnode *a_vp; 	struct buf *a_bp;     }; */
end_comment

begin_function
specifier|static
name|int
name|fuse_vnop_strategy
parameter_list|(
name|struct
name|vop_strategy_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
init|=
name|ap
operator|->
name|a_bp
decl_stmt|;
name|fuse_trace_printf_vnop
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|vp
operator|||
name|fuse_isdeadfs
argument_list|(
name|vp
argument_list|)
condition|)
block|{
name|bp
operator|->
name|b_ioflags
operator||=
name|BIO_ERROR
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|ENXIO
expr_stmt|;
name|bufdone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
if|if
condition|(
name|bp
operator|->
name|b_iocmd
operator|==
name|BIO_WRITE
condition|)
name|fuse_vnode_refreshsize
argument_list|(
name|vp
argument_list|,
name|NOCRED
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fuse_io_strategy
argument_list|(
name|vp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
comment|/* 	 * This is a dangerous function. If returns error, that might mean a 	 * panic. We prefer pretty much anything over being forced to panic 	 * by a malicious daemon (a demon?). So we just return 0 anyway. You 	 * should never mind this: this function has its own error 	 * propagation mechanism via the argument buffer, so 	 * not-that-melodramatic residents of the call chain still will be 	 * able to know what to do. 	 */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*     struct vnop_symlink_args { 	struct vnode *a_dvp; 	struct vnode **a_vpp; 	struct componentname *a_cnp; 	struct vattr *a_vap; 	char *a_target;     }; */
end_comment

begin_function
specifier|static
name|int
name|fuse_vnop_symlink
parameter_list|(
name|struct
name|vop_symlink_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|dvp
init|=
name|ap
operator|->
name|a_dvp
decl_stmt|;
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
init|=
name|ap
operator|->
name|a_vpp
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
name|char
modifier|*
name|target
init|=
name|ap
operator|->
name|a_target
decl_stmt|;
name|struct
name|fuse_dispatcher
name|fdi
decl_stmt|;
name|int
name|err
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|FS_DEBUG2G
argument_list|(
literal|"inode=%ju name=%*s\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|VTOI
argument_list|(
name|dvp
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|cnp
operator|->
name|cn_namelen
argument_list|,
name|cnp
operator|->
name|cn_nameptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|fuse_isdeadfs
argument_list|(
name|dvp
argument_list|)
condition|)
block|{
return|return
name|ENXIO
return|;
block|}
comment|/*          * Unlike the other creator type calls, here we have to create a message          * where the name of the new entry comes first, and the data describing          * the entry comes second.          * Hence we can't rely on our handy fuse_internal_newentry() routine,          * but put together the message manually and just call the core part.          */
name|len
operator|=
name|strlen
argument_list|(
name|target
argument_list|)
operator|+
literal|1
expr_stmt|;
name|fdisp_init
argument_list|(
operator|&
name|fdi
argument_list|,
name|len
operator|+
name|cnp
operator|->
name|cn_namelen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|fdisp_make_vp
argument_list|(
operator|&
name|fdi
argument_list|,
name|FUSE_SYMLINK
argument_list|,
name|dvp
argument_list|,
name|curthread
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|fdi
operator|.
name|indata
argument_list|,
name|cnp
operator|->
name|cn_nameptr
argument_list|,
name|cnp
operator|->
name|cn_namelen
argument_list|)
expr_stmt|;
operator|(
operator|(
name|char
operator|*
operator|)
name|fdi
operator|.
name|indata
operator|)
index|[
name|cnp
operator|->
name|cn_namelen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fdi
operator|.
name|indata
operator|+
name|cnp
operator|->
name|cn_namelen
operator|+
literal|1
argument_list|,
name|target
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|err
operator|=
name|fuse_internal_newentry_core
argument_list|(
name|dvp
argument_list|,
name|vpp
argument_list|,
name|cnp
argument_list|,
name|VLNK
argument_list|,
operator|&
name|fdi
argument_list|)
expr_stmt|;
name|fdisp_destroy
argument_list|(
operator|&
name|fdi
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/*     struct vnop_write_args { 	struct vnode *a_vp; 	struct uio *a_uio; 	int  a_ioflag; 	struct ucred *a_cred;     }; */
end_comment

begin_function
specifier|static
name|int
name|fuse_vnop_write
parameter_list|(
name|struct
name|vop_write_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
init|=
name|ap
operator|->
name|a_uio
decl_stmt|;
name|int
name|ioflag
init|=
name|ap
operator|->
name|a_ioflag
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|ap
operator|->
name|a_cred
decl_stmt|;
name|fuse_trace_printf_vnop
argument_list|()
expr_stmt|;
if|if
condition|(
name|fuse_isdeadfs
argument_list|(
name|vp
argument_list|)
condition|)
block|{
return|return
name|ENXIO
return|;
block|}
name|fuse_vnode_refreshsize
argument_list|(
name|vp
argument_list|,
name|cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|VTOFUD
argument_list|(
name|vp
argument_list|)
operator|->
name|flag
operator|&
name|FN_DIRECTIO
condition|)
block|{
name|ioflag
operator||=
name|IO_DIRECT
expr_stmt|;
block|}
return|return
name|fuse_io_dispatch
argument_list|(
name|vp
argument_list|,
name|uio
argument_list|,
name|ioflag
argument_list|,
name|cred
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*     struct vnop_getpages_args {         struct vnode *a_vp;         vm_page_t *a_m;         int a_count;         int a_reqpage;     }; */
end_comment

begin_function
specifier|static
name|int
name|fuse_vnop_getpages
parameter_list|(
name|struct
name|vop_getpages_args
modifier|*
name|ap
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|error
decl_stmt|,
name|nextoff
decl_stmt|,
name|size
decl_stmt|,
name|toff
decl_stmt|,
name|count
decl_stmt|,
name|npages
decl_stmt|;
name|struct
name|uio
name|uio
decl_stmt|;
name|struct
name|iovec
name|iov
decl_stmt|;
name|vm_offset_t
name|kva
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|vm_page_t
modifier|*
name|pages
decl_stmt|;
name|FS_DEBUG2G
argument_list|(
literal|"heh\n"
argument_list|)
expr_stmt|;
name|vp
operator|=
name|ap
operator|->
name|a_vp
expr_stmt|;
name|KASSERT
argument_list|(
name|vp
operator|->
name|v_object
argument_list|,
operator|(
literal|"objectless vp passed to getpages"
operator|)
argument_list|)
expr_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
comment|/* XXX */
name|cred
operator|=
name|curthread
operator|->
name|td_ucred
expr_stmt|;
comment|/* XXX */
name|pages
operator|=
name|ap
operator|->
name|a_m
expr_stmt|;
name|npages
operator|=
name|ap
operator|->
name|a_count
expr_stmt|;
if|if
condition|(
operator|!
name|fsess_opt_mmap
argument_list|(
name|vnode_mount
argument_list|(
name|vp
argument_list|)
argument_list|)
condition|)
block|{
name|FS_DEBUG
argument_list|(
literal|"called on non-cacheable vnode??\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|VM_PAGER_ERROR
operator|)
return|;
block|}
comment|/* 	 * If the last page is partially valid, just return it and allow 	 * the pager to zero-out the blanks.  Partially valid pages can 	 * only occur at the file EOF. 	 * 	 * XXXGL: is that true for FUSE, which is a local filesystem, 	 * but still somewhat disconnected from the kernel? 	 */
name|VM_OBJECT_WLOCK
argument_list|(
name|vp
operator|->
name|v_object
argument_list|)
expr_stmt|;
if|if
condition|(
name|pages
index|[
name|npages
operator|-
literal|1
index|]
operator|->
name|valid
operator|!=
literal|0
operator|&&
operator|--
name|npages
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
name|VM_OBJECT_WUNLOCK
argument_list|(
name|vp
operator|->
name|v_object
argument_list|)
expr_stmt|;
comment|/* 	 * We use only the kva address for the buffer, but this is extremely 	 * convenient and fast. 	 */
name|bp
operator|=
name|getpbuf
argument_list|(
operator|&
name|fuse_pbuf_freecnt
argument_list|)
expr_stmt|;
name|kva
operator|=
operator|(
name|vm_offset_t
operator|)
name|bp
operator|->
name|b_data
expr_stmt|;
name|pmap_qenter
argument_list|(
name|kva
argument_list|,
name|pages
argument_list|,
name|npages
argument_list|)
expr_stmt|;
name|VM_CNT_INC
argument_list|(
name|v_vnodein
argument_list|)
expr_stmt|;
name|VM_CNT_ADD
argument_list|(
name|v_vnodepgsin
argument_list|,
name|npages
argument_list|)
expr_stmt|;
name|count
operator|=
name|npages
operator|<<
name|PAGE_SHIFT
expr_stmt|;
name|iov
operator|.
name|iov_base
operator|=
operator|(
name|caddr_t
operator|)
name|kva
expr_stmt|;
name|iov
operator|.
name|iov_len
operator|=
name|count
expr_stmt|;
name|uio
operator|.
name|uio_iov
operator|=
operator|&
name|iov
expr_stmt|;
name|uio
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|uio
operator|.
name|uio_offset
operator|=
name|IDX_TO_OFF
argument_list|(
name|pages
index|[
literal|0
index|]
operator|->
name|pindex
argument_list|)
expr_stmt|;
name|uio
operator|.
name|uio_resid
operator|=
name|count
expr_stmt|;
name|uio
operator|.
name|uio_segflg
operator|=
name|UIO_SYSSPACE
expr_stmt|;
name|uio
operator|.
name|uio_rw
operator|=
name|UIO_READ
expr_stmt|;
name|uio
operator|.
name|uio_td
operator|=
name|td
expr_stmt|;
name|error
operator|=
name|fuse_io_dispatch
argument_list|(
name|vp
argument_list|,
operator|&
name|uio
argument_list|,
name|IO_DIRECT
argument_list|,
name|cred
argument_list|)
expr_stmt|;
name|pmap_qremove
argument_list|(
name|kva
argument_list|,
name|npages
argument_list|)
expr_stmt|;
name|relpbuf
argument_list|(
name|bp
argument_list|,
operator|&
name|fuse_pbuf_freecnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
operator|(
name|uio
operator|.
name|uio_resid
operator|==
name|count
operator|)
condition|)
block|{
name|FS_DEBUG
argument_list|(
literal|"error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|VM_PAGER_ERROR
return|;
block|}
comment|/* 	 * Calculate the number of bytes read and validate only that number 	 * of bytes.  Note that due to pending writes, size may be 0.  This 	 * does not mean that the remaining data is invalid! 	 */
name|size
operator|=
name|count
operator|-
name|uio
operator|.
name|uio_resid
expr_stmt|;
name|VM_OBJECT_WLOCK
argument_list|(
name|vp
operator|->
name|v_object
argument_list|)
expr_stmt|;
name|fuse_vm_page_lock_queues
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|toff
operator|=
literal|0
init|;
name|i
operator|<
name|npages
condition|;
name|i
operator|++
operator|,
name|toff
operator|=
name|nextoff
control|)
block|{
name|vm_page_t
name|m
decl_stmt|;
name|nextoff
operator|=
name|toff
operator|+
name|PAGE_SIZE
expr_stmt|;
name|m
operator|=
name|pages
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|nextoff
operator|<=
name|size
condition|)
block|{
comment|/* 			 * Read operation filled an entire page 			 */
name|m
operator|->
name|valid
operator|=
name|VM_PAGE_BITS_ALL
expr_stmt|;
name|KASSERT
argument_list|(
name|m
operator|->
name|dirty
operator|==
literal|0
argument_list|,
operator|(
literal|"fuse_getpages: page %p is dirty"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
operator|>
name|toff
condition|)
block|{
comment|/* 			 * Read operation filled a partial page. 			 */
name|m
operator|->
name|valid
operator|=
literal|0
expr_stmt|;
name|vm_page_set_valid_range
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|size
operator|-
name|toff
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|m
operator|->
name|dirty
operator|==
literal|0
argument_list|,
operator|(
literal|"fuse_getpages: page %p is dirty"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Read operation was short.  If no error occurred 			 * we may have hit a zero-fill section.   We simply 			 * leave valid set to 0. 			 */
empty_stmt|;
block|}
block|}
name|fuse_vm_page_unlock_queues
argument_list|()
expr_stmt|;
name|out
label|:
name|VM_OBJECT_WUNLOCK
argument_list|(
name|vp
operator|->
name|v_object
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|a_rbehind
condition|)
operator|*
name|ap
operator|->
name|a_rbehind
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|a_rahead
condition|)
operator|*
name|ap
operator|->
name|a_rahead
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|VM_PAGER_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*     struct vnop_putpages_args {         struct vnode *a_vp;         vm_page_t *a_m;         int a_count;         int a_sync;         int *a_rtvals;         vm_ooffset_t a_offset;     }; */
end_comment

begin_function
specifier|static
name|int
name|fuse_vnop_putpages
parameter_list|(
name|struct
name|vop_putpages_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|uio
name|uio
decl_stmt|;
name|struct
name|iovec
name|iov
decl_stmt|;
name|vm_offset_t
name|kva
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|,
name|npages
decl_stmt|,
name|count
decl_stmt|;
name|off_t
name|offset
decl_stmt|;
name|int
modifier|*
name|rtvals
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|vm_page_t
modifier|*
name|pages
decl_stmt|;
name|vm_ooffset_t
name|fsize
decl_stmt|;
name|FS_DEBUG2G
argument_list|(
literal|"heh\n"
argument_list|)
expr_stmt|;
name|vp
operator|=
name|ap
operator|->
name|a_vp
expr_stmt|;
name|KASSERT
argument_list|(
name|vp
operator|->
name|v_object
argument_list|,
operator|(
literal|"objectless vp passed to putpages"
operator|)
argument_list|)
expr_stmt|;
name|fsize
operator|=
name|vp
operator|->
name|v_object
operator|->
name|un_pager
operator|.
name|vnp
operator|.
name|vnp_size
expr_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
comment|/* XXX */
name|cred
operator|=
name|curthread
operator|->
name|td_ucred
expr_stmt|;
comment|/* XXX */
name|pages
operator|=
name|ap
operator|->
name|a_m
expr_stmt|;
name|count
operator|=
name|ap
operator|->
name|a_count
expr_stmt|;
name|rtvals
operator|=
name|ap
operator|->
name|a_rtvals
expr_stmt|;
name|npages
operator|=
name|btoc
argument_list|(
name|count
argument_list|)
expr_stmt|;
name|offset
operator|=
name|IDX_TO_OFF
argument_list|(
name|pages
index|[
literal|0
index|]
operator|->
name|pindex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fsess_opt_mmap
argument_list|(
name|vnode_mount
argument_list|(
name|vp
argument_list|)
argument_list|)
condition|)
block|{
name|FS_DEBUG
argument_list|(
literal|"called on non-cacheable vnode??\n"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|npages
condition|;
name|i
operator|++
control|)
name|rtvals
index|[
name|i
index|]
operator|=
name|VM_PAGER_AGAIN
expr_stmt|;
comment|/* 	 * When putting pages, do not extend file past EOF. 	 */
if|if
condition|(
name|offset
operator|+
name|count
operator|>
name|fsize
condition|)
block|{
name|count
operator|=
name|fsize
operator|-
name|offset
expr_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
name|count
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * We use only the kva address for the buffer, but this is extremely 	 * convenient and fast. 	 */
name|bp
operator|=
name|getpbuf
argument_list|(
operator|&
name|fuse_pbuf_freecnt
argument_list|)
expr_stmt|;
name|kva
operator|=
operator|(
name|vm_offset_t
operator|)
name|bp
operator|->
name|b_data
expr_stmt|;
name|pmap_qenter
argument_list|(
name|kva
argument_list|,
name|pages
argument_list|,
name|npages
argument_list|)
expr_stmt|;
name|VM_CNT_INC
argument_list|(
name|v_vnodeout
argument_list|)
expr_stmt|;
name|VM_CNT_ADD
argument_list|(
name|v_vnodepgsout
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|iov
operator|.
name|iov_base
operator|=
operator|(
name|caddr_t
operator|)
name|kva
expr_stmt|;
name|iov
operator|.
name|iov_len
operator|=
name|count
expr_stmt|;
name|uio
operator|.
name|uio_iov
operator|=
operator|&
name|iov
expr_stmt|;
name|uio
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|uio
operator|.
name|uio_offset
operator|=
name|offset
expr_stmt|;
name|uio
operator|.
name|uio_resid
operator|=
name|count
expr_stmt|;
name|uio
operator|.
name|uio_segflg
operator|=
name|UIO_SYSSPACE
expr_stmt|;
name|uio
operator|.
name|uio_rw
operator|=
name|UIO_WRITE
expr_stmt|;
name|uio
operator|.
name|uio_td
operator|=
name|td
expr_stmt|;
name|error
operator|=
name|fuse_io_dispatch
argument_list|(
name|vp
argument_list|,
operator|&
name|uio
argument_list|,
name|IO_DIRECT
argument_list|,
name|cred
argument_list|)
expr_stmt|;
name|pmap_qremove
argument_list|(
name|kva
argument_list|,
name|npages
argument_list|)
expr_stmt|;
name|relpbuf
argument_list|(
name|bp
argument_list|,
operator|&
name|fuse_pbuf_freecnt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|int
name|nwritten
init|=
name|round_page
argument_list|(
name|count
operator|-
name|uio
operator|.
name|uio_resid
argument_list|)
operator|/
name|PAGE_SIZE
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nwritten
condition|;
name|i
operator|++
control|)
block|{
name|rtvals
index|[
name|i
index|]
operator|=
name|VM_PAGER_OK
expr_stmt|;
name|VM_OBJECT_WLOCK
argument_list|(
name|pages
index|[
name|i
index|]
operator|->
name|object
argument_list|)
expr_stmt|;
name|vm_page_undirty
argument_list|(
name|pages
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|VM_OBJECT_WUNLOCK
argument_list|(
name|pages
index|[
name|i
index|]
operator|->
name|object
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|rtvals
index|[
literal|0
index|]
return|;
block|}
end_function

begin_comment
comment|/*     struct vnop_print_args {         struct vnode *a_vp;     }; */
end_comment

begin_function
specifier|static
name|int
name|fuse_vnop_print
parameter_list|(
name|struct
name|vop_print_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|fuse_vnode_data
modifier|*
name|fvdat
init|=
name|VTOFUD
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"nodeid: %ju, parent nodeid: %ju, nlookup: %ju, flag: %#x\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|VTOILLU
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
argument_list|,
operator|(
name|uintmax_t
operator|)
name|fvdat
operator|->
name|parent_nid
argument_list|,
operator|(
name|uintmax_t
operator|)
name|fvdat
operator|->
name|nlookup
argument_list|,
name|fvdat
operator|->
name|flag
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

