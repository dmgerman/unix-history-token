begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2007-2009 Google Inc. and Amit Singh  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  * * Redistributions of source code must retain the above copyright  *   notice, this list of conditions and the following disclaimer.  * * Redistributions in binary form must reproduce the above  *   copyright notice, this list of conditions and the following disclaimer  *   in the documentation and/or other materials provided with the  *   distribution.  * * Neither the name of Google Inc. nor the names of its  *   contributors may be used to endorse or promote products derived from  *   this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * Copyright (C) 2005 Csaba Henk.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/capsicum.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/filedesc.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|"fuse.h"
end_include

begin_include
include|#
directive|include
file|"fuse_param.h"
end_include

begin_include
include|#
directive|include
file|"fuse_node.h"
end_include

begin_include
include|#
directive|include
file|"fuse_ipc.h"
end_include

begin_include
include|#
directive|include
file|"fuse_internal.h"
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<security/mac/mac_framework.h>
end_include

begin_define
define|#
directive|define
name|FUSE_DEBUG_MODULE
value|VFSOPS
end_define

begin_include
include|#
directive|include
file|"fuse_debug.h"
end_include

begin_comment
comment|/* This will do for privilege types for now */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PRIV_VFS_FUSE_ALLOWOTHER
end_ifndef

begin_define
define|#
directive|define
name|PRIV_VFS_FUSE_ALLOWOTHER
value|PRIV_VFS_MOUNT_NONUSER
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PRIV_VFS_FUSE_MOUNT_NONUSER
end_ifndef

begin_define
define|#
directive|define
name|PRIV_VFS_FUSE_MOUNT_NONUSER
value|PRIV_VFS_MOUNT_NONUSER
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PRIV_VFS_FUSE_SYNC_UNMOUNT
end_ifndef

begin_define
define|#
directive|define
name|PRIV_VFS_FUSE_SYNC_UNMOUNT
value|PRIV_VFS_MOUNT_NONUSER
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|vfs_mount_t
name|fuse_vfsop_mount
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vfs_unmount_t
name|fuse_vfsop_unmount
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vfs_root_t
name|fuse_vfsop_root
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vfs_statfs_t
name|fuse_vfsop_statfs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vfsops
name|fuse_vfsops
init|=
block|{
operator|.
name|vfs_mount
operator|=
name|fuse_vfsop_mount
block|,
operator|.
name|vfs_unmount
operator|=
name|fuse_vfsop_unmount
block|,
operator|.
name|vfs_root
operator|=
name|fuse_vfsop_root
block|,
operator|.
name|vfs_statfs
operator|=
name|fuse_vfsop_statfs
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_fuse
argument_list|,
name|OID_AUTO
argument_list|,
name|init_backgrounded
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|SYSCTL_NULL_INT_PTR
argument_list|,
literal|1
argument_list|,
literal|"indicate async handshake"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|fuse_enforce_dev_perms
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_fuse
argument_list|,
name|OID_AUTO
argument_list|,
name|enforce_dev_perms
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|fuse_enforce_dev_perms
argument_list|,
literal|0
argument_list|,
literal|"enforce fuse device permissions for secondary mounts"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|sync_unmount
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_vfs_fuse
argument_list|,
name|OID_AUTO
argument_list|,
name|sync_unmount
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|sync_unmount
argument_list|,
literal|0
argument_list|,
literal|"specify when to use synchronous unmount"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_FUSEVFS
argument_list|,
literal|"fuse_filesystem"
argument_list|,
literal|"buffer for fuse vfs layer"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|fuse_getdevice
parameter_list|(
specifier|const
name|char
modifier|*
name|fspec
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|cdev
modifier|*
modifier|*
name|fdevp
parameter_list|)
block|{
name|struct
name|nameidata
name|nd
decl_stmt|,
modifier|*
name|ndp
init|=
operator|&
name|nd
decl_stmt|;
name|struct
name|vnode
modifier|*
name|devvp
decl_stmt|;
name|struct
name|cdev
modifier|*
name|fdev
decl_stmt|;
name|int
name|err
decl_stmt|;
comment|/*          * Not an update, or updating the name: look up the name          * and verify that it refers to a sensible disk device.          */
name|NDINIT
argument_list|(
name|ndp
argument_list|,
name|LOOKUP
argument_list|,
name|FOLLOW
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|fspec
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|namei
argument_list|(
name|ndp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|err
return|;
name|NDFREE
argument_list|(
name|ndp
argument_list|,
name|NDF_ONLY_PNBUF
argument_list|)
expr_stmt|;
name|devvp
operator|=
name|ndp
operator|->
name|ni_vp
expr_stmt|;
if|if
condition|(
name|devvp
operator|->
name|v_type
operator|!=
name|VCHR
condition|)
block|{
name|vrele
argument_list|(
name|devvp
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|fdev
operator|=
name|devvp
operator|->
name|v_rdev
expr_stmt|;
name|dev_ref
argument_list|(
name|fdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|fuse_enforce_dev_perms
condition|)
block|{
comment|/* 	         * Check if mounter can open the fuse device. 	         * 	         * This has significance only if we are doing a secondary mount 	         * which doesn't involve actually opening fuse devices, but we 	         * still want to enforce the permissions of the device (in 	         * order to keep control over the circle of fuse users). 	         * 	         * (In case of primary mounts, we are either the superuser so 	         * we can do anything anyway, or we can mount only if the 	         * device is already opened by us, ie. we are permitted to open 	         * the device.) 	         */
if|#
directive|if
literal|0
ifdef|#
directive|ifdef
name|MAC
block|err = mac_check_vnode_open(td->td_ucred, devvp, VREAD | VWRITE); 		if (!err)
endif|#
directive|endif
endif|#
directive|endif
comment|/* 0 */
name|err
operator|=
name|VOP_ACCESS
argument_list|(
name|devvp
argument_list|,
name|VREAD
operator||
name|VWRITE
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|vrele
argument_list|(
name|devvp
argument_list|)
expr_stmt|;
name|dev_rel
argument_list|(
name|fdev
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
block|}
comment|/*          * according to coda code, no extra lock is needed --          * although in sys/vnode.h this field is marked "v"          */
name|vrele
argument_list|(
name|devvp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fdev
operator|->
name|si_devsw
operator|||
name|strcmp
argument_list|(
literal|"fuse"
argument_list|,
name|fdev
operator|->
name|si_devsw
operator|->
name|d_name
argument_list|)
condition|)
block|{
name|dev_rel
argument_list|(
name|fdev
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
operator|*
name|fdevp
operator|=
name|fdev
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_define
define|#
directive|define
name|FUSE_FLAGOPT
parameter_list|(
name|fnam
parameter_list|,
name|fval
parameter_list|)
value|do {				\     vfs_flagopt(opts, #fnam,&mntopts, fval);		\     vfs_flagopt(opts, "__" #fnam,&__mntopts, fval);	\ } while (0)
end_define

begin_function
specifier|static
name|int
name|fuse_vfsop_mount
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|uint64_t
name|mntopts
decl_stmt|,
name|__mntopts
decl_stmt|;
name|int
name|max_read_set
decl_stmt|;
name|uint32_t
name|max_read
decl_stmt|;
name|int
name|daemon_timeout
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|struct
name|cdev
modifier|*
name|fdev
decl_stmt|;
name|struct
name|fuse_data
modifier|*
name|data
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|file
modifier|*
name|fp
decl_stmt|,
modifier|*
name|fptmp
decl_stmt|;
name|char
modifier|*
name|fspec
decl_stmt|,
modifier|*
name|subtype
decl_stmt|;
name|struct
name|vfsoptlist
modifier|*
name|opts
decl_stmt|;
name|cap_rights_t
name|rights
decl_stmt|;
name|subtype
operator|=
name|NULL
expr_stmt|;
name|max_read_set
operator|=
literal|0
expr_stmt|;
name|max_read
operator|=
operator|~
literal|0
expr_stmt|;
name|err
operator|=
literal|0
expr_stmt|;
name|mntopts
operator|=
literal|0
expr_stmt|;
name|__mntopts
operator|=
literal|0
expr_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
name|fuse_trace_printf_vfsop
argument_list|()
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|mnt_flag
operator|&
name|MNT_UPDATE
condition|)
return|return
name|EOPNOTSUPP
return|;
name|MNT_ILOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|mp
operator|->
name|mnt_flag
operator||=
name|MNT_SYNCHRONOUS
expr_stmt|;
name|mp
operator|->
name|mnt_data
operator|=
name|NULL
expr_stmt|;
name|MNT_IUNLOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
comment|/* Get the new options passed to mount */
name|opts
operator|=
name|mp
operator|->
name|mnt_optnew
expr_stmt|;
if|if
condition|(
operator|!
name|opts
condition|)
return|return
name|EINVAL
return|;
comment|/* `fspath' contains the mount point (eg. /mnt/fuse/sshfs); REQUIRED */
if|if
condition|(
operator|!
name|vfs_getopts
argument_list|(
name|opts
argument_list|,
literal|"fspath"
argument_list|,
operator|&
name|err
argument_list|)
condition|)
return|return
name|err
return|;
comment|/* `from' contains the device name (eg. /dev/fuse0); REQUIRED */
name|fspec
operator|=
name|vfs_getopts
argument_list|(
name|opts
argument_list|,
literal|"from"
argument_list|,
operator|&
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fspec
condition|)
return|return
name|err
return|;
comment|/* `fd' contains the filedescriptor for this session; REQUIRED */
if|if
condition|(
name|vfs_scanopt
argument_list|(
name|opts
argument_list|,
literal|"fd"
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|fd
argument_list|)
operator|!=
literal|1
condition|)
return|return
name|EINVAL
return|;
name|err
operator|=
name|fuse_getdevice
argument_list|(
name|fspec
argument_list|,
name|td
argument_list|,
operator|&
name|fdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
name|err
return|;
comment|/*          * With the help of underscored options the mount program          * can inform us from the flags it sets by default          */
name|FUSE_FLAGOPT
argument_list|(
name|allow_other
argument_list|,
name|FSESS_DAEMON_CAN_SPY
argument_list|)
expr_stmt|;
name|FUSE_FLAGOPT
argument_list|(
name|push_symlinks_in
argument_list|,
name|FSESS_PUSH_SYMLINKS_IN
argument_list|)
expr_stmt|;
name|FUSE_FLAGOPT
argument_list|(
name|default_permissions
argument_list|,
name|FSESS_DEFAULT_PERMISSIONS
argument_list|)
expr_stmt|;
name|FUSE_FLAGOPT
argument_list|(
name|no_attrcache
argument_list|,
name|FSESS_NO_ATTRCACHE
argument_list|)
expr_stmt|;
name|FUSE_FLAGOPT
argument_list|(
name|no_readahed
argument_list|,
name|FSESS_NO_READAHEAD
argument_list|)
expr_stmt|;
name|FUSE_FLAGOPT
argument_list|(
name|no_datacache
argument_list|,
name|FSESS_NO_DATACACHE
argument_list|)
expr_stmt|;
name|FUSE_FLAGOPT
argument_list|(
name|no_namecache
argument_list|,
name|FSESS_NO_NAMECACHE
argument_list|)
expr_stmt|;
name|FUSE_FLAGOPT
argument_list|(
name|no_mmap
argument_list|,
name|FSESS_NO_MMAP
argument_list|)
expr_stmt|;
name|FUSE_FLAGOPT
argument_list|(
name|brokenio
argument_list|,
name|FSESS_BROKENIO
argument_list|)
expr_stmt|;
if|if
condition|(
name|vfs_scanopt
argument_list|(
name|opts
argument_list|,
literal|"max_read="
argument_list|,
literal|"%u"
argument_list|,
operator|&
name|max_read
argument_list|)
operator|==
literal|1
condition|)
name|max_read_set
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|vfs_scanopt
argument_list|(
name|opts
argument_list|,
literal|"timeout="
argument_list|,
literal|"%u"
argument_list|,
operator|&
name|daemon_timeout
argument_list|)
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|daemon_timeout
operator|<
name|FUSE_MIN_DAEMON_TIMEOUT
condition|)
name|daemon_timeout
operator|=
name|FUSE_MIN_DAEMON_TIMEOUT
expr_stmt|;
elseif|else
if|if
condition|(
name|daemon_timeout
operator|>
name|FUSE_MAX_DAEMON_TIMEOUT
condition|)
name|daemon_timeout
operator|=
name|FUSE_MAX_DAEMON_TIMEOUT
expr_stmt|;
block|}
else|else
block|{
name|daemon_timeout
operator|=
name|FUSE_DEFAULT_DAEMON_TIMEOUT
expr_stmt|;
block|}
name|subtype
operator|=
name|vfs_getopts
argument_list|(
name|opts
argument_list|,
literal|"subtype="
argument_list|,
operator|&
name|err
argument_list|)
expr_stmt|;
name|FS_DEBUG2G
argument_list|(
literal|"mntopts 0x%jx\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|mntopts
argument_list|)
expr_stmt|;
name|err
operator|=
name|fget
argument_list|(
name|td
argument_list|,
name|fd
argument_list|,
name|cap_rights_init
argument_list|(
operator|&
name|rights
argument_list|,
name|CAP_READ
argument_list|)
argument_list|,
operator|&
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|FS_DEBUG
argument_list|(
literal|"invalid or not opened device: data=%p\n"
argument_list|,
name|data
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|fptmp
operator|=
name|td
operator|->
name|td_fpop
expr_stmt|;
name|td
operator|->
name|td_fpop
operator|=
name|fp
expr_stmt|;
name|err
operator|=
name|devfs_get_cdevpriv
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|data
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_fpop
operator|=
name|fptmp
expr_stmt|;
name|fdrop
argument_list|(
name|fp
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|FUSE_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
operator|||
name|data
operator|==
name|NULL
operator|||
name|data
operator|->
name|mp
operator|!=
name|NULL
condition|)
block|{
name|FS_DEBUG
argument_list|(
literal|"invalid or not opened device: data=%p data.mp=%p\n"
argument_list|,
name|data
argument_list|,
name|data
operator|!=
name|NULL
condition|?
name|data
operator|->
name|mp
else|:
name|NULL
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENXIO
expr_stmt|;
name|FUSE_UNLOCK
argument_list|()
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|fdata_get_dead
argument_list|(
name|data
argument_list|)
condition|)
block|{
name|FS_DEBUG
argument_list|(
literal|"device is dead during mount: data=%p\n"
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENOTCONN
expr_stmt|;
name|FUSE_UNLOCK
argument_list|()
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Sanity + permission checks */
if|if
condition|(
operator|!
name|data
operator|->
name|daemoncred
condition|)
name|panic
argument_list|(
literal|"fuse daemon found, but identity unknown"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mntopts
operator|&
name|FSESS_DAEMON_CAN_SPY
condition|)
name|err
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_VFS_FUSE_ALLOWOTHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
operator|&&
name|td
operator|->
name|td_ucred
operator|->
name|cr_uid
operator|!=
name|data
operator|->
name|daemoncred
operator|->
name|cr_uid
condition|)
comment|/* are we allowed to do the first mount? */
name|err
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_VFS_FUSE_MOUNT_NONUSER
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|FUSE_UNLOCK
argument_list|()
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|data
operator|->
name|ref
operator|++
expr_stmt|;
name|data
operator|->
name|mp
operator|=
name|mp
expr_stmt|;
name|data
operator|->
name|dataflags
operator||=
name|mntopts
expr_stmt|;
name|data
operator|->
name|max_read
operator|=
name|max_read
expr_stmt|;
name|data
operator|->
name|daemon_timeout
operator|=
name|daemon_timeout
expr_stmt|;
name|FUSE_UNLOCK
argument_list|()
expr_stmt|;
name|vfs_getnewfsid
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|MNT_ILOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|mp
operator|->
name|mnt_data
operator|=
name|data
expr_stmt|;
name|mp
operator|->
name|mnt_flag
operator||=
name|MNT_LOCAL
expr_stmt|;
name|MNT_IUNLOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
comment|/* We need this here as this slot is used by getnewvnode() */
name|mp
operator|->
name|mnt_stat
operator|.
name|f_iosize
operator|=
name|PAGE_SIZE
expr_stmt|;
if|if
condition|(
name|subtype
condition|)
block|{
name|strlcat
argument_list|(
name|mp
operator|->
name|mnt_stat
operator|.
name|f_fstypename
argument_list|,
literal|"."
argument_list|,
name|MFSNAMELEN
argument_list|)
expr_stmt|;
name|strlcat
argument_list|(
name|mp
operator|->
name|mnt_stat
operator|.
name|f_fstypename
argument_list|,
name|subtype
argument_list|,
name|MFSNAMELEN
argument_list|)
expr_stmt|;
block|}
name|copystr
argument_list|(
name|fspec
argument_list|,
name|mp
operator|->
name|mnt_stat
operator|.
name|f_mntfromname
argument_list|,
name|MNAMELEN
operator|-
literal|1
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|mp
operator|->
name|mnt_stat
operator|.
name|f_mntfromname
operator|+
name|len
argument_list|,
name|MNAMELEN
operator|-
name|len
argument_list|)
expr_stmt|;
name|FS_DEBUG2G
argument_list|(
literal|"mp %p: %s\n"
argument_list|,
name|mp
argument_list|,
name|mp
operator|->
name|mnt_stat
operator|.
name|f_mntfromname
argument_list|)
expr_stmt|;
comment|/* Now handshaking with daemon */
name|fuse_internal_send_init
argument_list|(
name|data
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|err
condition|)
block|{
name|FUSE_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|mp
operator|==
name|mp
condition|)
block|{
comment|/* 			 * Destroy device only if we acquired reference to 			 * it 			 */
name|FS_DEBUG
argument_list|(
literal|"mount failed, destroy device: data=%p mp=%p"
literal|" err=%d\n"
argument_list|,
name|data
argument_list|,
name|mp
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|data
operator|->
name|mp
operator|=
name|NULL
expr_stmt|;
name|fdata_trydestroy
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
name|FUSE_UNLOCK
argument_list|()
expr_stmt|;
name|dev_rel
argument_list|(
name|fdev
argument_list|)
expr_stmt|;
block|}
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fuse_vfsop_unmount
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|int
name|mntflags
parameter_list|)
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
name|int
name|flags
init|=
literal|0
decl_stmt|;
name|struct
name|cdev
modifier|*
name|fdev
decl_stmt|;
name|struct
name|fuse_data
modifier|*
name|data
decl_stmt|;
name|struct
name|fuse_dispatcher
name|fdi
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|fuse_trace_printf_vfsop
argument_list|()
expr_stmt|;
if|if
condition|(
name|mntflags
operator|&
name|MNT_FORCE
condition|)
block|{
name|flags
operator||=
name|FORCECLOSE
expr_stmt|;
block|}
name|data
operator|=
name|fuse_get_mpdata
argument_list|(
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|data
condition|)
block|{
name|panic
argument_list|(
literal|"no private data for mount point?"
argument_list|)
expr_stmt|;
block|}
comment|/* There is 1 extra root vnode reference (mp->mnt_data). */
name|FUSE_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|vroot
operator|!=
name|NULL
condition|)
block|{
name|struct
name|vnode
modifier|*
name|vroot
init|=
name|data
operator|->
name|vroot
decl_stmt|;
name|data
operator|->
name|vroot
operator|=
name|NULL
expr_stmt|;
name|FUSE_UNLOCK
argument_list|()
expr_stmt|;
name|vrele
argument_list|(
name|vroot
argument_list|)
expr_stmt|;
block|}
else|else
name|FUSE_UNLOCK
argument_list|()
expr_stmt|;
name|err
operator|=
name|vflush
argument_list|(
name|mp
argument_list|,
literal|0
argument_list|,
name|flags
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|debug_printf
argument_list|(
literal|"vflush failed"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
if|if
condition|(
name|fdata_get_dead
argument_list|(
name|data
argument_list|)
condition|)
block|{
goto|goto
name|alreadydead
goto|;
block|}
name|fdisp_init
argument_list|(
operator|&
name|fdi
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fdisp_make
argument_list|(
operator|&
name|fdi
argument_list|,
name|FUSE_DESTROY
argument_list|,
name|mp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|err
operator|=
name|fdisp_wait_answ
argument_list|(
operator|&
name|fdi
argument_list|)
expr_stmt|;
name|fdisp_destroy
argument_list|(
operator|&
name|fdi
argument_list|)
expr_stmt|;
name|fdata_set_dead
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|alreadydead
label|:
name|FUSE_LOCK
argument_list|()
expr_stmt|;
name|data
operator|->
name|mp
operator|=
name|NULL
expr_stmt|;
name|fdev
operator|=
name|data
operator|->
name|fdev
expr_stmt|;
name|fdata_trydestroy
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|FUSE_UNLOCK
argument_list|()
expr_stmt|;
name|MNT_ILOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|mp
operator|->
name|mnt_data
operator|=
name|NULL
expr_stmt|;
name|mp
operator|->
name|mnt_flag
operator|&=
operator|~
name|MNT_LOCAL
expr_stmt|;
name|MNT_IUNLOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|dev_rel
argument_list|(
name|fdev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fuse_vfsop_root
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|int
name|lkflags
parameter_list|,
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
parameter_list|)
block|{
name|struct
name|fuse_data
modifier|*
name|data
init|=
name|fuse_get_mpdata
argument_list|(
name|mp
argument_list|)
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|data
operator|->
name|vroot
operator|!=
name|NULL
condition|)
block|{
name|err
operator|=
name|vget
argument_list|(
name|data
operator|->
name|vroot
argument_list|,
name|lkflags
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
operator|*
name|vpp
operator|=
name|data
operator|->
name|vroot
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|fuse_vnode_get
argument_list|(
name|mp
argument_list|,
name|FUSE_ROOT_ID
argument_list|,
name|NULL
argument_list|,
name|vpp
argument_list|,
name|NULL
argument_list|,
name|VDIR
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|FUSE_LOCK
argument_list|()
expr_stmt|;
name|MPASS
argument_list|(
name|data
operator|->
name|vroot
operator|==
name|NULL
operator|||
name|data
operator|->
name|vroot
operator|==
operator|*
name|vpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|vroot
operator|==
name|NULL
condition|)
block|{
name|FS_DEBUG
argument_list|(
literal|"new root vnode\n"
argument_list|)
expr_stmt|;
name|data
operator|->
name|vroot
operator|=
operator|*
name|vpp
expr_stmt|;
name|FUSE_UNLOCK
argument_list|()
expr_stmt|;
name|vref
argument_list|(
operator|*
name|vpp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|data
operator|->
name|vroot
operator|!=
operator|*
name|vpp
condition|)
block|{
name|FS_DEBUG
argument_list|(
literal|"root vnode race\n"
argument_list|)
expr_stmt|;
name|FUSE_UNLOCK
argument_list|()
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
operator|*
name|vpp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
operator|*
name|vpp
argument_list|)
expr_stmt|;
name|vrecycle
argument_list|(
operator|*
name|vpp
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|data
operator|->
name|vroot
expr_stmt|;
block|}
else|else
name|FUSE_UNLOCK
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fuse_vfsop_statfs
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|struct
name|statfs
modifier|*
name|sbp
parameter_list|)
block|{
name|struct
name|fuse_dispatcher
name|fdi
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|struct
name|fuse_statfs_out
modifier|*
name|fsfo
decl_stmt|;
name|struct
name|fuse_data
modifier|*
name|data
decl_stmt|;
name|FS_DEBUG2G
argument_list|(
literal|"mp %p: %s\n"
argument_list|,
name|mp
argument_list|,
name|mp
operator|->
name|mnt_stat
operator|.
name|f_mntfromname
argument_list|)
expr_stmt|;
name|data
operator|=
name|fuse_get_mpdata
argument_list|(
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|data
operator|->
name|dataflags
operator|&
name|FSESS_INITED
operator|)
condition|)
goto|goto
name|fake
goto|;
name|fdisp_init
argument_list|(
operator|&
name|fdi
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fdisp_make
argument_list|(
operator|&
name|fdi
argument_list|,
name|FUSE_STATFS
argument_list|,
name|mp
argument_list|,
name|FUSE_ROOT_ID
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|err
operator|=
name|fdisp_wait_answ
argument_list|(
operator|&
name|fdi
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|fdisp_destroy
argument_list|(
operator|&
name|fdi
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|ENOTCONN
condition|)
block|{
comment|/* 	                 * We want to seem a legitimate fs even if the daemon 	                 * is stiff dead... (so that, eg., we can still do path 	                 * based unmounting after the daemon dies). 	                 */
goto|goto
name|fake
goto|;
block|}
return|return
name|err
return|;
block|}
name|fsfo
operator|=
name|fdi
operator|.
name|answ
expr_stmt|;
name|sbp
operator|->
name|f_blocks
operator|=
name|fsfo
operator|->
name|st
operator|.
name|blocks
expr_stmt|;
name|sbp
operator|->
name|f_bfree
operator|=
name|fsfo
operator|->
name|st
operator|.
name|bfree
expr_stmt|;
name|sbp
operator|->
name|f_bavail
operator|=
name|fsfo
operator|->
name|st
operator|.
name|bavail
expr_stmt|;
name|sbp
operator|->
name|f_files
operator|=
name|fsfo
operator|->
name|st
operator|.
name|files
expr_stmt|;
name|sbp
operator|->
name|f_ffree
operator|=
name|fsfo
operator|->
name|st
operator|.
name|ffree
expr_stmt|;
comment|/* cast from uint64_t to int64_t */
name|sbp
operator|->
name|f_namemax
operator|=
name|fsfo
operator|->
name|st
operator|.
name|namelen
expr_stmt|;
name|sbp
operator|->
name|f_bsize
operator|=
name|fsfo
operator|->
name|st
operator|.
name|frsize
expr_stmt|;
comment|/* cast from uint32_t to uint64_t */
name|FS_DEBUG
argument_list|(
literal|"fuse_statfs_out -- blocks: %llu, bfree: %llu, bavail: %llu, "
literal|"fil	es: %llu, ffree: %llu, bsize: %i, namelen: %i\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|fsfo
operator|->
name|st
operator|.
name|blocks
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|fsfo
operator|->
name|st
operator|.
name|bfree
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|fsfo
operator|->
name|st
operator|.
name|bavail
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|fsfo
operator|->
name|st
operator|.
name|files
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|fsfo
operator|->
name|st
operator|.
name|ffree
argument_list|,
name|fsfo
operator|->
name|st
operator|.
name|bsize
argument_list|,
name|fsfo
operator|->
name|st
operator|.
name|namelen
argument_list|)
expr_stmt|;
name|fdisp_destroy
argument_list|(
operator|&
name|fdi
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|fake
label|:
name|sbp
operator|->
name|f_blocks
operator|=
literal|0
expr_stmt|;
name|sbp
operator|->
name|f_bfree
operator|=
literal|0
expr_stmt|;
name|sbp
operator|->
name|f_bavail
operator|=
literal|0
expr_stmt|;
name|sbp
operator|->
name|f_files
operator|=
literal|0
expr_stmt|;
name|sbp
operator|->
name|f_ffree
operator|=
literal|0
expr_stmt|;
name|sbp
operator|->
name|f_namemax
operator|=
literal|0
expr_stmt|;
name|sbp
operator|->
name|f_bsize
operator|=
name|FUSE_DEFAULT_BLOCKSIZE
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

