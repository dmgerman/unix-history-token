begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000-2001 Boris Popov  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *    This product includes software developed by Boris Popov.  * 4. Neither the name of the author nor the names of any co-contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/lockf.h>
end_include

begin_include
include|#
directive|include
file|<machine/limits.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<netsmb/smb.h>
end_include

begin_include
include|#
directive|include
file|<netsmb/smb_conn.h>
end_include

begin_include
include|#
directive|include
file|<netsmb/smb_subr.h>
end_include

begin_include
include|#
directive|include
file|<fs/smbfs/smbfs.h>
end_include

begin_include
include|#
directive|include
file|<fs/smbfs/smbfs_node.h>
end_include

begin_include
include|#
directive|include
file|<fs/smbfs/smbfs_subr.h>
end_include

begin_comment
comment|/*  * Prototypes for SMBFS vnode operations  */
end_comment

begin_function_decl
specifier|static
name|int
name|smbfs_create
parameter_list|(
name|struct
name|vop_create_args
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|smbfs_mknod
parameter_list|(
name|struct
name|vop_mknod_args
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|smbfs_open
parameter_list|(
name|struct
name|vop_open_args
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|smbfs_close
parameter_list|(
name|struct
name|vop_close_args
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|smbfs_access
parameter_list|(
name|struct
name|vop_access_args
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|smbfs_getattr
parameter_list|(
name|struct
name|vop_getattr_args
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|smbfs_setattr
parameter_list|(
name|struct
name|vop_setattr_args
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|smbfs_read
parameter_list|(
name|struct
name|vop_read_args
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|smbfs_write
parameter_list|(
name|struct
name|vop_write_args
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|smbfs_fsync
parameter_list|(
name|struct
name|vop_fsync_args
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|smbfs_remove
parameter_list|(
name|struct
name|vop_remove_args
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|smbfs_link
parameter_list|(
name|struct
name|vop_link_args
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|smbfs_lookup
parameter_list|(
name|struct
name|vop_lookup_args
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|smbfs_rename
parameter_list|(
name|struct
name|vop_rename_args
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|smbfs_mkdir
parameter_list|(
name|struct
name|vop_mkdir_args
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|smbfs_rmdir
parameter_list|(
name|struct
name|vop_rmdir_args
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|smbfs_symlink
parameter_list|(
name|struct
name|vop_symlink_args
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|smbfs_readdir
parameter_list|(
name|struct
name|vop_readdir_args
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|smbfs_strategy
parameter_list|(
name|struct
name|vop_strategy_args
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|smbfs_print
parameter_list|(
name|struct
name|vop_print_args
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|smbfs_pathconf
parameter_list|(
name|struct
name|vop_pathconf_args
modifier|*
name|ap
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|smbfs_advlock
parameter_list|(
name|struct
name|vop_advlock_args
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|FB_RELENG3
end_ifndef

begin_function_decl
specifier|static
name|int
name|smbfs_getextattr
parameter_list|(
name|struct
name|vop_getextattr_args
modifier|*
name|ap
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|vop_t
modifier|*
modifier|*
name|smbfs_vnodeop_p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|vnodeopv_entry_desc
name|smbfs_vnodeop_entries
index|[]
init|=
block|{
block|{
operator|&
name|vop_default_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|vop_defaultop
block|}
block|,
block|{
operator|&
name|vop_access_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|smbfs_access
block|}
block|,
block|{
operator|&
name|vop_advlock_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|smbfs_advlock
block|}
block|,
block|{
operator|&
name|vop_close_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|smbfs_close
block|}
block|,
block|{
operator|&
name|vop_create_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|smbfs_create
block|}
block|,
block|{
operator|&
name|vop_fsync_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|smbfs_fsync
block|}
block|,
block|{
operator|&
name|vop_getattr_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|smbfs_getattr
block|}
block|,
block|{
operator|&
name|vop_getpages_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|smbfs_getpages
block|}
block|,
block|{
operator|&
name|vop_inactive_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|smbfs_inactive
block|}
block|,
block|{
operator|&
name|vop_ioctl_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|smbfs_ioctl
block|}
block|,
block|{
operator|&
name|vop_islocked_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|vop_stdislocked
block|}
block|,
block|{
operator|&
name|vop_link_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|smbfs_link
block|}
block|,
block|{
operator|&
name|vop_lock_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|vop_stdlock
block|}
block|,
block|{
operator|&
name|vop_lookup_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|smbfs_lookup
block|}
block|,
block|{
operator|&
name|vop_mkdir_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|smbfs_mkdir
block|}
block|,
block|{
operator|&
name|vop_mknod_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|smbfs_mknod
block|}
block|,
block|{
operator|&
name|vop_open_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|smbfs_open
block|}
block|,
block|{
operator|&
name|vop_pathconf_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|smbfs_pathconf
block|}
block|,
block|{
operator|&
name|vop_print_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|smbfs_print
block|}
block|,
block|{
operator|&
name|vop_putpages_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|smbfs_putpages
block|}
block|,
block|{
operator|&
name|vop_read_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|smbfs_read
block|}
block|,
block|{
operator|&
name|vop_readdir_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|smbfs_readdir
block|}
block|,
block|{
operator|&
name|vop_reclaim_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|smbfs_reclaim
block|}
block|,
block|{
operator|&
name|vop_remove_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|smbfs_remove
block|}
block|,
block|{
operator|&
name|vop_rename_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|smbfs_rename
block|}
block|,
block|{
operator|&
name|vop_rmdir_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|smbfs_rmdir
block|}
block|,
block|{
operator|&
name|vop_setattr_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|smbfs_setattr
block|}
block|,
block|{
operator|&
name|vop_strategy_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|smbfs_strategy
block|}
block|,
block|{
operator|&
name|vop_symlink_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|smbfs_symlink
block|}
block|,
block|{
operator|&
name|vop_unlock_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|vop_stdunlock
block|}
block|,
block|{
operator|&
name|vop_write_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|smbfs_write
block|}
block|,
ifndef|#
directive|ifndef
name|FB_RELENG3
block|{
operator|&
name|vop_getextattr_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|smbfs_getextattr
block|}
block|,
comment|/*	{&vop_setextattr_desc,		(vop_t *) smbfs_setextattr },*/
endif|#
directive|endif
block|{
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|vnodeopv_desc
name|smbfs_vnodeop_opv_desc
init|=
block|{
operator|&
name|smbfs_vnodeop_p
block|,
name|smbfs_vnodeop_entries
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|VNODEOP_SET
argument_list|(
name|smbfs_vnodeop_opv_desc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|smbfs_access
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_access_args
comment|/* { 		struct vnode *a_vp; 		int  a_mode; 		struct ucred *a_cred; 		struct thread *a_td; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|ap
operator|->
name|a_cred
decl_stmt|;
name|u_int
name|mode
init|=
name|ap
operator|->
name|a_mode
decl_stmt|;
name|struct
name|smbmount
modifier|*
name|smp
init|=
name|VTOSMBFS
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|SMBVDEBUG
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mode
operator|&
name|VWRITE
operator|)
operator|&&
operator|(
name|vp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
operator|)
condition|)
block|{
switch|switch
condition|(
name|vp
operator|->
name|v_type
condition|)
block|{
case|case
name|VREG
case|:
case|case
name|VDIR
case|:
case|case
name|VLNK
case|:
return|return
name|EROFS
return|;
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|cred
operator|->
name|cr_uid
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|cred
operator|->
name|cr_uid
operator|!=
name|smp
operator|->
name|sm_args
operator|.
name|uid
condition|)
block|{
name|mode
operator|>>=
literal|3
expr_stmt|;
if|if
condition|(
operator|!
name|groupmember
argument_list|(
name|smp
operator|->
name|sm_args
operator|.
name|gid
argument_list|,
name|cred
argument_list|)
condition|)
name|mode
operator|>>=
literal|3
expr_stmt|;
block|}
name|error
operator|=
operator|(
operator|(
operator|(
name|vp
operator|->
name|v_type
operator|==
name|VREG
operator|)
condition|?
name|smp
operator|->
name|sm_args
operator|.
name|file_mode
else|:
name|smp
operator|->
name|sm_args
operator|.
name|dir_mode
operator|)
operator|&
name|mode
operator|)
operator|==
name|mode
condition|?
literal|0
else|:
name|EACCES
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|smbfs_open
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_open_args
comment|/* { 		struct vnode *a_vp; 		int  a_mode; 		struct ucred *a_cred; 		struct thread *a_td; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|smbnode
modifier|*
name|np
init|=
name|VTOSMB
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|smb_cred
name|scred
decl_stmt|;
name|struct
name|vattr
name|vattr
decl_stmt|;
name|int
name|mode
init|=
name|ap
operator|->
name|a_mode
decl_stmt|;
name|int
name|error
decl_stmt|,
name|accmode
decl_stmt|;
name|SMBVDEBUG
argument_list|(
literal|"%s,%d\n"
argument_list|,
name|np
operator|->
name|n_name
argument_list|,
name|np
operator|->
name|n_opencount
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|VREG
operator|&&
name|vp
operator|->
name|v_type
operator|!=
name|VDIR
condition|)
block|{
name|SMBFSERR
argument_list|(
literal|"open eacces vtype=%d\n"
argument_list|,
name|vp
operator|->
name|v_type
argument_list|)
expr_stmt|;
return|return
name|EACCES
return|;
block|}
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VDIR
condition|)
block|{
name|np
operator|->
name|n_opencount
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|np
operator|->
name|n_flag
operator|&
name|NMODIFIED
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|smbfs_vinvalbuf
argument_list|(
name|vp
argument_list|,
name|V_SAVE
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_td
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|EINTR
condition|)
return|return
name|error
return|;
name|smbfs_attr_cacheremove
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|vp
argument_list|,
operator|&
name|vattr
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|np
operator|->
name|n_mtime
operator|.
name|tv_sec
operator|=
name|vattr
operator|.
name|va_mtime
operator|.
name|tv_sec
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|vp
argument_list|,
operator|&
name|vattr
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
name|np
operator|->
name|n_mtime
operator|.
name|tv_sec
operator|!=
name|vattr
operator|.
name|va_mtime
operator|.
name|tv_sec
condition|)
block|{
name|error
operator|=
name|smbfs_vinvalbuf
argument_list|(
name|vp
argument_list|,
name|V_SAVE
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_td
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EINTR
condition|)
return|return
name|error
return|;
name|np
operator|->
name|n_mtime
operator|.
name|tv_sec
operator|=
name|vattr
operator|.
name|va_mtime
operator|.
name|tv_sec
expr_stmt|;
block|}
block|}
if|if
condition|(
name|np
operator|->
name|n_opencount
condition|)
block|{
name|np
operator|->
name|n_opencount
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
name|accmode
operator|=
name|SMB_AM_OPENREAD
expr_stmt|;
if|if
condition|(
operator|(
name|vp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
operator|)
operator|==
literal|0
condition|)
name|accmode
operator|=
name|SMB_AM_OPENRW
expr_stmt|;
name|smb_makescred
argument_list|(
operator|&
name|scred
argument_list|,
name|ap
operator|->
name|a_td
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|)
expr_stmt|;
name|error
operator|=
name|smbfs_smb_open
argument_list|(
name|np
argument_list|,
name|accmode
argument_list|,
operator|&
name|scred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|mode
operator|&
name|FWRITE
condition|)
return|return
name|EACCES
return|;
name|accmode
operator|=
name|SMB_AM_OPENREAD
expr_stmt|;
name|error
operator|=
name|smbfs_smb_open
argument_list|(
name|np
argument_list|,
name|accmode
argument_list|,
operator|&
name|scred
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|np
operator|->
name|n_opencount
operator|++
expr_stmt|;
block|}
name|smbfs_attr_cacheremove
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|smbfs_closel
parameter_list|(
name|struct
name|vop_close_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|smbnode
modifier|*
name|np
init|=
name|VTOSMB
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|ap
operator|->
name|a_td
decl_stmt|;
name|struct
name|smb_cred
name|scred
decl_stmt|;
name|struct
name|vattr
name|vattr
decl_stmt|;
name|int
name|error
decl_stmt|;
name|SMBVDEBUG
argument_list|(
literal|"name=%s, pid=%d, c=%d\n"
argument_list|,
name|np
operator|->
name|n_name
argument_list|,
name|td
operator|->
name|td_pid
argument_list|,
name|np
operator|->
name|n_opencount
argument_list|)
expr_stmt|;
name|smb_makescred
argument_list|(
operator|&
name|scred
argument_list|,
name|td
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|n_opencount
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|VDIR
condition|)
name|SMBERROR
argument_list|(
literal|"Negative opencount\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|np
operator|->
name|n_opencount
operator|--
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VDIR
condition|)
block|{
if|if
condition|(
name|np
operator|->
name|n_opencount
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|np
operator|->
name|n_dirseq
condition|)
block|{
name|smbfs_findclose
argument_list|(
name|np
operator|->
name|n_dirseq
argument_list|,
operator|&
name|scred
argument_list|)
expr_stmt|;
name|np
operator|->
name|n_dirseq
operator|=
name|NULL
expr_stmt|;
block|}
name|error
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|smbfs_vinvalbuf
argument_list|(
name|vp
argument_list|,
name|V_SAVE
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|td
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|n_opencount
condition|)
return|return
name|error
return|;
name|VOP_GETATTR
argument_list|(
name|vp
argument_list|,
operator|&
name|vattr
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|error
operator|=
name|smbfs_smb_close
argument_list|(
name|np
operator|->
name|n_mount
operator|->
name|sm_share
argument_list|,
name|np
operator|->
name|n_fid
argument_list|,
operator|&
name|np
operator|->
name|n_mtime
argument_list|,
operator|&
name|scred
argument_list|)
expr_stmt|;
block|}
name|smbfs_attr_cacheremove
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * XXX: VOP_CLOSE() usually called without lock held which is suck. Here we  * do some heruistic to determine if vnode should be locked.  */
end_comment

begin_function
specifier|static
name|int
name|smbfs_close
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_close_args
comment|/* { 		struct vnodeop_desc *a_desc; 		struct vnode *a_vp; 		int  a_fflag; 		struct ucred *a_cred; 		struct thread *a_td; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|ap
operator|->
name|a_td
decl_stmt|;
name|int
name|error
decl_stmt|,
name|dolock
decl_stmt|;
name|VI_LOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|dolock
operator|=
operator|(
name|vp
operator|->
name|v_flag
operator|&
name|VXLOCK
operator|)
operator|==
literal|0
expr_stmt|;
if|if
condition|(
name|dolock
condition|)
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
operator||
name|LK_INTERLOCK
argument_list|,
name|td
argument_list|)
expr_stmt|;
else|else
name|VI_UNLOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|error
operator|=
name|smbfs_closel
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|dolock
condition|)
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * smbfs_getattr call from vfs.  */
end_comment

begin_function
specifier|static
name|int
name|smbfs_getattr
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_getattr_args
comment|/* { 		struct vnode *a_vp; 		struct vattr *a_vap; 		struct ucred *a_cred; 		struct thread *a_td; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|smbnode
modifier|*
name|np
init|=
name|VTOSMB
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|vattr
modifier|*
name|va
init|=
name|ap
operator|->
name|a_vap
decl_stmt|;
name|struct
name|smbfattr
name|fattr
decl_stmt|;
name|struct
name|smb_cred
name|scred
decl_stmt|;
name|u_int32_t
name|oldsize
decl_stmt|;
name|int
name|error
decl_stmt|;
name|SMBVDEBUG
argument_list|(
literal|"%lx: '%s' %d\n"
argument_list|,
operator|(
name|long
operator|)
name|vp
argument_list|,
name|np
operator|->
name|n_name
argument_list|,
operator|(
name|vp
operator|->
name|v_flag
operator|&
name|VROOT
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|smbfs_attr_cachelookup
argument_list|(
name|vp
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
return|return
literal|0
return|;
name|SMBVDEBUG
argument_list|(
literal|"not in the cache\n"
argument_list|)
expr_stmt|;
name|smb_makescred
argument_list|(
operator|&
name|scred
argument_list|,
name|ap
operator|->
name|a_td
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|)
expr_stmt|;
name|oldsize
operator|=
name|np
operator|->
name|n_size
expr_stmt|;
name|error
operator|=
name|smbfs_smb_lookup
argument_list|(
name|np
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|fattr
argument_list|,
operator|&
name|scred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|SMBVDEBUG
argument_list|(
literal|"error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|smbfs_attr_cacheenter
argument_list|(
name|vp
argument_list|,
operator|&
name|fattr
argument_list|)
expr_stmt|;
name|smbfs_attr_cachelookup
argument_list|(
name|vp
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|n_opencount
condition|)
name|np
operator|->
name|n_size
operator|=
name|oldsize
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|smbfs_setattr
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_setattr_args
comment|/* { 		struct vnode *a_vp; 		struct vattr *a_vap; 		struct ucred *a_cred; 		struct thread *a_td; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|smbnode
modifier|*
name|np
init|=
name|VTOSMB
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|vattr
modifier|*
name|vap
init|=
name|ap
operator|->
name|a_vap
decl_stmt|;
name|struct
name|timespec
modifier|*
name|mtime
decl_stmt|,
modifier|*
name|atime
decl_stmt|;
name|struct
name|smb_cred
name|scred
decl_stmt|;
name|struct
name|smb_share
modifier|*
name|ssp
init|=
name|np
operator|->
name|n_mount
operator|->
name|sm_share
decl_stmt|;
name|struct
name|smb_vc
modifier|*
name|vcp
init|=
name|SSTOVC
argument_list|(
name|ssp
argument_list|)
decl_stmt|;
name|u_quad_t
name|tsize
init|=
literal|0
decl_stmt|;
name|int
name|isreadonly
decl_stmt|,
name|doclose
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|SMBVDEBUG
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|va_flags
operator|!=
name|VNOVAL
condition|)
return|return
name|EOPNOTSUPP
return|;
name|isreadonly
operator|=
operator|(
name|vp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
operator|)
expr_stmt|;
comment|/* 	 * Disallow write attempts if the filesystem is mounted read-only. 	 */
if|if
condition|(
operator|(
name|vap
operator|->
name|va_uid
operator|!=
operator|(
name|uid_t
operator|)
name|VNOVAL
operator|||
name|vap
operator|->
name|va_gid
operator|!=
operator|(
name|gid_t
operator|)
name|VNOVAL
operator|||
name|vap
operator|->
name|va_atime
operator|.
name|tv_sec
operator|!=
name|VNOVAL
operator|||
name|vap
operator|->
name|va_mtime
operator|.
name|tv_sec
operator|!=
name|VNOVAL
operator|||
name|vap
operator|->
name|va_mode
operator|!=
operator|(
name|mode_t
operator|)
name|VNOVAL
operator|)
operator|&&
name|isreadonly
condition|)
return|return
name|EROFS
return|;
name|smb_makescred
argument_list|(
operator|&
name|scred
argument_list|,
name|ap
operator|->
name|a_td
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|va_size
operator|!=
name|VNOVAL
condition|)
block|{
switch|switch
condition|(
name|vp
operator|->
name|v_type
condition|)
block|{
case|case
name|VDIR
case|:
return|return
name|EISDIR
return|;
case|case
name|VREG
case|:
break|break;
default|default:
return|return
name|EINVAL
return|;
block|}
empty_stmt|;
if|if
condition|(
name|isreadonly
condition|)
return|return
name|EROFS
return|;
name|doclose
operator|=
literal|0
expr_stmt|;
name|vnode_pager_setsize
argument_list|(
name|vp
argument_list|,
operator|(
name|u_long
operator|)
name|vap
operator|->
name|va_size
argument_list|)
expr_stmt|;
name|tsize
operator|=
name|np
operator|->
name|n_size
expr_stmt|;
name|np
operator|->
name|n_size
operator|=
name|vap
operator|->
name|va_size
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|n_opencount
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|smbfs_smb_open
argument_list|(
name|np
argument_list|,
name|SMB_AM_OPENRW
argument_list|,
operator|&
name|scred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|doclose
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|smbfs_smb_setfsize
argument_list|(
name|np
argument_list|,
name|vap
operator|->
name|va_size
argument_list|,
operator|&
name|scred
argument_list|)
expr_stmt|;
if|if
condition|(
name|doclose
condition|)
name|smbfs_smb_close
argument_list|(
name|ssp
argument_list|,
name|np
operator|->
name|n_fid
argument_list|,
name|NULL
argument_list|,
operator|&
name|scred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|np
operator|->
name|n_size
operator|=
name|tsize
expr_stmt|;
name|vnode_pager_setsize
argument_list|(
name|vp
argument_list|,
operator|(
name|u_long
operator|)
name|tsize
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
block|}
name|mtime
operator|=
name|atime
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|va_mtime
operator|.
name|tv_sec
operator|!=
name|VNOVAL
condition|)
name|mtime
operator|=
operator|&
name|vap
operator|->
name|va_mtime
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|va_atime
operator|.
name|tv_sec
operator|!=
name|VNOVAL
condition|)
name|atime
operator|=
operator|&
name|vap
operator|->
name|va_atime
expr_stmt|;
if|if
condition|(
name|mtime
operator|!=
name|atime
condition|)
block|{
if|#
directive|if
literal|0
block|if (mtime == NULL) 			mtime =&np->n_mtime; 		if (atime == NULL) 			atime =&np->n_atime;
endif|#
directive|endif
comment|/* 		 * If file is opened, then we can use handle based calls. 		 * If not, use path based ones. 		 */
if|if
condition|(
name|np
operator|->
name|n_opencount
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|vcp
operator|->
name|vc_flags
operator|&
name|SMBV_WIN95
condition|)
block|{
name|error
operator|=
name|VOP_OPEN
argument_list|(
name|vp
argument_list|,
name|FWRITE
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_td
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
comment|/*				error = smbfs_smb_setfattrNT(np, 0, mtime, atime,&scred); 				VOP_GETATTR(vp,&vattr, ap->a_cred, ap->a_td);*/
if|if
condition|(
name|mtime
condition|)
name|np
operator|->
name|n_mtime
operator|=
operator|*
name|mtime
expr_stmt|;
name|VOP_CLOSE
argument_list|(
name|vp
argument_list|,
name|FWRITE
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_td
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|vcp
operator|->
name|vc_sopt
operator|.
name|sv_caps
operator|&
name|SMB_CAP_NT_SMBS
operator|)
condition|)
block|{
name|error
operator|=
name|smbfs_smb_setptime2
argument_list|(
name|np
argument_list|,
name|mtime
argument_list|,
name|atime
argument_list|,
literal|0
argument_list|,
operator|&
name|scred
argument_list|)
expr_stmt|;
comment|/*				error = smbfs_smb_setpattrNT(np, 0, mtime, atime,&scred);*/
block|}
elseif|else
if|if
condition|(
name|SMB_DIALECT
argument_list|(
name|vcp
argument_list|)
operator|>=
name|SMB_DIALECT_LANMAN2_0
condition|)
block|{
name|error
operator|=
name|smbfs_smb_setptime2
argument_list|(
name|np
argument_list|,
name|mtime
argument_list|,
name|atime
argument_list|,
literal|0
argument_list|,
operator|&
name|scred
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|smbfs_smb_setpattr
argument_list|(
name|np
argument_list|,
literal|0
argument_list|,
name|mtime
argument_list|,
operator|&
name|scred
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|vcp
operator|->
name|vc_sopt
operator|.
name|sv_caps
operator|&
name|SMB_CAP_NT_SMBS
condition|)
block|{
name|error
operator|=
name|smbfs_smb_setfattrNT
argument_list|(
name|np
argument_list|,
literal|0
argument_list|,
name|mtime
argument_list|,
name|atime
argument_list|,
operator|&
name|scred
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SMB_DIALECT
argument_list|(
name|vcp
argument_list|)
operator|>=
name|SMB_DIALECT_LANMAN1_0
condition|)
block|{
name|error
operator|=
name|smbfs_smb_setftime
argument_list|(
name|np
argument_list|,
name|mtime
argument_list|,
name|atime
argument_list|,
operator|&
name|scred
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * I have no idea how to handle this for core 				 * level servers. The possible solution is to 				 * update mtime after file is closed. 				 */
name|SMBERROR
argument_list|(
literal|"can't update times on an opened file\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Invalidate attribute cache in case if server doesn't set 	 * required attributes. 	 */
name|smbfs_attr_cacheremove
argument_list|(
name|vp
argument_list|)
expr_stmt|;
comment|/* invalidate cache */
name|VOP_GETATTR
argument_list|(
name|vp
argument_list|,
name|vap
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_td
argument_list|)
expr_stmt|;
name|np
operator|->
name|n_mtime
operator|.
name|tv_sec
operator|=
name|vap
operator|->
name|va_mtime
operator|.
name|tv_sec
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * smbfs_read call.  */
end_comment

begin_function
specifier|static
name|int
name|smbfs_read
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_read_args
comment|/* { 		struct vnode *a_vp; 		struct uio *a_uio; 		int  a_ioflag; 		struct ucred *a_cred; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
init|=
name|ap
operator|->
name|a_uio
decl_stmt|;
name|SMBVDEBUG
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|VREG
operator|&&
name|vp
operator|->
name|v_type
operator|!=
name|VDIR
condition|)
return|return
name|EPERM
return|;
return|return
name|smbfs_readvnode
argument_list|(
name|vp
argument_list|,
name|uio
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|smbfs_write
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_write_args
comment|/* { 		struct vnode *a_vp; 		struct uio *a_uio; 		int  a_ioflag; 		struct ucred *a_cred; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
init|=
name|ap
operator|->
name|a_uio
decl_stmt|;
name|SMBVDEBUG
argument_list|(
literal|"%d,ofs=%d,sz=%d\n"
argument_list|,
name|vp
operator|->
name|v_type
argument_list|,
operator|(
name|int
operator|)
name|uio
operator|->
name|uio_offset
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|VREG
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
return|return
name|smbfs_writevnode
argument_list|(
name|vp
argument_list|,
name|uio
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_ioflag
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * smbfs_create call  * Create a regular file. On entry the directory to contain the file being  * created is locked.  We must release before we return. We must also free  * the pathname buffer pointed at by cnp->cn_pnbuf, always on error, or  * only if the SAVESTART bit in cn_flags is clear on success.  */
end_comment

begin_function
specifier|static
name|int
name|smbfs_create
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_create_args
comment|/* { 		struct vnode *a_dvp; 		struct vnode **a_vpp; 		struct componentname *a_cnp; 		struct vattr *a_vap; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|vnode
modifier|*
name|dvp
init|=
name|ap
operator|->
name|a_dvp
decl_stmt|;
name|struct
name|vattr
modifier|*
name|vap
init|=
name|ap
operator|->
name|a_vap
decl_stmt|;
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
init|=
name|ap
operator|->
name|a_vpp
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
name|struct
name|smbnode
modifier|*
name|dnp
init|=
name|VTOSMB
argument_list|(
name|dvp
argument_list|)
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|vattr
name|vattr
decl_stmt|;
name|struct
name|smbfattr
name|fattr
decl_stmt|;
name|struct
name|smb_cred
name|scred
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|cnp
operator|->
name|cn_nameptr
decl_stmt|;
name|int
name|nmlen
init|=
name|cnp
operator|->
name|cn_namelen
decl_stmt|;
name|int
name|error
decl_stmt|;
name|SMBVDEBUG
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|va_type
operator|!=
name|VREG
condition|)
return|return
name|EOPNOTSUPP
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|dvp
argument_list|,
operator|&
name|vattr
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|,
name|cnp
operator|->
name|cn_thread
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
name|smb_makescred
argument_list|(
operator|&
name|scred
argument_list|,
name|cnp
operator|->
name|cn_thread
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|)
expr_stmt|;
name|error
operator|=
name|smbfs_smb_create
argument_list|(
name|dnp
argument_list|,
name|name
argument_list|,
name|nmlen
argument_list|,
operator|&
name|scred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|error
operator|=
name|smbfs_smb_lookup
argument_list|(
name|dnp
argument_list|,
name|name
argument_list|,
name|nmlen
argument_list|,
operator|&
name|fattr
argument_list|,
operator|&
name|scred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|error
operator|=
name|smbfs_nget
argument_list|(
name|VTOVFS
argument_list|(
name|dvp
argument_list|)
argument_list|,
name|dvp
argument_list|,
name|name
argument_list|,
name|nmlen
argument_list|,
operator|&
name|fattr
argument_list|,
operator|&
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
operator|*
name|vpp
operator|=
name|vp
expr_stmt|;
if|if
condition|(
name|cnp
operator|->
name|cn_flags
operator|&
name|MAKEENTRY
condition|)
name|cache_enter
argument_list|(
name|dvp
argument_list|,
name|vp
argument_list|,
name|cnp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|smbfs_remove
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_remove_args
comment|/* { 		struct vnodeop_desc *a_desc; 		struct vnode * a_dvp; 		struct vnode * a_vp; 		struct componentname * a_cnp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
comment|/*	struct vnode *dvp = ap->a_dvp;*/
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
name|struct
name|smbnode
modifier|*
name|np
init|=
name|VTOSMB
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|smb_cred
name|scred
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VDIR
operator|||
name|np
operator|->
name|n_opencount
operator|||
name|vp
operator|->
name|v_usecount
operator|!=
literal|1
condition|)
return|return
name|EPERM
return|;
name|smb_makescred
argument_list|(
operator|&
name|scred
argument_list|,
name|cnp
operator|->
name|cn_thread
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|)
expr_stmt|;
name|error
operator|=
name|smbfs_smb_delete
argument_list|(
name|np
argument_list|,
operator|&
name|scred
argument_list|)
expr_stmt|;
name|cache_purge
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * smbfs_file rename call  */
end_comment

begin_function
specifier|static
name|int
name|smbfs_rename
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_rename_args
comment|/* { 		struct vnode *a_fdvp; 		struct vnode *a_fvp; 		struct componentname *a_fcnp; 		struct vnode *a_tdvp; 		struct vnode *a_tvp; 		struct componentname *a_tcnp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|vnode
modifier|*
name|fvp
init|=
name|ap
operator|->
name|a_fvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|tvp
init|=
name|ap
operator|->
name|a_tvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|fdvp
init|=
name|ap
operator|->
name|a_fdvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|tdvp
init|=
name|ap
operator|->
name|a_tdvp
decl_stmt|;
name|struct
name|componentname
modifier|*
name|tcnp
init|=
name|ap
operator|->
name|a_tcnp
decl_stmt|;
comment|/*	struct componentname *fcnp = ap->a_fcnp;*/
name|struct
name|smb_cred
name|scred
decl_stmt|;
name|u_int16_t
name|flags
init|=
literal|6
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* Check for cross-device rename */
if|if
condition|(
operator|(
name|fvp
operator|->
name|v_mount
operator|!=
name|tdvp
operator|->
name|v_mount
operator|)
operator|||
operator|(
name|tvp
operator|&&
operator|(
name|fvp
operator|->
name|v_mount
operator|!=
name|tvp
operator|->
name|v_mount
operator|)
operator|)
condition|)
block|{
name|error
operator|=
name|EXDEV
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|tvp
operator|&&
name|tvp
operator|->
name|v_usecount
operator|>
literal|1
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|flags
operator|=
literal|0x10
expr_stmt|;
comment|/* verify all writes */
if|if
condition|(
name|fvp
operator|->
name|v_type
operator|==
name|VDIR
condition|)
block|{
name|flags
operator||=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fvp
operator|->
name|v_type
operator|==
name|VREG
condition|)
block|{
name|flags
operator||=
literal|1
expr_stmt|;
block|}
else|else
return|return
name|EINVAL
return|;
name|smb_makescred
argument_list|(
operator|&
name|scred
argument_list|,
name|tcnp
operator|->
name|cn_thread
argument_list|,
name|tcnp
operator|->
name|cn_cred
argument_list|)
expr_stmt|;
comment|/* 	 * It seems that Samba doesn't implement SMB_COM_MOVE call... 	 */
ifdef|#
directive|ifdef
name|notnow
if|if
condition|(
name|SMB_DIALECT
argument_list|(
name|SSTOCN
argument_list|(
name|smp
operator|->
name|sm_share
argument_list|)
argument_list|)
operator|>=
name|SMB_DIALECT_LANMAN1_0
condition|)
block|{
name|error
operator|=
name|smbfs_smb_move
argument_list|(
name|VTOSMB
argument_list|(
name|fvp
argument_list|)
argument_list|,
name|VTOSMB
argument_list|(
name|tdvp
argument_list|)
argument_list|,
name|tcnp
operator|->
name|cn_nameptr
argument_list|,
name|tcnp
operator|->
name|cn_namelen
argument_list|,
name|flags
argument_list|,
operator|&
name|scred
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
comment|/* 		 * We have to do the work atomicaly 		 */
if|if
condition|(
name|tvp
operator|&&
name|tvp
operator|!=
name|fvp
condition|)
block|{
name|error
operator|=
name|smbfs_smb_delete
argument_list|(
name|VTOSMB
argument_list|(
name|tvp
argument_list|)
argument_list|,
operator|&
name|scred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
block|}
name|error
operator|=
name|smbfs_smb_rename
argument_list|(
name|VTOSMB
argument_list|(
name|fvp
argument_list|)
argument_list|,
name|VTOSMB
argument_list|(
name|tdvp
argument_list|)
argument_list|,
name|tcnp
operator|->
name|cn_nameptr
argument_list|,
name|tcnp
operator|->
name|cn_namelen
argument_list|,
operator|&
name|scred
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fvp
operator|->
name|v_type
operator|==
name|VDIR
condition|)
block|{
if|if
condition|(
name|tvp
operator|!=
name|NULL
operator|&&
name|tvp
operator|->
name|v_type
operator|==
name|VDIR
condition|)
name|cache_purge
argument_list|(
name|tdvp
argument_list|)
expr_stmt|;
name|cache_purge
argument_list|(
name|fdvp
argument_list|)
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|tdvp
operator|==
name|tvp
condition|)
name|vrele
argument_list|(
name|tdvp
argument_list|)
expr_stmt|;
else|else
name|vput
argument_list|(
name|tdvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tvp
condition|)
name|vput
argument_list|(
name|tvp
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|fdvp
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|fvp
argument_list|)
expr_stmt|;
name|smbfs_attr_cacheremove
argument_list|(
name|fdvp
argument_list|)
expr_stmt|;
name|smbfs_attr_cacheremove
argument_list|(
name|tdvp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|possible_mistake
name|vgone
argument_list|(
name|fvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tvp
condition|)
name|vgone
argument_list|(
name|tvp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * somtime it will come true...  */
end_comment

begin_function
specifier|static
name|int
name|smbfs_link
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_link_args
comment|/* { 		struct vnode *a_tdvp; 		struct vnode *a_vp; 		struct componentname *a_cnp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
return|return
name|EOPNOTSUPP
return|;
block|}
end_function

begin_comment
comment|/*  * smbfs_symlink link create call.  * Sometime it will be functional...  */
end_comment

begin_function
specifier|static
name|int
name|smbfs_symlink
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_symlink_args
comment|/* { 		struct vnode *a_dvp; 		struct vnode **a_vpp; 		struct componentname *a_cnp; 		struct vattr *a_vap; 		char *a_target; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
return|return
name|EOPNOTSUPP
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|smbfs_mknod
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_mknod_args
comment|/* { 	} */
modifier|*
name|ap
decl_stmt|;
block|{
return|return
name|EOPNOTSUPP
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|smbfs_mkdir
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_mkdir_args
comment|/* { 		struct vnode *a_dvp; 		struct vnode **a_vpp; 		struct componentname *a_cnp; 		struct vattr *a_vap; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|vnode
modifier|*
name|dvp
init|=
name|ap
operator|->
name|a_dvp
decl_stmt|;
comment|/*	struct vattr *vap = ap->a_vap;*/
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
name|struct
name|smbnode
modifier|*
name|dnp
init|=
name|VTOSMB
argument_list|(
name|dvp
argument_list|)
decl_stmt|;
name|struct
name|vattr
name|vattr
decl_stmt|;
name|struct
name|smb_cred
name|scred
decl_stmt|;
name|struct
name|smbfattr
name|fattr
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|cnp
operator|->
name|cn_nameptr
decl_stmt|;
name|int
name|len
init|=
name|cnp
operator|->
name|cn_namelen
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|dvp
argument_list|,
operator|&
name|vattr
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|,
name|cnp
operator|->
name|cn_thread
argument_list|)
operator|)
condition|)
block|{
return|return
name|error
return|;
block|}
if|if
condition|(
operator|(
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|)
operator|&&
operator|(
operator|(
name|len
operator|==
literal|1
operator|)
operator|||
operator|(
operator|(
name|len
operator|==
literal|2
operator|)
operator|&&
operator|(
name|name
index|[
literal|1
index|]
operator|==
literal|'.'
operator|)
operator|)
operator|)
condition|)
return|return
name|EEXIST
return|;
name|smb_makescred
argument_list|(
operator|&
name|scred
argument_list|,
name|cnp
operator|->
name|cn_thread
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|)
expr_stmt|;
name|error
operator|=
name|smbfs_smb_mkdir
argument_list|(
name|dnp
argument_list|,
name|name
argument_list|,
name|len
argument_list|,
operator|&
name|scred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|error
operator|=
name|smbfs_smb_lookup
argument_list|(
name|dnp
argument_list|,
name|name
argument_list|,
name|len
argument_list|,
operator|&
name|fattr
argument_list|,
operator|&
name|scred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|error
operator|=
name|smbfs_nget
argument_list|(
name|VTOVFS
argument_list|(
name|dvp
argument_list|)
argument_list|,
name|dvp
argument_list|,
name|name
argument_list|,
name|len
argument_list|,
operator|&
name|fattr
argument_list|,
operator|&
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
operator|*
name|ap
operator|->
name|a_vpp
operator|=
name|vp
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * smbfs_remove directory call  */
end_comment

begin_function
specifier|static
name|int
name|smbfs_rmdir
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_rmdir_args
comment|/* { 		struct vnode *a_dvp; 		struct vnode *a_vp; 		struct componentname *a_cnp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|dvp
init|=
name|ap
operator|->
name|a_dvp
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
comment|/*	struct smbmount *smp = VTOSMBFS(vp);*/
name|struct
name|smbnode
modifier|*
name|dnp
init|=
name|VTOSMB
argument_list|(
name|dvp
argument_list|)
decl_stmt|;
name|struct
name|smbnode
modifier|*
name|np
init|=
name|VTOSMB
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|smb_cred
name|scred
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|dvp
operator|==
name|vp
condition|)
return|return
name|EINVAL
return|;
name|smb_makescred
argument_list|(
operator|&
name|scred
argument_list|,
name|cnp
operator|->
name|cn_thread
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|)
expr_stmt|;
name|error
operator|=
name|smbfs_smb_rmdir
argument_list|(
name|np
argument_list|,
operator|&
name|scred
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|n_flag
operator||=
name|NMODIFIED
expr_stmt|;
name|smbfs_attr_cacheremove
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
comment|/*	cache_purge(dvp);*/
name|cache_purge
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * smbfs_readdir call  */
end_comment

begin_function
specifier|static
name|int
name|smbfs_readdir
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_readdir_args
comment|/* { 		struct vnode *a_vp; 		struct uio *a_uio; 		struct ucred *a_cred; 		int *a_eofflag; 		u_long *a_cookies; 		int a_ncookies; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
init|=
name|ap
operator|->
name|a_uio
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|VDIR
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
ifdef|#
directive|ifdef
name|notnow
if|if
condition|(
name|ap
operator|->
name|a_ncookies
condition|)
block|{
name|printf
argument_list|(
literal|"smbfs_readdir: no support for cookies now..."
argument_list|)
expr_stmt|;
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
endif|#
directive|endif
name|error
operator|=
name|smbfs_readvnode
argument_list|(
name|vp
argument_list|,
name|uio
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|smbfs_fsync
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_fsync_args
comment|/* { 		struct vnodeop_desc *a_desc; 		struct vnode * a_vp; 		struct ucred * a_cred; 		int  a_waitfor; 		struct thread * a_td; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
comment|/*	return (smb_flush(ap->a_vp, ap->a_cred, ap->a_waitfor, ap->a_td, 1));*/
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|smbfs_print
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_print_args
comment|/* { 	struct vnode *a_vp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|smbnode
modifier|*
name|np
init|=
name|VTOSMB
argument_list|(
name|vp
argument_list|)
decl_stmt|;
if|if
condition|(
name|np
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"no smbnode data\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|printf
argument_list|(
literal|"tag VT_SMBFS, name = %s, parent = %p, opencount = %d"
argument_list|,
name|np
operator|->
name|n_name
argument_list|,
name|np
operator|->
name|n_parent
condition|?
name|SMBTOV
argument_list|(
name|np
operator|->
name|n_parent
argument_list|)
else|:
name|NULL
argument_list|,
name|np
operator|->
name|n_opencount
argument_list|)
expr_stmt|;
name|lockmgr_printinfo
argument_list|(
operator|&
name|vp
operator|->
name|v_lock
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|smbfs_pathconf
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_pathconf_args
comment|/* { 	struct vnode *vp; 	int name; 	register_t *retval; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|smbmount
modifier|*
name|smp
init|=
name|VFSTOSMBFS
argument_list|(
name|VTOVFS
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|smb_vc
modifier|*
name|vcp
init|=
name|SSTOVC
argument_list|(
name|smp
operator|->
name|sm_share
argument_list|)
decl_stmt|;
name|register_t
modifier|*
name|retval
init|=
name|ap
operator|->
name|a_retval
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|ap
operator|->
name|a_name
condition|)
block|{
case|case
name|_PC_LINK_MAX
case|:
operator|*
name|retval
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|_PC_NAME_MAX
case|:
operator|*
name|retval
operator|=
operator|(
name|vcp
operator|->
name|vc_hflags2
operator|&
name|SMB_FLAGS2_KNOWS_LONG_NAMES
operator|)
condition|?
literal|255
else|:
literal|12
expr_stmt|;
break|break;
case|case
name|_PC_PATH_MAX
case|:
operator|*
name|retval
operator|=
literal|800
expr_stmt|;
comment|/* XXX: a correct one ? */
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|smbfs_strategy
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_strategy_args
comment|/* { 	struct buf *a_bp 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|buf
modifier|*
name|bp
init|=
name|ap
operator|->
name|a_bp
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cr
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|SMBVDEBUG
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_PHYS
condition|)
name|panic
argument_list|(
literal|"smbfs physio"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_ASYNC
condition|)
name|td
operator|=
operator|(
expr|struct
name|thread
operator|*
operator|)
literal|0
expr_stmt|;
else|else
name|td
operator|=
name|curthread
expr_stmt|;
comment|/* XXX */
if|if
condition|(
name|bp
operator|->
name|b_iocmd
operator|==
name|BIO_READ
condition|)
name|cr
operator|=
name|bp
operator|->
name|b_rcred
expr_stmt|;
else|else
name|cr
operator|=
name|bp
operator|->
name|b_wcred
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_ASYNC
operator|)
operator|==
literal|0
condition|)
name|error
operator|=
name|smbfs_doio
argument_list|(
name|bp
argument_list|,
name|cr
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|smbfs_ioctl
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_ioctl_args
comment|/* { 		struct vnode *a_vp; 		u_long a_command; 		caddr_t a_data; 		int fflag; 		struct ucred *cred; 		struct thread *td; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
return|return
name|EINVAL
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
name|smbfs_atl
index|[]
init|=
literal|"rhsvda"
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|smbfs_getextattr
parameter_list|(
name|struct
name|vop_getextattr_args
modifier|*
name|ap
parameter_list|)
comment|/* {         IN struct vnode *a_vp;         IN char *a_name;         INOUT struct uio *a_uio;         IN struct ucred *a_cred;         IN struct thread *a_td; }; */
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|ap
operator|->
name|a_td
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|ap
operator|->
name|a_cred
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
init|=
name|ap
operator|->
name|a_uio
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|ap
operator|->
name|a_name
decl_stmt|;
name|struct
name|smbnode
modifier|*
name|np
init|=
name|VTOSMB
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|vattr
name|vattr
decl_stmt|;
name|char
name|buf
index|[
literal|10
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|attr
decl_stmt|,
name|error
decl_stmt|;
name|error
operator|=
name|VOP_ACCESS
argument_list|(
name|vp
argument_list|,
name|VREAD
argument_list|,
name|cred
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|vp
argument_list|,
operator|&
name|vattr
argument_list|,
name|cred
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"dosattr"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|attr
operator|=
name|np
operator|->
name|n_dosattr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
operator|,
name|attr
operator|>>=
literal|1
control|)
name|buf
index|[
name|i
index|]
operator|=
operator|(
name|attr
operator|&
literal|1
operator|)
condition|?
name|smbfs_atl
index|[
name|i
index|]
else|:
literal|'-'
expr_stmt|;
name|buf
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|uiomove
argument_list|(
name|buf
argument_list|,
name|i
argument_list|,
name|uio
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Since we expected to support F_GETLK (and SMB protocol has no such function),  * it is necessary to use lf_advlock(). It would be nice if this function had  * a callback mechanism because it will help to improve a level of consistency.  */
end_comment

begin_function
name|int
name|smbfs_advlock
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_advlock_args
comment|/* { 		struct vnode *a_vp; 		caddr_t  a_id; 		int  a_op; 		struct flock *a_fl; 		int  a_flags; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|smbnode
modifier|*
name|np
init|=
name|VTOSMB
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|flock
modifier|*
name|fl
init|=
name|ap
operator|->
name|a_fl
decl_stmt|;
name|caddr_t
name|id
init|=
operator|(
name|caddr_t
operator|)
literal|1
comment|/* ap->a_id */
decl_stmt|;
comment|/*	int flags = ap->a_flags;*/
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|struct
name|smb_cred
name|scred
decl_stmt|;
name|u_quad_t
name|size
decl_stmt|;
name|off_t
name|start
decl_stmt|,
name|end
decl_stmt|,
name|oadd
decl_stmt|;
name|int
name|error
decl_stmt|,
name|lkop
decl_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VDIR
condition|)
block|{
comment|/* 		 * SMB protocol have no support for directory locking. 		 * Although locks can be processed on local machine, I don't 		 * think that this is a good idea, because some programs 		 * can work wrong assuming directory is locked. So, we just 		 * return 'operation not supported 		 */
return|return
name|EOPNOTSUPP
return|;
block|}
name|size
operator|=
name|np
operator|->
name|n_size
expr_stmt|;
switch|switch
condition|(
name|fl
operator|->
name|l_whence
condition|)
block|{
case|case
name|SEEK_SET
case|:
case|case
name|SEEK_CUR
case|:
name|start
operator|=
name|fl
operator|->
name|l_start
expr_stmt|;
break|break;
case|case
name|SEEK_END
case|:
if|if
condition|(
name|size
operator|>
name|OFF_MAX
operator|||
operator|(
name|fl
operator|->
name|l_start
operator|>
literal|0
operator|&&
name|size
operator|>
name|OFF_MAX
operator|-
name|fl
operator|->
name|l_start
operator|)
condition|)
return|return
name|EOVERFLOW
return|;
name|start
operator|=
name|size
operator|+
name|fl
operator|->
name|l_start
expr_stmt|;
break|break;
default|default:
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
name|start
operator|<
literal|0
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|fl
operator|->
name|l_len
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|start
operator|==
literal|0
condition|)
return|return
name|EINVAL
return|;
name|end
operator|=
name|start
operator|-
literal|1
expr_stmt|;
name|start
operator|+=
name|fl
operator|->
name|l_len
expr_stmt|;
if|if
condition|(
name|start
operator|<
literal|0
condition|)
return|return
name|EINVAL
return|;
block|}
elseif|else
if|if
condition|(
name|fl
operator|->
name|l_len
operator|==
literal|0
condition|)
name|end
operator|=
operator|-
literal|1
expr_stmt|;
else|else
block|{
name|oadd
operator|=
name|fl
operator|->
name|l_len
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|oadd
operator|>
name|OFF_MAX
operator|-
name|start
condition|)
return|return
name|EOVERFLOW
return|;
name|end
operator|=
name|start
operator|+
name|oadd
expr_stmt|;
block|}
name|smb_makescred
argument_list|(
operator|&
name|scred
argument_list|,
name|td
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ap
operator|->
name|a_op
condition|)
block|{
case|case
name|F_SETLK
case|:
switch|switch
condition|(
name|fl
operator|->
name|l_type
condition|)
block|{
case|case
name|F_WRLCK
case|:
name|lkop
operator|=
name|SMB_LOCK_EXCL
expr_stmt|;
break|break;
case|case
name|F_RDLCK
case|:
name|lkop
operator|=
name|SMB_LOCK_SHARED
expr_stmt|;
break|break;
case|case
name|F_UNLCK
case|:
name|lkop
operator|=
name|SMB_LOCK_RELEASE
expr_stmt|;
break|break;
default|default:
return|return
name|EINVAL
return|;
block|}
name|error
operator|=
name|lf_advlock
argument_list|(
name|ap
argument_list|,
operator|&
name|np
operator|->
name|n_lockf
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|lkop
operator|=
name|SMB_LOCK_EXCL
expr_stmt|;
name|error
operator|=
name|smbfs_smb_lock
argument_list|(
name|np
argument_list|,
name|lkop
argument_list|,
name|id
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
operator|&
name|scred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|ap
operator|->
name|a_op
operator|=
name|F_UNLCK
expr_stmt|;
name|lf_advlock
argument_list|(
name|ap
argument_list|,
operator|&
name|np
operator|->
name|n_lockf
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|F_UNLCK
case|:
name|lf_advlock
argument_list|(
name|ap
argument_list|,
operator|&
name|np
operator|->
name|n_lockf
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|error
operator|=
name|smbfs_smb_lock
argument_list|(
name|np
argument_list|,
name|SMB_LOCK_RELEASE
argument_list|,
name|id
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
operator|&
name|scred
argument_list|)
expr_stmt|;
break|break;
case|case
name|F_GETLK
case|:
name|error
operator|=
name|lf_advlock
argument_list|(
name|ap
argument_list|,
operator|&
name|np
operator|->
name|n_lockf
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|EINVAL
return|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|smbfs_pathcheck
parameter_list|(
name|struct
name|smbmount
modifier|*
name|smp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|nmlen
parameter_list|,
name|int
name|nameiop
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|badchars
init|=
literal|"*/\[]:<>=;?"
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|badchars83
init|=
literal|" +|,"
decl_stmt|;
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
if|if
condition|(
name|nameiop
operator|==
name|LOOKUP
condition|)
return|return
literal|0
return|;
name|error
operator|=
name|ENOENT
expr_stmt|;
if|if
condition|(
name|SMB_DIALECT
argument_list|(
name|SSTOVC
argument_list|(
name|smp
operator|->
name|sm_share
argument_list|)
argument_list|)
operator|<
name|SMB_DIALECT_LANMAN2_0
condition|)
block|{
comment|/* 		 * Name should conform 8.3 format 		 */
if|if
condition|(
name|nmlen
operator|>
literal|12
condition|)
return|return
name|ENAMETOOLONG
return|;
name|cp
operator|=
name|index
argument_list|(
name|name
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
return|return
name|error
return|;
if|if
condition|(
name|cp
operator|==
name|name
operator|||
operator|(
name|cp
operator|-
name|name
operator|)
operator|>
literal|8
condition|)
return|return
name|error
return|;
name|cp
operator|=
name|index
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
return|return
name|error
return|;
for|for
control|(
name|cp
operator|=
name|name
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nmlen
condition|;
name|i
operator|++
operator|,
name|cp
operator|++
control|)
if|if
condition|(
name|index
argument_list|(
name|badchars83
argument_list|,
operator|*
name|cp
argument_list|)
operator|!=
name|NULL
condition|)
return|return
name|error
return|;
block|}
for|for
control|(
name|cp
operator|=
name|name
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nmlen
condition|;
name|i
operator|++
operator|,
name|cp
operator|++
control|)
if|if
condition|(
name|index
argument_list|(
name|badchars
argument_list|,
operator|*
name|cp
argument_list|)
operator|!=
name|NULL
condition|)
return|return
name|error
return|;
return|return
literal|0
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|PDIRUNLOCK
end_ifndef

begin_define
define|#
directive|define
name|PDIRUNLOCK
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Things go even weird without fixed inode numbers...  */
end_comment

begin_function
name|int
name|smbfs_lookup
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_lookup_args
comment|/* { 		struct vnodeop_desc *a_desc; 		struct vnode *a_dvp; 		struct vnode **a_vpp; 		struct componentname *a_cnp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|cnp
operator|->
name|cn_thread
decl_stmt|;
name|struct
name|vnode
modifier|*
name|dvp
init|=
name|ap
operator|->
name|a_dvp
decl_stmt|;
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
init|=
name|ap
operator|->
name|a_vpp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|smbmount
modifier|*
name|smp
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
init|=
name|dvp
operator|->
name|v_mount
decl_stmt|;
name|struct
name|smbnode
modifier|*
name|dnp
decl_stmt|;
name|struct
name|smbfattr
name|fattr
decl_stmt|,
modifier|*
name|fap
decl_stmt|;
name|struct
name|smb_cred
name|scred
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|cnp
operator|->
name|cn_nameptr
decl_stmt|;
name|int
name|flags
init|=
name|cnp
operator|->
name|cn_flags
decl_stmt|;
name|int
name|nameiop
init|=
name|cnp
operator|->
name|cn_nameiop
decl_stmt|;
name|int
name|nmlen
init|=
name|cnp
operator|->
name|cn_namelen
decl_stmt|;
name|int
name|lockparent
decl_stmt|,
name|wantparent
decl_stmt|,
name|error
decl_stmt|,
name|islastcn
decl_stmt|,
name|isdot
decl_stmt|;
name|SMBVDEBUG
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|cnp
operator|->
name|cn_flags
operator|&=
operator|~
name|PDIRUNLOCK
expr_stmt|;
if|if
condition|(
name|dvp
operator|->
name|v_type
operator|!=
name|VDIR
condition|)
return|return
name|ENOTDIR
return|;
if|if
condition|(
operator|(
name|flags
operator|&
name|ISDOTDOT
operator|)
operator|&&
operator|(
name|dvp
operator|->
name|v_flag
operator|&
name|VROOT
operator|)
condition|)
block|{
name|SMBFSERR
argument_list|(
literal|"invalid '..'\n"
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
ifdef|#
directive|ifdef
name|SMB_VNODE_DEBUG
block|{
name|char
modifier|*
name|cp
decl_stmt|,
name|c
decl_stmt|;
name|cp
operator|=
name|name
operator|+
name|nmlen
expr_stmt|;
name|c
operator|=
operator|*
name|cp
expr_stmt|;
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
name|SMBVDEBUG
argument_list|(
literal|"%d '%s' in '%s' id=d\n"
argument_list|,
name|nameiop
argument_list|,
name|name
argument_list|,
name|VTOSMB
argument_list|(
name|dvp
argument_list|)
operator|->
name|n_name
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
name|c
expr_stmt|;
block|}
endif|#
directive|endif
name|islastcn
operator|=
name|flags
operator|&
name|ISLASTCN
expr_stmt|;
if|if
condition|(
name|islastcn
operator|&&
operator|(
name|mp
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
operator|)
operator|&&
operator|(
name|nameiop
operator|!=
name|LOOKUP
operator|)
condition|)
return|return
name|EROFS
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|VOP_ACCESS
argument_list|(
name|dvp
argument_list|,
name|VEXEC
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|,
name|td
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|lockparent
operator|=
name|flags
operator|&
name|LOCKPARENT
expr_stmt|;
name|wantparent
operator|=
name|flags
operator|&
operator|(
name|LOCKPARENT
operator||
name|WANTPARENT
operator|)
expr_stmt|;
name|smp
operator|=
name|VFSTOSMBFS
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|dnp
operator|=
name|VTOSMB
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|isdot
operator|=
operator|(
name|nmlen
operator|==
literal|1
operator|&&
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|)
expr_stmt|;
name|error
operator|=
name|smbfs_pathcheck
argument_list|(
name|smp
argument_list|,
name|cnp
operator|->
name|cn_nameptr
argument_list|,
name|cnp
operator|->
name|cn_namelen
argument_list|,
name|nameiop
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|ENOENT
return|;
name|error
operator|=
name|cache_lookup
argument_list|(
name|dvp
argument_list|,
name|vpp
argument_list|,
name|cnp
argument_list|)
expr_stmt|;
name|SMBVDEBUG
argument_list|(
literal|"cache_lookup returned %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|>
literal|0
condition|)
return|return
name|error
return|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* name was found */
name|struct
name|vattr
name|vattr
decl_stmt|;
name|int
name|vpid
decl_stmt|;
name|vp
operator|=
operator|*
name|vpp
expr_stmt|;
name|vpid
operator|=
name|vp
operator|->
name|v_id
expr_stmt|;
if|if
condition|(
name|dvp
operator|==
name|vp
condition|)
block|{
comment|/* lookup on current */
name|vref
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|SMBVDEBUG
argument_list|(
literal|"cached '.'\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|ISDOTDOT
condition|)
block|{
name|VOP_UNLOCK
argument_list|(
name|dvp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
comment|/* unlock parent */
name|cnp
operator|->
name|cn_flags
operator||=
name|PDIRUNLOCK
expr_stmt|;
name|error
operator|=
name|vget
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
name|lockparent
operator|&&
name|islastcn
condition|)
block|{
name|error
operator|=
name|vn_lock
argument_list|(
name|dvp
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|cnp
operator|->
name|cn_flags
operator|&=
operator|~
name|PDIRUNLOCK
expr_stmt|;
block|}
block|}
else|else
block|{
name|error
operator|=
name|vget
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lockparent
operator|||
name|error
operator|||
operator|!
name|islastcn
condition|)
block|{
name|VOP_UNLOCK
argument_list|(
name|dvp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|cnp
operator|->
name|cn_flags
operator||=
name|PDIRUNLOCK
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|error
condition|)
block|{
if|if
condition|(
name|vpid
operator|==
name|vp
operator|->
name|v_id
condition|)
block|{
if|if
condition|(
operator|!
name|VOP_GETATTR
argument_list|(
name|vp
argument_list|,
operator|&
name|vattr
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|,
name|td
argument_list|)
comment|/*&& vattr.va_ctime.tv_sec == VTOSMB(vp)->n_ctime*/
condition|)
block|{
if|if
condition|(
name|nameiop
operator|!=
name|LOOKUP
operator|&&
name|islastcn
condition|)
name|cnp
operator|->
name|cn_flags
operator||=
name|SAVENAME
expr_stmt|;
name|SMBVDEBUG
argument_list|(
literal|"use cached vnode\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|cache_purge
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|lockparent
operator|&&
name|dvp
operator|!=
name|vp
operator|&&
name|islastcn
condition|)
name|VOP_UNLOCK
argument_list|(
name|dvp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|vn_lock
argument_list|(
name|dvp
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
name|td
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|NULLVP
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|cnp
operator|->
name|cn_flags
operator||=
name|PDIRUNLOCK
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|cnp
operator|->
name|cn_flags
operator|&=
operator|~
name|PDIRUNLOCK
expr_stmt|;
block|}
comment|/*  	 * entry is not in the cache or has been expired 	 */
name|error
operator|=
literal|0
expr_stmt|;
operator|*
name|vpp
operator|=
name|NULLVP
expr_stmt|;
name|smb_makescred
argument_list|(
operator|&
name|scred
argument_list|,
name|td
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|)
expr_stmt|;
name|fap
operator|=
operator|&
name|fattr
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|ISDOTDOT
condition|)
block|{
name|error
operator|=
name|smbfs_smb_lookup
argument_list|(
name|dnp
operator|->
name|n_parent
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|fap
argument_list|,
operator|&
name|scred
argument_list|)
expr_stmt|;
name|SMBVDEBUG
argument_list|(
literal|"result of dotdot lookup: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fap
operator|=
operator|&
name|fattr
expr_stmt|;
name|error
operator|=
name|smbfs_smb_lookup
argument_list|(
name|dnp
argument_list|,
name|name
argument_list|,
name|nmlen
argument_list|,
name|fap
argument_list|,
operator|&
name|scred
argument_list|)
expr_stmt|;
comment|/*		if (cnp->cn_namelen == 1&& cnp->cn_nameptr[0] == '.')*/
name|SMBVDEBUG
argument_list|(
literal|"result of smbfs_smb_lookup: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|ENOENT
condition|)
return|return
name|error
return|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* entry not found */
comment|/* 		 * Handle RENAME or CREATE case... 		 */
if|if
condition|(
operator|(
name|nameiop
operator|==
name|CREATE
operator|||
name|nameiop
operator|==
name|RENAME
operator|)
operator|&&
name|wantparent
operator|&&
name|islastcn
condition|)
block|{
name|error
operator|=
name|VOP_ACCESS
argument_list|(
name|dvp
argument_list|,
name|VWRITE
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|cnp
operator|->
name|cn_flags
operator||=
name|SAVENAME
expr_stmt|;
if|if
condition|(
operator|!
name|lockparent
condition|)
block|{
name|VOP_UNLOCK
argument_list|(
name|dvp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|cnp
operator|->
name|cn_flags
operator||=
name|PDIRUNLOCK
expr_stmt|;
block|}
return|return
operator|(
name|EJUSTRETURN
operator|)
return|;
block|}
return|return
name|ENOENT
return|;
block|}
comment|/* else { 		SMBVDEBUG("Found entry %s with id=%d\n", fap->entryName, fap->dirEntNum); 	}*/
comment|/* 	 * handle DELETE case ... 	 */
if|if
condition|(
name|nameiop
operator|==
name|DELETE
operator|&&
name|islastcn
condition|)
block|{
comment|/* delete last component */
name|error
operator|=
name|VOP_ACCESS
argument_list|(
name|dvp
argument_list|,
name|VWRITE
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
name|isdot
condition|)
block|{
name|VREF
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|dvp
expr_stmt|;
return|return
literal|0
return|;
block|}
name|error
operator|=
name|smbfs_nget
argument_list|(
name|mp
argument_list|,
name|dvp
argument_list|,
name|name
argument_list|,
name|nmlen
argument_list|,
name|fap
argument_list|,
operator|&
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
operator|*
name|vpp
operator|=
name|vp
expr_stmt|;
name|cnp
operator|->
name|cn_flags
operator||=
name|SAVENAME
expr_stmt|;
if|if
condition|(
operator|!
name|lockparent
condition|)
block|{
name|VOP_UNLOCK
argument_list|(
name|dvp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|cnp
operator|->
name|cn_flags
operator||=
name|PDIRUNLOCK
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
if|if
condition|(
name|nameiop
operator|==
name|RENAME
operator|&&
name|islastcn
operator|&&
name|wantparent
condition|)
block|{
name|error
operator|=
name|VOP_ACCESS
argument_list|(
name|dvp
argument_list|,
name|VWRITE
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
name|isdot
condition|)
return|return
name|EISDIR
return|;
name|error
operator|=
name|smbfs_nget
argument_list|(
name|mp
argument_list|,
name|dvp
argument_list|,
name|name
argument_list|,
name|nmlen
argument_list|,
name|fap
argument_list|,
operator|&
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
operator|*
name|vpp
operator|=
name|vp
expr_stmt|;
name|cnp
operator|->
name|cn_flags
operator||=
name|SAVENAME
expr_stmt|;
if|if
condition|(
operator|!
name|lockparent
condition|)
block|{
name|VOP_UNLOCK
argument_list|(
name|dvp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|cnp
operator|->
name|cn_flags
operator||=
name|PDIRUNLOCK
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
if|if
condition|(
name|flags
operator|&
name|ISDOTDOT
condition|)
block|{
name|VOP_UNLOCK
argument_list|(
name|dvp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|error
operator|=
name|smbfs_nget
argument_list|(
name|mp
argument_list|,
name|dvp
argument_list|,
name|name
argument_list|,
name|nmlen
argument_list|,
name|NULL
argument_list|,
operator|&
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|vn_lock
argument_list|(
name|dvp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
if|if
condition|(
name|lockparent
operator|&&
name|islastcn
condition|)
block|{
name|error
operator|=
name|vn_lock
argument_list|(
name|dvp
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|cnp
operator|->
name|cn_flags
operator||=
name|PDIRUNLOCK
expr_stmt|;
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
block|}
operator|*
name|vpp
operator|=
name|vp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isdot
condition|)
block|{
name|vref
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|dvp
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|smbfs_nget
argument_list|(
name|mp
argument_list|,
name|dvp
argument_list|,
name|name
argument_list|,
name|nmlen
argument_list|,
name|fap
argument_list|,
operator|&
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
operator|*
name|vpp
operator|=
name|vp
expr_stmt|;
name|SMBVDEBUG
argument_list|(
literal|"lookup: getnewvp!\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lockparent
operator|||
operator|!
name|islastcn
condition|)
block|{
name|VOP_UNLOCK
argument_list|(
name|dvp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|cnp
operator|->
name|cn_flags
operator||=
name|PDIRUNLOCK
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|cnp
operator|->
name|cn_flags
operator|&
name|MAKEENTRY
operator|)
comment|/*&& !islastcn*/
condition|)
block|{
comment|/*		VTOSMB(*vpp)->n_ctime = VTOSMB(*vpp)->n_vattr.va_ctime.tv_sec;*/
name|cache_enter
argument_list|(
name|dvp
argument_list|,
operator|*
name|vpp
argument_list|,
name|cnp
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

end_unit

