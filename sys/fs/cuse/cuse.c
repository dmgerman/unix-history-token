begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/*-  * Copyright (c) 2010-2013 Hans Petter Selasky. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"opt_compat.h"
end_include

begin_include
include|#
directive|include
file|<sys/stdint.h>
end_include

begin_include
include|#
directive|include
file|<sys/stddef.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker_set.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/condvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/selinfo.h>
end_include

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<fs/cuse/cuse_defs.h>
end_include

begin_include
include|#
directive|include
file|<fs/cuse/cuse_ioctl.h>
end_include

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|cuse
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Prevent cuse4bsd.ko and cuse.ko from loading at the same time by  * declaring support for the cuse4bsd interface in cuse.ko:  */
end_comment

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|cuse4bsd
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|NBUSY
value|((uint8_t *)1)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|FEATURE
end_ifdef

begin_expr_stmt
name|FEATURE
argument_list|(
name|cuse
argument_list|,
literal|"Userspace character devices"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_struct_decl
struct_decl|struct
name|cuse_command
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|cuse_server
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|cuse_client
struct_decl|;
end_struct_decl

begin_struct
struct|struct
name|cuse_client_command
block|{
name|TAILQ_ENTRY
argument_list|(
argument|cuse_client_command
argument_list|)
name|entry
expr_stmt|;
name|struct
name|cuse_command
name|sub
decl_stmt|;
name|struct
name|sx
name|sx
decl_stmt|;
name|struct
name|cv
name|cv
decl_stmt|;
name|struct
name|thread
modifier|*
name|entered
decl_stmt|;
name|struct
name|cuse_client
modifier|*
name|client
decl_stmt|;
name|struct
name|proc
modifier|*
name|proc_curr
decl_stmt|;
name|int
name|proc_refs
decl_stmt|;
name|int
name|got_signal
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|command
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|cuse_memory
block|{
name|struct
name|cuse_server
modifier|*
name|owner
decl_stmt|;
name|uint8_t
modifier|*
name|virtaddr
decl_stmt|;
name|uint32_t
name|page_count
decl_stmt|;
name|uint32_t
name|is_allocated
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|cuse_server_dev
block|{
name|TAILQ_ENTRY
argument_list|(
argument|cuse_server_dev
argument_list|)
name|entry
expr_stmt|;
name|struct
name|cuse_server
modifier|*
name|server
decl_stmt|;
name|struct
name|cdev
modifier|*
name|kern_dev
decl_stmt|;
name|struct
name|cuse_dev
modifier|*
name|user_dev
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|cuse_server
block|{
name|TAILQ_ENTRY
argument_list|(
argument|cuse_server
argument_list|)
name|entry
expr_stmt|;
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|cuse_client_command
argument_list|)
name|head
expr_stmt|;
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|cuse_server_dev
argument_list|)
name|hdev
expr_stmt|;
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|cuse_client
argument_list|)
name|hcli
expr_stmt|;
name|struct
name|cv
name|cv
decl_stmt|;
name|struct
name|selinfo
name|selinfo
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|int
name|is_closing
decl_stmt|;
name|int
name|refs
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|cuse_client
block|{
name|TAILQ_ENTRY
argument_list|(
argument|cuse_client
argument_list|)
name|entry
expr_stmt|;
name|TAILQ_ENTRY
argument_list|(
argument|cuse_client
argument_list|)
name|entry_ref
expr_stmt|;
name|struct
name|cuse_client_command
name|cmds
index|[
name|CUSE_CMD_MAX
index|]
decl_stmt|;
name|struct
name|cuse_server
modifier|*
name|server
decl_stmt|;
name|struct
name|cuse_server_dev
modifier|*
name|server_dev
decl_stmt|;
name|uint8_t
name|ioctl_buffer
index|[
name|CUSE_BUFFER_MAX
index|]
name|__aligned
argument_list|(
literal|4
argument_list|)
decl_stmt|;
name|int
name|fflags
decl_stmt|;
comment|/* file flags */
name|int
name|cflags
decl_stmt|;
comment|/* client flags */
define|#
directive|define
name|CUSE_CLI_IS_CLOSING
value|0x01
define|#
directive|define
name|CUSE_CLI_KNOTE_NEED_READ
value|0x02
define|#
directive|define
name|CUSE_CLI_KNOTE_NEED_WRITE
value|0x04
define|#
directive|define
name|CUSE_CLI_KNOTE_HAS_READ
value|0x08
define|#
directive|define
name|CUSE_CLI_KNOTE_HAS_WRITE
value|0x10
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|CUSE_CLIENT_CLOSING
parameter_list|(
name|pcc
parameter_list|)
define|\
value|((pcc)->cflags& CUSE_CLI_IS_CLOSING)
end_define

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_CUSE
argument_list|,
literal|"cuse"
argument_list|,
literal|"CUSE memory"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|cuse_server
argument_list|)
name|cuse_server_head
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|cuse_mtx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cdev
modifier|*
name|cuse_dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cuse_server
modifier|*
name|cuse_alloc_unit
index|[
name|CUSE_DEVICES_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cuse_alloc_unit_id
index|[
name|CUSE_DEVICES_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cuse_memory
name|cuse_mem
index|[
name|CUSE_ALLOC_UNIT_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|cuse_server_wakeup_all_client_locked
parameter_list|(
name|struct
name|cuse_server
modifier|*
name|pcs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cuse_client_kqfilter_read_detach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cuse_client_kqfilter_write_detach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cuse_client_kqfilter_read_event
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|long
name|hint
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cuse_client_kqfilter_write_event
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|long
name|hint
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|filterops
name|cuse_client_kqfilter_read_ops
init|=
block|{
operator|.
name|f_isfd
operator|=
literal|1
block|,
operator|.
name|f_detach
operator|=
name|cuse_client_kqfilter_read_detach
block|,
operator|.
name|f_event
operator|=
name|cuse_client_kqfilter_read_event
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|filterops
name|cuse_client_kqfilter_write_ops
init|=
block|{
operator|.
name|f_isfd
operator|=
literal|1
block|,
operator|.
name|f_detach
operator|=
name|cuse_client_kqfilter_write_detach
block|,
operator|.
name|f_event
operator|=
name|cuse_client_kqfilter_write_event
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_open_t
name|cuse_client_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|cuse_client_close
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|cuse_client_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_read_t
name|cuse_client_read
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_write_t
name|cuse_client_write
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_poll_t
name|cuse_client_poll
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_mmap_t
name|cuse_client_mmap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_kqfilter_t
name|cuse_client_kqfilter
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|cuse_client_devsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_open
operator|=
name|cuse_client_open
block|,
operator|.
name|d_close
operator|=
name|cuse_client_close
block|,
operator|.
name|d_ioctl
operator|=
name|cuse_client_ioctl
block|,
operator|.
name|d_name
operator|=
literal|"cuse_client"
block|,
operator|.
name|d_flags
operator|=
name|D_TRACKCLOSE
block|,
operator|.
name|d_read
operator|=
name|cuse_client_read
block|,
operator|.
name|d_write
operator|=
name|cuse_client_write
block|,
operator|.
name|d_poll
operator|=
name|cuse_client_poll
block|,
operator|.
name|d_mmap
operator|=
name|cuse_client_mmap
block|,
operator|.
name|d_kqfilter
operator|=
name|cuse_client_kqfilter
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_open_t
name|cuse_server_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|cuse_server_close
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|cuse_server_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_read_t
name|cuse_server_read
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_write_t
name|cuse_server_write
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_poll_t
name|cuse_server_poll
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_mmap_t
name|cuse_server_mmap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|cuse_server_devsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_open
operator|=
name|cuse_server_open
block|,
operator|.
name|d_close
operator|=
name|cuse_server_close
block|,
operator|.
name|d_ioctl
operator|=
name|cuse_server_ioctl
block|,
operator|.
name|d_name
operator|=
literal|"cuse_server"
block|,
operator|.
name|d_flags
operator|=
name|D_TRACKCLOSE
block|,
operator|.
name|d_read
operator|=
name|cuse_server_read
block|,
operator|.
name|d_write
operator|=
name|cuse_server_write
block|,
operator|.
name|d_poll
operator|=
name|cuse_server_poll
block|,
operator|.
name|d_mmap
operator|=
name|cuse_server_mmap
block|, }
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|cuse_client_is_closing
parameter_list|(
name|struct
name|cuse_client
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cuse_free_unit_by_id_locked
parameter_list|(
name|struct
name|cuse_server
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|cuse_lock
parameter_list|(
name|void
parameter_list|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|cuse_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cuse_unlock
parameter_list|(
name|void
parameter_list|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|cuse_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cuse_cmd_lock
parameter_list|(
name|struct
name|cuse_client_command
modifier|*
name|pccmd
parameter_list|)
block|{
name|sx_xlock
argument_list|(
operator|&
name|pccmd
operator|->
name|sx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cuse_cmd_unlock
parameter_list|(
name|struct
name|cuse_client_command
modifier|*
name|pccmd
parameter_list|)
block|{
name|sx_xunlock
argument_list|(
operator|&
name|pccmd
operator|->
name|sx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cuse_kern_init
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|TAILQ_INIT
argument_list|(
operator|&
name|cuse_server_head
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|cuse_mtx
argument_list|,
literal|"cuse-mtx"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|cuse_dev
operator|=
name|make_dev
argument_list|(
operator|&
name|cuse_server_devsw
argument_list|,
literal|0
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
literal|0600
argument_list|,
literal|"cuse"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Cuse v%d.%d.%d @ /dev/cuse\n"
argument_list|,
operator|(
name|CUSE_VERSION
operator|>>
literal|16
operator|)
operator|&
literal|0xFF
argument_list|,
operator|(
name|CUSE_VERSION
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
argument_list|,
operator|(
name|CUSE_VERSION
operator|>>
literal|0
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|cuse_kern_init
argument_list|,
name|SI_SUB_DEVFS
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|cuse_kern_init
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|cuse_kern_uninit
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|void
modifier|*
name|ptr
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"Cuse: Please exit all /dev/cuse instances "
literal|"and processes which have used this device.\n"
argument_list|)
expr_stmt|;
name|pause
argument_list|(
literal|"DRAIN"
argument_list|,
literal|2
operator|*
name|hz
argument_list|)
expr_stmt|;
name|cuse_lock
argument_list|()
expr_stmt|;
name|ptr
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|cuse_server_head
argument_list|)
expr_stmt|;
name|cuse_unlock
argument_list|()
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
break|break;
block|}
if|if
condition|(
name|cuse_dev
operator|!=
name|NULL
condition|)
name|destroy_dev
argument_list|(
name|cuse_dev
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|cuse_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSUNINIT
argument_list|(
name|cuse_kern_uninit
argument_list|,
name|SI_SUB_DEVFS
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|cuse_kern_uninit
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|cuse_server_get
parameter_list|(
name|struct
name|cuse_server
modifier|*
modifier|*
name|ppcs
parameter_list|)
block|{
name|struct
name|cuse_server
modifier|*
name|pcs
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|devfs_get_cdevpriv
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|pcs
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
operator|*
name|ppcs
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* check if closing */
name|cuse_lock
argument_list|()
expr_stmt|;
if|if
condition|(
name|pcs
operator|->
name|is_closing
condition|)
block|{
name|cuse_unlock
argument_list|()
expr_stmt|;
operator|*
name|ppcs
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|cuse_unlock
argument_list|()
expr_stmt|;
operator|*
name|ppcs
operator|=
name|pcs
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cuse_server_is_closing
parameter_list|(
name|struct
name|cuse_server
modifier|*
name|pcs
parameter_list|)
block|{
name|struct
name|cuse_client
modifier|*
name|pcc
decl_stmt|;
if|if
condition|(
name|pcs
operator|->
name|is_closing
condition|)
return|return;
name|pcs
operator|->
name|is_closing
operator|=
literal|1
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pcc
argument_list|,
argument|&pcs->hcli
argument_list|,
argument|entry
argument_list|)
block|{
name|cuse_client_is_closing
argument_list|(
name|pcc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|cuse_client_command
modifier|*
name|cuse_server_find_command
parameter_list|(
name|struct
name|cuse_server
modifier|*
name|pcs
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|cuse_client
modifier|*
name|pcc
decl_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
name|pcs
operator|->
name|is_closing
condition|)
goto|goto
name|done
goto|;
name|TAILQ_FOREACH
argument_list|(
argument|pcc
argument_list|,
argument|&pcs->hcli
argument_list|,
argument|entry
argument_list|)
block|{
if|if
condition|(
name|CUSE_CLIENT_CLOSING
argument_list|(
name|pcc
argument_list|)
condition|)
continue|continue;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|!=
name|CUSE_CMD_MAX
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|pcc
operator|->
name|cmds
index|[
name|n
index|]
operator|.
name|entered
operator|==
name|td
condition|)
return|return
operator|(
operator|&
name|pcc
operator|->
name|cmds
index|[
name|n
index|]
operator|)
return|;
block|}
block|}
name|done
label|:
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cuse_str_filter
parameter_list|(
name|char
modifier|*
name|ptr
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
operator|(
name|c
operator|=
operator|*
name|ptr
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|>=
literal|'a'
operator|)
operator|&&
operator|(
name|c
operator|<=
literal|'z'
operator|)
condition|)
block|{
name|ptr
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|c
operator|>=
literal|'A'
operator|)
operator|&&
operator|(
name|c
operator|<=
literal|'Z'
operator|)
condition|)
block|{
name|ptr
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|c
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
name|c
operator|<=
literal|'9'
operator|)
condition|)
block|{
name|ptr
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|c
operator|==
literal|'.'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'_'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'/'
operator|)
condition|)
block|{
name|ptr
operator|++
expr_stmt|;
continue|continue;
block|}
operator|*
name|ptr
operator|=
literal|'_'
expr_stmt|;
name|ptr
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|cuse_convert_error
parameter_list|(
name|int
name|error
parameter_list|)
block|{
empty_stmt|;
comment|/* indent fix */
switch|switch
condition|(
name|error
condition|)
block|{
case|case
name|CUSE_ERR_NONE
case|:
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|CUSE_ERR_BUSY
case|:
return|return
operator|(
name|EBUSY
operator|)
return|;
case|case
name|CUSE_ERR_WOULDBLOCK
case|:
return|return
operator|(
name|EWOULDBLOCK
operator|)
return|;
case|case
name|CUSE_ERR_INVALID
case|:
return|return
operator|(
name|EINVAL
operator|)
return|;
case|case
name|CUSE_ERR_NO_MEMORY
case|:
return|return
operator|(
name|ENOMEM
operator|)
return|;
case|case
name|CUSE_ERR_FAULT
case|:
return|return
operator|(
name|EFAULT
operator|)
return|;
case|case
name|CUSE_ERR_SIGNAL
case|:
return|return
operator|(
name|EINTR
operator|)
return|;
default|default:
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|cuse_server_free_memory
parameter_list|(
name|struct
name|cuse_server
modifier|*
name|pcs
parameter_list|)
block|{
name|struct
name|cuse_memory
modifier|*
name|mem
decl_stmt|;
name|uint32_t
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|!=
name|CUSE_ALLOC_UNIT_MAX
condition|;
name|n
operator|++
control|)
block|{
name|mem
operator|=
operator|&
name|cuse_mem
index|[
name|n
index|]
expr_stmt|;
comment|/* this memory is never freed */
if|if
condition|(
name|mem
operator|->
name|owner
operator|==
name|pcs
condition|)
block|{
name|mem
operator|->
name|owner
operator|=
name|NULL
expr_stmt|;
name|mem
operator|->
name|is_allocated
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|cuse_server_alloc_memory
parameter_list|(
name|struct
name|cuse_server
modifier|*
name|pcs
parameter_list|,
name|struct
name|cuse_memory
modifier|*
name|mem
parameter_list|,
name|uint32_t
name|page_count
parameter_list|)
block|{
name|void
modifier|*
name|ptr
decl_stmt|;
name|int
name|error
decl_stmt|;
name|cuse_lock
argument_list|()
expr_stmt|;
if|if
condition|(
name|mem
operator|->
name|virtaddr
operator|==
name|NBUSY
condition|)
block|{
name|cuse_unlock
argument_list|()
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
if|if
condition|(
name|mem
operator|->
name|virtaddr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|mem
operator|->
name|is_allocated
operator|!=
literal|0
condition|)
block|{
name|cuse_unlock
argument_list|()
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
if|if
condition|(
name|mem
operator|->
name|page_count
operator|==
name|page_count
condition|)
block|{
name|mem
operator|->
name|is_allocated
operator|=
literal|1
expr_stmt|;
name|mem
operator|->
name|owner
operator|=
name|pcs
expr_stmt|;
name|cuse_unlock
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|cuse_unlock
argument_list|()
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|memset
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|mem
argument_list|)
argument_list|)
expr_stmt|;
name|mem
operator|->
name|virtaddr
operator|=
name|NBUSY
expr_stmt|;
name|cuse_unlock
argument_list|()
expr_stmt|;
name|ptr
operator|=
name|malloc
argument_list|(
name|page_count
operator|*
name|PAGE_SIZE
argument_list|,
name|M_CUSE
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
name|error
operator|=
name|ENOMEM
expr_stmt|;
else|else
name|error
operator|=
literal|0
expr_stmt|;
name|cuse_lock
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|mem
operator|->
name|virtaddr
operator|=
name|NULL
expr_stmt|;
name|cuse_unlock
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|mem
operator|->
name|virtaddr
operator|=
name|ptr
expr_stmt|;
name|mem
operator|->
name|page_count
operator|=
name|page_count
expr_stmt|;
name|mem
operator|->
name|is_allocated
operator|=
literal|1
expr_stmt|;
name|mem
operator|->
name|owner
operator|=
name|pcs
expr_stmt|;
name|cuse_unlock
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cuse_client_get
parameter_list|(
name|struct
name|cuse_client
modifier|*
modifier|*
name|ppcc
parameter_list|)
block|{
name|struct
name|cuse_client
modifier|*
name|pcc
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* try to get private data */
name|error
operator|=
name|devfs_get_cdevpriv
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|pcc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
operator|*
name|ppcc
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* check if closing */
name|cuse_lock
argument_list|()
expr_stmt|;
if|if
condition|(
name|CUSE_CLIENT_CLOSING
argument_list|(
name|pcc
argument_list|)
operator|||
name|pcc
operator|->
name|server
operator|->
name|is_closing
condition|)
block|{
name|cuse_unlock
argument_list|()
expr_stmt|;
operator|*
name|ppcc
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|cuse_unlock
argument_list|()
expr_stmt|;
operator|*
name|ppcc
operator|=
name|pcc
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cuse_client_is_closing
parameter_list|(
name|struct
name|cuse_client
modifier|*
name|pcc
parameter_list|)
block|{
name|struct
name|cuse_client_command
modifier|*
name|pccmd
decl_stmt|;
name|uint32_t
name|n
decl_stmt|;
if|if
condition|(
name|CUSE_CLIENT_CLOSING
argument_list|(
name|pcc
argument_list|)
condition|)
return|return;
name|pcc
operator|->
name|cflags
operator||=
name|CUSE_CLI_IS_CLOSING
expr_stmt|;
name|pcc
operator|->
name|server_dev
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|!=
name|CUSE_CMD_MAX
condition|;
name|n
operator|++
control|)
block|{
name|pccmd
operator|=
operator|&
name|pcc
operator|->
name|cmds
index|[
name|n
index|]
expr_stmt|;
if|if
condition|(
name|pccmd
operator|->
name|entry
operator|.
name|tqe_prev
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pcc
operator|->
name|server
operator|->
name|head
argument_list|,
name|pccmd
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|pccmd
operator|->
name|entry
operator|.
name|tqe_prev
operator|=
name|NULL
expr_stmt|;
block|}
name|cv_broadcast
argument_list|(
operator|&
name|pccmd
operator|->
name|cv
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|cuse_client_send_command_locked
parameter_list|(
name|struct
name|cuse_client_command
modifier|*
name|pccmd
parameter_list|,
name|uintptr_t
name|data_ptr
parameter_list|,
name|unsigned
name|long
name|arg
parameter_list|,
name|int
name|fflags
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
name|unsigned
name|long
name|cuse_fflags
init|=
literal|0
decl_stmt|;
name|struct
name|cuse_server
modifier|*
name|pcs
decl_stmt|;
if|if
condition|(
name|fflags
operator|&
name|FREAD
condition|)
name|cuse_fflags
operator||=
name|CUSE_FFLAG_READ
expr_stmt|;
if|if
condition|(
name|fflags
operator|&
name|FWRITE
condition|)
name|cuse_fflags
operator||=
name|CUSE_FFLAG_WRITE
expr_stmt|;
if|if
condition|(
name|ioflag
operator|&
name|IO_NDELAY
condition|)
name|cuse_fflags
operator||=
name|CUSE_FFLAG_NONBLOCK
expr_stmt|;
name|pccmd
operator|->
name|sub
operator|.
name|fflags
operator|=
name|cuse_fflags
expr_stmt|;
name|pccmd
operator|->
name|sub
operator|.
name|data_pointer
operator|=
name|data_ptr
expr_stmt|;
name|pccmd
operator|->
name|sub
operator|.
name|argument
operator|=
name|arg
expr_stmt|;
name|pcs
operator|=
name|pccmd
operator|->
name|client
operator|->
name|server
expr_stmt|;
if|if
condition|(
operator|(
name|pccmd
operator|->
name|entry
operator|.
name|tqe_prev
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|CUSE_CLIENT_CLOSING
argument_list|(
name|pccmd
operator|->
name|client
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|pcs
operator|->
name|is_closing
operator|==
literal|0
operator|)
condition|)
block|{
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|pcs
operator|->
name|head
argument_list|,
name|pccmd
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|cv_signal
argument_list|(
operator|&
name|pcs
operator|->
name|cv
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|cuse_client_got_signal
parameter_list|(
name|struct
name|cuse_client_command
modifier|*
name|pccmd
parameter_list|)
block|{
name|struct
name|cuse_server
modifier|*
name|pcs
decl_stmt|;
name|pccmd
operator|->
name|got_signal
operator|=
literal|1
expr_stmt|;
name|pccmd
operator|=
operator|&
name|pccmd
operator|->
name|client
operator|->
name|cmds
index|[
name|CUSE_CMD_SIGNAL
index|]
expr_stmt|;
name|pcs
operator|=
name|pccmd
operator|->
name|client
operator|->
name|server
expr_stmt|;
if|if
condition|(
operator|(
name|pccmd
operator|->
name|entry
operator|.
name|tqe_prev
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|CUSE_CLIENT_CLOSING
argument_list|(
name|pccmd
operator|->
name|client
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|pcs
operator|->
name|is_closing
operator|==
literal|0
operator|)
condition|)
block|{
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|pcs
operator|->
name|head
argument_list|,
name|pccmd
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|cv_signal
argument_list|(
operator|&
name|pcs
operator|->
name|cv
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|cuse_client_receive_command_locked
parameter_list|(
name|struct
name|cuse_client_command
modifier|*
name|pccmd
parameter_list|,
name|uint8_t
modifier|*
name|arg_ptr
parameter_list|,
name|uint32_t
name|arg_len
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|pccmd
operator|->
name|proc_curr
operator|=
name|curthread
operator|->
name|td_proc
expr_stmt|;
if|if
condition|(
name|CUSE_CLIENT_CLOSING
argument_list|(
name|pccmd
operator|->
name|client
argument_list|)
operator|||
name|pccmd
operator|->
name|client
operator|->
name|server
operator|->
name|is_closing
condition|)
block|{
name|error
operator|=
name|CUSE_ERR_OTHER
expr_stmt|;
goto|goto
name|done
goto|;
block|}
while|while
condition|(
name|pccmd
operator|->
name|command
operator|==
name|CUSE_CMD_NONE
condition|)
block|{
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|cv_wait
argument_list|(
operator|&
name|pccmd
operator|->
name|cv
argument_list|,
operator|&
name|cuse_mtx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|cv_wait_sig
argument_list|(
operator|&
name|pccmd
operator|->
name|cv
argument_list|,
operator|&
name|cuse_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|cuse_client_got_signal
argument_list|(
name|pccmd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|CUSE_CLIENT_CLOSING
argument_list|(
name|pccmd
operator|->
name|client
argument_list|)
operator|||
name|pccmd
operator|->
name|client
operator|->
name|server
operator|->
name|is_closing
condition|)
block|{
name|error
operator|=
name|CUSE_ERR_OTHER
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
name|error
operator|=
name|pccmd
operator|->
name|error
expr_stmt|;
name|pccmd
operator|->
name|command
operator|=
name|CUSE_CMD_NONE
expr_stmt|;
name|cv_signal
argument_list|(
operator|&
name|pccmd
operator|->
name|cv
argument_list|)
expr_stmt|;
name|done
label|:
comment|/* wait until all process references are gone */
name|pccmd
operator|->
name|proc_curr
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|pccmd
operator|->
name|proc_refs
operator|!=
literal|0
condition|)
name|cv_wait
argument_list|(
operator|&
name|pccmd
operator|->
name|cv
argument_list|,
operator|&
name|cuse_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	CUSE SERVER PART  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|cuse_server_free_dev
parameter_list|(
name|struct
name|cuse_server_dev
modifier|*
name|pcsd
parameter_list|)
block|{
name|struct
name|cuse_server
modifier|*
name|pcs
decl_stmt|;
name|struct
name|cuse_client
modifier|*
name|pcc
decl_stmt|;
comment|/* get server pointer */
name|pcs
operator|=
name|pcsd
operator|->
name|server
expr_stmt|;
comment|/* prevent creation of more devices */
name|cuse_lock
argument_list|()
expr_stmt|;
if|if
condition|(
name|pcsd
operator|->
name|kern_dev
operator|!=
name|NULL
condition|)
name|pcsd
operator|->
name|kern_dev
operator|->
name|si_drv1
operator|=
name|NULL
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pcc
argument_list|,
argument|&pcs->hcli
argument_list|,
argument|entry
argument_list|)
block|{
if|if
condition|(
name|pcc
operator|->
name|server_dev
operator|==
name|pcsd
condition|)
name|cuse_client_is_closing
argument_list|(
name|pcc
argument_list|)
expr_stmt|;
block|}
name|cuse_unlock
argument_list|()
expr_stmt|;
comment|/* destroy device, if any */
if|if
condition|(
name|pcsd
operator|->
name|kern_dev
operator|!=
name|NULL
condition|)
block|{
comment|/* destroy device synchronously */
name|destroy_dev
argument_list|(
name|pcsd
operator|->
name|kern_dev
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|pcsd
argument_list|,
name|M_CUSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cuse_server_free
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|cuse_server
modifier|*
name|pcs
init|=
name|arg
decl_stmt|;
name|struct
name|cuse_server_dev
modifier|*
name|pcsd
decl_stmt|;
name|cuse_lock
argument_list|()
expr_stmt|;
name|pcs
operator|->
name|refs
operator|--
expr_stmt|;
if|if
condition|(
name|pcs
operator|->
name|refs
operator|!=
literal|0
condition|)
block|{
name|cuse_unlock
argument_list|()
expr_stmt|;
return|return;
block|}
name|cuse_server_is_closing
argument_list|(
name|pcs
argument_list|)
expr_stmt|;
comment|/* final client wakeup, if any */
name|cuse_server_wakeup_all_client_locked
argument_list|(
name|pcs
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|cuse_server_head
argument_list|,
name|pcs
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|cuse_free_unit_by_id_locked
argument_list|(
name|pcs
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|pcsd
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pcs
operator|->
name|hdev
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pcs
operator|->
name|hdev
argument_list|,
name|pcsd
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|cuse_unlock
argument_list|()
expr_stmt|;
name|cuse_server_free_dev
argument_list|(
name|pcsd
argument_list|)
expr_stmt|;
name|cuse_lock
argument_list|()
expr_stmt|;
block|}
name|cuse_server_free_memory
argument_list|(
name|pcs
argument_list|)
expr_stmt|;
name|knlist_clear
argument_list|(
operator|&
name|pcs
operator|->
name|selinfo
operator|.
name|si_note
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|knlist_destroy
argument_list|(
operator|&
name|pcs
operator|->
name|selinfo
operator|.
name|si_note
argument_list|)
expr_stmt|;
name|cuse_unlock
argument_list|()
expr_stmt|;
name|seldrain
argument_list|(
operator|&
name|pcs
operator|->
name|selinfo
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|pcs
operator|->
name|cv
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pcs
argument_list|,
name|M_CUSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|cuse_server_open
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|fflags
parameter_list|,
name|int
name|devtype
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|cuse_server
modifier|*
name|pcs
decl_stmt|;
name|pcs
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|pcs
argument_list|)
argument_list|,
name|M_CUSE
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcs
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
if|if
condition|(
name|devfs_set_cdevpriv
argument_list|(
name|pcs
argument_list|,
operator|&
name|cuse_server_free
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Cuse: Cannot set cdevpriv.\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pcs
argument_list|,
name|M_CUSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* store current process ID */
name|pcs
operator|->
name|pid
operator|=
name|curproc
operator|->
name|p_pid
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|pcs
operator|->
name|head
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|pcs
operator|->
name|hdev
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|pcs
operator|->
name|hcli
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|pcs
operator|->
name|cv
argument_list|,
literal|"cuse-server-cv"
argument_list|)
expr_stmt|;
name|knlist_init_mtx
argument_list|(
operator|&
name|pcs
operator|->
name|selinfo
operator|.
name|si_note
argument_list|,
operator|&
name|cuse_mtx
argument_list|)
expr_stmt|;
name|cuse_lock
argument_list|()
expr_stmt|;
name|pcs
operator|->
name|refs
operator|++
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|cuse_server_head
argument_list|,
name|pcs
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|cuse_unlock
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cuse_server_close
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|fflag
parameter_list|,
name|int
name|devtype
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|cuse_server
modifier|*
name|pcs
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|cuse_server_get
argument_list|(
operator|&
name|pcs
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
name|cuse_lock
argument_list|()
expr_stmt|;
name|cuse_server_is_closing
argument_list|(
name|pcs
argument_list|)
expr_stmt|;
comment|/* final client wakeup, if any */
name|cuse_server_wakeup_all_client_locked
argument_list|(
name|pcs
argument_list|)
expr_stmt|;
name|knlist_clear
argument_list|(
operator|&
name|pcs
operator|->
name|selinfo
operator|.
name|si_note
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cuse_unlock
argument_list|()
expr_stmt|;
name|done
label|:
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cuse_server_read
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cuse_server_write
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cuse_server_ioctl_copy_locked
parameter_list|(
name|struct
name|cuse_client_command
modifier|*
name|pccmd
parameter_list|,
name|struct
name|cuse_data_chunk
modifier|*
name|pchk
parameter_list|,
name|int
name|isread
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p_proc
decl_stmt|;
name|uint32_t
name|offset
decl_stmt|;
name|int
name|error
decl_stmt|;
name|offset
operator|=
name|pchk
operator|->
name|peer_ptr
operator|-
name|CUSE_BUF_MIN_PTR
expr_stmt|;
if|if
condition|(
name|pchk
operator|->
name|length
operator|>
name|CUSE_BUFFER_MAX
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
if|if
condition|(
name|offset
operator|>=
name|CUSE_BUFFER_MAX
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
if|if
condition|(
operator|(
name|offset
operator|+
name|pchk
operator|->
name|length
operator|)
operator|>
name|CUSE_BUFFER_MAX
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|p_proc
operator|=
name|pccmd
operator|->
name|proc_curr
expr_stmt|;
if|if
condition|(
name|p_proc
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|pccmd
operator|->
name|proc_refs
operator|<
literal|0
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|pccmd
operator|->
name|proc_refs
operator|++
expr_stmt|;
name|cuse_unlock
argument_list|()
expr_stmt|;
if|if
condition|(
name|isread
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|copyin
argument_list|(
operator|(
name|void
operator|*
operator|)
name|pchk
operator|->
name|local_ptr
argument_list|,
name|pccmd
operator|->
name|client
operator|->
name|ioctl_buffer
operator|+
name|offset
argument_list|,
name|pchk
operator|->
name|length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|copyout
argument_list|(
name|pccmd
operator|->
name|client
operator|->
name|ioctl_buffer
operator|+
name|offset
argument_list|,
operator|(
name|void
operator|*
operator|)
name|pchk
operator|->
name|local_ptr
argument_list|,
name|pchk
operator|->
name|length
argument_list|)
expr_stmt|;
block|}
name|cuse_lock
argument_list|()
expr_stmt|;
name|pccmd
operator|->
name|proc_refs
operator|--
expr_stmt|;
if|if
condition|(
name|pccmd
operator|->
name|proc_curr
operator|==
name|NULL
condition|)
name|cv_signal
argument_list|(
operator|&
name|pccmd
operator|->
name|cv
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cuse_proc2proc_copy
parameter_list|(
name|struct
name|proc
modifier|*
name|proc_s
parameter_list|,
name|vm_offset_t
name|data_s
parameter_list|,
name|struct
name|proc
modifier|*
name|proc_d
parameter_list|,
name|vm_offset_t
name|data_d
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|proc
modifier|*
name|proc_cur
decl_stmt|;
name|int
name|error
decl_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
name|proc_cur
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
if|if
condition|(
name|proc_cur
operator|==
name|proc_d
condition|)
block|{
name|struct
name|iovec
name|iov
init|=
block|{
operator|.
name|iov_base
operator|=
operator|(
name|caddr_t
operator|)
name|data_d
block|,
operator|.
name|iov_len
operator|=
name|len
block|, 		}
decl_stmt|;
name|struct
name|uio
name|uio
init|=
block|{
operator|.
name|uio_iov
operator|=
operator|&
name|iov
block|,
operator|.
name|uio_iovcnt
operator|=
literal|1
block|,
operator|.
name|uio_offset
operator|=
operator|(
name|off_t
operator|)
name|data_s
block|,
operator|.
name|uio_resid
operator|=
name|len
block|,
operator|.
name|uio_segflg
operator|=
name|UIO_USERSPACE
block|,
operator|.
name|uio_rw
operator|=
name|UIO_READ
block|,
operator|.
name|uio_td
operator|=
name|td
block|, 		}
decl_stmt|;
name|PHOLD
argument_list|(
name|proc_s
argument_list|)
expr_stmt|;
name|error
operator|=
name|proc_rwmem
argument_list|(
name|proc_s
argument_list|,
operator|&
name|uio
argument_list|)
expr_stmt|;
name|PRELE
argument_list|(
name|proc_s
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|proc_cur
operator|==
name|proc_s
condition|)
block|{
name|struct
name|iovec
name|iov
init|=
block|{
operator|.
name|iov_base
operator|=
operator|(
name|caddr_t
operator|)
name|data_s
block|,
operator|.
name|iov_len
operator|=
name|len
block|, 		}
decl_stmt|;
name|struct
name|uio
name|uio
init|=
block|{
operator|.
name|uio_iov
operator|=
operator|&
name|iov
block|,
operator|.
name|uio_iovcnt
operator|=
literal|1
block|,
operator|.
name|uio_offset
operator|=
operator|(
name|off_t
operator|)
name|data_d
block|,
operator|.
name|uio_resid
operator|=
name|len
block|,
operator|.
name|uio_segflg
operator|=
name|UIO_USERSPACE
block|,
operator|.
name|uio_rw
operator|=
name|UIO_WRITE
block|,
operator|.
name|uio_td
operator|=
name|td
block|, 		}
decl_stmt|;
name|PHOLD
argument_list|(
name|proc_d
argument_list|)
expr_stmt|;
name|error
operator|=
name|proc_rwmem
argument_list|(
name|proc_d
argument_list|,
operator|&
name|uio
argument_list|)
expr_stmt|;
name|PRELE
argument_list|(
name|proc_d
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cuse_server_data_copy_locked
parameter_list|(
name|struct
name|cuse_client_command
modifier|*
name|pccmd
parameter_list|,
name|struct
name|cuse_data_chunk
modifier|*
name|pchk
parameter_list|,
name|int
name|isread
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p_proc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|p_proc
operator|=
name|pccmd
operator|->
name|proc_curr
expr_stmt|;
if|if
condition|(
name|p_proc
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|pccmd
operator|->
name|proc_refs
operator|<
literal|0
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|pccmd
operator|->
name|proc_refs
operator|++
expr_stmt|;
name|cuse_unlock
argument_list|()
expr_stmt|;
if|if
condition|(
name|isread
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|cuse_proc2proc_copy
argument_list|(
name|curthread
operator|->
name|td_proc
argument_list|,
name|pchk
operator|->
name|local_ptr
argument_list|,
name|p_proc
argument_list|,
name|pchk
operator|->
name|peer_ptr
argument_list|,
name|pchk
operator|->
name|length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|cuse_proc2proc_copy
argument_list|(
name|p_proc
argument_list|,
name|pchk
operator|->
name|peer_ptr
argument_list|,
name|curthread
operator|->
name|td_proc
argument_list|,
name|pchk
operator|->
name|local_ptr
argument_list|,
name|pchk
operator|->
name|length
argument_list|)
expr_stmt|;
block|}
name|cuse_lock
argument_list|()
expr_stmt|;
name|pccmd
operator|->
name|proc_refs
operator|--
expr_stmt|;
if|if
condition|(
name|pccmd
operator|->
name|proc_curr
operator|==
name|NULL
condition|)
name|cv_signal
argument_list|(
operator|&
name|pccmd
operator|->
name|cv
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cuse_alloc_unit_by_id_locked
parameter_list|(
name|struct
name|cuse_server
modifier|*
name|pcs
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
name|int
name|x
init|=
literal|0
decl_stmt|;
name|int
name|match
decl_stmt|;
do|do
block|{
for|for
control|(
name|match
operator|=
name|n
operator|=
literal|0
init|;
name|n
operator|!=
name|CUSE_DEVICES_MAX
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|cuse_alloc_unit
index|[
name|n
index|]
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|cuse_alloc_unit_id
index|[
name|n
index|]
operator|^
name|id
operator|)
operator|&
name|CUSE_ID_MASK
condition|)
continue|continue;
if|if
condition|(
operator|(
name|cuse_alloc_unit_id
index|[
name|n
index|]
operator|&
operator|~
name|CUSE_ID_MASK
operator|)
operator|==
name|x
condition|)
block|{
name|x
operator|++
expr_stmt|;
name|match
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
do|while
condition|(
name|match
condition|)
do|;
if|if
condition|(
name|x
operator|<
literal|256
condition|)
block|{
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|!=
name|CUSE_DEVICES_MAX
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|cuse_alloc_unit
index|[
name|n
index|]
operator|==
name|NULL
condition|)
block|{
name|cuse_alloc_unit
index|[
name|n
index|]
operator|=
name|pcs
expr_stmt|;
name|cuse_alloc_unit_id
index|[
name|n
index|]
operator|=
name|id
operator||
name|x
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
block|}
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cuse_server_wakeup_locked
parameter_list|(
name|struct
name|cuse_server
modifier|*
name|pcs
parameter_list|)
block|{
name|selwakeup
argument_list|(
operator|&
name|pcs
operator|->
name|selinfo
argument_list|)
expr_stmt|;
name|KNOTE_LOCKED
argument_list|(
operator|&
name|pcs
operator|->
name|selinfo
operator|.
name|si_note
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cuse_server_wakeup_all_client_locked
parameter_list|(
name|struct
name|cuse_server
modifier|*
name|pcs
parameter_list|)
block|{
name|struct
name|cuse_client
modifier|*
name|pcc
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pcc
argument_list|,
argument|&pcs->hcli
argument_list|,
argument|entry
argument_list|)
block|{
name|pcc
operator|->
name|cflags
operator||=
operator|(
name|CUSE_CLI_KNOTE_NEED_READ
operator||
name|CUSE_CLI_KNOTE_NEED_WRITE
operator|)
expr_stmt|;
block|}
name|cuse_server_wakeup_locked
argument_list|(
name|pcs
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|cuse_free_unit_by_id_locked
parameter_list|(
name|struct
name|cuse_server
modifier|*
name|pcs
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|!=
name|CUSE_DEVICES_MAX
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|cuse_alloc_unit
index|[
name|n
index|]
operator|==
name|pcs
condition|)
block|{
if|if
condition|(
name|cuse_alloc_unit_id
index|[
name|n
index|]
operator|==
name|id
operator|||
name|id
operator|==
operator|-
literal|1
condition|)
block|{
name|cuse_alloc_unit
index|[
name|n
index|]
operator|=
name|NULL
expr_stmt|;
name|cuse_alloc_unit_id
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|found
condition|?
literal|0
else|:
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cuse_server_ioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|unsigned
name|long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|fflag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|cuse_server
modifier|*
name|pcs
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|cuse_server_get
argument_list|(
operator|&
name|pcs
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
switch|switch
condition|(
name|cmd
condition|)
block|{
name|struct
name|cuse_client_command
modifier|*
name|pccmd
decl_stmt|;
name|struct
name|cuse_client
modifier|*
name|pcc
decl_stmt|;
name|struct
name|cuse_command
modifier|*
name|pcmd
decl_stmt|;
name|struct
name|cuse_alloc_info
modifier|*
name|pai
decl_stmt|;
name|struct
name|cuse_create_dev
modifier|*
name|pcd
decl_stmt|;
name|struct
name|cuse_server_dev
modifier|*
name|pcsd
decl_stmt|;
name|struct
name|cuse_data_chunk
modifier|*
name|pchk
decl_stmt|;
name|int
name|n
decl_stmt|;
case|case
name|CUSE_IOCTL_GET_COMMAND
case|:
name|pcmd
operator|=
operator|(
name|void
operator|*
operator|)
name|data
expr_stmt|;
name|cuse_lock
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|pccmd
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pcs
operator|->
name|head
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|cv_wait_sig
argument_list|(
operator|&
name|pcs
operator|->
name|cv
argument_list|,
operator|&
name|cuse_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcs
operator|->
name|is_closing
condition|)
name|error
operator|=
name|ENXIO
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|cuse_unlock
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pcs
operator|->
name|head
argument_list|,
name|pccmd
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|pccmd
operator|->
name|entry
operator|.
name|tqe_prev
operator|=
name|NULL
expr_stmt|;
name|pccmd
operator|->
name|entered
operator|=
name|curthread
expr_stmt|;
operator|*
name|pcmd
operator|=
name|pccmd
operator|->
name|sub
expr_stmt|;
name|cuse_unlock
argument_list|()
expr_stmt|;
break|break;
case|case
name|CUSE_IOCTL_SYNC_COMMAND
case|:
name|cuse_lock
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|pccmd
operator|=
name|cuse_server_find_command
argument_list|(
name|pcs
argument_list|,
name|curthread
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* send sync command */
name|pccmd
operator|->
name|entered
operator|=
name|NULL
expr_stmt|;
name|pccmd
operator|->
name|error
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
name|pccmd
operator|->
name|command
operator|=
name|CUSE_CMD_SYNC
expr_stmt|;
comment|/* signal peer, if any */
name|cv_signal
argument_list|(
operator|&
name|pccmd
operator|->
name|cv
argument_list|)
expr_stmt|;
block|}
name|cuse_unlock
argument_list|()
expr_stmt|;
break|break;
case|case
name|CUSE_IOCTL_ALLOC_UNIT
case|:
name|cuse_lock
argument_list|()
expr_stmt|;
name|n
operator|=
name|cuse_alloc_unit_by_id_locked
argument_list|(
name|pcs
argument_list|,
name|CUSE_ID_DEFAULT
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|cuse_unlock
argument_list|()
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
name|error
operator|=
name|ENOMEM
expr_stmt|;
else|else
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|n
expr_stmt|;
break|break;
case|case
name|CUSE_IOCTL_ALLOC_UNIT_BY_ID
case|:
name|n
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
name|n
operator|=
operator|(
name|n
operator|&
name|CUSE_ID_MASK
operator|)
expr_stmt|;
name|cuse_lock
argument_list|()
expr_stmt|;
name|n
operator|=
name|cuse_alloc_unit_by_id_locked
argument_list|(
name|pcs
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|cuse_unlock
argument_list|()
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
name|error
operator|=
name|ENOMEM
expr_stmt|;
else|else
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|n
expr_stmt|;
break|break;
case|case
name|CUSE_IOCTL_FREE_UNIT
case|:
name|n
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
name|n
operator|=
name|CUSE_ID_DEFAULT
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|cuse_lock
argument_list|()
expr_stmt|;
name|error
operator|=
name|cuse_free_unit_by_id_locked
argument_list|(
name|pcs
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|cuse_unlock
argument_list|()
expr_stmt|;
break|break;
case|case
name|CUSE_IOCTL_FREE_UNIT_BY_ID
case|:
name|n
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
name|cuse_lock
argument_list|()
expr_stmt|;
name|error
operator|=
name|cuse_free_unit_by_id_locked
argument_list|(
name|pcs
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|cuse_unlock
argument_list|()
expr_stmt|;
break|break;
case|case
name|CUSE_IOCTL_ALLOC_MEMORY
case|:
name|pai
operator|=
operator|(
name|void
operator|*
operator|)
name|data
expr_stmt|;
if|if
condition|(
name|pai
operator|->
name|alloc_nr
operator|>=
name|CUSE_ALLOC_UNIT_MAX
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|pai
operator|->
name|page_count
operator|>
name|CUSE_ALLOC_PAGES_MAX
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|cuse_server_alloc_memory
argument_list|(
name|pcs
argument_list|,
operator|&
name|cuse_mem
index|[
name|pai
operator|->
name|alloc_nr
index|]
argument_list|,
name|pai
operator|->
name|page_count
argument_list|)
expr_stmt|;
break|break;
case|case
name|CUSE_IOCTL_FREE_MEMORY
case|:
name|pai
operator|=
operator|(
name|void
operator|*
operator|)
name|data
expr_stmt|;
if|if
condition|(
name|pai
operator|->
name|alloc_nr
operator|>=
name|CUSE_ALLOC_UNIT_MAX
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
comment|/* we trust the character device driver in this case */
name|cuse_lock
argument_list|()
expr_stmt|;
if|if
condition|(
name|cuse_mem
index|[
name|pai
operator|->
name|alloc_nr
index|]
operator|.
name|owner
operator|==
name|pcs
condition|)
block|{
name|cuse_mem
index|[
name|pai
operator|->
name|alloc_nr
index|]
operator|.
name|is_allocated
operator|=
literal|0
expr_stmt|;
name|cuse_mem
index|[
name|pai
operator|->
name|alloc_nr
index|]
operator|.
name|owner
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
name|cuse_unlock
argument_list|()
expr_stmt|;
break|break;
case|case
name|CUSE_IOCTL_GET_SIG
case|:
name|cuse_lock
argument_list|()
expr_stmt|;
name|pccmd
operator|=
name|cuse_server_find_command
argument_list|(
name|pcs
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
if|if
condition|(
name|pccmd
operator|!=
name|NULL
condition|)
block|{
name|n
operator|=
name|pccmd
operator|->
name|got_signal
expr_stmt|;
name|pccmd
operator|->
name|got_signal
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|n
operator|=
literal|0
expr_stmt|;
block|}
name|cuse_unlock
argument_list|()
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|n
expr_stmt|;
break|break;
case|case
name|CUSE_IOCTL_SET_PFH
case|:
name|cuse_lock
argument_list|()
expr_stmt|;
name|pccmd
operator|=
name|cuse_server_find_command
argument_list|(
name|pcs
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
if|if
condition|(
name|pccmd
operator|!=
name|NULL
condition|)
block|{
name|pcc
operator|=
name|pccmd
operator|->
name|client
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|!=
name|CUSE_CMD_MAX
condition|;
name|n
operator|++
control|)
block|{
name|pcc
operator|->
name|cmds
index|[
name|n
index|]
operator|.
name|sub
operator|.
name|per_file_handle
operator|=
operator|*
operator|(
name|uintptr_t
operator|*
operator|)
name|data
expr_stmt|;
block|}
block|}
else|else
block|{
name|error
operator|=
name|ENXIO
expr_stmt|;
block|}
name|cuse_unlock
argument_list|()
expr_stmt|;
break|break;
case|case
name|CUSE_IOCTL_CREATE_DEV
case|:
name|error
operator|=
name|priv_check
argument_list|(
name|curthread
argument_list|,
name|PRIV_DRIVER
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|pcd
operator|=
operator|(
name|void
operator|*
operator|)
name|data
expr_stmt|;
comment|/* filter input */
name|pcd
operator|->
name|devname
index|[
sizeof|sizeof
argument_list|(
name|pcd
operator|->
name|devname
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pcd
operator|->
name|devname
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|cuse_str_filter
argument_list|(
name|pcd
operator|->
name|devname
argument_list|)
expr_stmt|;
name|pcd
operator|->
name|permissions
operator|&=
literal|0777
expr_stmt|;
comment|/* try to allocate a character device */
name|pcsd
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|pcsd
argument_list|)
argument_list|,
name|M_CUSE
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcsd
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|pcsd
operator|->
name|server
operator|=
name|pcs
expr_stmt|;
name|pcsd
operator|->
name|user_dev
operator|=
name|pcd
operator|->
name|dev
expr_stmt|;
name|pcsd
operator|->
name|kern_dev
operator|=
name|make_dev_credf
argument_list|(
name|MAKEDEV_CHECKNAME
argument_list|,
operator|&
name|cuse_client_devsw
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|pcd
operator|->
name|user_id
argument_list|,
name|pcd
operator|->
name|group_id
argument_list|,
name|pcd
operator|->
name|permissions
argument_list|,
literal|"%s"
argument_list|,
name|pcd
operator|->
name|devname
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcsd
operator|->
name|kern_dev
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|pcsd
argument_list|,
name|M_CUSE
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|pcsd
operator|->
name|kern_dev
operator|->
name|si_drv1
operator|=
name|pcsd
expr_stmt|;
name|cuse_lock
argument_list|()
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|pcs
operator|->
name|hdev
argument_list|,
name|pcsd
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|cuse_unlock
argument_list|()
expr_stmt|;
break|break;
case|case
name|CUSE_IOCTL_DESTROY_DEV
case|:
name|error
operator|=
name|priv_check
argument_list|(
name|curthread
argument_list|,
name|PRIV_DRIVER
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|cuse_lock
argument_list|()
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
name|pcsd
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pcs
operator|->
name|hdev
argument_list|)
expr_stmt|;
while|while
condition|(
name|pcsd
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|pcsd
operator|->
name|user_dev
operator|==
operator|*
operator|(
expr|struct
name|cuse_dev
operator|*
operator|*
operator|)
name|data
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pcs
operator|->
name|hdev
argument_list|,
name|pcsd
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|cuse_unlock
argument_list|()
expr_stmt|;
name|cuse_server_free_dev
argument_list|(
name|pcsd
argument_list|)
expr_stmt|;
name|cuse_lock
argument_list|()
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|pcsd
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pcs
operator|->
name|hdev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pcsd
operator|=
name|TAILQ_NEXT
argument_list|(
name|pcsd
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
block|}
name|cuse_unlock
argument_list|()
expr_stmt|;
break|break;
case|case
name|CUSE_IOCTL_WRITE_DATA
case|:
case|case
name|CUSE_IOCTL_READ_DATA
case|:
name|cuse_lock
argument_list|()
expr_stmt|;
name|pchk
operator|=
operator|(
expr|struct
name|cuse_data_chunk
operator|*
operator|)
name|data
expr_stmt|;
name|pccmd
operator|=
name|cuse_server_find_command
argument_list|(
name|pcs
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
if|if
condition|(
name|pccmd
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENXIO
expr_stmt|;
comment|/* invalid request */
block|}
elseif|else
if|if
condition|(
name|pchk
operator|->
name|peer_ptr
operator|<
name|CUSE_BUF_MIN_PTR
condition|)
block|{
name|error
operator|=
name|EFAULT
expr_stmt|;
comment|/* NULL pointer */
block|}
elseif|else
if|if
condition|(
name|pchk
operator|->
name|peer_ptr
operator|<
name|CUSE_BUF_MAX_PTR
condition|)
block|{
name|error
operator|=
name|cuse_server_ioctl_copy_locked
argument_list|(
name|pccmd
argument_list|,
name|pchk
argument_list|,
name|cmd
operator|==
name|CUSE_IOCTL_READ_DATA
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|cuse_server_data_copy_locked
argument_list|(
name|pccmd
argument_list|,
name|pchk
argument_list|,
name|cmd
operator|==
name|CUSE_IOCTL_READ_DATA
argument_list|)
expr_stmt|;
block|}
name|cuse_unlock
argument_list|()
expr_stmt|;
break|break;
case|case
name|CUSE_IOCTL_SELWAKEUP
case|:
name|cuse_lock
argument_list|()
expr_stmt|;
comment|/* 		 * We don't know which direction caused the event. 		 * Wakeup both! 		 */
name|cuse_server_wakeup_all_client_locked
argument_list|(
name|pcs
argument_list|)
expr_stmt|;
name|cuse_unlock
argument_list|()
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ENXIO
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cuse_server_poll
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|events
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
return|return
operator|(
name|events
operator|&
operator|(
name|POLLHUP
operator||
name|POLLPRI
operator||
name|POLLIN
operator||
name|POLLRDNORM
operator||
name|POLLOUT
operator||
name|POLLWRNORM
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cuse_server_mmap
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|vm_ooffset_t
name|offset
parameter_list|,
name|vm_paddr_t
modifier|*
name|paddr
parameter_list|,
name|int
name|nprot
parameter_list|,
name|vm_memattr_t
modifier|*
name|memattr
parameter_list|)
block|{
name|uint32_t
name|page_nr
init|=
name|offset
operator|/
name|PAGE_SIZE
decl_stmt|;
name|uint32_t
name|alloc_nr
init|=
name|page_nr
operator|/
name|CUSE_ALLOC_PAGES_MAX
decl_stmt|;
name|struct
name|cuse_memory
modifier|*
name|mem
decl_stmt|;
name|struct
name|cuse_server
modifier|*
name|pcs
decl_stmt|;
name|uint8_t
modifier|*
name|ptr
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|alloc_nr
operator|>=
name|CUSE_ALLOC_UNIT_MAX
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|error
operator|=
name|cuse_server_get
argument_list|(
operator|&
name|pcs
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|pcs
operator|=
name|NULL
expr_stmt|;
name|cuse_lock
argument_list|()
expr_stmt|;
name|mem
operator|=
operator|&
name|cuse_mem
index|[
name|alloc_nr
index|]
expr_stmt|;
comment|/* try to enforce slight ownership */
if|if
condition|(
operator|(
name|pcs
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|mem
operator|->
name|owner
operator|!=
name|pcs
operator|)
condition|)
block|{
name|cuse_unlock
argument_list|()
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|mem
operator|->
name|virtaddr
operator|==
name|NULL
condition|)
block|{
name|cuse_unlock
argument_list|()
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|mem
operator|->
name|virtaddr
operator|==
name|NBUSY
condition|)
block|{
name|cuse_unlock
argument_list|()
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|page_nr
operator|%=
name|CUSE_ALLOC_PAGES_MAX
expr_stmt|;
if|if
condition|(
name|page_nr
operator|>=
name|mem
operator|->
name|page_count
condition|)
block|{
name|cuse_unlock
argument_list|()
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|ptr
operator|=
name|mem
operator|->
name|virtaddr
operator|+
operator|(
name|page_nr
operator|*
name|PAGE_SIZE
operator|)
expr_stmt|;
name|cuse_unlock
argument_list|()
expr_stmt|;
operator|*
name|paddr
operator|=
name|vtophys
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	CUSE CLIENT PART  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|cuse_client_free
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|cuse_client
modifier|*
name|pcc
init|=
name|arg
decl_stmt|;
name|struct
name|cuse_client_command
modifier|*
name|pccmd
decl_stmt|;
name|struct
name|cuse_server
modifier|*
name|pcs
decl_stmt|;
name|int
name|n
decl_stmt|;
name|cuse_lock
argument_list|()
expr_stmt|;
name|cuse_client_is_closing
argument_list|(
name|pcc
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pcc
operator|->
name|server
operator|->
name|hcli
argument_list|,
name|pcc
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|cuse_unlock
argument_list|()
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|!=
name|CUSE_CMD_MAX
condition|;
name|n
operator|++
control|)
block|{
name|pccmd
operator|=
operator|&
name|pcc
operator|->
name|cmds
index|[
name|n
index|]
expr_stmt|;
name|sx_destroy
argument_list|(
operator|&
name|pccmd
operator|->
name|sx
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|pccmd
operator|->
name|cv
argument_list|)
expr_stmt|;
block|}
name|pcs
operator|=
name|pcc
operator|->
name|server
expr_stmt|;
name|free
argument_list|(
name|pcc
argument_list|,
name|M_CUSE
argument_list|)
expr_stmt|;
comment|/* drop reference on server */
name|cuse_server_free
argument_list|(
name|pcs
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|cuse_client_open
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|fflags
parameter_list|,
name|int
name|devtype
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|cuse_client_command
modifier|*
name|pccmd
decl_stmt|;
name|struct
name|cuse_server_dev
modifier|*
name|pcsd
decl_stmt|;
name|struct
name|cuse_client
modifier|*
name|pcc
decl_stmt|;
name|struct
name|cuse_server
modifier|*
name|pcs
decl_stmt|;
name|struct
name|cuse_dev
modifier|*
name|pcd
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|n
decl_stmt|;
name|cuse_lock
argument_list|()
expr_stmt|;
name|pcsd
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
if|if
condition|(
name|pcsd
operator|!=
name|NULL
condition|)
block|{
name|pcs
operator|=
name|pcsd
operator|->
name|server
expr_stmt|;
name|pcd
operator|=
name|pcsd
operator|->
name|user_dev
expr_stmt|;
comment|/* 		 * Check that the refcount didn't wrap and that the 		 * same process is not both client and server. This 		 * can easily lead to deadlocks when destroying the 		 * CUSE character device nodes: 		 */
name|pcs
operator|->
name|refs
operator|++
expr_stmt|;
if|if
condition|(
name|pcs
operator|->
name|refs
operator|<
literal|0
operator|||
name|pcs
operator|->
name|pid
operator|==
name|curproc
operator|->
name|p_pid
condition|)
block|{
comment|/* overflow or wrong PID */
name|pcs
operator|->
name|refs
operator|--
expr_stmt|;
name|pcsd
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
name|pcs
operator|=
name|NULL
expr_stmt|;
name|pcd
operator|=
name|NULL
expr_stmt|;
block|}
name|cuse_unlock
argument_list|()
expr_stmt|;
if|if
condition|(
name|pcsd
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|pcc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|pcc
argument_list|)
argument_list|,
name|M_CUSE
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcc
operator|==
name|NULL
condition|)
block|{
comment|/* drop reference on server */
name|cuse_server_free
argument_list|(
name|pcs
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|devfs_set_cdevpriv
argument_list|(
name|pcc
argument_list|,
operator|&
name|cuse_client_free
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Cuse: Cannot set cdevpriv.\n"
argument_list|)
expr_stmt|;
comment|/* drop reference on server */
name|cuse_server_free
argument_list|(
name|pcs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pcc
argument_list|,
name|M_CUSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|pcc
operator|->
name|fflags
operator|=
name|fflags
expr_stmt|;
name|pcc
operator|->
name|server_dev
operator|=
name|pcsd
expr_stmt|;
name|pcc
operator|->
name|server
operator|=
name|pcs
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|!=
name|CUSE_CMD_MAX
condition|;
name|n
operator|++
control|)
block|{
name|pccmd
operator|=
operator|&
name|pcc
operator|->
name|cmds
index|[
name|n
index|]
expr_stmt|;
name|pccmd
operator|->
name|sub
operator|.
name|dev
operator|=
name|pcd
expr_stmt|;
name|pccmd
operator|->
name|sub
operator|.
name|command
operator|=
name|n
expr_stmt|;
name|pccmd
operator|->
name|client
operator|=
name|pcc
expr_stmt|;
name|sx_init
argument_list|(
operator|&
name|pccmd
operator|->
name|sx
argument_list|,
literal|"cuse-client-sx"
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|pccmd
operator|->
name|cv
argument_list|,
literal|"cuse-client-cv"
argument_list|)
expr_stmt|;
block|}
name|cuse_lock
argument_list|()
expr_stmt|;
comment|/* cuse_client_free() assumes that the client is listed somewhere! */
comment|/* always enqueue */
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|pcs
operator|->
name|hcli
argument_list|,
name|pcc
argument_list|,
name|entry
argument_list|)
expr_stmt|;
comment|/* check if server is closing */
if|if
condition|(
operator|(
name|pcs
operator|->
name|is_closing
operator|!=
literal|0
operator|)
operator|||
operator|(
name|dev
operator|->
name|si_drv1
operator|==
name|NULL
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
literal|0
expr_stmt|;
block|}
name|cuse_unlock
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|devfs_clear_cdevpriv
argument_list|()
expr_stmt|;
comment|/* XXX bugfix */
return|return
operator|(
name|error
operator|)
return|;
block|}
name|pccmd
operator|=
operator|&
name|pcc
operator|->
name|cmds
index|[
name|CUSE_CMD_OPEN
index|]
expr_stmt|;
name|cuse_cmd_lock
argument_list|(
name|pccmd
argument_list|)
expr_stmt|;
name|cuse_lock
argument_list|()
expr_stmt|;
name|cuse_client_send_command_locked
argument_list|(
name|pccmd
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|pcc
operator|->
name|fflags
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|cuse_client_receive_command_locked
argument_list|(
name|pccmd
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cuse_unlock
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
operator|<
literal|0
condition|)
block|{
name|error
operator|=
name|cuse_convert_error
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
literal|0
expr_stmt|;
block|}
name|cuse_cmd_unlock
argument_list|(
name|pccmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|devfs_clear_cdevpriv
argument_list|()
expr_stmt|;
comment|/* XXX bugfix */
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cuse_client_close
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|fflag
parameter_list|,
name|int
name|devtype
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|cuse_client_command
modifier|*
name|pccmd
decl_stmt|;
name|struct
name|cuse_client
modifier|*
name|pcc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|cuse_client_get
argument_list|(
operator|&
name|pcc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|pccmd
operator|=
operator|&
name|pcc
operator|->
name|cmds
index|[
name|CUSE_CMD_CLOSE
index|]
expr_stmt|;
name|cuse_cmd_lock
argument_list|(
name|pccmd
argument_list|)
expr_stmt|;
name|cuse_lock
argument_list|()
expr_stmt|;
name|cuse_client_send_command_locked
argument_list|(
name|pccmd
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|pcc
operator|->
name|fflags
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|cuse_client_receive_command_locked
argument_list|(
name|pccmd
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cuse_unlock
argument_list|()
expr_stmt|;
name|cuse_cmd_unlock
argument_list|(
name|pccmd
argument_list|)
expr_stmt|;
name|cuse_lock
argument_list|()
expr_stmt|;
name|cuse_client_is_closing
argument_list|(
name|pcc
argument_list|)
expr_stmt|;
name|cuse_unlock
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cuse_client_kqfilter_poll
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|cuse_client
modifier|*
name|pcc
parameter_list|)
block|{
name|int
name|temp
decl_stmt|;
name|cuse_lock
argument_list|()
expr_stmt|;
name|temp
operator|=
operator|(
name|pcc
operator|->
name|cflags
operator|&
operator|(
name|CUSE_CLI_KNOTE_HAS_READ
operator||
name|CUSE_CLI_KNOTE_HAS_WRITE
operator|)
operator|)
expr_stmt|;
name|pcc
operator|->
name|cflags
operator|&=
operator|~
operator|(
name|CUSE_CLI_KNOTE_NEED_READ
operator||
name|CUSE_CLI_KNOTE_NEED_WRITE
operator|)
expr_stmt|;
name|cuse_unlock
argument_list|()
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
literal|0
condition|)
block|{
comment|/* get the latest polling state from the server */
name|temp
operator|=
name|cuse_client_poll
argument_list|(
name|dev
argument_list|,
name|POLLIN
operator||
name|POLLOUT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|&
operator|(
name|POLLIN
operator||
name|POLLOUT
operator|)
condition|)
block|{
name|cuse_lock
argument_list|()
expr_stmt|;
if|if
condition|(
name|temp
operator|&
name|POLLIN
condition|)
name|pcc
operator|->
name|cflags
operator||=
name|CUSE_CLI_KNOTE_NEED_READ
expr_stmt|;
if|if
condition|(
name|temp
operator|&
name|POLLOUT
condition|)
name|pcc
operator|->
name|cflags
operator||=
name|CUSE_CLI_KNOTE_NEED_WRITE
expr_stmt|;
comment|/* make sure the "knote" gets woken up */
name|cuse_server_wakeup_locked
argument_list|(
name|pcc
operator|->
name|server
argument_list|)
expr_stmt|;
name|cuse_unlock
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|cuse_client_read
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
name|struct
name|cuse_client_command
modifier|*
name|pccmd
decl_stmt|;
name|struct
name|cuse_client
modifier|*
name|pcc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|len
decl_stmt|;
name|error
operator|=
name|cuse_client_get
argument_list|(
operator|&
name|pcc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|pccmd
operator|=
operator|&
name|pcc
operator|->
name|cmds
index|[
name|CUSE_CMD_READ
index|]
expr_stmt|;
if|if
condition|(
name|uio
operator|->
name|uio_segflg
operator|!=
name|UIO_USERSPACE
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|uio
operator|->
name|uio_segflg
operator|=
name|UIO_NOCOPY
expr_stmt|;
name|cuse_cmd_lock
argument_list|(
name|pccmd
argument_list|)
expr_stmt|;
while|while
condition|(
name|uio
operator|->
name|uio_resid
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|uio
operator|->
name|uio_iov
operator|->
name|iov_len
operator|>
name|CUSE_LENGTH_MAX
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|len
operator|=
name|uio
operator|->
name|uio_iov
operator|->
name|iov_len
expr_stmt|;
name|cuse_lock
argument_list|()
expr_stmt|;
name|cuse_client_send_command_locked
argument_list|(
name|pccmd
argument_list|,
operator|(
name|uintptr_t
operator|)
name|uio
operator|->
name|uio_iov
operator|->
name|iov_base
argument_list|,
operator|(
name|unsigned
name|long
operator|)
operator|(
name|unsigned
name|int
operator|)
name|len
argument_list|,
name|pcc
operator|->
name|fflags
argument_list|,
name|ioflag
argument_list|)
expr_stmt|;
name|error
operator|=
name|cuse_client_receive_command_locked
argument_list|(
name|pccmd
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cuse_unlock
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
operator|<
literal|0
condition|)
block|{
name|error
operator|=
name|cuse_convert_error
argument_list|(
name|error
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|error
operator|==
name|len
condition|)
block|{
name|error
operator|=
name|uiomove
argument_list|(
name|NULL
argument_list|,
name|error
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
else|else
block|{
name|error
operator|=
name|uiomove
argument_list|(
name|NULL
argument_list|,
name|error
argument_list|,
name|uio
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|cuse_cmd_unlock
argument_list|(
name|pccmd
argument_list|)
expr_stmt|;
name|uio
operator|->
name|uio_segflg
operator|=
name|UIO_USERSPACE
expr_stmt|;
comment|/* restore segment flag */
if|if
condition|(
name|error
operator|==
name|EWOULDBLOCK
condition|)
name|cuse_client_kqfilter_poll
argument_list|(
name|dev
argument_list|,
name|pcc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cuse_client_write
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
name|struct
name|cuse_client_command
modifier|*
name|pccmd
decl_stmt|;
name|struct
name|cuse_client
modifier|*
name|pcc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|len
decl_stmt|;
name|error
operator|=
name|cuse_client_get
argument_list|(
operator|&
name|pcc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|pccmd
operator|=
operator|&
name|pcc
operator|->
name|cmds
index|[
name|CUSE_CMD_WRITE
index|]
expr_stmt|;
if|if
condition|(
name|uio
operator|->
name|uio_segflg
operator|!=
name|UIO_USERSPACE
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|uio
operator|->
name|uio_segflg
operator|=
name|UIO_NOCOPY
expr_stmt|;
name|cuse_cmd_lock
argument_list|(
name|pccmd
argument_list|)
expr_stmt|;
while|while
condition|(
name|uio
operator|->
name|uio_resid
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|uio
operator|->
name|uio_iov
operator|->
name|iov_len
operator|>
name|CUSE_LENGTH_MAX
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|len
operator|=
name|uio
operator|->
name|uio_iov
operator|->
name|iov_len
expr_stmt|;
name|cuse_lock
argument_list|()
expr_stmt|;
name|cuse_client_send_command_locked
argument_list|(
name|pccmd
argument_list|,
operator|(
name|uintptr_t
operator|)
name|uio
operator|->
name|uio_iov
operator|->
name|iov_base
argument_list|,
operator|(
name|unsigned
name|long
operator|)
operator|(
name|unsigned
name|int
operator|)
name|len
argument_list|,
name|pcc
operator|->
name|fflags
argument_list|,
name|ioflag
argument_list|)
expr_stmt|;
name|error
operator|=
name|cuse_client_receive_command_locked
argument_list|(
name|pccmd
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cuse_unlock
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
operator|<
literal|0
condition|)
block|{
name|error
operator|=
name|cuse_convert_error
argument_list|(
name|error
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|error
operator|==
name|len
condition|)
block|{
name|error
operator|=
name|uiomove
argument_list|(
name|NULL
argument_list|,
name|error
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
else|else
block|{
name|error
operator|=
name|uiomove
argument_list|(
name|NULL
argument_list|,
name|error
argument_list|,
name|uio
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|cuse_cmd_unlock
argument_list|(
name|pccmd
argument_list|)
expr_stmt|;
name|uio
operator|->
name|uio_segflg
operator|=
name|UIO_USERSPACE
expr_stmt|;
comment|/* restore segment flag */
if|if
condition|(
name|error
operator|==
name|EWOULDBLOCK
condition|)
name|cuse_client_kqfilter_poll
argument_list|(
name|dev
argument_list|,
name|pcc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|cuse_client_ioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|unsigned
name|long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|fflag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|cuse_client_command
modifier|*
name|pccmd
decl_stmt|;
name|struct
name|cuse_client
modifier|*
name|pcc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|len
decl_stmt|;
name|error
operator|=
name|cuse_client_get
argument_list|(
operator|&
name|pcc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|len
operator|=
name|IOCPARM_LEN
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|CUSE_BUFFER_MAX
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|pccmd
operator|=
operator|&
name|pcc
operator|->
name|cmds
index|[
name|CUSE_CMD_IOCTL
index|]
expr_stmt|;
name|cuse_cmd_lock
argument_list|(
name|pccmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|&
operator|(
name|IOC_IN
operator||
name|IOC_VOID
operator|)
condition|)
name|memcpy
argument_list|(
name|pcc
operator|->
name|ioctl_buffer
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* 	 * When the ioctl-length is zero drivers can pass information 	 * through the data pointer of the ioctl. Make sure this information 	 * is forwarded to the driver. 	 */
name|cuse_lock
argument_list|()
expr_stmt|;
name|cuse_client_send_command_locked
argument_list|(
name|pccmd
argument_list|,
operator|(
name|len
operator|==
literal|0
operator|)
condition|?
operator|*
operator|(
name|long
operator|*
operator|)
name|data
else|:
name|CUSE_BUF_MIN_PTR
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|cmd
argument_list|,
name|pcc
operator|->
name|fflags
argument_list|,
operator|(
name|fflag
operator|&
name|O_NONBLOCK
operator|)
condition|?
name|IO_NDELAY
else|:
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|cuse_client_receive_command_locked
argument_list|(
name|pccmd
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|cuse_unlock
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
operator|<
literal|0
condition|)
block|{
name|error
operator|=
name|cuse_convert_error
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|cmd
operator|&
name|IOC_OUT
condition|)
name|memcpy
argument_list|(
name|data
argument_list|,
name|pcc
operator|->
name|ioctl_buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|cuse_cmd_unlock
argument_list|(
name|pccmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EWOULDBLOCK
condition|)
name|cuse_client_kqfilter_poll
argument_list|(
name|dev
argument_list|,
name|pcc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cuse_client_poll
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|events
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|cuse_client_command
modifier|*
name|pccmd
decl_stmt|;
name|struct
name|cuse_client
modifier|*
name|pcc
decl_stmt|;
name|unsigned
name|long
name|temp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|revents
decl_stmt|;
name|error
operator|=
name|cuse_client_get
argument_list|(
operator|&
name|pcc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|pollnval
goto|;
name|temp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|events
operator|&
operator|(
name|POLLPRI
operator||
name|POLLIN
operator||
name|POLLRDNORM
operator|)
condition|)
name|temp
operator||=
name|CUSE_POLL_READ
expr_stmt|;
if|if
condition|(
name|events
operator|&
operator|(
name|POLLOUT
operator||
name|POLLWRNORM
operator|)
condition|)
name|temp
operator||=
name|CUSE_POLL_WRITE
expr_stmt|;
if|if
condition|(
name|events
operator|&
name|POLLHUP
condition|)
name|temp
operator||=
name|CUSE_POLL_ERROR
expr_stmt|;
name|pccmd
operator|=
operator|&
name|pcc
operator|->
name|cmds
index|[
name|CUSE_CMD_POLL
index|]
expr_stmt|;
name|cuse_cmd_lock
argument_list|(
name|pccmd
argument_list|)
expr_stmt|;
comment|/* Need to selrecord() first to not loose any events. */
if|if
condition|(
name|temp
operator|!=
literal|0
operator|&&
name|td
operator|!=
name|NULL
condition|)
name|selrecord
argument_list|(
name|td
argument_list|,
operator|&
name|pcc
operator|->
name|server
operator|->
name|selinfo
argument_list|)
expr_stmt|;
name|cuse_lock
argument_list|()
expr_stmt|;
name|cuse_client_send_command_locked
argument_list|(
name|pccmd
argument_list|,
literal|0
argument_list|,
name|temp
argument_list|,
name|pcc
operator|->
name|fflags
argument_list|,
name|IO_NDELAY
argument_list|)
expr_stmt|;
name|error
operator|=
name|cuse_client_receive_command_locked
argument_list|(
name|pccmd
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cuse_unlock
argument_list|()
expr_stmt|;
name|cuse_cmd_unlock
argument_list|(
name|pccmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|<
literal|0
condition|)
block|{
goto|goto
name|pollnval
goto|;
block|}
else|else
block|{
name|revents
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|error
operator|&
name|CUSE_POLL_READ
condition|)
name|revents
operator||=
operator|(
name|events
operator|&
operator|(
name|POLLPRI
operator||
name|POLLIN
operator||
name|POLLRDNORM
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|error
operator|&
name|CUSE_POLL_WRITE
condition|)
name|revents
operator||=
operator|(
name|events
operator|&
operator|(
name|POLLOUT
operator||
name|POLLWRNORM
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|error
operator|&
name|CUSE_POLL_ERROR
condition|)
name|revents
operator||=
operator|(
name|events
operator|&
name|POLLHUP
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|revents
operator|)
return|;
name|pollnval
label|:
comment|/* XXX many clients don't understand POLLNVAL */
return|return
operator|(
name|events
operator|&
operator|(
name|POLLHUP
operator||
name|POLLPRI
operator||
name|POLLIN
operator||
name|POLLRDNORM
operator||
name|POLLOUT
operator||
name|POLLWRNORM
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cuse_client_mmap
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|vm_ooffset_t
name|offset
parameter_list|,
name|vm_paddr_t
modifier|*
name|paddr
parameter_list|,
name|int
name|nprot
parameter_list|,
name|vm_memattr_t
modifier|*
name|memattr
parameter_list|)
block|{
name|uint32_t
name|page_nr
init|=
name|offset
operator|/
name|PAGE_SIZE
decl_stmt|;
name|uint32_t
name|alloc_nr
init|=
name|page_nr
operator|/
name|CUSE_ALLOC_PAGES_MAX
decl_stmt|;
name|struct
name|cuse_memory
modifier|*
name|mem
decl_stmt|;
name|struct
name|cuse_server
modifier|*
name|pcs
decl_stmt|;
name|struct
name|cuse_client
modifier|*
name|pcc
decl_stmt|;
name|uint8_t
modifier|*
name|ptr
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|alloc_nr
operator|>=
name|CUSE_ALLOC_UNIT_MAX
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|error
operator|=
name|cuse_client_get
argument_list|(
operator|&
name|pcc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|pcs
operator|=
name|NULL
expr_stmt|;
else|else
name|pcs
operator|=
name|pcc
operator|->
name|server
expr_stmt|;
name|cuse_lock
argument_list|()
expr_stmt|;
name|mem
operator|=
operator|&
name|cuse_mem
index|[
name|alloc_nr
index|]
expr_stmt|;
comment|/* try to enforce slight ownership */
if|if
condition|(
operator|(
name|pcs
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|mem
operator|->
name|owner
operator|!=
name|pcs
operator|)
condition|)
block|{
name|cuse_unlock
argument_list|()
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|mem
operator|->
name|virtaddr
operator|==
name|NULL
condition|)
block|{
name|cuse_unlock
argument_list|()
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|mem
operator|->
name|virtaddr
operator|==
name|NBUSY
condition|)
block|{
name|cuse_unlock
argument_list|()
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|page_nr
operator|%=
name|CUSE_ALLOC_PAGES_MAX
expr_stmt|;
if|if
condition|(
name|page_nr
operator|>=
name|mem
operator|->
name|page_count
condition|)
block|{
name|cuse_unlock
argument_list|()
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|ptr
operator|=
name|mem
operator|->
name|virtaddr
operator|+
operator|(
name|page_nr
operator|*
name|PAGE_SIZE
operator|)
expr_stmt|;
name|cuse_unlock
argument_list|()
expr_stmt|;
operator|*
name|paddr
operator|=
name|vtophys
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cuse_client_kqfilter_read_detach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
block|{
name|struct
name|cuse_client
modifier|*
name|pcc
decl_stmt|;
name|cuse_lock
argument_list|()
expr_stmt|;
name|pcc
operator|=
name|kn
operator|->
name|kn_hook
expr_stmt|;
name|knlist_remove
argument_list|(
operator|&
name|pcc
operator|->
name|server
operator|->
name|selinfo
operator|.
name|si_note
argument_list|,
name|kn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cuse_unlock
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cuse_client_kqfilter_write_detach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
block|{
name|struct
name|cuse_client
modifier|*
name|pcc
decl_stmt|;
name|cuse_lock
argument_list|()
expr_stmt|;
name|pcc
operator|=
name|kn
operator|->
name|kn_hook
expr_stmt|;
name|knlist_remove
argument_list|(
operator|&
name|pcc
operator|->
name|server
operator|->
name|selinfo
operator|.
name|si_note
argument_list|,
name|kn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cuse_unlock
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|cuse_client_kqfilter_read_event
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|long
name|hint
parameter_list|)
block|{
name|struct
name|cuse_client
modifier|*
name|pcc
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|cuse_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|pcc
operator|=
name|kn
operator|->
name|kn_hook
expr_stmt|;
return|return
operator|(
operator|(
name|pcc
operator|->
name|cflags
operator|&
name|CUSE_CLI_KNOTE_NEED_READ
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cuse_client_kqfilter_write_event
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|long
name|hint
parameter_list|)
block|{
name|struct
name|cuse_client
modifier|*
name|pcc
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|cuse_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|pcc
operator|=
name|kn
operator|->
name|kn_hook
expr_stmt|;
return|return
operator|(
operator|(
name|pcc
operator|->
name|cflags
operator|&
name|CUSE_CLI_KNOTE_NEED_WRITE
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cuse_client_kqfilter
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
block|{
name|struct
name|cuse_client
modifier|*
name|pcc
decl_stmt|;
name|struct
name|cuse_server
modifier|*
name|pcs
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|cuse_client_get
argument_list|(
operator|&
name|pcc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|cuse_lock
argument_list|()
expr_stmt|;
name|pcs
operator|=
name|pcc
operator|->
name|server
expr_stmt|;
switch|switch
condition|(
name|kn
operator|->
name|kn_filter
condition|)
block|{
case|case
name|EVFILT_READ
case|:
name|pcc
operator|->
name|cflags
operator||=
name|CUSE_CLI_KNOTE_HAS_READ
expr_stmt|;
name|kn
operator|->
name|kn_hook
operator|=
name|pcc
expr_stmt|;
name|kn
operator|->
name|kn_fop
operator|=
operator|&
name|cuse_client_kqfilter_read_ops
expr_stmt|;
name|knlist_add
argument_list|(
operator|&
name|pcs
operator|->
name|selinfo
operator|.
name|si_note
argument_list|,
name|kn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|EVFILT_WRITE
case|:
name|pcc
operator|->
name|cflags
operator||=
name|CUSE_CLI_KNOTE_HAS_WRITE
expr_stmt|;
name|kn
operator|->
name|kn_hook
operator|=
name|pcc
expr_stmt|;
name|kn
operator|->
name|kn_fop
operator|=
operator|&
name|cuse_client_kqfilter_write_ops
expr_stmt|;
name|knlist_add
argument_list|(
operator|&
name|pcs
operator|->
name|selinfo
operator|.
name|si_note
argument_list|,
name|kn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|cuse_unlock
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|cuse_client_kqfilter_poll
argument_list|(
name|dev
argument_list|,
name|pcc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

