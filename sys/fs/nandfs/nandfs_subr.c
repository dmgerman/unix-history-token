begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2010-2012 Semihalf  * Copyright (c) 2008, 2009 Reinoud Zandijk  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * From: NetBSD: nilfs_subr.c,v 1.4 2009/07/29 17:06:57 reinoud  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/dirent.h>
end_include

begin_include
include|#
directive|include
file|<sys/lockf.h>
end_include

begin_include
include|#
directive|include
file|<sys/libkern.h>
end_include

begin_include
include|#
directive|include
file|<geom/geom.h>
end_include

begin_include
include|#
directive|include
file|<geom/geom_vfs.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<machine/_inttypes.h>
end_include

begin_include
include|#
directive|include
file|"nandfs_mount.h"
end_include

begin_include
include|#
directive|include
file|"nandfs.h"
end_include

begin_include
include|#
directive|include
file|"nandfs_subr.h"
end_include

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_NANDFSMNT
argument_list|,
literal|"nandfs_mount"
argument_list|,
literal|"NANDFS mount"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_NANDFSTEMP
argument_list|,
literal|"nandfs_tmt"
argument_list|,
literal|"NANDFS tmp"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|uma_zone_t
name|nandfs_node_zone
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|nandfs_bdflush
parameter_list|(
name|struct
name|bufobj
modifier|*
name|bo
parameter_list|,
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|nandfs_bufsync
parameter_list|(
name|struct
name|bufobj
modifier|*
name|bo
parameter_list|,
name|int
name|waitfor
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|buf_ops
name|buf_ops_nandfs
init|=
block|{
operator|.
name|bop_name
operator|=
literal|"buf_ops_nandfs"
block|,
operator|.
name|bop_write
operator|=
name|bufwrite
block|,
operator|.
name|bop_strategy
operator|=
name|bufstrategy
block|,
operator|.
name|bop_sync
operator|=
name|nandfs_bufsync
block|,
operator|.
name|bop_bdflush
operator|=
name|nandfs_bdflush
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|nandfs_bufsync
parameter_list|(
name|struct
name|bufobj
modifier|*
name|bo
parameter_list|,
name|int
name|waitfor
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|vp
operator|=
name|bo
operator|->
name|__bo_vnode
expr_stmt|;
name|ASSERT_VOP_LOCKED
argument_list|(
name|vp
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|nandfs_sync_file
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|nandfs_warning
argument_list|(
literal|"%s: cannot flush buffers err:%d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|nandfs_bdflush
parameter_list|(
name|bo
parameter_list|,
name|bp
parameter_list|)
name|struct
name|bufobj
modifier|*
name|bo
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
block|{
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|bo
operator|->
name|bo_dirty
operator|.
name|bv_cnt
operator|<=
operator|(
operator|(
name|dirtybufthresh
operator|*
literal|8
operator|)
operator|/
literal|10
operator|)
condition|)
return|return;
name|vp
operator|=
name|bp
operator|->
name|b_vp
expr_stmt|;
if|if
condition|(
name|NANDFS_SYS_NODE
argument_list|(
name|VTON
argument_list|(
name|vp
argument_list|)
operator|->
name|nn_ino
argument_list|)
condition|)
return|return;
if|if
condition|(
name|NANDFS_IS_INDIRECT
argument_list|(
name|bp
argument_list|)
condition|)
return|return;
name|error
operator|=
name|nandfs_sync_file
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|nandfs_warning
argument_list|(
literal|"%s: cannot flush buffers err:%d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|nandfs_init
parameter_list|(
name|struct
name|vfsconf
modifier|*
name|vfsp
parameter_list|)
block|{
name|nandfs_node_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"nandfs node zone"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nandfs_node
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nandfs_uninit
parameter_list|(
name|struct
name|vfsconf
modifier|*
name|vfsp
parameter_list|)
block|{
name|uma_zdestroy
argument_list|(
name|nandfs_node_zone
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Basic calculators */
end_comment

begin_function
name|uint64_t
name|nandfs_get_segnum_of_block
parameter_list|(
name|struct
name|nandfs_device
modifier|*
name|nandfsdev
parameter_list|,
name|nandfs_daddr_t
name|blocknr
parameter_list|)
block|{
name|uint64_t
name|segnum
decl_stmt|,
name|blks_per_seg
decl_stmt|;
name|MPASS
argument_list|(
name|blocknr
operator|>=
name|nandfsdev
operator|->
name|nd_fsdata
operator|.
name|f_first_data_block
argument_list|)
expr_stmt|;
name|blks_per_seg
operator|=
name|nandfsdev
operator|->
name|nd_fsdata
operator|.
name|f_blocks_per_segment
expr_stmt|;
name|segnum
operator|=
name|blocknr
operator|/
name|blks_per_seg
expr_stmt|;
name|segnum
operator|-=
name|nandfsdev
operator|->
name|nd_fsdata
operator|.
name|f_first_data_block
operator|/
name|blks_per_seg
expr_stmt|;
name|DPRINTF
argument_list|(
name|SYNC
argument_list|,
operator|(
literal|"%s: returning blocknr %jx -> segnum %jx\n"
operator|,
name|__func__
operator|,
name|blocknr
operator|,
name|segnum
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|segnum
operator|)
return|;
block|}
end_function

begin_function
name|void
name|nandfs_get_segment_range
parameter_list|(
name|struct
name|nandfs_device
modifier|*
name|nandfsdev
parameter_list|,
name|uint64_t
name|segnum
parameter_list|,
name|uint64_t
modifier|*
name|seg_start
parameter_list|,
name|uint64_t
modifier|*
name|seg_end
parameter_list|)
block|{
name|uint64_t
name|blks_per_seg
decl_stmt|;
name|blks_per_seg
operator|=
name|nandfsdev
operator|->
name|nd_fsdata
operator|.
name|f_blocks_per_segment
expr_stmt|;
operator|*
name|seg_start
operator|=
name|nandfsdev
operator|->
name|nd_fsdata
operator|.
name|f_first_data_block
operator|+
name|blks_per_seg
operator|*
name|segnum
expr_stmt|;
if|if
condition|(
name|seg_end
operator|!=
name|NULL
condition|)
operator|*
name|seg_end
operator|=
operator|*
name|seg_start
operator|+
name|blks_per_seg
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nandfs_calc_mdt_consts
parameter_list|(
name|struct
name|nandfs_device
modifier|*
name|nandfsdev
parameter_list|,
name|struct
name|nandfs_mdt
modifier|*
name|mdt
parameter_list|,
name|int
name|entry_size
parameter_list|)
block|{
name|uint32_t
name|blocksize
init|=
name|nandfsdev
operator|->
name|nd_blocksize
decl_stmt|;
name|mdt
operator|->
name|entries_per_group
operator|=
name|blocksize
operator|*
literal|8
expr_stmt|;
name|mdt
operator|->
name|entries_per_block
operator|=
name|blocksize
operator|/
name|entry_size
expr_stmt|;
name|mdt
operator|->
name|blocks_per_group
operator|=
operator|(
name|mdt
operator|->
name|entries_per_group
operator|-
literal|1
operator|)
operator|/
name|mdt
operator|->
name|entries_per_block
operator|+
literal|1
operator|+
literal|1
expr_stmt|;
name|mdt
operator|->
name|groups_per_desc_block
operator|=
name|blocksize
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|nandfs_block_group_desc
argument_list|)
expr_stmt|;
name|mdt
operator|->
name|blocks_per_desc_block
operator|=
name|mdt
operator|->
name|groups_per_desc_block
operator|*
name|mdt
operator|->
name|blocks_per_group
operator|+
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|int
name|nandfs_dev_bread
parameter_list|(
name|struct
name|nandfs_device
modifier|*
name|nandfsdev
parameter_list|,
name|nandfs_lbn_t
name|blocknr
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|buf
modifier|*
modifier|*
name|bpp
parameter_list|)
block|{
name|int
name|blk2dev
init|=
name|nandfsdev
operator|->
name|nd_blocksize
operator|/
name|DEV_BSIZE
decl_stmt|;
name|int
name|error
decl_stmt|;
name|DPRINTF
argument_list|(
name|BLOCK
argument_list|,
operator|(
literal|"%s: read from block %jx vp %p\n"
operator|,
name|__func__
operator|,
name|blocknr
operator|*
name|blk2dev
operator|,
name|nandfsdev
operator|->
name|nd_devvp
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|bread
argument_list|(
name|nandfsdev
operator|->
name|nd_devvp
argument_list|,
name|blocknr
operator|*
name|blk2dev
argument_list|,
name|nandfsdev
operator|->
name|nd_blocksize
argument_list|,
name|NOCRED
argument_list|,
name|bpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|nandfs_error
argument_list|(
literal|"%s: cannot read from device - blk:%jx\n"
argument_list|,
name|__func__
argument_list|,
name|blocknr
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Read on a node */
end_comment

begin_function
name|int
name|nandfs_bread
parameter_list|(
name|struct
name|nandfs_node
modifier|*
name|node
parameter_list|,
name|nandfs_lbn_t
name|blocknr
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|buf
modifier|*
modifier|*
name|bpp
parameter_list|)
block|{
name|nandfs_daddr_t
name|vblk
decl_stmt|;
name|int
name|error
decl_stmt|;
name|DPRINTF
argument_list|(
name|BLOCK
argument_list|,
operator|(
literal|"%s: vp:%p lbn:%#jx\n"
operator|,
name|__func__
operator|,
name|NTOV
argument_list|(
name|node
argument_list|)
operator|,
name|blocknr
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|bread
argument_list|(
name|NTOV
argument_list|(
name|node
argument_list|)
argument_list|,
name|blocknr
argument_list|,
name|node
operator|->
name|nn_nandfsdev
operator|->
name|nd_blocksize
argument_list|,
name|cred
argument_list|,
name|bpp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: vp:%p lbn:%#jx err:%d\n"
operator|,
name|__func__
operator|,
name|NTOV
argument_list|(
name|node
argument_list|)
operator|,
name|blocknr
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nandfs_vblk_get
argument_list|(
operator|*
name|bpp
argument_list|)
operator|&&
operator|(
operator|(
operator|*
name|bpp
operator|)
operator|->
name|b_flags
operator|&
name|B_CACHE
operator|)
operator|&&
name|node
operator|->
name|nn_ino
operator|!=
name|NANDFS_DAT_INO
condition|)
block|{
name|nandfs_bmap_lookup
argument_list|(
name|node
argument_list|,
name|blocknr
argument_list|,
operator|&
name|vblk
argument_list|)
expr_stmt|;
name|nandfs_vblk_set
argument_list|(
operator|*
name|bpp
argument_list|,
name|vblk
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nandfs_bread_meta
parameter_list|(
name|struct
name|nandfs_node
modifier|*
name|node
parameter_list|,
name|nandfs_lbn_t
name|blocknr
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|buf
modifier|*
modifier|*
name|bpp
parameter_list|)
block|{
name|nandfs_daddr_t
name|vblk
decl_stmt|;
name|int
name|error
decl_stmt|;
name|DPRINTF
argument_list|(
name|BLOCK
argument_list|,
operator|(
literal|"%s: vp:%p lbn:%#jx\n"
operator|,
name|__func__
operator|,
name|NTOV
argument_list|(
name|node
argument_list|)
operator|,
name|blocknr
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|bread
argument_list|(
name|NTOV
argument_list|(
name|node
argument_list|)
argument_list|,
name|blocknr
argument_list|,
name|node
operator|->
name|nn_nandfsdev
operator|->
name|nd_blocksize
argument_list|,
name|cred
argument_list|,
name|bpp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: vp:%p lbn:%#jx err:%d\n"
operator|,
name|__func__
operator|,
name|NTOV
argument_list|(
name|node
argument_list|)
operator|,
name|blocknr
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nandfs_vblk_get
argument_list|(
operator|*
name|bpp
argument_list|)
operator|&&
operator|(
operator|(
operator|*
name|bpp
operator|)
operator|->
name|b_flags
operator|&
name|B_CACHE
operator|)
operator|&&
name|node
operator|->
name|nn_ino
operator|!=
name|NANDFS_DAT_INO
condition|)
block|{
name|nandfs_bmap_lookup
argument_list|(
name|node
argument_list|,
name|blocknr
argument_list|,
operator|&
name|vblk
argument_list|)
expr_stmt|;
name|nandfs_vblk_set
argument_list|(
operator|*
name|bpp
argument_list|,
name|vblk
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nandfs_bdestroy
parameter_list|(
name|struct
name|nandfs_node
modifier|*
name|node
parameter_list|,
name|nandfs_daddr_t
name|vblk
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|!
name|NANDFS_SYS_NODE
argument_list|(
name|node
operator|->
name|nn_ino
argument_list|)
condition|)
name|NANDFS_WRITEASSERT
argument_list|(
name|node
operator|->
name|nn_nandfsdev
argument_list|)
expr_stmt|;
name|error
operator|=
name|nandfs_vblock_end
argument_list|(
name|node
operator|->
name|nn_nandfsdev
argument_list|,
name|vblk
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|nandfs_error
argument_list|(
literal|"%s: ending vblk: %jx failed\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|uintmax_t
operator|)
name|vblk
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|node
operator|->
name|nn_inode
operator|.
name|i_blocks
operator|--
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nandfs_bcreate
parameter_list|(
name|struct
name|nandfs_node
modifier|*
name|node
parameter_list|,
name|nandfs_lbn_t
name|blocknr
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|buf
modifier|*
modifier|*
name|bpp
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|ASSERT_VOP_LOCKED
argument_list|(
name|NTOV
argument_list|(
name|node
argument_list|)
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NANDFS_SYS_NODE
argument_list|(
name|node
operator|->
name|nn_ino
argument_list|)
condition|)
name|NANDFS_WRITEASSERT
argument_list|(
name|node
operator|->
name|nn_nandfsdev
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|BLOCK
argument_list|,
operator|(
literal|"%s: vp:%p lbn:%#jx\n"
operator|,
name|__func__
operator|,
name|NTOV
argument_list|(
name|node
argument_list|)
operator|,
name|blocknr
operator|)
argument_list|)
expr_stmt|;
operator|*
name|bpp
operator|=
name|getblk
argument_list|(
name|NTOV
argument_list|(
name|node
argument_list|)
argument_list|,
name|blocknr
argument_list|,
name|node
operator|->
name|nn_nandfsdev
operator|->
name|nd_blocksize
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
operator|*
name|bpp
operator|)
argument_list|,
operator|(
literal|"%s: vp:%p lbn:%#jx\n"
operator|,
name|__func__
operator|,
name|NTOV
argument_list|(
name|node
argument_list|)
operator|,
name|blocknr
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|bpp
condition|)
block|{
name|vfs_bio_clrbuf
argument_list|(
operator|*
name|bpp
argument_list|)
expr_stmt|;
operator|(
operator|*
name|bpp
operator|)
operator|->
name|b_blkno
operator|=
operator|~
operator|(
literal|0
operator|)
expr_stmt|;
comment|/* To avoid VOP_BMAP in bdwrite */
name|error
operator|=
name|nandfs_bmap_insert_block
argument_list|(
name|node
argument_list|,
name|blocknr
argument_list|,
operator|*
name|bpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|nandfs_warning
argument_list|(
literal|"%s: failed bmap insert node:%p"
literal|" blk:%jx\n"
argument_list|,
name|__func__
argument_list|,
name|node
argument_list|,
name|blocknr
argument_list|)
expr_stmt|;
name|brelse
argument_list|(
operator|*
name|bpp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|node
operator|->
name|nn_inode
operator|.
name|i_blocks
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nandfs_bcreate_meta
parameter_list|(
name|struct
name|nandfs_node
modifier|*
name|node
parameter_list|,
name|nandfs_lbn_t
name|blocknr
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|buf
modifier|*
modifier|*
name|bpp
parameter_list|)
block|{
name|struct
name|nandfs_device
modifier|*
name|fsdev
decl_stmt|;
name|nandfs_daddr_t
name|vblk
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ASSERT_VOP_LOCKED
argument_list|(
name|NTOV
argument_list|(
name|node
argument_list|)
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|NANDFS_WRITEASSERT
argument_list|(
name|node
operator|->
name|nn_nandfsdev
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|BLOCK
argument_list|,
operator|(
literal|"%s: vp:%p lbn:%#jx\n"
operator|,
name|__func__
operator|,
name|NTOV
argument_list|(
name|node
argument_list|)
operator|,
name|blocknr
operator|)
argument_list|)
expr_stmt|;
name|fsdev
operator|=
name|node
operator|->
name|nn_nandfsdev
expr_stmt|;
operator|*
name|bpp
operator|=
name|getblk
argument_list|(
name|NTOV
argument_list|(
name|node
argument_list|)
argument_list|,
name|blocknr
argument_list|,
name|node
operator|->
name|nn_nandfsdev
operator|->
name|nd_blocksize
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
operator|*
name|bpp
operator|)
argument_list|,
operator|(
literal|"%s: vp:%p lbn:%#jx\n"
operator|,
name|__func__
operator|,
name|NTOV
argument_list|(
name|node
argument_list|)
operator|,
name|blocknr
operator|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
operator|*
name|bpp
operator|)
operator|->
name|b_data
argument_list|,
literal|0
argument_list|,
name|fsdev
operator|->
name|nd_blocksize
argument_list|)
expr_stmt|;
name|vfs_bio_clrbuf
argument_list|(
operator|*
name|bpp
argument_list|)
expr_stmt|;
operator|(
operator|*
name|bpp
operator|)
operator|->
name|b_blkno
operator|=
operator|~
operator|(
literal|0
operator|)
expr_stmt|;
comment|/* To avoid VOP_BMAP in bdwrite */
name|nandfs_buf_set
argument_list|(
operator|*
name|bpp
argument_list|,
name|NANDFS_VBLK_ASSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|nn_ino
operator|!=
name|NANDFS_DAT_INO
condition|)
block|{
name|error
operator|=
name|nandfs_vblock_alloc
argument_list|(
name|fsdev
argument_list|,
operator|&
name|vblk
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|nandfs_buf_clear
argument_list|(
operator|*
name|bpp
argument_list|,
name|NANDFS_VBLK_ASSIGNED
argument_list|)
expr_stmt|;
name|brelse
argument_list|(
operator|*
name|bpp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
else|else
name|vblk
operator|=
name|fsdev
operator|->
name|nd_fakevblk
operator|++
expr_stmt|;
name|nandfs_vblk_set
argument_list|(
operator|*
name|bpp
argument_list|,
name|vblk
argument_list|)
expr_stmt|;
name|nandfs_bmap_insert_block
argument_list|(
name|node
argument_list|,
name|blocknr
argument_list|,
operator|*
name|bpp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Translate index to a file block number and an entry */
end_comment

begin_function
name|void
name|nandfs_mdt_trans
parameter_list|(
name|struct
name|nandfs_mdt
modifier|*
name|mdt
parameter_list|,
name|uint64_t
name|index
parameter_list|,
name|nandfs_lbn_t
modifier|*
name|blocknr
parameter_list|,
name|uint32_t
modifier|*
name|entry_in_block
parameter_list|)
block|{
name|uint64_t
name|blknr
decl_stmt|;
name|uint64_t
name|group
decl_stmt|,
name|group_offset
decl_stmt|,
name|blocknr_in_group
decl_stmt|;
name|uint64_t
name|desc_block
decl_stmt|,
name|desc_offset
decl_stmt|;
comment|/* Calculate our offset in the file */
name|group
operator|=
name|index
operator|/
name|mdt
operator|->
name|entries_per_group
expr_stmt|;
name|group_offset
operator|=
name|index
operator|%
name|mdt
operator|->
name|entries_per_group
expr_stmt|;
name|desc_block
operator|=
name|group
operator|/
name|mdt
operator|->
name|groups_per_desc_block
expr_stmt|;
name|desc_offset
operator|=
name|group
operator|%
name|mdt
operator|->
name|groups_per_desc_block
expr_stmt|;
name|blocknr_in_group
operator|=
name|group_offset
operator|/
name|mdt
operator|->
name|entries_per_block
expr_stmt|;
comment|/* To descgroup offset */
name|blknr
operator|=
literal|1
operator|+
name|desc_block
operator|*
name|mdt
operator|->
name|blocks_per_desc_block
expr_stmt|;
comment|/* To group offset */
name|blknr
operator|+=
name|desc_offset
operator|*
name|mdt
operator|->
name|blocks_per_group
expr_stmt|;
comment|/* To actual file block */
name|blknr
operator|+=
literal|1
operator|+
name|blocknr_in_group
expr_stmt|;
operator|*
name|blocknr
operator|=
name|blknr
expr_stmt|;
operator|*
name|entry_in_block
operator|=
name|group_offset
operator|%
name|mdt
operator|->
name|entries_per_block
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nandfs_mdt_trans_blk
parameter_list|(
name|struct
name|nandfs_mdt
modifier|*
name|mdt
parameter_list|,
name|uint64_t
name|index
parameter_list|,
name|uint64_t
modifier|*
name|desc
parameter_list|,
name|uint64_t
modifier|*
name|bitmap
parameter_list|,
name|nandfs_lbn_t
modifier|*
name|blocknr
parameter_list|,
name|uint32_t
modifier|*
name|entry_in_block
parameter_list|)
block|{
name|uint64_t
name|blknr
decl_stmt|;
name|uint64_t
name|group
decl_stmt|,
name|group_offset
decl_stmt|,
name|blocknr_in_group
decl_stmt|;
name|uint64_t
name|desc_block
decl_stmt|,
name|desc_offset
decl_stmt|;
comment|/* Calculate our offset in the file */
name|group
operator|=
name|index
operator|/
name|mdt
operator|->
name|entries_per_group
expr_stmt|;
name|group_offset
operator|=
name|index
operator|%
name|mdt
operator|->
name|entries_per_group
expr_stmt|;
name|desc_block
operator|=
name|group
operator|/
name|mdt
operator|->
name|groups_per_desc_block
expr_stmt|;
name|desc_offset
operator|=
name|group
operator|%
name|mdt
operator|->
name|groups_per_desc_block
expr_stmt|;
name|blocknr_in_group
operator|=
name|group_offset
operator|/
name|mdt
operator|->
name|entries_per_block
expr_stmt|;
comment|/* To descgroup offset */
operator|*
name|desc
operator|=
name|desc_block
operator|*
name|mdt
operator|->
name|blocks_per_desc_block
expr_stmt|;
name|blknr
operator|=
literal|1
operator|+
name|desc_block
operator|*
name|mdt
operator|->
name|blocks_per_desc_block
expr_stmt|;
comment|/* To group offset */
name|blknr
operator|+=
name|desc_offset
operator|*
name|mdt
operator|->
name|blocks_per_group
expr_stmt|;
operator|*
name|bitmap
operator|=
name|blknr
expr_stmt|;
comment|/* To actual file block */
name|blknr
operator|+=
literal|1
operator|+
name|blocknr_in_group
expr_stmt|;
operator|*
name|blocknr
operator|=
name|blknr
expr_stmt|;
operator|*
name|entry_in_block
operator|=
name|group_offset
operator|%
name|mdt
operator|->
name|entries_per_block
expr_stmt|;
name|DPRINTF
argument_list|(
name|ALLOC
argument_list|,
operator|(
literal|"%s: desc_buf: %jx bitmap_buf: %jx entry_buf: %jx entry: %x\n"
operator|,
name|__func__
operator|,
operator|(
name|uintmax_t
operator|)
operator|*
name|desc
operator|,
operator|(
name|uintmax_t
operator|)
operator|*
name|bitmap
operator|,
operator|(
name|uintmax_t
operator|)
operator|*
name|blocknr
operator|,
operator|*
name|entry_in_block
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|nandfs_vtop
parameter_list|(
name|struct
name|nandfs_node
modifier|*
name|node
parameter_list|,
name|nandfs_daddr_t
name|vblocknr
parameter_list|,
name|nandfs_daddr_t
modifier|*
name|pblocknr
parameter_list|)
block|{
name|struct
name|nandfs_node
modifier|*
name|dat_node
decl_stmt|;
name|struct
name|nandfs_dat_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|nandfs_lbn_t
name|ldatblknr
decl_stmt|;
name|uint32_t
name|entry_in_block
decl_stmt|;
name|int
name|locked
decl_stmt|,
name|error
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|nn_ino
operator|==
name|NANDFS_DAT_INO
operator|||
name|node
operator|->
name|nn_ino
operator|==
name|NANDFS_GC_INO
condition|)
block|{
operator|*
name|pblocknr
operator|=
name|vblocknr
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* only translate valid vblocknrs */
if|if
condition|(
name|vblocknr
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|dat_node
operator|=
name|node
operator|->
name|nn_nandfsdev
operator|->
name|nd_dat_node
expr_stmt|;
name|nandfs_mdt_trans
argument_list|(
operator|&
name|node
operator|->
name|nn_nandfsdev
operator|->
name|nd_dat_mdt
argument_list|,
name|vblocknr
argument_list|,
operator|&
name|ldatblknr
argument_list|,
operator|&
name|entry_in_block
argument_list|)
expr_stmt|;
name|locked
operator|=
name|NANDFS_VOP_ISLOCKED
argument_list|(
name|NTOV
argument_list|(
name|dat_node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|locked
condition|)
name|VOP_LOCK
argument_list|(
name|NTOV
argument_list|(
name|dat_node
argument_list|)
argument_list|,
name|LK_SHARED
argument_list|)
expr_stmt|;
name|error
operator|=
name|nandfs_bread
argument_list|(
name|dat_node
argument_list|,
name|ldatblknr
argument_list|,
name|NOCRED
argument_list|,
literal|0
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|DPRINTF
argument_list|(
name|TRANSLATE
argument_list|,
operator|(
literal|"vtop: can't read in DAT block %#jx!\n"
operator|,
operator|(
name|uintmax_t
operator|)
name|ldatblknr
operator|)
argument_list|)
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|NTOV
argument_list|(
name|dat_node
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Get our translation */
name|entry
operator|=
operator|(
operator|(
expr|struct
name|nandfs_dat_entry
operator|*
operator|)
name|bp
operator|->
name|b_data
operator|)
operator|+
name|entry_in_block
expr_stmt|;
name|DPRINTF
argument_list|(
argument|TRANSLATE
argument_list|,
argument|(
literal|"\tentry %p data %p entry_in_block %x\n"
argument|, 	    entry, bp->b_data, entry_in_block)
argument_list|)
name|DPRINTF
argument_list|(
name|TRANSLATE
argument_list|,
operator|(
literal|"\tvblk %#jx -> %#jx for cp [%#jx-%#jx]\n"
operator|,
operator|(
name|uintmax_t
operator|)
name|vblocknr
operator|,
operator|(
name|uintmax_t
operator|)
name|entry
operator|->
name|de_blocknr
operator|,
operator|(
name|uintmax_t
operator|)
name|entry
operator|->
name|de_start
operator|,
operator|(
name|uintmax_t
operator|)
name|entry
operator|->
name|de_end
operator|)
argument_list|)
expr_stmt|;
operator|*
name|pblocknr
operator|=
name|entry
operator|->
name|de_blocknr
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|locked
condition|)
name|VOP_UNLOCK
argument_list|(
name|NTOV
argument_list|(
name|dat_node
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
operator|*
name|pblocknr
operator|>=
name|node
operator|->
name|nn_nandfsdev
operator|->
name|nd_fsdata
operator|.
name|f_first_data_block
operator|||
operator|*
name|pblocknr
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nandfs_segsum_valid
parameter_list|(
name|struct
name|nandfs_segment_summary
modifier|*
name|segsum
parameter_list|)
block|{
return|return
operator|(
name|segsum
operator|->
name|ss_magic
operator|==
name|NANDFS_SEGSUM_MAGIC
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nandfs_load_segsum
parameter_list|(
name|struct
name|nandfs_device
modifier|*
name|fsdev
parameter_list|,
name|nandfs_daddr_t
name|blocknr
parameter_list|,
name|struct
name|nandfs_segment_summary
modifier|*
name|segsum
parameter_list|)
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|DPRINTF
argument_list|(
name|VOLUMES
argument_list|,
operator|(
literal|"nandfs: try segsum at block %jx\n"
operator|,
operator|(
name|uintmax_t
operator|)
name|blocknr
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|nandfs_dev_bread
argument_list|(
name|fsdev
argument_list|,
name|blocknr
argument_list|,
name|NOCRED
argument_list|,
literal|0
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|memcpy
argument_list|(
name|segsum
argument_list|,
name|bp
operator|->
name|b_data
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nandfs_segment_summary
argument_list|)
argument_list|)
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nandfs_segsum_valid
argument_list|(
name|segsum
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
name|VOLUMES
argument_list|,
operator|(
literal|"%s: bad magic pseg:%jx\n"
operator|,
name|__func__
operator|,
name|blocknr
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nandfs_load_super_root
parameter_list|(
name|struct
name|nandfs_device
modifier|*
name|nandfsdev
parameter_list|,
name|struct
name|nandfs_segment_summary
modifier|*
name|segsum
parameter_list|,
name|uint64_t
name|pseg
parameter_list|)
block|{
name|struct
name|nandfs_super_root
name|super_root
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|uint64_t
name|blocknr
decl_stmt|;
name|uint32_t
name|super_root_crc
decl_stmt|,
name|comp_crc
decl_stmt|;
name|int
name|off
decl_stmt|,
name|error
decl_stmt|;
comment|/* Check if there is a superroot */
if|if
condition|(
operator|(
name|segsum
operator|->
name|ss_flags
operator|&
name|NANDFS_SS_SR
operator|)
operator|==
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|VOLUMES
argument_list|,
operator|(
literal|"%s: no super root in pseg:%jx\n"
operator|,
name|__func__
operator|,
name|pseg
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
comment|/* Get our super root, located at the end of the pseg */
name|blocknr
operator|=
name|pseg
operator|+
name|segsum
operator|->
name|ss_nblocks
operator|-
literal|1
expr_stmt|;
name|DPRINTF
argument_list|(
name|VOLUMES
argument_list|,
operator|(
literal|"%s: try at %#jx\n"
operator|,
name|__func__
operator|,
operator|(
name|uintmax_t
operator|)
name|blocknr
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|nandfs_dev_bread
argument_list|(
name|nandfsdev
argument_list|,
name|blocknr
argument_list|,
name|NOCRED
argument_list|,
literal|0
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|memcpy
argument_list|(
operator|&
name|super_root
argument_list|,
name|bp
operator|->
name|b_data
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nandfs_super_root
argument_list|)
argument_list|)
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* Check super root CRC */
name|super_root_crc
operator|=
name|super_root
operator|.
name|sr_sum
expr_stmt|;
name|off
operator|=
sizeof|sizeof
argument_list|(
name|super_root
operator|.
name|sr_sum
argument_list|)
expr_stmt|;
name|comp_crc
operator|=
name|crc32
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|super_root
operator|+
name|off
argument_list|,
name|NANDFS_SR_BYTES
operator|-
name|off
argument_list|)
expr_stmt|;
if|if
condition|(
name|super_root_crc
operator|!=
name|comp_crc
condition|)
block|{
name|DPRINTF
argument_list|(
name|VOLUMES
argument_list|,
operator|(
literal|"%s: invalid crc:%#x [expect:%#x]\n"
operator|,
name|__func__
operator|,
name|super_root_crc
operator|,
name|comp_crc
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|nandfsdev
operator|->
name|nd_super_root
operator|=
name|super_root
expr_stmt|;
name|DPRINTF
argument_list|(
name|VOLUMES
argument_list|,
operator|(
literal|"%s: got valid superroot\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Search for the last super root recorded.  */
end_comment

begin_function
name|int
name|nandfs_search_super_root
parameter_list|(
name|struct
name|nandfs_device
modifier|*
name|nandfsdev
parameter_list|)
block|{
name|struct
name|nandfs_super_block
modifier|*
name|super
decl_stmt|;
name|struct
name|nandfs_segment_summary
name|segsum
decl_stmt|;
name|uint64_t
name|seg_start
decl_stmt|,
name|seg_end
decl_stmt|,
name|cno
decl_stmt|,
name|seq
decl_stmt|,
name|create
decl_stmt|,
name|pseg
decl_stmt|;
name|uint64_t
name|segnum
decl_stmt|;
name|int
name|error
decl_stmt|,
name|found
decl_stmt|;
name|error
operator|=
name|found
operator|=
literal|0
expr_stmt|;
comment|/* Search for last super root */
name|pseg
operator|=
name|nandfsdev
operator|->
name|nd_super
operator|.
name|s_last_pseg
expr_stmt|;
name|segnum
operator|=
name|nandfs_get_segnum_of_block
argument_list|(
name|nandfsdev
argument_list|,
name|pseg
argument_list|)
expr_stmt|;
name|cno
operator|=
name|nandfsdev
operator|->
name|nd_super
operator|.
name|s_last_cno
expr_stmt|;
name|create
operator|=
name|seq
operator|=
literal|0
expr_stmt|;
name|DPRINTF
argument_list|(
name|VOLUMES
argument_list|,
operator|(
literal|"%s: start in pseg %#jx\n"
operator|,
name|__func__
operator|,
operator|(
name|uintmax_t
operator|)
name|pseg
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|error
operator|=
name|nandfs_load_segsum
argument_list|(
name|nandfsdev
argument_list|,
name|pseg
argument_list|,
operator|&
name|segsum
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
if|if
condition|(
name|segsum
operator|.
name|ss_seq
operator|<
name|seq
operator|||
name|segsum
operator|.
name|ss_create
operator|<
name|create
condition|)
break|break;
comment|/* Try to load super root */
if|if
condition|(
name|segsum
operator|.
name|ss_flags
operator|&
name|NANDFS_SS_SR
condition|)
block|{
name|error
operator|=
name|nandfs_load_super_root
argument_list|(
name|nandfsdev
argument_list|,
operator|&
name|segsum
argument_list|,
name|pseg
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
comment|/* confused */
name|found
operator|=
literal|1
expr_stmt|;
name|super
operator|=
operator|&
name|nandfsdev
operator|->
name|nd_super
expr_stmt|;
name|nandfsdev
operator|->
name|nd_last_segsum
operator|=
name|segsum
expr_stmt|;
name|super
operator|->
name|s_last_pseg
operator|=
name|pseg
expr_stmt|;
name|super
operator|->
name|s_last_cno
operator|=
name|cno
operator|++
expr_stmt|;
name|super
operator|->
name|s_last_seq
operator|=
name|segsum
operator|.
name|ss_seq
expr_stmt|;
name|super
operator|->
name|s_state
operator|=
name|NANDFS_VALID_FS
expr_stmt|;
name|seq
operator|=
name|segsum
operator|.
name|ss_seq
expr_stmt|;
name|create
operator|=
name|segsum
operator|.
name|ss_create
expr_stmt|;
block|}
else|else
block|{
name|seq
operator|=
name|segsum
operator|.
name|ss_seq
expr_stmt|;
name|create
operator|=
name|segsum
operator|.
name|ss_create
expr_stmt|;
block|}
comment|/* Calculate next partial segment location */
name|pseg
operator|+=
name|segsum
operator|.
name|ss_nblocks
expr_stmt|;
name|DPRINTF
argument_list|(
name|VOLUMES
argument_list|,
operator|(
literal|"%s: next partial seg is %jx\n"
operator|,
name|__func__
operator|,
operator|(
name|uintmax_t
operator|)
name|pseg
operator|)
argument_list|)
expr_stmt|;
comment|/* Did we reach the end of the segment? if so, go to the next */
name|nandfs_get_segment_range
argument_list|(
name|nandfsdev
argument_list|,
name|segnum
argument_list|,
operator|&
name|seg_start
argument_list|,
operator|&
name|seg_end
argument_list|)
expr_stmt|;
if|if
condition|(
name|pseg
operator|>=
name|seg_end
condition|)
block|{
name|pseg
operator|=
name|segsum
operator|.
name|ss_next
expr_stmt|;
name|DPRINTF
argument_list|(
name|VOLUMES
argument_list|,
operator|(
literal|" partial seg oor next is %jx[%jx - %jx]\n"
operator|,
operator|(
name|uintmax_t
operator|)
name|pseg
operator|,
operator|(
name|uintmax_t
operator|)
name|seg_start
operator|,
operator|(
name|uintmax_t
operator|)
name|seg_end
operator|)
argument_list|)
expr_stmt|;
block|}
name|segnum
operator|=
name|nandfs_get_segnum_of_block
argument_list|(
name|nandfsdev
argument_list|,
name|pseg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|&&
operator|!
name|found
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nandfs_get_node_raw
parameter_list|(
name|struct
name|nandfs_device
modifier|*
name|nandfsdev
parameter_list|,
name|struct
name|nandfsmount
modifier|*
name|nmp
parameter_list|,
name|uint64_t
name|ino
parameter_list|,
name|struct
name|nandfs_inode
modifier|*
name|inode
parameter_list|,
name|struct
name|nandfs_node
modifier|*
modifier|*
name|nodep
parameter_list|)
block|{
name|struct
name|nandfs_node
modifier|*
name|node
decl_stmt|;
name|struct
name|vnode
modifier|*
name|nvp
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|int
name|error
decl_stmt|;
operator|*
name|nodep
operator|=
name|NULL
expr_stmt|;
comment|/* Associate with mountpoint if present */
if|if
condition|(
name|nmp
condition|)
block|{
name|mp
operator|=
name|nmp
operator|->
name|nm_vfs_mountp
expr_stmt|;
name|error
operator|=
name|getnewvnode
argument_list|(
literal|"nandfs"
argument_list|,
name|mp
argument_list|,
operator|&
name|nandfs_vnodeops
argument_list|,
operator|&
name|nvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
else|else
block|{
name|mp
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|getnewvnode
argument_list|(
literal|"snandfs"
argument_list|,
name|mp
argument_list|,
operator|&
name|nandfs_system_vnodeops
argument_list|,
operator|&
name|nvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
if|if
condition|(
name|mp
condition|)
name|NANDFS_WRITELOCK
argument_list|(
name|nandfsdev
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|IFILE
argument_list|,
operator|(
literal|"%s: ino: %#jx -> vp: %p\n"
operator|,
name|__func__
operator|,
operator|(
name|uintmax_t
operator|)
name|ino
operator|,
name|nvp
operator|)
argument_list|)
expr_stmt|;
comment|/* Lock node */
name|lockmgr
argument_list|(
name|nvp
operator|->
name|v_vnlock
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
condition|)
block|{
name|error
operator|=
name|insmntque
argument_list|(
name|nvp
argument_list|,
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
operator|*
name|nodep
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
name|node
operator|=
name|uma_zalloc
argument_list|(
name|nandfs_node_zone
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
comment|/* Crosslink */
name|node
operator|->
name|nn_vnode
operator|=
name|nvp
expr_stmt|;
name|nvp
operator|->
name|v_bufobj
operator|.
name|bo_ops
operator|=
operator|&
name|buf_ops_nandfs
expr_stmt|;
name|node
operator|->
name|nn_nmp
operator|=
name|nmp
expr_stmt|;
name|node
operator|->
name|nn_nandfsdev
operator|=
name|nandfsdev
expr_stmt|;
name|nvp
operator|->
name|v_data
operator|=
name|node
expr_stmt|;
comment|/* Initiase NANDFS node */
name|node
operator|->
name|nn_ino
operator|=
name|ino
expr_stmt|;
if|if
condition|(
name|inode
operator|!=
name|NULL
condition|)
name|node
operator|->
name|nn_inode
operator|=
operator|*
name|inode
expr_stmt|;
name|nandfs_vinit
argument_list|(
name|nvp
argument_list|,
name|ino
argument_list|)
expr_stmt|;
comment|/* Return node */
operator|*
name|nodep
operator|=
name|node
expr_stmt|;
name|DPRINTF
argument_list|(
name|IFILE
argument_list|,
operator|(
literal|"%s: ino:%#jx vp:%p node:%p\n"
operator|,
name|__func__
operator|,
operator|(
name|uintmax_t
operator|)
name|ino
operator|,
name|nvp
operator|,
operator|*
name|nodep
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nandfs_get_node
parameter_list|(
name|struct
name|nandfsmount
modifier|*
name|nmp
parameter_list|,
name|uint64_t
name|ino
parameter_list|,
name|struct
name|nandfs_node
modifier|*
modifier|*
name|nodep
parameter_list|)
block|{
name|struct
name|nandfs_device
modifier|*
name|nandfsdev
decl_stmt|;
name|struct
name|nandfs_inode
name|inode
decl_stmt|,
modifier|*
name|entry
decl_stmt|;
name|struct
name|vnode
modifier|*
name|nvp
decl_stmt|,
modifier|*
name|vpp
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|uint64_t
name|ivblocknr
decl_stmt|;
name|uint32_t
name|entry_in_block
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Look up node in hash table */
name|td
operator|=
name|curthread
expr_stmt|;
operator|*
name|nodep
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|ino
operator|<
name|NANDFS_ATIME_INO
operator|)
operator|&&
operator|(
name|ino
operator|!=
name|NANDFS_ROOT_INO
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"nandfs_get_node: system ino %"
name|PRIu64
literal|" not in mount "
literal|"point!\n"
argument_list|,
name|ino
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
name|error
operator|=
name|vfs_hash_get
argument_list|(
name|nmp
operator|->
name|nm_vfs_mountp
argument_list|,
name|ino
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
name|td
argument_list|,
operator|&
name|nvp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|nvp
operator|!=
name|NULL
condition|)
block|{
operator|*
name|nodep
operator|=
operator|(
expr|struct
name|nandfs_node
operator|*
operator|)
name|nvp
operator|->
name|v_data
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Look up inode structure in mountpoints ifile */
name|nandfsdev
operator|=
name|nmp
operator|->
name|nm_nandfsdev
expr_stmt|;
name|nandfs_mdt_trans
argument_list|(
operator|&
name|nandfsdev
operator|->
name|nd_ifile_mdt
argument_list|,
name|ino
argument_list|,
operator|&
name|ivblocknr
argument_list|,
operator|&
name|entry_in_block
argument_list|)
expr_stmt|;
name|VOP_LOCK
argument_list|(
name|NTOV
argument_list|(
name|nmp
operator|->
name|nm_ifile_node
argument_list|)
argument_list|,
name|LK_SHARED
argument_list|)
expr_stmt|;
name|error
operator|=
name|nandfs_bread
argument_list|(
name|nmp
operator|->
name|nm_ifile_node
argument_list|,
name|ivblocknr
argument_list|,
name|NOCRED
argument_list|,
literal|0
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|NTOV
argument_list|(
name|nmp
operator|->
name|nm_ifile_node
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
comment|/* Get inode entry */
name|entry
operator|=
operator|(
expr|struct
name|nandfs_inode
operator|*
operator|)
name|bp
operator|->
name|b_data
operator|+
name|entry_in_block
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|inode
argument_list|,
name|entry
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nandfs_inode
argument_list|)
argument_list|)
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|NTOV
argument_list|(
name|nmp
operator|->
name|nm_ifile_node
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Get node */
name|error
operator|=
name|nandfs_get_node_raw
argument_list|(
name|nmp
operator|->
name|nm_nandfsdev
argument_list|,
name|nmp
argument_list|,
name|ino
argument_list|,
operator|&
name|inode
argument_list|,
name|nodep
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
operator|*
name|nodep
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|nvp
operator|=
operator|(
operator|*
name|nodep
operator|)
operator|->
name|nn_vnode
expr_stmt|;
name|error
operator|=
name|vfs_hash_insert
argument_list|(
name|nvp
argument_list|,
name|ino
argument_list|,
literal|0
argument_list|,
name|td
argument_list|,
operator|&
name|vpp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
operator|*
name|nodep
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|nandfs_dispose_node
parameter_list|(
name|struct
name|nandfs_node
modifier|*
modifier|*
name|nodep
parameter_list|)
block|{
name|struct
name|nandfs_node
modifier|*
name|node
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
comment|/* Protect against rogue values */
name|node
operator|=
operator|*
name|nodep
expr_stmt|;
if|if
condition|(
operator|!
name|node
condition|)
block|{
return|return;
block|}
name|DPRINTF
argument_list|(
name|NODE
argument_list|,
operator|(
literal|"nandfs_dispose_node: %p\n"
operator|,
operator|*
name|nodep
operator|)
argument_list|)
expr_stmt|;
name|vp
operator|=
name|NTOV
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|vp
operator|->
name|v_data
operator|=
name|NULL
expr_stmt|;
comment|/* Free our associated memory */
name|uma_zfree
argument_list|(
name|nandfs_node_zone
argument_list|,
name|node
argument_list|)
expr_stmt|;
operator|*
name|nodep
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|int
name|nandfs_lookup_name_in_dir
parameter_list|(
name|struct
name|vnode
modifier|*
name|dvp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|,
name|uint64_t
modifier|*
name|ino
parameter_list|,
name|int
modifier|*
name|found
parameter_list|,
name|uint64_t
modifier|*
name|off
parameter_list|)
block|{
name|struct
name|nandfs_node
modifier|*
name|dir_node
init|=
name|VTON
argument_list|(
name|dvp
argument_list|)
decl_stmt|;
name|struct
name|nandfs_dir_entry
modifier|*
name|ndirent
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|uint64_t
name|file_size
decl_stmt|,
name|diroffset
decl_stmt|,
name|blkoff
decl_stmt|;
name|uint64_t
name|blocknr
decl_stmt|;
name|uint32_t
name|blocksize
init|=
name|dir_node
operator|->
name|nn_nandfsdev
operator|->
name|nd_blocksize
decl_stmt|;
name|uint8_t
modifier|*
name|pos
decl_stmt|,
name|name_len
decl_stmt|;
name|int
name|error
decl_stmt|;
operator|*
name|found
operator|=
literal|0
expr_stmt|;
name|DPRINTF
argument_list|(
name|VNCALL
argument_list|,
operator|(
literal|"%s: %s file\n"
operator|,
name|__func__
operator|,
name|name
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dvp
operator|->
name|v_type
operator|!=
name|VDIR
condition|)
block|{
return|return
operator|(
name|ENOTDIR
operator|)
return|;
block|}
comment|/* Get directory filesize */
name|file_size
operator|=
name|dir_node
operator|->
name|nn_inode
operator|.
name|i_size
expr_stmt|;
comment|/* Walk the directory */
name|diroffset
operator|=
literal|0
expr_stmt|;
name|blocknr
operator|=
literal|0
expr_stmt|;
name|blkoff
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|nandfs_bread
argument_list|(
name|dir_node
argument_list|,
name|blocknr
argument_list|,
name|NOCRED
argument_list|,
literal|0
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
while|while
condition|(
name|diroffset
operator|<
name|file_size
condition|)
block|{
if|if
condition|(
name|blkoff
operator|>=
name|blocksize
condition|)
block|{
name|blkoff
operator|=
literal|0
expr_stmt|;
name|blocknr
operator|++
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|error
operator|=
name|nandfs_bread
argument_list|(
name|dir_node
argument_list|,
name|blocknr
argument_list|,
name|NOCRED
argument_list|,
literal|0
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
block|}
comment|/* Read in one dirent */
name|pos
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|bp
operator|->
name|b_data
operator|+
name|blkoff
expr_stmt|;
name|ndirent
operator|=
operator|(
expr|struct
name|nandfs_dir_entry
operator|*
operator|)
name|pos
expr_stmt|;
name|name_len
operator|=
name|ndirent
operator|->
name|name_len
expr_stmt|;
if|if
condition|(
operator|(
name|name_len
operator|==
name|namelen
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|name
argument_list|,
name|ndirent
operator|->
name|name
argument_list|,
name|name_len
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|ndirent
operator|->
name|inode
operator|!=
literal|0
operator|)
condition|)
block|{
operator|*
name|ino
operator|=
name|ndirent
operator|->
name|inode
expr_stmt|;
operator|*
name|off
operator|=
name|diroffset
expr_stmt|;
name|DPRINTF
argument_list|(
name|LOOKUP
argument_list|,
operator|(
literal|"found `%.*s` with ino %"
name|PRIx64
literal|"\n"
operator|,
name|name_len
operator|,
name|ndirent
operator|->
name|name
operator|,
operator|*
name|ino
operator|)
argument_list|)
expr_stmt|;
operator|*
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* Advance */
name|diroffset
operator|+=
name|ndirent
operator|->
name|rec_len
expr_stmt|;
name|blkoff
operator|+=
name|ndirent
operator|->
name|rec_len
expr_stmt|;
block|}
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nandfs_get_fsinfo
parameter_list|(
name|struct
name|nandfsmount
modifier|*
name|nmp
parameter_list|,
name|struct
name|nandfs_fsinfo
modifier|*
name|fsinfo
parameter_list|)
block|{
name|struct
name|nandfs_device
modifier|*
name|fsdev
decl_stmt|;
name|fsdev
operator|=
name|nmp
operator|->
name|nm_nandfsdev
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|fsinfo
operator|->
name|fs_fsdata
argument_list|,
operator|&
name|fsdev
operator|->
name|nd_fsdata
argument_list|,
sizeof|sizeof
argument_list|(
name|fsdev
operator|->
name|nd_fsdata
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|fsinfo
operator|->
name|fs_super
argument_list|,
operator|&
name|fsdev
operator|->
name|nd_super
argument_list|,
sizeof|sizeof
argument_list|(
name|fsdev
operator|->
name|nd_super
argument_list|)
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|fsinfo
operator|->
name|fs_dev
argument_list|,
sizeof|sizeof
argument_list|(
name|fsinfo
operator|->
name|fs_dev
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|nmp
operator|->
name|nm_vfs_mountp
operator|->
name|mnt_stat
operator|.
name|f_mntfromname
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|nandfs_inode_init
parameter_list|(
name|struct
name|nandfs_inode
modifier|*
name|inode
parameter_list|,
name|uint16_t
name|mode
parameter_list|)
block|{
name|struct
name|timespec
name|ts
decl_stmt|;
name|vfs_timestamp
argument_list|(
operator|&
name|ts
argument_list|)
expr_stmt|;
name|inode
operator|->
name|i_blocks
operator|=
literal|0
expr_stmt|;
name|inode
operator|->
name|i_size
operator|=
literal|0
expr_stmt|;
name|inode
operator|->
name|i_ctime
operator|=
name|ts
operator|.
name|tv_sec
expr_stmt|;
name|inode
operator|->
name|i_ctime_nsec
operator|=
name|ts
operator|.
name|tv_nsec
expr_stmt|;
name|inode
operator|->
name|i_mtime
operator|=
name|ts
operator|.
name|tv_sec
expr_stmt|;
name|inode
operator|->
name|i_mtime_nsec
operator|=
name|ts
operator|.
name|tv_nsec
expr_stmt|;
name|inode
operator|->
name|i_mode
operator|=
name|mode
expr_stmt|;
name|inode
operator|->
name|i_links_count
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|S_ISDIR
argument_list|(
name|mode
argument_list|)
condition|)
name|inode
operator|->
name|i_links_count
operator|=
literal|2
expr_stmt|;
name|inode
operator|->
name|i_flags
operator|=
literal|0
expr_stmt|;
name|inode
operator|->
name|i_special
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|inode
operator|->
name|i_db
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|inode
operator|->
name|i_db
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|inode
operator|->
name|i_ib
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|inode
operator|->
name|i_ib
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nandfs_inode_destroy
parameter_list|(
name|struct
name|nandfs_inode
modifier|*
name|inode
parameter_list|)
block|{
name|MPASS
argument_list|(
name|inode
operator|->
name|i_blocks
operator|==
literal|0
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|inode
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|inode
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|nandfs_fs_full
parameter_list|(
name|struct
name|nandfs_device
modifier|*
name|nffsdev
parameter_list|)
block|{
name|uint64_t
name|space
decl_stmt|,
name|bps
decl_stmt|;
name|bps
operator|=
name|nffsdev
operator|->
name|nd_fsdata
operator|.
name|f_blocks_per_segment
expr_stmt|;
name|space
operator|=
operator|(
name|nffsdev
operator|->
name|nd_clean_segs
operator|-
literal|1
operator|)
operator|*
name|bps
expr_stmt|;
name|DPRINTF
argument_list|(
name|BUF
argument_list|,
operator|(
literal|"%s: bufs:%jx space:%jx\n"
operator|,
name|__func__
operator|,
operator|(
name|uintmax_t
operator|)
name|nffsdev
operator|->
name|nd_dirty_bufs
operator|,
operator|(
name|uintmax_t
operator|)
name|space
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nffsdev
operator|->
name|nd_dirty_bufs
operator|+
operator|(
literal|10
operator|*
name|bps
operator|)
operator|>=
name|space
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|_nandfs_dirty_buf
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|,
name|int
name|dirty_meta
parameter_list|,
name|int
name|force
parameter_list|)
block|{
name|struct
name|nandfs_device
modifier|*
name|nffsdev
decl_stmt|;
name|struct
name|nandfs_node
modifier|*
name|node
decl_stmt|;
name|uint64_t
name|ino
decl_stmt|,
name|bps
decl_stmt|;
if|if
condition|(
name|NANDFS_ISGATHERED
argument_list|(
name|bp
argument_list|)
condition|)
block|{
name|bqrelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
operator|(
name|B_MANAGED
operator||
name|B_DELWRI
operator|)
operator|)
operator|==
operator|(
name|B_MANAGED
operator||
name|B_DELWRI
operator|)
condition|)
block|{
name|bqrelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|node
operator|=
name|VTON
argument_list|(
name|bp
operator|->
name|b_vp
argument_list|)
expr_stmt|;
name|nffsdev
operator|=
name|node
operator|->
name|nn_nandfsdev
expr_stmt|;
name|DPRINTF
argument_list|(
name|BUF
argument_list|,
operator|(
literal|"%s: buf:%p\n"
operator|,
name|__func__
operator|,
name|bp
operator|)
argument_list|)
expr_stmt|;
name|ino
operator|=
name|node
operator|->
name|nn_ino
expr_stmt|;
if|if
condition|(
name|nandfs_fs_full
argument_list|(
name|nffsdev
argument_list|)
operator|&&
operator|!
name|NANDFS_SYS_NODE
argument_list|(
name|ino
argument_list|)
operator|&&
operator|!
name|force
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOSPC
operator|)
return|;
block|}
name|bp
operator|->
name|b_flags
operator||=
name|B_MANAGED
expr_stmt|;
name|bdwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|nandfs_dirty_bufs_increment
argument_list|(
name|nffsdev
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|bp
operator|->
name|b_vp
operator|)
argument_list|,
operator|(
literal|"vp missing for bp"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|nandfs_vblk_get
argument_list|(
name|bp
argument_list|)
operator|||
name|ino
operator|==
name|NANDFS_DAT_INO
operator|)
argument_list|,
operator|(
literal|"bp vblk is 0"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * To maintain consistency of FS we need to force making 	 * meta buffers dirty, even if free space is low. 	 */
if|if
condition|(
name|dirty_meta
operator|&&
name|ino
operator|!=
name|NANDFS_GC_INO
condition|)
name|nandfs_bmap_dirty_blocks
argument_list|(
name|VTON
argument_list|(
name|bp
operator|->
name|b_vp
argument_list|)
argument_list|,
name|bp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|bps
operator|=
name|nffsdev
operator|->
name|nd_fsdata
operator|.
name|f_blocks_per_segment
expr_stmt|;
if|if
condition|(
name|nffsdev
operator|->
name|nd_dirty_bufs
operator|>=
operator|(
name|bps
operator|*
name|nandfs_max_dirty_segs
operator|)
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|nffsdev
operator|->
name|nd_sync_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|nffsdev
operator|->
name|nd_syncing
operator|==
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|SYNC
argument_list|,
operator|(
literal|"%s: wakeup gc\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|nffsdev
operator|->
name|nd_syncing
operator|=
literal|1
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|nffsdev
operator|->
name|nd_syncing
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|nffsdev
operator|->
name|nd_sync_mtx
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nandfs_dirty_buf
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|,
name|int
name|force
parameter_list|)
block|{
return|return
operator|(
name|_nandfs_dirty_buf
argument_list|(
name|bp
argument_list|,
literal|1
argument_list|,
name|force
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nandfs_dirty_buf_meta
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|,
name|int
name|force
parameter_list|)
block|{
return|return
operator|(
name|_nandfs_dirty_buf
argument_list|(
name|bp
argument_list|,
literal|0
argument_list|,
name|force
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|nandfs_undirty_buf_fsdev
parameter_list|(
name|struct
name|nandfs_device
modifier|*
name|nffsdev
parameter_list|,
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|BUF_ASSERT_HELD
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_DELWRI
condition|)
block|{
name|bp
operator|->
name|b_flags
operator|&=
operator|~
operator|(
name|B_DELWRI
operator||
name|B_MANAGED
operator|)
expr_stmt|;
name|nandfs_dirty_bufs_decrement
argument_list|(
name|nffsdev
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Since it is now being written, we can clear its deferred write flag. 	 */
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_DEFERRED
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nandfs_undirty_buf
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|nandfs_node
modifier|*
name|node
decl_stmt|;
name|node
operator|=
name|VTON
argument_list|(
name|bp
operator|->
name|b_vp
argument_list|)
expr_stmt|;
name|nandfs_undirty_buf_fsdev
argument_list|(
name|node
operator|->
name|nn_nandfsdev
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nandfs_vblk_set
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|,
name|nandfs_daddr_t
name|blocknr
parameter_list|)
block|{
name|nandfs_daddr_t
modifier|*
name|vblk
init|=
operator|(
name|nandfs_daddr_t
operator|*
operator|)
operator|(
operator|&
name|bp
operator|->
name|b_fsprivate1
operator|)
decl_stmt|;
operator|*
name|vblk
operator|=
name|blocknr
expr_stmt|;
block|}
end_function

begin_function
name|nandfs_daddr_t
name|nandfs_vblk_get
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|nandfs_daddr_t
modifier|*
name|vblk
init|=
operator|(
name|nandfs_daddr_t
operator|*
operator|)
operator|(
operator|&
name|bp
operator|->
name|b_fsprivate1
operator|)
decl_stmt|;
return|return
operator|(
operator|*
name|vblk
operator|)
return|;
block|}
end_function

begin_function
name|void
name|nandfs_buf_set
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|,
name|uint32_t
name|bits
parameter_list|)
block|{
name|uintptr_t
name|flags
decl_stmt|;
name|flags
operator|=
operator|(
name|uintptr_t
operator|)
name|bp
operator|->
name|b_fsprivate3
expr_stmt|;
name|flags
operator||=
operator|(
name|uintptr_t
operator|)
name|bits
expr_stmt|;
name|bp
operator|->
name|b_fsprivate3
operator|=
operator|(
name|void
operator|*
operator|)
name|flags
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nandfs_buf_clear
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|,
name|uint32_t
name|bits
parameter_list|)
block|{
name|uintptr_t
name|flags
decl_stmt|;
name|flags
operator|=
operator|(
name|uintptr_t
operator|)
name|bp
operator|->
name|b_fsprivate3
expr_stmt|;
name|flags
operator|&=
operator|~
operator|(
name|uintptr_t
operator|)
name|bits
expr_stmt|;
name|bp
operator|->
name|b_fsprivate3
operator|=
operator|(
name|void
operator|*
operator|)
name|flags
expr_stmt|;
block|}
end_function

begin_function
name|int
name|nandfs_buf_check
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|,
name|uint32_t
name|bits
parameter_list|)
block|{
name|uintptr_t
name|flags
decl_stmt|;
name|flags
operator|=
operator|(
name|uintptr_t
operator|)
name|bp
operator|->
name|b_fsprivate3
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|bits
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nandfs_erase
parameter_list|(
name|struct
name|nandfs_device
modifier|*
name|fsdev
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|read_size
decl_stmt|,
name|error
decl_stmt|,
name|i
decl_stmt|;
name|DPRINTF
argument_list|(
name|BLOCK
argument_list|,
operator|(
literal|"%s: performing erase at offset %jx size %zx\n"
operator|,
name|__func__
operator|,
name|offset
operator|,
name|size
operator|)
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|size
operator|%
name|fsdev
operator|->
name|nd_erasesize
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fsdev
operator|->
name|nd_is_nand
condition|)
block|{
name|error
operator|=
name|g_delete_data
argument_list|(
name|fsdev
operator|->
name|nd_gconsumer
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|size
operator|>
name|MAXBSIZE
condition|)
name|read_size
operator|=
name|MAXBSIZE
expr_stmt|;
else|else
name|read_size
operator|=
name|size
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
operator|/
name|MAXBSIZE
condition|;
name|i
operator|++
control|)
block|{
name|error
operator|=
name|bread
argument_list|(
name|fsdev
operator|->
name|nd_devvp
argument_list|,
name|btodb
argument_list|(
name|offset
operator|+
name|i
operator|*
name|read_size
argument_list|)
argument_list|,
name|read_size
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|memset
argument_list|(
name|bp
operator|->
name|b_data
argument_list|,
literal|0xff
argument_list|,
name|read_size
argument_list|)
expr_stmt|;
name|error
operator|=
name|bwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|nandfs_error
argument_list|(
literal|"%s: err:%d from bwrite\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nandfs_vop_islocked
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|)
block|{
name|int
name|islocked
decl_stmt|;
name|islocked
operator|=
name|VOP_ISLOCKED
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
name|islocked
operator|==
name|LK_EXCLUSIVE
operator|||
name|islocked
operator|==
name|LK_SHARED
operator|)
return|;
block|}
end_function

begin_function
name|nandfs_daddr_t
name|nandfs_block_to_dblock
parameter_list|(
name|struct
name|nandfs_device
modifier|*
name|fsdev
parameter_list|,
name|nandfs_lbn_t
name|block
parameter_list|)
block|{
return|return
operator|(
name|btodb
argument_list|(
name|block
operator|*
name|fsdev
operator|->
name|nd_blocksize
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

