begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2010-2012 Semihalf.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/libkern.h>
end_include

begin_include
include|#
directive|include
file|<ddb/ddb.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<geom/geom.h>
end_include

begin_include
include|#
directive|include
file|<geom/geom_vfs.h>
end_include

begin_include
include|#
directive|include
file|<fs/nandfs/nandfs_mount.h>
end_include

begin_include
include|#
directive|include
file|<fs/nandfs/nandfs.h>
end_include

begin_include
include|#
directive|include
file|<fs/nandfs/nandfs_subr.h>
end_include

begin_function
specifier|static
name|int
name|nandfs_new_segment
parameter_list|(
name|struct
name|nandfs_device
modifier|*
name|fsdev
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|uint64_t
name|new
decl_stmt|;
name|error
operator|=
name|nandfs_alloc_segment
argument_list|(
name|fsdev
argument_list|,
operator|&
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|fsdev
operator|->
name|nd_seg_num
operator|=
name|fsdev
operator|->
name|nd_next_seg_num
expr_stmt|;
name|fsdev
operator|->
name|nd_next_seg_num
operator|=
name|new
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
name|SYNC
argument_list|,
operator|(
literal|"%s: new segment %jx next %jx error %d\n"
operator|,
name|__func__
operator|,
operator|(
name|uintmax_t
operator|)
name|fsdev
operator|->
name|nd_seg_num
operator|,
operator|(
name|uintmax_t
operator|)
name|new
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|nandfs_error
argument_list|(
literal|"%s: cannot create segment error %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|create_segment
parameter_list|(
name|struct
name|nandfs_seginfo
modifier|*
name|seginfo
parameter_list|)
block|{
name|struct
name|nandfs_segment
modifier|*
name|seg
decl_stmt|;
name|struct
name|nandfs_device
modifier|*
name|fsdev
decl_stmt|;
name|struct
name|nandfs_segment
modifier|*
name|prev
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|uint64_t
name|start_block
decl_stmt|,
name|curr
decl_stmt|;
name|uint32_t
name|blks_per_seg
decl_stmt|,
name|nblocks
decl_stmt|;
name|int
name|error
decl_stmt|;
name|fsdev
operator|=
name|seginfo
operator|->
name|fsdev
expr_stmt|;
name|prev
operator|=
name|seginfo
operator|->
name|curseg
expr_stmt|;
name|blks_per_seg
operator|=
name|fsdev
operator|->
name|nd_fsdata
operator|.
name|f_blocks_per_segment
expr_stmt|;
name|nblocks
operator|=
name|fsdev
operator|->
name|nd_last_segsum
operator|.
name|ss_nblocks
expr_stmt|;
if|if
condition|(
operator|!
name|prev
condition|)
block|{
name|vfs_timestamp
argument_list|(
operator|&
name|fsdev
operator|->
name|nd_ts
argument_list|)
expr_stmt|;
comment|/* Touch current segment */
name|error
operator|=
name|nandfs_touch_segment
argument_list|(
name|fsdev
argument_list|,
name|fsdev
operator|->
name|nd_seg_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|nandfs_error
argument_list|(
literal|"%s: cannot preallocate segment %jx\n"
argument_list|,
name|__func__
argument_list|,
name|fsdev
operator|->
name|nd_seg_num
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|nandfs_touch_segment
argument_list|(
name|fsdev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|nandfs_error
argument_list|(
literal|"%s: cannot dirty block with segment 0\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|start_block
operator|=
name|fsdev
operator|->
name|nd_last_pseg
operator|+
operator|(
name|uint64_t
operator|)
name|nblocks
expr_stmt|;
comment|/* 		 * XXX Hack 		 */
if|if
condition|(
name|blks_per_seg
operator|-
operator|(
name|start_block
operator|%
name|blks_per_seg
operator|)
operator|-
literal|1
operator|==
literal|0
condition|)
name|start_block
operator|++
expr_stmt|;
name|curr
operator|=
name|nandfs_get_segnum_of_block
argument_list|(
name|fsdev
argument_list|,
name|start_block
argument_list|)
expr_stmt|;
comment|/* Allocate new segment if last one is full */
if|if
condition|(
name|fsdev
operator|->
name|nd_seg_num
operator|!=
name|curr
condition|)
block|{
name|error
operator|=
name|nandfs_new_segment
argument_list|(
name|fsdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|nandfs_error
argument_list|(
literal|"%s: cannot create new segment\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 			 * XXX Hack 			 */
name|nandfs_get_segment_range
argument_list|(
name|fsdev
argument_list|,
name|fsdev
operator|->
name|nd_seg_num
argument_list|,
operator|&
name|start_block
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|nandfs_get_segment_range
argument_list|(
name|fsdev
argument_list|,
name|fsdev
operator|->
name|nd_next_seg_num
argument_list|,
operator|&
name|start_block
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Touch current segment and allocate and touch new one */
name|error
operator|=
name|nandfs_new_segment
argument_list|(
name|fsdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|nandfs_error
argument_list|(
literal|"%s: cannot create next segment\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Reiterate in case new buf is dirty */
name|seginfo
operator|->
name|reiterate
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Allocate and initialize nandfs_segment structure */
name|seg
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|seg
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|seg
operator|->
name|segsum
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|seg
operator|->
name|data
argument_list|)
expr_stmt|;
name|seg
operator|->
name|fsdev
operator|=
name|fsdev
expr_stmt|;
name|seg
operator|->
name|start_block
operator|=
name|start_block
expr_stmt|;
name|seg
operator|->
name|num_blocks
operator|=
name|blks_per_seg
operator|-
operator|(
name|start_block
operator|%
name|blks_per_seg
operator|)
operator|-
literal|1
expr_stmt|;
name|seg
operator|->
name|seg_num
operator|=
name|fsdev
operator|->
name|nd_seg_num
expr_stmt|;
name|seg
operator|->
name|seg_next
operator|=
name|fsdev
operator|->
name|nd_next_seg_num
expr_stmt|;
name|seg
operator|->
name|segsum_blocks
operator|=
literal|1
expr_stmt|;
name|seg
operator|->
name|bytes_left
operator|=
name|fsdev
operator|->
name|nd_blocksize
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|nandfs_segment_summary
argument_list|)
expr_stmt|;
name|seg
operator|->
name|segsum_bytes
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|nandfs_segment_summary
argument_list|)
expr_stmt|;
comment|/* Allocate buffer for segment summary */
name|bp
operator|=
name|getblk
argument_list|(
name|fsdev
operator|->
name|nd_devvp
argument_list|,
name|nandfs_block_to_dblock
argument_list|(
name|fsdev
argument_list|,
name|seg
operator|->
name|start_block
argument_list|)
argument_list|,
name|fsdev
operator|->
name|nd_blocksize
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|bp
operator|->
name|b_data
argument_list|,
name|seginfo
operator|->
name|fsdev
operator|->
name|nd_blocksize
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_bufobj
operator|=
operator|&
name|seginfo
operator|->
name|fsdev
operator|->
name|nd_devvp
operator|->
name|v_bufobj
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_MANAGED
expr_stmt|;
comment|/* Add buffer to segment */
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|seg
operator|->
name|segsum
argument_list|,
name|bp
argument_list|,
name|b_cluster
operator|.
name|cluster_entry
argument_list|)
expr_stmt|;
name|seg
operator|->
name|current_off
operator|=
name|bp
operator|->
name|b_data
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|nandfs_segment_summary
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|SYNC
argument_list|,
operator|(
literal|"%s: seg %p : initial settings: start %#jx size :%#x\n"
operator|,
name|__func__
operator|,
name|seg
operator|,
operator|(
name|uintmax_t
operator|)
name|seg
operator|->
name|start_block
operator|,
name|seg
operator|->
name|num_blocks
operator|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|SYNC
argument_list|,
operator|(
literal|"%s: seg->seg_num %#jx cno %#jx next %#jx\n"
operator|,
name|__func__
operator|,
operator|(
name|uintmax_t
operator|)
name|seg
operator|->
name|seg_num
operator|,
call|(
name|uintmax_t
call|)
argument_list|(
name|fsdev
operator|->
name|nd_last_cno
operator|+
literal|1
argument_list|)
operator|,
operator|(
name|uintmax_t
operator|)
name|seg
operator|->
name|seg_next
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prev
condition|)
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|seginfo
operator|->
name|seg_list
argument_list|,
name|seg
argument_list|,
name|seg_link
argument_list|)
expr_stmt|;
else|else
name|LIST_INSERT_AFTER
argument_list|(
name|prev
argument_list|,
name|seg
argument_list|,
name|seg_link
argument_list|)
expr_stmt|;
name|seginfo
operator|->
name|curseg
operator|=
name|seg
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|delete_segment
parameter_list|(
name|struct
name|nandfs_seginfo
modifier|*
name|seginfo
parameter_list|)
block|{
name|struct
name|nandfs_segment
modifier|*
name|seg
decl_stmt|,
modifier|*
name|tseg
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|,
modifier|*
name|tbp
decl_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|seg
argument_list|,
argument|&seginfo->seg_list
argument_list|,
argument|seg_link
argument_list|,
argument|tseg
argument_list|)
block|{
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|bp
argument_list|,
argument|&seg->segsum
argument_list|,
argument|b_cluster.cluster_entry
argument_list|,
argument|tbp
argument_list|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|seg
operator|->
name|segsum
argument_list|,
name|bp
argument_list|,
name|b_cluster
operator|.
name|cluster_entry
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_MANAGED
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|LIST_REMOVE
argument_list|(
name|seg
argument_list|,
name|seg_link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|seg
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|create_seginfo
parameter_list|(
name|struct
name|nandfs_device
modifier|*
name|fsdev
parameter_list|,
name|struct
name|nandfs_seginfo
modifier|*
modifier|*
name|seginfo
parameter_list|)
block|{
name|struct
name|nandfs_seginfo
modifier|*
name|info
decl_stmt|;
name|info
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|info
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|info
operator|->
name|seg_list
argument_list|)
expr_stmt|;
name|info
operator|->
name|fsdev
operator|=
name|fsdev
expr_stmt|;
name|info
operator|->
name|curseg
operator|=
name|NULL
expr_stmt|;
name|info
operator|->
name|blocks
operator|=
literal|0
expr_stmt|;
operator|*
name|seginfo
operator|=
name|info
expr_stmt|;
name|fsdev
operator|->
name|nd_seginfo
operator|=
name|info
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|delete_seginfo
parameter_list|(
name|struct
name|nandfs_seginfo
modifier|*
name|seginfo
parameter_list|)
block|{
name|struct
name|nandfs_device
modifier|*
name|nffsdev
decl_stmt|;
name|nffsdev
operator|=
name|seginfo
operator|->
name|fsdev
expr_stmt|;
name|delete_segment
argument_list|(
name|seginfo
argument_list|)
expr_stmt|;
name|nffsdev
operator|->
name|nd_seginfo
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|seginfo
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nandfs_create_superroot_block
parameter_list|(
name|struct
name|nandfs_seginfo
modifier|*
name|seginfo
parameter_list|,
name|struct
name|buf
modifier|*
modifier|*
name|newbp
parameter_list|)
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|bp
operator|=
name|nandfs_geteblk
argument_list|(
name|seginfo
operator|->
name|fsdev
operator|->
name|nd_blocksize
argument_list|,
name|GB_NOWAIT_BD
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|bp
operator|->
name|b_data
argument_list|,
name|seginfo
operator|->
name|fsdev
operator|->
name|nd_blocksize
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_bufobj
operator|=
operator|&
name|seginfo
operator|->
name|fsdev
operator|->
name|nd_devvp
operator|->
name|v_bufobj
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_MANAGED
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|seginfo
operator|->
name|curseg
operator|)
operator|||
operator|!
name|seginfo
operator|->
name|curseg
operator|->
name|num_blocks
condition|)
block|{
name|error
operator|=
name|create_segment
argument_list|(
name|seginfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|nandfs_error
argument_list|(
literal|"%s: no segment for superroot\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|seginfo
operator|->
name|curseg
operator|->
name|data
argument_list|,
name|bp
argument_list|,
name|b_cluster
operator|.
name|cluster_entry
argument_list|)
expr_stmt|;
name|seginfo
operator|->
name|curseg
operator|->
name|nblocks
operator|++
expr_stmt|;
name|seginfo
operator|->
name|curseg
operator|->
name|num_blocks
operator|--
expr_stmt|;
name|seginfo
operator|->
name|blocks
operator|++
expr_stmt|;
operator|*
name|newbp
operator|=
name|bp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nandfs_add_superroot
parameter_list|(
name|struct
name|nandfs_seginfo
modifier|*
name|seginfo
parameter_list|)
block|{
name|struct
name|nandfs_device
modifier|*
name|fsdev
decl_stmt|;
name|struct
name|nandfs_super_root
modifier|*
name|sr
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
init|=
name|NULL
decl_stmt|;
name|uint64_t
name|crc_skip
decl_stmt|;
name|uint32_t
name|crc_calc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|fsdev
operator|=
name|seginfo
operator|->
name|fsdev
expr_stmt|;
name|error
operator|=
name|nandfs_create_superroot_block
argument_list|(
name|seginfo
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|nandfs_error
argument_list|(
literal|"%s: cannot add superroot\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|sr
operator|=
operator|(
expr|struct
name|nandfs_super_root
operator|*
operator|)
name|bp
operator|->
name|b_data
expr_stmt|;
comment|/* Save superroot CRC */
name|sr
operator|->
name|sr_bytes
operator|=
name|NANDFS_SR_BYTES
expr_stmt|;
name|sr
operator|->
name|sr_flags
operator|=
literal|0
expr_stmt|;
name|sr
operator|->
name|sr_nongc_ctime
operator|=
literal|0
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|sr
operator|->
name|sr_dat
argument_list|,
operator|&
name|fsdev
operator|->
name|nd_dat_node
operator|->
name|nn_inode
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nandfs_inode
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|sr
operator|->
name|sr_cpfile
argument_list|,
operator|&
name|fsdev
operator|->
name|nd_cp_node
operator|->
name|nn_inode
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nandfs_inode
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|sr
operator|->
name|sr_sufile
argument_list|,
operator|&
name|fsdev
operator|->
name|nd_su_node
operator|->
name|nn_inode
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nandfs_inode
argument_list|)
argument_list|)
expr_stmt|;
name|crc_skip
operator|=
sizeof|sizeof
argument_list|(
name|sr
operator|->
name|sr_sum
argument_list|)
expr_stmt|;
name|crc_calc
operator|=
name|crc32
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
name|sr
operator|+
name|crc_skip
argument_list|,
name|NANDFS_SR_BYTES
operator|-
name|crc_skip
argument_list|)
expr_stmt|;
name|sr
operator|->
name|sr_sum
operator|=
name|crc_calc
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_MANAGED
expr_stmt|;
name|bp
operator|->
name|b_bufobj
operator|=
operator|&
name|seginfo
operator|->
name|fsdev
operator|->
name|nd_devvp
operator|->
name|v_bufobj
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_INVAL
expr_stmt|;
name|nandfs_dirty_bufs_increment
argument_list|(
name|fsdev
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|SYNC
argument_list|,
operator|(
literal|"%s: bp:%p\n"
operator|,
name|__func__
operator|,
name|bp
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nandfs_add_segsum_block
parameter_list|(
name|struct
name|nandfs_seginfo
modifier|*
name|seginfo
parameter_list|,
name|struct
name|buf
modifier|*
modifier|*
name|newbp
parameter_list|)
block|{
name|struct
name|nandfs_device
modifier|*
name|fsdev
decl_stmt|;
name|nandfs_daddr_t
name|blk
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|seginfo
operator|->
name|curseg
operator|)
operator|||
name|seginfo
operator|->
name|curseg
operator|->
name|num_blocks
operator|<=
literal|1
condition|)
block|{
name|error
operator|=
name|create_segment
argument_list|(
name|seginfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|nandfs_error
argument_list|(
literal|"%s: error:%d when creating segment\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
operator|*
name|newbp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|seginfo
operator|->
name|curseg
operator|->
name|segsum
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|fsdev
operator|=
name|seginfo
operator|->
name|fsdev
expr_stmt|;
name|blk
operator|=
name|nandfs_block_to_dblock
argument_list|(
name|fsdev
argument_list|,
name|seginfo
operator|->
name|curseg
operator|->
name|start_block
operator|+
name|seginfo
operator|->
name|curseg
operator|->
name|segsum_blocks
argument_list|)
expr_stmt|;
name|bp
operator|=
name|getblk
argument_list|(
name|fsdev
operator|->
name|nd_devvp
argument_list|,
name|blk
argument_list|,
name|fsdev
operator|->
name|nd_blocksize
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|bp
operator|->
name|b_data
argument_list|,
name|seginfo
operator|->
name|fsdev
operator|->
name|nd_blocksize
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_bufobj
operator|=
operator|&
name|seginfo
operator|->
name|fsdev
operator|->
name|nd_devvp
operator|->
name|v_bufobj
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_MANAGED
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|seginfo
operator|->
name|curseg
operator|->
name|segsum
argument_list|,
name|bp
argument_list|,
name|b_cluster
operator|.
name|cluster_entry
argument_list|)
expr_stmt|;
name|seginfo
operator|->
name|curseg
operator|->
name|num_blocks
operator|--
expr_stmt|;
name|seginfo
operator|->
name|curseg
operator|->
name|segsum_blocks
operator|++
expr_stmt|;
name|seginfo
operator|->
name|curseg
operator|->
name|bytes_left
operator|=
name|seginfo
operator|->
name|fsdev
operator|->
name|nd_blocksize
expr_stmt|;
name|seginfo
operator|->
name|curseg
operator|->
name|current_off
operator|=
name|bp
operator|->
name|b_data
expr_stmt|;
name|seginfo
operator|->
name|blocks
operator|++
expr_stmt|;
operator|*
name|newbp
operator|=
name|bp
expr_stmt|;
name|DPRINTF
argument_list|(
name|SYNC
argument_list|,
operator|(
literal|"%s: bp %p\n"
operator|,
name|__func__
operator|,
name|bp
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nandfs_add_blocks
parameter_list|(
name|struct
name|nandfs_seginfo
modifier|*
name|seginfo
parameter_list|,
name|struct
name|nandfs_node
modifier|*
name|node
parameter_list|,
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|union
name|nandfs_binfo
modifier|*
name|binfo
decl_stmt|;
name|struct
name|buf
modifier|*
name|seg_bp
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|seginfo
operator|->
name|curseg
operator|)
operator|||
operator|!
name|seginfo
operator|->
name|curseg
operator|->
name|num_blocks
condition|)
block|{
name|error
operator|=
name|create_segment
argument_list|(
name|seginfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|nandfs_error
argument_list|(
literal|"%s: error:%d when creating segment\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
if|if
condition|(
name|seginfo
operator|->
name|curseg
operator|->
name|bytes_left
operator|<
sizeof|sizeof
argument_list|(
expr|union
name|nandfs_binfo
argument_list|)
condition|)
block|{
name|error
operator|=
name|nandfs_add_segsum_block
argument_list|(
name|seginfo
argument_list|,
operator|&
name|seg_bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|nandfs_error
argument_list|(
literal|"%s: error:%d when adding segsum\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
name|binfo
operator|=
operator|(
expr|union
name|nandfs_binfo
operator|*
operator|)
name|seginfo
operator|->
name|curseg
operator|->
name|current_off
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|nn_ino
operator|!=
name|NANDFS_DAT_INO
condition|)
block|{
name|binfo
operator|->
name|bi_v
operator|.
name|bi_blkoff
operator|=
name|bp
operator|->
name|b_lblkno
expr_stmt|;
name|binfo
operator|->
name|bi_v
operator|.
name|bi_ino
operator|=
name|node
operator|->
name|nn_ino
expr_stmt|;
block|}
else|else
block|{
name|binfo
operator|->
name|bi_dat
operator|.
name|bi_blkoff
operator|=
name|bp
operator|->
name|b_lblkno
expr_stmt|;
name|binfo
operator|->
name|bi_dat
operator|.
name|bi_ino
operator|=
name|node
operator|->
name|nn_ino
expr_stmt|;
if|if
condition|(
name|NANDFS_IS_INDIRECT
argument_list|(
name|bp
argument_list|)
condition|)
name|binfo
operator|->
name|bi_dat
operator|.
name|bi_level
operator|=
literal|1
expr_stmt|;
else|else
name|binfo
operator|->
name|bi_dat
operator|.
name|bi_level
operator|=
literal|0
expr_stmt|;
block|}
name|binfo
operator|++
expr_stmt|;
name|seginfo
operator|->
name|curseg
operator|->
name|bytes_left
operator|-=
sizeof|sizeof
argument_list|(
expr|union
name|nandfs_binfo
argument_list|)
expr_stmt|;
name|seginfo
operator|->
name|curseg
operator|->
name|segsum_bytes
operator|+=
sizeof|sizeof
argument_list|(
expr|union
name|nandfs_binfo
argument_list|)
expr_stmt|;
name|seginfo
operator|->
name|curseg
operator|->
name|current_off
operator|=
operator|(
name|char
operator|*
operator|)
name|binfo
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|seginfo
operator|->
name|curseg
operator|->
name|data
argument_list|,
name|bp
argument_list|,
name|b_cluster
operator|.
name|cluster_entry
argument_list|)
expr_stmt|;
name|seginfo
operator|->
name|curseg
operator|->
name|nbinfos
operator|++
expr_stmt|;
name|seginfo
operator|->
name|curseg
operator|->
name|nblocks
operator|++
expr_stmt|;
name|seginfo
operator|->
name|curseg
operator|->
name|num_blocks
operator|--
expr_stmt|;
name|seginfo
operator|->
name|blocks
operator|++
expr_stmt|;
name|DPRINTF
argument_list|(
name|SYNC
argument_list|,
operator|(
literal|"%s: bp (%p) number %x (left %x)\n"
operator|,
name|__func__
operator|,
name|bp
operator|,
name|seginfo
operator|->
name|curseg
operator|->
name|nblocks
operator|,
name|seginfo
operator|->
name|curseg
operator|->
name|num_blocks
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nandfs_iterate_dirty_buf
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|struct
name|nandfs_seginfo
modifier|*
name|seginfo
parameter_list|,
name|uint8_t
name|hold
parameter_list|)
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|,
modifier|*
name|tbd
decl_stmt|;
name|struct
name|bufobj
modifier|*
name|bo
decl_stmt|;
name|struct
name|nandfs_node
modifier|*
name|node
decl_stmt|;
name|int
name|error
decl_stmt|;
name|node
operator|=
name|VTON
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|bo
operator|=
operator|&
name|vp
operator|->
name|v_bufobj
expr_stmt|;
name|ASSERT_VOP_ELOCKED
argument_list|(
name|vp
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* Iterate dirty data bufs */
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|bp
argument_list|,
argument|&bo->bo_dirty.bv_hd
argument_list|,
argument|b_bobufs
argument_list|,
argument|tbd
argument_list|)
block|{
name|DPRINTF
argument_list|(
name|SYNC
argument_list|,
operator|(
literal|"%s: vp (%p): bp (%p) with lblkno %jx ino %jx "
literal|"add buf\n"
operator|,
name|__func__
operator|,
name|vp
operator|,
name|bp
operator|,
name|bp
operator|->
name|b_lblkno
operator|,
name|node
operator|->
name|nn_ino
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|NANDFS_ISGATHERED
argument_list|(
name|bp
argument_list|)
operator|)
condition|)
block|{
name|error
operator|=
name|nandfs_bmap_update_dat
argument_list|(
name|node
argument_list|,
name|nandfs_vblk_get
argument_list|(
name|bp
argument_list|)
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|NANDFS_GATHER
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|nandfs_add_blocks
argument_list|(
name|seginfo
argument_list|,
name|node
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nandfs_iterate_system_vnode
parameter_list|(
name|struct
name|nandfs_node
modifier|*
name|node
parameter_list|,
name|struct
name|nandfs_seginfo
modifier|*
name|seginfo
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|int
name|nblocks
decl_stmt|;
name|uint8_t
name|hold
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|nn_ino
operator|!=
name|NANDFS_IFILE_INO
condition|)
name|hold
operator|=
literal|1
expr_stmt|;
name|vp
operator|=
name|NTOV
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|nblocks
operator|=
name|vp
operator|->
name|v_bufobj
operator|.
name|bo_dirty
operator|.
name|bv_cnt
expr_stmt|;
name|DPRINTF
argument_list|(
name|SYNC
argument_list|,
operator|(
literal|"%s: vp (%p): nblocks %x ino %jx\n"
operator|,
name|__func__
operator|,
name|vp
operator|,
name|nblocks
operator|,
name|node
operator|->
name|nn_ino
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nblocks
condition|)
name|nandfs_iterate_dirty_buf
argument_list|(
name|vp
argument_list|,
name|seginfo
argument_list|,
name|hold
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nandfs_iterate_dirty_vnodes
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|struct
name|nandfs_seginfo
modifier|*
name|seginfo
parameter_list|)
block|{
name|struct
name|nandfs_node
modifier|*
name|nandfs_node
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|,
modifier|*
name|mvp
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|int
name|error
decl_stmt|,
name|update
decl_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
name|MNT_VNODE_FOREACH_ACTIVE
argument_list|(
argument|vp
argument_list|,
argument|mp
argument_list|,
argument|mvp
argument_list|)
block|{
name|update
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|mnt_syncer
operator|==
name|vp
operator|||
name|VOP_ISLOCKED
argument_list|(
name|vp
argument_list|)
condition|)
block|{
name|VI_UNLOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|vget
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_INTERLOCK
operator||
name|LK_NOWAIT
argument_list|,
name|td
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
name|nandfs_node
operator|=
name|VTON
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nandfs_node
operator|->
name|nn_flags
operator|&
name|IN_MODIFIED
condition|)
block|{
name|nandfs_node
operator|->
name|nn_flags
operator|&=
operator|~
operator|(
name|IN_MODIFIED
operator|)
expr_stmt|;
name|update
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|vp
operator|->
name|v_bufobj
operator|.
name|bo_dirty
operator|.
name|bv_cnt
condition|)
block|{
name|error
operator|=
name|nandfs_iterate_dirty_buf
argument_list|(
name|vp
argument_list|,
name|seginfo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|nandfs_error
argument_list|(
literal|"%s: cannot iterate vnode:%p "
literal|"err:%d\n"
argument_list|,
name|__func__
argument_list|,
name|vp
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|update
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|update
condition|)
name|nandfs_node_update
argument_list|(
name|nandfs_node
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nandfs_update_phys_block
parameter_list|(
name|struct
name|nandfs_device
modifier|*
name|fsdev
parameter_list|,
name|struct
name|buf
modifier|*
name|bp
parameter_list|,
name|uint64_t
name|phys_blknr
parameter_list|,
name|union
name|nandfs_binfo
modifier|*
name|binfo
parameter_list|)
block|{
name|struct
name|nandfs_node
modifier|*
name|node
decl_stmt|,
modifier|*
name|dat
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|uint64_t
name|new_blknr
decl_stmt|;
name|int
name|error
decl_stmt|;
name|vp
operator|=
name|bp
operator|->
name|b_vp
expr_stmt|;
name|node
operator|=
name|VTON
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|new_blknr
operator|=
name|nandfs_vblk_get
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|dat
operator|=
name|fsdev
operator|->
name|nd_dat_node
expr_stmt|;
name|DPRINTF
argument_list|(
name|BMAP
argument_list|,
operator|(
literal|"%s: ino %#jx lblk %#jx: vblk %#jx -> %#jx\n"
operator|,
name|__func__
operator|,
operator|(
name|uintmax_t
operator|)
name|node
operator|->
name|nn_ino
operator|,
operator|(
name|uintmax_t
operator|)
name|bp
operator|->
name|b_lblkno
operator|,
operator|(
name|uintmax_t
operator|)
name|new_blknr
operator|,
operator|(
name|uintmax_t
operator|)
name|phys_blknr
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|nn_ino
operator|!=
name|NANDFS_DAT_INO
condition|)
block|{
name|KASSERT
argument_list|(
operator|(
name|new_blknr
operator|!=
literal|0
operator|)
argument_list|,
operator|(
literal|"vblk for bp %p is 0"
operator|,
name|bp
operator|)
argument_list|)
expr_stmt|;
name|nandfs_vblock_assign
argument_list|(
name|fsdev
argument_list|,
name|new_blknr
argument_list|,
name|phys_blknr
argument_list|)
expr_stmt|;
name|binfo
operator|->
name|bi_v
operator|.
name|bi_vblocknr
operator|=
name|new_blknr
expr_stmt|;
name|binfo
operator|->
name|bi_v
operator|.
name|bi_blkoff
operator|=
name|bp
operator|->
name|b_lblkno
expr_stmt|;
name|binfo
operator|->
name|bi_v
operator|.
name|bi_ino
operator|=
name|node
operator|->
name|nn_ino
expr_stmt|;
block|}
else|else
block|{
name|VOP_LOCK
argument_list|(
name|NTOV
argument_list|(
name|dat
argument_list|)
argument_list|,
name|LK_EXCLUSIVE
argument_list|)
expr_stmt|;
name|error
operator|=
name|nandfs_bmap_update_block
argument_list|(
name|node
argument_list|,
name|bp
argument_list|,
name|phys_blknr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|nandfs_error
argument_list|(
literal|"%s: error updating block:%jx for bp:%p\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|uintmax_t
operator|)
name|phys_blknr
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|NTOV
argument_list|(
name|dat
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|VOP_UNLOCK
argument_list|(
name|NTOV
argument_list|(
name|dat
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|binfo
operator|->
name|bi_dat
operator|.
name|bi_blkoff
operator|=
name|bp
operator|->
name|b_lblkno
expr_stmt|;
name|binfo
operator|->
name|bi_dat
operator|.
name|bi_ino
operator|=
name|node
operator|->
name|nn_ino
expr_stmt|;
if|if
condition|(
name|NANDFS_IS_INDIRECT
argument_list|(
name|bp
argument_list|)
condition|)
name|binfo
operator|->
name|bi_dat
operator|.
name|bi_level
operator|=
literal|1
expr_stmt|;
else|else
name|binfo
operator|->
name|bi_dat
operator|.
name|bi_level
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|NBINFO
parameter_list|(
name|off
parameter_list|)
value|((off) + sizeof(union nandfs_binfo))
end_define

begin_function
specifier|static
name|int
name|nandfs_segment_assign_pblk
parameter_list|(
name|struct
name|nandfs_segment
modifier|*
name|nfsseg
parameter_list|)
block|{
name|struct
name|nandfs_device
modifier|*
name|fsdev
decl_stmt|;
name|union
name|nandfs_binfo
modifier|*
name|binfo
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|,
modifier|*
name|seg_bp
decl_stmt|;
name|uint64_t
name|blocknr
decl_stmt|;
name|uint32_t
name|curr_off
decl_stmt|,
name|blocksize
decl_stmt|;
name|int
name|error
decl_stmt|;
name|fsdev
operator|=
name|nfsseg
operator|->
name|fsdev
expr_stmt|;
name|blocksize
operator|=
name|fsdev
operator|->
name|nd_blocksize
expr_stmt|;
name|blocknr
operator|=
name|nfsseg
operator|->
name|start_block
operator|+
name|nfsseg
operator|->
name|segsum_blocks
expr_stmt|;
name|seg_bp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|nfsseg
operator|->
name|segsum
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|SYNC
argument_list|,
operator|(
literal|"%s: seg:%p segsum bp:%p data:%p\n"
operator|,
name|__func__
operator|,
name|nfsseg
operator|,
name|seg_bp
operator|,
name|seg_bp
operator|->
name|b_data
operator|)
argument_list|)
expr_stmt|;
name|binfo
operator|=
operator|(
expr|union
name|nandfs_binfo
operator|*
operator|)
operator|(
name|seg_bp
operator|->
name|b_data
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|nandfs_segment_summary
argument_list|)
operator|)
expr_stmt|;
name|curr_off
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|nandfs_segment_summary
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|bp
argument_list|,
argument|&nfsseg->data
argument_list|,
argument|b_cluster.cluster_entry
argument_list|)
block|{
name|KASSERT
argument_list|(
operator|(
name|bp
operator|->
name|b_vp
operator|)
argument_list|,
operator|(
literal|"bp %p has not vp"
operator|,
name|bp
operator|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|BMAP
argument_list|,
operator|(
literal|"\n\n%s: assign buf %p for ino %#jx next %p\n"
operator|,
name|__func__
operator|,
name|bp
operator|,
operator|(
name|uintmax_t
operator|)
name|VTON
argument_list|(
name|bp
operator|->
name|b_vp
argument_list|)
operator|->
name|nn_ino
operator|,
name|TAILQ_NEXT
argument_list|(
name|bp
argument_list|,
name|b_cluster
operator|.
name|cluster_entry
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|NBINFO
argument_list|(
name|curr_off
argument_list|)
operator|>
name|blocksize
condition|)
block|{
name|seg_bp
operator|=
name|TAILQ_NEXT
argument_list|(
name|seg_bp
argument_list|,
name|b_cluster
operator|.
name|cluster_entry
argument_list|)
expr_stmt|;
name|binfo
operator|=
operator|(
expr|union
name|nandfs_binfo
operator|*
operator|)
name|seg_bp
operator|->
name|b_data
expr_stmt|;
name|curr_off
operator|=
literal|0
expr_stmt|;
name|DPRINTF
argument_list|(
name|SYNC
argument_list|,
operator|(
literal|"%s: next segsum %p data %p\n"
operator|,
name|__func__
operator|,
name|seg_bp
operator|,
name|seg_bp
operator|->
name|b_data
operator|)
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|nandfs_update_phys_block
argument_list|(
name|fsdev
argument_list|,
name|bp
argument_list|,
name|blocknr
argument_list|,
name|binfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|nandfs_error
argument_list|(
literal|"%s: err:%d when updatinng phys block:%jx"
literal|" for bp:%p and binfo:%p\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|,
operator|(
name|uintmax_t
operator|)
name|blocknr
argument_list|,
name|bp
argument_list|,
name|binfo
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|binfo
operator|++
expr_stmt|;
name|curr_off
operator|=
name|NBINFO
argument_list|(
name|curr_off
argument_list|)
expr_stmt|;
name|blocknr
operator|++
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nandfs_seginfo_assign_pblk
parameter_list|(
name|struct
name|nandfs_seginfo
modifier|*
name|seginfo
parameter_list|)
block|{
name|struct
name|nandfs_segment
modifier|*
name|nfsseg
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|nfsseg
argument_list|,
argument|&seginfo->seg_list
argument_list|,
argument|seg_link
argument_list|)
block|{
name|error
operator|=
name|nandfs_segment_assign_pblk
argument_list|(
name|nfsseg
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|nandfs_segment_summary
modifier|*
name|nandfs_fill_segsum
parameter_list|(
name|struct
name|nandfs_segment
modifier|*
name|seg
parameter_list|,
name|int
name|has_sr
parameter_list|)
block|{
name|struct
name|nandfs_segment_summary
modifier|*
name|ss
decl_stmt|;
name|struct
name|nandfs_device
modifier|*
name|fsdev
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|uint32_t
name|rest
decl_stmt|,
name|segsum_size
decl_stmt|,
name|blocksize
decl_stmt|,
name|crc_calc
decl_stmt|;
name|uint16_t
name|flags
decl_stmt|;
name|uint8_t
modifier|*
name|crc_area
decl_stmt|,
name|crc_skip
decl_stmt|;
name|DPRINTF
argument_list|(
name|SYNC
argument_list|,
operator|(
literal|"%s: seg %#jx nblocks %#x sumbytes %#x\n"
operator|,
name|__func__
operator|,
operator|(
name|uintmax_t
operator|)
name|seg
operator|->
name|seg_num
operator|,
name|seg
operator|->
name|nblocks
operator|+
name|seg
operator|->
name|segsum_blocks
operator|,
name|seg
operator|->
name|segsum_bytes
operator|)
argument_list|)
expr_stmt|;
name|fsdev
operator|=
name|seg
operator|->
name|fsdev
expr_stmt|;
name|flags
operator|=
name|NANDFS_SS_LOGBGN
operator||
name|NANDFS_SS_LOGEND
expr_stmt|;
if|if
condition|(
name|has_sr
condition|)
name|flags
operator||=
name|NANDFS_SS_SR
expr_stmt|;
name|bp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|seg
operator|->
name|segsum
argument_list|)
expr_stmt|;
name|ss
operator|=
operator|(
expr|struct
name|nandfs_segment_summary
operator|*
operator|)
name|bp
operator|->
name|b_data
expr_stmt|;
name|ss
operator|->
name|ss_magic
operator|=
name|NANDFS_SEGSUM_MAGIC
expr_stmt|;
name|ss
operator|->
name|ss_bytes
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|nandfs_segment_summary
argument_list|)
expr_stmt|;
name|ss
operator|->
name|ss_flags
operator|=
name|flags
expr_stmt|;
name|ss
operator|->
name|ss_seq
operator|=
operator|++
operator|(
name|fsdev
operator|->
name|nd_seg_sequence
operator|)
expr_stmt|;
name|ss
operator|->
name|ss_create
operator|=
name|fsdev
operator|->
name|nd_ts
operator|.
name|tv_sec
expr_stmt|;
name|nandfs_get_segment_range
argument_list|(
name|fsdev
argument_list|,
name|seg
operator|->
name|seg_next
argument_list|,
operator|&
name|ss
operator|->
name|ss_next
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ss
operator|->
name|ss_nblocks
operator|=
name|seg
operator|->
name|nblocks
operator|+
name|seg
operator|->
name|segsum_blocks
expr_stmt|;
name|ss
operator|->
name|ss_nbinfos
operator|=
name|seg
operator|->
name|nbinfos
expr_stmt|;
name|ss
operator|->
name|ss_sumbytes
operator|=
name|seg
operator|->
name|segsum_bytes
expr_stmt|;
name|crc_skip
operator|=
sizeof|sizeof
argument_list|(
name|ss
operator|->
name|ss_datasum
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|ss
operator|->
name|ss_sumsum
argument_list|)
expr_stmt|;
name|blocksize
operator|=
name|seg
operator|->
name|fsdev
operator|->
name|nd_blocksize
expr_stmt|;
name|segsum_size
operator|=
name|seg
operator|->
name|segsum_bytes
operator|-
name|crc_skip
expr_stmt|;
name|rest
operator|=
name|min
argument_list|(
name|seg
operator|->
name|segsum_bytes
argument_list|,
name|blocksize
argument_list|)
operator|-
name|crc_skip
expr_stmt|;
name|crc_area
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|ss
operator|+
name|crc_skip
expr_stmt|;
name|crc_calc
operator|=
operator|~
literal|0U
expr_stmt|;
while|while
condition|(
name|segsum_size
operator|>
literal|0
condition|)
block|{
name|crc_calc
operator|=
name|crc32_raw
argument_list|(
name|crc_area
argument_list|,
name|rest
argument_list|,
name|crc_calc
argument_list|)
expr_stmt|;
name|segsum_size
operator|-=
name|rest
expr_stmt|;
if|if
condition|(
operator|!
name|segsum_size
condition|)
break|break;
name|bp
operator|=
name|TAILQ_NEXT
argument_list|(
name|bp
argument_list|,
name|b_cluster
operator|.
name|cluster_entry
argument_list|)
expr_stmt|;
name|crc_area
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|bp
operator|->
name|b_data
expr_stmt|;
name|rest
operator|=
name|segsum_size
operator|<=
name|blocksize
condition|?
name|segsum_size
else|:
name|blocksize
expr_stmt|;
block|}
name|ss
operator|->
name|ss_sumsum
operator|=
name|crc_calc
operator|^
operator|~
literal|0U
expr_stmt|;
return|return
operator|(
name|ss
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nandfs_save_buf
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|,
name|uint64_t
name|blocknr
parameter_list|,
name|struct
name|nandfs_device
modifier|*
name|fsdev
parameter_list|)
block|{
name|struct
name|bufobj
modifier|*
name|bo
decl_stmt|;
name|int
name|error
decl_stmt|;
name|bo
operator|=
operator|&
name|fsdev
operator|->
name|nd_devvp
operator|->
name|v_bufobj
expr_stmt|;
name|bp
operator|->
name|b_blkno
operator|=
name|nandfs_block_to_dblock
argument_list|(
name|fsdev
argument_list|,
name|blocknr
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_iooffset
operator|=
name|dbtob
argument_list|(
name|bp
operator|->
name|b_blkno
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|bp
operator|->
name|b_bufobj
operator|!=
name|NULL
argument_list|,
operator|(
literal|"no bufobj for %p"
operator|,
name|bp
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_bufobj
operator|!=
name|bo
condition|)
block|{
name|BO_LOCK
argument_list|(
name|bp
operator|->
name|b_bufobj
argument_list|)
expr_stmt|;
name|BUF_LOCK
argument_list|(
name|bp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_NOWAIT
operator||
name|LK_INTERLOCK
argument_list|,
name|BO_MTX
argument_list|(
name|bp
operator|->
name|b_bufobj
argument_list|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|BUF_ISLOCKED
argument_list|(
name|bp
argument_list|)
argument_list|,
operator|(
literal|"Problem with locking buffer"
operator|)
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
name|SYNC
argument_list|,
operator|(
literal|"%s: buf: %p offset %#jx blk %#jx size %#x\n"
operator|,
name|__func__
operator|,
name|bp
operator|,
operator|(
name|uintmax_t
operator|)
name|bp
operator|->
name|b_offset
operator|,
operator|(
name|uintmax_t
operator|)
name|blocknr
operator|,
name|fsdev
operator|->
name|nd_blocksize
operator|)
argument_list|)
expr_stmt|;
name|NANDFS_UNGATHER
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|nandfs_buf_clear
argument_list|(
name|bp
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|&=
operator|~
operator|(
name|B_ASYNC
operator||
name|B_INVAL
operator||
name|B_MANAGED
operator|)
expr_stmt|;
name|error
operator|=
name|bwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|nandfs_error
argument_list|(
literal|"%s: error:%d when writing buffer:%p\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|,
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nandfs_clean_buf
parameter_list|(
name|struct
name|nandfs_device
modifier|*
name|fsdev
parameter_list|,
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|DPRINTF
argument_list|(
name|SYNC
argument_list|,
operator|(
literal|"%s: buf: %p\n"
operator|,
name|__func__
operator|,
name|bp
operator|)
argument_list|)
expr_stmt|;
name|NANDFS_UNGATHER
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|nandfs_buf_clear
argument_list|(
name|bp
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|&=
operator|~
operator|(
name|B_ASYNC
operator||
name|B_INVAL
operator||
name|B_MANAGED
operator|)
expr_stmt|;
name|nandfs_undirty_buf_fsdev
argument_list|(
name|fsdev
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|nandfs_clean_segblocks
parameter_list|(
name|struct
name|nandfs_segment
modifier|*
name|seg
parameter_list|,
name|uint8_t
name|unlock
parameter_list|)
block|{
name|struct
name|nandfs_device
modifier|*
name|fsdev
init|=
name|seg
operator|->
name|fsdev
decl_stmt|;
name|struct
name|nandfs_segment
modifier|*
name|next_seg
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|,
modifier|*
name|tbp
decl_stmt|,
modifier|*
name|next_bp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|,
modifier|*
name|next_vp
decl_stmt|;
name|VOP_LOCK
argument_list|(
name|fsdev
operator|->
name|nd_devvp
argument_list|,
name|LK_EXCLUSIVE
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|bp
argument_list|,
argument|&seg->segsum
argument_list|,
argument|b_cluster.cluster_entry
argument_list|,
argument|tbp
argument_list|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|seg
operator|->
name|segsum
argument_list|,
name|bp
argument_list|,
name|b_cluster
operator|.
name|cluster_entry
argument_list|)
expr_stmt|;
name|nandfs_clean_buf
argument_list|(
name|fsdev
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|bp
argument_list|,
argument|&seg->data
argument_list|,
argument|b_cluster.cluster_entry
argument_list|,
argument|tbp
argument_list|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|seg
operator|->
name|data
argument_list|,
name|bp
argument_list|,
name|b_cluster
operator|.
name|cluster_entry
argument_list|)
expr_stmt|;
comment|/* 		 * If bp is not super-root and vnode is not currently 		 * locked lock it. 		 */
name|vp
operator|=
name|bp
operator|->
name|b_vp
expr_stmt|;
name|next_vp
operator|=
name|NULL
expr_stmt|;
name|next_bp
operator|=
name|TAILQ_NEXT
argument_list|(
name|bp
argument_list|,
name|b_cluster
operator|.
name|cluster_entry
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|next_bp
condition|)
block|{
name|next_seg
operator|=
name|LIST_NEXT
argument_list|(
name|seg
argument_list|,
name|seg_link
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_seg
condition|)
name|next_bp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|next_seg
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|next_bp
condition|)
name|next_vp
operator|=
name|next_bp
operator|->
name|b_vp
expr_stmt|;
name|nandfs_clean_buf
argument_list|(
name|fsdev
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlock
operator|&&
name|vp
operator|!=
name|NULL
operator|&&
name|next_vp
operator|!=
name|vp
operator|&&
operator|!
name|NANDFS_SYS_NODE
argument_list|(
name|VTON
argument_list|(
name|vp
argument_list|)
operator|->
name|nn_ino
argument_list|)
condition|)
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|nandfs_dirty_bufs_decrement
argument_list|(
name|fsdev
argument_list|)
expr_stmt|;
block|}
name|VOP_UNLOCK
argument_list|(
name|fsdev
operator|->
name|nd_devvp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|nandfs_save_segblocks
parameter_list|(
name|struct
name|nandfs_segment
modifier|*
name|seg
parameter_list|,
name|uint8_t
name|unlock
parameter_list|)
block|{
name|struct
name|nandfs_device
modifier|*
name|fsdev
init|=
name|seg
operator|->
name|fsdev
decl_stmt|;
name|struct
name|nandfs_segment
modifier|*
name|next_seg
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|,
modifier|*
name|tbp
decl_stmt|,
modifier|*
name|next_bp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|,
modifier|*
name|next_vp
decl_stmt|;
name|uint64_t
name|blocknr
decl_stmt|;
name|uint32_t
name|i
init|=
literal|0
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|VOP_LOCK
argument_list|(
name|fsdev
operator|->
name|nd_devvp
argument_list|,
name|LK_EXCLUSIVE
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|bp
argument_list|,
argument|&seg->segsum
argument_list|,
argument|b_cluster.cluster_entry
argument_list|,
argument|tbp
argument_list|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|seg
operator|->
name|segsum
argument_list|,
name|bp
argument_list|,
name|b_cluster
operator|.
name|cluster_entry
argument_list|)
expr_stmt|;
name|blocknr
operator|=
name|seg
operator|->
name|start_block
operator|+
name|i
expr_stmt|;
name|error
operator|=
name|nandfs_save_buf
argument_list|(
name|bp
argument_list|,
name|blocknr
argument_list|,
name|fsdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|nandfs_error
argument_list|(
literal|"%s: error saving buf: %p blocknr:%jx\n"
argument_list|,
name|__func__
argument_list|,
name|bp
argument_list|,
operator|(
name|uintmax_t
operator|)
name|blocknr
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|i
operator|++
expr_stmt|;
block|}
empty_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|bp
argument_list|,
argument|&seg->data
argument_list|,
argument|b_cluster.cluster_entry
argument_list|,
argument|tbp
argument_list|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|seg
operator|->
name|data
argument_list|,
name|bp
argument_list|,
name|b_cluster
operator|.
name|cluster_entry
argument_list|)
expr_stmt|;
name|blocknr
operator|=
name|seg
operator|->
name|start_block
operator|+
name|seg
operator|->
name|segsum_blocks
operator|+
name|i
expr_stmt|;
comment|/* 		 * If bp is not super-root and vnode is not currently 		 * locked lock it. 		 */
name|vp
operator|=
name|bp
operator|->
name|b_vp
expr_stmt|;
name|next_vp
operator|=
name|NULL
expr_stmt|;
name|next_bp
operator|=
name|TAILQ_NEXT
argument_list|(
name|bp
argument_list|,
name|b_cluster
operator|.
name|cluster_entry
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|next_bp
condition|)
block|{
name|next_seg
operator|=
name|LIST_NEXT
argument_list|(
name|seg
argument_list|,
name|seg_link
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_seg
condition|)
name|next_bp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|next_seg
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|next_bp
condition|)
name|next_vp
operator|=
name|next_bp
operator|->
name|b_vp
expr_stmt|;
name|error
operator|=
name|nandfs_save_buf
argument_list|(
name|bp
argument_list|,
name|blocknr
argument_list|,
name|fsdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|nandfs_error
argument_list|(
literal|"%s: error saving buf: %p blknr: %jx\n"
argument_list|,
name|__func__
argument_list|,
name|bp
argument_list|,
operator|(
name|uintmax_t
operator|)
name|blocknr
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlock
operator|&&
name|vp
operator|!=
name|NULL
operator|&&
name|next_vp
operator|!=
name|vp
operator|&&
operator|!
name|NANDFS_SYS_NODE
argument_list|(
name|VTON
argument_list|(
name|vp
argument_list|)
operator|->
name|nn_ino
argument_list|)
condition|)
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|unlock
operator|&&
name|vp
operator|!=
name|NULL
operator|&&
name|next_vp
operator|!=
name|vp
operator|&&
operator|!
name|NANDFS_SYS_NODE
argument_list|(
name|VTON
argument_list|(
name|vp
argument_list|)
operator|->
name|nn_ino
argument_list|)
condition|)
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|nandfs_dirty_bufs_decrement
argument_list|(
name|fsdev
argument_list|)
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|error
condition|)
block|{
name|nandfs_clean_segblocks
argument_list|(
name|seg
argument_list|,
name|unlock
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|fsdev
operator|->
name|nd_devvp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|VOP_UNLOCK
argument_list|(
name|fsdev
operator|->
name|nd_devvp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|clean_seginfo
parameter_list|(
name|struct
name|nandfs_seginfo
modifier|*
name|seginfo
parameter_list|,
name|uint8_t
name|unlock
parameter_list|)
block|{
name|struct
name|nandfs_segment
modifier|*
name|seg
decl_stmt|;
name|DPRINTF
argument_list|(
name|SYNC
argument_list|,
operator|(
literal|"%s: seginfo %p\n"
operator|,
name|__func__
operator|,
name|seginfo
operator|)
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|seg
argument_list|,
argument|&seginfo->seg_list
argument_list|,
argument|seg_link
argument_list|)
block|{
name|nandfs_clean_segblocks
argument_list|(
name|seg
argument_list|,
name|unlock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|save_seginfo
parameter_list|(
name|struct
name|nandfs_seginfo
modifier|*
name|seginfo
parameter_list|,
name|uint8_t
name|unlock
parameter_list|)
block|{
name|struct
name|nandfs_segment
modifier|*
name|seg
decl_stmt|;
name|struct
name|nandfs_device
modifier|*
name|fsdev
decl_stmt|;
name|struct
name|nandfs_segment_summary
modifier|*
name|ss
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|fsdev
operator|=
name|seginfo
operator|->
name|fsdev
expr_stmt|;
name|DPRINTF
argument_list|(
name|SYNC
argument_list|,
operator|(
literal|"%s: seginfo %p\n"
operator|,
name|__func__
operator|,
name|seginfo
operator|)
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|seg
argument_list|,
argument|&seginfo->seg_list
argument_list|,
argument|seg_link
argument_list|)
block|{
if|if
condition|(
name|LIST_NEXT
argument_list|(
name|seg
argument_list|,
name|seg_link
argument_list|)
condition|)
block|{
name|nandfs_fill_segsum
argument_list|(
name|seg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|nandfs_save_segblocks
argument_list|(
name|seg
argument_list|,
name|unlock
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|nandfs_error
argument_list|(
literal|"%s: error:%d saving seg:%p\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|,
name|seg
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
else|else
block|{
name|ss
operator|=
name|nandfs_fill_segsum
argument_list|(
name|seg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fsdev
operator|->
name|nd_last_segsum
operator|=
operator|*
name|ss
expr_stmt|;
name|error
operator|=
name|nandfs_save_segblocks
argument_list|(
name|seg
argument_list|,
name|unlock
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|nandfs_error
argument_list|(
literal|"%s: error:%d saving seg:%p\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|,
name|seg
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|fsdev
operator|->
name|nd_last_cno
operator|++
expr_stmt|;
name|fsdev
operator|->
name|nd_last_pseg
operator|=
name|seg
operator|->
name|start_block
expr_stmt|;
block|}
block|}
name|out
label|:
if|if
condition|(
name|error
condition|)
name|clean_seginfo
argument_list|(
name|seginfo
argument_list|,
name|unlock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nandfs_invalidate_bufs
parameter_list|(
name|struct
name|nandfs_device
modifier|*
name|fsdev
parameter_list|,
name|uint64_t
name|segno
parameter_list|)
block|{
name|uint64_t
name|start
decl_stmt|,
name|end
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|,
modifier|*
name|tbd
decl_stmt|;
name|struct
name|bufobj
modifier|*
name|bo
decl_stmt|;
name|nandfs_get_segment_range
argument_list|(
name|fsdev
argument_list|,
name|segno
argument_list|,
operator|&
name|start
argument_list|,
operator|&
name|end
argument_list|)
expr_stmt|;
name|bo
operator|=
operator|&
name|NTOV
argument_list|(
name|fsdev
operator|->
name|nd_gc_node
argument_list|)
operator|->
name|v_bufobj
expr_stmt|;
name|BO_LOCK
argument_list|(
name|bo
argument_list|)
expr_stmt|;
name|restart_locked_gc
label|:
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|bp
argument_list|,
argument|&bo->bo_clean.bv_hd
argument_list|,
argument|b_bobufs
argument_list|,
argument|tbd
argument_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|bp
operator|->
name|b_lblkno
operator|>=
name|start
operator|&&
name|bp
operator|->
name|b_lblkno
operator|<=
name|end
operator|)
condition|)
continue|continue;
if|if
condition|(
name|BUF_LOCK
argument_list|(
name|bp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_NOWAIT
argument_list|,
name|NULL
argument_list|)
condition|)
goto|goto
name|restart_locked_gc
goto|;
name|bremfree
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
operator|(
name|B_INVAL
operator||
name|B_RELBUF
operator|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|&=
operator|~
operator|(
name|B_ASYNC
operator||
name|B_MANAGED
operator|)
expr_stmt|;
name|BO_UNLOCK
argument_list|(
name|bo
argument_list|)
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|BO_LOCK
argument_list|(
name|bo
argument_list|)
expr_stmt|;
block|}
name|BO_UNLOCK
argument_list|(
name|bo
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Process segments marks to free by cleaner */
end_comment

begin_function
specifier|static
name|void
name|nandfs_process_segments
parameter_list|(
name|struct
name|nandfs_device
modifier|*
name|fsdev
parameter_list|)
block|{
name|uint64_t
name|saved_segment
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|fsdev
operator|->
name|nd_free_base
condition|)
block|{
name|saved_segment
operator|=
name|nandfs_get_segnum_of_block
argument_list|(
name|fsdev
argument_list|,
name|fsdev
operator|->
name|nd_super
operator|.
name|s_last_pseg
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fsdev
operator|->
name|nd_free_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fsdev
operator|->
name|nd_free_base
index|[
name|i
index|]
operator|==
name|NANDFS_NOSEGMENT
condition|)
continue|continue;
comment|/* Update superblock if clearing segment point by it */
if|if
condition|(
name|fsdev
operator|->
name|nd_free_base
index|[
name|i
index|]
operator|==
name|saved_segment
condition|)
block|{
name|nandfs_write_superblock
argument_list|(
name|fsdev
argument_list|)
expr_stmt|;
name|saved_segment
operator|=
name|nandfs_get_segnum_of_block
argument_list|(
name|fsdev
argument_list|,
name|fsdev
operator|->
name|nd_super
operator|.
name|s_last_pseg
argument_list|)
expr_stmt|;
block|}
name|nandfs_invalidate_bufs
argument_list|(
name|fsdev
argument_list|,
name|fsdev
operator|->
name|nd_free_base
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|nandfs_clear_segment
argument_list|(
name|fsdev
argument_list|,
name|fsdev
operator|->
name|nd_free_base
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|fsdev
operator|->
name|nd_free_base
argument_list|,
name|M_NANDFSTEMP
argument_list|)
expr_stmt|;
name|fsdev
operator|->
name|nd_free_base
operator|=
name|NULL
expr_stmt|;
name|fsdev
operator|->
name|nd_free_count
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Collect and write dirty buffers */
end_comment

begin_function
name|int
name|nandfs_sync_file
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|)
block|{
name|struct
name|nandfs_device
modifier|*
name|fsdev
decl_stmt|;
name|struct
name|nandfs_node
modifier|*
name|nandfs_node
decl_stmt|;
name|struct
name|nandfsmount
modifier|*
name|nmp
decl_stmt|;
name|struct
name|nandfs_node
modifier|*
name|dat
decl_stmt|,
modifier|*
name|su
decl_stmt|,
modifier|*
name|ifile
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|struct
name|nandfs_seginfo
modifier|*
name|seginfo
init|=
name|NULL
decl_stmt|;
name|struct
name|nandfs_segment
modifier|*
name|seg
decl_stmt|;
name|int
name|update
decl_stmt|,
name|error
decl_stmt|;
name|int
name|cno_changed
decl_stmt|;
name|ASSERT_VOP_LOCKED
argument_list|(
name|vp
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|SYNC
argument_list|,
operator|(
literal|"%s: START\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|nmp
operator|=
name|VFSTONANDFS
argument_list|(
name|vp
operator|->
name|v_mount
argument_list|)
expr_stmt|;
name|fsdev
operator|=
name|nmp
operator|->
name|nm_nandfsdev
expr_stmt|;
name|dat
operator|=
name|fsdev
operator|->
name|nd_dat_node
expr_stmt|;
name|su
operator|=
name|fsdev
operator|->
name|nd_su_node
expr_stmt|;
name|cp
operator|=
name|fsdev
operator|->
name|nd_cp_node
expr_stmt|;
name|ifile
operator|=
name|nmp
operator|->
name|nm_ifile_node
expr_stmt|;
name|NANDFS_WRITEASSERT
argument_list|(
name|fsdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|lockmgr
argument_list|(
operator|&
name|fsdev
operator|->
name|nd_seg_const
argument_list|,
name|LK_UPGRADE
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|SYNC
argument_list|,
operator|(
literal|"%s: lost shared lock\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lockmgr
argument_list|(
operator|&
name|fsdev
operator|->
name|nd_seg_const
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"couldn't lock exclusive"
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
name|SYNC
argument_list|,
operator|(
literal|"%s: got lock\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|VOP_LOCK
argument_list|(
name|NTOV
argument_list|(
name|su
argument_list|)
argument_list|,
name|LK_EXCLUSIVE
argument_list|)
expr_stmt|;
name|create_seginfo
argument_list|(
name|fsdev
argument_list|,
operator|&
name|seginfo
argument_list|)
expr_stmt|;
name|update
operator|=
literal|0
expr_stmt|;
name|nandfs_node
operator|=
name|VTON
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nandfs_node
operator|->
name|nn_flags
operator|&
name|IN_MODIFIED
condition|)
block|{
name|nandfs_node
operator|->
name|nn_flags
operator|&=
operator|~
operator|(
name|IN_MODIFIED
operator|)
expr_stmt|;
name|update
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|vp
operator|->
name|v_bufobj
operator|.
name|bo_dirty
operator|.
name|bv_cnt
condition|)
block|{
name|error
operator|=
name|nandfs_iterate_dirty_buf
argument_list|(
name|vp
argument_list|,
name|seginfo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|clean_seginfo
argument_list|(
name|seginfo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|delete_seginfo
argument_list|(
name|seginfo
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|NTOV
argument_list|(
name|su
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lockmgr
argument_list|(
operator|&
name|fsdev
operator|->
name|nd_seg_const
argument_list|,
name|LK_DOWNGRADE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|nandfs_error
argument_list|(
literal|"%s: err:%d iterating dirty bufs vp:%p"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|,
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|update
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|update
condition|)
block|{
name|VOP_LOCK
argument_list|(
name|NTOV
argument_list|(
name|ifile
argument_list|)
argument_list|,
name|LK_EXCLUSIVE
argument_list|)
expr_stmt|;
name|error
operator|=
name|nandfs_node_update
argument_list|(
name|nandfs_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|clean_seginfo
argument_list|(
name|seginfo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|delete_seginfo
argument_list|(
name|seginfo
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|NTOV
argument_list|(
name|ifile
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|NTOV
argument_list|(
name|su
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lockmgr
argument_list|(
operator|&
name|fsdev
operator|->
name|nd_seg_const
argument_list|,
name|LK_DOWNGRADE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|nandfs_error
argument_list|(
literal|"%s: err:%d updating vp:%p"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|,
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|VOP_UNLOCK
argument_list|(
name|NTOV
argument_list|(
name|ifile
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|cno_changed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|seginfo
operator|->
name|blocks
condition|)
block|{
name|VOP_LOCK
argument_list|(
name|NTOV
argument_list|(
name|cp
argument_list|)
argument_list|,
name|LK_EXCLUSIVE
argument_list|)
expr_stmt|;
name|cno_changed
operator|=
literal|1
expr_stmt|;
comment|/* Create new checkpoint */
name|error
operator|=
name|nandfs_get_checkpoint
argument_list|(
name|fsdev
argument_list|,
name|cp
argument_list|,
name|fsdev
operator|->
name|nd_last_cno
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|clean_seginfo
argument_list|(
name|seginfo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|delete_seginfo
argument_list|(
name|seginfo
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|NTOV
argument_list|(
name|cp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|NTOV
argument_list|(
name|su
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lockmgr
argument_list|(
operator|&
name|fsdev
operator|->
name|nd_seg_const
argument_list|,
name|LK_DOWNGRADE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|nandfs_error
argument_list|(
literal|"%s: err:%d getting cp:%jx"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|,
name|fsdev
operator|->
name|nd_last_cno
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Reiterate all blocks and assign physical block number */
name|nandfs_seginfo_assign_pblk
argument_list|(
name|seginfo
argument_list|)
expr_stmt|;
comment|/* Fill checkpoint data */
name|error
operator|=
name|nandfs_set_checkpoint
argument_list|(
name|fsdev
argument_list|,
name|cp
argument_list|,
name|fsdev
operator|->
name|nd_last_cno
operator|+
literal|1
argument_list|,
operator|&
name|ifile
operator|->
name|nn_inode
argument_list|,
name|seginfo
operator|->
name|blocks
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|clean_seginfo
argument_list|(
name|seginfo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|delete_seginfo
argument_list|(
name|seginfo
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|NTOV
argument_list|(
name|cp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|NTOV
argument_list|(
name|su
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lockmgr
argument_list|(
operator|&
name|fsdev
operator|->
name|nd_seg_const
argument_list|,
name|LK_DOWNGRADE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|nandfs_error
argument_list|(
literal|"%s: err:%d setting cp:%jx"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|,
name|fsdev
operator|->
name|nd_last_cno
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|VOP_UNLOCK
argument_list|(
name|NTOV
argument_list|(
name|cp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|seg
argument_list|,
argument|&seginfo->seg_list
argument_list|,
argument|seg_link
argument_list|)
name|nandfs_update_segment
argument_list|(
name|fsdev
argument_list|,
name|seg
operator|->
name|seg_num
argument_list|,
name|seg
operator|->
name|nblocks
operator|+
name|seg
operator|->
name|segsum_blocks
argument_list|)
expr_stmt|;
name|VOP_LOCK
argument_list|(
name|NTOV
argument_list|(
name|dat
argument_list|)
argument_list|,
name|LK_EXCLUSIVE
argument_list|)
expr_stmt|;
name|error
operator|=
name|save_seginfo
argument_list|(
name|seginfo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|clean_seginfo
argument_list|(
name|seginfo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|delete_seginfo
argument_list|(
name|seginfo
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|NTOV
argument_list|(
name|dat
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|NTOV
argument_list|(
name|su
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lockmgr
argument_list|(
operator|&
name|fsdev
operator|->
name|nd_seg_const
argument_list|,
name|LK_DOWNGRADE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|nandfs_error
argument_list|(
literal|"%s: err:%d updating seg"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|VOP_UNLOCK
argument_list|(
name|NTOV
argument_list|(
name|dat
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|VOP_UNLOCK
argument_list|(
name|NTOV
argument_list|(
name|su
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|delete_seginfo
argument_list|(
name|seginfo
argument_list|)
expr_stmt|;
name|lockmgr
argument_list|(
operator|&
name|fsdev
operator|->
name|nd_seg_const
argument_list|,
name|LK_DOWNGRADE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|cno_changed
operator|&&
operator|!
name|error
condition|)
block|{
if|if
condition|(
name|nandfs_cps_between_sblocks
operator|!=
literal|0
operator|&&
name|fsdev
operator|->
name|nd_last_cno
operator|%
name|nandfs_cps_between_sblocks
operator|==
literal|0
condition|)
name|nandfs_write_superblock
argument_list|(
name|fsdev
argument_list|)
expr_stmt|;
block|}
name|ASSERT_VOP_LOCKED
argument_list|(
name|vp
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|SYNC
argument_list|,
operator|(
literal|"%s: END error %d\n"
operator|,
name|__func__
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nandfs_segment_constructor
parameter_list|(
name|struct
name|nandfsmount
modifier|*
name|nmp
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|nandfs_device
modifier|*
name|fsdev
decl_stmt|;
name|struct
name|nandfs_seginfo
modifier|*
name|seginfo
init|=
name|NULL
decl_stmt|;
name|struct
name|nandfs_segment
modifier|*
name|seg
decl_stmt|;
name|struct
name|nandfs_node
modifier|*
name|dat
decl_stmt|,
modifier|*
name|su
decl_stmt|,
modifier|*
name|ifile
decl_stmt|,
modifier|*
name|cp
decl_stmt|,
modifier|*
name|gc
decl_stmt|;
name|int
name|cno_changed
decl_stmt|,
name|error
decl_stmt|;
name|DPRINTF
argument_list|(
name|SYNC
argument_list|,
operator|(
literal|"%s: START\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|fsdev
operator|=
name|nmp
operator|->
name|nm_nandfsdev
expr_stmt|;
name|lockmgr
argument_list|(
operator|&
name|fsdev
operator|->
name|nd_seg_const
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|SYNC
argument_list|,
operator|(
literal|"%s: git lock\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|again
label|:
name|create_seginfo
argument_list|(
name|fsdev
argument_list|,
operator|&
name|seginfo
argument_list|)
expr_stmt|;
name|dat
operator|=
name|fsdev
operator|->
name|nd_dat_node
expr_stmt|;
name|su
operator|=
name|fsdev
operator|->
name|nd_su_node
expr_stmt|;
name|cp
operator|=
name|fsdev
operator|->
name|nd_cp_node
expr_stmt|;
name|gc
operator|=
name|fsdev
operator|->
name|nd_gc_node
expr_stmt|;
name|ifile
operator|=
name|nmp
operator|->
name|nm_ifile_node
expr_stmt|;
name|VOP_LOCK
argument_list|(
name|NTOV
argument_list|(
name|su
argument_list|)
argument_list|,
name|LK_EXCLUSIVE
argument_list|)
expr_stmt|;
name|VOP_LOCK
argument_list|(
name|NTOV
argument_list|(
name|ifile
argument_list|)
argument_list|,
name|LK_EXCLUSIVE
argument_list|)
expr_stmt|;
name|VOP_LOCK
argument_list|(
name|NTOV
argument_list|(
name|gc
argument_list|)
argument_list|,
name|LK_EXCLUSIVE
argument_list|)
expr_stmt|;
name|VOP_LOCK
argument_list|(
name|NTOV
argument_list|(
name|cp
argument_list|)
argument_list|,
name|LK_EXCLUSIVE
argument_list|)
expr_stmt|;
name|nandfs_iterate_system_vnode
argument_list|(
name|gc
argument_list|,
name|seginfo
argument_list|)
expr_stmt|;
name|nandfs_iterate_dirty_vnodes
argument_list|(
name|nmp
operator|->
name|nm_vfs_mountp
argument_list|,
name|seginfo
argument_list|)
expr_stmt|;
name|nandfs_iterate_system_vnode
argument_list|(
name|ifile
argument_list|,
name|seginfo
argument_list|)
expr_stmt|;
name|nandfs_iterate_system_vnode
argument_list|(
name|su
argument_list|,
name|seginfo
argument_list|)
expr_stmt|;
name|cno_changed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|seginfo
operator|->
name|blocks
operator|||
name|flags
condition|)
block|{
name|cno_changed
operator|=
literal|1
expr_stmt|;
comment|/* Create new checkpoint */
name|error
operator|=
name|nandfs_get_checkpoint
argument_list|(
name|fsdev
argument_list|,
name|cp
argument_list|,
name|fsdev
operator|->
name|nd_last_cno
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|clean_seginfo
argument_list|(
name|seginfo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|delete_seginfo
argument_list|(
name|seginfo
argument_list|)
expr_stmt|;
goto|goto
name|error_locks
goto|;
block|}
comment|/* Collect blocks from system files */
name|nandfs_iterate_system_vnode
argument_list|(
name|cp
argument_list|,
name|seginfo
argument_list|)
expr_stmt|;
name|nandfs_iterate_system_vnode
argument_list|(
name|su
argument_list|,
name|seginfo
argument_list|)
expr_stmt|;
name|VOP_LOCK
argument_list|(
name|NTOV
argument_list|(
name|dat
argument_list|)
argument_list|,
name|LK_EXCLUSIVE
argument_list|)
expr_stmt|;
name|nandfs_iterate_system_vnode
argument_list|(
name|dat
argument_list|,
name|seginfo
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|NTOV
argument_list|(
name|dat
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|reiterate
label|:
name|seginfo
operator|->
name|reiterate
operator|=
literal|0
expr_stmt|;
name|nandfs_iterate_system_vnode
argument_list|(
name|su
argument_list|,
name|seginfo
argument_list|)
expr_stmt|;
name|VOP_LOCK
argument_list|(
name|NTOV
argument_list|(
name|dat
argument_list|)
argument_list|,
name|LK_EXCLUSIVE
argument_list|)
expr_stmt|;
name|nandfs_iterate_system_vnode
argument_list|(
name|dat
argument_list|,
name|seginfo
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|NTOV
argument_list|(
name|dat
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|seginfo
operator|->
name|reiterate
condition|)
goto|goto
name|reiterate
goto|;
if|if
condition|(
operator|!
operator|(
name|seginfo
operator|->
name|curseg
operator|)
operator|||
operator|!
name|seginfo
operator|->
name|curseg
operator|->
name|num_blocks
condition|)
block|{
name|error
operator|=
name|create_segment
argument_list|(
name|seginfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|clean_seginfo
argument_list|(
name|seginfo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|delete_seginfo
argument_list|(
name|seginfo
argument_list|)
expr_stmt|;
goto|goto
name|error_locks
goto|;
block|}
goto|goto
name|reiterate
goto|;
block|}
comment|/* Reiterate all blocks and assign physical block number */
name|nandfs_seginfo_assign_pblk
argument_list|(
name|seginfo
argument_list|)
expr_stmt|;
comment|/* Fill superroot */
name|error
operator|=
name|nandfs_add_superroot
argument_list|(
name|seginfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|clean_seginfo
argument_list|(
name|seginfo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|delete_seginfo
argument_list|(
name|seginfo
argument_list|)
expr_stmt|;
goto|goto
name|error_locks
goto|;
block|}
name|KASSERT
argument_list|(
operator|!
operator|(
name|seginfo
operator|->
name|reiterate
operator|)
argument_list|,
operator|(
literal|"reiteration after superroot"
operator|)
argument_list|)
expr_stmt|;
comment|/* Fill checkpoint data */
name|nandfs_set_checkpoint
argument_list|(
name|fsdev
argument_list|,
name|cp
argument_list|,
name|fsdev
operator|->
name|nd_last_cno
operator|+
literal|1
argument_list|,
operator|&
name|ifile
operator|->
name|nn_inode
argument_list|,
name|seginfo
operator|->
name|blocks
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|seg
argument_list|,
argument|&seginfo->seg_list
argument_list|,
argument|seg_link
argument_list|)
name|nandfs_update_segment
argument_list|(
name|fsdev
argument_list|,
name|seg
operator|->
name|seg_num
argument_list|,
name|seg
operator|->
name|nblocks
operator|+
name|seg
operator|->
name|segsum_blocks
argument_list|)
expr_stmt|;
name|VOP_LOCK
argument_list|(
name|NTOV
argument_list|(
name|dat
argument_list|)
argument_list|,
name|LK_EXCLUSIVE
argument_list|)
expr_stmt|;
name|error
operator|=
name|save_seginfo
argument_list|(
name|seginfo
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|clean_seginfo
argument_list|(
name|seginfo
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|delete_seginfo
argument_list|(
name|seginfo
argument_list|)
expr_stmt|;
goto|goto
name|error_dat
goto|;
block|}
name|VOP_UNLOCK
argument_list|(
name|NTOV
argument_list|(
name|dat
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|VOP_UNLOCK
argument_list|(
name|NTOV
argument_list|(
name|cp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|NTOV
argument_list|(
name|gc
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|NTOV
argument_list|(
name|ifile
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nandfs_process_segments
argument_list|(
name|fsdev
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|NTOV
argument_list|(
name|su
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|delete_seginfo
argument_list|(
name|seginfo
argument_list|)
expr_stmt|;
comment|/* 	 * XXX: a hack, will go away soon 	 */
if|if
condition|(
operator|(
name|NTOV
argument_list|(
name|dat
argument_list|)
operator|->
name|v_bufobj
operator|.
name|bo_dirty
operator|.
name|bv_cnt
operator|!=
literal|0
operator|||
name|NTOV
argument_list|(
name|cp
argument_list|)
operator|->
name|v_bufobj
operator|.
name|bo_dirty
operator|.
name|bv_cnt
operator|!=
literal|0
operator|||
name|NTOV
argument_list|(
name|gc
argument_list|)
operator|->
name|v_bufobj
operator|.
name|bo_dirty
operator|.
name|bv_cnt
operator|!=
literal|0
operator|||
name|NTOV
argument_list|(
name|ifile
argument_list|)
operator|->
name|v_bufobj
operator|.
name|bo_dirty
operator|.
name|bv_cnt
operator|!=
literal|0
operator|||
name|NTOV
argument_list|(
name|su
argument_list|)
operator|->
name|v_bufobj
operator|.
name|bo_dirty
operator|.
name|bv_cnt
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|flags
operator|&
name|NANDFS_UMOUNT
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
name|SYNC
argument_list|,
operator|(
literal|"%s: RERUN\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
name|MPASS
argument_list|(
name|fsdev
operator|->
name|nd_free_base
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|lockmgr
argument_list|(
operator|&
name|fsdev
operator|->
name|nd_seg_const
argument_list|,
name|LK_RELEASE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|cno_changed
condition|)
block|{
if|if
condition|(
operator|(
name|nandfs_cps_between_sblocks
operator|!=
literal|0
operator|&&
name|fsdev
operator|->
name|nd_last_cno
operator|%
name|nandfs_cps_between_sblocks
operator|==
literal|0
operator|)
operator|||
name|flags
operator|&
name|NANDFS_UMOUNT
condition|)
name|nandfs_write_superblock
argument_list|(
name|fsdev
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
name|SYNC
argument_list|,
operator|(
literal|"%s: END\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|error_dat
label|:
name|VOP_UNLOCK
argument_list|(
name|NTOV
argument_list|(
name|dat
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|error_locks
label|:
name|VOP_UNLOCK
argument_list|(
name|NTOV
argument_list|(
name|cp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|NTOV
argument_list|(
name|gc
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|NTOV
argument_list|(
name|ifile
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|NTOV
argument_list|(
name|su
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lockmgr
argument_list|(
operator|&
name|fsdev
operator|->
name|nd_seg_const
argument_list|,
name|LK_RELEASE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_comment
comment|/*  * Show details about the given NANDFS mount point.  */
end_comment

begin_macro
name|DB_SHOW_COMMAND
argument_list|(
argument|nandfs
argument_list|,
argument|db_show_nandfs
argument_list|)
end_macro

begin_block
block|{
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|struct
name|nandfs_device
modifier|*
name|nffsdev
decl_stmt|;
name|struct
name|nandfs_segment
modifier|*
name|seg
decl_stmt|;
name|struct
name|nandfsmount
modifier|*
name|nmp
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
if|if
condition|(
operator|!
name|have_addr
condition|)
block|{
name|db_printf
argument_list|(
literal|"\nUsage: show nandfs<mount_addr>\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|mp
operator|=
operator|(
expr|struct
name|mount
operator|*
operator|)
name|addr
expr_stmt|;
name|db_printf
argument_list|(
literal|"%p %s on %s (%s)\n"
argument_list|,
name|mp
argument_list|,
name|mp
operator|->
name|mnt_stat
operator|.
name|f_mntfromname
argument_list|,
name|mp
operator|->
name|mnt_stat
operator|.
name|f_mntonname
argument_list|,
name|mp
operator|->
name|mnt_stat
operator|.
name|f_fstypename
argument_list|)
expr_stmt|;
name|nmp
operator|=
operator|(
expr|struct
name|nandfsmount
operator|*
operator|)
operator|(
name|mp
operator|->
name|mnt_data
operator|)
expr_stmt|;
name|nffsdev
operator|=
name|nmp
operator|->
name|nm_nandfsdev
expr_stmt|;
name|db_printf
argument_list|(
literal|"dev vnode:%p\n"
argument_list|,
name|nffsdev
operator|->
name|nd_devvp
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"blocksize:%jx last cno:%jx last pseg:%jx seg num:%jx\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|nffsdev
operator|->
name|nd_blocksize
argument_list|,
operator|(
name|uintmax_t
operator|)
name|nffsdev
operator|->
name|nd_last_cno
argument_list|,
operator|(
name|uintmax_t
operator|)
name|nffsdev
operator|->
name|nd_last_pseg
argument_list|,
operator|(
name|uintmax_t
operator|)
name|nffsdev
operator|->
name|nd_seg_num
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"system nodes: dat:%p cp:%p su:%p ifile:%p gc:%p\n"
argument_list|,
name|nffsdev
operator|->
name|nd_dat_node
argument_list|,
name|nffsdev
operator|->
name|nd_cp_node
argument_list|,
name|nffsdev
operator|->
name|nd_su_node
argument_list|,
name|nmp
operator|->
name|nm_ifile_node
argument_list|,
name|nffsdev
operator|->
name|nd_gc_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|nffsdev
operator|->
name|nd_seginfo
operator|!=
name|NULL
condition|)
block|{
name|LIST_FOREACH
argument_list|(
argument|seg
argument_list|,
argument|&nffsdev->nd_seginfo->seg_list
argument_list|,
argument|seg_link
argument_list|)
block|{
name|db_printf
argument_list|(
literal|"seg: %p\n"
argument_list|,
name|seg
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|bp
argument_list|,
argument|&seg->segsum
argument_list|,
argument|b_cluster.cluster_entry
argument_list|)
name|db_printf
argument_list|(
literal|"segbp %p\n"
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|bp
argument_list|,
argument|&seg->data
argument_list|,
argument|b_cluster.cluster_entry
argument_list|)
block|{
name|vp
operator|=
name|bp
operator|->
name|b_vp
expr_stmt|;
name|db_printf
argument_list|(
literal|"bp:%p bp->b_vp:%p ino:%jx\n"
argument_list|,
name|bp
argument_list|,
name|vp
argument_list|,
call|(
name|uintmax_t
call|)
argument_list|(
name|vp
condition|?
name|VTON
argument_list|(
name|vp
argument_list|)
operator|->
name|nn_ino
else|:
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

