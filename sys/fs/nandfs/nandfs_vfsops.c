begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2010-2012 Semihalf  * Copyright (c) 2008, 2009 Reinoud Zandijk  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * From: NetBSD: nilfs_vfsops.c,v 1.1 2009/07/18 16:31:42 reinoud Exp  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/libkern.h>
end_include

begin_include
include|#
directive|include
file|<geom/geom.h>
end_include

begin_include
include|#
directive|include
file|<geom/geom_vfs.h>
end_include

begin_include
include|#
directive|include
file|<machine/_inttypes.h>
end_include

begin_include
include|#
directive|include
file|<fs/nandfs/nandfs_mount.h>
end_include

begin_include
include|#
directive|include
file|<fs/nandfs/nandfs.h>
end_include

begin_include
include|#
directive|include
file|<fs/nandfs/nandfs_subr.h>
end_include

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_NANDFSMNT
argument_list|,
literal|"nandfs_mount"
argument_list|,
literal|"NANDFS mount structure"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|NANDFS_SET_SYSTEMFILE
parameter_list|(
name|vp
parameter_list|)
value|{	\ 	(vp)->v_vflag |= VV_SYSTEM;	\ 	vref(vp);			\ 	vput(vp); }
end_define

begin_define
define|#
directive|define
name|NANDFS_UNSET_SYSTEMFILE
parameter_list|(
name|vp
parameter_list|)
value|{	\ 	VOP_LOCK(vp, LK_EXCLUSIVE);	\ 	MPASS(vp->v_bufobj.bo_dirty.bv_cnt == 0); \ 	(vp)->v_vflag&= ~VV_SYSTEM;	\ 	vgone(vp);			\ 	vput(vp); }
end_define

begin_comment
comment|/* Globals */
end_comment

begin_decl_stmt
name|struct
name|_nandfs_devices
name|nandfs_devices
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parameters */
end_comment

begin_decl_stmt
name|int
name|nandfs_verbose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|nandfs_tunable_init
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|TUNABLE_INT_FETCH
argument_list|(
literal|"vfs.nandfs.verbose"
argument_list|,
operator|&
name|nandfs_verbose
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|nandfs_tunables
argument_list|,
name|SI_SUB_VFS
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|nandfs_tunable_init
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_vfs
argument_list|,
name|OID_AUTO
argument_list|,
name|nandfs
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"NAND filesystem"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_vfs_nandfs
argument_list|,
name|OID_AUTO
argument_list|,
name|mount
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"NANDFS mountpoints"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_nandfs
argument_list|,
name|OID_AUTO
argument_list|,
name|verbose
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|nandfs_verbose
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|NANDFS_CONSTR_INTERVAL
value|5
end_define

begin_decl_stmt
name|int
name|nandfs_sync_interval
init|=
name|NANDFS_CONSTR_INTERVAL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* sync every 5 seconds */
end_comment

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_vfs_nandfs
argument_list|,
name|OID_AUTO
argument_list|,
name|sync_interval
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|nandfs_sync_interval
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|NANDFS_MAX_DIRTY_SEGS
value|5
end_define

begin_decl_stmt
name|int
name|nandfs_max_dirty_segs
init|=
name|NANDFS_MAX_DIRTY_SEGS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* sync when 5 dirty seg */
end_comment

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_vfs_nandfs
argument_list|,
name|OID_AUTO
argument_list|,
name|max_dirty_segs
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|nandfs_max_dirty_segs
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|NANDFS_CPS_BETWEEN_SBLOCKS
value|5
end_define

begin_decl_stmt
name|int
name|nandfs_cps_between_sblocks
init|=
name|NANDFS_CPS_BETWEEN_SBLOCKS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* write superblock every 5 checkpoints */
end_comment

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_vfs_nandfs
argument_list|,
name|OID_AUTO
argument_list|,
name|cps_between_sblocks
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|nandfs_cps_between_sblocks
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|NANDFS_CLEANER_ENABLE
value|1
end_define

begin_decl_stmt
name|int
name|nandfs_cleaner_enable
init|=
name|NANDFS_CLEANER_ENABLE
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_vfs_nandfs
argument_list|,
name|OID_AUTO
argument_list|,
name|cleaner_enable
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|nandfs_cleaner_enable
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|NANDFS_CLEANER_INTERVAL
value|5
end_define

begin_decl_stmt
name|int
name|nandfs_cleaner_interval
init|=
name|NANDFS_CLEANER_INTERVAL
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_vfs_nandfs
argument_list|,
name|OID_AUTO
argument_list|,
name|cleaner_interval
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|nandfs_cleaner_interval
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|NANDFS_CLEANER_SEGMENTS
value|5
end_define

begin_decl_stmt
name|int
name|nandfs_cleaner_segments
init|=
name|NANDFS_CLEANER_SEGMENTS
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_vfs_nandfs
argument_list|,
name|OID_AUTO
argument_list|,
name|cleaner_segments
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|nandfs_cleaner_segments
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|int
name|nandfs_mountfs
parameter_list|(
name|struct
name|vnode
modifier|*
name|devvp
parameter_list|,
name|struct
name|mount
modifier|*
name|mp
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|vfs_mount_t
name|nandfs_mount
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vfs_root_t
name|nandfs_root
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vfs_statfs_t
name|nandfs_statfs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vfs_unmount_t
name|nandfs_unmount
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vfs_vget_t
name|nandfs_vget
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vfs_sync_t
name|nandfs_sync
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|nandfs_opts
index|[]
init|=
block|{
literal|"snap"
block|,
literal|"from"
block|,
literal|"noatime"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* System nodes */
end_comment

begin_function
specifier|static
name|int
name|nandfs_create_system_nodes
parameter_list|(
name|struct
name|nandfs_device
modifier|*
name|nandfsdev
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|nandfs_get_node_raw
argument_list|(
name|nandfsdev
argument_list|,
name|NULL
argument_list|,
name|NANDFS_DAT_INO
argument_list|,
operator|&
name|nandfsdev
operator|->
name|nd_super_root
operator|.
name|sr_dat
argument_list|,
operator|&
name|nandfsdev
operator|->
name|nd_dat_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|errorout
goto|;
name|error
operator|=
name|nandfs_get_node_raw
argument_list|(
name|nandfsdev
argument_list|,
name|NULL
argument_list|,
name|NANDFS_CPFILE_INO
argument_list|,
operator|&
name|nandfsdev
operator|->
name|nd_super_root
operator|.
name|sr_cpfile
argument_list|,
operator|&
name|nandfsdev
operator|->
name|nd_cp_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|errorout
goto|;
name|error
operator|=
name|nandfs_get_node_raw
argument_list|(
name|nandfsdev
argument_list|,
name|NULL
argument_list|,
name|NANDFS_SUFILE_INO
argument_list|,
operator|&
name|nandfsdev
operator|->
name|nd_super_root
operator|.
name|sr_sufile
argument_list|,
operator|&
name|nandfsdev
operator|->
name|nd_su_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|errorout
goto|;
name|error
operator|=
name|nandfs_get_node_raw
argument_list|(
name|nandfsdev
argument_list|,
name|NULL
argument_list|,
name|NANDFS_GC_INO
argument_list|,
name|NULL
argument_list|,
operator|&
name|nandfsdev
operator|->
name|nd_gc_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|errorout
goto|;
name|NANDFS_SET_SYSTEMFILE
argument_list|(
name|NTOV
argument_list|(
name|nandfsdev
operator|->
name|nd_dat_node
argument_list|)
argument_list|)
expr_stmt|;
name|NANDFS_SET_SYSTEMFILE
argument_list|(
name|NTOV
argument_list|(
name|nandfsdev
operator|->
name|nd_cp_node
argument_list|)
argument_list|)
expr_stmt|;
name|NANDFS_SET_SYSTEMFILE
argument_list|(
name|NTOV
argument_list|(
name|nandfsdev
operator|->
name|nd_su_node
argument_list|)
argument_list|)
expr_stmt|;
name|NANDFS_SET_SYSTEMFILE
argument_list|(
name|NTOV
argument_list|(
name|nandfsdev
operator|->
name|nd_gc_node
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|VOLUMES
argument_list|,
operator|(
literal|"System vnodes: dat: %p cp: %p su: %p\n"
operator|,
name|NTOV
argument_list|(
name|nandfsdev
operator|->
name|nd_dat_node
argument_list|)
operator|,
name|NTOV
argument_list|(
name|nandfsdev
operator|->
name|nd_cp_node
argument_list|)
operator|,
name|NTOV
argument_list|(
name|nandfsdev
operator|->
name|nd_su_node
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|errorout
label|:
name|nandfs_dispose_node
argument_list|(
operator|&
name|nandfsdev
operator|->
name|nd_gc_node
argument_list|)
expr_stmt|;
name|nandfs_dispose_node
argument_list|(
operator|&
name|nandfsdev
operator|->
name|nd_dat_node
argument_list|)
expr_stmt|;
name|nandfs_dispose_node
argument_list|(
operator|&
name|nandfsdev
operator|->
name|nd_cp_node
argument_list|)
expr_stmt|;
name|nandfs_dispose_node
argument_list|(
operator|&
name|nandfsdev
operator|->
name|nd_su_node
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nandfs_release_system_nodes
parameter_list|(
name|struct
name|nandfs_device
modifier|*
name|nandfsdev
parameter_list|)
block|{
if|if
condition|(
operator|!
name|nandfsdev
condition|)
return|return;
if|if
condition|(
name|nandfsdev
operator|->
name|nd_refcnt
operator|>
literal|0
condition|)
return|return;
if|if
condition|(
name|nandfsdev
operator|->
name|nd_gc_node
condition|)
name|NANDFS_UNSET_SYSTEMFILE
argument_list|(
name|NTOV
argument_list|(
name|nandfsdev
operator|->
name|nd_gc_node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nandfsdev
operator|->
name|nd_dat_node
condition|)
name|NANDFS_UNSET_SYSTEMFILE
argument_list|(
name|NTOV
argument_list|(
name|nandfsdev
operator|->
name|nd_dat_node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nandfsdev
operator|->
name|nd_cp_node
condition|)
name|NANDFS_UNSET_SYSTEMFILE
argument_list|(
name|NTOV
argument_list|(
name|nandfsdev
operator|->
name|nd_cp_node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nandfsdev
operator|->
name|nd_su_node
condition|)
name|NANDFS_UNSET_SYSTEMFILE
argument_list|(
name|NTOV
argument_list|(
name|nandfsdev
operator|->
name|nd_su_node
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|nandfs_check_fsdata_crc
parameter_list|(
name|struct
name|nandfs_fsdata
modifier|*
name|fsdata
parameter_list|)
block|{
name|uint32_t
name|fsdata_crc
decl_stmt|,
name|comp_crc
decl_stmt|;
if|if
condition|(
name|fsdata
operator|->
name|f_magic
operator|!=
name|NANDFS_FSDATA_MAGIC
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Preserve CRC */
name|fsdata_crc
operator|=
name|fsdata
operator|->
name|f_sum
expr_stmt|;
comment|/* Calculate */
name|fsdata
operator|->
name|f_sum
operator|=
operator|(
literal|0
operator|)
expr_stmt|;
name|comp_crc
operator|=
name|crc32
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
name|fsdata
argument_list|,
name|fsdata
operator|->
name|f_bytes
argument_list|)
expr_stmt|;
comment|/* Restore */
name|fsdata
operator|->
name|f_sum
operator|=
name|fsdata_crc
expr_stmt|;
comment|/* Check CRC */
return|return
operator|(
name|fsdata_crc
operator|==
name|comp_crc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nandfs_check_superblock_crc
parameter_list|(
name|struct
name|nandfs_fsdata
modifier|*
name|fsdata
parameter_list|,
name|struct
name|nandfs_super_block
modifier|*
name|super
parameter_list|)
block|{
name|uint32_t
name|super_crc
decl_stmt|,
name|comp_crc
decl_stmt|;
comment|/* Check super block magic */
if|if
condition|(
name|super
operator|->
name|s_magic
operator|!=
name|NANDFS_SUPER_MAGIC
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Preserve CRC */
name|super_crc
operator|=
name|super
operator|->
name|s_sum
expr_stmt|;
comment|/* Calculate */
name|super
operator|->
name|s_sum
operator|=
operator|(
literal|0
operator|)
expr_stmt|;
name|comp_crc
operator|=
name|crc32
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
name|super
argument_list|,
name|fsdata
operator|->
name|f_sbbytes
argument_list|)
expr_stmt|;
comment|/* Restore */
name|super
operator|->
name|s_sum
operator|=
name|super_crc
expr_stmt|;
comment|/* Check CRC */
return|return
operator|(
name|super_crc
operator|==
name|comp_crc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nandfs_calc_superblock_crc
parameter_list|(
name|struct
name|nandfs_fsdata
modifier|*
name|fsdata
parameter_list|,
name|struct
name|nandfs_super_block
modifier|*
name|super
parameter_list|)
block|{
name|uint32_t
name|comp_crc
decl_stmt|;
comment|/* Calculate */
name|super
operator|->
name|s_sum
operator|=
literal|0
expr_stmt|;
name|comp_crc
operator|=
name|crc32
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
name|super
argument_list|,
name|fsdata
operator|->
name|f_sbbytes
argument_list|)
expr_stmt|;
comment|/* Restore */
name|super
operator|->
name|s_sum
operator|=
name|comp_crc
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|nandfs_is_empty
parameter_list|(
name|u_char
modifier|*
name|area
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|area
index|[
name|i
index|]
operator|!=
literal|0xff
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|nandfs_sblocks_in_esize
parameter_list|(
name|struct
name|nandfs_device
modifier|*
name|fsdev
parameter_list|)
block|{
return|return
operator|(
operator|(
name|fsdev
operator|->
name|nd_erasesize
operator|-
name|NANDFS_SBLOCK_OFFSET_BYTES
operator|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|nandfs_super_block
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|nandfs_max_sblocks
parameter_list|(
name|struct
name|nandfs_device
modifier|*
name|fsdev
parameter_list|)
block|{
return|return
operator|(
name|NANDFS_NFSAREAS
operator|*
name|nandfs_sblocks_in_esize
argument_list|(
name|fsdev
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|nandfs_sblocks_in_block
parameter_list|(
name|struct
name|nandfs_device
modifier|*
name|fsdev
parameter_list|)
block|{
return|return
operator|(
name|fsdev
operator|->
name|nd_devblocksize
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|nandfs_super_block
argument_list|)
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static __inline int nandfs_sblocks_in_first_block(struct nandfs_device *fsdev) { 	int n;  	n = nandfs_sblocks_in_block(fsdev) - 	    NANDFS_SBLOCK_OFFSET_BYTES / sizeof(struct nandfs_super_block); 	if (n< 0) 		n = 0;  	return (n); }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|nandfs_write_superblock_at
parameter_list|(
name|struct
name|nandfs_device
modifier|*
name|fsdev
parameter_list|,
name|struct
name|nandfs_fsarea
modifier|*
name|fstp
parameter_list|)
block|{
name|struct
name|nandfs_super_block
modifier|*
name|super
decl_stmt|,
modifier|*
name|supert
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|sb_per_sector
decl_stmt|,
name|sbs_in_fsd
decl_stmt|,
name|read_block
decl_stmt|;
name|int
name|index
decl_stmt|,
name|pos
decl_stmt|,
name|error
decl_stmt|;
name|off_t
name|offset
decl_stmt|;
name|DPRINTF
argument_list|(
name|SYNC
argument_list|,
operator|(
literal|"%s: last_used %d nandfs_sblocks_in_esize %d\n"
operator|,
name|__func__
operator|,
name|fstp
operator|->
name|last_used
operator|,
name|nandfs_sblocks_in_esize
argument_list|(
name|fsdev
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fstp
operator|->
name|last_used
operator|==
name|nandfs_sblocks_in_esize
argument_list|(
name|fsdev
argument_list|)
operator|-
literal|1
condition|)
name|index
operator|=
literal|0
expr_stmt|;
else|else
name|index
operator|=
name|fstp
operator|->
name|last_used
operator|+
literal|1
expr_stmt|;
name|super
operator|=
operator|&
name|fsdev
operator|->
name|nd_super
expr_stmt|;
name|supert
operator|=
name|NULL
expr_stmt|;
name|sb_per_sector
operator|=
name|nandfs_sblocks_in_block
argument_list|(
name|fsdev
argument_list|)
expr_stmt|;
name|sbs_in_fsd
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|nandfs_fsdata
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|nandfs_super_block
argument_list|)
expr_stmt|;
name|index
operator|+=
name|sbs_in_fsd
expr_stmt|;
name|offset
operator|=
name|fstp
operator|->
name|offset
expr_stmt|;
name|DPRINTF
argument_list|(
name|SYNC
argument_list|,
operator|(
literal|"%s: offset %#jx s_last_pseg %#jx s_last_cno %#jx "
literal|"s_last_seq %#jx wtime %jd index %d\n"
operator|,
name|__func__
operator|,
name|offset
operator|,
name|super
operator|->
name|s_last_pseg
operator|,
name|super
operator|->
name|s_last_cno
operator|,
name|super
operator|->
name|s_last_seq
operator|,
name|super
operator|->
name|s_wtime
operator|,
name|index
operator|)
argument_list|)
expr_stmt|;
name|read_block
operator|=
name|btodb
argument_list|(
name|offset
operator|+
operator|(
operator|(
name|index
operator|/
name|sb_per_sector
operator|)
operator|*
name|sb_per_sector
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|nandfs_super_block
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|SYNC
argument_list|,
operator|(
literal|"%s: read_block %#x\n"
operator|,
name|__func__
operator|,
name|read_block
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|==
name|sbs_in_fsd
condition|)
block|{
name|error
operator|=
name|nandfs_erase
argument_list|(
name|fsdev
argument_list|,
name|offset
argument_list|,
name|fsdev
operator|->
name|nd_erasesize
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|bread
argument_list|(
name|fsdev
operator|->
name|nd_devvp
argument_list|,
name|btodb
argument_list|(
name|offset
argument_list|)
argument_list|,
name|fsdev
operator|->
name|nd_devblocksize
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"NANDFS: couldn't read initial data: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|memcpy
argument_list|(
name|bp
operator|->
name|b_data
argument_list|,
operator|&
name|fsdev
operator|->
name|nd_fsdata
argument_list|,
sizeof|sizeof
argument_list|(
name|fsdev
operator|->
name|nd_fsdata
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * 0xff-out the rest. This bp could be cached, so potentially 		 * b_data contains stale super blocks. 		 * 		 * We don't mind cached bp since most of the time we just add 		 * super blocks to already 0xff-out b_data and don't need to 		 * perform actual read. 		 */
if|if
condition|(
name|fsdev
operator|->
name|nd_devblocksize
operator|>
sizeof|sizeof
argument_list|(
name|fsdev
operator|->
name|nd_fsdata
argument_list|)
condition|)
name|memset
argument_list|(
name|bp
operator|->
name|b_data
operator|+
sizeof|sizeof
argument_list|(
name|fsdev
operator|->
name|nd_fsdata
argument_list|)
argument_list|,
literal|0xff
argument_list|,
name|fsdev
operator|->
name|nd_devblocksize
operator|-
sizeof|sizeof
argument_list|(
name|fsdev
operator|->
name|nd_fsdata
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|bwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"NANDFS: cannot rewrite initial data at %jx\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
name|error
operator|=
name|bread
argument_list|(
name|fsdev
operator|->
name|nd_devvp
argument_list|,
name|read_block
argument_list|,
name|fsdev
operator|->
name|nd_devblocksize
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|supert
operator|=
operator|(
expr|struct
name|nandfs_super_block
operator|*
operator|)
operator|(
name|bp
operator|->
name|b_data
operator|)
expr_stmt|;
name|pos
operator|=
name|index
operator|%
name|sb_per_sector
expr_stmt|;
name|DPRINTF
argument_list|(
name|SYNC
argument_list|,
operator|(
literal|"%s: storing at %d\n"
operator|,
name|__func__
operator|,
name|pos
operator|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|supert
index|[
name|pos
index|]
argument_list|,
name|super
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nandfs_super_block
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * See comment above in code that performs erase. 	 */
if|if
condition|(
name|pos
operator|==
literal|0
condition|)
name|memset
argument_list|(
operator|&
name|supert
index|[
literal|1
index|]
argument_list|,
literal|0xff
argument_list|,
operator|(
name|sb_per_sector
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|nandfs_super_block
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|bwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"NANDFS: cannot update superblock at %jx\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|DPRINTF
argument_list|(
name|SYNC
argument_list|,
operator|(
literal|"%s: fstp->last_used %d -> %d\n"
operator|,
name|__func__
operator|,
name|fstp
operator|->
name|last_used
operator|,
name|index
operator|-
name|sbs_in_fsd
operator|)
argument_list|)
expr_stmt|;
name|fstp
operator|->
name|last_used
operator|=
name|index
operator|-
name|sbs_in_fsd
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nandfs_write_superblock
parameter_list|(
name|struct
name|nandfs_device
modifier|*
name|fsdev
parameter_list|)
block|{
name|struct
name|nandfs_super_block
modifier|*
name|super
decl_stmt|;
name|struct
name|timespec
name|ts
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|vfs_timestamp
argument_list|(
operator|&
name|ts
argument_list|)
expr_stmt|;
name|super
operator|=
operator|&
name|fsdev
operator|->
name|nd_super
expr_stmt|;
name|super
operator|->
name|s_last_pseg
operator|=
name|fsdev
operator|->
name|nd_last_pseg
expr_stmt|;
name|super
operator|->
name|s_last_cno
operator|=
name|fsdev
operator|->
name|nd_last_cno
expr_stmt|;
name|super
operator|->
name|s_last_seq
operator|=
name|fsdev
operator|->
name|nd_seg_sequence
expr_stmt|;
name|super
operator|->
name|s_wtime
operator|=
name|ts
operator|.
name|tv_sec
expr_stmt|;
name|nandfs_calc_superblock_crc
argument_list|(
operator|&
name|fsdev
operator|->
name|nd_fsdata
argument_list|,
name|super
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
name|fsdev
operator|->
name|nd_last_fsarea
init|;
name|i
operator|<
name|NANDFS_NFSAREAS
condition|;
name|i
operator|++
operator|,
name|j
operator|=
operator|(
name|j
operator|+
literal|1
operator|%
name|NANDFS_NFSAREAS
operator|)
control|)
block|{
if|if
condition|(
name|fsdev
operator|->
name|nd_fsarea
index|[
name|j
index|]
operator|.
name|flags
operator|&
name|NANDFS_FSSTOR_FAILED
condition|)
block|{
name|DPRINTF
argument_list|(
name|SYNC
argument_list|,
operator|(
literal|"%s: skipping %d\n"
operator|,
name|__func__
operator|,
name|j
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|error
operator|=
name|nandfs_write_superblock_at
argument_list|(
name|fsdev
argument_list|,
operator|&
name|fsdev
operator|->
name|nd_fsarea
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"NANDFS: writing superblock at offset %d failed:"
literal|"%d\n"
argument_list|,
name|j
operator|*
name|fsdev
operator|->
name|nd_erasesize
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|fsdev
operator|->
name|nd_fsarea
index|[
name|j
index|]
operator|.
name|flags
operator||=
name|NANDFS_FSSTOR_FAILED
expr_stmt|;
block|}
else|else
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|NANDFS_NFSAREAS
condition|)
block|{
name|printf
argument_list|(
literal|"NANDFS: superblock was not written\n"
argument_list|)
expr_stmt|;
comment|/* 		 * TODO: switch to read-only? 		 */
return|return
operator|(
name|error
operator|)
return|;
block|}
else|else
name|fsdev
operator|->
name|nd_last_fsarea
operator|=
operator|(
name|j
operator|+
literal|1
operator|)
operator|%
name|NANDFS_NFSAREAS
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nandfs_select_fsdata
parameter_list|(
name|struct
name|nandfs_device
modifier|*
name|fsdev
parameter_list|,
name|struct
name|nandfs_fsdata
modifier|*
name|fsdatat
parameter_list|,
name|struct
name|nandfs_fsdata
modifier|*
modifier|*
name|fsdata
parameter_list|,
name|int
name|nfsds
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
operator|*
name|fsdata
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfsds
condition|;
name|i
operator|++
control|)
block|{
name|DPRINTF
argument_list|(
name|VOLUMES
argument_list|,
operator|(
literal|"%s: i %d f_magic %x f_crc %x\n"
operator|,
name|__func__
operator|,
name|i
operator|,
name|fsdatat
index|[
name|i
index|]
operator|.
name|f_magic
operator|,
name|fsdatat
index|[
name|i
index|]
operator|.
name|f_sum
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nandfs_check_fsdata_crc
argument_list|(
operator|&
name|fsdatat
index|[
name|i
index|]
argument_list|)
condition|)
continue|continue;
operator|*
name|fsdata
operator|=
operator|&
name|fsdatat
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
return|return
operator|(
operator|*
name|fsdata
operator|!=
name|NULL
condition|?
literal|0
else|:
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nandfs_select_sb
parameter_list|(
name|struct
name|nandfs_device
modifier|*
name|fsdev
parameter_list|,
name|struct
name|nandfs_super_block
modifier|*
name|supert
parameter_list|,
name|struct
name|nandfs_super_block
modifier|*
modifier|*
name|super
parameter_list|,
name|int
name|nsbs
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
operator|*
name|super
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsbs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|nandfs_check_superblock_crc
argument_list|(
operator|&
name|fsdev
operator|->
name|nd_fsdata
argument_list|,
operator|&
name|supert
index|[
name|i
index|]
argument_list|)
condition|)
continue|continue;
name|DPRINTF
argument_list|(
name|SYNC
argument_list|,
operator|(
literal|"%s: i %d s_last_cno %jx s_magic %x "
literal|"s_wtime %jd\n"
operator|,
name|__func__
operator|,
name|i
operator|,
name|supert
index|[
name|i
index|]
operator|.
name|s_last_cno
operator|,
name|supert
index|[
name|i
index|]
operator|.
name|s_magic
operator|,
name|supert
index|[
name|i
index|]
operator|.
name|s_wtime
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|super
operator|==
name|NULL
operator|||
name|supert
index|[
name|i
index|]
operator|.
name|s_last_cno
operator|>
operator|(
operator|*
name|super
operator|)
operator|->
name|s_last_cno
condition|)
operator|*
name|super
operator|=
operator|&
name|supert
index|[
name|i
index|]
expr_stmt|;
block|}
return|return
operator|(
operator|*
name|super
operator|!=
name|NULL
condition|?
literal|0
else|:
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nandfs_read_structures_at
parameter_list|(
name|struct
name|nandfs_device
modifier|*
name|fsdev
parameter_list|,
name|struct
name|nandfs_fsarea
modifier|*
name|fstp
parameter_list|,
name|struct
name|nandfs_fsdata
modifier|*
name|fsdata
parameter_list|,
name|struct
name|nandfs_super_block
modifier|*
name|super
parameter_list|)
block|{
name|struct
name|nandfs_super_block
modifier|*
name|tsuper
decl_stmt|,
modifier|*
name|tsuperd
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|read_size
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|offset
operator|=
name|fstp
operator|->
name|offset
expr_stmt|;
if|if
condition|(
name|fsdev
operator|->
name|nd_erasesize
operator|>
name|MAXBSIZE
condition|)
name|read_size
operator|=
name|MAXBSIZE
expr_stmt|;
else|else
name|read_size
operator|=
name|fsdev
operator|->
name|nd_erasesize
expr_stmt|;
name|error
operator|=
name|bread
argument_list|(
name|fsdev
operator|->
name|nd_devvp
argument_list|,
name|btodb
argument_list|(
name|offset
argument_list|)
argument_list|,
name|read_size
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"couldn't read: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|fstp
operator|->
name|flags
operator||=
name|NANDFS_FSSTOR_FAILED
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|tsuper
operator|=
name|super
expr_stmt|;
name|memcpy
argument_list|(
name|fsdata
argument_list|,
name|bp
operator|->
name|b_data
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nandfs_fsdata
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|tsuper
argument_list|,
operator|(
name|bp
operator|->
name|b_data
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|nandfs_fsdata
argument_list|)
operator|)
argument_list|,
name|read_size
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|nandfs_fsdata
argument_list|)
argument_list|)
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|tsuper
operator|+=
operator|(
name|read_size
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|nandfs_fsdata
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|nandfs_super_block
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|fsdev
operator|->
name|nd_erasesize
operator|/
name|read_size
condition|;
name|i
operator|++
control|)
block|{
name|error
operator|=
name|bread
argument_list|(
name|fsdev
operator|->
name|nd_devvp
argument_list|,
name|btodb
argument_list|(
name|offset
operator|+
name|i
operator|*
name|read_size
argument_list|)
argument_list|,
name|read_size
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"couldn't read: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|fstp
operator|->
name|flags
operator||=
name|NANDFS_FSSTOR_FAILED
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|memcpy
argument_list|(
name|tsuper
argument_list|,
name|bp
operator|->
name|b_data
argument_list|,
name|read_size
argument_list|)
expr_stmt|;
name|tsuper
operator|+=
name|read_size
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|nandfs_super_block
argument_list|)
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
name|tsuper
operator|-=
literal|1
expr_stmt|;
name|fstp
operator|->
name|last_used
operator|=
name|nandfs_sblocks_in_esize
argument_list|(
name|fsdev
argument_list|)
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|tsuperd
operator|=
name|super
operator|-
literal|1
init|;
operator|(
name|tsuper
operator|!=
name|tsuperd
operator|)
condition|;
name|tsuper
operator|-=
literal|1
control|)
block|{
if|if
condition|(
name|nandfs_is_empty
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|tsuper
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tsuper
argument_list|)
argument_list|)
condition|)
name|fstp
operator|->
name|last_used
operator|--
expr_stmt|;
else|else
break|break;
block|}
name|DPRINTF
argument_list|(
name|VOLUMES
argument_list|,
operator|(
literal|"%s: last_used %d\n"
operator|,
name|__func__
operator|,
name|fstp
operator|->
name|last_used
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nandfs_read_structures
parameter_list|(
name|struct
name|nandfs_device
modifier|*
name|fsdev
parameter_list|)
block|{
name|struct
name|nandfs_fsdata
modifier|*
name|fsdata
decl_stmt|,
modifier|*
name|fsdatat
decl_stmt|;
name|struct
name|nandfs_super_block
modifier|*
name|sblocks
decl_stmt|,
modifier|*
name|ssblock
decl_stmt|;
name|int
name|nsbs
decl_stmt|,
name|nfsds
decl_stmt|,
name|i
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|nrsbs
decl_stmt|;
name|nfsds
operator|=
name|NANDFS_NFSAREAS
expr_stmt|;
name|nsbs
operator|=
name|nandfs_max_sblocks
argument_list|(
name|fsdev
argument_list|)
expr_stmt|;
name|fsdatat
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nandfs_fsdata
argument_list|)
operator|*
name|nfsds
argument_list|,
name|M_NANDFSTEMP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|sblocks
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nandfs_super_block
argument_list|)
operator|*
name|nsbs
argument_list|,
name|M_NANDFSTEMP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|nrsbs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NANDFS_NFSAREAS
condition|;
name|i
operator|++
control|)
block|{
name|fsdev
operator|->
name|nd_fsarea
index|[
name|i
index|]
operator|.
name|offset
operator|=
name|i
operator|*
name|fsdev
operator|->
name|nd_erasesize
expr_stmt|;
name|error
operator|=
name|nandfs_read_structures_at
argument_list|(
name|fsdev
argument_list|,
operator|&
name|fsdev
operator|->
name|nd_fsarea
index|[
name|i
index|]
argument_list|,
operator|&
name|fsdatat
index|[
name|i
index|]
argument_list|,
name|sblocks
operator|+
name|nrsbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
continue|continue;
name|nrsbs
operator|+=
operator|(
name|fsdev
operator|->
name|nd_fsarea
index|[
name|i
index|]
operator|.
name|last_used
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|fsdev
operator|->
name|nd_fsarea
index|[
name|fsdev
operator|->
name|nd_last_fsarea
index|]
operator|.
name|last_used
operator|>
name|fsdev
operator|->
name|nd_fsarea
index|[
name|i
index|]
operator|.
name|last_used
condition|)
name|fsdev
operator|->
name|nd_last_fsarea
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|nrsbs
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"nandfs: no valid superblocks found\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|error
operator|=
name|nandfs_select_fsdata
argument_list|(
name|fsdev
argument_list|,
name|fsdatat
argument_list|,
operator|&
name|fsdata
argument_list|,
name|nfsds
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|memcpy
argument_list|(
operator|&
name|fsdev
operator|->
name|nd_fsdata
argument_list|,
name|fsdata
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nandfs_fsdata
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|nandfs_select_sb
argument_list|(
name|fsdev
argument_list|,
name|sblocks
argument_list|,
operator|&
name|ssblock
argument_list|,
name|nsbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|memcpy
argument_list|(
operator|&
name|fsdev
operator|->
name|nd_super
argument_list|,
name|ssblock
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nandfs_super_block
argument_list|)
argument_list|)
expr_stmt|;
name|out
label|:
name|free
argument_list|(
name|fsdatat
argument_list|,
name|M_NANDFSTEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sblocks
argument_list|,
name|M_NANDFSTEMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|DPRINTF
argument_list|(
name|VOLUMES
argument_list|,
operator|(
literal|"%s: selected sb with w_time %jd "
literal|"last_pseg %#jx\n"
operator|,
name|__func__
operator|,
name|fsdev
operator|->
name|nd_super
operator|.
name|s_wtime
operator|,
name|fsdev
operator|->
name|nd_super
operator|.
name|s_last_pseg
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nandfs_unmount_base
parameter_list|(
name|struct
name|nandfs_device
modifier|*
name|nandfsdev
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|!
name|nandfsdev
condition|)
return|return;
comment|/* Remove all our information */
name|error
operator|=
name|vinvalbuf
argument_list|(
name|nandfsdev
operator|->
name|nd_devvp
argument_list|,
name|V_SAVE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* 		 * Flushing buffers failed when fs was umounting, can't do 		 * much now, just printf error and continue with umount. 		 */
name|nandfs_error
argument_list|(
literal|"%s(): error:%d when umounting FS\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
comment|/* Release the device's system nodes */
name|nandfs_release_system_nodes
argument_list|(
name|nandfsdev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|nandfs_get_ncleanseg
parameter_list|(
name|struct
name|nandfs_device
modifier|*
name|nandfsdev
parameter_list|)
block|{
name|struct
name|nandfs_seg_stat
name|nss
decl_stmt|;
name|nandfs_get_seg_stat
argument_list|(
name|nandfsdev
argument_list|,
operator|&
name|nss
argument_list|)
expr_stmt|;
name|nandfsdev
operator|->
name|nd_clean_segs
operator|=
name|nss
operator|.
name|nss_ncleansegs
expr_stmt|;
name|DPRINTF
argument_list|(
name|VOLUMES
argument_list|,
operator|(
literal|"nandfs_mount: clean segs: %jx\n"
operator|,
operator|(
name|uintmax_t
operator|)
name|nandfsdev
operator|->
name|nd_clean_segs
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|nandfs_mount_base
parameter_list|(
name|struct
name|nandfs_device
modifier|*
name|nandfsdev
parameter_list|,
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|struct
name|nandfs_args
modifier|*
name|args
parameter_list|)
block|{
name|uint32_t
name|log_blocksize
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Flush out any old buffers remaining from a previous use. */
if|if
condition|(
operator|(
name|error
operator|=
name|vinvalbuf
argument_list|(
name|nandfsdev
operator|->
name|nd_devvp
argument_list|,
name|V_SAVE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|nandfs_read_structures
argument_list|(
name|nandfsdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"nandfs: could not get valid filesystem structures\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|nandfsdev
operator|->
name|nd_fsdata
operator|.
name|f_rev_level
operator|!=
name|NANDFS_CURRENT_REV
condition|)
block|{
name|printf
argument_list|(
literal|"nandfs: unsupported file system revision: %d "
literal|"(supported is %d).\n"
argument_list|,
name|nandfsdev
operator|->
name|nd_fsdata
operator|.
name|f_rev_level
argument_list|,
name|NANDFS_CURRENT_REV
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|nandfsdev
operator|->
name|nd_fsdata
operator|.
name|f_erasesize
operator|!=
name|nandfsdev
operator|->
name|nd_erasesize
condition|)
block|{
name|printf
argument_list|(
literal|"nandfs: erasesize mismatch (device %#x, fs %#x)\n"
argument_list|,
name|nandfsdev
operator|->
name|nd_erasesize
argument_list|,
name|nandfsdev
operator|->
name|nd_fsdata
operator|.
name|f_erasesize
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Get our blocksize */
name|log_blocksize
operator|=
name|nandfsdev
operator|->
name|nd_fsdata
operator|.
name|f_log_block_size
expr_stmt|;
name|nandfsdev
operator|->
name|nd_blocksize
operator|=
operator|(
name|uint64_t
operator|)
literal|1
operator|<<
operator|(
name|log_blocksize
operator|+
literal|10
operator|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|VOLUMES
argument_list|,
operator|(
literal|"%s: blocksize:%x\n"
operator|,
name|__func__
operator|,
name|nandfsdev
operator|->
name|nd_blocksize
operator|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|VOLUMES
argument_list|,
operator|(
literal|"%s: accepted super block with cp %#jx\n"
operator|,
name|__func__
operator|,
operator|(
name|uintmax_t
operator|)
name|nandfsdev
operator|->
name|nd_super
operator|.
name|s_last_cno
operator|)
argument_list|)
expr_stmt|;
comment|/* Calculate dat structure parameters */
name|nandfs_calc_mdt_consts
argument_list|(
name|nandfsdev
argument_list|,
operator|&
name|nandfsdev
operator|->
name|nd_dat_mdt
argument_list|,
name|nandfsdev
operator|->
name|nd_fsdata
operator|.
name|f_dat_entry_size
argument_list|)
expr_stmt|;
name|nandfs_calc_mdt_consts
argument_list|(
name|nandfsdev
argument_list|,
operator|&
name|nandfsdev
operator|->
name|nd_ifile_mdt
argument_list|,
name|nandfsdev
operator|->
name|nd_fsdata
operator|.
name|f_inode_size
argument_list|)
expr_stmt|;
comment|/* Search for the super root and roll forward when needed */
if|if
condition|(
name|nandfs_search_super_root
argument_list|(
name|nandfsdev
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Cannot find valid SuperRoot\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|nandfsdev
operator|->
name|nd_mount_state
operator|=
name|nandfsdev
operator|->
name|nd_super
operator|.
name|s_state
expr_stmt|;
if|if
condition|(
name|nandfsdev
operator|->
name|nd_mount_state
operator|!=
name|NANDFS_VALID_FS
condition|)
block|{
name|printf
argument_list|(
literal|"FS is seriously damaged, needs repairing\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"aborting mount\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 	 * FS should be ok now. The superblock and the last segsum could be 	 * updated from the repair so extract running values again. 	 */
name|nandfsdev
operator|->
name|nd_last_pseg
operator|=
name|nandfsdev
operator|->
name|nd_super
operator|.
name|s_last_pseg
expr_stmt|;
name|nandfsdev
operator|->
name|nd_seg_sequence
operator|=
name|nandfsdev
operator|->
name|nd_super
operator|.
name|s_last_seq
expr_stmt|;
name|nandfsdev
operator|->
name|nd_seg_num
operator|=
name|nandfs_get_segnum_of_block
argument_list|(
name|nandfsdev
argument_list|,
name|nandfsdev
operator|->
name|nd_last_pseg
argument_list|)
expr_stmt|;
name|nandfsdev
operator|->
name|nd_next_seg_num
operator|=
name|nandfs_get_segnum_of_block
argument_list|(
name|nandfsdev
argument_list|,
name|nandfsdev
operator|->
name|nd_last_segsum
operator|.
name|ss_next
argument_list|)
expr_stmt|;
name|nandfsdev
operator|->
name|nd_ts
operator|.
name|tv_sec
operator|=
name|nandfsdev
operator|->
name|nd_last_segsum
operator|.
name|ss_create
expr_stmt|;
name|nandfsdev
operator|->
name|nd_last_cno
operator|=
name|nandfsdev
operator|->
name|nd_super
operator|.
name|s_last_cno
expr_stmt|;
name|nandfsdev
operator|->
name|nd_fakevblk
operator|=
literal|1
expr_stmt|;
comment|/* 	 * FIXME: bogus calculation. Should use actual number of usable segments 	 * instead of total amount. 	 */
name|nandfsdev
operator|->
name|nd_segs_reserved
operator|=
name|nandfsdev
operator|->
name|nd_fsdata
operator|.
name|f_nsegments
operator|*
name|nandfsdev
operator|->
name|nd_fsdata
operator|.
name|f_r_segments_percentage
operator|/
literal|100
expr_stmt|;
name|nandfsdev
operator|->
name|nd_last_ino
operator|=
name|NANDFS_USER_INO
expr_stmt|;
name|DPRINTF
argument_list|(
name|VOLUMES
argument_list|,
operator|(
literal|"%s: last_pseg %#jx last_cno %#jx last_seq %#jx\n"
literal|"fsdev: last_seg: seq %#jx num %#jx, next_seg_num %#jx "
literal|"segs_reserved %#jx\n"
operator|,
name|__func__
operator|,
operator|(
name|uintmax_t
operator|)
name|nandfsdev
operator|->
name|nd_last_pseg
operator|,
operator|(
name|uintmax_t
operator|)
name|nandfsdev
operator|->
name|nd_last_cno
operator|,
operator|(
name|uintmax_t
operator|)
name|nandfsdev
operator|->
name|nd_seg_sequence
operator|,
operator|(
name|uintmax_t
operator|)
name|nandfsdev
operator|->
name|nd_seg_sequence
operator|,
operator|(
name|uintmax_t
operator|)
name|nandfsdev
operator|->
name|nd_seg_num
operator|,
operator|(
name|uintmax_t
operator|)
name|nandfsdev
operator|->
name|nd_next_seg_num
operator|,
operator|(
name|uintmax_t
operator|)
name|nandfsdev
operator|->
name|nd_segs_reserved
operator|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|VOLUMES
argument_list|,
operator|(
literal|"nandfs_mount: accepted super root\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Create system vnodes for DAT, CP and SEGSUM */
name|error
operator|=
name|nandfs_create_system_nodes
argument_list|(
name|nandfsdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|nandfs_unmount_base
argument_list|(
name|nandfsdev
argument_list|)
expr_stmt|;
name|nandfs_get_ncleanseg
argument_list|(
name|nandfsdev
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nandfs_unmount_device
parameter_list|(
name|struct
name|nandfs_device
modifier|*
name|nandfsdev
parameter_list|)
block|{
comment|/* Is there anything? */
if|if
condition|(
name|nandfsdev
operator|==
name|NULL
condition|)
return|return;
comment|/* Remove the device only if we're the last reference */
name|nandfsdev
operator|->
name|nd_refcnt
operator|--
expr_stmt|;
if|if
condition|(
name|nandfsdev
operator|->
name|nd_refcnt
operator|>=
literal|1
condition|)
return|return;
name|MPASS
argument_list|(
name|nandfsdev
operator|->
name|nd_syncer
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|nandfsdev
operator|->
name|nd_cleaner
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|nandfsdev
operator|->
name|nd_free_base
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* Unmount our base */
name|nandfs_unmount_base
argument_list|(
name|nandfsdev
argument_list|)
expr_stmt|;
comment|/* Remove from our device list */
name|SLIST_REMOVE
argument_list|(
operator|&
name|nandfs_devices
argument_list|,
name|nandfsdev
argument_list|,
name|nandfs_device
argument_list|,
name|nd_next_device
argument_list|)
expr_stmt|;
name|DROP_GIANT
argument_list|()
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
name|g_vfs_close
argument_list|(
name|nandfsdev
operator|->
name|nd_gconsumer
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|PICKUP_GIANT
argument_list|()
expr_stmt|;
name|DPRINTF
argument_list|(
name|VOLUMES
argument_list|,
operator|(
literal|"closing device\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Clear our mount reference and release device node */
name|vrele
argument_list|(
name|nandfsdev
operator|->
name|nd_devvp
argument_list|)
expr_stmt|;
name|dev_rel
argument_list|(
name|nandfsdev
operator|->
name|nd_devvp
operator|->
name|v_rdev
argument_list|)
expr_stmt|;
comment|/* Free our device info */
name|cv_destroy
argument_list|(
operator|&
name|nandfsdev
operator|->
name|nd_sync_cv
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|nandfsdev
operator|->
name|nd_sync_mtx
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|nandfsdev
operator|->
name|nd_clean_cv
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|nandfsdev
operator|->
name|nd_clean_mtx
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|nandfsdev
operator|->
name|nd_mutex
argument_list|)
expr_stmt|;
name|lockdestroy
argument_list|(
operator|&
name|nandfsdev
operator|->
name|nd_seg_const
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nandfsdev
argument_list|,
name|M_NANDFSMNT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|nandfs_check_mounts
parameter_list|(
name|struct
name|nandfs_device
modifier|*
name|nandfsdev
parameter_list|,
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|struct
name|nandfs_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|nandfsmount
modifier|*
name|nmp
decl_stmt|;
name|uint64_t
name|last_cno
decl_stmt|;
comment|/* no double-mounting of the same checkpoint */
name|STAILQ_FOREACH
argument_list|(
argument|nmp
argument_list|,
argument|&nandfsdev->nd_mounts
argument_list|,
argument|nm_next_mount
argument_list|)
block|{
if|if
condition|(
name|nmp
operator|->
name|nm_mount_args
operator|.
name|cpno
operator|==
name|args
operator|->
name|cpno
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
comment|/* Allow readonly mounts without questioning here */
if|if
condition|(
name|mp
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Read/write mount */
name|STAILQ_FOREACH
argument_list|(
argument|nmp
argument_list|,
argument|&nandfsdev->nd_mounts
argument_list|,
argument|nm_next_mount
argument_list|)
block|{
comment|/* Only one RW mount on this device! */
if|if
condition|(
operator|(
name|nmp
operator|->
name|nm_vfs_mountp
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EROFS
operator|)
return|;
comment|/* RDONLY on last mountpoint is device busy */
name|last_cno
operator|=
name|nmp
operator|->
name|nm_nandfsdev
operator|->
name|nd_super
operator|.
name|s_last_cno
expr_stmt|;
if|if
condition|(
name|nmp
operator|->
name|nm_mount_args
operator|.
name|cpno
operator|==
name|last_cno
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
comment|/* OK for now */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nandfs_mount_device
parameter_list|(
name|struct
name|vnode
modifier|*
name|devvp
parameter_list|,
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|struct
name|nandfs_args
modifier|*
name|args
parameter_list|,
name|struct
name|nandfs_device
modifier|*
modifier|*
name|nandfsdev_p
parameter_list|)
block|{
name|struct
name|nandfs_device
modifier|*
name|nandfsdev
decl_stmt|;
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|struct
name|cdev
modifier|*
name|dev
decl_stmt|;
name|uint32_t
name|erasesize
decl_stmt|;
name|int
name|error
decl_stmt|,
name|size
decl_stmt|;
name|int
name|ronly
decl_stmt|;
name|DPRINTF
argument_list|(
name|VOLUMES
argument_list|,
operator|(
literal|"Mounting NANDFS device\n"
operator|)
argument_list|)
expr_stmt|;
name|ronly
operator|=
operator|(
name|mp
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
operator|)
operator|!=
literal|0
expr_stmt|;
comment|/* Look up device in our nandfs_mountpoints */
operator|*
name|nandfsdev_p
operator|=
name|NULL
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|nandfsdev
argument_list|,
argument|&nandfs_devices
argument_list|,
argument|nd_next_device
argument_list|)
if|if
condition|(
name|nandfsdev
operator|->
name|nd_devvp
operator|==
name|devvp
condition|)
break|break;
if|if
condition|(
name|nandfsdev
condition|)
block|{
name|DPRINTF
argument_list|(
name|VOLUMES
argument_list|,
operator|(
literal|"device already mounted\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|nandfs_check_mounts
argument_list|(
name|nandfsdev
argument_list|,
name|mp
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|nandfsdev
operator|->
name|nd_refcnt
operator|++
expr_stmt|;
operator|*
name|nandfsdev_p
operator|=
name|nandfsdev
expr_stmt|;
if|if
condition|(
operator|!
name|ronly
condition|)
block|{
name|DROP_GIANT
argument_list|()
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
name|error
operator|=
name|g_access
argument_list|(
name|nandfsdev
operator|->
name|nd_gconsumer
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|PICKUP_GIANT
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
name|vn_lock
argument_list|(
name|devvp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
name|dev
operator|=
name|devvp
operator|->
name|v_rdev
expr_stmt|;
name|dev_ref
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|DROP_GIANT
argument_list|()
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
name|error
operator|=
name|g_vfs_open
argument_list|(
name|devvp
argument_list|,
operator|&
name|cp
argument_list|,
literal|"nandfs"
argument_list|,
name|ronly
condition|?
literal|0
else|:
literal|1
argument_list|)
expr_stmt|;
name|pp
operator|=
name|g_dev_getprovider
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|PICKUP_GIANT
argument_list|()
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|devvp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|dev_rel
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|nandfsdev
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nandfs_device
argument_list|)
argument_list|,
name|M_NANDFSMNT
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
comment|/* Initialise */
name|nandfsdev
operator|->
name|nd_refcnt
operator|=
literal|1
expr_stmt|;
name|nandfsdev
operator|->
name|nd_devvp
operator|=
name|devvp
expr_stmt|;
name|nandfsdev
operator|->
name|nd_syncing
operator|=
literal|0
expr_stmt|;
name|nandfsdev
operator|->
name|nd_cleaning
operator|=
literal|0
expr_stmt|;
name|nandfsdev
operator|->
name|nd_gconsumer
operator|=
name|cp
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|nandfsdev
operator|->
name|nd_sync_cv
argument_list|,
literal|"nandfssync"
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|nandfsdev
operator|->
name|nd_sync_mtx
argument_list|,
literal|"nffssyncmtx"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|nandfsdev
operator|->
name|nd_clean_cv
argument_list|,
literal|"nandfsclean"
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|nandfsdev
operator|->
name|nd_clean_mtx
argument_list|,
literal|"nffscleanmtx"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|nandfsdev
operator|->
name|nd_mutex
argument_list|,
literal|"nandfsdev lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|lockinit
argument_list|(
operator|&
name|nandfsdev
operator|->
name|nd_seg_const
argument_list|,
name|PVFS
argument_list|,
literal|"nffssegcon"
argument_list|,
name|VLKTIMEOUT
argument_list|,
name|LK_CANRECURSE
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|nandfsdev
operator|->
name|nd_mounts
argument_list|)
expr_stmt|;
name|nandfsdev
operator|->
name|nd_devsize
operator|=
name|pp
operator|->
name|mediasize
expr_stmt|;
name|nandfsdev
operator|->
name|nd_devblocksize
operator|=
name|pp
operator|->
name|sectorsize
expr_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
name|erasesize
argument_list|)
expr_stmt|;
name|error
operator|=
name|g_io_getattr
argument_list|(
literal|"NAND::blocksize"
argument_list|,
name|nandfsdev
operator|->
name|nd_gconsumer
argument_list|,
operator|&
name|size
argument_list|,
operator|&
name|erasesize
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|DPRINTF
argument_list|(
name|VOLUMES
argument_list|,
operator|(
literal|"couldn't get erasesize: %d\n"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOIOCTL
operator|||
name|error
operator|==
name|EOPNOTSUPP
condition|)
block|{
comment|/* 			 * We conclude that this is not NAND storage 			 */
name|erasesize
operator|=
name|NANDFS_DEF_ERASESIZE
expr_stmt|;
block|}
else|else
block|{
name|DROP_GIANT
argument_list|()
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
name|g_vfs_close
argument_list|(
name|nandfsdev
operator|->
name|nd_gconsumer
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|PICKUP_GIANT
argument_list|()
expr_stmt|;
name|dev_rel
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nandfsdev
argument_list|,
name|M_NANDFSMNT
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
name|nandfsdev
operator|->
name|nd_erasesize
operator|=
name|erasesize
expr_stmt|;
name|DPRINTF
argument_list|(
name|VOLUMES
argument_list|,
operator|(
literal|"%s: erasesize %x\n"
operator|,
name|__func__
operator|,
name|nandfsdev
operator|->
name|nd_erasesize
operator|)
argument_list|)
expr_stmt|;
comment|/* Register nandfs_device in list */
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|nandfs_devices
argument_list|,
name|nandfsdev
argument_list|,
name|nd_next_device
argument_list|)
expr_stmt|;
name|error
operator|=
name|nandfs_mount_base
argument_list|(
name|nandfsdev
argument_list|,
name|mp
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* Remove all our information */
name|nandfs_unmount_device
argument_list|(
name|nandfsdev
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|nandfsdev
operator|->
name|nd_maxfilesize
operator|=
name|nandfs_get_maxfilesize
argument_list|(
name|nandfsdev
argument_list|)
expr_stmt|;
operator|*
name|nandfsdev_p
operator|=
name|nandfsdev
expr_stmt|;
name|DPRINTF
argument_list|(
name|VOLUMES
argument_list|,
operator|(
literal|"NANDFS device mounted ok\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nandfs_mount_checkpoint
parameter_list|(
name|struct
name|nandfsmount
modifier|*
name|nmp
parameter_list|)
block|{
name|struct
name|nandfs_cpfile_header
modifier|*
name|cphdr
decl_stmt|;
name|struct
name|nandfs_checkpoint
modifier|*
name|cp
decl_stmt|;
name|struct
name|nandfs_inode
name|ifile_inode
decl_stmt|;
name|struct
name|nandfs_node
modifier|*
name|cp_node
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|uint64_t
name|ncp
decl_stmt|,
name|nsn
decl_stmt|,
name|cpno
decl_stmt|,
name|fcpno
decl_stmt|,
name|blocknr
decl_stmt|,
name|last_cno
decl_stmt|;
name|uint32_t
name|off
decl_stmt|,
name|dlen
decl_stmt|;
name|int
name|cp_per_block
decl_stmt|,
name|error
decl_stmt|;
name|cpno
operator|=
name|nmp
operator|->
name|nm_mount_args
operator|.
name|cpno
expr_stmt|;
if|if
condition|(
name|cpno
operator|==
literal|0
condition|)
name|cpno
operator|=
name|nmp
operator|->
name|nm_nandfsdev
operator|->
name|nd_super
operator|.
name|s_last_cno
expr_stmt|;
name|DPRINTF
argument_list|(
name|VOLUMES
argument_list|,
operator|(
literal|"%s: trying to mount checkpoint number %"
name|PRIu64
literal|"\n"
operator|,
name|__func__
operator|,
name|cpno
operator|)
argument_list|)
expr_stmt|;
name|cp_node
operator|=
name|nmp
operator|->
name|nm_nandfsdev
operator|->
name|nd_cp_node
expr_stmt|;
name|VOP_LOCK
argument_list|(
name|NTOV
argument_list|(
name|cp_node
argument_list|)
argument_list|,
name|LK_SHARED
argument_list|)
expr_stmt|;
comment|/* Get cpfile header from 1st block of cp file */
name|error
operator|=
name|nandfs_bread
argument_list|(
name|cp_node
argument_list|,
literal|0
argument_list|,
name|NOCRED
argument_list|,
literal|0
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|NTOV
argument_list|(
name|cp_node
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|cphdr
operator|=
operator|(
expr|struct
name|nandfs_cpfile_header
operator|*
operator|)
name|bp
operator|->
name|b_data
expr_stmt|;
name|ncp
operator|=
name|cphdr
operator|->
name|ch_ncheckpoints
expr_stmt|;
name|nsn
operator|=
name|cphdr
operator|->
name|ch_nsnapshots
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|VOLUMES
argument_list|,
operator|(
literal|"mount_nandfs: checkpoint header read in\n"
operator|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|VOLUMES
argument_list|,
operator|(
literal|"\tNumber of checkpoints %"
name|PRIu64
literal|"\n"
operator|,
name|ncp
operator|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|VOLUMES
argument_list|,
operator|(
literal|"\tNumber of snapshots %"
name|PRIu64
literal|"\n"
operator|,
name|nsn
operator|)
argument_list|)
expr_stmt|;
comment|/* Read in our specified checkpoint */
name|dlen
operator|=
name|nmp
operator|->
name|nm_nandfsdev
operator|->
name|nd_fsdata
operator|.
name|f_checkpoint_size
expr_stmt|;
name|cp_per_block
operator|=
name|nmp
operator|->
name|nm_nandfsdev
operator|->
name|nd_blocksize
operator|/
name|dlen
expr_stmt|;
name|fcpno
operator|=
name|cpno
operator|+
name|NANDFS_CPFILE_FIRST_CHECKPOINT_OFFSET
operator|-
literal|1
expr_stmt|;
name|blocknr
operator|=
name|fcpno
operator|/
name|cp_per_block
expr_stmt|;
name|off
operator|=
operator|(
name|fcpno
operator|%
name|cp_per_block
operator|)
operator|*
name|dlen
expr_stmt|;
name|error
operator|=
name|nandfs_bread
argument_list|(
name|cp_node
argument_list|,
name|blocknr
argument_list|,
name|NOCRED
argument_list|,
literal|0
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|NTOV
argument_list|(
name|cp_node
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"mount_nandfs: couldn't read cp block %"
name|PRIu64
literal|"\n"
argument_list|,
name|fcpno
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Needs to be a valid checkpoint */
name|cp
operator|=
operator|(
expr|struct
name|nandfs_checkpoint
operator|*
operator|)
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|bp
operator|->
name|b_data
operator|+
name|off
operator|)
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|cp_flags
operator|&
name|NANDFS_CHECKPOINT_INVALID
condition|)
block|{
name|printf
argument_list|(
literal|"mount_nandfs: checkpoint marked invalid\n"
argument_list|)
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|NTOV
argument_list|(
name|cp_node
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Is this really the checkpoint we want? */
if|if
condition|(
name|cp
operator|->
name|cp_cno
operator|!=
name|cpno
condition|)
block|{
name|printf
argument_list|(
literal|"mount_nandfs: checkpoint file corrupt? "
literal|"expected cpno %"
name|PRIu64
literal|", found cpno %"
name|PRIu64
literal|"\n"
argument_list|,
name|cpno
argument_list|,
name|cp
operator|->
name|cp_cno
argument_list|)
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|NTOV
argument_list|(
name|cp_node
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Check if it's a snapshot ! */
name|last_cno
operator|=
name|nmp
operator|->
name|nm_nandfsdev
operator|->
name|nd_super
operator|.
name|s_last_cno
expr_stmt|;
if|if
condition|(
name|cpno
operator|!=
name|last_cno
condition|)
block|{
comment|/* Only allow snapshots if not mounting on the last cp */
if|if
condition|(
operator|(
name|cp
operator|->
name|cp_flags
operator|&
name|NANDFS_CHECKPOINT_SNAPSHOT
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"mount_nandfs: checkpoint %"
name|PRIu64
literal|" is not a "
literal|"snapshot\n"
argument_list|,
name|cpno
argument_list|)
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|NTOV
argument_list|(
name|cp_node
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
name|ifile_inode
operator|=
name|cp
operator|->
name|cp_ifile_inode
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* Get ifile inode */
name|error
operator|=
name|nandfs_get_node_raw
argument_list|(
name|nmp
operator|->
name|nm_nandfsdev
argument_list|,
name|NULL
argument_list|,
name|NANDFS_IFILE_INO
argument_list|,
operator|&
name|ifile_inode
argument_list|,
operator|&
name|nmp
operator|->
name|nm_ifile_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"mount_nandfs: can't read ifile node\n"
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|NTOV
argument_list|(
name|cp_node
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|NANDFS_SET_SYSTEMFILE
argument_list|(
name|NTOV
argument_list|(
name|nmp
operator|->
name|nm_ifile_node
argument_list|)
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|NTOV
argument_list|(
name|cp_node
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Get root node? */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_nandfs_mountinfo
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|)
block|{
name|struct
name|nandfsmount
modifier|*
name|nmp
init|=
name|VFSTONANDFS
argument_list|(
name|mp
argument_list|)
decl_stmt|;
if|if
condition|(
name|nmp
operator|==
name|NULL
condition|)
return|return;
name|free
argument_list|(
name|nmp
argument_list|,
name|M_NANDFSMNT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nandfs_wakeup_wait_sync
parameter_list|(
name|struct
name|nandfs_device
modifier|*
name|nffsdev
parameter_list|,
name|int
name|reason
parameter_list|)
block|{
name|char
modifier|*
name|reasons
index|[]
init|=
block|{
literal|"umount"
block|,
literal|"vfssync"
block|,
literal|"bdflush"
block|,
literal|"fforce"
block|,
literal|"fsync"
block|,
literal|"ro_upd"
block|}
decl_stmt|;
name|DPRINTF
argument_list|(
name|SYNC
argument_list|,
operator|(
literal|"%s: %s\n"
operator|,
name|__func__
operator|,
name|reasons
index|[
name|reason
index|]
operator|)
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|nffsdev
operator|->
name|nd_sync_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|nffsdev
operator|->
name|nd_syncing
condition|)
name|cv_wait
argument_list|(
operator|&
name|nffsdev
operator|->
name|nd_sync_cv
argument_list|,
operator|&
name|nffsdev
operator|->
name|nd_sync_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|reason
operator|==
name|SYNCER_UMOUNT
condition|)
name|nffsdev
operator|->
name|nd_syncer_exit
operator|=
literal|1
expr_stmt|;
name|nffsdev
operator|->
name|nd_syncing
operator|=
literal|1
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|nffsdev
operator|->
name|nd_syncing
argument_list|)
expr_stmt|;
name|cv_wait
argument_list|(
operator|&
name|nffsdev
operator|->
name|nd_sync_cv
argument_list|,
operator|&
name|nffsdev
operator|->
name|nd_sync_mtx
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|nffsdev
operator|->
name|nd_sync_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|nandfs_gc_finished
parameter_list|(
name|struct
name|nandfs_device
modifier|*
name|nffsdev
parameter_list|,
name|int
name|exit
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|nffsdev
operator|->
name|nd_sync_mtx
argument_list|)
expr_stmt|;
name|nffsdev
operator|->
name|nd_syncing
operator|=
literal|0
expr_stmt|;
name|DPRINTF
argument_list|(
name|SYNC
argument_list|,
operator|(
literal|"%s: cleaner finish\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|nffsdev
operator|->
name|nd_sync_cv
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|nffsdev
operator|->
name|nd_sync_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|exit
condition|)
block|{
name|error
operator|=
name|tsleep
argument_list|(
operator|&
name|nffsdev
operator|->
name|nd_syncing
argument_list|,
name|PRIBIO
argument_list|,
literal|"-"
argument_list|,
name|hz
operator|*
name|nandfs_sync_interval
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|SYNC
argument_list|,
operator|(
literal|"%s: cleaner waked up: %d\n"
operator|,
name|__func__
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|nandfs_syncer
parameter_list|(
name|struct
name|nandfsmount
modifier|*
name|nmp
parameter_list|)
block|{
name|struct
name|nandfs_device
modifier|*
name|nffsdev
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|int
name|flags
decl_stmt|,
name|error
decl_stmt|;
name|mp
operator|=
name|nmp
operator|->
name|nm_vfs_mountp
expr_stmt|;
name|nffsdev
operator|=
name|nmp
operator|->
name|nm_nandfsdev
expr_stmt|;
name|tsleep
argument_list|(
operator|&
name|nffsdev
operator|->
name|nd_syncing
argument_list|,
name|PRIBIO
argument_list|,
literal|"-"
argument_list|,
name|hz
operator|*
name|nandfs_sync_interval
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|nffsdev
operator|->
name|nd_syncer_exit
condition|)
block|{
name|DPRINTF
argument_list|(
name|SYNC
argument_list|,
operator|(
literal|"%s: syncer run\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|nffsdev
operator|->
name|nd_syncing
operator|=
literal|1
expr_stmt|;
name|flags
operator|=
operator|(
name|nmp
operator|->
name|nm_flags
operator|&
operator|(
name|NANDFS_FORCE_SYNCER
operator||
name|NANDFS_UMOUNT
operator|)
operator|)
expr_stmt|;
name|error
operator|=
name|nandfs_segment_constructor
argument_list|(
name|nmp
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|nandfs_error
argument_list|(
literal|"%s: error:%d when creating segments\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|nmp
operator|->
name|nm_flags
operator|&=
operator|~
name|flags
expr_stmt|;
name|nandfs_gc_finished
argument_list|(
name|nffsdev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|MPASS
argument_list|(
name|nffsdev
operator|->
name|nd_cleaner
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|error
operator|=
name|nandfs_segment_constructor
argument_list|(
name|nmp
argument_list|,
name|NANDFS_FORCE_SYNCER
operator||
name|NANDFS_UMOUNT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|nandfs_error
argument_list|(
literal|"%s: error:%d when creating segments\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|nandfs_gc_finished
argument_list|(
name|nffsdev
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|nffsdev
operator|->
name|nd_syncer
operator|=
name|NULL
expr_stmt|;
name|MPASS
argument_list|(
name|nffsdev
operator|->
name|nd_free_base
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|SYNC
argument_list|,
operator|(
literal|"%s: exiting\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|kthread_exit
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|start_syncer
parameter_list|(
name|struct
name|nandfsmount
modifier|*
name|nmp
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|MPASS
argument_list|(
name|nmp
operator|->
name|nm_nandfsdev
operator|->
name|nd_syncer
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|SYNC
argument_list|,
operator|(
literal|"%s: start syncer\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|nmp
operator|->
name|nm_nandfsdev
operator|->
name|nd_syncer_exit
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|kthread_add
argument_list|(
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|)
name|nandfs_syncer
argument_list|,
name|nmp
argument_list|,
name|NULL
argument_list|,
operator|&
name|nmp
operator|->
name|nm_nandfsdev
operator|->
name|nd_syncer
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"nandfs_syncer"
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|printf
argument_list|(
literal|"nandfs: could not start syncer: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|stop_syncer
parameter_list|(
name|struct
name|nandfsmount
modifier|*
name|nmp
parameter_list|)
block|{
name|MPASS
argument_list|(
name|nmp
operator|->
name|nm_nandfsdev
operator|->
name|nd_syncer
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|nandfs_wakeup_wait_sync
argument_list|(
name|nmp
operator|->
name|nm_nandfsdev
argument_list|,
name|SYNCER_UMOUNT
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|SYNC
argument_list|,
operator|(
literal|"%s: stop syncer\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Mount null layer  */
end_comment

begin_function
specifier|static
name|int
name|nandfs_mount
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|)
block|{
name|struct
name|nandfsmount
modifier|*
name|nmp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|devvp
decl_stmt|;
name|struct
name|nameidata
name|nd
decl_stmt|;
name|struct
name|vfsoptlist
modifier|*
name|opts
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|char
modifier|*
name|from
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|flags
decl_stmt|;
name|DPRINTF
argument_list|(
name|VOLUMES
argument_list|,
operator|(
literal|"%s: mp = %p\n"
operator|,
name|__func__
operator|,
operator|(
name|void
operator|*
operator|)
name|mp
operator|)
argument_list|)
expr_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
name|opts
operator|=
name|mp
operator|->
name|mnt_optnew
expr_stmt|;
if|if
condition|(
name|vfs_filteropt
argument_list|(
name|opts
argument_list|,
name|nandfs_opts
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * Update is a no-op 	 */
if|if
condition|(
name|mp
operator|->
name|mnt_flag
operator|&
name|MNT_UPDATE
condition|)
block|{
name|nmp
operator|=
name|VFSTONANDFS
argument_list|(
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|vfs_flagopt
argument_list|(
name|mp
operator|->
name|mnt_optnew
argument_list|,
literal|"export"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|nmp
operator|->
name|nm_ronly
operator|)
operator|&&
name|vfs_flagopt
argument_list|(
name|opts
argument_list|,
literal|"ro"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|vn_start_write
argument_list|(
name|NULL
argument_list|,
operator|&
name|mp
argument_list|,
name|V_WAIT
argument_list|)
expr_stmt|;
name|error
operator|=
name|VFS_SYNC
argument_list|(
name|mp
argument_list|,
name|MNT_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|vn_finished_write
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|flags
operator|=
name|WRITECLOSE
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|mnt_flag
operator|&
name|MNT_FORCE
condition|)
name|flags
operator||=
name|FORCECLOSE
expr_stmt|;
name|nandfs_wakeup_wait_sync
argument_list|(
name|nmp
operator|->
name|nm_nandfsdev
argument_list|,
name|SYNCER_ROUPD
argument_list|)
expr_stmt|;
name|error
operator|=
name|vflush
argument_list|(
name|mp
argument_list|,
literal|0
argument_list|,
name|flags
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|nandfs_stop_cleaner
argument_list|(
name|nmp
operator|->
name|nm_nandfsdev
argument_list|)
expr_stmt|;
name|stop_syncer
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
name|DROP_GIANT
argument_list|()
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
name|g_access
argument_list|(
name|nmp
operator|->
name|nm_nandfsdev
operator|->
name|nd_gconsumer
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|PICKUP_GIANT
argument_list|()
expr_stmt|;
name|MNT_ILOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|mp
operator|->
name|mnt_flag
operator||=
name|MNT_RDONLY
expr_stmt|;
name|MNT_IUNLOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|nmp
operator|->
name|nm_ronly
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|nmp
operator|->
name|nm_ronly
operator|)
operator|&&
operator|!
name|vfs_flagopt
argument_list|(
name|opts
argument_list|,
literal|"ro"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* 			 * Don't allow read-write snapshots. 			 */
if|if
condition|(
name|nmp
operator|->
name|nm_mount_args
operator|.
name|cpno
operator|!=
literal|0
condition|)
return|return
operator|(
name|EROFS
operator|)
return|;
comment|/* 			 * If upgrade to read-write by non-root, then verify 			 * that user has necessary permissions on the device. 			 */
name|devvp
operator|=
name|nmp
operator|->
name|nm_nandfsdev
operator|->
name|nd_devvp
expr_stmt|;
name|vn_lock
argument_list|(
name|devvp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_ACCESS
argument_list|(
name|devvp
argument_list|,
name|VREAD
operator||
name|VWRITE
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_VFS_MOUNT_PERM
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|VOP_UNLOCK
argument_list|(
name|devvp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
name|VOP_UNLOCK
argument_list|(
name|devvp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DROP_GIANT
argument_list|()
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
name|error
operator|=
name|g_access
argument_list|(
name|nmp
operator|->
name|nm_nandfsdev
operator|->
name|nd_gconsumer
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|PICKUP_GIANT
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|MNT_ILOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|mp
operator|->
name|mnt_flag
operator|&=
operator|~
name|MNT_RDONLY
expr_stmt|;
name|MNT_IUNLOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|error
operator|=
name|start_syncer
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|nandfs_start_cleaner
argument_list|(
name|nmp
operator|->
name|nm_nandfsdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|DROP_GIANT
argument_list|()
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
name|g_access
argument_list|(
name|nmp
operator|->
name|nm_nandfsdev
operator|->
name|nd_gconsumer
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|PICKUP_GIANT
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|nmp
operator|->
name|nm_ronly
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|from
operator|=
name|vfs_getopts
argument_list|(
name|opts
argument_list|,
literal|"from"
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * Find device node 	 */
name|NDINIT
argument_list|(
operator|&
name|nd
argument_list|,
name|LOOKUP
argument_list|,
name|FOLLOW
operator||
name|LOCKLEAF
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|from
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
name|error
operator|=
name|namei
argument_list|(
operator|&
name|nd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|NDFREE
argument_list|(
operator|&
name|nd
argument_list|,
name|NDF_ONLY_PNBUF
argument_list|)
expr_stmt|;
name|devvp
operator|=
name|nd
operator|.
name|ni_vp
expr_stmt|;
if|if
condition|(
operator|!
name|vn_isdisk
argument_list|(
name|devvp
argument_list|,
operator|&
name|error
argument_list|)
condition|)
block|{
name|vput
argument_list|(
name|devvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Check the access rights on the mount device */
name|error
operator|=
name|VOP_ACCESS
argument_list|(
name|devvp
argument_list|,
name|VREAD
argument_list|,
name|curthread
operator|->
name|td_ucred
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|error
operator|=
name|priv_check
argument_list|(
name|curthread
argument_list|,
name|PRIV_VFS_MOUNT_PERM
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|vput
argument_list|(
name|devvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|vfs_getnewfsid
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|error
operator|=
name|nandfs_mountfs
argument_list|(
name|devvp
argument_list|,
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|vfs_mountedfrom
argument_list|(
name|mp
argument_list|,
name|from
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nandfs_mountfs
parameter_list|(
name|struct
name|vnode
modifier|*
name|devvp
parameter_list|,
name|struct
name|mount
modifier|*
name|mp
parameter_list|)
block|{
name|struct
name|nandfsmount
modifier|*
name|nmp
init|=
name|NULL
decl_stmt|;
name|struct
name|nandfs_args
modifier|*
name|args
init|=
name|NULL
decl_stmt|;
name|struct
name|nandfs_device
modifier|*
name|nandfsdev
decl_stmt|;
name|char
modifier|*
name|from
decl_stmt|;
name|int
name|error
decl_stmt|,
name|ronly
decl_stmt|;
name|char
modifier|*
name|cpno
decl_stmt|;
name|ronly
operator|=
operator|(
name|mp
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
operator|)
operator|!=
literal|0
expr_stmt|;
if|if
condition|(
name|devvp
operator|->
name|v_rdev
operator|->
name|si_iosize_max
operator|!=
literal|0
condition|)
name|mp
operator|->
name|mnt_iosize_max
operator|=
name|devvp
operator|->
name|v_rdev
operator|->
name|si_iosize_max
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|devvp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|mnt_iosize_max
operator|>
name|MAXPHYS
condition|)
name|mp
operator|->
name|mnt_iosize_max
operator|=
name|MAXPHYS
expr_stmt|;
name|from
operator|=
name|vfs_getopts
argument_list|(
name|mp
operator|->
name|mnt_optnew
argument_list|,
literal|"from"
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|error
goto|;
name|error
operator|=
name|vfs_getopt
argument_list|(
name|mp
operator|->
name|mnt_optnew
argument_list|,
literal|"snap"
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|cpno
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOENT
condition|)
name|cpno
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|error
condition|)
goto|goto
name|error
goto|;
name|args
operator|=
operator|(
expr|struct
name|nandfs_args
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nandfs_args
argument_list|)
argument_list|,
name|M_NANDFSMNT
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpno
operator|!=
name|NULL
condition|)
name|args
operator|->
name|cpno
operator|=
name|strtoul
argument_list|(
name|cpno
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
else|else
name|args
operator|->
name|cpno
operator|=
literal|0
expr_stmt|;
name|args
operator|->
name|fspec
operator|=
name|from
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|cpno
operator|!=
literal|0
operator|&&
operator|!
name|ronly
condition|)
block|{
name|error
operator|=
name|EROFS
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|printf
argument_list|(
literal|"WARNING: NANDFS is considered to be a highly experimental "
literal|"feature in FreeBSD.\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|nandfs_mount_device
argument_list|(
name|devvp
argument_list|,
name|mp
argument_list|,
name|args
argument_list|,
operator|&
name|nandfsdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|error
goto|;
name|nmp
operator|=
operator|(
expr|struct
name|nandfsmount
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nandfsmount
argument_list|)
argument_list|,
name|M_NANDFSMNT
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|mp
operator|->
name|mnt_data
operator|=
name|nmp
expr_stmt|;
name|nmp
operator|->
name|nm_vfs_mountp
operator|=
name|mp
expr_stmt|;
name|nmp
operator|->
name|nm_ronly
operator|=
name|ronly
expr_stmt|;
name|MNT_ILOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|mp
operator|->
name|mnt_flag
operator||=
name|MNT_LOCAL
expr_stmt|;
name|MNT_IUNLOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|nmp
operator|->
name|nm_nandfsdev
operator|=
name|nandfsdev
expr_stmt|;
comment|/* Add our mountpoint */
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|nandfsdev
operator|->
name|nd_mounts
argument_list|,
name|nmp
argument_list|,
name|nm_next_mount
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|cpno
operator|>
name|nandfsdev
operator|->
name|nd_last_cno
condition|)
block|{
name|printf
argument_list|(
literal|"WARNING: supplied checkpoint number (%jd) is greater "
literal|"than last known checkpoint on filesystem (%jd). Mounting"
literal|" checkpoint %jd\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|args
operator|->
name|cpno
argument_list|,
operator|(
name|uintmax_t
operator|)
name|nandfsdev
operator|->
name|nd_last_cno
argument_list|,
operator|(
name|uintmax_t
operator|)
name|nandfsdev
operator|->
name|nd_last_cno
argument_list|)
expr_stmt|;
name|args
operator|->
name|cpno
operator|=
name|nandfsdev
operator|->
name|nd_last_cno
expr_stmt|;
block|}
comment|/* Setting up other parameters */
name|nmp
operator|->
name|nm_mount_args
operator|=
operator|*
name|args
expr_stmt|;
name|free
argument_list|(
name|args
argument_list|,
name|M_NANDFSMNT
argument_list|)
expr_stmt|;
name|error
operator|=
name|nandfs_mount_checkpoint
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|nandfs_unmount
argument_list|(
name|mp
argument_list|,
name|MNT_FORCE
argument_list|)
expr_stmt|;
goto|goto
name|unmounted
goto|;
block|}
if|if
condition|(
operator|!
name|ronly
condition|)
block|{
name|error
operator|=
name|start_syncer
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|nandfs_start_cleaner
argument_list|(
name|nmp
operator|->
name|nm_nandfsdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|nandfs_unmount
argument_list|(
name|mp
argument_list|,
name|MNT_FORCE
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|error
label|:
if|if
condition|(
name|args
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|args
argument_list|,
name|M_NANDFSMNT
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmp
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|nmp
argument_list|,
name|M_NANDFSMNT
argument_list|)
expr_stmt|;
name|mp
operator|->
name|mnt_data
operator|=
name|NULL
expr_stmt|;
block|}
name|unmounted
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nandfs_unmount
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|int
name|mntflags
parameter_list|)
block|{
name|struct
name|nandfs_device
modifier|*
name|nandfsdev
decl_stmt|;
name|struct
name|nandfsmount
modifier|*
name|nmp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|flags
init|=
literal|0
decl_stmt|;
name|DPRINTF
argument_list|(
name|VOLUMES
argument_list|,
operator|(
literal|"%s: mp = %p\n"
operator|,
name|__func__
operator|,
operator|(
name|void
operator|*
operator|)
name|mp
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mntflags
operator|&
name|MNT_FORCE
condition|)
name|flags
operator||=
name|FORCECLOSE
expr_stmt|;
name|nmp
operator|=
name|mp
operator|->
name|mnt_data
expr_stmt|;
name|nandfsdev
operator|=
name|nmp
operator|->
name|nm_nandfsdev
expr_stmt|;
name|error
operator|=
name|vflush
argument_list|(
name|mp
argument_list|,
literal|0
argument_list|,
name|flags
operator||
name|SKIPSYSTEM
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|nmp
operator|->
name|nm_ronly
operator|)
condition|)
block|{
name|nandfs_stop_cleaner
argument_list|(
name|nandfsdev
argument_list|)
expr_stmt|;
name|stop_syncer
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nmp
operator|->
name|nm_ifile_node
condition|)
name|NANDFS_UNSET_SYSTEMFILE
argument_list|(
name|NTOV
argument_list|(
name|nmp
operator|->
name|nm_ifile_node
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Remove our mount point */
name|STAILQ_REMOVE
argument_list|(
operator|&
name|nandfsdev
operator|->
name|nd_mounts
argument_list|,
name|nmp
argument_list|,
name|nandfsmount
argument_list|,
name|nm_next_mount
argument_list|)
expr_stmt|;
comment|/* Unmount the device itself when we're the last one */
name|nandfs_unmount_device
argument_list|(
name|nandfsdev
argument_list|)
expr_stmt|;
name|free_nandfs_mountinfo
argument_list|(
name|mp
argument_list|)
expr_stmt|;
comment|/* 	 * Finally, throw away the null_mount structure 	 */
name|mp
operator|->
name|mnt_data
operator|=
literal|0
expr_stmt|;
name|MNT_ILOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|mp
operator|->
name|mnt_flag
operator|&=
operator|~
name|MNT_LOCAL
expr_stmt|;
name|MNT_IUNLOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nandfs_statfs
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|struct
name|statfs
modifier|*
name|sbp
parameter_list|)
block|{
name|struct
name|nandfsmount
modifier|*
name|nmp
decl_stmt|;
name|struct
name|nandfs_device
modifier|*
name|nandfsdev
decl_stmt|;
name|struct
name|nandfs_fsdata
modifier|*
name|fsdata
decl_stmt|;
name|struct
name|nandfs_super_block
modifier|*
name|sb
decl_stmt|;
name|struct
name|nandfs_block_group_desc
modifier|*
name|groups
decl_stmt|;
name|struct
name|nandfs_node
modifier|*
name|ifile
decl_stmt|;
name|struct
name|nandfs_mdt
modifier|*
name|mdt
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
name|uint32_t
name|entries_per_group
decl_stmt|;
name|uint64_t
name|files
init|=
literal|0
decl_stmt|;
name|nmp
operator|=
name|mp
operator|->
name|mnt_data
expr_stmt|;
name|nandfsdev
operator|=
name|nmp
operator|->
name|nm_nandfsdev
expr_stmt|;
name|fsdata
operator|=
operator|&
name|nandfsdev
operator|->
name|nd_fsdata
expr_stmt|;
name|sb
operator|=
operator|&
name|nandfsdev
operator|->
name|nd_super
expr_stmt|;
name|ifile
operator|=
name|nmp
operator|->
name|nm_ifile_node
expr_stmt|;
name|mdt
operator|=
operator|&
name|nandfsdev
operator|->
name|nd_ifile_mdt
expr_stmt|;
name|entries_per_group
operator|=
name|mdt
operator|->
name|entries_per_group
expr_stmt|;
name|VOP_LOCK
argument_list|(
name|NTOV
argument_list|(
name|ifile
argument_list|)
argument_list|,
name|LK_SHARED
argument_list|)
expr_stmt|;
name|error
operator|=
name|nandfs_bread
argument_list|(
name|ifile
argument_list|,
literal|0
argument_list|,
name|NOCRED
argument_list|,
literal|0
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|NTOV
argument_list|(
name|ifile
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|groups
operator|=
operator|(
expr|struct
name|nandfs_block_group_desc
operator|*
operator|)
name|bp
operator|->
name|b_data
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mdt
operator|->
name|groups_per_desc_block
condition|;
name|i
operator|++
control|)
name|files
operator|+=
operator|(
name|entries_per_group
operator|-
name|groups
index|[
name|i
index|]
operator|.
name|bg_nfrees
operator|)
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|NTOV
argument_list|(
name|ifile
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sbp
operator|->
name|f_bsize
operator|=
name|nandfsdev
operator|->
name|nd_blocksize
expr_stmt|;
name|sbp
operator|->
name|f_iosize
operator|=
name|sbp
operator|->
name|f_bsize
expr_stmt|;
name|sbp
operator|->
name|f_blocks
operator|=
name|fsdata
operator|->
name|f_blocks_per_segment
operator|*
name|fsdata
operator|->
name|f_nsegments
expr_stmt|;
name|sbp
operator|->
name|f_bfree
operator|=
name|sb
operator|->
name|s_free_blocks_count
expr_stmt|;
name|sbp
operator|->
name|f_bavail
operator|=
name|sbp
operator|->
name|f_bfree
expr_stmt|;
name|sbp
operator|->
name|f_files
operator|=
name|files
expr_stmt|;
name|sbp
operator|->
name|f_ffree
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nandfs_root
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
parameter_list|)
block|{
name|struct
name|nandfsmount
modifier|*
name|nmp
init|=
name|VFSTONANDFS
argument_list|(
name|mp
argument_list|)
decl_stmt|;
name|struct
name|nandfs_node
modifier|*
name|node
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|nandfs_get_node
argument_list|(
name|nmp
argument_list|,
name|NANDFS_ROOT_INO
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|KASSERT
argument_list|(
name|NTOV
argument_list|(
name|node
argument_list|)
operator|->
name|v_vflag
operator|&
name|VV_ROOT
argument_list|,
operator|(
literal|"root_vp->v_vflag& VV_ROOT"
operator|)
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|NTOV
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nandfs_vget
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|ino_t
name|ino
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
parameter_list|)
block|{
name|struct
name|nandfsmount
modifier|*
name|nmp
init|=
name|VFSTONANDFS
argument_list|(
name|mp
argument_list|)
decl_stmt|;
name|struct
name|nandfs_node
modifier|*
name|node
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|nandfs_get_node
argument_list|(
name|nmp
argument_list|,
name|ino
argument_list|,
operator|&
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
condition|)
operator|*
name|vpp
operator|=
name|NTOV
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nandfs_sync
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|int
name|waitfor
parameter_list|)
block|{
name|struct
name|nandfsmount
modifier|*
name|nmp
init|=
name|VFSTONANDFS
argument_list|(
name|mp
argument_list|)
decl_stmt|;
name|DPRINTF
argument_list|(
name|SYNC
argument_list|,
operator|(
literal|"%s: mp %p waitfor %d\n"
operator|,
name|__func__
operator|,
name|mp
operator|,
name|waitfor
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * XXX: A hack to be removed soon 	 */
if|if
condition|(
name|waitfor
operator|==
name|MNT_LAZY
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|waitfor
operator|==
name|MNT_SUSPEND
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|nandfs_wakeup_wait_sync
argument_list|(
name|nmp
operator|->
name|nm_nandfsdev
argument_list|,
name|SYNCER_VFS_SYNC
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|vfsops
name|nandfs_vfsops
init|=
block|{
operator|.
name|vfs_init
operator|=
name|nandfs_init
block|,
operator|.
name|vfs_mount
operator|=
name|nandfs_mount
block|,
operator|.
name|vfs_root
operator|=
name|nandfs_root
block|,
operator|.
name|vfs_statfs
operator|=
name|nandfs_statfs
block|,
operator|.
name|vfs_uninit
operator|=
name|nandfs_uninit
block|,
operator|.
name|vfs_unmount
operator|=
name|nandfs_unmount
block|,
operator|.
name|vfs_vget
operator|=
name|nandfs_vget
block|,
operator|.
name|vfs_sync
operator|=
name|nandfs_sync
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|VFS_SET
argument_list|(
name|nandfs_vfsops
argument_list|,
name|nandfs
argument_list|,
name|VFCF_LOOPBACK
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

