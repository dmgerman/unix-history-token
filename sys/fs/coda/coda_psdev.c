begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *   *             Coda: an Experimental Distributed File System  *                              Release 3.1  *   *           Copyright (c) 1987-1998 Carnegie Mellon University  *                          All Rights Reserved  *   * Permission  to  use, copy, modify and distribute this software and its  * documentation is hereby granted,  provided  that  both  the  copyright  * notice  and  this  permission  notice  appear  in  all  copies  of the  * software, derivative works or  modified  versions,  and  any  portions  * thereof, and that both notices appear in supporting documentation, and  * that credit is given to Carnegie Mellon University  in  all  documents  * and publicity pertaining to direct or indirect use of this code or its  * derivatives.  *   * CODA IS AN EXPERIMENTAL SOFTWARE SYSTEM AND IS  KNOWN  TO  HAVE  BUGS,  * SOME  OF  WHICH MAY HAVE SERIOUS CONSEQUENCES.  CARNEGIE MELLON ALLOWS  * FREE USE OF THIS SOFTWARE IN ITS "AS IS" CONDITION.   CARNEGIE  MELLON  * DISCLAIMS  ANY  LIABILITY  OF  ANY  KIND  FOR  ANY  DAMAGES WHATSOEVER  * RESULTING DIRECTLY OR INDIRECTLY FROM THE USE OF THIS SOFTWARE  OR  OF  * ANY DERIVATIVE WORK.  *   * Carnegie  Mellon  encourages  users  of  this  software  to return any  * improvements or extensions that  they  make,  and  to  grant  Carnegie  * Mellon the rights to redistribute these changes without encumbrance.  *   * 	@(#) src/sys/coda/coda_psdev.c,v 1.1.1.1 1998/08/29 21:14:52 rvb Exp $  *  $Id: coda_psdev.c,v 1.4 1998/09/13 13:57:59 rvb Exp $  *   */
end_comment

begin_comment
comment|/*   * Mach Operating System  * Copyright (c) 1989 Carnegie-Mellon University  * All rights reserved.  The CMU software License Agreement specifies  * the terms and conditions for use and redistribution.  */
end_comment

begin_comment
comment|/*  * This code was written for the Coda file system at Carnegie Mellon  * University.  Contributers include David Steere, James Kistler, and  * M. Satyanarayanan.  */
end_comment

begin_comment
comment|/*   * These routines define the psuedo device for communication between  * Coda's Venus and Minicache in Mach 2.6. They used to be in cfs_subr.c,   * but I moved them to make it easier to port the Minicache without   * porting coda. -- DCS 10/12/94  */
end_comment

begin_comment
comment|/*  * HISTORY  * $Log: coda_psdev.c,v $  * Revision 1.4  1998/09/13 13:57:59  rvb  * Finish conversion of cfs -> coda  *  * Revision 1.3  1998/09/11 18:50:17  rvb  * All the references to cfs, in symbols, structs, and strings  * have been changed to coda.  (Same for CFS.)  *  * Revision 1.2  1998/09/02 19:09:53  rvb  * Pass2 complete  *  * Revision 1.1.1.1  1998/08/29 21:14:52  rvb  * Very Preliminary Coda  *  * Revision 1.9  1998/08/28 18:12:17  rvb  * Now it also works on FreeBSD -current.  This code will be  * committed to the FreeBSD -current and NetBSD -current  * trees.  It will then be tailored to the particular platform  * by flushing conditional code.  *  * Revision 1.8  1998/08/18 17:05:15  rvb  * Don't use __RCSID now  *  * Revision 1.7  1998/08/18 16:31:41  rvb  * Sync the code for NetBSD -current; test on 1.3 later  *  * Revision 1.8  1998/06/09 23:30:42  rvb  * Try to allow ^C -- take 1  *  * Revision 1.5.2.8  98/01/23  11:21:04  rvb  * Sync with 2.2.5  *   * Revision 1.5.2.7  98/01/22  22:22:21  rvb  * sync 1.2 and 1.3  *   * Revision 1.5.2.6  98/01/22  13:11:24  rvb  * Move make_coda_node ctlfid later so vfsp is known; work on ^c and ^z  *   * Revision 1.5.2.5  97/12/16  22:01:27  rvb  * Oops add cfs_subr.h cfs_venus.h; sync with peter  *   * Revision 1.5.2.4  97/12/16  12:40:05  rvb  * Sync with 1.3  *   * Revision 1.5.2.3  97/12/10  14:08:24  rvb  * Fix O_ flags; check result in coda_call  *   * Revision 1.5.2.2  97/12/10  11:40:24  rvb  * No more ody  *   * Revision 1.5.2.1  97/12/06  17:41:20  rvb  * Sync with peters coda.h  *   * Revision 1.5  97/12/05  10:39:16  rvb  * Read CHANGES  *   * Revision 1.4.18.9  97/12/05  08:58:07  rvb  * peter found this one  *   * Revision 1.4.18.8  97/11/26  15:28:57  rvb  * Cant make downcall pbuf == union cfs_downcalls yet  *   * Revision 1.4.18.7  97/11/25  09:40:49  rvb  * Final cfs_venus.c w/o macros, but one locking bug  *   * Revision 1.4.18.6  97/11/20  11:46:41  rvb  * Capture current cfs_venus  *   * Revision 1.4.18.5  97/11/18  10:27:15  rvb  * cfs_nbsd.c is DEAD!!!; integrated into cfs_vf/vnops.c  * cfs_nb_foo and cfs_foo are joined  *   * Revision 1.4.18.4  97/11/13  22:02:59  rvb  * pass2 cfs_NetBSD.h mt  *   * Revision 1.4.18.3  97/11/12  12:09:38  rvb  * reorg pass1  *   * Revision 1.4.18.2  97/10/29  16:06:09  rvb  * Kill DYING  *   * Revision 1.4.18.1  1997/10/28 23:10:15  rvb  *>64Meg; venus can be killed!  *  * Revision 1.4  1996/12/12 22:10:58  bnoble  * Fixed the "downcall invokes venus operation" deadlock in all known cases.  * There may be more  *  * Revision 1.3  1996/11/13 04:14:20  bnoble  * Merging BNOBLE_WORK_6_20_96 into main line  *  * Revision 1.2.8.1  1996/08/22 14:25:04  bnoble  * Added a return code from vc_nb_close  *  * Revision 1.2  1996/01/02 16:56:58  bnoble  * Added support for Coda MiniCache and raw inode calls (final commit)  *  * Revision 1.1.2.1  1995/12/20 01:57:24  bnoble  * Added CODA-specific files  *  * Revision 1.1  1995/03/14  20:52:15  bnoble  * Initial revision  *  */
end_comment

begin_comment
comment|/* These routines are the device entry points for Venus. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|coda_nc_initialized
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set if cache has been initialized */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ACTUALLY_LKM_NOT_KERNEL
end_ifdef

begin_define
define|#
directive|define
name|NVCODA
value|4
end_define

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<vcoda.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioccom.h>
end_include

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<coda/coda.h>
end_include

begin_include
include|#
directive|include
file|<coda/cnode.h>
end_include

begin_include
include|#
directive|include
file|<coda/coda_namecache.h>
end_include

begin_include
include|#
directive|include
file|<coda/coda_io.h>
end_include

begin_include
include|#
directive|include
file|<coda/coda_psdev.h>
end_include

begin_define
define|#
directive|define
name|CTL_C
end_define

begin_decl_stmt
name|int
name|coda_psdev_print_entry
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ENTRY
value|if(coda_psdev_print_entry) myprintf(("Entered %s\n",__FUNCTION__))
end_define

begin_function_decl
name|void
name|vcodaattach
parameter_list|(
name|int
name|n
parameter_list|)
function_decl|;
end_function_decl

begin_struct
struct|struct
name|vmsg
block|{
name|struct
name|queue
name|vm_chain
decl_stmt|;
name|caddr_t
name|vm_data
decl_stmt|;
name|u_short
name|vm_flags
decl_stmt|;
name|u_short
name|vm_inSize
decl_stmt|;
comment|/* Size is at most 5000 bytes */
name|u_short
name|vm_outSize
decl_stmt|;
name|u_short
name|vm_opcode
decl_stmt|;
comment|/* copied from data to save ptr lookup */
name|int
name|vm_unique
decl_stmt|;
name|caddr_t
name|vm_sleep
decl_stmt|;
comment|/* Not used by Mach. */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|VM_READ
value|1
end_define

begin_define
define|#
directive|define
name|VM_WRITE
value|2
end_define

begin_define
define|#
directive|define
name|VM_INTR
value|4
end_define

begin_comment
comment|/* vcodaattach: do nothing */
end_comment

begin_function
name|void
name|vcodaattach
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{ }
end_function

begin_function
name|int
name|vc_nb_open
parameter_list|(
name|dev
parameter_list|,
name|flag
parameter_list|,
name|mode
parameter_list|,
name|p
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|flag
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
comment|/* NetBSD only */
block|{
specifier|register
name|struct
name|vcomm
modifier|*
name|vcp
decl_stmt|;
name|ENTRY
expr_stmt|;
if|if
condition|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|>=
name|NVCODA
operator|||
name|minor
argument_list|(
name|dev
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
operator|!
name|coda_nc_initialized
condition|)
name|coda_nc_init
argument_list|()
expr_stmt|;
name|vcp
operator|=
operator|&
name|coda_mnttbl
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
operator|.
name|mi_vcomm
expr_stmt|;
if|if
condition|(
name|VC_OPEN
argument_list|(
name|vcp
argument_list|)
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|bzero
argument_list|(
operator|&
operator|(
name|vcp
operator|->
name|vc_selproc
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|selinfo
argument_list|)
argument_list|)
expr_stmt|;
name|INIT_QUEUE
argument_list|(
name|vcp
operator|->
name|vc_requests
argument_list|)
expr_stmt|;
name|INIT_QUEUE
argument_list|(
name|vcp
operator|->
name|vc_replys
argument_list|)
expr_stmt|;
name|MARK_VC_OPEN
argument_list|(
name|vcp
argument_list|)
expr_stmt|;
name|coda_mnttbl
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
operator|.
name|mi_vfsp
operator|=
name|NULL
expr_stmt|;
name|coda_mnttbl
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
operator|.
name|mi_rootvp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vc_nb_close
parameter_list|(
name|dev
parameter_list|,
name|flag
parameter_list|,
name|mode
parameter_list|,
name|p
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|flag
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|struct
name|vcomm
modifier|*
name|vcp
decl_stmt|;
specifier|register
name|struct
name|vmsg
modifier|*
name|vmp
decl_stmt|;
name|struct
name|coda_mntinfo
modifier|*
name|mi
decl_stmt|;
name|int
name|err
decl_stmt|;
name|ENTRY
expr_stmt|;
if|if
condition|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|>=
name|NVCODA
operator|||
name|minor
argument_list|(
name|dev
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|mi
operator|=
operator|&
name|coda_mnttbl
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
name|vcp
operator|=
operator|&
operator|(
name|mi
operator|->
name|mi_vcomm
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|VC_OPEN
argument_list|(
name|vcp
argument_list|)
condition|)
name|panic
argument_list|(
literal|"vcclose: not open"
argument_list|)
expr_stmt|;
comment|/* prevent future operations on this vfs from succeeding by auto-      * unmounting any vfs mounted via this device. This frees user or      * sysadm from having to remember where all mount points are located.      * Put this before WAKEUPs to avoid queuing new messages between      * the WAKEUP and the unmount (which can happen if we're unlucky)      */
if|if
condition|(
name|mi
operator|->
name|mi_rootvp
condition|)
block|{
comment|/* Let unmount know this is for real */
name|VTOC
argument_list|(
name|mi
operator|->
name|mi_rootvp
argument_list|)
operator|->
name|c_flags
operator||=
name|C_UNMOUNTING
expr_stmt|;
name|coda_unmounting
argument_list|(
name|mi
operator|->
name|mi_vfsp
argument_list|)
expr_stmt|;
name|err
operator|=
name|dounmount
argument_list|(
name|mi
operator|->
name|mi_vfsp
argument_list|,
name|flag
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|myprintf
argument_list|(
operator|(
literal|"Error %d unmounting vfs in vcclose(%d)\n"
operator|,
name|err
operator|,
name|minor
argument_list|(
name|dev
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Wakeup clients so they can return. */
for|for
control|(
name|vmp
operator|=
operator|(
expr|struct
name|vmsg
operator|*
operator|)
name|GETNEXT
argument_list|(
name|vcp
operator|->
name|vc_requests
argument_list|)
init|;
operator|!
name|EOQ
argument_list|(
name|vmp
argument_list|,
name|vcp
operator|->
name|vc_requests
argument_list|)
condition|;
name|vmp
operator|=
operator|(
expr|struct
name|vmsg
operator|*
operator|)
name|GETNEXT
argument_list|(
name|vmp
operator|->
name|vm_chain
argument_list|)
control|)
block|{
comment|/* Free signal request messages and don't wakeup cause 	   no one is waiting. */
if|if
condition|(
name|vmp
operator|->
name|vm_opcode
operator|==
name|CODA_SIGNAL
condition|)
block|{
name|CODA_FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|vmp
operator|->
name|vm_data
argument_list|,
operator|(
name|u_int
operator|)
name|VC_IN_NO_DATA
argument_list|)
expr_stmt|;
name|CODA_FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|vmp
argument_list|,
operator|(
name|u_int
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|vmsg
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|wakeup
argument_list|(
operator|&
name|vmp
operator|->
name|vm_sleep
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|vmp
operator|=
operator|(
expr|struct
name|vmsg
operator|*
operator|)
name|GETNEXT
argument_list|(
name|vcp
operator|->
name|vc_replys
argument_list|)
init|;
operator|!
name|EOQ
argument_list|(
name|vmp
argument_list|,
name|vcp
operator|->
name|vc_replys
argument_list|)
condition|;
name|vmp
operator|=
operator|(
expr|struct
name|vmsg
operator|*
operator|)
name|GETNEXT
argument_list|(
name|vmp
operator|->
name|vm_chain
argument_list|)
control|)
block|{
name|wakeup
argument_list|(
operator|&
name|vmp
operator|->
name|vm_sleep
argument_list|)
expr_stmt|;
block|}
name|MARK_VC_CLOSED
argument_list|(
name|vcp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|vc_nb_read
parameter_list|(
name|dev
parameter_list|,
name|uiop
parameter_list|,
name|flag
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|struct
name|uio
modifier|*
name|uiop
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
specifier|register
name|struct
name|vcomm
modifier|*
name|vcp
decl_stmt|;
specifier|register
name|struct
name|vmsg
modifier|*
name|vmp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|ENTRY
expr_stmt|;
if|if
condition|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|>=
name|NVCODA
operator|||
name|minor
argument_list|(
name|dev
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|vcp
operator|=
operator|&
name|coda_mnttbl
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
operator|.
name|mi_vcomm
expr_stmt|;
comment|/* Get message at head of request queue. */
if|if
condition|(
name|EMPTY
argument_list|(
name|vcp
operator|->
name|vc_requests
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Nothing to read */
name|vmp
operator|=
operator|(
expr|struct
name|vmsg
operator|*
operator|)
name|GETNEXT
argument_list|(
name|vcp
operator|->
name|vc_requests
argument_list|)
expr_stmt|;
comment|/* Move the input args into userspace */
name|uiop
operator|->
name|uio_rw
operator|=
name|UIO_READ
expr_stmt|;
name|error
operator|=
name|uiomove
argument_list|(
name|vmp
operator|->
name|vm_data
argument_list|,
name|vmp
operator|->
name|vm_inSize
argument_list|,
name|uiop
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|myprintf
argument_list|(
operator|(
literal|"vcread: error (%d) on uiomove\n"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|OLD_DIAGNOSTIC
if|if
condition|(
name|vmp
operator|->
name|vm_chain
operator|.
name|forw
operator|==
literal|0
operator|||
name|vmp
operator|->
name|vm_chain
operator|.
name|back
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"vc_nb_read: bad chain"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|REMQUE
argument_list|(
name|vmp
operator|->
name|vm_chain
argument_list|)
expr_stmt|;
comment|/* If request was a signal, free up the message and don't        enqueue it in the reply queue. */
if|if
condition|(
name|vmp
operator|->
name|vm_opcode
operator|==
name|CODA_SIGNAL
condition|)
block|{
if|if
condition|(
name|codadebug
condition|)
name|myprintf
argument_list|(
operator|(
literal|"vcread: signal msg (%d, %d)\n"
operator|,
name|vmp
operator|->
name|vm_opcode
operator|,
name|vmp
operator|->
name|vm_unique
operator|)
argument_list|)
expr_stmt|;
name|CODA_FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|vmp
operator|->
name|vm_data
argument_list|,
operator|(
name|u_int
operator|)
name|VC_IN_NO_DATA
argument_list|)
expr_stmt|;
name|CODA_FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|vmp
argument_list|,
operator|(
name|u_int
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|vmsg
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|vmp
operator|->
name|vm_flags
operator||=
name|VM_READ
expr_stmt|;
name|INSQUE
argument_list|(
name|vmp
operator|->
name|vm_chain
argument_list|,
name|vcp
operator|->
name|vc_replys
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vc_nb_write
parameter_list|(
name|dev
parameter_list|,
name|uiop
parameter_list|,
name|flag
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|struct
name|uio
modifier|*
name|uiop
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
specifier|register
name|struct
name|vcomm
modifier|*
name|vcp
decl_stmt|;
specifier|register
name|struct
name|vmsg
modifier|*
name|vmp
decl_stmt|;
name|struct
name|coda_out_hdr
modifier|*
name|out
decl_stmt|;
name|u_long
name|seq
decl_stmt|;
name|u_long
name|opcode
decl_stmt|;
name|int
name|buf
index|[
literal|2
index|]
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|ENTRY
expr_stmt|;
if|if
condition|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|>=
name|NVCODA
operator|||
name|minor
argument_list|(
name|dev
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|vcp
operator|=
operator|&
name|coda_mnttbl
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
operator|.
name|mi_vcomm
expr_stmt|;
comment|/* Peek at the opcode, unique without transfering the data. */
name|uiop
operator|->
name|uio_rw
operator|=
name|UIO_WRITE
expr_stmt|;
name|error
operator|=
name|uiomove
argument_list|(
operator|(
name|caddr_t
operator|)
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
literal|2
argument_list|,
name|uiop
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|myprintf
argument_list|(
operator|(
literal|"vcwrite: error (%d) on uiomove\n"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|opcode
operator|=
name|buf
index|[
literal|0
index|]
expr_stmt|;
name|seq
operator|=
name|buf
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|codadebug
condition|)
name|myprintf
argument_list|(
operator|(
literal|"vcwrite got a call for %ld.%ld\n"
operator|,
name|opcode
operator|,
name|seq
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DOWNCALL
argument_list|(
name|opcode
argument_list|)
condition|)
block|{
name|union
name|outputArgs
name|pbuf
decl_stmt|;
comment|/* get the rest of the data. */
name|uiop
operator|->
name|uio_rw
operator|=
name|UIO_WRITE
expr_stmt|;
name|error
operator|=
name|uiomove
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|pbuf
operator|.
name|coda_purgeuser
operator|.
name|oh
operator|.
name|result
argument_list|,
sizeof|sizeof
argument_list|(
name|pbuf
argument_list|)
operator|-
operator|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
literal|2
operator|)
argument_list|,
name|uiop
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|myprintf
argument_list|(
operator|(
literal|"vcwrite: error (%d) on uiomove (Op %ld seq %ld)\n"
operator|,
name|error
operator|,
name|opcode
operator|,
name|seq
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
name|handleDownCall
argument_list|(
name|opcode
argument_list|,
operator|&
name|pbuf
argument_list|)
return|;
block|}
comment|/* Look for the message on the (waiting for) reply queue. */
for|for
control|(
name|vmp
operator|=
operator|(
expr|struct
name|vmsg
operator|*
operator|)
name|GETNEXT
argument_list|(
name|vcp
operator|->
name|vc_replys
argument_list|)
init|;
operator|!
name|EOQ
argument_list|(
name|vmp
argument_list|,
name|vcp
operator|->
name|vc_replys
argument_list|)
condition|;
name|vmp
operator|=
operator|(
expr|struct
name|vmsg
operator|*
operator|)
name|GETNEXT
argument_list|(
name|vmp
operator|->
name|vm_chain
argument_list|)
control|)
block|{
if|if
condition|(
name|vmp
operator|->
name|vm_unique
operator|==
name|seq
condition|)
break|break;
block|}
if|if
condition|(
name|EOQ
argument_list|(
name|vmp
argument_list|,
name|vcp
operator|->
name|vc_replys
argument_list|)
condition|)
block|{
if|if
condition|(
name|codadebug
condition|)
name|myprintf
argument_list|(
operator|(
literal|"vcwrite: msg (%ld, %ld) not found\n"
operator|,
name|opcode
operator|,
name|seq
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ESRCH
operator|)
return|;
block|}
comment|/* Remove the message from the reply queue */
name|REMQUE
argument_list|(
name|vmp
operator|->
name|vm_chain
argument_list|)
expr_stmt|;
comment|/* move data into response buffer. */
name|out
operator|=
operator|(
expr|struct
name|coda_out_hdr
operator|*
operator|)
name|vmp
operator|->
name|vm_data
expr_stmt|;
comment|/* Don't need to copy opcode and uniquifier. */
comment|/* get the rest of the data. */
if|if
condition|(
name|vmp
operator|->
name|vm_outSize
operator|<
name|uiop
operator|->
name|uio_resid
condition|)
block|{
name|myprintf
argument_list|(
operator|(
literal|"vcwrite: more data than asked for (%d< %d)\n"
operator|,
name|vmp
operator|->
name|vm_outSize
operator|,
name|uiop
operator|->
name|uio_resid
operator|)
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|vmp
operator|->
name|vm_sleep
argument_list|)
expr_stmt|;
comment|/* Notify caller of the error. */
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|buf
index|[
literal|0
index|]
operator|=
name|uiop
operator|->
name|uio_resid
expr_stmt|;
comment|/* Save this value. */
name|uiop
operator|->
name|uio_rw
operator|=
name|UIO_WRITE
expr_stmt|;
name|error
operator|=
name|uiomove
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|out
operator|->
name|result
argument_list|,
name|vmp
operator|->
name|vm_outSize
operator|-
operator|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
literal|2
operator|)
argument_list|,
name|uiop
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|myprintf
argument_list|(
operator|(
literal|"vcwrite: error (%d) on uiomove (op %ld seq %ld)\n"
operator|,
name|error
operator|,
name|opcode
operator|,
name|seq
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* I don't think these are used, but just in case. */
comment|/* XXX - aren't these two already correct? -bnoble */
name|out
operator|->
name|opcode
operator|=
name|opcode
expr_stmt|;
name|out
operator|->
name|unique
operator|=
name|seq
expr_stmt|;
name|vmp
operator|->
name|vm_outSize
operator|=
name|buf
index|[
literal|0
index|]
expr_stmt|;
comment|/* Amount of data transferred? */
name|vmp
operator|->
name|vm_flags
operator||=
name|VM_WRITE
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|vmp
operator|->
name|vm_sleep
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vc_nb_ioctl
parameter_list|(
name|dev
parameter_list|,
name|cmd
parameter_list|,
name|addr
parameter_list|,
name|flag
parameter_list|,
name|p
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|u_long
name|cmd
decl_stmt|;
name|caddr_t
name|addr
decl_stmt|;
name|int
name|flag
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|ENTRY
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|CODARESIZE
case|:
block|{
name|struct
name|coda_resize
modifier|*
name|data
init|=
operator|(
expr|struct
name|coda_resize
operator|*
operator|)
name|addr
decl_stmt|;
return|return
operator|(
name|coda_nc_resize
argument_list|(
name|data
operator|->
name|hashsize
argument_list|,
name|data
operator|->
name|heapsize
argument_list|,
name|IS_DOWNCALL
argument_list|)
operator|)
return|;
break|break;
block|}
case|case
name|CODASTATS
case|:
if|if
condition|(
name|coda_nc_use
condition|)
block|{
name|coda_nc_gather_stats
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
break|break;
case|case
name|CODAPRINT
case|:
if|if
condition|(
name|coda_nc_use
condition|)
block|{
name|print_coda_nc
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
break|break;
default|default :
return|return
operator|(
name|EINVAL
operator|)
return|;
break|break;
block|}
block|}
end_function

begin_function
name|int
name|vc_nb_poll
parameter_list|(
name|dev
parameter_list|,
name|events
parameter_list|,
name|p
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|events
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|struct
name|vcomm
modifier|*
name|vcp
decl_stmt|;
name|int
name|event_msk
init|=
literal|0
decl_stmt|;
name|ENTRY
expr_stmt|;
if|if
condition|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|>=
name|NVCODA
operator|||
name|minor
argument_list|(
name|dev
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|vcp
operator|=
operator|&
name|coda_mnttbl
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
operator|.
name|mi_vcomm
expr_stmt|;
name|event_msk
operator|=
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|event_msk
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|EMPTY
argument_list|(
name|vcp
operator|->
name|vc_requests
argument_list|)
condition|)
return|return
operator|(
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
operator|)
return|;
name|selrecord
argument_list|(
name|p
argument_list|,
operator|&
operator|(
name|vcp
operator|->
name|vc_selproc
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Statistics  */
end_comment

begin_decl_stmt
name|struct
name|coda_clstat
name|coda_clstat
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   * Key question: whether to sleep interuptably or uninteruptably when  * waiting for Venus.  The former seems better (cause you can ^C a  * job), but then GNU-EMACS completion breaks. Use tsleep with no  * timeout, and no longjmp happens. But, when sleeping  * "uninterruptibly", we don't get told if it returns abnormally  * (e.g. kill -9).    */
end_comment

begin_decl_stmt
name|int
name|coda_call_sleep
init|=
name|PZERO
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|CTL_C
end_ifdef

begin_decl_stmt
name|int
name|coda_pcatch
init|=
name|PCATCH
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|coda_call
parameter_list|(
name|mntinfo
parameter_list|,
name|inSize
parameter_list|,
name|outSize
parameter_list|,
name|buffer
parameter_list|)
name|struct
name|coda_mntinfo
modifier|*
name|mntinfo
decl_stmt|;
name|int
name|inSize
decl_stmt|;
name|int
modifier|*
name|outSize
decl_stmt|;
name|caddr_t
name|buffer
decl_stmt|;
block|{
name|struct
name|vcomm
modifier|*
name|vcp
decl_stmt|;
name|struct
name|vmsg
modifier|*
name|vmp
decl_stmt|;
name|int
name|error
decl_stmt|;
ifdef|#
directive|ifdef
name|CTL_C
name|struct
name|proc
modifier|*
name|p
init|=
name|curproc
decl_stmt|;
name|unsigned
name|int
name|psig_omask
init|=
name|p
operator|->
name|p_sigmask
decl_stmt|;
name|int
name|i
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|mntinfo
operator|==
name|NULL
condition|)
block|{
comment|/* Unlikely, but could be a race condition with a dying warden */
return|return
name|ENODEV
return|;
block|}
name|vcp
operator|=
operator|&
operator|(
name|mntinfo
operator|->
name|mi_vcomm
operator|)
expr_stmt|;
name|coda_clstat
operator|.
name|ncalls
operator|++
expr_stmt|;
name|coda_clstat
operator|.
name|reqs
index|[
operator|(
operator|(
expr|struct
name|coda_in_hdr
operator|*
block|)
function|buffer
end_function

begin_expr_stmt
unit|)
operator|->
name|opcode
expr|]
operator|++
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|VC_OPEN
argument_list|(
name|vcp
argument_list|)
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
end_if

begin_expr_stmt
name|CODA_ALLOC
argument_list|(
name|vmp
argument_list|,
expr|struct
name|vmsg
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vmsg
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Format the request message. */
end_comment

begin_expr_stmt
name|vmp
operator|->
name|vm_data
operator|=
name|buffer
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|vmp
operator|->
name|vm_flags
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|vmp
operator|->
name|vm_inSize
operator|=
name|inSize
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|vmp
operator|->
name|vm_outSize
operator|=
operator|*
name|outSize
condition|?
operator|*
name|outSize
else|:
name|inSize
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* |buffer|>= inSize */
end_comment

begin_expr_stmt
name|vmp
operator|->
name|vm_opcode
operator|=
operator|(
operator|(
expr|struct
name|coda_in_hdr
operator|*
operator|)
name|buffer
operator|)
operator|->
name|opcode
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|vmp
operator|->
name|vm_unique
operator|=
operator|++
name|vcp
operator|->
name|vc_seq
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|codadebug
condition|)
name|myprintf
argument_list|(
operator|(
literal|"Doing a call for %d.%d\n"
operator|,
name|vmp
operator|->
name|vm_opcode
operator|,
name|vmp
operator|->
name|vm_unique
operator|)
argument_list|)
expr_stmt|;
end_if

begin_comment
comment|/* Fill in the common input args. */
end_comment

begin_expr_stmt
operator|(
operator|(
expr|struct
name|coda_in_hdr
operator|*
operator|)
name|buffer
operator|)
operator|->
name|unique
operator|=
name|vmp
operator|->
name|vm_unique
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Append msg to request queue and poke Venus. */
end_comment

begin_expr_stmt
name|INSQUE
argument_list|(
name|vmp
operator|->
name|vm_chain
argument_list|,
name|vcp
operator|->
name|vc_requests
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|selwakeup
argument_list|(
operator|&
operator|(
name|vcp
operator|->
name|vc_selproc
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* We can be interrupted while we wait for Venus to process 	 * our request.  If the interrupt occurs before Venus has read 	 * the request, we dequeue and return. If it occurs after the 	 * read but before the reply, we dequeue, send a signal 	 * message, and return. If it occurs after the reply we ignore 	 * it. In no case do we want to restart the syscall.  If it 	 * was interrupted by a venus shutdown (vcclose), return 	 * ENODEV.  */
end_comment

begin_comment
comment|/* Ignore return, We have to check anyway */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CTL_C
end_ifdef

begin_comment
comment|/* This is work in progress.  Setting coda_pcatch lets tsleep reawaken 	   on a ^c or ^z.  The problem is that emacs sets certain interrupts 	   as SA_RESTART.  This means that we should exit sleep handle the 	   "signal" and then go to sleep again.  Mostly this is done by letting 	   the syscall complete and be restarted.  We are not idempotent and  	   can not do this.  A better solution is necessary. 	 */
end_comment

begin_expr_stmt
name|i
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_do
do|do
block|{
name|error
operator|=
name|tsleep
argument_list|(
operator|&
name|vmp
operator|->
name|vm_sleep
argument_list|,
operator|(
name|coda_call_sleep
operator||
name|coda_pcatch
operator|)
argument_list|,
literal|"coda_call"
argument_list|,
name|hz
operator|*
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
break|break;
elseif|else
if|if
condition|(
name|error
operator|==
name|EWOULDBLOCK
condition|)
block|{
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|printf
argument_list|(
literal|"coda_call: tsleep TIMEOUT %d sec\n"
argument_list|,
literal|2
operator|+
literal|2
operator|*
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|p_siglist
operator|==
name|sigmask
argument_list|(
name|SIGIO
argument_list|)
condition|)
block|{
name|p
operator|->
name|p_sigmask
operator||=
name|p
operator|->
name|p_siglist
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|printf
argument_list|(
literal|"coda_call: tsleep returns %d SIGIO, cnt %d\n"
argument_list|,
name|error
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|printf
argument_list|(
literal|"coda_call: tsleep returns %d, cnt %d\n"
argument_list|,
name|error
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"coda_call: siglist = %x, sigmask = %x, mask %x\n"
argument_list|,
name|p
operator|->
name|p_siglist
argument_list|,
name|p
operator|->
name|p_sigmask
argument_list|,
name|p
operator|->
name|p_siglist
operator|&
operator|~
name|p
operator|->
name|p_sigmask
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|notyet
name|p
operator|->
name|p_sigmask
operator||=
name|p
operator|->
name|p_siglist
expr_stmt|;
name|printf
argument_list|(
literal|"coda_call: new mask, siglist = %x, sigmask = %x, mask %x\n"
argument_list|,
name|p
operator|->
name|p_siglist
argument_list|,
name|p
operator|->
name|p_sigmask
argument_list|,
name|p
operator|->
name|p_siglist
operator|&
operator|~
name|p
operator|->
name|p_sigmask
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
do|while
condition|(
name|error
operator|&&
name|i
operator|++
operator|<
literal|128
condition|)
do|;
end_do

begin_expr_stmt
name|p
operator|->
name|p_sigmask
operator|=
name|psig_omask
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
operator|(
name|void
operator|)
name|tsleep
argument_list|(
operator|&
name|vmp
operator|->
name|vm_sleep
argument_list|,
name|coda_call_sleep
argument_list|,
literal|"coda_call"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|if
condition|(
name|VC_OPEN
argument_list|(
name|vcp
argument_list|)
condition|)
block|{
comment|/* Venus is still alive */
comment|/* Op went through, interrupt or not... */
if|if
condition|(
name|vmp
operator|->
name|vm_flags
operator|&
name|VM_WRITE
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
operator|*
name|outSize
operator|=
name|vmp
operator|->
name|vm_outSize
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|vmp
operator|->
name|vm_flags
operator|&
name|VM_READ
operator|)
condition|)
block|{
comment|/* Interrupted before venus read it. */
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
literal|1
condition|)
else|#
directive|else
if|if
condition|(
name|codadebug
condition|)
endif|#
directive|endif
name|myprintf
argument_list|(
operator|(
literal|"interrupted before read: op = %d.%d, flags = %x\n"
operator|,
name|vmp
operator|->
name|vm_opcode
operator|,
name|vmp
operator|->
name|vm_unique
operator|,
name|vmp
operator|->
name|vm_flags
operator|)
argument_list|)
expr_stmt|;
name|REMQUE
argument_list|(
name|vmp
operator|->
name|vm_chain
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINTR
expr_stmt|;
block|}
else|else
block|{
comment|/* (!(vmp->vm_flags& VM_WRITE)) means interrupted after                    upcall started */
comment|/* Interrupted after start of upcall, send venus a signal */
name|struct
name|coda_in_hdr
modifier|*
name|dog
decl_stmt|;
name|struct
name|vmsg
modifier|*
name|svmp
decl_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
literal|1
condition|)
else|#
directive|else
if|if
condition|(
name|codadebug
condition|)
endif|#
directive|endif
name|myprintf
argument_list|(
operator|(
literal|"Sending Venus a signal: op = %d.%d, flags = %x\n"
operator|,
name|vmp
operator|->
name|vm_opcode
operator|,
name|vmp
operator|->
name|vm_unique
operator|,
name|vmp
operator|->
name|vm_flags
operator|)
argument_list|)
expr_stmt|;
name|REMQUE
argument_list|(
name|vmp
operator|->
name|vm_chain
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINTR
expr_stmt|;
name|CODA_ALLOC
argument_list|(
name|svmp
argument_list|,
expr|struct
name|vmsg
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vmsg
argument_list|)
argument_list|)
expr_stmt|;
name|CODA_ALLOC
argument_list|(
operator|(
name|svmp
operator|->
name|vm_data
operator|)
argument_list|,
name|char
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|coda_in_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|dog
operator|=
operator|(
expr|struct
name|coda_in_hdr
operator|*
operator|)
name|svmp
operator|->
name|vm_data
expr_stmt|;
name|svmp
operator|->
name|vm_flags
operator|=
literal|0
expr_stmt|;
name|dog
operator|->
name|opcode
operator|=
name|svmp
operator|->
name|vm_opcode
operator|=
name|CODA_SIGNAL
expr_stmt|;
name|dog
operator|->
name|unique
operator|=
name|svmp
operator|->
name|vm_unique
operator|=
name|vmp
operator|->
name|vm_unique
expr_stmt|;
name|svmp
operator|->
name|vm_inSize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|coda_in_hdr
argument_list|)
expr_stmt|;
comment|/*??? rvb */
name|svmp
operator|->
name|vm_outSize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|coda_in_hdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|codadebug
condition|)
name|myprintf
argument_list|(
operator|(
literal|"coda_call: enqueing signal msg (%d, %d)\n"
operator|,
name|svmp
operator|->
name|vm_opcode
operator|,
name|svmp
operator|->
name|vm_unique
operator|)
argument_list|)
expr_stmt|;
comment|/* insert at head of queue! */
name|INSQUE
argument_list|(
name|svmp
operator|->
name|vm_chain
argument_list|,
name|vcp
operator|->
name|vc_requests
argument_list|)
expr_stmt|;
name|selwakeup
argument_list|(
operator|&
operator|(
name|vcp
operator|->
name|vc_selproc
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* If venus died (!VC_OPEN(vcp)) */
if|if
condition|(
name|codadebug
condition|)
name|myprintf
argument_list|(
operator|(
literal|"vcclose woke op %d.%d flags %d\n"
operator|,
name|vmp
operator|->
name|vm_opcode
operator|,
name|vmp
operator|->
name|vm_unique
operator|,
name|vmp
operator|->
name|vm_flags
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENODEV
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|CODA_FREE
argument_list|(
name|vmp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vmsg
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
operator|(
operator|(
expr|struct
name|coda_out_hdr
operator|*
operator|)
name|buffer
operator|)
operator|->
name|result
expr_stmt|;
end_if

begin_return
return|return
operator|(
name|error
operator|)
return|;
end_return

unit|}
end_unit

