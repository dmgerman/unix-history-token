begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *   *             Coda: an Experimental Distributed File System  *                              Release 3.1  *   *           Copyright (c) 1987-1998 Carnegie Mellon University  *                          All Rights Reserved  *   * Permission  to  use, copy, modify and distribute this software and its  * documentation is hereby granted,  provided  that  both  the  copyright  * notice  and  this  permission  notice  appear  in  all  copies  of the  * software, derivative works or  modified  versions,  and  any  portions  * thereof, and that both notices appear in supporting documentation, and  * that credit is given to Carnegie Mellon University  in  all  documents  * and publicity pertaining to direct or indirect use of this code or its  * derivatives.  *   * CODA IS AN EXPERIMENTAL SOFTWARE SYSTEM AND IS  KNOWN  TO  HAVE  BUGS,  * SOME  OF  WHICH MAY HAVE SERIOUS CONSEQUENCES.  CARNEGIE MELLON ALLOWS  * FREE USE OF THIS SOFTWARE IN ITS "AS IS" CONDITION.   CARNEGIE  MELLON  * DISCLAIMS  ANY  LIABILITY  OF  ANY  KIND  FOR  ANY  DAMAGES WHATSOEVER  * RESULTING DIRECTLY OR INDIRECTLY FROM THE USE OF THIS SOFTWARE  OR  OF  * ANY DERIVATIVE WORK.  *   * Carnegie  Mellon  encourages  users  of  this  software  to return any  * improvements or extensions that  they  make,  and  to  grant  Carnegie  * Mellon the rights to redistribute these changes without encumbrance.  *   * 	@(#) src/sys/cfs/coda_venus.c,v 1.1.1.1 1998/08/29 21:14:52 rvb Exp $  * $FreeBSD$  *   */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioccom.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<coda/coda.h>
end_include

begin_include
include|#
directive|include
file|<coda/cnode.h>
end_include

begin_include
include|#
directive|include
file|<coda/coda_venus.h>
end_include

begin_include
include|#
directive|include
file|<coda/coda_pioctl.h>
end_include

begin_define
define|#
directive|define
name|DECL_NO_IN
parameter_list|(
name|name
parameter_list|)
define|\
value|struct coda_in_hdr *inp;				\     struct name ## _out *outp;				\     int name ## _size = sizeof (struct coda_in_hdr);	\     int Isize = sizeof (struct coda_in_hdr);		\     int Osize = sizeof (struct name ## _out);		\     int error
end_define

begin_define
define|#
directive|define
name|DECL
parameter_list|(
name|name
parameter_list|)
define|\
value|struct name ## _in *inp;				\     struct name ## _out *outp;				\     int name ## _size = sizeof (struct name ## _in);	\     int Isize = sizeof (struct name ## _in);		\     int Osize = sizeof (struct name ## _out);		\     int error
end_define

begin_define
define|#
directive|define
name|DECL_NO_OUT
parameter_list|(
name|name
parameter_list|)
define|\
value|struct name ## _in *inp;				\     struct coda_out_hdr *outp;				\     int name ## _size = sizeof (struct name ## _in);	\     int Isize = sizeof (struct name ## _in);		\     int Osize = sizeof (struct coda_out_hdr);		\     int error
end_define

begin_define
define|#
directive|define
name|ALLOC_NO_IN
parameter_list|(
name|name
parameter_list|)
define|\
value|if (Osize> name ## _size)				\     	name ## _size = Osize;				\     CODA_ALLOC(inp, struct coda_in_hdr *, name ## _size);\     outp = (struct name ## _out *) inp
end_define

begin_define
define|#
directive|define
name|ALLOC
parameter_list|(
name|name
parameter_list|)
define|\
value|if (Osize> name ## _size)				\     	name ## _size = Osize;				\     CODA_ALLOC(inp, struct name ## _in *, name ## _size);\     outp = (struct name ## _out *) inp
end_define

begin_define
define|#
directive|define
name|ALLOC_NO_OUT
parameter_list|(
name|name
parameter_list|)
define|\
value|if (Osize> name ## _size)				\     	name ## _size = Osize;				\     CODA_ALLOC(inp, struct name ## _in *, name ## _size);\     outp = (struct coda_out_hdr *) inp
end_define

begin_define
define|#
directive|define
name|STRCPY
parameter_list|(
name|struc
parameter_list|,
name|name
parameter_list|,
name|len
parameter_list|)
define|\
value|bcopy(name, (char *)inp + (int)inp->struc, len); \     ((char*)inp + (int)inp->struc)[len++] = 0; \     Isize += len
end_define

begin_define
define|#
directive|define
name|INIT_IN
parameter_list|(
name|in
parameter_list|,
name|op
parameter_list|,
name|ident
parameter_list|,
name|p
parameter_list|)
define|\
value|(in)->opcode = (op); \ 	  PGRPSESS_SLOCK(); \ 	  (in)->pid = p ? p->p_pid : -1; \           (in)->pgid = p ? p->p_pgid : -1; \           (in)->sid = (p&& p->p_session&& p->p_session->s_leader) ? (p->p_session->s_leader->p_pid) : -1; \ 	  PGRPSESS_SUNLOCK(); \           if (ident != NOCRED) {                              \ 	      (in)->cred.cr_uid = ident->cr_uid;              \ 	      (in)->cred.cr_groupid = ident->cr_gid;          \           } else {                                            \ 	      bzero(&((in)->cred),sizeof(struct coda_cred));  \ 	      (in)->cred.cr_uid = -1;                         \ 	      (in)->cred.cr_groupid = -1;                     \           }                                                   \  #define	CNV_OFLAG(to, from) 				\     do { 						\ 	  to = 0;					\ 	  if (from& FREAD)   to |= C_O_READ; 		\ 	  if (from& FWRITE)  to |= C_O_WRITE; 		\ 	  if (from& O_TRUNC) to |= C_O_TRUNC; 		\ 	  if (from& O_EXCL)  to |= C_O_EXCL; 		\ 	  if (from& O_CREAT) to |= C_O_CREAT;		\     } while (0)
end_define

begin_define
define|#
directive|define
name|CNV_VV2V_ATTR
parameter_list|(
name|top
parameter_list|,
name|fromp
parameter_list|)
define|\
value|do { \ 		(top)->va_type = (fromp)->va_type; \ 		(top)->va_mode = (fromp)->va_mode; \ 		(top)->va_nlink = (fromp)->va_nlink; \ 		(top)->va_uid = (fromp)->va_uid; \ 		(top)->va_gid = (fromp)->va_gid; \ 		(top)->va_fsid = VNOVAL; \ 		(top)->va_fileid = (fromp)->va_fileid; \ 		(top)->va_size = (fromp)->va_size; \ 		(top)->va_blocksize = (fromp)->va_blocksize; \ 		(top)->va_atime = (fromp)->va_atime; \ 		(top)->va_mtime = (fromp)->va_mtime; \ 		(top)->va_ctime = (fromp)->va_ctime; \ 		(top)->va_gen = (fromp)->va_gen; \ 		(top)->va_flags = (fromp)->va_flags; \ 		(top)->va_rdev = (fromp)->va_rdev; \ 		(top)->va_bytes = (fromp)->va_bytes; \ 		(top)->va_filerev = (fromp)->va_filerev; \ 		(top)->va_vaflags = VNOVAL; \ 		(top)->va_spare = VNOVAL; \ 	} while (0)
end_define

begin_define
define|#
directive|define
name|CNV_V2VV_ATTR
parameter_list|(
name|top
parameter_list|,
name|fromp
parameter_list|)
define|\
value|do { \ 		(top)->va_type = (fromp)->va_type; \ 		(top)->va_mode = (fromp)->va_mode; \ 		(top)->va_nlink = (fromp)->va_nlink; \ 		(top)->va_uid = (fromp)->va_uid; \ 		(top)->va_gid = (fromp)->va_gid; \ 		(top)->va_fileid = (fromp)->va_fileid; \ 		(top)->va_size = (fromp)->va_size; \ 		(top)->va_blocksize = (fromp)->va_blocksize; \ 		(top)->va_atime = (fromp)->va_atime; \ 		(top)->va_mtime = (fromp)->va_mtime; \ 		(top)->va_ctime = (fromp)->va_ctime; \ 		(top)->va_gen = (fromp)->va_gen; \ 		(top)->va_flags = (fromp)->va_flags; \ 		(top)->va_rdev = (fromp)->va_rdev; \ 		(top)->va_bytes = (fromp)->va_bytes; \ 		(top)->va_filerev = (fromp)->va_filerev; \ 	} while (0)
end_define

begin_decl_stmt
name|int
name|coda_kernel_version
init|=
name|CODA_KERNEL_VERSION
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|venus_root
parameter_list|(
name|void
modifier|*
name|mdp
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|,
comment|/*out*/
name|ViceFid
modifier|*
name|VFid
parameter_list|)
block|{
name|DECL_NO_IN
argument_list|(
name|coda_root
argument_list|)
expr_stmt|;
comment|/* sets Isize& Osize */
name|ALLOC_NO_IN
argument_list|(
name|coda_root
argument_list|)
expr_stmt|;
comment|/* sets inp& outp */
comment|/* send the open to venus. */
name|INIT_IN
argument_list|(
name|inp
argument_list|,
name|CODA_ROOT
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|error
operator|=
name|coda_call
argument_list|(
name|mdp
argument_list|,
name|Isize
argument_list|,
operator|&
name|Osize
argument_list|,
operator|(
name|char
operator|*
operator|)
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
operator|*
name|VFid
operator|=
name|outp
operator|->
name|VFid
expr_stmt|;
name|CODA_FREE
argument_list|(
name|inp
argument_list|,
name|coda_root_size
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|venus_open
parameter_list|(
name|void
modifier|*
name|mdp
parameter_list|,
name|ViceFid
modifier|*
name|fid
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|,
comment|/*out*/
name|dev_t
modifier|*
name|dev
parameter_list|,
name|ino_t
modifier|*
name|inode
parameter_list|)
block|{
name|int
name|cflag
decl_stmt|;
name|DECL
argument_list|(
name|coda_open
argument_list|)
expr_stmt|;
comment|/* sets Isize& Osize */
name|ALLOC
argument_list|(
name|coda_open
argument_list|)
expr_stmt|;
comment|/* sets inp& outp */
comment|/* send the open to venus. */
name|INIT_IN
argument_list|(
operator|&
name|inp
operator|->
name|ih
argument_list|,
name|CODA_OPEN
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|inp
operator|->
name|VFid
operator|=
operator|*
name|fid
expr_stmt|;
name|CNV_OFLAG
argument_list|(
name|cflag
argument_list|,
name|flag
argument_list|)
expr_stmt|;
name|inp
operator|->
name|flags
operator|=
name|cflag
expr_stmt|;
name|error
operator|=
name|coda_call
argument_list|(
name|mdp
argument_list|,
name|Isize
argument_list|,
operator|&
name|Osize
argument_list|,
operator|(
name|char
operator|*
operator|)
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
comment|/* 5/11	*dev =  udev2dev(outp->dev, 2); */
operator|*
name|dev
operator|=
name|udev2dev
argument_list|(
name|outp
operator|->
name|dev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|inode
operator|=
name|outp
operator|->
name|inode
expr_stmt|;
block|}
name|CODA_FREE
argument_list|(
name|inp
argument_list|,
name|coda_open_size
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|venus_close
parameter_list|(
name|void
modifier|*
name|mdp
parameter_list|,
name|ViceFid
modifier|*
name|fid
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|cflag
decl_stmt|;
name|DECL_NO_OUT
argument_list|(
name|coda_close
argument_list|)
expr_stmt|;
comment|/* sets Isize& Osize */
name|ALLOC_NO_OUT
argument_list|(
name|coda_close
argument_list|)
expr_stmt|;
comment|/* sets inp& outp */
name|INIT_IN
argument_list|(
operator|&
name|inp
operator|->
name|ih
argument_list|,
name|CODA_CLOSE
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|inp
operator|->
name|VFid
operator|=
operator|*
name|fid
expr_stmt|;
name|CNV_OFLAG
argument_list|(
name|cflag
argument_list|,
name|flag
argument_list|)
expr_stmt|;
name|inp
operator|->
name|flags
operator|=
name|cflag
expr_stmt|;
name|error
operator|=
name|coda_call
argument_list|(
name|mdp
argument_list|,
name|Isize
argument_list|,
operator|&
name|Osize
argument_list|,
operator|(
name|char
operator|*
operator|)
name|inp
argument_list|)
expr_stmt|;
name|CODA_FREE
argument_list|(
name|inp
argument_list|,
name|coda_close_size
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * these two calls will not exist!!!  the container file is read/written  * directly.  */
end_comment

begin_function
name|void
name|venus_read
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function

begin_function
name|void
name|venus_write
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function

begin_comment
comment|/*  * this is a bit sad too.  the ioctl's are for the control file, not for  * normal files.  */
end_comment

begin_function
name|int
name|venus_ioctl
parameter_list|(
name|void
modifier|*
name|mdp
parameter_list|,
name|ViceFid
modifier|*
name|fid
parameter_list|,
name|int
name|com
parameter_list|,
name|int
name|flag
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|DECL
argument_list|(
name|coda_ioctl
argument_list|)
expr_stmt|;
comment|/* sets Isize& Osize */
name|struct
name|PioctlData
modifier|*
name|iap
init|=
operator|(
expr|struct
name|PioctlData
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|tmp
decl_stmt|;
name|coda_ioctl_size
operator|=
name|VC_MAXMSGSIZE
expr_stmt|;
name|ALLOC
argument_list|(
name|coda_ioctl
argument_list|)
expr_stmt|;
comment|/* sets inp& outp */
name|INIT_IN
argument_list|(
operator|&
name|inp
operator|->
name|ih
argument_list|,
name|CODA_IOCTL
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|inp
operator|->
name|VFid
operator|=
operator|*
name|fid
expr_stmt|;
comment|/* command was mutated by increasing its size field to reflect the        * path and follow args. we need to subtract that out before sending      * the command to venus.      */
name|inp
operator|->
name|cmd
operator|=
operator|(
name|com
operator|&
operator|~
operator|(
name|IOCPARM_MASK
operator|<<
literal|16
operator|)
operator|)
expr_stmt|;
name|tmp
operator|=
operator|(
operator|(
name|com
operator|>>
literal|16
operator|)
operator|&
name|IOCPARM_MASK
operator|)
operator|-
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|inp
operator|->
name|cmd
operator||=
operator|(
name|tmp
operator|&
name|IOCPARM_MASK
operator|)
operator|<<
literal|16
expr_stmt|;
name|inp
operator|->
name|rwflag
operator|=
name|flag
expr_stmt|;
name|inp
operator|->
name|len
operator|=
name|iap
operator|->
name|vi
operator|.
name|in_size
expr_stmt|;
name|inp
operator|->
name|data
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|coda_ioctl_in
argument_list|)
operator|)
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|iap
operator|->
name|vi
operator|.
name|in
argument_list|,
operator|(
name|char
operator|*
operator|)
name|inp
operator|+
operator|(
name|int
operator|)
name|inp
operator|->
name|data
argument_list|,
name|iap
operator|->
name|vi
operator|.
name|in_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|CODA_FREE
argument_list|(
name|inp
argument_list|,
name|coda_ioctl_size
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|Osize
operator|=
name|VC_MAXMSGSIZE
expr_stmt|;
name|error
operator|=
name|coda_call
argument_list|(
name|mdp
argument_list|,
name|Isize
operator|+
name|iap
operator|->
name|vi
operator|.
name|in_size
argument_list|,
operator|&
name|Osize
argument_list|,
operator|(
name|char
operator|*
operator|)
name|inp
argument_list|)
expr_stmt|;
comment|/* copy out the out buffer. */
if|if
condition|(
operator|!
name|error
condition|)
block|{
if|if
condition|(
name|outp
operator|->
name|len
operator|>
name|iap
operator|->
name|vi
operator|.
name|out_size
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|copyout
argument_list|(
operator|(
name|char
operator|*
operator|)
name|outp
operator|+
operator|(
name|int
operator|)
name|outp
operator|->
name|data
argument_list|,
name|iap
operator|->
name|vi
operator|.
name|out
argument_list|,
name|iap
operator|->
name|vi
operator|.
name|out_size
argument_list|)
expr_stmt|;
block|}
block|}
name|CODA_FREE
argument_list|(
name|inp
argument_list|,
name|coda_ioctl_size
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|venus_getattr
parameter_list|(
name|void
modifier|*
name|mdp
parameter_list|,
name|ViceFid
modifier|*
name|fid
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|,
comment|/*out*/
name|struct
name|vattr
modifier|*
name|vap
parameter_list|)
block|{
name|DECL
argument_list|(
name|coda_getattr
argument_list|)
expr_stmt|;
comment|/* sets Isize& Osize */
name|ALLOC
argument_list|(
name|coda_getattr
argument_list|)
expr_stmt|;
comment|/* sets inp& outp */
comment|/* send the open to venus. */
name|INIT_IN
argument_list|(
operator|&
name|inp
operator|->
name|ih
argument_list|,
name|CODA_GETATTR
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|inp
operator|->
name|VFid
operator|=
operator|*
name|fid
expr_stmt|;
name|error
operator|=
name|coda_call
argument_list|(
name|mdp
argument_list|,
name|Isize
argument_list|,
operator|&
name|Osize
argument_list|,
operator|(
name|char
operator|*
operator|)
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|CNV_VV2V_ATTR
argument_list|(
name|vap
argument_list|,
operator|&
name|outp
operator|->
name|attr
argument_list|)
expr_stmt|;
block|}
name|CODA_FREE
argument_list|(
name|inp
argument_list|,
name|coda_getattr_size
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|venus_setattr
parameter_list|(
name|void
modifier|*
name|mdp
parameter_list|,
name|ViceFid
modifier|*
name|fid
parameter_list|,
name|struct
name|vattr
modifier|*
name|vap
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|DECL_NO_OUT
argument_list|(
name|coda_setattr
argument_list|)
expr_stmt|;
comment|/* sets Isize& Osize */
name|ALLOC_NO_OUT
argument_list|(
name|coda_setattr
argument_list|)
expr_stmt|;
comment|/* sets inp& outp */
comment|/* send the open to venus. */
name|INIT_IN
argument_list|(
operator|&
name|inp
operator|->
name|ih
argument_list|,
name|CODA_SETATTR
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|inp
operator|->
name|VFid
operator|=
operator|*
name|fid
expr_stmt|;
name|CNV_V2VV_ATTR
argument_list|(
operator|&
name|inp
operator|->
name|attr
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|error
operator|=
name|coda_call
argument_list|(
name|mdp
argument_list|,
name|Isize
argument_list|,
operator|&
name|Osize
argument_list|,
operator|(
name|char
operator|*
operator|)
name|inp
argument_list|)
expr_stmt|;
name|CODA_FREE
argument_list|(
name|inp
argument_list|,
name|coda_setattr_size
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|venus_access
parameter_list|(
name|void
modifier|*
name|mdp
parameter_list|,
name|ViceFid
modifier|*
name|fid
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|DECL_NO_OUT
argument_list|(
name|coda_access
argument_list|)
expr_stmt|;
comment|/* sets Isize& Osize */
name|ALLOC_NO_OUT
argument_list|(
name|coda_access
argument_list|)
expr_stmt|;
comment|/* sets inp& outp */
comment|/* send the open to venus. */
name|INIT_IN
argument_list|(
operator|&
name|inp
operator|->
name|ih
argument_list|,
name|CODA_ACCESS
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|inp
operator|->
name|VFid
operator|=
operator|*
name|fid
expr_stmt|;
comment|/* NOTE:      * NetBSD and Venus internals use the "data" in the low 3 bits.      * Hence, the conversion.      */
name|inp
operator|->
name|flags
operator|=
name|mode
operator|>>
literal|6
expr_stmt|;
name|error
operator|=
name|coda_call
argument_list|(
name|mdp
argument_list|,
name|Isize
argument_list|,
operator|&
name|Osize
argument_list|,
operator|(
name|char
operator|*
operator|)
name|inp
argument_list|)
expr_stmt|;
name|CODA_FREE
argument_list|(
name|inp
argument_list|,
name|coda_access_size
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|venus_readlink
parameter_list|(
name|void
modifier|*
name|mdp
parameter_list|,
name|ViceFid
modifier|*
name|fid
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|,
comment|/*out*/
name|char
modifier|*
modifier|*
name|str
parameter_list|,
name|int
modifier|*
name|len
parameter_list|)
block|{
name|DECL
argument_list|(
name|coda_readlink
argument_list|)
expr_stmt|;
comment|/* sets Isize& Osize */
name|coda_readlink_size
operator|+=
name|CODA_MAXPATHLEN
expr_stmt|;
name|ALLOC
argument_list|(
name|coda_readlink
argument_list|)
expr_stmt|;
comment|/* sets inp& outp */
comment|/* send the open to venus. */
name|INIT_IN
argument_list|(
operator|&
name|inp
operator|->
name|ih
argument_list|,
name|CODA_READLINK
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|inp
operator|->
name|VFid
operator|=
operator|*
name|fid
expr_stmt|;
name|Osize
operator|+=
name|CODA_MAXPATHLEN
expr_stmt|;
name|error
operator|=
name|coda_call
argument_list|(
name|mdp
argument_list|,
name|Isize
argument_list|,
operator|&
name|Osize
argument_list|,
operator|(
name|char
operator|*
operator|)
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|CODA_ALLOC
argument_list|(
operator|*
name|str
argument_list|,
name|char
operator|*
argument_list|,
name|outp
operator|->
name|count
argument_list|)
expr_stmt|;
operator|*
name|len
operator|=
name|outp
operator|->
name|count
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|outp
operator|+
operator|(
name|int
operator|)
name|outp
operator|->
name|data
argument_list|,
operator|*
name|str
argument_list|,
operator|*
name|len
argument_list|)
expr_stmt|;
block|}
name|CODA_FREE
argument_list|(
name|inp
argument_list|,
name|coda_readlink_size
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|venus_fsync
parameter_list|(
name|void
modifier|*
name|mdp
parameter_list|,
name|ViceFid
modifier|*
name|fid
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|DECL_NO_OUT
argument_list|(
name|coda_fsync
argument_list|)
expr_stmt|;
comment|/* sets Isize& Osize */
name|ALLOC_NO_OUT
argument_list|(
name|coda_fsync
argument_list|)
expr_stmt|;
comment|/* sets inp& outp */
comment|/* send the open to venus. */
name|INIT_IN
argument_list|(
operator|&
name|inp
operator|->
name|ih
argument_list|,
name|CODA_FSYNC
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|inp
operator|->
name|VFid
operator|=
operator|*
name|fid
expr_stmt|;
name|error
operator|=
name|coda_call
argument_list|(
name|mdp
argument_list|,
name|Isize
argument_list|,
operator|&
name|Osize
argument_list|,
operator|(
name|char
operator|*
operator|)
name|inp
argument_list|)
expr_stmt|;
name|CODA_FREE
argument_list|(
name|inp
argument_list|,
name|coda_fsync_size
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|venus_lookup
parameter_list|(
name|void
modifier|*
name|mdp
parameter_list|,
name|ViceFid
modifier|*
name|fid
parameter_list|,
specifier|const
name|char
modifier|*
name|nm
parameter_list|,
name|int
name|len
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|,
comment|/*out*/
name|ViceFid
modifier|*
name|VFid
parameter_list|,
name|int
modifier|*
name|vtype
parameter_list|)
block|{
name|DECL
argument_list|(
name|coda_lookup
argument_list|)
expr_stmt|;
comment|/* sets Isize& Osize */
name|coda_lookup_size
operator|+=
name|len
operator|+
literal|1
expr_stmt|;
name|ALLOC
argument_list|(
name|coda_lookup
argument_list|)
expr_stmt|;
comment|/* sets inp& outp */
comment|/* send the open to venus. */
name|INIT_IN
argument_list|(
operator|&
name|inp
operator|->
name|ih
argument_list|,
name|CODA_LOOKUP
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|inp
operator|->
name|VFid
operator|=
operator|*
name|fid
expr_stmt|;
comment|/* NOTE:      * Between version 1 and version 2 we have added an extra flag field      * to this structure.  But because the string was at the end and because      * of the wierd way we represent strings by having the slot point to      * where the string characters are in the "heap", we can just slip the      * flag parameter in after the string slot pointer and veni that don't      * know better won't see this new flag field ...      * Otherwise we'd need two different venus_lookup functions.      */
name|inp
operator|->
name|name
operator|=
name|Isize
expr_stmt|;
name|inp
operator|->
name|flags
operator|=
name|CLU_CASE_SENSITIVE
expr_stmt|;
comment|/* doesn't really matter for BSD */
name|STRCPY
argument_list|(
name|name
argument_list|,
name|nm
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* increments Isize */
name|error
operator|=
name|coda_call
argument_list|(
name|mdp
argument_list|,
name|Isize
argument_list|,
operator|&
name|Osize
argument_list|,
operator|(
name|char
operator|*
operator|)
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
operator|*
name|VFid
operator|=
name|outp
operator|->
name|VFid
expr_stmt|;
operator|*
name|vtype
operator|=
name|outp
operator|->
name|vtype
expr_stmt|;
block|}
name|CODA_FREE
argument_list|(
name|inp
argument_list|,
name|coda_lookup_size
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|venus_create
parameter_list|(
name|void
modifier|*
name|mdp
parameter_list|,
name|ViceFid
modifier|*
name|fid
parameter_list|,
specifier|const
name|char
modifier|*
name|nm
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|exclusive
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|vattr
modifier|*
name|va
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|,
comment|/*out*/
name|ViceFid
modifier|*
name|VFid
parameter_list|,
name|struct
name|vattr
modifier|*
name|attr
parameter_list|)
block|{
name|DECL
argument_list|(
name|coda_create
argument_list|)
expr_stmt|;
comment|/* sets Isize& Osize */
name|coda_create_size
operator|+=
name|len
operator|+
literal|1
expr_stmt|;
name|ALLOC
argument_list|(
name|coda_create
argument_list|)
expr_stmt|;
comment|/* sets inp& outp */
comment|/* send the open to venus. */
name|INIT_IN
argument_list|(
operator|&
name|inp
operator|->
name|ih
argument_list|,
name|CODA_CREATE
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|inp
operator|->
name|VFid
operator|=
operator|*
name|fid
expr_stmt|;
name|inp
operator|->
name|excl
operator|=
name|exclusive
condition|?
name|C_O_EXCL
else|:
literal|0
expr_stmt|;
name|inp
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
name|CNV_V2VV_ATTR
argument_list|(
operator|&
name|inp
operator|->
name|attr
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|inp
operator|->
name|name
operator|=
name|Isize
expr_stmt|;
name|STRCPY
argument_list|(
name|name
argument_list|,
name|nm
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* increments Isize */
name|error
operator|=
name|coda_call
argument_list|(
name|mdp
argument_list|,
name|Isize
argument_list|,
operator|&
name|Osize
argument_list|,
operator|(
name|char
operator|*
operator|)
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
operator|*
name|VFid
operator|=
name|outp
operator|->
name|VFid
expr_stmt|;
name|CNV_VV2V_ATTR
argument_list|(
name|attr
argument_list|,
operator|&
name|outp
operator|->
name|attr
argument_list|)
expr_stmt|;
block|}
name|CODA_FREE
argument_list|(
name|inp
argument_list|,
name|coda_create_size
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|venus_remove
parameter_list|(
name|void
modifier|*
name|mdp
parameter_list|,
name|ViceFid
modifier|*
name|fid
parameter_list|,
specifier|const
name|char
modifier|*
name|nm
parameter_list|,
name|int
name|len
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|DECL_NO_OUT
argument_list|(
name|coda_remove
argument_list|)
expr_stmt|;
comment|/* sets Isize& Osize */
name|coda_remove_size
operator|+=
name|len
operator|+
literal|1
expr_stmt|;
name|ALLOC_NO_OUT
argument_list|(
name|coda_remove
argument_list|)
expr_stmt|;
comment|/* sets inp& outp */
comment|/* send the open to venus. */
name|INIT_IN
argument_list|(
operator|&
name|inp
operator|->
name|ih
argument_list|,
name|CODA_REMOVE
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|inp
operator|->
name|VFid
operator|=
operator|*
name|fid
expr_stmt|;
name|inp
operator|->
name|name
operator|=
name|Isize
expr_stmt|;
name|STRCPY
argument_list|(
name|name
argument_list|,
name|nm
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* increments Isize */
name|error
operator|=
name|coda_call
argument_list|(
name|mdp
argument_list|,
name|Isize
argument_list|,
operator|&
name|Osize
argument_list|,
operator|(
name|char
operator|*
operator|)
name|inp
argument_list|)
expr_stmt|;
name|CODA_FREE
argument_list|(
name|inp
argument_list|,
name|coda_remove_size
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|venus_link
parameter_list|(
name|void
modifier|*
name|mdp
parameter_list|,
name|ViceFid
modifier|*
name|fid
parameter_list|,
name|ViceFid
modifier|*
name|tfid
parameter_list|,
specifier|const
name|char
modifier|*
name|nm
parameter_list|,
name|int
name|len
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|DECL_NO_OUT
argument_list|(
name|coda_link
argument_list|)
expr_stmt|;
comment|/* sets Isize& Osize */
name|coda_link_size
operator|+=
name|len
operator|+
literal|1
expr_stmt|;
name|ALLOC_NO_OUT
argument_list|(
name|coda_link
argument_list|)
expr_stmt|;
comment|/* sets inp& outp */
comment|/* send the open to venus. */
name|INIT_IN
argument_list|(
operator|&
name|inp
operator|->
name|ih
argument_list|,
name|CODA_LINK
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|inp
operator|->
name|sourceFid
operator|=
operator|*
name|fid
expr_stmt|;
name|inp
operator|->
name|destFid
operator|=
operator|*
name|tfid
expr_stmt|;
name|inp
operator|->
name|tname
operator|=
name|Isize
expr_stmt|;
name|STRCPY
argument_list|(
name|tname
argument_list|,
name|nm
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* increments Isize */
name|error
operator|=
name|coda_call
argument_list|(
name|mdp
argument_list|,
name|Isize
argument_list|,
operator|&
name|Osize
argument_list|,
operator|(
name|char
operator|*
operator|)
name|inp
argument_list|)
expr_stmt|;
name|CODA_FREE
argument_list|(
name|inp
argument_list|,
name|coda_link_size
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|venus_rename
parameter_list|(
name|void
modifier|*
name|mdp
parameter_list|,
name|ViceFid
modifier|*
name|fid
parameter_list|,
name|ViceFid
modifier|*
name|tfid
parameter_list|,
specifier|const
name|char
modifier|*
name|nm
parameter_list|,
name|int
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|tnm
parameter_list|,
name|int
name|tlen
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|DECL_NO_OUT
argument_list|(
name|coda_rename
argument_list|)
expr_stmt|;
comment|/* sets Isize& Osize */
name|coda_rename_size
operator|+=
name|len
operator|+
literal|1
operator|+
name|tlen
operator|+
literal|1
expr_stmt|;
name|ALLOC_NO_OUT
argument_list|(
name|coda_rename
argument_list|)
expr_stmt|;
comment|/* sets inp& outp */
comment|/* send the open to venus. */
name|INIT_IN
argument_list|(
operator|&
name|inp
operator|->
name|ih
argument_list|,
name|CODA_RENAME
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|inp
operator|->
name|sourceFid
operator|=
operator|*
name|fid
expr_stmt|;
name|inp
operator|->
name|destFid
operator|=
operator|*
name|tfid
expr_stmt|;
name|inp
operator|->
name|srcname
operator|=
name|Isize
expr_stmt|;
name|STRCPY
argument_list|(
name|srcname
argument_list|,
name|nm
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* increments Isize */
name|inp
operator|->
name|destname
operator|=
name|Isize
expr_stmt|;
name|STRCPY
argument_list|(
name|destname
argument_list|,
name|tnm
argument_list|,
name|tlen
argument_list|)
expr_stmt|;
comment|/* increments Isize */
name|error
operator|=
name|coda_call
argument_list|(
name|mdp
argument_list|,
name|Isize
argument_list|,
operator|&
name|Osize
argument_list|,
operator|(
name|char
operator|*
operator|)
name|inp
argument_list|)
expr_stmt|;
name|CODA_FREE
argument_list|(
name|inp
argument_list|,
name|coda_rename_size
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|venus_mkdir
parameter_list|(
name|void
modifier|*
name|mdp
parameter_list|,
name|ViceFid
modifier|*
name|fid
parameter_list|,
specifier|const
name|char
modifier|*
name|nm
parameter_list|,
name|int
name|len
parameter_list|,
name|struct
name|vattr
modifier|*
name|va
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|,
comment|/*out*/
name|ViceFid
modifier|*
name|VFid
parameter_list|,
name|struct
name|vattr
modifier|*
name|ova
parameter_list|)
block|{
name|DECL
argument_list|(
name|coda_mkdir
argument_list|)
expr_stmt|;
comment|/* sets Isize& Osize */
name|coda_mkdir_size
operator|+=
name|len
operator|+
literal|1
expr_stmt|;
name|ALLOC
argument_list|(
name|coda_mkdir
argument_list|)
expr_stmt|;
comment|/* sets inp& outp */
comment|/* send the open to venus. */
name|INIT_IN
argument_list|(
operator|&
name|inp
operator|->
name|ih
argument_list|,
name|CODA_MKDIR
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|inp
operator|->
name|VFid
operator|=
operator|*
name|fid
expr_stmt|;
name|CNV_V2VV_ATTR
argument_list|(
operator|&
name|inp
operator|->
name|attr
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|inp
operator|->
name|name
operator|=
name|Isize
expr_stmt|;
name|STRCPY
argument_list|(
name|name
argument_list|,
name|nm
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* increments Isize */
name|error
operator|=
name|coda_call
argument_list|(
name|mdp
argument_list|,
name|Isize
argument_list|,
operator|&
name|Osize
argument_list|,
operator|(
name|char
operator|*
operator|)
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
operator|*
name|VFid
operator|=
name|outp
operator|->
name|VFid
expr_stmt|;
name|CNV_VV2V_ATTR
argument_list|(
name|ova
argument_list|,
operator|&
name|outp
operator|->
name|attr
argument_list|)
expr_stmt|;
block|}
name|CODA_FREE
argument_list|(
name|inp
argument_list|,
name|coda_mkdir_size
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|venus_rmdir
parameter_list|(
name|void
modifier|*
name|mdp
parameter_list|,
name|ViceFid
modifier|*
name|fid
parameter_list|,
specifier|const
name|char
modifier|*
name|nm
parameter_list|,
name|int
name|len
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|DECL_NO_OUT
argument_list|(
name|coda_rmdir
argument_list|)
expr_stmt|;
comment|/* sets Isize& Osize */
name|coda_rmdir_size
operator|+=
name|len
operator|+
literal|1
expr_stmt|;
name|ALLOC_NO_OUT
argument_list|(
name|coda_rmdir
argument_list|)
expr_stmt|;
comment|/* sets inp& outp */
comment|/* send the open to venus. */
name|INIT_IN
argument_list|(
operator|&
name|inp
operator|->
name|ih
argument_list|,
name|CODA_RMDIR
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|inp
operator|->
name|VFid
operator|=
operator|*
name|fid
expr_stmt|;
name|inp
operator|->
name|name
operator|=
name|Isize
expr_stmt|;
name|STRCPY
argument_list|(
name|name
argument_list|,
name|nm
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* increments Isize */
name|error
operator|=
name|coda_call
argument_list|(
name|mdp
argument_list|,
name|Isize
argument_list|,
operator|&
name|Osize
argument_list|,
operator|(
name|char
operator|*
operator|)
name|inp
argument_list|)
expr_stmt|;
name|CODA_FREE
argument_list|(
name|inp
argument_list|,
name|coda_rmdir_size
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|venus_symlink
parameter_list|(
name|void
modifier|*
name|mdp
parameter_list|,
name|ViceFid
modifier|*
name|fid
parameter_list|,
specifier|const
name|char
modifier|*
name|lnm
parameter_list|,
name|int
name|llen
parameter_list|,
specifier|const
name|char
modifier|*
name|nm
parameter_list|,
name|int
name|len
parameter_list|,
name|struct
name|vattr
modifier|*
name|va
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|DECL_NO_OUT
argument_list|(
name|coda_symlink
argument_list|)
expr_stmt|;
comment|/* sets Isize& Osize */
name|coda_symlink_size
operator|+=
name|llen
operator|+
literal|1
operator|+
name|len
operator|+
literal|1
expr_stmt|;
name|ALLOC_NO_OUT
argument_list|(
name|coda_symlink
argument_list|)
expr_stmt|;
comment|/* sets inp& outp */
comment|/* send the open to venus. */
name|INIT_IN
argument_list|(
operator|&
name|inp
operator|->
name|ih
argument_list|,
name|CODA_SYMLINK
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|inp
operator|->
name|VFid
operator|=
operator|*
name|fid
expr_stmt|;
name|CNV_V2VV_ATTR
argument_list|(
operator|&
name|inp
operator|->
name|attr
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|inp
operator|->
name|srcname
operator|=
name|Isize
expr_stmt|;
name|STRCPY
argument_list|(
name|srcname
argument_list|,
name|lnm
argument_list|,
name|llen
argument_list|)
expr_stmt|;
comment|/* increments Isize */
name|inp
operator|->
name|tname
operator|=
name|Isize
expr_stmt|;
name|STRCPY
argument_list|(
name|tname
argument_list|,
name|nm
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* increments Isize */
name|error
operator|=
name|coda_call
argument_list|(
name|mdp
argument_list|,
name|Isize
argument_list|,
operator|&
name|Osize
argument_list|,
operator|(
name|char
operator|*
operator|)
name|inp
argument_list|)
expr_stmt|;
name|CODA_FREE
argument_list|(
name|inp
argument_list|,
name|coda_symlink_size
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|venus_readdir
parameter_list|(
name|void
modifier|*
name|mdp
parameter_list|,
name|ViceFid
modifier|*
name|fid
parameter_list|,
name|int
name|count
parameter_list|,
name|int
name|offset
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|,
comment|/*out*/
name|char
modifier|*
name|buffer
parameter_list|,
name|int
modifier|*
name|len
parameter_list|)
block|{
name|DECL
argument_list|(
name|coda_readdir
argument_list|)
expr_stmt|;
comment|/* sets Isize& Osize */
name|coda_readdir_size
operator|=
name|VC_MAXMSGSIZE
expr_stmt|;
name|ALLOC
argument_list|(
name|coda_readdir
argument_list|)
expr_stmt|;
comment|/* sets inp& outp */
comment|/* send the open to venus. */
name|INIT_IN
argument_list|(
operator|&
name|inp
operator|->
name|ih
argument_list|,
name|CODA_READDIR
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|inp
operator|->
name|VFid
operator|=
operator|*
name|fid
expr_stmt|;
name|inp
operator|->
name|count
operator|=
name|count
expr_stmt|;
name|inp
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
name|Osize
operator|=
name|VC_MAXMSGSIZE
expr_stmt|;
name|error
operator|=
name|coda_call
argument_list|(
name|mdp
argument_list|,
name|Isize
argument_list|,
operator|&
name|Osize
argument_list|,
operator|(
name|char
operator|*
operator|)
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|outp
operator|+
operator|(
name|int
operator|)
name|outp
operator|->
name|data
argument_list|,
name|buffer
argument_list|,
name|outp
operator|->
name|size
argument_list|)
expr_stmt|;
operator|*
name|len
operator|=
name|outp
operator|->
name|size
expr_stmt|;
block|}
name|CODA_FREE
argument_list|(
name|inp
argument_list|,
name|coda_readdir_size
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|venus_fhtovp
parameter_list|(
name|void
modifier|*
name|mdp
parameter_list|,
name|ViceFid
modifier|*
name|fid
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|,
comment|/*out*/
name|ViceFid
modifier|*
name|VFid
parameter_list|,
name|int
modifier|*
name|vtype
parameter_list|)
block|{
name|DECL
argument_list|(
name|coda_vget
argument_list|)
expr_stmt|;
comment|/* sets Isize& Osize */
name|ALLOC
argument_list|(
name|coda_vget
argument_list|)
expr_stmt|;
comment|/* sets inp& outp */
comment|/* Send the open to Venus. */
name|INIT_IN
argument_list|(
operator|&
name|inp
operator|->
name|ih
argument_list|,
name|CODA_VGET
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|inp
operator|->
name|VFid
operator|=
operator|*
name|fid
expr_stmt|;
name|error
operator|=
name|coda_call
argument_list|(
name|mdp
argument_list|,
name|Isize
argument_list|,
operator|&
name|Osize
argument_list|,
operator|(
name|char
operator|*
operator|)
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
operator|*
name|VFid
operator|=
name|outp
operator|->
name|VFid
expr_stmt|;
operator|*
name|vtype
operator|=
name|outp
operator|->
name|vtype
expr_stmt|;
block|}
name|CODA_FREE
argument_list|(
name|inp
argument_list|,
name|coda_vget_size
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

end_unit

