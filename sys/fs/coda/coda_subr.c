begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  *             Coda: an Experimental Distributed File System  *                              Release 3.1  *  *           Copyright (c) 1987-1998 Carnegie Mellon University  *                          All Rights Reserved  *  * Permission  to  use, copy, modify and distribute this software and its  * documentation is hereby granted,  provided  that  both  the  copyright  * notice  and  this  permission  notice  appear  in  all  copies  of the  * software, derivative works or  modified  versions,  and  any  portions  * thereof, and that both notices appear in supporting documentation, and  * that credit is given to Carnegie Mellon University  in  all  documents  * and publicity pertaining to direct or indirect use of this code or its  * derivatives.  *  * CODA IS AN EXPERIMENTAL SOFTWARE SYSTEM AND IS  KNOWN  TO  HAVE  BUGS,  * SOME  OF  WHICH MAY HAVE SERIOUS CONSEQUENCES.  CARNEGIE MELLON ALLOWS  * FREE USE OF THIS SOFTWARE IN ITS "AS IS" CONDITION.   CARNEGIE  MELLON  * DISCLAIMS  ANY  LIABILITY  OF  ANY  KIND  FOR  ANY  DAMAGES WHATSOEVER  * RESULTING DIRECTLY OR INDIRECTLY FROM THE USE OF THIS SOFTWARE  OR  OF  * ANY DERIVATIVE WORK.  *  * Carnegie  Mellon  encourages  users  of  this  software  to return any  * improvements or extensions that  they  make,  and  to  grant  Carnegie  * Mellon the rights to redistribute these changes without encumbrance.  *  * 	@(#) src/sys/coda/coda_subr.c,v 1.1.1.1 1998/08/29 21:14:52 rvb Exp $  */
end_comment

begin_comment
comment|/*-  * Mach Operating System  * Copyright (c) 1989 Carnegie-Mellon University  * All rights reserved.  The CMU software License Agreement specifies  * the terms and conditions for use and redistribution.  */
end_comment

begin_comment
comment|/*  * This code was written for the Coda filesystem at Carnegie Mellon  * University.  Contributers include David Steere, James Kistler, and  * M. Satyanarayanan.  */
end_comment

begin_comment
comment|/*-  * NOTES: rvb  * 1.	Added coda_unmounting to mark all cnodes as being UNMOUNTING.  This  *	has to be done before dounmount is called.  Because some of the  *	routines that dounmount calls before coda_unmounted might try to  *	force flushes to venus.  The vnode pager does this.  * 2.	coda_unmounting marks all cnodes scanning coda_cache.  * 3.	cfs_checkunmounting (under DEBUG) checks all cnodes by chasing the  *	vnodes under the /coda mount point.  * 4.	coda_cacheprint (under DEBUG) prints names with vnode/cnode address.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<fs/coda/coda.h>
end_include

begin_include
include|#
directive|include
file|<fs/coda/cnode.h>
end_include

begin_include
include|#
directive|include
file|<fs/coda/coda_subr.h>
end_include

begin_decl_stmt
specifier|static
name|int
name|coda_active
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|coda_reuse
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|coda_new
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cnode
modifier|*
name|coda_freelist
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cnode
modifier|*
name|coda_cache
index|[
name|CODA_CACHESIZE
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CNODE_NEXT
parameter_list|(
name|cp
parameter_list|)
value|((cp)->c_next)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|CODA_COMPAT_5
end_ifdef

begin_define
define|#
directive|define
name|coda_hash
parameter_list|(
name|fid
parameter_list|)
value|(((fid)->Volume + (fid)->Vnode)& (CODA_CACHESIZE-1))
end_define

begin_define
define|#
directive|define
name|IS_DIR
parameter_list|(
name|cnode
parameter_list|)
value|(cnode.Vnode& 0x1)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|coda_hash
parameter_list|(
name|fid
parameter_list|)
value|(coda_f2i(fid)& (CODA_CACHESIZE-1))
end_define

begin_define
define|#
directive|define
name|IS_DIR
parameter_list|(
name|cnode
parameter_list|)
value|(cnode.opaque[2]& 0x1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Allocate a cnode.  */
end_comment

begin_function
name|struct
name|cnode
modifier|*
name|coda_alloc
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cnode
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|coda_freelist
operator|!=
name|NULL
condition|)
block|{
name|cp
operator|=
name|coda_freelist
expr_stmt|;
name|coda_freelist
operator|=
name|CNODE_NEXT
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|coda_reuse
operator|++
expr_stmt|;
block|}
else|else
block|{
name|CODA_ALLOC
argument_list|(
name|cp
argument_list|,
expr|struct
name|cnode
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cnode
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * FreeBSD vnodes don't have any Pager info in them ('cause 		 * there are no external pagers, duh!). 		 */
define|#
directive|define
name|VNODE_VM_INFO_INIT
parameter_list|(
name|vp
parameter_list|)
comment|/* MT */
name|VNODE_VM_INFO_INIT
argument_list|(
name|CTOV
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|coda_new
operator|++
expr_stmt|;
block|}
name|bzero
argument_list|(
name|cp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cnode
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Deallocate a cnode.  */
end_comment

begin_function
name|void
name|coda_free
parameter_list|(
name|struct
name|cnode
modifier|*
name|cp
parameter_list|)
block|{
name|CNODE_NEXT
argument_list|(
name|cp
argument_list|)
operator|=
name|coda_freelist
expr_stmt|;
name|coda_freelist
operator|=
name|cp
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Put a cnode in the hash table.  */
end_comment

begin_function
name|void
name|coda_save
parameter_list|(
name|struct
name|cnode
modifier|*
name|cp
parameter_list|)
block|{
name|CNODE_NEXT
argument_list|(
name|cp
argument_list|)
operator|=
name|coda_cache
index|[
name|coda_hash
argument_list|(
operator|&
name|cp
operator|->
name|c_fid
argument_list|)
index|]
expr_stmt|;
name|coda_cache
index|[
name|coda_hash
argument_list|(
operator|&
name|cp
operator|->
name|c_fid
argument_list|)
index|]
operator|=
name|cp
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove a cnode from the hash table.  */
end_comment

begin_function
name|void
name|coda_unsave
parameter_list|(
name|struct
name|cnode
modifier|*
name|cp
parameter_list|)
block|{
name|struct
name|cnode
modifier|*
name|ptr
decl_stmt|;
name|struct
name|cnode
modifier|*
name|ptrprev
init|=
name|NULL
decl_stmt|;
name|ptr
operator|=
name|coda_cache
index|[
name|coda_hash
argument_list|(
operator|&
name|cp
operator|->
name|c_fid
argument_list|)
index|]
expr_stmt|;
while|while
condition|(
name|ptr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ptr
operator|==
name|cp
condition|)
block|{
if|if
condition|(
name|ptrprev
operator|==
name|NULL
condition|)
name|coda_cache
index|[
name|coda_hash
argument_list|(
operator|&
name|cp
operator|->
name|c_fid
argument_list|)
index|]
operator|=
name|CNODE_NEXT
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
else|else
name|CNODE_NEXT
argument_list|(
name|ptrprev
argument_list|)
operator|=
name|CNODE_NEXT
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|CNODE_NEXT
argument_list|(
name|cp
argument_list|)
operator|=
operator|(
expr|struct
name|cnode
operator|*
operator|)
name|NULL
expr_stmt|;
return|return;
block|}
name|ptrprev
operator|=
name|ptr
expr_stmt|;
name|ptr
operator|=
name|CNODE_NEXT
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Lookup a cnode by fid. If the cnode is dying, it is bogus so skip it.  *  * NOTE: this allows multiple cnodes with same fid -- dcs 1/25/95  */
end_comment

begin_function
name|struct
name|cnode
modifier|*
name|coda_find
parameter_list|(
name|CodaFid
modifier|*
name|fid
parameter_list|)
block|{
name|struct
name|cnode
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
name|coda_cache
index|[
name|coda_hash
argument_list|(
name|fid
argument_list|)
index|]
expr_stmt|;
while|while
condition|(
name|cp
condition|)
block|{
if|if
condition|(
name|coda_fid_eq
argument_list|(
operator|&
operator|(
name|cp
operator|->
name|c_fid
operator|)
argument_list|,
name|fid
argument_list|)
operator|&&
operator|(
operator|!
name|IS_UNMOUNTING
argument_list|(
name|cp
argument_list|)
operator|)
condition|)
block|{
name|coda_active
operator|++
expr_stmt|;
return|return
operator|(
name|cp
operator|)
return|;
block|}
name|cp
operator|=
name|CNODE_NEXT
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Clear all cached access control decisions from Coda.  */
end_comment

begin_function
specifier|static
name|void
name|coda_acccache_purge
parameter_list|(
name|struct
name|mount
modifier|*
name|mnt
parameter_list|)
block|{
name|struct
name|cnode
modifier|*
name|cp
decl_stmt|;
name|int
name|hash
decl_stmt|;
for|for
control|(
name|hash
operator|=
literal|0
init|;
name|hash
operator|<
name|CODA_CACHESIZE
condition|;
name|hash
operator|++
control|)
block|{
for|for
control|(
name|cp
operator|=
name|coda_cache
index|[
name|hash
index|]
init|;
name|cp
operator|!=
name|NULL
condition|;
name|cp
operator|=
name|CNODE_NEXT
argument_list|(
name|cp
argument_list|)
control|)
block|{
if|if
condition|(
name|CTOV
argument_list|(
name|cp
argument_list|)
operator|->
name|v_mount
operator|==
name|mnt
operator|&&
name|VALID_ACCCACHE
argument_list|(
name|cp
argument_list|)
condition|)
block|{
name|CODADEBUG
argument_list|(
argument|CODA_FLUSH
argument_list|,
argument|myprintf((
literal|"acccache "
literal|"purge fid %s uid %d mode 0x%x\n"
argument|, 				    coda_f2s(&cp->c_fid), cp->c_cached_uid, 				    cp->c_cached_mode));
argument_list|)
empty_stmt|;
name|cp
operator|->
name|c_flags
operator|&=
operator|~
name|C_ACCCACHE
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * When a user loses their tokens (or other related events), we invalidate  * any cached access rights in the access cache.  In the Linux version of  * Coda, we maintain a global epoch and simply bump it to invalidate all  * cached results generated in the epoch.  For now, we walk all cnodes and  * manually invalidate just that uid in FreeBSD.  */
end_comment

begin_function
specifier|static
name|void
name|coda_acccache_purgeuser
parameter_list|(
name|struct
name|mount
modifier|*
name|mnt
parameter_list|,
name|uid_t
name|uid
parameter_list|)
block|{
name|struct
name|cnode
modifier|*
name|cp
decl_stmt|;
name|int
name|hash
decl_stmt|;
for|for
control|(
name|hash
operator|=
literal|0
init|;
name|hash
operator|<
name|CODA_CACHESIZE
condition|;
name|hash
operator|++
control|)
block|{
for|for
control|(
name|cp
operator|=
name|coda_cache
index|[
name|hash
index|]
init|;
name|cp
operator|!=
name|NULL
condition|;
name|cp
operator|=
name|CNODE_NEXT
argument_list|(
name|cp
argument_list|)
control|)
block|{
if|if
condition|(
name|CTOV
argument_list|(
name|cp
argument_list|)
operator|->
name|v_mount
operator|==
name|mnt
operator|&&
name|VALID_ACCCACHE
argument_list|(
name|cp
argument_list|)
operator|&&
operator|(
name|cp
operator|->
name|c_cached_uid
operator|==
name|uid
operator|)
condition|)
block|{
name|CODADEBUG
argument_list|(
argument|CODA_PURGEUSER
argument_list|,
argument|myprintf((
literal|"acccache purgeuser fid %s uid %d mode "
literal|"0x%x\n"
argument|, coda_f2s(&cp->c_fid), 				    cp->c_cached_uid, cp->c_cached_mode));
argument_list|)
empty_stmt|;
name|cp
operator|->
name|c_flags
operator|&=
operator|~
name|C_ACCCACHE
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * coda_kill is called as a side effect to vcopen.  To prevent any cnodes  * left around from an earlier run of a venus or warden from causing problems  * with the new instance, mark any outstanding cnodes as dying.  Future  * operations on these cnodes should fail (excepting coda_inactive of  * course!).  Since multiple venii/wardens can be running, only kill the  * cnodes for a particular entry in the coda_mnttbl. -- DCS 12/1/94  *  * XXX: I don't believe any special behavior is required with respect to the  * global namecache here, as /coda will have unmounted and hence cache_flush  * will have run...?  */
end_comment

begin_function
name|int
name|coda_kill
parameter_list|(
name|struct
name|mount
modifier|*
name|whoIam
parameter_list|,
name|enum
name|dc_status
name|dcstat
parameter_list|)
block|{
name|int
name|hash
decl_stmt|,
name|count
init|=
literal|0
decl_stmt|;
name|struct
name|cnode
modifier|*
name|cp
decl_stmt|;
comment|/*- 	 * Algorithm is as follows: 	 *     Second, flush whatever vnodes we can from the name cache. 	 * 	 *     Finally, step through whatever is left and mark them dying. 	 *        This prevents any operation at all. 	 * 	 * This is slightly overkill, but should work.  Eventually it'd be 	 * nice to only flush those entries from the namecache that reference 	 * a vnode in this vfs. 	 * 	 * XXXRW: Perhaps we no longer need to purge the name cache when 	 * using the VFS name cache, as unmount will do that. 	 */
name|cache_purgevfs
argument_list|(
name|whoIam
argument_list|)
expr_stmt|;
for|for
control|(
name|hash
operator|=
literal|0
init|;
name|hash
operator|<
name|CODA_CACHESIZE
condition|;
name|hash
operator|++
control|)
block|{
for|for
control|(
name|cp
operator|=
name|coda_cache
index|[
name|hash
index|]
init|;
name|cp
operator|!=
name|NULL
condition|;
name|cp
operator|=
name|CNODE_NEXT
argument_list|(
name|cp
argument_list|)
control|)
block|{
if|if
condition|(
name|CTOV
argument_list|(
name|cp
argument_list|)
operator|->
name|v_mount
operator|==
name|whoIam
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"coda_kill: vp %p, cp %p\n"
argument_list|,
name|CTOV
argument_list|(
name|cp
argument_list|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|count
operator|++
expr_stmt|;
name|CODADEBUG
argument_list|(
argument|CODA_FLUSH
argument_list|,
argument|myprintf((
literal|"Live cnode "
literal|"fid %s flags %d count %d\n"
argument|, 				    coda_f2s(&cp->c_fid), cp->c_flags, 				    vrefcnt(CTOV(cp))));
argument_list|)
empty_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * There are two reasons why a cnode may be in use, it may be in the name  * cache or it may be executing.  */
end_comment

begin_function
name|void
name|coda_flush
parameter_list|(
name|struct
name|coda_mntinfo
modifier|*
name|mnt
parameter_list|,
name|enum
name|dc_status
name|dcstat
parameter_list|)
block|{
name|int
name|hash
decl_stmt|;
name|struct
name|cnode
modifier|*
name|cp
decl_stmt|;
name|coda_clstat
operator|.
name|ncalls
operator|++
expr_stmt|;
name|coda_clstat
operator|.
name|reqs
index|[
name|CODA_FLUSH
index|]
operator|++
expr_stmt|;
name|coda_acccache_purge
argument_list|(
name|mnt
operator|->
name|mi_vfsp
argument_list|)
expr_stmt|;
name|cache_purgevfs
argument_list|(
name|mnt
operator|->
name|mi_vfsp
argument_list|)
expr_stmt|;
for|for
control|(
name|hash
operator|=
literal|0
init|;
name|hash
operator|<
name|CODA_CACHESIZE
condition|;
name|hash
operator|++
control|)
block|{
for|for
control|(
name|cp
operator|=
name|coda_cache
index|[
name|hash
index|]
init|;
name|cp
operator|!=
name|NULL
condition|;
name|cp
operator|=
name|CNODE_NEXT
argument_list|(
name|cp
argument_list|)
control|)
block|{
comment|/* 			 * Only files that can be executed need to be flushed 			 * from the VM. 			 * 			 * NOTE: Currently this doesn't do anything, but 			 * perhaps it should? 			 */
if|if
condition|(
operator|!
name|IS_DIR
argument_list|(
name|cp
operator|->
name|c_fid
argument_list|)
condition|)
name|coda_vmflush
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * As a debugging measure, print out any cnodes that lived through a name  * cache flush.  */
end_comment

begin_function
name|void
name|coda_testflush
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|hash
decl_stmt|;
name|struct
name|cnode
modifier|*
name|cp
decl_stmt|;
for|for
control|(
name|hash
operator|=
literal|0
init|;
name|hash
operator|<
name|CODA_CACHESIZE
condition|;
name|hash
operator|++
control|)
block|{
for|for
control|(
name|cp
operator|=
name|coda_cache
index|[
name|hash
index|]
init|;
name|cp
operator|!=
name|NULL
condition|;
name|cp
operator|=
name|CNODE_NEXT
argument_list|(
name|cp
argument_list|)
control|)
name|myprintf
argument_list|(
operator|(
literal|"Live cnode fid %s count %d\n"
operator|,
name|coda_f2s
argument_list|(
operator|&
name|cp
operator|->
name|c_fid
argument_list|)
operator|,
name|CTOV
argument_list|(
name|cp
argument_list|)
operator|->
name|v_usecount
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * First, step through all cnodes and mark them unmounting.  FreeBSD kernels  * may try to fsync them now that venus is dead, which would be a bad thing.  */
end_comment

begin_function
name|void
name|coda_unmounting
parameter_list|(
name|struct
name|mount
modifier|*
name|whoIam
parameter_list|)
block|{
name|int
name|hash
decl_stmt|;
name|struct
name|cnode
modifier|*
name|cp
decl_stmt|;
for|for
control|(
name|hash
operator|=
literal|0
init|;
name|hash
operator|<
name|CODA_CACHESIZE
condition|;
name|hash
operator|++
control|)
block|{
for|for
control|(
name|cp
operator|=
name|coda_cache
index|[
name|hash
index|]
init|;
name|cp
operator|!=
name|NULL
condition|;
name|cp
operator|=
name|CNODE_NEXT
argument_list|(
name|cp
argument_list|)
control|)
block|{
if|if
condition|(
name|CTOV
argument_list|(
name|cp
argument_list|)
operator|->
name|v_mount
operator|==
name|whoIam
condition|)
block|{
if|if
condition|(
name|cp
operator|->
name|c_flags
operator|&
operator|(
name|C_LOCKED
operator||
name|C_WANTED
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"coda_unmounting: Unlocking "
literal|"%p\n"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|->
name|c_flags
operator|&=
operator|~
operator|(
name|C_LOCKED
operator||
name|C_WANTED
operator|)
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|cp
argument_list|)
expr_stmt|;
block|}
name|cp
operator|->
name|c_flags
operator||=
name|C_UNMOUNTING
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function
name|void
name|coda_checkunmounting
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|,
modifier|*
name|nvp
decl_stmt|;
name|struct
name|cnode
modifier|*
name|cp
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|,
name|bad
init|=
literal|0
decl_stmt|;
name|MNT_ILOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|MNT_VNODE_FOREACH
argument_list|(
argument|vp
argument_list|,
argument|mp
argument_list|,
argument|nvp
argument_list|)
block|{
name|VI_LOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_iflag
operator|&
name|VI_DOOMED
condition|)
block|{
name|VI_UNLOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|cp
operator|=
name|VTOC
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|cp
operator|->
name|c_flags
operator|&
name|C_UNMOUNTING
operator|)
condition|)
block|{
name|bad
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"vp %p, cp %p missed\n"
argument_list|,
name|vp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|->
name|c_flags
operator||=
name|C_UNMOUNTING
expr_stmt|;
block|}
name|VI_UNLOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
name|MNT_IUNLOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|coda_cacheprint
parameter_list|(
name|struct
name|mount
modifier|*
name|whoIam
parameter_list|)
block|{
name|int
name|hash
decl_stmt|;
name|struct
name|cnode
modifier|*
name|cp
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|printf
argument_list|(
literal|"coda_cacheprint: coda_ctlvp %p, cp %p"
argument_list|,
name|coda_ctlvp
argument_list|,
name|VTOC
argument_list|(
name|coda_ctlvp
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|coda_nc_name(VTOC(coda_ctlvp));
endif|#
directive|endif
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|hash
operator|=
literal|0
init|;
name|hash
operator|<
name|CODA_CACHESIZE
condition|;
name|hash
operator|++
control|)
block|{
for|for
control|(
name|cp
operator|=
name|coda_cache
index|[
name|hash
index|]
init|;
name|cp
operator|!=
name|NULL
condition|;
name|cp
operator|=
name|CNODE_NEXT
argument_list|(
name|cp
argument_list|)
control|)
block|{
if|if
condition|(
name|CTOV
argument_list|(
name|cp
argument_list|)
operator|->
name|v_mount
operator|==
name|whoIam
condition|)
block|{
name|printf
argument_list|(
literal|"coda_cacheprint: vp %p, cp %p"
argument_list|,
name|CTOV
argument_list|(
name|cp
argument_list|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|coda_nc_name(cp);
endif|#
directive|endif
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
block|}
block|}
name|printf
argument_list|(
literal|"coda_cacheprint: count %d\n"
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*-  * There are 6 cases where invalidations occur.  The semantics of each is  * listed here:  *  * CODA_FLUSH     -- Flush all entries from the name cache and the cnode  *                   cache.  *  * CODA_PURGEUSER -- Flush all entries from the name cache for a specific  *                   user.   This call is a result of token expiration.  *  * The next two are the result of callbacks on a file or directory:  *  * CODA_ZAPDIR    -- Flush the attributes for the dir from its cnode.  Zap  *                   all children of this directory from the namecache.  *  * CODA_ZAPFILE   -- Flush the attributes for a file.  *  * The fifth is a result of Venus detecting an inconsistent file:  *  * CODA_PURGEFID  -- Flush the attribute for the file; if it is a dir (odd  *                   vnode), purge its children from the namecache; remove  *                   the file from the namecache.  *  * The sixth allows Venus to replace local fids with global ones during  * reintegration.  *  * CODA_REPLACE   -- Replace one CodaFid with another throughout the name  *                   cache.  */
end_comment

begin_function
name|int
name|handleDownCall
parameter_list|(
name|struct
name|coda_mntinfo
modifier|*
name|mnt
parameter_list|,
name|int
name|opcode
parameter_list|,
name|union
name|outputArgs
modifier|*
name|out
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
comment|/* 	 * Handle invalidate requests. 	 */
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
name|CODA_FLUSH
case|:
block|{
name|coda_flush
argument_list|(
name|mnt
argument_list|,
name|IS_DOWNCALL
argument_list|)
expr_stmt|;
comment|/* Print any remaining cnodes. */
name|CODADEBUG
argument_list|(
argument|CODA_FLUSH
argument_list|,
argument|coda_testflush();
argument_list|)
empty_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
case|case
name|CODA_PURGEUSER
case|:
block|{
name|coda_clstat
operator|.
name|ncalls
operator|++
expr_stmt|;
name|coda_clstat
operator|.
name|reqs
index|[
name|CODA_PURGEUSER
index|]
operator|++
expr_stmt|;
comment|/* XXX - need to prevent fsync's. */
comment|/* 		 * Purge any access cache entries for the uid. 		 */
ifdef|#
directive|ifdef
name|CODA_COMPAT_5
name|coda_acccache_purgeuser
argument_list|(
name|mnt
operator|->
name|mi_vfsp
argument_list|,
name|out
operator|->
name|coda_purgeuser
operator|.
name|cred
operator|.
name|cr_uid
argument_list|)
expr_stmt|;
else|#
directive|else
name|coda_acccache_purgeuser
argument_list|(
name|mnt
operator|->
name|mi_vfsp
argument_list|,
name|out
operator|->
name|coda_purgeuser
operator|.
name|uid
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
case|case
name|CODA_ZAPFILE
case|:
block|{
name|struct
name|cnode
modifier|*
name|cp
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|coda_clstat
operator|.
name|ncalls
operator|++
expr_stmt|;
name|coda_clstat
operator|.
name|reqs
index|[
name|CODA_ZAPFILE
index|]
operator|++
expr_stmt|;
name|cp
operator|=
name|coda_find
argument_list|(
operator|&
name|out
operator|->
name|coda_zapfile
operator|.
name|Fid
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
block|{
name|vref
argument_list|(
name|CTOV
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|cache_purge
argument_list|(
name|CTOV
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|->
name|c_flags
operator|&=
operator|~
operator|(
name|C_VATTR
operator||
name|C_ACCCACHE
operator|)
expr_stmt|;
name|ASSERT_VOP_LOCKED
argument_list|(
name|CTOV
argument_list|(
name|cp
argument_list|)
argument_list|,
literal|"coda HandleDownCall"
argument_list|)
expr_stmt|;
if|if
condition|(
name|CTOV
argument_list|(
name|cp
argument_list|)
operator|->
name|v_vflag
operator|&
name|VV_TEXT
condition|)
name|error
operator|=
name|coda_vmflush
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|CODADEBUG
argument_list|(
argument|CODA_ZAPFILE
argument_list|,
argument|myprintf((
literal|"zapfile: fid = %s, refcnt = %d, error = "
literal|"%d\n"
argument|, coda_f2s(&cp->c_fid), 			    CTOV(cp)->v_usecount -
literal|1
argument|, error));
argument_list|)
empty_stmt|;
if|if
condition|(
name|vrefcnt
argument_list|(
name|CTOV
argument_list|(
name|cp
argument_list|)
argument_list|)
operator|==
literal|1
condition|)
name|cp
operator|->
name|c_flags
operator||=
name|C_PURGING
expr_stmt|;
name|vrele
argument_list|(
name|CTOV
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
case|case
name|CODA_ZAPDIR
case|:
block|{
name|struct
name|cnode
modifier|*
name|cp
decl_stmt|;
name|coda_clstat
operator|.
name|ncalls
operator|++
expr_stmt|;
name|coda_clstat
operator|.
name|reqs
index|[
name|CODA_ZAPDIR
index|]
operator|++
expr_stmt|;
name|cp
operator|=
name|coda_find
argument_list|(
operator|&
name|out
operator|->
name|coda_zapdir
operator|.
name|Fid
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
block|{
name|vref
argument_list|(
name|CTOV
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|cache_purge
argument_list|(
name|CTOV
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|->
name|c_flags
operator|&=
operator|~
operator|(
name|C_VATTR
operator||
name|C_ACCCACHE
operator|)
expr_stmt|;
name|CODADEBUG
argument_list|(
argument|CODA_ZAPDIR
argument_list|,
argument|myprintf((
literal|"zapdir: fid = %s, "
literal|"refcnt = %d\n"
argument|, coda_f2s(&cp->c_fid), 			    CTOV(cp)->v_usecount -
literal|1
argument|));
argument_list|)
empty_stmt|;
if|if
condition|(
name|vrefcnt
argument_list|(
name|CTOV
argument_list|(
name|cp
argument_list|)
argument_list|)
operator|==
literal|1
condition|)
name|cp
operator|->
name|c_flags
operator||=
name|C_PURGING
expr_stmt|;
name|vrele
argument_list|(
name|CTOV
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
case|case
name|CODA_PURGEFID
case|:
block|{
name|struct
name|cnode
modifier|*
name|cp
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|coda_clstat
operator|.
name|ncalls
operator|++
expr_stmt|;
name|coda_clstat
operator|.
name|reqs
index|[
name|CODA_PURGEFID
index|]
operator|++
expr_stmt|;
name|cp
operator|=
name|coda_find
argument_list|(
operator|&
name|out
operator|->
name|coda_purgefid
operator|.
name|Fid
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
block|{
name|vref
argument_list|(
name|CTOV
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|cache_purge
argument_list|(
name|CTOV
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|->
name|c_flags
operator|&=
operator|~
operator|(
name|C_VATTR
operator||
name|C_ACCCACHE
operator|)
expr_stmt|;
name|ASSERT_VOP_LOCKED
argument_list|(
name|CTOV
argument_list|(
name|cp
argument_list|)
argument_list|,
literal|"coda HandleDownCall"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|IS_DIR
argument_list|(
name|out
operator|->
name|coda_purgefid
operator|.
name|Fid
argument_list|)
operator|)
operator|&&
operator|(
name|CTOV
argument_list|(
name|cp
argument_list|)
operator|->
name|v_vflag
operator|&
name|VV_TEXT
operator|)
condition|)
name|error
operator|=
name|coda_vmflush
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|CODADEBUG
argument_list|(
argument|CODA_PURGEFID
argument_list|,
argument|myprintf((
literal|"purgefid: fid "
literal|"= %s, refcnt = %d, error = %d\n"
argument|, 			    coda_f2s(&cp->c_fid), 			    CTOV(cp)->v_usecount -
literal|1
argument|, error));
argument_list|)
empty_stmt|;
if|if
condition|(
name|vrefcnt
argument_list|(
name|CTOV
argument_list|(
name|cp
argument_list|)
argument_list|)
operator|==
literal|1
condition|)
name|cp
operator|->
name|c_flags
operator||=
name|C_PURGING
expr_stmt|;
name|vrele
argument_list|(
name|CTOV
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
case|case
name|CODA_REPLACE
case|:
block|{
name|struct
name|cnode
modifier|*
name|cp
init|=
name|NULL
decl_stmt|;
name|coda_clstat
operator|.
name|ncalls
operator|++
expr_stmt|;
name|coda_clstat
operator|.
name|reqs
index|[
name|CODA_REPLACE
index|]
operator|++
expr_stmt|;
name|cp
operator|=
name|coda_find
argument_list|(
operator|&
name|out
operator|->
name|coda_replace
operator|.
name|OldFid
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * Remove the cnode from the hash table, replace the 			 * fid, and reinsert. 			 */
name|vref
argument_list|(
name|CTOV
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|coda_unsave
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|->
name|c_fid
operator|=
name|out
operator|->
name|coda_replace
operator|.
name|NewFid
expr_stmt|;
name|coda_save
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|CODADEBUG
argument_list|(
argument|CODA_REPLACE
argument_list|,
argument|myprintf((
literal|"replace: oldfid "
literal|"= %s, newfid = %s, cp = %p\n"
argument|, 			    coda_f2s(&out->coda_replace.OldFid), 			    coda_f2s(&cp->c_fid), cp));
argument_list|)
empty_stmt|;
name|vrele
argument_list|(
name|CTOV
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
default|default:
name|myprintf
argument_list|(
operator|(
literal|"handleDownCall: unknown opcode %d\n"
operator|,
name|opcode
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
end_function

begin_function
name|int
name|coda_vmflush
parameter_list|(
name|struct
name|cnode
modifier|*
name|cp
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Kernel-internal debugging switches.  */
end_comment

begin_function
name|void
name|coda_debugon
parameter_list|(
name|void
parameter_list|)
block|{
name|codadebug
operator|=
operator|-
literal|1
expr_stmt|;
name|coda_vnop_print_entry
operator|=
literal|1
expr_stmt|;
name|coda_psdev_print_entry
operator|=
literal|1
expr_stmt|;
name|coda_vfsop_print_entry
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|coda_debugoff
parameter_list|(
name|void
parameter_list|)
block|{
name|codadebug
operator|=
literal|0
expr_stmt|;
name|coda_vnop_print_entry
operator|=
literal|0
expr_stmt|;
name|coda_psdev_print_entry
operator|=
literal|0
expr_stmt|;
name|coda_vfsop_print_entry
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  * Utilities used by both client and server  * Standard levels:  * 0) no debugging  * 1) hard failures  * 2) soft failures  * 3) current test software  * 4) main procedure entry points  * 5) main procedure exit points  * 6) utility procedure entry points  * 7) utility procedure exit points  * 8) obscure procedure entry points  * 9) obscure procedure exit points  * 10) random stuff  * 11) all<= 1  * 12) all<= 2  * 13) all<= 3  * ...  */
end_comment

end_unit

