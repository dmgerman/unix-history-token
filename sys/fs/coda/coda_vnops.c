begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *   *             Coda: an Experimental Distributed File System  *                              Release 3.1  *   *           Copyright (c) 1987-1998 Carnegie Mellon University  *                          All Rights Reserved  *   * Permission  to  use, copy, modify and distribute this software and its  * documentation is hereby granted,  provided  that  both  the  copyright  * notice  and  this  permission  notice  appear  in  all  copies  of the  * software, derivative works or  modified  versions,  and  any  portions  * thereof, and that both notices appear in supporting documentation, and  * that credit is given to Carnegie Mellon University  in  all  documents  * and publicity pertaining to direct or indirect use of this code or its  * derivatives.  *   * CODA IS AN EXPERIMENTAL SOFTWARE SYSTEM AND IS  KNOWN  TO  HAVE  BUGS,  * SOME  OF  WHICH MAY HAVE SERIOUS CONSEQUENCES.  CARNEGIE MELLON ALLOWS  * FREE USE OF THIS SOFTWARE IN ITS "AS IS" CONDITION.   CARNEGIE  MELLON  * DISCLAIMS  ANY  LIABILITY  OF  ANY  KIND  FOR  ANY  DAMAGES WHATSOEVER  * RESULTING DIRECTLY OR INDIRECTLY FROM THE USE OF THIS SOFTWARE  OR  OF  * ANY DERIVATIVE WORK.  *   * Carnegie  Mellon  encourages  users  of  this  software  to return any  * improvements or extensions that  they  make,  and  to  grant  Carnegie  * Mellon the rights to redistribute these changes without encumbrance.  *   *  	@(#) src/sys/coda/coda_vnops.c,v 1.1.1.1 1998/08/29 21:14:52 rvb Exp $  * $FreeBSD$  *   */
end_comment

begin_comment
comment|/*   * Mach Operating System  * Copyright (c) 1990 Carnegie-Mellon University  * Copyright (c) 1989 Carnegie-Mellon University  * All rights reserved.  The CMU software License Agreement specifies  * the terms and conditions for use and redistribution.  */
end_comment

begin_comment
comment|/*  * This code was written for the Coda file system at Carnegie Mellon  * University.  Contributers include David Steere, James Kistler, and  * M. Satyanarayanan.    */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/acct.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_comment
comment|/* Must come after sys/malloc.h */
end_comment

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<coda/coda.h>
end_include

begin_include
include|#
directive|include
file|<coda/cnode.h>
end_include

begin_include
include|#
directive|include
file|<coda/coda_vnops.h>
end_include

begin_include
include|#
directive|include
file|<coda/coda_venus.h>
end_include

begin_include
include|#
directive|include
file|<coda/coda_opstats.h>
end_include

begin_include
include|#
directive|include
file|<coda/coda_subr.h>
end_include

begin_include
include|#
directive|include
file|<coda/coda_namecache.h>
end_include

begin_include
include|#
directive|include
file|<coda/coda_pioctl.h>
end_include

begin_comment
comment|/*   * These flags select various performance enhancements.  */
end_comment

begin_decl_stmt
name|int
name|coda_attr_cache
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to cache attributes in the kernel */
end_comment

begin_decl_stmt
name|int
name|coda_symlink_cache
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to cache symbolic link information */
end_comment

begin_decl_stmt
name|int
name|coda_access_cache
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to handle some access checks directly */
end_comment

begin_comment
comment|/* structure to keep track of vfs calls */
end_comment

begin_decl_stmt
name|struct
name|coda_op_stats
name|coda_vnodeopstats
index|[
name|CODA_VNODEOPS_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MARK_ENTRY
parameter_list|(
name|op
parameter_list|)
value|(coda_vnodeopstats[op].entries++)
end_define

begin_define
define|#
directive|define
name|MARK_INT_SAT
parameter_list|(
name|op
parameter_list|)
value|(coda_vnodeopstats[op].sat_intrn++)
end_define

begin_define
define|#
directive|define
name|MARK_INT_FAIL
parameter_list|(
name|op
parameter_list|)
value|(coda_vnodeopstats[op].unsat_intrn++)
end_define

begin_define
define|#
directive|define
name|MARK_INT_GEN
parameter_list|(
name|op
parameter_list|)
value|(coda_vnodeopstats[op].gen_intrn++)
end_define

begin_comment
comment|/* What we are delaying for in printf */
end_comment

begin_decl_stmt
name|int
name|coda_printf_delay
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* in microseconds */
end_comment

begin_decl_stmt
name|int
name|coda_vnop_print_entry
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|coda_lockdebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Definition of the vfs operation vector */
end_comment

begin_comment
comment|/*  * Some NetBSD details:  *   *   coda_start is called at the end of the mount syscall.  *   coda_init is called at boot time.  */
end_comment

begin_define
define|#
directive|define
name|ENTRY
value|if(coda_vnop_print_entry) myprintf(("Entered %s\n",__FUNCTION__))
end_define

begin_comment
comment|/* Definition of the vnode operation vector */
end_comment

begin_decl_stmt
name|struct
name|vnodeopv_entry_desc
name|coda_vnodeop_entries
index|[]
init|=
block|{
block|{
operator|&
name|vop_default_desc
block|,
name|coda_vop_error
block|}
block|,
block|{
operator|&
name|vop_lookup_desc
block|,
name|coda_lookup
block|}
block|,
comment|/* lookup */
block|{
operator|&
name|vop_create_desc
block|,
name|coda_create
block|}
block|,
comment|/* create */
block|{
operator|&
name|vop_mknod_desc
block|,
name|coda_vop_error
block|}
block|,
comment|/* mknod */
block|{
operator|&
name|vop_open_desc
block|,
name|coda_open
block|}
block|,
comment|/* open */
block|{
operator|&
name|vop_close_desc
block|,
name|coda_close
block|}
block|,
comment|/* close */
block|{
operator|&
name|vop_access_desc
block|,
name|coda_access
block|}
block|,
comment|/* access */
block|{
operator|&
name|vop_getattr_desc
block|,
name|coda_getattr
block|}
block|,
comment|/* getattr */
block|{
operator|&
name|vop_setattr_desc
block|,
name|coda_setattr
block|}
block|,
comment|/* setattr */
block|{
operator|&
name|vop_read_desc
block|,
name|coda_read
block|}
block|,
comment|/* read */
block|{
operator|&
name|vop_write_desc
block|,
name|coda_write
block|}
block|,
comment|/* write */
block|{
operator|&
name|vop_ioctl_desc
block|,
name|coda_ioctl
block|}
block|,
comment|/* ioctl */
block|{
operator|&
name|vop_fsync_desc
block|,
name|coda_fsync
block|}
block|,
comment|/* fsync */
block|{
operator|&
name|vop_remove_desc
block|,
name|coda_remove
block|}
block|,
comment|/* remove */
block|{
operator|&
name|vop_link_desc
block|,
name|coda_link
block|}
block|,
comment|/* link */
block|{
operator|&
name|vop_rename_desc
block|,
name|coda_rename
block|}
block|,
comment|/* rename */
block|{
operator|&
name|vop_mkdir_desc
block|,
name|coda_mkdir
block|}
block|,
comment|/* mkdir */
block|{
operator|&
name|vop_rmdir_desc
block|,
name|coda_rmdir
block|}
block|,
comment|/* rmdir */
block|{
operator|&
name|vop_symlink_desc
block|,
name|coda_symlink
block|}
block|,
comment|/* symlink */
block|{
operator|&
name|vop_readdir_desc
block|,
name|coda_readdir
block|}
block|,
comment|/* readdir */
block|{
operator|&
name|vop_readlink_desc
block|,
name|coda_readlink
block|}
block|,
comment|/* readlink */
block|{
operator|&
name|vop_inactive_desc
block|,
name|coda_inactive
block|}
block|,
comment|/* inactive */
block|{
operator|&
name|vop_reclaim_desc
block|,
name|coda_reclaim
block|}
block|,
comment|/* reclaim */
block|{
operator|&
name|vop_lock_desc
block|,
name|coda_lock
block|}
block|,
comment|/* lock */
block|{
operator|&
name|vop_unlock_desc
block|,
name|coda_unlock
block|}
block|,
comment|/* unlock */
block|{
operator|&
name|vop_bmap_desc
block|,
name|coda_bmap
block|}
block|,
comment|/* bmap */
block|{
operator|&
name|vop_strategy_desc
block|,
name|coda_strategy
block|}
block|,
comment|/* strategy */
block|{
operator|&
name|vop_print_desc
block|,
name|coda_vop_error
block|}
block|,
comment|/* print */
block|{
operator|&
name|vop_islocked_desc
block|,
name|coda_islocked
block|}
block|,
comment|/* islocked */
block|{
operator|&
name|vop_pathconf_desc
block|,
name|coda_vop_error
block|}
block|,
comment|/* pathconf */
block|{
operator|&
name|vop_advlock_desc
block|,
name|coda_vop_nop
block|}
block|,
comment|/* advlock */
block|{
operator|&
name|vop_lease_desc
block|,
name|coda_vop_nop
block|}
block|,
comment|/* lease */
block|{
operator|&
name|vop_poll_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|vop_stdpoll
block|}
block|,
block|{
operator|&
name|vop_getpages_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|vop_stdgetpages
block|}
block|,
comment|/* pager intf.*/
block|{
operator|&
name|vop_putpages_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|vop_stdputpages
block|}
block|,
comment|/* pager intf.*/
block|{
operator|&
name|vop_createvobject_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|vop_stdcreatevobject
block|}
block|,
block|{
operator|&
name|vop_destroyvobject_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|vop_stddestroyvobject
block|}
block|,
block|{
operator|&
name|vop_getvobject_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|vop_stdgetvobject
block|}
block|,
if|#
directive|if
literal|0
block|we need to define these someday
define|#
directive|define
name|UFS_BLKATOFF
parameter_list|(
name|aa
parameter_list|,
name|bb
parameter_list|,
name|cc
parameter_list|,
name|dd
parameter_list|)
value|VFSTOUFS((aa)->v_mount)->um_blkatoff(aa, bb, cc, dd)
define|#
directive|define
name|UFS_VALLOC
parameter_list|(
name|aa
parameter_list|,
name|bb
parameter_list|,
name|cc
parameter_list|,
name|dd
parameter_list|)
value|VFSTOUFS((aa)->v_mount)->um_valloc(aa, bb, cc, dd)
define|#
directive|define
name|UFS_VFREE
parameter_list|(
name|aa
parameter_list|,
name|bb
parameter_list|,
name|cc
parameter_list|)
value|VFSTOUFS((aa)->v_mount)->um_vfree(aa, bb, cc)
define|#
directive|define
name|UFS_TRUNCATE
parameter_list|(
name|aa
parameter_list|,
name|bb
parameter_list|,
name|cc
parameter_list|,
name|dd
parameter_list|,
name|ee
parameter_list|)
value|VFSTOUFS((aa)->v_mount)->um_truncate(aa, bb, cc, dd, ee)
define|#
directive|define
name|UFS_UPDATE
parameter_list|(
name|aa
parameter_list|,
name|bb
parameter_list|)
value|VFSTOUFS((aa)->v_mount)->um_update(aa, bb)
block|missing     {&vop_reallocblks_desc,	(vop_t *) ufs_missingop },     {&vop_cachedlookup_desc,	(vop_t *) ufs_lookup },     {&vop_whiteout_desc,	(vop_t *) ufs_whiteout },
endif|#
directive|endif
block|{
operator|&
name|vop_createvobject_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|vop_stdcreatevobject
block|}
block|,
block|{
operator|&
name|vop_destroyvobject_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|vop_stddestroyvobject
block|}
block|,
block|{
operator|&
name|vop_getvobject_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|vop_stdgetvobject
block|}
block|,
block|{
operator|&
name|vop_getwritemount_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|vop_stdgetwritemount
block|}
block|,
block|{
operator|(
expr|struct
name|vnodeop_desc
operator|*
operator|)
name|NULL
block|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|)
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|vnodeopv_desc
name|coda_vnodeop_opv_desc
init|=
block|{
operator|&
name|coda_vnodeop_p
block|,
name|coda_vnodeop_entries
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|VNODEOP_SET
argument_list|(
name|coda_vnodeop_opv_desc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* A generic panic: we were called with something we didn't define yet */
end_comment

begin_function
name|int
name|coda_vop_error
parameter_list|(
name|void
modifier|*
name|anon
parameter_list|)
block|{
name|struct
name|vnodeop_desc
modifier|*
modifier|*
name|desc
init|=
operator|(
expr|struct
name|vnodeop_desc
operator|*
operator|*
operator|)
name|anon
decl_stmt|;
name|myprintf
argument_list|(
operator|(
literal|"coda_vop_error: Vnode operation %s called, but not defined.\n"
operator|,
operator|(
operator|*
name|desc
operator|)
operator|->
name|vdesc_name
operator|)
argument_list|)
expr_stmt|;
comment|/*     panic("coda_vop_error");     */
return|return
name|EIO
return|;
block|}
end_function

begin_comment
comment|/* A generic do-nothing.  For lease_check, advlock */
end_comment

begin_function
name|int
name|coda_vop_nop
parameter_list|(
name|void
modifier|*
name|anon
parameter_list|)
block|{
name|struct
name|vnodeop_desc
modifier|*
modifier|*
name|desc
init|=
operator|(
expr|struct
name|vnodeop_desc
operator|*
operator|*
operator|)
name|anon
decl_stmt|;
if|if
condition|(
name|codadebug
condition|)
block|{
name|myprintf
argument_list|(
operator|(
literal|"Vnode operation %s called, but unsupported\n"
operator|,
operator|(
operator|*
name|desc
operator|)
operator|->
name|vdesc_name
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|coda_vnodeopstats_init
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CODA_VNODEOPS_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|coda_vnodeopstats
index|[
name|i
index|]
operator|.
name|opcode
operator|=
name|i
expr_stmt|;
name|coda_vnodeopstats
index|[
name|i
index|]
operator|.
name|entries
operator|=
literal|0
expr_stmt|;
name|coda_vnodeopstats
index|[
name|i
index|]
operator|.
name|sat_intrn
operator|=
literal|0
expr_stmt|;
name|coda_vnodeopstats
index|[
name|i
index|]
operator|.
name|unsat_intrn
operator|=
literal|0
expr_stmt|;
name|coda_vnodeopstats
index|[
name|i
index|]
operator|.
name|gen_intrn
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*   * coda_open calls Venus to return the device, inode pair of the cache  * file holding the data. Using iget, coda_open finds the vnode of the  * cache file, and then opens it.  */
end_comment

begin_function
name|int
name|coda_open
parameter_list|(
name|v
parameter_list|)
name|void
modifier|*
name|v
decl_stmt|;
block|{
comment|/*       * NetBSD can pass the O_EXCL flag in mode, even though the check      * has already happened.  Venus defensively assumes that if open      * is passed the EXCL, it must be a bug.  We strip the flag here.      */
comment|/* true args */
name|struct
name|vop_open_args
modifier|*
name|ap
init|=
name|v
decl_stmt|;
specifier|register
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
init|=
operator|&
operator|(
name|ap
operator|->
name|a_vp
operator|)
decl_stmt|;
name|struct
name|cnode
modifier|*
name|cp
init|=
name|VTOC
argument_list|(
operator|*
name|vpp
argument_list|)
decl_stmt|;
name|int
name|flag
init|=
name|ap
operator|->
name|a_mode
operator|&
operator|(
operator|~
name|O_EXCL
operator|)
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|ap
operator|->
name|a_cred
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|ap
operator|->
name|a_td
decl_stmt|;
comment|/* locals */
name|int
name|error
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|dev_t
name|dev
decl_stmt|;
name|ino_t
name|inode
decl_stmt|;
name|MARK_ENTRY
argument_list|(
name|CODA_OPEN_STATS
argument_list|)
expr_stmt|;
comment|/* Check for open of control file. */
if|if
condition|(
name|IS_CTL_VP
argument_list|(
operator|*
name|vpp
argument_list|)
condition|)
block|{
comment|/* XXX */
comment|/* if (WRITEABLE(flag)) */
if|if
condition|(
name|flag
operator|&
operator|(
name|FWRITE
operator||
name|O_TRUNC
operator||
name|O_CREAT
operator||
name|O_EXCL
operator|)
condition|)
block|{
name|MARK_INT_FAIL
argument_list|(
name|CODA_OPEN_STATS
argument_list|)
expr_stmt|;
return|return
operator|(
name|EACCES
operator|)
return|;
block|}
name|MARK_INT_SAT
argument_list|(
name|CODA_OPEN_STATS
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|error
operator|=
name|venus_open
argument_list|(
name|vtomi
argument_list|(
operator|(
operator|*
name|vpp
operator|)
argument_list|)
argument_list|,
operator|&
name|cp
operator|->
name|c_fid
argument_list|,
name|flag
argument_list|,
name|cred
argument_list|,
name|td
operator|->
name|td_proc
argument_list|,
operator|&
name|dev
argument_list|,
operator|&
name|inode
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|CODADEBUG
argument_list|(
argument|CODA_OPEN
argument_list|,
argument|myprintf((
literal|"open: dev %#lx inode %lu result %d\n"
argument|, 				       (u_long)dev2udev(dev), (u_long)inode, 				       error));
argument_list|)
block|}
comment|/* Translate the<device, inode> pair for the cache file into        an inode pointer. */
name|error
operator|=
name|coda_grab_vnode
argument_list|(
name|dev
argument_list|,
name|inode
argument_list|,
operator|&
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* We get the vnode back locked.  Needs unlocked */
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
comment|/* Keep a reference until the close comes in. */
name|vref
argument_list|(
operator|*
name|vpp
argument_list|)
expr_stmt|;
comment|/* Save the vnode pointer for the cache file. */
if|if
condition|(
name|cp
operator|->
name|c_ovp
operator|==
name|NULL
condition|)
block|{
name|cp
operator|->
name|c_ovp
operator|=
name|vp
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cp
operator|->
name|c_ovp
operator|!=
name|vp
condition|)
name|panic
argument_list|(
literal|"coda_open:  cp->c_ovp != ITOV(ip)"
argument_list|)
expr_stmt|;
block|}
name|cp
operator|->
name|c_ocount
operator|++
expr_stmt|;
comment|/* Flush the attribute cached if writing the file. */
if|if
condition|(
name|flag
operator|&
name|FWRITE
condition|)
block|{
name|cp
operator|->
name|c_owrite
operator|++
expr_stmt|;
name|cp
operator|->
name|c_flags
operator|&=
operator|~
name|C_VATTR
expr_stmt|;
block|}
comment|/* Save the<device, inode> pair for the cache file to speed        up subsequent page_read's. */
name|cp
operator|->
name|c_device
operator|=
name|dev
expr_stmt|;
name|cp
operator|->
name|c_inode
operator|=
name|inode
expr_stmt|;
comment|/* Open the cache file. */
name|error
operator|=
name|VOP_OPEN
argument_list|(
name|vp
argument_list|,
name|flag
argument_list|,
name|cred
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"coda_open: VOP_OPEN on container failed %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* grab (above) does this when it calls newvnode unless it's in the cache*/
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VREG
condition|)
block|{
name|error
operator|=
name|vfs_object_create
argument_list|(
name|vp
argument_list|,
name|td
argument_list|,
name|cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"coda_open: vfs_object_create() returns %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Close the cache file used for I/O and notify Venus.  */
end_comment

begin_function
name|int
name|coda_close
parameter_list|(
name|v
parameter_list|)
name|void
modifier|*
name|v
decl_stmt|;
block|{
comment|/* true args */
name|struct
name|vop_close_args
modifier|*
name|ap
init|=
name|v
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|cnode
modifier|*
name|cp
init|=
name|VTOC
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|int
name|flag
init|=
name|ap
operator|->
name|a_fflag
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|ap
operator|->
name|a_cred
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|ap
operator|->
name|a_td
decl_stmt|;
comment|/* locals */
name|int
name|error
decl_stmt|;
name|MARK_ENTRY
argument_list|(
name|CODA_CLOSE_STATS
argument_list|)
expr_stmt|;
comment|/* Check for close of control file. */
if|if
condition|(
name|IS_CTL_VP
argument_list|(
name|vp
argument_list|)
condition|)
block|{
name|MARK_INT_SAT
argument_list|(
name|CODA_CLOSE_STATS
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|IS_UNMOUNTING
argument_list|(
name|cp
argument_list|)
condition|)
block|{
if|if
condition|(
name|cp
operator|->
name|c_ovp
condition|)
block|{
ifdef|#
directive|ifdef
name|CODA_VERBOSE
name|printf
argument_list|(
literal|"coda_close: destroying container ref %d, ufs vp %p of vp %p/cp %p\n"
argument_list|,
name|vp
operator|->
name|v_usecount
argument_list|,
name|cp
operator|->
name|c_ovp
argument_list|,
name|vp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|hmm
name|vgone
argument_list|(
name|cp
operator|->
name|c_ovp
argument_list|)
expr_stmt|;
else|#
directive|else
name|VOP_CLOSE
argument_list|(
name|cp
operator|->
name|c_ovp
argument_list|,
name|flag
argument_list|,
name|cred
argument_list|,
name|td
argument_list|)
expr_stmt|;
comment|/* Do errors matter here? */
name|vrele
argument_list|(
name|cp
operator|->
name|c_ovp
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|CODA_VERBOSE
name|printf
argument_list|(
literal|"coda_close: NO container vp %p/cp %p\n"
argument_list|,
name|vp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
name|ENODEV
return|;
block|}
else|else
block|{
name|VOP_CLOSE
argument_list|(
name|cp
operator|->
name|c_ovp
argument_list|,
name|flag
argument_list|,
name|cred
argument_list|,
name|td
argument_list|)
expr_stmt|;
comment|/* Do errors matter here? */
name|vrele
argument_list|(
name|cp
operator|->
name|c_ovp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|--
name|cp
operator|->
name|c_ocount
operator|==
literal|0
condition|)
name|cp
operator|->
name|c_ovp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|flag
operator|&
name|FWRITE
condition|)
comment|/* file was opened for write */
operator|--
name|cp
operator|->
name|c_owrite
expr_stmt|;
name|error
operator|=
name|venus_close
argument_list|(
name|vtomi
argument_list|(
name|vp
argument_list|)
argument_list|,
operator|&
name|cp
operator|->
name|c_fid
argument_list|,
name|flag
argument_list|,
name|cred
argument_list|,
name|td
operator|->
name|td_proc
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|CTOV
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|CODADEBUG
argument_list|(
argument|CODA_CLOSE
argument_list|,
argument|myprintf((
literal|"close: result %d\n"
argument|,error));
argument_list|)
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|coda_read
parameter_list|(
name|v
parameter_list|)
name|void
modifier|*
name|v
decl_stmt|;
block|{
name|struct
name|vop_read_args
modifier|*
name|ap
init|=
name|v
decl_stmt|;
name|ENTRY
expr_stmt|;
return|return
operator|(
name|coda_rdwr
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|ap
operator|->
name|a_uio
argument_list|,
name|UIO_READ
argument_list|,
name|ap
operator|->
name|a_ioflag
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_uio
operator|->
name|uio_td
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|coda_write
parameter_list|(
name|v
parameter_list|)
name|void
modifier|*
name|v
decl_stmt|;
block|{
name|struct
name|vop_write_args
modifier|*
name|ap
init|=
name|v
decl_stmt|;
name|ENTRY
expr_stmt|;
return|return
operator|(
name|coda_rdwr
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|ap
operator|->
name|a_uio
argument_list|,
name|UIO_WRITE
argument_list|,
name|ap
operator|->
name|a_ioflag
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_uio
operator|->
name|uio_td
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|coda_rdwr
parameter_list|(
name|vp
parameter_list|,
name|uiop
parameter_list|,
name|rw
parameter_list|,
name|ioflag
parameter_list|,
name|cred
parameter_list|,
name|td
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|uio
modifier|*
name|uiop
decl_stmt|;
name|enum
name|uio_rw
name|rw
decl_stmt|;
name|int
name|ioflag
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
block|{
comment|/* upcall decl */
comment|/* NOTE: container file operation!!! */
comment|/* locals */
name|struct
name|cnode
modifier|*
name|cp
init|=
name|VTOC
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|vnode
modifier|*
name|cfvp
init|=
name|cp
operator|->
name|c_ovp
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|struct
name|thread
modifier|*
name|ltd
init|=
name|td
decl_stmt|;
name|int
name|igot_internally
init|=
literal|0
decl_stmt|;
name|int
name|opened_internally
init|=
literal|0
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|iscore
init|=
literal|0
decl_stmt|;
name|MARK_ENTRY
argument_list|(
name|CODA_RDWR_STATS
argument_list|)
expr_stmt|;
name|CODADEBUG
argument_list|(
argument|CODA_RDWR
argument_list|,
argument|myprintf((
literal|"coda_rdwr(%d, %p, %d, %lld, %d)\n"
argument|, rw,  			      (void *)uiop->uio_iov->iov_base, uiop->uio_resid,  			      (long long)uiop->uio_offset, uiop->uio_segflg));
argument_list|)
comment|/* Check for rdwr of control object. */
if|if
condition|(
name|IS_CTL_VP
argument_list|(
name|vp
argument_list|)
condition|)
block|{
name|MARK_INT_FAIL
argument_list|(
name|CODA_RDWR_STATS
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/*       * If file is not already open this must be a page      * {read,write} request.  Iget the cache file's inode      * pointer if we still have its<device, inode> pair.      * Otherwise, we must do an internal open to derive the      * pair.       */
if|if
condition|(
name|cfvp
operator|==
name|NULL
condition|)
block|{
comment|/*  	 * If we're dumping core, do the internal open. Otherwise 	 * venus won't have the correct size of the core when 	 * it's completely written. 	 */
if|if
condition|(
name|p
condition|)
block|{
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|iscore
operator|=
operator|(
name|p
operator|->
name|p_acflag
operator|&
name|ACORE
operator|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
name|ltd
operator|=
name|curthread
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|c_inode
operator|!=
literal|0
operator|&&
operator|!
name|iscore
condition|)
block|{
name|igot_internally
operator|=
literal|1
expr_stmt|;
name|error
operator|=
name|coda_grab_vnode
argument_list|(
name|cp
operator|->
name|c_device
argument_list|,
name|cp
operator|->
name|c_inode
argument_list|,
operator|&
name|cfvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|MARK_INT_FAIL
argument_list|(
name|CODA_RDWR_STATS
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/*  	     * We get the vnode back locked by curthread in both Mach and 	     * NetBSD.  Needs unlocked  	     */
name|VOP_UNLOCK
argument_list|(
name|cfvp
argument_list|,
literal|0
argument_list|,
name|ltd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|opened_internally
operator|=
literal|1
expr_stmt|;
name|MARK_INT_GEN
argument_list|(
name|CODA_OPEN_STATS
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_OPEN
argument_list|(
name|vp
argument_list|,
operator|(
name|rw
operator|==
name|UIO_READ
condition|?
name|FREAD
else|:
name|FWRITE
operator|)
argument_list|,
name|cred
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"coda_rdwr: Internally Opening %p\n"
argument_list|,
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"coda_rdwr: VOP_OPEN on container failed %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VREG
condition|)
block|{
name|error
operator|=
name|vfs_object_create
argument_list|(
name|vp
argument_list|,
name|td
argument_list|,
name|cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"coda_rdwr: vfs_object_create() returns %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error
condition|)
block|{
name|MARK_INT_FAIL
argument_list|(
name|CODA_RDWR_STATS
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|cfvp
operator|=
name|cp
operator|->
name|c_ovp
expr_stmt|;
block|}
block|}
comment|/* Have UFS handle the call. */
name|CODADEBUG
argument_list|(
argument|CODA_RDWR
argument_list|,
argument|myprintf((
literal|"indirect rdwr: fid = (%lx.%lx.%lx), refcnt = %d\n"
argument|, 			      cp->c_fid.Volume, cp->c_fid.Vnode,  			      cp->c_fid.Unique, CTOV(cp)->v_usecount));
argument_list|)
if|if
condition|(
name|rw
operator|==
name|UIO_READ
condition|)
block|{
name|error
operator|=
name|VOP_READ
argument_list|(
name|cfvp
argument_list|,
name|uiop
argument_list|,
name|ioflag
argument_list|,
name|cred
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|VOP_WRITE
argument_list|(
name|cfvp
argument_list|,
name|uiop
argument_list|,
name|ioflag
argument_list|,
name|cred
argument_list|)
expr_stmt|;
comment|/* ufs_write updates the vnode_pager_setsize for the vnode/object */
block|{
name|struct
name|vattr
name|attr
decl_stmt|;
if|if
condition|(
name|VOP_GETATTR
argument_list|(
name|cfvp
argument_list|,
operator|&
name|attr
argument_list|,
name|cred
argument_list|,
name|td
argument_list|)
operator|==
literal|0
condition|)
block|{
name|vnode_pager_setsize
argument_list|(
name|vp
argument_list|,
name|attr
operator|.
name|va_size
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|error
condition|)
name|MARK_INT_FAIL
argument_list|(
name|CODA_RDWR_STATS
argument_list|)
expr_stmt|;
else|else
name|MARK_INT_SAT
argument_list|(
name|CODA_RDWR_STATS
argument_list|)
expr_stmt|;
comment|/* Do an internal close if necessary. */
if|if
condition|(
name|opened_internally
condition|)
block|{
name|MARK_INT_GEN
argument_list|(
name|CODA_CLOSE_STATS
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|VOP_CLOSE
argument_list|(
name|vp
argument_list|,
operator|(
name|rw
operator|==
name|UIO_READ
condition|?
name|FREAD
else|:
name|FWRITE
operator|)
argument_list|,
name|cred
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
comment|/* Invalidate cached attributes if writing. */
if|if
condition|(
name|rw
operator|==
name|UIO_WRITE
condition|)
name|cp
operator|->
name|c_flags
operator|&=
operator|~
name|C_VATTR
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|coda_ioctl
parameter_list|(
name|v
parameter_list|)
name|void
modifier|*
name|v
decl_stmt|;
block|{
comment|/* true args */
name|struct
name|vop_ioctl_args
modifier|*
name|ap
init|=
name|v
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|int
name|com
init|=
name|ap
operator|->
name|a_command
decl_stmt|;
name|caddr_t
name|data
init|=
name|ap
operator|->
name|a_data
decl_stmt|;
name|int
name|flag
init|=
name|ap
operator|->
name|a_fflag
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|ap
operator|->
name|a_cred
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|ap
operator|->
name|a_td
decl_stmt|;
comment|/* locals */
name|int
name|error
decl_stmt|;
name|struct
name|vnode
modifier|*
name|tvp
decl_stmt|;
name|struct
name|nameidata
name|ndp
decl_stmt|;
name|struct
name|PioctlData
modifier|*
name|iap
init|=
operator|(
expr|struct
name|PioctlData
operator|*
operator|)
name|data
decl_stmt|;
name|MARK_ENTRY
argument_list|(
name|CODA_IOCTL_STATS
argument_list|)
expr_stmt|;
name|CODADEBUG
argument_list|(
argument|CODA_IOCTL
argument_list|,
argument|myprintf((
literal|"in coda_ioctl on %s\n"
argument|, iap->path));
argument_list|)
comment|/* Don't check for operation on a dying object, for ctlvp it        shouldn't matter */
comment|/* Must be control object to succeed. */
if|if
condition|(
operator|!
name|IS_CTL_VP
argument_list|(
name|vp
argument_list|)
condition|)
block|{
name|MARK_INT_FAIL
argument_list|(
name|CODA_IOCTL_STATS
argument_list|)
expr_stmt|;
name|CODADEBUG
argument_list|(
argument|CODA_IOCTL
argument_list|,
argument|myprintf((
literal|"coda_ioctl error: vp != ctlvp"
argument|));
argument_list|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
comment|/* Look up the pathname. */
comment|/* Should we use the name cache here? It would get it from        lookupname sooner or later anyway, right? */
name|NDINIT
argument_list|(
operator|&
name|ndp
argument_list|,
name|LOOKUP
argument_list|,
operator|(
name|iap
operator|->
name|follow
condition|?
name|FOLLOW
else|:
name|NOFOLLOW
operator|)
argument_list|,
name|UIO_USERSPACE
argument_list|,
name|iap
operator|->
name|path
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|error
operator|=
name|namei
argument_list|(
operator|&
name|ndp
argument_list|)
expr_stmt|;
name|tvp
operator|=
name|ndp
operator|.
name|ni_vp
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|MARK_INT_FAIL
argument_list|(
name|CODA_IOCTL_STATS
argument_list|)
expr_stmt|;
name|CODADEBUG
argument_list|(
argument|CODA_IOCTL
argument_list|,
argument|myprintf((
literal|"coda_ioctl error: lookup returns %d\n"
argument|, 				   error));
argument_list|)
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/*       * Make sure this is a coda style cnode, but it may be a      * different vfsp       */
if|if
condition|(
name|tvp
operator|->
name|v_op
operator|!=
name|coda_vnodeop_p
condition|)
block|{
name|vrele
argument_list|(
name|tvp
argument_list|)
expr_stmt|;
name|NDFREE
argument_list|(
operator|&
name|ndp
argument_list|,
name|NDF_ONLY_PNBUF
argument_list|)
expr_stmt|;
name|MARK_INT_FAIL
argument_list|(
name|CODA_IOCTL_STATS
argument_list|)
expr_stmt|;
name|CODADEBUG
argument_list|(
argument|CODA_IOCTL
argument_list|,
argument|myprintf((
literal|"coda_ioctl error: %s not a coda object\n"
argument|,  			iap->path));
argument_list|)
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|iap
operator|->
name|vi
operator|.
name|in_size
operator|>
name|VC_MAXDATASIZE
condition|)
block|{
name|NDFREE
argument_list|(
operator|&
name|ndp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|error
operator|=
name|venus_ioctl
argument_list|(
name|vtomi
argument_list|(
name|tvp
argument_list|)
argument_list|,
operator|&
operator|(
operator|(
name|VTOC
argument_list|(
name|tvp
argument_list|)
operator|)
operator|->
name|c_fid
operator|)
argument_list|,
name|com
argument_list|,
name|flag
argument_list|,
name|data
argument_list|,
name|cred
argument_list|,
name|td
operator|->
name|td_proc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|MARK_INT_FAIL
argument_list|(
name|CODA_IOCTL_STATS
argument_list|)
expr_stmt|;
else|else
name|CODADEBUG
argument_list|(
argument|CODA_IOCTL
argument_list|,
argument|myprintf((
literal|"Ioctl returns %d \n"
argument|, error));
argument_list|)
name|vrele
argument_list|(
name|tvp
argument_list|)
expr_stmt|;
name|NDFREE
argument_list|(
operator|&
name|ndp
argument_list|,
name|NDF_ONLY_PNBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * To reduce the cost of a user-level venus;we cache attributes in  * the kernel.  Each cnode has storage allocated for an attribute. If  * c_vattr is valid, return a reference to it. Otherwise, get the  * attributes from venus and store them in the cnode.  There is some  * question if this method is a security leak. But I think that in  * order to make this call, the user must have done a lookup and  * opened the file, and therefore should already have access.    */
end_comment

begin_function
name|int
name|coda_getattr
parameter_list|(
name|v
parameter_list|)
name|void
modifier|*
name|v
decl_stmt|;
block|{
comment|/* true args */
name|struct
name|vop_getattr_args
modifier|*
name|ap
init|=
name|v
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|cnode
modifier|*
name|cp
init|=
name|VTOC
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|vattr
modifier|*
name|vap
init|=
name|ap
operator|->
name|a_vap
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|ap
operator|->
name|a_cred
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|ap
operator|->
name|a_td
decl_stmt|;
comment|/* locals */
name|int
name|error
decl_stmt|;
name|MARK_ENTRY
argument_list|(
name|CODA_GETATTR_STATS
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_UNMOUNTING
argument_list|(
name|cp
argument_list|)
condition|)
return|return
name|ENODEV
return|;
comment|/* Check for getattr of control object. */
if|if
condition|(
name|IS_CTL_VP
argument_list|(
name|vp
argument_list|)
condition|)
block|{
name|MARK_INT_FAIL
argument_list|(
name|CODA_GETATTR_STATS
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
comment|/* Check to see if the attributes have already been cached */
if|if
condition|(
name|VALID_VATTR
argument_list|(
name|cp
argument_list|)
condition|)
block|{
name|CODADEBUG
argument_list|(
argument|CODA_GETATTR
argument_list|,
argument|{ myprintf((
literal|"attr cache hit: (%lx.%lx.%lx)\n"
argument|, 				       cp->c_fid.Volume, 				       cp->c_fid.Vnode, 				       cp->c_fid.Unique));}
argument_list|)
empty_stmt|;
name|CODADEBUG
argument_list|(
argument|CODA_GETATTR
argument_list|,
argument|if (!(codadebug& ~CODA_GETATTR)) 		 print_vattr(&cp->c_vattr);
argument_list|)
empty_stmt|;
operator|*
name|vap
operator|=
name|cp
operator|->
name|c_vattr
expr_stmt|;
name|MARK_INT_SAT
argument_list|(
name|CODA_GETATTR_STATS
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|error
operator|=
name|venus_getattr
argument_list|(
name|vtomi
argument_list|(
name|vp
argument_list|)
argument_list|,
operator|&
name|cp
operator|->
name|c_fid
argument_list|,
name|cred
argument_list|,
name|td
operator|->
name|td_proc
argument_list|,
name|vap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|CODADEBUG
argument_list|(
argument|CODA_GETATTR
argument_list|,
argument|myprintf((
literal|"getattr miss (%lx.%lx.%lx): result %d\n"
argument|, 				     cp->c_fid.Volume, 				     cp->c_fid.Vnode, 				     cp->c_fid.Unique, 				     error));
argument_list|)
name|CODADEBUG
argument_list|(
argument|CODA_GETATTR
argument_list|,
argument|if (!(codadebug& ~CODA_GETATTR)) 		 print_vattr(vap);
argument_list|)
empty_stmt|;
block|{
name|int
name|size
init|=
name|vap
operator|->
name|va_size
decl_stmt|;
name|struct
name|vnode
modifier|*
name|convp
init|=
name|cp
operator|->
name|c_ovp
decl_stmt|;
if|if
condition|(
name|convp
operator|!=
operator|(
expr|struct
name|vnode
operator|*
operator|)
literal|0
condition|)
block|{
name|vnode_pager_setsize
argument_list|(
name|convp
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If not open for write, store attributes in cnode */
if|if
condition|(
operator|(
name|cp
operator|->
name|c_owrite
operator|==
literal|0
operator|)
operator|&&
operator|(
name|coda_attr_cache
operator|)
condition|)
block|{
name|cp
operator|->
name|c_vattr
operator|=
operator|*
name|vap
expr_stmt|;
name|cp
operator|->
name|c_flags
operator||=
name|C_VATTR
expr_stmt|;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|coda_setattr
parameter_list|(
name|v
parameter_list|)
name|void
modifier|*
name|v
decl_stmt|;
block|{
comment|/* true args */
name|struct
name|vop_setattr_args
modifier|*
name|ap
init|=
name|v
decl_stmt|;
specifier|register
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|cnode
modifier|*
name|cp
init|=
name|VTOC
argument_list|(
name|vp
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|vattr
modifier|*
name|vap
init|=
name|ap
operator|->
name|a_vap
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|ap
operator|->
name|a_cred
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|ap
operator|->
name|a_td
decl_stmt|;
comment|/* locals */
name|int
name|error
decl_stmt|;
name|MARK_ENTRY
argument_list|(
name|CODA_SETATTR_STATS
argument_list|)
expr_stmt|;
comment|/* Check for setattr of control object. */
if|if
condition|(
name|IS_CTL_VP
argument_list|(
name|vp
argument_list|)
condition|)
block|{
name|MARK_INT_FAIL
argument_list|(
name|CODA_SETATTR_STATS
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
if|if
condition|(
name|codadebug
operator|&
name|CODADBGMSK
argument_list|(
name|CODA_SETATTR
argument_list|)
condition|)
block|{
name|print_vattr
argument_list|(
name|vap
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|venus_setattr
argument_list|(
name|vtomi
argument_list|(
name|vp
argument_list|)
argument_list|,
operator|&
name|cp
operator|->
name|c_fid
argument_list|,
name|vap
argument_list|,
name|cred
argument_list|,
name|td
operator|->
name|td_proc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|cp
operator|->
name|c_flags
operator|&=
operator|~
name|C_VATTR
expr_stmt|;
block|{
name|int
name|size
init|=
name|vap
operator|->
name|va_size
decl_stmt|;
name|struct
name|vnode
modifier|*
name|convp
init|=
name|cp
operator|->
name|c_ovp
decl_stmt|;
if|if
condition|(
name|size
operator|!=
name|VNOVAL
operator|&&
name|convp
operator|!=
operator|(
expr|struct
name|vnode
operator|*
operator|)
literal|0
condition|)
block|{
name|vnode_pager_setsize
argument_list|(
name|convp
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
block|}
name|CODADEBUG
argument_list|(
argument|CODA_SETATTR
argument_list|,
argument|myprintf((
literal|"setattr %d\n"
argument|, error));
argument_list|)
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|coda_access
parameter_list|(
name|v
parameter_list|)
name|void
modifier|*
name|v
decl_stmt|;
block|{
comment|/* true args */
name|struct
name|vop_access_args
modifier|*
name|ap
init|=
name|v
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|cnode
modifier|*
name|cp
init|=
name|VTOC
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|int
name|mode
init|=
name|ap
operator|->
name|a_mode
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|ap
operator|->
name|a_cred
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|ap
operator|->
name|a_td
decl_stmt|;
comment|/* locals */
name|int
name|error
decl_stmt|;
name|MARK_ENTRY
argument_list|(
name|CODA_ACCESS_STATS
argument_list|)
expr_stmt|;
comment|/* Check for access of control object.  Only read access is        allowed on it. */
if|if
condition|(
name|IS_CTL_VP
argument_list|(
name|vp
argument_list|)
condition|)
block|{
comment|/* bogus hack - all will be marked as successes */
name|MARK_INT_SAT
argument_list|(
name|CODA_ACCESS_STATS
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
operator|(
name|mode
operator|&
name|VREAD
operator|)
operator|&&
operator|!
operator|(
name|mode
operator|&
operator|(
name|VWRITE
operator||
name|VEXEC
operator|)
operator|)
operator|)
condition|?
literal|0
else|:
name|EACCES
operator|)
return|;
block|}
comment|/*      * if the file is a directory, and we are checking exec (eg lookup)       * access, and the file is in the namecache, then the user must have       * lookup access to it.      */
if|if
condition|(
name|coda_access_cache
condition|)
block|{
if|if
condition|(
operator|(
name|vp
operator|->
name|v_type
operator|==
name|VDIR
operator|)
operator|&&
operator|(
name|mode
operator|&
name|VEXEC
operator|)
condition|)
block|{
if|if
condition|(
name|coda_nc_lookup
argument_list|(
name|cp
argument_list|,
literal|"."
argument_list|,
literal|1
argument_list|,
name|cred
argument_list|)
condition|)
block|{
name|MARK_INT_SAT
argument_list|(
name|CODA_ACCESS_STATS
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* it was in the cache */
block|}
block|}
block|}
name|error
operator|=
name|venus_access
argument_list|(
name|vtomi
argument_list|(
name|vp
argument_list|)
argument_list|,
operator|&
name|cp
operator|->
name|c_fid
argument_list|,
name|mode
argument_list|,
name|cred
argument_list|,
name|td
operator|->
name|td_proc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|coda_readlink
parameter_list|(
name|v
parameter_list|)
name|void
modifier|*
name|v
decl_stmt|;
block|{
comment|/* true args */
name|struct
name|vop_readlink_args
modifier|*
name|ap
init|=
name|v
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|cnode
modifier|*
name|cp
init|=
name|VTOC
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|uio
modifier|*
name|uiop
init|=
name|ap
operator|->
name|a_uio
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|ap
operator|->
name|a_cred
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|ap
operator|->
name|a_uio
operator|->
name|uio_td
decl_stmt|;
comment|/* locals */
name|int
name|error
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|len
decl_stmt|;
name|MARK_ENTRY
argument_list|(
name|CODA_READLINK_STATS
argument_list|)
expr_stmt|;
comment|/* Check for readlink of control object. */
if|if
condition|(
name|IS_CTL_VP
argument_list|(
name|vp
argument_list|)
condition|)
block|{
name|MARK_INT_FAIL
argument_list|(
name|CODA_READLINK_STATS
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|coda_symlink_cache
operator|)
operator|&&
operator|(
name|VALID_SYMLINK
argument_list|(
name|cp
argument_list|)
operator|)
condition|)
block|{
comment|/* symlink was cached */
name|uiop
operator|->
name|uio_rw
operator|=
name|UIO_READ
expr_stmt|;
name|error
operator|=
name|uiomove
argument_list|(
name|cp
operator|->
name|c_symlink
argument_list|,
operator|(
name|int
operator|)
name|cp
operator|->
name|c_symlen
argument_list|,
name|uiop
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|MARK_INT_FAIL
argument_list|(
name|CODA_READLINK_STATS
argument_list|)
expr_stmt|;
else|else
name|MARK_INT_SAT
argument_list|(
name|CODA_READLINK_STATS
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|venus_readlink
argument_list|(
name|vtomi
argument_list|(
name|vp
argument_list|)
argument_list|,
operator|&
name|cp
operator|->
name|c_fid
argument_list|,
name|cred
argument_list|,
name|td
operator|->
name|td_proc
argument_list|,
operator|&
name|str
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|uiop
operator|->
name|uio_rw
operator|=
name|UIO_READ
expr_stmt|;
name|error
operator|=
name|uiomove
argument_list|(
name|str
argument_list|,
name|len
argument_list|,
name|uiop
argument_list|)
expr_stmt|;
if|if
condition|(
name|coda_symlink_cache
condition|)
block|{
name|cp
operator|->
name|c_symlink
operator|=
name|str
expr_stmt|;
name|cp
operator|->
name|c_symlen
operator|=
name|len
expr_stmt|;
name|cp
operator|->
name|c_flags
operator||=
name|C_SYMLINK
expr_stmt|;
block|}
else|else
name|CODA_FREE
argument_list|(
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
name|CODADEBUG
argument_list|(
argument|CODA_READLINK
argument_list|,
argument|myprintf((
literal|"in readlink result %d\n"
argument|,error));
argument_list|)
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|coda_fsync
parameter_list|(
name|v
parameter_list|)
name|void
modifier|*
name|v
decl_stmt|;
block|{
comment|/* true args */
name|struct
name|vop_fsync_args
modifier|*
name|ap
init|=
name|v
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|cnode
modifier|*
name|cp
init|=
name|VTOC
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|ap
operator|->
name|a_cred
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|ap
operator|->
name|a_td
decl_stmt|;
comment|/* locals */
name|struct
name|vnode
modifier|*
name|convp
init|=
name|cp
operator|->
name|c_ovp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|MARK_ENTRY
argument_list|(
name|CODA_FSYNC_STATS
argument_list|)
expr_stmt|;
comment|/* Check for fsync on an unmounting object */
comment|/* The NetBSD kernel, in it's infinite wisdom, can try to fsync      * after an unmount has been initiated.  This is a Bad Thing,      * which we have to avoid.  Not a legitimate failure for stats.      */
if|if
condition|(
name|IS_UNMOUNTING
argument_list|(
name|cp
argument_list|)
condition|)
block|{
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
comment|/* Check for fsync of control object. */
if|if
condition|(
name|IS_CTL_VP
argument_list|(
name|vp
argument_list|)
condition|)
block|{
name|MARK_INT_SAT
argument_list|(
name|CODA_FSYNC_STATS
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|convp
condition|)
name|VOP_FSYNC
argument_list|(
name|convp
argument_list|,
name|cred
argument_list|,
name|MNT_WAIT
argument_list|,
name|td
argument_list|)
expr_stmt|;
comment|/*      * We see fsyncs with usecount == 1 then usecount == 0.      * For now we ignore them.      */
comment|/*     if (!vp->v_usecount) {     	printf("coda_fsync on vnode %p with %d usecount.  c_flags = %x (%x)\n", 		vp, vp->v_usecount, cp->c_flags, cp->c_flags&C_PURGING);     }     */
comment|/*      * We can expect fsync on any vnode at all if venus is pruging it.      * Venus can't very well answer the fsync request, now can it?      * Hopefully, it won't have to, because hopefully, venus preserves      * the (possibly untrue) invariant that it never purges an open      * vnode.  Hopefully.      */
if|if
condition|(
name|cp
operator|->
name|c_flags
operator|&
name|C_PURGING
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* needs research */
return|return
literal|0
return|;
name|error
operator|=
name|venus_fsync
argument_list|(
name|vtomi
argument_list|(
name|vp
argument_list|)
argument_list|,
operator|&
name|cp
operator|->
name|c_fid
argument_list|,
name|cred
argument_list|,
name|td
operator|->
name|td_proc
argument_list|)
expr_stmt|;
name|CODADEBUG
argument_list|(
argument|CODA_FSYNC
argument_list|,
argument|myprintf((
literal|"in fsync result %d\n"
argument|,error));
argument_list|)
empty_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|coda_inactive
parameter_list|(
name|v
parameter_list|)
name|void
modifier|*
name|v
decl_stmt|;
block|{
comment|/* XXX - at the moment, inactive doesn't look at cred, and doesn't        have a proc pointer.  Oops. */
comment|/* true args */
name|struct
name|vop_inactive_args
modifier|*
name|ap
init|=
name|v
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|cnode
modifier|*
name|cp
init|=
name|VTOC
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
name|__attribute__
argument_list|(
operator|(
name|unused
operator|)
argument_list|)
init|=
name|NULL
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
name|__attribute__
argument_list|(
operator|(
name|unused
operator|)
argument_list|)
init|=
name|curthread
decl_stmt|;
comment|/* upcall decl */
comment|/* locals */
comment|/* We don't need to send inactive to venus - DCS */
name|MARK_ENTRY
argument_list|(
name|CODA_INACTIVE_STATS
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_CTL_VP
argument_list|(
name|vp
argument_list|)
condition|)
block|{
name|MARK_INT_SAT
argument_list|(
name|CODA_INACTIVE_STATS
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|CODADEBUG
argument_list|(
argument|CODA_INACTIVE
argument_list|,
argument|myprintf((
literal|"in inactive, %lx.%lx.%lx. vfsp %p\n"
argument|, 				  cp->c_fid.Volume, cp->c_fid.Vnode,  				  cp->c_fid.Unique, vp->v_mount));
argument_list|)
comment|/* If an array has been allocated to hold the symlink, deallocate it */
if|if
condition|(
operator|(
name|coda_symlink_cache
operator|)
operator|&&
operator|(
name|VALID_SYMLINK
argument_list|(
name|cp
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|cp
operator|->
name|c_symlink
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"coda_inactive: null symlink pointer in cnode"
argument_list|)
expr_stmt|;
name|CODA_FREE
argument_list|(
name|cp
operator|->
name|c_symlink
argument_list|,
name|cp
operator|->
name|c_symlen
argument_list|)
expr_stmt|;
name|cp
operator|->
name|c_flags
operator|&=
operator|~
name|C_SYMLINK
expr_stmt|;
name|cp
operator|->
name|c_symlen
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Remove it from the table so it can't be found. */
name|coda_unsave
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
expr|struct
name|coda_mntinfo
operator|*
operator|)
operator|(
name|vp
operator|->
name|v_mount
operator|->
name|mnt_data
operator|)
operator|==
name|NULL
condition|)
block|{
name|myprintf
argument_list|(
operator|(
literal|"Help! vfsp->vfs_data was NULL, but vnode %p wasn't dying\n"
operator|,
name|vp
operator|)
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"badness in coda_inactive\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|IS_UNMOUNTING
argument_list|(
name|cp
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"coda_inactive: IS_UNMOUNTING use %d: vp %p, cp %p\n"
argument_list|,
name|vp
operator|->
name|v_usecount
argument_list|,
name|vp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|c_ovp
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"coda_inactive: cp->ovp != NULL use %d: vp %p, cp %p\n"
argument_list|,
name|vp
operator|->
name|v_usecount
argument_list|,
name|vp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|lockmgr
argument_list|(
operator|&
name|cp
operator|->
name|c_lock
argument_list|,
name|LK_RELEASE
argument_list|,
operator|&
name|vp
operator|->
name|v_interlock
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|OLD_DIAGNOSTIC
if|if
condition|(
name|CTOV
argument_list|(
name|cp
argument_list|)
operator|->
name|v_usecount
condition|)
block|{
name|panic
argument_list|(
literal|"coda_inactive: nonzero reference count"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cp
operator|->
name|c_ovp
operator|!=
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"coda_inactive:  cp->ovp != NULL"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|vgone
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
name|MARK_INT_SAT
argument_list|(
name|CODA_INACTIVE_STATS
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remote file system operations having to do with directory manipulation.  */
end_comment

begin_comment
comment|/*   * It appears that in NetBSD, lookup is supposed to return the vnode locked  */
end_comment

begin_function
name|int
name|coda_lookup
parameter_list|(
name|v
parameter_list|)
name|void
modifier|*
name|v
decl_stmt|;
block|{
comment|/* true args */
name|struct
name|vop_lookup_args
modifier|*
name|ap
init|=
name|v
decl_stmt|;
name|struct
name|vnode
modifier|*
name|dvp
init|=
name|ap
operator|->
name|a_dvp
decl_stmt|;
name|struct
name|cnode
modifier|*
name|dcp
init|=
name|VTOC
argument_list|(
name|dvp
argument_list|)
decl_stmt|;
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
init|=
name|ap
operator|->
name|a_vpp
decl_stmt|;
comment|/*       * It looks as though ap->a_cnp->ni_cnd->cn_nameptr holds the rest      * of the string to xlate, and that we must try to get at least      * ap->a_cnp->ni_cnd->cn_namelen of those characters to macth.  I      * could be wrong.       */
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|cnp
operator|->
name|cn_cred
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|cnp
operator|->
name|cn_thread
decl_stmt|;
comment|/* locals */
name|struct
name|cnode
modifier|*
name|cp
decl_stmt|;
specifier|const
name|char
modifier|*
name|nm
init|=
name|cnp
operator|->
name|cn_nameptr
decl_stmt|;
name|int
name|len
init|=
name|cnp
operator|->
name|cn_namelen
decl_stmt|;
name|ViceFid
name|VFid
decl_stmt|;
name|int
name|vtype
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|MARK_ENTRY
argument_list|(
name|CODA_LOOKUP_STATS
argument_list|)
expr_stmt|;
name|CODADEBUG
argument_list|(
argument|CODA_LOOKUP
argument_list|,
argument|myprintf((
literal|"lookup: %s in %lx.%lx.%lx\n"
argument|, 				   nm, dcp->c_fid.Volume, 				   dcp->c_fid.Vnode, dcp->c_fid.Unique));
argument_list|)
empty_stmt|;
comment|/* Check for lookup of control object. */
if|if
condition|(
name|IS_CTL_NAME
argument_list|(
name|dvp
argument_list|,
name|nm
argument_list|,
name|len
argument_list|)
condition|)
block|{
operator|*
name|vpp
operator|=
name|coda_ctlvp
expr_stmt|;
name|vref
argument_list|(
operator|*
name|vpp
argument_list|)
expr_stmt|;
name|MARK_INT_SAT
argument_list|(
name|CODA_LOOKUP_STATS
argument_list|)
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
if|if
condition|(
name|len
operator|+
literal|1
operator|>
name|CODA_MAXNAMLEN
condition|)
block|{
name|MARK_INT_FAIL
argument_list|(
name|CODA_LOOKUP_STATS
argument_list|)
expr_stmt|;
name|CODADEBUG
argument_list|(
argument|CODA_LOOKUP
argument_list|,
argument|myprintf((
literal|"name too long: lookup, %lx.%lx.%lx(%s)\n"
argument|, 				    dcp->c_fid.Volume, dcp->c_fid.Vnode, 				    dcp->c_fid.Unique, nm));
argument_list|)
empty_stmt|;
operator|*
name|vpp
operator|=
operator|(
expr|struct
name|vnode
operator|*
operator|)
literal|0
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
comment|/* First try to look the file up in the cfs name cache */
comment|/* lock the parent vnode? */
name|cp
operator|=
name|coda_nc_lookup
argument_list|(
name|dcp
argument_list|,
name|nm
argument_list|,
name|len
argument_list|,
name|cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
block|{
operator|*
name|vpp
operator|=
name|CTOV
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|vref
argument_list|(
operator|*
name|vpp
argument_list|)
expr_stmt|;
name|CODADEBUG
argument_list|(
argument|CODA_LOOKUP
argument_list|,
argument|myprintf((
literal|"lookup result %d vpp %p\n"
argument|,error,*vpp));
argument_list|)
block|}
else|else
block|{
comment|/* The name wasn't cached, so we need to contact Venus */
name|error
operator|=
name|venus_lookup
argument_list|(
name|vtomi
argument_list|(
name|dvp
argument_list|)
argument_list|,
operator|&
name|dcp
operator|->
name|c_fid
argument_list|,
name|nm
argument_list|,
name|len
argument_list|,
name|cred
argument_list|,
name|td
operator|->
name|td_proc
argument_list|,
operator|&
name|VFid
argument_list|,
operator|&
name|vtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|MARK_INT_FAIL
argument_list|(
name|CODA_LOOKUP_STATS
argument_list|)
expr_stmt|;
name|CODADEBUG
argument_list|(
argument|CODA_LOOKUP
argument_list|,
argument|myprintf((
literal|"lookup error on %lx.%lx.%lx(%s)%d\n"
argument|, 					dcp->c_fid.Volume, dcp->c_fid.Vnode, dcp->c_fid.Unique, nm, error));
argument_list|)
operator|*
name|vpp
operator|=
operator|(
expr|struct
name|vnode
operator|*
operator|)
literal|0
expr_stmt|;
block|}
else|else
block|{
name|MARK_INT_SAT
argument_list|(
name|CODA_LOOKUP_STATS
argument_list|)
expr_stmt|;
name|CODADEBUG
argument_list|(
argument|CODA_LOOKUP
argument_list|,
argument|myprintf((
literal|"lookup: vol %lx vno %lx uni %lx type %o result %d\n"
argument|, 			    VFid.Volume, VFid.Vnode, VFid.Unique, vtype, 			    error));
argument_list|)
name|cp
operator|=
name|make_coda_node
argument_list|(
operator|&
name|VFid
argument_list|,
name|dvp
operator|->
name|v_mount
argument_list|,
name|vtype
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|CTOV
argument_list|(
name|cp
argument_list|)
expr_stmt|;
comment|/* enter the new vnode in the Name Cache only if the top bit isn't set */
comment|/* And don't enter a new vnode for an invalid one! */
if|if
condition|(
operator|!
operator|(
name|vtype
operator|&
name|CODA_NOCACHE
operator|)
condition|)
name|coda_nc_enter
argument_list|(
name|VTOC
argument_list|(
name|dvp
argument_list|)
argument_list|,
name|nm
argument_list|,
name|len
argument_list|,
name|cred
argument_list|,
name|VTOC
argument_list|(
operator|*
name|vpp
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|exit
label|:
comment|/*       * If we are creating, and this was the last name to be looked up,      * and the error was ENOENT, then there really shouldn't be an      * error and we can make the leaf NULL and return success.  Since      * this is supposed to work under Mach as well as NetBSD, we're      * leaving this fn wrapped.  We also must tell lookup/namei that      * we need to save the last component of the name.  (Create will      * have to free the name buffer later...lucky us...)      */
if|if
condition|(
operator|(
operator|(
name|cnp
operator|->
name|cn_nameiop
operator|==
name|CREATE
operator|)
operator|||
operator|(
name|cnp
operator|->
name|cn_nameiop
operator|==
name|RENAME
operator|)
operator|)
operator|&&
operator|(
name|cnp
operator|->
name|cn_flags
operator|&
name|ISLASTCN
operator|)
operator|&&
operator|(
name|error
operator|==
name|ENOENT
operator|)
condition|)
block|{
name|error
operator|=
name|EJUSTRETURN
expr_stmt|;
name|cnp
operator|->
name|cn_flags
operator||=
name|SAVENAME
expr_stmt|;
operator|*
name|ap
operator|->
name|a_vpp
operator|=
name|NULL
expr_stmt|;
block|}
comment|/*       * If we are removing, and we are at the last element, and we      * found it, then we need to keep the name around so that the      * removal will go ahead as planned.  Unfortunately, this will      * probably also lock the to-be-removed vnode, which may or may      * not be a good idea.  I'll have to look at the bits of      * coda_remove to make sure.  We'll only save the name if we did in      * fact find the name, otherwise coda_remove won't have a chance      * to free the pathname.        */
if|if
condition|(
operator|(
name|cnp
operator|->
name|cn_nameiop
operator|==
name|DELETE
operator|)
operator|&&
operator|(
name|cnp
operator|->
name|cn_flags
operator|&
name|ISLASTCN
operator|)
operator|&&
operator|!
name|error
condition|)
block|{
name|cnp
operator|->
name|cn_flags
operator||=
name|SAVENAME
expr_stmt|;
block|}
comment|/*       * If the lookup went well, we need to (potentially?) unlock the      * parent, and lock the child.  We are only responsible for      * checking to see if the parent is supposed to be unlocked before      * we return.  We must always lock the child (provided there is      * one, and (the parent isn't locked or it isn't the same as the      * parent.)  Simple, huh?  We can never leave the parent locked unless      * we are ISLASTCN      */
if|if
condition|(
operator|!
name|error
operator|||
operator|(
name|error
operator|==
name|EJUSTRETURN
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|cnp
operator|->
name|cn_flags
operator|&
name|LOCKPARENT
operator|)
operator|||
operator|!
operator|(
name|cnp
operator|->
name|cn_flags
operator|&
name|ISLASTCN
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|VOP_UNLOCK
argument_list|(
name|dvp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
operator|)
condition|)
block|{
return|return
name|error
return|;
block|}
comment|/*  	     * The parent is unlocked.  As long as there is a child, 	     * lock it without bothering to check anything else.  	     */
if|if
condition|(
operator|*
name|ap
operator|->
name|a_vpp
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|VOP_LOCK
argument_list|(
operator|*
name|ap
operator|->
name|a_vpp
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
name|td
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"coda_lookup: "
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"unlocked parent but couldn't lock child"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* The parent is locked, and may be the same as the child */
if|if
condition|(
operator|*
name|ap
operator|->
name|a_vpp
operator|&&
operator|(
operator|*
name|ap
operator|->
name|a_vpp
operator|!=
name|dvp
operator|)
condition|)
block|{
comment|/* Different, go ahead and lock it. */
if|if
condition|(
operator|(
name|error
operator|=
name|VOP_LOCK
argument_list|(
operator|*
name|ap
operator|->
name|a_vpp
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
name|td
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"coda_lookup: "
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"unlocked parent but couldn't lock child"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
comment|/* If the lookup failed, we need to ensure that the leaf is NULL */
comment|/* Don't change any locking? */
operator|*
name|ap
operator|->
name|a_vpp
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|coda_create
parameter_list|(
name|v
parameter_list|)
name|void
modifier|*
name|v
decl_stmt|;
block|{
comment|/* true args */
name|struct
name|vop_create_args
modifier|*
name|ap
init|=
name|v
decl_stmt|;
name|struct
name|vnode
modifier|*
name|dvp
init|=
name|ap
operator|->
name|a_dvp
decl_stmt|;
name|struct
name|cnode
modifier|*
name|dcp
init|=
name|VTOC
argument_list|(
name|dvp
argument_list|)
decl_stmt|;
name|struct
name|vattr
modifier|*
name|va
init|=
name|ap
operator|->
name|a_vap
decl_stmt|;
name|int
name|exclusive
init|=
literal|1
decl_stmt|;
name|int
name|mode
init|=
name|ap
operator|->
name|a_vap
operator|->
name|va_mode
decl_stmt|;
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
init|=
name|ap
operator|->
name|a_vpp
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|cnp
operator|->
name|cn_cred
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|cnp
operator|->
name|cn_thread
decl_stmt|;
comment|/* locals */
name|int
name|error
decl_stmt|;
name|struct
name|cnode
modifier|*
name|cp
decl_stmt|;
specifier|const
name|char
modifier|*
name|nm
init|=
name|cnp
operator|->
name|cn_nameptr
decl_stmt|;
name|int
name|len
init|=
name|cnp
operator|->
name|cn_namelen
decl_stmt|;
name|ViceFid
name|VFid
decl_stmt|;
name|struct
name|vattr
name|attr
decl_stmt|;
name|MARK_ENTRY
argument_list|(
name|CODA_CREATE_STATS
argument_list|)
expr_stmt|;
comment|/* All creates are exclusive XXX */
comment|/* I'm assuming the 'mode' argument is the file mode bits XXX */
comment|/* Check for create of control object. */
if|if
condition|(
name|IS_CTL_NAME
argument_list|(
name|dvp
argument_list|,
name|nm
argument_list|,
name|len
argument_list|)
condition|)
block|{
operator|*
name|vpp
operator|=
operator|(
expr|struct
name|vnode
operator|*
operator|)
literal|0
expr_stmt|;
name|MARK_INT_FAIL
argument_list|(
name|CODA_CREATE_STATS
argument_list|)
expr_stmt|;
return|return
operator|(
name|EACCES
operator|)
return|;
block|}
name|error
operator|=
name|venus_create
argument_list|(
name|vtomi
argument_list|(
name|dvp
argument_list|)
argument_list|,
operator|&
name|dcp
operator|->
name|c_fid
argument_list|,
name|nm
argument_list|,
name|len
argument_list|,
name|exclusive
argument_list|,
name|mode
argument_list|,
name|va
argument_list|,
name|cred
argument_list|,
name|td
operator|->
name|td_proc
argument_list|,
operator|&
name|VFid
argument_list|,
operator|&
name|attr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
comment|/* If this is an exclusive create, panic if the file already exists. */
comment|/* Venus should have detected the file and reported EEXIST. */
if|if
condition|(
operator|(
name|exclusive
operator|==
literal|1
operator|)
operator|&&
operator|(
name|coda_find
argument_list|(
operator|&
name|VFid
argument_list|)
operator|!=
name|NULL
operator|)
condition|)
name|panic
argument_list|(
literal|"cnode existed for newly created file!"
argument_list|)
expr_stmt|;
name|cp
operator|=
name|make_coda_node
argument_list|(
operator|&
name|VFid
argument_list|,
name|dvp
operator|->
name|v_mount
argument_list|,
name|attr
operator|.
name|va_type
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|CTOV
argument_list|(
name|cp
argument_list|)
expr_stmt|;
comment|/* Update va to reflect the new attributes. */
operator|(
operator|*
name|va
operator|)
operator|=
name|attr
expr_stmt|;
comment|/* Update the attribute cache and mark it as valid */
if|if
condition|(
name|coda_attr_cache
condition|)
block|{
name|VTOC
argument_list|(
operator|*
name|vpp
argument_list|)
operator|->
name|c_vattr
operator|=
name|attr
expr_stmt|;
name|VTOC
argument_list|(
operator|*
name|vpp
argument_list|)
operator|->
name|c_flags
operator||=
name|C_VATTR
expr_stmt|;
block|}
comment|/* Invalidate the parent's attr cache, the modification time has changed */
name|VTOC
argument_list|(
name|dvp
argument_list|)
operator|->
name|c_flags
operator|&=
operator|~
name|C_VATTR
expr_stmt|;
comment|/* enter the new vnode in the Name Cache */
name|coda_nc_enter
argument_list|(
name|VTOC
argument_list|(
name|dvp
argument_list|)
argument_list|,
name|nm
argument_list|,
name|len
argument_list|,
name|cred
argument_list|,
name|VTOC
argument_list|(
operator|*
name|vpp
argument_list|)
argument_list|)
expr_stmt|;
name|CODADEBUG
argument_list|(
argument|CODA_CREATE
argument_list|,
argument|myprintf((
literal|"create: (%lx.%lx.%lx), result %d\n"
argument|, 			VFid.Volume, VFid.Vnode, VFid.Unique, error));
argument_list|)
block|}
else|else
block|{
operator|*
name|vpp
operator|=
operator|(
expr|struct
name|vnode
operator|*
operator|)
literal|0
expr_stmt|;
name|CODADEBUG
argument_list|(
argument|CODA_CREATE
argument_list|,
argument|myprintf((
literal|"create error %d\n"
argument|, error));
argument_list|)
block|}
if|if
condition|(
operator|!
name|error
condition|)
block|{
if|if
condition|(
name|cnp
operator|->
name|cn_flags
operator|&
name|LOCKLEAF
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|VOP_LOCK
argument_list|(
operator|*
name|ap
operator|->
name|a_vpp
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
name|td
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"coda_create: "
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"unlocked parent but couldn't lock child"
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|OLD_DIAGNOSTIC
else|else
block|{
name|printf
argument_list|(
literal|"coda_create: LOCKLEAF not set!\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|coda_remove
parameter_list|(
name|v
parameter_list|)
name|void
modifier|*
name|v
decl_stmt|;
block|{
comment|/* true args */
name|struct
name|vop_remove_args
modifier|*
name|ap
init|=
name|v
decl_stmt|;
name|struct
name|vnode
modifier|*
name|dvp
init|=
name|ap
operator|->
name|a_dvp
decl_stmt|;
name|struct
name|cnode
modifier|*
name|cp
init|=
name|VTOC
argument_list|(
name|dvp
argument_list|)
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|cnp
operator|->
name|cn_cred
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|cnp
operator|->
name|cn_thread
decl_stmt|;
comment|/* locals */
name|int
name|error
decl_stmt|;
specifier|const
name|char
modifier|*
name|nm
init|=
name|cnp
operator|->
name|cn_nameptr
decl_stmt|;
name|int
name|len
init|=
name|cnp
operator|->
name|cn_namelen
decl_stmt|;
name|struct
name|cnode
modifier|*
name|tp
decl_stmt|;
name|MARK_ENTRY
argument_list|(
name|CODA_REMOVE_STATS
argument_list|)
expr_stmt|;
name|CODADEBUG
argument_list|(
argument|CODA_REMOVE
argument_list|,
argument|myprintf((
literal|"remove: %s in %lx.%lx.%lx\n"
argument|, 				   nm, cp->c_fid.Volume, cp->c_fid.Vnode, 				   cp->c_fid.Unique));
argument_list|)
empty_stmt|;
comment|/* Remove the file's entry from the CODA Name Cache */
comment|/* We're being conservative here, it might be that this person      * doesn't really have sufficient access to delete the file      * but we feel zapping the entry won't really hurt anyone -- dcs      */
comment|/* I'm gonna go out on a limb here. If a file and a hardlink to it      * exist, and one is removed, the link count on the other will be      * off by 1. We could either invalidate the attrs if cached, or      * fix them. I'll try to fix them. DCS 11/8/94      */
name|tp
operator|=
name|coda_nc_lookup
argument_list|(
name|VTOC
argument_list|(
name|dvp
argument_list|)
argument_list|,
name|nm
argument_list|,
name|len
argument_list|,
name|cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
condition|)
block|{
if|if
condition|(
name|VALID_VATTR
argument_list|(
name|tp
argument_list|)
condition|)
block|{
comment|/* If attrs are cached */
if|if
condition|(
name|tp
operator|->
name|c_vattr
operator|.
name|va_nlink
operator|>
literal|1
condition|)
block|{
comment|/* If it's a hard link */
name|tp
operator|->
name|c_vattr
operator|.
name|va_nlink
operator|--
expr_stmt|;
block|}
block|}
name|coda_nc_zapfile
argument_list|(
name|VTOC
argument_list|(
name|dvp
argument_list|)
argument_list|,
name|nm
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* No need to flush it if it doesn't exist! */
block|}
comment|/* Invalidate the parent's attr cache, the modification time has changed */
name|VTOC
argument_list|(
name|dvp
argument_list|)
operator|->
name|c_flags
operator|&=
operator|~
name|C_VATTR
expr_stmt|;
comment|/* Check for remove of control object. */
if|if
condition|(
name|IS_CTL_NAME
argument_list|(
name|dvp
argument_list|,
name|nm
argument_list|,
name|len
argument_list|)
condition|)
block|{
name|MARK_INT_FAIL
argument_list|(
name|CODA_REMOVE_STATS
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
name|error
operator|=
name|venus_remove
argument_list|(
name|vtomi
argument_list|(
name|dvp
argument_list|)
argument_list|,
operator|&
name|cp
operator|->
name|c_fid
argument_list|,
name|nm
argument_list|,
name|len
argument_list|,
name|cred
argument_list|,
name|td
operator|->
name|td_proc
argument_list|)
expr_stmt|;
name|CODADEBUG
argument_list|(
argument|CODA_REMOVE
argument_list|,
argument|myprintf((
literal|"in remove result %d\n"
argument|,error));
argument_list|)
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|coda_link
parameter_list|(
name|v
parameter_list|)
name|void
modifier|*
name|v
decl_stmt|;
block|{
comment|/* true args */
name|struct
name|vop_link_args
modifier|*
name|ap
init|=
name|v
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|cnode
modifier|*
name|cp
init|=
name|VTOC
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|vnode
modifier|*
name|tdvp
init|=
name|ap
operator|->
name|a_tdvp
decl_stmt|;
name|struct
name|cnode
modifier|*
name|tdcp
init|=
name|VTOC
argument_list|(
name|tdvp
argument_list|)
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|cnp
operator|->
name|cn_cred
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|cnp
operator|->
name|cn_thread
decl_stmt|;
comment|/* locals */
name|int
name|error
decl_stmt|;
specifier|const
name|char
modifier|*
name|nm
init|=
name|cnp
operator|->
name|cn_nameptr
decl_stmt|;
name|int
name|len
init|=
name|cnp
operator|->
name|cn_namelen
decl_stmt|;
name|MARK_ENTRY
argument_list|(
name|CODA_LINK_STATS
argument_list|)
expr_stmt|;
if|if
condition|(
name|codadebug
operator|&
name|CODADBGMSK
argument_list|(
name|CODA_LINK
argument_list|)
condition|)
block|{
name|myprintf
argument_list|(
operator|(
literal|"nb_link:   vp fid: (%lx.%lx.%lx)\n"
operator|,
name|cp
operator|->
name|c_fid
operator|.
name|Volume
operator|,
name|cp
operator|->
name|c_fid
operator|.
name|Vnode
operator|,
name|cp
operator|->
name|c_fid
operator|.
name|Unique
operator|)
argument_list|)
expr_stmt|;
name|myprintf
argument_list|(
operator|(
literal|"nb_link: tdvp fid: (%lx.%lx.%lx)\n"
operator|,
name|tdcp
operator|->
name|c_fid
operator|.
name|Volume
operator|,
name|tdcp
operator|->
name|c_fid
operator|.
name|Vnode
operator|,
name|tdcp
operator|->
name|c_fid
operator|.
name|Unique
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|codadebug
operator|&
name|CODADBGMSK
argument_list|(
name|CODA_LINK
argument_list|)
condition|)
block|{
name|myprintf
argument_list|(
operator|(
literal|"link:   vp fid: (%lx.%lx.%lx)\n"
operator|,
name|cp
operator|->
name|c_fid
operator|.
name|Volume
operator|,
name|cp
operator|->
name|c_fid
operator|.
name|Vnode
operator|,
name|cp
operator|->
name|c_fid
operator|.
name|Unique
operator|)
argument_list|)
expr_stmt|;
name|myprintf
argument_list|(
operator|(
literal|"link: tdvp fid: (%lx.%lx.%lx)\n"
operator|,
name|tdcp
operator|->
name|c_fid
operator|.
name|Volume
operator|,
name|tdcp
operator|->
name|c_fid
operator|.
name|Vnode
operator|,
name|tdcp
operator|->
name|c_fid
operator|.
name|Unique
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Check for link to/from control object. */
if|if
condition|(
name|IS_CTL_NAME
argument_list|(
name|tdvp
argument_list|,
name|nm
argument_list|,
name|len
argument_list|)
operator|||
name|IS_CTL_VP
argument_list|(
name|vp
argument_list|)
condition|)
block|{
name|MARK_INT_FAIL
argument_list|(
name|CODA_LINK_STATS
argument_list|)
expr_stmt|;
return|return
operator|(
name|EACCES
operator|)
return|;
block|}
name|error
operator|=
name|venus_link
argument_list|(
name|vtomi
argument_list|(
name|vp
argument_list|)
argument_list|,
operator|&
name|cp
operator|->
name|c_fid
argument_list|,
operator|&
name|tdcp
operator|->
name|c_fid
argument_list|,
name|nm
argument_list|,
name|len
argument_list|,
name|cred
argument_list|,
name|td
operator|->
name|td_proc
argument_list|)
expr_stmt|;
comment|/* Invalidate the parent's attr cache, the modification time has changed */
name|VTOC
argument_list|(
name|tdvp
argument_list|)
operator|->
name|c_flags
operator|&=
operator|~
name|C_VATTR
expr_stmt|;
name|VTOC
argument_list|(
name|vp
argument_list|)
operator|->
name|c_flags
operator|&=
operator|~
name|C_VATTR
expr_stmt|;
name|CODADEBUG
argument_list|(
argument|CODA_LINK
argument_list|,
argument|myprintf((
literal|"in link result %d\n"
argument|,error));
argument_list|)
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|coda_rename
parameter_list|(
name|v
parameter_list|)
name|void
modifier|*
name|v
decl_stmt|;
block|{
comment|/* true args */
name|struct
name|vop_rename_args
modifier|*
name|ap
init|=
name|v
decl_stmt|;
name|struct
name|vnode
modifier|*
name|odvp
init|=
name|ap
operator|->
name|a_fdvp
decl_stmt|;
name|struct
name|cnode
modifier|*
name|odcp
init|=
name|VTOC
argument_list|(
name|odvp
argument_list|)
decl_stmt|;
name|struct
name|componentname
modifier|*
name|fcnp
init|=
name|ap
operator|->
name|a_fcnp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|ndvp
init|=
name|ap
operator|->
name|a_tdvp
decl_stmt|;
name|struct
name|cnode
modifier|*
name|ndcp
init|=
name|VTOC
argument_list|(
name|ndvp
argument_list|)
decl_stmt|;
name|struct
name|componentname
modifier|*
name|tcnp
init|=
name|ap
operator|->
name|a_tcnp
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|fcnp
operator|->
name|cn_cred
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|fcnp
operator|->
name|cn_thread
decl_stmt|;
comment|/* true args */
name|int
name|error
decl_stmt|;
specifier|const
name|char
modifier|*
name|fnm
init|=
name|fcnp
operator|->
name|cn_nameptr
decl_stmt|;
name|int
name|flen
init|=
name|fcnp
operator|->
name|cn_namelen
decl_stmt|;
specifier|const
name|char
modifier|*
name|tnm
init|=
name|tcnp
operator|->
name|cn_nameptr
decl_stmt|;
name|int
name|tlen
init|=
name|tcnp
operator|->
name|cn_namelen
decl_stmt|;
name|MARK_ENTRY
argument_list|(
name|CODA_RENAME_STATS
argument_list|)
expr_stmt|;
comment|/* Hmmm.  The vnodes are already looked up.  Perhaps they are locked?        This could be Bad. XXX */
ifdef|#
directive|ifdef
name|OLD_DIAGNOSTIC
if|if
condition|(
operator|(
name|fcnp
operator|->
name|cn_cred
operator|!=
name|tcnp
operator|->
name|cn_cred
operator|)
operator|||
operator|(
name|fcnp
operator|->
name|cn_thread
operator|!=
name|tcnp
operator|->
name|cn_thread
operator|)
condition|)
block|{
name|panic
argument_list|(
literal|"coda_rename: component names don't agree"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Check for rename involving control object. */
if|if
condition|(
name|IS_CTL_NAME
argument_list|(
name|odvp
argument_list|,
name|fnm
argument_list|,
name|flen
argument_list|)
operator|||
name|IS_CTL_NAME
argument_list|(
name|ndvp
argument_list|,
name|tnm
argument_list|,
name|tlen
argument_list|)
condition|)
block|{
name|MARK_INT_FAIL
argument_list|(
name|CODA_RENAME_STATS
argument_list|)
expr_stmt|;
return|return
operator|(
name|EACCES
operator|)
return|;
block|}
comment|/* Problem with moving directories -- need to flush entry for .. */
if|if
condition|(
name|odvp
operator|!=
name|ndvp
condition|)
block|{
name|struct
name|cnode
modifier|*
name|ovcp
init|=
name|coda_nc_lookup
argument_list|(
name|VTOC
argument_list|(
name|odvp
argument_list|)
argument_list|,
name|fnm
argument_list|,
name|flen
argument_list|,
name|cred
argument_list|)
decl_stmt|;
if|if
condition|(
name|ovcp
condition|)
block|{
name|struct
name|vnode
modifier|*
name|ovp
init|=
name|CTOV
argument_list|(
name|ovcp
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|ovp
operator|)
operator|&&
operator|(
name|ovp
operator|->
name|v_type
operator|==
name|VDIR
operator|)
condition|)
comment|/* If it's a directory */
name|coda_nc_zapfile
argument_list|(
name|VTOC
argument_list|(
name|ovp
argument_list|)
argument_list|,
literal|".."
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Remove the entries for both source and target files */
name|coda_nc_zapfile
argument_list|(
name|VTOC
argument_list|(
name|odvp
argument_list|)
argument_list|,
name|fnm
argument_list|,
name|flen
argument_list|)
expr_stmt|;
name|coda_nc_zapfile
argument_list|(
name|VTOC
argument_list|(
name|ndvp
argument_list|)
argument_list|,
name|tnm
argument_list|,
name|tlen
argument_list|)
expr_stmt|;
comment|/* Invalidate the parent's attr cache, the modification time has changed */
name|VTOC
argument_list|(
name|odvp
argument_list|)
operator|->
name|c_flags
operator|&=
operator|~
name|C_VATTR
expr_stmt|;
name|VTOC
argument_list|(
name|ndvp
argument_list|)
operator|->
name|c_flags
operator|&=
operator|~
name|C_VATTR
expr_stmt|;
if|if
condition|(
name|flen
operator|+
literal|1
operator|>
name|CODA_MAXNAMLEN
condition|)
block|{
name|MARK_INT_FAIL
argument_list|(
name|CODA_RENAME_STATS
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
if|if
condition|(
name|tlen
operator|+
literal|1
operator|>
name|CODA_MAXNAMLEN
condition|)
block|{
name|MARK_INT_FAIL
argument_list|(
name|CODA_RENAME_STATS
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
name|error
operator|=
name|venus_rename
argument_list|(
name|vtomi
argument_list|(
name|odvp
argument_list|)
argument_list|,
operator|&
name|odcp
operator|->
name|c_fid
argument_list|,
operator|&
name|ndcp
operator|->
name|c_fid
argument_list|,
name|fnm
argument_list|,
name|flen
argument_list|,
name|tnm
argument_list|,
name|tlen
argument_list|,
name|cred
argument_list|,
name|td
operator|->
name|td_proc
argument_list|)
expr_stmt|;
name|exit
label|:
name|CODADEBUG
argument_list|(
argument|CODA_RENAME
argument_list|,
argument|myprintf((
literal|"in rename result %d\n"
argument|,error));
argument_list|)
comment|/* XXX - do we need to call cache pureg on the moved vnode? */
name|cache_purge
argument_list|(
name|ap
operator|->
name|a_fvp
argument_list|)
expr_stmt|;
comment|/* It seems to be incumbent on us to drop locks on all four vnodes */
comment|/* From-vnodes are not locked, only ref'd.  To-vnodes are locked. */
name|vrele
argument_list|(
name|ap
operator|->
name|a_fvp
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|odvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|a_tvp
condition|)
block|{
if|if
condition|(
name|ap
operator|->
name|a_tvp
operator|==
name|ndvp
condition|)
block|{
name|vrele
argument_list|(
name|ap
operator|->
name|a_tvp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vput
argument_list|(
name|ap
operator|->
name|a_tvp
argument_list|)
expr_stmt|;
block|}
block|}
name|vput
argument_list|(
name|ndvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|coda_mkdir
parameter_list|(
name|v
parameter_list|)
name|void
modifier|*
name|v
decl_stmt|;
block|{
comment|/* true args */
name|struct
name|vop_mkdir_args
modifier|*
name|ap
init|=
name|v
decl_stmt|;
name|struct
name|vnode
modifier|*
name|dvp
init|=
name|ap
operator|->
name|a_dvp
decl_stmt|;
name|struct
name|cnode
modifier|*
name|dcp
init|=
name|VTOC
argument_list|(
name|dvp
argument_list|)
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
specifier|register
name|struct
name|vattr
modifier|*
name|va
init|=
name|ap
operator|->
name|a_vap
decl_stmt|;
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
init|=
name|ap
operator|->
name|a_vpp
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|cnp
operator|->
name|cn_cred
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|cnp
operator|->
name|cn_thread
decl_stmt|;
comment|/* locals */
name|int
name|error
decl_stmt|;
specifier|const
name|char
modifier|*
name|nm
init|=
name|cnp
operator|->
name|cn_nameptr
decl_stmt|;
name|int
name|len
init|=
name|cnp
operator|->
name|cn_namelen
decl_stmt|;
name|struct
name|cnode
modifier|*
name|cp
decl_stmt|;
name|ViceFid
name|VFid
decl_stmt|;
name|struct
name|vattr
name|ova
decl_stmt|;
name|MARK_ENTRY
argument_list|(
name|CODA_MKDIR_STATS
argument_list|)
expr_stmt|;
comment|/* Check for mkdir of target object. */
if|if
condition|(
name|IS_CTL_NAME
argument_list|(
name|dvp
argument_list|,
name|nm
argument_list|,
name|len
argument_list|)
condition|)
block|{
operator|*
name|vpp
operator|=
operator|(
expr|struct
name|vnode
operator|*
operator|)
literal|0
expr_stmt|;
name|MARK_INT_FAIL
argument_list|(
name|CODA_MKDIR_STATS
argument_list|)
expr_stmt|;
return|return
operator|(
name|EACCES
operator|)
return|;
block|}
if|if
condition|(
name|len
operator|+
literal|1
operator|>
name|CODA_MAXNAMLEN
condition|)
block|{
operator|*
name|vpp
operator|=
operator|(
expr|struct
name|vnode
operator|*
operator|)
literal|0
expr_stmt|;
name|MARK_INT_FAIL
argument_list|(
name|CODA_MKDIR_STATS
argument_list|)
expr_stmt|;
return|return
operator|(
name|EACCES
operator|)
return|;
block|}
name|error
operator|=
name|venus_mkdir
argument_list|(
name|vtomi
argument_list|(
name|dvp
argument_list|)
argument_list|,
operator|&
name|dcp
operator|->
name|c_fid
argument_list|,
name|nm
argument_list|,
name|len
argument_list|,
name|va
argument_list|,
name|cred
argument_list|,
name|td
operator|->
name|td_proc
argument_list|,
operator|&
name|VFid
argument_list|,
operator|&
name|ova
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
if|if
condition|(
name|coda_find
argument_list|(
operator|&
name|VFid
argument_list|)
operator|!=
name|NULL
condition|)
name|panic
argument_list|(
literal|"cnode existed for newly created directory!"
argument_list|)
expr_stmt|;
name|cp
operator|=
name|make_coda_node
argument_list|(
operator|&
name|VFid
argument_list|,
name|dvp
operator|->
name|v_mount
argument_list|,
name|va
operator|->
name|va_type
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|CTOV
argument_list|(
name|cp
argument_list|)
expr_stmt|;
comment|/* enter the new vnode in the Name Cache */
name|coda_nc_enter
argument_list|(
name|VTOC
argument_list|(
name|dvp
argument_list|)
argument_list|,
name|nm
argument_list|,
name|len
argument_list|,
name|cred
argument_list|,
name|VTOC
argument_list|(
operator|*
name|vpp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* as a side effect, enter "." and ".." for the directory */
name|coda_nc_enter
argument_list|(
name|VTOC
argument_list|(
operator|*
name|vpp
argument_list|)
argument_list|,
literal|"."
argument_list|,
literal|1
argument_list|,
name|cred
argument_list|,
name|VTOC
argument_list|(
operator|*
name|vpp
argument_list|)
argument_list|)
expr_stmt|;
name|coda_nc_enter
argument_list|(
name|VTOC
argument_list|(
operator|*
name|vpp
argument_list|)
argument_list|,
literal|".."
argument_list|,
literal|2
argument_list|,
name|cred
argument_list|,
name|VTOC
argument_list|(
name|dvp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|coda_attr_cache
condition|)
block|{
name|VTOC
argument_list|(
operator|*
name|vpp
argument_list|)
operator|->
name|c_vattr
operator|=
name|ova
expr_stmt|;
comment|/* update the attr cache */
name|VTOC
argument_list|(
operator|*
name|vpp
argument_list|)
operator|->
name|c_flags
operator||=
name|C_VATTR
expr_stmt|;
comment|/* Valid attributes in cnode */
block|}
comment|/* Invalidate the parent's attr cache, the modification time has changed */
name|VTOC
argument_list|(
name|dvp
argument_list|)
operator|->
name|c_flags
operator|&=
operator|~
name|C_VATTR
expr_stmt|;
name|CODADEBUG
argument_list|(
argument|CODA_MKDIR
argument_list|,
argument|myprintf((
literal|"mkdir: (%lx.%lx.%lx) result %d\n"
argument|, 				    VFid.Volume, VFid.Vnode, VFid.Unique, error));
argument_list|)
block|}
else|else
block|{
operator|*
name|vpp
operator|=
operator|(
expr|struct
name|vnode
operator|*
operator|)
literal|0
expr_stmt|;
name|CODADEBUG
argument_list|(
argument|CODA_MKDIR
argument_list|,
argument|myprintf((
literal|"mkdir error %d\n"
argument|,error));
argument_list|)
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|coda_rmdir
parameter_list|(
name|v
parameter_list|)
name|void
modifier|*
name|v
decl_stmt|;
block|{
comment|/* true args */
name|struct
name|vop_rmdir_args
modifier|*
name|ap
init|=
name|v
decl_stmt|;
name|struct
name|vnode
modifier|*
name|dvp
init|=
name|ap
operator|->
name|a_dvp
decl_stmt|;
name|struct
name|cnode
modifier|*
name|dcp
init|=
name|VTOC
argument_list|(
name|dvp
argument_list|)
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|cnp
operator|->
name|cn_cred
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|cnp
operator|->
name|cn_thread
decl_stmt|;
comment|/* true args */
name|int
name|error
decl_stmt|;
specifier|const
name|char
modifier|*
name|nm
init|=
name|cnp
operator|->
name|cn_nameptr
decl_stmt|;
name|int
name|len
init|=
name|cnp
operator|->
name|cn_namelen
decl_stmt|;
name|struct
name|cnode
modifier|*
name|cp
decl_stmt|;
name|MARK_ENTRY
argument_list|(
name|CODA_RMDIR_STATS
argument_list|)
expr_stmt|;
comment|/* Check for rmdir of control object. */
if|if
condition|(
name|IS_CTL_NAME
argument_list|(
name|dvp
argument_list|,
name|nm
argument_list|,
name|len
argument_list|)
condition|)
block|{
name|MARK_INT_FAIL
argument_list|(
name|CODA_RMDIR_STATS
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
comment|/* We're being conservative here, it might be that this person      * doesn't really have sufficient access to delete the file      * but we feel zapping the entry won't really hurt anyone -- dcs      */
comment|/*      * As a side effect of the rmdir, remove any entries for children of      * the directory, especially "." and "..".      */
name|cp
operator|=
name|coda_nc_lookup
argument_list|(
name|dcp
argument_list|,
name|nm
argument_list|,
name|len
argument_list|,
name|cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
name|coda_nc_zapParentfid
argument_list|(
operator|&
operator|(
name|cp
operator|->
name|c_fid
operator|)
argument_list|,
name|NOT_DOWNCALL
argument_list|)
expr_stmt|;
comment|/* Remove the file's entry from the CODA Name Cache */
name|coda_nc_zapfile
argument_list|(
name|dcp
argument_list|,
name|nm
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Invalidate the parent's attr cache, the modification time has changed */
name|dcp
operator|->
name|c_flags
operator|&=
operator|~
name|C_VATTR
expr_stmt|;
name|error
operator|=
name|venus_rmdir
argument_list|(
name|vtomi
argument_list|(
name|dvp
argument_list|)
argument_list|,
operator|&
name|dcp
operator|->
name|c_fid
argument_list|,
name|nm
argument_list|,
name|len
argument_list|,
name|cred
argument_list|,
name|td
operator|->
name|td_proc
argument_list|)
expr_stmt|;
name|CODADEBUG
argument_list|(
argument|CODA_RMDIR
argument_list|,
argument|myprintf((
literal|"in rmdir result %d\n"
argument|, error));
argument_list|)
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|coda_symlink
parameter_list|(
name|v
parameter_list|)
name|void
modifier|*
name|v
decl_stmt|;
block|{
comment|/* true args */
name|struct
name|vop_symlink_args
modifier|*
name|ap
init|=
name|v
decl_stmt|;
name|struct
name|vnode
modifier|*
name|tdvp
init|=
name|ap
operator|->
name|a_dvp
decl_stmt|;
name|struct
name|cnode
modifier|*
name|tdcp
init|=
name|VTOC
argument_list|(
name|tdvp
argument_list|)
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
name|struct
name|vattr
modifier|*
name|tva
init|=
name|ap
operator|->
name|a_vap
decl_stmt|;
name|char
modifier|*
name|path
init|=
name|ap
operator|->
name|a_target
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|cnp
operator|->
name|cn_cred
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|cnp
operator|->
name|cn_thread
decl_stmt|;
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
init|=
name|ap
operator|->
name|a_vpp
decl_stmt|;
comment|/* locals */
name|int
name|error
decl_stmt|;
comment|/*       * XXX I'm assuming the following things about coda_symlink's      * arguments:       *       t(foo) is the new name/parent/etc being created.      *       lname is the contents of the new symlink.       */
name|char
modifier|*
name|nm
init|=
name|cnp
operator|->
name|cn_nameptr
decl_stmt|;
name|int
name|len
init|=
name|cnp
operator|->
name|cn_namelen
decl_stmt|;
name|int
name|plen
init|=
name|strlen
argument_list|(
name|path
argument_list|)
decl_stmt|;
comment|/*       * Here's the strategy for the moment: perform the symlink, then      * do a lookup to grab the resulting vnode.  I know this requires      * two communications with Venus for a new sybolic link, but      * that's the way the ball bounces.  I don't yet want to change      * the way the Mach symlink works.  When Mach support is      * deprecated, we should change symlink so that the common case      * returns the resultant vnode in a vpp argument.      */
name|MARK_ENTRY
argument_list|(
name|CODA_SYMLINK_STATS
argument_list|)
expr_stmt|;
comment|/* Check for symlink of control object. */
if|if
condition|(
name|IS_CTL_NAME
argument_list|(
name|tdvp
argument_list|,
name|nm
argument_list|,
name|len
argument_list|)
condition|)
block|{
name|MARK_INT_FAIL
argument_list|(
name|CODA_SYMLINK_STATS
argument_list|)
expr_stmt|;
return|return
operator|(
name|EACCES
operator|)
return|;
block|}
if|if
condition|(
name|plen
operator|+
literal|1
operator|>
name|CODA_MAXPATHLEN
condition|)
block|{
name|MARK_INT_FAIL
argument_list|(
name|CODA_SYMLINK_STATS
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|len
operator|+
literal|1
operator|>
name|CODA_MAXNAMLEN
condition|)
block|{
name|MARK_INT_FAIL
argument_list|(
name|CODA_SYMLINK_STATS
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
name|error
operator|=
name|venus_symlink
argument_list|(
name|vtomi
argument_list|(
name|tdvp
argument_list|)
argument_list|,
operator|&
name|tdcp
operator|->
name|c_fid
argument_list|,
name|path
argument_list|,
name|plen
argument_list|,
name|nm
argument_list|,
name|len
argument_list|,
name|tva
argument_list|,
name|cred
argument_list|,
name|td
operator|->
name|td_proc
argument_list|)
expr_stmt|;
comment|/* Invalidate the parent's attr cache, the modification time has changed */
name|tdcp
operator|->
name|c_flags
operator|&=
operator|~
name|C_VATTR
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|VOP_LOOKUP
argument_list|(
name|tdvp
argument_list|,
name|vpp
argument_list|,
name|cnp
argument_list|)
expr_stmt|;
name|exit
label|:
name|CODADEBUG
argument_list|(
argument|CODA_SYMLINK
argument_list|,
argument|myprintf((
literal|"in symlink result %d\n"
argument|,error));
argument_list|)
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read directory entries.  */
end_comment

begin_function
name|int
name|coda_readdir
parameter_list|(
name|v
parameter_list|)
name|void
modifier|*
name|v
decl_stmt|;
block|{
comment|/* true args */
name|struct
name|vop_readdir_args
modifier|*
name|ap
init|=
name|v
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|cnode
modifier|*
name|cp
init|=
name|VTOC
argument_list|(
name|vp
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|uio
modifier|*
name|uiop
init|=
name|ap
operator|->
name|a_uio
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|ap
operator|->
name|a_cred
decl_stmt|;
name|int
modifier|*
name|eofflag
init|=
name|ap
operator|->
name|a_eofflag
decl_stmt|;
name|u_long
modifier|*
modifier|*
name|cookies
init|=
name|ap
operator|->
name|a_cookies
decl_stmt|;
name|int
modifier|*
name|ncookies
init|=
name|ap
operator|->
name|a_ncookies
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|ap
operator|->
name|a_uio
operator|->
name|uio_td
decl_stmt|;
comment|/* upcall decl */
comment|/* locals */
name|int
name|error
init|=
literal|0
decl_stmt|;
name|MARK_ENTRY
argument_list|(
name|CODA_READDIR_STATS
argument_list|)
expr_stmt|;
name|CODADEBUG
argument_list|(
argument|CODA_READDIR
argument_list|,
argument|myprintf((
literal|"coda_readdir(%p, %d, %lld, %d)\n"
argument|, 				      (void *)uiop->uio_iov->iov_base, 				      uiop->uio_resid, 				      (long long)uiop->uio_offset, 				      uiop->uio_segflg));
argument_list|)
comment|/* Check for readdir of control object. */
if|if
condition|(
name|IS_CTL_VP
argument_list|(
name|vp
argument_list|)
condition|)
block|{
name|MARK_INT_FAIL
argument_list|(
name|CODA_READDIR_STATS
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
block|{
comment|/* If directory is not already open do an "internal open" on it. */
name|int
name|opened_internally
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|cp
operator|->
name|c_ovp
operator|==
name|NULL
condition|)
block|{
name|opened_internally
operator|=
literal|1
expr_stmt|;
name|MARK_INT_GEN
argument_list|(
name|CODA_OPEN_STATS
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_OPEN
argument_list|(
name|vp
argument_list|,
name|FREAD
argument_list|,
name|cred
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"coda_readdir: Internally Opening %p\n"
argument_list|,
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"coda_readdir: VOP_OPEN on container failed %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VREG
condition|)
block|{
name|error
operator|=
name|vfs_object_create
argument_list|(
name|vp
argument_list|,
name|td
argument_list|,
name|cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"coda_readdir: vfs_object_create() returns %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Have UFS handle the call. */
name|CODADEBUG
argument_list|(
argument|CODA_READDIR
argument_list|,
argument|myprintf((
literal|"indirect readdir: fid = (%lx.%lx.%lx), refcnt = %d\n"
argument|,cp->c_fid.Volume, cp->c_fid.Vnode, cp->c_fid.Unique, vp->v_usecount));
argument_list|)
name|error
operator|=
name|VOP_READDIR
argument_list|(
name|cp
operator|->
name|c_ovp
argument_list|,
name|uiop
argument_list|,
name|cred
argument_list|,
name|eofflag
argument_list|,
name|ncookies
argument_list|,
name|cookies
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|MARK_INT_FAIL
argument_list|(
name|CODA_READDIR_STATS
argument_list|)
expr_stmt|;
else|else
name|MARK_INT_SAT
argument_list|(
name|CODA_READDIR_STATS
argument_list|)
expr_stmt|;
comment|/* Do an "internal close" if necessary. */
if|if
condition|(
name|opened_internally
condition|)
block|{
name|MARK_INT_GEN
argument_list|(
name|CODA_CLOSE_STATS
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|VOP_CLOSE
argument_list|(
name|vp
argument_list|,
name|FREAD
argument_list|,
name|cred
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert from file system blocks to device blocks  */
end_comment

begin_function
name|int
name|coda_bmap
parameter_list|(
name|v
parameter_list|)
name|void
modifier|*
name|v
decl_stmt|;
block|{
comment|/* XXX on the global proc */
comment|/* true args */
name|struct
name|vop_bmap_args
modifier|*
name|ap
init|=
name|v
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
name|__attribute__
argument_list|(
operator|(
name|unused
operator|)
argument_list|)
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
comment|/* file's vnode */
name|daddr_t
name|bn
name|__attribute__
argument_list|(
operator|(
name|unused
operator|)
argument_list|)
init|=
name|ap
operator|->
name|a_bn
decl_stmt|;
comment|/* fs block number */
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
init|=
name|ap
operator|->
name|a_vpp
decl_stmt|;
comment|/* RETURN vp of device */
name|daddr_t
modifier|*
name|bnp
name|__attribute__
argument_list|(
operator|(
name|unused
operator|)
argument_list|)
init|=
name|ap
operator|->
name|a_bnp
decl_stmt|;
comment|/* RETURN device block number */
name|struct
name|thread
modifier|*
name|td
name|__attribute__
argument_list|(
operator|(
name|unused
operator|)
argument_list|)
init|=
name|curthread
decl_stmt|;
comment|/* upcall decl */
comment|/* locals */
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|struct
name|cnode
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
name|VTOC
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|c_ovp
condition|)
block|{
return|return
name|EINVAL
return|;
name|ret
operator|=
name|VOP_BMAP
argument_list|(
name|cp
operator|->
name|c_ovp
argument_list|,
name|bn
argument_list|,
name|vpp
argument_list|,
name|bnp
argument_list|,
name|ap
operator|->
name|a_runp
argument_list|,
name|ap
operator|->
name|a_runb
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|printf("VOP_BMAP(cp->c_ovp %p, bn %p, vpp %p, bnp %p, ap->a_runp %p, ap->a_runb %p) = %d\n", 			cp->c_ovp, bn, vpp, bnp, ap->a_runp, ap->a_runb, ret);
endif|#
directive|endif
return|return
name|ret
return|;
block|}
else|else
block|{
if|#
directive|if
literal|0
block|printf("coda_bmap: no container\n");
endif|#
directive|endif
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * I don't think the following two things are used anywhere, so I've  * commented them out   *   * struct buf *async_bufhead;   * int async_daemon_count;  */
end_comment

begin_function
name|int
name|coda_strategy
parameter_list|(
name|v
parameter_list|)
name|void
modifier|*
name|v
decl_stmt|;
block|{
comment|/* true args */
name|struct
name|vop_strategy_args
modifier|*
name|ap
init|=
name|v
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
name|__attribute__
argument_list|(
operator|(
name|unused
operator|)
argument_list|)
init|=
name|ap
operator|->
name|a_bp
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
name|__attribute__
argument_list|(
operator|(
name|unused
operator|)
argument_list|)
init|=
name|curthread
decl_stmt|;
comment|/* upcall decl */
comment|/* locals */
name|printf
argument_list|(
literal|"coda_strategy: called ???\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
end_function

begin_function
name|int
name|coda_reclaim
parameter_list|(
name|v
parameter_list|)
name|void
modifier|*
name|v
decl_stmt|;
block|{
comment|/* true args */
name|struct
name|vop_reclaim_args
modifier|*
name|ap
init|=
name|v
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|cnode
modifier|*
name|cp
init|=
name|VTOC
argument_list|(
name|vp
argument_list|)
decl_stmt|;
comment|/* upcall decl */
comment|/* locals */
comment|/*  * Forced unmount/flush will let vnodes with non zero use be destroyed!  */
name|ENTRY
expr_stmt|;
if|if
condition|(
name|IS_UNMOUNTING
argument_list|(
name|cp
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|VTOC
argument_list|(
name|vp
argument_list|)
operator|->
name|c_ovp
condition|)
block|{
if|if
condition|(
name|IS_UNMOUNTING
argument_list|(
name|cp
argument_list|)
condition|)
name|printf
argument_list|(
literal|"coda_reclaim: c_ovp not void: vp %p, cp %p\n"
argument_list|,
name|vp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|OLD_DIAGNOSTIC
if|if
condition|(
name|vp
operator|->
name|v_usecount
operator|!=
literal|0
condition|)
name|print
argument_list|(
literal|"coda_reclaim: pushing active %p\n"
argument_list|,
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|VTOC
argument_list|(
name|vp
argument_list|)
operator|->
name|c_ovp
condition|)
block|{
name|panic
argument_list|(
literal|"coda_reclaim: c_ovp not void"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|cache_purge
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|lockdestroy
argument_list|(
operator|&
operator|(
name|VTOC
argument_list|(
name|vp
argument_list|)
operator|->
name|c_lock
operator|)
argument_list|)
expr_stmt|;
name|coda_free
argument_list|(
name|VTOC
argument_list|(
name|vp
argument_list|)
argument_list|)
expr_stmt|;
name|VTOC
argument_list|(
name|vp
argument_list|)
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|coda_lock
parameter_list|(
name|v
parameter_list|)
name|void
modifier|*
name|v
decl_stmt|;
block|{
comment|/* true args */
name|struct
name|vop_lock_args
modifier|*
name|ap
init|=
name|v
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|cnode
modifier|*
name|cp
init|=
name|VTOC
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|ap
operator|->
name|a_td
decl_stmt|;
comment|/* upcall decl */
comment|/* locals */
name|ENTRY
expr_stmt|;
if|if
condition|(
name|coda_lockdebug
condition|)
block|{
name|myprintf
argument_list|(
operator|(
literal|"Attempting lock on %lx.%lx.%lx\n"
operator|,
name|cp
operator|->
name|c_fid
operator|.
name|Volume
operator|,
name|cp
operator|->
name|c_fid
operator|.
name|Vnode
operator|,
name|cp
operator|->
name|c_fid
operator|.
name|Unique
operator|)
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|DEBUG_LOCKS
return|return
operator|(
name|lockmgr
argument_list|(
operator|&
name|cp
operator|->
name|c_lock
argument_list|,
name|ap
operator|->
name|a_flags
argument_list|,
operator|&
name|vp
operator|->
name|v_interlock
argument_list|,
name|td
argument_list|)
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|debuglockmgr
argument_list|(
operator|&
name|cp
operator|->
name|c_lock
argument_list|,
name|ap
operator|->
name|a_flags
argument_list|,
operator|&
name|vp
operator|->
name|v_interlock
argument_list|,
name|td
argument_list|,
literal|"coda_lock"
argument_list|,
name|vp
operator|->
name|filename
argument_list|,
name|vp
operator|->
name|line
argument_list|)
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|coda_unlock
parameter_list|(
name|v
parameter_list|)
name|void
modifier|*
name|v
decl_stmt|;
block|{
comment|/* true args */
name|struct
name|vop_unlock_args
modifier|*
name|ap
init|=
name|v
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|cnode
modifier|*
name|cp
init|=
name|VTOC
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|ap
operator|->
name|a_td
decl_stmt|;
comment|/* upcall decl */
comment|/* locals */
name|ENTRY
expr_stmt|;
if|if
condition|(
name|coda_lockdebug
condition|)
block|{
name|myprintf
argument_list|(
operator|(
literal|"Attempting unlock on %lx.%lx.%lx\n"
operator|,
name|cp
operator|->
name|c_fid
operator|.
name|Volume
operator|,
name|cp
operator|->
name|c_fid
operator|.
name|Vnode
operator|,
name|cp
operator|->
name|c_fid
operator|.
name|Unique
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|lockmgr
argument_list|(
operator|&
name|cp
operator|->
name|c_lock
argument_list|,
name|ap
operator|->
name|a_flags
operator||
name|LK_RELEASE
argument_list|,
operator|&
name|vp
operator|->
name|v_interlock
argument_list|,
name|td
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|coda_islocked
parameter_list|(
name|v
parameter_list|)
name|void
modifier|*
name|v
decl_stmt|;
block|{
comment|/* true args */
name|struct
name|vop_islocked_args
modifier|*
name|ap
init|=
name|v
decl_stmt|;
name|struct
name|cnode
modifier|*
name|cp
init|=
name|VTOC
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|ENTRY
expr_stmt|;
return|return
operator|(
name|lockstatus
argument_list|(
operator|&
name|cp
operator|->
name|c_lock
argument_list|,
name|ap
operator|->
name|a_td
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* How one looks up a vnode given a device/inode pair: */
end_comment

begin_function
name|int
name|coda_grab_vnode
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|ino_t
name|ino
parameter_list|,
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
parameter_list|)
block|{
comment|/* This is like VFS_VGET() or igetinode()! */
name|int
name|error
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|mp
operator|=
name|devtomp
argument_list|(
name|dev
argument_list|)
operator|)
condition|)
block|{
name|myprintf
argument_list|(
operator|(
literal|"coda_grab_vnode: devtomp(%#lx) returns NULL\n"
operator|,
operator|(
name|u_long
operator|)
name|dev2udev
argument_list|(
name|dev
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* XXX - ensure that nonzero-return means failure */
name|error
operator|=
name|VFS_VGET
argument_list|(
name|mp
argument_list|,
name|ino
argument_list|,
name|vpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|myprintf
argument_list|(
operator|(
literal|"coda_grab_vnode: iget/vget(%lx, %lu) returns %p, err %d\n"
operator|,
operator|(
name|u_long
operator|)
name|dev2udev
argument_list|(
name|dev
argument_list|)
operator|,
operator|(
name|u_long
operator|)
name|ino
operator|,
operator|(
name|void
operator|*
operator|)
operator|*
name|vpp
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|print_vattr
parameter_list|(
name|attr
parameter_list|)
name|struct
name|vattr
modifier|*
name|attr
decl_stmt|;
block|{
name|char
modifier|*
name|typestr
decl_stmt|;
switch|switch
condition|(
name|attr
operator|->
name|va_type
condition|)
block|{
case|case
name|VNON
case|:
name|typestr
operator|=
literal|"VNON"
expr_stmt|;
break|break;
case|case
name|VREG
case|:
name|typestr
operator|=
literal|"VREG"
expr_stmt|;
break|break;
case|case
name|VDIR
case|:
name|typestr
operator|=
literal|"VDIR"
expr_stmt|;
break|break;
case|case
name|VBLK
case|:
name|typestr
operator|=
literal|"VBLK"
expr_stmt|;
break|break;
case|case
name|VCHR
case|:
name|typestr
operator|=
literal|"VCHR"
expr_stmt|;
break|break;
case|case
name|VLNK
case|:
name|typestr
operator|=
literal|"VLNK"
expr_stmt|;
break|break;
case|case
name|VSOCK
case|:
name|typestr
operator|=
literal|"VSCK"
expr_stmt|;
break|break;
case|case
name|VFIFO
case|:
name|typestr
operator|=
literal|"VFFO"
expr_stmt|;
break|break;
case|case
name|VBAD
case|:
name|typestr
operator|=
literal|"VBAD"
expr_stmt|;
break|break;
default|default:
name|typestr
operator|=
literal|"????"
expr_stmt|;
break|break;
block|}
name|myprintf
argument_list|(
operator|(
literal|"attr: type %s mode %d uid %d gid %d fsid %d rdev %d\n"
operator|,
name|typestr
operator|,
operator|(
name|int
operator|)
name|attr
operator|->
name|va_mode
operator|,
operator|(
name|int
operator|)
name|attr
operator|->
name|va_uid
operator|,
operator|(
name|int
operator|)
name|attr
operator|->
name|va_gid
operator|,
operator|(
name|int
operator|)
name|attr
operator|->
name|va_fsid
operator|,
operator|(
name|int
operator|)
name|attr
operator|->
name|va_rdev
operator|)
argument_list|)
expr_stmt|;
name|myprintf
argument_list|(
operator|(
literal|"      fileid %d nlink %d size %d blocksize %d bytes %d\n"
operator|,
operator|(
name|int
operator|)
name|attr
operator|->
name|va_fileid
operator|,
operator|(
name|int
operator|)
name|attr
operator|->
name|va_nlink
operator|,
operator|(
name|int
operator|)
name|attr
operator|->
name|va_size
operator|,
operator|(
name|int
operator|)
name|attr
operator|->
name|va_blocksize
operator|,
operator|(
name|int
operator|)
name|attr
operator|->
name|va_bytes
operator|)
argument_list|)
expr_stmt|;
name|myprintf
argument_list|(
operator|(
literal|"      gen %ld flags %ld vaflags %d\n"
operator|,
name|attr
operator|->
name|va_gen
operator|,
name|attr
operator|->
name|va_flags
operator|,
name|attr
operator|->
name|va_vaflags
operator|)
argument_list|)
expr_stmt|;
name|myprintf
argument_list|(
operator|(
literal|"      atime sec %d nsec %d\n"
operator|,
operator|(
name|int
operator|)
name|attr
operator|->
name|va_atime
operator|.
name|tv_sec
operator|,
operator|(
name|int
operator|)
name|attr
operator|->
name|va_atime
operator|.
name|tv_nsec
operator|)
argument_list|)
expr_stmt|;
name|myprintf
argument_list|(
operator|(
literal|"      mtime sec %d nsec %d\n"
operator|,
operator|(
name|int
operator|)
name|attr
operator|->
name|va_mtime
operator|.
name|tv_sec
operator|,
operator|(
name|int
operator|)
name|attr
operator|->
name|va_mtime
operator|.
name|tv_nsec
operator|)
argument_list|)
expr_stmt|;
name|myprintf
argument_list|(
operator|(
literal|"      ctime sec %d nsec %d\n"
operator|,
operator|(
name|int
operator|)
name|attr
operator|->
name|va_ctime
operator|.
name|tv_sec
operator|,
operator|(
name|int
operator|)
name|attr
operator|->
name|va_ctime
operator|.
name|tv_nsec
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* How to print a ucred */
end_comment

begin_function
name|void
name|print_cred
parameter_list|(
name|cred
parameter_list|)
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|myprintf
argument_list|(
operator|(
literal|"ref %d\tuid %d\n"
operator|,
name|cred
operator|->
name|cr_ref
operator|,
name|cred
operator|->
name|cr_uid
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cred
operator|->
name|cr_ngroups
condition|;
name|i
operator|++
control|)
name|myprintf
argument_list|(
operator|(
literal|"\tgroup %d: (%d)\n"
operator|,
name|i
operator|,
name|cred
operator|->
name|cr_groups
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
name|myprintf
argument_list|(
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return a vnode for the given fid.  * If no cnode exists for this fid create one and put it  * in a table hashed by fid.Volume and fid.Vnode.  If the cnode for  * this fid is already in the table return it (ref count is  * incremented by coda_find.  The cnode will be flushed from the  * table when coda_inactive calls coda_unsave.  */
end_comment

begin_function
name|struct
name|cnode
modifier|*
name|make_coda_node
parameter_list|(
name|fid
parameter_list|,
name|vfsp
parameter_list|,
name|type
parameter_list|)
name|ViceFid
modifier|*
name|fid
decl_stmt|;
name|struct
name|mount
modifier|*
name|vfsp
decl_stmt|;
name|short
name|type
decl_stmt|;
block|{
name|struct
name|cnode
modifier|*
name|cp
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|coda_find
argument_list|(
name|fid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|cp
operator|=
name|coda_alloc
argument_list|()
expr_stmt|;
name|lockinit
argument_list|(
operator|&
name|cp
operator|->
name|c_lock
argument_list|,
name|PINOD
argument_list|,
literal|"cnode"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cp
operator|->
name|c_fid
operator|=
operator|*
name|fid
expr_stmt|;
name|err
operator|=
name|getnewvnode
argument_list|(
name|VT_CODA
argument_list|,
name|vfsp
argument_list|,
name|coda_vnodeop_p
argument_list|,
operator|&
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|panic
argument_list|(
literal|"coda: getnewvnode returned error %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
name|vp
operator|->
name|v_data
operator|=
name|cp
expr_stmt|;
name|vp
operator|->
name|v_type
operator|=
name|type
expr_stmt|;
name|cp
operator|->
name|c_vnode
operator|=
name|vp
expr_stmt|;
name|coda_save
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vref
argument_list|(
name|CTOV
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|cp
return|;
block|}
end_function

end_unit

