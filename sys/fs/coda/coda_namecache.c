begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *   *             Coda: an Experimental Distributed File System  *                              Release 3.1  *   *           Copyright (c) 1987-1998 Carnegie Mellon University  *                          All Rights Reserved  *   * Permission  to  use, copy, modify and distribute this software and its  * documentation is hereby granted,  provided  that  both  the  copyright  * notice  and  this  permission  notice  appear  in  all  copies  of the  * software, derivative works or  modified  versions,  and  any  portions  * thereof, and that both notices appear in supporting documentation, and  * that credit is given to Carnegie Mellon University  in  all  documents  * and publicity pertaining to direct or indirect use of this code or its  * derivatives.  *   * CODA IS AN EXPERIMENTAL SOFTWARE SYSTEM AND IS  KNOWN  TO  HAVE  BUGS,  * SOME  OF  WHICH MAY HAVE SERIOUS CONSEQUENCES.  CARNEGIE MELLON ALLOWS  * FREE USE OF THIS SOFTWARE IN ITS "AS IS" CONDITION.   CARNEGIE  MELLON  * DISCLAIMS  ANY  LIABILITY  OF  ANY  KIND  FOR  ANY  DAMAGES WHATSOEVER  * RESULTING DIRECTLY OR INDIRECTLY FROM THE USE OF THIS SOFTWARE  OR  OF  * ANY DERIVATIVE WORK.  *   * Carnegie  Mellon  encourages  users  of  this  software  to return any  * improvements or extensions that  they  make,  and  to  grant  Carnegie  * Mellon the rights to redistribute these changes without encumbrance.  *   * 	@(#) src/sys/cfs/cfs_namecache.c,v 1.1.1.1 1998/08/29 21:14:52 rvb Exp $  *  $Id: cfs_namecache.c,v 1.2 1998/09/02 19:09:53 rvb Exp $  *   */
end_comment

begin_comment
comment|/*   * Mach Operating System  * Copyright (c) 1990 Carnegie-Mellon University  * Copyright (c) 1989 Carnegie-Mellon University  * All rights reserved.  The CMU software License Agreement specifies  * the terms and conditions for use and redistribution.  */
end_comment

begin_comment
comment|/*  * This code was written for the Coda file system at Carnegie Mellon University.  * Contributers include David Steere, James Kistler, and M. Satyanarayanan.  */
end_comment

begin_comment
comment|/*  * HISTORY  * $Log: cfs_namecache.c,v $  * Revision 1.2  1998/09/02 19:09:53  rvb  * Pass2 complete  *  * Revision 1.1.1.1  1998/08/29 21:14:52  rvb  * Very Preliminary Coda  *  * Revision 1.11  1998/08/28 18:12:16  rvb  * Now it also works on FreeBSD -current.  This code will be  * committed to the FreeBSD -current and NetBSD -current  * trees.  It will then be tailored to the particular platform  * by flushing conditional code.  *  * Revision 1.10  1998/08/18 17:05:14  rvb  * Don't use __RCSID now  *  * Revision 1.9  1998/08/18 16:31:39  rvb  * Sync the code for NetBSD -current; test on 1.3 later  *  * Revision 1.8  98/01/31  20:53:10  rvb  * First version that works on FreeBSD 2.2.5  *   * Revision 1.7  98/01/23  11:53:39  rvb  * Bring RVB_CFS1_1 to HEAD  *   * Revision 1.6.2.4  98/01/23  11:21:02  rvb  * Sync with 2.2.5  *   * Revision 1.6.2.3  97/12/16  12:40:03  rvb  * Sync with 1.3  *   * Revision 1.6.2.2  97/12/09  16:07:10  rvb  * Sync with vfs/include/coda.h  *   * Revision 1.6.2.1  97/12/06  17:41:18  rvb  * Sync with peters coda.h  *   * Revision 1.6  97/12/05  10:39:13  rvb  * Read CHANGES  *   * Revision 1.5.4.7  97/11/25  08:08:43  rvb  * cfs_venus ... done; until cred/vattr change  *   * Revision 1.5.4.6  97/11/24  15:44:43  rvb  * Final cfs_venus.c w/o macros, but one locking bug  *   * Revision 1.5.4.5  97/11/20  11:46:38  rvb  * Capture current cfs_venus  *   * Revision 1.5.4.4  97/11/18  10:27:13  rvb  * cfs_nbsd.c is DEAD!!!; integrated into cfs_vf/vnops.c  * cfs_nb_foo and cfs_foo are joined  *   * Revision 1.5.4.3  97/11/13  22:02:57  rvb  * pass2 cfs_NetBSD.h mt  *   * Revision 1.5.4.2  97/11/12  12:09:35  rvb  * reorg pass1  *   * Revision 1.5.4.1  97/10/28  23:10:12  rvb  *>64Meg; venus can be killed!  *   * Revision 1.5  97/08/05  11:08:01  lily  * Removed cfsnc_replace, replaced it with a cfs_find, unhash, and  * rehash.  This fixes a cnode leak and a bug in which the fid is  * not actually replaced.  (cfs_namecache.c, cfsnc.h, cfs_subr.c)  *   * Revision 1.4  96/12/12  22:10:57  bnoble  * Fixed the "downcall invokes venus operation" deadlock in all known cases.  * There may be more  *   * Revision 1.3  1996/11/08 18:06:09  bnoble  * Minor changes in vnode operation signature, VOP_UPDATE signature, and  * some newly defined bits in the include files.  *  * Revision 1.2  1996/01/02 16:56:50  bnoble  * Added support for Coda MiniCache and raw inode calls (final commit)  *  * Revision 1.1.2.1  1995/12/20 01:57:15  bnoble  * Added CFS-specific files  *  * Revision 3.1.1.1  1995/03/04  19:07:57  bnoble  * Branch for NetBSD port revisions  *  * Revision 3.1  1995/03/04  19:07:56  bnoble  * Bump to major revision 3 to prepare for NetBSD port  *  * Revision 2.3  1994/10/14  09:57:54  dcs  * Made changes 'cause sun4s have braindead compilers  *  * Revision 2.2  94/08/28  19:37:35  luqi  * Add a new CFS_REPLACE call to allow venus to replace a ViceFid in the  * mini-cache.   *   * In "cfs.h":  * Add CFS_REPLACE decl.  *   * In "cfs_namecache.c":  * Add routine cfsnc_replace.  *   * In "cfs_subr.c":  * Add case-statement to process CFS_REPLACE.  *   * In "cfsnc.h":  * Add decl for CFSNC_REPLACE.  *   *   * Revision 2.1  94/07/21  16:25:15  satya  * Conversion to C++ 3.0; start of Coda Release 2.0  *  * Revision 1.2  92/10/27  17:58:21  lily  * merge kernel/latest and alpha/src/cfs  *   * Revision 2.3  92/09/30  14:16:20  mja  * 	call cfs_flush instead of calling inode_uncache_try directly   * 	(from dcs). Also...  *   * 	Substituted rvb's history blurb so that we agree with Mach 2.5 sources.  * 	[91/02/09            jjk]  *   * 	Added contributors blurb.  * 	[90/12/13            jjk]  *   * Revision 2.2  90/07/05  11:26:30  mrt  * 	Created for the Coda File System.  * 	[90/05/23            dcs]  *   * Revision 1.3  90/05/31  17:01:24  dcs  * Prepare for merge with facilities kernel.  *   *   */
end_comment

begin_comment
comment|/*  * This module contains the routines to implement the CFS name cache. The  * purpose of this cache is to reduce the cost of translating pathnames   * into Vice FIDs. Each entry in the cache contains the name of the file,  * the vnode (FID) of the parent directory, and the cred structure of the  * user accessing the file.  *  * The first time a file is accessed, it is looked up by the local Venus  * which first insures that the user has access to the file. In addition  * we are guaranteed that Venus will invalidate any name cache entries in  * case the user no longer should be able to access the file. For these  * reasons we do not need to keep access list information as well as a  * cred structure for each entry.  *  * The table can be accessed through the routines cnc_init(), cnc_enter(),  * cnc_lookup(), cnc_rmfidcred(), cnc_rmfid(), cnc_rmcred(), and cnc_purge().  * There are several other routines which aid in the implementation of the  * hash table.  */
end_comment

begin_comment
comment|/*  * NOTES: rvb@cs  * 1.	The name cache holds a reference to every vnode in it.  Hence files can not be  *	 closed or made inactive until they are released.  * 2.	cfsnc_name(cp) was added to get a name for a cnode pointer for debugging.  * 3.	cfsnc_find() has debug code to detect when entries are stored with different  *	 credentials.  We don't understand yet, if/how entries are NOT EQ but still  *	 EQUAL  * 4.	I wonder if this name cache could be replace by the vnode name cache.  *	The latter has no zapping functions, so probably not.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/ucred.h>
end_include

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|insque
end_ifndef

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* insque */
end_comment

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<cfs/coda.h>
end_include

begin_include
include|#
directive|include
file|<cfs/cnode.h>
end_include

begin_include
include|#
directive|include
file|<cfs/cfsnc.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_comment
comment|/* for printcred */
end_comment

begin_include
include|#
directive|include
file|<cfs/cfs_vnodeops.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*   * Declaration of the name cache data structure.  */
end_comment

begin_decl_stmt
name|int
name|cfsnc_use
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indicate use of CFS Name Cache */
end_comment

begin_decl_stmt
name|int
name|cfsnc_size
init|=
name|CFSNC_CACHESIZE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size of the cache */
end_comment

begin_decl_stmt
name|int
name|cfsnc_hashsize
init|=
name|CFSNC_HASHSIZE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size of the primary hash */
end_comment

begin_decl_stmt
name|struct
name|cfscache
modifier|*
name|cfsncheap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointer to the cache entries */
end_comment

begin_decl_stmt
name|struct
name|cfshash
modifier|*
name|cfsnchash
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* hash table of cfscache pointers */
end_comment

begin_decl_stmt
name|struct
name|cfslru
name|cfsnc_lru
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* head of lru chain */
end_comment

begin_decl_stmt
name|struct
name|cfsnc_statistics
name|cfsnc_stat
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Keep various stats */
end_comment

begin_comment
comment|/*   * for testing purposes  */
end_comment

begin_decl_stmt
name|int
name|cfsnc_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Entry points for the CFS Name Cache  */
end_comment

begin_function_decl
specifier|static
name|struct
name|cfscache
modifier|*
name|cfsnc_find
parameter_list|(
name|struct
name|cnode
modifier|*
name|dcp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|int
name|hash
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cfsnc_remove
parameter_list|(
name|struct
name|cfscache
modifier|*
name|cncp
parameter_list|,
name|enum
name|dc_status
name|dcstat
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*    * Initialize the cache, the LRU structure and the Hash structure(s)  */
end_comment

begin_define
define|#
directive|define
name|TOTAL_CACHE_SIZE
value|(sizeof(struct cfscache) * cfsnc_size)
end_define

begin_define
define|#
directive|define
name|TOTAL_HASH_SIZE
value|(sizeof(struct cfshash)  * cfsnc_hashsize)
end_define

begin_decl_stmt
name|int
name|cfsnc_initialized
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initially the cache has not been initialized */
end_comment

begin_function
name|void
name|cfsnc_init
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* zero the statistics structure */
name|bzero
argument_list|(
operator|&
name|cfsnc_stat
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|cfsnc_statistics
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"CFS NAME CACHE: CACHE %d, HASH TBL %d\n"
argument_list|,
name|CFSNC_CACHESIZE
argument_list|,
name|CFSNC_HASHSIZE
argument_list|)
expr_stmt|;
name|CFS_ALLOC
argument_list|(
name|cfsncheap
argument_list|,
expr|struct
name|cfscache
operator|*
argument_list|,
name|TOTAL_CACHE_SIZE
argument_list|)
expr_stmt|;
name|CFS_ALLOC
argument_list|(
name|cfsnchash
argument_list|,
expr|struct
name|cfshash
operator|*
argument_list|,
name|TOTAL_HASH_SIZE
argument_list|)
expr_stmt|;
name|cfsnc_lru
operator|.
name|lru_next
operator|=
name|cfsnc_lru
operator|.
name|lru_prev
operator|=
operator|(
expr|struct
name|cfscache
operator|*
operator|)
name|LRU_PART
argument_list|(
operator|&
name|cfsnc_lru
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cfsnc_size
condition|;
name|i
operator|++
control|)
block|{
comment|/* initialize the heap */
name|CFSNC_LRUINS
argument_list|(
operator|&
name|cfsncheap
index|[
name|i
index|]
argument_list|,
operator|&
name|cfsnc_lru
argument_list|)
expr_stmt|;
name|CFSNC_HSHNUL
argument_list|(
operator|&
name|cfsncheap
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|cfsncheap
index|[
name|i
index|]
operator|.
name|cp
operator|=
name|cfsncheap
index|[
name|i
index|]
operator|.
name|dcp
operator|=
operator|(
expr|struct
name|cnode
operator|*
operator|)
literal|0
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cfsnc_hashsize
condition|;
name|i
operator|++
control|)
block|{
comment|/* initialize the hashtable */
name|CFSNC_HSHNUL
argument_list|(
operator|(
expr|struct
name|cfscache
operator|*
operator|)
operator|&
name|cfsnchash
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|cfsnc_initialized
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Auxillary routines -- shouldn't be entry points  */
end_comment

begin_function
specifier|static
name|struct
name|cfscache
modifier|*
name|cfsnc_find
parameter_list|(
name|dcp
parameter_list|,
name|name
parameter_list|,
name|namelen
parameter_list|,
name|cred
parameter_list|,
name|hash
parameter_list|)
name|struct
name|cnode
modifier|*
name|dcp
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|namelen
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|int
name|hash
decl_stmt|;
block|{
comment|/*  	 * hash to find the appropriate bucket, look through the chain 	 * for the right entry (especially right cred, unless cred == 0)  	 */
name|struct
name|cfscache
modifier|*
name|cncp
decl_stmt|;
name|int
name|count
init|=
literal|1
decl_stmt|;
name|CFSNC_DEBUG
argument_list|(
argument|CFSNC_FIND
argument_list|,
argument|myprintf((
literal|"cfsnc_find(dcp %p, name %s, len %d, cred %p, hash %d\n"
argument|, 			   dcp, name, namelen, cred, hash));
argument_list|)
for|for
control|(
name|cncp
operator|=
name|cfsnchash
index|[
name|hash
index|]
operator|.
name|hash_next
init|;
name|cncp
operator|!=
operator|(
expr|struct
name|cfscache
operator|*
operator|)
operator|&
name|cfsnchash
index|[
name|hash
index|]
condition|;
name|cncp
operator|=
name|cncp
operator|->
name|hash_next
operator|,
name|count
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|CFS_NAMEMATCH
argument_list|(
name|cncp
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|,
name|dcp
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|cred
operator|==
literal|0
operator|)
operator|||
operator|(
name|cncp
operator|->
name|cred
operator|==
name|cred
operator|)
operator|)
condition|)
block|{
comment|/* compare cr_uid instead */
name|cfsnc_stat
operator|.
name|Search_len
operator|+=
name|count
expr_stmt|;
return|return
operator|(
name|cncp
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
elseif|else
if|if
condition|(
name|CFS_NAMEMATCH
argument_list|(
name|cncp
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|,
name|dcp
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"cfsnc_find: name %s, new cred = %p, cred = %p\n"
argument_list|,
name|name
argument_list|,
name|cred
argument_list|,
name|cncp
operator|->
name|cred
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"nref %d, nuid %d, ngid %d // oref %d, ocred %d, ogid %d\n"
argument_list|,
name|cred
operator|->
name|cr_ref
argument_list|,
name|cred
operator|->
name|cr_uid
argument_list|,
name|cred
operator|->
name|cr_gid
argument_list|,
name|cncp
operator|->
name|cred
operator|->
name|cr_ref
argument_list|,
name|cncp
operator|->
name|cred
operator|->
name|cr_uid
argument_list|,
name|cncp
operator|->
name|cred
operator|->
name|cr_gid
argument_list|)
expr_stmt|;
name|print_cred
argument_list|(
name|cred
argument_list|)
expr_stmt|;
name|print_cred
argument_list|(
name|cncp
operator|->
name|cred
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
return|return
operator|(
operator|(
expr|struct
name|cfscache
operator|*
operator|)
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Enter a new (dir cnode, name) pair into the cache, updating the  * LRU and Hash as needed.  */
end_comment

begin_function
name|void
name|cfsnc_enter
parameter_list|(
name|dcp
parameter_list|,
name|name
parameter_list|,
name|namelen
parameter_list|,
name|cred
parameter_list|,
name|cp
parameter_list|)
name|struct
name|cnode
modifier|*
name|dcp
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|namelen
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|struct
name|cnode
modifier|*
name|cp
decl_stmt|;
block|{
name|struct
name|cfscache
modifier|*
name|cncp
decl_stmt|;
name|int
name|hash
decl_stmt|;
if|if
condition|(
name|cfsnc_use
operator|==
literal|0
condition|)
comment|/* Cache is off */
return|return;
name|CFSNC_DEBUG
argument_list|(
argument|CFSNC_ENTER
argument_list|,
argument|myprintf((
literal|"Enter: dcp %p cp %p name %s cred %p \n"
argument|, 		       dcp, cp, name, cred));
argument_list|)
if|if
condition|(
name|namelen
operator|>
name|CFSNC_NAMELEN
condition|)
block|{
name|CFSNC_DEBUG
argument_list|(
argument|CFSNC_ENTER
argument_list|,
argument|myprintf((
literal|"long name enter %s\n"
argument|,name));
argument_list|)
name|cfsnc_stat
operator|.
name|long_name_enters
operator|++
expr_stmt|;
comment|/* record stats */
return|return;
block|}
name|hash
operator|=
name|CFSNC_HASH
argument_list|(
name|name
argument_list|,
name|namelen
argument_list|,
name|dcp
argument_list|)
expr_stmt|;
name|cncp
operator|=
name|cfsnc_find
argument_list|(
name|dcp
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|,
name|cred
argument_list|,
name|hash
argument_list|)
expr_stmt|;
if|if
condition|(
name|cncp
operator|!=
operator|(
expr|struct
name|cfscache
operator|*
operator|)
literal|0
condition|)
block|{
name|cfsnc_stat
operator|.
name|dbl_enters
operator|++
expr_stmt|;
comment|/* duplicate entry */
return|return;
block|}
name|cfsnc_stat
operator|.
name|enters
operator|++
expr_stmt|;
comment|/* record the enters statistic */
comment|/* Grab the next element in the lru chain */
name|cncp
operator|=
name|CFSNC_LRUGET
argument_list|(
name|cfsnc_lru
argument_list|)
expr_stmt|;
name|CFSNC_LRUREM
argument_list|(
name|cncp
argument_list|)
expr_stmt|;
comment|/* remove it from the lists */
if|if
condition|(
name|CFSNC_VALID
argument_list|(
name|cncp
argument_list|)
condition|)
block|{
comment|/* Seems really ugly, but we have to decrement the appropriate 	   hash bucket length here, so we have to find the hash bucket 	   */
name|cfsnchash
index|[
name|CFSNC_HASH
argument_list|(
name|cncp
operator|->
name|name
argument_list|,
name|cncp
operator|->
name|namelen
argument_list|,
name|cncp
operator|->
name|dcp
argument_list|)
index|]
operator|.
name|length
operator|--
expr_stmt|;
name|cfsnc_stat
operator|.
name|lru_rm
operator|++
expr_stmt|;
comment|/* zapped a valid entry */
name|CFSNC_HSHREM
argument_list|(
name|cncp
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|CTOV
argument_list|(
name|cncp
operator|->
name|dcp
argument_list|)
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|CTOV
argument_list|(
name|cncp
operator|->
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|crfree
argument_list|(
name|cncp
operator|->
name|cred
argument_list|)
expr_stmt|;
block|}
comment|/*      * Put a hold on the current vnodes and fill in the cache entry.      */
name|vref
argument_list|(
name|CTOV
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|vref
argument_list|(
name|CTOV
argument_list|(
name|dcp
argument_list|)
argument_list|)
expr_stmt|;
name|crhold
argument_list|(
name|cred
argument_list|)
expr_stmt|;
name|cncp
operator|->
name|dcp
operator|=
name|dcp
expr_stmt|;
name|cncp
operator|->
name|cp
operator|=
name|cp
expr_stmt|;
name|cncp
operator|->
name|namelen
operator|=
name|namelen
expr_stmt|;
name|cncp
operator|->
name|cred
operator|=
name|cred
expr_stmt|;
name|bcopy
argument_list|(
name|name
argument_list|,
name|cncp
operator|->
name|name
argument_list|,
operator|(
name|unsigned
operator|)
name|namelen
argument_list|)
expr_stmt|;
comment|/* Insert into the lru and hash chains. */
name|CFSNC_LRUINS
argument_list|(
name|cncp
argument_list|,
operator|&
name|cfsnc_lru
argument_list|)
expr_stmt|;
name|CFSNC_HSHINS
argument_list|(
name|cncp
argument_list|,
operator|&
name|cfsnchash
index|[
name|hash
index|]
argument_list|)
expr_stmt|;
name|cfsnchash
index|[
name|hash
index|]
operator|.
name|length
operator|++
expr_stmt|;
comment|/* Used for tuning */
name|CFSNC_DEBUG
argument_list|(
argument|CFSNC_PRINTCFSNC
argument_list|,
argument|print_cfsnc();
argument_list|)
block|}
end_function

begin_comment
comment|/*  * Find the (dir cnode, name) pair in the cache, if it's cred  * matches the input, return it, otherwise return 0  */
end_comment

begin_function
name|struct
name|cnode
modifier|*
name|cfsnc_lookup
parameter_list|(
name|dcp
parameter_list|,
name|name
parameter_list|,
name|namelen
parameter_list|,
name|cred
parameter_list|)
name|struct
name|cnode
modifier|*
name|dcp
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|namelen
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
block|{
name|int
name|hash
decl_stmt|;
name|struct
name|cfscache
modifier|*
name|cncp
decl_stmt|;
if|if
condition|(
name|cfsnc_use
operator|==
literal|0
condition|)
comment|/* Cache is off */
return|return
operator|(
operator|(
expr|struct
name|cnode
operator|*
operator|)
literal|0
operator|)
return|;
if|if
condition|(
name|namelen
operator|>
name|CFSNC_NAMELEN
condition|)
block|{
name|CFSNC_DEBUG
argument_list|(
argument|CFSNC_LOOKUP
argument_list|,
argument|myprintf((
literal|"long name lookup %s\n"
argument|,name));
argument_list|)
name|cfsnc_stat
operator|.
name|long_name_lookups
operator|++
expr_stmt|;
comment|/* record stats */
return|return
operator|(
operator|(
expr|struct
name|cnode
operator|*
operator|)
literal|0
operator|)
return|;
block|}
comment|/* Use the hash function to locate the starting point, 	   then the search routine to go down the list looking for 	   the correct cred.  	 */
name|hash
operator|=
name|CFSNC_HASH
argument_list|(
name|name
argument_list|,
name|namelen
argument_list|,
name|dcp
argument_list|)
expr_stmt|;
name|cncp
operator|=
name|cfsnc_find
argument_list|(
name|dcp
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|,
name|cred
argument_list|,
name|hash
argument_list|)
expr_stmt|;
if|if
condition|(
name|cncp
operator|==
operator|(
expr|struct
name|cfscache
operator|*
operator|)
literal|0
condition|)
block|{
name|cfsnc_stat
operator|.
name|misses
operator|++
expr_stmt|;
comment|/* record miss */
return|return
operator|(
operator|(
expr|struct
name|cnode
operator|*
operator|)
literal|0
operator|)
return|;
block|}
name|cfsnc_stat
operator|.
name|hits
operator|++
expr_stmt|;
comment|/* put this entry at the end of the LRU */
name|CFSNC_LRUREM
argument_list|(
name|cncp
argument_list|)
expr_stmt|;
name|CFSNC_LRUINS
argument_list|(
name|cncp
argument_list|,
operator|&
name|cfsnc_lru
argument_list|)
expr_stmt|;
comment|/* move it to the front of the hash chain */
comment|/* don't need to change the hash bucket length */
name|CFSNC_HSHREM
argument_list|(
name|cncp
argument_list|)
expr_stmt|;
name|CFSNC_HSHINS
argument_list|(
name|cncp
argument_list|,
operator|&
name|cfsnchash
index|[
name|hash
index|]
argument_list|)
expr_stmt|;
name|CFSNC_DEBUG
argument_list|(
argument|CFSNC_LOOKUP
argument_list|,
argument|printf(
literal|"lookup: dcp %p, name %s, cred %p = cp %p\n"
argument|, 			dcp, name, cred, cncp->cp);
argument_list|)
return|return
operator|(
name|cncp
operator|->
name|cp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cfsnc_remove
parameter_list|(
name|cncp
parameter_list|,
name|dcstat
parameter_list|)
name|struct
name|cfscache
modifier|*
name|cncp
decl_stmt|;
name|enum
name|dc_status
name|dcstat
decl_stmt|;
block|{
comment|/*  	 * remove an entry -- vrele(cncp->dcp, cp), crfree(cred), 	 * remove it from it's hash chain, and 	 * place it at the head of the lru list. 	 */
name|CFSNC_DEBUG
argument_list|(
argument|CFSNC_REMOVE
argument_list|,
argument|myprintf((
literal|"cfsnc_remove %s from parent %lx.%lx.%lx\n"
argument|, 			   cncp->name, (cncp->dcp)->c_fid.Volume, 			   (cncp->dcp)->c_fid.Vnode, (cncp->dcp)->c_fid.Unique));
argument_list|)
name|CFSNC_HSHREM
argument_list|(
name|cncp
argument_list|)
expr_stmt|;
name|CFSNC_HSHNUL
argument_list|(
name|cncp
argument_list|)
expr_stmt|;
comment|/* have it be a null chain */
if|if
condition|(
operator|(
name|dcstat
operator|==
name|IS_DOWNCALL
operator|)
operator|&&
operator|(
name|CTOV
argument_list|(
name|cncp
operator|->
name|dcp
argument_list|)
operator|->
name|v_usecount
operator|==
literal|1
operator|)
condition|)
block|{
name|cncp
operator|->
name|dcp
operator|->
name|c_flags
operator||=
name|C_PURGING
expr_stmt|;
block|}
name|vrele
argument_list|(
name|CTOV
argument_list|(
name|cncp
operator|->
name|dcp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dcstat
operator|==
name|IS_DOWNCALL
operator|)
operator|&&
operator|(
name|CTOV
argument_list|(
name|cncp
operator|->
name|cp
argument_list|)
operator|->
name|v_usecount
operator|==
literal|1
operator|)
condition|)
block|{
name|cncp
operator|->
name|cp
operator|->
name|c_flags
operator||=
name|C_PURGING
expr_stmt|;
block|}
name|vrele
argument_list|(
name|CTOV
argument_list|(
name|cncp
operator|->
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|crfree
argument_list|(
name|cncp
operator|->
name|cred
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|DATA_PART
argument_list|(
name|cncp
argument_list|)
argument_list|,
name|DATA_SIZE
argument_list|)
expr_stmt|;
comment|/* Put the null entry just after the least-recently-used entry */
comment|/* LRU_TOP adjusts the pointer to point to the top of the structure. */
name|CFSNC_LRUREM
argument_list|(
name|cncp
argument_list|)
expr_stmt|;
name|CFSNC_LRUINS
argument_list|(
name|cncp
argument_list|,
name|LRU_TOP
argument_list|(
name|cfsnc_lru
operator|.
name|lru_prev
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove all entries with a parent which has the input fid.  */
end_comment

begin_function
name|void
name|cfsnc_zapParentfid
parameter_list|(
name|fid
parameter_list|,
name|dcstat
parameter_list|)
name|ViceFid
modifier|*
name|fid
decl_stmt|;
name|enum
name|dc_status
name|dcstat
decl_stmt|;
block|{
comment|/* To get to a specific fid, we might either have another hashing 	   function or do a sequential search through the cache for the 	   appropriate entries. The later may be acceptable since I don't 	   think callbacks or whatever Case 1 covers are frequent occurences. 	 */
name|struct
name|cfscache
modifier|*
name|cncp
decl_stmt|,
modifier|*
name|ncncp
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|cfsnc_use
operator|==
literal|0
condition|)
comment|/* Cache is off */
return|return;
name|CFSNC_DEBUG
argument_list|(
argument|CFSNC_ZAPPFID
argument_list|,
argument|myprintf((
literal|"ZapParent: fid 0x%lx, 0x%lx, 0x%lx \n"
argument|, 			fid->Volume, fid->Vnode, fid->Unique));
argument_list|)
name|cfsnc_stat
operator|.
name|zapPfids
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cfsnc_hashsize
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * Need to save the hash_next pointer in case we remove the 		 * entry. remove causes hash_next to point to itself. 		 */
for|for
control|(
name|cncp
operator|=
name|cfsnchash
index|[
name|i
index|]
operator|.
name|hash_next
init|;
name|cncp
operator|!=
operator|(
expr|struct
name|cfscache
operator|*
operator|)
operator|&
name|cfsnchash
index|[
name|i
index|]
condition|;
name|cncp
operator|=
name|ncncp
control|)
block|{
name|ncncp
operator|=
name|cncp
operator|->
name|hash_next
expr_stmt|;
if|if
condition|(
operator|(
name|cncp
operator|->
name|dcp
operator|->
name|c_fid
operator|.
name|Volume
operator|==
name|fid
operator|->
name|Volume
operator|)
operator|&&
operator|(
name|cncp
operator|->
name|dcp
operator|->
name|c_fid
operator|.
name|Vnode
operator|==
name|fid
operator|->
name|Vnode
operator|)
operator|&&
operator|(
name|cncp
operator|->
name|dcp
operator|->
name|c_fid
operator|.
name|Unique
operator|==
name|fid
operator|->
name|Unique
operator|)
condition|)
block|{
name|cfsnchash
index|[
name|i
index|]
operator|.
name|length
operator|--
expr_stmt|;
comment|/* Used for tuning */
name|cfsnc_remove
argument_list|(
name|cncp
argument_list|,
name|dcstat
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Remove all entries which have the same fid as the input  */
end_comment

begin_function
name|void
name|cfsnc_zapfid
parameter_list|(
name|fid
parameter_list|,
name|dcstat
parameter_list|)
name|ViceFid
modifier|*
name|fid
decl_stmt|;
name|enum
name|dc_status
name|dcstat
decl_stmt|;
block|{
comment|/* See comment for zapParentfid. This routine will be used 	   if attributes are being cached.  	 */
name|struct
name|cfscache
modifier|*
name|cncp
decl_stmt|,
modifier|*
name|ncncp
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|cfsnc_use
operator|==
literal|0
condition|)
comment|/* Cache is off */
return|return;
name|CFSNC_DEBUG
argument_list|(
argument|CFSNC_ZAPFID
argument_list|,
argument|myprintf((
literal|"Zapfid: fid 0x%lx, 0x%lx, 0x%lx \n"
argument|, 			fid->Volume, fid->Vnode, fid->Unique));
argument_list|)
name|cfsnc_stat
operator|.
name|zapFids
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cfsnc_hashsize
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|cncp
operator|=
name|cfsnchash
index|[
name|i
index|]
operator|.
name|hash_next
init|;
name|cncp
operator|!=
operator|(
expr|struct
name|cfscache
operator|*
operator|)
operator|&
name|cfsnchash
index|[
name|i
index|]
condition|;
name|cncp
operator|=
name|ncncp
control|)
block|{
name|ncncp
operator|=
name|cncp
operator|->
name|hash_next
expr_stmt|;
if|if
condition|(
operator|(
name|cncp
operator|->
name|cp
operator|->
name|c_fid
operator|.
name|Volume
operator|==
name|fid
operator|->
name|Volume
operator|)
operator|&&
operator|(
name|cncp
operator|->
name|cp
operator|->
name|c_fid
operator|.
name|Vnode
operator|==
name|fid
operator|->
name|Vnode
operator|)
operator|&&
operator|(
name|cncp
operator|->
name|cp
operator|->
name|c_fid
operator|.
name|Unique
operator|==
name|fid
operator|->
name|Unique
operator|)
condition|)
block|{
name|cfsnchash
index|[
name|i
index|]
operator|.
name|length
operator|--
expr_stmt|;
comment|/* Used for tuning */
name|cfsnc_remove
argument_list|(
name|cncp
argument_list|,
name|dcstat
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*   * Remove all entries which match the fid and the cred  */
end_comment

begin_function
name|void
name|cfsnc_zapvnode
parameter_list|(
name|fid
parameter_list|,
name|cred
parameter_list|,
name|dcstat
parameter_list|)
name|ViceFid
modifier|*
name|fid
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|enum
name|dc_status
name|dcstat
decl_stmt|;
block|{
comment|/* See comment for zapfid. I don't think that one would ever 	   want to zap a file with a specific cred from the kernel. 	   We'll leave this one unimplemented. 	 */
if|if
condition|(
name|cfsnc_use
operator|==
literal|0
condition|)
comment|/* Cache is off */
return|return;
name|CFSNC_DEBUG
argument_list|(
argument|CFSNC_ZAPVNODE
argument_list|,
argument|myprintf((
literal|"Zapvnode: fid 0x%lx, 0x%lx, 0x%lx cred %p\n"
argument|, 			  fid->Volume, fid->Vnode, fid->Unique, cred));
argument_list|)
block|}
end_function

begin_comment
comment|/*  * Remove all entries which have the (dir vnode, name) pair  */
end_comment

begin_function
name|void
name|cfsnc_zapfile
parameter_list|(
name|dcp
parameter_list|,
name|name
parameter_list|,
name|namelen
parameter_list|)
name|struct
name|cnode
modifier|*
name|dcp
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|namelen
decl_stmt|;
block|{
comment|/* use the hash function to locate the file, then zap all  	   entries of it regardless of the cred. 	 */
name|struct
name|cfscache
modifier|*
name|cncp
decl_stmt|;
name|int
name|hash
decl_stmt|;
if|if
condition|(
name|cfsnc_use
operator|==
literal|0
condition|)
comment|/* Cache is off */
return|return;
name|CFSNC_DEBUG
argument_list|(
argument|CFSNC_ZAPFILE
argument_list|,
argument|myprintf((
literal|"Zapfile: dcp %p name %s \n"
argument|, 			  dcp, name));
argument_list|)
if|if
condition|(
name|namelen
operator|>
name|CFSNC_NAMELEN
condition|)
block|{
name|cfsnc_stat
operator|.
name|long_remove
operator|++
expr_stmt|;
comment|/* record stats */
return|return;
block|}
name|cfsnc_stat
operator|.
name|zapFile
operator|++
expr_stmt|;
name|hash
operator|=
name|CFSNC_HASH
argument_list|(
name|name
argument_list|,
name|namelen
argument_list|,
name|dcp
argument_list|)
expr_stmt|;
name|cncp
operator|=
name|cfsnc_find
argument_list|(
name|dcp
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|,
literal|0
argument_list|,
name|hash
argument_list|)
expr_stmt|;
while|while
condition|(
name|cncp
condition|)
block|{
name|cfsnchash
index|[
name|hash
index|]
operator|.
name|length
operator|--
expr_stmt|;
comment|/* Used for tuning */
name|cfsnc_remove
argument_list|(
name|cncp
argument_list|,
name|NOT_DOWNCALL
argument_list|)
expr_stmt|;
name|cncp
operator|=
name|cfsnc_find
argument_list|(
name|dcp
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|,
literal|0
argument_list|,
name|hash
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*   * Remove all the entries for a particular user. Used when tokens expire.  * A user is determined by his/her effective user id (id_uid).  */
end_comment

begin_function
name|void
name|cfsnc_purge_user
parameter_list|(
name|uid
parameter_list|,
name|dcstat
parameter_list|)
name|vuid_t
name|uid
decl_stmt|;
name|enum
name|dc_status
name|dcstat
decl_stmt|;
block|{
comment|/*  	 * I think the best approach is to go through the entire cache 	 * via HASH or whatever and zap all entries which match the 	 * input cred. Or just flush the whole cache.  It might be 	 * best to go through on basis of LRU since cache will almost 	 * always be full and LRU is more straightforward.   	 */
name|struct
name|cfscache
modifier|*
name|cncp
decl_stmt|,
modifier|*
name|ncncp
decl_stmt|;
name|int
name|hash
decl_stmt|;
if|if
condition|(
name|cfsnc_use
operator|==
literal|0
condition|)
comment|/* Cache is off */
return|return;
name|CFSNC_DEBUG
argument_list|(
argument|CFSNC_PURGEUSER
argument_list|,
argument|myprintf((
literal|"ZapDude: uid %lx\n"
argument|, uid));
argument_list|)
name|cfsnc_stat
operator|.
name|zapUsers
operator|++
expr_stmt|;
for|for
control|(
name|cncp
operator|=
name|CFSNC_LRUGET
argument_list|(
name|cfsnc_lru
argument_list|)
init|;
name|cncp
operator|!=
operator|(
expr|struct
name|cfscache
operator|*
operator|)
operator|(
operator|&
name|cfsnc_lru
operator|)
condition|;
name|cncp
operator|=
name|ncncp
control|)
block|{
name|ncncp
operator|=
name|CFSNC_LRUGET
argument_list|(
operator|*
name|cncp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|CFSNC_VALID
argument_list|(
name|cncp
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|cncp
operator|->
name|cred
operator|)
operator|->
name|cr_uid
operator|==
name|uid
operator|)
condition|)
block|{
comment|/* Seems really ugly, but we have to decrement the appropriate 			   hash bucket length here, so we have to find the hash bucket 			   */
name|hash
operator|=
name|CFSNC_HASH
argument_list|(
name|cncp
operator|->
name|name
argument_list|,
name|cncp
operator|->
name|namelen
argument_list|,
name|cncp
operator|->
name|dcp
argument_list|)
expr_stmt|;
name|cfsnchash
index|[
name|hash
index|]
operator|.
name|length
operator|--
expr_stmt|;
comment|/* For performance tuning */
name|cfsnc_remove
argument_list|(
name|cncp
argument_list|,
name|dcstat
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Flush the entire name cache. In response to a flush of the Venus cache.  */
end_comment

begin_function
name|void
name|cfsnc_flush
parameter_list|(
name|dcstat
parameter_list|)
name|enum
name|dc_status
name|dcstat
decl_stmt|;
block|{
comment|/* One option is to deallocate the current name cache and 	   call init to start again. Or just deallocate, then rebuild. 	   Or again, we could just go through the array and zero the  	   appropriate fields.  	 */
comment|/*  	 * Go through the whole lru chain and kill everything as we go. 	 * I don't use remove since that would rebuild the lru chain 	 * as it went and that seemed unneccesary. 	 */
name|struct
name|cfscache
modifier|*
name|cncp
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|cfsnc_use
operator|==
literal|0
condition|)
comment|/* Cache is off */
return|return;
name|cfsnc_stat
operator|.
name|Flushes
operator|++
expr_stmt|;
for|for
control|(
name|cncp
operator|=
name|CFSNC_LRUGET
argument_list|(
name|cfsnc_lru
argument_list|)
init|;
name|cncp
operator|!=
operator|(
expr|struct
name|cfscache
operator|*
operator|)
operator|&
name|cfsnc_lru
condition|;
name|cncp
operator|=
name|CFSNC_LRUGET
argument_list|(
operator|*
name|cncp
argument_list|)
control|)
block|{
if|if
condition|(
name|CFSNC_VALID
argument_list|(
name|cncp
argument_list|)
condition|)
block|{
name|CFSNC_HSHREM
argument_list|(
name|cncp
argument_list|)
expr_stmt|;
comment|/* only zero valid nodes */
name|CFSNC_HSHNUL
argument_list|(
name|cncp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dcstat
operator|==
name|IS_DOWNCALL
operator|)
operator|&&
operator|(
name|CTOV
argument_list|(
name|cncp
operator|->
name|dcp
argument_list|)
operator|->
name|v_usecount
operator|==
literal|1
operator|)
condition|)
block|{
name|cncp
operator|->
name|dcp
operator|->
name|c_flags
operator||=
name|C_PURGING
expr_stmt|;
block|}
name|vrele
argument_list|(
name|CTOV
argument_list|(
name|cncp
operator|->
name|dcp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|CTOV
argument_list|(
name|cncp
operator|->
name|cp
argument_list|)
operator|->
name|v_flag
operator|&
name|VTEXT
condition|)
block|{
if|if
condition|(
name|cfs_vmflush
argument_list|(
name|cncp
operator|->
name|cp
argument_list|)
condition|)
name|CFSDEBUG
argument_list|(
argument|CFS_FLUSH
argument_list|,
argument|myprintf((
literal|"cfsnc_flush: (%lx.%lx.%lx) busy\n"
argument|, cncp->cp->c_fid.Volume, cncp->cp->c_fid.Vnode, cncp->cp->c_fid.Unique));
argument_list|)
block|}
if|if
condition|(
operator|(
name|dcstat
operator|==
name|IS_DOWNCALL
operator|)
operator|&&
operator|(
name|CTOV
argument_list|(
name|cncp
operator|->
name|cp
argument_list|)
operator|->
name|v_usecount
operator|==
literal|1
operator|)
condition|)
block|{
name|cncp
operator|->
name|cp
operator|->
name|c_flags
operator||=
name|C_PURGING
expr_stmt|;
block|}
name|vrele
argument_list|(
name|CTOV
argument_list|(
name|cncp
operator|->
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|crfree
argument_list|(
name|cncp
operator|->
name|cred
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|DATA_PART
argument_list|(
name|cncp
argument_list|)
argument_list|,
name|DATA_SIZE
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cfsnc_hashsize
condition|;
name|i
operator|++
control|)
name|cfsnchash
index|[
name|i
index|]
operator|.
name|length
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Debugging routines  */
end_comment

begin_comment
comment|/*   * This routine should print out all the hash chains to the console.  */
end_comment

begin_function
name|void
name|print_cfsnc
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|hash
decl_stmt|;
name|struct
name|cfscache
modifier|*
name|cncp
decl_stmt|;
for|for
control|(
name|hash
operator|=
literal|0
init|;
name|hash
operator|<
name|cfsnc_hashsize
condition|;
name|hash
operator|++
control|)
block|{
name|myprintf
argument_list|(
operator|(
literal|"\nhash %d\n"
operator|,
name|hash
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|cncp
operator|=
name|cfsnchash
index|[
name|hash
index|]
operator|.
name|hash_next
init|;
name|cncp
operator|!=
operator|(
expr|struct
name|cfscache
operator|*
operator|)
operator|&
name|cfsnchash
index|[
name|hash
index|]
condition|;
name|cncp
operator|=
name|cncp
operator|->
name|hash_next
control|)
block|{
name|myprintf
argument_list|(
operator|(
literal|"cp %p dcp %p cred %p name %s\n"
operator|,
name|cncp
operator|->
name|cp
operator|,
name|cncp
operator|->
name|dcp
operator|,
name|cncp
operator|->
name|cred
operator|,
name|cncp
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|cfsnc_gather_stats
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|max
init|=
literal|0
decl_stmt|,
name|sum
init|=
literal|0
decl_stmt|,
name|temp
decl_stmt|,
name|zeros
init|=
literal|0
decl_stmt|,
name|ave
decl_stmt|,
name|n
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cfsnc_hashsize
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cfsnchash
index|[
name|i
index|]
operator|.
name|length
condition|)
block|{
name|sum
operator|+=
name|cfsnchash
index|[
name|i
index|]
operator|.
name|length
expr_stmt|;
block|}
else|else
block|{
name|zeros
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|cfsnchash
index|[
name|i
index|]
operator|.
name|length
operator|>
name|max
condition|)
name|max
operator|=
name|cfsnchash
index|[
name|i
index|]
operator|.
name|length
expr_stmt|;
block|}
comment|/* 	 * When computing the Arithmetic mean, only count slots which  	 * are not empty in the distribution. 	 */
name|cfsnc_stat
operator|.
name|Sum_bucket_len
operator|=
name|sum
expr_stmt|;
name|cfsnc_stat
operator|.
name|Num_zero_len
operator|=
name|zeros
expr_stmt|;
name|cfsnc_stat
operator|.
name|Max_bucket_len
operator|=
name|max
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|cfsnc_hashsize
operator|-
name|zeros
operator|)
operator|>
literal|0
condition|)
name|ave
operator|=
name|sum
operator|/
name|n
expr_stmt|;
else|else
name|ave
operator|=
literal|0
expr_stmt|;
name|sum
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cfsnc_hashsize
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cfsnchash
index|[
name|i
index|]
operator|.
name|length
condition|)
block|{
name|temp
operator|=
name|cfsnchash
index|[
name|i
index|]
operator|.
name|length
operator|-
name|ave
expr_stmt|;
name|sum
operator|+=
name|temp
operator|*
name|temp
expr_stmt|;
block|}
block|}
name|cfsnc_stat
operator|.
name|Sum2_bucket_len
operator|=
name|sum
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The purpose of this routine is to allow the hash and cache sizes to be  * changed dynamically. This should only be used in controlled environments,  * it makes no effort to lock other users from accessing the cache while it  * is in an improper state (except by turning the cache off).  */
end_comment

begin_function
name|int
name|cfsnc_resize
parameter_list|(
name|hashsize
parameter_list|,
name|heapsize
parameter_list|,
name|dcstat
parameter_list|)
name|int
name|hashsize
decl_stmt|,
name|heapsize
decl_stmt|;
name|enum
name|dc_status
name|dcstat
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|hashsize
operator|%
literal|2
operator|)
operator|||
operator|(
name|heapsize
operator|%
literal|2
operator|)
condition|)
block|{
comment|/* Illegal hash or cache sizes */
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|cfsnc_use
operator|=
literal|0
expr_stmt|;
comment|/* Turn the cache off */
name|cfsnc_flush
argument_list|(
name|dcstat
argument_list|)
expr_stmt|;
comment|/* free any cnodes in the cache */
comment|/* WARNING: free must happen *before* size is reset */
name|CFS_FREE
argument_list|(
name|cfsncheap
argument_list|,
name|TOTAL_CACHE_SIZE
argument_list|)
expr_stmt|;
name|CFS_FREE
argument_list|(
name|cfsnchash
argument_list|,
name|TOTAL_HASH_SIZE
argument_list|)
expr_stmt|;
name|cfsnc_hashsize
operator|=
name|hashsize
expr_stmt|;
name|cfsnc_size
operator|=
name|heapsize
expr_stmt|;
name|cfsnc_init
argument_list|()
expr_stmt|;
comment|/* Set up a cache with the new size */
name|cfsnc_use
operator|=
literal|1
expr_stmt|;
comment|/* Turn the cache back on */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|char
name|cfsnc_name_buf
index|[
name|CFS_MAXNAMLEN
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|cfsnc_name
parameter_list|(
name|struct
name|cnode
modifier|*
name|cp
parameter_list|)
block|{
name|struct
name|cfscache
modifier|*
name|cncp
decl_stmt|,
modifier|*
name|ncncp
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|cfsnc_use
operator|==
literal|0
condition|)
comment|/* Cache is off */
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cfsnc_hashsize
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|cncp
operator|=
name|cfsnchash
index|[
name|i
index|]
operator|.
name|hash_next
init|;
name|cncp
operator|!=
operator|(
expr|struct
name|cfscache
operator|*
operator|)
operator|&
name|cfsnchash
index|[
name|i
index|]
condition|;
name|cncp
operator|=
name|ncncp
control|)
block|{
name|ncncp
operator|=
name|cncp
operator|->
name|hash_next
expr_stmt|;
if|if
condition|(
name|cncp
operator|->
name|cp
operator|==
name|cp
condition|)
block|{
name|bcopy
argument_list|(
name|cncp
operator|->
name|name
argument_list|,
name|cfsnc_name_buf
argument_list|,
name|cncp
operator|->
name|namelen
argument_list|)
expr_stmt|;
name|cfsnc_name_buf
index|[
name|cncp
operator|->
name|namelen
index|]
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|" is %s (%p,%p)@%p"
argument_list|,
name|cfsnc_name_buf
argument_list|,
name|cncp
operator|->
name|cp
argument_list|,
name|cncp
operator|->
name|dcp
argument_list|,
name|cncp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

end_unit

