begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2009 Rick Macklem, University of Guelph  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * These functions implement the client side state handling for NFSv4.  * NFSv4 state handling:  * - A lockowner is used to determine lock contention, so it  *   corresponds directly to a Posix pid. (1 to 1 mapping)  * - The correct granularity of an OpenOwner is not nearly so  *   obvious. An OpenOwner does the following:  *   - provides a serial sequencing of Open/Close/Lock-with-new-lockowner  *   - is used to check for Open/Share contention (not applicable to  *     this client, since all Opens are Deny_None)  *   As such, I considered both extreme.  *   1 OpenOwner per ClientID - Simple to manage, but fully serializes  *   all Open, Close and Lock (with a new lockowner) Ops.  *   1 OpenOwner for each Open - This one results in an OpenConfirm for  *   every Open, for most servers.  *   So, I chose to use the same mapping as I did for LockOwnwers.  *   The main concern here is that you can end up with multiple Opens  *   for the same File Handle, but on different OpenOwners (opens  *   inherited from parents, grandparents...) and you do not know  *   which of these the vnodeop close applies to. This is handled by  *   delaying the Close Op(s) until all of the Opens have been closed.  *   (It is not yet obvious if this is the correct granularity.)  * - How the code handles serialization:  *   - For the ClientId, it uses an exclusive lock while getting its  *     SetClientId and during recovery. Otherwise, it uses a shared  *     lock via a reference count.  *   - For the rest of the data structures, it uses an SMP mutex  *     (once the nfs client is SMP safe) and doesn't sleep while  *     manipulating the linked lists.  *   - The serialization of Open/Close/Lock/LockU falls out in the  *     "wash", since OpenOwners and LockOwners are both mapped from  *     Posix pid. In other words, there is only one Posix pid using  *     any given owner, so that owner is serialized. (If you change  *     the granularity of the OpenOwner, then code must be added to  *     serialize Ops on the OpenOwner.)  * - When to get rid of OpenOwners and LockOwners.  *   - When a process exits, it calls nfscl_cleanup(), which goes  *     through the client list looking for all Open and Lock Owners.  *     When one is found, it is marked "defunct" or in the case of  *     an OpenOwner without any Opens, freed.  *     The renew thread scans for defunct Owners and gets rid of them,  *     if it can. The LockOwners will also be deleted when the  *     associated Open is closed.  *   - If the LockU or Close Op(s) fail during close in a way  *     that could be recovered upon retry, they are relinked to the  *     ClientId's defunct open list and retried by the renew thread  *     until they succeed or an unmount/recovery occurs.  *     (Since we are done with them, they do not need to be recovered.)  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|APPLEKEXT
end_ifndef

begin_include
include|#
directive|include
file|<fs/nfs/nfsport.h>
end_include

begin_comment
comment|/*  * Global variables  */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|nfsstats
name|newnfsstats
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|nfsreqhead
name|nfsd_reqq
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|NFSREQSPINLOCK
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|NFSCLSTATEMUTEX
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|nfscl_inited
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|nfsclhead
name|nfsclhead
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Head of clientid list */
end_comment

begin_decl_stmt
name|int
name|nfscl_deleghighwater
init|=
name|NFSCLDELEGHIGHWATER
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !APPLEKEXT */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nfscl_delegcnt
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|nfscl_getopen
parameter_list|(
name|struct
name|nfsclownerhead
modifier|*
parameter_list|,
name|u_int8_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|u_int8_t
modifier|*
parameter_list|,
name|NFSPROC_T
modifier|*
parameter_list|,
name|u_int32_t
parameter_list|,
name|struct
name|nfsclowner
modifier|*
modifier|*
parameter_list|,
name|struct
name|nfsclopen
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nfscl_clrelease
parameter_list|(
name|struct
name|nfsclclient
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nfscl_cleanclient
parameter_list|(
name|struct
name|nfsclclient
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nfscl_expireclient
parameter_list|(
name|struct
name|nfsclclient
modifier|*
parameter_list|,
name|struct
name|nfsmount
modifier|*
parameter_list|,
name|struct
name|ucred
modifier|*
parameter_list|,
name|NFSPROC_T
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nfscl_expireopen
parameter_list|(
name|struct
name|nfsclclient
modifier|*
parameter_list|,
name|struct
name|nfsclopen
modifier|*
parameter_list|,
name|struct
name|nfsmount
modifier|*
parameter_list|,
name|struct
name|ucred
modifier|*
parameter_list|,
name|NFSPROC_T
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nfscl_recover
parameter_list|(
name|struct
name|nfsclclient
modifier|*
parameter_list|,
name|struct
name|ucred
modifier|*
parameter_list|,
name|NFSPROC_T
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nfscl_insertlock
parameter_list|(
name|struct
name|nfscllockowner
modifier|*
parameter_list|,
name|struct
name|nfscllock
modifier|*
parameter_list|,
name|struct
name|nfscllock
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nfscl_updatelock
parameter_list|(
name|struct
name|nfscllockowner
modifier|*
parameter_list|,
name|struct
name|nfscllock
modifier|*
modifier|*
parameter_list|,
name|struct
name|nfscllock
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nfscl_delegreturnall
parameter_list|(
name|struct
name|nfsclclient
modifier|*
parameter_list|,
name|NFSPROC_T
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int32_t
name|nfscl_nextcbident
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|mount_t
name|nfscl_getmnt
parameter_list|(
name|u_int32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|nfscldeleg
modifier|*
name|nfscl_finddeleg
parameter_list|(
name|struct
name|nfsclclient
modifier|*
parameter_list|,
name|u_int8_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nfscl_checkconflict
parameter_list|(
name|struct
name|nfscllockownerhead
modifier|*
parameter_list|,
name|struct
name|nfscllock
modifier|*
parameter_list|,
name|u_int8_t
modifier|*
parameter_list|,
name|struct
name|nfscllock
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nfscl_freelockowner
parameter_list|(
name|struct
name|nfscllockowner
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nfscl_freealllocks
parameter_list|(
name|struct
name|nfscllockownerhead
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nfscl_localconflict
parameter_list|(
name|struct
name|nfsclclient
modifier|*
parameter_list|,
name|u_int8_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|nfscllock
modifier|*
parameter_list|,
name|u_int8_t
modifier|*
parameter_list|,
name|struct
name|nfscldeleg
modifier|*
parameter_list|,
name|struct
name|nfscllock
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nfscl_newopen
parameter_list|(
name|struct
name|nfsclclient
modifier|*
parameter_list|,
name|struct
name|nfscldeleg
modifier|*
parameter_list|,
name|struct
name|nfsclowner
modifier|*
modifier|*
parameter_list|,
name|struct
name|nfsclowner
modifier|*
modifier|*
parameter_list|,
name|struct
name|nfsclopen
modifier|*
modifier|*
parameter_list|,
name|struct
name|nfsclopen
modifier|*
modifier|*
parameter_list|,
name|u_int8_t
modifier|*
parameter_list|,
name|u_int8_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nfscl_moveopen
parameter_list|(
name|vnode_t
parameter_list|,
name|struct
name|nfsclclient
modifier|*
parameter_list|,
name|struct
name|nfsmount
modifier|*
parameter_list|,
name|struct
name|nfsclopen
modifier|*
parameter_list|,
name|struct
name|nfsclowner
modifier|*
parameter_list|,
name|struct
name|nfscldeleg
modifier|*
parameter_list|,
name|struct
name|ucred
modifier|*
parameter_list|,
name|NFSPROC_T
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nfscl_totalrecall
parameter_list|(
name|struct
name|nfsclclient
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nfscl_relock
parameter_list|(
name|vnode_t
parameter_list|,
name|struct
name|nfsclclient
modifier|*
parameter_list|,
name|struct
name|nfsmount
modifier|*
parameter_list|,
name|struct
name|nfscllockowner
modifier|*
parameter_list|,
name|struct
name|nfscllock
modifier|*
parameter_list|,
name|struct
name|ucred
modifier|*
parameter_list|,
name|NFSPROC_T
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nfscl_tryopen
parameter_list|(
name|struct
name|nfsmount
modifier|*
parameter_list|,
name|vnode_t
parameter_list|,
name|u_int8_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|u_int8_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|u_int32_t
parameter_list|,
name|struct
name|nfsclopen
modifier|*
parameter_list|,
name|u_int8_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|nfscldeleg
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|,
name|u_int32_t
parameter_list|,
name|struct
name|ucred
modifier|*
parameter_list|,
name|NFSPROC_T
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nfscl_trylock
parameter_list|(
name|struct
name|nfsmount
modifier|*
parameter_list|,
name|vnode_t
parameter_list|,
name|u_int8_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|nfscllockowner
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|u_int64_t
parameter_list|,
name|u_int64_t
parameter_list|,
name|short
parameter_list|,
name|struct
name|ucred
modifier|*
parameter_list|,
name|NFSPROC_T
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nfsrpc_reopen
parameter_list|(
name|struct
name|nfsmount
modifier|*
parameter_list|,
name|u_int8_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|u_int32_t
parameter_list|,
name|struct
name|nfsclopen
modifier|*
parameter_list|,
name|struct
name|nfscldeleg
modifier|*
modifier|*
parameter_list|,
name|struct
name|ucred
modifier|*
parameter_list|,
name|NFSPROC_T
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nfscl_freedeleg
parameter_list|(
name|struct
name|nfscldeleghead
modifier|*
parameter_list|,
name|struct
name|nfscldeleg
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nfscl_errmap
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nfscl_cleanup_common
parameter_list|(
name|struct
name|nfsclclient
modifier|*
parameter_list|,
name|u_int8_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nfscl_recalldeleg
parameter_list|(
name|struct
name|nfsclclient
modifier|*
parameter_list|,
name|struct
name|nfsmount
modifier|*
parameter_list|,
name|struct
name|nfscldeleg
modifier|*
parameter_list|,
name|vnode_t
parameter_list|,
name|struct
name|ucred
modifier|*
parameter_list|,
name|NFSPROC_T
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nfscl_freeopenowner
parameter_list|(
name|struct
name|nfsclowner
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nfscl_cleandeleg
parameter_list|(
name|struct
name|nfscldeleg
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nfscl_trydelegreturn
parameter_list|(
name|struct
name|nfscldeleg
modifier|*
parameter_list|,
name|struct
name|ucred
modifier|*
parameter_list|,
name|struct
name|nfsmount
modifier|*
parameter_list|,
name|NFSPROC_T
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|short
name|nfscberr_null
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|nfscberr_getattr
index|[]
init|=
block|{
name|NFSERR_RESOURCE
block|,
name|NFSERR_BADHANDLE
block|,
name|NFSERR_BADXDR
block|,
name|NFSERR_RESOURCE
block|,
name|NFSERR_SERVERFAULT
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|nfscberr_recall
index|[]
init|=
block|{
name|NFSERR_RESOURCE
block|,
name|NFSERR_BADHANDLE
block|,
name|NFSERR_BADSTATEID
block|,
name|NFSERR_BADXDR
block|,
name|NFSERR_RESOURCE
block|,
name|NFSERR_SERVERFAULT
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
modifier|*
name|nfscl_cberrmap
index|[]
init|=
block|{
name|nfscberr_null
block|,
name|nfscberr_null
block|,
name|nfscberr_null
block|,
name|nfscberr_getattr
block|,
name|nfscberr_recall
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NETFAMILY
parameter_list|(
name|clp
parameter_list|)
define|\
value|(((clp)->nfsc_flags& NFSCLFLAGS_AFINET6) ? AF_INET6 : AF_INET)
end_define

begin_comment
comment|/*  * Called for an open operation.  * If the nfhp argument is NULL, just get an openowner.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfscl_open
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|u_int8_t
modifier|*
name|nfhp
parameter_list|,
name|int
name|fhlen
parameter_list|,
name|u_int32_t
name|amode
parameter_list|,
name|int
name|usedeleg
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|struct
name|nfsclowner
modifier|*
modifier|*
name|owpp
parameter_list|,
name|struct
name|nfsclopen
modifier|*
modifier|*
name|opp
parameter_list|,
name|int
modifier|*
name|newonep
parameter_list|,
name|int
modifier|*
name|retp
parameter_list|,
name|int
name|lockit
parameter_list|)
block|{
name|struct
name|nfsclclient
modifier|*
name|clp
decl_stmt|;
name|struct
name|nfsclowner
modifier|*
name|owp
decl_stmt|,
modifier|*
name|nowp
decl_stmt|;
name|struct
name|nfsclopen
modifier|*
name|op
init|=
name|NULL
decl_stmt|,
modifier|*
name|nop
init|=
name|NULL
decl_stmt|;
name|struct
name|nfscldeleg
modifier|*
name|dp
decl_stmt|;
name|struct
name|nfsclownerhead
modifier|*
name|ohp
decl_stmt|;
name|u_int8_t
name|own
index|[
name|NFSV4CL_LOCKNAMELEN
index|]
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|newonep
operator|!=
name|NULL
condition|)
operator|*
name|newonep
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|opp
operator|!=
name|NULL
condition|)
operator|*
name|opp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|owpp
operator|!=
name|NULL
condition|)
operator|*
name|owpp
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Might need one or both of these, so MALLOC them now, to 	 * avoid a tsleep() in MALLOC later. 	 */
name|MALLOC
argument_list|(
name|nowp
argument_list|,
expr|struct
name|nfsclowner
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nfsclowner
argument_list|)
argument_list|,
name|M_NFSCLOWNER
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|nfhp
operator|!=
name|NULL
condition|)
name|MALLOC
argument_list|(
name|nop
argument_list|,
expr|struct
name|nfsclopen
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nfsclopen
argument_list|)
operator|+
name|fhlen
operator|-
literal|1
argument_list|,
name|M_NFSCLOPEN
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|ret
operator|=
name|nfscl_getcl
argument_list|(
name|vp
argument_list|,
name|cred
argument_list|,
name|p
argument_list|,
operator|&
name|clp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|nowp
argument_list|,
name|M_NFSCLOWNER
argument_list|)
expr_stmt|;
if|if
condition|(
name|nop
operator|!=
name|NULL
condition|)
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|nop
argument_list|,
name|M_NFSCLOPEN
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
comment|/* 	 * Get the Open iff it already exists. 	 * If none found, add the new one or return error, depending upon 	 * "create". 	 */
name|nfscl_filllockowner
argument_list|(
name|p
argument_list|,
name|own
argument_list|)
expr_stmt|;
name|NFSLOCKCLSTATE
argument_list|()
expr_stmt|;
name|dp
operator|=
name|NULL
expr_stmt|;
comment|/* First check the delegation list */
if|if
condition|(
name|nfhp
operator|!=
name|NULL
operator|&&
name|usedeleg
condition|)
block|{
name|LIST_FOREACH
argument_list|(
argument|dp
argument_list|,
argument|NFSCLDELEGHASH(clp, nfhp, fhlen)
argument_list|,
argument|nfsdl_hash
argument_list|)
block|{
if|if
condition|(
name|dp
operator|->
name|nfsdl_fhlen
operator|==
name|fhlen
operator|&&
operator|!
name|NFSBCMP
argument_list|(
name|nfhp
argument_list|,
name|dp
operator|->
name|nfsdl_fh
argument_list|,
name|fhlen
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|amode
operator|&
name|NFSV4OPEN_ACCESSWRITE
operator|)
operator|||
operator|(
name|dp
operator|->
name|nfsdl_flags
operator|&
name|NFSCLDL_WRITE
operator|)
condition|)
break|break;
name|dp
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|dp
operator|!=
name|NULL
condition|)
name|ohp
operator|=
operator|&
name|dp
operator|->
name|nfsdl_owner
expr_stmt|;
else|else
name|ohp
operator|=
operator|&
name|clp
operator|->
name|nfsc_owner
expr_stmt|;
comment|/* Now, search for an openowner */
name|LIST_FOREACH
argument_list|(
argument|owp
argument_list|,
argument|ohp
argument_list|,
argument|nfsow_list
argument_list|)
block|{
if|if
condition|(
operator|!
name|NFSBCMP
argument_list|(
name|owp
operator|->
name|nfsow_owner
argument_list|,
name|own
argument_list|,
name|NFSV4CL_LOCKNAMELEN
argument_list|)
condition|)
break|break;
block|}
comment|/* 	 * Create a new open, as required. 	 */
name|nfscl_newopen
argument_list|(
name|clp
argument_list|,
name|dp
argument_list|,
operator|&
name|owp
argument_list|,
operator|&
name|nowp
argument_list|,
operator|&
name|op
argument_list|,
operator|&
name|nop
argument_list|,
name|own
argument_list|,
name|nfhp
argument_list|,
name|fhlen
argument_list|,
name|newonep
argument_list|)
expr_stmt|;
comment|/* 	 * Serialize modifications to the open owner for multiple threads 	 * within the same process using a read/write sleep lock. 	 */
if|if
condition|(
name|lockit
condition|)
name|nfscl_lockexcl
argument_list|(
operator|&
name|owp
operator|->
name|nfsow_rwlock
argument_list|,
name|NFSCLSTATEMUTEXPTR
argument_list|)
expr_stmt|;
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
if|if
condition|(
name|nowp
operator|!=
name|NULL
condition|)
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|nowp
argument_list|,
name|M_NFSCLOWNER
argument_list|)
expr_stmt|;
if|if
condition|(
name|nop
operator|!=
name|NULL
condition|)
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|nop
argument_list|,
name|M_NFSCLOPEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|owpp
operator|!=
name|NULL
condition|)
operator|*
name|owpp
operator|=
name|owp
expr_stmt|;
if|if
condition|(
name|opp
operator|!=
name|NULL
condition|)
operator|*
name|opp
operator|=
name|op
expr_stmt|;
if|if
condition|(
name|retp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|nfhp
operator|!=
name|NULL
operator|&&
name|dp
operator|!=
name|NULL
operator|&&
name|nop
operator|==
name|NULL
condition|)
comment|/* new local open on delegation */
operator|*
name|retp
operator|=
name|NFSCLOPEN_SETCRED
expr_stmt|;
else|else
operator|*
name|retp
operator|=
name|NFSCLOPEN_OK
expr_stmt|;
block|}
comment|/* 	 * Now, check the mode on the open and return the appropriate 	 * value. 	 */
if|if
condition|(
name|op
operator|!=
name|NULL
operator|&&
operator|(
name|amode
operator|&
operator|~
operator|(
name|op
operator|->
name|nfso_mode
operator|)
operator|)
condition|)
block|{
name|op
operator|->
name|nfso_mode
operator||=
name|amode
expr_stmt|;
if|if
condition|(
name|retp
operator|!=
name|NULL
operator|&&
name|dp
operator|==
name|NULL
condition|)
operator|*
name|retp
operator|=
name|NFSCLOPEN_DOOPEN
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create a new open, as required.  */
end_comment

begin_function
specifier|static
name|void
name|nfscl_newopen
parameter_list|(
name|struct
name|nfsclclient
modifier|*
name|clp
parameter_list|,
name|struct
name|nfscldeleg
modifier|*
name|dp
parameter_list|,
name|struct
name|nfsclowner
modifier|*
modifier|*
name|owpp
parameter_list|,
name|struct
name|nfsclowner
modifier|*
modifier|*
name|nowpp
parameter_list|,
name|struct
name|nfsclopen
modifier|*
modifier|*
name|opp
parameter_list|,
name|struct
name|nfsclopen
modifier|*
modifier|*
name|nopp
parameter_list|,
name|u_int8_t
modifier|*
name|own
parameter_list|,
name|u_int8_t
modifier|*
name|fhp
parameter_list|,
name|int
name|fhlen
parameter_list|,
name|int
modifier|*
name|newonep
parameter_list|)
block|{
name|struct
name|nfsclowner
modifier|*
name|owp
init|=
operator|*
name|owpp
decl_stmt|,
modifier|*
name|nowp
decl_stmt|;
name|struct
name|nfsclopen
modifier|*
name|op
decl_stmt|,
modifier|*
name|nop
decl_stmt|;
if|if
condition|(
name|nowpp
operator|!=
name|NULL
condition|)
name|nowp
operator|=
operator|*
name|nowpp
expr_stmt|;
else|else
name|nowp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|nopp
operator|!=
name|NULL
condition|)
name|nop
operator|=
operator|*
name|nopp
expr_stmt|;
else|else
name|nop
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|owp
operator|==
name|NULL
operator|&&
name|nowp
operator|!=
name|NULL
condition|)
block|{
name|NFSBCOPY
argument_list|(
name|own
argument_list|,
name|nowp
operator|->
name|nfsow_owner
argument_list|,
name|NFSV4CL_LOCKNAMELEN
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|nowp
operator|->
name|nfsow_open
argument_list|)
expr_stmt|;
name|nowp
operator|->
name|nfsow_clp
operator|=
name|clp
expr_stmt|;
name|nowp
operator|->
name|nfsow_seqid
operator|=
literal|0
expr_stmt|;
name|nowp
operator|->
name|nfsow_defunct
operator|=
literal|0
expr_stmt|;
name|nfscl_lockinit
argument_list|(
operator|&
name|nowp
operator|->
name|nfsow_rwlock
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|!=
name|NULL
condition|)
block|{
name|newnfsstats
operator|.
name|cllocalopenowners
operator|++
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|dp
operator|->
name|nfsdl_owner
argument_list|,
name|nowp
argument_list|,
name|nfsow_list
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newnfsstats
operator|.
name|clopenowners
operator|++
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|clp
operator|->
name|nfsc_owner
argument_list|,
name|nowp
argument_list|,
name|nfsow_list
argument_list|)
expr_stmt|;
block|}
name|owp
operator|=
operator|*
name|owpp
operator|=
name|nowp
expr_stmt|;
operator|*
name|nowpp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|newonep
operator|!=
name|NULL
condition|)
operator|*
name|newonep
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If an fhp has been specified, create an Open as well. */
if|if
condition|(
name|fhp
operator|!=
name|NULL
condition|)
block|{
comment|/* and look for the correct open, based upon FH */
name|LIST_FOREACH
argument_list|(
argument|op
argument_list|,
argument|&owp->nfsow_open
argument_list|,
argument|nfso_list
argument_list|)
block|{
if|if
condition|(
name|op
operator|->
name|nfso_fhlen
operator|==
name|fhlen
operator|&&
operator|!
name|NFSBCMP
argument_list|(
name|op
operator|->
name|nfso_fh
argument_list|,
name|fhp
argument_list|,
name|fhlen
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|op
operator|==
name|NULL
operator|&&
name|nop
operator|!=
name|NULL
condition|)
block|{
name|nop
operator|->
name|nfso_own
operator|=
name|owp
expr_stmt|;
name|nop
operator|->
name|nfso_mode
operator|=
literal|0
expr_stmt|;
name|nop
operator|->
name|nfso_opencnt
operator|=
literal|0
expr_stmt|;
name|nop
operator|->
name|nfso_posixlock
operator|=
literal|1
expr_stmt|;
name|nop
operator|->
name|nfso_fhlen
operator|=
name|fhlen
expr_stmt|;
name|NFSBCOPY
argument_list|(
name|fhp
argument_list|,
name|nop
operator|->
name|nfso_fh
argument_list|,
name|fhlen
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|nop
operator|->
name|nfso_lock
argument_list|)
expr_stmt|;
name|nop
operator|->
name|nfso_stateid
operator|.
name|seqid
operator|=
literal|0
expr_stmt|;
name|nop
operator|->
name|nfso_stateid
operator|.
name|other
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|nop
operator|->
name|nfso_stateid
operator|.
name|other
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|nop
operator|->
name|nfso_stateid
operator|.
name|other
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dp
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|clp
operator|->
name|nfsc_deleg
argument_list|,
name|dp
argument_list|,
name|nfsdl_list
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|clp
operator|->
name|nfsc_deleg
argument_list|,
name|dp
argument_list|,
name|nfsdl_list
argument_list|)
expr_stmt|;
name|dp
operator|->
name|nfsdl_timestamp
operator|=
name|NFSD_MONOSEC
operator|+
literal|120
expr_stmt|;
name|newnfsstats
operator|.
name|cllocalopens
operator|++
expr_stmt|;
block|}
else|else
block|{
name|newnfsstats
operator|.
name|clopens
operator|++
expr_stmt|;
block|}
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|owp
operator|->
name|nfsow_open
argument_list|,
name|nop
argument_list|,
name|nfso_list
argument_list|)
expr_stmt|;
operator|*
name|opp
operator|=
name|nop
expr_stmt|;
operator|*
name|nopp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|newonep
operator|!=
name|NULL
condition|)
operator|*
name|newonep
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
operator|*
name|opp
operator|=
name|op
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Called to find/add a delegation to a client.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfscl_deleg
parameter_list|(
name|mount_t
name|mp
parameter_list|,
name|struct
name|nfsclclient
modifier|*
name|clp
parameter_list|,
name|u_int8_t
modifier|*
name|nfhp
parameter_list|,
name|int
name|fhlen
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|struct
name|nfscldeleg
modifier|*
modifier|*
name|dpp
parameter_list|)
block|{
name|struct
name|nfscldeleg
modifier|*
name|dp
init|=
operator|*
name|dpp
decl_stmt|,
modifier|*
name|tdp
decl_stmt|;
comment|/* 	 * First, if we have received a Read delegation for a file on a 	 * read/write file system, just return it, because they aren't 	 * useful, imho. 	 */
if|if
condition|(
name|mp
operator|!=
name|NULL
operator|&&
name|dp
operator|!=
name|NULL
operator|&&
operator|!
name|NFSMNT_RDONLY
argument_list|(
name|mp
argument_list|)
operator|&&
operator|(
name|dp
operator|->
name|nfsdl_flags
operator|&
name|NFSCLDL_READ
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|nfscl_trydelegreturn
argument_list|(
name|dp
argument_list|,
name|cred
argument_list|,
name|VFSTONFS
argument_list|(
name|mp
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|dp
argument_list|,
name|M_NFSCLDELEG
argument_list|)
expr_stmt|;
operator|*
name|dpp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Look for the correct deleg, based upon FH */
name|NFSLOCKCLSTATE
argument_list|()
expr_stmt|;
name|tdp
operator|=
name|nfscl_finddeleg
argument_list|(
name|clp
argument_list|,
name|nfhp
argument_list|,
name|fhlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|dp
operator|==
name|NULL
condition|)
block|{
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
return|return
operator|(
name|NFSERR_BADSTATEID
operator|)
return|;
block|}
operator|*
name|dpp
operator|=
name|NULL
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|clp
operator|->
name|nfsc_deleg
argument_list|,
name|dp
argument_list|,
name|nfsdl_list
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|NFSCLDELEGHASH
argument_list|(
name|clp
argument_list|,
name|nfhp
argument_list|,
name|fhlen
argument_list|)
argument_list|,
name|dp
argument_list|,
name|nfsdl_hash
argument_list|)
expr_stmt|;
name|dp
operator|->
name|nfsdl_timestamp
operator|=
name|NFSD_MONOSEC
operator|+
literal|120
expr_stmt|;
name|newnfsstats
operator|.
name|cldelegates
operator|++
expr_stmt|;
name|nfscl_delegcnt
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Delegation already exists, what do we do if a new one?? 		 */
if|if
condition|(
name|dp
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"Deleg already exists!\n"
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|dp
argument_list|,
name|M_NFSCLDELEG
argument_list|)
expr_stmt|;
operator|*
name|dpp
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
operator|*
name|dpp
operator|=
name|tdp
expr_stmt|;
block|}
block|}
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find a delegation for this file handle. Return NULL upon failure.  */
end_comment

begin_function
specifier|static
name|struct
name|nfscldeleg
modifier|*
name|nfscl_finddeleg
parameter_list|(
name|struct
name|nfsclclient
modifier|*
name|clp
parameter_list|,
name|u_int8_t
modifier|*
name|fhp
parameter_list|,
name|int
name|fhlen
parameter_list|)
block|{
name|struct
name|nfscldeleg
modifier|*
name|dp
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|dp
argument_list|,
argument|NFSCLDELEGHASH(clp, fhp, fhlen)
argument_list|,
argument|nfsdl_hash
argument_list|)
block|{
if|if
condition|(
name|dp
operator|->
name|nfsdl_fhlen
operator|==
name|fhlen
operator|&&
operator|!
name|NFSBCMP
argument_list|(
name|dp
operator|->
name|nfsdl_fh
argument_list|,
name|fhp
argument_list|,
name|fhlen
argument_list|)
condition|)
break|break;
block|}
return|return
operator|(
name|dp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get a stateid for an I/O operation. First, look for an open and iff  * found, return either a lockowner stateid or the open stateid.  * If no Open is found, just return error and the special stateid of all zeros.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfscl_getstateid
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|u_int8_t
modifier|*
name|nfhp
parameter_list|,
name|int
name|fhlen
parameter_list|,
name|u_int32_t
name|mode
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|nfsv4stateid_t
modifier|*
name|stateidp
parameter_list|,
name|void
modifier|*
modifier|*
name|lckpp
parameter_list|)
block|{
name|struct
name|nfsclclient
modifier|*
name|clp
decl_stmt|;
name|struct
name|nfsclowner
modifier|*
name|owp
decl_stmt|;
name|struct
name|nfsclopen
modifier|*
name|op
init|=
name|NULL
decl_stmt|;
name|struct
name|nfscllockowner
modifier|*
name|lp
decl_stmt|;
name|struct
name|nfscldeleg
modifier|*
name|dp
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|np
decl_stmt|;
name|u_int8_t
name|own
index|[
name|NFSV4CL_LOCKNAMELEN
index|]
decl_stmt|;
name|int
name|error
decl_stmt|,
name|done
decl_stmt|;
operator|*
name|lckpp
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Initially, just set the special stateid of all zeros. 	 */
name|stateidp
operator|->
name|seqid
operator|=
literal|0
expr_stmt|;
name|stateidp
operator|->
name|other
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|stateidp
operator|->
name|other
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|stateidp
operator|->
name|other
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vnode_vtype
argument_list|(
name|vp
argument_list|)
operator|!=
name|VREG
condition|)
return|return
operator|(
name|EISDIR
operator|)
return|;
name|np
operator|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|NFSLOCKCLSTATE
argument_list|()
expr_stmt|;
name|clp
operator|=
name|nfscl_findcl
argument_list|(
name|VFSTONFS
argument_list|(
name|vnode_mount
argument_list|(
name|vp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|clp
operator|==
name|NULL
condition|)
block|{
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
return|return
operator|(
name|EACCES
operator|)
return|;
block|}
comment|/* 	 * Wait for recovery to complete. 	 */
while|while
condition|(
operator|(
name|clp
operator|->
name|nfsc_flags
operator|&
name|NFSCLFLAGS_RECVRINPROG
operator|)
condition|)
operator|(
name|void
operator|)
name|nfsmsleep
argument_list|(
operator|&
name|clp
operator|->
name|nfsc_flags
argument_list|,
name|NFSCLSTATEMUTEXPTR
argument_list|,
name|PZERO
argument_list|,
literal|"nfsrecvr"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * First, look for a delegation. 	 */
name|LIST_FOREACH
argument_list|(
argument|dp
argument_list|,
argument|NFSCLDELEGHASH(clp, nfhp, fhlen)
argument_list|,
argument|nfsdl_hash
argument_list|)
block|{
if|if
condition|(
name|dp
operator|->
name|nfsdl_fhlen
operator|==
name|fhlen
operator|&&
operator|!
name|NFSBCMP
argument_list|(
name|nfhp
argument_list|,
name|dp
operator|->
name|nfsdl_fh
argument_list|,
name|fhlen
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|mode
operator|&
name|NFSV4OPEN_ACCESSWRITE
operator|)
operator|||
operator|(
name|dp
operator|->
name|nfsdl_flags
operator|&
name|NFSCLDL_WRITE
operator|)
condition|)
block|{
name|stateidp
operator|->
name|seqid
operator|=
name|dp
operator|->
name|nfsdl_stateid
operator|.
name|seqid
expr_stmt|;
name|stateidp
operator|->
name|other
index|[
literal|0
index|]
operator|=
name|dp
operator|->
name|nfsdl_stateid
operator|.
name|other
index|[
literal|0
index|]
expr_stmt|;
name|stateidp
operator|->
name|other
index|[
literal|1
index|]
operator|=
name|dp
operator|->
name|nfsdl_stateid
operator|.
name|other
index|[
literal|1
index|]
expr_stmt|;
name|stateidp
operator|->
name|other
index|[
literal|2
index|]
operator|=
name|dp
operator|->
name|nfsdl_stateid
operator|.
name|other
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|np
operator|->
name|n_flag
operator|&
name|NDELEGRECALL
operator|)
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|clp
operator|->
name|nfsc_deleg
argument_list|,
name|dp
argument_list|,
name|nfsdl_list
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|clp
operator|->
name|nfsc_deleg
argument_list|,
name|dp
argument_list|,
name|nfsdl_list
argument_list|)
expr_stmt|;
name|dp
operator|->
name|nfsdl_timestamp
operator|=
name|NFSD_MONOSEC
operator|+
literal|120
expr_stmt|;
name|dp
operator|->
name|nfsdl_rwlock
operator|.
name|nfslock_usecnt
operator|++
expr_stmt|;
operator|*
name|lckpp
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|dp
operator|->
name|nfsdl_rwlock
expr_stmt|;
block|}
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * If p != NULL, we want to search the parentage tree 		 * for a matching OpenOwner and use that. 		 */
name|nfscl_filllockowner
argument_list|(
name|p
argument_list|,
name|own
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfscl_getopen
argument_list|(
operator|&
name|clp
operator|->
name|nfsc_owner
argument_list|,
name|nfhp
argument_list|,
name|fhlen
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|,
name|mode
argument_list|,
name|NULL
argument_list|,
operator|&
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
comment|/* now look for a lockowner */
name|LIST_FOREACH
argument_list|(
argument|lp
argument_list|,
argument|&op->nfso_lock
argument_list|,
argument|nfsl_list
argument_list|)
block|{
if|if
condition|(
operator|!
name|NFSBCMP
argument_list|(
name|lp
operator|->
name|nfsl_owner
argument_list|,
name|own
argument_list|,
name|NFSV4CL_LOCKNAMELEN
argument_list|)
condition|)
block|{
name|stateidp
operator|->
name|seqid
operator|=
name|lp
operator|->
name|nfsl_stateid
operator|.
name|seqid
expr_stmt|;
name|stateidp
operator|->
name|other
index|[
literal|0
index|]
operator|=
name|lp
operator|->
name|nfsl_stateid
operator|.
name|other
index|[
literal|0
index|]
expr_stmt|;
name|stateidp
operator|->
name|other
index|[
literal|1
index|]
operator|=
name|lp
operator|->
name|nfsl_stateid
operator|.
name|other
index|[
literal|1
index|]
expr_stmt|;
name|stateidp
operator|->
name|other
index|[
literal|2
index|]
operator|=
name|lp
operator|->
name|nfsl_stateid
operator|.
name|other
index|[
literal|2
index|]
expr_stmt|;
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|op
operator|==
name|NULL
condition|)
block|{
comment|/* If not found, just look for any OpenOwner that will work. */
name|done
operator|=
literal|0
expr_stmt|;
name|owp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|clp
operator|->
name|nfsc_owner
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|done
operator|&&
name|owp
operator|!=
name|NULL
condition|)
block|{
name|LIST_FOREACH
argument_list|(
argument|op
argument_list|,
argument|&owp->nfsow_open
argument_list|,
argument|nfso_list
argument_list|)
block|{
if|if
condition|(
name|op
operator|->
name|nfso_fhlen
operator|==
name|fhlen
operator|&&
operator|!
name|NFSBCMP
argument_list|(
name|op
operator|->
name|nfso_fh
argument_list|,
name|nfhp
argument_list|,
name|fhlen
argument_list|)
operator|&&
operator|(
name|mode
operator|&
name|op
operator|->
name|nfso_mode
operator|)
operator|==
name|mode
condition|)
block|{
name|done
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|done
condition|)
name|owp
operator|=
name|LIST_NEXT
argument_list|(
name|owp
argument_list|,
name|nfsow_list
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|done
condition|)
block|{
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
comment|/* for read aheads or write behinds, use the open cred */
name|newnfs_copycred
argument_list|(
operator|&
name|op
operator|->
name|nfso_cred
argument_list|,
name|cred
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * No lock stateid, so return the open stateid. 	 */
name|stateidp
operator|->
name|seqid
operator|=
name|op
operator|->
name|nfso_stateid
operator|.
name|seqid
expr_stmt|;
name|stateidp
operator|->
name|other
index|[
literal|0
index|]
operator|=
name|op
operator|->
name|nfso_stateid
operator|.
name|other
index|[
literal|0
index|]
expr_stmt|;
name|stateidp
operator|->
name|other
index|[
literal|1
index|]
operator|=
name|op
operator|->
name|nfso_stateid
operator|.
name|other
index|[
literal|1
index|]
expr_stmt|;
name|stateidp
operator|->
name|other
index|[
literal|2
index|]
operator|=
name|op
operator|->
name|nfso_stateid
operator|.
name|other
index|[
literal|2
index|]
expr_stmt|;
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get an existing open. Search up the parentage tree for a match and  * return with the first one found.  */
end_comment

begin_function
specifier|static
name|int
name|nfscl_getopen
parameter_list|(
name|struct
name|nfsclownerhead
modifier|*
name|ohp
parameter_list|,
name|u_int8_t
modifier|*
name|nfhp
parameter_list|,
name|int
name|fhlen
parameter_list|,
name|u_int8_t
modifier|*
name|rown
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|u_int32_t
name|mode
parameter_list|,
name|struct
name|nfsclowner
modifier|*
modifier|*
name|owpp
parameter_list|,
name|struct
name|nfsclopen
modifier|*
modifier|*
name|opp
parameter_list|)
block|{
name|struct
name|nfsclowner
modifier|*
name|owp
init|=
name|NULL
decl_stmt|;
name|struct
name|nfsclopen
modifier|*
name|op
decl_stmt|;
name|NFSPROC_T
modifier|*
name|nproc
decl_stmt|;
name|u_int8_t
name|own
index|[
name|NFSV4CL_LOCKNAMELEN
index|]
decl_stmt|,
modifier|*
name|ownp
decl_stmt|;
name|nproc
operator|=
name|p
expr_stmt|;
name|op
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|op
operator|==
name|NULL
operator|&&
operator|(
name|nproc
operator|!=
name|NULL
operator|||
name|rown
operator|!=
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
name|nproc
operator|!=
name|NULL
condition|)
block|{
name|nfscl_filllockowner
argument_list|(
name|nproc
argument_list|,
name|own
argument_list|)
expr_stmt|;
name|ownp
operator|=
name|own
expr_stmt|;
block|}
else|else
block|{
name|ownp
operator|=
name|rown
expr_stmt|;
block|}
comment|/* Search the client list */
name|LIST_FOREACH
argument_list|(
argument|owp
argument_list|,
argument|ohp
argument_list|,
argument|nfsow_list
argument_list|)
block|{
if|if
condition|(
operator|!
name|NFSBCMP
argument_list|(
name|owp
operator|->
name|nfsow_owner
argument_list|,
name|ownp
argument_list|,
name|NFSV4CL_LOCKNAMELEN
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|owp
operator|!=
name|NULL
condition|)
block|{
comment|/* and look for the correct open */
name|LIST_FOREACH
argument_list|(
argument|op
argument_list|,
argument|&owp->nfsow_open
argument_list|,
argument|nfso_list
argument_list|)
block|{
if|if
condition|(
name|op
operator|->
name|nfso_fhlen
operator|==
name|fhlen
operator|&&
operator|!
name|NFSBCMP
argument_list|(
name|op
operator|->
name|nfso_fh
argument_list|,
name|nfhp
argument_list|,
name|fhlen
argument_list|)
operator|&&
operator|(
name|op
operator|->
name|nfso_mode
operator|&
name|mode
operator|)
operator|==
name|mode
condition|)
block|{
break|break;
block|}
block|}
block|}
if|if
condition|(
name|rown
operator|!=
name|NULL
condition|)
break|break;
if|if
condition|(
name|op
operator|==
name|NULL
condition|)
name|nproc
operator|=
name|nfscl_getparent
argument_list|(
name|nproc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|op
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|EBADF
operator|)
return|;
block|}
if|if
condition|(
name|owpp
condition|)
operator|*
name|owpp
operator|=
name|owp
expr_stmt|;
operator|*
name|opp
operator|=
name|op
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Release use of an open owner. Called when open operations are done  * with the open owner.  */
end_comment

begin_function
name|APPLESTATIC
name|void
name|nfscl_ownerrelease
parameter_list|(
name|struct
name|nfsclowner
modifier|*
name|owp
parameter_list|,
name|__unused
name|int
name|error
parameter_list|,
name|__unused
name|int
name|candelete
parameter_list|,
name|int
name|unlocked
parameter_list|)
block|{
if|if
condition|(
name|owp
operator|==
name|NULL
condition|)
return|return;
name|NFSLOCKCLSTATE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|unlocked
condition|)
name|nfscl_lockunlock
argument_list|(
operator|&
name|owp
operator|->
name|nfsow_rwlock
argument_list|)
expr_stmt|;
name|nfscl_clrelease
argument_list|(
name|owp
operator|->
name|nfsow_clp
argument_list|)
expr_stmt|;
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Release use of an open structure under an open owner.  */
end_comment

begin_function
name|APPLESTATIC
name|void
name|nfscl_openrelease
parameter_list|(
name|struct
name|nfsclopen
modifier|*
name|op
parameter_list|,
name|int
name|error
parameter_list|,
name|int
name|candelete
parameter_list|)
block|{
name|struct
name|nfsclclient
modifier|*
name|clp
decl_stmt|;
name|struct
name|nfsclowner
modifier|*
name|owp
decl_stmt|;
if|if
condition|(
name|op
operator|==
name|NULL
condition|)
return|return;
name|NFSLOCKCLSTATE
argument_list|()
expr_stmt|;
name|owp
operator|=
name|op
operator|->
name|nfso_own
expr_stmt|;
name|nfscl_lockunlock
argument_list|(
operator|&
name|owp
operator|->
name|nfsow_rwlock
argument_list|)
expr_stmt|;
name|clp
operator|=
name|owp
operator|->
name|nfsow_clp
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|candelete
operator|&&
name|op
operator|->
name|nfso_opencnt
operator|==
literal|0
condition|)
name|nfscl_freeopen
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nfscl_clrelease
argument_list|(
name|clp
argument_list|)
expr_stmt|;
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called to get a clientid structure. It will optionally lock the  * client data structures to do the SetClientId/SetClientId_confirm,  * but will release that lock and return the clientid with a refernce  * count on it.  * If the "cred" argument is NULL, a new clientid should not be created.  * If the "p" argument is NULL, a SetClientID/SetClientIDConfirm cannot  * be done.  * It always clpp with a reference count on it, unless returning an error.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfscl_getcl
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|struct
name|nfsclclient
modifier|*
modifier|*
name|clpp
parameter_list|)
block|{
name|struct
name|nfsclclient
modifier|*
name|clp
decl_stmt|;
name|struct
name|nfsclclient
modifier|*
name|newclp
init|=
name|NULL
decl_stmt|;
name|struct
name|nfscllockowner
modifier|*
name|lp
decl_stmt|,
modifier|*
name|nlp
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
init|=
name|VFSTONFS
argument_list|(
name|vnode_mount
argument_list|(
name|vp
argument_list|)
argument_list|)
decl_stmt|;
name|char
name|uuid
index|[
name|HOSTUUIDLEN
index|]
decl_stmt|;
name|int
name|igotlock
init|=
literal|0
decl_stmt|,
name|error
decl_stmt|,
name|trystalecnt
decl_stmt|,
name|clidinusedelay
decl_stmt|,
name|i
decl_stmt|;
name|u_int16_t
name|idlen
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|cred
operator|!=
name|NULL
condition|)
block|{
name|getcredhostuuid
argument_list|(
name|cred
argument_list|,
name|uuid
argument_list|,
sizeof|sizeof
name|uuid
argument_list|)
expr_stmt|;
name|idlen
operator|=
name|strlen
argument_list|(
name|uuid
argument_list|)
expr_stmt|;
if|if
condition|(
name|idlen
operator|>
literal|0
condition|)
name|idlen
operator|+=
sizeof|sizeof
argument_list|(
name|u_int64_t
argument_list|)
expr_stmt|;
else|else
name|idlen
operator|+=
sizeof|sizeof
argument_list|(
name|u_int64_t
argument_list|)
operator|+
literal|16
expr_stmt|;
comment|/* 16 random bytes */
name|MALLOC
argument_list|(
name|newclp
argument_list|,
expr|struct
name|nfsclclient
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nfsclclient
argument_list|)
operator|+
name|idlen
operator|-
literal|1
argument_list|,
name|M_NFSCLCLIENT
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
block|}
name|NFSLOCKCLSTATE
argument_list|()
expr_stmt|;
name|clp
operator|=
name|nmp
operator|->
name|nm_clp
expr_stmt|;
if|if
condition|(
name|clp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|newclp
operator|==
name|NULL
condition|)
block|{
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
return|return
operator|(
name|EACCES
operator|)
return|;
block|}
name|clp
operator|=
name|newclp
expr_stmt|;
name|NFSBZERO
argument_list|(
operator|(
name|caddr_t
operator|)
name|clp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nfsclclient
argument_list|)
operator|+
name|idlen
operator|-
literal|1
argument_list|)
expr_stmt|;
name|clp
operator|->
name|nfsc_idlen
operator|=
name|idlen
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|clp
operator|->
name|nfsc_owner
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|clp
operator|->
name|nfsc_deleg
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NFSCLDELEGHASHSIZE
condition|;
name|i
operator|++
control|)
name|LIST_INIT
argument_list|(
operator|&
name|clp
operator|->
name|nfsc_deleghash
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|clp
operator|->
name|nfsc_defunctlockowner
argument_list|)
expr_stmt|;
name|clp
operator|->
name|nfsc_flags
operator|=
name|NFSCLFLAGS_INITED
expr_stmt|;
name|clp
operator|->
name|nfsc_clientidrev
operator|=
literal|1
expr_stmt|;
name|clp
operator|->
name|nfsc_cbident
operator|=
name|nfscl_nextcbident
argument_list|()
expr_stmt|;
name|nfscl_fillclid
argument_list|(
name|nmp
operator|->
name|nm_clval
argument_list|,
name|uuid
argument_list|,
name|clp
operator|->
name|nfsc_id
argument_list|,
name|clp
operator|->
name|nfsc_idlen
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|nfsclhead
argument_list|,
name|clp
argument_list|,
name|nfsc_list
argument_list|)
expr_stmt|;
name|nmp
operator|->
name|nm_clp
operator|=
name|clp
expr_stmt|;
name|clp
operator|->
name|nfsc_nmp
operator|=
name|nmp
expr_stmt|;
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
name|nfscl_start_renewthread
argument_list|(
name|clp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
if|if
condition|(
name|newclp
operator|!=
name|NULL
condition|)
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|newclp
argument_list|,
name|M_NFSCLCLIENT
argument_list|)
expr_stmt|;
block|}
name|NFSLOCKCLSTATE
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|clp
operator|->
name|nfsc_flags
operator|&
name|NFSCLFLAGS_HASCLIENTID
operator|)
operator|==
literal|0
operator|&&
operator|!
name|igotlock
condition|)
name|igotlock
operator|=
name|nfsv4_lock
argument_list|(
operator|&
name|clp
operator|->
name|nfsc_lock
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
name|NFSCLSTATEMUTEXPTR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|igotlock
condition|)
name|nfsv4_getref
argument_list|(
operator|&
name|clp
operator|->
name|nfsc_lock
argument_list|,
name|NULL
argument_list|,
name|NFSCLSTATEMUTEXPTR
argument_list|)
expr_stmt|;
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
comment|/* 	 * If it needs a clientid, do the setclientid now. 	 */
if|if
condition|(
operator|(
name|clp
operator|->
name|nfsc_flags
operator|&
name|NFSCLFLAGS_HASCLIENTID
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|igotlock
condition|)
name|panic
argument_list|(
literal|"nfscl_clget"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
name|cred
operator|==
name|NULL
condition|)
block|{
name|NFSLOCKCLSTATE
argument_list|()
expr_stmt|;
name|nfsv4_unlock
argument_list|(
operator|&
name|clp
operator|->
name|nfsc_lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
return|return
operator|(
name|EACCES
operator|)
return|;
block|}
comment|/* get rid of defunct lockowners */
name|LIST_FOREACH_SAFE
argument_list|(
argument|lp
argument_list|,
argument|&clp->nfsc_defunctlockowner
argument_list|,
argument|nfsl_list
argument_list|,
argument|nlp
argument_list|)
block|{
name|nfscl_freelockowner
argument_list|(
name|lp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If RFC3530 Sec. 14.2.33 is taken literally, 		 * NFSERR_CLIDINUSE will be returned persistently for the 		 * case where a new mount of the same file system is using 		 * a different principal. In practice, NFSERR_CLIDINUSE is 		 * only returned when there is outstanding unexpired state 		 * on the clientid. As such, try for twice the lease 		 * interval, if we know what that is. Otherwise, make a 		 * wild ass guess. 		 * The case of returning NFSERR_STALECLIENTID is far less 		 * likely, but might occur if there is a significant delay 		 * between doing the SetClientID and SetClientIDConfirm Ops, 		 * such that the server throws away the clientid before 		 * receiving the SetClientIDConfirm. 		 */
if|if
condition|(
name|clp
operator|->
name|nfsc_renew
operator|>
literal|0
condition|)
name|clidinusedelay
operator|=
name|NFSCL_LEASE
argument_list|(
name|clp
operator|->
name|nfsc_renew
argument_list|)
operator|*
literal|2
expr_stmt|;
else|else
name|clidinusedelay
operator|=
literal|120
expr_stmt|;
name|trystalecnt
operator|=
literal|3
expr_stmt|;
do|do
block|{
name|error
operator|=
name|nfsrpc_setclient
argument_list|(
name|VFSTONFS
argument_list|(
name|vnode_mount
argument_list|(
name|vp
argument_list|)
argument_list|)
argument_list|,
name|clp
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|NFSERR_STALECLIENTID
operator|||
name|error
operator|==
name|NFSERR_STALEDONTRECOVER
operator|||
name|error
operator|==
name|NFSERR_CLIDINUSE
condition|)
block|{
operator|(
name|void
operator|)
name|nfs_catnap
argument_list|(
name|PZERO
argument_list|,
name|error
argument_list|,
literal|"nfs_setcl"
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|(
operator|(
name|error
operator|==
name|NFSERR_STALECLIENTID
operator|||
name|error
operator|==
name|NFSERR_STALEDONTRECOVER
operator|)
operator|&&
operator|--
name|trystalecnt
operator|>
literal|0
operator|)
operator|||
operator|(
name|error
operator|==
name|NFSERR_CLIDINUSE
operator|&&
operator|--
name|clidinusedelay
operator|>
literal|0
operator|)
condition|)
do|;
if|if
condition|(
name|error
condition|)
block|{
name|NFSLOCKCLSTATE
argument_list|()
expr_stmt|;
name|nfsv4_unlock
argument_list|(
operator|&
name|clp
operator|->
name|nfsc_lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|clp
operator|->
name|nfsc_flags
operator||=
name|NFSCLFLAGS_HASCLIENTID
expr_stmt|;
block|}
if|if
condition|(
name|igotlock
condition|)
block|{
name|NFSLOCKCLSTATE
argument_list|()
expr_stmt|;
name|nfsv4_unlock
argument_list|(
operator|&
name|clp
operator|->
name|nfsc_lock
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
block|}
operator|*
name|clpp
operator|=
name|clp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get a reference to a clientid and return it, if valid.  */
end_comment

begin_function
name|APPLESTATIC
name|struct
name|nfsclclient
modifier|*
name|nfscl_findcl
parameter_list|(
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|)
block|{
name|struct
name|nfsclclient
modifier|*
name|clp
decl_stmt|;
name|clp
operator|=
name|nmp
operator|->
name|nm_clp
expr_stmt|;
if|if
condition|(
name|clp
operator|==
name|NULL
operator|||
operator|!
operator|(
name|clp
operator|->
name|nfsc_flags
operator|&
name|NFSCLFLAGS_HASCLIENTID
operator|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|clp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Release the clientid structure. It may be locked or reference counted.  */
end_comment

begin_function
specifier|static
name|void
name|nfscl_clrelease
parameter_list|(
name|struct
name|nfsclclient
modifier|*
name|clp
parameter_list|)
block|{
if|if
condition|(
name|clp
operator|->
name|nfsc_lock
operator|.
name|nfslock_lock
operator|&
name|NFSV4LOCK_LOCK
condition|)
name|nfsv4_unlock
argument_list|(
operator|&
name|clp
operator|->
name|nfsc_lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|nfsv4_relref
argument_list|(
operator|&
name|clp
operator|->
name|nfsc_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * External call for nfscl_clrelease.  */
end_comment

begin_function
name|APPLESTATIC
name|void
name|nfscl_clientrelease
parameter_list|(
name|struct
name|nfsclclient
modifier|*
name|clp
parameter_list|)
block|{
name|NFSLOCKCLSTATE
argument_list|()
expr_stmt|;
if|if
condition|(
name|clp
operator|->
name|nfsc_lock
operator|.
name|nfslock_lock
operator|&
name|NFSV4LOCK_LOCK
condition|)
name|nfsv4_unlock
argument_list|(
operator|&
name|clp
operator|->
name|nfsc_lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|nfsv4_relref
argument_list|(
operator|&
name|clp
operator|->
name|nfsc_lock
argument_list|)
expr_stmt|;
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called when wanting to lock a byte region.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfscl_getbytelock
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|u_int64_t
name|off
parameter_list|,
name|u_int64_t
name|len
parameter_list|,
name|short
name|type
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|struct
name|nfsclclient
modifier|*
name|rclp
parameter_list|,
name|int
name|recovery
parameter_list|,
name|u_int8_t
modifier|*
name|rownp
parameter_list|,
name|u_int8_t
modifier|*
name|ropenownp
parameter_list|,
name|struct
name|nfscllockowner
modifier|*
modifier|*
name|lpp
parameter_list|,
name|int
modifier|*
name|newonep
parameter_list|,
name|int
modifier|*
name|donelocallyp
parameter_list|)
block|{
name|struct
name|nfscllockowner
modifier|*
name|lp
decl_stmt|;
name|struct
name|nfsclopen
modifier|*
name|op
decl_stmt|;
name|struct
name|nfsclclient
modifier|*
name|clp
decl_stmt|;
name|struct
name|nfscllockowner
modifier|*
name|nlp
decl_stmt|;
name|struct
name|nfscllock
modifier|*
name|nlop
decl_stmt|,
modifier|*
name|otherlop
decl_stmt|;
name|struct
name|nfscldeleg
modifier|*
name|dp
init|=
name|NULL
decl_stmt|,
modifier|*
name|ldp
init|=
name|NULL
decl_stmt|;
name|struct
name|nfscllockownerhead
modifier|*
name|lhp
init|=
name|NULL
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|np
decl_stmt|;
name|u_int8_t
name|own
index|[
name|NFSV4CL_LOCKNAMELEN
index|]
decl_stmt|,
modifier|*
name|ownp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|ret
decl_stmt|,
name|donelocally
init|=
literal|0
decl_stmt|;
name|u_int32_t
name|mode
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|F_WRLCK
condition|)
name|mode
operator|=
name|NFSV4OPEN_ACCESSWRITE
expr_stmt|;
else|else
name|mode
operator|=
name|NFSV4OPEN_ACCESSREAD
expr_stmt|;
name|np
operator|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
expr_stmt|;
operator|*
name|lpp
operator|=
name|NULL
expr_stmt|;
operator|*
name|newonep
operator|=
literal|0
expr_stmt|;
operator|*
name|donelocallyp
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Might need these, so MALLOC them now, to 	 * avoid a tsleep() in MALLOC later. 	 */
name|MALLOC
argument_list|(
name|nlp
argument_list|,
expr|struct
name|nfscllockowner
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nfscllockowner
argument_list|)
argument_list|,
name|M_NFSCLLOCKOWNER
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|MALLOC
argument_list|(
name|otherlop
argument_list|,
expr|struct
name|nfscllock
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nfscllock
argument_list|)
argument_list|,
name|M_NFSCLLOCK
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|MALLOC
argument_list|(
name|nlop
argument_list|,
expr|struct
name|nfscllock
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nfscllock
argument_list|)
argument_list|,
name|M_NFSCLLOCK
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|nlop
operator|->
name|nfslo_type
operator|=
name|type
expr_stmt|;
name|nlop
operator|->
name|nfslo_first
operator|=
name|off
expr_stmt|;
if|if
condition|(
name|len
operator|==
name|NFS64BITSSET
condition|)
block|{
name|nlop
operator|->
name|nfslo_end
operator|=
name|NFS64BITSSET
expr_stmt|;
block|}
else|else
block|{
name|nlop
operator|->
name|nfslo_end
operator|=
name|off
operator|+
name|len
expr_stmt|;
if|if
condition|(
name|nlop
operator|->
name|nfslo_end
operator|<=
name|nlop
operator|->
name|nfslo_first
condition|)
name|error
operator|=
name|NFSERR_INVAL
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|error
condition|)
block|{
if|if
condition|(
name|recovery
condition|)
name|clp
operator|=
name|rclp
expr_stmt|;
else|else
name|error
operator|=
name|nfscl_getcl
argument_list|(
name|vp
argument_list|,
name|cred
argument_list|,
name|p
argument_list|,
operator|&
name|clp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|nlp
argument_list|,
name|M_NFSCLLOCKOWNER
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|otherlop
argument_list|,
name|M_NFSCLLOCK
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|nlop
argument_list|,
name|M_NFSCLLOCK
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|op
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|recovery
condition|)
block|{
name|ownp
operator|=
name|rownp
expr_stmt|;
block|}
else|else
block|{
name|nfscl_filllockowner
argument_list|(
name|p
argument_list|,
name|own
argument_list|)
expr_stmt|;
name|ownp
operator|=
name|own
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|recovery
condition|)
block|{
name|NFSLOCKCLSTATE
argument_list|()
expr_stmt|;
comment|/* 		 * First, search for a delegation. If one exists for this file, 		 * the lock can be done locally against it, so long as there 		 * isn't a local lock conflict. 		 */
name|ldp
operator|=
name|dp
operator|=
name|nfscl_finddeleg
argument_list|(
name|clp
argument_list|,
name|np
operator|->
name|n_fhp
operator|->
name|nfh_fh
argument_list|,
name|np
operator|->
name|n_fhp
operator|->
name|nfh_len
argument_list|)
expr_stmt|;
comment|/* Just sanity check for correct type of delegation */
if|if
condition|(
name|dp
operator|!=
name|NULL
operator|&&
operator|(
operator|(
name|dp
operator|->
name|nfsdl_flags
operator|&
operator|(
name|NFSCLDL_RECALL
operator||
name|NFSCLDL_DELEGRET
operator|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|type
operator|==
name|F_WRLCK
operator|&&
operator|(
name|dp
operator|->
name|nfsdl_flags
operator|&
name|NFSCLDL_WRITE
operator|)
operator|==
literal|0
operator|)
operator|)
condition|)
name|dp
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|dp
operator|!=
name|NULL
condition|)
block|{
comment|/* Now, find the associated open to get the correct openowner */
name|ret
operator|=
name|nfscl_getopen
argument_list|(
operator|&
name|dp
operator|->
name|nfsdl_owner
argument_list|,
name|np
operator|->
name|n_fhp
operator|->
name|nfh_fh
argument_list|,
name|np
operator|->
name|n_fhp
operator|->
name|nfh_len
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|,
name|mode
argument_list|,
name|NULL
argument_list|,
operator|&
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|ret
operator|=
name|nfscl_getopen
argument_list|(
operator|&
name|clp
operator|->
name|nfsc_owner
argument_list|,
name|np
operator|->
name|n_fhp
operator|->
name|nfh_fh
argument_list|,
name|np
operator|->
name|n_fhp
operator|->
name|nfh_len
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|,
name|mode
argument_list|,
name|NULL
argument_list|,
operator|&
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|lhp
operator|=
operator|&
name|dp
operator|->
name|nfsdl_lock
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|clp
operator|->
name|nfsc_deleg
argument_list|,
name|dp
argument_list|,
name|nfsdl_list
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|clp
operator|->
name|nfsc_deleg
argument_list|,
name|dp
argument_list|,
name|nfsdl_list
argument_list|)
expr_stmt|;
name|dp
operator|->
name|nfsdl_timestamp
operator|=
name|NFSD_MONOSEC
operator|+
literal|120
expr_stmt|;
name|donelocally
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|dp
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|donelocally
condition|)
block|{
comment|/* 		 * Get the related Open. 		 */
if|if
condition|(
name|recovery
condition|)
name|error
operator|=
name|nfscl_getopen
argument_list|(
operator|&
name|clp
operator|->
name|nfsc_owner
argument_list|,
name|np
operator|->
name|n_fhp
operator|->
name|nfh_fh
argument_list|,
name|np
operator|->
name|n_fhp
operator|->
name|nfh_len
argument_list|,
name|ropenownp
argument_list|,
name|NULL
argument_list|,
name|mode
argument_list|,
name|NULL
argument_list|,
operator|&
name|op
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|nfscl_getopen
argument_list|(
operator|&
name|clp
operator|->
name|nfsc_owner
argument_list|,
name|np
operator|->
name|n_fhp
operator|->
name|nfh_fh
argument_list|,
name|np
operator|->
name|n_fhp
operator|->
name|nfh_len
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|,
name|mode
argument_list|,
name|NULL
argument_list|,
operator|&
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|lhp
operator|=
operator|&
name|op
operator|->
name|nfso_lock
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|error
operator|&&
operator|!
name|recovery
condition|)
name|error
operator|=
name|nfscl_localconflict
argument_list|(
name|clp
argument_list|,
name|np
operator|->
name|n_fhp
operator|->
name|nfh_fh
argument_list|,
name|np
operator|->
name|n_fhp
operator|->
name|nfh_len
argument_list|,
name|nlop
argument_list|,
name|ownp
argument_list|,
name|ldp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
operator|!
name|recovery
condition|)
block|{
name|nfscl_clrelease
argument_list|(
name|clp
argument_list|)
expr_stmt|;
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
block|}
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|nlp
argument_list|,
name|M_NFSCLLOCKOWNER
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|otherlop
argument_list|,
name|M_NFSCLLOCK
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|nlop
argument_list|,
name|M_NFSCLLOCK
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Ok, see if a lockowner exists and create one, as required. 	 */
name|LIST_FOREACH
argument_list|(
argument|lp
argument_list|,
argument|lhp
argument_list|,
argument|nfsl_list
argument_list|)
block|{
if|if
condition|(
operator|!
name|NFSBCMP
argument_list|(
name|lp
operator|->
name|nfsl_owner
argument_list|,
name|ownp
argument_list|,
name|NFSV4CL_LOCKNAMELEN
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|lp
operator|==
name|NULL
condition|)
block|{
name|NFSBCOPY
argument_list|(
name|ownp
argument_list|,
name|nlp
operator|->
name|nfsl_owner
argument_list|,
name|NFSV4CL_LOCKNAMELEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|recovery
condition|)
name|NFSBCOPY
argument_list|(
name|ropenownp
argument_list|,
name|nlp
operator|->
name|nfsl_openowner
argument_list|,
name|NFSV4CL_LOCKNAMELEN
argument_list|)
expr_stmt|;
else|else
name|NFSBCOPY
argument_list|(
name|op
operator|->
name|nfso_own
operator|->
name|nfsow_owner
argument_list|,
name|nlp
operator|->
name|nfsl_openowner
argument_list|,
name|NFSV4CL_LOCKNAMELEN
argument_list|)
expr_stmt|;
name|nlp
operator|->
name|nfsl_seqid
operator|=
literal|0
expr_stmt|;
name|nlp
operator|->
name|nfsl_defunct
operator|=
literal|0
expr_stmt|;
name|nlp
operator|->
name|nfsl_inprog
operator|=
name|NULL
expr_stmt|;
name|nfscl_lockinit
argument_list|(
operator|&
name|nlp
operator|->
name|nfsl_rwlock
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|nlp
operator|->
name|nfsl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|donelocally
condition|)
block|{
name|nlp
operator|->
name|nfsl_open
operator|=
name|NULL
expr_stmt|;
name|newnfsstats
operator|.
name|cllocallockowners
operator|++
expr_stmt|;
block|}
else|else
block|{
name|nlp
operator|->
name|nfsl_open
operator|=
name|op
expr_stmt|;
name|newnfsstats
operator|.
name|cllockowners
operator|++
expr_stmt|;
block|}
name|LIST_INSERT_HEAD
argument_list|(
name|lhp
argument_list|,
name|nlp
argument_list|,
name|nfsl_list
argument_list|)
expr_stmt|;
name|lp
operator|=
name|nlp
expr_stmt|;
name|nlp
operator|=
name|NULL
expr_stmt|;
operator|*
name|newonep
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * Now, update the byte ranges for locks. 	 */
name|ret
operator|=
name|nfscl_updatelock
argument_list|(
name|lp
argument_list|,
operator|&
name|nlop
argument_list|,
operator|&
name|otherlop
argument_list|,
name|donelocally
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
name|donelocally
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|donelocally
condition|)
block|{
operator|*
name|donelocallyp
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|recovery
condition|)
name|nfscl_clrelease
argument_list|(
name|clp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Serial modifications on the lock owner for multiple threads 		 * for the same process using a read/write lock. 		 */
if|if
condition|(
operator|!
name|recovery
condition|)
name|nfscl_lockexcl
argument_list|(
operator|&
name|lp
operator|->
name|nfsl_rwlock
argument_list|,
name|NFSCLSTATEMUTEXPTR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|recovery
condition|)
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
if|if
condition|(
name|nlp
condition|)
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|nlp
argument_list|,
name|M_NFSCLLOCKOWNER
argument_list|)
expr_stmt|;
if|if
condition|(
name|nlop
condition|)
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|nlop
argument_list|,
name|M_NFSCLLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|otherlop
condition|)
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|otherlop
argument_list|,
name|M_NFSCLLOCK
argument_list|)
expr_stmt|;
operator|*
name|lpp
operator|=
name|lp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called to unlock a byte range, for LockU.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfscl_relbytelock
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|u_int64_t
name|off
parameter_list|,
name|u_int64_t
name|len
parameter_list|,
name|__unused
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|int
name|callcnt
parameter_list|,
name|struct
name|nfsclclient
modifier|*
name|clp
parameter_list|,
name|struct
name|nfscllockowner
modifier|*
modifier|*
name|lpp
parameter_list|,
name|int
modifier|*
name|dorpcp
parameter_list|)
block|{
name|struct
name|nfscllockowner
modifier|*
name|lp
decl_stmt|;
name|struct
name|nfsclowner
modifier|*
name|owp
decl_stmt|;
name|struct
name|nfsclopen
modifier|*
name|op
decl_stmt|;
name|struct
name|nfscllock
modifier|*
name|nlop
decl_stmt|,
modifier|*
name|other_lop
init|=
name|NULL
decl_stmt|;
name|struct
name|nfscldeleg
modifier|*
name|dp
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|np
decl_stmt|;
name|u_int8_t
name|own
index|[
name|NFSV4CL_LOCKNAMELEN
index|]
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|,
name|fnd
decl_stmt|;
name|np
operator|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
expr_stmt|;
operator|*
name|lpp
operator|=
name|NULL
expr_stmt|;
operator|*
name|dorpcp
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Might need these, so MALLOC them now, to 	 * avoid a tsleep() in MALLOC later. 	 */
name|MALLOC
argument_list|(
name|nlop
argument_list|,
expr|struct
name|nfscllock
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nfscllock
argument_list|)
argument_list|,
name|M_NFSCLLOCK
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|nlop
operator|->
name|nfslo_type
operator|=
name|F_UNLCK
expr_stmt|;
name|nlop
operator|->
name|nfslo_first
operator|=
name|off
expr_stmt|;
if|if
condition|(
name|len
operator|==
name|NFS64BITSSET
condition|)
block|{
name|nlop
operator|->
name|nfslo_end
operator|=
name|NFS64BITSSET
expr_stmt|;
block|}
else|else
block|{
name|nlop
operator|->
name|nfslo_end
operator|=
name|off
operator|+
name|len
expr_stmt|;
if|if
condition|(
name|nlop
operator|->
name|nfslo_end
operator|<=
name|nlop
operator|->
name|nfslo_first
condition|)
block|{
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|nlop
argument_list|,
name|M_NFSCLLOCK
argument_list|)
expr_stmt|;
return|return
operator|(
name|NFSERR_INVAL
operator|)
return|;
block|}
block|}
if|if
condition|(
name|callcnt
operator|==
literal|0
condition|)
block|{
name|MALLOC
argument_list|(
name|other_lop
argument_list|,
expr|struct
name|nfscllock
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nfscllock
argument_list|)
argument_list|,
name|M_NFSCLLOCK
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
operator|*
name|other_lop
operator|=
operator|*
name|nlop
expr_stmt|;
block|}
name|nfscl_filllockowner
argument_list|(
name|p
argument_list|,
name|own
argument_list|)
expr_stmt|;
name|dp
operator|=
name|NULL
expr_stmt|;
name|NFSLOCKCLSTATE
argument_list|()
expr_stmt|;
if|if
condition|(
name|callcnt
operator|==
literal|0
condition|)
name|dp
operator|=
name|nfscl_finddeleg
argument_list|(
name|clp
argument_list|,
name|np
operator|->
name|n_fhp
operator|->
name|nfh_fh
argument_list|,
name|np
operator|->
name|n_fhp
operator|->
name|nfh_len
argument_list|)
expr_stmt|;
comment|/* 	 * First, unlock any local regions on a delegation. 	 */
if|if
condition|(
name|dp
operator|!=
name|NULL
condition|)
block|{
comment|/* Look for this lockowner. */
name|LIST_FOREACH
argument_list|(
argument|lp
argument_list|,
argument|&dp->nfsdl_lock
argument_list|,
argument|nfsl_list
argument_list|)
block|{
if|if
condition|(
operator|!
name|NFSBCMP
argument_list|(
name|lp
operator|->
name|nfsl_owner
argument_list|,
name|own
argument_list|,
name|NFSV4CL_LOCKNAMELEN
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|lp
operator|!=
name|NULL
condition|)
comment|/* Use other_lop, so nlop is still available */
operator|(
name|void
operator|)
name|nfscl_updatelock
argument_list|(
name|lp
argument_list|,
operator|&
name|other_lop
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Now, find a matching open/lockowner that hasn't already been done, 	 * as marked by nfsl_inprog. 	 */
name|lp
operator|=
name|NULL
expr_stmt|;
name|fnd
operator|=
literal|0
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|owp
argument_list|,
argument|&clp->nfsc_owner
argument_list|,
argument|nfsow_list
argument_list|)
block|{
name|LIST_FOREACH
argument_list|(
argument|op
argument_list|,
argument|&owp->nfsow_open
argument_list|,
argument|nfso_list
argument_list|)
block|{
if|if
condition|(
name|op
operator|->
name|nfso_fhlen
operator|==
name|np
operator|->
name|n_fhp
operator|->
name|nfh_len
operator|&&
operator|!
name|NFSBCMP
argument_list|(
name|op
operator|->
name|nfso_fh
argument_list|,
name|np
operator|->
name|n_fhp
operator|->
name|nfh_fh
argument_list|,
name|op
operator|->
name|nfso_fhlen
argument_list|)
condition|)
block|{
name|LIST_FOREACH
argument_list|(
argument|lp
argument_list|,
argument|&op->nfso_lock
argument_list|,
argument|nfsl_list
argument_list|)
block|{
if|if
condition|(
name|lp
operator|->
name|nfsl_inprog
operator|==
name|NULL
operator|&&
operator|!
name|NFSBCMP
argument_list|(
name|lp
operator|->
name|nfsl_owner
argument_list|,
name|own
argument_list|,
name|NFSV4CL_LOCKNAMELEN
argument_list|)
condition|)
block|{
name|fnd
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|fnd
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|fnd
condition|)
break|break;
block|}
if|if
condition|(
name|lp
operator|!=
name|NULL
condition|)
block|{
name|ret
operator|=
name|nfscl_updatelock
argument_list|(
name|lp
argument_list|,
operator|&
name|nlop
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
operator|*
name|dorpcp
operator|=
literal|1
expr_stmt|;
comment|/* 		 * Serial modifications on the lock owner for multiple 		 * threads for the same process using a read/write lock. 		 */
name|lp
operator|->
name|nfsl_inprog
operator|=
name|p
expr_stmt|;
name|nfscl_lockexcl
argument_list|(
operator|&
name|lp
operator|->
name|nfsl_rwlock
argument_list|,
name|NFSCLSTATEMUTEXPTR
argument_list|)
expr_stmt|;
operator|*
name|lpp
operator|=
name|lp
expr_stmt|;
block|}
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
if|if
condition|(
name|nlop
condition|)
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|nlop
argument_list|,
name|M_NFSCLLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|other_lop
condition|)
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|other_lop
argument_list|,
name|M_NFSCLLOCK
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Release all lockowners marked in progess for this process and file.  */
end_comment

begin_function
name|APPLESTATIC
name|void
name|nfscl_releasealllocks
parameter_list|(
name|struct
name|nfsclclient
modifier|*
name|clp
parameter_list|,
name|vnode_t
name|vp
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|nfsclowner
modifier|*
name|owp
decl_stmt|;
name|struct
name|nfsclopen
modifier|*
name|op
decl_stmt|;
name|struct
name|nfscllockowner
modifier|*
name|lp
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|np
decl_stmt|;
name|u_int8_t
name|own
index|[
name|NFSV4CL_LOCKNAMELEN
index|]
decl_stmt|;
name|np
operator|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|nfscl_filllockowner
argument_list|(
name|p
argument_list|,
name|own
argument_list|)
expr_stmt|;
name|NFSLOCKCLSTATE
argument_list|()
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|owp
argument_list|,
argument|&clp->nfsc_owner
argument_list|,
argument|nfsow_list
argument_list|)
block|{
name|LIST_FOREACH
argument_list|(
argument|op
argument_list|,
argument|&owp->nfsow_open
argument_list|,
argument|nfso_list
argument_list|)
block|{
if|if
condition|(
name|op
operator|->
name|nfso_fhlen
operator|==
name|np
operator|->
name|n_fhp
operator|->
name|nfh_len
operator|&&
operator|!
name|NFSBCMP
argument_list|(
name|op
operator|->
name|nfso_fh
argument_list|,
name|np
operator|->
name|n_fhp
operator|->
name|nfh_fh
argument_list|,
name|op
operator|->
name|nfso_fhlen
argument_list|)
condition|)
block|{
name|LIST_FOREACH
argument_list|(
argument|lp
argument_list|,
argument|&op->nfso_lock
argument_list|,
argument|nfsl_list
argument_list|)
block|{
if|if
condition|(
name|lp
operator|->
name|nfsl_inprog
operator|==
name|p
operator|&&
operator|!
name|NFSBCMP
argument_list|(
name|lp
operator|->
name|nfsl_owner
argument_list|,
name|own
argument_list|,
name|NFSV4CL_LOCKNAMELEN
argument_list|)
condition|)
block|{
name|lp
operator|->
name|nfsl_inprog
operator|=
name|NULL
expr_stmt|;
name|nfscl_lockunlock
argument_list|(
operator|&
name|lp
operator|->
name|nfsl_rwlock
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
name|nfscl_clrelease
argument_list|(
name|clp
argument_list|)
expr_stmt|;
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called to find out if any bytes within the byte range specified are  * write locked by the calling process. Used to determine if flushing  * is required before a LockU.  * If in doubt, return 1, so the flush will occur.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfscl_checkwritelocked
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|struct
name|flock
modifier|*
name|fl
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|nfsclowner
modifier|*
name|owp
decl_stmt|;
name|struct
name|nfscllockowner
modifier|*
name|lp
decl_stmt|;
name|struct
name|nfsclopen
modifier|*
name|op
decl_stmt|;
name|struct
name|nfsclclient
modifier|*
name|clp
decl_stmt|;
name|struct
name|nfscllock
modifier|*
name|lop
decl_stmt|;
name|struct
name|nfscldeleg
modifier|*
name|dp
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|np
decl_stmt|;
name|u_int64_t
name|off
decl_stmt|,
name|end
decl_stmt|;
name|u_int8_t
name|own
index|[
name|NFSV4CL_LOCKNAMELEN
index|]
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|np
operator|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|fl
operator|->
name|l_whence
condition|)
block|{
case|case
name|SEEK_SET
case|:
case|case
name|SEEK_CUR
case|:
comment|/* 		 * Caller is responsible for adding any necessary offset 		 * when SEEK_CUR is used. 		 */
name|off
operator|=
name|fl
operator|->
name|l_start
expr_stmt|;
break|break;
case|case
name|SEEK_END
case|:
name|off
operator|=
name|np
operator|->
name|n_size
operator|+
name|fl
operator|->
name|l_start
expr_stmt|;
break|break;
default|default:
return|return
operator|(
literal|1
operator|)
return|;
block|}
empty_stmt|;
if|if
condition|(
name|fl
operator|->
name|l_len
operator|!=
literal|0
condition|)
block|{
name|end
operator|=
name|off
operator|+
name|fl
operator|->
name|l_len
expr_stmt|;
if|if
condition|(
name|end
operator|<
name|off
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
name|end
operator|=
name|NFS64BITSSET
expr_stmt|;
block|}
name|error
operator|=
name|nfscl_getcl
argument_list|(
name|vp
argument_list|,
name|cred
argument_list|,
name|p
argument_list|,
operator|&
name|clp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|nfscl_filllockowner
argument_list|(
name|p
argument_list|,
name|own
argument_list|)
expr_stmt|;
name|NFSLOCKCLSTATE
argument_list|()
expr_stmt|;
comment|/* 	 * First check the delegation locks. 	 */
name|dp
operator|=
name|nfscl_finddeleg
argument_list|(
name|clp
argument_list|,
name|np
operator|->
name|n_fhp
operator|->
name|nfh_fh
argument_list|,
name|np
operator|->
name|n_fhp
operator|->
name|nfh_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|!=
name|NULL
condition|)
block|{
name|LIST_FOREACH
argument_list|(
argument|lp
argument_list|,
argument|&dp->nfsdl_lock
argument_list|,
argument|nfsl_list
argument_list|)
block|{
if|if
condition|(
operator|!
name|NFSBCMP
argument_list|(
name|lp
operator|->
name|nfsl_owner
argument_list|,
name|own
argument_list|,
name|NFSV4CL_LOCKNAMELEN
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|lp
operator|!=
name|NULL
condition|)
block|{
name|LIST_FOREACH
argument_list|(
argument|lop
argument_list|,
argument|&lp->nfsl_lock
argument_list|,
argument|nfslo_list
argument_list|)
block|{
if|if
condition|(
name|lop
operator|->
name|nfslo_first
operator|>=
name|end
condition|)
break|break;
if|if
condition|(
name|lop
operator|->
name|nfslo_end
operator|<=
name|off
condition|)
continue|continue;
if|if
condition|(
name|lop
operator|->
name|nfslo_type
operator|==
name|F_WRLCK
condition|)
block|{
name|nfscl_clrelease
argument_list|(
name|clp
argument_list|)
expr_stmt|;
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
block|}
block|}
comment|/* 	 * Now, check state against the server. 	 */
name|LIST_FOREACH
argument_list|(
argument|owp
argument_list|,
argument|&clp->nfsc_owner
argument_list|,
argument|nfsow_list
argument_list|)
block|{
name|LIST_FOREACH
argument_list|(
argument|op
argument_list|,
argument|&owp->nfsow_open
argument_list|,
argument|nfso_list
argument_list|)
block|{
if|if
condition|(
name|op
operator|->
name|nfso_fhlen
operator|==
name|np
operator|->
name|n_fhp
operator|->
name|nfh_len
operator|&&
operator|!
name|NFSBCMP
argument_list|(
name|op
operator|->
name|nfso_fh
argument_list|,
name|np
operator|->
name|n_fhp
operator|->
name|nfh_fh
argument_list|,
name|op
operator|->
name|nfso_fhlen
argument_list|)
condition|)
block|{
name|LIST_FOREACH
argument_list|(
argument|lp
argument_list|,
argument|&op->nfso_lock
argument_list|,
argument|nfsl_list
argument_list|)
block|{
if|if
condition|(
operator|!
name|NFSBCMP
argument_list|(
name|lp
operator|->
name|nfsl_owner
argument_list|,
name|own
argument_list|,
name|NFSV4CL_LOCKNAMELEN
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|lp
operator|!=
name|NULL
condition|)
block|{
name|LIST_FOREACH
argument_list|(
argument|lop
argument_list|,
argument|&lp->nfsl_lock
argument_list|,
argument|nfslo_list
argument_list|)
block|{
if|if
condition|(
name|lop
operator|->
name|nfslo_first
operator|>=
name|end
condition|)
break|break;
if|if
condition|(
name|lop
operator|->
name|nfslo_end
operator|<=
name|off
condition|)
continue|continue;
if|if
condition|(
name|lop
operator|->
name|nfslo_type
operator|==
name|F_WRLCK
condition|)
block|{
name|nfscl_clrelease
argument_list|(
name|clp
argument_list|)
expr_stmt|;
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
block|}
block|}
block|}
block|}
name|nfscl_clrelease
argument_list|(
name|clp
argument_list|)
expr_stmt|;
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Release a byte range lock owner structure.  */
end_comment

begin_function
name|APPLESTATIC
name|void
name|nfscl_lockrelease
parameter_list|(
name|struct
name|nfscllockowner
modifier|*
name|lp
parameter_list|,
name|int
name|error
parameter_list|,
name|int
name|candelete
parameter_list|)
block|{
name|struct
name|nfsclclient
modifier|*
name|clp
decl_stmt|;
if|if
condition|(
name|lp
operator|==
name|NULL
condition|)
return|return;
name|NFSLOCKCLSTATE
argument_list|()
expr_stmt|;
name|clp
operator|=
name|lp
operator|->
name|nfsl_open
operator|->
name|nfso_own
operator|->
name|nfsow_clp
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|candelete
operator|&&
operator|(
name|lp
operator|->
name|nfsl_rwlock
operator|.
name|nfslock_lock
operator|&
name|NFSV4LOCK_WANTED
operator|)
operator|==
literal|0
condition|)
name|nfscl_freelockowner
argument_list|(
name|lp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|nfscl_lockunlock
argument_list|(
operator|&
name|lp
operator|->
name|nfsl_rwlock
argument_list|)
expr_stmt|;
name|nfscl_clrelease
argument_list|(
name|clp
argument_list|)
expr_stmt|;
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free up an open structure and any associated byte range lock structures.  */
end_comment

begin_function
name|APPLESTATIC
name|void
name|nfscl_freeopen
parameter_list|(
name|struct
name|nfsclopen
modifier|*
name|op
parameter_list|,
name|int
name|local
parameter_list|)
block|{
name|LIST_REMOVE
argument_list|(
name|op
argument_list|,
name|nfso_list
argument_list|)
expr_stmt|;
name|nfscl_freealllocks
argument_list|(
operator|&
name|op
operator|->
name|nfso_lock
argument_list|,
name|local
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|op
argument_list|,
name|M_NFSCLOPEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|local
condition|)
name|newnfsstats
operator|.
name|cllocalopens
operator|--
expr_stmt|;
else|else
name|newnfsstats
operator|.
name|clopens
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free up all lock owners and associated locks.  */
end_comment

begin_function
specifier|static
name|void
name|nfscl_freealllocks
parameter_list|(
name|struct
name|nfscllockownerhead
modifier|*
name|lhp
parameter_list|,
name|int
name|local
parameter_list|)
block|{
name|struct
name|nfscllockowner
modifier|*
name|lp
decl_stmt|,
modifier|*
name|nlp
decl_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|lp
argument_list|,
argument|lhp
argument_list|,
argument|nfsl_list
argument_list|,
argument|nlp
argument_list|)
block|{
if|if
condition|(
operator|(
name|lp
operator|->
name|nfsl_rwlock
operator|.
name|nfslock_lock
operator|&
name|NFSV4LOCK_WANTED
operator|)
condition|)
name|panic
argument_list|(
literal|"nfscllckw"
argument_list|)
expr_stmt|;
name|nfscl_freelockowner
argument_list|(
name|lp
argument_list|,
name|local
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Called for an Open when NFSERR_EXPIRED is received from the server.  * If there are no byte range locks nor a Share Deny lost, try to do a  * fresh Open. Otherwise, free the open.  */
end_comment

begin_function
specifier|static
name|int
name|nfscl_expireopen
parameter_list|(
name|struct
name|nfsclclient
modifier|*
name|clp
parameter_list|,
name|struct
name|nfsclopen
modifier|*
name|op
parameter_list|,
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|nfscllockowner
modifier|*
name|lp
decl_stmt|;
name|struct
name|nfscldeleg
modifier|*
name|dp
decl_stmt|;
name|int
name|mustdelete
init|=
literal|0
decl_stmt|,
name|error
decl_stmt|;
comment|/* 	 * Look for any byte range lock(s). 	 */
name|LIST_FOREACH
argument_list|(
argument|lp
argument_list|,
argument|&op->nfso_lock
argument_list|,
argument|nfsl_list
argument_list|)
block|{
if|if
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|lp
operator|->
name|nfsl_lock
argument_list|)
condition|)
block|{
name|mustdelete
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|/* 	 * If no byte range lock(s) nor a Share deny, try to re-open. 	 */
if|if
condition|(
operator|!
name|mustdelete
operator|&&
operator|(
name|op
operator|->
name|nfso_mode
operator|&
name|NFSLCK_DENYBITS
operator|)
operator|==
literal|0
condition|)
block|{
name|newnfs_copycred
argument_list|(
operator|&
name|op
operator|->
name|nfso_cred
argument_list|,
name|cred
argument_list|)
expr_stmt|;
name|dp
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|nfsrpc_reopen
argument_list|(
name|nmp
argument_list|,
name|op
operator|->
name|nfso_fh
argument_list|,
name|op
operator|->
name|nfso_fhlen
argument_list|,
name|op
operator|->
name|nfso_mode
argument_list|,
name|op
argument_list|,
operator|&
name|dp
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|mustdelete
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|dp
operator|!=
name|NULL
condition|)
block|{
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|dp
argument_list|,
name|M_NFSCLDELEG
argument_list|)
expr_stmt|;
name|dp
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dp
operator|!=
name|NULL
condition|)
name|nfscl_deleg
argument_list|(
name|nmp
operator|->
name|nm_mountp
argument_list|,
name|clp
argument_list|,
name|op
operator|->
name|nfso_fh
argument_list|,
name|op
operator|->
name|nfso_fhlen
argument_list|,
name|cred
argument_list|,
name|p
argument_list|,
operator|&
name|dp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If a byte range lock or Share deny or couldn't re-open, free it. 	 */
if|if
condition|(
name|mustdelete
condition|)
name|nfscl_freeopen
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|mustdelete
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free up an open owner structure.  */
end_comment

begin_function
specifier|static
name|void
name|nfscl_freeopenowner
parameter_list|(
name|struct
name|nfsclowner
modifier|*
name|owp
parameter_list|,
name|int
name|local
parameter_list|)
block|{
name|LIST_REMOVE
argument_list|(
name|owp
argument_list|,
name|nfsow_list
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|owp
argument_list|,
name|M_NFSCLOWNER
argument_list|)
expr_stmt|;
if|if
condition|(
name|local
condition|)
name|newnfsstats
operator|.
name|cllocalopenowners
operator|--
expr_stmt|;
else|else
name|newnfsstats
operator|.
name|clopenowners
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free up a byte range lock owner structure.  */
end_comment

begin_function
specifier|static
name|void
name|nfscl_freelockowner
parameter_list|(
name|struct
name|nfscllockowner
modifier|*
name|lp
parameter_list|,
name|int
name|local
parameter_list|)
block|{
name|struct
name|nfscllock
modifier|*
name|lop
decl_stmt|,
modifier|*
name|nlop
decl_stmt|;
name|LIST_REMOVE
argument_list|(
name|lp
argument_list|,
name|nfsl_list
argument_list|)
expr_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|lop
argument_list|,
argument|&lp->nfsl_lock
argument_list|,
argument|nfslo_list
argument_list|,
argument|nlop
argument_list|)
block|{
name|nfscl_freelock
argument_list|(
name|lop
argument_list|,
name|local
argument_list|)
expr_stmt|;
block|}
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|lp
argument_list|,
name|M_NFSCLLOCKOWNER
argument_list|)
expr_stmt|;
if|if
condition|(
name|local
condition|)
name|newnfsstats
operator|.
name|cllocallockowners
operator|--
expr_stmt|;
else|else
name|newnfsstats
operator|.
name|cllockowners
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free up a byte range lock structure.  */
end_comment

begin_function
name|APPLESTATIC
name|void
name|nfscl_freelock
parameter_list|(
name|struct
name|nfscllock
modifier|*
name|lop
parameter_list|,
name|int
name|local
parameter_list|)
block|{
name|LIST_REMOVE
argument_list|(
name|lop
argument_list|,
name|nfslo_list
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|lop
argument_list|,
name|M_NFSCLLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|local
condition|)
name|newnfsstats
operator|.
name|cllocallocks
operator|--
expr_stmt|;
else|else
name|newnfsstats
operator|.
name|cllocks
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Clean out the state related to a delegation.  */
end_comment

begin_function
specifier|static
name|void
name|nfscl_cleandeleg
parameter_list|(
name|struct
name|nfscldeleg
modifier|*
name|dp
parameter_list|)
block|{
name|struct
name|nfsclowner
modifier|*
name|owp
decl_stmt|,
modifier|*
name|nowp
decl_stmt|;
name|struct
name|nfsclopen
modifier|*
name|op
decl_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|owp
argument_list|,
argument|&dp->nfsdl_owner
argument_list|,
argument|nfsow_list
argument_list|,
argument|nowp
argument_list|)
block|{
name|op
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|owp
operator|->
name|nfsow_open
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|LIST_NEXT
argument_list|(
name|op
argument_list|,
name|nfso_list
argument_list|)
operator|!=
name|NULL
condition|)
name|panic
argument_list|(
literal|"nfscleandel"
argument_list|)
expr_stmt|;
name|nfscl_freeopen
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|nfscl_freeopenowner
argument_list|(
name|owp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|nfscl_freealllocks
argument_list|(
operator|&
name|dp
operator|->
name|nfsdl_lock
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free a delegation.  */
end_comment

begin_function
specifier|static
name|void
name|nfscl_freedeleg
parameter_list|(
name|struct
name|nfscldeleghead
modifier|*
name|hdp
parameter_list|,
name|struct
name|nfscldeleg
modifier|*
name|dp
parameter_list|)
block|{
name|TAILQ_REMOVE
argument_list|(
name|hdp
argument_list|,
name|dp
argument_list|,
name|nfsdl_list
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|dp
argument_list|,
name|nfsdl_hash
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|dp
argument_list|,
name|M_NFSCLDELEG
argument_list|)
expr_stmt|;
name|newnfsstats
operator|.
name|cldelegates
operator|--
expr_stmt|;
name|nfscl_delegcnt
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free up all state related to this client structure.  */
end_comment

begin_function
specifier|static
name|void
name|nfscl_cleanclient
parameter_list|(
name|struct
name|nfsclclient
modifier|*
name|clp
parameter_list|)
block|{
name|struct
name|nfsclowner
modifier|*
name|owp
decl_stmt|,
modifier|*
name|nowp
decl_stmt|;
name|struct
name|nfsclopen
modifier|*
name|op
decl_stmt|,
modifier|*
name|nop
decl_stmt|;
name|struct
name|nfscllockowner
modifier|*
name|lp
decl_stmt|,
modifier|*
name|nlp
decl_stmt|;
comment|/* get rid of defunct lockowners */
name|LIST_FOREACH_SAFE
argument_list|(
argument|lp
argument_list|,
argument|&clp->nfsc_defunctlockowner
argument_list|,
argument|nfsl_list
argument_list|,
argument|nlp
argument_list|)
block|{
name|nfscl_freelockowner
argument_list|(
name|lp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Now, all the OpenOwners, etc. */
name|LIST_FOREACH_SAFE
argument_list|(
argument|owp
argument_list|,
argument|&clp->nfsc_owner
argument_list|,
argument|nfsow_list
argument_list|,
argument|nowp
argument_list|)
block|{
name|LIST_FOREACH_SAFE
argument_list|(
argument|op
argument_list|,
argument|&owp->nfsow_open
argument_list|,
argument|nfso_list
argument_list|,
argument|nop
argument_list|)
block|{
name|nfscl_freeopen
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|nfscl_freeopenowner
argument_list|(
name|owp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Called when an NFSERR_EXPIRED is received from the server.  */
end_comment

begin_function
specifier|static
name|void
name|nfscl_expireclient
parameter_list|(
name|struct
name|nfsclclient
modifier|*
name|clp
parameter_list|,
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|nfsclowner
modifier|*
name|owp
decl_stmt|,
modifier|*
name|nowp
decl_stmt|,
modifier|*
name|towp
decl_stmt|;
name|struct
name|nfsclopen
modifier|*
name|op
decl_stmt|,
modifier|*
name|nop
decl_stmt|,
modifier|*
name|top
decl_stmt|;
name|struct
name|nfscldeleg
modifier|*
name|dp
decl_stmt|,
modifier|*
name|ndp
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|printed
init|=
literal|0
decl_stmt|;
comment|/* 	 * First, merge locally issued Opens into the list for the server. 	 */
name|dp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|clp
operator|->
name|nfsc_deleg
argument_list|)
expr_stmt|;
while|while
condition|(
name|dp
operator|!=
name|NULL
condition|)
block|{
name|ndp
operator|=
name|TAILQ_NEXT
argument_list|(
name|dp
argument_list|,
name|nfsdl_list
argument_list|)
expr_stmt|;
name|owp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|dp
operator|->
name|nfsdl_owner
argument_list|)
expr_stmt|;
while|while
condition|(
name|owp
operator|!=
name|NULL
condition|)
block|{
name|nowp
operator|=
name|LIST_NEXT
argument_list|(
name|owp
argument_list|,
name|nfsow_list
argument_list|)
expr_stmt|;
name|op
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|owp
operator|->
name|nfsow_open
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|LIST_NEXT
argument_list|(
name|op
argument_list|,
name|nfso_list
argument_list|)
operator|!=
name|NULL
condition|)
name|panic
argument_list|(
literal|"nfsclexp"
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|towp
argument_list|,
argument|&clp->nfsc_owner
argument_list|,
argument|nfsow_list
argument_list|)
block|{
if|if
condition|(
operator|!
name|NFSBCMP
argument_list|(
name|towp
operator|->
name|nfsow_owner
argument_list|,
name|owp
operator|->
name|nfsow_owner
argument_list|,
name|NFSV4CL_LOCKNAMELEN
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|towp
operator|!=
name|NULL
condition|)
block|{
comment|/* Merge opens in */
name|LIST_FOREACH
argument_list|(
argument|top
argument_list|,
argument|&towp->nfsow_open
argument_list|,
argument|nfso_list
argument_list|)
block|{
if|if
condition|(
name|top
operator|->
name|nfso_fhlen
operator|==
name|op
operator|->
name|nfso_fhlen
operator|&&
operator|!
name|NFSBCMP
argument_list|(
name|top
operator|->
name|nfso_fh
argument_list|,
name|op
operator|->
name|nfso_fh
argument_list|,
name|op
operator|->
name|nfso_fhlen
argument_list|)
condition|)
block|{
name|top
operator|->
name|nfso_mode
operator||=
name|op
operator|->
name|nfso_mode
expr_stmt|;
name|top
operator|->
name|nfso_opencnt
operator|+=
name|op
operator|->
name|nfso_opencnt
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|top
operator|==
name|NULL
condition|)
block|{
comment|/* Just add the open to the owner list */
name|LIST_REMOVE
argument_list|(
name|op
argument_list|,
name|nfso_list
argument_list|)
expr_stmt|;
name|op
operator|->
name|nfso_own
operator|=
name|towp
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|towp
operator|->
name|nfsow_open
argument_list|,
name|op
argument_list|,
name|nfso_list
argument_list|)
expr_stmt|;
name|newnfsstats
operator|.
name|cllocalopens
operator|--
expr_stmt|;
name|newnfsstats
operator|.
name|clopens
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Just add the openowner to the client list */
name|LIST_REMOVE
argument_list|(
name|owp
argument_list|,
name|nfsow_list
argument_list|)
expr_stmt|;
name|owp
operator|->
name|nfsow_clp
operator|=
name|clp
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|clp
operator|->
name|nfsc_owner
argument_list|,
name|owp
argument_list|,
name|nfsow_list
argument_list|)
expr_stmt|;
name|newnfsstats
operator|.
name|cllocalopenowners
operator|--
expr_stmt|;
name|newnfsstats
operator|.
name|clopenowners
operator|++
expr_stmt|;
name|newnfsstats
operator|.
name|cllocalopens
operator|--
expr_stmt|;
name|newnfsstats
operator|.
name|clopens
operator|++
expr_stmt|;
block|}
block|}
name|owp
operator|=
name|nowp
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|printed
operator|&&
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|dp
operator|->
name|nfsdl_lock
argument_list|)
condition|)
block|{
name|printed
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"nfsv4 expired locks lost\n"
argument_list|)
expr_stmt|;
block|}
name|nfscl_cleandeleg
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|nfscl_freedeleg
argument_list|(
operator|&
name|clp
operator|->
name|nfsc_deleg
argument_list|,
name|dp
argument_list|)
expr_stmt|;
name|dp
operator|=
name|ndp
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|clp
operator|->
name|nfsc_deleg
argument_list|)
condition|)
name|panic
argument_list|(
literal|"nfsclexp"
argument_list|)
expr_stmt|;
comment|/* 	 * Now, try and reopen against the server. 	 */
name|LIST_FOREACH_SAFE
argument_list|(
argument|owp
argument_list|,
argument|&clp->nfsc_owner
argument_list|,
argument|nfsow_list
argument_list|,
argument|nowp
argument_list|)
block|{
name|owp
operator|->
name|nfsow_seqid
operator|=
literal|0
expr_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|op
argument_list|,
argument|&owp->nfsow_open
argument_list|,
argument|nfso_list
argument_list|,
argument|nop
argument_list|)
block|{
name|ret
operator|=
name|nfscl_expireopen
argument_list|(
name|clp
argument_list|,
name|op
argument_list|,
name|nmp
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|&&
operator|!
name|printed
condition|)
block|{
name|printed
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"nfsv4 expired locks lost\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|owp
operator|->
name|nfsow_open
argument_list|)
condition|)
name|nfscl_freeopenowner
argument_list|(
name|owp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|__FreeBSD__
end_ifndef

begin_comment
comment|/*  * Called from exit() upon process termination.  */
end_comment

begin_function
name|APPLESTATIC
name|void
name|nfscl_cleanup
parameter_list|(
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|nfsclclient
modifier|*
name|clp
decl_stmt|;
name|u_int8_t
name|own
index|[
name|NFSV4CL_LOCKNAMELEN
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|nfscl_inited
condition|)
return|return;
name|nfscl_filllockowner
argument_list|(
name|p
argument_list|,
name|own
argument_list|)
expr_stmt|;
name|NFSLOCKCLSTATE
argument_list|()
expr_stmt|;
comment|/* 	 * Loop through all the clientids, looking for the OpenOwners. 	 */
name|LIST_FOREACH
argument_list|(
argument|clp
argument_list|,
argument|&nfsclhead
argument_list|,
argument|nfsc_list
argument_list|)
name|nfscl_cleanup_common
argument_list|(
name|clp
argument_list|,
name|own
argument_list|)
expr_stmt|;
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !__FreeBSD__ */
end_comment

begin_comment
comment|/*  * Common code used by nfscl_cleanup() and nfscl_cleanupkext().  * Must be called with CLSTATE lock held.  */
end_comment

begin_function
specifier|static
name|void
name|nfscl_cleanup_common
parameter_list|(
name|struct
name|nfsclclient
modifier|*
name|clp
parameter_list|,
name|u_int8_t
modifier|*
name|own
parameter_list|)
block|{
name|struct
name|nfsclowner
modifier|*
name|owp
decl_stmt|,
modifier|*
name|nowp
decl_stmt|;
name|struct
name|nfsclopen
modifier|*
name|op
decl_stmt|;
name|struct
name|nfscllockowner
modifier|*
name|lp
decl_stmt|,
modifier|*
name|nlp
decl_stmt|;
name|struct
name|nfscldeleg
modifier|*
name|dp
decl_stmt|;
comment|/* First, get rid of local locks on delegations. */
name|TAILQ_FOREACH
argument_list|(
argument|dp
argument_list|,
argument|&clp->nfsc_deleg
argument_list|,
argument|nfsdl_list
argument_list|)
block|{
name|LIST_FOREACH_SAFE
argument_list|(
argument|lp
argument_list|,
argument|&dp->nfsdl_lock
argument_list|,
argument|nfsl_list
argument_list|,
argument|nlp
argument_list|)
block|{
if|if
condition|(
operator|!
name|NFSBCMP
argument_list|(
name|lp
operator|->
name|nfsl_owner
argument_list|,
name|own
argument_list|,
name|NFSV4CL_LOCKNAMELEN
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|lp
operator|->
name|nfsl_rwlock
operator|.
name|nfslock_lock
operator|&
name|NFSV4LOCK_WANTED
operator|)
condition|)
name|panic
argument_list|(
literal|"nfscllckw"
argument_list|)
expr_stmt|;
name|nfscl_freelockowner
argument_list|(
name|lp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|owp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|clp
operator|->
name|nfsc_owner
argument_list|)
expr_stmt|;
while|while
condition|(
name|owp
operator|!=
name|NULL
condition|)
block|{
name|nowp
operator|=
name|LIST_NEXT
argument_list|(
name|owp
argument_list|,
name|nfsow_list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NFSBCMP
argument_list|(
name|owp
operator|->
name|nfsow_owner
argument_list|,
name|own
argument_list|,
name|NFSV4CL_LOCKNAMELEN
argument_list|)
condition|)
block|{
comment|/* 			 * If there are children that haven't closed the 			 * file descriptors yet, the opens will still be 			 * here. For that case, let the renew thread clear 			 * out the OpenOwner later. 			 */
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|owp
operator|->
name|nfsow_open
argument_list|)
condition|)
name|nfscl_freeopenowner
argument_list|(
name|owp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|owp
operator|->
name|nfsow_defunct
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* look for lockowners on other opens */
name|LIST_FOREACH
argument_list|(
argument|op
argument_list|,
argument|&owp->nfsow_open
argument_list|,
argument|nfso_list
argument_list|)
block|{
name|LIST_FOREACH
argument_list|(
argument|lp
argument_list|,
argument|&op->nfso_lock
argument_list|,
argument|nfsl_list
argument_list|)
block|{
if|if
condition|(
operator|!
name|NFSBCMP
argument_list|(
name|lp
operator|->
name|nfsl_owner
argument_list|,
name|own
argument_list|,
name|NFSV4CL_LOCKNAMELEN
argument_list|)
condition|)
name|lp
operator|->
name|nfsl_defunct
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
name|owp
operator|=
name|nowp
expr_stmt|;
block|}
comment|/* and check the defunct list */
name|LIST_FOREACH
argument_list|(
argument|lp
argument_list|,
argument|&clp->nfsc_defunctlockowner
argument_list|,
argument|nfsl_list
argument_list|)
block|{
if|if
condition|(
operator|!
name|NFSBCMP
argument_list|(
name|lp
operator|->
name|nfsl_owner
argument_list|,
name|own
argument_list|,
name|NFSV4CL_LOCKNAMELEN
argument_list|)
condition|)
name|lp
operator|->
name|nfsl_defunct
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|APPLEKEXT
argument_list|)
operator|||
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_comment
comment|/*  * Simulate the call nfscl_cleanup() by looking for open owners associated  * with processes that no longer exist, since a call to nfscl_cleanup()  * can't be patched into exit().  */
end_comment

begin_function
specifier|static
name|void
name|nfscl_cleanupkext
parameter_list|(
name|struct
name|nfsclclient
modifier|*
name|clp
parameter_list|)
block|{
name|struct
name|nfsclowner
modifier|*
name|owp
decl_stmt|,
modifier|*
name|nowp
decl_stmt|;
name|struct
name|nfscllockowner
modifier|*
name|lp
decl_stmt|;
name|NFSPROCLISTLOCK
argument_list|()
expr_stmt|;
name|NFSLOCKCLSTATE
argument_list|()
expr_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|owp
argument_list|,
argument|&clp->nfsc_owner
argument_list|,
argument|nfsow_list
argument_list|,
argument|nowp
argument_list|)
block|{
if|if
condition|(
name|nfscl_procdoesntexist
argument_list|(
name|owp
operator|->
name|nfsow_owner
argument_list|)
condition|)
name|nfscl_cleanup_common
argument_list|(
name|clp
argument_list|,
name|owp
operator|->
name|nfsow_owner
argument_list|)
expr_stmt|;
block|}
comment|/* and check the defunct list */
name|LIST_FOREACH
argument_list|(
argument|lp
argument_list|,
argument|&clp->nfsc_defunctlockowner
argument_list|,
argument|nfsl_list
argument_list|)
block|{
if|if
condition|(
name|nfscl_procdoesntexist
argument_list|(
name|lp
operator|->
name|nfsl_owner
argument_list|)
condition|)
name|lp
operator|->
name|nfsl_defunct
operator|=
literal|1
expr_stmt|;
block|}
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
name|NFSPROCLISTUNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* APPLEKEXT || __FreeBSD__ */
end_comment

begin_comment
comment|/*  * Called from nfs umount to free up the clientid.  */
end_comment

begin_function
name|APPLESTATIC
name|void
name|nfscl_umount
parameter_list|(
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|nfsclclient
modifier|*
name|clp
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|int
name|igotlock
decl_stmt|;
name|clp
operator|=
name|nmp
operator|->
name|nm_clp
expr_stmt|;
if|if
condition|(
name|clp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|clp
operator|->
name|nfsc_flags
operator|&
name|NFSCLFLAGS_INITED
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"nfscl umount"
argument_list|)
expr_stmt|;
comment|/* 		 * First, handshake with the nfscl renew thread, to terminate 		 * it. 		 */
name|clp
operator|->
name|nfsc_flags
operator||=
name|NFSCLFLAGS_UMOUNT
expr_stmt|;
while|while
condition|(
name|clp
operator|->
name|nfsc_flags
operator|&
name|NFSCLFLAGS_HASTHREAD
condition|)
operator|(
name|void
operator|)
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|clp
argument_list|,
name|PWAIT
argument_list|,
literal|"nfsclumnt"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
name|NFSLOCKCLSTATE
argument_list|()
expr_stmt|;
do|do
block|{
name|igotlock
operator|=
name|nfsv4_lock
argument_list|(
operator|&
name|clp
operator|->
name|nfsc_lock
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
name|NFSCLSTATEMUTEXPTR
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|igotlock
condition|)
do|;
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
comment|/* 		 * Free up all the state. It will expire on the server, but 		 * maybe we should do a SetClientId/SetClientIdConfirm so 		 * the server throws it away? 		 */
name|LIST_REMOVE
argument_list|(
name|clp
argument_list|,
name|nfsc_list
argument_list|)
expr_stmt|;
name|nfscl_delegreturnall
argument_list|(
name|clp
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|cred
operator|=
name|newnfs_getcred
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|nfsrpc_setclient
argument_list|(
name|nmp
argument_list|,
name|clp
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|nfscl_cleanclient
argument_list|(
name|clp
argument_list|)
expr_stmt|;
name|nmp
operator|->
name|nm_clp
operator|=
name|NULL
expr_stmt|;
name|NFSFREECRED
argument_list|(
name|cred
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|clp
argument_list|,
name|M_NFSCLCLIENT
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * This function is called when a server replies with NFSERR_STALECLIENTID  * or NFSERR_STALESTATEID. It traverses the clientid lists, doing Opens  * and Locks with reclaim. If these fail, it deletes the corresponding state.  */
end_comment

begin_function
specifier|static
name|void
name|nfscl_recover
parameter_list|(
name|struct
name|nfsclclient
modifier|*
name|clp
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|nfsclowner
modifier|*
name|owp
decl_stmt|,
modifier|*
name|nowp
decl_stmt|;
name|struct
name|nfsclopen
modifier|*
name|op
decl_stmt|,
modifier|*
name|nop
decl_stmt|;
name|struct
name|nfscllockowner
modifier|*
name|lp
decl_stmt|,
modifier|*
name|nlp
decl_stmt|;
name|struct
name|nfscllock
modifier|*
name|lop
decl_stmt|,
modifier|*
name|nlop
decl_stmt|;
name|struct
name|nfscldeleg
modifier|*
name|dp
decl_stmt|,
modifier|*
name|ndp
decl_stmt|,
modifier|*
name|tdp
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
decl_stmt|;
name|struct
name|ucred
modifier|*
name|tcred
decl_stmt|;
name|struct
name|nfsclopenhead
name|extra_open
decl_stmt|;
name|struct
name|nfscldeleghead
name|extra_deleg
decl_stmt|;
name|struct
name|nfsreq
modifier|*
name|rep
decl_stmt|;
name|u_int64_t
name|len
decl_stmt|;
name|u_int32_t
name|delegtype
init|=
name|NFSV4OPEN_DELEGATEWRITE
decl_stmt|,
name|mode
decl_stmt|;
name|int
name|igotlock
init|=
literal|0
decl_stmt|,
name|error
decl_stmt|,
name|trycnt
decl_stmt|,
name|firstlock
decl_stmt|,
name|s
decl_stmt|;
comment|/* 	 * First, lock the client structure, so everyone else will 	 * block when trying to use state. 	 */
name|NFSLOCKCLSTATE
argument_list|()
expr_stmt|;
name|clp
operator|->
name|nfsc_flags
operator||=
name|NFSCLFLAGS_RECVRINPROG
expr_stmt|;
do|do
block|{
name|igotlock
operator|=
name|nfsv4_lock
argument_list|(
operator|&
name|clp
operator|->
name|nfsc_lock
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
name|NFSCLSTATEMUTEXPTR
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|igotlock
condition|)
do|;
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
name|nmp
operator|=
name|clp
operator|->
name|nfsc_nmp
expr_stmt|;
if|if
condition|(
name|nmp
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"nfscl recover"
argument_list|)
expr_stmt|;
name|trycnt
operator|=
literal|5
expr_stmt|;
do|do
block|{
name|error
operator|=
name|nfsrpc_setclient
argument_list|(
name|nmp
argument_list|,
name|clp
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|error
operator|==
name|NFSERR_STALECLIENTID
operator|||
name|error
operator|==
name|NFSERR_STALEDONTRECOVER
operator|)
operator|&&
operator|--
name|trycnt
operator|>
literal|0
condition|)
do|;
if|if
condition|(
name|error
condition|)
block|{
name|nfscl_cleanclient
argument_list|(
name|clp
argument_list|)
expr_stmt|;
name|NFSLOCKCLSTATE
argument_list|()
expr_stmt|;
name|clp
operator|->
name|nfsc_flags
operator|&=
operator|~
operator|(
name|NFSCLFLAGS_HASCLIENTID
operator||
name|NFSCLFLAGS_RECOVER
operator||
name|NFSCLFLAGS_RECVRINPROG
operator|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|clp
operator|->
name|nfsc_flags
argument_list|)
expr_stmt|;
name|nfsv4_unlock
argument_list|(
operator|&
name|clp
operator|->
name|nfsc_lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
return|return;
block|}
name|clp
operator|->
name|nfsc_flags
operator||=
name|NFSCLFLAGS_HASCLIENTID
expr_stmt|;
name|clp
operator|->
name|nfsc_flags
operator|&=
operator|~
name|NFSCLFLAGS_RECOVER
expr_stmt|;
comment|/* 	 * Mark requests already queued on the server, so that they don't 	 * initiate another recovery cycle. Any requests already in the 	 * queue that handle state information will have the old stale 	 * clientid/stateid and will get a NFSERR_STALESTATEID or 	 * NFSERR_STALECLIENTID reply from the server. This will be 	 * translated to NFSERR_STALEDONTRECOVER when R_DONTRECOVER is set. 	 */
name|s
operator|=
name|splsoftclock
argument_list|()
expr_stmt|;
name|NFSLOCKREQ
argument_list|()
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|rep
argument_list|,
argument|&nfsd_reqq
argument_list|,
argument|r_chain
argument_list|)
block|{
if|if
condition|(
name|rep
operator|->
name|r_nmp
operator|==
name|nmp
condition|)
name|rep
operator|->
name|r_flags
operator||=
name|R_DONTRECOVER
expr_stmt|;
block|}
name|NFSUNLOCKREQ
argument_list|()
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* get rid of defunct lockowners */
name|LIST_FOREACH_SAFE
argument_list|(
argument|lp
argument_list|,
argument|&clp->nfsc_defunctlockowner
argument_list|,
argument|nfsl_list
argument_list|,
argument|nlp
argument_list|)
block|{
name|nfscl_freelockowner
argument_list|(
name|lp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Now, mark all delegations "need reclaim". 	 */
name|TAILQ_FOREACH
argument_list|(
argument|dp
argument_list|,
argument|&clp->nfsc_deleg
argument_list|,
argument|nfsdl_list
argument_list|)
name|dp
operator|->
name|nfsdl_flags
operator||=
name|NFSCLDL_NEEDRECLAIM
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|extra_deleg
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|extra_open
argument_list|)
expr_stmt|;
comment|/* 	 * Now traverse the state lists, doing Open and Lock Reclaims. 	 */
name|tcred
operator|=
name|newnfs_getcred
argument_list|()
expr_stmt|;
name|owp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|clp
operator|->
name|nfsc_owner
argument_list|)
expr_stmt|;
while|while
condition|(
name|owp
operator|!=
name|NULL
condition|)
block|{
name|nowp
operator|=
name|LIST_NEXT
argument_list|(
name|owp
argument_list|,
name|nfsow_list
argument_list|)
expr_stmt|;
name|owp
operator|->
name|nfsow_seqid
operator|=
literal|0
expr_stmt|;
name|op
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|owp
operator|->
name|nfsow_open
argument_list|)
expr_stmt|;
while|while
condition|(
name|op
operator|!=
name|NULL
condition|)
block|{
name|nop
operator|=
name|LIST_NEXT
argument_list|(
name|op
argument_list|,
name|nfso_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|NFSERR_NOGRACE
condition|)
block|{
comment|/* Search for a delegation to reclaim with the open */
name|TAILQ_FOREACH
argument_list|(
argument|dp
argument_list|,
argument|&clp->nfsc_deleg
argument_list|,
argument|nfsdl_list
argument_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|dp
operator|->
name|nfsdl_flags
operator|&
name|NFSCLDL_NEEDRECLAIM
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|dp
operator|->
name|nfsdl_flags
operator|&
name|NFSCLDL_WRITE
operator|)
condition|)
block|{
name|mode
operator|=
name|NFSV4OPEN_ACCESSWRITE
expr_stmt|;
name|delegtype
operator|=
name|NFSV4OPEN_DELEGATEWRITE
expr_stmt|;
block|}
else|else
block|{
name|mode
operator|=
name|NFSV4OPEN_ACCESSREAD
expr_stmt|;
name|delegtype
operator|=
name|NFSV4OPEN_DELEGATEREAD
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|op
operator|->
name|nfso_mode
operator|&
name|mode
operator|)
operator|==
name|mode
operator|&&
name|op
operator|->
name|nfso_fhlen
operator|==
name|dp
operator|->
name|nfsdl_fhlen
operator|&&
operator|!
name|NFSBCMP
argument_list|(
name|op
operator|->
name|nfso_fh
argument_list|,
name|dp
operator|->
name|nfsdl_fh
argument_list|,
name|op
operator|->
name|nfso_fhlen
argument_list|)
condition|)
break|break;
block|}
name|ndp
operator|=
name|dp
expr_stmt|;
if|if
condition|(
name|dp
operator|==
name|NULL
condition|)
name|delegtype
operator|=
name|NFSV4OPEN_DELEGATENONE
expr_stmt|;
name|newnfs_copycred
argument_list|(
operator|&
name|op
operator|->
name|nfso_cred
argument_list|,
name|tcred
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfscl_tryopen
argument_list|(
name|nmp
argument_list|,
name|NULL
argument_list|,
name|op
operator|->
name|nfso_fh
argument_list|,
name|op
operator|->
name|nfso_fhlen
argument_list|,
name|op
operator|->
name|nfso_fh
argument_list|,
name|op
operator|->
name|nfso_fhlen
argument_list|,
name|op
operator|->
name|nfso_mode
argument_list|,
name|op
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|ndp
argument_list|,
literal|1
argument_list|,
name|delegtype
argument_list|,
name|tcred
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
comment|/* Handle any replied delegation */
if|if
condition|(
name|ndp
operator|!=
name|NULL
operator|&&
operator|(
operator|(
name|ndp
operator|->
name|nfsdl_flags
operator|&
name|NFSCLDL_WRITE
operator|)
operator|||
name|NFSMNT_RDONLY
argument_list|(
name|nmp
operator|->
name|nm_mountp
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|ndp
operator|->
name|nfsdl_flags
operator|&
name|NFSCLDL_WRITE
operator|)
condition|)
name|mode
operator|=
name|NFSV4OPEN_ACCESSWRITE
expr_stmt|;
else|else
name|mode
operator|=
name|NFSV4OPEN_ACCESSREAD
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|dp
argument_list|,
argument|&clp->nfsc_deleg
argument_list|,
argument|nfsdl_list
argument_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|dp
operator|->
name|nfsdl_flags
operator|&
name|NFSCLDL_NEEDRECLAIM
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|op
operator|->
name|nfso_mode
operator|&
name|mode
operator|)
operator|==
name|mode
operator|&&
name|op
operator|->
name|nfso_fhlen
operator|==
name|dp
operator|->
name|nfsdl_fhlen
operator|&&
operator|!
name|NFSBCMP
argument_list|(
name|op
operator|->
name|nfso_fh
argument_list|,
name|dp
operator|->
name|nfsdl_fh
argument_list|,
name|op
operator|->
name|nfso_fhlen
argument_list|)
condition|)
block|{
name|dp
operator|->
name|nfsdl_stateid
operator|=
name|ndp
operator|->
name|nfsdl_stateid
expr_stmt|;
name|dp
operator|->
name|nfsdl_sizelimit
operator|=
name|ndp
operator|->
name|nfsdl_sizelimit
expr_stmt|;
name|dp
operator|->
name|nfsdl_ace
operator|=
name|ndp
operator|->
name|nfsdl_ace
expr_stmt|;
name|dp
operator|->
name|nfsdl_change
operator|=
name|ndp
operator|->
name|nfsdl_change
expr_stmt|;
name|dp
operator|->
name|nfsdl_flags
operator|&=
operator|~
name|NFSCLDL_NEEDRECLAIM
expr_stmt|;
if|if
condition|(
operator|(
name|ndp
operator|->
name|nfsdl_flags
operator|&
name|NFSCLDL_RECALL
operator|)
condition|)
name|dp
operator|->
name|nfsdl_flags
operator||=
name|NFSCLDL_RECALL
expr_stmt|;
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|ndp
argument_list|,
name|M_NFSCLDELEG
argument_list|)
expr_stmt|;
name|ndp
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|ndp
operator|!=
name|NULL
condition|)
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|extra_deleg
argument_list|,
name|ndp
argument_list|,
name|nfsdl_list
argument_list|)
expr_stmt|;
comment|/* and reclaim all byte range locks */
name|lp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|op
operator|->
name|nfso_lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|lp
operator|!=
name|NULL
condition|)
block|{
name|nlp
operator|=
name|LIST_NEXT
argument_list|(
name|lp
argument_list|,
name|nfsl_list
argument_list|)
expr_stmt|;
name|lp
operator|->
name|nfsl_seqid
operator|=
literal|0
expr_stmt|;
name|firstlock
operator|=
literal|1
expr_stmt|;
name|lop
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|lp
operator|->
name|nfsl_lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|lop
operator|!=
name|NULL
condition|)
block|{
name|nlop
operator|=
name|LIST_NEXT
argument_list|(
name|lop
argument_list|,
name|nfslo_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|lop
operator|->
name|nfslo_end
operator|==
name|NFS64BITSSET
condition|)
name|len
operator|=
name|NFS64BITSSET
expr_stmt|;
else|else
name|len
operator|=
name|lop
operator|->
name|nfslo_end
operator|-
name|lop
operator|->
name|nfslo_first
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|NFSERR_NOGRACE
condition|)
name|error
operator|=
name|nfscl_trylock
argument_list|(
name|nmp
argument_list|,
name|NULL
argument_list|,
name|op
operator|->
name|nfso_fh
argument_list|,
name|op
operator|->
name|nfso_fhlen
argument_list|,
name|lp
argument_list|,
name|firstlock
argument_list|,
literal|1
argument_list|,
name|lop
operator|->
name|nfslo_first
argument_list|,
name|len
argument_list|,
name|lop
operator|->
name|nfslo_type
argument_list|,
name|tcred
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|nfscl_freelock
argument_list|(
name|lop
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|firstlock
operator|=
literal|0
expr_stmt|;
name|lop
operator|=
name|nlop
expr_stmt|;
block|}
comment|/* If no locks, but a lockowner, just delete it. */
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|lp
operator|->
name|nfsl_lock
argument_list|)
condition|)
name|nfscl_freelockowner
argument_list|(
name|lp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lp
operator|=
name|nlp
expr_stmt|;
block|}
block|}
else|else
block|{
name|nfscl_freeopen
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|op
operator|=
name|nop
expr_stmt|;
block|}
name|owp
operator|=
name|nowp
expr_stmt|;
block|}
comment|/* 	 * Now, try and get any delegations not yet reclaimed by cobbling 	 * to-gether an appropriate open. 	 */
name|nowp
operator|=
name|NULL
expr_stmt|;
name|dp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|clp
operator|->
name|nfsc_deleg
argument_list|)
expr_stmt|;
while|while
condition|(
name|dp
operator|!=
name|NULL
condition|)
block|{
name|ndp
operator|=
name|TAILQ_NEXT
argument_list|(
name|dp
argument_list|,
name|nfsdl_list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dp
operator|->
name|nfsdl_flags
operator|&
name|NFSCLDL_NEEDRECLAIM
operator|)
condition|)
block|{
if|if
condition|(
name|nowp
operator|==
name|NULL
condition|)
block|{
name|MALLOC
argument_list|(
name|nowp
argument_list|,
expr|struct
name|nfsclowner
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nfsclowner
argument_list|)
argument_list|,
name|M_NFSCLOWNER
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
comment|/* 		     * Name must be as long an largest possible 		     * NFSV4CL_LOCKNAMELEN. 12 for now. 		     */
name|NFSBCOPY
argument_list|(
literal|"RECLAIMDELEG"
argument_list|,
name|nowp
operator|->
name|nfsow_owner
argument_list|,
name|NFSV4CL_LOCKNAMELEN
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|nowp
operator|->
name|nfsow_open
argument_list|)
expr_stmt|;
name|nowp
operator|->
name|nfsow_clp
operator|=
name|clp
expr_stmt|;
name|nowp
operator|->
name|nfsow_seqid
operator|=
literal|0
expr_stmt|;
name|nowp
operator|->
name|nfsow_defunct
operator|=
literal|0
expr_stmt|;
name|nfscl_lockinit
argument_list|(
operator|&
name|nowp
operator|->
name|nfsow_rwlock
argument_list|)
expr_stmt|;
block|}
name|nop
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|NFSERR_NOGRACE
condition|)
block|{
name|MALLOC
argument_list|(
name|nop
argument_list|,
expr|struct
name|nfsclopen
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nfsclopen
argument_list|)
operator|+
name|dp
operator|->
name|nfsdl_fhlen
operator|-
literal|1
argument_list|,
name|M_NFSCLOPEN
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|nop
operator|->
name|nfso_own
operator|=
name|nowp
expr_stmt|;
if|if
condition|(
operator|(
name|dp
operator|->
name|nfsdl_flags
operator|&
name|NFSCLDL_WRITE
operator|)
condition|)
block|{
name|nop
operator|->
name|nfso_mode
operator|=
name|NFSV4OPEN_ACCESSWRITE
expr_stmt|;
name|delegtype
operator|=
name|NFSV4OPEN_DELEGATEWRITE
expr_stmt|;
block|}
else|else
block|{
name|nop
operator|->
name|nfso_mode
operator|=
name|NFSV4OPEN_ACCESSREAD
expr_stmt|;
name|delegtype
operator|=
name|NFSV4OPEN_DELEGATEREAD
expr_stmt|;
block|}
name|nop
operator|->
name|nfso_opencnt
operator|=
literal|0
expr_stmt|;
name|nop
operator|->
name|nfso_posixlock
operator|=
literal|1
expr_stmt|;
name|nop
operator|->
name|nfso_fhlen
operator|=
name|dp
operator|->
name|nfsdl_fhlen
expr_stmt|;
name|NFSBCOPY
argument_list|(
name|dp
operator|->
name|nfsdl_fh
argument_list|,
name|nop
operator|->
name|nfso_fh
argument_list|,
name|dp
operator|->
name|nfsdl_fhlen
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|nop
operator|->
name|nfso_lock
argument_list|)
expr_stmt|;
name|nop
operator|->
name|nfso_stateid
operator|.
name|seqid
operator|=
literal|0
expr_stmt|;
name|nop
operator|->
name|nfso_stateid
operator|.
name|other
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|nop
operator|->
name|nfso_stateid
operator|.
name|other
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|nop
operator|->
name|nfso_stateid
operator|.
name|other
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|newnfs_copycred
argument_list|(
operator|&
name|dp
operator|->
name|nfsdl_cred
argument_list|,
name|tcred
argument_list|)
expr_stmt|;
name|newnfs_copyincred
argument_list|(
name|tcred
argument_list|,
operator|&
name|nop
operator|->
name|nfso_cred
argument_list|)
expr_stmt|;
name|tdp
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|nfscl_tryopen
argument_list|(
name|nmp
argument_list|,
name|NULL
argument_list|,
name|nop
operator|->
name|nfso_fh
argument_list|,
name|nop
operator|->
name|nfso_fhlen
argument_list|,
name|nop
operator|->
name|nfso_fh
argument_list|,
name|nop
operator|->
name|nfso_fhlen
argument_list|,
name|nop
operator|->
name|nfso_mode
argument_list|,
name|nop
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|tdp
argument_list|,
literal|1
argument_list|,
name|delegtype
argument_list|,
name|tcred
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|tdp
operator|->
name|nfsdl_flags
operator|&
name|NFSCLDL_WRITE
operator|)
condition|)
name|mode
operator|=
name|NFSV4OPEN_ACCESSWRITE
expr_stmt|;
else|else
name|mode
operator|=
name|NFSV4OPEN_ACCESSREAD
expr_stmt|;
if|if
condition|(
operator|(
name|nop
operator|->
name|nfso_mode
operator|&
name|mode
operator|)
operator|==
name|mode
operator|&&
name|nop
operator|->
name|nfso_fhlen
operator|==
name|tdp
operator|->
name|nfsdl_fhlen
operator|&&
operator|!
name|NFSBCMP
argument_list|(
name|nop
operator|->
name|nfso_fh
argument_list|,
name|tdp
operator|->
name|nfsdl_fh
argument_list|,
name|nop
operator|->
name|nfso_fhlen
argument_list|)
condition|)
block|{
name|dp
operator|->
name|nfsdl_stateid
operator|=
name|tdp
operator|->
name|nfsdl_stateid
expr_stmt|;
name|dp
operator|->
name|nfsdl_sizelimit
operator|=
name|tdp
operator|->
name|nfsdl_sizelimit
expr_stmt|;
name|dp
operator|->
name|nfsdl_ace
operator|=
name|tdp
operator|->
name|nfsdl_ace
expr_stmt|;
name|dp
operator|->
name|nfsdl_change
operator|=
name|tdp
operator|->
name|nfsdl_change
expr_stmt|;
name|dp
operator|->
name|nfsdl_flags
operator|&=
operator|~
name|NFSCLDL_NEEDRECLAIM
expr_stmt|;
if|if
condition|(
operator|(
name|tdp
operator|->
name|nfsdl_flags
operator|&
name|NFSCLDL_RECALL
operator|)
condition|)
name|dp
operator|->
name|nfsdl_flags
operator||=
name|NFSCLDL_RECALL
expr_stmt|;
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|tdp
argument_list|,
name|M_NFSCLDELEG
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|extra_deleg
argument_list|,
name|tdp
argument_list|,
name|nfsdl_list
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|nop
operator|!=
name|NULL
condition|)
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|nop
argument_list|,
name|M_NFSCLOPEN
argument_list|)
expr_stmt|;
comment|/* 		     * Couldn't reclaim it, so throw the state 		     * away. Ouch!! 		     */
name|nfscl_cleandeleg
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|nfscl_freedeleg
argument_list|(
operator|&
name|clp
operator|->
name|nfsc_deleg
argument_list|,
name|dp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|extra_open
argument_list|,
name|nop
argument_list|,
name|nfso_list
argument_list|)
expr_stmt|;
block|}
block|}
name|dp
operator|=
name|ndp
expr_stmt|;
block|}
comment|/* 	 * Now, get rid of extra Opens and Delegations. 	 */
name|LIST_FOREACH_SAFE
argument_list|(
argument|op
argument_list|,
argument|&extra_open
argument_list|,
argument|nfso_list
argument_list|,
argument|nop
argument_list|)
block|{
do|do
block|{
name|newnfs_copycred
argument_list|(
operator|&
name|op
operator|->
name|nfso_cred
argument_list|,
name|tcred
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfscl_tryclose
argument_list|(
name|op
argument_list|,
name|tcred
argument_list|,
name|nmp
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|NFSERR_GRACE
condition|)
operator|(
name|void
operator|)
name|nfs_catnap
argument_list|(
name|PZERO
argument_list|,
name|error
argument_list|,
literal|"nfsexcls"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|error
operator|==
name|NFSERR_GRACE
condition|)
do|;
name|LIST_REMOVE
argument_list|(
name|op
argument_list|,
name|nfso_list
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|op
argument_list|,
name|M_NFSCLOPEN
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nowp
operator|!=
name|NULL
condition|)
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|nowp
argument_list|,
name|M_NFSCLOWNER
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|dp
argument_list|,
argument|&extra_deleg
argument_list|,
argument|nfsdl_list
argument_list|,
argument|ndp
argument_list|)
block|{
do|do
block|{
name|newnfs_copycred
argument_list|(
operator|&
name|dp
operator|->
name|nfsdl_cred
argument_list|,
name|tcred
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfscl_trydelegreturn
argument_list|(
name|dp
argument_list|,
name|tcred
argument_list|,
name|nmp
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|NFSERR_GRACE
condition|)
operator|(
name|void
operator|)
name|nfs_catnap
argument_list|(
name|PZERO
argument_list|,
name|error
argument_list|,
literal|"nfsexdlg"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|error
operator|==
name|NFSERR_GRACE
condition|)
do|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|extra_deleg
argument_list|,
name|dp
argument_list|,
name|nfsdl_list
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|dp
argument_list|,
name|M_NFSCLDELEG
argument_list|)
expr_stmt|;
block|}
name|NFSLOCKCLSTATE
argument_list|()
expr_stmt|;
name|clp
operator|->
name|nfsc_flags
operator|&=
operator|~
name|NFSCLFLAGS_RECVRINPROG
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|clp
operator|->
name|nfsc_flags
argument_list|)
expr_stmt|;
name|nfsv4_unlock
argument_list|(
operator|&
name|clp
operator|->
name|nfsc_lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
name|NFSFREECRED
argument_list|(
name|tcred
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This function is called when a server replies with NFSERR_EXPIRED.  * It deletes all state for the client and does a fresh SetClientId/confirm.  * XXX Someday it should post a signal to the process(es) that hold the  * state, so they know that lock state has been lost.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfscl_hasexpired
parameter_list|(
name|struct
name|nfsclclient
modifier|*
name|clp
parameter_list|,
name|u_int32_t
name|clidrev
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|nfscllockowner
modifier|*
name|lp
decl_stmt|,
modifier|*
name|nlp
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|int
name|igotlock
init|=
literal|0
decl_stmt|,
name|error
decl_stmt|,
name|trycnt
decl_stmt|;
comment|/* 	 * If the clientid has gone away or a new SetClientid has already 	 * been done, just return ok. 	 */
if|if
condition|(
name|clp
operator|==
name|NULL
operator|||
name|clidrev
operator|!=
name|clp
operator|->
name|nfsc_clientidrev
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * First, lock the client structure, so everyone else will 	 * block when trying to use state. Also, use NFSCLFLAGS_EXPIREIT so 	 * that only one thread does the work. 	 */
name|NFSLOCKCLSTATE
argument_list|()
expr_stmt|;
name|clp
operator|->
name|nfsc_flags
operator||=
name|NFSCLFLAGS_EXPIREIT
expr_stmt|;
do|do
block|{
name|igotlock
operator|=
name|nfsv4_lock
argument_list|(
operator|&
name|clp
operator|->
name|nfsc_lock
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
name|NFSCLSTATEMUTEXPTR
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|igotlock
operator|&&
operator|(
name|clp
operator|->
name|nfsc_flags
operator|&
name|NFSCLFLAGS_EXPIREIT
operator|)
condition|)
do|;
if|if
condition|(
operator|(
name|clp
operator|->
name|nfsc_flags
operator|&
name|NFSCLFLAGS_EXPIREIT
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|igotlock
condition|)
name|nfsv4_unlock
argument_list|(
operator|&
name|clp
operator|->
name|nfsc_lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|clp
operator|->
name|nfsc_flags
operator||=
name|NFSCLFLAGS_RECVRINPROG
expr_stmt|;
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
name|nmp
operator|=
name|clp
operator|->
name|nfsc_nmp
expr_stmt|;
if|if
condition|(
name|nmp
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"nfscl expired"
argument_list|)
expr_stmt|;
name|cred
operator|=
name|newnfs_getcred
argument_list|()
expr_stmt|;
name|trycnt
operator|=
literal|5
expr_stmt|;
do|do
block|{
name|error
operator|=
name|nfsrpc_setclient
argument_list|(
name|nmp
argument_list|,
name|clp
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|error
operator|==
name|NFSERR_STALECLIENTID
operator|||
name|error
operator|==
name|NFSERR_STALEDONTRECOVER
operator|)
operator|&&
operator|--
name|trycnt
operator|>
literal|0
condition|)
do|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* 		 * Clear out any state. 		 */
name|nfscl_cleanclient
argument_list|(
name|clp
argument_list|)
expr_stmt|;
name|NFSLOCKCLSTATE
argument_list|()
expr_stmt|;
name|clp
operator|->
name|nfsc_flags
operator|&=
operator|~
operator|(
name|NFSCLFLAGS_HASCLIENTID
operator||
name|NFSCLFLAGS_RECOVER
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* get rid of defunct lockowners */
name|LIST_FOREACH_SAFE
argument_list|(
argument|lp
argument_list|,
argument|&clp->nfsc_defunctlockowner
argument_list|,
argument|nfsl_list
argument_list|,
argument|nlp
argument_list|)
block|{
name|nfscl_freelockowner
argument_list|(
name|lp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Expire the state for the client. 		 */
name|nfscl_expireclient
argument_list|(
name|clp
argument_list|,
name|nmp
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|NFSLOCKCLSTATE
argument_list|()
expr_stmt|;
name|clp
operator|->
name|nfsc_flags
operator||=
name|NFSCLFLAGS_HASCLIENTID
expr_stmt|;
name|clp
operator|->
name|nfsc_flags
operator|&=
operator|~
name|NFSCLFLAGS_RECOVER
expr_stmt|;
block|}
name|clp
operator|->
name|nfsc_flags
operator|&=
operator|~
operator|(
name|NFSCLFLAGS_EXPIREIT
operator||
name|NFSCLFLAGS_RECVRINPROG
operator|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|clp
operator|->
name|nfsc_flags
argument_list|)
expr_stmt|;
name|nfsv4_unlock
argument_list|(
operator|&
name|clp
operator|->
name|nfsc_lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
name|NFSFREECRED
argument_list|(
name|cred
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This function inserts a lock in the list after insert_lop.  */
end_comment

begin_function
specifier|static
name|void
name|nfscl_insertlock
parameter_list|(
name|struct
name|nfscllockowner
modifier|*
name|lp
parameter_list|,
name|struct
name|nfscllock
modifier|*
name|new_lop
parameter_list|,
name|struct
name|nfscllock
modifier|*
name|insert_lop
parameter_list|,
name|int
name|local
parameter_list|)
block|{
if|if
condition|(
operator|(
expr|struct
name|nfscllockowner
operator|*
operator|)
name|insert_lop
operator|==
name|lp
condition|)
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|lp
operator|->
name|nfsl_lock
argument_list|,
name|new_lop
argument_list|,
name|nfslo_list
argument_list|)
expr_stmt|;
else|else
name|LIST_INSERT_AFTER
argument_list|(
name|insert_lop
argument_list|,
name|new_lop
argument_list|,
name|nfslo_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|local
condition|)
name|newnfsstats
operator|.
name|cllocallocks
operator|++
expr_stmt|;
else|else
name|newnfsstats
operator|.
name|cllocks
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This function updates the locking for a lock owner and given file. It  * maintains a list of lock ranges ordered on increasing file offset that  * are NFSCLLOCK_READ or NFSCLLOCK_WRITE and non-overlapping (aka POSIX style).  * It always adds new_lop to the list and sometimes uses the one pointed  * at by other_lopp.  * Returns 1 if the locks were modified, 0 otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|nfscl_updatelock
parameter_list|(
name|struct
name|nfscllockowner
modifier|*
name|lp
parameter_list|,
name|struct
name|nfscllock
modifier|*
modifier|*
name|new_lopp
parameter_list|,
name|struct
name|nfscllock
modifier|*
modifier|*
name|other_lopp
parameter_list|,
name|int
name|local
parameter_list|)
block|{
name|struct
name|nfscllock
modifier|*
name|new_lop
init|=
operator|*
name|new_lopp
decl_stmt|;
name|struct
name|nfscllock
modifier|*
name|lop
decl_stmt|,
modifier|*
name|tlop
decl_stmt|,
modifier|*
name|ilop
decl_stmt|;
name|struct
name|nfscllock
modifier|*
name|other_lop
decl_stmt|;
name|int
name|unlock
init|=
literal|0
decl_stmt|,
name|modified
init|=
literal|0
decl_stmt|;
name|u_int64_t
name|tmp
decl_stmt|;
comment|/* 	 * Work down the list until the lock is merged. 	 */
if|if
condition|(
name|new_lop
operator|->
name|nfslo_type
operator|==
name|F_UNLCK
condition|)
name|unlock
operator|=
literal|1
expr_stmt|;
name|ilop
operator|=
operator|(
expr|struct
name|nfscllock
operator|*
operator|)
name|lp
expr_stmt|;
name|lop
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|lp
operator|->
name|nfsl_lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|lop
operator|!=
name|NULL
condition|)
block|{
comment|/* 	     * Only check locks for this file that aren't before the start of 	     * new lock's range. 	     */
if|if
condition|(
name|lop
operator|->
name|nfslo_end
operator|>=
name|new_lop
operator|->
name|nfslo_first
condition|)
block|{
if|if
condition|(
name|new_lop
operator|->
name|nfslo_end
operator|<
name|lop
operator|->
name|nfslo_first
condition|)
block|{
comment|/* 		     * If the new lock ends before the start of the 		     * current lock's range, no merge, just insert 		     * the new lock. 		     */
break|break;
block|}
if|if
condition|(
name|new_lop
operator|->
name|nfslo_type
operator|==
name|lop
operator|->
name|nfslo_type
operator|||
operator|(
name|new_lop
operator|->
name|nfslo_first
operator|<=
name|lop
operator|->
name|nfslo_first
operator|&&
name|new_lop
operator|->
name|nfslo_end
operator|>=
name|lop
operator|->
name|nfslo_end
operator|)
condition|)
block|{
comment|/* 		     * This lock can be absorbed by the new lock/unlock. 		     * This happens when it covers the entire range 		     * of the old lock or is contiguous 		     * with the old lock and is of the same type or an 		     * unlock. 		     */
if|if
condition|(
name|new_lop
operator|->
name|nfslo_type
operator|!=
name|lop
operator|->
name|nfslo_type
operator|||
name|new_lop
operator|->
name|nfslo_first
operator|!=
name|lop
operator|->
name|nfslo_first
operator|||
name|new_lop
operator|->
name|nfslo_end
operator|!=
name|lop
operator|->
name|nfslo_end
condition|)
name|modified
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|lop
operator|->
name|nfslo_first
operator|<
name|new_lop
operator|->
name|nfslo_first
condition|)
name|new_lop
operator|->
name|nfslo_first
operator|=
name|lop
operator|->
name|nfslo_first
expr_stmt|;
if|if
condition|(
name|lop
operator|->
name|nfslo_end
operator|>
name|new_lop
operator|->
name|nfslo_end
condition|)
name|new_lop
operator|->
name|nfslo_end
operator|=
name|lop
operator|->
name|nfslo_end
expr_stmt|;
name|tlop
operator|=
name|lop
expr_stmt|;
name|lop
operator|=
name|LIST_NEXT
argument_list|(
name|lop
argument_list|,
name|nfslo_list
argument_list|)
expr_stmt|;
name|nfscl_freelock
argument_list|(
name|tlop
argument_list|,
name|local
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * All these cases are for contiguous locks that are not the 		 * same type, so they can't be merged. 		 */
if|if
condition|(
name|new_lop
operator|->
name|nfslo_first
operator|<=
name|lop
operator|->
name|nfslo_first
condition|)
block|{
comment|/* 		     * This case is where the new lock overlaps with the 		     * first part of the old lock. Move the start of the 		     * old lock to just past the end of the new lock. The 		     * new lock will be inserted in front of the old, since 		     * ilop hasn't been updated. (We are done now.) 		     */
if|if
condition|(
name|lop
operator|->
name|nfslo_first
operator|!=
name|new_lop
operator|->
name|nfslo_end
condition|)
block|{
name|lop
operator|->
name|nfslo_first
operator|=
name|new_lop
operator|->
name|nfslo_end
expr_stmt|;
name|modified
operator|=
literal|1
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|new_lop
operator|->
name|nfslo_end
operator|>=
name|lop
operator|->
name|nfslo_end
condition|)
block|{
comment|/* 		     * This case is where the new lock overlaps with the 		     * end of the old lock's range. Move the old lock's 		     * end to just before the new lock's first and insert 		     * the new lock after the old lock. 		     * Might not be done yet, since the new lock could 		     * overlap further locks with higher ranges. 		     */
if|if
condition|(
name|lop
operator|->
name|nfslo_end
operator|!=
name|new_lop
operator|->
name|nfslo_first
condition|)
block|{
name|lop
operator|->
name|nfslo_end
operator|=
name|new_lop
operator|->
name|nfslo_first
expr_stmt|;
name|modified
operator|=
literal|1
expr_stmt|;
block|}
name|ilop
operator|=
name|lop
expr_stmt|;
name|lop
operator|=
name|LIST_NEXT
argument_list|(
name|lop
argument_list|,
name|nfslo_list
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * The final case is where the new lock's range is in the 		 * middle of the current lock's and splits the current lock 		 * up. Use *other_lopp to handle the second part of the 		 * split old lock range. (We are done now.) 		 * For unlock, we use new_lop as other_lop and tmp, since 		 * other_lop and new_lop are the same for this case. 		 * We noted the unlock case above, so we don't need 		 * new_lop->nfslo_type any longer. 		 */
name|tmp
operator|=
name|new_lop
operator|->
name|nfslo_first
expr_stmt|;
if|if
condition|(
name|unlock
condition|)
block|{
name|other_lop
operator|=
name|new_lop
expr_stmt|;
operator|*
name|new_lopp
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|other_lop
operator|=
operator|*
name|other_lopp
expr_stmt|;
operator|*
name|other_lopp
operator|=
name|NULL
expr_stmt|;
block|}
name|other_lop
operator|->
name|nfslo_first
operator|=
name|new_lop
operator|->
name|nfslo_end
expr_stmt|;
name|other_lop
operator|->
name|nfslo_end
operator|=
name|lop
operator|->
name|nfslo_end
expr_stmt|;
name|other_lop
operator|->
name|nfslo_type
operator|=
name|lop
operator|->
name|nfslo_type
expr_stmt|;
name|lop
operator|->
name|nfslo_end
operator|=
name|tmp
expr_stmt|;
name|nfscl_insertlock
argument_list|(
name|lp
argument_list|,
name|other_lop
argument_list|,
name|lop
argument_list|,
name|local
argument_list|)
expr_stmt|;
name|ilop
operator|=
name|lop
expr_stmt|;
name|modified
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|ilop
operator|=
name|lop
expr_stmt|;
name|lop
operator|=
name|LIST_NEXT
argument_list|(
name|lop
argument_list|,
name|nfslo_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|lop
operator|==
name|NULL
condition|)
break|break;
block|}
comment|/* 	 * Insert the new lock in the list at the appropriate place. 	 */
if|if
condition|(
operator|!
name|unlock
condition|)
block|{
name|nfscl_insertlock
argument_list|(
name|lp
argument_list|,
name|new_lop
argument_list|,
name|ilop
argument_list|,
name|local
argument_list|)
expr_stmt|;
operator|*
name|new_lopp
operator|=
name|NULL
expr_stmt|;
name|modified
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|modified
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This function must be run as a kernel thread.  * It does Renew Ops and recovery, when required.  */
end_comment

begin_function
name|APPLESTATIC
name|void
name|nfscl_renewthread
parameter_list|(
name|struct
name|nfsclclient
modifier|*
name|clp
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|nfsclowner
modifier|*
name|owp
decl_stmt|,
modifier|*
name|nowp
decl_stmt|;
name|struct
name|nfsclopen
modifier|*
name|op
decl_stmt|;
name|struct
name|nfscllockowner
modifier|*
name|lp
decl_stmt|,
modifier|*
name|nlp
decl_stmt|,
modifier|*
name|olp
decl_stmt|;
name|struct
name|nfscldeleghead
name|dh
decl_stmt|;
name|struct
name|nfscllockownerhead
name|lh
decl_stmt|;
name|struct
name|nfscldeleg
modifier|*
name|dp
decl_stmt|,
modifier|*
name|ndp
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|u_int32_t
name|clidrev
decl_stmt|;
name|int
name|error
decl_stmt|,
name|cbpathdown
decl_stmt|,
name|islept
decl_stmt|,
name|igotlock
decl_stmt|,
name|ret
decl_stmt|,
name|clearok
decl_stmt|;
name|uint32_t
name|recover_done_time
init|=
literal|0
decl_stmt|;
name|cred
operator|=
name|newnfs_getcred
argument_list|()
expr_stmt|;
name|NFSLOCKCLSTATE
argument_list|()
expr_stmt|;
name|clp
operator|->
name|nfsc_flags
operator||=
name|NFSCLFLAGS_HASTHREAD
expr_stmt|;
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|newnfs_setroot
argument_list|(
name|cred
argument_list|)
expr_stmt|;
name|cbpathdown
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|clp
operator|->
name|nfsc_flags
operator|&
name|NFSCLFLAGS_RECOVER
condition|)
block|{
comment|/* 			 * Only allow one recover within 1/2 of the lease 			 * duration (nfsc_renew). 			 */
if|if
condition|(
name|recover_done_time
operator|<
name|NFSD_MONOSEC
condition|)
block|{
name|recover_done_time
operator|=
name|NFSD_MONOSEC
operator|+
name|clp
operator|->
name|nfsc_renew
expr_stmt|;
name|nfscl_recover
argument_list|(
name|clp
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NFSLOCKCLSTATE
argument_list|()
expr_stmt|;
name|clp
operator|->
name|nfsc_flags
operator|&=
operator|~
name|NFSCLFLAGS_RECOVER
expr_stmt|;
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|clp
operator|->
name|nfsc_expire
operator|<=
name|NFSD_MONOSEC
operator|&&
operator|(
name|clp
operator|->
name|nfsc_flags
operator|&
name|NFSCLFLAGS_HASCLIENTID
operator|)
condition|)
block|{
name|clp
operator|->
name|nfsc_expire
operator|=
name|NFSD_MONOSEC
operator|+
name|clp
operator|->
name|nfsc_renew
expr_stmt|;
name|clidrev
operator|=
name|clp
operator|->
name|nfsc_clientidrev
expr_stmt|;
name|error
operator|=
name|nfsrpc_renew
argument_list|(
name|clp
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|NFSERR_CBPATHDOWN
condition|)
name|cbpathdown
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|error
operator|==
name|NFSERR_STALECLIENTID
condition|)
block|{
name|NFSLOCKCLSTATE
argument_list|()
expr_stmt|;
name|clp
operator|->
name|nfsc_flags
operator||=
name|NFSCLFLAGS_RECOVER
expr_stmt|;
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|error
operator|==
name|NFSERR_EXPIRED
condition|)
operator|(
name|void
operator|)
name|nfscl_hasexpired
argument_list|(
name|clp
argument_list|,
name|clidrev
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
name|LIST_INIT
argument_list|(
operator|&
name|lh
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|dh
argument_list|)
expr_stmt|;
name|NFSLOCKCLSTATE
argument_list|()
expr_stmt|;
if|if
condition|(
name|cbpathdown
condition|)
comment|/* It's a Total Recall! */
name|nfscl_totalrecall
argument_list|(
name|clp
argument_list|)
expr_stmt|;
comment|/* 		 * Now, handle defunct owners. 		 */
name|owp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|clp
operator|->
name|nfsc_owner
argument_list|)
expr_stmt|;
while|while
condition|(
name|owp
operator|!=
name|NULL
condition|)
block|{
name|nowp
operator|=
name|LIST_NEXT
argument_list|(
name|owp
argument_list|,
name|nfsow_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|owp
operator|->
name|nfsow_open
argument_list|)
condition|)
block|{
if|if
condition|(
name|owp
operator|->
name|nfsow_defunct
condition|)
name|nfscl_freeopenowner
argument_list|(
name|owp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LIST_FOREACH
argument_list|(
argument|op
argument_list|,
argument|&owp->nfsow_open
argument_list|,
argument|nfso_list
argument_list|)
block|{
name|lp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|op
operator|->
name|nfso_lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|lp
operator|!=
name|NULL
condition|)
block|{
name|nlp
operator|=
name|LIST_NEXT
argument_list|(
name|lp
argument_list|,
name|nfsl_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|lp
operator|->
name|nfsl_defunct
operator|&&
name|LIST_EMPTY
argument_list|(
operator|&
name|lp
operator|->
name|nfsl_lock
argument_list|)
condition|)
block|{
name|LIST_FOREACH
argument_list|(
argument|olp
argument_list|,
argument|&lh
argument_list|,
argument|nfsl_list
argument_list|)
block|{
if|if
condition|(
operator|!
name|NFSBCMP
argument_list|(
name|olp
operator|->
name|nfsl_owner
argument_list|,
name|lp
operator|->
name|nfsl_owner
argument_list|,
name|NFSV4CL_LOCKNAMELEN
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|olp
operator|==
name|NULL
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|lp
argument_list|,
name|nfsl_list
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|lh
argument_list|,
name|lp
argument_list|,
name|nfsl_list
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nfscl_freelockowner
argument_list|(
name|lp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|lp
operator|=
name|nlp
expr_stmt|;
block|}
block|}
block|}
name|owp
operator|=
name|nowp
expr_stmt|;
block|}
comment|/* also search the defunct list */
name|lp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|clp
operator|->
name|nfsc_defunctlockowner
argument_list|)
expr_stmt|;
while|while
condition|(
name|lp
operator|!=
name|NULL
condition|)
block|{
name|nlp
operator|=
name|LIST_NEXT
argument_list|(
name|lp
argument_list|,
name|nfsl_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|lp
operator|->
name|nfsl_defunct
condition|)
block|{
name|LIST_FOREACH
argument_list|(
argument|olp
argument_list|,
argument|&lh
argument_list|,
argument|nfsl_list
argument_list|)
block|{
if|if
condition|(
operator|!
name|NFSBCMP
argument_list|(
name|olp
operator|->
name|nfsl_owner
argument_list|,
name|lp
operator|->
name|nfsl_owner
argument_list|,
name|NFSV4CL_LOCKNAMELEN
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|olp
operator|==
name|NULL
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|lp
argument_list|,
name|nfsl_list
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|lh
argument_list|,
name|lp
argument_list|,
name|nfsl_list
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nfscl_freelockowner
argument_list|(
name|lp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|lp
operator|=
name|nlp
expr_stmt|;
block|}
comment|/* and release defunct lock owners */
name|LIST_FOREACH_SAFE
argument_list|(
argument|lp
argument_list|,
argument|&lh
argument_list|,
argument|nfsl_list
argument_list|,
argument|nlp
argument_list|)
block|{
name|nfscl_freelockowner
argument_list|(
name|lp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Do the recall on any delegations. To avoid trouble, always 		 * come back up here after having slept. 		 */
name|igotlock
operator|=
literal|0
expr_stmt|;
name|tryagain
label|:
name|dp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|clp
operator|->
name|nfsc_deleg
argument_list|)
expr_stmt|;
while|while
condition|(
name|dp
operator|!=
name|NULL
condition|)
block|{
name|ndp
operator|=
name|TAILQ_NEXT
argument_list|(
name|dp
argument_list|,
name|nfsdl_list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dp
operator|->
name|nfsdl_flags
operator|&
name|NFSCLDL_RECALL
operator|)
condition|)
block|{
comment|/* 				 * Wait for outstanding I/O ops to be done. 				 */
if|if
condition|(
name|dp
operator|->
name|nfsdl_rwlock
operator|.
name|nfslock_usecnt
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|igotlock
condition|)
block|{
name|nfsv4_unlock
argument_list|(
operator|&
name|clp
operator|->
name|nfsc_lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|igotlock
operator|=
literal|0
expr_stmt|;
block|}
name|dp
operator|->
name|nfsdl_rwlock
operator|.
name|nfslock_lock
operator||=
name|NFSV4LOCK_WANTED
expr_stmt|;
operator|(
name|void
operator|)
name|nfsmsleep
argument_list|(
operator|&
name|dp
operator|->
name|nfsdl_rwlock
argument_list|,
name|NFSCLSTATEMUTEXPTR
argument_list|,
name|PZERO
argument_list|,
literal|"nfscld"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|tryagain
goto|;
block|}
while|while
condition|(
operator|!
name|igotlock
condition|)
block|{
name|igotlock
operator|=
name|nfsv4_lock
argument_list|(
operator|&
name|clp
operator|->
name|nfsc_lock
argument_list|,
literal|1
argument_list|,
operator|&
name|islept
argument_list|,
name|NFSCLSTATEMUTEXPTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|islept
condition|)
goto|goto
name|tryagain
goto|;
block|}
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
name|newnfs_copycred
argument_list|(
operator|&
name|dp
operator|->
name|nfsdl_cred
argument_list|,
name|cred
argument_list|)
expr_stmt|;
name|ret
operator|=
name|nfscl_recalldeleg
argument_list|(
name|clp
argument_list|,
name|clp
operator|->
name|nfsc_nmp
argument_list|,
name|dp
argument_list|,
name|NULL
argument_list|,
name|cred
argument_list|,
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|nfscl_cleandeleg
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|clp
operator|->
name|nfsc_deleg
argument_list|,
name|dp
argument_list|,
name|nfsdl_list
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|dp
argument_list|,
name|nfsdl_hash
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|dh
argument_list|,
name|dp
argument_list|,
name|nfsdl_list
argument_list|)
expr_stmt|;
name|nfscl_delegcnt
operator|--
expr_stmt|;
name|newnfsstats
operator|.
name|cldelegates
operator|--
expr_stmt|;
block|}
name|NFSLOCKCLSTATE
argument_list|()
expr_stmt|;
block|}
name|dp
operator|=
name|ndp
expr_stmt|;
block|}
comment|/* 		 * Clear out old delegations, if we are above the high water 		 * mark. Only clear out ones with no state related to them. 		 * The tailq list is in LRU order. 		 */
name|dp
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|clp
operator|->
name|nfsc_deleg
argument_list|,
name|nfscldeleghead
argument_list|)
expr_stmt|;
while|while
condition|(
name|nfscl_delegcnt
operator|>
name|nfscl_deleghighwater
operator|&&
name|dp
operator|!=
name|NULL
condition|)
block|{
name|ndp
operator|=
name|TAILQ_PREV
argument_list|(
name|dp
argument_list|,
name|nfscldeleghead
argument_list|,
name|nfsdl_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|nfsdl_rwlock
operator|.
name|nfslock_usecnt
operator|==
literal|0
operator|&&
name|dp
operator|->
name|nfsdl_rwlock
operator|.
name|nfslock_lock
operator|==
literal|0
operator|&&
name|dp
operator|->
name|nfsdl_timestamp
operator|<
name|NFSD_MONOSEC
operator|&&
operator|(
name|dp
operator|->
name|nfsdl_flags
operator|&
operator|(
name|NFSCLDL_RECALL
operator||
name|NFSCLDL_ZAPPED
operator||
name|NFSCLDL_NEEDRECLAIM
operator||
name|NFSCLDL_DELEGRET
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|clearok
operator|=
literal|1
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|owp
argument_list|,
argument|&dp->nfsdl_owner
argument_list|,
argument|nfsow_list
argument_list|)
block|{
name|op
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|owp
operator|->
name|nfsow_open
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|!=
name|NULL
condition|)
block|{
name|clearok
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|clearok
condition|)
block|{
name|LIST_FOREACH
argument_list|(
argument|lp
argument_list|,
argument|&dp->nfsdl_lock
argument_list|,
argument|nfsl_list
argument_list|)
block|{
if|if
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|lp
operator|->
name|nfsl_lock
argument_list|)
condition|)
block|{
name|clearok
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|clearok
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|clp
operator|->
name|nfsc_deleg
argument_list|,
name|dp
argument_list|,
name|nfsdl_list
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|dp
argument_list|,
name|nfsdl_hash
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|dh
argument_list|,
name|dp
argument_list|,
name|nfsdl_list
argument_list|)
expr_stmt|;
name|nfscl_delegcnt
operator|--
expr_stmt|;
name|newnfsstats
operator|.
name|cldelegates
operator|--
expr_stmt|;
block|}
block|}
name|dp
operator|=
name|ndp
expr_stmt|;
block|}
if|if
condition|(
name|igotlock
condition|)
name|nfsv4_unlock
argument_list|(
operator|&
name|clp
operator|->
name|nfsc_lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
comment|/* 		 * Delegreturn any delegations cleaned out or recalled. 		 */
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|dp
argument_list|,
argument|&dh
argument_list|,
argument|nfsdl_list
argument_list|,
argument|ndp
argument_list|)
block|{
name|newnfs_copycred
argument_list|(
operator|&
name|dp
operator|->
name|nfsdl_cred
argument_list|,
name|cred
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfscl_trydelegreturn
argument_list|(
name|dp
argument_list|,
name|cred
argument_list|,
name|clp
operator|->
name|nfsc_nmp
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|dh
argument_list|,
name|dp
argument_list|,
name|nfsdl_list
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|dp
argument_list|,
name|M_NFSCLDELEG
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|APPLEKEXT
argument_list|)
operator|||
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
comment|/* 		 * Simulate the calls to nfscl_cleanup() when a process 		 * exits, since the call can't be patched into exit(). 		 */
block|{
name|struct
name|timespec
name|mytime
decl_stmt|;
specifier|static
name|time_t
name|prevsec
init|=
literal|0
decl_stmt|;
name|NFSGETNANOTIME
argument_list|(
operator|&
name|mytime
argument_list|)
expr_stmt|;
if|if
condition|(
name|prevsec
operator|!=
name|mytime
operator|.
name|tv_sec
condition|)
block|{
name|prevsec
operator|=
name|mytime
operator|.
name|tv_sec
expr_stmt|;
name|nfscl_cleanupkext
argument_list|(
name|clp
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* APPLEKEXT || __FreeBSD__ */
if|if
condition|(
operator|(
name|clp
operator|->
name|nfsc_flags
operator|&
name|NFSCLFLAGS_RECOVER
operator|)
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|clp
argument_list|,
name|PWAIT
argument_list|,
literal|"nfscl"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
if|if
condition|(
name|clp
operator|->
name|nfsc_flags
operator|&
name|NFSCLFLAGS_UMOUNT
condition|)
block|{
name|NFSFREECRED
argument_list|(
name|cred
argument_list|)
expr_stmt|;
name|clp
operator|->
name|nfsc_flags
operator|&=
operator|~
name|NFSCLFLAGS_HASTHREAD
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|clp
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Initiate state recovery. Called when NFSERR_STALECLIENTID or  * NFSERR_STALESTATEID is received.  */
end_comment

begin_function
name|APPLESTATIC
name|void
name|nfscl_initiate_recovery
parameter_list|(
name|struct
name|nfsclclient
modifier|*
name|clp
parameter_list|)
block|{
if|if
condition|(
name|clp
operator|==
name|NULL
condition|)
return|return;
name|NFSLOCKCLSTATE
argument_list|()
expr_stmt|;
name|clp
operator|->
name|nfsc_flags
operator||=
name|NFSCLFLAGS_RECOVER
expr_stmt|;
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|clp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Dump out the state stuff for debugging.  */
end_comment

begin_function
name|APPLESTATIC
name|void
name|nfscl_dumpstate
parameter_list|(
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|,
name|int
name|openowner
parameter_list|,
name|int
name|opens
parameter_list|,
name|int
name|lockowner
parameter_list|,
name|int
name|locks
parameter_list|)
block|{
name|struct
name|nfsclclient
modifier|*
name|clp
decl_stmt|;
name|struct
name|nfsclowner
modifier|*
name|owp
decl_stmt|;
name|struct
name|nfsclopen
modifier|*
name|op
decl_stmt|;
name|struct
name|nfscllockowner
modifier|*
name|lp
decl_stmt|;
name|struct
name|nfscllock
modifier|*
name|lop
decl_stmt|;
name|struct
name|nfscldeleg
modifier|*
name|dp
decl_stmt|;
name|clp
operator|=
name|nmp
operator|->
name|nm_clp
expr_stmt|;
if|if
condition|(
name|clp
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"nfscl dumpstate NULL clp\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|NFSLOCKCLSTATE
argument_list|()
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|dp
argument_list|,
argument|&clp->nfsc_deleg
argument_list|,
argument|nfsdl_list
argument_list|)
block|{
name|LIST_FOREACH
argument_list|(
argument|owp
argument_list|,
argument|&dp->nfsdl_owner
argument_list|,
argument|nfsow_list
argument_list|)
block|{
if|if
condition|(
name|openowner
operator|&&
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|owp
operator|->
name|nfsow_open
argument_list|)
condition|)
name|printf
argument_list|(
literal|"owner=0x%x 0x%x 0x%x 0x%x seqid=%d\n"
argument_list|,
name|owp
operator|->
name|nfsow_owner
index|[
literal|0
index|]
argument_list|,
name|owp
operator|->
name|nfsow_owner
index|[
literal|1
index|]
argument_list|,
name|owp
operator|->
name|nfsow_owner
index|[
literal|2
index|]
argument_list|,
name|owp
operator|->
name|nfsow_owner
index|[
literal|3
index|]
argument_list|,
name|owp
operator|->
name|nfsow_seqid
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|op
argument_list|,
argument|&owp->nfsow_open
argument_list|,
argument|nfso_list
argument_list|)
block|{
if|if
condition|(
name|opens
condition|)
name|printf
argument_list|(
literal|"open st=0x%x 0x%x 0x%x cnt=%d fh12=0x%x\n"
argument_list|,
name|op
operator|->
name|nfso_stateid
operator|.
name|other
index|[
literal|0
index|]
argument_list|,
name|op
operator|->
name|nfso_stateid
operator|.
name|other
index|[
literal|1
index|]
argument_list|,
name|op
operator|->
name|nfso_stateid
operator|.
name|other
index|[
literal|2
index|]
argument_list|,
name|op
operator|->
name|nfso_opencnt
argument_list|,
name|op
operator|->
name|nfso_fh
index|[
literal|12
index|]
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|lp
argument_list|,
argument|&op->nfso_lock
argument_list|,
argument|nfsl_list
argument_list|)
block|{
if|if
condition|(
name|lockowner
condition|)
name|printf
argument_list|(
literal|"lckown=0x%x 0x%x 0x%x 0x%x seqid=%d st=0x%x 0x%x 0x%x\n"
argument_list|,
name|lp
operator|->
name|nfsl_owner
index|[
literal|0
index|]
argument_list|,
name|lp
operator|->
name|nfsl_owner
index|[
literal|1
index|]
argument_list|,
name|lp
operator|->
name|nfsl_owner
index|[
literal|2
index|]
argument_list|,
name|lp
operator|->
name|nfsl_owner
index|[
literal|3
index|]
argument_list|,
name|lp
operator|->
name|nfsl_seqid
argument_list|,
name|lp
operator|->
name|nfsl_stateid
operator|.
name|other
index|[
literal|0
index|]
argument_list|,
name|lp
operator|->
name|nfsl_stateid
operator|.
name|other
index|[
literal|1
index|]
argument_list|,
name|lp
operator|->
name|nfsl_stateid
operator|.
name|other
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|lop
argument_list|,
argument|&lp->nfsl_lock
argument_list|,
argument|nfslo_list
argument_list|)
block|{
if|if
condition|(
name|locks
condition|)
ifdef|#
directive|ifdef
name|__FreeBSD__
name|printf
argument_list|(
literal|"lck typ=%d fst=%ju end=%ju\n"
argument_list|,
name|lop
operator|->
name|nfslo_type
argument_list|,
operator|(
name|intmax_t
operator|)
name|lop
operator|->
name|nfslo_first
argument_list|,
operator|(
name|intmax_t
operator|)
name|lop
operator|->
name|nfslo_end
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"lck typ=%d fst=%qd end=%qd\n"
argument_list|,
name|lop
operator|->
name|nfslo_type
argument_list|,
name|lop
operator|->
name|nfslo_first
argument_list|,
name|lop
operator|->
name|nfslo_end
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
block|}
block|}
name|LIST_FOREACH
argument_list|(
argument|owp
argument_list|,
argument|&clp->nfsc_owner
argument_list|,
argument|nfsow_list
argument_list|)
block|{
if|if
condition|(
name|openowner
operator|&&
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|owp
operator|->
name|nfsow_open
argument_list|)
condition|)
name|printf
argument_list|(
literal|"owner=0x%x 0x%x 0x%x 0x%x seqid=%d\n"
argument_list|,
name|owp
operator|->
name|nfsow_owner
index|[
literal|0
index|]
argument_list|,
name|owp
operator|->
name|nfsow_owner
index|[
literal|1
index|]
argument_list|,
name|owp
operator|->
name|nfsow_owner
index|[
literal|2
index|]
argument_list|,
name|owp
operator|->
name|nfsow_owner
index|[
literal|3
index|]
argument_list|,
name|owp
operator|->
name|nfsow_seqid
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|op
argument_list|,
argument|&owp->nfsow_open
argument_list|,
argument|nfso_list
argument_list|)
block|{
if|if
condition|(
name|opens
condition|)
name|printf
argument_list|(
literal|"open st=0x%x 0x%x 0x%x cnt=%d fh12=0x%x\n"
argument_list|,
name|op
operator|->
name|nfso_stateid
operator|.
name|other
index|[
literal|0
index|]
argument_list|,
name|op
operator|->
name|nfso_stateid
operator|.
name|other
index|[
literal|1
index|]
argument_list|,
name|op
operator|->
name|nfso_stateid
operator|.
name|other
index|[
literal|2
index|]
argument_list|,
name|op
operator|->
name|nfso_opencnt
argument_list|,
name|op
operator|->
name|nfso_fh
index|[
literal|12
index|]
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|lp
argument_list|,
argument|&op->nfso_lock
argument_list|,
argument|nfsl_list
argument_list|)
block|{
if|if
condition|(
name|lockowner
condition|)
name|printf
argument_list|(
literal|"lckown=0x%x 0x%x 0x%x 0x%x seqid=%d st=0x%x 0x%x 0x%x\n"
argument_list|,
name|lp
operator|->
name|nfsl_owner
index|[
literal|0
index|]
argument_list|,
name|lp
operator|->
name|nfsl_owner
index|[
literal|1
index|]
argument_list|,
name|lp
operator|->
name|nfsl_owner
index|[
literal|2
index|]
argument_list|,
name|lp
operator|->
name|nfsl_owner
index|[
literal|3
index|]
argument_list|,
name|lp
operator|->
name|nfsl_seqid
argument_list|,
name|lp
operator|->
name|nfsl_stateid
operator|.
name|other
index|[
literal|0
index|]
argument_list|,
name|lp
operator|->
name|nfsl_stateid
operator|.
name|other
index|[
literal|1
index|]
argument_list|,
name|lp
operator|->
name|nfsl_stateid
operator|.
name|other
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|lop
argument_list|,
argument|&lp->nfsl_lock
argument_list|,
argument|nfslo_list
argument_list|)
block|{
if|if
condition|(
name|locks
condition|)
ifdef|#
directive|ifdef
name|__FreeBSD__
name|printf
argument_list|(
literal|"lck typ=%d fst=%ju end=%ju\n"
argument_list|,
name|lop
operator|->
name|nfslo_type
argument_list|,
operator|(
name|intmax_t
operator|)
name|lop
operator|->
name|nfslo_first
argument_list|,
operator|(
name|intmax_t
operator|)
name|lop
operator|->
name|nfslo_end
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"lck typ=%d fst=%qd end=%qd\n"
argument_list|,
name|lop
operator|->
name|nfslo_type
argument_list|,
name|lop
operator|->
name|nfslo_first
argument_list|,
name|lop
operator|->
name|nfslo_end
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
block|}
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Check for duplicate open owners and opens.  * (Only used as a diagnostic aid.)  */
end_comment

begin_function
name|APPLESTATIC
name|void
name|nfscl_dupopen
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|int
name|dupopens
parameter_list|)
block|{
name|struct
name|nfsclclient
modifier|*
name|clp
decl_stmt|;
name|struct
name|nfsclowner
modifier|*
name|owp
decl_stmt|,
modifier|*
name|owp2
decl_stmt|;
name|struct
name|nfsclopen
modifier|*
name|op
decl_stmt|,
modifier|*
name|op2
decl_stmt|;
name|struct
name|nfsfh
modifier|*
name|nfhp
decl_stmt|;
name|clp
operator|=
name|VFSTONFS
argument_list|(
name|vnode_mount
argument_list|(
name|vp
argument_list|)
argument_list|)
operator|->
name|nm_clp
expr_stmt|;
if|if
condition|(
name|clp
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"nfscl dupopen NULL clp\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|nfhp
operator|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
operator|->
name|n_fhp
expr_stmt|;
name|NFSLOCKCLSTATE
argument_list|()
expr_stmt|;
comment|/* 	 * First, search for duplicate owners. 	 * These should never happen! 	 */
name|LIST_FOREACH
argument_list|(
argument|owp2
argument_list|,
argument|&clp->nfsc_owner
argument_list|,
argument|nfsow_list
argument_list|)
block|{
name|LIST_FOREACH
argument_list|(
argument|owp
argument_list|,
argument|&clp->nfsc_owner
argument_list|,
argument|nfsow_list
argument_list|)
block|{
if|if
condition|(
name|owp
operator|!=
name|owp2
operator|&&
operator|!
name|NFSBCMP
argument_list|(
name|owp
operator|->
name|nfsow_owner
argument_list|,
name|owp2
operator|->
name|nfsow_owner
argument_list|,
name|NFSV4CL_LOCKNAMELEN
argument_list|)
condition|)
block|{
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"DUP OWNER\n"
argument_list|)
expr_stmt|;
name|nfscl_dumpstate
argument_list|(
name|VFSTONFS
argument_list|(
name|vnode_mount
argument_list|(
name|vp
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
comment|/* 	 * Now, search for duplicate stateids. 	 * These shouldn't happen, either. 	 */
name|LIST_FOREACH
argument_list|(
argument|owp2
argument_list|,
argument|&clp->nfsc_owner
argument_list|,
argument|nfsow_list
argument_list|)
block|{
name|LIST_FOREACH
argument_list|(
argument|op2
argument_list|,
argument|&owp2->nfsow_open
argument_list|,
argument|nfso_list
argument_list|)
block|{
name|LIST_FOREACH
argument_list|(
argument|owp
argument_list|,
argument|&clp->nfsc_owner
argument_list|,
argument|nfsow_list
argument_list|)
block|{
name|LIST_FOREACH
argument_list|(
argument|op
argument_list|,
argument|&owp->nfsow_open
argument_list|,
argument|nfso_list
argument_list|)
block|{
if|if
condition|(
name|op
operator|!=
name|op2
operator|&&
operator|(
name|op
operator|->
name|nfso_stateid
operator|.
name|other
index|[
literal|0
index|]
operator|!=
literal|0
operator|||
name|op
operator|->
name|nfso_stateid
operator|.
name|other
index|[
literal|1
index|]
operator|!=
literal|0
operator|||
name|op
operator|->
name|nfso_stateid
operator|.
name|other
index|[
literal|2
index|]
operator|!=
literal|0
operator|)
operator|&&
name|op
operator|->
name|nfso_stateid
operator|.
name|other
index|[
literal|0
index|]
operator|==
name|op2
operator|->
name|nfso_stateid
operator|.
name|other
index|[
literal|0
index|]
operator|&&
name|op
operator|->
name|nfso_stateid
operator|.
name|other
index|[
literal|1
index|]
operator|==
name|op2
operator|->
name|nfso_stateid
operator|.
name|other
index|[
literal|1
index|]
operator|&&
name|op
operator|->
name|nfso_stateid
operator|.
name|other
index|[
literal|2
index|]
operator|==
name|op2
operator|->
name|nfso_stateid
operator|.
name|other
index|[
literal|2
index|]
condition|)
block|{
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"DUP STATEID\n"
argument_list|)
expr_stmt|;
name|nfscl_dumpstate
argument_list|(
name|VFSTONFS
argument_list|(
name|vnode_mount
argument_list|(
name|vp
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
block|}
block|}
comment|/* 	 * Now search for duplicate opens. 	 * Duplicate opens for the same owner 	 * should never occur. Other duplicates are 	 * possible and are checked for if "dupopens" 	 * is true. 	 */
name|LIST_FOREACH
argument_list|(
argument|owp2
argument_list|,
argument|&clp->nfsc_owner
argument_list|,
argument|nfsow_list
argument_list|)
block|{
name|LIST_FOREACH
argument_list|(
argument|op2
argument_list|,
argument|&owp2->nfsow_open
argument_list|,
argument|nfso_list
argument_list|)
block|{
if|if
condition|(
name|nfhp
operator|->
name|nfh_len
operator|==
name|op2
operator|->
name|nfso_fhlen
operator|&&
operator|!
name|NFSBCMP
argument_list|(
name|nfhp
operator|->
name|nfh_fh
argument_list|,
name|op2
operator|->
name|nfso_fh
argument_list|,
name|nfhp
operator|->
name|nfh_len
argument_list|)
condition|)
block|{
name|LIST_FOREACH
argument_list|(
argument|owp
argument_list|,
argument|&clp->nfsc_owner
argument_list|,
argument|nfsow_list
argument_list|)
block|{
name|LIST_FOREACH
argument_list|(
argument|op
argument_list|,
argument|&owp->nfsow_open
argument_list|,
argument|nfso_list
argument_list|)
block|{
if|if
condition|(
name|op
operator|!=
name|op2
operator|&&
name|nfhp
operator|->
name|nfh_len
operator|==
name|op
operator|->
name|nfso_fhlen
operator|&&
operator|!
name|NFSBCMP
argument_list|(
name|nfhp
operator|->
name|nfh_fh
argument_list|,
name|op
operator|->
name|nfso_fh
argument_list|,
name|nfhp
operator|->
name|nfh_len
argument_list|)
operator|&&
operator|(
operator|!
name|NFSBCMP
argument_list|(
name|op
operator|->
name|nfso_own
operator|->
name|nfsow_owner
argument_list|,
name|op2
operator|->
name|nfso_own
operator|->
name|nfsow_owner
argument_list|,
name|NFSV4CL_LOCKNAMELEN
argument_list|)
operator|||
name|dupopens
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|NFSBCMP
argument_list|(
name|op
operator|->
name|nfso_own
operator|->
name|nfsow_owner
argument_list|,
name|op2
operator|->
name|nfso_own
operator|->
name|nfsow_owner
argument_list|,
name|NFSV4CL_LOCKNAMELEN
argument_list|)
condition|)
block|{
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"BADDUP OPEN\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"DUP OPEN\n"
argument_list|)
expr_stmt|;
block|}
name|nfscl_dumpstate
argument_list|(
name|VFSTONFS
argument_list|(
name|vnode_mount
argument_list|(
name|vp
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
block|}
block|}
block|}
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * During close, find an open that needs to be dereferenced and  * dereference it. If there are no more opens for this file,  * log a message to that effect.  * Opens aren't actually Close'd until VOP_INACTIVE() is performed  * on the file's vnode.  * This is the safe way, since it is difficult to identify  * which open the close is for and I/O can be performed after the  * close(2) system call when a file is mmap'd.  * If it returns 0 for success, there will be a referenced  * clp returned via clpp.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfscl_getclose
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|struct
name|nfsclclient
modifier|*
modifier|*
name|clpp
parameter_list|)
block|{
name|struct
name|nfsclclient
modifier|*
name|clp
decl_stmt|;
name|struct
name|nfsclowner
modifier|*
name|owp
decl_stmt|;
name|struct
name|nfsclopen
modifier|*
name|op
decl_stmt|;
name|struct
name|nfscldeleg
modifier|*
name|dp
decl_stmt|;
name|struct
name|nfsfh
modifier|*
name|nfhp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|notdecr
decl_stmt|;
name|error
operator|=
name|nfscl_getcl
argument_list|(
name|vp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|clp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
operator|*
name|clpp
operator|=
name|clp
expr_stmt|;
name|nfhp
operator|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
operator|->
name|n_fhp
expr_stmt|;
name|notdecr
operator|=
literal|1
expr_stmt|;
name|NFSLOCKCLSTATE
argument_list|()
expr_stmt|;
comment|/* 	 * First, look for one under a delegation that was locally issued 	 * and just decrement the opencnt for it. Since all my Opens against 	 * the server are DENY_NONE, I don't see a problem with hanging 	 * onto them. (It is much easier to use one of the extant Opens 	 * that I already have on the server when a Delegation is recalled 	 * than to do fresh Opens.) Someday, I might need to rethink this, but. 	 */
name|dp
operator|=
name|nfscl_finddeleg
argument_list|(
name|clp
argument_list|,
name|nfhp
operator|->
name|nfh_fh
argument_list|,
name|nfhp
operator|->
name|nfh_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|!=
name|NULL
condition|)
block|{
name|LIST_FOREACH
argument_list|(
argument|owp
argument_list|,
argument|&dp->nfsdl_owner
argument_list|,
argument|nfsow_list
argument_list|)
block|{
name|op
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|owp
operator|->
name|nfsow_open
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|!=
name|NULL
condition|)
block|{
comment|/* 				 * Since a delegation is for a file, there 				 * should never be more than one open for 				 * each openowner. 				 */
if|if
condition|(
name|LIST_NEXT
argument_list|(
name|op
argument_list|,
name|nfso_list
argument_list|)
operator|!=
name|NULL
condition|)
name|panic
argument_list|(
literal|"nfscdeleg opens"
argument_list|)
expr_stmt|;
if|if
condition|(
name|notdecr
operator|&&
name|op
operator|->
name|nfso_opencnt
operator|>
literal|0
condition|)
block|{
name|notdecr
operator|=
literal|0
expr_stmt|;
name|op
operator|->
name|nfso_opencnt
operator|--
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
comment|/* Now process the opens against the server. */
name|LIST_FOREACH
argument_list|(
argument|owp
argument_list|,
argument|&clp->nfsc_owner
argument_list|,
argument|nfsow_list
argument_list|)
block|{
name|LIST_FOREACH
argument_list|(
argument|op
argument_list|,
argument|&owp->nfsow_open
argument_list|,
argument|nfso_list
argument_list|)
block|{
if|if
condition|(
name|op
operator|->
name|nfso_fhlen
operator|==
name|nfhp
operator|->
name|nfh_len
operator|&&
operator|!
name|NFSBCMP
argument_list|(
name|op
operator|->
name|nfso_fh
argument_list|,
name|nfhp
operator|->
name|nfh_fh
argument_list|,
name|nfhp
operator|->
name|nfh_len
argument_list|)
condition|)
block|{
comment|/* Found an open, decrement cnt if possible */
if|if
condition|(
name|notdecr
operator|&&
name|op
operator|->
name|nfso_opencnt
operator|>
literal|0
condition|)
block|{
name|notdecr
operator|=
literal|0
expr_stmt|;
name|op
operator|->
name|nfso_opencnt
operator|--
expr_stmt|;
block|}
comment|/* 				 * There are more opens, so just return. 				 */
if|if
condition|(
name|op
operator|->
name|nfso_opencnt
operator|>
literal|0
condition|)
block|{
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
block|}
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
if|if
condition|(
name|notdecr
condition|)
name|printf
argument_list|(
literal|"nfscl: never fnd open\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|APPLESTATIC
name|int
name|nfscl_doclose
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|struct
name|nfsclclient
modifier|*
modifier|*
name|clpp
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|nfsclclient
modifier|*
name|clp
decl_stmt|;
name|struct
name|nfsclowner
modifier|*
name|owp
decl_stmt|,
modifier|*
name|nowp
decl_stmt|;
name|struct
name|nfsclopen
modifier|*
name|op
decl_stmt|;
name|struct
name|nfscldeleg
modifier|*
name|dp
decl_stmt|;
name|struct
name|nfsfh
modifier|*
name|nfhp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|nfscl_getcl
argument_list|(
name|vp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|clp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
operator|*
name|clpp
operator|=
name|clp
expr_stmt|;
name|nfhp
operator|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
operator|->
name|n_fhp
expr_stmt|;
name|NFSLOCKCLSTATE
argument_list|()
expr_stmt|;
comment|/* 	 * First get rid of the local Open structures, which should be no 	 * longer in use. 	 */
name|dp
operator|=
name|nfscl_finddeleg
argument_list|(
name|clp
argument_list|,
name|nfhp
operator|->
name|nfh_fh
argument_list|,
name|nfhp
operator|->
name|nfh_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|!=
name|NULL
condition|)
block|{
name|LIST_FOREACH_SAFE
argument_list|(
argument|owp
argument_list|,
argument|&dp->nfsdl_owner
argument_list|,
argument|nfsow_list
argument_list|,
argument|nowp
argument_list|)
block|{
name|op
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|owp
operator|->
name|nfsow_open
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|!=
name|NULL
condition|)
block|{
name|KASSERT
argument_list|(
operator|(
name|op
operator|->
name|nfso_opencnt
operator|==
literal|0
operator|)
argument_list|,
operator|(
literal|"nfscl: bad open cnt on deleg"
operator|)
argument_list|)
expr_stmt|;
name|nfscl_freeopen
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|nfscl_freeopenowner
argument_list|(
name|owp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now process the opens against the server. */
name|lookformore
label|:
name|LIST_FOREACH
argument_list|(
argument|owp
argument_list|,
argument|&clp->nfsc_owner
argument_list|,
argument|nfsow_list
argument_list|)
block|{
name|op
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|owp
operator|->
name|nfsow_open
argument_list|)
expr_stmt|;
while|while
condition|(
name|op
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|op
operator|->
name|nfso_fhlen
operator|==
name|nfhp
operator|->
name|nfh_len
operator|&&
operator|!
name|NFSBCMP
argument_list|(
name|op
operator|->
name|nfso_fh
argument_list|,
name|nfhp
operator|->
name|nfh_fh
argument_list|,
name|nfhp
operator|->
name|nfh_len
argument_list|)
condition|)
block|{
comment|/* Found an open, close it. */
name|KASSERT
argument_list|(
operator|(
name|op
operator|->
name|nfso_opencnt
operator|==
literal|0
operator|)
argument_list|,
operator|(
literal|"nfscl: bad open cnt on server"
operator|)
argument_list|)
expr_stmt|;
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
name|nfsrpc_doclose
argument_list|(
name|VFSTONFS
argument_list|(
name|vnode_mount
argument_list|(
name|vp
argument_list|)
argument_list|)
argument_list|,
name|op
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|NFSLOCKCLSTATE
argument_list|()
expr_stmt|;
goto|goto
name|lookformore
goto|;
block|}
name|op
operator|=
name|LIST_NEXT
argument_list|(
name|op
argument_list|,
name|nfso_list
argument_list|)
expr_stmt|;
block|}
block|}
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return all delegations on this client.  * (Must be called with client sleep lock.)  */
end_comment

begin_function
specifier|static
name|void
name|nfscl_delegreturnall
parameter_list|(
name|struct
name|nfsclclient
modifier|*
name|clp
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|nfscldeleg
modifier|*
name|dp
decl_stmt|,
modifier|*
name|ndp
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|cred
operator|=
name|newnfs_getcred
argument_list|()
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|dp
argument_list|,
argument|&clp->nfsc_deleg
argument_list|,
argument|nfsdl_list
argument_list|,
argument|ndp
argument_list|)
block|{
name|nfscl_cleandeleg
argument_list|(
name|dp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfscl_trydelegreturn
argument_list|(
name|dp
argument_list|,
name|cred
argument_list|,
name|clp
operator|->
name|nfsc_nmp
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|nfscl_freedeleg
argument_list|(
operator|&
name|clp
operator|->
name|nfsc_deleg
argument_list|,
name|dp
argument_list|)
expr_stmt|;
block|}
name|NFSFREECRED
argument_list|(
name|cred
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Do a callback RPC.  */
end_comment

begin_function
name|APPLESTATIC
name|void
name|nfscl_docb
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|op
decl_stmt|;
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|struct
name|nfsclclient
modifier|*
name|clp
decl_stmt|;
name|struct
name|nfscldeleg
modifier|*
name|dp
init|=
name|NULL
decl_stmt|;
name|int
name|numops
decl_stmt|,
name|taglen
init|=
operator|-
literal|1
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|,
name|trunc
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
name|u_int32_t
name|minorvers
decl_stmt|,
name|retops
init|=
literal|0
decl_stmt|,
modifier|*
name|retopsp
init|=
name|NULL
decl_stmt|,
modifier|*
name|repp
decl_stmt|,
name|cbident
decl_stmt|;
name|u_char
name|tag
index|[
name|NFSV4_SMALLSTR
operator|+
literal|1
index|]
decl_stmt|,
modifier|*
name|tagstr
decl_stmt|;
name|vnode_t
name|vp
init|=
name|NULL
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|np
decl_stmt|;
name|struct
name|vattr
name|va
decl_stmt|;
name|struct
name|nfsfh
modifier|*
name|nfhp
decl_stmt|;
name|mount_t
name|mp
decl_stmt|;
name|nfsattrbit_t
name|attrbits
decl_stmt|,
name|rattrbits
decl_stmt|;
name|nfsv4stateid_t
name|stateid
decl_stmt|;
name|nfsrvd_rephead
argument_list|(
name|nd
argument_list|)
expr_stmt|;
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|taglen
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
name|taglen
operator|<
literal|0
condition|)
block|{
name|error
operator|=
name|EBADRPC
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
if|if
condition|(
name|taglen
operator|<=
name|NFSV4_SMALLSTR
condition|)
name|tagstr
operator|=
name|tag
expr_stmt|;
else|else
name|tagstr
operator|=
name|malloc
argument_list|(
name|taglen
operator|+
literal|1
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfsrv_mtostr
argument_list|(
name|nd
argument_list|,
name|tagstr
argument_list|,
name|taglen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|taglen
operator|>
name|NFSV4_SMALLSTR
condition|)
name|free
argument_list|(
name|tagstr
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|taglen
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
operator|(
name|void
operator|)
name|nfsm_strtom
argument_list|(
name|nd
argument_list|,
name|tag
argument_list|,
name|taglen
argument_list|)
expr_stmt|;
if|if
condition|(
name|taglen
operator|>
name|NFSV4_SMALLSTR
condition|)
block|{
name|free
argument_list|(
name|tagstr
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
name|NFSM_BUILD
argument_list|(
name|retopsp
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|3
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|minorvers
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|minorvers
operator|!=
name|NFSV4_MINORVERSION
condition|)
name|nd
operator|->
name|nd_repstat
operator|=
name|NFSERR_MINORVERMISMATCH
expr_stmt|;
name|cbident
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_repstat
condition|)
name|numops
operator|=
literal|0
expr_stmt|;
else|else
name|numops
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
comment|/* 	 * Loop around doing the sub ops. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numops
condition|;
name|i
operator|++
control|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|repp
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|repp
operator|++
operator|=
operator|*
name|tl
expr_stmt|;
name|op
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|<
name|NFSV4OP_CBGETATTR
operator|||
name|op
operator|>
name|NFSV4OP_CBRECALL
condition|)
block|{
name|nd
operator|->
name|nd_repstat
operator|=
name|NFSERR_OPILLEGAL
expr_stmt|;
operator|*
name|repp
operator|=
name|nfscl_errmap
argument_list|(
name|nd
argument_list|)
expr_stmt|;
name|retops
operator|++
expr_stmt|;
break|break;
block|}
name|nd
operator|->
name|nd_procnum
operator|=
name|op
expr_stmt|;
name|newnfsstats
operator|.
name|cbrpccnt
index|[
name|nd
operator|->
name|nd_procnum
index|]
operator|++
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|NFSV4OP_CBGETATTR
case|:
name|clp
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|nfsm_getfh
argument_list|(
name|nd
argument_list|,
operator|&
name|nfhp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|nfsrv_getattrbits
argument_list|(
name|nd
argument_list|,
operator|&
name|attrbits
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|mp
operator|=
name|nfscl_getmnt
argument_list|(
name|cbident
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|==
name|NULL
condition|)
name|error
operator|=
name|NFSERR_SERVERFAULT
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|dp
operator|=
name|NULL
expr_stmt|;
name|NFSLOCKCLSTATE
argument_list|()
expr_stmt|;
name|clp
operator|=
name|nfscl_findcl
argument_list|(
name|VFSTONFS
argument_list|(
name|mp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|clp
operator|!=
name|NULL
condition|)
name|dp
operator|=
name|nfscl_finddeleg
argument_list|(
name|clp
argument_list|,
name|nfhp
operator|->
name|nfh_fh
argument_list|,
name|nfhp
operator|->
name|nfh_len
argument_list|)
expr_stmt|;
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
if|if
condition|(
name|dp
operator|==
name|NULL
condition|)
name|error
operator|=
name|NFSERR_SERVERFAULT
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|ret
operator|=
name|nfscl_ngetreopen
argument_list|(
name|mp
argument_list|,
name|nfhp
operator|->
name|nfh_fh
argument_list|,
name|nfhp
operator|->
name|nfh_len
argument_list|,
name|p
argument_list|,
operator|&
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
name|vp
operator|=
name|NFSTOV
argument_list|(
name|np
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nfhp
operator|!=
name|NULL
condition|)
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|nfhp
argument_list|,
name|M_NFSFH
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|NFSZERO_ATTRBIT
argument_list|(
operator|&
name|rattrbits
argument_list|)
expr_stmt|;
if|if
condition|(
name|NFSISSET_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|,
name|NFSATTRBIT_SIZE
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ret
condition|)
name|va
operator|.
name|va_size
operator|=
name|np
operator|->
name|n_size
expr_stmt|;
else|else
name|va
operator|.
name|va_size
operator|=
name|dp
operator|->
name|nfsdl_size
expr_stmt|;
name|NFSSETBIT_ATTRBIT
argument_list|(
operator|&
name|rattrbits
argument_list|,
name|NFSATTRBIT_SIZE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|NFSISSET_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|,
name|NFSATTRBIT_CHANGE
argument_list|)
condition|)
block|{
name|va
operator|.
name|va_filerev
operator|=
name|dp
operator|->
name|nfsdl_change
expr_stmt|;
if|if
condition|(
name|ret
operator|||
operator|(
name|np
operator|->
name|n_flag
operator|&
name|NDELEGMOD
operator|)
condition|)
name|va
operator|.
name|va_filerev
operator|++
expr_stmt|;
name|NFSSETBIT_ATTRBIT
argument_list|(
operator|&
name|rattrbits
argument_list|,
name|NFSATTRBIT_CHANGE
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|nfsv4_fillattr
argument_list|(
name|nd
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|va
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|rattrbits
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|uint64_t
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
name|vrele
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|NFSV4OP_CBRECALL
case|:
name|clp
operator|=
name|NULL
expr_stmt|;
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_STATEID
operator|+
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|stateid
operator|.
name|seqid
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|NFSBCOPY
argument_list|(
operator|(
name|caddr_t
operator|)
name|tl
argument_list|,
operator|(
name|caddr_t
operator|)
name|stateid
operator|.
name|other
argument_list|,
name|NFSX_STATEIDOTHER
argument_list|)
expr_stmt|;
name|tl
operator|+=
operator|(
name|NFSX_STATEIDOTHER
operator|/
name|NFSX_UNSIGNED
operator|)
expr_stmt|;
name|trunc
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfsm_getfh
argument_list|(
name|nd
argument_list|,
operator|&
name|nfhp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|mp
operator|=
name|nfscl_getmnt
argument_list|(
name|cbident
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|==
name|NULL
condition|)
name|error
operator|=
name|NFSERR_SERVERFAULT
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|NFSLOCKCLSTATE
argument_list|()
expr_stmt|;
name|clp
operator|=
name|nfscl_findcl
argument_list|(
name|VFSTONFS
argument_list|(
name|mp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|clp
operator|!=
name|NULL
condition|)
block|{
name|dp
operator|=
name|nfscl_finddeleg
argument_list|(
name|clp
argument_list|,
name|nfhp
operator|->
name|nfh_fh
argument_list|,
name|nfhp
operator|->
name|nfh_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|!=
name|NULL
operator|&&
operator|(
name|dp
operator|->
name|nfsdl_flags
operator|&
name|NFSCLDL_DELEGRET
operator|)
operator|==
literal|0
condition|)
block|{
name|dp
operator|->
name|nfsdl_flags
operator||=
name|NFSCLDL_RECALL
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|clp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|error
operator|=
name|NFSERR_SERVERFAULT
expr_stmt|;
block|}
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|nfhp
operator|!=
name|NULL
condition|)
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|nfhp
argument_list|,
name|M_NFSFH
argument_list|)
expr_stmt|;
break|break;
block|}
empty_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|EBADRPC
operator|||
name|error
operator|==
name|NFSERR_BADXDR
condition|)
block|{
name|nd
operator|->
name|nd_repstat
operator|=
name|NFSERR_BADXDR
expr_stmt|;
block|}
else|else
block|{
name|nd
operator|->
name|nd_repstat
operator|=
name|error
expr_stmt|;
block|}
name|error
operator|=
literal|0
expr_stmt|;
block|}
name|retops
operator|++
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_repstat
condition|)
block|{
operator|*
name|repp
operator|=
name|nfscl_errmap
argument_list|(
name|nd
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
operator|*
name|repp
operator|=
literal|0
expr_stmt|;
comment|/* NFS4_OK */
block|}
name|nfsmout
label|:
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|EBADRPC
operator|||
name|error
operator|==
name|NFSERR_BADXDR
condition|)
name|nd
operator|->
name|nd_repstat
operator|=
name|NFSERR_BADXDR
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"nfsv4 comperr1=%d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|taglen
operator|==
operator|-
literal|1
condition|)
block|{
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|tl
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|*
name|retopsp
operator|=
name|txdr_unsigned
argument_list|(
name|retops
argument_list|)
expr_stmt|;
block|}
operator|*
name|nd
operator|->
name|nd_errp
operator|=
name|nfscl_errmap
argument_list|(
name|nd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Generate the next cbident value. Basically just increment a static value  * and then check that it isn't already in the list, if it has wrapped around.  */
end_comment

begin_function
specifier|static
name|u_int32_t
name|nfscl_nextcbident
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|nfsclclient
modifier|*
name|clp
decl_stmt|;
name|int
name|matched
decl_stmt|;
specifier|static
name|u_int32_t
name|nextcbident
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|haswrapped
init|=
literal|0
decl_stmt|;
name|nextcbident
operator|++
expr_stmt|;
if|if
condition|(
name|nextcbident
operator|==
literal|0
condition|)
name|haswrapped
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|haswrapped
condition|)
block|{
comment|/* 		 * Search the clientid list for one already using this cbident. 		 */
do|do
block|{
name|matched
operator|=
literal|0
expr_stmt|;
name|NFSLOCKCLSTATE
argument_list|()
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|clp
argument_list|,
argument|&nfsclhead
argument_list|,
argument|nfsc_list
argument_list|)
block|{
if|if
condition|(
name|clp
operator|->
name|nfsc_cbident
operator|==
name|nextcbident
condition|)
block|{
name|matched
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
if|if
condition|(
name|matched
operator|==
literal|1
condition|)
name|nextcbident
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|matched
condition|)
do|;
block|}
return|return
operator|(
name|nextcbident
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get the mount point related to a given cbident.  */
end_comment

begin_function
specifier|static
name|mount_t
name|nfscl_getmnt
parameter_list|(
name|u_int32_t
name|cbident
parameter_list|)
block|{
name|struct
name|nfsclclient
modifier|*
name|clp
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
decl_stmt|;
name|NFSLOCKCLSTATE
argument_list|()
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|clp
argument_list|,
argument|&nfsclhead
argument_list|,
argument|nfsc_list
argument_list|)
block|{
if|if
condition|(
name|clp
operator|->
name|nfsc_cbident
operator|==
name|cbident
condition|)
break|break;
block|}
if|if
condition|(
name|clp
operator|==
name|NULL
condition|)
block|{
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|nmp
operator|=
name|clp
operator|->
name|nfsc_nmp
expr_stmt|;
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
return|return
operator|(
name|nmp
operator|->
name|nm_mountp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Search for a lock conflict locally on the client. A conflict occurs if  * - not same owner and overlapping byte range and at least one of them is  *   a write lock or this is an unlock.  */
end_comment

begin_function
specifier|static
name|int
name|nfscl_localconflict
parameter_list|(
name|struct
name|nfsclclient
modifier|*
name|clp
parameter_list|,
name|u_int8_t
modifier|*
name|fhp
parameter_list|,
name|int
name|fhlen
parameter_list|,
name|struct
name|nfscllock
modifier|*
name|nlop
parameter_list|,
name|u_int8_t
modifier|*
name|own
parameter_list|,
name|struct
name|nfscldeleg
modifier|*
name|dp
parameter_list|,
name|struct
name|nfscllock
modifier|*
modifier|*
name|lopp
parameter_list|)
block|{
name|struct
name|nfsclowner
modifier|*
name|owp
decl_stmt|;
name|struct
name|nfsclopen
modifier|*
name|op
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|dp
operator|!=
name|NULL
condition|)
block|{
name|ret
operator|=
name|nfscl_checkconflict
argument_list|(
operator|&
name|dp
operator|->
name|nfsdl_lock
argument_list|,
name|nlop
argument_list|,
name|own
argument_list|,
name|lopp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
operator|(
name|ret
operator|)
return|;
block|}
name|LIST_FOREACH
argument_list|(
argument|owp
argument_list|,
argument|&clp->nfsc_owner
argument_list|,
argument|nfsow_list
argument_list|)
block|{
name|LIST_FOREACH
argument_list|(
argument|op
argument_list|,
argument|&owp->nfsow_open
argument_list|,
argument|nfso_list
argument_list|)
block|{
if|if
condition|(
name|op
operator|->
name|nfso_fhlen
operator|==
name|fhlen
operator|&&
operator|!
name|NFSBCMP
argument_list|(
name|op
operator|->
name|nfso_fh
argument_list|,
name|fhp
argument_list|,
name|fhlen
argument_list|)
condition|)
block|{
name|ret
operator|=
name|nfscl_checkconflict
argument_list|(
operator|&
name|op
operator|->
name|nfso_lock
argument_list|,
name|nlop
argument_list|,
name|own
argument_list|,
name|lopp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
operator|(
name|ret
operator|)
return|;
block|}
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nfscl_checkconflict
parameter_list|(
name|struct
name|nfscllockownerhead
modifier|*
name|lhp
parameter_list|,
name|struct
name|nfscllock
modifier|*
name|nlop
parameter_list|,
name|u_int8_t
modifier|*
name|own
parameter_list|,
name|struct
name|nfscllock
modifier|*
modifier|*
name|lopp
parameter_list|)
block|{
name|struct
name|nfscllockowner
modifier|*
name|lp
decl_stmt|;
name|struct
name|nfscllock
modifier|*
name|lop
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|lp
argument_list|,
argument|lhp
argument_list|,
argument|nfsl_list
argument_list|)
block|{
if|if
condition|(
name|NFSBCMP
argument_list|(
name|lp
operator|->
name|nfsl_owner
argument_list|,
name|own
argument_list|,
name|NFSV4CL_LOCKNAMELEN
argument_list|)
condition|)
block|{
name|LIST_FOREACH
argument_list|(
argument|lop
argument_list|,
argument|&lp->nfsl_lock
argument_list|,
argument|nfslo_list
argument_list|)
block|{
if|if
condition|(
name|lop
operator|->
name|nfslo_first
operator|>=
name|nlop
operator|->
name|nfslo_end
condition|)
break|break;
if|if
condition|(
name|lop
operator|->
name|nfslo_end
operator|<=
name|nlop
operator|->
name|nfslo_first
condition|)
continue|continue;
if|if
condition|(
name|lop
operator|->
name|nfslo_type
operator|==
name|F_WRLCK
operator|||
name|nlop
operator|->
name|nfslo_type
operator|==
name|F_WRLCK
operator|||
name|nlop
operator|->
name|nfslo_type
operator|==
name|F_UNLCK
condition|)
block|{
if|if
condition|(
name|lopp
operator|!=
name|NULL
condition|)
operator|*
name|lopp
operator|=
name|lop
expr_stmt|;
return|return
operator|(
name|NFSERR_DENIED
operator|)
return|;
block|}
block|}
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check for a local conflicting lock.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfscl_lockt
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|struct
name|nfsclclient
modifier|*
name|clp
parameter_list|,
name|u_int64_t
name|off
parameter_list|,
name|u_int64_t
name|len
parameter_list|,
name|struct
name|flock
modifier|*
name|fl
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|nfscllock
modifier|*
name|lop
decl_stmt|,
name|nlck
decl_stmt|;
name|struct
name|nfscldeleg
modifier|*
name|dp
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|np
decl_stmt|;
name|u_int8_t
name|own
index|[
name|NFSV4CL_LOCKNAMELEN
index|]
decl_stmt|;
name|int
name|error
decl_stmt|;
name|nlck
operator|.
name|nfslo_type
operator|=
name|fl
operator|->
name|l_type
expr_stmt|;
name|nlck
operator|.
name|nfslo_first
operator|=
name|off
expr_stmt|;
if|if
condition|(
name|len
operator|==
name|NFS64BITSSET
condition|)
block|{
name|nlck
operator|.
name|nfslo_end
operator|=
name|NFS64BITSSET
expr_stmt|;
block|}
else|else
block|{
name|nlck
operator|.
name|nfslo_end
operator|=
name|off
operator|+
name|len
expr_stmt|;
if|if
condition|(
name|nlck
operator|.
name|nfslo_end
operator|<=
name|nlck
operator|.
name|nfslo_first
condition|)
return|return
operator|(
name|NFSERR_INVAL
operator|)
return|;
block|}
name|np
operator|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|nfscl_filllockowner
argument_list|(
name|p
argument_list|,
name|own
argument_list|)
expr_stmt|;
name|NFSLOCKCLSTATE
argument_list|()
expr_stmt|;
name|dp
operator|=
name|nfscl_finddeleg
argument_list|(
name|clp
argument_list|,
name|np
operator|->
name|n_fhp
operator|->
name|nfh_fh
argument_list|,
name|np
operator|->
name|n_fhp
operator|->
name|nfh_len
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfscl_localconflict
argument_list|(
name|clp
argument_list|,
name|np
operator|->
name|n_fhp
operator|->
name|nfh_fh
argument_list|,
name|np
operator|->
name|n_fhp
operator|->
name|nfh_len
argument_list|,
operator|&
name|nlck
argument_list|,
name|own
argument_list|,
name|dp
argument_list|,
operator|&
name|lop
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|fl
operator|->
name|l_whence
operator|=
name|SEEK_SET
expr_stmt|;
name|fl
operator|->
name|l_start
operator|=
name|lop
operator|->
name|nfslo_first
expr_stmt|;
if|if
condition|(
name|lop
operator|->
name|nfslo_end
operator|==
name|NFS64BITSSET
condition|)
name|fl
operator|->
name|l_len
operator|=
literal|0
expr_stmt|;
else|else
name|fl
operator|->
name|l_len
operator|=
name|lop
operator|->
name|nfslo_end
operator|-
name|lop
operator|->
name|nfslo_first
expr_stmt|;
name|fl
operator|->
name|l_pid
operator|=
operator|(
name|pid_t
operator|)
literal|0
expr_stmt|;
name|fl
operator|->
name|l_type
operator|=
name|lop
operator|->
name|nfslo_type
expr_stmt|;
name|error
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* no RPC required */
block|}
elseif|else
if|if
condition|(
name|dp
operator|!=
name|NULL
operator|&&
operator|(
operator|(
name|dp
operator|->
name|nfsdl_flags
operator|&
name|NFSCLDL_WRITE
operator|)
operator|||
name|fl
operator|->
name|l_type
operator|==
name|F_RDLCK
operator|)
condition|)
block|{
comment|/* 		 * The delegation ensures that there isn't a conflicting 		 * lock on the server, so return -1 to indicate an RPC 		 * isn't required. 		 */
name|fl
operator|->
name|l_type
operator|=
name|F_UNLCK
expr_stmt|;
name|error
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handle Recall of a delegation.  * The clp must be exclusive locked when this is called.  */
end_comment

begin_function
specifier|static
name|int
name|nfscl_recalldeleg
parameter_list|(
name|struct
name|nfsclclient
modifier|*
name|clp
parameter_list|,
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|,
name|struct
name|nfscldeleg
modifier|*
name|dp
parameter_list|,
name|vnode_t
name|vp
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|int
name|called_from_renewthread
parameter_list|)
block|{
name|struct
name|nfsclowner
modifier|*
name|owp
decl_stmt|,
modifier|*
name|lowp
decl_stmt|,
modifier|*
name|nowp
decl_stmt|;
name|struct
name|nfsclopen
modifier|*
name|op
decl_stmt|,
modifier|*
name|lop
decl_stmt|;
name|struct
name|nfscllockowner
modifier|*
name|lp
decl_stmt|;
name|struct
name|nfscllock
modifier|*
name|lckp
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|np
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|ret
decl_stmt|,
name|gotvp
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|vp
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * First, get a vnode for the file. This is needed to do RPCs. 		 */
name|ret
operator|=
name|nfscl_ngetreopen
argument_list|(
name|nmp
operator|->
name|nm_mountp
argument_list|,
name|dp
operator|->
name|nfsdl_fh
argument_list|,
name|dp
operator|->
name|nfsdl_fhlen
argument_list|,
name|p
argument_list|,
operator|&
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
comment|/* 			 * File isn't open, so nothing to move over to the 			 * server. 			 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|vp
operator|=
name|NFSTOV
argument_list|(
name|np
argument_list|)
expr_stmt|;
name|gotvp
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|np
operator|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
name|dp
operator|->
name|nfsdl_flags
operator|&=
operator|~
name|NFSCLDL_MODTIMESET
expr_stmt|;
comment|/* 	 * Ok, if it's a write delegation, flush data to the server, so 	 * that close/open consistency is retained. 	 */
name|ret
operator|=
literal|0
expr_stmt|;
name|NFSLOCKNODE
argument_list|(
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dp
operator|->
name|nfsdl_flags
operator|&
name|NFSCLDL_WRITE
operator|)
operator|&&
operator|(
name|np
operator|->
name|n_flag
operator|&
name|NMODIFIED
operator|)
condition|)
block|{
name|np
operator|->
name|n_flag
operator||=
name|NDELEGRECALL
expr_stmt|;
name|NFSUNLOCKNODE
argument_list|(
name|np
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ncl_flush
argument_list|(
name|vp
argument_list|,
name|MNT_WAIT
argument_list|,
name|cred
argument_list|,
name|p
argument_list|,
literal|1
argument_list|,
name|called_from_renewthread
argument_list|)
expr_stmt|;
name|NFSLOCKNODE
argument_list|(
name|np
argument_list|)
expr_stmt|;
name|np
operator|->
name|n_flag
operator|&=
operator|~
name|NDELEGRECALL
expr_stmt|;
block|}
name|NFSINVALATTRCACHE
argument_list|(
name|np
argument_list|)
expr_stmt|;
name|NFSUNLOCKNODE
argument_list|(
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|EIO
operator|&&
name|called_from_renewthread
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * If the flush failed with EIO for the renew thread, 		 * return now, so that the dirty buffer will be flushed 		 * later. 		 */
if|if
condition|(
name|gotvp
operator|!=
literal|0
condition|)
name|vrele
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
comment|/* 	 * Now, for each openowner with opens issued locally, move them 	 * over to state against the server. 	 */
name|LIST_FOREACH
argument_list|(
argument|lowp
argument_list|,
argument|&dp->nfsdl_owner
argument_list|,
argument|nfsow_list
argument_list|)
block|{
name|lop
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|lowp
operator|->
name|nfsow_open
argument_list|)
expr_stmt|;
if|if
condition|(
name|lop
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|LIST_NEXT
argument_list|(
name|lop
argument_list|,
name|nfso_list
argument_list|)
operator|!=
name|NULL
condition|)
name|panic
argument_list|(
literal|"nfsdlg mult opens"
argument_list|)
expr_stmt|;
comment|/* 			 * Look for the same openowner against the server. 			 */
name|LIST_FOREACH
argument_list|(
argument|owp
argument_list|,
argument|&clp->nfsc_owner
argument_list|,
argument|nfsow_list
argument_list|)
block|{
if|if
condition|(
operator|!
name|NFSBCMP
argument_list|(
name|lowp
operator|->
name|nfsow_owner
argument_list|,
name|owp
operator|->
name|nfsow_owner
argument_list|,
name|NFSV4CL_LOCKNAMELEN
argument_list|)
condition|)
block|{
name|newnfs_copycred
argument_list|(
operator|&
name|dp
operator|->
name|nfsdl_cred
argument_list|,
name|cred
argument_list|)
expr_stmt|;
name|ret
operator|=
name|nfscl_moveopen
argument_list|(
name|vp
argument_list|,
name|clp
argument_list|,
name|nmp
argument_list|,
name|lop
argument_list|,
name|owp
argument_list|,
name|dp
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NFSERR_STALECLIENTID
operator|||
name|ret
operator|==
name|NFSERR_STALEDONTRECOVER
condition|)
block|{
if|if
condition|(
name|gotvp
condition|)
name|vrele
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
if|if
condition|(
name|ret
condition|)
block|{
name|nfscl_freeopen
argument_list|(
name|lop
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|ret
expr_stmt|;
block|}
break|break;
block|}
block|}
comment|/* 			 * If no openowner found, create one and get an open 			 * for it. 			 */
if|if
condition|(
name|owp
operator|==
name|NULL
condition|)
block|{
name|MALLOC
argument_list|(
name|nowp
argument_list|,
expr|struct
name|nfsclowner
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nfsclowner
argument_list|)
argument_list|,
name|M_NFSCLOWNER
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|nfscl_newopen
argument_list|(
name|clp
argument_list|,
name|NULL
argument_list|,
operator|&
name|owp
argument_list|,
operator|&
name|nowp
argument_list|,
operator|&
name|op
argument_list|,
name|NULL
argument_list|,
name|lowp
operator|->
name|nfsow_owner
argument_list|,
name|dp
operator|->
name|nfsdl_fh
argument_list|,
name|dp
operator|->
name|nfsdl_fhlen
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|newnfs_copycred
argument_list|(
operator|&
name|dp
operator|->
name|nfsdl_cred
argument_list|,
name|cred
argument_list|)
expr_stmt|;
name|ret
operator|=
name|nfscl_moveopen
argument_list|(
name|vp
argument_list|,
name|clp
argument_list|,
name|nmp
argument_list|,
name|lop
argument_list|,
name|owp
argument_list|,
name|dp
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|nfscl_freeopenowner
argument_list|(
name|owp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NFSERR_STALECLIENTID
operator|||
name|ret
operator|==
name|NFSERR_STALEDONTRECOVER
condition|)
block|{
if|if
condition|(
name|gotvp
condition|)
name|vrele
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
if|if
condition|(
name|ret
condition|)
block|{
name|nfscl_freeopen
argument_list|(
name|lop
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|ret
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/* 	 * Now, get byte range locks for any locks done locally. 	 */
name|LIST_FOREACH
argument_list|(
argument|lp
argument_list|,
argument|&dp->nfsdl_lock
argument_list|,
argument|nfsl_list
argument_list|)
block|{
name|LIST_FOREACH
argument_list|(
argument|lckp
argument_list|,
argument|&lp->nfsl_lock
argument_list|,
argument|nfslo_list
argument_list|)
block|{
name|newnfs_copycred
argument_list|(
operator|&
name|dp
operator|->
name|nfsdl_cred
argument_list|,
name|cred
argument_list|)
expr_stmt|;
name|ret
operator|=
name|nfscl_relock
argument_list|(
name|vp
argument_list|,
name|clp
argument_list|,
name|nmp
argument_list|,
name|lp
argument_list|,
name|lckp
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NFSERR_STALESTATEID
operator|||
name|ret
operator|==
name|NFSERR_STALEDONTRECOVER
operator|||
name|ret
operator|==
name|NFSERR_STALECLIENTID
condition|)
block|{
if|if
condition|(
name|gotvp
condition|)
name|vrele
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
if|if
condition|(
name|ret
operator|&&
operator|!
name|error
condition|)
name|error
operator|=
name|ret
expr_stmt|;
block|}
block|}
if|if
condition|(
name|gotvp
condition|)
name|vrele
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Move a locally issued open over to an owner on the state list.  * SIDE EFFECT: If it needs to sleep (do an rpc), it unlocks clstate and  * returns with it unlocked.  */
end_comment

begin_function
specifier|static
name|int
name|nfscl_moveopen
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|struct
name|nfsclclient
modifier|*
name|clp
parameter_list|,
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|,
name|struct
name|nfsclopen
modifier|*
name|lop
parameter_list|,
name|struct
name|nfsclowner
modifier|*
name|owp
parameter_list|,
name|struct
name|nfscldeleg
modifier|*
name|dp
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|nfsclopen
modifier|*
name|op
decl_stmt|,
modifier|*
name|nop
decl_stmt|;
name|struct
name|nfscldeleg
modifier|*
name|ndp
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|np
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|newone
decl_stmt|;
comment|/* 	 * First, look for an appropriate open, If found, just increment the 	 * opencnt in it. 	 */
name|LIST_FOREACH
argument_list|(
argument|op
argument_list|,
argument|&owp->nfsow_open
argument_list|,
argument|nfso_list
argument_list|)
block|{
if|if
condition|(
operator|(
name|op
operator|->
name|nfso_mode
operator|&
name|lop
operator|->
name|nfso_mode
operator|)
operator|==
name|lop
operator|->
name|nfso_mode
operator|&&
name|op
operator|->
name|nfso_fhlen
operator|==
name|lop
operator|->
name|nfso_fhlen
operator|&&
operator|!
name|NFSBCMP
argument_list|(
name|op
operator|->
name|nfso_fh
argument_list|,
name|lop
operator|->
name|nfso_fh
argument_list|,
name|op
operator|->
name|nfso_fhlen
argument_list|)
condition|)
block|{
name|op
operator|->
name|nfso_opencnt
operator|+=
name|lop
operator|->
name|nfso_opencnt
expr_stmt|;
name|nfscl_freeopen
argument_list|(
name|lop
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* No appropriate open, so we have to do one against the server. */
name|np
operator|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|MALLOC
argument_list|(
name|nop
argument_list|,
expr|struct
name|nfsclopen
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nfsclopen
argument_list|)
operator|+
name|lop
operator|->
name|nfso_fhlen
operator|-
literal|1
argument_list|,
name|M_NFSCLOPEN
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|newone
operator|=
literal|0
expr_stmt|;
name|nfscl_newopen
argument_list|(
name|clp
argument_list|,
name|NULL
argument_list|,
operator|&
name|owp
argument_list|,
name|NULL
argument_list|,
operator|&
name|op
argument_list|,
operator|&
name|nop
argument_list|,
name|owp
operator|->
name|nfsow_owner
argument_list|,
name|lop
operator|->
name|nfso_fh
argument_list|,
name|lop
operator|->
name|nfso_fhlen
argument_list|,
operator|&
name|newone
argument_list|)
expr_stmt|;
name|ndp
operator|=
name|dp
expr_stmt|;
name|error
operator|=
name|nfscl_tryopen
argument_list|(
name|nmp
argument_list|,
name|vp
argument_list|,
name|np
operator|->
name|n_v4
operator|->
name|n4_data
argument_list|,
name|np
operator|->
name|n_v4
operator|->
name|n4_fhlen
argument_list|,
name|lop
operator|->
name|nfso_fh
argument_list|,
name|lop
operator|->
name|nfso_fhlen
argument_list|,
name|lop
operator|->
name|nfso_mode
argument_list|,
name|op
argument_list|,
name|NFS4NODENAME
argument_list|(
name|np
operator|->
name|n_v4
argument_list|)
argument_list|,
name|np
operator|->
name|n_v4
operator|->
name|n4_namelen
argument_list|,
operator|&
name|ndp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|newone
condition|)
name|nfscl_freeopen
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|newone
condition|)
name|newnfs_copyincred
argument_list|(
name|cred
argument_list|,
operator|&
name|op
operator|->
name|nfso_cred
argument_list|)
expr_stmt|;
name|op
operator|->
name|nfso_mode
operator||=
name|lop
operator|->
name|nfso_mode
expr_stmt|;
name|op
operator|->
name|nfso_opencnt
operator|+=
name|lop
operator|->
name|nfso_opencnt
expr_stmt|;
name|nfscl_freeopen
argument_list|(
name|lop
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nop
operator|!=
name|NULL
condition|)
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|nop
argument_list|,
name|M_NFSCLOPEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|ndp
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * What should I do with the returned delegation, since the 		 * delegation is being recalled? For now, just printf and 		 * through it away. 		 */
name|printf
argument_list|(
literal|"Moveopen returned deleg\n"
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|ndp
argument_list|,
name|M_NFSCLDELEG
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Recall all delegations on this client.  */
end_comment

begin_function
specifier|static
name|void
name|nfscl_totalrecall
parameter_list|(
name|struct
name|nfsclclient
modifier|*
name|clp
parameter_list|)
block|{
name|struct
name|nfscldeleg
modifier|*
name|dp
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|dp
argument_list|,
argument|&clp->nfsc_deleg
argument_list|,
argument|nfsdl_list
argument_list|)
block|{
if|if
condition|(
operator|(
name|dp
operator|->
name|nfsdl_flags
operator|&
name|NFSCLDL_DELEGRET
operator|)
operator|==
literal|0
condition|)
name|dp
operator|->
name|nfsdl_flags
operator||=
name|NFSCLDL_RECALL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Relock byte ranges. Called for delegation recall and state expiry.  */
end_comment

begin_function
specifier|static
name|int
name|nfscl_relock
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|struct
name|nfsclclient
modifier|*
name|clp
parameter_list|,
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|,
name|struct
name|nfscllockowner
modifier|*
name|lp
parameter_list|,
name|struct
name|nfscllock
modifier|*
name|lop
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|nfscllockowner
modifier|*
name|nlp
decl_stmt|;
name|struct
name|nfsfh
modifier|*
name|nfhp
decl_stmt|;
name|u_int64_t
name|off
decl_stmt|,
name|len
decl_stmt|;
name|u_int32_t
name|clidrev
init|=
literal|0
decl_stmt|;
name|int
name|error
decl_stmt|,
name|newone
decl_stmt|,
name|donelocally
decl_stmt|;
name|off
operator|=
name|lop
operator|->
name|nfslo_first
expr_stmt|;
name|len
operator|=
name|lop
operator|->
name|nfslo_end
operator|-
name|lop
operator|->
name|nfslo_first
expr_stmt|;
name|error
operator|=
name|nfscl_getbytelock
argument_list|(
name|vp
argument_list|,
name|off
argument_list|,
name|len
argument_list|,
name|lop
operator|->
name|nfslo_type
argument_list|,
name|cred
argument_list|,
name|p
argument_list|,
name|clp
argument_list|,
literal|1
argument_list|,
name|lp
operator|->
name|nfsl_owner
argument_list|,
name|lp
operator|->
name|nfsl_openowner
argument_list|,
operator|&
name|nlp
argument_list|,
operator|&
name|newone
argument_list|,
operator|&
name|donelocally
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|donelocally
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|nmp
operator|->
name|nm_clp
operator|!=
name|NULL
condition|)
name|clidrev
operator|=
name|nmp
operator|->
name|nm_clp
operator|->
name|nfsc_clientidrev
expr_stmt|;
else|else
name|clidrev
operator|=
literal|0
expr_stmt|;
name|nfhp
operator|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
operator|->
name|n_fhp
expr_stmt|;
name|error
operator|=
name|nfscl_trylock
argument_list|(
name|nmp
argument_list|,
name|vp
argument_list|,
name|nfhp
operator|->
name|nfh_fh
argument_list|,
name|nfhp
operator|->
name|nfh_len
argument_list|,
name|nlp
argument_list|,
name|newone
argument_list|,
literal|0
argument_list|,
name|off
argument_list|,
name|len
argument_list|,
name|lop
operator|->
name|nfslo_type
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|nfscl_freelockowner
argument_list|(
name|nlp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called to re-open a file. Basically get a vnode for the file handle  * and then call nfsrpc_openrpc() to do the rest.  */
end_comment

begin_function
specifier|static
name|int
name|nfsrpc_reopen
parameter_list|(
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|,
name|u_int8_t
modifier|*
name|fhp
parameter_list|,
name|int
name|fhlen
parameter_list|,
name|u_int32_t
name|mode
parameter_list|,
name|struct
name|nfsclopen
modifier|*
name|op
parameter_list|,
name|struct
name|nfscldeleg
modifier|*
modifier|*
name|dpp
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|nfsnode
modifier|*
name|np
decl_stmt|;
name|vnode_t
name|vp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|nfscl_ngetreopen
argument_list|(
name|nmp
operator|->
name|nm_mountp
argument_list|,
name|fhp
argument_list|,
name|fhlen
argument_list|,
name|p
argument_list|,
operator|&
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|vp
operator|=
name|NFSTOV
argument_list|(
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|n_v4
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|nfscl_tryopen
argument_list|(
name|nmp
argument_list|,
name|vp
argument_list|,
name|np
operator|->
name|n_v4
operator|->
name|n4_data
argument_list|,
name|np
operator|->
name|n_v4
operator|->
name|n4_fhlen
argument_list|,
name|fhp
argument_list|,
name|fhlen
argument_list|,
name|mode
argument_list|,
name|op
argument_list|,
name|NFS4NODENAME
argument_list|(
name|np
operator|->
name|n_v4
argument_list|)
argument_list|,
name|np
operator|->
name|n_v4
operator|->
name|n4_namelen
argument_list|,
name|dpp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
name|vrele
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Try an open against the server. Just call nfsrpc_openrpc(), retrying while  * NFSERR_DELAY. Also, try system credentials, if the passed in credentials  * fail.  */
end_comment

begin_function
specifier|static
name|int
name|nfscl_tryopen
parameter_list|(
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|,
name|vnode_t
name|vp
parameter_list|,
name|u_int8_t
modifier|*
name|fhp
parameter_list|,
name|int
name|fhlen
parameter_list|,
name|u_int8_t
modifier|*
name|newfhp
parameter_list|,
name|int
name|newfhlen
parameter_list|,
name|u_int32_t
name|mode
parameter_list|,
name|struct
name|nfsclopen
modifier|*
name|op
parameter_list|,
name|u_int8_t
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|,
name|struct
name|nfscldeleg
modifier|*
modifier|*
name|ndpp
parameter_list|,
name|int
name|reclaim
parameter_list|,
name|u_int32_t
name|delegtype
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
do|do
block|{
name|error
operator|=
name|nfsrpc_openrpc
argument_list|(
name|nmp
argument_list|,
name|vp
argument_list|,
name|fhp
argument_list|,
name|fhlen
argument_list|,
name|newfhp
argument_list|,
name|newfhlen
argument_list|,
name|mode
argument_list|,
name|op
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|,
name|ndpp
argument_list|,
name|reclaim
argument_list|,
name|delegtype
argument_list|,
name|cred
argument_list|,
name|p
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|NFSERR_DELAY
condition|)
operator|(
name|void
operator|)
name|nfs_catnap
argument_list|(
name|PZERO
argument_list|,
name|error
argument_list|,
literal|"nfstryop"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|error
operator|==
name|NFSERR_DELAY
condition|)
do|;
if|if
condition|(
name|error
operator|==
name|EAUTH
operator|||
name|error
operator|==
name|EACCES
condition|)
block|{
comment|/* Try again using system credentials */
name|newnfs_setroot
argument_list|(
name|cred
argument_list|)
expr_stmt|;
do|do
block|{
name|error
operator|=
name|nfsrpc_openrpc
argument_list|(
name|nmp
argument_list|,
name|vp
argument_list|,
name|fhp
argument_list|,
name|fhlen
argument_list|,
name|newfhp
argument_list|,
name|newfhlen
argument_list|,
name|mode
argument_list|,
name|op
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|,
name|ndpp
argument_list|,
name|reclaim
argument_list|,
name|delegtype
argument_list|,
name|cred
argument_list|,
name|p
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|NFSERR_DELAY
condition|)
operator|(
name|void
operator|)
name|nfs_catnap
argument_list|(
name|PZERO
argument_list|,
name|error
argument_list|,
literal|"nfstryop"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|error
operator|==
name|NFSERR_DELAY
condition|)
do|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Try a byte range lock. Just loop on nfsrpc_lock() while it returns  * NFSERR_DELAY. Also, retry with system credentials, if the provided  * cred don't work.  */
end_comment

begin_function
specifier|static
name|int
name|nfscl_trylock
parameter_list|(
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|,
name|vnode_t
name|vp
parameter_list|,
name|u_int8_t
modifier|*
name|fhp
parameter_list|,
name|int
name|fhlen
parameter_list|,
name|struct
name|nfscllockowner
modifier|*
name|nlp
parameter_list|,
name|int
name|newone
parameter_list|,
name|int
name|reclaim
parameter_list|,
name|u_int64_t
name|off
parameter_list|,
name|u_int64_t
name|len
parameter_list|,
name|short
name|type
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|,
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|int
name|error
decl_stmt|;
do|do
block|{
name|error
operator|=
name|nfsrpc_lock
argument_list|(
name|nd
argument_list|,
name|nmp
argument_list|,
name|vp
argument_list|,
name|fhp
argument_list|,
name|fhlen
argument_list|,
name|nlp
argument_list|,
name|newone
argument_list|,
name|reclaim
argument_list|,
name|off
argument_list|,
name|len
argument_list|,
name|type
argument_list|,
name|cred
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
name|nd
operator|->
name|nd_repstat
operator|==
name|NFSERR_DELAY
condition|)
operator|(
name|void
operator|)
name|nfs_catnap
argument_list|(
name|PZERO
argument_list|,
operator|(
name|int
operator|)
name|nd
operator|->
name|nd_repstat
argument_list|,
literal|"nfstrylck"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|error
operator|&&
name|nd
operator|->
name|nd_repstat
operator|==
name|NFSERR_DELAY
condition|)
do|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EAUTH
operator|||
name|error
operator|==
name|EACCES
condition|)
block|{
comment|/* Try again using root credentials */
name|newnfs_setroot
argument_list|(
name|cred
argument_list|)
expr_stmt|;
do|do
block|{
name|error
operator|=
name|nfsrpc_lock
argument_list|(
name|nd
argument_list|,
name|nmp
argument_list|,
name|vp
argument_list|,
name|fhp
argument_list|,
name|fhlen
argument_list|,
name|nlp
argument_list|,
name|newone
argument_list|,
name|reclaim
argument_list|,
name|off
argument_list|,
name|len
argument_list|,
name|type
argument_list|,
name|cred
argument_list|,
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
name|nd
operator|->
name|nd_repstat
operator|==
name|NFSERR_DELAY
condition|)
operator|(
name|void
operator|)
name|nfs_catnap
argument_list|(
name|PZERO
argument_list|,
operator|(
name|int
operator|)
name|nd
operator|->
name|nd_repstat
argument_list|,
literal|"nfstrylck"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|error
operator|&&
name|nd
operator|->
name|nd_repstat
operator|==
name|NFSERR_DELAY
condition|)
do|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Try a delegreturn against the server. Just call nfsrpc_delegreturn(),  * retrying while NFSERR_DELAY. Also, try system credentials, if the passed in  * credentials fail.  */
end_comment

begin_function
specifier|static
name|int
name|nfscl_trydelegreturn
parameter_list|(
name|struct
name|nfscldeleg
modifier|*
name|dp
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
do|do
block|{
name|error
operator|=
name|nfsrpc_delegreturn
argument_list|(
name|dp
argument_list|,
name|cred
argument_list|,
name|nmp
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|NFSERR_DELAY
condition|)
operator|(
name|void
operator|)
name|nfs_catnap
argument_list|(
name|PZERO
argument_list|,
name|error
argument_list|,
literal|"nfstrydp"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|error
operator|==
name|NFSERR_DELAY
condition|)
do|;
if|if
condition|(
name|error
operator|==
name|EAUTH
operator|||
name|error
operator|==
name|EACCES
condition|)
block|{
comment|/* Try again using system credentials */
name|newnfs_setroot
argument_list|(
name|cred
argument_list|)
expr_stmt|;
do|do
block|{
name|error
operator|=
name|nfsrpc_delegreturn
argument_list|(
name|dp
argument_list|,
name|cred
argument_list|,
name|nmp
argument_list|,
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|NFSERR_DELAY
condition|)
operator|(
name|void
operator|)
name|nfs_catnap
argument_list|(
name|PZERO
argument_list|,
name|error
argument_list|,
literal|"nfstrydp"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|error
operator|==
name|NFSERR_DELAY
condition|)
do|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Try a close against the server. Just call nfsrpc_closerpc(),  * retrying while NFSERR_DELAY. Also, try system credentials, if the passed in  * credentials fail.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfscl_tryclose
parameter_list|(
name|struct
name|nfsclopen
modifier|*
name|op
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|,
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|int
name|error
decl_stmt|;
do|do
block|{
name|error
operator|=
name|nfsrpc_closerpc
argument_list|(
name|nd
argument_list|,
name|nmp
argument_list|,
name|op
argument_list|,
name|cred
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|NFSERR_DELAY
condition|)
operator|(
name|void
operator|)
name|nfs_catnap
argument_list|(
name|PZERO
argument_list|,
name|error
argument_list|,
literal|"nfstrycl"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|error
operator|==
name|NFSERR_DELAY
condition|)
do|;
if|if
condition|(
name|error
operator|==
name|EAUTH
operator|||
name|error
operator|==
name|EACCES
condition|)
block|{
comment|/* Try again using system credentials */
name|newnfs_setroot
argument_list|(
name|cred
argument_list|)
expr_stmt|;
do|do
block|{
name|error
operator|=
name|nfsrpc_closerpc
argument_list|(
name|nd
argument_list|,
name|nmp
argument_list|,
name|op
argument_list|,
name|cred
argument_list|,
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|NFSERR_DELAY
condition|)
operator|(
name|void
operator|)
name|nfs_catnap
argument_list|(
name|PZERO
argument_list|,
name|error
argument_list|,
literal|"nfstrycl"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|error
operator|==
name|NFSERR_DELAY
condition|)
do|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Decide if a delegation on a file permits close without flushing writes  * to the server. This might be a big performance win in some environments.  * (Not useful until the client does caching on local stable storage.)  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfscl_mustflush
parameter_list|(
name|vnode_t
name|vp
parameter_list|)
block|{
name|struct
name|nfsclclient
modifier|*
name|clp
decl_stmt|;
name|struct
name|nfscldeleg
modifier|*
name|dp
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|np
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
decl_stmt|;
name|np
operator|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|nmp
operator|=
name|VFSTONFS
argument_list|(
name|vnode_mount
argument_list|(
name|vp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NFSHASNFSV4
argument_list|(
name|nmp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|NFSLOCKCLSTATE
argument_list|()
expr_stmt|;
name|clp
operator|=
name|nfscl_findcl
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|clp
operator|==
name|NULL
condition|)
block|{
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|dp
operator|=
name|nfscl_finddeleg
argument_list|(
name|clp
argument_list|,
name|np
operator|->
name|n_fhp
operator|->
name|nfh_fh
argument_list|,
name|np
operator|->
name|n_fhp
operator|->
name|nfh_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|!=
name|NULL
operator|&&
operator|(
name|dp
operator|->
name|nfsdl_flags
operator|&
operator|(
name|NFSCLDL_WRITE
operator||
name|NFSCLDL_RECALL
operator||
name|NFSCLDL_DELEGRET
operator|)
operator|)
operator|==
name|NFSCLDL_WRITE
operator|&&
operator|(
name|dp
operator|->
name|nfsdl_sizelimit
operator|>=
name|np
operator|->
name|n_size
operator|||
operator|!
name|NFSHASSTRICT3530
argument_list|(
name|nmp
argument_list|)
operator|)
condition|)
block|{
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * See if a (write) delegation exists for this file.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfscl_nodeleg
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|int
name|writedeleg
parameter_list|)
block|{
name|struct
name|nfsclclient
modifier|*
name|clp
decl_stmt|;
name|struct
name|nfscldeleg
modifier|*
name|dp
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|np
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
decl_stmt|;
name|np
operator|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|nmp
operator|=
name|VFSTONFS
argument_list|(
name|vnode_mount
argument_list|(
name|vp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NFSHASNFSV4
argument_list|(
name|nmp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|NFSLOCKCLSTATE
argument_list|()
expr_stmt|;
name|clp
operator|=
name|nfscl_findcl
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|clp
operator|==
name|NULL
condition|)
block|{
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|dp
operator|=
name|nfscl_finddeleg
argument_list|(
name|clp
argument_list|,
name|np
operator|->
name|n_fhp
operator|->
name|nfh_fh
argument_list|,
name|np
operator|->
name|n_fhp
operator|->
name|nfh_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|!=
name|NULL
operator|&&
operator|(
name|dp
operator|->
name|nfsdl_flags
operator|&
operator|(
name|NFSCLDL_RECALL
operator||
name|NFSCLDL_DELEGRET
operator|)
operator|)
operator|==
literal|0
operator|&&
operator|(
name|writedeleg
operator|==
literal|0
operator|||
operator|(
name|dp
operator|->
name|nfsdl_flags
operator|&
name|NFSCLDL_WRITE
operator|)
operator|==
name|NFSCLDL_WRITE
operator|)
condition|)
block|{
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Look for an associated delegation that should be DelegReturned.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfscl_removedeleg
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|nfsv4stateid_t
modifier|*
name|stp
parameter_list|)
block|{
name|struct
name|nfsclclient
modifier|*
name|clp
decl_stmt|;
name|struct
name|nfscldeleg
modifier|*
name|dp
decl_stmt|;
name|struct
name|nfsclowner
modifier|*
name|owp
decl_stmt|;
name|struct
name|nfscllockowner
modifier|*
name|lp
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|np
decl_stmt|;
name|int
name|igotlock
init|=
literal|0
decl_stmt|,
name|triedrecall
init|=
literal|0
decl_stmt|,
name|needsrecall
decl_stmt|,
name|retcnt
init|=
literal|0
decl_stmt|,
name|islept
decl_stmt|;
name|nmp
operator|=
name|VFSTONFS
argument_list|(
name|vnode_mount
argument_list|(
name|vp
argument_list|)
argument_list|)
expr_stmt|;
name|np
operator|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|NFSLOCKCLSTATE
argument_list|()
expr_stmt|;
comment|/* 	 * Loop around waiting for: 	 * - outstanding I/O operations on delegations to complete 	 * - for a delegation on vp that has state, lock the client and 	 *   do a recall 	 * - return delegation with no state 	 */
while|while
condition|(
literal|1
condition|)
block|{
name|clp
operator|=
name|nfscl_findcl
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|clp
operator|==
name|NULL
condition|)
block|{
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
return|return
operator|(
name|retcnt
operator|)
return|;
block|}
name|dp
operator|=
name|nfscl_finddeleg
argument_list|(
name|clp
argument_list|,
name|np
operator|->
name|n_fhp
operator|->
name|nfh_fh
argument_list|,
name|np
operator|->
name|n_fhp
operator|->
name|nfh_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|!=
name|NULL
condition|)
block|{
comment|/* 		     * Wait for outstanding I/O ops to be done. 		     */
if|if
condition|(
name|dp
operator|->
name|nfsdl_rwlock
operator|.
name|nfslock_usecnt
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|igotlock
condition|)
block|{
name|nfsv4_unlock
argument_list|(
operator|&
name|clp
operator|->
name|nfsc_lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|igotlock
operator|=
literal|0
expr_stmt|;
block|}
name|dp
operator|->
name|nfsdl_rwlock
operator|.
name|nfslock_lock
operator||=
name|NFSV4LOCK_WANTED
expr_stmt|;
operator|(
name|void
operator|)
name|nfsmsleep
argument_list|(
operator|&
name|dp
operator|->
name|nfsdl_rwlock
argument_list|,
name|NFSCLSTATEMUTEXPTR
argument_list|,
name|PZERO
argument_list|,
literal|"nfscld"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|needsrecall
operator|=
literal|0
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|owp
argument_list|,
argument|&dp->nfsdl_owner
argument_list|,
argument|nfsow_list
argument_list|)
block|{
if|if
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|owp
operator|->
name|nfsow_open
argument_list|)
condition|)
block|{
name|needsrecall
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|needsrecall
condition|)
block|{
name|LIST_FOREACH
argument_list|(
argument|lp
argument_list|,
argument|&dp->nfsdl_lock
argument_list|,
argument|nfsl_list
argument_list|)
block|{
if|if
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|lp
operator|->
name|nfsl_lock
argument_list|)
condition|)
block|{
name|needsrecall
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|needsrecall
operator|&&
operator|!
name|triedrecall
condition|)
block|{
name|dp
operator|->
name|nfsdl_flags
operator||=
name|NFSCLDL_DELEGRET
expr_stmt|;
name|islept
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|igotlock
condition|)
block|{
name|igotlock
operator|=
name|nfsv4_lock
argument_list|(
operator|&
name|clp
operator|->
name|nfsc_lock
argument_list|,
literal|1
argument_list|,
operator|&
name|islept
argument_list|,
name|NFSCLSTATEMUTEXPTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|islept
condition|)
break|break;
block|}
if|if
condition|(
name|islept
condition|)
continue|continue;
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
name|cred
operator|=
name|newnfs_getcred
argument_list|()
expr_stmt|;
name|newnfs_copycred
argument_list|(
operator|&
name|dp
operator|->
name|nfsdl_cred
argument_list|,
name|cred
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfscl_recalldeleg
argument_list|(
name|clp
argument_list|,
name|nmp
argument_list|,
name|dp
argument_list|,
name|vp
argument_list|,
name|cred
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|NFSFREECRED
argument_list|(
name|cred
argument_list|)
expr_stmt|;
name|triedrecall
operator|=
literal|1
expr_stmt|;
name|NFSLOCKCLSTATE
argument_list|()
expr_stmt|;
name|nfsv4_unlock
argument_list|(
operator|&
name|clp
operator|->
name|nfsc_lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|igotlock
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
operator|*
name|stp
operator|=
name|dp
operator|->
name|nfsdl_stateid
expr_stmt|;
name|retcnt
operator|=
literal|1
expr_stmt|;
name|nfscl_cleandeleg
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|nfscl_freedeleg
argument_list|(
operator|&
name|clp
operator|->
name|nfsc_deleg
argument_list|,
name|dp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|igotlock
condition|)
name|nfsv4_unlock
argument_list|(
operator|&
name|clp
operator|->
name|nfsc_lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
return|return
operator|(
name|retcnt
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Look for associated delegation(s) that should be DelegReturned.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfscl_renamedeleg
parameter_list|(
name|vnode_t
name|fvp
parameter_list|,
name|nfsv4stateid_t
modifier|*
name|fstp
parameter_list|,
name|int
modifier|*
name|gotfdp
parameter_list|,
name|vnode_t
name|tvp
parameter_list|,
name|nfsv4stateid_t
modifier|*
name|tstp
parameter_list|,
name|int
modifier|*
name|gottdp
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|nfsclclient
modifier|*
name|clp
decl_stmt|;
name|struct
name|nfscldeleg
modifier|*
name|dp
decl_stmt|;
name|struct
name|nfsclowner
modifier|*
name|owp
decl_stmt|;
name|struct
name|nfscllockowner
modifier|*
name|lp
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|np
decl_stmt|;
name|int
name|igotlock
init|=
literal|0
decl_stmt|,
name|triedrecall
init|=
literal|0
decl_stmt|,
name|needsrecall
decl_stmt|,
name|retcnt
init|=
literal|0
decl_stmt|,
name|islept
decl_stmt|;
name|nmp
operator|=
name|VFSTONFS
argument_list|(
name|vnode_mount
argument_list|(
name|fvp
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|gotfdp
operator|=
literal|0
expr_stmt|;
operator|*
name|gottdp
operator|=
literal|0
expr_stmt|;
name|NFSLOCKCLSTATE
argument_list|()
expr_stmt|;
comment|/* 	 * Loop around waiting for: 	 * - outstanding I/O operations on delegations to complete 	 * - for a delegation on fvp that has state, lock the client and 	 *   do a recall 	 * - return delegation(s) with no state. 	 */
while|while
condition|(
literal|1
condition|)
block|{
name|clp
operator|=
name|nfscl_findcl
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|clp
operator|==
name|NULL
condition|)
block|{
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
return|return
operator|(
name|retcnt
operator|)
return|;
block|}
name|np
operator|=
name|VTONFS
argument_list|(
name|fvp
argument_list|)
expr_stmt|;
name|dp
operator|=
name|nfscl_finddeleg
argument_list|(
name|clp
argument_list|,
name|np
operator|->
name|n_fhp
operator|->
name|nfh_fh
argument_list|,
name|np
operator|->
name|n_fhp
operator|->
name|nfh_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|!=
name|NULL
operator|&&
operator|*
name|gotfdp
operator|==
literal|0
condition|)
block|{
comment|/* 		     * Wait for outstanding I/O ops to be done. 		     */
if|if
condition|(
name|dp
operator|->
name|nfsdl_rwlock
operator|.
name|nfslock_usecnt
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|igotlock
condition|)
block|{
name|nfsv4_unlock
argument_list|(
operator|&
name|clp
operator|->
name|nfsc_lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|igotlock
operator|=
literal|0
expr_stmt|;
block|}
name|dp
operator|->
name|nfsdl_rwlock
operator|.
name|nfslock_lock
operator||=
name|NFSV4LOCK_WANTED
expr_stmt|;
operator|(
name|void
operator|)
name|nfsmsleep
argument_list|(
operator|&
name|dp
operator|->
name|nfsdl_rwlock
argument_list|,
name|NFSCLSTATEMUTEXPTR
argument_list|,
name|PZERO
argument_list|,
literal|"nfscld"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|needsrecall
operator|=
literal|0
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|owp
argument_list|,
argument|&dp->nfsdl_owner
argument_list|,
argument|nfsow_list
argument_list|)
block|{
if|if
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|owp
operator|->
name|nfsow_open
argument_list|)
condition|)
block|{
name|needsrecall
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|needsrecall
condition|)
block|{
name|LIST_FOREACH
argument_list|(
argument|lp
argument_list|,
argument|&dp->nfsdl_lock
argument_list|,
argument|nfsl_list
argument_list|)
block|{
if|if
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|lp
operator|->
name|nfsl_lock
argument_list|)
condition|)
block|{
name|needsrecall
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|needsrecall
operator|&&
operator|!
name|triedrecall
condition|)
block|{
name|dp
operator|->
name|nfsdl_flags
operator||=
name|NFSCLDL_DELEGRET
expr_stmt|;
name|islept
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|igotlock
condition|)
block|{
name|igotlock
operator|=
name|nfsv4_lock
argument_list|(
operator|&
name|clp
operator|->
name|nfsc_lock
argument_list|,
literal|1
argument_list|,
operator|&
name|islept
argument_list|,
name|NFSCLSTATEMUTEXPTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|islept
condition|)
break|break;
block|}
if|if
condition|(
name|islept
condition|)
continue|continue;
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
name|cred
operator|=
name|newnfs_getcred
argument_list|()
expr_stmt|;
name|newnfs_copycred
argument_list|(
operator|&
name|dp
operator|->
name|nfsdl_cred
argument_list|,
name|cred
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfscl_recalldeleg
argument_list|(
name|clp
argument_list|,
name|nmp
argument_list|,
name|dp
argument_list|,
name|fvp
argument_list|,
name|cred
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|NFSFREECRED
argument_list|(
name|cred
argument_list|)
expr_stmt|;
name|triedrecall
operator|=
literal|1
expr_stmt|;
name|NFSLOCKCLSTATE
argument_list|()
expr_stmt|;
name|nfsv4_unlock
argument_list|(
operator|&
name|clp
operator|->
name|nfsc_lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|igotlock
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
operator|*
name|fstp
operator|=
name|dp
operator|->
name|nfsdl_stateid
expr_stmt|;
name|retcnt
operator|++
expr_stmt|;
operator|*
name|gotfdp
operator|=
literal|1
expr_stmt|;
name|nfscl_cleandeleg
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|nfscl_freedeleg
argument_list|(
operator|&
name|clp
operator|->
name|nfsc_deleg
argument_list|,
name|dp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|igotlock
condition|)
block|{
name|nfsv4_unlock
argument_list|(
operator|&
name|clp
operator|->
name|nfsc_lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|igotlock
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|tvp
operator|!=
name|NULL
condition|)
block|{
name|np
operator|=
name|VTONFS
argument_list|(
name|tvp
argument_list|)
expr_stmt|;
name|dp
operator|=
name|nfscl_finddeleg
argument_list|(
name|clp
argument_list|,
name|np
operator|->
name|n_fhp
operator|->
name|nfh_fh
argument_list|,
name|np
operator|->
name|n_fhp
operator|->
name|nfh_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|!=
name|NULL
operator|&&
operator|*
name|gottdp
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Wait for outstanding I/O ops to be done. 			 */
if|if
condition|(
name|dp
operator|->
name|nfsdl_rwlock
operator|.
name|nfslock_usecnt
operator|>
literal|0
condition|)
block|{
name|dp
operator|->
name|nfsdl_rwlock
operator|.
name|nfslock_lock
operator||=
name|NFSV4LOCK_WANTED
expr_stmt|;
operator|(
name|void
operator|)
name|nfsmsleep
argument_list|(
operator|&
name|dp
operator|->
name|nfsdl_rwlock
argument_list|,
name|NFSCLSTATEMUTEXPTR
argument_list|,
name|PZERO
argument_list|,
literal|"nfscld"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|LIST_FOREACH
argument_list|(
argument|owp
argument_list|,
argument|&dp->nfsdl_owner
argument_list|,
argument|nfsow_list
argument_list|)
block|{
if|if
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|owp
operator|->
name|nfsow_open
argument_list|)
condition|)
block|{
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
return|return
operator|(
name|retcnt
operator|)
return|;
block|}
block|}
name|LIST_FOREACH
argument_list|(
argument|lp
argument_list|,
argument|&dp->nfsdl_lock
argument_list|,
argument|nfsl_list
argument_list|)
block|{
if|if
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|lp
operator|->
name|nfsl_lock
argument_list|)
condition|)
block|{
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
return|return
operator|(
name|retcnt
operator|)
return|;
block|}
block|}
operator|*
name|tstp
operator|=
name|dp
operator|->
name|nfsdl_stateid
expr_stmt|;
name|retcnt
operator|++
expr_stmt|;
operator|*
name|gottdp
operator|=
literal|1
expr_stmt|;
name|nfscl_cleandeleg
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|nfscl_freedeleg
argument_list|(
operator|&
name|clp
operator|->
name|nfsc_deleg
argument_list|,
name|dp
argument_list|)
expr_stmt|;
block|}
block|}
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
return|return
operator|(
name|retcnt
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Get a reference on the clientid associated with the mount point.  * Return 1 if success, 0 otherwise.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfscl_getref
parameter_list|(
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|)
block|{
name|struct
name|nfsclclient
modifier|*
name|clp
decl_stmt|;
name|NFSLOCKCLSTATE
argument_list|()
expr_stmt|;
name|clp
operator|=
name|nfscl_findcl
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|clp
operator|==
name|NULL
condition|)
block|{
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|nfsv4_getref
argument_list|(
operator|&
name|clp
operator|->
name|nfsc_lock
argument_list|,
name|NULL
argument_list|,
name|NFSCLSTATEMUTEXPTR
argument_list|)
expr_stmt|;
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Release a reference on a clientid acquired with the above call.  */
end_comment

begin_function
name|APPLESTATIC
name|void
name|nfscl_relref
parameter_list|(
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|)
block|{
name|struct
name|nfsclclient
modifier|*
name|clp
decl_stmt|;
name|NFSLOCKCLSTATE
argument_list|()
expr_stmt|;
name|clp
operator|=
name|nfscl_findcl
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|clp
operator|==
name|NULL
condition|)
block|{
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
return|return;
block|}
name|nfsv4_relref
argument_list|(
operator|&
name|clp
operator|->
name|nfsc_lock
argument_list|)
expr_stmt|;
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Save the size attribute in the delegation, since the nfsnode  * is going away.  */
end_comment

begin_function
name|APPLESTATIC
name|void
name|nfscl_reclaimnode
parameter_list|(
name|vnode_t
name|vp
parameter_list|)
block|{
name|struct
name|nfsclclient
modifier|*
name|clp
decl_stmt|;
name|struct
name|nfscldeleg
modifier|*
name|dp
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|np
init|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
decl_stmt|;
name|nmp
operator|=
name|VFSTONFS
argument_list|(
name|vnode_mount
argument_list|(
name|vp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NFSHASNFSV4
argument_list|(
name|nmp
argument_list|)
condition|)
return|return;
name|NFSLOCKCLSTATE
argument_list|()
expr_stmt|;
name|clp
operator|=
name|nfscl_findcl
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|clp
operator|==
name|NULL
condition|)
block|{
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
return|return;
block|}
name|dp
operator|=
name|nfscl_finddeleg
argument_list|(
name|clp
argument_list|,
name|np
operator|->
name|n_fhp
operator|->
name|nfh_fh
argument_list|,
name|np
operator|->
name|n_fhp
operator|->
name|nfh_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|!=
name|NULL
operator|&&
operator|(
name|dp
operator|->
name|nfsdl_flags
operator|&
name|NFSCLDL_WRITE
operator|)
condition|)
name|dp
operator|->
name|nfsdl_size
operator|=
name|np
operator|->
name|n_size
expr_stmt|;
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get the saved size attribute in the delegation, since it is a  * newly allocated nfsnode.  */
end_comment

begin_function
name|APPLESTATIC
name|void
name|nfscl_newnode
parameter_list|(
name|vnode_t
name|vp
parameter_list|)
block|{
name|struct
name|nfsclclient
modifier|*
name|clp
decl_stmt|;
name|struct
name|nfscldeleg
modifier|*
name|dp
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|np
init|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
decl_stmt|;
name|nmp
operator|=
name|VFSTONFS
argument_list|(
name|vnode_mount
argument_list|(
name|vp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NFSHASNFSV4
argument_list|(
name|nmp
argument_list|)
condition|)
return|return;
name|NFSLOCKCLSTATE
argument_list|()
expr_stmt|;
name|clp
operator|=
name|nfscl_findcl
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|clp
operator|==
name|NULL
condition|)
block|{
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
return|return;
block|}
name|dp
operator|=
name|nfscl_finddeleg
argument_list|(
name|clp
argument_list|,
name|np
operator|->
name|n_fhp
operator|->
name|nfh_fh
argument_list|,
name|np
operator|->
name|n_fhp
operator|->
name|nfh_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|!=
name|NULL
operator|&&
operator|(
name|dp
operator|->
name|nfsdl_flags
operator|&
name|NFSCLDL_WRITE
operator|)
condition|)
name|np
operator|->
name|n_size
operator|=
name|dp
operator|->
name|nfsdl_size
expr_stmt|;
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * If there is a valid write delegation for this file, set the modtime  * to the local clock time.  */
end_comment

begin_function
name|APPLESTATIC
name|void
name|nfscl_delegmodtime
parameter_list|(
name|vnode_t
name|vp
parameter_list|)
block|{
name|struct
name|nfsclclient
modifier|*
name|clp
decl_stmt|;
name|struct
name|nfscldeleg
modifier|*
name|dp
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|np
init|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
decl_stmt|;
name|nmp
operator|=
name|VFSTONFS
argument_list|(
name|vnode_mount
argument_list|(
name|vp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NFSHASNFSV4
argument_list|(
name|nmp
argument_list|)
condition|)
return|return;
name|NFSLOCKCLSTATE
argument_list|()
expr_stmt|;
name|clp
operator|=
name|nfscl_findcl
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|clp
operator|==
name|NULL
condition|)
block|{
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
return|return;
block|}
name|dp
operator|=
name|nfscl_finddeleg
argument_list|(
name|clp
argument_list|,
name|np
operator|->
name|n_fhp
operator|->
name|nfh_fh
argument_list|,
name|np
operator|->
name|n_fhp
operator|->
name|nfh_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|!=
name|NULL
operator|&&
operator|(
name|dp
operator|->
name|nfsdl_flags
operator|&
name|NFSCLDL_WRITE
operator|)
condition|)
block|{
name|NFSGETNANOTIME
argument_list|(
operator|&
name|dp
operator|->
name|nfsdl_modtime
argument_list|)
expr_stmt|;
name|dp
operator|->
name|nfsdl_flags
operator||=
name|NFSCLDL_MODTIMESET
expr_stmt|;
block|}
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * If there is a valid write delegation for this file with a modtime set,  * put that modtime in mtime.  */
end_comment

begin_function
name|APPLESTATIC
name|void
name|nfscl_deleggetmodtime
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|struct
name|timespec
modifier|*
name|mtime
parameter_list|)
block|{
name|struct
name|nfsclclient
modifier|*
name|clp
decl_stmt|;
name|struct
name|nfscldeleg
modifier|*
name|dp
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|np
init|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
decl_stmt|;
name|nmp
operator|=
name|VFSTONFS
argument_list|(
name|vnode_mount
argument_list|(
name|vp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NFSHASNFSV4
argument_list|(
name|nmp
argument_list|)
condition|)
return|return;
name|NFSLOCKCLSTATE
argument_list|()
expr_stmt|;
name|clp
operator|=
name|nfscl_findcl
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|clp
operator|==
name|NULL
condition|)
block|{
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
return|return;
block|}
name|dp
operator|=
name|nfscl_finddeleg
argument_list|(
name|clp
argument_list|,
name|np
operator|->
name|n_fhp
operator|->
name|nfh_fh
argument_list|,
name|np
operator|->
name|n_fhp
operator|->
name|nfh_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|!=
name|NULL
operator|&&
operator|(
name|dp
operator|->
name|nfsdl_flags
operator|&
operator|(
name|NFSCLDL_WRITE
operator||
name|NFSCLDL_MODTIMESET
operator|)
operator|)
operator|==
operator|(
name|NFSCLDL_WRITE
operator||
name|NFSCLDL_MODTIMESET
operator|)
condition|)
operator|*
name|mtime
operator|=
name|dp
operator|->
name|nfsdl_modtime
expr_stmt|;
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|nfscl_errmap
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|)
block|{
name|short
modifier|*
name|defaulterrp
decl_stmt|,
modifier|*
name|errp
decl_stmt|;
if|if
condition|(
operator|!
name|nd
operator|->
name|nd_repstat
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|nd
operator|->
name|nd_procnum
operator|==
name|NFSPROC_NOOP
condition|)
return|return
operator|(
name|txdr_unsigned
argument_list|(
name|nd
operator|->
name|nd_repstat
operator|&
literal|0xffff
argument_list|)
operator|)
return|;
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|==
name|EBADRPC
condition|)
return|return
operator|(
name|txdr_unsigned
argument_list|(
name|NFSERR_BADXDR
argument_list|)
operator|)
return|;
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|==
name|NFSERR_MINORVERMISMATCH
operator|||
name|nd
operator|->
name|nd_repstat
operator|==
name|NFSERR_OPILLEGAL
condition|)
return|return
operator|(
name|txdr_unsigned
argument_list|(
name|nd
operator|->
name|nd_repstat
argument_list|)
operator|)
return|;
name|errp
operator|=
name|defaulterrp
operator|=
name|nfscl_cberrmap
index|[
name|nd
operator|->
name|nd_procnum
index|]
expr_stmt|;
while|while
condition|(
operator|*
operator|++
name|errp
condition|)
if|if
condition|(
operator|*
name|errp
operator|==
operator|(
name|short
operator|)
name|nd
operator|->
name|nd_repstat
condition|)
return|return
operator|(
name|txdr_unsigned
argument_list|(
name|nd
operator|->
name|nd_repstat
argument_list|)
operator|)
return|;
return|return
operator|(
name|txdr_unsigned
argument_list|(
operator|*
name|defaulterrp
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

