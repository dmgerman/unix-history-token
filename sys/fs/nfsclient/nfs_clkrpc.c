begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1989, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Rick Macklem at The University of Guelph.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_kgssapi.h"
end_include

begin_include
include|#
directive|include
file|<fs/nfs/nfsport.h>
end_include

begin_include
include|#
directive|include
file|<rpc/rpc.h>
end_include

begin_include
include|#
directive|include
file|<rpc/rpcsec_gss.h>
end_include

begin_include
include|#
directive|include
file|<rpc/replay.h>
end_include

begin_expr_stmt
name|NFSDLOCKMUTEX
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|extern
name|SVCPOOL
modifier|*
name|nfscbd_pool
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|nfs_cbproc
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
parameter_list|,
name|u_int32_t
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|u_long
name|sb_max_adj
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|nfs_numnfscbd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|nfscl_debuglevel
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * NFS client system calls for handling callbacks.  */
end_comment

begin_comment
comment|/*  * Handles server to client callbacks.  */
end_comment

begin_function
specifier|static
name|void
name|nfscb_program
parameter_list|(
name|struct
name|svc_req
modifier|*
name|rqst
parameter_list|,
name|SVCXPRT
modifier|*
name|xprt
parameter_list|)
block|{
name|struct
name|nfsrv_descript
name|nd
decl_stmt|;
name|int
name|cacherep
decl_stmt|,
name|credflavor
decl_stmt|;
name|memset
argument_list|(
operator|&
name|nd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|nd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rqst
operator|->
name|rq_proc
operator|!=
name|NFSPROC_NULL
operator|&&
name|rqst
operator|->
name|rq_proc
operator|!=
name|NFSV4PROC_CBCOMPOUND
condition|)
block|{
name|svcerr_noproc
argument_list|(
name|rqst
argument_list|)
expr_stmt|;
name|svc_freereq
argument_list|(
name|rqst
argument_list|)
expr_stmt|;
return|return;
block|}
name|nd
operator|.
name|nd_procnum
operator|=
name|rqst
operator|->
name|rq_proc
expr_stmt|;
name|nd
operator|.
name|nd_flag
operator|=
operator|(
name|ND_NFSCB
operator||
name|ND_NFSV4
operator|)
expr_stmt|;
comment|/* 	 * Note: we want rq_addr, not svc_getrpccaller for nd_nam2 - 	 * NFS_SRVMAXDATA uses a NULL value for nd_nam2 to detect TCP 	 * mounts. 	 */
name|nd
operator|.
name|nd_mrep
operator|=
name|rqst
operator|->
name|rq_args
expr_stmt|;
name|rqst
operator|->
name|rq_args
operator|=
name|NULL
expr_stmt|;
name|newnfs_realign
argument_list|(
operator|&
name|nd
operator|.
name|nd_mrep
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|nd
operator|.
name|nd_md
operator|=
name|nd
operator|.
name|nd_mrep
expr_stmt|;
name|nd
operator|.
name|nd_dpos
operator|=
name|mtod
argument_list|(
name|nd
operator|.
name|nd_md
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
name|nd
operator|.
name|nd_nam
operator|=
name|svc_getrpccaller
argument_list|(
name|rqst
argument_list|)
expr_stmt|;
name|nd
operator|.
name|nd_nam2
operator|=
name|rqst
operator|->
name|rq_addr
expr_stmt|;
name|nd
operator|.
name|nd_mreq
operator|=
name|NULL
expr_stmt|;
name|nd
operator|.
name|nd_cred
operator|=
name|NULL
expr_stmt|;
name|NFSCL_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"cbproc=%d\n"
argument_list|,
name|nd
operator|.
name|nd_procnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|.
name|nd_procnum
operator|!=
name|NFSPROC_NULL
condition|)
block|{
if|if
condition|(
operator|!
name|svc_getcred
argument_list|(
name|rqst
argument_list|,
operator|&
name|nd
operator|.
name|nd_cred
argument_list|,
operator|&
name|credflavor
argument_list|)
condition|)
block|{
name|svcerr_weakauth
argument_list|(
name|rqst
argument_list|)
expr_stmt|;
name|svc_freereq
argument_list|(
name|rqst
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|nd
operator|.
name|nd_mrep
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* For now, I don't care what credential flavor was used. */
ifdef|#
directive|ifdef
name|notyet
ifdef|#
directive|ifdef
name|MAC
name|mac_cred_associate_nfsd
argument_list|(
name|nd
operator|.
name|nd_cred
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|cacherep
operator|=
name|nfs_cbproc
argument_list|(
operator|&
name|nd
argument_list|,
name|rqst
operator|->
name|rq_xid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NFSMGET
argument_list|(
name|nd
operator|.
name|nd_mreq
argument_list|)
expr_stmt|;
name|nd
operator|.
name|nd_mreq
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
name|cacherep
operator|=
name|RC_REPLY
expr_stmt|;
block|}
if|if
condition|(
name|nd
operator|.
name|nd_mrep
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|nd
operator|.
name|nd_mrep
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|.
name|nd_cred
operator|!=
name|NULL
condition|)
name|crfree
argument_list|(
name|nd
operator|.
name|nd_cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|cacherep
operator|==
name|RC_DROPIT
condition|)
block|{
if|if
condition|(
name|nd
operator|.
name|nd_mreq
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|nd
operator|.
name|nd_mreq
argument_list|)
expr_stmt|;
name|svc_freereq
argument_list|(
name|rqst
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|nd
operator|.
name|nd_mreq
operator|==
name|NULL
condition|)
block|{
name|svcerr_decode
argument_list|(
name|rqst
argument_list|)
expr_stmt|;
name|svc_freereq
argument_list|(
name|rqst
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|nd
operator|.
name|nd_repstat
operator|&
name|NFSERR_AUTHERR
condition|)
block|{
name|svcerr_auth
argument_list|(
name|rqst
argument_list|,
name|nd
operator|.
name|nd_repstat
operator|&
operator|~
name|NFSERR_AUTHERR
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|.
name|nd_mreq
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|nd
operator|.
name|nd_mreq
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|svc_sendreply_mbuf
argument_list|(
name|rqst
argument_list|,
name|nd
operator|.
name|nd_mreq
argument_list|)
condition|)
name|svcerr_systemerr
argument_list|(
name|rqst
argument_list|)
expr_stmt|;
else|else
name|NFSCL_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"cbrep sent\n"
argument_list|)
expr_stmt|;
name|svc_freereq
argument_list|(
name|rqst
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Check the cache and, optionally, do the RPC.  * Return the appropriate cache response.  */
end_comment

begin_function
specifier|static
name|int
name|nfs_cbproc
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|,
name|u_int32_t
name|xid
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|int
name|cacherep
decl_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_nam2
operator|==
name|NULL
condition|)
name|nd
operator|->
name|nd_flag
operator||=
name|ND_STREAMSOCK
expr_stmt|;
name|nfscl_docb
argument_list|(
name|nd
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|==
name|NFSERR_DONTREPLY
condition|)
name|cacherep
operator|=
name|RC_DROPIT
expr_stmt|;
else|else
name|cacherep
operator|=
name|RC_REPLY
expr_stmt|;
return|return
operator|(
name|cacherep
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Adds a socket to the list for servicing by nfscbds.  */
end_comment

begin_function
name|int
name|nfscbd_addsock
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|)
block|{
name|int
name|siz
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|int
name|error
decl_stmt|;
name|SVCXPRT
modifier|*
name|xprt
decl_stmt|;
name|so
operator|=
name|fp
operator|->
name|f_data
expr_stmt|;
name|siz
operator|=
name|sb_max_adj
expr_stmt|;
name|error
operator|=
name|soreserve
argument_list|(
name|so
argument_list|,
name|siz
argument_list|,
name|siz
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * Steal the socket from userland so that it doesn't close 	 * unexpectedly. 	 */
if|if
condition|(
name|so
operator|->
name|so_type
operator|==
name|SOCK_DGRAM
condition|)
name|xprt
operator|=
name|svc_dg_create
argument_list|(
name|nfscbd_pool
argument_list|,
name|so
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|xprt
operator|=
name|svc_vc_create
argument_list|(
name|nfscbd_pool
argument_list|,
name|so
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|xprt
condition|)
block|{
name|fp
operator|->
name|f_ops
operator|=
operator|&
name|badfileops
expr_stmt|;
name|fp
operator|->
name|f_data
operator|=
name|NULL
expr_stmt|;
name|svc_reg
argument_list|(
name|xprt
argument_list|,
name|NFS_CALLBCKPROG
argument_list|,
name|NFSV4_CBVERS
argument_list|,
name|nfscb_program
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|SVC_RELEASE
argument_list|(
name|xprt
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called by nfssvc() for nfscbds. Just loops around servicing rpc requests  * until it is killed by a signal.  *  * For now, only support callbacks via RPCSEC_GSS if there is a KerberosV  * keytab entry with a host based entry in it on the client. (I'm not even  * sure that getting Acceptor credentials for a user principal with a  * credentials cache is possible, but even if it is, major changes to the  * kgssapi would be required.)  * I don't believe that this is a serious limitation since, as of 2009, most  * NFSv4 servers supporting callbacks are using AUTH_SYS for callbacks even  * when the client is using RPCSEC_GSS. (This BSD server uses AUTH_SYS  * for callbacks unless nfsrv_gsscallbackson is set non-zero.)  */
end_comment

begin_function
name|int
name|nfscbd_nfsd
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|nfsd_nfscbd_args
modifier|*
name|args
parameter_list|)
block|{
name|char
name|principal
index|[
literal|128
index|]
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|args
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|copyinstr
argument_list|(
name|args
operator|->
name|principal
argument_list|,
name|principal
argument_list|,
sizeof|sizeof
argument_list|(
name|principal
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
else|else
block|{
name|principal
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* 	 * Only the first nfsd actually does any work. The RPC code 	 * adds threads to it as needed. Any extra processes offered 	 * by nfsd just exit. If nfsd is new enough, it will call us 	 * once with a structure that specifies how many threads to 	 * use. 	 */
name|NFSD_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|nfs_numnfscbd
operator|==
literal|0
condition|)
block|{
name|nfs_numnfscbd
operator|++
expr_stmt|;
name|NFSD_UNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|principal
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|rpc_gss_set_svc_name_call
argument_list|(
name|principal
argument_list|,
literal|"kerberosv5"
argument_list|,
name|GSS_C_INDEFINITE
argument_list|,
name|NFS_CALLBCKPROG
argument_list|,
name|NFSV4_CBVERS
argument_list|)
expr_stmt|;
name|nfscbd_pool
operator|->
name|sp_minthreads
operator|=
literal|4
expr_stmt|;
name|nfscbd_pool
operator|->
name|sp_maxthreads
operator|=
literal|4
expr_stmt|;
name|svc_run
argument_list|(
name|nfscbd_pool
argument_list|)
expr_stmt|;
name|rpc_gss_clear_svc_name_call
argument_list|(
name|NFS_CALLBCKPROG
argument_list|,
name|NFSV4_CBVERS
argument_list|)
expr_stmt|;
name|NFSD_LOCK
argument_list|()
expr_stmt|;
name|nfs_numnfscbd
operator|--
expr_stmt|;
name|nfsrvd_cbinit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|NFSD_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize the data structures for the server.  * Handshake with any new nfsds starting up to avoid any chance of  * corruption.  */
end_comment

begin_function
name|void
name|nfsrvd_cbinit
parameter_list|(
name|int
name|terminating
parameter_list|)
block|{
name|NFSD_LOCK_ASSERT
argument_list|()
expr_stmt|;
if|if
condition|(
name|terminating
condition|)
block|{
comment|/* Wait for any xprt registrations to complete. */
while|while
condition|(
name|nfs_numnfscbd
operator|>
literal|0
condition|)
name|msleep
argument_list|(
operator|&
name|nfs_numnfscbd
argument_list|,
name|NFSDLOCKMUTEXPTR
argument_list|,
name|PZERO
argument_list|,
literal|"nfscbdt"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nfscbd_pool
operator|!=
name|NULL
condition|)
block|{
name|NFSD_UNLOCK
argument_list|()
expr_stmt|;
name|svcpool_close
argument_list|(
name|nfscbd_pool
argument_list|)
expr_stmt|;
name|NFSD_LOCK
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nfscbd_pool
operator|==
name|NULL
condition|)
block|{
name|NFSD_UNLOCK
argument_list|()
expr_stmt|;
name|nfscbd_pool
operator|=
name|svcpool_create
argument_list|(
literal|"nfscbd"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|nfscbd_pool
operator|->
name|sp_rcache
operator|=
name|NULL
expr_stmt|;
name|nfscbd_pool
operator|->
name|sp_assign
operator|=
name|NULL
expr_stmt|;
name|nfscbd_pool
operator|->
name|sp_done
operator|=
name|NULL
expr_stmt|;
name|NFSD_LOCK
argument_list|()
expr_stmt|;
block|}
block|}
end_function

end_unit

