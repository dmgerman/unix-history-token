begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1989, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Rick Macklem at The University of Guelph.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|"opt_kdtrace.h"
end_include

begin_include
include|#
directive|include
file|<sys/capsicum.h>
end_include

begin_comment
comment|/*  * generally, I don't like #includes inside .h files, but it seems to  * be the easiest way to handle the port.  */
end_comment

begin_include
include|#
directive|include
file|<sys/hash.h>
end_include

begin_include
include|#
directive|include
file|<fs/nfs/nfsport.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<fs/nfsclient/nfs_kdtrace.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|KDTRACE_HOOKS
end_ifdef

begin_decl_stmt
name|dtrace_nfsclient_attrcache_flush_probe_func_t
name|dtrace_nfscl_attrcache_flush_done_probe
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint32_t
name|nfscl_attrcache_flush_done_id
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|dtrace_nfsclient_attrcache_get_hit_probe_func_t
name|dtrace_nfscl_attrcache_get_hit_probe
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint32_t
name|nfscl_attrcache_get_hit_id
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|dtrace_nfsclient_attrcache_get_miss_probe_func_t
name|dtrace_nfscl_attrcache_get_miss_probe
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint32_t
name|nfscl_attrcache_get_miss_id
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|dtrace_nfsclient_attrcache_load_probe_func_t
name|dtrace_nfscl_attrcache_load_done_probe
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint32_t
name|nfscl_attrcache_load_done_id
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !KDTRACE_HOOKS */
end_comment

begin_decl_stmt
specifier|extern
name|u_int32_t
name|newnfs_true
decl_stmt|,
name|newnfs_false
decl_stmt|,
name|newnfs_xdrneg1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|vop_vector
name|newnfs_vnodeops
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|vop_vector
name|newnfs_fifoops
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|uma_zone_t
name|newnfsnode_zone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|buf_ops
name|buf_ops_newnfs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|ncl_pbuf_freecnt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|short
name|nfsv4_cbport
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|nfscl_enablecallb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|nfs_numnfscbd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|nfscl_inited
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mtx
name|ncl_iod_mutex
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|NFSDLOCKMUTEX
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|extern
name|void
function_decl|(
modifier|*
name|ncl_call_invalcaches
function_decl|)
parameter_list|(
name|struct
name|vnode
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Comparison function for vfs_hash functions.  */
end_comment

begin_function
name|int
name|newnfs_vncmpf
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|nfsfh
modifier|*
name|nfhp
init|=
operator|(
expr|struct
name|nfsfh
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|np
init|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
decl_stmt|;
if|if
condition|(
name|np
operator|->
name|n_fhp
operator|->
name|nfh_len
operator|!=
name|nfhp
operator|->
name|nfh_len
operator|||
name|NFSBCMP
argument_list|(
name|np
operator|->
name|n_fhp
operator|->
name|nfh_fh
argument_list|,
name|nfhp
operator|->
name|nfh_fh
argument_list|,
name|nfhp
operator|->
name|nfh_len
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Look up a vnode/nfsnode by file handle.  * Callers must check for mount points!!  * In all cases, a pointer to a  * nfsnode structure is returned.  * This variant takes a "struct nfsfh *" as second argument and uses  * that structure up, either by hanging off the nfsnode or FREEing it.  */
end_comment

begin_function
name|int
name|nfscl_nget
parameter_list|(
name|struct
name|mount
modifier|*
name|mntp
parameter_list|,
name|struct
name|vnode
modifier|*
name|dvp
parameter_list|,
name|struct
name|nfsfh
modifier|*
name|nfhp
parameter_list|,
name|struct
name|componentname
modifier|*
name|cnp
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|nfsnode
modifier|*
modifier|*
name|npp
parameter_list|,
name|void
modifier|*
name|stuff
parameter_list|,
name|int
name|lkflags
parameter_list|)
block|{
name|struct
name|nfsnode
modifier|*
name|np
decl_stmt|,
modifier|*
name|dnp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|,
modifier|*
name|nvp
decl_stmt|;
name|struct
name|nfsv4node
modifier|*
name|newd
decl_stmt|,
modifier|*
name|oldd
decl_stmt|;
name|int
name|error
decl_stmt|;
name|u_int
name|hash
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
decl_stmt|;
name|nmp
operator|=
name|VFSTONFS
argument_list|(
name|mntp
argument_list|)
expr_stmt|;
name|dnp
operator|=
name|VTONFS
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
operator|*
name|npp
operator|=
name|NULL
expr_stmt|;
name|hash
operator|=
name|fnv_32_buf
argument_list|(
name|nfhp
operator|->
name|nfh_fh
argument_list|,
name|nfhp
operator|->
name|nfh_len
argument_list|,
name|FNV1_32_INIT
argument_list|)
expr_stmt|;
name|error
operator|=
name|vfs_hash_get
argument_list|(
name|mntp
argument_list|,
name|hash
argument_list|,
name|lkflags
argument_list|,
name|td
argument_list|,
operator|&
name|nvp
argument_list|,
name|newnfs_vncmpf
argument_list|,
name|nfhp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|nvp
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * I believe there is a slight chance that vgonel() could 		 * get called on this vnode between when NFSVOPLOCK() drops 		 * the VI_LOCK() and vget() acquires it again, so that it 		 * hasn't yet had v_usecount incremented. If this were to 		 * happen, the VI_DOOMED flag would be set, so check for 		 * that here. Since we now have the v_usecount incremented, 		 * we should be ok until we vrele() it, if the VI_DOOMED 		 * flag isn't set now. 		 */
name|VI_LOCK
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nvp
operator|->
name|v_iflag
operator|&
name|VI_DOOMED
operator|)
condition|)
block|{
name|VI_UNLOCK
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOENT
expr_stmt|;
block|}
else|else
block|{
name|VI_UNLOCK
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error
condition|)
block|{
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|nfhp
argument_list|,
name|M_NFSFH
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|nvp
operator|!=
name|NULL
condition|)
block|{
name|np
operator|=
name|VTONFS
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
comment|/* 		 * For NFSv4, check to see if it is the same name and 		 * replace the name, if it is different. 		 */
name|oldd
operator|=
name|newd
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_NFSV4
operator|)
operator|&&
name|np
operator|->
name|n_v4
operator|!=
name|NULL
operator|&&
name|nvp
operator|->
name|v_type
operator|==
name|VREG
operator|&&
operator|(
name|np
operator|->
name|n_v4
operator|->
name|n4_namelen
operator|!=
name|cnp
operator|->
name|cn_namelen
operator|||
name|NFSBCMP
argument_list|(
name|cnp
operator|->
name|cn_nameptr
argument_list|,
name|NFS4NODENAME
argument_list|(
name|np
operator|->
name|n_v4
argument_list|)
argument_list|,
name|cnp
operator|->
name|cn_namelen
argument_list|)
operator|||
name|dnp
operator|->
name|n_fhp
operator|->
name|nfh_len
operator|!=
name|np
operator|->
name|n_v4
operator|->
name|n4_fhlen
operator|||
name|NFSBCMP
argument_list|(
name|dnp
operator|->
name|n_fhp
operator|->
name|nfh_fh
argument_list|,
name|np
operator|->
name|n_v4
operator|->
name|n4_data
argument_list|,
name|dnp
operator|->
name|n_fhp
operator|->
name|nfh_len
argument_list|)
operator|)
condition|)
block|{
name|MALLOC
argument_list|(
name|newd
argument_list|,
expr|struct
name|nfsv4node
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nfsv4node
argument_list|)
operator|+
name|dnp
operator|->
name|n_fhp
operator|->
name|nfh_len
operator|+
operator|+
name|cnp
operator|->
name|cn_namelen
operator|-
literal|1
argument_list|,
name|M_NFSV4NODE
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|NFSLOCKNODE
argument_list|(
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
name|newd
operator|!=
name|NULL
operator|&&
name|np
operator|->
name|n_v4
operator|!=
name|NULL
operator|&&
name|nvp
operator|->
name|v_type
operator|==
name|VREG
operator|&&
operator|(
name|np
operator|->
name|n_v4
operator|->
name|n4_namelen
operator|!=
name|cnp
operator|->
name|cn_namelen
operator|||
name|NFSBCMP
argument_list|(
name|cnp
operator|->
name|cn_nameptr
argument_list|,
name|NFS4NODENAME
argument_list|(
name|np
operator|->
name|n_v4
argument_list|)
argument_list|,
name|cnp
operator|->
name|cn_namelen
argument_list|)
operator|||
name|dnp
operator|->
name|n_fhp
operator|->
name|nfh_len
operator|!=
name|np
operator|->
name|n_v4
operator|->
name|n4_fhlen
operator|||
name|NFSBCMP
argument_list|(
name|dnp
operator|->
name|n_fhp
operator|->
name|nfh_fh
argument_list|,
name|np
operator|->
name|n_v4
operator|->
name|n4_data
argument_list|,
name|dnp
operator|->
name|n_fhp
operator|->
name|nfh_len
argument_list|)
operator|)
condition|)
block|{
name|oldd
operator|=
name|np
operator|->
name|n_v4
expr_stmt|;
name|np
operator|->
name|n_v4
operator|=
name|newd
expr_stmt|;
name|newd
operator|=
name|NULL
expr_stmt|;
name|np
operator|->
name|n_v4
operator|->
name|n4_fhlen
operator|=
name|dnp
operator|->
name|n_fhp
operator|->
name|nfh_len
expr_stmt|;
name|np
operator|->
name|n_v4
operator|->
name|n4_namelen
operator|=
name|cnp
operator|->
name|cn_namelen
expr_stmt|;
name|NFSBCOPY
argument_list|(
name|dnp
operator|->
name|n_fhp
operator|->
name|nfh_fh
argument_list|,
name|np
operator|->
name|n_v4
operator|->
name|n4_data
argument_list|,
name|dnp
operator|->
name|n_fhp
operator|->
name|nfh_len
argument_list|)
expr_stmt|;
name|NFSBCOPY
argument_list|(
name|cnp
operator|->
name|cn_nameptr
argument_list|,
name|NFS4NODENAME
argument_list|(
name|np
operator|->
name|n_v4
argument_list|)
argument_list|,
name|cnp
operator|->
name|cn_namelen
argument_list|)
expr_stmt|;
block|}
name|NFSUNLOCKNODE
argument_list|(
name|np
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|newd
operator|!=
name|NULL
condition|)
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|newd
argument_list|,
name|M_NFSV4NODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldd
operator|!=
name|NULL
condition|)
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|oldd
argument_list|,
name|M_NFSV4NODE
argument_list|)
expr_stmt|;
operator|*
name|npp
operator|=
name|np
expr_stmt|;
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|nfhp
argument_list|,
name|M_NFSFH
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|np
operator|=
name|uma_zalloc
argument_list|(
name|newnfsnode_zone
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|error
operator|=
name|getnewvnode
argument_list|(
name|nfs_vnode_tag
argument_list|,
name|mntp
argument_list|,
operator|&
name|newnfs_vnodeops
argument_list|,
operator|&
name|nvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|uma_zfree
argument_list|(
name|newnfsnode_zone
argument_list|,
name|np
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|nfhp
argument_list|,
name|M_NFSFH
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|vp
operator|=
name|nvp
expr_stmt|;
name|KASSERT
argument_list|(
name|vp
operator|->
name|v_bufobj
operator|.
name|bo_bsize
operator|!=
literal|0
argument_list|,
operator|(
literal|"nfscl_nget: bo_bsize == 0"
operator|)
argument_list|)
expr_stmt|;
name|vp
operator|->
name|v_bufobj
operator|.
name|bo_ops
operator|=
operator|&
name|buf_ops_newnfs
expr_stmt|;
name|vp
operator|->
name|v_data
operator|=
name|np
expr_stmt|;
name|np
operator|->
name|n_vnode
operator|=
name|vp
expr_stmt|;
comment|/*  	 * Initialize the mutex even if the vnode is going to be a loser. 	 * This simplifies the logic in reclaim, which can then unconditionally 	 * destroy the mutex (in the case of the loser, or if hash_insert 	 * happened to return an error no special casing is needed). 	 */
name|mtx_init
argument_list|(
operator|&
name|np
operator|->
name|n_mtx
argument_list|,
literal|"NEWNFSnode lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
operator||
name|MTX_DUPOK
argument_list|)
expr_stmt|;
comment|/*  	 * Are we getting the root? If so, make sure the vnode flags 	 * are correct  	 */
if|if
condition|(
operator|(
name|nfhp
operator|->
name|nfh_len
operator|==
name|nmp
operator|->
name|nm_fhsize
operator|)
operator|&&
operator|!
name|bcmp
argument_list|(
name|nfhp
operator|->
name|nfh_fh
argument_list|,
name|nmp
operator|->
name|nm_fh
argument_list|,
name|nfhp
operator|->
name|nfh_len
argument_list|)
condition|)
block|{
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VNON
condition|)
name|vp
operator|->
name|v_type
operator|=
name|VDIR
expr_stmt|;
name|vp
operator|->
name|v_vflag
operator||=
name|VV_ROOT
expr_stmt|;
block|}
name|np
operator|->
name|n_fhp
operator|=
name|nfhp
expr_stmt|;
comment|/* 	 * For NFSv4, we have to attach the directory file handle and 	 * file name, so that Open Ops can be done later. 	 */
if|if
condition|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_NFSV4
condition|)
block|{
name|MALLOC
argument_list|(
name|np
operator|->
name|n_v4
argument_list|,
expr|struct
name|nfsv4node
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nfsv4node
argument_list|)
operator|+
name|dnp
operator|->
name|n_fhp
operator|->
name|nfh_len
operator|+
name|cnp
operator|->
name|cn_namelen
operator|-
literal|1
argument_list|,
name|M_NFSV4NODE
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|np
operator|->
name|n_v4
operator|->
name|n4_fhlen
operator|=
name|dnp
operator|->
name|n_fhp
operator|->
name|nfh_len
expr_stmt|;
name|np
operator|->
name|n_v4
operator|->
name|n4_namelen
operator|=
name|cnp
operator|->
name|cn_namelen
expr_stmt|;
name|NFSBCOPY
argument_list|(
name|dnp
operator|->
name|n_fhp
operator|->
name|nfh_fh
argument_list|,
name|np
operator|->
name|n_v4
operator|->
name|n4_data
argument_list|,
name|dnp
operator|->
name|n_fhp
operator|->
name|nfh_len
argument_list|)
expr_stmt|;
name|NFSBCOPY
argument_list|(
name|cnp
operator|->
name|cn_nameptr
argument_list|,
name|NFS4NODENAME
argument_list|(
name|np
operator|->
name|n_v4
argument_list|)
argument_list|,
name|cnp
operator|->
name|cn_namelen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|np
operator|->
name|n_v4
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * NFS supports recursive and shared locking. 	 */
name|lockmgr
argument_list|(
name|vp
operator|->
name|v_vnlock
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_NOWITNESS
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|VN_LOCK_AREC
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|VN_LOCK_ASHARE
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|error
operator|=
name|insmntque
argument_list|(
name|vp
argument_list|,
name|mntp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
operator|*
name|npp
operator|=
name|NULL
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|np
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|nfhp
argument_list|,
name|M_NFSFH
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|n_v4
operator|!=
name|NULL
condition|)
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|np
operator|->
name|n_v4
argument_list|,
name|M_NFSV4NODE
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|newnfsnode_zone
argument_list|,
name|np
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|vfs_hash_insert
argument_list|(
name|vp
argument_list|,
name|hash
argument_list|,
name|lkflags
argument_list|,
name|td
argument_list|,
operator|&
name|nvp
argument_list|,
name|newnfs_vncmpf
argument_list|,
name|nfhp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|nvp
operator|!=
name|NULL
condition|)
block|{
operator|*
name|npp
operator|=
name|VTONFS
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
comment|/* vfs_hash_insert() vput()'s the losing vnode */
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|*
name|npp
operator|=
name|np
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Another variant of nfs_nget(). This one is only used by reopen. It  * takes almost the same args as nfs_nget(), but only succeeds if an entry  * exists in the cache. (Since files should already be "open" with a  * vnode ref cnt on the node when reopen calls this, it should always  * succeed.)  * Also, don't get a vnode lock, since it may already be locked by some  * other process that is handling it. This is ok, since all other threads  * on the client are blocked by the nfsc_lock being exclusively held by the  * caller of this function.  */
end_comment

begin_function
name|int
name|nfscl_ngetreopen
parameter_list|(
name|struct
name|mount
modifier|*
name|mntp
parameter_list|,
name|u_int8_t
modifier|*
name|fhp
parameter_list|,
name|int
name|fhsize
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|nfsnode
modifier|*
modifier|*
name|npp
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|nvp
decl_stmt|;
name|u_int
name|hash
decl_stmt|;
name|struct
name|nfsfh
modifier|*
name|nfhp
decl_stmt|;
name|int
name|error
decl_stmt|;
operator|*
name|npp
operator|=
name|NULL
expr_stmt|;
comment|/* For forced dismounts, just return error. */
if|if
condition|(
operator|(
name|mntp
operator|->
name|mnt_kern_flag
operator|&
name|MNTK_UNMOUNTF
operator|)
condition|)
return|return
operator|(
name|EINTR
operator|)
return|;
name|MALLOC
argument_list|(
name|nfhp
argument_list|,
expr|struct
name|nfsfh
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nfsfh
argument_list|)
operator|+
name|fhsize
argument_list|,
name|M_NFSFH
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|fhp
argument_list|,
operator|&
name|nfhp
operator|->
name|nfh_fh
index|[
literal|0
index|]
argument_list|,
name|fhsize
argument_list|)
expr_stmt|;
name|nfhp
operator|->
name|nfh_len
operator|=
name|fhsize
expr_stmt|;
name|hash
operator|=
name|fnv_32_buf
argument_list|(
name|fhp
argument_list|,
name|fhsize
argument_list|,
name|FNV1_32_INIT
argument_list|)
expr_stmt|;
comment|/* 	 * First, try to get the vnode locked, but don't block for the lock. 	 */
name|error
operator|=
name|vfs_hash_get
argument_list|(
name|mntp
argument_list|,
name|hash
argument_list|,
operator|(
name|LK_EXCLUSIVE
operator||
name|LK_NOWAIT
operator|)
argument_list|,
name|td
argument_list|,
operator|&
name|nvp
argument_list|,
name|newnfs_vncmpf
argument_list|,
name|nfhp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|nvp
operator|!=
name|NULL
condition|)
block|{
name|NFSVOPUNLOCK
argument_list|(
name|nvp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|error
operator|==
name|EBUSY
condition|)
block|{
comment|/* 		 * It is safe so long as a vflush() with 		 * FORCECLOSE has not been done. Since the Renew thread is 		 * stopped and the MNTK_UNMOUNTF flag is set before doing 		 * a vflush() with FORCECLOSE, we should be ok here. 		 */
if|if
condition|(
operator|(
name|mntp
operator|->
name|mnt_kern_flag
operator|&
name|MNTK_UNMOUNTF
operator|)
condition|)
name|error
operator|=
name|EINTR
expr_stmt|;
else|else
block|{
name|vfs_hash_ref
argument_list|(
name|mntp
argument_list|,
name|hash
argument_list|,
name|td
argument_list|,
operator|&
name|nvp
argument_list|,
name|newnfs_vncmpf
argument_list|,
name|nfhp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOENT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|nvp
operator|->
name|v_iflag
operator|&
name|VI_DOOMED
operator|)
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|ENOENT
expr_stmt|;
name|vrele
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
name|FREE
argument_list|(
name|nfhp
argument_list|,
name|M_NFSFH
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|nvp
operator|!=
name|NULL
condition|)
block|{
operator|*
name|npp
operator|=
name|VTONFS
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Load the attribute cache (that lives in the nfsnode entry) with  * the attributes of the second argument and  * Iff vaper not NULL  *    copy the attributes to *vaper  * Similar to nfs_loadattrcache(), except the attributes are passed in  * instead of being parsed out of the mbuf list.  */
end_comment

begin_function
name|int
name|nfscl_loadattrcache
parameter_list|(
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|nap
parameter_list|,
name|void
modifier|*
name|nvaper
parameter_list|,
name|void
modifier|*
name|stuff
parameter_list|,
name|int
name|writeattr
parameter_list|,
name|int
name|dontshrink
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
operator|*
name|vpp
decl_stmt|;
name|struct
name|vattr
modifier|*
name|vap
decl_stmt|,
modifier|*
name|nvap
init|=
operator|&
name|nap
operator|->
name|na_vattr
decl_stmt|,
modifier|*
name|vaper
init|=
name|nvaper
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|np
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
decl_stmt|;
name|struct
name|timespec
name|mtime_save
decl_stmt|;
name|u_quad_t
name|nsize
decl_stmt|;
name|int
name|setnsize
decl_stmt|;
comment|/* 	 * If v_type == VNON it is a new node, so fill in the v_type, 	 * n_mtime fields. Check to see if it represents a special  	 * device, and if so, check for a possible alias. Once the 	 * correct vnode has been obtained, fill in the rest of the 	 * information. 	 */
name|np
operator|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|NFSLOCKNODE
argument_list|(
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|nvap
operator|->
name|va_type
condition|)
block|{
name|vp
operator|->
name|v_type
operator|=
name|nvap
operator|->
name|va_type
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VFIFO
condition|)
name|vp
operator|->
name|v_op
operator|=
operator|&
name|newnfs_fifoops
expr_stmt|;
name|np
operator|->
name|n_mtime
operator|=
name|nvap
operator|->
name|va_mtime
expr_stmt|;
block|}
name|nmp
operator|=
name|VFSTONFS
argument_list|(
name|vp
operator|->
name|v_mount
argument_list|)
expr_stmt|;
name|vap
operator|=
operator|&
name|np
operator|->
name|n_vattr
operator|.
name|na_vattr
expr_stmt|;
name|mtime_save
operator|=
name|vap
operator|->
name|va_mtime
expr_stmt|;
if|if
condition|(
name|writeattr
condition|)
block|{
name|np
operator|->
name|n_vattr
operator|.
name|na_filerev
operator|=
name|nap
operator|->
name|na_filerev
expr_stmt|;
name|np
operator|->
name|n_vattr
operator|.
name|na_size
operator|=
name|nap
operator|->
name|na_size
expr_stmt|;
name|np
operator|->
name|n_vattr
operator|.
name|na_mtime
operator|=
name|nap
operator|->
name|na_mtime
expr_stmt|;
name|np
operator|->
name|n_vattr
operator|.
name|na_ctime
operator|=
name|nap
operator|->
name|na_ctime
expr_stmt|;
name|np
operator|->
name|n_vattr
operator|.
name|na_fsid
operator|=
name|nap
operator|->
name|na_fsid
expr_stmt|;
name|np
operator|->
name|n_vattr
operator|.
name|na_mode
operator|=
name|nap
operator|->
name|na_mode
expr_stmt|;
block|}
else|else
block|{
name|NFSBCOPY
argument_list|(
operator|(
name|caddr_t
operator|)
name|nap
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|np
operator|->
name|n_vattr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nfsvattr
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * For NFSv4, if the node's fsid is not equal to the mount point's 	 * fsid, return the low order 32bits of the node's fsid. This 	 * allows getcwd(3) to work. There is a chance that the fsid might 	 * be the same as a local fs, but since this is in an NFS mount 	 * point, I don't think that will cause any problems? 	 */
if|if
condition|(
name|NFSHASNFSV4
argument_list|(
name|nmp
argument_list|)
operator|&&
name|NFSHASHASSETFSID
argument_list|(
name|nmp
argument_list|)
operator|&&
operator|(
name|nmp
operator|->
name|nm_fsid
index|[
literal|0
index|]
operator|!=
name|np
operator|->
name|n_vattr
operator|.
name|na_filesid
index|[
literal|0
index|]
operator|||
name|nmp
operator|->
name|nm_fsid
index|[
literal|1
index|]
operator|!=
name|np
operator|->
name|n_vattr
operator|.
name|na_filesid
index|[
literal|1
index|]
operator|)
condition|)
block|{
comment|/* 		 * va_fsid needs to be set to some value derived from 		 * np->n_vattr.na_filesid that is not equal 		 * vp->v_mount->mnt_stat.f_fsid[0], so that it changes 		 * from the value used for the top level server volume 		 * in the mounted subtree. 		 */
if|if
condition|(
name|vp
operator|->
name|v_mount
operator|->
name|mnt_stat
operator|.
name|f_fsid
operator|.
name|val
index|[
literal|0
index|]
operator|!=
operator|(
name|uint32_t
operator|)
name|np
operator|->
name|n_vattr
operator|.
name|na_filesid
index|[
literal|0
index|]
condition|)
name|vap
operator|->
name|va_fsid
operator|=
operator|(
name|uint32_t
operator|)
name|np
operator|->
name|n_vattr
operator|.
name|na_filesid
index|[
literal|0
index|]
expr_stmt|;
else|else
name|vap
operator|->
name|va_fsid
operator|=
operator|(
name|uint32_t
operator|)
name|hash32_buf
argument_list|(
name|np
operator|->
name|n_vattr
operator|.
name|na_filesid
argument_list|,
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|vap
operator|->
name|va_fsid
operator|=
name|vp
operator|->
name|v_mount
operator|->
name|mnt_stat
operator|.
name|f_fsid
operator|.
name|val
index|[
literal|0
index|]
expr_stmt|;
name|np
operator|->
name|n_attrstamp
operator|=
name|time_second
expr_stmt|;
name|setnsize
operator|=
literal|0
expr_stmt|;
name|nsize
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|va_size
operator|!=
name|np
operator|->
name|n_size
condition|)
block|{
if|if
condition|(
name|vap
operator|->
name|va_type
operator|==
name|VREG
condition|)
block|{
if|if
condition|(
name|dontshrink
operator|&&
name|vap
operator|->
name|va_size
operator|<
name|np
operator|->
name|n_size
condition|)
block|{
comment|/* 				 * We've been told not to shrink the file; 				 * zero np->n_attrstamp to indicate that 				 * the attributes are stale. 				 */
name|vap
operator|->
name|va_size
operator|=
name|np
operator|->
name|n_size
expr_stmt|;
name|np
operator|->
name|n_attrstamp
operator|=
literal|0
expr_stmt|;
name|KDTRACE_NFS_ATTRCACHE_FLUSH_DONE
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|vnode_pager_setsize
argument_list|(
name|vp
argument_list|,
name|np
operator|->
name|n_size
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|np
operator|->
name|n_flag
operator|&
name|NMODIFIED
condition|)
block|{
comment|/* 				 * We've modified the file: Use the larger 				 * of our size, and the server's size. 				 */
if|if
condition|(
name|vap
operator|->
name|va_size
operator|<
name|np
operator|->
name|n_size
condition|)
block|{
name|vap
operator|->
name|va_size
operator|=
name|np
operator|->
name|n_size
expr_stmt|;
block|}
else|else
block|{
name|np
operator|->
name|n_size
operator|=
name|vap
operator|->
name|va_size
expr_stmt|;
name|np
operator|->
name|n_flag
operator||=
name|NSIZECHANGED
expr_stmt|;
block|}
name|vnode_pager_setsize
argument_list|(
name|vp
argument_list|,
name|np
operator|->
name|n_size
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vap
operator|->
name|va_size
operator|<
name|np
operator|->
name|n_size
condition|)
block|{
comment|/* 				 * When shrinking the size, the call to 				 * vnode_pager_setsize() cannot be done 				 * with the mutex held, so delay it until 				 * after the mtx_unlock call. 				 */
name|nsize
operator|=
name|np
operator|->
name|n_size
operator|=
name|vap
operator|->
name|va_size
expr_stmt|;
name|np
operator|->
name|n_flag
operator||=
name|NSIZECHANGED
expr_stmt|;
name|setnsize
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|np
operator|->
name|n_size
operator|=
name|vap
operator|->
name|va_size
expr_stmt|;
name|np
operator|->
name|n_flag
operator||=
name|NSIZECHANGED
expr_stmt|;
name|vnode_pager_setsize
argument_list|(
name|vp
argument_list|,
name|np
operator|->
name|n_size
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|np
operator|->
name|n_size
operator|=
name|vap
operator|->
name|va_size
expr_stmt|;
block|}
block|}
comment|/* 	 * The following checks are added to prevent a race between (say) 	 * a READDIR+ and a WRITE.  	 * READDIR+, WRITE requests sent out. 	 * READDIR+ resp, WRITE resp received on client. 	 * However, the WRITE resp was handled before the READDIR+ resp 	 * causing the post op attrs from the write to be loaded first 	 * and the attrs from the READDIR+ to be loaded later. If this  	 * happens, we have stale attrs loaded into the attrcache. 	 * We detect this by for the mtime moving back. We invalidate the  	 * attrcache when this happens. 	 */
if|if
condition|(
name|timespeccmp
argument_list|(
operator|&
name|mtime_save
argument_list|,
operator|&
name|vap
operator|->
name|va_mtime
argument_list|,
operator|>
argument_list|)
condition|)
block|{
comment|/* Size changed or mtime went backwards */
name|np
operator|->
name|n_attrstamp
operator|=
literal|0
expr_stmt|;
name|KDTRACE_NFS_ATTRCACHE_FLUSH_DONE
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vaper
operator|!=
name|NULL
condition|)
block|{
name|NFSBCOPY
argument_list|(
operator|(
name|caddr_t
operator|)
name|vap
argument_list|,
operator|(
name|caddr_t
operator|)
name|vaper
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|vap
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|n_flag
operator|&
name|NCHG
condition|)
block|{
if|if
condition|(
name|np
operator|->
name|n_flag
operator|&
name|NACC
condition|)
name|vaper
operator|->
name|va_atime
operator|=
name|np
operator|->
name|n_atim
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|n_flag
operator|&
name|NUPD
condition|)
name|vaper
operator|->
name|va_mtime
operator|=
name|np
operator|->
name|n_mtim
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|KDTRACE_HOOKS
if|if
condition|(
name|np
operator|->
name|n_attrstamp
operator|!=
literal|0
condition|)
name|KDTRACE_NFS_ATTRCACHE_LOAD_DONE
argument_list|(
name|vp
argument_list|,
name|vap
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|NFSUNLOCKNODE
argument_list|(
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
name|setnsize
condition|)
name|vnode_pager_setsize
argument_list|(
name|vp
argument_list|,
name|nsize
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Fill in the client id name. For these bytes:  * 1 - they must be unique  * 2 - they should be persistent across client reboots  * 1 is more critical than 2  * Use the mount point's unique id plus either the uuid or, if that  * isn't set, random junk.  */
end_comment

begin_function
name|void
name|nfscl_fillclid
parameter_list|(
name|u_int64_t
name|clval
parameter_list|,
name|char
modifier|*
name|uuid
parameter_list|,
name|u_int8_t
modifier|*
name|cp
parameter_list|,
name|u_int16_t
name|idlen
parameter_list|)
block|{
name|int
name|uuidlen
decl_stmt|;
comment|/* 	 * First, put in the 64bit mount point identifier. 	 */
if|if
condition|(
name|idlen
operator|>=
sizeof|sizeof
argument_list|(
name|u_int64_t
argument_list|)
condition|)
block|{
name|NFSBCOPY
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|clval
argument_list|,
name|cp
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int64_t
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|u_int64_t
argument_list|)
expr_stmt|;
name|idlen
operator|-=
sizeof|sizeof
argument_list|(
name|u_int64_t
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If uuid is non-zero length, use it. 	 */
name|uuidlen
operator|=
name|strlen
argument_list|(
name|uuid
argument_list|)
expr_stmt|;
if|if
condition|(
name|uuidlen
operator|>
literal|0
operator|&&
name|idlen
operator|>=
name|uuidlen
condition|)
block|{
name|NFSBCOPY
argument_list|(
name|uuid
argument_list|,
name|cp
argument_list|,
name|uuidlen
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|uuidlen
expr_stmt|;
name|idlen
operator|-=
name|uuidlen
expr_stmt|;
block|}
comment|/* 	 * This only normally happens if the uuid isn't set. 	 */
while|while
condition|(
name|idlen
operator|>
literal|0
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
call|(
name|u_int8_t
call|)
argument_list|(
name|arc4random
argument_list|()
operator|%
literal|256
argument_list|)
expr_stmt|;
name|idlen
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Fill in a lock owner name. For now, pid + the process's creation time.  */
end_comment

begin_function
name|void
name|nfscl_filllockowner
parameter_list|(
name|void
modifier|*
name|id
parameter_list|,
name|u_int8_t
modifier|*
name|cp
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
union|union
block|{
name|u_int32_t
name|lval
decl_stmt|;
name|u_int8_t
name|cval
index|[
literal|4
index|]
decl_stmt|;
block|}
name|tl
union|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|id
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"NULL id\n"
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|cp
argument_list|,
name|NFSV4CL_LOCKNAMELEN
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|F_POSIX
operator|)
operator|!=
literal|0
condition|)
block|{
name|p
operator|=
operator|(
expr|struct
name|proc
operator|*
operator|)
name|id
expr_stmt|;
name|tl
operator|.
name|lval
operator|=
name|p
operator|->
name|p_pid
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|tl
operator|.
name|cval
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|tl
operator|.
name|cval
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|tl
operator|.
name|cval
index|[
literal|2
index|]
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|tl
operator|.
name|cval
index|[
literal|3
index|]
expr_stmt|;
name|tl
operator|.
name|lval
operator|=
name|p
operator|->
name|p_stats
operator|->
name|p_start
operator|.
name|tv_sec
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|tl
operator|.
name|cval
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|tl
operator|.
name|cval
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|tl
operator|.
name|cval
index|[
literal|2
index|]
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|tl
operator|.
name|cval
index|[
literal|3
index|]
expr_stmt|;
name|tl
operator|.
name|lval
operator|=
name|p
operator|->
name|p_stats
operator|->
name|p_start
operator|.
name|tv_usec
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|tl
operator|.
name|cval
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|tl
operator|.
name|cval
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|tl
operator|.
name|cval
index|[
literal|2
index|]
expr_stmt|;
operator|*
name|cp
operator|=
name|tl
operator|.
name|cval
index|[
literal|3
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|F_FLOCK
operator|)
operator|!=
literal|0
condition|)
block|{
name|bcopy
argument_list|(
operator|&
name|id
argument_list|,
name|cp
argument_list|,
sizeof|sizeof
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|cp
index|[
sizeof|sizeof
argument_list|(
name|id
argument_list|)
index|]
argument_list|,
name|NFSV4CL_LOCKNAMELEN
operator|-
sizeof|sizeof
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"nfscl_filllockowner: not F_POSIX or F_FLOCK\n"
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|cp
argument_list|,
name|NFSV4CL_LOCKNAMELEN
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Find the parent process for the thread passed in as an argument.  * If none exists, return NULL, otherwise return a thread for the parent.  * (Can be any of the threads, since it is only used for td->td_proc.)  */
end_comment

begin_function
name|NFSPROC_T
modifier|*
name|nfscl_getparent
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|thread
modifier|*
name|ptd
decl_stmt|;
if|if
condition|(
name|td
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_pid
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|p
operator|=
name|p
operator|->
name|p_pptr
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|ptd
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|p
operator|->
name|p_threads
argument_list|)
expr_stmt|;
return|return
operator|(
name|ptd
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Start up the renew kernel thread.  */
end_comment

begin_function
specifier|static
name|void
name|start_nfscl
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|nfsclclient
modifier|*
name|clp
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|clp
operator|=
operator|(
expr|struct
name|nfsclclient
operator|*
operator|)
name|arg
expr_stmt|;
name|td
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|clp
operator|->
name|nfsc_renewthread
operator|->
name|p_threads
argument_list|)
expr_stmt|;
name|nfscl_renewthread
argument_list|(
name|clp
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|kproc_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nfscl_start_renewthread
parameter_list|(
name|struct
name|nfsclclient
modifier|*
name|clp
parameter_list|)
block|{
name|kproc_create
argument_list|(
name|start_nfscl
argument_list|,
operator|(
name|void
operator|*
operator|)
name|clp
argument_list|,
operator|&
name|clp
operator|->
name|nfsc_renewthread
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"nfscl"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handle wcc_data.  * For NFSv4, it assumes that nfsv4_wccattr() was used to set up the getattr  * as the first Op after PutFH.  * (For NFSv4, the postop attributes are after the Op, so they can't be  *  parsed here. A separate call to nfscl_postop_attr() is required.)  */
end_comment

begin_function
name|int
name|nfscl_wcc_data
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|,
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|nap
parameter_list|,
name|int
modifier|*
name|flagp
parameter_list|,
name|int
modifier|*
name|wccflagp
parameter_list|,
name|void
modifier|*
name|stuff
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|np
init|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|nfsvattr
name|nfsva
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|wccflagp
operator|!=
name|NULL
condition|)
operator|*
name|wccflagp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
condition|)
block|{
operator|*
name|flagp
operator|=
literal|0
expr_stmt|;
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|tl
operator|==
name|newnfs_true
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|6
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|wccflagp
operator|!=
name|NULL
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|np
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
operator|*
name|wccflagp
operator|=
operator|(
name|np
operator|->
name|n_mtime
operator|.
name|tv_sec
operator|==
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
operator|(
name|tl
operator|+
literal|2
operator|)
argument_list|)
operator|&&
name|np
operator|->
name|n_mtime
operator|.
name|tv_nsec
operator|==
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
operator|(
name|tl
operator|+
literal|3
operator|)
argument_list|)
operator|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|np
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
block|}
block|}
name|error
operator|=
name|nfscl_postop_attr
argument_list|(
name|nd
argument_list|,
name|nap
argument_list|,
name|flagp
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|nd
operator|->
name|nd_flag
operator|&
operator|(
name|ND_NOMOREDATA
operator||
name|ND_NFSV4
operator||
name|ND_V4WCCATTR
operator|)
operator|)
operator|==
operator|(
name|ND_NFSV4
operator||
name|ND_V4WCCATTR
operator|)
condition|)
block|{
name|error
operator|=
name|nfsv4_loadattr
argument_list|(
name|nd
argument_list|,
name|NULL
argument_list|,
operator|&
name|nfsva
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 		 * Get rid of Op# and status for next op. 		 */
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|++
name|tl
condition|)
name|nd
operator|->
name|nd_flag
operator||=
name|ND_NOMOREDATA
expr_stmt|;
if|if
condition|(
name|wccflagp
operator|!=
name|NULL
operator|&&
name|nfsva
operator|.
name|na_vattr
operator|.
name|va_mtime
operator|.
name|tv_sec
operator|!=
literal|0
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|np
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
operator|*
name|wccflagp
operator|=
operator|(
name|np
operator|->
name|n_mtime
operator|.
name|tv_sec
operator|==
name|nfsva
operator|.
name|na_vattr
operator|.
name|va_mtime
operator|.
name|tv_sec
operator|&&
name|np
operator|->
name|n_mtime
operator|.
name|tv_nsec
operator|==
name|nfsva
operator|.
name|na_vattr
operator|.
name|va_mtime
operator|.
name|tv_sec
operator|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|np
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
block|}
block|}
name|nfsmout
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get postop attributes.  */
end_comment

begin_function
name|int
name|nfscl_postop_attr
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|nap
parameter_list|,
name|int
modifier|*
name|retp
parameter_list|,
name|void
modifier|*
name|stuff
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
operator|*
name|retp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NOMOREDATA
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|retp
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
block|{
comment|/* 		 * For NFSv4, the postop attr are at the end, so no point 		 * in looking if nd_repstat != 0. 		 */
if|if
condition|(
operator|!
name|nd
operator|->
name|nd_repstat
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|tl
operator|+
literal|1
operator|)
condition|)
comment|/* should never happen since nd_repstat != 0 */
name|nd
operator|->
name|nd_flag
operator||=
name|ND_NOMOREDATA
expr_stmt|;
else|else
operator|*
name|retp
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|nd
operator|->
name|nd_repstat
condition|)
block|{
comment|/* For NFSv2, the attributes are here iff nd_repstat == 0 */
operator|*
name|retp
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|retp
condition|)
block|{
name|error
operator|=
name|nfsm_loadattr
argument_list|(
name|nd
argument_list|,
name|nap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
operator|*
name|retp
operator|=
literal|0
expr_stmt|;
block|}
name|nfsmout
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Fill in the setable attributes. The full argument indicates whether  * to fill in them all or just mode and time.  */
end_comment

begin_function
name|void
name|nfscl_fillsattr
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|,
name|struct
name|vattr
modifier|*
name|vap
parameter_list|,
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|int
name|flags
parameter_list|,
name|u_int32_t
name|rdev
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|struct
name|nfsv2_sattr
modifier|*
name|sp
decl_stmt|;
name|nfsattrbit_t
name|attrbits
decl_stmt|;
switch|switch
condition|(
name|nd
operator|->
name|nd_flag
operator|&
operator|(
name|ND_NFSV2
operator||
name|ND_NFSV3
operator||
name|ND_NFSV4
operator|)
condition|)
block|{
case|case
name|ND_NFSV2
case|:
name|NFSM_BUILD
argument_list|(
name|sp
argument_list|,
expr|struct
name|nfsv2_sattr
operator|*
argument_list|,
name|NFSX_V2SATTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|va_mode
operator|==
operator|(
name|mode_t
operator|)
name|VNOVAL
condition|)
name|sp
operator|->
name|sa_mode
operator|=
name|newnfs_xdrneg1
expr_stmt|;
else|else
name|sp
operator|->
name|sa_mode
operator|=
name|vtonfsv2_mode
argument_list|(
name|vap
operator|->
name|va_type
argument_list|,
name|vap
operator|->
name|va_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|va_uid
operator|==
operator|(
name|uid_t
operator|)
name|VNOVAL
condition|)
name|sp
operator|->
name|sa_uid
operator|=
name|newnfs_xdrneg1
expr_stmt|;
else|else
name|sp
operator|->
name|sa_uid
operator|=
name|txdr_unsigned
argument_list|(
name|vap
operator|->
name|va_uid
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|va_gid
operator|==
operator|(
name|gid_t
operator|)
name|VNOVAL
condition|)
name|sp
operator|->
name|sa_gid
operator|=
name|newnfs_xdrneg1
expr_stmt|;
else|else
name|sp
operator|->
name|sa_gid
operator|=
name|txdr_unsigned
argument_list|(
name|vap
operator|->
name|va_gid
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|NFSSATTR_SIZE0
condition|)
name|sp
operator|->
name|sa_size
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|NFSSATTR_SIZENEG1
condition|)
name|sp
operator|->
name|sa_size
operator|=
name|newnfs_xdrneg1
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|NFSSATTR_SIZERDEV
condition|)
name|sp
operator|->
name|sa_size
operator|=
name|txdr_unsigned
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
else|else
name|sp
operator|->
name|sa_size
operator|=
name|txdr_unsigned
argument_list|(
name|vap
operator|->
name|va_size
argument_list|)
expr_stmt|;
name|txdr_nfsv2time
argument_list|(
operator|&
name|vap
operator|->
name|va_atime
argument_list|,
operator|&
name|sp
operator|->
name|sa_atime
argument_list|)
expr_stmt|;
name|txdr_nfsv2time
argument_list|(
operator|&
name|vap
operator|->
name|va_mtime
argument_list|,
operator|&
name|sp
operator|->
name|sa_mtime
argument_list|)
expr_stmt|;
break|break;
case|case
name|ND_NFSV3
case|:
if|if
condition|(
name|vap
operator|->
name|va_mode
operator|!=
operator|(
name|mode_t
operator|)
name|VNOVAL
condition|)
block|{
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|newnfs_true
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|vap
operator|->
name|va_mode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|newnfs_false
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|NFSSATTR_FULL
operator|)
operator|&&
name|vap
operator|->
name|va_uid
operator|!=
operator|(
name|uid_t
operator|)
name|VNOVAL
condition|)
block|{
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|newnfs_true
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|vap
operator|->
name|va_uid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|newnfs_false
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|NFSSATTR_FULL
operator|)
operator|&&
name|vap
operator|->
name|va_gid
operator|!=
operator|(
name|gid_t
operator|)
name|VNOVAL
condition|)
block|{
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|newnfs_true
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|vap
operator|->
name|va_gid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|newnfs_false
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|NFSSATTR_FULL
operator|)
operator|&&
name|vap
operator|->
name|va_size
operator|!=
name|VNOVAL
condition|)
block|{
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|3
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|newnfs_true
expr_stmt|;
name|txdr_hyper
argument_list|(
name|vap
operator|->
name|va_size
argument_list|,
name|tl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|newnfs_false
expr_stmt|;
block|}
if|if
condition|(
name|vap
operator|->
name|va_atime
operator|.
name|tv_sec
operator|!=
name|VNOVAL
condition|)
block|{
if|if
condition|(
operator|(
name|vap
operator|->
name|va_vaflags
operator|&
name|VA_UTIMES_NULL
operator|)
operator|==
literal|0
condition|)
block|{
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|3
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV3SATTRTIME_TOCLIENT
argument_list|)
expr_stmt|;
name|txdr_nfsv3time
argument_list|(
operator|&
name|vap
operator|->
name|va_atime
argument_list|,
name|tl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV3SATTRTIME_TOSERVER
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV3SATTRTIME_DONTCHANGE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vap
operator|->
name|va_mtime
operator|.
name|tv_sec
operator|!=
name|VNOVAL
condition|)
block|{
if|if
condition|(
operator|(
name|vap
operator|->
name|va_vaflags
operator|&
name|VA_UTIMES_NULL
operator|)
operator|==
literal|0
condition|)
block|{
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|3
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV3SATTRTIME_TOCLIENT
argument_list|)
expr_stmt|;
name|txdr_nfsv3time
argument_list|(
operator|&
name|vap
operator|->
name|va_mtime
argument_list|,
name|tl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV3SATTRTIME_TOSERVER
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV3SATTRTIME_DONTCHANGE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ND_NFSV4
case|:
name|NFSZERO_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|va_mode
operator|!=
operator|(
name|mode_t
operator|)
name|VNOVAL
condition|)
name|NFSSETBIT_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|,
name|NFSATTRBIT_MODE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|NFSSATTR_FULL
operator|)
operator|&&
name|vap
operator|->
name|va_uid
operator|!=
operator|(
name|uid_t
operator|)
name|VNOVAL
condition|)
name|NFSSETBIT_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|,
name|NFSATTRBIT_OWNER
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|NFSSATTR_FULL
operator|)
operator|&&
name|vap
operator|->
name|va_gid
operator|!=
operator|(
name|gid_t
operator|)
name|VNOVAL
condition|)
name|NFSSETBIT_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|,
name|NFSATTRBIT_OWNERGROUP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|NFSSATTR_FULL
operator|)
operator|&&
name|vap
operator|->
name|va_size
operator|!=
name|VNOVAL
condition|)
name|NFSSETBIT_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|,
name|NFSATTRBIT_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|va_atime
operator|.
name|tv_sec
operator|!=
name|VNOVAL
condition|)
name|NFSSETBIT_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|,
name|NFSATTRBIT_TIMEACCESSSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|va_mtime
operator|.
name|tv_sec
operator|!=
name|VNOVAL
condition|)
name|NFSSETBIT_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|,
name|NFSATTRBIT_TIMEMODIFYSET
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsv4_fillattr
argument_list|(
name|nd
argument_list|,
name|vp
operator|->
name|v_mount
argument_list|,
name|vp
argument_list|,
name|NULL
argument_list|,
name|vap
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|attrbits
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|uint64_t
operator|)
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
empty_stmt|;
block|}
end_function

begin_comment
comment|/*  * nfscl_request() - mostly a wrapper for newnfs_request().  */
end_comment

begin_function
name|int
name|nfscl_request
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|,
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|void
modifier|*
name|stuff
parameter_list|)
block|{
name|int
name|ret
decl_stmt|,
name|vers
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
decl_stmt|;
name|nmp
operator|=
name|VFSTONFS
argument_list|(
name|vp
operator|->
name|v_mount
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
name|vers
operator|=
name|NFS_VER4
expr_stmt|;
elseif|else
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
condition|)
name|vers
operator|=
name|NFS_VER3
expr_stmt|;
else|else
name|vers
operator|=
name|NFS_VER2
expr_stmt|;
name|ret
operator|=
name|newnfs_request
argument_list|(
name|nd
argument_list|,
name|nmp
argument_list|,
name|NULL
argument_list|,
operator|&
name|nmp
operator|->
name|nm_sockreq
argument_list|,
name|vp
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|NFS_PROG
argument_list|,
name|vers
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * fill in this bsden's variant of statfs using nfsstatfs.  */
end_comment

begin_function
name|void
name|nfscl_loadsbinfo
parameter_list|(
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|,
name|struct
name|nfsstatfs
modifier|*
name|sfp
parameter_list|,
name|void
modifier|*
name|statfs
parameter_list|)
block|{
name|struct
name|statfs
modifier|*
name|sbp
init|=
operator|(
expr|struct
name|statfs
operator|*
operator|)
name|statfs
decl_stmt|;
if|if
condition|(
name|nmp
operator|->
name|nm_flag
operator|&
operator|(
name|NFSMNT_NFSV3
operator||
name|NFSMNT_NFSV4
operator|)
condition|)
block|{
name|sbp
operator|->
name|f_bsize
operator|=
name|NFS_FABLKSIZE
expr_stmt|;
name|sbp
operator|->
name|f_blocks
operator|=
name|sfp
operator|->
name|sf_tbytes
operator|/
name|NFS_FABLKSIZE
expr_stmt|;
name|sbp
operator|->
name|f_bfree
operator|=
name|sfp
operator|->
name|sf_fbytes
operator|/
name|NFS_FABLKSIZE
expr_stmt|;
comment|/* 		 * Although sf_abytes is uint64_t and f_bavail is int64_t, 		 * the value after dividing by NFS_FABLKSIZE is small 		 * enough that it will fit in 63bits, so it is ok to 		 * assign it to f_bavail without fear that it will become 		 * negative. 		 */
name|sbp
operator|->
name|f_bavail
operator|=
name|sfp
operator|->
name|sf_abytes
operator|/
name|NFS_FABLKSIZE
expr_stmt|;
name|sbp
operator|->
name|f_files
operator|=
name|sfp
operator|->
name|sf_tfiles
expr_stmt|;
comment|/* Since f_ffree is int64_t, clip it to 63bits. */
if|if
condition|(
name|sfp
operator|->
name|sf_ffiles
operator|>
name|INT64_MAX
condition|)
name|sbp
operator|->
name|f_ffree
operator|=
name|INT64_MAX
expr_stmt|;
else|else
name|sbp
operator|->
name|f_ffree
operator|=
name|sfp
operator|->
name|sf_ffiles
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_NFSV4
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * The type casts to (int32_t) ensure that this code is 		 * compatible with the old NFS client, in that it will 		 * propagate bit31 to the high order bits. This may or may 		 * not be correct for NFSv2, but since it is a legacy 		 * environment, I'd rather retain backwards compatibility. 		 */
name|sbp
operator|->
name|f_bsize
operator|=
operator|(
name|int32_t
operator|)
name|sfp
operator|->
name|sf_bsize
expr_stmt|;
name|sbp
operator|->
name|f_blocks
operator|=
operator|(
name|int32_t
operator|)
name|sfp
operator|->
name|sf_blocks
expr_stmt|;
name|sbp
operator|->
name|f_bfree
operator|=
operator|(
name|int32_t
operator|)
name|sfp
operator|->
name|sf_bfree
expr_stmt|;
name|sbp
operator|->
name|f_bavail
operator|=
operator|(
name|int32_t
operator|)
name|sfp
operator|->
name|sf_bavail
expr_stmt|;
name|sbp
operator|->
name|f_files
operator|=
literal|0
expr_stmt|;
name|sbp
operator|->
name|f_ffree
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Use the fsinfo stuff to update the mount point.  */
end_comment

begin_function
name|void
name|nfscl_loadfsinfo
parameter_list|(
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|,
name|struct
name|nfsfsinfo
modifier|*
name|fsp
parameter_list|)
block|{
if|if
condition|(
operator|(
name|nmp
operator|->
name|nm_wsize
operator|==
literal|0
operator|||
name|fsp
operator|->
name|fs_wtpref
operator|<
name|nmp
operator|->
name|nm_wsize
operator|)
operator|&&
name|fsp
operator|->
name|fs_wtpref
operator|>=
name|NFS_FABLKSIZE
condition|)
name|nmp
operator|->
name|nm_wsize
operator|=
operator|(
name|fsp
operator|->
name|fs_wtpref
operator|+
name|NFS_FABLKSIZE
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|NFS_FABLKSIZE
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|fsp
operator|->
name|fs_wtmax
operator|<
name|nmp
operator|->
name|nm_wsize
operator|&&
name|fsp
operator|->
name|fs_wtmax
operator|>
literal|0
condition|)
block|{
name|nmp
operator|->
name|nm_wsize
operator|=
name|fsp
operator|->
name|fs_wtmax
operator|&
operator|~
operator|(
name|NFS_FABLKSIZE
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|nmp
operator|->
name|nm_wsize
operator|==
literal|0
condition|)
name|nmp
operator|->
name|nm_wsize
operator|=
name|fsp
operator|->
name|fs_wtmax
expr_stmt|;
block|}
if|if
condition|(
name|nmp
operator|->
name|nm_wsize
operator|<
name|NFS_FABLKSIZE
condition|)
name|nmp
operator|->
name|nm_wsize
operator|=
name|NFS_FABLKSIZE
expr_stmt|;
if|if
condition|(
operator|(
name|nmp
operator|->
name|nm_rsize
operator|==
literal|0
operator|||
name|fsp
operator|->
name|fs_rtpref
operator|<
name|nmp
operator|->
name|nm_rsize
operator|)
operator|&&
name|fsp
operator|->
name|fs_rtpref
operator|>=
name|NFS_FABLKSIZE
condition|)
name|nmp
operator|->
name|nm_rsize
operator|=
operator|(
name|fsp
operator|->
name|fs_rtpref
operator|+
name|NFS_FABLKSIZE
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|NFS_FABLKSIZE
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|fsp
operator|->
name|fs_rtmax
operator|<
name|nmp
operator|->
name|nm_rsize
operator|&&
name|fsp
operator|->
name|fs_rtmax
operator|>
literal|0
condition|)
block|{
name|nmp
operator|->
name|nm_rsize
operator|=
name|fsp
operator|->
name|fs_rtmax
operator|&
operator|~
operator|(
name|NFS_FABLKSIZE
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|nmp
operator|->
name|nm_rsize
operator|==
literal|0
condition|)
name|nmp
operator|->
name|nm_rsize
operator|=
name|fsp
operator|->
name|fs_rtmax
expr_stmt|;
block|}
if|if
condition|(
name|nmp
operator|->
name|nm_rsize
operator|<
name|NFS_FABLKSIZE
condition|)
name|nmp
operator|->
name|nm_rsize
operator|=
name|NFS_FABLKSIZE
expr_stmt|;
if|if
condition|(
operator|(
name|nmp
operator|->
name|nm_readdirsize
operator|==
literal|0
operator|||
name|fsp
operator|->
name|fs_dtpref
operator|<
name|nmp
operator|->
name|nm_readdirsize
operator|)
operator|&&
name|fsp
operator|->
name|fs_dtpref
operator|>=
name|NFS_DIRBLKSIZ
condition|)
name|nmp
operator|->
name|nm_readdirsize
operator|=
operator|(
name|fsp
operator|->
name|fs_dtpref
operator|+
name|NFS_DIRBLKSIZ
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|NFS_DIRBLKSIZ
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|fsp
operator|->
name|fs_rtmax
operator|<
name|nmp
operator|->
name|nm_readdirsize
operator|&&
name|fsp
operator|->
name|fs_rtmax
operator|>
literal|0
condition|)
block|{
name|nmp
operator|->
name|nm_readdirsize
operator|=
name|fsp
operator|->
name|fs_rtmax
operator|&
operator|~
operator|(
name|NFS_DIRBLKSIZ
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|nmp
operator|->
name|nm_readdirsize
operator|==
literal|0
condition|)
name|nmp
operator|->
name|nm_readdirsize
operator|=
name|fsp
operator|->
name|fs_rtmax
expr_stmt|;
block|}
if|if
condition|(
name|nmp
operator|->
name|nm_readdirsize
operator|<
name|NFS_DIRBLKSIZ
condition|)
name|nmp
operator|->
name|nm_readdirsize
operator|=
name|NFS_DIRBLKSIZ
expr_stmt|;
if|if
condition|(
name|fsp
operator|->
name|fs_maxfilesize
operator|>
literal|0
operator|&&
name|fsp
operator|->
name|fs_maxfilesize
operator|<
name|nmp
operator|->
name|nm_maxfilesize
condition|)
name|nmp
operator|->
name|nm_maxfilesize
operator|=
name|fsp
operator|->
name|fs_maxfilesize
expr_stmt|;
name|nmp
operator|->
name|nm_mountp
operator|->
name|mnt_stat
operator|.
name|f_iosize
operator|=
name|newnfs_iosize
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
name|nmp
operator|->
name|nm_state
operator||=
name|NFSSTA_GOTFSINFO
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get a pointer to my IP addrress and return it.  * Return NULL if you can't find one.  */
end_comment

begin_function
name|u_int8_t
modifier|*
name|nfscl_getmyip
parameter_list|(
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|,
name|int
modifier|*
name|isinet6p
parameter_list|)
block|{
name|struct
name|sockaddr_in
name|sad
decl_stmt|,
modifier|*
name|sin
decl_stmt|;
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
name|u_int8_t
modifier|*
name|retp
init|=
name|NULL
decl_stmt|;
specifier|static
name|struct
name|in_addr
name|laddr
decl_stmt|;
operator|*
name|isinet6p
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Loop up a route for the destination address. 	 */
if|if
condition|(
name|nmp
operator|->
name|nm_nam
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|bzero
argument_list|(
operator|&
name|sad
argument_list|,
sizeof|sizeof
argument_list|(
name|sad
argument_list|)
argument_list|)
expr_stmt|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|nmp
operator|->
name|nm_nam
expr_stmt|;
name|sad
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sad
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|sad
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
name|CURVNET_SET
argument_list|(
name|CRED_TO_VNET
argument_list|(
name|nmp
operator|->
name|nm_sockreq
operator|.
name|nr_cred
argument_list|)
argument_list|)
expr_stmt|;
name|rt
operator|=
name|rtalloc1_fib
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sad
argument_list|,
literal|0
argument_list|,
literal|0UL
argument_list|,
name|curthread
operator|->
name|td_proc
operator|->
name|p_fibnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|rt
operator|->
name|rt_ifp
operator|!=
name|NULL
operator|&&
name|rt
operator|->
name|rt_ifa
operator|!=
name|NULL
operator|&&
operator|(
operator|(
name|rt
operator|->
name|rt_ifp
operator|->
name|if_flags
operator|&
name|IFF_LOOPBACK
operator|)
operator|==
literal|0
operator|)
operator|&&
name|rt
operator|->
name|rt_ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|rt
operator|->
name|rt_ifa
operator|->
name|ifa_addr
expr_stmt|;
name|laddr
operator|.
name|s_addr
operator|=
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
name|retp
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|laddr
expr_stmt|;
block|}
name|RTFREE_LOCKED
argument_list|(
name|rt
argument_list|)
expr_stmt|;
block|}
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|INET6
block|}
elseif|else
if|if
condition|(
name|nmp
operator|->
name|nm_nam
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
name|struct
name|sockaddr_in6
name|sad6
decl_stmt|,
modifier|*
name|sin6
decl_stmt|;
specifier|static
name|struct
name|in6_addr
name|laddr6
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|sad6
argument_list|,
sizeof|sizeof
argument_list|(
name|sad6
argument_list|)
argument_list|)
expr_stmt|;
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|nmp
operator|->
name|nm_nam
expr_stmt|;
name|sad6
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|sad6
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
name|sad6
operator|.
name|sin6_addr
operator|=
name|sin6
operator|->
name|sin6_addr
expr_stmt|;
name|CURVNET_SET
argument_list|(
name|CRED_TO_VNET
argument_list|(
name|nmp
operator|->
name|nm_sockreq
operator|.
name|nr_cred
argument_list|)
argument_list|)
expr_stmt|;
name|rt
operator|=
name|rtalloc1_fib
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sad6
argument_list|,
literal|0
argument_list|,
literal|0UL
argument_list|,
name|curthread
operator|->
name|td_proc
operator|->
name|p_fibnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|rt
operator|->
name|rt_ifp
operator|!=
name|NULL
operator|&&
name|rt
operator|->
name|rt_ifa
operator|!=
name|NULL
operator|&&
operator|(
operator|(
name|rt
operator|->
name|rt_ifp
operator|->
name|if_flags
operator|&
name|IFF_LOOPBACK
operator|)
operator|==
literal|0
operator|)
operator|&&
name|rt
operator|->
name|rt_ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|rt
operator|->
name|rt_ifa
operator|->
name|ifa_addr
expr_stmt|;
name|laddr6
operator|=
name|sin6
operator|->
name|sin6_addr
expr_stmt|;
name|retp
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|laddr6
expr_stmt|;
operator|*
name|isinet6p
operator|=
literal|1
expr_stmt|;
block|}
name|RTFREE_LOCKED
argument_list|(
name|rt
argument_list|)
expr_stmt|;
block|}
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
return|return
operator|(
name|retp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Copy NFS uid, gids from the cred structure.  */
end_comment

begin_function
name|void
name|newnfs_copyincred
parameter_list|(
name|struct
name|ucred
modifier|*
name|cr
parameter_list|,
name|struct
name|nfscred
modifier|*
name|nfscr
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|KASSERT
argument_list|(
name|cr
operator|->
name|cr_ngroups
operator|>=
literal|0
argument_list|,
operator|(
literal|"newnfs_copyincred: negative cr_ngroups"
operator|)
argument_list|)
expr_stmt|;
name|nfscr
operator|->
name|nfsc_uid
operator|=
name|cr
operator|->
name|cr_uid
expr_stmt|;
name|nfscr
operator|->
name|nfsc_ngroups
operator|=
name|MIN
argument_list|(
name|cr
operator|->
name|cr_ngroups
argument_list|,
name|NFS_MAXGRPS
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfscr
operator|->
name|nfsc_ngroups
condition|;
name|i
operator|++
control|)
name|nfscr
operator|->
name|nfsc_groups
index|[
name|i
index|]
operator|=
name|cr
operator|->
name|cr_groups
index|[
name|i
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Do any client specific initialization.  */
end_comment

begin_function
name|void
name|nfscl_init
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|int
name|inited
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|inited
condition|)
return|return;
name|inited
operator|=
literal|1
expr_stmt|;
name|nfscl_inited
operator|=
literal|1
expr_stmt|;
name|ncl_pbuf_freecnt
operator|=
name|nswbuf
operator|/
literal|2
operator|+
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Check each of the attributes to be set, to ensure they aren't already  * the correct value. Disable setting ones already correct.  */
end_comment

begin_function
name|int
name|nfscl_checksattr
parameter_list|(
name|struct
name|vattr
modifier|*
name|vap
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|nvap
parameter_list|)
block|{
if|if
condition|(
name|vap
operator|->
name|va_mode
operator|!=
operator|(
name|mode_t
operator|)
name|VNOVAL
condition|)
block|{
if|if
condition|(
name|vap
operator|->
name|va_mode
operator|==
name|nvap
operator|->
name|na_mode
condition|)
name|vap
operator|->
name|va_mode
operator|=
operator|(
name|mode_t
operator|)
name|VNOVAL
expr_stmt|;
block|}
if|if
condition|(
name|vap
operator|->
name|va_uid
operator|!=
operator|(
name|uid_t
operator|)
name|VNOVAL
condition|)
block|{
if|if
condition|(
name|vap
operator|->
name|va_uid
operator|==
name|nvap
operator|->
name|na_uid
condition|)
name|vap
operator|->
name|va_uid
operator|=
operator|(
name|uid_t
operator|)
name|VNOVAL
expr_stmt|;
block|}
if|if
condition|(
name|vap
operator|->
name|va_gid
operator|!=
operator|(
name|gid_t
operator|)
name|VNOVAL
condition|)
block|{
if|if
condition|(
name|vap
operator|->
name|va_gid
operator|==
name|nvap
operator|->
name|na_gid
condition|)
name|vap
operator|->
name|va_gid
operator|=
operator|(
name|gid_t
operator|)
name|VNOVAL
expr_stmt|;
block|}
if|if
condition|(
name|vap
operator|->
name|va_size
operator|!=
name|VNOVAL
condition|)
block|{
if|if
condition|(
name|vap
operator|->
name|va_size
operator|==
name|nvap
operator|->
name|na_size
condition|)
name|vap
operator|->
name|va_size
operator|=
name|VNOVAL
expr_stmt|;
block|}
comment|/* 	 * We are normally called with only a partially initialized 	 * VAP.  Since the NFSv3 spec says that server may use the 	 * file attributes to store the verifier, the spec requires 	 * us to do a SETATTR RPC. FreeBSD servers store the verifier 	 * in atime, but we can't really assume that all servers will 	 * so we ensure that our SETATTR sets both atime and mtime. 	 * Set the VA_UTIMES_NULL flag for this case, so that 	 * the server's time will be used.  This is needed to 	 * work around a bug in some Solaris servers, where 	 * setting the time TOCLIENT causes the Setattr RPC 	 * to return NFS_OK, but not set va_mode. 	 */
if|if
condition|(
name|vap
operator|->
name|va_mtime
operator|.
name|tv_sec
operator|==
name|VNOVAL
condition|)
block|{
name|vfs_timestamp
argument_list|(
operator|&
name|vap
operator|->
name|va_mtime
argument_list|)
expr_stmt|;
name|vap
operator|->
name|va_vaflags
operator||=
name|VA_UTIMES_NULL
expr_stmt|;
block|}
if|if
condition|(
name|vap
operator|->
name|va_atime
operator|.
name|tv_sec
operator|==
name|VNOVAL
condition|)
name|vap
operator|->
name|va_atime
operator|=
name|vap
operator|->
name|va_mtime
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Map nfsv4 errors to errno.h errors.  * The uid and gid arguments are only used for NFSERR_BADOWNER and that  * error should only be returned for the Open, Create and Setattr Ops.  * As such, most calls can just pass in 0 for those arguments.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfscl_maperr
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|int
name|error
parameter_list|,
name|uid_t
name|uid
parameter_list|,
name|gid_t
name|gid
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|error
operator|<
literal|10000
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|td
operator|!=
name|NULL
condition|)
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
else|else
name|p
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|error
condition|)
block|{
case|case
name|NFSERR_BADOWNER
case|:
name|tprintf
argument_list|(
name|p
argument_list|,
name|LOG_INFO
argument_list|,
literal|"No name and/or group mapping for uid,gid:(%d,%d)\n"
argument_list|,
name|uid
argument_list|,
name|gid
argument_list|)
expr_stmt|;
return|return
operator|(
name|EPERM
operator|)
return|;
case|case
name|NFSERR_BADNAME
case|:
case|case
name|NFSERR_BADCHAR
case|:
name|printf
argument_list|(
literal|"nfsv4 char/name not handled by server\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
case|case
name|NFSERR_STALECLIENTID
case|:
case|case
name|NFSERR_STALESTATEID
case|:
case|case
name|NFSERR_EXPIRED
case|:
case|case
name|NFSERR_BADSTATEID
case|:
case|case
name|NFSERR_BADSESSION
case|:
name|printf
argument_list|(
literal|"nfsv4 recover err returned %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
case|case
name|NFSERR_BADHANDLE
case|:
case|case
name|NFSERR_SERVERFAULT
case|:
case|case
name|NFSERR_BADTYPE
case|:
case|case
name|NFSERR_FHEXPIRED
case|:
case|case
name|NFSERR_RESOURCE
case|:
case|case
name|NFSERR_MOVED
case|:
case|case
name|NFSERR_NOFILEHANDLE
case|:
case|case
name|NFSERR_MINORVERMISMATCH
case|:
case|case
name|NFSERR_OLDSTATEID
case|:
case|case
name|NFSERR_BADSEQID
case|:
case|case
name|NFSERR_LEASEMOVED
case|:
case|case
name|NFSERR_RECLAIMBAD
case|:
case|case
name|NFSERR_BADXDR
case|:
case|case
name|NFSERR_OPILLEGAL
case|:
name|printf
argument_list|(
literal|"nfsv4 client/server protocol prob err=%d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
default|default:
name|tprintf
argument_list|(
name|p
argument_list|,
name|LOG_INFO
argument_list|,
literal|"nfsv4 err=%d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
empty_stmt|;
block|}
end_function

begin_comment
comment|/*  * Check to see if the process for this owner exists. Return 1 if it doesn't  * and 0 otherwise.  */
end_comment

begin_function
name|int
name|nfscl_procdoesntexist
parameter_list|(
name|u_int8_t
modifier|*
name|own
parameter_list|)
block|{
union|union
block|{
name|u_int32_t
name|lval
decl_stmt|;
name|u_int8_t
name|cval
index|[
literal|4
index|]
decl_stmt|;
block|}
name|tl
union|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|tl
operator|.
name|cval
index|[
literal|0
index|]
operator|=
operator|*
name|own
operator|++
expr_stmt|;
name|tl
operator|.
name|cval
index|[
literal|1
index|]
operator|=
operator|*
name|own
operator|++
expr_stmt|;
name|tl
operator|.
name|cval
index|[
literal|2
index|]
operator|=
operator|*
name|own
operator|++
expr_stmt|;
name|tl
operator|.
name|cval
index|[
literal|3
index|]
operator|=
operator|*
name|own
operator|++
expr_stmt|;
name|pid
operator|=
name|tl
operator|.
name|lval
expr_stmt|;
name|p
operator|=
name|pfind_locked
argument_list|(
name|pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|p
operator|->
name|p_stats
operator|==
name|NULL
condition|)
block|{
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|tl
operator|.
name|cval
index|[
literal|0
index|]
operator|=
operator|*
name|own
operator|++
expr_stmt|;
name|tl
operator|.
name|cval
index|[
literal|1
index|]
operator|=
operator|*
name|own
operator|++
expr_stmt|;
name|tl
operator|.
name|cval
index|[
literal|2
index|]
operator|=
operator|*
name|own
operator|++
expr_stmt|;
name|tl
operator|.
name|cval
index|[
literal|3
index|]
operator|=
operator|*
name|own
operator|++
expr_stmt|;
if|if
condition|(
name|tl
operator|.
name|lval
operator|!=
name|p
operator|->
name|p_stats
operator|->
name|p_start
operator|.
name|tv_sec
condition|)
block|{
name|ret
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|tl
operator|.
name|cval
index|[
literal|0
index|]
operator|=
operator|*
name|own
operator|++
expr_stmt|;
name|tl
operator|.
name|cval
index|[
literal|1
index|]
operator|=
operator|*
name|own
operator|++
expr_stmt|;
name|tl
operator|.
name|cval
index|[
literal|2
index|]
operator|=
operator|*
name|own
operator|++
expr_stmt|;
name|tl
operator|.
name|cval
index|[
literal|3
index|]
operator|=
operator|*
name|own
expr_stmt|;
if|if
condition|(
name|tl
operator|.
name|lval
operator|!=
name|p
operator|->
name|p_stats
operator|->
name|p_start
operator|.
name|tv_usec
condition|)
name|ret
operator|=
literal|1
expr_stmt|;
block|}
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * - nfs pseudo system call for the client  */
end_comment

begin_comment
comment|/*  * MPSAFE  */
end_comment

begin_function
specifier|static
name|int
name|nfssvc_nfscl
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|nfssvc_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|struct
name|nfscbd_args
name|nfscbdarg
decl_stmt|;
name|struct
name|nfsd_nfscbd_args
name|nfscbdarg2
decl_stmt|;
name|struct
name|nameidata
name|nd
decl_stmt|;
name|struct
name|nfscl_dumpmntopts
name|dumpmntopts
decl_stmt|;
name|cap_rights_t
name|rights
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|uap
operator|->
name|flag
operator|&
name|NFSSVC_CBADDSOCK
condition|)
block|{
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|argp
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|nfscbdarg
argument_list|,
sizeof|sizeof
argument_list|(
name|nfscbdarg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 		 * Since we don't know what rights might be required, 		 * pretend that we need them all. It is better to be too 		 * careful than too reckless. 		 */
name|error
operator|=
name|fget
argument_list|(
name|td
argument_list|,
name|nfscbdarg
operator|.
name|sock
argument_list|,
name|cap_rights_init
argument_list|(
operator|&
name|rights
argument_list|,
name|CAP_SOCK_CLIENT
argument_list|)
argument_list|,
operator|&
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|fp
operator|->
name|f_type
operator|!=
name|DTYPE_SOCKET
condition|)
block|{
name|fdrop
argument_list|(
name|fp
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
name|error
operator|=
name|nfscbd_addsock
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fdrop
argument_list|(
name|fp
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
name|nfscl_enablecallb
operator|==
literal|0
condition|)
block|{
name|nfsv4_cbport
operator|=
name|nfscbdarg
operator|.
name|port
expr_stmt|;
name|nfscl_enablecallb
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|uap
operator|->
name|flag
operator|&
name|NFSSVC_NFSCBD
condition|)
block|{
if|if
condition|(
name|uap
operator|->
name|argp
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|argp
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|nfscbdarg2
argument_list|,
sizeof|sizeof
argument_list|(
name|nfscbdarg2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|nfscbd_nfsd
argument_list|(
name|td
argument_list|,
operator|&
name|nfscbdarg2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|uap
operator|->
name|flag
operator|&
name|NFSSVC_DUMPMNTOPTS
condition|)
block|{
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|argp
argument_list|,
operator|&
name|dumpmntopts
argument_list|,
sizeof|sizeof
argument_list|(
name|dumpmntopts
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
operator|(
name|dumpmntopts
operator|.
name|ndmnt_blen
operator|<
literal|256
operator|||
name|dumpmntopts
operator|.
name|ndmnt_blen
operator|>
literal|1024
operator|)
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|nfsrv_lookupfilename
argument_list|(
operator|&
name|nd
argument_list|,
name|dumpmntopts
operator|.
name|ndmnt_fname
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|nd
operator|.
name|ni_vp
operator|->
name|v_mount
operator|->
name|mnt_vfc
operator|->
name|vfc_name
argument_list|,
literal|"nfs"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|vput
argument_list|(
name|nd
operator|.
name|ni_vp
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|buf
operator|=
name|malloc
argument_list|(
name|dumpmntopts
operator|.
name|ndmnt_blen
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|nfscl_retopts
argument_list|(
name|VFSTONFS
argument_list|(
name|nd
operator|.
name|ni_vp
operator|->
name|v_mount
argument_list|)
argument_list|,
name|buf
argument_list|,
name|dumpmntopts
operator|.
name|ndmnt_blen
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|nd
operator|.
name|ni_vp
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
name|buf
argument_list|,
name|dumpmntopts
operator|.
name|ndmnt_buf
argument_list|,
name|dumpmntopts
operator|.
name|ndmnt_blen
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function_decl
specifier|extern
name|int
function_decl|(
modifier|*
name|nfsd_call_nfscl
function_decl|)
parameter_list|(
name|struct
name|thread
modifier|*
parameter_list|,
name|struct
name|nfssvc_args
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Called once to initialize data structures...  */
end_comment

begin_function
specifier|static
name|int
name|nfscl_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|loaded
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MOD_LOAD
case|:
if|if
condition|(
name|loaded
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|newnfs_portinit
argument_list|()
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|ncl_iod_mutex
argument_list|,
literal|"ncl_iod_mutex"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|nfscl_init
argument_list|()
expr_stmt|;
name|NFSD_LOCK
argument_list|()
expr_stmt|;
name|nfsrvd_cbinit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|NFSD_UNLOCK
argument_list|()
expr_stmt|;
name|ncl_call_invalcaches
operator|=
name|ncl_invalcaches
expr_stmt|;
name|nfsd_call_nfscl
operator|=
name|nfssvc_nfscl
expr_stmt|;
name|loaded
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
if|if
condition|(
name|nfs_numnfscbd
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
comment|/* 		 * XXX: Unloading of nfscl module is unsupported. 		 */
if|#
directive|if
literal|0
block|ncl_call_invalcaches = NULL; 		nfsd_call_nfscl = NULL;
comment|/* and get rid of the mutexes */
block|mtx_destroy(&ncl_iod_mutex); 		loaded = 0; 		break;
else|#
directive|else
comment|/* FALLTHROUGH */
endif|#
directive|endif
default|default:
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
block|}
return|return
name|error
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|moduledata_t
name|nfscl_mod
init|=
block|{
literal|"nfscl"
block|,
name|nfscl_modevent
block|,
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|nfscl
argument_list|,
name|nfscl_mod
argument_list|,
name|SI_SUB_VFS
argument_list|,
name|SI_ORDER_FIRST
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* So that loader and kldload(2) can find us, wherever we are.. */
end_comment

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|nfscl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|nfscl
argument_list|,
name|nfscommon
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|nfscl
argument_list|,
name|krpc
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|nfscl
argument_list|,
name|nfssvc
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|nfscl
argument_list|,
name|nfslock
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

